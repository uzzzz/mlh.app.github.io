<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【比特币】自己动手制作山寨币 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【比特币】自己动手制作山寨币" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wuzh1230/article/details/40422535 Key: altcoin generate, make altcoin, bitcoin, coingen 关键字： 制作山寨币，山寨币，比特币 源代码地址： https://github.com/imharrywu/fastcoin 构建问题可以参考这个[BGOLD](https://github.com/bitbaba/bitgold)的travis.sh 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论&nbsp;161928517(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin git clone&nbsp;https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件&nbsp;chainparams.cpp /** * Build the genesis block. Note that the output of the genesis coinbase cannot * be spent as it did not originally exist in the database. * * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1) * CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0) * CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73) * CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B) * vMerkleTree: 4a5e1e */ // HarryWu, generate genesis block by genesis.py as following: // // localhost genesis # python genesis.py \ // -t $(date +%s) \ // -z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \ // -a SHA256 \ // -p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \ // -v 10000000000 // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 // algorithm: SHA256 // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc // time: 1411650667 // bits: 0x1d00ffff // Searching for genesis hash.. // // nonce: 1456993276 // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; CMutableTransaction txNew; txNew.vin.resize(1); txNew.vout.resize(1); txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); txNew.vout[0].nValue = nGenesisSubsidy * COIN; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; genesis.vtx.push_back(txNew); genesis.hashPrevBlock = 0; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); genesis.nVersion = 1; genesis.nTime = 1411666331; genesis.nBits = 0x1d00ffff; genesis.nNonce = 2056985438; hashGenesisBlock = genesis.GetHash(); assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); （3）修改网络协议魔数 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本 建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件&nbsp;chainparams.cpp base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); 有一个 wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 /** * Testnet (v3) */ class CTestNetParams : public CMainParams { public: CTestNetParams() { networkID = CBaseChainParams::TESTNET; strNetworkID = &quot;test&quot;; pchMessageStart[0] = 0xC0; pchMessageStart[1] = 0x1d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); nDefaultPort = 19999; /** * Regression test */ class CRegTestParams : public CTestNetParams { public: CRegTestParams() { networkID = CBaseChainParams::REGTEST; strNetworkID = &quot;regtest&quot;; pchMessageStart[0] = 0x0b; pchMessageStart[1] = 0xad; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; nDefaultPort = 29999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; （6）修改种子网络连接参数 源文件&nbsp;chainparams.cpp //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， // // ScanHash scans nonces looking for a hash with at least some zero bits. // The nonce is usually preserved between calls, but periodically or if the // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at // zero. // bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) { // Write the first 76 bytes of the block header to a double-SHA256 state. //CHash256 hasher; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); //ss &lt;&lt; *pblock; //assert(ss.size() == 80); //hasher.Write((unsigned char*)&amp;ss[0], 76); while (true) { nNonce++; // Write the last 4 bytes of the block header (the nonce) to a copy of // the double-SHA256 state, and compute the result. //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); *phash = pblock-&gt;ComputePowHash(nNonce); // Return the nonce if the hash has at least some zero bits, // caller will check if it has enough to reach the target if (((uint16_t*)phash)[15] == 0) return true; // If nothing found after trying for a while, return -1 if ((nNonce &amp; 0xffff) == 0) return false; if ((nNonce &amp; 0xfff) == 0) boost::this_thread::interruption_point(); } } 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) fMiningRequiresPeers = !true; // See BitcoinMiner() for details. 挖矿代码： void static BitcoinMiner(CWallet *pwallet) { LogPrintf(&quot;FastCoinMiner started\n&quot;); SetThreadPriority(THREAD_PRIORITY_LOWEST); RenameThread(&quot;fastcoin-miner&quot;); // Each thread has its own key and counter CReserveKey reservekey(pwallet); unsigned int nExtraNonce = 0; try { while (true) { if (Params().MiningRequiresPeers()) { // Busy-wait for the network to come online so we don&#39;t waste time mining // on an obsolete chain. In regtest mode we expect to fly solo. while (vNodes.empty()) MilliSleep(1000); } // // Create new block // unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); CBlockIndex* pindexPrev = chainActive.Tip(); auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); if (!pblocktemplate.get()) { LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n&quot;); return; } CBlock *pblock = &amp;pblocktemplate-&gt;block; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\n&quot;, pblock-&gt;vtx.size(), ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const { if (nVersion == 1 || nVersion == 2){ /** * Use SHA256+SHA256 to make PoW */ // Write the first 76 bytes of the block header to a double-SHA256 state. CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 3){ /** * Scrypt PoW */ CScryptHash256Pow hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 4){ /** * Scrypt+SHA256 PoW */ }else if (nVersion == 5){ /** * Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow */ CKeccak_256 hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else{ // Abort, unknown block version. assert(false); return ~(uint256)0; } } （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ static const int COINBASE_MATURITY = 14; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has multiple outputs. */ class TransactionRecord { public: enum Type { Other, Generated, SendToAddress, SendToOther, RecvWithAddress, RecvFromOther, SendToSelf }; /** Number of confirmation recommended for accepting a transaction */ static const int RecommendedNumConfirmations = 2; （9）修改难度配置 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; nSubsidyHalvingInterval = 210000; nEnforceBlockUpgradeMajority = 750; nRejectBlockOutdatedMajority = 950; nToCheckBlockUpgradeMajority = 1000; nMinerThreads = 1; // 0 for all available cpus. nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; // do new pow every 1 minutes. nGenesisSubsidy = 100; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) { CAmount nSubsidy = Params().GenesisSubsidy() * COIN; int halvings = nHeight / Params().SubsidyHalvingInterval(); // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return nFees; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy + nFees; }很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour, 60 blocksnTargetSpacing = 1 * 60; &nbsp;// expect 1 block/minute这里的设置是60分钟（3600秒, 因为预期60秒钟1个block，那么就是60个blocks计算新难度，否则使用上一个block的难度），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试&nbsp;P2pool&nbsp; &amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wuzh1230/article/details/40422535 Key: altcoin generate, make altcoin, bitcoin, coingen 关键字： 制作山寨币，山寨币，比特币 源代码地址： https://github.com/imharrywu/fastcoin 构建问题可以参考这个[BGOLD](https://github.com/bitbaba/bitgold)的travis.sh 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论&nbsp;161928517(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin git clone&nbsp;https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件&nbsp;chainparams.cpp /** * Build the genesis block. Note that the output of the genesis coinbase cannot * be spent as it did not originally exist in the database. * * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1) * CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0) * CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73) * CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B) * vMerkleTree: 4a5e1e */ // HarryWu, generate genesis block by genesis.py as following: // // localhost genesis # python genesis.py \ // -t $(date +%s) \ // -z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \ // -a SHA256 \ // -p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \ // -v 10000000000 // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 // algorithm: SHA256 // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc // time: 1411650667 // bits: 0x1d00ffff // Searching for genesis hash.. // // nonce: 1456993276 // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; CMutableTransaction txNew; txNew.vin.resize(1); txNew.vout.resize(1); txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); txNew.vout[0].nValue = nGenesisSubsidy * COIN; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; genesis.vtx.push_back(txNew); genesis.hashPrevBlock = 0; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); genesis.nVersion = 1; genesis.nTime = 1411666331; genesis.nBits = 0x1d00ffff; genesis.nNonce = 2056985438; hashGenesisBlock = genesis.GetHash(); assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); （3）修改网络协议魔数 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本 建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件&nbsp;chainparams.cpp base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); 有一个 wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 /** * Testnet (v3) */ class CTestNetParams : public CMainParams { public: CTestNetParams() { networkID = CBaseChainParams::TESTNET; strNetworkID = &quot;test&quot;; pchMessageStart[0] = 0xC0; pchMessageStart[1] = 0x1d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); nDefaultPort = 19999; /** * Regression test */ class CRegTestParams : public CTestNetParams { public: CRegTestParams() { networkID = CBaseChainParams::REGTEST; strNetworkID = &quot;regtest&quot;; pchMessageStart[0] = 0x0b; pchMessageStart[1] = 0xad; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; nDefaultPort = 29999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; （6）修改种子网络连接参数 源文件&nbsp;chainparams.cpp //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， // // ScanHash scans nonces looking for a hash with at least some zero bits. // The nonce is usually preserved between calls, but periodically or if the // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at // zero. // bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) { // Write the first 76 bytes of the block header to a double-SHA256 state. //CHash256 hasher; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); //ss &lt;&lt; *pblock; //assert(ss.size() == 80); //hasher.Write((unsigned char*)&amp;ss[0], 76); while (true) { nNonce++; // Write the last 4 bytes of the block header (the nonce) to a copy of // the double-SHA256 state, and compute the result. //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); *phash = pblock-&gt;ComputePowHash(nNonce); // Return the nonce if the hash has at least some zero bits, // caller will check if it has enough to reach the target if (((uint16_t*)phash)[15] == 0) return true; // If nothing found after trying for a while, return -1 if ((nNonce &amp; 0xffff) == 0) return false; if ((nNonce &amp; 0xfff) == 0) boost::this_thread::interruption_point(); } } 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) fMiningRequiresPeers = !true; // See BitcoinMiner() for details. 挖矿代码： void static BitcoinMiner(CWallet *pwallet) { LogPrintf(&quot;FastCoinMiner started\n&quot;); SetThreadPriority(THREAD_PRIORITY_LOWEST); RenameThread(&quot;fastcoin-miner&quot;); // Each thread has its own key and counter CReserveKey reservekey(pwallet); unsigned int nExtraNonce = 0; try { while (true) { if (Params().MiningRequiresPeers()) { // Busy-wait for the network to come online so we don&#39;t waste time mining // on an obsolete chain. In regtest mode we expect to fly solo. while (vNodes.empty()) MilliSleep(1000); } // // Create new block // unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); CBlockIndex* pindexPrev = chainActive.Tip(); auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); if (!pblocktemplate.get()) { LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n&quot;); return; } CBlock *pblock = &amp;pblocktemplate-&gt;block; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\n&quot;, pblock-&gt;vtx.size(), ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const { if (nVersion == 1 || nVersion == 2){ /** * Use SHA256+SHA256 to make PoW */ // Write the first 76 bytes of the block header to a double-SHA256 state. CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 3){ /** * Scrypt PoW */ CScryptHash256Pow hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 4){ /** * Scrypt+SHA256 PoW */ }else if (nVersion == 5){ /** * Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow */ CKeccak_256 hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else{ // Abort, unknown block version. assert(false); return ~(uint256)0; } } （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ static const int COINBASE_MATURITY = 14; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has multiple outputs. */ class TransactionRecord { public: enum Type { Other, Generated, SendToAddress, SendToOther, RecvWithAddress, RecvFromOther, SendToSelf }; /** Number of confirmation recommended for accepting a transaction */ static const int RecommendedNumConfirmations = 2; （9）修改难度配置 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; nSubsidyHalvingInterval = 210000; nEnforceBlockUpgradeMajority = 750; nRejectBlockOutdatedMajority = 950; nToCheckBlockUpgradeMajority = 1000; nMinerThreads = 1; // 0 for all available cpus. nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; // do new pow every 1 minutes. nGenesisSubsidy = 100; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) { CAmount nSubsidy = Params().GenesisSubsidy() * COIN; int halvings = nHeight / Params().SubsidyHalvingInterval(); // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return nFees; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy + nFees; }很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour, 60 blocksnTargetSpacing = 1 * 60; &nbsp;// expect 1 block/minute这里的设置是60分钟（3600秒, 因为预期60秒钟1个block，那么就是60个blocks计算新难度，否则使用上一个block的难度），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试&nbsp;P2pool&nbsp; &amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多" />
<link rel="canonical" href="https://mlh.app/2014/10/24/68d14f0e078993f6430aa18ad5836470.html" />
<meta property="og:url" content="https://mlh.app/2014/10/24/68d14f0e078993f6430aa18ad5836470.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-10-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wuzh1230/article/details/40422535 Key: altcoin generate, make altcoin, bitcoin, coingen 关键字： 制作山寨币，山寨币，比特币 源代码地址： https://github.com/imharrywu/fastcoin 构建问题可以参考这个[BGOLD](https://github.com/bitbaba/bitgold)的travis.sh 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论&nbsp;161928517(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin git clone&nbsp;https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件&nbsp;chainparams.cpp /** * Build the genesis block. Note that the output of the genesis coinbase cannot * be spent as it did not originally exist in the database. * * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1) * CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0) * CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73) * CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B) * vMerkleTree: 4a5e1e */ // HarryWu, generate genesis block by genesis.py as following: // // localhost genesis # python genesis.py \\ // -t $(date +%s) \\ // -z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \\ // -a SHA256 \\ // -p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \\ // -v 10000000000 // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 // algorithm: SHA256 // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc // time: 1411650667 // bits: 0x1d00ffff // Searching for genesis hash.. // // nonce: 1456993276 // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; CMutableTransaction txNew; txNew.vin.resize(1); txNew.vout.resize(1); txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); txNew.vout[0].nValue = nGenesisSubsidy * COIN; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; genesis.vtx.push_back(txNew); genesis.hashPrevBlock = 0; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); genesis.nVersion = 1; genesis.nTime = 1411666331; genesis.nBits = 0x1d00ffff; genesis.nNonce = 2056985438; hashGenesisBlock = genesis.GetHash(); assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); （3）修改网络协议魔数 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本 建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件&nbsp;chainparams.cpp base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); 有一个 wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 /** * Testnet (v3) */ class CTestNetParams : public CMainParams { public: CTestNetParams() { networkID = CBaseChainParams::TESTNET; strNetworkID = &quot;test&quot;; pchMessageStart[0] = 0xC0; pchMessageStart[1] = 0x1d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); nDefaultPort = 19999; /** * Regression test */ class CRegTestParams : public CTestNetParams { public: CRegTestParams() { networkID = CBaseChainParams::REGTEST; strNetworkID = &quot;regtest&quot;; pchMessageStart[0] = 0x0b; pchMessageStart[1] = 0xad; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; nDefaultPort = 29999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; （6）修改种子网络连接参数 源文件&nbsp;chainparams.cpp //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix base58Prefixes[SECRET_KEY] = list_of(45); // 7 prefix base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， // // ScanHash scans nonces looking for a hash with at least some zero bits. // The nonce is usually preserved between calls, but periodically or if the // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at // zero. // bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) { // Write the first 76 bytes of the block header to a double-SHA256 state. //CHash256 hasher; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); //ss &lt;&lt; *pblock; //assert(ss.size() == 80); //hasher.Write((unsigned char*)&amp;ss[0], 76); while (true) { nNonce++; // Write the last 4 bytes of the block header (the nonce) to a copy of // the double-SHA256 state, and compute the result. //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); *phash = pblock-&gt;ComputePowHash(nNonce); // Return the nonce if the hash has at least some zero bits, // caller will check if it has enough to reach the target if (((uint16_t*)phash)[15] == 0) return true; // If nothing found after trying for a while, return -1 if ((nNonce &amp; 0xffff) == 0) return false; if ((nNonce &amp; 0xfff) == 0) boost::this_thread::interruption_point(); } } 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) fMiningRequiresPeers = !true; // See BitcoinMiner() for details. 挖矿代码： void static BitcoinMiner(CWallet *pwallet) { LogPrintf(&quot;FastCoinMiner started\\n&quot;); SetThreadPriority(THREAD_PRIORITY_LOWEST); RenameThread(&quot;fastcoin-miner&quot;); // Each thread has its own key and counter CReserveKey reservekey(pwallet); unsigned int nExtraNonce = 0; try { while (true) { if (Params().MiningRequiresPeers()) { // Busy-wait for the network to come online so we don&#39;t waste time mining // on an obsolete chain. In regtest mode we expect to fly solo. while (vNodes.empty()) MilliSleep(1000); } // // Create new block // unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); CBlockIndex* pindexPrev = chainActive.Tip(); auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); if (!pblocktemplate.get()) { LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n&quot;); return; } CBlock *pblock = &amp;pblocktemplate-&gt;block; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\\n&quot;, pblock-&gt;vtx.size(), ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const { if (nVersion == 1 || nVersion == 2){ /** * Use SHA256+SHA256 to make PoW */ // Write the first 76 bytes of the block header to a double-SHA256 state. CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 3){ /** * Scrypt PoW */ CScryptHash256Pow hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else if (nVersion == 4){ /** * Scrypt+SHA256 PoW */ }else if (nVersion == 5){ /** * Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow */ CKeccak_256 hasher; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss &lt;&lt; *this; assert(ss.size() == 80); hasher.Write((unsigned char*)&amp;ss[0], 76); uint256 powHash; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); return powHash; }else{ // Abort, unknown block version. assert(false); return ~(uint256)0; } } （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ static const int COINBASE_MATURITY = 14; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has multiple outputs. */ class TransactionRecord { public: enum Type { Other, Generated, SendToAddress, SendToOther, RecvWithAddress, RecvFromOther, SendToSelf }; /** Number of confirmation recommended for accepting a transaction */ static const int RecommendedNumConfirmations = 2; （9）修改难度配置 源文件&nbsp;chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { networkID = CBaseChainParams::MAIN; strNetworkID = &quot;main&quot;; /** * The message start string is designed to be unlikely to occur in normal data. * The characters are rarely used upper ASCII, not valid as UTF-8, and produce * a large 4-byte int at any alignment. */ pchMessageStart[0] = 0x90; pchMessageStart[1] = 0x0d; pchMessageStart[2] = 0xf0; pchMessageStart[3] = 0x0d; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); nDefaultPort = 9999; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; nSubsidyHalvingInterval = 210000; nEnforceBlockUpgradeMajority = 750; nRejectBlockOutdatedMajority = 950; nToCheckBlockUpgradeMajority = 1000; nMinerThreads = 1; // 0 for all available cpus. nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; // do new pow every 1 minutes. nGenesisSubsidy = 100; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) { CAmount nSubsidy = Params().GenesisSubsidy() * COIN; int halvings = nHeight / Params().SubsidyHalvingInterval(); // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return nFees; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy + nFees; }很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour, 60 blocksnTargetSpacing = 1 * 60; &nbsp;// expect 1 block/minute这里的设置是60分钟（3600秒, 因为预期60秒钟1个block，那么就是60个blocks计算新难度，否则使用上一个block的难度），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试&nbsp;P2pool&nbsp; &amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2014/10/24/68d14f0e078993f6430aa18ad5836470.html","headline":"【比特币】自己动手制作山寨币","dateModified":"2014-10-24T00:00:00+08:00","datePublished":"2014-10-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2014/10/24/68d14f0e078993f6430aa18ad5836470.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【比特币】自己动手制作山寨币</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wuzh1230/article/details/40422535 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css"> 
 <div class="htmledit_views"> 
  <p>Key:</p>
  <p>altcoin generate, make altcoin, bitcoin, coingen</p>
  <p>关键字：</p>
  <p>制作山寨币，山寨币，比特币</p>
  <p><br></p>
  <p>源代码地址：</p>
  <p><a href="https://github.com/imharrywu/fastcoin" rel="nofollow">https://github.com/imharrywu/fastcoin</a></p>
  <p>构建问题可以参考这个[<a href="https://github.com/bitbaba/bitgold" rel="nofollow">BGOLD</a>](<a href="https://github.com/bitbaba/bitgold" rel="nofollow">https://github.com/bitbaba/bitgold</a>)的travis.sh</p>
  <p>程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论<strong><span style="font-family:'微软雅黑', Tahoma, '宋体';line-height:29px;">&nbsp;</span><span class="group_number" style="font-size:14px;vertical-align:top;font-family:'微软雅黑', Tahoma, '宋体';line-height:29px;">161928517(注明：csdn</span><span class="group_number" style="font-size:14px;vertical-align:top;font-family:'微软雅黑', Tahoma, '宋体';line-height:29px;">)</span></strong>，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。</p>
  <p><br></p>
  <p>可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。</p>
  <p><br></p>
  <p>目前预先内置了<strong>比特币的SHA256</strong>和<strong>莱特币的scypt，以及SHA3-256(KECCAK)</strong>。</p>
  <p><br></p>
  <p>在线编译目前提供三种安装包：</p>
  <p>1，linux/unix的daemon程序（带钱包功能）</p>
  <p>2，Mac钱包安装包&nbsp;</p>
  <p>3，windows钱包安装包</p>
  <p><br></p>
  <p></p>
  <h1>1、 &nbsp;截图预览</h1>
  <h2>(1) 安装图1</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031093947904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（2）安装图2</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094003832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（3）安装图3</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094007732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（4）安装图4</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094105109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（5）安装图5</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094015797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <p><br></p>
  <h2>（6）概览图 已经挖到3个block 奖励了300个FTC</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094019276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（7）交易记录图</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094024080?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（8）点击显示交易细节 显示为挖矿所得 并且还没有确认</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094027996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（9）版权页</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094032583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <h2>（10）调试窗口</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094129828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <p><br></p>
  <h2>（11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094038916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <p><br></p>
  <h2>（12）2个节点构成的p2p通信网络</h2>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20141031094136125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p>
  <p><br></p>
  <h1>2、 山寨币修改步骤：</h1>
  <h2>（1）迁出最新的比特币源代码</h2>
  <p>比特币官方代码: <a href="https://github.com/bitcoin/bitcoin" rel="nofollow">https://github.com/bitcoin/bitcoin</a></p>
  <p>山寨币代码地址（紧跟bitcoin更新）:<a href="https://github.com/imharrywu/fastcoin" rel="nofollow">https://github.com/imharrywu/fastcoin</a></p>
  <p>git clone&nbsp;<a href="https://github.com/imharrywu/fastcoin" rel="nofollow">https://github.com/imharrywu/fastcoin</a>&nbsp;</p>
  <p><br></p>
  <p>一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。</p>
  <p><br></p>
  <h2>（2）修改创世块</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong></p>
  <p></p>
  <pre><code class="language-cpp">        /**
         * Build the genesis block. Note that the output of the genesis coinbase cannot
         * be spent as it did not originally exist in the database.
         * 
         * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)
         *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)
         *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)
         *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)
         *   vMerkleTree: 4a5e1e
         */

        // HarryWu, generate genesis block by genesis.py as following:
        //
        // localhost genesis # python genesis.py \
        //                            -t $(date +%s) \
        //                            -z "shanghai stock index closed at 2343.57, on 24th Sept., 2014" \
        //                            -a SHA256 \
        //                            -p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \
        //                            -v 10000000000
        // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134
        // algorithm: SHA256
        // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b
        // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014
        // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc
        // time: 1411650667
        // bits: 0x1d00ffff
        // Searching for genesis hash..
        //
        // nonce: 1456993276
        // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5

        const char* pszTimestamp = "shanghai stock index closed at 2343.57, on 24th Sept., 2014";
        CMutableTransaction txNew;
        txNew.vin.resize(1);
        txNew.vout.resize(1);
        txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
        txNew.vout[0].nValue = nGenesisSubsidy * COIN;
        txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex("049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc") &lt;&lt; OP_CHECKSIG;
        genesis.vtx.push_back(txNew);
        genesis.hashPrevBlock = 0;
        genesis.hashMerkleRoot = genesis.BuildMerkleTree();
        genesis.nVersion = 1;
        genesis.nTime    = 1411666331;
        genesis.nBits    = 0x1d00ffff;
        genesis.nNonce   = 2056985438;

        hashGenesisBlock = genesis.GetHash();
        assert(hashGenesisBlock == uint256("0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942"));
        assert(genesis.hashMerkleRoot == uint256("0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb"));
</code></pre>
  <br>
  <br>
  <p></p>
  <h2>（3）修改网络协议魔数</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong><br></p>
  <p></p>
  <pre><code class="language-cpp">class CMainParams : public CChainParams {
public:
    CMainParams() {
        networkID = CBaseChainParams::MAIN;
        strNetworkID = "main";
        /** 
         * The message start string is designed to be unlikely to occur in normal data.
         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce
         * a large 4-byte int at any alignment.
         */
        pchMessageStart[0] = 0x90;
        pchMessageStart[1] = 0x0d;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0x0d;</code></pre>
  <br>0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本
  <strong>建议</strong>，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。
  <p></p>
  <p>另外：对应的修改TESTNET和REGTESTNET的参数</p>
  <p><br></p>
  <h2>（4）修改地址前缀</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong><br></p>
  <p></p>
  <pre><code class="language-cpp">        base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix
        base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix
        base58Prefixes[SECRET_KEY] =     list_of(45); // 7 prefix
        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35);
        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45);</code></pre>
  <br>有一个
  <a href="https://en.bitcoin.it/wiki/List_of_address_prefixes" rel="nofollow">wiki</a>的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。
  <p></p>
  <p><br></p>
  <h2>（5）修改网络端口</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong><br></p>
  <p></p>
  <pre><code class="language-cpp">class CMainParams : public CChainParams {
public:
    CMainParams() {
        networkID = CBaseChainParams::MAIN;
        strNetworkID = "main";
        /** 
         * The message start string is designed to be unlikely to occur in normal data.
         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce
         * a large 4-byte int at any alignment.
         */
        pchMessageStart[0] = 0x90;
        pchMessageStart[1] = 0x0d;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0x0d;
        vAlertPubKey = ParseHex("04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85");
        nDefaultPort = 9999;
        bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32;</code></pre>
  <br>修改了nDefaultPort=9999，比特币默认是8333
  <p></p>
  <p>另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可</p>
  <p></p>
  <pre><code class="language-cpp">/**
 * Testnet (v3)
 */
class CTestNetParams : public CMainParams {
public:
    CTestNetParams() {
        networkID = CBaseChainParams::TESTNET;
        strNetworkID = "test";
        pchMessageStart[0] = 0xC0;
        pchMessageStart[1] = 0x1d;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0x0d;
        vAlertPubKey = ParseHex("045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c");
        nDefaultPort = 19999;</code></pre>
  <br>
  <pre><code class="language-cpp">/**
 * Regression test
 */
class CRegTestParams : public CTestNetParams {
public:
    CRegTestParams() {
        networkID = CBaseChainParams::REGTEST;
        strNetworkID = "regtest";
        pchMessageStart[0] = 0x0b;
        pchMessageStart[1] = 0xad;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0x0d;
        nDefaultPort = 29999;
        bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1;</code></pre>
  <br>
  <br>
  <p></p>
  <h2>（6）修改种子网络连接参数</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong><br></p>
  <p></p>
  <pre><code class="language-cpp">        //vSeeds.push_back(CDNSSeedData("bitcoin.sipa.be", "seed.bitcoin.sipa.be"));
        //vSeeds.push_back(CDNSSeedData("bluematt.me", "dnsseed.bluematt.me"));
        //vSeeds.push_back(CDNSSeedData("dashjr.org", "dnsseed.bitcoin.dashjr.org"));
        //vSeeds.push_back(CDNSSeedData("bitcoinstats.com", "seed.bitcoinstats.com"));
        //vSeeds.push_back(CDNSSeedData("bitnodes.io", "seed.bitnodes.io"));
        //vSeeds.push_back(CDNSSeedData("xf2.org", "bitseed.xf2.org"));

        base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix
        base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix
        base58Prefixes[SECRET_KEY] =     list_of(45); // 7 prefix
        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35);
        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45);

        //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main));</code></pre>
  <p></p>
  <p><br></p>如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。
  <p>如果没有的话，可以考虑和我一样<strong>暂时注释掉</strong>，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com</p>
  <p>对应的修改一下TESTNET和REGTESTNET的网络节点地址。<br><br></p>
  <h2>（7）修改工作量机制</h2>
  <p>源文件 miner.cpp</p>
  <p>比特币在函数ScanHash（）里面搜索随机数，</p>
  <p></p>
  <pre><code class="language-cpp">//
// ScanHash scans nonces looking for a hash with at least some zero bits.
// The nonce is usually preserved between calls, but periodically or if the
// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at
// zero.
//
bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash)
{
    // Write the first 76 bytes of the block header to a double-SHA256 state.
    //CHash256 hasher;
    //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
    //ss &lt;&lt; *pblock;
    //assert(ss.size() == 80);
    //hasher.Write((unsigned char*)&amp;ss[0], 76);

    while (true) {
        nNonce++;

        // Write the last 4 bytes of the block header (the nonce) to a copy of
        // the double-SHA256 state, and compute the result.
        //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash);

        *phash = pblock-&gt;ComputePowHash(nNonce);

        // Return the nonce if the hash has at least some zero bits,
        // caller will check if it has enough to reach the target
        if (((uint16_t*)phash)[15] == 0)
            return true;

        // If nothing found after trying for a while, return -1
        if ((nNonce &amp; 0xffff) == 0)
            return false;
        if ((nNonce &amp; 0xfff) == 0)
            boost::this_thread::interruption_point();
    }
}</code></pre>
  <br>
  <br>
  <p></p>
  <p>在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。</p>
  <p>另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。</p>
  <p>注意：设置独立挖矿的条件(chainparams.cpp里面设置)</p>
  <p></p>
  <pre><code class="language-cpp">        fMiningRequiresPeers = !true; // See BitcoinMiner() for details.</code></pre>
  <br>挖矿代码：
  <p></p>
  <p></p>
  <pre><code class="language-cpp">void static BitcoinMiner(CWallet *pwallet)
{
    LogPrintf("FastCoinMiner started\n");
    SetThreadPriority(THREAD_PRIORITY_LOWEST);
    RenameThread("fastcoin-miner");

    // Each thread has its own key and counter
    CReserveKey reservekey(pwallet);
    unsigned int nExtraNonce = 0;

    try {
        while (true) {
            if (Params().MiningRequiresPeers()) {
                // Busy-wait for the network to come online so we don't waste time mining
                // on an obsolete chain. In regtest mode we expect to fly solo.
                while (vNodes.empty())
                    MilliSleep(1000);
            }

            //
            // Create new block
            //
            unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();
            CBlockIndex* pindexPrev = chainActive.Tip();

            auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey));
            if (!pblocktemplate.get())
            {
                LogPrintf("Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n");
                return;
            }
            CBlock *pblock = &amp;pblocktemplate-&gt;block;
            IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);

            LogPrintf("Running FastCoinMiner with %u transactions in block (%u bytes)\n", pblock-&gt;vtx.size(),
                ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));</code></pre>
  <br>博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。
  <p></p>
  <p>看代码吧：</p>
  <p></p>
  <pre><code class="language-cpp">uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const
{
    if (nVersion == 1 || nVersion == 2){
        /**
         * Use SHA256+SHA256 to make PoW
         */
        // Write the first 76 bytes of the block header to a double-SHA256 state.
        CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss &lt;&lt; *this;
        assert(ss.size() == 80);
        hasher.Write((unsigned char*)&amp;ss[0], 76);
        uint256 powHash;
        CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash);
        return powHash;
    }else if (nVersion == 3){
        /**
         * Scrypt PoW
         */
        CScryptHash256Pow hasher;
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss &lt;&lt; *this;
        assert(ss.size() == 80);
        hasher.Write((unsigned char*)&amp;ss[0], 76);
        uint256 powHash;
        CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash);
        return powHash;
    }else if (nVersion == 4){
        /**
         *  Scrypt+SHA256 PoW
         */
    }else if (nVersion == 5){
    	/**
    	 * Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow
    	 */
    	CKeccak_256 hasher;
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss &lt;&lt; *this;
        assert(ss.size() == 80);
        hasher.Write((unsigned char*)&amp;ss[0], 76);
        uint256 powHash;
        CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash);
        return powHash;
    }else{
        // Abort, unknown block version.
        assert(false);
        return ~(uint256)0;
    }
}</code></pre>
  <br>
  <br>
  <p></p>
  <h2>（8）修改奖励机制</h2>
  <p>参考9.3</p>
  <h3>8.1) 修改挖矿奖励的成熟时间</h3>
  <p>源代码：<strong>main.h</strong></p>
  <p></p>
  <pre><code class="language-cpp">/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */
static const int COINBASE_MATURITY = 14;</code></pre>
  <p></p>
  <p><br></p>
  <h3>8.2) 修改交易确认块数推荐值</h3>
  <p>源代码 <strong>qt/transactionrecord.h</strong></p>
  <p></p>
  <pre><code class="language-cpp">/** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has
    multiple outputs.
 */
class TransactionRecord
{
public:
    enum Type
    {
        Other,
        Generated,
        SendToAddress,
        SendToOther,
        RecvWithAddress,
        RecvFromOther,
        SendToSelf
    };

    /** Number of confirmation recommended for accepting a transaction */
    static const int RecommendedNumConfirmations = 2;
</code></pre>
  <p></p>
  <p><br></p>
  <h2>（9）修改难度配置</h2>
  <p>源文件<strong>&nbsp;chainparams.cpp</strong><br></p>
  <p></p>
  <pre><code class="language-cpp">class CMainParams : public CChainParams {
public:
    CMainParams() {
        networkID = CBaseChainParams::MAIN;
        strNetworkID = "main";
        /** 
         * The message start string is designed to be unlikely to occur in normal data.
         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce
         * a large 4-byte int at any alignment.
         */
        pchMessageStart[0] = 0x90;
        pchMessageStart[1] = 0x0d;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0x0d;
        vAlertPubKey = ParseHex("04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85");
        nDefaultPort = 9999;
        bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32;
        nSubsidyHalvingInterval = 210000;
        nEnforceBlockUpgradeMajority = 750;
        nRejectBlockOutdatedMajority = 950;
        nToCheckBlockUpgradeMajority = 1000;
        nMinerThreads = 1; // 0 for all available cpus.
        nTargetTimespan = 60 * 60; // re-targeting every one hour
        nTargetSpacing = 1 * 60;  // do new pow every 1 minutes.
        nGenesisSubsidy = 100;</code></pre>
  <p></p>
  <p><br></p>
  <h3>a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32;</h3>
  <p>是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。</p>
  <p><br></p>
  <h3>b) nGenesisSubsidy = 100;</h3>
  <p>初始津贴，比特币的第一个块的奖励是50个btc。</p>
  <p><br></p>
  <h3>c) nSubsidyHavlingInterval = 210000;&nbsp;</h3>
  <p>这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。<br>上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节</p>
  <p></p>
  <pre><code class="language-cpp">CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees)
{
    CAmount nSubsidy = Params().GenesisSubsidy() * COIN;

    int halvings = nHeight / Params().SubsidyHalvingInterval();

    // Force block reward to zero when right shift is undefined.
    if (halvings &gt;= 64)
        return nFees;

    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.
    nSubsidy &gt;&gt;= halvings;

    return nSubsidy + nFees;
}</code></pre>很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。
  <p></p>
  <p>另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。</p>
  <h3>d）难度调节周期</h3>
  <p>nTargetTimespan = 60 * 60; // re-targeting every one hour, 60 blocks<br>nTargetSpacing = 1 * 60; &nbsp;// expect 1 block/minute<br>这里的设置是60分钟（3600秒, 因为预期60秒钟1个block，那么就是60个blocks计算新难度，否则使用上一个block的难度），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。</p>
  <p>。</p>
  <p>比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016</p>
  <p>参考：<a href="http://bitcoindifficulty.com/blog/" rel="nofollow">http://bitcoindifficulty.com/blog/</a></p>
  <p><a href="https://en.bitcoin.it/wiki/Difficulty" rel="nofollow">https://en.bitcoin.it/wiki/Difficulty</a><br><br></p>
  <h2>(10) 修改checkpoints检查</h2>
  <p><br></p>
  <h2>(11) 修改界面</h2>
  <p><br></p>
  <p><a href="https://github.com/imharrywu/anycoin" rel="nofollow">github地址</a></p>
  <p><br></p>
  <p>TODO:</p>
  <p>1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。</p>
  <p>2）矿池搭建与节点测试&nbsp;<a href="http://p2pool.org/" rel="nofollow">P2pool</a>&nbsp; &amp;<a href="https://en.bitcoin.it/wiki/Poclbm" rel="nofollow">Poclbm</a></p>
  <p>3）移动支付和网页支付</p>
  <p>4）应用生态</p>
  <p>5）交易备注</p>
  <p>6）复杂交易应用(脚本，非标准交易）</p>
  <p><br></p>
  <p>备注：</p>
  <p>1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...”</p>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/40422535,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/40422535,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
