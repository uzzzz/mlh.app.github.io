<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【比特币】椭圆曲线数字签名算法-ECDSA | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【比特币】椭圆曲线数字签名算法-ECDSA" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="参考： https://github.com/openssl/openssl/blob/master/crypto/ecdsa/ecdsa.h 原理篇： http://kakaroto.homelinux.net/2012/01/how-the-ecdsa-algorithm-works/ 实验篇： http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html Makefile .PHONY:all all: gcc -I/d/workspace/github/altcoin/bitcoin-3rd/ssl/include -o sigvery -g -O0 sigvery.c -L/d/workspace/github/altcoin/bitcoin-3rd/ssl/lib -lssl -lcrypto -lgdi32 Code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;openssl/opensslconf.h&gt; #include &lt;openssl/ec.h&gt; #include &lt;openssl/bn.h&gt; #include &lt;openssl/ecdsa.h&gt; int main(int argc, char * argv []){ &nbsp; &nbsp; // First step: create a EC_KEY object (note: this part is not ECDSA specific) &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;ret; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;nid; &nbsp; &nbsp; ECDSA_SIG *sig; &nbsp; &nbsp; EC_KEY &nbsp; &nbsp;*eckey; &nbsp; &nbsp; unsigned char digest [20]; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; memset(digest, 0xaa, sizeof(digest));// 测试用的假HASH &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; nid = OBJ_sn2nid(&quot;secp256k1&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; eckey = EC_KEY_new_by_curve_name(nid); &nbsp; &nbsp; if (eckey == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;EC_KEY_new_by_curve_name&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (!EC_KEY_generate_key(eckey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下ec的私钥和公钥 &nbsp; &nbsp; &nbsp; &nbsp; EC_KEY_print_fp(stdout, eckey, 0); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; // Second step: compute the ECDSA signature of a SHA-1 hash value using ECDSA_do_sign &nbsp; &nbsp; sig = ECDSA_do_sign(digest, 20, eckey);// 签名 &nbsp; &nbsp; if (sig == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_sign&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下签名，r和s &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Signature:\n\tr=%s\n\ts=%s\n&quot;, BN_bn2hex(sig-&gt;r), BN_bn2hex(sig-&gt;s)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Third step: verify the created ECDSA signature using ECDSA_do_verify &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ECDSA_do_verify(digest, 20, sig, eckey);// 验证 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (ret == -1) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_verify&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else if (ret == 0) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* incorrect signature */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified Failure\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; /* ret == 1 */ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* signature ok */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified OK\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; return 0; } 测试： HASH=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; // 20个字节的0xaa $ ./sigvery.exe Private-Key: (256 bit) priv: 00:95:55:33:26:d8:92:cd:58:d7:7b:71:b8:02:29: 36:41:9a:22:e9:f0:21:72:02:a7:fc:1e:05:a3:f5: 6e:f4:ec pub: 04:76:91:81:fd:2e:44:e0:17:03:b3:53:7d:55:fe: e2:f5:6a:89:d1:5b:2c:e2:06:83:6a:e5:64:b6:4b: 07:76:8c:8b:df:57:7b:75:7b:f6:fb:9c:44:6f:1b: f6:56:ff:ac:ed:2f:65:a9:49:81:ba:af:90:13:8f: 96:a3:9e:83:9f Field Type: prime-field Prime: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff: ff:fc:2f A: 0 B: 7 (0x7) Generator (uncompressed): 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87: 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16: f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc: 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0: 8f:fb:10:d4:b8 Order: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0: 36:41:41 Cofactor: 1 (0x1) Signature: r=F0AB42A05A1C7CB18EF50A0E63CF287B3604A3741D6875DADE9031E648055E7D s=4C556EDC930313C67286A7B7AD7BC336FB39C0BA4BC42BE801FBBE8CBDCD0012 Verified OK 比特币目前使用ECDSA对货币的所有权进行鉴定，当然前提是对于付款地址是椭圆曲线算法的公钥(secp256k1 for bitcoin)。 如果是puzzle类型等非标准的付款方式，那么resolve的方式就不是签名/验证的形式了，那就要看脚本的设置到底需要什么的推理前提了。 关于签名算法的细节可以参考wiki上bob&amp;alice的签名验证例子。 比特币的源代码使用CECKey结构对openssl的ec算法进行了封装。 在此基础上衍生了其他密钥管理对象，CPubKey, CKeyID, CScriptID, CPrivKey, CKey 1) CKey 对openssl中的ecdsa算法的基本封装，是整个算法的核心。 CKey可以导入通过SetPrivKey()/GetPrivKey()导入/导出openssl格式的私钥。 // Initialize from a CPrivKey (serialized OpenSSL private key data). bool SetPrivKey(const CPrivKey &amp;vchPrivKey, bool fCompressed); // Convert the private key to a CPrivKey (serialized OpenSSL private key data). // This is expensive. CPrivKey GetPrivKey() const; CKey可以通过GetPubKey()导出公钥（压缩格式或者非压缩格式的，根据内部标记来决定） // Compute the public key from a private key. // This is expensive. CPubKey GetPubKey() const; CKey可以通过Sign()来签署消息摘要 // Create a DER-serialized signature. bool Sign(const uint256 &amp;hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; 2) CPubKey 对openssl中的ecdsa算法的公钥的基本封装，可以由CKey的成员函数计算得到。 CPubKey可以通过GetID()调用来计算得到该公钥对应的索引（也就是该公钥的hash256/ripemd160的hash） // Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch+size())); } CPubKey可以通过Verify()来验证CKey的签名 // Verify a DER signature (~72 bytes). // If this public key is not fully valid, the return value will be false. bool Verify(const uint256 &amp;hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 3）CScript 对支付脚本的状态机的封装 CScript可以通过GetID()来获取序列化的脚本的索引（hash值） CScriptID GetID() const { return CScriptID(Hash160(*this)); } 4）CScriptID&nbsp; 支付脚本script的索引的封装,20字节hash值 5) &nbsp;CPubKeyID 支付公钥的索引的封装,&nbsp;20字节hash值 6）CBitcoinAddress 版本和索引值的封装 可以以base58格式操作2类钱包地址； 地址可以是脚本，也可以是公钥，对应的分别是脚本的id和公钥的id，CSriptID, CPubKeyID 7) CBitCoinSecret 对私钥base58格式的封装 可以以base58格式操作私钥。 openssl ecdsa算法实践 1) 列举所有已经实现的算法曲线 gentoobox harrywu # openssl ecparam -list_curves secp112r1 : SECG/WTLS curve over a 112 bit prime field secp112r2 : SECG curve over a 112 bit prime field secp128r1 : SECG curve over a 128 bit prime field secp128r2 : SECG curve over a 128 bit prime field secp160k1 : SECG curve over a 160 bit prime field secp160r1 : SECG curve over a 160 bit prime field secp160r2 : SECG/WTLS curve over a 160 bit prime field secp192k1 : SECG curve over a 192 bit prime field secp224k1 : SECG curve over a 224 bit prime field secp224r1 : NIST/SECG curve over a 224 bit prime field secp256k1 : SECG curve over a 256 bit prime field secp384r1 : NIST/SECG curve over a 384 bit prime field secp521r1 : NIST/SECG curve over a 521 bit prime field prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field prime192v2: X9.62 curve over a 192 bit prime field prime192v3: X9.62 curve over a 192 bit prime field prime239v1: X9.62 curve over a 239 bit prime field prime239v2: X9.62 curve over a 239 bit prime field prime239v3: X9.62 curve over a 239 bit prime field prime256v1: X9.62/SECG curve over a 256 bit prime field sect113r1 : SECG curve over a 113 bit binary field sect113r2 : SECG curve over a 113 bit binary field sect131r1 : SECG/WTLS curve over a 131 bit binary field sect131r2 : SECG curve over a 131 bit binary field sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field sect163r1 : SECG curve over a 163 bit binary field sect163r2 : NIST/SECG curve over a 163 bit binary field sect193r1 : SECG curve over a 193 bit binary field sect193r2 : SECG curve over a 193 bit binary field sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field sect239k1 : SECG curve over a 239 bit binary field sect283k1 : NIST/SECG curve over a 283 bit binary field sect283r1 : NIST/SECG curve over a 283 bit binary field sect409k1 : NIST/SECG curve over a 409 bit binary field sect409r1 : NIST/SECG curve over a 409 bit binary field sect571k1 : NIST/SECG curve over a 571 bit binary field sect571r1 : NIST/SECG curve over a 571 bit binary field c2pnb163v1: X9.62 curve over a 163 bit binary field c2pnb163v2: X9.62 curve over a 163 bit binary field c2pnb163v3: X9.62 curve over a 163 bit binary field c2pnb176v1: X9.62 curve over a 176 bit binary field c2tnb191v1: X9.62 curve over a 191 bit binary field c2tnb191v2: X9.62 curve over a 191 bit binary field c2tnb191v3: X9.62 curve over a 191 bit binary field c2pnb208w1: X9.62 curve over a 208 bit binary field c2tnb239v1: X9.62 curve over a 239 bit binary field c2tnb239v2: X9.62 curve over a 239 bit binary field c2tnb239v3: X9.62 curve over a 239 bit binary field c2pnb272w1: X9.62 curve over a 272 bit binary field c2pnb304w1: X9.62 curve over a 304 bit binary field c2tnb359v1: X9.62 curve over a 359 bit binary field c2pnb368w1: X9.62 curve over a 368 bit binary field c2tnb431r1: X9.62 curve over a 431 bit binary field wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls12: WTLS curvs over a 224 bit prime field Oakley-EC2N-3: IPSec/IKE/Oakley curve #3 over a 155 bit binary field. Not suitable for ECDSA. Questionable extension field! Oakley-EC2N-4: IPSec/IKE/Oakley curve #4 over a 185 bit binary field. Not suitable for ECDSA. Questionable extension field! 比特币选取了 secp256k1 : SECG curve over a 256 bit prime field 以下内容转载自原理篇 To popular demand, I have decided to try and explain how the&nbsp;ECDSA&nbsp;algorithm works. I’ve been struggling a bit to understand it properly and while I found a lot of documentation about it, I haven’t really found any “ECDSA for newbies” anywhere. So I thought it would be good to explain in simple terms how it works so others can learn from my research. I have found some websites that explain the basic principles but nowhere near enough to actually understand it, others that explains things without any basics, making it incomprehensible, and others that go way too deep into the the mathematics behind it. ECDSA stands for “Elliptic Curve Digital Signature Algorithm”, it’s used to create a&nbsp;digital signatureof data (a file for example) in order to allow you to verify its authenticity without compromising its security. Think of it like a real signature, you can recognize someone’s signature, but you can’t forge it without others knowing. The ECDSA algorithm is basically all about mathematics.. so I think it’s important to start by saying : “hey kids, don’t slack off at school, listen to your teachers, that stuff might be useful for you some day!”&nbsp;&nbsp;But these maths are fairly complicated, so while I’ll try to vulgarize it and make it understandable for non technical people, you will still probably need some knowledge in mathematics to understand it properly. I will do this in two parts, one that is a sort of high level explanation about how it works, and another where I dig deeper into its inner workings to complete your understanding. Note however that I’ve just recently learned this stuff, so I’m definitely not an expert on the matter. So the principle is simple, you have a mathematical equation which draws a curve on a graph, and you choose a random point on that curve and consider that your point of origin. Then you generate a random number, this is your private key, you do some magical mathematical equation using that random number and that “point of origin” and you get a second point on the curve, that’s your public key. When you want to sign a file, you will use this private key (the random number) with a hash of the file (a unique number to represent the file) into a magical equation and that will give you your signature. The signature itself is divided into two parts, called&nbsp;R&nbsp;and&nbsp;S. In order to verify that the signature is correct, you only need the public key (that point on the curve that was generated using the private key) and you put that into another magical equation with one part of the signature (S), and if it was signed correctly using the the private key, it will give you the other part of the signature (R). So to make it short, a signature consists of two numbers,&nbsp;R&nbsp;and&nbsp;S, and you use a private key to generate&nbsp;R&nbsp;and&nbsp;S, and if a mathematical equation using the public key and&nbsp;Sgives you&nbsp;R, then the signature is valid. There is no way to know the private key or to create a signature using only the public key. Alright, now for the more in depth understanding, I suggest you take an aspirin right now as this might hurt!&nbsp; Let’s start with the basics (which may be boring for people who know about it, but is mandatory for those who don’t) : ECDSA uses only integer mathematics, there are no floating points (this means possible values are 1, 2, 3, etc.. but not 1.5..), &nbsp;also, the range of the numbers is bound by how many bits are used in the signature (more bits means higher numbers, means more security as it becomes harder to ‘guess’ the critical numbers used in the equation), as you should know, computers use ‘bits’ to represent data, a bit is a ‘digit’ in binary notation (0 and 1) and 8 bits represent one byte. Every time you add one bit, the maximum number that can be represented doubles, with 4 bits you can represent values 0 to 15 (for a total of 16 possible values), with 5 bits, you can represent 32 values, with 6 bits, you can represent 64 values, etc.. one byte (8 bits) can represent 256 values, and 32 bits can represent 4294967296 values (4 Giga).. Usually ECDSA will use 160 bits total, so that makes… well, a very huge number with 49 digits in it… ECDSA&nbsp;is used with a&nbsp;SHA1&nbsp;cryptographic hash&nbsp;of the message to sign (the file). A&nbsp;hash&nbsp;is simply another mathematical equation that you apply on every byte of data which will give you a number that is unique to your data. Like for example, the sum of the values of all bytes may be considered a very dumb hash function. So if anything changes in the message (the file) then the hash will be completely different. In the case of the SHA1 hash algorithm, it will always be 20 bytes (160 bits). It’s very useful to validate that a file has not been modified or corrupted, you get the 20 bytes hash for a file of any size, and you can easily recalculate that hash to make sure it matches. What ECDSA signs is actually that hash, so if the data changes, the hash changes, and the signature isn’t valid anymore. Now, how does it work? Well&nbsp;Elliptic Curve cryptography&nbsp;is based on an equation of the form : y^2 = (x^3 + a * x + b) mod p First thing you notice is that there is a modulo and that the ‘y‘ is a square. This means that for anyx&nbsp;coordinate, you will have two values of&nbsp;y&nbsp;and that the curve is symmetric on the&nbsp;X axis. The modulo is a prime number and makes sure that all the values are within our range of 160 bits and it allows the use of “modular square root” and “modular multiplicative inverse” mathematics which make calculating stuff easier (I think). Since we have a modulo (p) , it means that the possible values of&nbsp;y^2&nbsp;are between &nbsp;0 and&nbsp;p-1, which gives us&nbsp;p&nbsp;total possible values. However, since we are dealing with integers, only a smaller subset of those values will be a “perfect square” (the square value of two integers), which gives us&nbsp;N&nbsp;possible points on the curve where&nbsp;N &lt; p&nbsp;(N&nbsp;being the number of perfect squares between 0 and&nbsp;p). Since each&nbsp;x&nbsp;will yield two points (positive and negative values of the square-root of&nbsp;y^2), this means that there are&nbsp;N/2&nbsp;possible ‘x‘ coordinates that are valid and that give a point on the curve. So this elliptic curve has a finite number of points on it, and it’s all because of the integer calculations and the modulus. Another thing you need to know about&nbsp;Elliptic curves, is the notion of “point addition“. It is defined as adding one point&nbsp;P&nbsp;to another point&nbsp;Q&nbsp;will lead to a point&nbsp;S&nbsp;such that if you draw a line from&nbsp;P&nbsp;to&nbsp;Q, it will intersect the curve on a third point&nbsp;R&nbsp;which is the negative value of&nbsp;S&nbsp;(remember that the curve is symmetric on the&nbsp;X axis). In this case, we define&nbsp;R = -S&nbsp;to represent the symmetrical point of&nbsp;R&nbsp;on the&nbsp;X axis. This is easier to illustrate with an image :So you can see a curve of the form&nbsp;y^2 = x^3 + ax + b&nbsp;(where&nbsp;a = -4&nbsp;and&nbsp;b = 0), which is symmetric on the&nbsp;X axis, and where&nbsp;P+Q&nbsp;is the symmetrical point through&nbsp;X&nbsp;of the point&nbsp;R&nbsp;which is the third intersection of a line going from&nbsp;P&nbsp;to&nbsp;Q. In the same manner, if you do&nbsp;P + P, &nbsp;it will be the symmetrical point of&nbsp;R&nbsp;which is the intersection of the line that is a tangent to the point&nbsp;P.. AndP + P + P&nbsp;is the addition between the resulting point of&nbsp;P+P&nbsp;with the point&nbsp;P&nbsp;since&nbsp;P + P + P&nbsp;can be written as&nbsp;(P+P) + P.. This defines the “point multiplication” where&nbsp;k*P&nbsp;is the addition of the point&nbsp;P&nbsp;to itself&nbsp;k&nbsp;times… here are two examples showing this :&nbsp; Here, you can see two elliptic curves, and a point&nbsp;P&nbsp;from which you draw the tangent, it intersects the curve with a third point, and its symmetric point it&nbsp;2P, then from there, you draw a line from&nbsp;2Pand&nbsp;P&nbsp;and it will intersect the curve, and the symmetrical point is&nbsp;3P. etc… you can keep doing that for the point multiplication. You can also already guess why you need to take the symmetric point of&nbsp;R&nbsp;when doing the addition, otherwise, multiple additions of the same point will always give the same line and the same three intersections. One particularity of this point multiplication is that if you have a point&nbsp;R = k*P, where you know&nbsp;Rand you know&nbsp;P, there is no way to find out what the value of ‘k‘ is. Since there is no point subtraction or point division, you cannot just resolve&nbsp;k = R/P. Also, since you could be doing millions of &nbsp;point additions, you will just end up on another point on the curve, and you’d have no way of knowing “how” you got there. You can’t reverse this operation, and you can’t find the value ‘k‘ which was multiplied with your point&nbsp;P&nbsp;to give you the resulting point&nbsp;R. This thing where you can’t find the multiplicand even when you know the original and destination points is the whole basis of the security behind the ECDSA algorithm, and the principle is called a “trap door function“. Now that we’ve handled the “basics”, let’s talk about the actual ECDSA signature algorithm. For ECDSA, you first need to know your curve parameters, those are&nbsp;a, b, p, N&nbsp;and&nbsp;G. You already know that ‘a‘ and ‘b‘ are the parameters of the curve function (y^2 = x^3 + ax + b), that ‘p‘ is the prime modulus, &nbsp;and that ‘N‘ is the number of points of the curve, but there is also ‘G‘ that is needed for ECDSA, and it represents a ‘reference point’ or a point of origin if you prefer. Those curve parameters are important and without knowing them, you obviously can’t sign or verify a signature. Yes, verifying a signature isn’t just about knowing the public key, you also need to know the curve parameters for which this public key is derived from. So first of all, you will have a private and a public key.. the private key is a random number (of 20 bytes) that is generated, and the public key is a point on the curve generated from the point multiplication of&nbsp;G&nbsp;with the private key. We set ‘dA‘ as the private key (random number) and ‘Qa‘ as the public key (a point), so we have :&nbsp;Qa = dA * G&nbsp;(where&nbsp;G&nbsp;is the point of reference in the curve parameters). So how do you sign a file/message ? First, you need to know that the signature is 40 bytes and is represented by two values of 20 bytes each, the first one is called&nbsp;R&nbsp;and the second one is called&nbsp;S.. so the pair&nbsp;(R, S)&nbsp;together is your ECDSA signature.. now here’s how you can create those two values in order to sign a file.. first you must generate a random value ‘k‘ (of 20 byes), and use point multiplication to calculate the point&nbsp;P=k*G. That point’s&nbsp;x&nbsp;value will represent ‘R‘. Since the point on the curve&nbsp;P&nbsp;is represented by its&nbsp;(x, y)&nbsp;coordinates (each being 20 bytes long), you only need the ‘x‘ value (20 bytes) for the signature, and that value will be called ‘R‘. Now all you need is the ‘S‘ value. To calculate&nbsp;S, you must make a SHA1 hash of the message, this gives you a 20 bytes value that you will consider as a very huge integer number and we’ll call it ‘z‘. Now you can calculate&nbsp;S&nbsp;using the equation : S = k^-1 (z + dA * R) mod p Note here the&nbsp;k^-1&nbsp;which is the ‘modular multiplicative inverse‘ of&nbsp;k… it’s basically the inverse ofk, but since we are dealing with integer numbers, then that’s not possible, so it’s a number such that&nbsp;(k^-1 * k ) mod p&nbsp;is equal to 1. And again, I remind you that&nbsp;k&nbsp;is the random number used to generate&nbsp;R,&nbsp;z&nbsp;is the hash of the message to sign,&nbsp;dA&nbsp;is the private key and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate ofk*G&nbsp;(where&nbsp;G&nbsp;is the point of origin of the curve parameters). Now that you have your signature, you want to verify it, it’s also quite simple, and you only need the public key (and curve parameters of course) to do that. You use this equation to calculate a point&nbsp;P&nbsp;: P= &nbsp;S^-1*z*G + S^-1 * R * Qa If the&nbsp;x&nbsp;coordinate of the point&nbsp;P&nbsp;is equal to&nbsp;R, that means that the signature is valid, otherwise it’s not. Pretty simple, huh? now let’s see why and how… and this is going to require some mathematics to verify : We have : P = S^-1*z*G + S^-1 * R *Qa but&nbsp;Qa = dA*G, so: P = S^-1*z*G + S^-1 * R * dA*G = S^-1 (z + dA* R) * G But the&nbsp;x&nbsp;coordinate of&nbsp;P&nbsp;must match&nbsp;R&nbsp;and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate of&nbsp;k * G, which means that : k*G = S^-1 (z + dA * R) *G we can simplify by removing&nbsp;G&nbsp;which gives us : k = S^-1(z + dA * R) by inverting&nbsp;k&nbsp;and&nbsp;S, we get : S = k^-1 (z + dA *R) and that is the equation used to generate the signature.. so it matches, and that is the reason why you can verify the signature with it. You can note that you need both ‘k‘ (random number) and ‘dA‘ (the private key) in order to calculate&nbsp;S, but you only need&nbsp;R&nbsp;and&nbsp;Qa&nbsp;(public key) to validate the signature. And since&nbsp;R=k*G&nbsp;andQa = dA*G&nbsp;and because of the trap door function in the ECDSA point multiplication (explained above), we cannot calculate&nbsp;dA&nbsp;or&nbsp;k&nbsp;from knowing&nbsp;Qa&nbsp;and&nbsp;R, this makes the ECDSA algorithm secure, there is no way of finding the private keys, and there is no way of faking a signature without knowing the private key. The ECDSA algorithm is used everywhere and has not been cracked and it is a vital part of most of today’s security. Now I’ll discuss on how and why the ECDSA signatures that Sony &nbsp;used in the PS3 were faulty and how it allowed us to gain access to their private key. So you remember the equations needed to generate a signature..&nbsp;R = k*G&nbsp;and&nbsp;S= k^-1(z + dA*R) mod p.. well this equation’s strength is in the fact that you have one equation with two unknowns (k&nbsp;and&nbsp;dA) so there is no way to determine either one of those. However, the security of the algorithm is based on its implementation and it’s important to make sure that ‘k‘ is randomly generated and that there is no way that someone can guess, calculate, or use a timing attack or any other type of attack in order to find the random value ‘k‘. But Sony made a huge mistake in their implementation, they used the same value for ‘k‘ everywhere, which means that if you have two signatures, both with the same&nbsp;k, then they will both have the same&nbsp;R&nbsp;value, and it means that you can calculate&nbsp;k&nbsp;using two&nbsp;S&nbsp;signatures of two files with hashes&nbsp;z&nbsp;and&nbsp;z’&nbsp;and signatures&nbsp;S&nbsp;and&nbsp;S’respectively : S – S’ = k^-1 (z + dA*R) – k^-1 (z’ + da*R) = k^-1 (z + da*R – z’ -dA*R) = k^-1 (z – z’) So :&nbsp;k = (z – z’) / (S – S’) Once you know&nbsp;k, then the equation &nbsp;for&nbsp;S&nbsp;because one equation with one unknown and is then easily resolved for&nbsp;dA&nbsp;: dA = (S*k – z) / R Once you know the private key&nbsp;dA, you can now sign your files and the PS3 will recognize it as an authentic file signed by Sony. This is why it’s important to make sure that the random number used for generating the signature is actually “cryptographically random”. &nbsp;This is also the reason why it is impossible to have a custom firmware above 3.56, simply because since the 3.56 version, Sony have fixed their ECDSA algorithm implementation and used new keys for which it is impossible to find the private key.. if there was a way to find that key, then the security of every computer, website, system may be compromised since a lot of systems are relying on ECDSA for their security, and it is impossible to crack. Finally! I hope this makes the whole algorithm clearer to many of you.. I know that this is still very complicated and hard to understand. I usually try to make things easy to understand for non technical people, but this algorithm is too complex to be able to explain in any simpler terms. After all that’s why I prefer to call it the MFET algorithm (Mathematics For Extra Terrestrials)&nbsp; But if you are a developer or a mathematician or someone interested in learning about this because you want to help or simple gain knowledge, then I’m sure that this contains enough information for you to get started or to at least understand the concept behind this unknown beast called “ECDSA”. That being said, I’d like to thank a few people who helped me understand all of this, one particularly who wishes to remain anonymous, as well as the many wikipedia pages I linked to throughout this article, and Avi Kak thanks to&nbsp;his paper&nbsp;explaining the mathematics behind ECDSA, and from which I have taken those graph images aboves. P.s: In this article, I used ’20 bytes’ in my text to talk about the ECDSA signature because that’s what is usually used as it matches the SHA1 hash size of 20 bytes and that’s what the PS3 security uses, but the algorithm itself can be used with any size of numbers. There may be other inaccuracies in this article, but like I said, I’m not an expert, I just barely learned all of this in the past week. 以下内容转载在实验篇： Recovering Bitcoin private keys using weak signatures from the blockchain On December 25th of last year I discovered a potential weakness in some Bitcoin implementations. Have a look at this transaction: transaction: 9ec4bc49e828d924af1d1029cacf709431abbde46d59554b62bc270e3b29c4b1 input script 1: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1022044e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff input script 2: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad102209a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff This transactions has two inputs and one output. If you look closely at the two input scripts you will notice there are quite a few equal bytes at the start and at the end. Those bytes at the end is the hex-encoded public key of the address spending the coins so there’s nothing wrong with that. However, the first half of the script is the actual signature (r, s): r1: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 r2: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1: 44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2: 9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab As you can see, r1 equals r2. This is a huge problem. We’ll be able to&nbsp;recover the private&nbsp;key to this public key: private key = (z1*s2 - z2*s1)/(r*(s1-s2)) We just need to find z1 and z2! These are the hashes of the outputs to be signed. Let’s fetch the output transations and calculate them (it is calculated by OP_CHECKSIG): z1: c0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2: 17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc That’s it. Let’s setup our&nbsp;sage&nbsp;notebook like this: p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 r = 0xd47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1 = 0x44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2 = 0x9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab z1 = 0xc0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2 = 0x17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc p is just the order of G, a parameter of the secp256k1 curve used by Bitcoin. Let’s create a field for our calculations: K = GF(p) And calculate the private key within this field: K((z1*s2 - z2*s1)/(r*(s1-s2))) 88865298299719117682218467295833367085649033095698151055007620974294165995414 Convert it to a more suitable format: hex: c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96 WIF: 5KJp7KEffR7HHFWSFYjiCUAntRSTY69LAQEX1AUzaSBHHFdKEpQ And import it to your favourite Bitcoin wallet. It’ll calculate the correct bitcoin address and you’ll be able to spend coins send to this address. There are a few vulnerable bitcoin addresses in the blockchain. After some research I was able to contact the owner of this address. He allowed me to spend the funds. Why did this work? ECDSA requires a random number for each signature. If this random number is ever used twice with the same private key it can be recovered. This transaction was generated by a hardware bitcoin wallet using a pseudo-random number generator that was returning the same “random” number every time. 阅读更多" />
<meta property="og:description" content="参考： https://github.com/openssl/openssl/blob/master/crypto/ecdsa/ecdsa.h 原理篇： http://kakaroto.homelinux.net/2012/01/how-the-ecdsa-algorithm-works/ 实验篇： http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html Makefile .PHONY:all all: gcc -I/d/workspace/github/altcoin/bitcoin-3rd/ssl/include -o sigvery -g -O0 sigvery.c -L/d/workspace/github/altcoin/bitcoin-3rd/ssl/lib -lssl -lcrypto -lgdi32 Code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;openssl/opensslconf.h&gt; #include &lt;openssl/ec.h&gt; #include &lt;openssl/bn.h&gt; #include &lt;openssl/ecdsa.h&gt; int main(int argc, char * argv []){ &nbsp; &nbsp; // First step: create a EC_KEY object (note: this part is not ECDSA specific) &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;ret; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;nid; &nbsp; &nbsp; ECDSA_SIG *sig; &nbsp; &nbsp; EC_KEY &nbsp; &nbsp;*eckey; &nbsp; &nbsp; unsigned char digest [20]; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; memset(digest, 0xaa, sizeof(digest));// 测试用的假HASH &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; nid = OBJ_sn2nid(&quot;secp256k1&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; eckey = EC_KEY_new_by_curve_name(nid); &nbsp; &nbsp; if (eckey == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;EC_KEY_new_by_curve_name&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (!EC_KEY_generate_key(eckey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下ec的私钥和公钥 &nbsp; &nbsp; &nbsp; &nbsp; EC_KEY_print_fp(stdout, eckey, 0); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; // Second step: compute the ECDSA signature of a SHA-1 hash value using ECDSA_do_sign &nbsp; &nbsp; sig = ECDSA_do_sign(digest, 20, eckey);// 签名 &nbsp; &nbsp; if (sig == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_sign&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下签名，r和s &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Signature:\n\tr=%s\n\ts=%s\n&quot;, BN_bn2hex(sig-&gt;r), BN_bn2hex(sig-&gt;s)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Third step: verify the created ECDSA signature using ECDSA_do_verify &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ECDSA_do_verify(digest, 20, sig, eckey);// 验证 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (ret == -1) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_verify&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else if (ret == 0) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* incorrect signature */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified Failure\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; /* ret == 1 */ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* signature ok */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified OK\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; return 0; } 测试： HASH=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; // 20个字节的0xaa $ ./sigvery.exe Private-Key: (256 bit) priv: 00:95:55:33:26:d8:92:cd:58:d7:7b:71:b8:02:29: 36:41:9a:22:e9:f0:21:72:02:a7:fc:1e:05:a3:f5: 6e:f4:ec pub: 04:76:91:81:fd:2e:44:e0:17:03:b3:53:7d:55:fe: e2:f5:6a:89:d1:5b:2c:e2:06:83:6a:e5:64:b6:4b: 07:76:8c:8b:df:57:7b:75:7b:f6:fb:9c:44:6f:1b: f6:56:ff:ac:ed:2f:65:a9:49:81:ba:af:90:13:8f: 96:a3:9e:83:9f Field Type: prime-field Prime: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff: ff:fc:2f A: 0 B: 7 (0x7) Generator (uncompressed): 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87: 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16: f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc: 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0: 8f:fb:10:d4:b8 Order: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0: 36:41:41 Cofactor: 1 (0x1) Signature: r=F0AB42A05A1C7CB18EF50A0E63CF287B3604A3741D6875DADE9031E648055E7D s=4C556EDC930313C67286A7B7AD7BC336FB39C0BA4BC42BE801FBBE8CBDCD0012 Verified OK 比特币目前使用ECDSA对货币的所有权进行鉴定，当然前提是对于付款地址是椭圆曲线算法的公钥(secp256k1 for bitcoin)。 如果是puzzle类型等非标准的付款方式，那么resolve的方式就不是签名/验证的形式了，那就要看脚本的设置到底需要什么的推理前提了。 关于签名算法的细节可以参考wiki上bob&amp;alice的签名验证例子。 比特币的源代码使用CECKey结构对openssl的ec算法进行了封装。 在此基础上衍生了其他密钥管理对象，CPubKey, CKeyID, CScriptID, CPrivKey, CKey 1) CKey 对openssl中的ecdsa算法的基本封装，是整个算法的核心。 CKey可以导入通过SetPrivKey()/GetPrivKey()导入/导出openssl格式的私钥。 // Initialize from a CPrivKey (serialized OpenSSL private key data). bool SetPrivKey(const CPrivKey &amp;vchPrivKey, bool fCompressed); // Convert the private key to a CPrivKey (serialized OpenSSL private key data). // This is expensive. CPrivKey GetPrivKey() const; CKey可以通过GetPubKey()导出公钥（压缩格式或者非压缩格式的，根据内部标记来决定） // Compute the public key from a private key. // This is expensive. CPubKey GetPubKey() const; CKey可以通过Sign()来签署消息摘要 // Create a DER-serialized signature. bool Sign(const uint256 &amp;hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; 2) CPubKey 对openssl中的ecdsa算法的公钥的基本封装，可以由CKey的成员函数计算得到。 CPubKey可以通过GetID()调用来计算得到该公钥对应的索引（也就是该公钥的hash256/ripemd160的hash） // Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch+size())); } CPubKey可以通过Verify()来验证CKey的签名 // Verify a DER signature (~72 bytes). // If this public key is not fully valid, the return value will be false. bool Verify(const uint256 &amp;hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 3）CScript 对支付脚本的状态机的封装 CScript可以通过GetID()来获取序列化的脚本的索引（hash值） CScriptID GetID() const { return CScriptID(Hash160(*this)); } 4）CScriptID&nbsp; 支付脚本script的索引的封装,20字节hash值 5) &nbsp;CPubKeyID 支付公钥的索引的封装,&nbsp;20字节hash值 6）CBitcoinAddress 版本和索引值的封装 可以以base58格式操作2类钱包地址； 地址可以是脚本，也可以是公钥，对应的分别是脚本的id和公钥的id，CSriptID, CPubKeyID 7) CBitCoinSecret 对私钥base58格式的封装 可以以base58格式操作私钥。 openssl ecdsa算法实践 1) 列举所有已经实现的算法曲线 gentoobox harrywu # openssl ecparam -list_curves secp112r1 : SECG/WTLS curve over a 112 bit prime field secp112r2 : SECG curve over a 112 bit prime field secp128r1 : SECG curve over a 128 bit prime field secp128r2 : SECG curve over a 128 bit prime field secp160k1 : SECG curve over a 160 bit prime field secp160r1 : SECG curve over a 160 bit prime field secp160r2 : SECG/WTLS curve over a 160 bit prime field secp192k1 : SECG curve over a 192 bit prime field secp224k1 : SECG curve over a 224 bit prime field secp224r1 : NIST/SECG curve over a 224 bit prime field secp256k1 : SECG curve over a 256 bit prime field secp384r1 : NIST/SECG curve over a 384 bit prime field secp521r1 : NIST/SECG curve over a 521 bit prime field prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field prime192v2: X9.62 curve over a 192 bit prime field prime192v3: X9.62 curve over a 192 bit prime field prime239v1: X9.62 curve over a 239 bit prime field prime239v2: X9.62 curve over a 239 bit prime field prime239v3: X9.62 curve over a 239 bit prime field prime256v1: X9.62/SECG curve over a 256 bit prime field sect113r1 : SECG curve over a 113 bit binary field sect113r2 : SECG curve over a 113 bit binary field sect131r1 : SECG/WTLS curve over a 131 bit binary field sect131r2 : SECG curve over a 131 bit binary field sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field sect163r1 : SECG curve over a 163 bit binary field sect163r2 : NIST/SECG curve over a 163 bit binary field sect193r1 : SECG curve over a 193 bit binary field sect193r2 : SECG curve over a 193 bit binary field sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field sect239k1 : SECG curve over a 239 bit binary field sect283k1 : NIST/SECG curve over a 283 bit binary field sect283r1 : NIST/SECG curve over a 283 bit binary field sect409k1 : NIST/SECG curve over a 409 bit binary field sect409r1 : NIST/SECG curve over a 409 bit binary field sect571k1 : NIST/SECG curve over a 571 bit binary field sect571r1 : NIST/SECG curve over a 571 bit binary field c2pnb163v1: X9.62 curve over a 163 bit binary field c2pnb163v2: X9.62 curve over a 163 bit binary field c2pnb163v3: X9.62 curve over a 163 bit binary field c2pnb176v1: X9.62 curve over a 176 bit binary field c2tnb191v1: X9.62 curve over a 191 bit binary field c2tnb191v2: X9.62 curve over a 191 bit binary field c2tnb191v3: X9.62 curve over a 191 bit binary field c2pnb208w1: X9.62 curve over a 208 bit binary field c2tnb239v1: X9.62 curve over a 239 bit binary field c2tnb239v2: X9.62 curve over a 239 bit binary field c2tnb239v3: X9.62 curve over a 239 bit binary field c2pnb272w1: X9.62 curve over a 272 bit binary field c2pnb304w1: X9.62 curve over a 304 bit binary field c2tnb359v1: X9.62 curve over a 359 bit binary field c2pnb368w1: X9.62 curve over a 368 bit binary field c2tnb431r1: X9.62 curve over a 431 bit binary field wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls12: WTLS curvs over a 224 bit prime field Oakley-EC2N-3: IPSec/IKE/Oakley curve #3 over a 155 bit binary field. Not suitable for ECDSA. Questionable extension field! Oakley-EC2N-4: IPSec/IKE/Oakley curve #4 over a 185 bit binary field. Not suitable for ECDSA. Questionable extension field! 比特币选取了 secp256k1 : SECG curve over a 256 bit prime field 以下内容转载自原理篇 To popular demand, I have decided to try and explain how the&nbsp;ECDSA&nbsp;algorithm works. I’ve been struggling a bit to understand it properly and while I found a lot of documentation about it, I haven’t really found any “ECDSA for newbies” anywhere. So I thought it would be good to explain in simple terms how it works so others can learn from my research. I have found some websites that explain the basic principles but nowhere near enough to actually understand it, others that explains things without any basics, making it incomprehensible, and others that go way too deep into the the mathematics behind it. ECDSA stands for “Elliptic Curve Digital Signature Algorithm”, it’s used to create a&nbsp;digital signatureof data (a file for example) in order to allow you to verify its authenticity without compromising its security. Think of it like a real signature, you can recognize someone’s signature, but you can’t forge it without others knowing. The ECDSA algorithm is basically all about mathematics.. so I think it’s important to start by saying : “hey kids, don’t slack off at school, listen to your teachers, that stuff might be useful for you some day!”&nbsp;&nbsp;But these maths are fairly complicated, so while I’ll try to vulgarize it and make it understandable for non technical people, you will still probably need some knowledge in mathematics to understand it properly. I will do this in two parts, one that is a sort of high level explanation about how it works, and another where I dig deeper into its inner workings to complete your understanding. Note however that I’ve just recently learned this stuff, so I’m definitely not an expert on the matter. So the principle is simple, you have a mathematical equation which draws a curve on a graph, and you choose a random point on that curve and consider that your point of origin. Then you generate a random number, this is your private key, you do some magical mathematical equation using that random number and that “point of origin” and you get a second point on the curve, that’s your public key. When you want to sign a file, you will use this private key (the random number) with a hash of the file (a unique number to represent the file) into a magical equation and that will give you your signature. The signature itself is divided into two parts, called&nbsp;R&nbsp;and&nbsp;S. In order to verify that the signature is correct, you only need the public key (that point on the curve that was generated using the private key) and you put that into another magical equation with one part of the signature (S), and if it was signed correctly using the the private key, it will give you the other part of the signature (R). So to make it short, a signature consists of two numbers,&nbsp;R&nbsp;and&nbsp;S, and you use a private key to generate&nbsp;R&nbsp;and&nbsp;S, and if a mathematical equation using the public key and&nbsp;Sgives you&nbsp;R, then the signature is valid. There is no way to know the private key or to create a signature using only the public key. Alright, now for the more in depth understanding, I suggest you take an aspirin right now as this might hurt!&nbsp; Let’s start with the basics (which may be boring for people who know about it, but is mandatory for those who don’t) : ECDSA uses only integer mathematics, there are no floating points (this means possible values are 1, 2, 3, etc.. but not 1.5..), &nbsp;also, the range of the numbers is bound by how many bits are used in the signature (more bits means higher numbers, means more security as it becomes harder to ‘guess’ the critical numbers used in the equation), as you should know, computers use ‘bits’ to represent data, a bit is a ‘digit’ in binary notation (0 and 1) and 8 bits represent one byte. Every time you add one bit, the maximum number that can be represented doubles, with 4 bits you can represent values 0 to 15 (for a total of 16 possible values), with 5 bits, you can represent 32 values, with 6 bits, you can represent 64 values, etc.. one byte (8 bits) can represent 256 values, and 32 bits can represent 4294967296 values (4 Giga).. Usually ECDSA will use 160 bits total, so that makes… well, a very huge number with 49 digits in it… ECDSA&nbsp;is used with a&nbsp;SHA1&nbsp;cryptographic hash&nbsp;of the message to sign (the file). A&nbsp;hash&nbsp;is simply another mathematical equation that you apply on every byte of data which will give you a number that is unique to your data. Like for example, the sum of the values of all bytes may be considered a very dumb hash function. So if anything changes in the message (the file) then the hash will be completely different. In the case of the SHA1 hash algorithm, it will always be 20 bytes (160 bits). It’s very useful to validate that a file has not been modified or corrupted, you get the 20 bytes hash for a file of any size, and you can easily recalculate that hash to make sure it matches. What ECDSA signs is actually that hash, so if the data changes, the hash changes, and the signature isn’t valid anymore. Now, how does it work? Well&nbsp;Elliptic Curve cryptography&nbsp;is based on an equation of the form : y^2 = (x^3 + a * x + b) mod p First thing you notice is that there is a modulo and that the ‘y‘ is a square. This means that for anyx&nbsp;coordinate, you will have two values of&nbsp;y&nbsp;and that the curve is symmetric on the&nbsp;X axis. The modulo is a prime number and makes sure that all the values are within our range of 160 bits and it allows the use of “modular square root” and “modular multiplicative inverse” mathematics which make calculating stuff easier (I think). Since we have a modulo (p) , it means that the possible values of&nbsp;y^2&nbsp;are between &nbsp;0 and&nbsp;p-1, which gives us&nbsp;p&nbsp;total possible values. However, since we are dealing with integers, only a smaller subset of those values will be a “perfect square” (the square value of two integers), which gives us&nbsp;N&nbsp;possible points on the curve where&nbsp;N &lt; p&nbsp;(N&nbsp;being the number of perfect squares between 0 and&nbsp;p). Since each&nbsp;x&nbsp;will yield two points (positive and negative values of the square-root of&nbsp;y^2), this means that there are&nbsp;N/2&nbsp;possible ‘x‘ coordinates that are valid and that give a point on the curve. So this elliptic curve has a finite number of points on it, and it’s all because of the integer calculations and the modulus. Another thing you need to know about&nbsp;Elliptic curves, is the notion of “point addition“. It is defined as adding one point&nbsp;P&nbsp;to another point&nbsp;Q&nbsp;will lead to a point&nbsp;S&nbsp;such that if you draw a line from&nbsp;P&nbsp;to&nbsp;Q, it will intersect the curve on a third point&nbsp;R&nbsp;which is the negative value of&nbsp;S&nbsp;(remember that the curve is symmetric on the&nbsp;X axis). In this case, we define&nbsp;R = -S&nbsp;to represent the symmetrical point of&nbsp;R&nbsp;on the&nbsp;X axis. This is easier to illustrate with an image :So you can see a curve of the form&nbsp;y^2 = x^3 + ax + b&nbsp;(where&nbsp;a = -4&nbsp;and&nbsp;b = 0), which is symmetric on the&nbsp;X axis, and where&nbsp;P+Q&nbsp;is the symmetrical point through&nbsp;X&nbsp;of the point&nbsp;R&nbsp;which is the third intersection of a line going from&nbsp;P&nbsp;to&nbsp;Q. In the same manner, if you do&nbsp;P + P, &nbsp;it will be the symmetrical point of&nbsp;R&nbsp;which is the intersection of the line that is a tangent to the point&nbsp;P.. AndP + P + P&nbsp;is the addition between the resulting point of&nbsp;P+P&nbsp;with the point&nbsp;P&nbsp;since&nbsp;P + P + P&nbsp;can be written as&nbsp;(P+P) + P.. This defines the “point multiplication” where&nbsp;k*P&nbsp;is the addition of the point&nbsp;P&nbsp;to itself&nbsp;k&nbsp;times… here are two examples showing this :&nbsp; Here, you can see two elliptic curves, and a point&nbsp;P&nbsp;from which you draw the tangent, it intersects the curve with a third point, and its symmetric point it&nbsp;2P, then from there, you draw a line from&nbsp;2Pand&nbsp;P&nbsp;and it will intersect the curve, and the symmetrical point is&nbsp;3P. etc… you can keep doing that for the point multiplication. You can also already guess why you need to take the symmetric point of&nbsp;R&nbsp;when doing the addition, otherwise, multiple additions of the same point will always give the same line and the same three intersections. One particularity of this point multiplication is that if you have a point&nbsp;R = k*P, where you know&nbsp;Rand you know&nbsp;P, there is no way to find out what the value of ‘k‘ is. Since there is no point subtraction or point division, you cannot just resolve&nbsp;k = R/P. Also, since you could be doing millions of &nbsp;point additions, you will just end up on another point on the curve, and you’d have no way of knowing “how” you got there. You can’t reverse this operation, and you can’t find the value ‘k‘ which was multiplied with your point&nbsp;P&nbsp;to give you the resulting point&nbsp;R. This thing where you can’t find the multiplicand even when you know the original and destination points is the whole basis of the security behind the ECDSA algorithm, and the principle is called a “trap door function“. Now that we’ve handled the “basics”, let’s talk about the actual ECDSA signature algorithm. For ECDSA, you first need to know your curve parameters, those are&nbsp;a, b, p, N&nbsp;and&nbsp;G. You already know that ‘a‘ and ‘b‘ are the parameters of the curve function (y^2 = x^3 + ax + b), that ‘p‘ is the prime modulus, &nbsp;and that ‘N‘ is the number of points of the curve, but there is also ‘G‘ that is needed for ECDSA, and it represents a ‘reference point’ or a point of origin if you prefer. Those curve parameters are important and without knowing them, you obviously can’t sign or verify a signature. Yes, verifying a signature isn’t just about knowing the public key, you also need to know the curve parameters for which this public key is derived from. So first of all, you will have a private and a public key.. the private key is a random number (of 20 bytes) that is generated, and the public key is a point on the curve generated from the point multiplication of&nbsp;G&nbsp;with the private key. We set ‘dA‘ as the private key (random number) and ‘Qa‘ as the public key (a point), so we have :&nbsp;Qa = dA * G&nbsp;(where&nbsp;G&nbsp;is the point of reference in the curve parameters). So how do you sign a file/message ? First, you need to know that the signature is 40 bytes and is represented by two values of 20 bytes each, the first one is called&nbsp;R&nbsp;and the second one is called&nbsp;S.. so the pair&nbsp;(R, S)&nbsp;together is your ECDSA signature.. now here’s how you can create those two values in order to sign a file.. first you must generate a random value ‘k‘ (of 20 byes), and use point multiplication to calculate the point&nbsp;P=k*G. That point’s&nbsp;x&nbsp;value will represent ‘R‘. Since the point on the curve&nbsp;P&nbsp;is represented by its&nbsp;(x, y)&nbsp;coordinates (each being 20 bytes long), you only need the ‘x‘ value (20 bytes) for the signature, and that value will be called ‘R‘. Now all you need is the ‘S‘ value. To calculate&nbsp;S, you must make a SHA1 hash of the message, this gives you a 20 bytes value that you will consider as a very huge integer number and we’ll call it ‘z‘. Now you can calculate&nbsp;S&nbsp;using the equation : S = k^-1 (z + dA * R) mod p Note here the&nbsp;k^-1&nbsp;which is the ‘modular multiplicative inverse‘ of&nbsp;k… it’s basically the inverse ofk, but since we are dealing with integer numbers, then that’s not possible, so it’s a number such that&nbsp;(k^-1 * k ) mod p&nbsp;is equal to 1. And again, I remind you that&nbsp;k&nbsp;is the random number used to generate&nbsp;R,&nbsp;z&nbsp;is the hash of the message to sign,&nbsp;dA&nbsp;is the private key and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate ofk*G&nbsp;(where&nbsp;G&nbsp;is the point of origin of the curve parameters). Now that you have your signature, you want to verify it, it’s also quite simple, and you only need the public key (and curve parameters of course) to do that. You use this equation to calculate a point&nbsp;P&nbsp;: P= &nbsp;S^-1*z*G + S^-1 * R * Qa If the&nbsp;x&nbsp;coordinate of the point&nbsp;P&nbsp;is equal to&nbsp;R, that means that the signature is valid, otherwise it’s not. Pretty simple, huh? now let’s see why and how… and this is going to require some mathematics to verify : We have : P = S^-1*z*G + S^-1 * R *Qa but&nbsp;Qa = dA*G, so: P = S^-1*z*G + S^-1 * R * dA*G = S^-1 (z + dA* R) * G But the&nbsp;x&nbsp;coordinate of&nbsp;P&nbsp;must match&nbsp;R&nbsp;and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate of&nbsp;k * G, which means that : k*G = S^-1 (z + dA * R) *G we can simplify by removing&nbsp;G&nbsp;which gives us : k = S^-1(z + dA * R) by inverting&nbsp;k&nbsp;and&nbsp;S, we get : S = k^-1 (z + dA *R) and that is the equation used to generate the signature.. so it matches, and that is the reason why you can verify the signature with it. You can note that you need both ‘k‘ (random number) and ‘dA‘ (the private key) in order to calculate&nbsp;S, but you only need&nbsp;R&nbsp;and&nbsp;Qa&nbsp;(public key) to validate the signature. And since&nbsp;R=k*G&nbsp;andQa = dA*G&nbsp;and because of the trap door function in the ECDSA point multiplication (explained above), we cannot calculate&nbsp;dA&nbsp;or&nbsp;k&nbsp;from knowing&nbsp;Qa&nbsp;and&nbsp;R, this makes the ECDSA algorithm secure, there is no way of finding the private keys, and there is no way of faking a signature without knowing the private key. The ECDSA algorithm is used everywhere and has not been cracked and it is a vital part of most of today’s security. Now I’ll discuss on how and why the ECDSA signatures that Sony &nbsp;used in the PS3 were faulty and how it allowed us to gain access to their private key. So you remember the equations needed to generate a signature..&nbsp;R = k*G&nbsp;and&nbsp;S= k^-1(z + dA*R) mod p.. well this equation’s strength is in the fact that you have one equation with two unknowns (k&nbsp;and&nbsp;dA) so there is no way to determine either one of those. However, the security of the algorithm is based on its implementation and it’s important to make sure that ‘k‘ is randomly generated and that there is no way that someone can guess, calculate, or use a timing attack or any other type of attack in order to find the random value ‘k‘. But Sony made a huge mistake in their implementation, they used the same value for ‘k‘ everywhere, which means that if you have two signatures, both with the same&nbsp;k, then they will both have the same&nbsp;R&nbsp;value, and it means that you can calculate&nbsp;k&nbsp;using two&nbsp;S&nbsp;signatures of two files with hashes&nbsp;z&nbsp;and&nbsp;z’&nbsp;and signatures&nbsp;S&nbsp;and&nbsp;S’respectively : S – S’ = k^-1 (z + dA*R) – k^-1 (z’ + da*R) = k^-1 (z + da*R – z’ -dA*R) = k^-1 (z – z’) So :&nbsp;k = (z – z’) / (S – S’) Once you know&nbsp;k, then the equation &nbsp;for&nbsp;S&nbsp;because one equation with one unknown and is then easily resolved for&nbsp;dA&nbsp;: dA = (S*k – z) / R Once you know the private key&nbsp;dA, you can now sign your files and the PS3 will recognize it as an authentic file signed by Sony. This is why it’s important to make sure that the random number used for generating the signature is actually “cryptographically random”. &nbsp;This is also the reason why it is impossible to have a custom firmware above 3.56, simply because since the 3.56 version, Sony have fixed their ECDSA algorithm implementation and used new keys for which it is impossible to find the private key.. if there was a way to find that key, then the security of every computer, website, system may be compromised since a lot of systems are relying on ECDSA for their security, and it is impossible to crack. Finally! I hope this makes the whole algorithm clearer to many of you.. I know that this is still very complicated and hard to understand. I usually try to make things easy to understand for non technical people, but this algorithm is too complex to be able to explain in any simpler terms. After all that’s why I prefer to call it the MFET algorithm (Mathematics For Extra Terrestrials)&nbsp; But if you are a developer or a mathematician or someone interested in learning about this because you want to help or simple gain knowledge, then I’m sure that this contains enough information for you to get started or to at least understand the concept behind this unknown beast called “ECDSA”. That being said, I’d like to thank a few people who helped me understand all of this, one particularly who wishes to remain anonymous, as well as the many wikipedia pages I linked to throughout this article, and Avi Kak thanks to&nbsp;his paper&nbsp;explaining the mathematics behind ECDSA, and from which I have taken those graph images aboves. P.s: In this article, I used ’20 bytes’ in my text to talk about the ECDSA signature because that’s what is usually used as it matches the SHA1 hash size of 20 bytes and that’s what the PS3 security uses, but the algorithm itself can be used with any size of numbers. There may be other inaccuracies in this article, but like I said, I’m not an expert, I just barely learned all of this in the past week. 以下内容转载在实验篇： Recovering Bitcoin private keys using weak signatures from the blockchain On December 25th of last year I discovered a potential weakness in some Bitcoin implementations. Have a look at this transaction: transaction: 9ec4bc49e828d924af1d1029cacf709431abbde46d59554b62bc270e3b29c4b1 input script 1: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1022044e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff input script 2: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad102209a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff This transactions has two inputs and one output. If you look closely at the two input scripts you will notice there are quite a few equal bytes at the start and at the end. Those bytes at the end is the hex-encoded public key of the address spending the coins so there’s nothing wrong with that. However, the first half of the script is the actual signature (r, s): r1: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 r2: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1: 44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2: 9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab As you can see, r1 equals r2. This is a huge problem. We’ll be able to&nbsp;recover the private&nbsp;key to this public key: private key = (z1*s2 - z2*s1)/(r*(s1-s2)) We just need to find z1 and z2! These are the hashes of the outputs to be signed. Let’s fetch the output transations and calculate them (it is calculated by OP_CHECKSIG): z1: c0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2: 17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc That’s it. Let’s setup our&nbsp;sage&nbsp;notebook like this: p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 r = 0xd47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1 = 0x44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2 = 0x9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab z1 = 0xc0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2 = 0x17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc p is just the order of G, a parameter of the secp256k1 curve used by Bitcoin. Let’s create a field for our calculations: K = GF(p) And calculate the private key within this field: K((z1*s2 - z2*s1)/(r*(s1-s2))) 88865298299719117682218467295833367085649033095698151055007620974294165995414 Convert it to a more suitable format: hex: c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96 WIF: 5KJp7KEffR7HHFWSFYjiCUAntRSTY69LAQEX1AUzaSBHHFdKEpQ And import it to your favourite Bitcoin wallet. It’ll calculate the correct bitcoin address and you’ll be able to spend coins send to this address. There are a few vulnerable bitcoin addresses in the blockchain. After some research I was able to contact the owner of this address. He allowed me to spend the funds. Why did this work? ECDSA requires a random number for each signature. If this random number is ever used twice with the same private key it can be recovered. This transaction was generated by a hardware bitcoin wallet using a pseudo-random number generator that was returning the same “random” number every time. 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-07-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"参考： https://github.com/openssl/openssl/blob/master/crypto/ecdsa/ecdsa.h 原理篇： http://kakaroto.homelinux.net/2012/01/how-the-ecdsa-algorithm-works/ 实验篇： http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html Makefile .PHONY:all all: gcc -I/d/workspace/github/altcoin/bitcoin-3rd/ssl/include -o sigvery -g -O0 sigvery.c -L/d/workspace/github/altcoin/bitcoin-3rd/ssl/lib -lssl -lcrypto -lgdi32 Code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;openssl/opensslconf.h&gt; #include &lt;openssl/ec.h&gt; #include &lt;openssl/bn.h&gt; #include &lt;openssl/ecdsa.h&gt; int main(int argc, char * argv []){ &nbsp; &nbsp; // First step: create a EC_KEY object (note: this part is not ECDSA specific) &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;ret; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;nid; &nbsp; &nbsp; ECDSA_SIG *sig; &nbsp; &nbsp; EC_KEY &nbsp; &nbsp;*eckey; &nbsp; &nbsp; unsigned char digest [20]; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; memset(digest, 0xaa, sizeof(digest));// 测试用的假HASH &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; nid = OBJ_sn2nid(&quot;secp256k1&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; eckey = EC_KEY_new_by_curve_name(nid); &nbsp; &nbsp; if (eckey == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;EC_KEY_new_by_curve_name&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (!EC_KEY_generate_key(eckey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下ec的私钥和公钥 &nbsp; &nbsp; &nbsp; &nbsp; EC_KEY_print_fp(stdout, eckey, 0); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; // Second step: compute the ECDSA signature of a SHA-1 hash value using ECDSA_do_sign &nbsp; &nbsp; sig = ECDSA_do_sign(digest, 20, eckey);// 签名 &nbsp; &nbsp; if (sig == NULL) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_sign&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下签名，r和s &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Signature:\\n\\tr=%s\\n\\ts=%s\\n&quot;, BN_bn2hex(sig-&gt;r), BN_bn2hex(sig-&gt;s)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Third step: verify the created ECDSA signature using ECDSA_do_verify &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ECDSA_do_verify(digest, 20, sig, eckey);// 验证 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; if (ret == -1) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* error */ &nbsp; &nbsp; &nbsp; &nbsp; perror(&quot;ECDSA_do_verify&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else if (ret == 0) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* incorrect signature */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified Failure\\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; /* ret == 1 */ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; /* signature ok */ &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Verified OK\\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; return 0; } 测试： HASH=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; // 20个字节的0xaa $ ./sigvery.exe Private-Key: (256 bit) priv: 00:95:55:33:26:d8:92:cd:58:d7:7b:71:b8:02:29: 36:41:9a:22:e9:f0:21:72:02:a7:fc:1e:05:a3:f5: 6e:f4:ec pub: 04:76:91:81:fd:2e:44:e0:17:03:b3:53:7d:55:fe: e2:f5:6a:89:d1:5b:2c:e2:06:83:6a:e5:64:b6:4b: 07:76:8c:8b:df:57:7b:75:7b:f6:fb:9c:44:6f:1b: f6:56:ff:ac:ed:2f:65:a9:49:81:ba:af:90:13:8f: 96:a3:9e:83:9f Field Type: prime-field Prime: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff: ff:fc:2f A: 0 B: 7 (0x7) Generator (uncompressed): 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87: 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16: f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc: 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0: 8f:fb:10:d4:b8 Order: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0: 36:41:41 Cofactor: 1 (0x1) Signature: r=F0AB42A05A1C7CB18EF50A0E63CF287B3604A3741D6875DADE9031E648055E7D s=4C556EDC930313C67286A7B7AD7BC336FB39C0BA4BC42BE801FBBE8CBDCD0012 Verified OK 比特币目前使用ECDSA对货币的所有权进行鉴定，当然前提是对于付款地址是椭圆曲线算法的公钥(secp256k1 for bitcoin)。 如果是puzzle类型等非标准的付款方式，那么resolve的方式就不是签名/验证的形式了，那就要看脚本的设置到底需要什么的推理前提了。 关于签名算法的细节可以参考wiki上bob&amp;alice的签名验证例子。 比特币的源代码使用CECKey结构对openssl的ec算法进行了封装。 在此基础上衍生了其他密钥管理对象，CPubKey, CKeyID, CScriptID, CPrivKey, CKey 1) CKey 对openssl中的ecdsa算法的基本封装，是整个算法的核心。 CKey可以导入通过SetPrivKey()/GetPrivKey()导入/导出openssl格式的私钥。 // Initialize from a CPrivKey (serialized OpenSSL private key data). bool SetPrivKey(const CPrivKey &amp;vchPrivKey, bool fCompressed); // Convert the private key to a CPrivKey (serialized OpenSSL private key data). // This is expensive. CPrivKey GetPrivKey() const; CKey可以通过GetPubKey()导出公钥（压缩格式或者非压缩格式的，根据内部标记来决定） // Compute the public key from a private key. // This is expensive. CPubKey GetPubKey() const; CKey可以通过Sign()来签署消息摘要 // Create a DER-serialized signature. bool Sign(const uint256 &amp;hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; 2) CPubKey 对openssl中的ecdsa算法的公钥的基本封装，可以由CKey的成员函数计算得到。 CPubKey可以通过GetID()调用来计算得到该公钥对应的索引（也就是该公钥的hash256/ripemd160的hash） // Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch+size())); } CPubKey可以通过Verify()来验证CKey的签名 // Verify a DER signature (~72 bytes). // If this public key is not fully valid, the return value will be false. bool Verify(const uint256 &amp;hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 3）CScript 对支付脚本的状态机的封装 CScript可以通过GetID()来获取序列化的脚本的索引（hash值） CScriptID GetID() const { return CScriptID(Hash160(*this)); } 4）CScriptID&nbsp; 支付脚本script的索引的封装,20字节hash值 5) &nbsp;CPubKeyID 支付公钥的索引的封装,&nbsp;20字节hash值 6）CBitcoinAddress 版本和索引值的封装 可以以base58格式操作2类钱包地址； 地址可以是脚本，也可以是公钥，对应的分别是脚本的id和公钥的id，CSriptID, CPubKeyID 7) CBitCoinSecret 对私钥base58格式的封装 可以以base58格式操作私钥。 openssl ecdsa算法实践 1) 列举所有已经实现的算法曲线 gentoobox harrywu # openssl ecparam -list_curves secp112r1 : SECG/WTLS curve over a 112 bit prime field secp112r2 : SECG curve over a 112 bit prime field secp128r1 : SECG curve over a 128 bit prime field secp128r2 : SECG curve over a 128 bit prime field secp160k1 : SECG curve over a 160 bit prime field secp160r1 : SECG curve over a 160 bit prime field secp160r2 : SECG/WTLS curve over a 160 bit prime field secp192k1 : SECG curve over a 192 bit prime field secp224k1 : SECG curve over a 224 bit prime field secp224r1 : NIST/SECG curve over a 224 bit prime field secp256k1 : SECG curve over a 256 bit prime field secp384r1 : NIST/SECG curve over a 384 bit prime field secp521r1 : NIST/SECG curve over a 521 bit prime field prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field prime192v2: X9.62 curve over a 192 bit prime field prime192v3: X9.62 curve over a 192 bit prime field prime239v1: X9.62 curve over a 239 bit prime field prime239v2: X9.62 curve over a 239 bit prime field prime239v3: X9.62 curve over a 239 bit prime field prime256v1: X9.62/SECG curve over a 256 bit prime field sect113r1 : SECG curve over a 113 bit binary field sect113r2 : SECG curve over a 113 bit binary field sect131r1 : SECG/WTLS curve over a 131 bit binary field sect131r2 : SECG curve over a 131 bit binary field sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field sect163r1 : SECG curve over a 163 bit binary field sect163r2 : NIST/SECG curve over a 163 bit binary field sect193r1 : SECG curve over a 193 bit binary field sect193r2 : SECG curve over a 193 bit binary field sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field sect239k1 : SECG curve over a 239 bit binary field sect283k1 : NIST/SECG curve over a 283 bit binary field sect283r1 : NIST/SECG curve over a 283 bit binary field sect409k1 : NIST/SECG curve over a 409 bit binary field sect409r1 : NIST/SECG curve over a 409 bit binary field sect571k1 : NIST/SECG curve over a 571 bit binary field sect571r1 : NIST/SECG curve over a 571 bit binary field c2pnb163v1: X9.62 curve over a 163 bit binary field c2pnb163v2: X9.62 curve over a 163 bit binary field c2pnb163v3: X9.62 curve over a 163 bit binary field c2pnb176v1: X9.62 curve over a 176 bit binary field c2tnb191v1: X9.62 curve over a 191 bit binary field c2tnb191v2: X9.62 curve over a 191 bit binary field c2tnb191v3: X9.62 curve over a 191 bit binary field c2pnb208w1: X9.62 curve over a 208 bit binary field c2tnb239v1: X9.62 curve over a 239 bit binary field c2tnb239v2: X9.62 curve over a 239 bit binary field c2tnb239v3: X9.62 curve over a 239 bit binary field c2pnb272w1: X9.62 curve over a 272 bit binary field c2pnb304w1: X9.62 curve over a 304 bit binary field c2tnb359v1: X9.62 curve over a 359 bit binary field c2pnb368w1: X9.62 curve over a 368 bit binary field c2tnb431r1: X9.62 curve over a 431 bit binary field wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field wap-wsg-idm-ecid-wtls12: WTLS curvs over a 224 bit prime field Oakley-EC2N-3: IPSec/IKE/Oakley curve #3 over a 155 bit binary field. Not suitable for ECDSA. Questionable extension field! Oakley-EC2N-4: IPSec/IKE/Oakley curve #4 over a 185 bit binary field. Not suitable for ECDSA. Questionable extension field! 比特币选取了 secp256k1 : SECG curve over a 256 bit prime field 以下内容转载自原理篇 To popular demand, I have decided to try and explain how the&nbsp;ECDSA&nbsp;algorithm works. I’ve been struggling a bit to understand it properly and while I found a lot of documentation about it, I haven’t really found any “ECDSA for newbies” anywhere. So I thought it would be good to explain in simple terms how it works so others can learn from my research. I have found some websites that explain the basic principles but nowhere near enough to actually understand it, others that explains things without any basics, making it incomprehensible, and others that go way too deep into the the mathematics behind it. ECDSA stands for “Elliptic Curve Digital Signature Algorithm”, it’s used to create a&nbsp;digital signatureof data (a file for example) in order to allow you to verify its authenticity without compromising its security. Think of it like a real signature, you can recognize someone’s signature, but you can’t forge it without others knowing. The ECDSA algorithm is basically all about mathematics.. so I think it’s important to start by saying : “hey kids, don’t slack off at school, listen to your teachers, that stuff might be useful for you some day!”&nbsp;&nbsp;But these maths are fairly complicated, so while I’ll try to vulgarize it and make it understandable for non technical people, you will still probably need some knowledge in mathematics to understand it properly. I will do this in two parts, one that is a sort of high level explanation about how it works, and another where I dig deeper into its inner workings to complete your understanding. Note however that I’ve just recently learned this stuff, so I’m definitely not an expert on the matter. So the principle is simple, you have a mathematical equation which draws a curve on a graph, and you choose a random point on that curve and consider that your point of origin. Then you generate a random number, this is your private key, you do some magical mathematical equation using that random number and that “point of origin” and you get a second point on the curve, that’s your public key. When you want to sign a file, you will use this private key (the random number) with a hash of the file (a unique number to represent the file) into a magical equation and that will give you your signature. The signature itself is divided into two parts, called&nbsp;R&nbsp;and&nbsp;S. In order to verify that the signature is correct, you only need the public key (that point on the curve that was generated using the private key) and you put that into another magical equation with one part of the signature (S), and if it was signed correctly using the the private key, it will give you the other part of the signature (R). So to make it short, a signature consists of two numbers,&nbsp;R&nbsp;and&nbsp;S, and you use a private key to generate&nbsp;R&nbsp;and&nbsp;S, and if a mathematical equation using the public key and&nbsp;Sgives you&nbsp;R, then the signature is valid. There is no way to know the private key or to create a signature using only the public key. Alright, now for the more in depth understanding, I suggest you take an aspirin right now as this might hurt!&nbsp; Let’s start with the basics (which may be boring for people who know about it, but is mandatory for those who don’t) : ECDSA uses only integer mathematics, there are no floating points (this means possible values are 1, 2, 3, etc.. but not 1.5..), &nbsp;also, the range of the numbers is bound by how many bits are used in the signature (more bits means higher numbers, means more security as it becomes harder to ‘guess’ the critical numbers used in the equation), as you should know, computers use ‘bits’ to represent data, a bit is a ‘digit’ in binary notation (0 and 1) and 8 bits represent one byte. Every time you add one bit, the maximum number that can be represented doubles, with 4 bits you can represent values 0 to 15 (for a total of 16 possible values), with 5 bits, you can represent 32 values, with 6 bits, you can represent 64 values, etc.. one byte (8 bits) can represent 256 values, and 32 bits can represent 4294967296 values (4 Giga).. Usually ECDSA will use 160 bits total, so that makes… well, a very huge number with 49 digits in it… ECDSA&nbsp;is used with a&nbsp;SHA1&nbsp;cryptographic hash&nbsp;of the message to sign (the file). A&nbsp;hash&nbsp;is simply another mathematical equation that you apply on every byte of data which will give you a number that is unique to your data. Like for example, the sum of the values of all bytes may be considered a very dumb hash function. So if anything changes in the message (the file) then the hash will be completely different. In the case of the SHA1 hash algorithm, it will always be 20 bytes (160 bits). It’s very useful to validate that a file has not been modified or corrupted, you get the 20 bytes hash for a file of any size, and you can easily recalculate that hash to make sure it matches. What ECDSA signs is actually that hash, so if the data changes, the hash changes, and the signature isn’t valid anymore. Now, how does it work? Well&nbsp;Elliptic Curve cryptography&nbsp;is based on an equation of the form : y^2 = (x^3 + a * x + b) mod p First thing you notice is that there is a modulo and that the ‘y‘ is a square. This means that for anyx&nbsp;coordinate, you will have two values of&nbsp;y&nbsp;and that the curve is symmetric on the&nbsp;X axis. The modulo is a prime number and makes sure that all the values are within our range of 160 bits and it allows the use of “modular square root” and “modular multiplicative inverse” mathematics which make calculating stuff easier (I think). Since we have a modulo (p) , it means that the possible values of&nbsp;y^2&nbsp;are between &nbsp;0 and&nbsp;p-1, which gives us&nbsp;p&nbsp;total possible values. However, since we are dealing with integers, only a smaller subset of those values will be a “perfect square” (the square value of two integers), which gives us&nbsp;N&nbsp;possible points on the curve where&nbsp;N &lt; p&nbsp;(N&nbsp;being the number of perfect squares between 0 and&nbsp;p). Since each&nbsp;x&nbsp;will yield two points (positive and negative values of the square-root of&nbsp;y^2), this means that there are&nbsp;N/2&nbsp;possible ‘x‘ coordinates that are valid and that give a point on the curve. So this elliptic curve has a finite number of points on it, and it’s all because of the integer calculations and the modulus. Another thing you need to know about&nbsp;Elliptic curves, is the notion of “point addition“. It is defined as adding one point&nbsp;P&nbsp;to another point&nbsp;Q&nbsp;will lead to a point&nbsp;S&nbsp;such that if you draw a line from&nbsp;P&nbsp;to&nbsp;Q, it will intersect the curve on a third point&nbsp;R&nbsp;which is the negative value of&nbsp;S&nbsp;(remember that the curve is symmetric on the&nbsp;X axis). In this case, we define&nbsp;R = -S&nbsp;to represent the symmetrical point of&nbsp;R&nbsp;on the&nbsp;X axis. This is easier to illustrate with an image :So you can see a curve of the form&nbsp;y^2 = x^3 + ax + b&nbsp;(where&nbsp;a = -4&nbsp;and&nbsp;b = 0), which is symmetric on the&nbsp;X axis, and where&nbsp;P+Q&nbsp;is the symmetrical point through&nbsp;X&nbsp;of the point&nbsp;R&nbsp;which is the third intersection of a line going from&nbsp;P&nbsp;to&nbsp;Q. In the same manner, if you do&nbsp;P + P, &nbsp;it will be the symmetrical point of&nbsp;R&nbsp;which is the intersection of the line that is a tangent to the point&nbsp;P.. AndP + P + P&nbsp;is the addition between the resulting point of&nbsp;P+P&nbsp;with the point&nbsp;P&nbsp;since&nbsp;P + P + P&nbsp;can be written as&nbsp;(P+P) + P.. This defines the “point multiplication” where&nbsp;k*P&nbsp;is the addition of the point&nbsp;P&nbsp;to itself&nbsp;k&nbsp;times… here are two examples showing this :&nbsp; Here, you can see two elliptic curves, and a point&nbsp;P&nbsp;from which you draw the tangent, it intersects the curve with a third point, and its symmetric point it&nbsp;2P, then from there, you draw a line from&nbsp;2Pand&nbsp;P&nbsp;and it will intersect the curve, and the symmetrical point is&nbsp;3P. etc… you can keep doing that for the point multiplication. You can also already guess why you need to take the symmetric point of&nbsp;R&nbsp;when doing the addition, otherwise, multiple additions of the same point will always give the same line and the same three intersections. One particularity of this point multiplication is that if you have a point&nbsp;R = k*P, where you know&nbsp;Rand you know&nbsp;P, there is no way to find out what the value of ‘k‘ is. Since there is no point subtraction or point division, you cannot just resolve&nbsp;k = R/P. Also, since you could be doing millions of &nbsp;point additions, you will just end up on another point on the curve, and you’d have no way of knowing “how” you got there. You can’t reverse this operation, and you can’t find the value ‘k‘ which was multiplied with your point&nbsp;P&nbsp;to give you the resulting point&nbsp;R. This thing where you can’t find the multiplicand even when you know the original and destination points is the whole basis of the security behind the ECDSA algorithm, and the principle is called a “trap door function“. Now that we’ve handled the “basics”, let’s talk about the actual ECDSA signature algorithm. For ECDSA, you first need to know your curve parameters, those are&nbsp;a, b, p, N&nbsp;and&nbsp;G. You already know that ‘a‘ and ‘b‘ are the parameters of the curve function (y^2 = x^3 + ax + b), that ‘p‘ is the prime modulus, &nbsp;and that ‘N‘ is the number of points of the curve, but there is also ‘G‘ that is needed for ECDSA, and it represents a ‘reference point’ or a point of origin if you prefer. Those curve parameters are important and without knowing them, you obviously can’t sign or verify a signature. Yes, verifying a signature isn’t just about knowing the public key, you also need to know the curve parameters for which this public key is derived from. So first of all, you will have a private and a public key.. the private key is a random number (of 20 bytes) that is generated, and the public key is a point on the curve generated from the point multiplication of&nbsp;G&nbsp;with the private key. We set ‘dA‘ as the private key (random number) and ‘Qa‘ as the public key (a point), so we have :&nbsp;Qa = dA * G&nbsp;(where&nbsp;G&nbsp;is the point of reference in the curve parameters). So how do you sign a file/message ? First, you need to know that the signature is 40 bytes and is represented by two values of 20 bytes each, the first one is called&nbsp;R&nbsp;and the second one is called&nbsp;S.. so the pair&nbsp;(R, S)&nbsp;together is your ECDSA signature.. now here’s how you can create those two values in order to sign a file.. first you must generate a random value ‘k‘ (of 20 byes), and use point multiplication to calculate the point&nbsp;P=k*G. That point’s&nbsp;x&nbsp;value will represent ‘R‘. Since the point on the curve&nbsp;P&nbsp;is represented by its&nbsp;(x, y)&nbsp;coordinates (each being 20 bytes long), you only need the ‘x‘ value (20 bytes) for the signature, and that value will be called ‘R‘. Now all you need is the ‘S‘ value. To calculate&nbsp;S, you must make a SHA1 hash of the message, this gives you a 20 bytes value that you will consider as a very huge integer number and we’ll call it ‘z‘. Now you can calculate&nbsp;S&nbsp;using the equation : S = k^-1 (z + dA * R) mod p Note here the&nbsp;k^-1&nbsp;which is the ‘modular multiplicative inverse‘ of&nbsp;k… it’s basically the inverse ofk, but since we are dealing with integer numbers, then that’s not possible, so it’s a number such that&nbsp;(k^-1 * k ) mod p&nbsp;is equal to 1. And again, I remind you that&nbsp;k&nbsp;is the random number used to generate&nbsp;R,&nbsp;z&nbsp;is the hash of the message to sign,&nbsp;dA&nbsp;is the private key and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate ofk*G&nbsp;(where&nbsp;G&nbsp;is the point of origin of the curve parameters). Now that you have your signature, you want to verify it, it’s also quite simple, and you only need the public key (and curve parameters of course) to do that. You use this equation to calculate a point&nbsp;P&nbsp;: P= &nbsp;S^-1*z*G + S^-1 * R * Qa If the&nbsp;x&nbsp;coordinate of the point&nbsp;P&nbsp;is equal to&nbsp;R, that means that the signature is valid, otherwise it’s not. Pretty simple, huh? now let’s see why and how… and this is going to require some mathematics to verify : We have : P = S^-1*z*G + S^-1 * R *Qa but&nbsp;Qa = dA*G, so: P = S^-1*z*G + S^-1 * R * dA*G = S^-1 (z + dA* R) * G But the&nbsp;x&nbsp;coordinate of&nbsp;P&nbsp;must match&nbsp;R&nbsp;and&nbsp;R&nbsp;is the&nbsp;x&nbsp;coordinate of&nbsp;k * G, which means that : k*G = S^-1 (z + dA * R) *G we can simplify by removing&nbsp;G&nbsp;which gives us : k = S^-1(z + dA * R) by inverting&nbsp;k&nbsp;and&nbsp;S, we get : S = k^-1 (z + dA *R) and that is the equation used to generate the signature.. so it matches, and that is the reason why you can verify the signature with it. You can note that you need both ‘k‘ (random number) and ‘dA‘ (the private key) in order to calculate&nbsp;S, but you only need&nbsp;R&nbsp;and&nbsp;Qa&nbsp;(public key) to validate the signature. And since&nbsp;R=k*G&nbsp;andQa = dA*G&nbsp;and because of the trap door function in the ECDSA point multiplication (explained above), we cannot calculate&nbsp;dA&nbsp;or&nbsp;k&nbsp;from knowing&nbsp;Qa&nbsp;and&nbsp;R, this makes the ECDSA algorithm secure, there is no way of finding the private keys, and there is no way of faking a signature without knowing the private key. The ECDSA algorithm is used everywhere and has not been cracked and it is a vital part of most of today’s security. Now I’ll discuss on how and why the ECDSA signatures that Sony &nbsp;used in the PS3 were faulty and how it allowed us to gain access to their private key. So you remember the equations needed to generate a signature..&nbsp;R = k*G&nbsp;and&nbsp;S= k^-1(z + dA*R) mod p.. well this equation’s strength is in the fact that you have one equation with two unknowns (k&nbsp;and&nbsp;dA) so there is no way to determine either one of those. However, the security of the algorithm is based on its implementation and it’s important to make sure that ‘k‘ is randomly generated and that there is no way that someone can guess, calculate, or use a timing attack or any other type of attack in order to find the random value ‘k‘. But Sony made a huge mistake in their implementation, they used the same value for ‘k‘ everywhere, which means that if you have two signatures, both with the same&nbsp;k, then they will both have the same&nbsp;R&nbsp;value, and it means that you can calculate&nbsp;k&nbsp;using two&nbsp;S&nbsp;signatures of two files with hashes&nbsp;z&nbsp;and&nbsp;z’&nbsp;and signatures&nbsp;S&nbsp;and&nbsp;S’respectively : S – S’ = k^-1 (z + dA*R) – k^-1 (z’ + da*R) = k^-1 (z + da*R – z’ -dA*R) = k^-1 (z – z’) So :&nbsp;k = (z – z’) / (S – S’) Once you know&nbsp;k, then the equation &nbsp;for&nbsp;S&nbsp;because one equation with one unknown and is then easily resolved for&nbsp;dA&nbsp;: dA = (S*k – z) / R Once you know the private key&nbsp;dA, you can now sign your files and the PS3 will recognize it as an authentic file signed by Sony. This is why it’s important to make sure that the random number used for generating the signature is actually “cryptographically random”. &nbsp;This is also the reason why it is impossible to have a custom firmware above 3.56, simply because since the 3.56 version, Sony have fixed their ECDSA algorithm implementation and used new keys for which it is impossible to find the private key.. if there was a way to find that key, then the security of every computer, website, system may be compromised since a lot of systems are relying on ECDSA for their security, and it is impossible to crack. Finally! I hope this makes the whole algorithm clearer to many of you.. I know that this is still very complicated and hard to understand. I usually try to make things easy to understand for non technical people, but this algorithm is too complex to be able to explain in any simpler terms. After all that’s why I prefer to call it the MFET algorithm (Mathematics For Extra Terrestrials)&nbsp; But if you are a developer or a mathematician or someone interested in learning about this because you want to help or simple gain knowledge, then I’m sure that this contains enough information for you to get started or to at least understand the concept behind this unknown beast called “ECDSA”. That being said, I’d like to thank a few people who helped me understand all of this, one particularly who wishes to remain anonymous, as well as the many wikipedia pages I linked to throughout this article, and Avi Kak thanks to&nbsp;his paper&nbsp;explaining the mathematics behind ECDSA, and from which I have taken those graph images aboves. P.s: In this article, I used ’20 bytes’ in my text to talk about the ECDSA signature because that’s what is usually used as it matches the SHA1 hash size of 20 bytes and that’s what the PS3 security uses, but the algorithm itself can be used with any size of numbers. There may be other inaccuracies in this article, but like I said, I’m not an expert, I just barely learned all of this in the past week. 以下内容转载在实验篇： Recovering Bitcoin private keys using weak signatures from the blockchain On December 25th of last year I discovered a potential weakness in some Bitcoin implementations. Have a look at this transaction: transaction: 9ec4bc49e828d924af1d1029cacf709431abbde46d59554b62bc270e3b29c4b1 input script 1: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1022044e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff input script 2: 30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad102209a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff This transactions has two inputs and one output. If you look closely at the two input scripts you will notice there are quite a few equal bytes at the start and at the end. Those bytes at the end is the hex-encoded public key of the address spending the coins so there’s nothing wrong with that. However, the first half of the script is the actual signature (r, s): r1: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 r2: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1: 44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2: 9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab As you can see, r1 equals r2. This is a huge problem. We’ll be able to&nbsp;recover the private&nbsp;key to this public key: private key = (z1*s2 - z2*s1)/(r*(s1-s2)) We just need to find z1 and z2! These are the hashes of the outputs to be signed. Let’s fetch the output transations and calculate them (it is calculated by OP_CHECKSIG): z1: c0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2: 17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc That’s it. Let’s setup our&nbsp;sage&nbsp;notebook like this: p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 r = 0xd47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1 s1 = 0x44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e s2 = 0x9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab z1 = 0xc0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e z2 = 0x17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc p is just the order of G, a parameter of the secp256k1 curve used by Bitcoin. Let’s create a field for our calculations: K = GF(p) And calculate the private key within this field: K((z1*s2 - z2*s1)/(r*(s1-s2))) 88865298299719117682218467295833367085649033095698151055007620974294165995414 Convert it to a more suitable format: hex: c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96 WIF: 5KJp7KEffR7HHFWSFYjiCUAntRSTY69LAQEX1AUzaSBHHFdKEpQ And import it to your favourite Bitcoin wallet. It’ll calculate the correct bitcoin address and you’ll be able to spend coins send to this address. There are a few vulnerable bitcoin addresses in the blockchain. After some research I was able to contact the owner of this address. He allowed me to spend the funds. Why did this work? ECDSA requires a random number for each signature. If this random number is ever used twice with the same private key it can be recovered. This transaction was generated by a hardware bitcoin wallet using a pseudo-random number generator that was returning the same “random” number every time. 阅读更多","@type":"BlogPosting","url":"/2014/07/17/58e225a31c9940ecf648aa98a07852c3.html","headline":"【比特币】椭圆曲线数字签名算法-ECDSA","dateModified":"2014-07-17T00:00:00+08:00","datePublished":"2014-07-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2014/07/17/58e225a31c9940ecf648aa98a07852c3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【比特币】椭圆曲线数字签名算法-ECDSA</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>参考：</p> 
  <p><a href="https://github.com/openssl/openssl/blob/master/crypto/ecdsa/ecdsa.h" rel="nofollow">https://github.com/openssl/openssl/blob/master/crypto/ecdsa/ecdsa.h</a><br></p> 
  <p>原理篇：</p> 
  <p><a href="http://kakaroto.homelinux.net/2012/01/how-the-ecdsa-algorithm-works/" rel="nofollow">http://kakaroto.homelinux.net/2012/01/how-the-ecdsa-algorithm-works/</a><br></p> 
  <p>实验篇：</p> 
  <p><a href="http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html" rel="nofollow">http://www.nilsschneider.net/2013/01/28/recovering-bitcoin-private-keys.html</a><br></p> 
  <p><br></p> 
  <p>Makefile</p> 
  <p></p> 
  <pre><code class="language-cpp">.PHONY:all
	
all:
	gcc -I/d/workspace/github/altcoin/bitcoin-3rd/ssl/include -o sigvery -g -O0 sigvery.c -L/d/workspace/github/altcoin/bitcoin-3rd/ssl/lib -lssl -lcrypto -lgdi32</code></pre>
  <br> Code: 
  <p></p> 
  <p></p> 
  <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


#include &lt;openssl/opensslconf.h&gt;
#include &lt;openssl/ec.h&gt;
#include &lt;openssl/bn.h&gt;
#include &lt;openssl/ecdsa.h&gt;




int main(int argc, char * argv []){
&nbsp; &nbsp; // First step: create a EC_KEY object (note: this part is not ECDSA specific)
&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;ret;
&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp;nid;
&nbsp; &nbsp; ECDSA_SIG *sig;
&nbsp; &nbsp; EC_KEY &nbsp; &nbsp;*eckey;
&nbsp; &nbsp; unsigned char digest [20];
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; memset(digest, 0xaa, sizeof(digest));// 测试用的假HASH
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; nid = OBJ_sn2nid("secp256k1");
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; eckey = EC_KEY_new_by_curve_name(nid);
&nbsp; &nbsp; if (eckey == NULL)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* error */
&nbsp; &nbsp; &nbsp; &nbsp; perror("EC_KEY_new_by_curve_name");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; if (!EC_KEY_generate_key(eckey))
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* error */
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; else
&nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下ec的私钥和公钥
&nbsp; &nbsp; &nbsp; &nbsp; EC_KEY_print_fp(stdout, eckey, 0);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; // Second step: compute the ECDSA signature of a SHA-1 hash value using ECDSA_do_sign


&nbsp; &nbsp; sig = ECDSA_do_sign(digest, 20, eckey);// 签名
&nbsp; &nbsp; if (sig == NULL)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* error */
&nbsp; &nbsp; &nbsp; &nbsp; perror("ECDSA_do_sign");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; else
&nbsp; &nbsp; &nbsp; &nbsp; {// 打印一下签名，r和s
&nbsp; &nbsp; &nbsp; &nbsp; printf("Signature:\n\tr=%s\n\ts=%s\n", BN_bn2hex(sig-&gt;r), BN_bn2hex(sig-&gt;s));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; // Third step: verify the created ECDSA signature using ECDSA_do_verify &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = ECDSA_do_verify(digest, 20, sig, eckey);// 验证
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; if (ret == -1)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* error */
&nbsp; &nbsp; &nbsp; &nbsp; perror("ECDSA_do_verify");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; else if (ret == 0)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* incorrect signature */
&nbsp; &nbsp; &nbsp; &nbsp; printf("Verified Failure\n");
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; else &nbsp; /* ret == 1 */
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; /* signature ok */
&nbsp; &nbsp; &nbsp; &nbsp; printf("Verified OK\n");
&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;
&nbsp; &nbsp; return 0;
}


</code></pre>
  <br>
  <p><br></p> 
  <p>测试：</p> 
  <p>HASH=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; // 20个字节的0xaa</p> 
  <p></p> 
  <pre><code class="language-cpp">$ ./sigvery.exe
Private-Key: (256 bit)
priv:
    00:95:55:33:26:d8:92:cd:58:d7:7b:71:b8:02:29:
    36:41:9a:22:e9:f0:21:72:02:a7:fc:1e:05:a3:f5:
    6e:f4:ec
pub:
    04:76:91:81:fd:2e:44:e0:17:03:b3:53:7d:55:fe:
    e2:f5:6a:89:d1:5b:2c:e2:06:83:6a:e5:64:b6:4b:
    07:76:8c:8b:df:57:7b:75:7b:f6:fb:9c:44:6f:1b:
    f6:56:ff:ac:ed:2f:65:a9:49:81:ba:af:90:13:8f:
    96:a3:9e:83:9f
Field Type: prime-field
Prime:
    00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
    ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff:
    ff:fc:2f
A:    0
B:    7 (0x7)
Generator (uncompressed):
    04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87:
    0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16:
    f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc:
    0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0:
    8f:fb:10:d4:b8
Order:
    00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:
    ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0:
    36:41:41
Cofactor:  1 (0x1)
Signature:
        r=F0AB42A05A1C7CB18EF50A0E63CF287B3604A3741D6875DADE9031E648055E7D
        s=4C556EDC930313C67286A7B7AD7BC336FB39C0BA4BC42BE801FBBE8CBDCD0012
Verified OK</code></pre>
  <br>
  <br>
  <p></p> 
  <p><br></p> 
  <p></p> 
  <p>比特币目前使用ECDSA对货币的所有权进行鉴定，当然前提是对于付款地址是椭圆曲线算法的公钥(secp256k1 for bitcoin)。</p> 
  <p><br></p> 
  <p>如果是puzzle类型等非标准的付款方式，那么resolve的方式就不是签名/验证的形式了，那就要看脚本的设置到底需要什么的推理前提了。</p> 
  <p><br></p> 
  <p>关于签名算法的细节可以参考<a href="http://en.wikipedia.org/wiki/Elliptic_Curve_DSA" rel="nofollow">wiki上bob&amp;alice的签名验证</a>例子。</p> 
  <p><br></p> 
  <p>比特币的源代码使用CECKey结构对openssl的ec算法进行了封装。</p> 
  <p><br></p> 
  <p>在此基础上衍生了其他密钥管理对象，CPubKey, CKeyID, CScriptID, CPrivKey, CKey</p> 
  <p><br></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20140722144033703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFjb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p> 
  <p><br></p> 
  <h1>1) CKey</h1> 
  <p>对openssl中的ecdsa算法的基本封装，是整个算法的核心。</p> 
  <p><br></p> 
  <p>CKey可以导入通过SetPrivKey()/GetPrivKey()导入/导出openssl格式的私钥。</p> 
  <p></p> 
  <pre><code class="language-cpp">    // Initialize from a CPrivKey (serialized OpenSSL private key data).
    bool SetPrivKey(const CPrivKey &amp;vchPrivKey, bool fCompressed);
</code></pre>
  <pre><code class="language-cpp">    // Convert the private key to a CPrivKey (serialized OpenSSL private key data).
    // This is expensive.
    CPrivKey GetPrivKey() const;</code></pre>
  <br> CKey可以通过GetPubKey()导出公钥（压缩格式或者非压缩格式的，根据内部标记来决定） 
  <p></p> 
  <p></p> 
  <pre><code class="language-cpp">    // Compute the public key from a private key.
    // This is expensive.
    CPubKey GetPubKey() const;</code></pre>
  <br> CKey可以通过Sign()来签署消息摘要 
  <p></p> 
  <p></p> 
  <pre><code class="language-cpp">    // Create a DER-serialized signature.
    bool Sign(const uint256 &amp;hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const;
</code></pre>
  <br>
  <h1>2) CPubKey</h1> 
  <p><br></p> 
  <p>对openssl中的ecdsa算法的公钥的基本封装，可以由CKey的成员函数计算得到。</p> 
  <p><br></p> 
  <p>CPubKey可以通过GetID()调用来计算得到该公钥对应的索引（也就是该公钥的hash256/ripemd160的hash）</p> 
  <p></p> 
  <pre><code class="language-cpp">    // Get the KeyID of this public key (hash of its serialization)
    CKeyID GetID() const {
        return CKeyID(Hash160(vch, vch+size()));
    }
</code></pre>
  <br> CPubKey可以通过Verify()来验证CKey的签名 
  <p></p> 
  <p></p> 
  <pre><code class="language-cpp">    // Verify a DER signature (~72 bytes).
    // If this public key is not fully valid, the return value will be false.
    bool Verify(const uint256 &amp;hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const;
</code></pre>
  <br>
  <h1>3）CScript</h1> 
  <p><br></p> 
  <p>对支付脚本的状态机的封装</p> 
  <p><br></p> 
  <p>CScript可以通过GetID()来获取序列化的脚本的索引（hash值）</p> 
  <p></p> 
  <pre><code class="language-cpp">    CScriptID GetID() const
    {
        return CScriptID(Hash160(*this));
    }</code></pre>
  <br>
  <p><br></p> 
  <h1>4）CScriptID&nbsp;</h1> 
  <p>支付脚本script的索引的封装,20字节hash值</p> 
  <p><br></p> 
  <h1>5) &nbsp;CPubKeyID</h1> 
  <p>支付公钥的索引的封装,&nbsp;20字节hash值</p> 
  <p><br></p> 
  <h1>6）CBitcoinAddress</h1> 
  <p>版本和索引值的封装</p> 
  <p><br></p> 
  <p>可以以base58格式操作2类钱包地址；</p> 
  <p>地址可以是脚本，也可以是公钥，对应的分别是脚本的id和公钥的id，CSriptID, CPubKeyID</p> 
  <p><br></p> 
  <h1>7) CBitCoinSecret</h1> 
  <p>对私钥base58格式的封装</p> 
  <p>可以以base58格式操作私钥。</p> 
  <p><br></p> 
  <p><br></p> 
  <p>openssl ecdsa算法实践</p> 
  <p>1) 列举所有已经实现的算法曲线</p> 
  <p></p> 
  <pre><code class="language-cpp">gentoobox harrywu # openssl ecparam -list_curves
  secp112r1 : SECG/WTLS curve over a 112 bit prime field
  secp112r2 : SECG curve over a 112 bit prime field
  secp128r1 : SECG curve over a 128 bit prime field
  secp128r2 : SECG curve over a 128 bit prime field
  secp160k1 : SECG curve over a 160 bit prime field
  secp160r1 : SECG curve over a 160 bit prime field
  secp160r2 : SECG/WTLS curve over a 160 bit prime field
  secp192k1 : SECG curve over a 192 bit prime field
  secp224k1 : SECG curve over a 224 bit prime field
  secp224r1 : NIST/SECG curve over a 224 bit prime field
  secp256k1 : SECG curve over a 256 bit prime field
  secp384r1 : NIST/SECG curve over a 384 bit prime field
  secp521r1 : NIST/SECG curve over a 521 bit prime field
  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field
  prime192v2: X9.62 curve over a 192 bit prime field
  prime192v3: X9.62 curve over a 192 bit prime field
  prime239v1: X9.62 curve over a 239 bit prime field
  prime239v2: X9.62 curve over a 239 bit prime field
  prime239v3: X9.62 curve over a 239 bit prime field
  prime256v1: X9.62/SECG curve over a 256 bit prime field
  sect113r1 : SECG curve over a 113 bit binary field
  sect113r2 : SECG curve over a 113 bit binary field
  sect131r1 : SECG/WTLS curve over a 131 bit binary field
  sect131r2 : SECG curve over a 131 bit binary field
  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field
  sect163r1 : SECG curve over a 163 bit binary field
  sect163r2 : NIST/SECG curve over a 163 bit binary field
  sect193r1 : SECG curve over a 193 bit binary field
  sect193r2 : SECG curve over a 193 bit binary field
  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field
  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field
  sect239k1 : SECG curve over a 239 bit binary field
  sect283k1 : NIST/SECG curve over a 283 bit binary field
  sect283r1 : NIST/SECG curve over a 283 bit binary field
  sect409k1 : NIST/SECG curve over a 409 bit binary field
  sect409r1 : NIST/SECG curve over a 409 bit binary field
  sect571k1 : NIST/SECG curve over a 571 bit binary field
  sect571r1 : NIST/SECG curve over a 571 bit binary field
  c2pnb163v1: X9.62 curve over a 163 bit binary field
  c2pnb163v2: X9.62 curve over a 163 bit binary field
  c2pnb163v3: X9.62 curve over a 163 bit binary field
  c2pnb176v1: X9.62 curve over a 176 bit binary field
  c2tnb191v1: X9.62 curve over a 191 bit binary field
  c2tnb191v2: X9.62 curve over a 191 bit binary field
  c2tnb191v3: X9.62 curve over a 191 bit binary field
  c2pnb208w1: X9.62 curve over a 208 bit binary field
  c2tnb239v1: X9.62 curve over a 239 bit binary field
  c2tnb239v2: X9.62 curve over a 239 bit binary field
  c2tnb239v3: X9.62 curve over a 239 bit binary field
  c2pnb272w1: X9.62 curve over a 272 bit binary field
  c2pnb304w1: X9.62 curve over a 304 bit binary field
  c2tnb359v1: X9.62 curve over a 359 bit binary field
  c2pnb368w1: X9.62 curve over a 368 bit binary field
  c2tnb431r1: X9.62 curve over a 431 bit binary field
  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field
  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field
  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field
  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field
  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field
  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field
  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field
  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field
  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field
  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field
  wap-wsg-idm-ecid-wtls12: WTLS curvs over a 224 bit prime field
  Oakley-EC2N-3: 
	IPSec/IKE/Oakley curve #3 over a 155 bit binary field.
	Not suitable for ECDSA.
	Questionable extension field!
  Oakley-EC2N-4: 
	IPSec/IKE/Oakley curve #4 over a 185 bit binary field.
	Not suitable for ECDSA.
	Questionable extension field!</code></pre>
  <br> 比特币选取了 
  <p></p> 
  <p></p> 
  <pre><code class="language-cpp">  secp256k1 : SECG curve over a 256 bit prime field</code></pre>
  <br>
  <p></p> 
  <p>以下内容转载自原理篇</p> 
  <p></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> To popular demand, I have decided to try and explain how the&nbsp;<a href="http://en.wikipedia.org/wiki/ECDSA" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">ECDSA</a>&nbsp;algorithm works. I’ve been struggling a bit to understand it properly and while I found a lot of documentation about it, I haven’t really found any “ECDSA for newbies” anywhere. So I thought it would be good to explain in simple terms how it works so others can learn from my research. I have found some websites that explain the basic principles but nowhere near enough to actually understand it, others that explains things without any basics, making it incomprehensible, and others that go way too deep into the the mathematics behind it.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> ECDSA stands for “Elliptic Curve Digital Signature Algorithm”, it’s used to create a&nbsp;<a href="http://en.wikipedia.org/wiki/Digital_signature" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">digital signature</a>of data (a file for example) in order to allow you to verify its authenticity without compromising its security. Think of it like a real signature, you can recognize someone’s signature, but you can’t forge it without others knowing. The ECDSA algorithm is basically all about mathematics.. so I think it’s important to start by saying : “hey kids, don’t slack off at school, listen to your teachers, that stuff might be useful for you some day!”&nbsp;<img src="http://kakaroto.homelinux.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" style="border:none;vertical-align:baseline;background:transparent;">&nbsp;But these maths are fairly complicated, so while I’ll try to vulgarize it and make it understandable for non technical people, you will still probably need some knowledge in mathematics to understand it properly. I will do this in two parts, one that is a sort of high level explanation about how it works, and another where I dig deeper into its inner workings to complete your understanding. Note however that I’ve just recently learned this stuff, so I’m definitely not an expert on the matter.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> So the principle is simple, you have a mathematical equation which draws a curve on a graph, and you choose a random point on that curve and consider that your point of origin. Then you generate a random number, this is your private key, you do some magical mathematical equation using that random number and that “point of origin” and you get a second point on the curve, that’s your public key. When you want to sign a file, you will use this private key (the random number) with a hash of the file (a unique number to represent the file) into a magical equation and that will give you your signature. The signature itself is divided into two parts, called&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>. In order to verify that the signature is correct, you only need the public key (that point on the curve that was generated using the private key) and you put that into another magical equation with one part of the signature (<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>), and if it was signed correctly using the the private key, it will give you the other part of the signature (<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>). So to make it short, a signature consists of two numbers,&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>, and you use a private key to generate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>, and if a mathematical equation using the public key and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>gives you&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>, then the signature is valid. There is no way to know the private key or to create a signature using only the public key.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Alright, now for the more in depth understanding, I suggest you take an aspirin right now as this might hurt!&nbsp;<img src="http://kakaroto.homelinux.net/wp-includes/images/smilies/icon_razz.gif" alt=":P" class="wp-smiley" style="border:none;vertical-align:baseline;background:transparent;"></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Let’s start with the basics (which may be boring for people who know about it, but is mandatory for those who don’t) : ECDSA uses only integer mathematics, there are no floating points (this means possible values are 1, 2, 3, etc.. but not 1.5..), &nbsp;also, the range of the numbers is bound by how many bits are used in the signature (more bits means higher numbers, means more security as it becomes harder to ‘guess’ the critical numbers used in the equation), as you should know, computers use ‘bits’ to represent data, a bit is a ‘digit’ in binary notation (0 and 1) and 8 bits represent one byte. Every time you add one bit, the maximum number that can be represented doubles, with 4 bits you can represent values 0 to 15 (for a total of 16 possible values), with 5 bits, you can represent 32 values, with 6 bits, you can represent 64 values, etc.. one byte (8 bits) can represent 256 values, and 32 bits can represent 4294967296 values (4 Giga).. Usually ECDSA will use 160 bits total, so that makes… well, a very huge number with 49 digits in it…</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <a href="http://en.wikipedia.org/wiki/ECDSA" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">ECDSA</a>&nbsp;is used with a&nbsp;<a href="http://en.wikipedia.org/wiki/Sha1" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">SHA1</a>&nbsp;<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">cryptographic hash</a>&nbsp;of the message to sign (the file). A&nbsp;<a href="http://en.wikipedia.org/wiki/Hash_function" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">hash</a>&nbsp;is simply another mathematical equation that you apply on every byte of data which will give you a number that is unique to your data. Like for example, the sum of the values of all bytes may be considered a very dumb hash function. So if anything changes in the message (the file) then the hash will be completely different. In the case of the SHA1 hash algorithm, it will always be 20 bytes (160 bits). It’s very useful to validate that a file has not been modified or corrupted, you get the 20 bytes hash for a file of any size, and you can easily recalculate that hash to make sure it matches. What ECDSA signs is actually that hash, so if the data changes, the hash changes, and the signature isn’t valid anymore.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Now, how does it work? Well&nbsp;<a href="http://en.wikipedia.org/wiki/Elliptic_curve_cryptography" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">Elliptic Curve cryptography</a>&nbsp;is based on an equation of the form :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;text-align:center;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y^2 = (x^3 + a * x + b) mod p</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> First thing you notice is that there is a modulo and that the ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y</span></span>‘ is a square. This means that for any<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;coordinate, you will have two values of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y</span></span>&nbsp;and that the curve is symmetric on the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;">X axis</span>. The modulo is a prime number and makes sure that all the values are within our range of 160 bits and it allows the use of “<a href="http://en.wikipedia.org/wiki/Modular_square_root" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">modular square root</a>” and “<a href="http://en.wikipedia.org/wiki/Modular_multiplicative_inverse" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">modular multiplicative inverse</a>” mathematics which make calculating stuff easier (I think). Since we have a modulo (<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">p</span></span>) , it means that the possible values of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y^2</span></span>&nbsp;are between &nbsp;0 and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">p</span></span>-1, which gives us&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">p</span></span>&nbsp;total possible values. However, since we are dealing with integers, only a smaller subset of those values will be a “<a href="http://en.wikipedia.org/wiki/Square_number" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">perfect square</a>” (the square value of two integers), which gives us&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">N</span></span>&nbsp;possible points on the curve where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">N &lt; p</span></span>&nbsp;(<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">N</span></span>&nbsp;being the number of perfect squares between 0 and<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">&nbsp;p</span></span>). Since each&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x&nbsp;</span></span>will yield two points (positive and negative values of the square-root of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y^2</span></span>), this means that there are&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">N/2</span></span>&nbsp;possible ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>‘ coordinates that are valid and that give a point on the curve. So this elliptic curve has a finite number of points on it, and it’s all because of the integer calculations and the modulus. Another thing you need to know about&nbsp;<a href="http://en.wikipedia.org/wiki/Elliptic_curve" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">Elliptic curves</a>, is the notion of “<a href="http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">point addition</a>“. It is defined as adding one point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;to another point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Q</span></span>&nbsp;will lead to a point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;such that if you draw a line from&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;to&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Q</span></span>, it will intersect the curve on a third point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;which is the negative value of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;(remember that the curve is symmetric on the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;">X axis</span>). In this case, we define&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R = -S</span></span>&nbsp;to represent the symmetrical point of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;on the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;">X axis</span>. This is easier to illustrate with an image :<a href="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa1.png" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;"><img class="aligncenter size-medium wp-image-465" title="ecdsa1" src="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa1-300x251.png" alt="" style="border:none;vertical-align:baseline;display:block;background:transparent;"></a>So you can see a curve of the form&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y^2 = x^3 + ax + b</span></span>&nbsp;(where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">a = -4</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">b = 0</span></span>), which is symmetric on the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;">X axis</span>, and where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P+Q</span></span>&nbsp;is the symmetrical point through&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;">X</span>&nbsp;of the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;which is the third intersection of a line going from&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;to&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Q</span></span>. In the same manner, if you do&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P + P</span></span>, &nbsp;it will be the symmetrical point of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;which is the intersection of the line that is a tangent to the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>.. And<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P + P + P</span></span>&nbsp;is the addition between the resulting point of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P+P</span></span>&nbsp;with the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;since&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P + P + P</span></span>&nbsp;can be written as&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">(P+P) + P</span></span>.. This defines the “<a href="http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">point multiplication</a>” where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k*P</span></span>&nbsp;is the addition of the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;to itself&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;times… here are two examples showing this :<a href="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa3.png" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;"><img class="aligncenter size-medium wp-image-470" title="ecdsa3" src="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa3-300x242.png" alt="" style="border:none;vertical-align:baseline;display:block;background:transparent;"></a>&nbsp;<a href="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa4.png" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;"><img class="aligncenter size-medium wp-image-471" title="ecdsa4" src="http://kakaroto.homelinux.net/wp-content/uploads/2012/01/ecdsa4-300x235.png" alt="" style="border:none;vertical-align:baseline;display:block;background:transparent;"></a></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Here, you can see two elliptic curves, and a point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;from which you draw the tangent, it intersects the curve with a third point, and its symmetric point it&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">2P</span></span>, then from there, you draw a line from&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">2P</span></span>and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;and it will intersect the curve, and the symmetrical point is&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">3P</span></span>. etc… you can keep doing that for the point multiplication. You can also already guess why you need to take the symmetric point of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;when doing the addition, otherwise, multiple additions of the same point will always give the same line and the same three intersections.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> One particularity of this point multiplication is that if you have a point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R = k*P</span></span>, where you know&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>and you know&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>, there is no way to find out what the value of ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ is. Since there is no point subtraction or point division, you cannot just resolve&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k = R/P</span></span>. Also, since you could be doing millions of &nbsp;point additions, you will just end up on another point on the curve, and you’d have no way of knowing “how” you got there. You can’t reverse this operation, and you can’t find the value ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ which was multiplied with your point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;to give you the resulting point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> This thing where you can’t find the multiplicand even when you know the original and destination points is the whole basis of the security behind the ECDSA algorithm, and the principle is called a “<a href="http://en.wikipedia.org/wiki/Trap_door_function" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">trap door function</a>“.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Now that we’ve handled the “basics”, let’s talk about the actual ECDSA signature algorithm. For ECDSA, you first need to know your curve parameters, those are&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">a, b, p, N</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>. You already know that ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">a</span></span>‘ and ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">b</span></span>‘ are the parameters of the curve function (<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">y^2 = x^3 + ax + b</span></span>), that ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">p</span></span>‘ is the prime modulus, &nbsp;and that ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">N</span></span>‘ is the number of points of the curve, but there is also ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>‘ that is needed for ECDSA, and it represents a ‘reference point’ or a point of origin if you prefer. Those curve parameters are important and without knowing them, you obviously can’t sign or verify a signature. Yes, verifying a signature isn’t just about knowing the public key, you also need to know the curve parameters for which this public key is derived from.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> So first of all, you will have a private and a public key.. the private key is a random number (of 20 bytes) that is generated, and the public key is a point on the curve generated from the point multiplication of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>&nbsp;with the private key. We set ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>‘ as the private key (random number) and ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa</span></span>‘ as the public key (a point), so we have :&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa = dA * G</span></span>&nbsp;(where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>&nbsp;is the point of reference in the curve parameters).</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> So how do you sign a file/message ? First, you need to know that the signature is 40 bytes and is represented by two values of 20 bytes each, the first one is called&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and the second one is called&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>.. so the pair&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">(R, S)</span></span>&nbsp;together is your ECDSA signature.. now here’s how you can create those two values in order to sign a file.. first you must generate a random value ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ (of 20 byes), and use point multiplication to calculate the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P=k*G</span></span>. That point’s&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;value will represent ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>‘. Since the point on the curve&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;is represented by its&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">(x, y)</span></span>&nbsp;coordinates (each being 20 bytes long), you only need the ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>‘ value (20 bytes) for the signature, and that value will be called ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>‘. Now all you need is the ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>‘ value.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> To calculate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>, you must make a SHA1 hash of the message, this gives you a 20 bytes value that you will consider as a very huge integer number and we’ll call it ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">z</span></span>‘. Now you can calculate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;using the equation :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;text-align:center;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S = k^-1 (z + dA * R) mod p</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Note here the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k^-1</span></span>&nbsp;which is the ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><a href="http://en.wikipedia.org/wiki/Modular_multiplicative_inverse" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">modular multiplicative inverse</a></span>‘ of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>… it’s basically the inverse of<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>, but since we are dealing with integer numbers, then that’s not possible, so it’s a number such that&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">(k^-1 * k ) mod p</span></span>&nbsp;is equal to 1. And again, I remind you that&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;is the random number used to generate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>,&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">z</span></span>&nbsp;is the hash of the message to sign,&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>&nbsp;is the private key and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;is the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;coordinate of<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k*G</span></span>&nbsp;(where&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>&nbsp;is the point of origin of the curve parameters).</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Now that you have your signature, you want to verify it, it’s also quite simple, and you only need the public key (and curve parameters of course) to do that. You use this equation to calculate a point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;:</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;text-align:center;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P= &nbsp;S^-1*z*G + S^-1 * R * Qa</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> If the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;coordinate of the point&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;is equal to&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>, that means that the signature is valid, otherwise it’s not.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Pretty simple, huh? now let’s see why and how… and this is going to require some mathematics to verify :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> We have :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P = S^-1*z*G + S^-1 * R *Qa</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> but&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa = dA*G</span></span>, so:</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P = S^-1*z*G + S^-1 * R * dA*G = S^-1 (z + dA* R) * G</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> But the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;coordinate of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">P</span></span>&nbsp;must match&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;is the&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">x</span></span>&nbsp;coordinate of&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k * G</span></span>, which means that :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k*G = S^-1 (z + dA * R) *G</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> we can simplify by removing&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">G</span></span>&nbsp;which gives us :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k = S^-1(z + dA * R)</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> by inverting&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>, we get :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S = k^-1 (z + dA *R)</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> and that is the equation used to generate the signature.. so it matches, and that is the reason why you can verify the signature with it.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> You can note that you need both ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ (random number) and ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>‘ (the private key) in order to calculate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>, but you only need&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa</span></span>&nbsp;(public key) to validate the signature. And since&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R=k*G&nbsp;</span></span>and<span style="border:0px;vertical-align:baseline;background:transparent;"></span><span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa = dA*G</span></span>&nbsp;and because of the trap door function in the ECDSA point multiplication (explained above), we cannot calculate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>&nbsp;or&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;from knowing&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">Qa</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>, this makes the ECDSA algorithm secure, there is no way of finding the private keys, and there is no way of faking a signature without knowing the private key.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> The ECDSA algorithm is used everywhere and has not been cracked and it is a vital part of most of today’s security.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Now I’ll discuss on how and why the ECDSA signatures that Sony &nbsp;used in the PS3 were faulty and how it allowed us to gain access to their private key.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> So you remember the equations needed to generate a signature..&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R = k*G</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S= k^-1(z + dA*R) mod p</span></span>.. well this equation’s strength is in the fact that you have one equation with two unknowns (<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>) so there is no way to determine either one of those. However, the security of the algorithm is based on its implementation and it’s important to make sure that ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ is randomly generated and that there is no way that someone can guess, calculate, or use a timing attack or any other type of attack in order to find the random value ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘. But Sony made a huge mistake in their implementation, they used the same value for ‘<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>‘ everywhere, which means that if you have two signatures, both with the same&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>, then they will both have the same&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">R</span></span>&nbsp;value, and it means that you can calculate&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>&nbsp;using two&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;signatures of two files with hashes&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">z</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">z’</span></span>&nbsp;and signatures&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;and&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S’</span></span>respectively :</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S – S’ = k^-1 (z + dA*R) – k^-1 (z’ + da*R) = k^-1 (z + da*R – z’ -dA*R) = k^-1 (z – z’)</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> So :&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k = (z – z’) / (S – S’)</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Once you know&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">k</span></span>, then the equation &nbsp;for&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">S</span></span>&nbsp;because one equation with one unknown and is then easily resolved for&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>&nbsp;:</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> <span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA = (S*k – z) / R</span></span></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Once you know the private key&nbsp;<span style="border:0px;vertical-align:baseline;background:transparent;"><span style="border:0px;vertical-align:baseline;background:transparent;">dA</span></span>, you can now sign your files and the PS3 will recognize it as an authentic file signed by Sony. This is why it’s important to make sure that the random number used for generating the signature is actually “cryptographically random”. &nbsp;This is also the reason why it is impossible to have a custom firmware above 3.56, simply because since the 3.56 version, Sony have fixed their ECDSA algorithm implementation and used new keys for which it is impossible to find the private key.. if there was a way to find that key, then the security of every computer, website, system may be compromised since a lot of systems are relying on ECDSA for their security, and it is impossible to crack.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> Finally! I hope this makes the whole algorithm clearer to many of you.. I know that this is still very complicated and hard to understand. I usually try to make things easy to understand for non technical people, but this algorithm is too complex to be able to explain in any simpler terms. After all that’s why I prefer to call it the MFET algorithm (Mathematics For Extra Terrestrials)&nbsp;<img src="http://kakaroto.homelinux.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" style="border:none;vertical-align:baseline;background:transparent;"></p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> But if you are a developer or a mathematician or someone interested in learning about this because you want to help or simple gain knowledge, then I’m sure that this contains enough information for you to get started or to at least understand the concept behind this unknown beast called “ECDSA”.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> That being said, I’d like to thank a few people who helped me understand all of this, one particularly who wishes to remain anonymous, as well as the many wikipedia pages I linked to throughout this article, and Avi Kak thanks to&nbsp;<a href="https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture14.pdf" rel="nofollow" style="border:0px;vertical-align:baseline;text-decoration:none;color:rgb(0,136,204);background:transparent;">his paper</a>&nbsp;explaining the mathematics behind ECDSA, and from which I have taken those graph images aboves.</p> 
  <p style="border:0px;vertical-align:baseline;color:rgb(51,51,51);font-family:'Lucida Grande', 'Lucida Sans Unicode', Arial, Verdana, sans-serif;line-height:18px;"> P.s: In this article, I used ’20 bytes’ in my text to talk about the ECDSA signature because that’s what is usually used as it matches the SHA1 hash size of 20 bytes and that’s what the PS3 security uses, but the algorithm itself can be used with any size of numbers. There may be other inaccuracies in this article, but like I said, I’m not an expert, I just barely learned all of this in the past week.</p> 
  <br>
  <p>以下内容转载在实验篇：</p> 
  <p></p> 
  <h1 style="font-family:Telex, sans-serif;line-height:1.4;margin-left:auto;color:rgb(62,62,55);"> Recovering Bitcoin private keys using weak signatures from the blockchain</h1> 
  <p></p> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> On December 25th of last year I discovered a potential weakness in some Bitcoin implementations. Have a look at this transaction:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">transaction: 9ec4bc49e828d924af1d1029cacf709431abbde46d59554b62bc270e3b29c4b1

input script 1:
30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1022044e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff

input script 2:
30440220d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad102209a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab0104dbd0c61532279cf72981c3584fc32216e0127699635c2789f549e0730c059b81ae133016a69c21e23f1859a95f06d52b7bf149a8f2fe4e8535c8a829b449c5ff</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> This transactions has two inputs and one output. If you look closely at the two input scripts you will notice there are quite a few equal bytes at the start and at the end. Those bytes at the end is the hex-encoded public key of the address spending the coins so there’s nothing wrong with that. However, the first half of the script is the actual signature (r, s):</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">r1: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1
r2: d47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1

s1: 44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e
s2: 9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> As you can see, r1 equals r2. This is a huge problem. We’ll be able to&nbsp;<a href="http://events.ccc.de/congress/2010/Fahrplan/attachments/1780_27c3_console_hacking_2010.pdf" rel="nofollow" style="text-decoration:none;color:rgb(90,109,117);">recover the private</a>&nbsp;key to this public key:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">private key = (z1*s2 - z2*s1)/(r*(s1-s2))</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> We just need to find z1 and z2! These are the hashes of the outputs to be signed. Let’s fetch the output transations and calculate them (it is calculated by OP_CHECKSIG):</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">z1: c0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e
z2: 17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> That’s it. Let’s setup our&nbsp;<a href="http://sagemath.org/" rel="nofollow" style="text-decoration:none;color:rgb(90,109,117);">sage</a>&nbsp;notebook like this:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">p  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
r  = 0xd47ce4c025c35ec440bc81d99834a624875161a26bf56ef7fdc0f5d52f843ad1
s1 = 0x44e1ff2dfd8102cf7a47c21d5c9fd5701610d04953c6836596b4fe9dd2f53e3e
s2 = 0x9a5f1c75e461d7ceb1cf3cab9013eb2dc85b6d0da8c3c6e27e3a5a5b3faa5bab
z1 = 0xc0e2d0a89a348de88fda08211c70d1d7e52ccef2eb9459911bf977d587784c6e
z2 = 0x17b0f41c8c337ac1e18c98759e83a8cccbc368dd9d89e5f03cb633c265fd0ddc</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> p is just the order of G, a parameter of the secp256k1 curve used by Bitcoin. Let’s create a field for our calculations:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">K = GF(p)</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> And calculate the private key within this field:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">K((z1*s2 - z2*s1)/(r*(s1-s2)))
88865298299719117682218467295833367085649033095698151055007620974294165995414</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> Convert it to a more suitable format:</p> 
  <pre style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;color:rgb(101,123,131);line-height:1em;overflow:auto;border-width:1pt 0px;border-style:solid;font-size:16px;text-align:justify;background:rgb(250,250,250);"><code style="font-family:'Droid Sans Mono', Consolas, 'Andale Mono', Monaco, Courier, 'Courier New', Verdana, sans-serif;font-size:.8em;display:inline-block;">hex: c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96
WIF: 5KJp7KEffR7HHFWSFYjiCUAntRSTY69LAQEX1AUzaSBHHFdKEpQ</code></pre> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> And import it to your favourite Bitcoin wallet. It’ll calculate the correct bitcoin address and you’ll be able to spend coins send to this address.</p> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> There are a few vulnerable bitcoin addresses in the blockchain. After some research I was able to contact the owner of this address. He allowed me to spend the funds.</p> 
  <p style="margin-left:auto;color:rgb(62,62,55);font-family:'PT Sans', serif;font-size:16px;line-height:28.799999237060547px;text-align:justify;"> Why did this work? ECDSA requires a random number for each signature. If this random number is ever used twice with the same private key it can be recovered. This transaction was generated by a hardware bitcoin wallet using a pseudo-random number generator that was returning the same “random” number every time.</p> 
  <br>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/37901763,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/37901763,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
