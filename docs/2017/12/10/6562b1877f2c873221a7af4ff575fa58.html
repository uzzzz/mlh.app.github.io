<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【CryptoKitties源码解析】养猫的正确姿势！ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【CryptoKitties源码解析】养猫的正确姿势！" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="今天想介绍一个最近比较火的一个“区块链”应用CryptoKitties，这个应用本质上实现的功能就是电子猫的繁殖与交易两个功能，功能上虽然比较简单但是再加上区块链这个强大的底层技术作为支撑，让它在整个行业掀起了一波热潮，甚至还导致了以太坊主网的堵塞，使得以太坊中未确认的交易数量从平常的2.5k增涨到了15k，网络中其他的交易也都受到了极大的影响。整个项目的代码总共2000行左右，其中还包含了详细的注释，使得即使没有学过Solidity编程（例如我）的同学也能够很容易的看懂，代码可以通过以太坊浏览器（https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code）直接查看，也可以查看另外一个在线的版本（https://ethfiddle.com/09YbyJRfiI），后一个支持在线编译调试。 High Level Overview 作为一个资深（伪）撸猫后期患者，首先还是想先介绍一下这个项目，以便让众多深夜猫瘾发作夜不能寐的患者找到心灵的港湾。项目官网：https://www.cryptokitties.co/，操作其实比较简单，首先你得有以太币，然后安装一个Chrome插件，也就是一个eth轻量钱包，接下来就可以进入Marketplace选择心仪的小可爱了，作为一个交易失败数次的过来人建议大家购买8页以后的喵喵，因为前面几页基本上都已经被人买走了，只不过交易还在等待确认，网站上更新有些延迟，这时候如果再买的话很有可能就是浪费Gas（交易费）。每只喵都是由一个256位的整数DNA来确定的，没有性别，任意两只没有直系血缘关系的喵都是可以繁殖后代的，和父母以及兄弟姐妹则无法繁殖后代。所有的喵都是可以挂到拍卖市场上去卖的，繁殖是需要支付手续费的，其他的交易类型则只需要支付Gas（交易费）就行，不过现在网络拥堵，大量未确认的交易依然存在，所以Gas建议设置到50-60。 按照项目中合约的继承关系，总共有以下几个合约： contract KittyAccessControl contract KittyBase is KittyAccessControl contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 所以KittyCore就是最终应用的合约地址，它继承了前面合约的所有数据和方法，下面我们就一次来看看每一个合约的具体实现。 1 KittyAccessControl：访问控制 这个合约的主要目的是设置了三个地址：CEO/CFO/COO，以及定义了一些function modifiers（http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers）例如onlyCEO/onlyCFO/onlyCLevel等等，接下来定义了一些函数并加上了function modifier标识使得这些函数都只能由特定的角色来调用，例如冻结和解除冻结整个合约。 modifier onlyCLevel() { require( msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress ); _; } ///... /// @dev Called by any &quot;C-level&quot; role to pause the contract. Used only when /// a bug or exploit is detected and we need to limit damage. function pause() external onlyCLevel whenNotPaused { paused = true; } 根据代码中的解释，这个pause()函数原本的设计目的是只有当程序出现漏洞时才会暂停合约从而减少漏洞带来的损失，暂停合约意味着停止处理所有发往该合约的交易，这也就意味着CLevel的成员具有控制项目运行的绝对权力，而不需要像一般区块链中所有的决定都必须经过矿工的投票分叉来执行，所以我们所谓的许多DApp其实本质上并不像我们想象中那么Decentralized。 2 KittyBase：存储结构 这个合约定义了每只喵所包含的基本的属性、合约运行过程中的数据存储变量（每只喵的主人，挂上拍卖场的喵，等待交配的喵等）以及一些基本操作函数（例如喵的属权转移，新喵的诞生）。 首先定义了喵的基本属性， struct Kitty { uint256 genes; // 基因 uint64 birthTime; // 出生区块的时间戳 uint64 cooldownEndBlock; // 再次繁殖的区块号 uint32 matronId; // 母亲的ID uint32 sireId; // 父亲的ID uint32 siringWithId; // 如果正在繁殖期那么就是当前交配对象的ID，否则为0 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 第几代 } 喵是没有性别的，属性中父母是看谁生下的新喵。所有的喵都是通过genes来决定外表的，而这个genes又是通过一个非开源的库来产生的，避免通过父母的基因来直接推测出新喵的基因，从而减少fancy cat的比例。另外值得注意的一点是，所有喵的外表都是通过前端的web服务器来解析的，也就是说开发人员可以随意定义哪些喵是fancy cat，并且一旦web服务器崩溃那么所有的喵除了cooldownIndex之外将没有任何区别。这也从侧面反应了区块链应用的一个缺陷——不可能将所有的应用数据都存储再区块链上，因为链上存储数据的代价太高了，所以未来如果要开发真正的完全去中心化的应用，如何将这些数据的存储也去中心化是一个值得考虑的问题。 /*** STORAGE ***/ /// 保存所有的喵的ID Kitty[] kitties; /// 所有喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // owner地址到owner的token数的映射 mapping (address =&gt; uint256) ownershipTokenCount; /// 待出售的喵ID到owner地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; /// 待交配的喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; /// 拍卖合约的地址，处理用户之间的交易和每隔15分钟系统生成的gen0代喵 SaleClockAuction public saleAuction; /// 交配的合约地址，和上面拍卖的不同因为两者的处理方式不同 SiringClockAuction public siringAuction; 这里定义了合约运行中所有的存储数据结构，可以看出总共存储的变量也并不多。接下来又定义了两个函数_transfer()和_createKitty()用来转移喵的属权和创建新喵，这两个函数都只能从内部调用， /// 一个内部函数用来创建新的喵然后保存起来，这个函数假设所有的输入数据都是有效的， /// 函数最后将触发一个Brith和Transfer事件。 function _createKitty( uint256 _matronId, // 母亲的ID，不存在则为0 uint256 _sireId, // 父亲的ID，不存在则为0 uint256 _generation, // 当前第几代，由调用者计算 uint256 _genes, // 基因 address _owner // 拥有者 ) internal returns (uint) { // 保证数据都在正常范围内 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 新喵的cooldown是由generation/2来决定 // generation = max(motherGeneration, fatherGeneration)+1 uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 创建新喵 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); uint256 newKittenId = kitties.push(_kitty) - 1; // 保存新喵ID // 确保总喵的个数小于2^32 require(newKittenId == uint256(uint32(newKittenId))); // 触发Birth事件 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 分配新喵属权 _transfer(0, _owner, newKittenId); return newKittenId; } 上述函数展示了创建新喵的详细过程，主要就是计算新喵的generation，然后根据generation分配相应的属性。 3 KittyOwnership：属权 这部分主要实现的是将喵的ID和实际的以太坊地址进行对应起来，实现的函数包括_owns()和transfer()等等涉及属权获取或者转换的操作，实现操作相对较为简单。 4 KittyBreeding：繁殖 这个合约包含了两只喵一起繁殖下一代喵的必要的步骤，繁殖依赖一个外部的基因组合合约（geneScience），但是这个合约却不是开源的，并且这个合约的地址是由CEO通过调用setGeneScienceAddress来设定的，也就是说CEO可以随意更改基因组合的方法。 function setGeneScienceAddress(address _address) external onlyCEO { GeneScienceInterface candidateContract = GeneScienceInterface(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; } 两只喵繁殖需要调用breedWithAuto()，首先会检查一系列条件，例如繁殖费用是否足够、双方是否都允许、双方是否没有直系关系等等，这些条件都满足以后调用内部函数_breedWith()来进行繁殖，同时改变双方的生殖状态并触发_triggerCooldown()来改变下次生殖的冷却时间，在_breedWith()函数最后触发Pregnant()事件，而web前端的繁殖界面就是通过监听Pregnant()事件来进行修改的，同时在时间到达时调用giveBirth()来产生新的喵。 function giveBirth(uint256 _matronId) external whenNotPaused returns(uint256) { // 通过母亲的ID获取对象 Kitty storage matron = kitties[_matronId]; // 通过birthTime验证是否是合法的喵 require(matron.birthTime != 0); // 检查母亲是否该生了 require(_isReadyToGiveBirth(matron)); // 获取父亲的对象 uint256 sireId = matron.siringWithId; Kitty storage sire = kitties[sireId]; // 计算父母的generation大的一个 uint16 parentGen = matron.generation; if (sire.generation &gt; matron.generation) { parentGen = sire.generation; } // 传入父母基因，调用外部基因组合函数，得到新喵的基因 uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1); // 新喵的owner设置为母亲的owner address owner = kittyIndexToOwner[_matronId]; uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner); // 清除母亲的交配对象，使得可以再次繁殖 delete matron.siringWithId; // 怀孕的喵数减一 pregnantKitties--; // 将费用发送给父亲 msg.sender.send(autoBirthFee); // 返回新喵的ID return kittenId; } 5 KittyAuction：拍卖 拍卖合约包括买、卖以及繁殖，繁殖指的是提供一方作为父亲，拿取繁殖费用并由母方获取繁殖的新喵。根据开发者所描述的，他们将拍卖合约分成几个子合约，因为“其中逻辑比较复杂，总是存在bug的风险，将每个过程分成单独的一个合约，我们就可以在不改变主合约的情况下升级子合约。”因此这个合约提供了两个函数setSaleAuctionAddress()和setSiringAuctionAddress用来设置子合约的地址，以便更方便的升级子合约。从安全性来讲这的确有利于代码的修复与升级，但是从另外一个角度来讲，合约中的CEO就有了任意更改拍卖规则的权利。 6 KittyMinting：初代喵 这部分合约规定了有合约生成的初代喵的个数，合约中是通过硬编码的形式写入的， // Limits the number of cats the contract owner can ever create. uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; 其中5000指的是用来促销的喵的数量，45000指的是合约产生初代喵的限制，产生的过程是分别通过调用createPromoKitty()和createGen0Auction()，通过createGen0Auction()产生的喵会被直接挂到拍卖场上，价格是通过过去5只初代喵的平均价格*1.5来作为初始价格。这两个函数都只能由COO来调用，并且创建是可以直接传入基因，也就是说COO可以将任意一直喵复制出来最多5000份，所以你觉得独一无二的喵也许并不像你想象中那么独特。 7 KittyCore：主合约 主合约的作用是控制合约的运行与更新，它继承了以上所有的合约，所以也就包括了以上所有的存储结构和函数。合约通过变量paused来控制停止与运行，通过setNewAddress()函数来设置合约更新的地址，通过unpaused()函数来启动合约。同时还包括两个外部调用函数getKitty()和withdrawBalance()，其中getKitty()是用来读取每只喵的所有属性，应该是应用于web server的后台；而withdrawBalance()则是用于提取合约中所有的余额，但是要保留pregnant kitties繁殖的费用，因为这需要从外部调用giveBirth()函数。 总结 如果从实际运行效果来看的话，不得不说这个项目非常的成功，至少到目前为止还占据了网络的一大部交易量，作为一个区块链应用，也的确是能够把握住时代的潮流，但是从上述代码来看还存在几个问题： 所有的喵本质上只是一个256位的整数，解释权都归前端所有； CEO具有控制应用运行的绝对权利，可以无条件暂停合约或者更新子合约； 开源的合约却又调用了非开源的合约（gene science）。 最后一个可能不能称之为问题，但是从我个人来讲开源就应该全部开源，如果能gene science这部分替换为开源的随机基因组合可能会更好，至少不会让其他人觉得这其中有什么猫腻。但是前面两个问题却是的的确确存在的，所以从技术上来讲这并不能完全算是个区块链应用，但却是个不错且成功的尝试！ 参考资料 https://medium.com/loom-network/your-crypto-kitty-isnt-forever-why-dapps-aren-t-as-decentralized-as-you-think-871d6acfea https://medium.com/loom-network/how-to-code-your-own-cryptokitties-style-game-on-ethereum-7c8ac86a4eb3 阅读更多" />
<meta property="og:description" content="今天想介绍一个最近比较火的一个“区块链”应用CryptoKitties，这个应用本质上实现的功能就是电子猫的繁殖与交易两个功能，功能上虽然比较简单但是再加上区块链这个强大的底层技术作为支撑，让它在整个行业掀起了一波热潮，甚至还导致了以太坊主网的堵塞，使得以太坊中未确认的交易数量从平常的2.5k增涨到了15k，网络中其他的交易也都受到了极大的影响。整个项目的代码总共2000行左右，其中还包含了详细的注释，使得即使没有学过Solidity编程（例如我）的同学也能够很容易的看懂，代码可以通过以太坊浏览器（https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code）直接查看，也可以查看另外一个在线的版本（https://ethfiddle.com/09YbyJRfiI），后一个支持在线编译调试。 High Level Overview 作为一个资深（伪）撸猫后期患者，首先还是想先介绍一下这个项目，以便让众多深夜猫瘾发作夜不能寐的患者找到心灵的港湾。项目官网：https://www.cryptokitties.co/，操作其实比较简单，首先你得有以太币，然后安装一个Chrome插件，也就是一个eth轻量钱包，接下来就可以进入Marketplace选择心仪的小可爱了，作为一个交易失败数次的过来人建议大家购买8页以后的喵喵，因为前面几页基本上都已经被人买走了，只不过交易还在等待确认，网站上更新有些延迟，这时候如果再买的话很有可能就是浪费Gas（交易费）。每只喵都是由一个256位的整数DNA来确定的，没有性别，任意两只没有直系血缘关系的喵都是可以繁殖后代的，和父母以及兄弟姐妹则无法繁殖后代。所有的喵都是可以挂到拍卖市场上去卖的，繁殖是需要支付手续费的，其他的交易类型则只需要支付Gas（交易费）就行，不过现在网络拥堵，大量未确认的交易依然存在，所以Gas建议设置到50-60。 按照项目中合约的继承关系，总共有以下几个合约： contract KittyAccessControl contract KittyBase is KittyAccessControl contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 所以KittyCore就是最终应用的合约地址，它继承了前面合约的所有数据和方法，下面我们就一次来看看每一个合约的具体实现。 1 KittyAccessControl：访问控制 这个合约的主要目的是设置了三个地址：CEO/CFO/COO，以及定义了一些function modifiers（http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers）例如onlyCEO/onlyCFO/onlyCLevel等等，接下来定义了一些函数并加上了function modifier标识使得这些函数都只能由特定的角色来调用，例如冻结和解除冻结整个合约。 modifier onlyCLevel() { require( msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress ); _; } ///... /// @dev Called by any &quot;C-level&quot; role to pause the contract. Used only when /// a bug or exploit is detected and we need to limit damage. function pause() external onlyCLevel whenNotPaused { paused = true; } 根据代码中的解释，这个pause()函数原本的设计目的是只有当程序出现漏洞时才会暂停合约从而减少漏洞带来的损失，暂停合约意味着停止处理所有发往该合约的交易，这也就意味着CLevel的成员具有控制项目运行的绝对权力，而不需要像一般区块链中所有的决定都必须经过矿工的投票分叉来执行，所以我们所谓的许多DApp其实本质上并不像我们想象中那么Decentralized。 2 KittyBase：存储结构 这个合约定义了每只喵所包含的基本的属性、合约运行过程中的数据存储变量（每只喵的主人，挂上拍卖场的喵，等待交配的喵等）以及一些基本操作函数（例如喵的属权转移，新喵的诞生）。 首先定义了喵的基本属性， struct Kitty { uint256 genes; // 基因 uint64 birthTime; // 出生区块的时间戳 uint64 cooldownEndBlock; // 再次繁殖的区块号 uint32 matronId; // 母亲的ID uint32 sireId; // 父亲的ID uint32 siringWithId; // 如果正在繁殖期那么就是当前交配对象的ID，否则为0 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 第几代 } 喵是没有性别的，属性中父母是看谁生下的新喵。所有的喵都是通过genes来决定外表的，而这个genes又是通过一个非开源的库来产生的，避免通过父母的基因来直接推测出新喵的基因，从而减少fancy cat的比例。另外值得注意的一点是，所有喵的外表都是通过前端的web服务器来解析的，也就是说开发人员可以随意定义哪些喵是fancy cat，并且一旦web服务器崩溃那么所有的喵除了cooldownIndex之外将没有任何区别。这也从侧面反应了区块链应用的一个缺陷——不可能将所有的应用数据都存储再区块链上，因为链上存储数据的代价太高了，所以未来如果要开发真正的完全去中心化的应用，如何将这些数据的存储也去中心化是一个值得考虑的问题。 /*** STORAGE ***/ /// 保存所有的喵的ID Kitty[] kitties; /// 所有喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // owner地址到owner的token数的映射 mapping (address =&gt; uint256) ownershipTokenCount; /// 待出售的喵ID到owner地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; /// 待交配的喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; /// 拍卖合约的地址，处理用户之间的交易和每隔15分钟系统生成的gen0代喵 SaleClockAuction public saleAuction; /// 交配的合约地址，和上面拍卖的不同因为两者的处理方式不同 SiringClockAuction public siringAuction; 这里定义了合约运行中所有的存储数据结构，可以看出总共存储的变量也并不多。接下来又定义了两个函数_transfer()和_createKitty()用来转移喵的属权和创建新喵，这两个函数都只能从内部调用， /// 一个内部函数用来创建新的喵然后保存起来，这个函数假设所有的输入数据都是有效的， /// 函数最后将触发一个Brith和Transfer事件。 function _createKitty( uint256 _matronId, // 母亲的ID，不存在则为0 uint256 _sireId, // 父亲的ID，不存在则为0 uint256 _generation, // 当前第几代，由调用者计算 uint256 _genes, // 基因 address _owner // 拥有者 ) internal returns (uint) { // 保证数据都在正常范围内 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 新喵的cooldown是由generation/2来决定 // generation = max(motherGeneration, fatherGeneration)+1 uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 创建新喵 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); uint256 newKittenId = kitties.push(_kitty) - 1; // 保存新喵ID // 确保总喵的个数小于2^32 require(newKittenId == uint256(uint32(newKittenId))); // 触发Birth事件 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 分配新喵属权 _transfer(0, _owner, newKittenId); return newKittenId; } 上述函数展示了创建新喵的详细过程，主要就是计算新喵的generation，然后根据generation分配相应的属性。 3 KittyOwnership：属权 这部分主要实现的是将喵的ID和实际的以太坊地址进行对应起来，实现的函数包括_owns()和transfer()等等涉及属权获取或者转换的操作，实现操作相对较为简单。 4 KittyBreeding：繁殖 这个合约包含了两只喵一起繁殖下一代喵的必要的步骤，繁殖依赖一个外部的基因组合合约（geneScience），但是这个合约却不是开源的，并且这个合约的地址是由CEO通过调用setGeneScienceAddress来设定的，也就是说CEO可以随意更改基因组合的方法。 function setGeneScienceAddress(address _address) external onlyCEO { GeneScienceInterface candidateContract = GeneScienceInterface(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; } 两只喵繁殖需要调用breedWithAuto()，首先会检查一系列条件，例如繁殖费用是否足够、双方是否都允许、双方是否没有直系关系等等，这些条件都满足以后调用内部函数_breedWith()来进行繁殖，同时改变双方的生殖状态并触发_triggerCooldown()来改变下次生殖的冷却时间，在_breedWith()函数最后触发Pregnant()事件，而web前端的繁殖界面就是通过监听Pregnant()事件来进行修改的，同时在时间到达时调用giveBirth()来产生新的喵。 function giveBirth(uint256 _matronId) external whenNotPaused returns(uint256) { // 通过母亲的ID获取对象 Kitty storage matron = kitties[_matronId]; // 通过birthTime验证是否是合法的喵 require(matron.birthTime != 0); // 检查母亲是否该生了 require(_isReadyToGiveBirth(matron)); // 获取父亲的对象 uint256 sireId = matron.siringWithId; Kitty storage sire = kitties[sireId]; // 计算父母的generation大的一个 uint16 parentGen = matron.generation; if (sire.generation &gt; matron.generation) { parentGen = sire.generation; } // 传入父母基因，调用外部基因组合函数，得到新喵的基因 uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1); // 新喵的owner设置为母亲的owner address owner = kittyIndexToOwner[_matronId]; uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner); // 清除母亲的交配对象，使得可以再次繁殖 delete matron.siringWithId; // 怀孕的喵数减一 pregnantKitties--; // 将费用发送给父亲 msg.sender.send(autoBirthFee); // 返回新喵的ID return kittenId; } 5 KittyAuction：拍卖 拍卖合约包括买、卖以及繁殖，繁殖指的是提供一方作为父亲，拿取繁殖费用并由母方获取繁殖的新喵。根据开发者所描述的，他们将拍卖合约分成几个子合约，因为“其中逻辑比较复杂，总是存在bug的风险，将每个过程分成单独的一个合约，我们就可以在不改变主合约的情况下升级子合约。”因此这个合约提供了两个函数setSaleAuctionAddress()和setSiringAuctionAddress用来设置子合约的地址，以便更方便的升级子合约。从安全性来讲这的确有利于代码的修复与升级，但是从另外一个角度来讲，合约中的CEO就有了任意更改拍卖规则的权利。 6 KittyMinting：初代喵 这部分合约规定了有合约生成的初代喵的个数，合约中是通过硬编码的形式写入的， // Limits the number of cats the contract owner can ever create. uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; 其中5000指的是用来促销的喵的数量，45000指的是合约产生初代喵的限制，产生的过程是分别通过调用createPromoKitty()和createGen0Auction()，通过createGen0Auction()产生的喵会被直接挂到拍卖场上，价格是通过过去5只初代喵的平均价格*1.5来作为初始价格。这两个函数都只能由COO来调用，并且创建是可以直接传入基因，也就是说COO可以将任意一直喵复制出来最多5000份，所以你觉得独一无二的喵也许并不像你想象中那么独特。 7 KittyCore：主合约 主合约的作用是控制合约的运行与更新，它继承了以上所有的合约，所以也就包括了以上所有的存储结构和函数。合约通过变量paused来控制停止与运行，通过setNewAddress()函数来设置合约更新的地址，通过unpaused()函数来启动合约。同时还包括两个外部调用函数getKitty()和withdrawBalance()，其中getKitty()是用来读取每只喵的所有属性，应该是应用于web server的后台；而withdrawBalance()则是用于提取合约中所有的余额，但是要保留pregnant kitties繁殖的费用，因为这需要从外部调用giveBirth()函数。 总结 如果从实际运行效果来看的话，不得不说这个项目非常的成功，至少到目前为止还占据了网络的一大部交易量，作为一个区块链应用，也的确是能够把握住时代的潮流，但是从上述代码来看还存在几个问题： 所有的喵本质上只是一个256位的整数，解释权都归前端所有； CEO具有控制应用运行的绝对权利，可以无条件暂停合约或者更新子合约； 开源的合约却又调用了非开源的合约（gene science）。 最后一个可能不能称之为问题，但是从我个人来讲开源就应该全部开源，如果能gene science这部分替换为开源的随机基因组合可能会更好，至少不会让其他人觉得这其中有什么猫腻。但是前面两个问题却是的的确确存在的，所以从技术上来讲这并不能完全算是个区块链应用，但却是个不错且成功的尝试！ 参考资料 https://medium.com/loom-network/your-crypto-kitty-isnt-forever-why-dapps-aren-t-as-decentralized-as-you-think-871d6acfea https://medium.com/loom-network/how-to-code-your-own-cryptokitties-style-game-on-ethereum-7c8ac86a4eb3 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"今天想介绍一个最近比较火的一个“区块链”应用CryptoKitties，这个应用本质上实现的功能就是电子猫的繁殖与交易两个功能，功能上虽然比较简单但是再加上区块链这个强大的底层技术作为支撑，让它在整个行业掀起了一波热潮，甚至还导致了以太坊主网的堵塞，使得以太坊中未确认的交易数量从平常的2.5k增涨到了15k，网络中其他的交易也都受到了极大的影响。整个项目的代码总共2000行左右，其中还包含了详细的注释，使得即使没有学过Solidity编程（例如我）的同学也能够很容易的看懂，代码可以通过以太坊浏览器（https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code）直接查看，也可以查看另外一个在线的版本（https://ethfiddle.com/09YbyJRfiI），后一个支持在线编译调试。 High Level Overview 作为一个资深（伪）撸猫后期患者，首先还是想先介绍一下这个项目，以便让众多深夜猫瘾发作夜不能寐的患者找到心灵的港湾。项目官网：https://www.cryptokitties.co/，操作其实比较简单，首先你得有以太币，然后安装一个Chrome插件，也就是一个eth轻量钱包，接下来就可以进入Marketplace选择心仪的小可爱了，作为一个交易失败数次的过来人建议大家购买8页以后的喵喵，因为前面几页基本上都已经被人买走了，只不过交易还在等待确认，网站上更新有些延迟，这时候如果再买的话很有可能就是浪费Gas（交易费）。每只喵都是由一个256位的整数DNA来确定的，没有性别，任意两只没有直系血缘关系的喵都是可以繁殖后代的，和父母以及兄弟姐妹则无法繁殖后代。所有的喵都是可以挂到拍卖市场上去卖的，繁殖是需要支付手续费的，其他的交易类型则只需要支付Gas（交易费）就行，不过现在网络拥堵，大量未确认的交易依然存在，所以Gas建议设置到50-60。 按照项目中合约的继承关系，总共有以下几个合约： contract KittyAccessControl contract KittyBase is KittyAccessControl contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 所以KittyCore就是最终应用的合约地址，它继承了前面合约的所有数据和方法，下面我们就一次来看看每一个合约的具体实现。 1 KittyAccessControl：访问控制 这个合约的主要目的是设置了三个地址：CEO/CFO/COO，以及定义了一些function modifiers（http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers）例如onlyCEO/onlyCFO/onlyCLevel等等，接下来定义了一些函数并加上了function modifier标识使得这些函数都只能由特定的角色来调用，例如冻结和解除冻结整个合约。 modifier onlyCLevel() { require( msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress ); _; } ///... /// @dev Called by any &quot;C-level&quot; role to pause the contract. Used only when /// a bug or exploit is detected and we need to limit damage. function pause() external onlyCLevel whenNotPaused { paused = true; } 根据代码中的解释，这个pause()函数原本的设计目的是只有当程序出现漏洞时才会暂停合约从而减少漏洞带来的损失，暂停合约意味着停止处理所有发往该合约的交易，这也就意味着CLevel的成员具有控制项目运行的绝对权力，而不需要像一般区块链中所有的决定都必须经过矿工的投票分叉来执行，所以我们所谓的许多DApp其实本质上并不像我们想象中那么Decentralized。 2 KittyBase：存储结构 这个合约定义了每只喵所包含的基本的属性、合约运行过程中的数据存储变量（每只喵的主人，挂上拍卖场的喵，等待交配的喵等）以及一些基本操作函数（例如喵的属权转移，新喵的诞生）。 首先定义了喵的基本属性， struct Kitty { uint256 genes; // 基因 uint64 birthTime; // 出生区块的时间戳 uint64 cooldownEndBlock; // 再次繁殖的区块号 uint32 matronId; // 母亲的ID uint32 sireId; // 父亲的ID uint32 siringWithId; // 如果正在繁殖期那么就是当前交配对象的ID，否则为0 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 第几代 } 喵是没有性别的，属性中父母是看谁生下的新喵。所有的喵都是通过genes来决定外表的，而这个genes又是通过一个非开源的库来产生的，避免通过父母的基因来直接推测出新喵的基因，从而减少fancy cat的比例。另外值得注意的一点是，所有喵的外表都是通过前端的web服务器来解析的，也就是说开发人员可以随意定义哪些喵是fancy cat，并且一旦web服务器崩溃那么所有的喵除了cooldownIndex之外将没有任何区别。这也从侧面反应了区块链应用的一个缺陷——不可能将所有的应用数据都存储再区块链上，因为链上存储数据的代价太高了，所以未来如果要开发真正的完全去中心化的应用，如何将这些数据的存储也去中心化是一个值得考虑的问题。 /*** STORAGE ***/ /// 保存所有的喵的ID Kitty[] kitties; /// 所有喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // owner地址到owner的token数的映射 mapping (address =&gt; uint256) ownershipTokenCount; /// 待出售的喵ID到owner地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; /// 待交配的喵的ID到owner的地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; /// 拍卖合约的地址，处理用户之间的交易和每隔15分钟系统生成的gen0代喵 SaleClockAuction public saleAuction; /// 交配的合约地址，和上面拍卖的不同因为两者的处理方式不同 SiringClockAuction public siringAuction; 这里定义了合约运行中所有的存储数据结构，可以看出总共存储的变量也并不多。接下来又定义了两个函数_transfer()和_createKitty()用来转移喵的属权和创建新喵，这两个函数都只能从内部调用， /// 一个内部函数用来创建新的喵然后保存起来，这个函数假设所有的输入数据都是有效的， /// 函数最后将触发一个Brith和Transfer事件。 function _createKitty( uint256 _matronId, // 母亲的ID，不存在则为0 uint256 _sireId, // 父亲的ID，不存在则为0 uint256 _generation, // 当前第几代，由调用者计算 uint256 _genes, // 基因 address _owner // 拥有者 ) internal returns (uint) { // 保证数据都在正常范围内 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 新喵的cooldown是由generation/2来决定 // generation = max(motherGeneration, fatherGeneration)+1 uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 创建新喵 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); uint256 newKittenId = kitties.push(_kitty) - 1; // 保存新喵ID // 确保总喵的个数小于2^32 require(newKittenId == uint256(uint32(newKittenId))); // 触发Birth事件 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 分配新喵属权 _transfer(0, _owner, newKittenId); return newKittenId; } 上述函数展示了创建新喵的详细过程，主要就是计算新喵的generation，然后根据generation分配相应的属性。 3 KittyOwnership：属权 这部分主要实现的是将喵的ID和实际的以太坊地址进行对应起来，实现的函数包括_owns()和transfer()等等涉及属权获取或者转换的操作，实现操作相对较为简单。 4 KittyBreeding：繁殖 这个合约包含了两只喵一起繁殖下一代喵的必要的步骤，繁殖依赖一个外部的基因组合合约（geneScience），但是这个合约却不是开源的，并且这个合约的地址是由CEO通过调用setGeneScienceAddress来设定的，也就是说CEO可以随意更改基因组合的方法。 function setGeneScienceAddress(address _address) external onlyCEO { GeneScienceInterface candidateContract = GeneScienceInterface(_address); require(candidateContract.isGeneScience()); geneScience = candidateContract; } 两只喵繁殖需要调用breedWithAuto()，首先会检查一系列条件，例如繁殖费用是否足够、双方是否都允许、双方是否没有直系关系等等，这些条件都满足以后调用内部函数_breedWith()来进行繁殖，同时改变双方的生殖状态并触发_triggerCooldown()来改变下次生殖的冷却时间，在_breedWith()函数最后触发Pregnant()事件，而web前端的繁殖界面就是通过监听Pregnant()事件来进行修改的，同时在时间到达时调用giveBirth()来产生新的喵。 function giveBirth(uint256 _matronId) external whenNotPaused returns(uint256) { // 通过母亲的ID获取对象 Kitty storage matron = kitties[_matronId]; // 通过birthTime验证是否是合法的喵 require(matron.birthTime != 0); // 检查母亲是否该生了 require(_isReadyToGiveBirth(matron)); // 获取父亲的对象 uint256 sireId = matron.siringWithId; Kitty storage sire = kitties[sireId]; // 计算父母的generation大的一个 uint16 parentGen = matron.generation; if (sire.generation &gt; matron.generation) { parentGen = sire.generation; } // 传入父母基因，调用外部基因组合函数，得到新喵的基因 uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1); // 新喵的owner设置为母亲的owner address owner = kittyIndexToOwner[_matronId]; uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner); // 清除母亲的交配对象，使得可以再次繁殖 delete matron.siringWithId; // 怀孕的喵数减一 pregnantKitties--; // 将费用发送给父亲 msg.sender.send(autoBirthFee); // 返回新喵的ID return kittenId; } 5 KittyAuction：拍卖 拍卖合约包括买、卖以及繁殖，繁殖指的是提供一方作为父亲，拿取繁殖费用并由母方获取繁殖的新喵。根据开发者所描述的，他们将拍卖合约分成几个子合约，因为“其中逻辑比较复杂，总是存在bug的风险，将每个过程分成单独的一个合约，我们就可以在不改变主合约的情况下升级子合约。”因此这个合约提供了两个函数setSaleAuctionAddress()和setSiringAuctionAddress用来设置子合约的地址，以便更方便的升级子合约。从安全性来讲这的确有利于代码的修复与升级，但是从另外一个角度来讲，合约中的CEO就有了任意更改拍卖规则的权利。 6 KittyMinting：初代喵 这部分合约规定了有合约生成的初代喵的个数，合约中是通过硬编码的形式写入的， // Limits the number of cats the contract owner can ever create. uint256 public constant PROMO_CREATION_LIMIT = 5000; uint256 public constant GEN0_CREATION_LIMIT = 45000; 其中5000指的是用来促销的喵的数量，45000指的是合约产生初代喵的限制，产生的过程是分别通过调用createPromoKitty()和createGen0Auction()，通过createGen0Auction()产生的喵会被直接挂到拍卖场上，价格是通过过去5只初代喵的平均价格*1.5来作为初始价格。这两个函数都只能由COO来调用，并且创建是可以直接传入基因，也就是说COO可以将任意一直喵复制出来最多5000份，所以你觉得独一无二的喵也许并不像你想象中那么独特。 7 KittyCore：主合约 主合约的作用是控制合约的运行与更新，它继承了以上所有的合约，所以也就包括了以上所有的存储结构和函数。合约通过变量paused来控制停止与运行，通过setNewAddress()函数来设置合约更新的地址，通过unpaused()函数来启动合约。同时还包括两个外部调用函数getKitty()和withdrawBalance()，其中getKitty()是用来读取每只喵的所有属性，应该是应用于web server的后台；而withdrawBalance()则是用于提取合约中所有的余额，但是要保留pregnant kitties繁殖的费用，因为这需要从外部调用giveBirth()函数。 总结 如果从实际运行效果来看的话，不得不说这个项目非常的成功，至少到目前为止还占据了网络的一大部交易量，作为一个区块链应用，也的确是能够把握住时代的潮流，但是从上述代码来看还存在几个问题： 所有的喵本质上只是一个256位的整数，解释权都归前端所有； CEO具有控制应用运行的绝对权利，可以无条件暂停合约或者更新子合约； 开源的合约却又调用了非开源的合约（gene science）。 最后一个可能不能称之为问题，但是从我个人来讲开源就应该全部开源，如果能gene science这部分替换为开源的随机基因组合可能会更好，至少不会让其他人觉得这其中有什么猫腻。但是前面两个问题却是的的确确存在的，所以从技术上来讲这并不能完全算是个区块链应用，但却是个不错且成功的尝试！ 参考资料 https://medium.com/loom-network/your-crypto-kitty-isnt-forever-why-dapps-aren-t-as-decentralized-as-you-think-871d6acfea https://medium.com/loom-network/how-to-code-your-own-cryptokitties-style-game-on-ethereum-7c8ac86a4eb3 阅读更多","@type":"BlogPosting","url":"/2017/12/10/6562b1877f2c873221a7af4ff575fa58.html","headline":"【CryptoKitties源码解析】养猫的正确姿势！","dateModified":"2017-12-10T00:00:00+08:00","datePublished":"2017-12-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/12/10/6562b1877f2c873221a7af4ff575fa58.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【CryptoKitties源码解析】养猫的正确姿势！</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171210231542012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHVyZV9sYWR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="myKitty" title=""></p> 
  <p>今天想介绍一个最近比较火的一个“区块链”应用<code>CryptoKitties</code>，这个应用本质上实现的功能就是电子猫的繁殖与交易两个功能，功能上虽然比较简单但是再加上区块链这个强大的底层技术作为支撑，让它在整个行业掀起了一波热潮，甚至还导致了以太坊主网的堵塞，使得以太坊中未确认的交易数量从平常的2.5k增涨到了15k，网络中其他的交易也都受到了极大的影响。整个项目的代码总共2000行左右，其中还包含了详细的注释，使得即使没有学过Solidity编程（例如我）的同学也能够很容易的看懂，代码可以通过以太坊浏览器（<a href="https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code" rel="nofollow">https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code</a>）直接查看，也可以查看另外一个在线的版本（<a href="https://ethfiddle.com/09YbyJRfiI" rel="nofollow">https://ethfiddle.com/09YbyJRfiI</a>），后一个支持在线编译调试。</p> 
  <h2 id="high-level-overview">High Level Overview</h2> 
  <p>作为一个资深（伪）撸猫后期患者，首先还是想先介绍一下这个项目，以便让众多深夜猫瘾发作夜不能寐的患者找到心灵的港湾。项目官网：<a href="https://www.cryptokitties.co/" rel="nofollow" target="_blank">https://www.cryptokitties.co/</a>，操作其实比较简单，首先你得有以太币，然后安装一个Chrome插件，也就是一个eth轻量钱包，接下来就可以进入Marketplace选择心仪的小可爱了，作为一个交易失败数次的过来人建议大家购买8页以后的喵喵，因为前面几页基本上都已经被人买走了，只不过交易还在等待确认，网站上更新有些延迟，这时候如果再买的话很有可能就是浪费Gas（交易费）。每只喵都是由一个256位的整数DNA来确定的，没有性别，任意两只没有直系血缘关系的喵都是可以繁殖后代的，和父母以及兄弟姐妹则无法繁殖后代。所有的喵都是可以挂到拍卖市场上去卖的，繁殖是需要支付手续费的，其他的交易类型则只需要支付Gas（交易费）就行，不过现在网络拥堵，大量未确认的交易依然存在，所以Gas建议设置到50-60。</p> 
  <p>按照项目中合约的继承关系，总共有以下几个合约：</p> 
  <pre class="prettyprint"><code class=" hljs cs">contract KittyAccessControl
contract KittyBase <span class="hljs-keyword">is</span> KittyAccessControl
contract KittyOwnership <span class="hljs-keyword">is</span> KittyBase, ERC721
contract KittyBreeding <span class="hljs-keyword">is</span> KittyOwnership
contract KittyAuction <span class="hljs-keyword">is</span> KittyBreeding
contract KittyMinting <span class="hljs-keyword">is</span> KittyAuction
contract KittyCore <span class="hljs-keyword">is</span> KittyMinting</code></pre> 
  <p>所以KittyCore就是最终应用的合约地址，它继承了前面合约的所有数据和方法，下面我们就一次来看看每一个合约的具体实现。</p> 
  <h2 id="1-kittyaccesscontrol访问控制">1 KittyAccessControl：访问控制</h2> 
  <p>这个合约的主要目的是设置了三个地址：CEO/CFO/COO，以及定义了一些function modifiers（<a href="http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers" rel="nofollow" target="_blank">http://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers</a>）例如onlyCEO/onlyCFO/onlyCLevel等等，接下来定义了一些函数并加上了function modifier标识使得这些函数都只能由特定的角色来调用，例如冻结和解除冻结整个合约。</p> 
  <pre class="prettyprint"><code class=" hljs r">modifier onlyCLevel() {
    <span class="hljs-keyword">require</span>(
        msg.sender == cooAddress ||
        msg.sender == ceoAddress ||
        msg.sender == cfoAddress
    );
    _;
}

///<span class="hljs-keyword">...</span>

/// @dev Called by any <span class="hljs-string">"C-level"</span> role to pause the contract. Used only when
///  a bug or exploit is detected and we need to limit damage.
<span class="hljs-keyword">function</span> pause() external onlyCLevel whenNotPaused {
    paused = true;
}</code></pre> 
  <p>根据代码中的解释，这个<code>pause()</code>函数原本的设计目的是只有当程序出现漏洞时才会暂停合约从而减少漏洞带来的损失，暂停合约意味着停止处理所有发往该合约的交易，这也就意味着CLevel的成员具有控制项目运行的绝对权力，而不需要像一般区块链中所有的决定都必须经过矿工的投票分叉来执行，所以我们所谓的许多DApp其实本质上并不像我们想象中那么Decentralized。</p> 
  <h2 id="2-kittybase存储结构">2 KittyBase：存储结构</h2> 
  <p>这个合约定义了每只喵所包含的基本的属性、合约运行过程中的数据存储变量（每只喵的主人，挂上拍卖场的喵，等待交配的喵等）以及一些基本操作函数（例如喵的属权转移，新喵的诞生）。</p> 
  <p>首先定义了喵的基本属性，</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> Kitty {
    uint256 genes; <span class="hljs-comment">// 基因</span>
    <span class="hljs-keyword">uint64</span> birthTime; <span class="hljs-comment">// 出生区块的时间戳</span>
    <span class="hljs-keyword">uint64</span> cooldownEndBlock; <span class="hljs-comment">// 再次繁殖的区块号</span>
    <span class="hljs-keyword">uint32</span> matronId; <span class="hljs-comment">// 母亲的ID</span>
    <span class="hljs-keyword">uint32</span> sireId; <span class="hljs-comment">// 父亲的ID</span>
    <span class="hljs-keyword">uint32</span> siringWithId; <span class="hljs-comment">// 如果正在繁殖期那么就是当前交配对象的ID，否则为0</span>
    <span class="hljs-keyword">uint16</span> cooldownIndex; <span class="hljs-comment">// 繁殖冷却时间</span>
    <span class="hljs-keyword">uint16</span> generation; <span class="hljs-comment">// 第几代</span>
}</code></pre> 
  <p>喵是没有性别的，属性中父母是看谁生下的新喵。所有的喵都是通过<code>genes</code>来决定外表的，而这个genes又是通过一个非开源的库来产生的，避免通过父母的基因来直接推测出新喵的基因，从而减少fancy cat的比例。<strong>另外值得注意的一点是，所有喵的外表都是通过前端的web服务器来解析的，也就是说开发人员可以随意定义哪些喵是fancy cat，并且一旦web服务器崩溃那么所有的喵除了cooldownIndex之外将没有任何区别。</strong>这也从侧面反应了区块链应用的一个缺陷——不可能将所有的应用数据都存储再区块链上，因为链上存储数据的代价太高了，所以未来如果要开发真正的完全去中心化的应用，如何将这些数据的存储也去中心化是一个值得考虑的问题。</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*** STORAGE ***/</span>

    <span class="hljs-comment">/// 保存所有的喵的ID</span>
    Kitty[] kitties;

    <span class="hljs-comment">/// 所有喵的ID到owner的地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> kittyIndexToOwner;

    <span class="hljs-comment">// owner地址到owner的token数的映射</span>
    mapping (address =&gt; uint256) ownershipTokenCount;

    <span class="hljs-comment">/// 待出售的喵ID到owner地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> kittyIndexToApproved;

    <span class="hljs-comment">/// 待交配的喵的ID到owner的地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> sireAllowedToAddress;

    <span class="hljs-comment">/// 拍卖合约的地址，处理用户之间的交易和每隔15分钟系统生成的gen0代喵</span>
    SaleClockAuction <span class="hljs-keyword">public</span> saleAuction;

    <span class="hljs-comment">/// 交配的合约地址，和上面拍卖的不同因为两者的处理方式不同</span>
    SiringClockAuction <span class="hljs-keyword">public</span> siringAuction;</code></pre> 
  <p>这里定义了合约运行中所有的存储数据结构，可以看出总共存储的变量也并不多。接下来又定义了两个函数<code>_transfer()</code>和<code>_createKitty()</code>用来转移喵的属权和创建新喵，这两个函数都只能从内部调用，</p> 
  <pre class="prettyprint"><code class=" hljs vala">    <span class="hljs-comment">/// 一个内部函数用来创建新的喵然后保存起来，这个函数假设所有的输入数据都是有效的，</span>
    <span class="hljs-comment">/// 函数最后将触发一个Brith和Transfer事件。</span>
    function _createKitty(
        uint256 _matronId, <span class="hljs-comment">// 母亲的ID，不存在则为0</span>
        uint256 _sireId,  <span class="hljs-comment">// 父亲的ID，不存在则为0</span>
        uint256 _generation, <span class="hljs-comment">// 当前第几代，由调用者计算</span>
        uint256 _genes, <span class="hljs-comment">// 基因</span>
        address _owner <span class="hljs-comment">// 拥有者</span>
    )
        <span class="hljs-keyword">internal</span>
        returns (<span class="hljs-keyword">uint</span>)
    {
        <span class="hljs-comment">// 保证数据都在正常范围内</span>
        require(_matronId == uint256(<span class="hljs-keyword">uint32</span>(_matronId)));
        require(_sireId == uint256(<span class="hljs-keyword">uint32</span>(_sireId)));
        require(_generation == uint256(<span class="hljs-keyword">uint16</span>(_generation)));

        <span class="hljs-comment">// 新喵的cooldown是由generation/2来决定</span>
        <span class="hljs-comment">// generation = max(motherGeneration, fatherGeneration)+1</span>
        <span class="hljs-keyword">uint16</span> cooldownIndex = <span class="hljs-keyword">uint16</span>(_generation / <span class="hljs-number">2</span>);
        if (cooldownIndex &gt; <span class="hljs-number">13</span>) {
            cooldownIndex = <span class="hljs-number">13</span>;
        }

        <span class="hljs-comment">// 创建新喵</span>
        Kitty memory _kitty = Kitty({
            genes: _genes,
            birthTime: <span class="hljs-keyword">uint64</span>(now),
            cooldownEndBlock: <span class="hljs-number">0</span>,
            matronId: <span class="hljs-keyword">uint32</span>(_matronId),
            sireId: <span class="hljs-keyword">uint32</span>(_sireId),
            siringWithId: <span class="hljs-number">0</span>,
            cooldownIndex: cooldownIndex,
            generation: <span class="hljs-keyword">uint16</span>(_generation)
        });
        uint256 newKittenId = kitties.push(_kitty) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 保存新喵ID</span>

        <span class="hljs-comment">// 确保总喵的个数小于2^32</span>
        require(newKittenId == uint256(<span class="hljs-keyword">uint32</span>(newKittenId)));

        <span class="hljs-comment">// 触发Birth事件</span>
        Birth(
            _owner,
            newKittenId,
            uint256(_kitty.matronId),
            uint256(_kitty.sireId),
            _kitty.genes
        );

        <span class="hljs-comment">// 分配新喵属权</span>
        _transfer(<span class="hljs-number">0</span>, _owner, newKittenId);

        <span class="hljs-keyword">return</span> newKittenId;
    }</code></pre> 
  <p>上述函数展示了创建新喵的详细过程，主要就是计算新喵的generation，然后根据generation分配相应的属性。</p> 
  <h2 id="3-kittyownership属权">3 KittyOwnership：属权</h2> 
  <p>这部分主要实现的是将喵的ID和实际的以太坊地址进行对应起来，实现的函数包括<code>_owns()</code>和<code>transfer()</code>等等涉及属权获取或者转换的操作，实现操作相对较为简单。</p> 
  <h2 id="4-kittybreeding繁殖">4 KittyBreeding：繁殖</h2> 
  <p>这个合约包含了两只喵一起繁殖下一代喵的必要的步骤，繁殖依赖一个外部的基因组合合约（geneScience），但是这个合约却不是开源的，并且这个合约的地址是由CEO通过调用<code>setGeneScienceAddress</code>来设定的，也就是说CEO可以随意更改基因组合的方法。</p> 
  <pre class="prettyprint"><code class=" hljs javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setGeneScienceAddress</span><span class="hljs-params">(address _address)</span> <span class="hljs-title">external</span> <span class="hljs-title">onlyCEO</span> {</span>
        GeneScienceInterface candidateContract = GeneScienceInterface(_address);
        <span class="hljs-built_in">require</span>(candidateContract.isGeneScience());
        geneScience = candidateContract;
    }</code></pre> 
  <p>两只喵繁殖需要调用<code>breedWithAuto()</code>，首先会检查一系列条件，例如繁殖费用是否足够、双方是否都允许、双方是否没有直系关系等等，这些条件都满足以后调用内部函数<code>_breedWith()</code>来进行繁殖，同时改变双方的生殖状态并触发<code>_triggerCooldown()</code>来改变下次生殖的冷却时间，在<code>_breedWith()</code>函数最后触发<code>Pregnant()</code>事件，而web前端的繁殖界面就是通过监听<code>Pregnant()</code>事件来进行修改的，同时在时间到达时调用<code>giveBirth()</code>来产生新的喵。</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveBirth</span><span class="hljs-params">(uint256 _matronId)</span> <span class="hljs-title">external</span> <span class="hljs-title">whenNotPaused</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span> {</span>
        <span class="hljs-comment">// 通过母亲的ID获取对象</span>
        Kitty storage matron = kitties[_matronId];

        <span class="hljs-comment">// 通过birthTime验证是否是合法的喵</span>
        <span class="hljs-built_in">require</span>(matron.birthTime != <span class="hljs-number">0</span>);

        <span class="hljs-comment">// 检查母亲是否该生了</span>
        <span class="hljs-built_in">require</span>(_isReadyToGiveBirth(matron));

        <span class="hljs-comment">// 获取父亲的对象</span>
        uint256 sireId = matron.siringWithId;
        Kitty storage sire = kitties[sireId];

        <span class="hljs-comment">// 计算父母的generation大的一个</span>
        uint16 parentGen = matron.generation;
        <span class="hljs-keyword">if</span> (sire.generation &gt; matron.generation) {
            parentGen = sire.generation;
        }

        <span class="hljs-comment">// 传入父母基因，调用外部基因组合函数，得到新喵的基因</span>
        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - <span class="hljs-number">1</span>);

        <span class="hljs-comment">// 新喵的owner设置为母亲的owner</span>
        address owner = kittyIndexToOwner[_matronId];
        uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + <span class="hljs-number">1</span>, childGenes, owner);

        <span class="hljs-comment">// 清除母亲的交配对象，使得可以再次繁殖</span>
        <span class="hljs-keyword">delete</span> matron.siringWithId;

        <span class="hljs-comment">// 怀孕的喵数减一</span>
        pregnantKitties--;

        <span class="hljs-comment">// 将费用发送给父亲</span>
        msg.sender.send(autoBirthFee);

        <span class="hljs-comment">// 返回新喵的ID</span>
        <span class="hljs-keyword">return</span> kittenId;
    }</code></pre> 
  <h2 id="5-kittyauction拍卖">5 KittyAuction：拍卖</h2> 
  <p>拍卖合约包括买、卖以及繁殖，繁殖指的是提供一方作为父亲，拿取繁殖费用并由母方获取繁殖的新喵。根据开发者所描述的，他们将拍卖合约分成几个子合约，因为“其中逻辑比较复杂，总是存在bug的风险，将每个过程分成单独的一个合约，我们就可以在不改变主合约的情况下升级子合约。”因此这个合约提供了两个函数<code>setSaleAuctionAddress()</code>和<code>setSiringAuctionAddress</code>用来设置子合约的地址，以便更方便的升级子合约。从安全性来讲这的确有利于代码的修复与升级，但是从另外一个角度来讲，合约中的CEO就有了任意更改拍卖规则的权利。</p> 
  <h2 id="6-kittyminting初代喵">6 KittyMinting：初代喵</h2> 
  <p>这部分合约规定了有合约生成的初代喵的个数，合约中是通过硬编码的形式写入的，</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// Limits the number of cats the contract owner can ever create.</span>
    uint256 <span class="hljs-keyword">public</span> constant PROMO_CREATION_LIMIT = <span class="hljs-number">5000</span>;
    uint256 <span class="hljs-keyword">public</span> constant GEN0_CREATION_LIMIT = <span class="hljs-number">45000</span>;</code></pre> 
  <p>其中5000指的是用来促销的喵的数量，45000指的是合约产生初代喵的限制，产生的过程是分别通过调用<code>createPromoKitty()</code>和<code>createGen0Auction()</code>，通过<code>createGen0Auction()</code>产生的喵会被直接挂到拍卖场上，价格是通过<code>过去5只初代喵的平均价格*1.5</code>来作为初始价格。这两个函数都只能由COO来调用，并且创建是可以直接传入基因，也就是说COO可以将任意一直喵复制出来最多5000份，所以你觉得独一无二的喵也许并不像你想象中那么独特。</p> 
  <h2 id="7-kittycore主合约">7 KittyCore：主合约</h2> 
  <p>主合约的作用是控制合约的运行与更新，它继承了以上所有的合约，所以也就包括了以上所有的存储结构和函数。合约通过变量<code>paused</code>来控制停止与运行，通过<code>setNewAddress()</code>函数来设置合约更新的地址，通过<code>unpaused()</code>函数来启动合约。同时还包括两个外部调用函数<code>getKitty()</code>和<code>withdrawBalance()</code>，其中<code>getKitty()</code>是用来读取每只喵的所有属性，应该是应用于web server的后台；而<code>withdrawBalance()</code>则是用于提取合约中所有的余额，但是要保留pregnant kitties繁殖的费用，因为这需要从外部调用<code>giveBirth()</code>函数。</p> 
  <h2 id="总结">总结</h2> 
  <p>如果从实际运行效果来看的话，不得不说这个项目非常的成功，至少到目前为止还占据了网络的一大部交易量，作为一个区块链应用，也的确是能够把握住时代的潮流，但是从上述代码来看还存在几个问题：</p> 
  <ul> 
   <li>所有的喵本质上只是一个256位的整数，解释权都归前端所有；</li> 
   <li>CEO具有控制应用运行的绝对权利，可以无条件暂停合约或者更新子合约；</li> 
   <li>开源的合约却又调用了非开源的合约（gene science）。</li> 
  </ul> 
  <p>最后一个可能不能称之为问题，但是从我个人来讲开源就应该全部开源，如果能gene science这部分替换为开源的随机基因组合可能会更好，至少不会让其他人觉得这其中有什么猫腻。但是前面两个问题却是的的确确存在的，所以从技术上来讲这并不能完全算是个区块链应用，但却是个不错且成功的尝试！</p> 
  <h2 id="参考资料">参考资料</h2> 
  <ul> 
   <li><a href="https://medium.com/loom-network/your-crypto-kitty-isnt-forever-why-dapps-aren-t-as-decentralized-as-you-think-871d6acfea" rel="nofollow" target="_blank">https://medium.com/loom-network/your-crypto-kitty-isnt-forever-why-dapps-aren-t-as-decentralized-as-you-think-871d6acfea</a></li> 
   <li><a href="https://medium.com/loom-network/how-to-code-your-own-cryptokitties-style-game-on-ethereum-7c8ac86a4eb3" rel="nofollow" target="_blank">https://medium.com/loom-network/how-to-code-your-own-cryptokitties-style-game-on-ethereum-7c8ac86a4eb3</a></li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78768546,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78768546,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
