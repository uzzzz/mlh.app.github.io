<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>手把手｜ 用Python代码建个数据实验室，顺利入坑比特币 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="手把手｜ 用Python代码建个数据实验室，顺利入坑比特币" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者：Patrick Triest 编译：Katherine Hou、林海、Shan LIU、高宁、Yawei 比特币市场到底是如何运作的？数字加密货币（cryptocurrency）跌宕起伏的原因是什么？不同的山寨币（altcoins）市场之间是紧密联系还是各自为营？我们该如何预测接下来将发生什么？ 关于数字加密货币（如：比特币和以太坊）的文章铺天盖地，数百个自诩专家的作者各自发表着他们对比特币未来的猜想。而用来支持他们观点的这些分析中强有力的数据和统计学基础却乏善可陈。 这篇文章的目的是简单介绍“如何用Python来分析数字加密货币”。我们将用简单的Python代码来检索、分析和可视化不同的数字货币数据。在这个过程中，我们将揭示一个有趣的趋势：这些不稳定的市场是如何运作的，它们又是如何发展的。 这不是一篇解释数字加密货币是什么的科普贴（如果你需要，我推荐这篇很棒的概述），这也不是一篇讲哪个货币会升值、哪个会贬值的观点性文章。相反，在这篇教程中，我们所关心的只是获取原始数据，并揭示隐藏在数字中的故事。 步骤1 - 配置你的数据实验室 这篇教材适合在不同技能水平上的爱好者、工程师和数据科学家们。要求的技能只是对Python有基础的了解，以及知道如何用命令建立一个项目。 包含运行结果的notebook完整版本可以在这里下载。 步骤1.1 - 安装 Anaconda 安装这个项目所需的所有相关环境，最简单的办法就是用Anaconda。它是一个打包的Python数据科学生态系统和依赖管理器。 推荐使用下面的官方安装指南来安装Anaconda&nbsp;https://www.continuum.io/downloads 如果你是一个高阶用户，而你不需要使用Anaconda，那也完全没有问题。我会假设你在安装必须的依赖环境时不需要帮助，你可以直接跳到第二部分。 步骤1.2 - 建立一个Anaconda项目环境 当Anaconda安装完成后，我们需要创建一个新的环境来管理我们的依赖包。运行&nbsp;conda create --name cryptocurrency-analysis python=3&nbsp;来为我们的项目创建一个新的Anaconda环境。接下来，运行source activate cryptocurrency-analysis ( Linux/macOS 系统) 或者 activate cryptocurrency-analysis (windows 系统) 来激活这个环境。 最后，运行 conda install numpy pandas nb_conda jupyter plotly quandl 来为这个环境安装所需的依赖包。完成这些需要几分钟的时间。 为什么要用环境？如果你打算在你的电脑上运行很多Python项目，那么分开不同项目的依赖包（软件库和包）来避免冲突是很有帮助的。 Ananconda会为每一个项目的依赖包创建一个特殊的环境目录，使得所有包都能妥善地被管理和区分。 步骤1.3 - 启动一个交互的Jupyter Notebook 当环境和依赖包都安装好之后，运行 jupyter notebook 来启动 iPython 内核，然后用你的浏览器访问http://localhost:8888/&nbsp;。创建一个新的Python notebook，确保它使用的内核是Python [conda env:cryptocurrency-analysis]。 步骤1.4 – 导入依赖包 当你打开了一个空的Jupyter notebook，我们要做的第一件事就是导入所需的依赖包。 import os import numpy as np import pandas as pd import pickle import quandl from datetime import datetime 我们还要导入Plotly来启用离线模式。 import plotly.offline as py import plotly.graph_objs as go import plotly.figure_factory as ff py.init_notebook_mode(connected=True) 步骤2 - 获得比特币的价格数据 一切就绪，我们可以开始获取要分析的数据了。首先，我们要用Quandl的免费比特币接口来获得比特币的价格数据。 步骤2.1 - 编写Quandl帮助函数 为了方便数据获取，我们要编写一个函数来下载和同步来自Quandl（https://www.quandl.com/ 号称金融数据界的维基百科）的数据。 def get_quandl_data(quandl_id): &nbsp; &nbsp; &#39;&#39;&#39;Download and cache Quandl dataseries&#39;&#39;&#39; &nbsp; &nbsp; cache_path = &#39;{}.pkl&#39;.format(quandl_id).replace(&#39;/&#39;,&#39;-&#39;) &nbsp; &nbsp; try: &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path, &#39;rb&#39;) &nbsp; &nbsp; &nbsp; &nbsp; df = pickle.load(f) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&#39;Loaded {} from cache&#39;.format(quandl_id)) &nbsp; &nbsp; except (OSError, IOError) as e: &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Downloading {} from Quandl&#39;.format(quandl_id)) &nbsp; &nbsp; &nbsp; &nbsp; df = quandl.get(quandl_id, returns=&quot;pandas&quot;) &nbsp; &nbsp; &nbsp; &nbsp; df.to_pickle(cache_path) &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Cached {} at {}&#39;.format(quandl_id, cache_path)) &nbsp; &nbsp; return df 我们用pickle来序列化，把下载的数据存成文件，这样代码就不会在每次运行的时候重新下载同样的数据。这个函数将返回Pandas数据框（Dataframe）格式的数据。如果你对数据框不太熟悉，你可以把它想成是强大的电子表格。 步骤2.2 – 抓取Kraken交易所定价数据 我们首先来获取Kraken比特币交易所的历史比特币汇率。 # Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(&#39;BCHARTS/KRAKENUSD&#39;) 我们可以用head()方法来查看数据框的前五行。 btc_usd_price_kraken.head() &nbsp; 接下来，我们要做一个简单的图表，以此来快速地通过可视化的方法验证数据基本正确。 # Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[&#39;Weighted Price&#39;]) py.iplot([btc_trace]) &nbsp; 这里，我们用Plotly 来完成可视化部分。相对于使用一些更成熟的Python数据可视化库，例如Matplotlib ，用Plotly是一个不那么传统的选择，但我认为Plotly是一个不错的选择，因为它可以调用D3.js的充分交互式图表。这些图表有非常漂亮的默认设置，易于探索，而且非常方便嵌入到网页中。 我们可以将生成的图表与公开可用的比特币价格图表（如Coinbase上的图表）进行比较，作为一个快速的完整性检查，验证下载的数据是否合理。 步骤2.3 从更多的比特币交易所抓取价格数据 你可能已经注意到，上面的数据集中存在数据缺失现象－－特别是在2014年末和2016年初。在Kraken交易所的数据集中，这种数据缺失情况尤为明显。我们当然不希望这些数据会影响到我们对价格的全面分析。 比特币交易所的特点是，供需关系决定比特币的价格。因而，没有哪个交易的价格所能够成为市场的“主流价格”。为了解决这个问题，以及刚刚提到的数据缺失问题（可能是由于技术性断电和数据的差错），我们将从三家主要的比特币交易所抓取数据，进而计算出平均的比特币价格指数。 首先，我们把各个交易所的数据下载到到由字典类型的数据框中。 # Pull pricing data for 3 more BTC exchanges exchanges=[&#39;COINBASE&#39;,&#39;BITSTAMP&#39;,&#39;ITBIT&#39;]exchange_data={}exchange_data[&#39;KRAKEN&#39;]=btc_usd_price_kraken for exchange in exchanges:exchange_code=&#39;BCHARTS/{}USD&#39;.format(exchange)btc_exchange_df=get_quandl_data(exchange_code)exchange_data[exchange]=btc_exchange_df 步骤2.4 将所有价格数据整合到单一数据框之中 接下来，我们将要定义一个简单的函数，把各个数据框中共有的列合并为一个新的组合数据框。 def merge_dfs_on_column(dataframes, labels, col):&#39;&#39;&#39;Merge a single column of each dataframe into a new combined dataframe&#39;&#39;&#39;series_dict={} for index in range(len(dataframes)):series_dict[labels[index]]=dataframes[index][col]return pd.DataFrame(series_dict) &nbsp; 现在，基于各个数据集的“加权价格”列，把所有的数据框整合到一起。 # Merge the BTC price dataseries&#39; into a single dataframebtc_usd_datasets=merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()),&#39;Weighted Price&#39;) 最后，可以使用“tail()”方法，查看合并后数据的最后五行，以确保数据整合成功。 btc_usd_datasets.tail() &nbsp; 看起来，这些数据符合我们的预期：数据范围大致相同，只是基于各个交易所的供求关系而略有不同。 步骤2.5 价格数据的可视化 从逻辑上来说，下一步就是通过可视化，将这些数据进行比对。为此，我们需要先定义一个辅助函数，通过提供单行命令使用数据制作图表。 def df_scatter(df, title,seperate_y_axis=False,y_axis_label=&#39;&#39;, scale=&#39;linear&#39;,initial_hide=False):&#39;&#39;&#39;Generate a scatter plot of the entire dataframe&#39;&#39;&#39;label_arr= list(df)series_arr= list(map(lambda col:df[col],label_arr)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout =go.Layout(title=title, legend=dict(orientation=&quot;h&quot;), xaxis=dict(type=&#39;date&#39;), yaxis=dict(title=y_axis_label, showticklabels=notseperate_y_axis, type=scale))y_axis_config=dict(overlaying=&#39;y&#39;, showticklabels=False, &nbsp;type=scale ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visibility =&#39;visible&#39;ifinitial_hide: visibility =&#39;legendonly&#39;# Form Trace For Each Seriestrace_arr=[]for index, series in enumerate(series_arr): &nbsp; &nbsp; &nbsp; &nbsp; trace =go.Scatter(x=series.index, y=series, name=label_arr[index], visible=visibility)# Add seperate axis for the seriesif seperate_y_axis: trace[&#39;yaxis&#39;]=&#39;y{}&#39;.format(index +1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layout[&#39;yaxis{}&#39;.format(index +1)]=y_axis_configtrace_arr.append(trace) &nbsp; &nbsp; &nbsp;fig =go.Figure(data=trace_arr, layout=layout)py.iplot(fig) 为简便起见，我不会过多探讨这个辅助函数的工作原理。如果想了解更多，请查看Pandas&nbsp;和&nbsp;Plotly的说明文件。 现在，我们就可以轻松制作比特币价格数据的图形了！ # Plot all of the BTC exchange pricesdf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) &nbsp; 步骤2.6 清理并加总价格数据 从以上图形中可以看到，尽管这四个系列数据遵循大致相同的路径，但其中还是有一些不规则的变化，我们将设法清除这些异常变化。 在2012-2017年的时间段中，我们知道比特币的价格从来没有等于零的时候，所以我们先去除数据框中所有的零值。 # Remove &quot;0&quot; valuesbtc_usd_datasets.replace(0,np.nan,inplace=True) &nbsp; 在重新构建数据框之后，我们可以看到更加清晰的图形，没有缺失数据的情况了。 # Plot the revised dataframedf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) 我们现在可以计算一个新的列：所有交易所的比特币日平均价格。 # Calculate the average BTC price as a new columnbtc_usd_datasets[&#39;avg_btc_price_usd&#39;]=btc_usd_datasets.mean(axis=1) &nbsp; 新的一列就是比特币的价格指数！我们再把它画出来，以核对该数据看起来是否有问题。 # Plot the average BTC pricebtc_trace=go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[&#39;avg_btc_price_usd&#39;])py.iplot([btc_trace]) &nbsp; 太好了，看起来确实没有问题。稍后，我们将继续使用这个加总的价格序列数据，以便能够确定其他数字货币与美元之间的兑换汇率。 步骤3 获取山寨币（Altcoins）价格 现在，我们已经有了比特币价格的时间序列数据了。接下来我们来看看非比特币的数字加密货币的一些数据，一般是指山寨币（Altcoins）。 步骤3.1 定义Poloniex交易所的API辅助函数 我们将使用Poloniex API来获取数字加密货币交易的数据信息。我们定义了两个辅助函数来获取山寨币的相关数据，这两个函数主要是通过这个API下载和缓存JSON数据。 首先，我们定义函数get_json_data，它将从给定的URL中下载和缓存JSON数据。 defget_json_data(json_url,cache_path):&#39;&#39;&#39;Download and cache JSON data, return as a dataframe.&#39;&#39;&#39;try: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path,&#39;rb&#39;)df=pickle.load(f)print(&#39;Loaded {} from cache&#39;.format(json_url))except(OSError,IOError) as e:print(&#39;Downloading {}&#39;.format(json_url))df=pd.read_json(json_url)df.to_pickle(cache_path)print(&#39;Cached {} at {}&#39;.format(json_url,cache_path))return df 然后，我们定义一个新的函数，该函数将产生Poloniex API的HTTP请求，并调用刚刚定义的get_json_data函数，以保存调用的数据结果。 base_polo_url=&#39;https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}&#39;start_date=datetime.strptime(&#39;2015-01-01&#39;,&#39;%Y-%m-%d&#39;)# get data from the start of 2015end_date=datetime.now()# up until todaypediod=86400# pull daily data (86,400 seconds per day)def get_crypto_data(poloniex_pair):&#39;&#39;&#39;Retrieve cryptocurrency data from poloniex&#39;&#39;&#39;json_url=base_polo_url.format(poloniex_pair,start_date.timestamp(),end_date.timestamp(),pediod)data_df=get_json_data(json_url,poloniex_pair)data_df=data_df.set_index(&#39;date&#39;)return data_df 上述函数将抽取加密货币配对字符代码（比如“BTC_ETH”），并返回包含两种货币历史兑换汇率的数据框。 步骤3.2 从Poloniex下载交易数据 绝大多数山寨币都无法使用美元直接购买，个人要想获取这些电子货币，通常都得先买比特币，再根据加密货币兑换汇率，兑换成山寨币。因而，我们就得下载每一种加密货币兑换比特币的兑换汇率，然后再使用现有比特币价格数据转换成美元。 我们会下载9种排名靠前的加密货币交易数据：Ethereum，Litecoin，Ripple，Ethereum Classic，Stellar，Dash，Siacoin，Monero，和NEM。 altcoins=[&#39;ETH&#39;,&#39;LTC&#39;,&#39;XRP&#39;,&#39;ETC&#39;,&#39;STR&#39;,&#39;DASH&#39;,&#39;SC&#39;,&#39;XMR&#39;,&#39;XEM&#39;]altcoin_data={} for altcoin in altcoins:coinpair=&#39;BTC_{}&#39;.format(altcoin)crypto_price_df=get_crypto_data(coinpair)altcoin_data[altcoin]=crypto_price_df 现在，我们有了包含9个数据框的字典，每种都包含山寨币与比特币之间的历史日平均价格数据。 我们可以通过Ethereum价格表格的最后几行，来判定数据是否可用。 altcoin_data[&#39;ETH&#39;].tail()&nbsp; &nbsp; &nbsp; 步骤3.3 – 统一货币单位：美元 现在，我们可以将BTC-山寨币汇率数据与我们的比特币价格指数结合，来直接计算每一个山寨币的历史价格（单位：美元）。 # Calculate USD Price as a new column in each altcoin dataframe for altcoin in altcoin_data.keys(): &nbsp; &nbsp; altcoin_data[altcoin][&#39;price_usd&#39;] = &nbsp;altcoin_data[altcoin][&#39;weightedAverage&#39;] * btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 此处，我们为每一个山寨币的数据框新增一列存储其相应的美元价格。 接着，我们可以重新使用之前定义的函数merge_dfs_on_column，来建立一个合并的数据框，整合每种电子货币的美元价格。 # Merge USD price of each altcoin into single dataframe &nbsp;combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), &#39;price_usd&#39;) 就是如此简单！ 现在让我们同时把比特币价格作为最后一栏添加到合并后的数据框中。 # Add BTC price to the dataframe combined_df[&#39;BTC&#39;] = btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 现在我们有一个唯一的数据框，它包含了我们正在验证的十种电子货币的每日美元价格。 我们重新调用之前的函数df_scatter，以图表形式展现全部山寨币的相应价格。 # Chart all of the altocoin prices df_scatter(combined_df, &#39;Cryptocurrency Prices (USD)&#39;, seperate_y_axis=False, y_axis_label=&#39;Coin Value (USD)&#39;, scale=&#39;log&#39;) 看起来不错！这张图为我们展现了每一种货币兑换汇率在过去几年的变化情况的一个全貌。 在这里我们使用了对数规格的y轴，在同一绘图上比较所有货币。你也可以尝试其他不同的参数值(例如scale=&#39;linear&#39;)，可以从不同视角理解数据。 步骤3.4- 执行相关性分析 你可能注意到电子货币的汇率看上去似乎是相关的，尽管他们的货币价值相差很大，而且波动性很高。尤其是从2017年4月的迅猛上涨开始，甚至很多的小波动似乎都与整个市场的波动同步出现。 当然，有数据支撑的结论比依据图像而产生的直觉更有说服力。 我们可以利用Pandas corr()函数来验证上述的相关性假设。该检验手段为数据框的每一栏计算了其对应另一栏的皮尔森相关系数。 8/22/2017修订说明-这部分的修改是为了在计算相关系数时使用每日回报率而不是价格的绝对值。 基于一个非稳态时间序列（例如原始的价格数据）直接计算可能会导致相关性系数的偏差。针对此问题，我们的解决方案是使用pct_change()方法，将数据框中的每一个的价格绝对值转化为相应的日回报率。 首先，我们来计算2016年的相关系数。 # Calculate the pearson correlation coefficients for cryptocurrencies in 2016 combined_df_2016 = combined_df[combined_df.index.year == 2016] combined_df_2016.pct_change().corr(method=&#39;pearson&#39;) 上面这张图显示的都是相关系数。系数接近1或-1，分别意味着这一序列是强正相关的，或逆相关的，相关系数趋近于0则说明相应对象并不相关，他们的波动是相互独立的。 为了更可视化的展示结果，我们创建了一个新的可视化的帮助函数。 def correlation_heatmap(df, title, absolute_bounds=True): &nbsp; &nbsp; &#39;&#39;&#39;Plot a correlation heatmap for the entire dataframe&#39;&#39;&#39; &nbsp; &nbsp; heatmap = go.Heatmap( &nbsp; &nbsp; &nbsp; &nbsp; z=df.corr(method=&#39;pearson&#39;).as_matrix(), x=df.columns, &nbsp; &nbsp; &nbsp; &nbsp; y=df.columns, colorbar=dict(title=&#39;Pearson Coefficient&#39;), ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout = go.Layout(title=title) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if absolute_bounds: heatmap[&#39;zmax&#39;] = 1.0 &nbsp; &nbsp; &nbsp; &nbsp; heatmap[&#39;zmin&#39;] = -1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fig = go.Figure(data=[heatmap], layout=layout) &nbsp; &nbsp; py.iplot(fig) correlation_heatmap(combined_df_2016.pct_change(), &quot;Cryptocurrency Correlations in 2016&quot;) &nbsp; 图示为2016年的电子货币相关系数 此处，深红色的数值代表强相关性(每一种货币显然是与其自身高度相关的)，深蓝色的数值表示强逆相关性。所有介于中间的颜色-浅蓝/橙/灰/茶色-其数值代表不同程度的弱相关或不相关。 这张图表说明了什么呢？关键在于，它说明了不同的数字加密货币价格在2016年间的波动情况，几乎没有统计上的显著相关性。 现在，为了验证我们的假设-电子货币在近几个月的相关性增强，接下来，我们将使用从2017年开始的数据来重复同样的测试。 combined_df_2017 = combined_df[combined_df.index.year == 2017] combined_df_2017.pct_change().corr(method=&#39;pearson&#39;) 上图似乎显示了更强的相关性。但这些数据可以单独作为投资决策的依据吗？答案是否定的。 然而值得注意得是，在这张图上几乎所有的电子货币相互之间都变得相关性更强了。 correlation_heatmap(combined_df_2017.pct_change(), &quot;Cryptocurrency Correlations in 2017&quot;) 图：2017年的电子货币相关性 这是不是相当有趣呢！？ 为什么？ 好问题！其实，我也不是很确定。。。 我的第一反应是，对冲基金最近开始公开在电子货币市场交易[1][2]。这些基金持有远超于普通交易人的大量资本，当一支基金如果在多种加密货币间对冲自己的投入资本，然后根据独立变量（比如说，股票市场）对每一种货币使用相似的交易策略。如果从这个角度来看，出现这种越来越强的相关性趋势是合理的。 更深度的理解XRP和STR 例如，从上图中可以很明显看出XRP（Ripple的代币）是与其他电子货币相关性最低的。但这里有一个值得注意的例外是STR（Stellar的代币，官方名字是&quot;Lumens&quot;)，与XRP有强相关关系(相关系数：0.62)。 有趣的是，Stellar和Ripple是非常相似的金融科技平台，他们都旨在减少银行间跨国转账时的繁琐步骤。 可想而知，考虑到区块链服务使用代币的相似性，一些大玩家以及对冲基金可能会对他们在Stellar和Ripple上的投资使用相似的交易战略。这可能就是为什么XRP相比其他电子货币，与STR有更强相关性的原因。 快讯-我是Chipper的合作人之一。Chipper是一家使用Stella的非常早期的初创企业，旨在颠覆非洲的小额汇款行业。 现在，到你了！ 然而，这一解释在很大程度上是推测性的，可能你会做的更好。基于我们已经奠定的基础，你有成百上千条不同的方法可以继续探索数据中蕴藏的故事。 可以考虑从以下思路入手: 为整个分析添加更多加密货币的数据 调整相关性分析的时间范围和颗粒度，以得到优化的或粗粒度的趋势视图。 从交易量或区块链数据挖掘集中寻找趋势。相较于原始的价格数据，如果你想预测未来价格波动，你可以更需要买/卖量的比率数据。 在股票、商品、法定货币上加入价格数据来决定他们当中哪一项与电子货币具有相关性（但是，别忘了那句老话“相关不蕴含因果”） 使用Event Registry, GDELT,以及Google Trends来量化围绕着特定电子货币的“热词”数量。 利用数据训练一个预测性机器学习模型，来预测明日价格。如果你有更大的雄心壮志，你甚至可以考虑尝试用循环神经网络（RNN）进行上述训练。 利用你的分析来创建一个自动化的交易机器人，通过对应的应用编程接口（API），应用在例如“Poloniex”或“Coinbase”的交易网站上。请小心:一个性能欠佳的机器人可以轻易地让你的资产瞬间灰飞烟灭。 关于比特币，以及对于加密货币总体而言，最好的部分是它们的去中心化本质，这使得它比任何其他资产都自由、民主。可以将你的分析开源共享，参与到社区中，或者写一篇博客！ 希望你现在已经掌握了自行分析所需的技能，以及在未来读到任何投机性的加密货币的文章时，进行辩证思考的能力，尤其是那些没有数据支撑的预测。 感谢你的阅读，关于这一教程，如果你有任何看法、建议或批评指正，请在下方留言。如果你发现代码如果有问题，也可以点在Github仓库中新建一个问题（issue）。 http://fortune.com/2017/07/26/bitcoin-cryptocurrency-hedge-fund-sequoia-andreessen-horowitz-metastable/&nbsp; https://www.forbes.com/sites/laurashin/2017/07/12/crypto-boom-15-new-hedge-funds-want-in-on-84000-returns/#7946ab0d416a&nbsp; &nbsp; 原文链接：https://blog.patricktriest.com/analyzing-cryptocurrencies-python/ &nbsp; 志愿者介绍 回复“志愿者”加入我们 往期精彩文章 点击图片阅读 强壮的男性 &amp; 有想法的女性：分析34476个漫画角色，超级英雄中的性别透析 阅读更多" />
<meta property="og:description" content="作者：Patrick Triest 编译：Katherine Hou、林海、Shan LIU、高宁、Yawei 比特币市场到底是如何运作的？数字加密货币（cryptocurrency）跌宕起伏的原因是什么？不同的山寨币（altcoins）市场之间是紧密联系还是各自为营？我们该如何预测接下来将发生什么？ 关于数字加密货币（如：比特币和以太坊）的文章铺天盖地，数百个自诩专家的作者各自发表着他们对比特币未来的猜想。而用来支持他们观点的这些分析中强有力的数据和统计学基础却乏善可陈。 这篇文章的目的是简单介绍“如何用Python来分析数字加密货币”。我们将用简单的Python代码来检索、分析和可视化不同的数字货币数据。在这个过程中，我们将揭示一个有趣的趋势：这些不稳定的市场是如何运作的，它们又是如何发展的。 这不是一篇解释数字加密货币是什么的科普贴（如果你需要，我推荐这篇很棒的概述），这也不是一篇讲哪个货币会升值、哪个会贬值的观点性文章。相反，在这篇教程中，我们所关心的只是获取原始数据，并揭示隐藏在数字中的故事。 步骤1 - 配置你的数据实验室 这篇教材适合在不同技能水平上的爱好者、工程师和数据科学家们。要求的技能只是对Python有基础的了解，以及知道如何用命令建立一个项目。 包含运行结果的notebook完整版本可以在这里下载。 步骤1.1 - 安装 Anaconda 安装这个项目所需的所有相关环境，最简单的办法就是用Anaconda。它是一个打包的Python数据科学生态系统和依赖管理器。 推荐使用下面的官方安装指南来安装Anaconda&nbsp;https://www.continuum.io/downloads 如果你是一个高阶用户，而你不需要使用Anaconda，那也完全没有问题。我会假设你在安装必须的依赖环境时不需要帮助，你可以直接跳到第二部分。 步骤1.2 - 建立一个Anaconda项目环境 当Anaconda安装完成后，我们需要创建一个新的环境来管理我们的依赖包。运行&nbsp;conda create --name cryptocurrency-analysis python=3&nbsp;来为我们的项目创建一个新的Anaconda环境。接下来，运行source activate cryptocurrency-analysis ( Linux/macOS 系统) 或者 activate cryptocurrency-analysis (windows 系统) 来激活这个环境。 最后，运行 conda install numpy pandas nb_conda jupyter plotly quandl 来为这个环境安装所需的依赖包。完成这些需要几分钟的时间。 为什么要用环境？如果你打算在你的电脑上运行很多Python项目，那么分开不同项目的依赖包（软件库和包）来避免冲突是很有帮助的。 Ananconda会为每一个项目的依赖包创建一个特殊的环境目录，使得所有包都能妥善地被管理和区分。 步骤1.3 - 启动一个交互的Jupyter Notebook 当环境和依赖包都安装好之后，运行 jupyter notebook 来启动 iPython 内核，然后用你的浏览器访问http://localhost:8888/&nbsp;。创建一个新的Python notebook，确保它使用的内核是Python [conda env:cryptocurrency-analysis]。 步骤1.4 – 导入依赖包 当你打开了一个空的Jupyter notebook，我们要做的第一件事就是导入所需的依赖包。 import os import numpy as np import pandas as pd import pickle import quandl from datetime import datetime 我们还要导入Plotly来启用离线模式。 import plotly.offline as py import plotly.graph_objs as go import plotly.figure_factory as ff py.init_notebook_mode(connected=True) 步骤2 - 获得比特币的价格数据 一切就绪，我们可以开始获取要分析的数据了。首先，我们要用Quandl的免费比特币接口来获得比特币的价格数据。 步骤2.1 - 编写Quandl帮助函数 为了方便数据获取，我们要编写一个函数来下载和同步来自Quandl（https://www.quandl.com/ 号称金融数据界的维基百科）的数据。 def get_quandl_data(quandl_id): &nbsp; &nbsp; &#39;&#39;&#39;Download and cache Quandl dataseries&#39;&#39;&#39; &nbsp; &nbsp; cache_path = &#39;{}.pkl&#39;.format(quandl_id).replace(&#39;/&#39;,&#39;-&#39;) &nbsp; &nbsp; try: &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path, &#39;rb&#39;) &nbsp; &nbsp; &nbsp; &nbsp; df = pickle.load(f) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&#39;Loaded {} from cache&#39;.format(quandl_id)) &nbsp; &nbsp; except (OSError, IOError) as e: &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Downloading {} from Quandl&#39;.format(quandl_id)) &nbsp; &nbsp; &nbsp; &nbsp; df = quandl.get(quandl_id, returns=&quot;pandas&quot;) &nbsp; &nbsp; &nbsp; &nbsp; df.to_pickle(cache_path) &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Cached {} at {}&#39;.format(quandl_id, cache_path)) &nbsp; &nbsp; return df 我们用pickle来序列化，把下载的数据存成文件，这样代码就不会在每次运行的时候重新下载同样的数据。这个函数将返回Pandas数据框（Dataframe）格式的数据。如果你对数据框不太熟悉，你可以把它想成是强大的电子表格。 步骤2.2 – 抓取Kraken交易所定价数据 我们首先来获取Kraken比特币交易所的历史比特币汇率。 # Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(&#39;BCHARTS/KRAKENUSD&#39;) 我们可以用head()方法来查看数据框的前五行。 btc_usd_price_kraken.head() &nbsp; 接下来，我们要做一个简单的图表，以此来快速地通过可视化的方法验证数据基本正确。 # Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[&#39;Weighted Price&#39;]) py.iplot([btc_trace]) &nbsp; 这里，我们用Plotly 来完成可视化部分。相对于使用一些更成熟的Python数据可视化库，例如Matplotlib ，用Plotly是一个不那么传统的选择，但我认为Plotly是一个不错的选择，因为它可以调用D3.js的充分交互式图表。这些图表有非常漂亮的默认设置，易于探索，而且非常方便嵌入到网页中。 我们可以将生成的图表与公开可用的比特币价格图表（如Coinbase上的图表）进行比较，作为一个快速的完整性检查，验证下载的数据是否合理。 步骤2.3 从更多的比特币交易所抓取价格数据 你可能已经注意到，上面的数据集中存在数据缺失现象－－特别是在2014年末和2016年初。在Kraken交易所的数据集中，这种数据缺失情况尤为明显。我们当然不希望这些数据会影响到我们对价格的全面分析。 比特币交易所的特点是，供需关系决定比特币的价格。因而，没有哪个交易的价格所能够成为市场的“主流价格”。为了解决这个问题，以及刚刚提到的数据缺失问题（可能是由于技术性断电和数据的差错），我们将从三家主要的比特币交易所抓取数据，进而计算出平均的比特币价格指数。 首先，我们把各个交易所的数据下载到到由字典类型的数据框中。 # Pull pricing data for 3 more BTC exchanges exchanges=[&#39;COINBASE&#39;,&#39;BITSTAMP&#39;,&#39;ITBIT&#39;]exchange_data={}exchange_data[&#39;KRAKEN&#39;]=btc_usd_price_kraken for exchange in exchanges:exchange_code=&#39;BCHARTS/{}USD&#39;.format(exchange)btc_exchange_df=get_quandl_data(exchange_code)exchange_data[exchange]=btc_exchange_df 步骤2.4 将所有价格数据整合到单一数据框之中 接下来，我们将要定义一个简单的函数，把各个数据框中共有的列合并为一个新的组合数据框。 def merge_dfs_on_column(dataframes, labels, col):&#39;&#39;&#39;Merge a single column of each dataframe into a new combined dataframe&#39;&#39;&#39;series_dict={} for index in range(len(dataframes)):series_dict[labels[index]]=dataframes[index][col]return pd.DataFrame(series_dict) &nbsp; 现在，基于各个数据集的“加权价格”列，把所有的数据框整合到一起。 # Merge the BTC price dataseries&#39; into a single dataframebtc_usd_datasets=merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()),&#39;Weighted Price&#39;) 最后，可以使用“tail()”方法，查看合并后数据的最后五行，以确保数据整合成功。 btc_usd_datasets.tail() &nbsp; 看起来，这些数据符合我们的预期：数据范围大致相同，只是基于各个交易所的供求关系而略有不同。 步骤2.5 价格数据的可视化 从逻辑上来说，下一步就是通过可视化，将这些数据进行比对。为此，我们需要先定义一个辅助函数，通过提供单行命令使用数据制作图表。 def df_scatter(df, title,seperate_y_axis=False,y_axis_label=&#39;&#39;, scale=&#39;linear&#39;,initial_hide=False):&#39;&#39;&#39;Generate a scatter plot of the entire dataframe&#39;&#39;&#39;label_arr= list(df)series_arr= list(map(lambda col:df[col],label_arr)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout =go.Layout(title=title, legend=dict(orientation=&quot;h&quot;), xaxis=dict(type=&#39;date&#39;), yaxis=dict(title=y_axis_label, showticklabels=notseperate_y_axis, type=scale))y_axis_config=dict(overlaying=&#39;y&#39;, showticklabels=False, &nbsp;type=scale ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visibility =&#39;visible&#39;ifinitial_hide: visibility =&#39;legendonly&#39;# Form Trace For Each Seriestrace_arr=[]for index, series in enumerate(series_arr): &nbsp; &nbsp; &nbsp; &nbsp; trace =go.Scatter(x=series.index, y=series, name=label_arr[index], visible=visibility)# Add seperate axis for the seriesif seperate_y_axis: trace[&#39;yaxis&#39;]=&#39;y{}&#39;.format(index +1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layout[&#39;yaxis{}&#39;.format(index +1)]=y_axis_configtrace_arr.append(trace) &nbsp; &nbsp; &nbsp;fig =go.Figure(data=trace_arr, layout=layout)py.iplot(fig) 为简便起见，我不会过多探讨这个辅助函数的工作原理。如果想了解更多，请查看Pandas&nbsp;和&nbsp;Plotly的说明文件。 现在，我们就可以轻松制作比特币价格数据的图形了！ # Plot all of the BTC exchange pricesdf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) &nbsp; 步骤2.6 清理并加总价格数据 从以上图形中可以看到，尽管这四个系列数据遵循大致相同的路径，但其中还是有一些不规则的变化，我们将设法清除这些异常变化。 在2012-2017年的时间段中，我们知道比特币的价格从来没有等于零的时候，所以我们先去除数据框中所有的零值。 # Remove &quot;0&quot; valuesbtc_usd_datasets.replace(0,np.nan,inplace=True) &nbsp; 在重新构建数据框之后，我们可以看到更加清晰的图形，没有缺失数据的情况了。 # Plot the revised dataframedf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) 我们现在可以计算一个新的列：所有交易所的比特币日平均价格。 # Calculate the average BTC price as a new columnbtc_usd_datasets[&#39;avg_btc_price_usd&#39;]=btc_usd_datasets.mean(axis=1) &nbsp; 新的一列就是比特币的价格指数！我们再把它画出来，以核对该数据看起来是否有问题。 # Plot the average BTC pricebtc_trace=go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[&#39;avg_btc_price_usd&#39;])py.iplot([btc_trace]) &nbsp; 太好了，看起来确实没有问题。稍后，我们将继续使用这个加总的价格序列数据，以便能够确定其他数字货币与美元之间的兑换汇率。 步骤3 获取山寨币（Altcoins）价格 现在，我们已经有了比特币价格的时间序列数据了。接下来我们来看看非比特币的数字加密货币的一些数据，一般是指山寨币（Altcoins）。 步骤3.1 定义Poloniex交易所的API辅助函数 我们将使用Poloniex API来获取数字加密货币交易的数据信息。我们定义了两个辅助函数来获取山寨币的相关数据，这两个函数主要是通过这个API下载和缓存JSON数据。 首先，我们定义函数get_json_data，它将从给定的URL中下载和缓存JSON数据。 defget_json_data(json_url,cache_path):&#39;&#39;&#39;Download and cache JSON data, return as a dataframe.&#39;&#39;&#39;try: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path,&#39;rb&#39;)df=pickle.load(f)print(&#39;Loaded {} from cache&#39;.format(json_url))except(OSError,IOError) as e:print(&#39;Downloading {}&#39;.format(json_url))df=pd.read_json(json_url)df.to_pickle(cache_path)print(&#39;Cached {} at {}&#39;.format(json_url,cache_path))return df 然后，我们定义一个新的函数，该函数将产生Poloniex API的HTTP请求，并调用刚刚定义的get_json_data函数，以保存调用的数据结果。 base_polo_url=&#39;https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}&#39;start_date=datetime.strptime(&#39;2015-01-01&#39;,&#39;%Y-%m-%d&#39;)# get data from the start of 2015end_date=datetime.now()# up until todaypediod=86400# pull daily data (86,400 seconds per day)def get_crypto_data(poloniex_pair):&#39;&#39;&#39;Retrieve cryptocurrency data from poloniex&#39;&#39;&#39;json_url=base_polo_url.format(poloniex_pair,start_date.timestamp(),end_date.timestamp(),pediod)data_df=get_json_data(json_url,poloniex_pair)data_df=data_df.set_index(&#39;date&#39;)return data_df 上述函数将抽取加密货币配对字符代码（比如“BTC_ETH”），并返回包含两种货币历史兑换汇率的数据框。 步骤3.2 从Poloniex下载交易数据 绝大多数山寨币都无法使用美元直接购买，个人要想获取这些电子货币，通常都得先买比特币，再根据加密货币兑换汇率，兑换成山寨币。因而，我们就得下载每一种加密货币兑换比特币的兑换汇率，然后再使用现有比特币价格数据转换成美元。 我们会下载9种排名靠前的加密货币交易数据：Ethereum，Litecoin，Ripple，Ethereum Classic，Stellar，Dash，Siacoin，Monero，和NEM。 altcoins=[&#39;ETH&#39;,&#39;LTC&#39;,&#39;XRP&#39;,&#39;ETC&#39;,&#39;STR&#39;,&#39;DASH&#39;,&#39;SC&#39;,&#39;XMR&#39;,&#39;XEM&#39;]altcoin_data={} for altcoin in altcoins:coinpair=&#39;BTC_{}&#39;.format(altcoin)crypto_price_df=get_crypto_data(coinpair)altcoin_data[altcoin]=crypto_price_df 现在，我们有了包含9个数据框的字典，每种都包含山寨币与比特币之间的历史日平均价格数据。 我们可以通过Ethereum价格表格的最后几行，来判定数据是否可用。 altcoin_data[&#39;ETH&#39;].tail()&nbsp; &nbsp; &nbsp; 步骤3.3 – 统一货币单位：美元 现在，我们可以将BTC-山寨币汇率数据与我们的比特币价格指数结合，来直接计算每一个山寨币的历史价格（单位：美元）。 # Calculate USD Price as a new column in each altcoin dataframe for altcoin in altcoin_data.keys(): &nbsp; &nbsp; altcoin_data[altcoin][&#39;price_usd&#39;] = &nbsp;altcoin_data[altcoin][&#39;weightedAverage&#39;] * btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 此处，我们为每一个山寨币的数据框新增一列存储其相应的美元价格。 接着，我们可以重新使用之前定义的函数merge_dfs_on_column，来建立一个合并的数据框，整合每种电子货币的美元价格。 # Merge USD price of each altcoin into single dataframe &nbsp;combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), &#39;price_usd&#39;) 就是如此简单！ 现在让我们同时把比特币价格作为最后一栏添加到合并后的数据框中。 # Add BTC price to the dataframe combined_df[&#39;BTC&#39;] = btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 现在我们有一个唯一的数据框，它包含了我们正在验证的十种电子货币的每日美元价格。 我们重新调用之前的函数df_scatter，以图表形式展现全部山寨币的相应价格。 # Chart all of the altocoin prices df_scatter(combined_df, &#39;Cryptocurrency Prices (USD)&#39;, seperate_y_axis=False, y_axis_label=&#39;Coin Value (USD)&#39;, scale=&#39;log&#39;) 看起来不错！这张图为我们展现了每一种货币兑换汇率在过去几年的变化情况的一个全貌。 在这里我们使用了对数规格的y轴，在同一绘图上比较所有货币。你也可以尝试其他不同的参数值(例如scale=&#39;linear&#39;)，可以从不同视角理解数据。 步骤3.4- 执行相关性分析 你可能注意到电子货币的汇率看上去似乎是相关的，尽管他们的货币价值相差很大，而且波动性很高。尤其是从2017年4月的迅猛上涨开始，甚至很多的小波动似乎都与整个市场的波动同步出现。 当然，有数据支撑的结论比依据图像而产生的直觉更有说服力。 我们可以利用Pandas corr()函数来验证上述的相关性假设。该检验手段为数据框的每一栏计算了其对应另一栏的皮尔森相关系数。 8/22/2017修订说明-这部分的修改是为了在计算相关系数时使用每日回报率而不是价格的绝对值。 基于一个非稳态时间序列（例如原始的价格数据）直接计算可能会导致相关性系数的偏差。针对此问题，我们的解决方案是使用pct_change()方法，将数据框中的每一个的价格绝对值转化为相应的日回报率。 首先，我们来计算2016年的相关系数。 # Calculate the pearson correlation coefficients for cryptocurrencies in 2016 combined_df_2016 = combined_df[combined_df.index.year == 2016] combined_df_2016.pct_change().corr(method=&#39;pearson&#39;) 上面这张图显示的都是相关系数。系数接近1或-1，分别意味着这一序列是强正相关的，或逆相关的，相关系数趋近于0则说明相应对象并不相关，他们的波动是相互独立的。 为了更可视化的展示结果，我们创建了一个新的可视化的帮助函数。 def correlation_heatmap(df, title, absolute_bounds=True): &nbsp; &nbsp; &#39;&#39;&#39;Plot a correlation heatmap for the entire dataframe&#39;&#39;&#39; &nbsp; &nbsp; heatmap = go.Heatmap( &nbsp; &nbsp; &nbsp; &nbsp; z=df.corr(method=&#39;pearson&#39;).as_matrix(), x=df.columns, &nbsp; &nbsp; &nbsp; &nbsp; y=df.columns, colorbar=dict(title=&#39;Pearson Coefficient&#39;), ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout = go.Layout(title=title) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if absolute_bounds: heatmap[&#39;zmax&#39;] = 1.0 &nbsp; &nbsp; &nbsp; &nbsp; heatmap[&#39;zmin&#39;] = -1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fig = go.Figure(data=[heatmap], layout=layout) &nbsp; &nbsp; py.iplot(fig) correlation_heatmap(combined_df_2016.pct_change(), &quot;Cryptocurrency Correlations in 2016&quot;) &nbsp; 图示为2016年的电子货币相关系数 此处，深红色的数值代表强相关性(每一种货币显然是与其自身高度相关的)，深蓝色的数值表示强逆相关性。所有介于中间的颜色-浅蓝/橙/灰/茶色-其数值代表不同程度的弱相关或不相关。 这张图表说明了什么呢？关键在于，它说明了不同的数字加密货币价格在2016年间的波动情况，几乎没有统计上的显著相关性。 现在，为了验证我们的假设-电子货币在近几个月的相关性增强，接下来，我们将使用从2017年开始的数据来重复同样的测试。 combined_df_2017 = combined_df[combined_df.index.year == 2017] combined_df_2017.pct_change().corr(method=&#39;pearson&#39;) 上图似乎显示了更强的相关性。但这些数据可以单独作为投资决策的依据吗？答案是否定的。 然而值得注意得是，在这张图上几乎所有的电子货币相互之间都变得相关性更强了。 correlation_heatmap(combined_df_2017.pct_change(), &quot;Cryptocurrency Correlations in 2017&quot;) 图：2017年的电子货币相关性 这是不是相当有趣呢！？ 为什么？ 好问题！其实，我也不是很确定。。。 我的第一反应是，对冲基金最近开始公开在电子货币市场交易[1][2]。这些基金持有远超于普通交易人的大量资本，当一支基金如果在多种加密货币间对冲自己的投入资本，然后根据独立变量（比如说，股票市场）对每一种货币使用相似的交易策略。如果从这个角度来看，出现这种越来越强的相关性趋势是合理的。 更深度的理解XRP和STR 例如，从上图中可以很明显看出XRP（Ripple的代币）是与其他电子货币相关性最低的。但这里有一个值得注意的例外是STR（Stellar的代币，官方名字是&quot;Lumens&quot;)，与XRP有强相关关系(相关系数：0.62)。 有趣的是，Stellar和Ripple是非常相似的金融科技平台，他们都旨在减少银行间跨国转账时的繁琐步骤。 可想而知，考虑到区块链服务使用代币的相似性，一些大玩家以及对冲基金可能会对他们在Stellar和Ripple上的投资使用相似的交易战略。这可能就是为什么XRP相比其他电子货币，与STR有更强相关性的原因。 快讯-我是Chipper的合作人之一。Chipper是一家使用Stella的非常早期的初创企业，旨在颠覆非洲的小额汇款行业。 现在，到你了！ 然而，这一解释在很大程度上是推测性的，可能你会做的更好。基于我们已经奠定的基础，你有成百上千条不同的方法可以继续探索数据中蕴藏的故事。 可以考虑从以下思路入手: 为整个分析添加更多加密货币的数据 调整相关性分析的时间范围和颗粒度，以得到优化的或粗粒度的趋势视图。 从交易量或区块链数据挖掘集中寻找趋势。相较于原始的价格数据，如果你想预测未来价格波动，你可以更需要买/卖量的比率数据。 在股票、商品、法定货币上加入价格数据来决定他们当中哪一项与电子货币具有相关性（但是，别忘了那句老话“相关不蕴含因果”） 使用Event Registry, GDELT,以及Google Trends来量化围绕着特定电子货币的“热词”数量。 利用数据训练一个预测性机器学习模型，来预测明日价格。如果你有更大的雄心壮志，你甚至可以考虑尝试用循环神经网络（RNN）进行上述训练。 利用你的分析来创建一个自动化的交易机器人，通过对应的应用编程接口（API），应用在例如“Poloniex”或“Coinbase”的交易网站上。请小心:一个性能欠佳的机器人可以轻易地让你的资产瞬间灰飞烟灭。 关于比特币，以及对于加密货币总体而言，最好的部分是它们的去中心化本质，这使得它比任何其他资产都自由、民主。可以将你的分析开源共享，参与到社区中，或者写一篇博客！ 希望你现在已经掌握了自行分析所需的技能，以及在未来读到任何投机性的加密货币的文章时，进行辩证思考的能力，尤其是那些没有数据支撑的预测。 感谢你的阅读，关于这一教程，如果你有任何看法、建议或批评指正，请在下方留言。如果你发现代码如果有问题，也可以点在Github仓库中新建一个问题（issue）。 http://fortune.com/2017/07/26/bitcoin-cryptocurrency-hedge-fund-sequoia-andreessen-horowitz-metastable/&nbsp; https://www.forbes.com/sites/laurashin/2017/07/12/crypto-boom-15-new-hedge-funds-want-in-on-84000-returns/#7946ab0d416a&nbsp; &nbsp; 原文链接：https://blog.patricktriest.com/analyzing-cryptocurrencies-python/ &nbsp; 志愿者介绍 回复“志愿者”加入我们 往期精彩文章 点击图片阅读 强壮的男性 &amp; 有想法的女性：分析34476个漫画角色，超级英雄中的性别透析 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者：Patrick Triest 编译：Katherine Hou、林海、Shan LIU、高宁、Yawei 比特币市场到底是如何运作的？数字加密货币（cryptocurrency）跌宕起伏的原因是什么？不同的山寨币（altcoins）市场之间是紧密联系还是各自为营？我们该如何预测接下来将发生什么？ 关于数字加密货币（如：比特币和以太坊）的文章铺天盖地，数百个自诩专家的作者各自发表着他们对比特币未来的猜想。而用来支持他们观点的这些分析中强有力的数据和统计学基础却乏善可陈。 这篇文章的目的是简单介绍“如何用Python来分析数字加密货币”。我们将用简单的Python代码来检索、分析和可视化不同的数字货币数据。在这个过程中，我们将揭示一个有趣的趋势：这些不稳定的市场是如何运作的，它们又是如何发展的。 这不是一篇解释数字加密货币是什么的科普贴（如果你需要，我推荐这篇很棒的概述），这也不是一篇讲哪个货币会升值、哪个会贬值的观点性文章。相反，在这篇教程中，我们所关心的只是获取原始数据，并揭示隐藏在数字中的故事。 步骤1 - 配置你的数据实验室 这篇教材适合在不同技能水平上的爱好者、工程师和数据科学家们。要求的技能只是对Python有基础的了解，以及知道如何用命令建立一个项目。 包含运行结果的notebook完整版本可以在这里下载。 步骤1.1 - 安装 Anaconda 安装这个项目所需的所有相关环境，最简单的办法就是用Anaconda。它是一个打包的Python数据科学生态系统和依赖管理器。 推荐使用下面的官方安装指南来安装Anaconda&nbsp;https://www.continuum.io/downloads 如果你是一个高阶用户，而你不需要使用Anaconda，那也完全没有问题。我会假设你在安装必须的依赖环境时不需要帮助，你可以直接跳到第二部分。 步骤1.2 - 建立一个Anaconda项目环境 当Anaconda安装完成后，我们需要创建一个新的环境来管理我们的依赖包。运行&nbsp;conda create --name cryptocurrency-analysis python=3&nbsp;来为我们的项目创建一个新的Anaconda环境。接下来，运行source activate cryptocurrency-analysis ( Linux/macOS 系统) 或者 activate cryptocurrency-analysis (windows 系统) 来激活这个环境。 最后，运行 conda install numpy pandas nb_conda jupyter plotly quandl 来为这个环境安装所需的依赖包。完成这些需要几分钟的时间。 为什么要用环境？如果你打算在你的电脑上运行很多Python项目，那么分开不同项目的依赖包（软件库和包）来避免冲突是很有帮助的。 Ananconda会为每一个项目的依赖包创建一个特殊的环境目录，使得所有包都能妥善地被管理和区分。 步骤1.3 - 启动一个交互的Jupyter Notebook 当环境和依赖包都安装好之后，运行 jupyter notebook 来启动 iPython 内核，然后用你的浏览器访问http://localhost:8888/&nbsp;。创建一个新的Python notebook，确保它使用的内核是Python [conda env:cryptocurrency-analysis]。 步骤1.4 – 导入依赖包 当你打开了一个空的Jupyter notebook，我们要做的第一件事就是导入所需的依赖包。 import os import numpy as np import pandas as pd import pickle import quandl from datetime import datetime 我们还要导入Plotly来启用离线模式。 import plotly.offline as py import plotly.graph_objs as go import plotly.figure_factory as ff py.init_notebook_mode(connected=True) 步骤2 - 获得比特币的价格数据 一切就绪，我们可以开始获取要分析的数据了。首先，我们要用Quandl的免费比特币接口来获得比特币的价格数据。 步骤2.1 - 编写Quandl帮助函数 为了方便数据获取，我们要编写一个函数来下载和同步来自Quandl（https://www.quandl.com/ 号称金融数据界的维基百科）的数据。 def get_quandl_data(quandl_id): &nbsp; &nbsp; &#39;&#39;&#39;Download and cache Quandl dataseries&#39;&#39;&#39; &nbsp; &nbsp; cache_path = &#39;{}.pkl&#39;.format(quandl_id).replace(&#39;/&#39;,&#39;-&#39;) &nbsp; &nbsp; try: &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path, &#39;rb&#39;) &nbsp; &nbsp; &nbsp; &nbsp; df = pickle.load(f) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&#39;Loaded {} from cache&#39;.format(quandl_id)) &nbsp; &nbsp; except (OSError, IOError) as e: &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Downloading {} from Quandl&#39;.format(quandl_id)) &nbsp; &nbsp; &nbsp; &nbsp; df = quandl.get(quandl_id, returns=&quot;pandas&quot;) &nbsp; &nbsp; &nbsp; &nbsp; df.to_pickle(cache_path) &nbsp; &nbsp; &nbsp; &nbsp; print(&#39;Cached {} at {}&#39;.format(quandl_id, cache_path)) &nbsp; &nbsp; return df 我们用pickle来序列化，把下载的数据存成文件，这样代码就不会在每次运行的时候重新下载同样的数据。这个函数将返回Pandas数据框（Dataframe）格式的数据。如果你对数据框不太熟悉，你可以把它想成是强大的电子表格。 步骤2.2 – 抓取Kraken交易所定价数据 我们首先来获取Kraken比特币交易所的历史比特币汇率。 # Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(&#39;BCHARTS/KRAKENUSD&#39;) 我们可以用head()方法来查看数据框的前五行。 btc_usd_price_kraken.head() &nbsp; 接下来，我们要做一个简单的图表，以此来快速地通过可视化的方法验证数据基本正确。 # Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[&#39;Weighted Price&#39;]) py.iplot([btc_trace]) &nbsp; 这里，我们用Plotly 来完成可视化部分。相对于使用一些更成熟的Python数据可视化库，例如Matplotlib ，用Plotly是一个不那么传统的选择，但我认为Plotly是一个不错的选择，因为它可以调用D3.js的充分交互式图表。这些图表有非常漂亮的默认设置，易于探索，而且非常方便嵌入到网页中。 我们可以将生成的图表与公开可用的比特币价格图表（如Coinbase上的图表）进行比较，作为一个快速的完整性检查，验证下载的数据是否合理。 步骤2.3 从更多的比特币交易所抓取价格数据 你可能已经注意到，上面的数据集中存在数据缺失现象－－特别是在2014年末和2016年初。在Kraken交易所的数据集中，这种数据缺失情况尤为明显。我们当然不希望这些数据会影响到我们对价格的全面分析。 比特币交易所的特点是，供需关系决定比特币的价格。因而，没有哪个交易的价格所能够成为市场的“主流价格”。为了解决这个问题，以及刚刚提到的数据缺失问题（可能是由于技术性断电和数据的差错），我们将从三家主要的比特币交易所抓取数据，进而计算出平均的比特币价格指数。 首先，我们把各个交易所的数据下载到到由字典类型的数据框中。 # Pull pricing data for 3 more BTC exchanges exchanges=[&#39;COINBASE&#39;,&#39;BITSTAMP&#39;,&#39;ITBIT&#39;]exchange_data={}exchange_data[&#39;KRAKEN&#39;]=btc_usd_price_kraken for exchange in exchanges:exchange_code=&#39;BCHARTS/{}USD&#39;.format(exchange)btc_exchange_df=get_quandl_data(exchange_code)exchange_data[exchange]=btc_exchange_df 步骤2.4 将所有价格数据整合到单一数据框之中 接下来，我们将要定义一个简单的函数，把各个数据框中共有的列合并为一个新的组合数据框。 def merge_dfs_on_column(dataframes, labels, col):&#39;&#39;&#39;Merge a single column of each dataframe into a new combined dataframe&#39;&#39;&#39;series_dict={} for index in range(len(dataframes)):series_dict[labels[index]]=dataframes[index][col]return pd.DataFrame(series_dict) &nbsp; 现在，基于各个数据集的“加权价格”列，把所有的数据框整合到一起。 # Merge the BTC price dataseries&#39; into a single dataframebtc_usd_datasets=merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()),&#39;Weighted Price&#39;) 最后，可以使用“tail()”方法，查看合并后数据的最后五行，以确保数据整合成功。 btc_usd_datasets.tail() &nbsp; 看起来，这些数据符合我们的预期：数据范围大致相同，只是基于各个交易所的供求关系而略有不同。 步骤2.5 价格数据的可视化 从逻辑上来说，下一步就是通过可视化，将这些数据进行比对。为此，我们需要先定义一个辅助函数，通过提供单行命令使用数据制作图表。 def df_scatter(df, title,seperate_y_axis=False,y_axis_label=&#39;&#39;, scale=&#39;linear&#39;,initial_hide=False):&#39;&#39;&#39;Generate a scatter plot of the entire dataframe&#39;&#39;&#39;label_arr= list(df)series_arr= list(map(lambda col:df[col],label_arr)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout =go.Layout(title=title, legend=dict(orientation=&quot;h&quot;), xaxis=dict(type=&#39;date&#39;), yaxis=dict(title=y_axis_label, showticklabels=notseperate_y_axis, type=scale))y_axis_config=dict(overlaying=&#39;y&#39;, showticklabels=False, &nbsp;type=scale ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visibility =&#39;visible&#39;ifinitial_hide: visibility =&#39;legendonly&#39;# Form Trace For Each Seriestrace_arr=[]for index, series in enumerate(series_arr): &nbsp; &nbsp; &nbsp; &nbsp; trace =go.Scatter(x=series.index, y=series, name=label_arr[index], visible=visibility)# Add seperate axis for the seriesif seperate_y_axis: trace[&#39;yaxis&#39;]=&#39;y{}&#39;.format(index +1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layout[&#39;yaxis{}&#39;.format(index +1)]=y_axis_configtrace_arr.append(trace) &nbsp; &nbsp; &nbsp;fig =go.Figure(data=trace_arr, layout=layout)py.iplot(fig) 为简便起见，我不会过多探讨这个辅助函数的工作原理。如果想了解更多，请查看Pandas&nbsp;和&nbsp;Plotly的说明文件。 现在，我们就可以轻松制作比特币价格数据的图形了！ # Plot all of the BTC exchange pricesdf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) &nbsp; 步骤2.6 清理并加总价格数据 从以上图形中可以看到，尽管这四个系列数据遵循大致相同的路径，但其中还是有一些不规则的变化，我们将设法清除这些异常变化。 在2012-2017年的时间段中，我们知道比特币的价格从来没有等于零的时候，所以我们先去除数据框中所有的零值。 # Remove &quot;0&quot; valuesbtc_usd_datasets.replace(0,np.nan,inplace=True) &nbsp; 在重新构建数据框之后，我们可以看到更加清晰的图形，没有缺失数据的情况了。 # Plot the revised dataframedf_scatter(btc_usd_datasets,&#39;Bitcoin Price (USD) By Exchange&#39;) 我们现在可以计算一个新的列：所有交易所的比特币日平均价格。 # Calculate the average BTC price as a new columnbtc_usd_datasets[&#39;avg_btc_price_usd&#39;]=btc_usd_datasets.mean(axis=1) &nbsp; 新的一列就是比特币的价格指数！我们再把它画出来，以核对该数据看起来是否有问题。 # Plot the average BTC pricebtc_trace=go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[&#39;avg_btc_price_usd&#39;])py.iplot([btc_trace]) &nbsp; 太好了，看起来确实没有问题。稍后，我们将继续使用这个加总的价格序列数据，以便能够确定其他数字货币与美元之间的兑换汇率。 步骤3 获取山寨币（Altcoins）价格 现在，我们已经有了比特币价格的时间序列数据了。接下来我们来看看非比特币的数字加密货币的一些数据，一般是指山寨币（Altcoins）。 步骤3.1 定义Poloniex交易所的API辅助函数 我们将使用Poloniex API来获取数字加密货币交易的数据信息。我们定义了两个辅助函数来获取山寨币的相关数据，这两个函数主要是通过这个API下载和缓存JSON数据。 首先，我们定义函数get_json_data，它将从给定的URL中下载和缓存JSON数据。 defget_json_data(json_url,cache_path):&#39;&#39;&#39;Download and cache JSON data, return as a dataframe.&#39;&#39;&#39;try: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path,&#39;rb&#39;)df=pickle.load(f)print(&#39;Loaded {} from cache&#39;.format(json_url))except(OSError,IOError) as e:print(&#39;Downloading {}&#39;.format(json_url))df=pd.read_json(json_url)df.to_pickle(cache_path)print(&#39;Cached {} at {}&#39;.format(json_url,cache_path))return df 然后，我们定义一个新的函数，该函数将产生Poloniex API的HTTP请求，并调用刚刚定义的get_json_data函数，以保存调用的数据结果。 base_polo_url=&#39;https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}&#39;start_date=datetime.strptime(&#39;2015-01-01&#39;,&#39;%Y-%m-%d&#39;)# get data from the start of 2015end_date=datetime.now()# up until todaypediod=86400# pull daily data (86,400 seconds per day)def get_crypto_data(poloniex_pair):&#39;&#39;&#39;Retrieve cryptocurrency data from poloniex&#39;&#39;&#39;json_url=base_polo_url.format(poloniex_pair,start_date.timestamp(),end_date.timestamp(),pediod)data_df=get_json_data(json_url,poloniex_pair)data_df=data_df.set_index(&#39;date&#39;)return data_df 上述函数将抽取加密货币配对字符代码（比如“BTC_ETH”），并返回包含两种货币历史兑换汇率的数据框。 步骤3.2 从Poloniex下载交易数据 绝大多数山寨币都无法使用美元直接购买，个人要想获取这些电子货币，通常都得先买比特币，再根据加密货币兑换汇率，兑换成山寨币。因而，我们就得下载每一种加密货币兑换比特币的兑换汇率，然后再使用现有比特币价格数据转换成美元。 我们会下载9种排名靠前的加密货币交易数据：Ethereum，Litecoin，Ripple，Ethereum Classic，Stellar，Dash，Siacoin，Monero，和NEM。 altcoins=[&#39;ETH&#39;,&#39;LTC&#39;,&#39;XRP&#39;,&#39;ETC&#39;,&#39;STR&#39;,&#39;DASH&#39;,&#39;SC&#39;,&#39;XMR&#39;,&#39;XEM&#39;]altcoin_data={} for altcoin in altcoins:coinpair=&#39;BTC_{}&#39;.format(altcoin)crypto_price_df=get_crypto_data(coinpair)altcoin_data[altcoin]=crypto_price_df 现在，我们有了包含9个数据框的字典，每种都包含山寨币与比特币之间的历史日平均价格数据。 我们可以通过Ethereum价格表格的最后几行，来判定数据是否可用。 altcoin_data[&#39;ETH&#39;].tail()&nbsp; &nbsp; &nbsp; 步骤3.3 – 统一货币单位：美元 现在，我们可以将BTC-山寨币汇率数据与我们的比特币价格指数结合，来直接计算每一个山寨币的历史价格（单位：美元）。 # Calculate USD Price as a new column in each altcoin dataframe for altcoin in altcoin_data.keys(): &nbsp; &nbsp; altcoin_data[altcoin][&#39;price_usd&#39;] = &nbsp;altcoin_data[altcoin][&#39;weightedAverage&#39;] * btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 此处，我们为每一个山寨币的数据框新增一列存储其相应的美元价格。 接着，我们可以重新使用之前定义的函数merge_dfs_on_column，来建立一个合并的数据框，整合每种电子货币的美元价格。 # Merge USD price of each altcoin into single dataframe &nbsp;combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), &#39;price_usd&#39;) 就是如此简单！ 现在让我们同时把比特币价格作为最后一栏添加到合并后的数据框中。 # Add BTC price to the dataframe combined_df[&#39;BTC&#39;] = btc_usd_datasets[&#39;avg_btc_price_usd&#39;] 现在我们有一个唯一的数据框，它包含了我们正在验证的十种电子货币的每日美元价格。 我们重新调用之前的函数df_scatter，以图表形式展现全部山寨币的相应价格。 # Chart all of the altocoin prices df_scatter(combined_df, &#39;Cryptocurrency Prices (USD)&#39;, seperate_y_axis=False, y_axis_label=&#39;Coin Value (USD)&#39;, scale=&#39;log&#39;) 看起来不错！这张图为我们展现了每一种货币兑换汇率在过去几年的变化情况的一个全貌。 在这里我们使用了对数规格的y轴，在同一绘图上比较所有货币。你也可以尝试其他不同的参数值(例如scale=&#39;linear&#39;)，可以从不同视角理解数据。 步骤3.4- 执行相关性分析 你可能注意到电子货币的汇率看上去似乎是相关的，尽管他们的货币价值相差很大，而且波动性很高。尤其是从2017年4月的迅猛上涨开始，甚至很多的小波动似乎都与整个市场的波动同步出现。 当然，有数据支撑的结论比依据图像而产生的直觉更有说服力。 我们可以利用Pandas corr()函数来验证上述的相关性假设。该检验手段为数据框的每一栏计算了其对应另一栏的皮尔森相关系数。 8/22/2017修订说明-这部分的修改是为了在计算相关系数时使用每日回报率而不是价格的绝对值。 基于一个非稳态时间序列（例如原始的价格数据）直接计算可能会导致相关性系数的偏差。针对此问题，我们的解决方案是使用pct_change()方法，将数据框中的每一个的价格绝对值转化为相应的日回报率。 首先，我们来计算2016年的相关系数。 # Calculate the pearson correlation coefficients for cryptocurrencies in 2016 combined_df_2016 = combined_df[combined_df.index.year == 2016] combined_df_2016.pct_change().corr(method=&#39;pearson&#39;) 上面这张图显示的都是相关系数。系数接近1或-1，分别意味着这一序列是强正相关的，或逆相关的，相关系数趋近于0则说明相应对象并不相关，他们的波动是相互独立的。 为了更可视化的展示结果，我们创建了一个新的可视化的帮助函数。 def correlation_heatmap(df, title, absolute_bounds=True): &nbsp; &nbsp; &#39;&#39;&#39;Plot a correlation heatmap for the entire dataframe&#39;&#39;&#39; &nbsp; &nbsp; heatmap = go.Heatmap( &nbsp; &nbsp; &nbsp; &nbsp; z=df.corr(method=&#39;pearson&#39;).as_matrix(), x=df.columns, &nbsp; &nbsp; &nbsp; &nbsp; y=df.columns, colorbar=dict(title=&#39;Pearson Coefficient&#39;), ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout = go.Layout(title=title) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if absolute_bounds: heatmap[&#39;zmax&#39;] = 1.0 &nbsp; &nbsp; &nbsp; &nbsp; heatmap[&#39;zmin&#39;] = -1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fig = go.Figure(data=[heatmap], layout=layout) &nbsp; &nbsp; py.iplot(fig) correlation_heatmap(combined_df_2016.pct_change(), &quot;Cryptocurrency Correlations in 2016&quot;) &nbsp; 图示为2016年的电子货币相关系数 此处，深红色的数值代表强相关性(每一种货币显然是与其自身高度相关的)，深蓝色的数值表示强逆相关性。所有介于中间的颜色-浅蓝/橙/灰/茶色-其数值代表不同程度的弱相关或不相关。 这张图表说明了什么呢？关键在于，它说明了不同的数字加密货币价格在2016年间的波动情况，几乎没有统计上的显著相关性。 现在，为了验证我们的假设-电子货币在近几个月的相关性增强，接下来，我们将使用从2017年开始的数据来重复同样的测试。 combined_df_2017 = combined_df[combined_df.index.year == 2017] combined_df_2017.pct_change().corr(method=&#39;pearson&#39;) 上图似乎显示了更强的相关性。但这些数据可以单独作为投资决策的依据吗？答案是否定的。 然而值得注意得是，在这张图上几乎所有的电子货币相互之间都变得相关性更强了。 correlation_heatmap(combined_df_2017.pct_change(), &quot;Cryptocurrency Correlations in 2017&quot;) 图：2017年的电子货币相关性 这是不是相当有趣呢！？ 为什么？ 好问题！其实，我也不是很确定。。。 我的第一反应是，对冲基金最近开始公开在电子货币市场交易[1][2]。这些基金持有远超于普通交易人的大量资本，当一支基金如果在多种加密货币间对冲自己的投入资本，然后根据独立变量（比如说，股票市场）对每一种货币使用相似的交易策略。如果从这个角度来看，出现这种越来越强的相关性趋势是合理的。 更深度的理解XRP和STR 例如，从上图中可以很明显看出XRP（Ripple的代币）是与其他电子货币相关性最低的。但这里有一个值得注意的例外是STR（Stellar的代币，官方名字是&quot;Lumens&quot;)，与XRP有强相关关系(相关系数：0.62)。 有趣的是，Stellar和Ripple是非常相似的金融科技平台，他们都旨在减少银行间跨国转账时的繁琐步骤。 可想而知，考虑到区块链服务使用代币的相似性，一些大玩家以及对冲基金可能会对他们在Stellar和Ripple上的投资使用相似的交易战略。这可能就是为什么XRP相比其他电子货币，与STR有更强相关性的原因。 快讯-我是Chipper的合作人之一。Chipper是一家使用Stella的非常早期的初创企业，旨在颠覆非洲的小额汇款行业。 现在，到你了！ 然而，这一解释在很大程度上是推测性的，可能你会做的更好。基于我们已经奠定的基础，你有成百上千条不同的方法可以继续探索数据中蕴藏的故事。 可以考虑从以下思路入手: 为整个分析添加更多加密货币的数据 调整相关性分析的时间范围和颗粒度，以得到优化的或粗粒度的趋势视图。 从交易量或区块链数据挖掘集中寻找趋势。相较于原始的价格数据，如果你想预测未来价格波动，你可以更需要买/卖量的比率数据。 在股票、商品、法定货币上加入价格数据来决定他们当中哪一项与电子货币具有相关性（但是，别忘了那句老话“相关不蕴含因果”） 使用Event Registry, GDELT,以及Google Trends来量化围绕着特定电子货币的“热词”数量。 利用数据训练一个预测性机器学习模型，来预测明日价格。如果你有更大的雄心壮志，你甚至可以考虑尝试用循环神经网络（RNN）进行上述训练。 利用你的分析来创建一个自动化的交易机器人，通过对应的应用编程接口（API），应用在例如“Poloniex”或“Coinbase”的交易网站上。请小心:一个性能欠佳的机器人可以轻易地让你的资产瞬间灰飞烟灭。 关于比特币，以及对于加密货币总体而言，最好的部分是它们的去中心化本质，这使得它比任何其他资产都自由、民主。可以将你的分析开源共享，参与到社区中，或者写一篇博客！ 希望你现在已经掌握了自行分析所需的技能，以及在未来读到任何投机性的加密货币的文章时，进行辩证思考的能力，尤其是那些没有数据支撑的预测。 感谢你的阅读，关于这一教程，如果你有任何看法、建议或批评指正，请在下方留言。如果你发现代码如果有问题，也可以点在Github仓库中新建一个问题（issue）。 http://fortune.com/2017/07/26/bitcoin-cryptocurrency-hedge-fund-sequoia-andreessen-horowitz-metastable/&nbsp; https://www.forbes.com/sites/laurashin/2017/07/12/crypto-boom-15-new-hedge-funds-want-in-on-84000-returns/#7946ab0d416a&nbsp; &nbsp; 原文链接：https://blog.patricktriest.com/analyzing-cryptocurrencies-python/ &nbsp; 志愿者介绍 回复“志愿者”加入我们 往期精彩文章 点击图片阅读 强壮的男性 &amp; 有想法的女性：分析34476个漫画角色，超级英雄中的性别透析 阅读更多","@type":"BlogPosting","url":"/2017/12/11/3173c2ba59f591296ae380e69b4cc241.html","headline":"手把手｜ 用Python代码建个数据实验室，顺利入坑比特币","dateModified":"2017-12-11T00:00:00+08:00","datePublished":"2017-12-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/12/11/3173c2ba59f591296ae380e69b4cc241.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>手把手｜ 用Python代码建个数据实验室，顺利入坑比特币</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="line-height:1.75em;letter-spacing:2px;"><img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJ3J5kb0TJh1J4gwB2GvVtrH4iaLGUul5ic5U5pK6iciaAlJr9w7DDICEhDA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" style="visibility:visible !important;" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1"></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><strong><span style="font-size:15px;">作者：Patrick Triest</span></strong><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><strong>编译</strong></span><strong><span style="font-size:15px;letter-spacing:2px;">：Katherine Hou、林海、Shan LIU、高宁、Yawei</span></strong></p> 
   <p><br></p> 
   <p><span style="letter-spacing:2px;">比特币市场到底是如何运作的？数字加密货币（cryptocurrency）跌宕起伏的原因是什么？不同的山寨币（altcoins）市场之间是紧密联系还是各自为营？我们该如何预测接下来将发生什么？</span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">关于数字加密货币（如：比特币和以太坊）的文章铺天盖地，数百个自诩专家的作者各自发表着他们对比特币未来的猜想。而用来支持他们观点的这些分析中强有力的数据和统计学基础却乏善可陈。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">这篇文章的目的是简单介绍<strong>“如何用Python来分析数字加密货币”</strong>。我们将用简单的Python代码来检索、分析和可视化不同的数字货币数据。在这个过程中，我们将揭示一个有趣的趋势：这些不稳定的市场是如何运作的，它们又是如何发展的。</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJfODzQcXlMUZroheYZpibxFPDNibnHHAbMOrpS0K0EclFZVWmx1Mv4zibg/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">这不是一篇解释数字加密货币是什么的科普贴（如果你需要，我推荐这篇很棒的概述），这也不是一篇讲哪个货币会升值、哪个会贬值的观点性文章。相反，在这篇教程中，<strong>我们所关心的只是获取原始数据，并揭示隐藏在数字中的故事</strong>。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><br></p> 
   <p style="border-left-width:5px;border-left-style:solid;border-left-color:rgb(102,142,104);font-size:16px;font-weight:bold;line-height:32px;color:rgb(102,102,102);letter-spacing:2px;"> <span style="color:rgb(102,142,104);">步骤1 - 配置你的数据实验室</span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">这篇教材适合在不同技能水平上的爱好者、工程师和数据科学家们。要求的技能只是对Python有基础的了解，以及知道如何用命令建立一个项目。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">包含运行结果的notebook完整版本可以在这里下载。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤1.1 - 安装 Anaconda</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">安装这个项目所需的所有相关环境，最简单的办法就是用Anaconda。它是一个打包的Python数据科学生态系统和依赖管理器。</span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">推荐使用下面的官方安装指南来安装Anaconda&nbsp;<span style="color:rgb(136,136,136);">https://www.continuum.io/downloads</span></span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">如果你是一个高阶用户，而你不需要使用Anaconda，那也完全没有问题。我会假设你在安装必须的依赖环境时不需要帮助，你可以直接跳到第二部分。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤1.2 - 建立一个Anaconda项目环境</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">当Anaconda安装完成后，我们需要创建一个新的环境来管理我们的依赖包。运行&nbsp;conda create --name cryptocurrency-analysis python=3&nbsp;来为我们的项目创建一个新的Anaconda环境。接下来，运行source activate cryptocurrency-analysis ( Linux/macOS 系统) 或者 activate cryptocurrency-analysis (windows 系统) 来激活这个环境。</span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;"><br></span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">最后，运行 conda install numpy pandas nb_conda jupyter plotly quandl 来为这个环境安装所需的依赖包。完成这些需要几分钟的时间。</span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><br></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">为什么要用环境？如果你打算在你的电脑上运行很多Python项目，那么分开不同项目的依赖包（软件库和包）来避免冲突是很有帮助的。</span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;"><br></span></p> 
   <p style="letter-spacing:2px;line-height:1.75em;"><span style="font-size:15px;">Ananconda会为每一个项目的依赖包创建一个特殊的环境目录，使得所有包都能妥善地被管理和区分。</span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤1.3 - 启动一个交互的Jupyter Notebook</span></strong></span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">当环境和依赖包都安装好之后，运行 jupyter notebook 来启动 iPython 内核，然后用你的浏览器访问<span style="color:rgb(136,136,136);">http://localhost:8888/&nbsp;</span>。创建一个新的Python notebook，确保它使用的内核是Python [conda env:cryptocurrency-analysis]。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJ2wndqqFAmZibaGfj5A0x0cibETG7aXKJiaxpayO5M1nVLxKTaOHl6AaOQ/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤1.4 – 导入依赖包</span></strong></span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">当你打开了一个空的Jupyter notebook，我们要做的第一件事就是导入所需的依赖包。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-keyword" style="font-weight:bold;">import</span> os <span class="hljs-keyword" style="font-weight:bold;">import</span> numpy as np <span class="hljs-keyword" style="font-weight:bold;">import</span> pandas as pd <span class="hljs-keyword" style="font-weight:bold;">import</span> pickle <span class="hljs-keyword" style="font-weight:bold;">import</span> quandl from datetime <span class="hljs-keyword" style="font-weight:bold;">import</span> datetime</code></pre> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">我们还要导入Plotly来启用离线模式。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-keyword" style="font-weight:bold;">import</span> plotly.offline as py <span class="hljs-keyword" style="font-weight:bold;">import</span> plotly.graph_objs as go <span class="hljs-keyword" style="font-weight:bold;">import</span> plotly.figure_factory as ff py.init_notebook_mode(connected=True)</code></pre> 
   <p><br></p> 
   <p style="border-left-width:5px;border-left-style:solid;border-left-color:rgb(102,142,104);font-size:16px;font-weight:bold;line-height:32px;color:rgb(102,102,102);letter-spacing:2px;"> <span style="color:rgb(102,142,104);">步骤2 - 获得比特币的价格数据</span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">一切就绪，我们可以开始获取要分析的数据了。首先，我们要用Quandl的免费比特币接口来获得比特币的价格数据。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤2.1 - 编写Quandl帮助函数</span></strong></span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">为了方便数据获取，我们要编写一个函数来下载和同步来自Quandl（https://www.quandl.com/ 号称金融数据界的维基百科）的数据。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-function">def <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">get_quandl_data</span><span class="hljs-params">(quandl_id)</span>: &nbsp; &nbsp; '''Download and cache Quandl dataseries''' &nbsp; &nbsp; cache_path </span>= <span class="hljs-string" style="color:rgb(136,0,0);">'{}.pkl'</span>.format(quandl_id).replace(<span class="hljs-string" style="color:rgb(136,0,0);">'/'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'-'</span>) &nbsp; &nbsp; <span class="hljs-keyword" style="font-weight:bold;">try</span>: &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path, <span class="hljs-string" style="color:rgb(136,0,0);">'rb'</span>) &nbsp; &nbsp; &nbsp; &nbsp; df = pickle.load(f) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(<span class="hljs-string" style="color:rgb(136,0,0);">'Loaded {} from cache'</span>.format(quandl_id)) &nbsp; &nbsp; except (OSError, IOError) as e: &nbsp; &nbsp; &nbsp; &nbsp; print(<span class="hljs-string" style="color:rgb(136,0,0);">'Downloading {} from Quandl'</span>.format(quandl_id)) &nbsp; &nbsp; &nbsp; &nbsp; df = quandl.get(quandl_id, returns=<span class="hljs-string" style="color:rgb(136,0,0);">"pandas"</span>) &nbsp; &nbsp; &nbsp; &nbsp; df.to_pickle(cache_path) &nbsp; &nbsp; &nbsp; &nbsp; print(<span class="hljs-string" style="color:rgb(136,0,0);">'Cached {} at {}'</span>.format(quandl_id, cache_path)) &nbsp; &nbsp; <span class="hljs-keyword" style="font-weight:bold;">return</span> df</code></pre> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">我们用pickle来序列化，把下载的数据存成文件，这样代码就不会在每次运行的时候重新下载同样的数据。这个函数将返回Pandas数据框（Dataframe）格式的数据。如果你对数据框不太熟悉，你可以把它想成是强大的电子表格。</span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><strong><span style="font-size:15px;color:rgb(93,139,183);">步骤2.2 – 抓取Kraken交易所定价数据</span></strong></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">我们首先来获取Kraken比特币交易所的历史比特币汇率。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(<span class="hljs-string" style="color:rgb(136,0,0);">'BCHARTS/KRAKENUSD'</span>)</code></pre> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">我们可以用head()方法来查看数据框的前五行。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">btc_usd_price_kraken.head()</code></pre> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJbmFGMhKNro2bBdqbjGpdZWAzRuKG5ZK2PCcaplmvDf24xCLS9JKvIw/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">接下来，我们要做一个简单的图表，以此来快速地通过可视化的方法验证数据基本正确。</span></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[<span class="hljs-string" style="color:rgb(136,0,0);">'Weighted Price'</span>]) py.iplot([btc_trace])</code></pre> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJRyvdGAsiaAmk86bM2H0tnR6zmC9HOibbibrLrJ8AB8ibiaVKWYZCicTfH91Q/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">这里，我们用Plotly 来完成可视化部分。相对于使用一些更成熟的Python数据可视化库，例如Matplotlib ，用Plotly是一个不那么传统的选择，但我认为Plotly是一个不错的选择，因为它可以调用D3.js的充分交互式图表。这些图表有非常漂亮的默认设置，易于探索，而且非常方便嵌入到网页中。<br></span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;">我们可以将生成的图表与公开可用的比特币价格图表（如Coinbase上的图表）进行比较，作为一个快速的完整性检查，验证下载的数据是否合理。<br></span></p> 
   <p><br></p> 
   <p style="line-height:1.75em;letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤2.3 从更多的比特币交易所抓取价格数据</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">你可能已经注意到，上面的数据集中存在数据缺失现象－－特别是在2014年末和2016年初。在Kraken交易所的数据集中，这种数据缺失情况尤为明显。我们当然不希望这些数据会影响到我们对价格的全面分析。</span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">比特币交易所的特点是，供需关系决定比特币的价格。因而，没有哪个交易的价格所能够成为市场的“主流价格”。为了解决这个问题，以及刚刚提到的数据缺失问题（可能是由于技术性断电和数据的差错），我们将从三家主要的比特币交易所抓取数据，进而计算出平均的比特币价格指数。</span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">首先，我们把各个交易所的数据下载到到由字典类型的数据框中。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Pull pricing data <span class="hljs-keyword" style="font-weight:bold;">for</span> <span class="hljs-number" style="color:rgb(136,0,0);">3</span> more BTC exchanges exchanges=[<span class="hljs-string" style="color:rgb(136,0,0);">'COINBASE'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'BITSTAMP'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'ITBIT'</span>]exchange_data={}exchange_data[<span class="hljs-string" style="color:rgb(136,0,0);">'KRAKEN'</span>]=btc_usd_price_kraken <span class="hljs-keyword" style="font-weight:bold;">for</span> exchange in exchanges:exchange_code=<span class="hljs-string" style="color:rgb(136,0,0);">'BCHARTS/{}USD'</span>.format(exchange)btc_exchange_df=get_quandl_data(exchange_code)exchange_data[exchange]=btc_exchange_df</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"> </h5>
   <p style="letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤2.4 将所有价格数据整合到单一数据框之中</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">接下来，我们将要定义一个简单的函数，把各个数据框中共有的列合并为一个新的组合数据框。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-function">def <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">merge_dfs_on_column</span><span class="hljs-params">(dataframes, labels, col)</span>:'''Merge a single column of each dataframe into a <span class="hljs-keyword" style="font-weight:bold;">new</span> combined dataframe'''series_dict</span>={} <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">for</span> index in <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">range</span><span class="hljs-params">(len(dataframes)</span>):series_dict[labels[index]]</span>=dataframes[index][col]<span class="hljs-keyword" style="font-weight:bold;">return</span> pd.DataFrame(series_dict)</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">现在，基于各个数据集的“加权价格”列，把所有的数据框整合到一起。</span></p> 
   <p><span style="letter-spacing:2px;"><br></span></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Merge the BTC price dataseries' into a single dataframebtc_usd_datasets=merge_dfs_on_column(<span class="hljs-built_in" style="color:rgb(57,115,0);">list</span>(exchange_data.values()), <span class="hljs-built_in" style="color:rgb(57,115,0);">list</span>(exchange_data.keys()),<span class="hljs-string" style="color:rgb(136,0,0);">'Weighted Price'</span>)</code></pre> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">最后，可以使用“tail()”方法，查看合并后数据的最后五行，以确保数据整合成功。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">btc_usd_datasets.tail()</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJqjSz3sEibgPnlXqdECr51j2VJicOFXMMN2ES0NLTM3eRlBFO14r8icTUg/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">看起来，这些数据符合我们的预期：数据范围大致相同，只是基于各个交易所的供求关系而略有不同。</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤2.5 价格数据的可视化</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">从逻辑上来说，下一步就是通过可视化，将这些数据进行比对。为此，我们需要先定义一个辅助函数，通过提供单行命令使用数据制作图表。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-function">def <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">df_scatter</span><span class="hljs-params">(df, title,seperate_y_axis=False,y_axis_label=<span class="hljs-string" style="color:rgb(136,0,0);">'', scale='</span>linear<span class="hljs-string" style="color:rgb(136,0,0);">',initial_hide=False):'''Generate a scatter plot of the entire dataframe'''label_arr= list(df)series_arr= list(map(lambda col:df[col],label_arr)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout =go.Layout(title=title, legend=dict(orientation="h"), xaxis=dict(type='</span>date<span class="hljs-string" style="color:rgb(136,0,0);">'), yaxis=dict(title=y_axis_label, showticklabels=notseperate_y_axis, type=scale))y_axis_config=dict(overlaying='</span>y<span class="hljs-string" style="color:rgb(136,0,0);">', showticklabels=False, &nbsp;type=scale ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visibility ='</span>visible<span class="hljs-string" style="color:rgb(136,0,0);">'ifinitial_hide: visibility ='</span>legendonly<span class="hljs-string" style="color:rgb(136,0,0);">'# Form Trace For Each Seriestrace_arr=[]for index, series in enumerate(series_arr): &nbsp; &nbsp; &nbsp; &nbsp; trace =go.Scatter(x=series.index, y=series, name=label_arr[index], visible=visibility)# Add seperate axis for the seriesif seperate_y_axis: trace['</span>yaxis<span class="hljs-string" style="color:rgb(136,0,0);">']='</span>y{}<span class="hljs-string" style="color:rgb(136,0,0);">'.format(index +1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layout['</span>yaxis{}<span class="hljs-string" style="color:rgb(136,0,0);">'.format(index +1)]=y_axis_configtrace_arr.append(trace) &nbsp; &nbsp; &nbsp;fig =go.Figure(data=trace_arr, layout=layout)py.iplot(fig)</span></span></span></code></pre> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">为简便起见，我不会过多探讨这个辅助函数的工作原理。如果想了解更多，请查看Pandas&nbsp;和&nbsp;Plotly的说明文件。</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">现在，我们就可以轻松制作比特币价格数据的图形了！</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># <span class="hljs-function">Plot all of the BTC exchange <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">pricesdf_scatter</span><span class="hljs-params">(btc_usd_datasets,<span class="hljs-string" style="color:rgb(136,0,0);">'Bitcoin Price (USD) By Exchange'</span>)</span></span></code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJFjdcSDx92BG7YUUeFk9CFSb7DALWktDkBXSmQvzRKgHtUVHT3twqAA/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;"><br></span></p> 
   <p style="letter-spacing:2px;"><span style="color:rgb(93,139,183);"><strong><span style="font-size:15px;">步骤2.6 清理并加总价格数据</span></strong></span></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">从以上图形中可以看到，尽管这四个系列数据遵循大致相同的路径，但其中还是有一些不规则的变化，我们将设法清除这些异常变化。</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">在2012-2017年的时间段中，我们知道比特币的价格从来没有等于零的时候，所以我们先去除数据框中所有的零值。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Remove <span class="hljs-string" style="color:rgb(136,0,0);">"0"</span> valuesbtc_usd_datasets.replace(<span class="hljs-number" style="color:rgb(136,0,0);">0</span>,np.nan,inplace=True)</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">在重新构建数据框之后，我们可以看到更加清晰的图形，没有缺失数据的情况了。<br></span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># <span class="hljs-function">Plot the revised <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">dataframedf_scatter</span><span class="hljs-params">(btc_usd_datasets,<span class="hljs-string" style="color:rgb(136,0,0);">'Bitcoin Price (USD) By Exchange'</span>)</span></span></code></pre> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJBJibWUco4a0gJrXXTfib8udvKyXIHJrlKpp39za5VvTal83MutGr9sjA/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">我们现在可以计算一个新的列：所有交易所的比特币日平均价格。<br></span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Calculate the average BTC price as a <span class="hljs-keyword" style="font-weight:bold;">new</span> columnbtc_usd_datasets[<span class="hljs-string" style="color:rgb(136,0,0);">'avg_btc_price_usd'</span>]=btc_usd_datasets.mean(axis=<span class="hljs-number" style="color:rgb(136,0,0);">1</span>)</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">新的一列就是比特币的价格指数！我们再把它画出来，以核对该数据看起来是否有问题。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Plot the average BTC pricebtc_trace=go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[<span class="hljs-string" style="color:rgb(136,0,0);">'avg_btc_price_usd'</span>])py.iplot([btc_trace])</code></pre> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJrm2ameSdszQzfnAltHMgJLmgvCNxMJNcapuJ54JF7D4UrZVKdMdRfw/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p style="letter-spacing:2px;"><span style="font-size:15px;">太好了，看起来确实没有问题。稍后，我们将继续使用这个加总的价格序列数据，以便能够确定其他数字货币与美元之间的兑换汇率。</span></p> 
   <p style="letter-spacing:2px;"><br></p> 
   <p style="border-left-width:5px;border-left-style:solid;border-left-color:rgb(102,142,104);font-size:16px;font-weight:bold;line-height:32px;color:rgb(102,102,102);letter-spacing:2px;"> <span style="color:rgb(102,142,104);">步骤3 获取山寨币（Altcoins）价格</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在，我们已经有了比特币价格的时间序列数据了。接下来我们来看看非比特币的数字加密货币的一些数据，一般是指山寨币（Altcoins）。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"><span style="letter-spacing:2px;"><strong><span style="font-size:15px;color:rgb(93,139,183);">步骤3.1 定义Poloniex交易所的API辅助函数</span></strong></span></h5> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我们将使用Poloniex API来获取数字加密货币交易的数据信息。我们定义了两个辅助函数来获取山寨币的相关数据，这两个函数主要是通过这个API下载和缓存JSON数据。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">首先，我们定义函数get_json_data，它将从给定的URL中下载和缓存JSON数据。<br></span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">defget_json_data(json_url,cache_path):<span class="hljs-string" style="color:rgb(136,0,0);">'''</span>Download and cache JSON data, <span class="hljs-keyword" style="font-weight:bold;">return</span> as a dataframe<span class="hljs-number" style="color:rgb(136,0,0);">.'''</span><span class="hljs-keyword" style="font-weight:bold;">try</span>: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = open(cache_path,<span class="hljs-string" style="color:rgb(136,0,0);">'rb'</span>)df=pickle.load(f)print(<span class="hljs-string" style="color:rgb(136,0,0);">'Loaded {} from cache'</span>.format(json_url))except(OSError,IOError) as e:print(<span class="hljs-string" style="color:rgb(136,0,0);">'Downloading {}'</span>.format(json_url))df=pd.read_json(json_url)df.to_pickle(cache_path)print(<span class="hljs-string" style="color:rgb(136,0,0);">'Cached {} at {}'</span>.format(json_url,cache_path))<span class="hljs-keyword" style="font-weight:bold;">return</span> df</code></pre> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">然后，我们定义一个新的函数，该函数将产生Poloniex API的HTTP请求，并调用刚刚定义的get_json_data函数，以保存调用的数据结果。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">base_polo_url=<span class="hljs-string" style="color:rgb(136,0,0);">'https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}'</span>start_date=datetime.strptime(<span class="hljs-string" style="color:rgb(136,0,0);">'2015-01-01'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'%Y-%m-%d'</span>)# get data from the start of <span class="hljs-number" style="color:rgb(136,0,0);">2015</span>end_date=datetime.now()# up until todaypediod=<span class="hljs-number" style="color:rgb(136,0,0);">86400</span># pull daily data (<span class="hljs-number" style="color:rgb(136,0,0);">86</span>,<span class="hljs-number" style="color:rgb(136,0,0);">400</span> seconds per day)def get_crypto_data(poloniex_pair):<span class="hljs-string" style="color:rgb(136,0,0);">'''</span>Retrieve cryptocurrency data from poloniex<span class="hljs-string" style="color:rgb(136,0,0);">'''json_url=base_polo_url.format(poloniex_pair,start_date.timestamp(),end_date.timestamp(),pediod)data_df=get_json_data(json_url,poloniex_pair)data_df=data_df.set_index('</span>date')<span class="hljs-keyword" style="font-weight:bold;">return</span> data_df</code></pre> 
   <p><span style="font-size:15px;letter-spacing:2px;">上述函数将抽取加密货币配对字符代码（比如“BTC_ETH”），并返回包含两种货币历史兑换汇率的数据框。<br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"><span style="color:rgb(93,139,183);letter-spacing:2px;"><strong><span style="font-size:15px;">步骤3.2 从Poloniex下载交易数据</span></strong></span></h5> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">绝大多数山寨币都无法使用美元直接购买，个人要想获取这些电子货币，通常都得先买比特币，再根据加密货币兑换汇率，兑换成山寨币。因而，我们就得下载每一种加密货币兑换比特币的兑换汇率，然后再使用现有比特币价格数据转换成美元。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我们会下载9种排名靠前的加密货币交易数据：Ethereum，Litecoin，Ripple，Ethereum Classic，Stellar，Dash，Siacoin，Monero，和NEM。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">altcoins=[<span class="hljs-string" style="color:rgb(136,0,0);">'ETH'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'LTC'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'XRP'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'ETC'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'STR'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'DASH'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'SC'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'XMR'</span>,<span class="hljs-string" style="color:rgb(136,0,0);">'XEM'</span>]altcoin_data={} <span class="hljs-keyword" style="font-weight:bold;">for</span> altcoin in altcoins:coinpair=<span class="hljs-string" style="color:rgb(136,0,0);">'BTC_{}'</span>.format(altcoin)crypto_price_df=get_crypto_data(coinpair)altcoin_data[altcoin]=crypto_price_df</code></pre> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在，我们有了包含9个数据框的字典，每种都包含山寨币与比特币之间的历史日平均价格数据。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我们可以通过Ethereum价格表格的最后几行，来判定数据是否可用。<br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">altcoin_data['ETH'].tail()&nbsp;</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJbXLia3GsOT8Z1WbGbhQDT7oGYA89zlCdmicgRR4hShFA6YR9aeZl8HKA/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">&nbsp;</span></p> 
   <p><br></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"><span style="color:rgb(93,139,183);letter-spacing:2px;"><strong><span style="font-size:15px;">步骤3.3 – 统一货币单位：美元</span></strong></span></h5> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在，我们可以将BTC-山寨币汇率数据与我们的比特币价格指数结合，来直接计算每一个山寨币的历史价格（单位：美元）。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Calculate USD Price as a <span class="hljs-keyword" style="font-weight:bold;">new</span> column in each altcoin dataframe <span class="hljs-keyword" style="font-weight:bold;">for</span> altcoin in altcoin_data.keys(): &nbsp; &nbsp; altcoin_data[altcoin][<span class="hljs-string" style="color:rgb(136,0,0);">'price_usd'</span>] = &nbsp;altcoin_data[altcoin][<span class="hljs-string" style="color:rgb(136,0,0);">'weightedAverage'</span>] * btc_usd_datasets[<span class="hljs-string" style="color:rgb(136,0,0);">'avg_btc_price_usd'</span>]</code></pre> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">此处，我们为每一个山寨币的数据框新增一列存储其相应的美元价格。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">接着，我们可以重新使用之前定义的函数merge_dfs_on_column，来建立一个合并的数据框，整合每种电子货币的美元价格。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Merge USD price of each altcoin into single dataframe &nbsp;combined_df = merge_dfs_on_column(<span class="hljs-built_in" style="color:rgb(57,115,0);">list</span>(altcoin_data.values()), <span class="hljs-built_in" style="color:rgb(57,115,0);">list</span>(altcoin_data.keys()), <span class="hljs-string" style="color:rgb(136,0,0);">'price_usd'</span>)</code></pre> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">就是如此简单！</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在让我们同时把比特币价格作为最后一栏添加到合并后的数据框中。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Add BTC price to the dataframe combined_df[<span class="hljs-string" style="color:rgb(136,0,0);">'BTC'</span>] = btc_usd_datasets[<span class="hljs-string" style="color:rgb(136,0,0);">'avg_btc_price_usd'</span>]</code></pre> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在我们有一个唯一的数据框，它包含了我们正在验证的十种电子货币的每日美元价格。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我们重新调用之前的函数df_scatter，以图表形式展现全部山寨币的相应价格。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># <span class="hljs-function">Chart all of the altocoin prices <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">df_scatter</span><span class="hljs-params">(combined_df, <span class="hljs-string" style="color:rgb(136,0,0);">'Cryptocurrency Prices (USD)'</span>, seperate_y_axis=False, y_axis_label=<span class="hljs-string" style="color:rgb(136,0,0);">'Coin Value (USD)'</span>, scale=<span class="hljs-string" style="color:rgb(136,0,0);">'log'</span>)</span></span></code></pre> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJNCMQQsyPfGXlv56MSyFTaIHEOLQ2xbdtf0EBzsicA65vHVl1jeoIN7A/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">看起来不错！这张图为我们展现了每一种货币兑换汇率在过去几年的变化情况的一个全貌。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">在这里我们使用了对数规格的y轴，在同一绘图上比较所有货币。你也可以尝试其他不同的参数值(例如scale='linear')，可以从不同视角理解数据。</span></p> 
   <p><br></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"><span style="color:rgb(93,139,183);letter-spacing:2px;"><strong><span style="font-size:15px;">步骤3.4- 执行相关性分析</span></strong></span></h5> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">你可能注意到电子货币的汇率看上去似乎是相关的，尽管他们的货币价值相差很大，而且波动性很高。尤其是从2017年4月的迅猛上涨开始，甚至很多的小波动似乎都与整个市场的波动同步出现。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">当然，有数据支撑的结论比依据图像而产生的直觉更有说服力。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我们可以利用Pandas corr()函数来验证上述的相关性假设。该检验手段为数据框的每一栏计算了其对应另一栏的皮尔森相关系数。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">8/22/2017修订说明-这部分的修改是为了在计算相关系数时使用每日回报率而不是价格的绝对值。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">基于一个非稳态时间序列（例如原始的价格数据）直接计算可能会导致相关性系数的偏差。针对此问题，我们的解决方案是使用pct_change()方法，将数据框中的每一个的价格绝对值转化为相应的日回报率。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">首先，我们来计算2016年的相关系数。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"># Calculate the pearson correlation coefficients <span class="hljs-keyword" style="font-weight:bold;">for</span> cryptocurrencies in <span class="hljs-number" style="color:rgb(136,0,0);">2016</span> combined_df_2016 = combined_df[combined_df.index.year == <span class="hljs-number" style="color:rgb(136,0,0);">2016</span>] combined_df_2016.pct_change().corr(method=<span class="hljs-string" style="color:rgb(136,0,0);">'pearson'</span>)</code></pre> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJS5FMSPW6oUcsHpLjDoxEEPGqpSnGRklPgX1EoN6ib4xaladskBrK8jg/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">上面这张图显示的都是相关系数。系数接近1或-1，分别意味着这一序列是强正相关的，或逆相关的，相关系数趋近于0则说明相应对象并不相关，他们的波动是相互独立的。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">为了更可视化的展示结果，我们创建了一个新的可视化的帮助函数。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;"><span class="hljs-function">def <span class="hljs-title" style="color:rgb(136,0,0);font-weight:bold;">correlation_heatmap</span><span class="hljs-params">(df, title, absolute_bounds=True)</span>: &nbsp; &nbsp; '''Plot a correlation heatmap <span class="hljs-keyword" style="font-weight:bold;">for</span> the entire dataframe''' &nbsp; &nbsp; heatmap </span>= go.Heatmap( &nbsp; &nbsp; &nbsp; &nbsp; z=df.corr(method=<span class="hljs-string" style="color:rgb(136,0,0);">'pearson'</span>).as_matrix(), x=df.columns, &nbsp; &nbsp; &nbsp; &nbsp; y=df.columns, colorbar=dict(title=<span class="hljs-string" style="color:rgb(136,0,0);">'Pearson Coefficient'</span>), ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;layout = go.Layout(title=title) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> absolute_bounds: heatmap[<span class="hljs-string" style="color:rgb(136,0,0);">'zmax'</span>] = <span class="hljs-number" style="color:rgb(136,0,0);">1.0</span> &nbsp; &nbsp; &nbsp; &nbsp; heatmap[<span class="hljs-string" style="color:rgb(136,0,0);">'zmin'</span>] = <span class="hljs-number" style="color:rgb(136,0,0);">-1.0</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fig = go.Figure(data=[heatmap], layout=layout) &nbsp; &nbsp; py.iplot(fig) correlation_heatmap(combined_df_2016.pct_change(), <span class="hljs-string" style="color:rgb(136,0,0);">"Cryptocurrency Correlations in 2016"</span>)</code></pre> 
   <p><span style="font-size:15px;letter-spacing:2px;">&nbsp;</span></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJomqYqZTVKvAbnoa1OjKfymPNP8J43GCIibdIWv2b2OXommQ9HYicWmfw/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><span style="font-size:15px;letter-spacing:2px;color:rgb(136,136,136);">图示为2016年的电子货币相关系数</span><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;color:rgb(136,136,136);"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">此处，深红色的数值代表强相关性(每一种货币显然是与其自身高度相关的)，深蓝色的数值表示强逆相关性。所有介于中间的颜色-浅蓝/橙/灰/茶色-其数值代表不同程度的弱相关或不相关。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">这张图表说明了什么呢？关键在于，它说明了不同的数字加密货币价格在2016年间的波动情况，几乎没有统计上的显著相关性。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">现在，为了验证我们的假设-电子货币在近几个月的相关性增强，接下来，我们将使用从2017年开始的数据来重复同样的测试。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">combined_df_2017 = combined_df[combined_df.index.year == <span class="hljs-number" style="color:rgb(136,0,0);">2017</span>] combined_df_2017.pct_change().corr(method=<span class="hljs-string" style="color:rgb(136,0,0);">'pearson'</span>)</code></pre> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJcwXEBxS8VKTibRSm2eAcOv3IZLL9wibFVT0geINniaXcDB4JeUhQ5iaLLw/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">上图似乎显示了更强的相关性。但这些数据可以单独作为投资决策的依据吗？答案是否定的。<br></span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">然而值得注意得是，在这张图上几乎所有的电子货币相互之间都变得相关性更强了。</span></p> 
   <p><br></p> 
   <pre><code class="c hljs cpp" style="margin-left:.15em;font-size:.85em;font-family:Consolas, Menlo, Courier, monospace;overflow:auto;color:rgb(51,51,51);min-width:400px;display:block !important;">correlation_heatmap(combined_df_2017.pct_change(), <span class="hljs-string" style="color:rgb(136,0,0);">"Cryptocurrency Correlations in 2017"</span>)</code></pre> 
   <p><br></p> 
   <p><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXTImjvx58RIzedRzMyokdJHib8ukW4VsRrqVA7vvicibpqPHEjzGnV2ctn3pv0DQZSibsb4vZDiaiap0Ew/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p><span style="color:rgb(136,136,136);font-size:15px;letter-spacing:2px;">图：2017年的电子货币相关性</span></p> 
   <p><span style="color:rgb(136,136,136);font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">这是不是相当有趣呢！？</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <h3 style="font-weight:bold;line-height:1.6em;"><span style="font-size:15px;letter-spacing:2px;">为什么？</span></h3> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">好问题！其实，我也不是很确定。。。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">我的第一反应是，对冲基金最近开始公开在电子货币市场交易[1][2]。这些基金持有远超于普通交易人的大量资本，当一支基金如果在多种加密货币间对冲自己的投入资本，然后根据独立变量（比如说，股票市场）对每一种货币使用相似的交易策略。如果从这个角度来看，出现这种越来越强的相关性趋势是合理的。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <h5 style="font-weight:bold;line-height:1.6em;"><span style="font-size:15px;letter-spacing:2px;">更深度的理解XRP和STR</span></h5> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">例如，从上图中可以很明显看出XRP（Ripple的代币）是与其他电子货币相关性最低的。但这里有一个值得注意的例外是STR（Stellar的代币，官方名字是"Lumens")，与XRP有强相关关系(相关系数：0.62)。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">有趣的是，Stellar和Ripple是非常相似的金融科技平台，他们都旨在减少银行间跨国转账时的繁琐步骤。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">可想而知，考虑到区块链服务使用代币的相似性，一些大玩家以及对冲基金可能会对他们在Stellar和Ripple上的投资使用相似的交易战略。这可能就是为什么XRP相比其他电子货币，与STR有更强相关性的原因。</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">快讯-我是Chipper的合作人之一。Chipper是一家使用Stella的非常早期的初创企业，旨在颠覆非洲的小额汇款行业。</span></p> 
   <h3 style="font-weight:bold;line-height:1.6em;"><span style="font-size:15px;letter-spacing:2px;">现在，到你了！</span></h3> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">然而，这一解释在很大程度上是推测性的，可能你会做的更好。基于我们已经奠定的基础，你有成百上千条不同的方法可以继续探索数据中蕴藏的故事。</span></p> 
   <p><br></p> 
   <p><strong><span style="font-size:15px;letter-spacing:2px;">可以考虑从以下思路入手:</span></strong></p> 
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">为整个分析添加更多加密货币的数据</span></p> <p><br></p> </li>
    <li> <p><span style="font-size:15px;letter-spacing:2px;">调整相关性分析的时间范围和颗粒度，以得到优化的或粗粒度的趋势视图。</span></p> </li>
   </ul>
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">从交易量或区块链数据挖掘集中寻找趋势。相较于原始的价格数据，如果你想预测未来价格波动，你可以更需要买/卖量的比率数据。</span></p> </li>
   </ul>
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">在股票、商品、法定货币上加入价格数据来决定他们当中哪一项与电子货币具有相关性（但是，别忘了那句老话“相关不蕴含因果”）</span></p> </li>
   </ul>
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">使用Event Registry, GDELT,以及Google Trends来量化围绕着特定电子货币的“热词”数量。</span></p> </li>
   </ul>
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">利用数据训练一个预测性机器学习模型，来预测明日价格。如果你有更大的雄心壮志，你甚至可以考虑尝试用循环神经网络（RNN）进行上述训练。</span></p> </li>
   </ul>
   <p><br></p> 
   <ul class="list-paddingleft-2">
    <li> <p><span style="font-size:15px;letter-spacing:2px;">利用你的分析来创建一个自动化的交易机器人，通过对应的应用编程接口（API），应用在例如“Poloniex”或“Coinbase”的交易网站上。请小心:一个性能欠佳的机器人可以轻易地让你的资产瞬间灰飞烟灭。</span></p> </li>
   </ul>
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">关于比特币，以及对于加密货币总体而言，最好的部分是它们的去中心化本质，这使得它比任何其他资产都自由、民主。可以将你的分析开源共享，参与到社区中，或者写一篇博客！</span></p> 
   <p><br></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">希望你现在已经掌握了自行分析所需的技能，以及在未来读到任何投机性的加密货币的文章时，进行辩证思考的能力，尤其是那些没有数据支撑的预测。</span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;"><br></span></p> 
   <p><span style="font-size:15px;letter-spacing:2px;">感谢你的阅读，关于这一教程，如果你有任何看法、建议或批评指正，请在下方留言。如果你发现代码如果有问题，也可以点在Github仓库中新建一个问题（issue）。</span></p> 
   <p><br></p> 
   <blockquote> 
    <p><span style="font-size:15px;letter-spacing:2px;color:rgb(136,136,136);">http://fortune.com/2017/07/26/bitcoin-cryptocurrency-hedge-fund-sequoia-andreessen-horowitz-metastable/&nbsp;</span></p> 
    <p><span style="font-size:15px;letter-spacing:2px;color:rgb(136,136,136);"><br></span></p> 
    <p><span style="font-size:15px;letter-spacing:2px;color:rgb(136,136,136);">https://www.forbes.com/sites/laurashin/2017/07/12/crypto-boom-15-new-hedge-funds-want-in-on-84000-returns/#7946ab0d416a&nbsp;</span></p> 
   </blockquote> 
   <p><span style="font-size:15px;letter-spacing:2px;">&nbsp;</span></p> 
   <blockquote> 
    <p style="line-height:1.75em;letter-spacing:2px;"><span style="font-size:15px;color:rgb(136,136,136);">原文链接：https://blog.patricktriest.com/analyzing-cryptocurrencies-python/</span></p> 
   </blockquote> 
   <p><span style="font-size:15px;letter-spacing:2px;">&nbsp;</span></p> 
   <p><br></p> 
   <p style="text-align:center;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTQzNzU2NA==&amp;mid=2651655153&amp;idx=3&amp;sn=9809b23df563a3e51364a66605bb5a24&amp;scene=21#wechat_redirect" rel="nofollow"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/wc7YNPm3YxVNgknJ4evSyrxxUpicvBSB1JzLCLxNyIsy6ia3hW1faJgt8siaAa4jibuk6gOmicDnHHNqPuO4c5rCEfg/0?wx_fmt=jpeg" alt="0?wx_fmt=jpeg"></a></p> 
   <p style="margin-left:8px;min-height:1em;border-width:1px;border-style:dashed;border-color:#FFFFFF;line-height:1.75em;"> <span style="letter-spacing:2px;">志愿者介绍</span></p> 
   <p style="font-size:16px;text-align:center;"><strong style="letter-spacing:2px;"><span style="font-size:14px;">回复<strong style="font-size:16px;"><span style="font-size:14px;">“<span style="color:rgb(102,142,104);">志愿者</span>”加入我们</span></strong></span></strong></p> 
   <p style="text-align:center;"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXcVLibL0yc3ccYbEusx01lD2pmhG67VaXL1B7LkSku6zfdEOk1zukPDTM5IPAIrtFHYCrbl71sHOA/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="text-align:center;"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxXcVLibL0yc3ccYbEusx01lDibmO1peaYYW9kuMDtv61icxtbxTrTEXjLhrA4iawX3LiamdQNqtjo1kxuA/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="text-align:center;"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxU0NnsmhDuTgKIMweJtXzNDg1NacgnaO2icffUUGIPft1A8QSjjkE21aIhBIFWfWrMBxk6icN0fjJibw/0?wx_fmt=png" alt="0?wx_fmt=png"></p> 
   <p style="text-align:center;"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/wc7YNPm3YxVMib0n7Lz1OQEGXrUG1ibl7BgYgCicCAgNJerUeqJ75OaMJ7USweWunbQ6hS7VMdv0JLl1CZg4W1AJw/0?wx_fmt=png" alt="0?wx_fmt=png"><br></p> 
   <p style="text-align:center;"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/wc7YNPm3YxWns94nyiao3bRq72sQE0p1Wx7KWl1fhc3Yhowj5rJ56Lvz7Dib0Cqlic5zdePsDlcGwYRL9feBZQMbg/0?wx_fmt=jpeg" alt="0?wx_fmt=jpeg"></p> 
   <p style="margin-left:8px;border-width:1px;border-style:dashed;border-color:#FFFFFF;"> <span>往期精彩文章</span></p> 
   <p style="margin-left:8px;font-size:16px;min-height:1em;line-height:25.6px;text-align:center;"> <strong><span style="font-size:14px;color:rgb(102,142,104);">点击图片阅读</span></strong></p> 
   <p style="margin-left:8px;font-size:16px;min-height:1em;line-height:25.6px;text-align:center;"> <a href="http://mp.weixin.qq.com/s?__biz=MjM5MTQzNzU2NA==&amp;mid=2651655230&amp;idx=1&amp;sn=e79e038a4914edb4fbcc19565b432223&amp;chksm=bd4c2bad8a3ba2bb2cd76a60f74c039c3438825274dc5b1d57fe0bdf86333e4a43be3e564558&amp;scene=21#wechat_redirect" rel="nofollow" style="font-size:15px;text-decoration:underline;"><span style="font-size:15px;"><strong>强壮的男性 &amp; 有想法的女性：分析34476个漫画角色，超级英雄中的性别透析</strong></span></a><br></p> 
   <p style="text-align:center;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTQzNzU2NA==&amp;mid=2651655230&amp;idx=1&amp;sn=e79e038a4914edb4fbcc19565b432223&amp;chksm=bd4c2bad8a3ba2bb2cd76a60f74c039c3438825274dc5b1d57fe0bdf86333e4a43be3e564558&amp;scene=21#wechat_redirect" rel="nofollow"><img class="img_loading" src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/wc7YNPm3YxVNgknJ4evSyrxxUpicvBSB11YQ2WZ6opcWhpFxalavWJEoPp441bt8UoGiayYyxJARIL8aAGxazkhQ/0?wx_fmt=jpeg" alt="0?wx_fmt=jpeg"></a></p> 
   <p style="font-size:16px;text-align:center;"><img class="__bg_gif img_loading" src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/wc7YNPm3YxXDGeKCY9bsRUPhgfwchKMM5EJYjEZUbCZiapSkH1ic6NdLfBm1oObXCGlr3uczHqlDtqib4K1H4oosw/0?wx_fmt=jpeg" style="visibility:visible !important;" alt="0?wx_fmt=jpeg"></p> 
   <p style="margin-left:8px;font-size:16px;min-height:1em;text-align:center;"> <img class="img_loading" src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/wc7YNPm3YxXDGeKCY9bsRUPhgfwchKMMFvSuwlBgC2UWLxW9SywhMjl4NuHlTP9Klh3NfMVwwJrCuNVxF6cabg/0?wx_fmt=jpeg" style="visibility:visible !important;" alt="0?wx_fmt=jpeg"></p> 
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/dzJx2EOtaA24Adr/article/details/78774969,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/dzJx2EOtaA24Adr/article/details/78774969,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
