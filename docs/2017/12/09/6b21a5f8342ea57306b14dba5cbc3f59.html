<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>CRC算法 个人学习笔记 直接法、查表法注意点 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="CRC算法 个人学习笔记 直接法、查表法注意点" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CRC检验码主要是用在数据校验中，用于判断对应数据是否发生传输错误，详细的介绍百度就可以。本文主要是记录我个人在这几天学习使用CRC的过程中遇到的问题。各位在阅读时如果有发现问题，可在评论区留言，谢谢。 1、CRC算法会根据选择生成的检验码的长度，需要设置一个生成多项式，一般会使用国际上几个大厂或者行业内的常用的标准多项式，而且这些标准还有其他选项细微的差别， 比如初始值的设置、是从数据的MSB/LSB开始计算、结果是否需要与其他值异或等，以下是我找到的几个通用算法的配置信息： 参考网址1：http://www.ip33.com/crc.html 参考网址2：http://blog.csdn.net/xlhcgd/article/details/44980005 参考网址3：https://wenku.baidu.com/view/3c9eadc7cc7931b764ce15b8.html &nbsp; 2、算法原理（参考网址4：http://blog.csdn.net/huang_shiyang/article/details/50881305） 假设数据传输过程中需要发送15位的二进制信息g=101001110100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，既将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。 h(x)可以自由选择或者使用国际通行标准，一般按照h(x)的阶数m，将CRC算法称为CRC-m，比如CRC-32、CRC-64等。国际通行标准可以参看http://en.wikipedia.org/wiki/Cyclic_redundancy_check g(x)和h(x)的除运算，可以通过g和h做xor（异或）运算。比如将11001与10101做xor运算： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 明白了xor运算法则后，举一个例子使用CRC-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 +1，既h是9位的二进制串111010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过迭代运算后，最终得到的r是10001100，这就是CRC效验码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过示例，可以发现一些规律，依据这些规律调整算法：&nbsp;1.&nbsp;每次迭代，根据gk的首位决定b，b是与gk进行运算的二进制码。若gk的首位是1，则b=h；若gk的首位是0，则b=0，或者跳过此次迭代，上面的例子中就是碰到0后直接跳到后面的非零位。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;每次迭代，gk的首位将会被移出，所以只需考虑第2位后计算即可。这样就可以舍弃h的首位，将b取h的后m位。比如CRC-8的h是111010101，b只需是11010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;每次迭代，受到影响的是gk的前m位，所以构建一个m位的寄存器S，此寄存器储存gk的前m位。每次迭代计算前先将S的首位抛弃，将寄存器左移一位，同时将g的后一位加入寄存器。若使用此种方法，计算步骤如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ※蓝色表示寄存器S的首位，是需要移出的，b根据S的首位选择0或者h。黄色是需要移入寄存器的位。S&#39;是经过位移后的S。 &nbsp; 3、举个例子，计算单字节0x81的CRC8的值（生成多项式：0x07，初始值00，输入输出不反转） 1)&nbsp;将经0x81与初始值0x00进行异或 CRC8 = 0x81 XOR 0x00 = 0x81; 2)&nbsp;从判断数据的最高位，选择对应的计算方法 1：数据左移一位，然后与多项式0x07进行异或，CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07 0：数据左移一位，然后不动作，CRC8 =（CRC8 &lt;&lt; 1) 3)&nbsp;8位数据是否都移动完：未移动完：返回第2步继续计算移动完 &nbsp;：最后的结果则为最终的8位校验值 4)&nbsp;对应的C代码 uint8_t Get_CRC8( uint8_t dat , uint8_t init_value) { uint8_t CRC8 = dat ^ init_value; for(uint8_t i = 0 ; i &lt; 8 ; i++) { if(CRC8 &amp; 0x80) CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07; else CRC8 &lt;&lt;= 1; } return CRC8; } 5)&nbsp;以上是8位检验值的直接计算方法，16位/32位也是同样的。 &nbsp; 4、CRC16、CRC32等多字节的校验值的计算有几点需要清楚（只针对一次一个字节的算法）： 1)&nbsp;初始值不为0的情况下，该如何计算： 输入数据需要反转：先将要计算的数据与初始值的最低字节进行异或，再与反转后的多项式进行计算。输入数据不需要反转：先将要计算的数据左移到与初始值对齐的位置（如CRC16算法，则左移8位，低位填充0；如CRC32算法，则左移24位，低位填充0）与初始值进行异或，再与正常的多项式进行计算。 2)&nbsp;结果异或值不为0的情况：第一步算得到的CRC值再与结果异或值进行异或操作得到最终的校验值： 输出数据反转：如果输入数据是反转的模式，则结果也是反转的 输出数据不反转：如果输入数据是不反转的模式，则结果也是不反转的 3）初始值的选择是可自己定义，很多不同的厂家使用的初始值是不一样，不一样的初始值得到的结果也是不一样的，要起到定制的效果，像上面提到的国际、行业使用的标准算法，初始值是固定的。 &nbsp; 5、使用查表法进行多字节数据检验值计算时的算法原理（可参考参考网址4中的推导部分）： 1)&nbsp;CRC8的查表法：要计算的单字节数据与初始值进行异或得到单字节数据，以此结果为表的序号从表中取得的值即为该字节的校验值；如果是多字节，则以前一字节的检验值作为初始值进行同样的操作，算法如下： //结果不异或其他值 uint8_t Get_CRC8_With_Table(uint8_t *datptr , uint8_t len , uint8_t init_value) { uint8_t CRC8 = init_value; while(len--) { CRC8 = CRC8_TABLE[(*datptr++) ^ CRC8]; } return CRC8; } 2)&nbsp;CRC16的查表法：要计算的单字节数据与初始值的高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转，结果不异或其他值 uint16_t Get_CRC16_With_Table(uint8_t *datptr , uint8_t len , uint16_t init_value) { uint16_t CRC16 = init_value; while(len--) { CRC16 = CRC16_TABLE[(*datptr++) ^ ((CRC16 &gt;&gt; 8) &amp; 0xFF)] ^ ((CRC16 &lt;&lt; 8) &amp; 0xFF00); } return CRC16; } 3)&nbsp;CRC32的查表法：要计算的单字节数据与初始值的最高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转的查表算法，结果不异或任何值&nbsp; uint32_t Get_CRC32_With_Table(uint8_t *datptr , uint8_t len , uint32_t init_value) { uint32_t CRC32 = init_value; while(len--) { CRC32 = CRC32_TABLE[(*datptr++) ^ ((CRC32 &gt;&gt; 24) &amp; 0xFF)] ^ ((CRC32 &lt;&lt; 8) &amp; 0xFFFFFF00); } return CRC32; } //反转输入、输出的查表算法，结果异或0xFFFFFFFF&nbsp; uint32_t Get_CRC32_With_Table_Inv(uint8_t *datptr , uint8_t len , uint32_t init_value) {uint32_t CRC32 = init_value;while(len--){CRC32 = CRC32_TABLE_INV[((*datptr++) ^ CRC32) &amp; 0xFF] ^ ((CRC32 &gt;&gt; 8) &amp; 0x00FFFFFF);}return CRC32 ^ 0xFFFFFFFF; } //生成输入、输出不反转的表&nbsp; void CRC32_Table_Init(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = (i &lt;&lt; 24);for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x80000000){CRC = (CRC &lt;&lt; 1) ^ 0x04C11DB7;}else{CRC &lt;&lt;= 1;}}CRC32_TABLE[i] = CRC;} } //生成输入、输出反转的表&nbsp; void CRC32_Table_Init_Inv(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = i;for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x00000001){CRC = (CRC &gt;&gt; 1) ^ 0xEDB88320;}else{CRC &gt;&gt;= 1;}}CRC32_TABLE_INV[i] = CRC;} }&nbsp; 6、使用查表法需要注意的问题： 1)&nbsp;关于表的生成，是以0~255这256个数分别计算得到的CRC检验值，需要注意的是，此表的生成需要配合所使用的CRC算法的配置，如输入数据是否要反转，输入数据反转和不反转对应的表是不一样的。还有很重要的一点，表的生成是以初始值为0时生成的检验值，否则会出错，以下我是生成的表数据： //输入、输出数据不反转使用查表法时的表数据 uint32_t CRC32_TABLE[256] = { 0x00000000 , 0x04C11DB7 , 0x09823B6E , 0x0D4326D9 , 0x130476DC , 0x17C56B6B , 0x1A864DB2 , 0x1E475005 , 0x2608EDB8 , 0x22C9F00F , 0x2F8AD6D6 , 0x2B4BCB61 , 0x350C9B64 , 0x31CD86D3 , 0x3C8EA00A , 0x384FBDBD , 0x4C11DB70 , 0x48D0C6C7 , 0x4593E01E , 0x4152FDA9 , 0x5F15ADAC , 0x5BD4B01B , 0x569796C2 , 0x52568B75 , 0x6A1936C8 , 0x6ED82B7F , 0x639B0DA6 , 0x675A1011 , 0x791D4014 , 0x7DDC5DA3 , 0x709F7B7A , 0x745E66CD , 0x9823B6E0 , 0x9CE2AB57 , 0x91A18D8E , 0x95609039 , 0x8B27C03C , 0x8FE6DD8B , 0x82A5FB52 , 0x8664E6E5 , 0xBE2B5B58 , 0xBAEA46EF , 0xB7A96036 , 0xB3687D81 , 0xAD2F2D84 , 0xA9EE3033 , 0xA4AD16EA , 0xA06C0B5D , 0xD4326D90 , 0xD0F37027 , 0xDDB056FE , 0xD9714B49 , 0xC7361B4C , 0xC3F706FB , 0xCEB42022 , 0xCA753D95 , 0xF23A8028 , 0xF6FB9D9F , 0xFBB8BB46 , 0xFF79A6F1 , 0xE13EF6F4 , 0xE5FFEB43 , 0xE8BCCD9A , 0xEC7DD02D , 0x34867077 , 0x30476DC0 , 0x3D044B19 , 0x39C556AE , 0x278206AB , 0x23431B1C , 0x2E003DC5 , 0x2AC12072 , 0x128E9DCF , 0x164F8078 , 0x1B0CA6A1 , 0x1FCDBB16 , 0x018AEB13 , 0x054BF6A4 , 0x0808D07D , 0x0CC9CDCA , 0x7897AB07 , 0x7C56B6B0 , 0x71159069 , 0x75D48DDE , 0x6B93DDDB , 0x6F52C06C , 0x6211E6B5 , 0x66D0FB02 , 0x5E9F46BF , 0x5A5E5B08 , 0x571D7DD1 , 0x53DC6066 , 0x4D9B3063 , 0x495A2DD4 , 0x44190B0D , 0x40D816BA , 0xACA5C697 , 0xA864DB20 , 0xA527FDF9 , 0xA1E6E04E , 0xBFA1B04B , 0xBB60ADFC , 0xB6238B25 , 0xB2E29692 , 0x8AAD2B2F , 0x8E6C3698 , 0x832F1041 , 0x87EE0DF6 , 0x99A95DF3 , 0x9D684044 , 0x902B669D , 0x94EA7B2A , 0xE0B41DE7 , 0xE4750050 , 0xE9362689 , 0xEDF73B3E , 0xF3B06B3B , 0xF771768C , 0xFA325055 , 0xFEF34DE2 , 0xC6BCF05F , 0xC27DEDE8 , 0xCF3ECB31 , 0xCBFFD686 , 0xD5B88683 , 0xD1799B34 , 0xDC3ABDED , 0xD8FBA05A , 0x690CE0EE , 0x6DCDFD59 , 0x608EDB80 , 0x644FC637 , 0x7A089632 , 0x7EC98B85 , 0x738AAD5C , 0x774BB0EB , 0x4F040D56 , 0x4BC510E1 , 0x46863638 , 0x42472B8F , 0x5C007B8A , 0x58C1663D , 0x558240E4 , 0x51435D53 , 0x251D3B9E , 0x21DC2629 , 0x2C9F00F0 , 0x285E1D47 , 0x36194D42 , 0x32D850F5 , 0x3F9B762C , 0x3B5A6B9B , 0x0315D626 , 0x07D4CB91 , 0x0A97ED48 , 0x0E56F0FF , 0x1011A0FA , 0x14D0BD4D , 0x19939B94 , 0x1D528623 , 0xF12F560E , 0xF5EE4BB9 , 0xF8AD6D60 , 0xFC6C70D7 , 0xE22B20D2 , 0xE6EA3D65 , 0xEBA91BBC , 0xEF68060B , 0xD727BBB6 , 0xD3E6A601 , 0xDEA580D8 , 0xDA649D6F , 0xC423CD6A , 0xC0E2D0DD , 0xCDA1F604 , 0xC960EBB3 , 0xBD3E8D7E , 0xB9FF90C9 , 0xB4BCB610 , 0xB07DABA7 , 0xAE3AFBA2 , 0xAAFBE615 , 0xA7B8C0CC , 0xA379DD7B , 0x9B3660C6 , 0x9FF77D71 , 0x92B45BA8 , 0x9675461F , 0x8832161A , 0x8CF30BAD , 0x81B02D74 , 0x857130C3 , 0x5D8A9099 , 0x594B8D2E , 0x5408ABF7 , 0x50C9B640 , 0x4E8EE645 , 0x4A4FFBF2 , 0x470CDD2B , 0x43CDC09C , 0x7B827D21 , 0x7F436096 , 0x7200464F , 0x76C15BF8 , 0x68860BFD , 0x6C47164A , 0x61043093 , 0x65C52D24 , 0x119B4BE9 , 0x155A565E , 0x18197087 , 0x1CD86D30 , 0x029F3D35 , 0x065E2082 , 0x0B1D065B , 0x0FDC1BEC , 0x3793A651 , 0x3352BBE6 , 0x3E119D3F , 0x3AD08088 , 0x2497D08D , 0x2056CD3A , 0x2D15EBE3 , 0x29D4F654 , 0xC5A92679 , 0xC1683BCE , 0xCC2B1D17 , 0xC8EA00A0 , 0xD6AD50A5 , 0xD26C4D12 , 0xDF2F6BCB , 0xDBEE767C , 0xE3A1CBC1 , 0xE760D676 , 0xEA23F0AF , 0xEEE2ED18 , 0xF0A5BD1D , 0xF464A0AA , 0xF9278673 , 0xFDE69BC4 , 0x89B8FD09 , 0x8D79E0BE , 0x803AC667 , 0x84FBDBD0 , 0x9ABC8BD5 , 0x9E7D9662 , 0x933EB0BB , 0x97FFAD0C , 0xAFB010B1 , 0xAB710D06 , 0xA6322BDF , 0xA2F33668 , 0xBCB4666D , 0xB8757BDA , 0xB5365D03 , 0xB1F740B4 , }; //输入、输出数据反转使用查表法时的表数据 uint32_t CRC32_TABLE_INV[256] = { 0x00000000 , 0x77073096 , 0xEE0E612C , 0x990951BA , 0x076DC419 , 0x706AF48F , 0xE963A535 , 0x9E6495A3 , 0x0EDB8832 , 0x79DCB8A4 , 0xE0D5E91E , 0x97D2D988 , 0x09B64C2B , 0x7EB17CBD , 0xE7B82D07 , 0x90BF1D91 , 0x1DB71064 , 0x6AB020F2 , 0xF3B97148 , 0x84BE41DE , 0x1ADAD47D , 0x6DDDE4EB , 0xF4D4B551 , 0x83D385C7 , 0x136C9856 , 0x646BA8C0 , 0xFD62F97A , 0x8A65C9EC , 0x14015C4F , 0x63066CD9 , 0xFA0F3D63 , 0x8D080DF5 , 0x3B6E20C8 , 0x4C69105E , 0xD56041E4 , 0xA2677172 , 0x3C03E4D1 , 0x4B04D447 , 0xD20D85FD , 0xA50AB56B , 0x35B5A8FA , 0x42B2986C , 0xDBBBC9D6 , 0xACBCF940 , 0x32D86CE3 , 0x45DF5C75 , 0xDCD60DCF , 0xABD13D59 , 0x26D930AC , 0x51DE003A , 0xC8D75180 , 0xBFD06116 , 0x21B4F4B5 , 0x56B3C423 , 0xCFBA9599 , 0xB8BDA50F , 0x2802B89E , 0x5F058808 , 0xC60CD9B2 , 0xB10BE924 , 0x2F6F7C87 , 0x58684C11 , 0xC1611DAB , 0xB6662D3D , 0x76DC4190 , 0x01DB7106 , 0x98D220BC , 0xEFD5102A , 0x71B18589 , 0x06B6B51F , 0x9FBFE4A5 , 0xE8B8D433 , 0x7807C9A2 , 0x0F00F934 , 0x9609A88E , 0xE10E9818 , 0x7F6A0DBB , 0x086D3D2D , 0x91646C97 , 0xE6635C01 , 0x6B6B51F4 , 0x1C6C6162 , 0x856530D8 , 0xF262004E , 0x6C0695ED , 0x1B01A57B , 0x8208F4C1 , 0xF50FC457 , 0x65B0D9C6 , 0x12B7E950 , 0x8BBEB8EA , 0xFCB9887C , 0x62DD1DDF , 0x15DA2D49 , 0x8CD37CF3 , 0xFBD44C65 , 0x4DB26158 , 0x3AB551CE , 0xA3BC0074 , 0xD4BB30E2 , 0x4ADFA541 , 0x3DD895D7 , 0xA4D1C46D , 0xD3D6F4FB , 0x4369E96A , 0x346ED9FC , 0xAD678846 , 0xDA60B8D0 , 0x44042D73 , 0x33031DE5 , 0xAA0A4C5F , 0xDD0D7CC9 , 0x5005713C , 0x270241AA , 0xBE0B1010 , 0xC90C2086 , 0x5768B525 , 0x206F85B3 , 0xB966D409 , 0xCE61E49F , 0x5EDEF90E , 0x29D9C998 , 0xB0D09822 , 0xC7D7A8B4 , 0x59B33D17 , 0x2EB40D81 , 0xB7BD5C3B , 0xC0BA6CAD , 0xEDB88320 , 0x9ABFB3B6 , 0x03B6E20C , 0x74B1D29A , 0xEAD54739 , 0x9DD277AF , 0x04DB2615 , 0x73DC1683 , 0xE3630B12 , 0x94643B84 , 0x0D6D6A3E , 0x7A6A5AA8 , 0xE40ECF0B , 0x9309FF9D , 0x0A00AE27 , 0x7D079EB1 , 0xF00F9344 , 0x8708A3D2 , 0x1E01F268 , 0x6906C2FE , 0xF762575D , 0x806567CB , 0x196C3671 , 0x6E6B06E7 , 0xFED41B76 , 0x89D32BE0 , 0x10DA7A5A , 0x67DD4ACC , 0xF9B9DF6F , 0x8EBEEFF9 , 0x17B7BE43 , 0x60B08ED5 , 0xD6D6A3E8 , 0xA1D1937E , 0x38D8C2C4 , 0x4FDFF252 , 0xD1BB67F1 , 0xA6BC5767 , 0x3FB506DD , 0x48B2364B , 0xD80D2BDA , 0xAF0A1B4C , 0x36034AF6 , 0x41047A60 , 0xDF60EFC3 , 0xA867DF55 , 0x316E8EEF , 0x4669BE79 , 0xCB61B38C , 0xBC66831A , 0x256FD2A0 , 0x5268E236 , 0xCC0C7795 , 0xBB0B4703 , 0x220216B9 , 0x5505262F , 0xC5BA3BBE , 0xB2BD0B28 , 0x2BB45A92 , 0x5CB36A04 , 0xC2D7FFA7 , 0xB5D0CF31 , 0x2CD99E8B , 0x5BDEAE1D , 0x9B64C2B0 , 0xEC63F226 , 0x756AA39C , 0x026D930A , 0x9C0906A9 , 0xEB0E363F , 0x72076785 , 0x05005713 , 0x95BF4A82 , 0xE2B87A14 , 0x7BB12BAE , 0x0CB61B38 , 0x92D28E9B , 0xE5D5BE0D , 0x7CDCEFB7 , 0x0BDBDF21 , 0x86D3D2D4 , 0xF1D4E242 , 0x68DDB3F8 , 0x1FDA836E , 0x81BE16CD , 0xF6B9265B , 0x6FB077E1 , 0x18B74777 , 0x88085AE6 , 0xFF0F6A70 , 0x66063BCA , 0x11010B5C , 0x8F659EFF , 0xF862AE69 , 0x616BFFD3 , 0x166CCF45 , 0xA00AE278 , 0xD70DD2EE , 0x4E048354 , 0x3903B3C2 , 0xA7672661 , 0xD06016F7 , 0x4969474D , 0x3E6E77DB , 0xAED16A4A , 0xD9D65ADC , 0x40DF0B66 , 0x37D83BF0 , 0xA9BCAE53 , 0xDEBB9EC5 , 0x47B2CF7F , 0x30B5FFE9 , 0xBDBDF21C , 0xCABAC28A , 0x53B39330 , 0x24B4A3A6 , 0xBAD03605 , 0xCDD70693 , 0x54DE5729 , 0x23D967BF , 0xB3667A2E , 0xC4614AB8 , 0x5D681B02 , 0x2A6F2B94 , 0xB40BBE37 , 0xC30C8EA1 , 0x5A05DF1B , 0x2D02EF8D , }; 阅读更多" />
<meta property="og:description" content="CRC检验码主要是用在数据校验中，用于判断对应数据是否发生传输错误，详细的介绍百度就可以。本文主要是记录我个人在这几天学习使用CRC的过程中遇到的问题。各位在阅读时如果有发现问题，可在评论区留言，谢谢。 1、CRC算法会根据选择生成的检验码的长度，需要设置一个生成多项式，一般会使用国际上几个大厂或者行业内的常用的标准多项式，而且这些标准还有其他选项细微的差别， 比如初始值的设置、是从数据的MSB/LSB开始计算、结果是否需要与其他值异或等，以下是我找到的几个通用算法的配置信息： 参考网址1：http://www.ip33.com/crc.html 参考网址2：http://blog.csdn.net/xlhcgd/article/details/44980005 参考网址3：https://wenku.baidu.com/view/3c9eadc7cc7931b764ce15b8.html &nbsp; 2、算法原理（参考网址4：http://blog.csdn.net/huang_shiyang/article/details/50881305） 假设数据传输过程中需要发送15位的二进制信息g=101001110100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，既将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。 h(x)可以自由选择或者使用国际通行标准，一般按照h(x)的阶数m，将CRC算法称为CRC-m，比如CRC-32、CRC-64等。国际通行标准可以参看http://en.wikipedia.org/wiki/Cyclic_redundancy_check g(x)和h(x)的除运算，可以通过g和h做xor（异或）运算。比如将11001与10101做xor运算： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 明白了xor运算法则后，举一个例子使用CRC-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 +1，既h是9位的二进制串111010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过迭代运算后，最终得到的r是10001100，这就是CRC效验码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过示例，可以发现一些规律，依据这些规律调整算法：&nbsp;1.&nbsp;每次迭代，根据gk的首位决定b，b是与gk进行运算的二进制码。若gk的首位是1，则b=h；若gk的首位是0，则b=0，或者跳过此次迭代，上面的例子中就是碰到0后直接跳到后面的非零位。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;每次迭代，gk的首位将会被移出，所以只需考虑第2位后计算即可。这样就可以舍弃h的首位，将b取h的后m位。比如CRC-8的h是111010101，b只需是11010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;每次迭代，受到影响的是gk的前m位，所以构建一个m位的寄存器S，此寄存器储存gk的前m位。每次迭代计算前先将S的首位抛弃，将寄存器左移一位，同时将g的后一位加入寄存器。若使用此种方法，计算步骤如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ※蓝色表示寄存器S的首位，是需要移出的，b根据S的首位选择0或者h。黄色是需要移入寄存器的位。S&#39;是经过位移后的S。 &nbsp; 3、举个例子，计算单字节0x81的CRC8的值（生成多项式：0x07，初始值00，输入输出不反转） 1)&nbsp;将经0x81与初始值0x00进行异或 CRC8 = 0x81 XOR 0x00 = 0x81; 2)&nbsp;从判断数据的最高位，选择对应的计算方法 1：数据左移一位，然后与多项式0x07进行异或，CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07 0：数据左移一位，然后不动作，CRC8 =（CRC8 &lt;&lt; 1) 3)&nbsp;8位数据是否都移动完：未移动完：返回第2步继续计算移动完 &nbsp;：最后的结果则为最终的8位校验值 4)&nbsp;对应的C代码 uint8_t Get_CRC8( uint8_t dat , uint8_t init_value) { uint8_t CRC8 = dat ^ init_value; for(uint8_t i = 0 ; i &lt; 8 ; i++) { if(CRC8 &amp; 0x80) CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07; else CRC8 &lt;&lt;= 1; } return CRC8; } 5)&nbsp;以上是8位检验值的直接计算方法，16位/32位也是同样的。 &nbsp; 4、CRC16、CRC32等多字节的校验值的计算有几点需要清楚（只针对一次一个字节的算法）： 1)&nbsp;初始值不为0的情况下，该如何计算： 输入数据需要反转：先将要计算的数据与初始值的最低字节进行异或，再与反转后的多项式进行计算。输入数据不需要反转：先将要计算的数据左移到与初始值对齐的位置（如CRC16算法，则左移8位，低位填充0；如CRC32算法，则左移24位，低位填充0）与初始值进行异或，再与正常的多项式进行计算。 2)&nbsp;结果异或值不为0的情况：第一步算得到的CRC值再与结果异或值进行异或操作得到最终的校验值： 输出数据反转：如果输入数据是反转的模式，则结果也是反转的 输出数据不反转：如果输入数据是不反转的模式，则结果也是不反转的 3）初始值的选择是可自己定义，很多不同的厂家使用的初始值是不一样，不一样的初始值得到的结果也是不一样的，要起到定制的效果，像上面提到的国际、行业使用的标准算法，初始值是固定的。 &nbsp; 5、使用查表法进行多字节数据检验值计算时的算法原理（可参考参考网址4中的推导部分）： 1)&nbsp;CRC8的查表法：要计算的单字节数据与初始值进行异或得到单字节数据，以此结果为表的序号从表中取得的值即为该字节的校验值；如果是多字节，则以前一字节的检验值作为初始值进行同样的操作，算法如下： //结果不异或其他值 uint8_t Get_CRC8_With_Table(uint8_t *datptr , uint8_t len , uint8_t init_value) { uint8_t CRC8 = init_value; while(len--) { CRC8 = CRC8_TABLE[(*datptr++) ^ CRC8]; } return CRC8; } 2)&nbsp;CRC16的查表法：要计算的单字节数据与初始值的高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转，结果不异或其他值 uint16_t Get_CRC16_With_Table(uint8_t *datptr , uint8_t len , uint16_t init_value) { uint16_t CRC16 = init_value; while(len--) { CRC16 = CRC16_TABLE[(*datptr++) ^ ((CRC16 &gt;&gt; 8) &amp; 0xFF)] ^ ((CRC16 &lt;&lt; 8) &amp; 0xFF00); } return CRC16; } 3)&nbsp;CRC32的查表法：要计算的单字节数据与初始值的最高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转的查表算法，结果不异或任何值&nbsp; uint32_t Get_CRC32_With_Table(uint8_t *datptr , uint8_t len , uint32_t init_value) { uint32_t CRC32 = init_value; while(len--) { CRC32 = CRC32_TABLE[(*datptr++) ^ ((CRC32 &gt;&gt; 24) &amp; 0xFF)] ^ ((CRC32 &lt;&lt; 8) &amp; 0xFFFFFF00); } return CRC32; } //反转输入、输出的查表算法，结果异或0xFFFFFFFF&nbsp; uint32_t Get_CRC32_With_Table_Inv(uint8_t *datptr , uint8_t len , uint32_t init_value) {uint32_t CRC32 = init_value;while(len--){CRC32 = CRC32_TABLE_INV[((*datptr++) ^ CRC32) &amp; 0xFF] ^ ((CRC32 &gt;&gt; 8) &amp; 0x00FFFFFF);}return CRC32 ^ 0xFFFFFFFF; } //生成输入、输出不反转的表&nbsp; void CRC32_Table_Init(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = (i &lt;&lt; 24);for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x80000000){CRC = (CRC &lt;&lt; 1) ^ 0x04C11DB7;}else{CRC &lt;&lt;= 1;}}CRC32_TABLE[i] = CRC;} } //生成输入、输出反转的表&nbsp; void CRC32_Table_Init_Inv(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = i;for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x00000001){CRC = (CRC &gt;&gt; 1) ^ 0xEDB88320;}else{CRC &gt;&gt;= 1;}}CRC32_TABLE_INV[i] = CRC;} }&nbsp; 6、使用查表法需要注意的问题： 1)&nbsp;关于表的生成，是以0~255这256个数分别计算得到的CRC检验值，需要注意的是，此表的生成需要配合所使用的CRC算法的配置，如输入数据是否要反转，输入数据反转和不反转对应的表是不一样的。还有很重要的一点，表的生成是以初始值为0时生成的检验值，否则会出错，以下我是生成的表数据： //输入、输出数据不反转使用查表法时的表数据 uint32_t CRC32_TABLE[256] = { 0x00000000 , 0x04C11DB7 , 0x09823B6E , 0x0D4326D9 , 0x130476DC , 0x17C56B6B , 0x1A864DB2 , 0x1E475005 , 0x2608EDB8 , 0x22C9F00F , 0x2F8AD6D6 , 0x2B4BCB61 , 0x350C9B64 , 0x31CD86D3 , 0x3C8EA00A , 0x384FBDBD , 0x4C11DB70 , 0x48D0C6C7 , 0x4593E01E , 0x4152FDA9 , 0x5F15ADAC , 0x5BD4B01B , 0x569796C2 , 0x52568B75 , 0x6A1936C8 , 0x6ED82B7F , 0x639B0DA6 , 0x675A1011 , 0x791D4014 , 0x7DDC5DA3 , 0x709F7B7A , 0x745E66CD , 0x9823B6E0 , 0x9CE2AB57 , 0x91A18D8E , 0x95609039 , 0x8B27C03C , 0x8FE6DD8B , 0x82A5FB52 , 0x8664E6E5 , 0xBE2B5B58 , 0xBAEA46EF , 0xB7A96036 , 0xB3687D81 , 0xAD2F2D84 , 0xA9EE3033 , 0xA4AD16EA , 0xA06C0B5D , 0xD4326D90 , 0xD0F37027 , 0xDDB056FE , 0xD9714B49 , 0xC7361B4C , 0xC3F706FB , 0xCEB42022 , 0xCA753D95 , 0xF23A8028 , 0xF6FB9D9F , 0xFBB8BB46 , 0xFF79A6F1 , 0xE13EF6F4 , 0xE5FFEB43 , 0xE8BCCD9A , 0xEC7DD02D , 0x34867077 , 0x30476DC0 , 0x3D044B19 , 0x39C556AE , 0x278206AB , 0x23431B1C , 0x2E003DC5 , 0x2AC12072 , 0x128E9DCF , 0x164F8078 , 0x1B0CA6A1 , 0x1FCDBB16 , 0x018AEB13 , 0x054BF6A4 , 0x0808D07D , 0x0CC9CDCA , 0x7897AB07 , 0x7C56B6B0 , 0x71159069 , 0x75D48DDE , 0x6B93DDDB , 0x6F52C06C , 0x6211E6B5 , 0x66D0FB02 , 0x5E9F46BF , 0x5A5E5B08 , 0x571D7DD1 , 0x53DC6066 , 0x4D9B3063 , 0x495A2DD4 , 0x44190B0D , 0x40D816BA , 0xACA5C697 , 0xA864DB20 , 0xA527FDF9 , 0xA1E6E04E , 0xBFA1B04B , 0xBB60ADFC , 0xB6238B25 , 0xB2E29692 , 0x8AAD2B2F , 0x8E6C3698 , 0x832F1041 , 0x87EE0DF6 , 0x99A95DF3 , 0x9D684044 , 0x902B669D , 0x94EA7B2A , 0xE0B41DE7 , 0xE4750050 , 0xE9362689 , 0xEDF73B3E , 0xF3B06B3B , 0xF771768C , 0xFA325055 , 0xFEF34DE2 , 0xC6BCF05F , 0xC27DEDE8 , 0xCF3ECB31 , 0xCBFFD686 , 0xD5B88683 , 0xD1799B34 , 0xDC3ABDED , 0xD8FBA05A , 0x690CE0EE , 0x6DCDFD59 , 0x608EDB80 , 0x644FC637 , 0x7A089632 , 0x7EC98B85 , 0x738AAD5C , 0x774BB0EB , 0x4F040D56 , 0x4BC510E1 , 0x46863638 , 0x42472B8F , 0x5C007B8A , 0x58C1663D , 0x558240E4 , 0x51435D53 , 0x251D3B9E , 0x21DC2629 , 0x2C9F00F0 , 0x285E1D47 , 0x36194D42 , 0x32D850F5 , 0x3F9B762C , 0x3B5A6B9B , 0x0315D626 , 0x07D4CB91 , 0x0A97ED48 , 0x0E56F0FF , 0x1011A0FA , 0x14D0BD4D , 0x19939B94 , 0x1D528623 , 0xF12F560E , 0xF5EE4BB9 , 0xF8AD6D60 , 0xFC6C70D7 , 0xE22B20D2 , 0xE6EA3D65 , 0xEBA91BBC , 0xEF68060B , 0xD727BBB6 , 0xD3E6A601 , 0xDEA580D8 , 0xDA649D6F , 0xC423CD6A , 0xC0E2D0DD , 0xCDA1F604 , 0xC960EBB3 , 0xBD3E8D7E , 0xB9FF90C9 , 0xB4BCB610 , 0xB07DABA7 , 0xAE3AFBA2 , 0xAAFBE615 , 0xA7B8C0CC , 0xA379DD7B , 0x9B3660C6 , 0x9FF77D71 , 0x92B45BA8 , 0x9675461F , 0x8832161A , 0x8CF30BAD , 0x81B02D74 , 0x857130C3 , 0x5D8A9099 , 0x594B8D2E , 0x5408ABF7 , 0x50C9B640 , 0x4E8EE645 , 0x4A4FFBF2 , 0x470CDD2B , 0x43CDC09C , 0x7B827D21 , 0x7F436096 , 0x7200464F , 0x76C15BF8 , 0x68860BFD , 0x6C47164A , 0x61043093 , 0x65C52D24 , 0x119B4BE9 , 0x155A565E , 0x18197087 , 0x1CD86D30 , 0x029F3D35 , 0x065E2082 , 0x0B1D065B , 0x0FDC1BEC , 0x3793A651 , 0x3352BBE6 , 0x3E119D3F , 0x3AD08088 , 0x2497D08D , 0x2056CD3A , 0x2D15EBE3 , 0x29D4F654 , 0xC5A92679 , 0xC1683BCE , 0xCC2B1D17 , 0xC8EA00A0 , 0xD6AD50A5 , 0xD26C4D12 , 0xDF2F6BCB , 0xDBEE767C , 0xE3A1CBC1 , 0xE760D676 , 0xEA23F0AF , 0xEEE2ED18 , 0xF0A5BD1D , 0xF464A0AA , 0xF9278673 , 0xFDE69BC4 , 0x89B8FD09 , 0x8D79E0BE , 0x803AC667 , 0x84FBDBD0 , 0x9ABC8BD5 , 0x9E7D9662 , 0x933EB0BB , 0x97FFAD0C , 0xAFB010B1 , 0xAB710D06 , 0xA6322BDF , 0xA2F33668 , 0xBCB4666D , 0xB8757BDA , 0xB5365D03 , 0xB1F740B4 , }; //输入、输出数据反转使用查表法时的表数据 uint32_t CRC32_TABLE_INV[256] = { 0x00000000 , 0x77073096 , 0xEE0E612C , 0x990951BA , 0x076DC419 , 0x706AF48F , 0xE963A535 , 0x9E6495A3 , 0x0EDB8832 , 0x79DCB8A4 , 0xE0D5E91E , 0x97D2D988 , 0x09B64C2B , 0x7EB17CBD , 0xE7B82D07 , 0x90BF1D91 , 0x1DB71064 , 0x6AB020F2 , 0xF3B97148 , 0x84BE41DE , 0x1ADAD47D , 0x6DDDE4EB , 0xF4D4B551 , 0x83D385C7 , 0x136C9856 , 0x646BA8C0 , 0xFD62F97A , 0x8A65C9EC , 0x14015C4F , 0x63066CD9 , 0xFA0F3D63 , 0x8D080DF5 , 0x3B6E20C8 , 0x4C69105E , 0xD56041E4 , 0xA2677172 , 0x3C03E4D1 , 0x4B04D447 , 0xD20D85FD , 0xA50AB56B , 0x35B5A8FA , 0x42B2986C , 0xDBBBC9D6 , 0xACBCF940 , 0x32D86CE3 , 0x45DF5C75 , 0xDCD60DCF , 0xABD13D59 , 0x26D930AC , 0x51DE003A , 0xC8D75180 , 0xBFD06116 , 0x21B4F4B5 , 0x56B3C423 , 0xCFBA9599 , 0xB8BDA50F , 0x2802B89E , 0x5F058808 , 0xC60CD9B2 , 0xB10BE924 , 0x2F6F7C87 , 0x58684C11 , 0xC1611DAB , 0xB6662D3D , 0x76DC4190 , 0x01DB7106 , 0x98D220BC , 0xEFD5102A , 0x71B18589 , 0x06B6B51F , 0x9FBFE4A5 , 0xE8B8D433 , 0x7807C9A2 , 0x0F00F934 , 0x9609A88E , 0xE10E9818 , 0x7F6A0DBB , 0x086D3D2D , 0x91646C97 , 0xE6635C01 , 0x6B6B51F4 , 0x1C6C6162 , 0x856530D8 , 0xF262004E , 0x6C0695ED , 0x1B01A57B , 0x8208F4C1 , 0xF50FC457 , 0x65B0D9C6 , 0x12B7E950 , 0x8BBEB8EA , 0xFCB9887C , 0x62DD1DDF , 0x15DA2D49 , 0x8CD37CF3 , 0xFBD44C65 , 0x4DB26158 , 0x3AB551CE , 0xA3BC0074 , 0xD4BB30E2 , 0x4ADFA541 , 0x3DD895D7 , 0xA4D1C46D , 0xD3D6F4FB , 0x4369E96A , 0x346ED9FC , 0xAD678846 , 0xDA60B8D0 , 0x44042D73 , 0x33031DE5 , 0xAA0A4C5F , 0xDD0D7CC9 , 0x5005713C , 0x270241AA , 0xBE0B1010 , 0xC90C2086 , 0x5768B525 , 0x206F85B3 , 0xB966D409 , 0xCE61E49F , 0x5EDEF90E , 0x29D9C998 , 0xB0D09822 , 0xC7D7A8B4 , 0x59B33D17 , 0x2EB40D81 , 0xB7BD5C3B , 0xC0BA6CAD , 0xEDB88320 , 0x9ABFB3B6 , 0x03B6E20C , 0x74B1D29A , 0xEAD54739 , 0x9DD277AF , 0x04DB2615 , 0x73DC1683 , 0xE3630B12 , 0x94643B84 , 0x0D6D6A3E , 0x7A6A5AA8 , 0xE40ECF0B , 0x9309FF9D , 0x0A00AE27 , 0x7D079EB1 , 0xF00F9344 , 0x8708A3D2 , 0x1E01F268 , 0x6906C2FE , 0xF762575D , 0x806567CB , 0x196C3671 , 0x6E6B06E7 , 0xFED41B76 , 0x89D32BE0 , 0x10DA7A5A , 0x67DD4ACC , 0xF9B9DF6F , 0x8EBEEFF9 , 0x17B7BE43 , 0x60B08ED5 , 0xD6D6A3E8 , 0xA1D1937E , 0x38D8C2C4 , 0x4FDFF252 , 0xD1BB67F1 , 0xA6BC5767 , 0x3FB506DD , 0x48B2364B , 0xD80D2BDA , 0xAF0A1B4C , 0x36034AF6 , 0x41047A60 , 0xDF60EFC3 , 0xA867DF55 , 0x316E8EEF , 0x4669BE79 , 0xCB61B38C , 0xBC66831A , 0x256FD2A0 , 0x5268E236 , 0xCC0C7795 , 0xBB0B4703 , 0x220216B9 , 0x5505262F , 0xC5BA3BBE , 0xB2BD0B28 , 0x2BB45A92 , 0x5CB36A04 , 0xC2D7FFA7 , 0xB5D0CF31 , 0x2CD99E8B , 0x5BDEAE1D , 0x9B64C2B0 , 0xEC63F226 , 0x756AA39C , 0x026D930A , 0x9C0906A9 , 0xEB0E363F , 0x72076785 , 0x05005713 , 0x95BF4A82 , 0xE2B87A14 , 0x7BB12BAE , 0x0CB61B38 , 0x92D28E9B , 0xE5D5BE0D , 0x7CDCEFB7 , 0x0BDBDF21 , 0x86D3D2D4 , 0xF1D4E242 , 0x68DDB3F8 , 0x1FDA836E , 0x81BE16CD , 0xF6B9265B , 0x6FB077E1 , 0x18B74777 , 0x88085AE6 , 0xFF0F6A70 , 0x66063BCA , 0x11010B5C , 0x8F659EFF , 0xF862AE69 , 0x616BFFD3 , 0x166CCF45 , 0xA00AE278 , 0xD70DD2EE , 0x4E048354 , 0x3903B3C2 , 0xA7672661 , 0xD06016F7 , 0x4969474D , 0x3E6E77DB , 0xAED16A4A , 0xD9D65ADC , 0x40DF0B66 , 0x37D83BF0 , 0xA9BCAE53 , 0xDEBB9EC5 , 0x47B2CF7F , 0x30B5FFE9 , 0xBDBDF21C , 0xCABAC28A , 0x53B39330 , 0x24B4A3A6 , 0xBAD03605 , 0xCDD70693 , 0x54DE5729 , 0x23D967BF , 0xB3667A2E , 0xC4614AB8 , 0x5D681B02 , 0x2A6F2B94 , 0xB40BBE37 , 0xC30C8EA1 , 0x5A05DF1B , 0x2D02EF8D , }; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/12/09/6b21a5f8342ea57306b14dba5cbc3f59.html" />
<meta property="og:url" content="https://mlh.app/2017/12/09/6b21a5f8342ea57306b14dba5cbc3f59.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"CRC检验码主要是用在数据校验中，用于判断对应数据是否发生传输错误，详细的介绍百度就可以。本文主要是记录我个人在这几天学习使用CRC的过程中遇到的问题。各位在阅读时如果有发现问题，可在评论区留言，谢谢。 1、CRC算法会根据选择生成的检验码的长度，需要设置一个生成多项式，一般会使用国际上几个大厂或者行业内的常用的标准多项式，而且这些标准还有其他选项细微的差别， 比如初始值的设置、是从数据的MSB/LSB开始计算、结果是否需要与其他值异或等，以下是我找到的几个通用算法的配置信息： 参考网址1：http://www.ip33.com/crc.html 参考网址2：http://blog.csdn.net/xlhcgd/article/details/44980005 参考网址3：https://wenku.baidu.com/view/3c9eadc7cc7931b764ce15b8.html &nbsp; 2、算法原理（参考网址4：http://blog.csdn.net/huang_shiyang/article/details/50881305） 假设数据传输过程中需要发送15位的二进制信息g=101001110100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，既将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。 h(x)可以自由选择或者使用国际通行标准，一般按照h(x)的阶数m，将CRC算法称为CRC-m，比如CRC-32、CRC-64等。国际通行标准可以参看http://en.wikipedia.org/wiki/Cyclic_redundancy_check g(x)和h(x)的除运算，可以通过g和h做xor（异或）运算。比如将11001与10101做xor运算： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 明白了xor运算法则后，举一个例子使用CRC-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 +1，既h是9位的二进制串111010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过迭代运算后，最终得到的r是10001100，这就是CRC效验码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过示例，可以发现一些规律，依据这些规律调整算法：&nbsp;1.&nbsp;每次迭代，根据gk的首位决定b，b是与gk进行运算的二进制码。若gk的首位是1，则b=h；若gk的首位是0，则b=0，或者跳过此次迭代，上面的例子中就是碰到0后直接跳到后面的非零位。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;每次迭代，gk的首位将会被移出，所以只需考虑第2位后计算即可。这样就可以舍弃h的首位，将b取h的后m位。比如CRC-8的h是111010101，b只需是11010101。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;每次迭代，受到影响的是gk的前m位，所以构建一个m位的寄存器S，此寄存器储存gk的前m位。每次迭代计算前先将S的首位抛弃，将寄存器左移一位，同时将g的后一位加入寄存器。若使用此种方法，计算步骤如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ※蓝色表示寄存器S的首位，是需要移出的，b根据S的首位选择0或者h。黄色是需要移入寄存器的位。S&#39;是经过位移后的S。 &nbsp; 3、举个例子，计算单字节0x81的CRC8的值（生成多项式：0x07，初始值00，输入输出不反转） 1)&nbsp;将经0x81与初始值0x00进行异或 CRC8 = 0x81 XOR 0x00 = 0x81; 2)&nbsp;从判断数据的最高位，选择对应的计算方法 1：数据左移一位，然后与多项式0x07进行异或，CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07 0：数据左移一位，然后不动作，CRC8 =（CRC8 &lt;&lt; 1) 3)&nbsp;8位数据是否都移动完：未移动完：返回第2步继续计算移动完 &nbsp;：最后的结果则为最终的8位校验值 4)&nbsp;对应的C代码 uint8_t Get_CRC8( uint8_t dat , uint8_t init_value) { uint8_t CRC8 = dat ^ init_value; for(uint8_t i = 0 ; i &lt; 8 ; i++) { if(CRC8 &amp; 0x80) CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07; else CRC8 &lt;&lt;= 1; } return CRC8; } 5)&nbsp;以上是8位检验值的直接计算方法，16位/32位也是同样的。 &nbsp; 4、CRC16、CRC32等多字节的校验值的计算有几点需要清楚（只针对一次一个字节的算法）： 1)&nbsp;初始值不为0的情况下，该如何计算： 输入数据需要反转：先将要计算的数据与初始值的最低字节进行异或，再与反转后的多项式进行计算。输入数据不需要反转：先将要计算的数据左移到与初始值对齐的位置（如CRC16算法，则左移8位，低位填充0；如CRC32算法，则左移24位，低位填充0）与初始值进行异或，再与正常的多项式进行计算。 2)&nbsp;结果异或值不为0的情况：第一步算得到的CRC值再与结果异或值进行异或操作得到最终的校验值： 输出数据反转：如果输入数据是反转的模式，则结果也是反转的 输出数据不反转：如果输入数据是不反转的模式，则结果也是不反转的 3）初始值的选择是可自己定义，很多不同的厂家使用的初始值是不一样，不一样的初始值得到的结果也是不一样的，要起到定制的效果，像上面提到的国际、行业使用的标准算法，初始值是固定的。 &nbsp; 5、使用查表法进行多字节数据检验值计算时的算法原理（可参考参考网址4中的推导部分）： 1)&nbsp;CRC8的查表法：要计算的单字节数据与初始值进行异或得到单字节数据，以此结果为表的序号从表中取得的值即为该字节的校验值；如果是多字节，则以前一字节的检验值作为初始值进行同样的操作，算法如下： //结果不异或其他值 uint8_t Get_CRC8_With_Table(uint8_t *datptr , uint8_t len , uint8_t init_value) { uint8_t CRC8 = init_value; while(len--) { CRC8 = CRC8_TABLE[(*datptr++) ^ CRC8]; } return CRC8; } 2)&nbsp;CRC16的查表法：要计算的单字节数据与初始值的高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转，结果不异或其他值 uint16_t Get_CRC16_With_Table(uint8_t *datptr , uint8_t len , uint16_t init_value) { uint16_t CRC16 = init_value; while(len--) { CRC16 = CRC16_TABLE[(*datptr++) ^ ((CRC16 &gt;&gt; 8) &amp; 0xFF)] ^ ((CRC16 &lt;&lt; 8) &amp; 0xFF00); } return CRC16; } 3)&nbsp;CRC32的查表法：要计算的单字节数据与初始值的最高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移8位后的值进行异或得到最终的检验值： //输入、输出不反转的查表算法，结果不异或任何值&nbsp; uint32_t Get_CRC32_With_Table(uint8_t *datptr , uint8_t len , uint32_t init_value) { uint32_t CRC32 = init_value; while(len--) { CRC32 = CRC32_TABLE[(*datptr++) ^ ((CRC32 &gt;&gt; 24) &amp; 0xFF)] ^ ((CRC32 &lt;&lt; 8) &amp; 0xFFFFFF00); } return CRC32; } //反转输入、输出的查表算法，结果异或0xFFFFFFFF&nbsp; uint32_t Get_CRC32_With_Table_Inv(uint8_t *datptr , uint8_t len , uint32_t init_value) {uint32_t CRC32 = init_value;while(len--){CRC32 = CRC32_TABLE_INV[((*datptr++) ^ CRC32) &amp; 0xFF] ^ ((CRC32 &gt;&gt; 8) &amp; 0x00FFFFFF);}return CRC32 ^ 0xFFFFFFFF; } //生成输入、输出不反转的表&nbsp; void CRC32_Table_Init(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = (i &lt;&lt; 24);for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x80000000){CRC = (CRC &lt;&lt; 1) ^ 0x04C11DB7;}else{CRC &lt;&lt;= 1;}}CRC32_TABLE[i] = CRC;} } //生成输入、输出反转的表&nbsp; void CRC32_Table_Init_Inv(void) {uint32_t i , j;uint32_t CRC = 0;for(i = 0 ; i &lt; 256 ; i++){CRC = i;for(j = 0 ; j &lt; 8 ; j++){if(CRC &amp; 0x00000001){CRC = (CRC &gt;&gt; 1) ^ 0xEDB88320;}else{CRC &gt;&gt;= 1;}}CRC32_TABLE_INV[i] = CRC;} }&nbsp; 6、使用查表法需要注意的问题： 1)&nbsp;关于表的生成，是以0~255这256个数分别计算得到的CRC检验值，需要注意的是，此表的生成需要配合所使用的CRC算法的配置，如输入数据是否要反转，输入数据反转和不反转对应的表是不一样的。还有很重要的一点，表的生成是以初始值为0时生成的检验值，否则会出错，以下我是生成的表数据： //输入、输出数据不反转使用查表法时的表数据 uint32_t CRC32_TABLE[256] = { 0x00000000 , 0x04C11DB7 , 0x09823B6E , 0x0D4326D9 , 0x130476DC , 0x17C56B6B , 0x1A864DB2 , 0x1E475005 , 0x2608EDB8 , 0x22C9F00F , 0x2F8AD6D6 , 0x2B4BCB61 , 0x350C9B64 , 0x31CD86D3 , 0x3C8EA00A , 0x384FBDBD , 0x4C11DB70 , 0x48D0C6C7 , 0x4593E01E , 0x4152FDA9 , 0x5F15ADAC , 0x5BD4B01B , 0x569796C2 , 0x52568B75 , 0x6A1936C8 , 0x6ED82B7F , 0x639B0DA6 , 0x675A1011 , 0x791D4014 , 0x7DDC5DA3 , 0x709F7B7A , 0x745E66CD , 0x9823B6E0 , 0x9CE2AB57 , 0x91A18D8E , 0x95609039 , 0x8B27C03C , 0x8FE6DD8B , 0x82A5FB52 , 0x8664E6E5 , 0xBE2B5B58 , 0xBAEA46EF , 0xB7A96036 , 0xB3687D81 , 0xAD2F2D84 , 0xA9EE3033 , 0xA4AD16EA , 0xA06C0B5D , 0xD4326D90 , 0xD0F37027 , 0xDDB056FE , 0xD9714B49 , 0xC7361B4C , 0xC3F706FB , 0xCEB42022 , 0xCA753D95 , 0xF23A8028 , 0xF6FB9D9F , 0xFBB8BB46 , 0xFF79A6F1 , 0xE13EF6F4 , 0xE5FFEB43 , 0xE8BCCD9A , 0xEC7DD02D , 0x34867077 , 0x30476DC0 , 0x3D044B19 , 0x39C556AE , 0x278206AB , 0x23431B1C , 0x2E003DC5 , 0x2AC12072 , 0x128E9DCF , 0x164F8078 , 0x1B0CA6A1 , 0x1FCDBB16 , 0x018AEB13 , 0x054BF6A4 , 0x0808D07D , 0x0CC9CDCA , 0x7897AB07 , 0x7C56B6B0 , 0x71159069 , 0x75D48DDE , 0x6B93DDDB , 0x6F52C06C , 0x6211E6B5 , 0x66D0FB02 , 0x5E9F46BF , 0x5A5E5B08 , 0x571D7DD1 , 0x53DC6066 , 0x4D9B3063 , 0x495A2DD4 , 0x44190B0D , 0x40D816BA , 0xACA5C697 , 0xA864DB20 , 0xA527FDF9 , 0xA1E6E04E , 0xBFA1B04B , 0xBB60ADFC , 0xB6238B25 , 0xB2E29692 , 0x8AAD2B2F , 0x8E6C3698 , 0x832F1041 , 0x87EE0DF6 , 0x99A95DF3 , 0x9D684044 , 0x902B669D , 0x94EA7B2A , 0xE0B41DE7 , 0xE4750050 , 0xE9362689 , 0xEDF73B3E , 0xF3B06B3B , 0xF771768C , 0xFA325055 , 0xFEF34DE2 , 0xC6BCF05F , 0xC27DEDE8 , 0xCF3ECB31 , 0xCBFFD686 , 0xD5B88683 , 0xD1799B34 , 0xDC3ABDED , 0xD8FBA05A , 0x690CE0EE , 0x6DCDFD59 , 0x608EDB80 , 0x644FC637 , 0x7A089632 , 0x7EC98B85 , 0x738AAD5C , 0x774BB0EB , 0x4F040D56 , 0x4BC510E1 , 0x46863638 , 0x42472B8F , 0x5C007B8A , 0x58C1663D , 0x558240E4 , 0x51435D53 , 0x251D3B9E , 0x21DC2629 , 0x2C9F00F0 , 0x285E1D47 , 0x36194D42 , 0x32D850F5 , 0x3F9B762C , 0x3B5A6B9B , 0x0315D626 , 0x07D4CB91 , 0x0A97ED48 , 0x0E56F0FF , 0x1011A0FA , 0x14D0BD4D , 0x19939B94 , 0x1D528623 , 0xF12F560E , 0xF5EE4BB9 , 0xF8AD6D60 , 0xFC6C70D7 , 0xE22B20D2 , 0xE6EA3D65 , 0xEBA91BBC , 0xEF68060B , 0xD727BBB6 , 0xD3E6A601 , 0xDEA580D8 , 0xDA649D6F , 0xC423CD6A , 0xC0E2D0DD , 0xCDA1F604 , 0xC960EBB3 , 0xBD3E8D7E , 0xB9FF90C9 , 0xB4BCB610 , 0xB07DABA7 , 0xAE3AFBA2 , 0xAAFBE615 , 0xA7B8C0CC , 0xA379DD7B , 0x9B3660C6 , 0x9FF77D71 , 0x92B45BA8 , 0x9675461F , 0x8832161A , 0x8CF30BAD , 0x81B02D74 , 0x857130C3 , 0x5D8A9099 , 0x594B8D2E , 0x5408ABF7 , 0x50C9B640 , 0x4E8EE645 , 0x4A4FFBF2 , 0x470CDD2B , 0x43CDC09C , 0x7B827D21 , 0x7F436096 , 0x7200464F , 0x76C15BF8 , 0x68860BFD , 0x6C47164A , 0x61043093 , 0x65C52D24 , 0x119B4BE9 , 0x155A565E , 0x18197087 , 0x1CD86D30 , 0x029F3D35 , 0x065E2082 , 0x0B1D065B , 0x0FDC1BEC , 0x3793A651 , 0x3352BBE6 , 0x3E119D3F , 0x3AD08088 , 0x2497D08D , 0x2056CD3A , 0x2D15EBE3 , 0x29D4F654 , 0xC5A92679 , 0xC1683BCE , 0xCC2B1D17 , 0xC8EA00A0 , 0xD6AD50A5 , 0xD26C4D12 , 0xDF2F6BCB , 0xDBEE767C , 0xE3A1CBC1 , 0xE760D676 , 0xEA23F0AF , 0xEEE2ED18 , 0xF0A5BD1D , 0xF464A0AA , 0xF9278673 , 0xFDE69BC4 , 0x89B8FD09 , 0x8D79E0BE , 0x803AC667 , 0x84FBDBD0 , 0x9ABC8BD5 , 0x9E7D9662 , 0x933EB0BB , 0x97FFAD0C , 0xAFB010B1 , 0xAB710D06 , 0xA6322BDF , 0xA2F33668 , 0xBCB4666D , 0xB8757BDA , 0xB5365D03 , 0xB1F740B4 , }; //输入、输出数据反转使用查表法时的表数据 uint32_t CRC32_TABLE_INV[256] = { 0x00000000 , 0x77073096 , 0xEE0E612C , 0x990951BA , 0x076DC419 , 0x706AF48F , 0xE963A535 , 0x9E6495A3 , 0x0EDB8832 , 0x79DCB8A4 , 0xE0D5E91E , 0x97D2D988 , 0x09B64C2B , 0x7EB17CBD , 0xE7B82D07 , 0x90BF1D91 , 0x1DB71064 , 0x6AB020F2 , 0xF3B97148 , 0x84BE41DE , 0x1ADAD47D , 0x6DDDE4EB , 0xF4D4B551 , 0x83D385C7 , 0x136C9856 , 0x646BA8C0 , 0xFD62F97A , 0x8A65C9EC , 0x14015C4F , 0x63066CD9 , 0xFA0F3D63 , 0x8D080DF5 , 0x3B6E20C8 , 0x4C69105E , 0xD56041E4 , 0xA2677172 , 0x3C03E4D1 , 0x4B04D447 , 0xD20D85FD , 0xA50AB56B , 0x35B5A8FA , 0x42B2986C , 0xDBBBC9D6 , 0xACBCF940 , 0x32D86CE3 , 0x45DF5C75 , 0xDCD60DCF , 0xABD13D59 , 0x26D930AC , 0x51DE003A , 0xC8D75180 , 0xBFD06116 , 0x21B4F4B5 , 0x56B3C423 , 0xCFBA9599 , 0xB8BDA50F , 0x2802B89E , 0x5F058808 , 0xC60CD9B2 , 0xB10BE924 , 0x2F6F7C87 , 0x58684C11 , 0xC1611DAB , 0xB6662D3D , 0x76DC4190 , 0x01DB7106 , 0x98D220BC , 0xEFD5102A , 0x71B18589 , 0x06B6B51F , 0x9FBFE4A5 , 0xE8B8D433 , 0x7807C9A2 , 0x0F00F934 , 0x9609A88E , 0xE10E9818 , 0x7F6A0DBB , 0x086D3D2D , 0x91646C97 , 0xE6635C01 , 0x6B6B51F4 , 0x1C6C6162 , 0x856530D8 , 0xF262004E , 0x6C0695ED , 0x1B01A57B , 0x8208F4C1 , 0xF50FC457 , 0x65B0D9C6 , 0x12B7E950 , 0x8BBEB8EA , 0xFCB9887C , 0x62DD1DDF , 0x15DA2D49 , 0x8CD37CF3 , 0xFBD44C65 , 0x4DB26158 , 0x3AB551CE , 0xA3BC0074 , 0xD4BB30E2 , 0x4ADFA541 , 0x3DD895D7 , 0xA4D1C46D , 0xD3D6F4FB , 0x4369E96A , 0x346ED9FC , 0xAD678846 , 0xDA60B8D0 , 0x44042D73 , 0x33031DE5 , 0xAA0A4C5F , 0xDD0D7CC9 , 0x5005713C , 0x270241AA , 0xBE0B1010 , 0xC90C2086 , 0x5768B525 , 0x206F85B3 , 0xB966D409 , 0xCE61E49F , 0x5EDEF90E , 0x29D9C998 , 0xB0D09822 , 0xC7D7A8B4 , 0x59B33D17 , 0x2EB40D81 , 0xB7BD5C3B , 0xC0BA6CAD , 0xEDB88320 , 0x9ABFB3B6 , 0x03B6E20C , 0x74B1D29A , 0xEAD54739 , 0x9DD277AF , 0x04DB2615 , 0x73DC1683 , 0xE3630B12 , 0x94643B84 , 0x0D6D6A3E , 0x7A6A5AA8 , 0xE40ECF0B , 0x9309FF9D , 0x0A00AE27 , 0x7D079EB1 , 0xF00F9344 , 0x8708A3D2 , 0x1E01F268 , 0x6906C2FE , 0xF762575D , 0x806567CB , 0x196C3671 , 0x6E6B06E7 , 0xFED41B76 , 0x89D32BE0 , 0x10DA7A5A , 0x67DD4ACC , 0xF9B9DF6F , 0x8EBEEFF9 , 0x17B7BE43 , 0x60B08ED5 , 0xD6D6A3E8 , 0xA1D1937E , 0x38D8C2C4 , 0x4FDFF252 , 0xD1BB67F1 , 0xA6BC5767 , 0x3FB506DD , 0x48B2364B , 0xD80D2BDA , 0xAF0A1B4C , 0x36034AF6 , 0x41047A60 , 0xDF60EFC3 , 0xA867DF55 , 0x316E8EEF , 0x4669BE79 , 0xCB61B38C , 0xBC66831A , 0x256FD2A0 , 0x5268E236 , 0xCC0C7795 , 0xBB0B4703 , 0x220216B9 , 0x5505262F , 0xC5BA3BBE , 0xB2BD0B28 , 0x2BB45A92 , 0x5CB36A04 , 0xC2D7FFA7 , 0xB5D0CF31 , 0x2CD99E8B , 0x5BDEAE1D , 0x9B64C2B0 , 0xEC63F226 , 0x756AA39C , 0x026D930A , 0x9C0906A9 , 0xEB0E363F , 0x72076785 , 0x05005713 , 0x95BF4A82 , 0xE2B87A14 , 0x7BB12BAE , 0x0CB61B38 , 0x92D28E9B , 0xE5D5BE0D , 0x7CDCEFB7 , 0x0BDBDF21 , 0x86D3D2D4 , 0xF1D4E242 , 0x68DDB3F8 , 0x1FDA836E , 0x81BE16CD , 0xF6B9265B , 0x6FB077E1 , 0x18B74777 , 0x88085AE6 , 0xFF0F6A70 , 0x66063BCA , 0x11010B5C , 0x8F659EFF , 0xF862AE69 , 0x616BFFD3 , 0x166CCF45 , 0xA00AE278 , 0xD70DD2EE , 0x4E048354 , 0x3903B3C2 , 0xA7672661 , 0xD06016F7 , 0x4969474D , 0x3E6E77DB , 0xAED16A4A , 0xD9D65ADC , 0x40DF0B66 , 0x37D83BF0 , 0xA9BCAE53 , 0xDEBB9EC5 , 0x47B2CF7F , 0x30B5FFE9 , 0xBDBDF21C , 0xCABAC28A , 0x53B39330 , 0x24B4A3A6 , 0xBAD03605 , 0xCDD70693 , 0x54DE5729 , 0x23D967BF , 0xB3667A2E , 0xC4614AB8 , 0x5D681B02 , 0x2A6F2B94 , 0xB40BBE37 , 0xC30C8EA1 , 0x5A05DF1B , 0x2D02EF8D , }; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/12/09/6b21a5f8342ea57306b14dba5cbc3f59.html","headline":"CRC算法 个人学习笔记 直接法、查表法注意点","dateModified":"2017-12-09T00:00:00+08:00","datePublished":"2017-12-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/12/09/6b21a5f8342ea57306b14dba5cbc3f59.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>CRC算法 个人学习笔记 直接法、查表法注意点</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p></p> 
  <p>CRC<span style="font-family:'宋体';">检验码主要是用在数据校验中，用于判断对应数据是否发生传输错误，详细的介绍百度就可以。本文主要是记录我个人在这几天学习使用</span><span style="font-family:Arial;">CRC</span><span style="font-family:'宋体';">的过程中遇到的问题。各位在阅读时如果有发现问题，可在评论区留言，谢谢。</span></p> 
  <p>1<span style="font-family:'宋体';">、</span><span style="font-family:Arial;">CRC</span><span style="font-family:'宋体';">算法会根据选择生成的检验码的长度，需要设置一个生成多项式，一般会使用国际上几个大厂或者行业内的常用的标准多项式，而且这些标准还有其他选项细微的差别， 比如初始值的设置、是从数据的</span><span style="font-family:Arial;">MSB/LSB</span><span style="font-family:'宋体';">开始计算、结果是否需要与其他值异或等，以下是我找到的几个通用算法的配置信息：</span></p> 
  <p><span style="font-family:'宋体';">参考网址</span>1<span style="font-family:'宋体';">：</span><a href="http://www.ip33.com/crc.html" rel="nofollow"><u><span style="color:rgb(0,0,255);">http://www.ip33.com/crc.html</span></u></a></p> 
  <p><span style="font-family:'宋体';">参考网址</span>2<span style="font-family:'宋体';">：</span><a href="http://blog.csdn.net/xlhcgd/article/details/44980005" rel="nofollow"><u><span style="color:rgb(0,0,255);">http://blog.csdn.net/xlhcgd/article/details/44980005</span></u></a></p> 
  <p><span style="font-family:'宋体';">参考网址</span>3<span style="font-family:'宋体';">：</span><span style="font-family:Arial;">https://wenku.baidu.com/view/3c9eadc7cc7931b764ce15b8.html</span></p> 
  <p>&nbsp;</p> 
  <p><strong><span style="color:rgb(85,85,85);">2、</span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">算法原理</span></span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">（</span></span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">参考网址</span>4：http://blog.csdn.net/huang_shiyang/article/details/50881305）</span></strong></p> 
  <p><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">假设数据传输过程中需要发送</span>15位的二进制信息g=101001110100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，既将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。</span></p> 
  <p><span style="color:rgb(85,85,85);">h(x)可以自由选择或者使用国际通行标准，一般按照h(x)的阶数m，将CRC算法称为CRC-m，比如CRC-32、CRC-64等。国际通行标准可以参看</span><a href="http://en.wikipedia.org/wiki/Cyclic_redundancy_check" rel="nofollow"><span style="color:rgb(12,137,207);">http://en.wikipedia.org/wiki/Cyclic_redundancy_check</span></a></p> 
  <p><span style="color:rgb(85,85,85);">g(x)和h(x)的除运算，可以通过g和h做xor（异或）运算。比如将11001与10101做xor运算：</span></p> 
  <p><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://images.cnblogs.com/cnblogs_com/esestt/CRC/crc001.gif" alt=""></span></p> 
  <p><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">明白了</span>xor运算法则后，举一个例子使用CRC-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 +1，既h是9位的二进制串111010101。&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
  <p><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">经过迭代运算后，最终得到的</span>r是10001100，这就是CRC效验码。</span></p> 
  <p><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);"><img src="http://images.cnblogs.com/cnblogs_com/esestt/CRC/crc002.gif" alt=""><br></span><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
  <p><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">通过示例，可以发现一些规律，依据这些规律调整算法：</span>&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">1.&nbsp;</span><u><span style="color:rgb(255,0,0);"><span style="font-family:'微软雅黑';">每次迭代，根据</span>gk</span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">的首位决定</span>b，b是与gk进行运算的二进制码。若gk的首位是1，则b=h；若gk的首位是0，则b=0，或者跳过此次迭代，上面的例子中就是碰到0后直接跳到后面的非零位。</span></u></p> 
  <p><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
  <p>&nbsp;<img src="http://images.cnblogs.com/cnblogs_com/esestt/CRC/crc003.gif" alt=""></p> 
  <p><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">2.&nbsp;</span><u><span style="color:rgb(255,0,0);"><span style="font-family:'微软雅黑';">每次迭代，</span>gk</span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">的首位将会被移出，所以只需考虑第</span>2位后计算即可。这样就可以舍弃h的首位，将b取h的后m位。比如CRC-8的h是111010101，b只需是11010101。</span></u><span style="color:rgb(85,85,85);">&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://images.cnblogs.com/cnblogs_com/esestt/CRC/crc004.gif" alt=""></span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">3.&nbsp;</span><u><span style="color:rgb(255,0,0);"><span style="font-family:'微软雅黑';">每次迭代，受到影响的是</span>gk</span><span style="color:rgb(85,85,85);"><span style="font-family:'微软雅黑';">的前</span>m位，所以构建一个m位的寄存器S，此寄存器储存gk的前m位。每次迭代计算前先将S的首位抛弃，将寄存器左移一位，同时将g的后一位加入寄存器。若使用此种方法，计算步骤如下：</span></u><span style="color:rgb(85,85,85);">&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(85,85,85);"><br></span><span style="color:rgb(85,85,85);"><img src="http://images.cnblogs.com/cnblogs_com/esestt/CRC/crc005.gif" alt=""><br></span><span style="color:rgb(85,85,85);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
  <p><span style="color:rgb(85,85,85);">※蓝色表示寄存器S的首位，是需要移出的，b根据S的首位选择0或者h。黄色是需要移入寄存器的位。S'是经过位移后的S。</span></p> 
  <p>&nbsp;</p> 
  <p>3<span style="font-family:'宋体';">、举个例子，计算单字节</span><span style="font-family:Calibri;">0x81</span><span style="font-family:'宋体';">的</span><span style="font-family:Calibri;">CRC8</span><span style="font-family:'宋体';">的值（生成多项式：</span><span style="font-family:Calibri;">0x07</span><span style="font-family:'宋体';">，初始值</span><span style="font-family:Calibri;">00</span><span style="font-family:'宋体';">，输入输出不反转）</span></p> 
  <p>1)&nbsp;<span style="font-family:'宋体';">将经</span>0x81<span style="font-family:'宋体';">与初始值</span><span style="font-family:Calibri;">0x00</span><span style="font-family:'宋体';">进行异或</span><br> CRC8 = 0x81 XOR 0x00 = 0x81;</p> 
  <p>2)&nbsp;从判断数据的最高位，选择对应的计算方法<br> 1<span style="font-family:'宋体';">：数据左移一位，然后与多项式</span><span style="font-family:Calibri;">0x07</span><span style="font-family:'宋体';">进行异或，</span><span style="font-family:Calibri;">CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07</span><br> 0<span style="font-family:'宋体';">：数据左移一位，然后不动作，</span><span style="font-family:Calibri;">CRC8 =</span><span style="font-family:'宋体';">（</span><span style="font-family:Calibri;">CRC8 &lt;&lt; 1)</span></p> 
  <p>3)&nbsp;8<span style="font-family:'宋体';">位数据是否都移动完：</span><br><span style="font-family:'宋体';">未移动完：返回第</span>2<span style="font-family:'宋体';">步继续计算</span><br><span style="font-family:'宋体';">移动完</span> &nbsp;<span style="font-family:'宋体';">：最后的结果则为最终的</span>8<span style="font-family:'宋体';">位校验值</span></p> 
  <p>4)&nbsp;<span style="font-family:'宋体';">对应的</span>C<span style="font-family:'宋体';">代码</span><br> uint8_t Get_CRC8( uint8_t dat , uint8_t init_value)<br> {<br> uint8_t CRC8 = dat ^ init_value;<br> for(uint8_t i = 0 ; i &lt; 8 ; i++)<br> {<br> if(CRC8 &amp; 0x80)<br> CRC8 = (CRC8 &lt;&lt; 1) ^ 0x07;<br> else<br> CRC8 &lt;&lt;= 1;<br> }<br> return CRC8;<br> }</p> 
  <p>5)&nbsp;<span style="font-family:'宋体';">以上是</span>8<span style="font-family:'宋体';">位检验值的直接计算方法，</span><span style="font-family:Calibri;">16</span><span style="font-family:'宋体';">位</span><span style="font-family:Calibri;">/32</span><span style="font-family:'宋体';">位也是同样的。</span></p> 
  <p>&nbsp;</p> 
  <p>4<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">CRC16</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">CRC32</span><span style="font-family:'宋体';">等多字节的校验值的计算有几点需要清楚（只针对一次一个字节的算法）：</span></p> 
  <p>1)&nbsp;<span style="font-family:'宋体';">初始值不为</span>0<span style="font-family:'宋体';">的情况下，该如何计算：</span><br> 输入数据需要反转：先将要计算的数据与初始值的最低字节进行异或，再与反转后的多项式进行计算。<br><span style="font-family:'宋体';">输入数据不需要反转：先将要计算的数据左移到与初始值对齐的位置（如</span>CRC16<span style="font-family:'宋体';">算法，则左移</span><span style="font-family:Calibri;">8</span><span style="font-family:'宋体';">位，低位填充</span><span style="font-family:Calibri;">0</span><span style="font-family:'宋体';">；如</span><span style="font-family:Calibri;">CRC32</span><span style="font-family:'宋体';">算法，则左移</span><span style="font-family:Calibri;">24</span><span style="font-family:'宋体';">位，低位填充</span><span style="font-family:Calibri;">0</span><span style="font-family:'宋体';">）与初始值进行异或，再与正常的多项式进行计算。</span></p> 
  <p>2)&nbsp;<span style="font-family:'宋体';">结果异或值不为</span>0<span style="font-family:'宋体';">的情况：第一步算得到的</span><span style="font-family:Calibri;">CRC</span><span style="font-family:'宋体';">值再与结果异或值进行异或操作得到最终的校验值：</span><br> 输出数据反转：如果输入数据是反转的模式，则结果也是反转的<br> 输出数据不反转：如果输入数据是不反转的模式，则结果也是不反转的</p> 
  <p>3）初始值的选择是可自己定义，很多不同的厂家使用的初始值是不一样，不一样的初始值得到的结果也是不一样的，要起到定制的效果，像上面提到的国际、行业使用的标准算法，初始值是固定的。</p> 
  <p>&nbsp;</p> 
  <p>5<span style="font-family:'宋体';">、使用查表法进行多字节数据检验值计算时的算法原理（可参考参考网址</span><span style="font-family:Calibri;">4</span><span style="font-family:'宋体';">中的推导部分）：</span></p> 
  <p>1)&nbsp;CRC8<span style="font-family:'宋体';">的查表法：要计算的单字节数据与初始值进行异或得到单字节数据，以此结果为表的序号从表中取得的值即为该字节的校验值；如果是多字节，则以前一字节的检验值作为初始值进行同样的操作，算法如下：</span><br> //<span style="font-family:'宋体';">结果不异或其他值</span><br> uint8_t Get_CRC8_With_Table(uint8_t *datptr , uint8_t len , uint8_t init_value)</p> 
  <p>{</p> 
  <p>uint8_t CRC8 = init_value;</p> 
  <p>while(len--)</p> 
  <p>{</p> 
  <p>CRC8 = CRC8_TABLE[(*datptr++) ^ CRC8];</p> 
  <p>}</p> 
  <p>return CRC8;</p> 
  <p>}</p> 
  <p>2)&nbsp;CRC16<span style="font-family:'宋体';">的查表法：要计算的单字节数据与初始值的高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移</span><span style="font-family:Calibri;">8</span><span style="font-family:'宋体';">位后的值进行异或得到最终的检验值：</span><br> //输入、输出不反转，<span style="font-family:'宋体';">结果不异或其他值</span><br> uint16_t Get_CRC16_With_Table(uint8_t *datptr , uint8_t len , uint16_t init_value)</p> 
  <p>{</p> 
  <p><span></span>uint16_t CRC16 = init_value;</p> 
  <p><span></span>while(len--)</p> 
  <p><span></span>{</p> 
  <p><span></span>CRC16 = CRC16_TABLE[(*datptr++) ^ ((CRC16 &gt;&gt; 8) &amp; 0xFF)] ^ ((CRC16 &lt;&lt; 8) &amp; 0xFF00);</p> 
  <p><span></span>}</p> 
  <p><span></span>return CRC16;</p> 
  <p>}</p> 
  <p>3)&nbsp;CRC32<span style="font-family:'宋体';">的查表法：要计算的单字节数据与初始值的最高字节异或，然后以此单字节数据作为表的序号从表中取得的值再与初始值的低字节左移</span><span style="font-family:Calibri;">8</span><span style="font-family:'宋体';">位后的值进行异或得到最终的检验值：</span><br></p> //输入、输出不反转的查表算法，结果不异或任何值&nbsp;
  <br> uint32_t Get_CRC32_With_Table(uint8_t *datptr , uint8_t len , uint32_t init_value)
  <br> {
  <br>
  <span></span>uint32_t CRC32 = init_value;
  <br>
  <span></span>while(len--)
  <br>
  <span></span>{
  <br>
  <span></span>CRC32 = CRC32_TABLE[(*datptr++) ^ ((CRC32 &gt;&gt; 24) &amp; 0xFF)] ^ ((CRC32 &lt;&lt; 8) &amp; 0xFFFFFF00);
  <br>
  <span></span>}
  <br>
  <span></span>return CRC32;
  <br> } 
  <p></p> 
  <p>//反转输入、输出的查表算法，结果异或0xFFFFFFFF&nbsp;<br> uint32_t Get_CRC32_With_Table_Inv(uint8_t *datptr , uint8_t len , uint32_t init_value)<br> {<br><span></span>uint32_t CRC32 = init_value;<br><span></span><br><span></span>while(len--)<br><span></span>{<br><span></span>CRC32 = CRC32_TABLE_INV[((*datptr++) ^ CRC32) &amp; 0xFF] ^ ((CRC32 &gt;&gt; 8) &amp; 0x00FFFFFF);<br><span></span>}<br><span></span>return CRC32 ^ 0xFFFFFFFF;<br> }<br><br><br> //生成输入、输出不反转的表&nbsp;<br> void CRC32_Table_Init(void)<br> {<br><span></span>uint32_t i , j;<br><span></span>uint32_t CRC = 0;<br><span></span>for(i = 0 ; i &lt; 256 ; i++)<br><span></span>{<br><span></span>CRC = (i &lt;&lt; 24);<br><span></span>for(j = 0 ; j &lt; 8 ; j++)<br><span></span>{<br><span></span>if(CRC &amp; 0x80000000)<br><span></span>{<br><span></span>CRC = (CRC &lt;&lt; 1) ^ 0x04C11DB7;<br><span></span>}<br><span></span>else<br><span></span>{<br><span></span>CRC &lt;&lt;= 1;<br><span></span>}<br><span></span>}<br><span></span><br><span></span>CRC32_TABLE[i] = CRC;<br><span></span>}<br> }<br><br><br> //生成输入、输出反转的表&nbsp;<br> void CRC32_Table_Init_Inv(void)<br> {<br><span></span>uint32_t i , j;<br><span></span>uint32_t CRC = 0;<br><span></span>for(i = 0 ; i &lt; 256 ; i++)<br><span></span>{<br><span></span>CRC = i;<br><span></span>for(j = 0 ; j &lt; 8 ; j++)<br><span></span>{<br><span></span>if(CRC &amp; 0x00000001)<br><span></span>{<br><span></span>CRC = (CRC &gt;&gt; 1) ^ 0xEDB88320;<br><span></span>}<br><span></span>else<br><span></span>{<br><span></span>CRC &gt;&gt;= 1;<br><span></span>}<br><span></span>}<br><span></span><br><span></span>CRC32_TABLE_INV[i] = CRC;<br><span></span>}<br> }&nbsp;</p> 
  <p>6<span style="font-family:'宋体';">、使用查表法需要注意的问题：</span></p> 
  <p>1)&nbsp;<span style="font-family:'宋体';">关于表的生成，是以</span>0~255<span style="font-family:'宋体';">这</span><span style="font-family:Calibri;">256</span><span style="font-family:'宋体';">个数分别计算得到的</span><span style="font-family:Calibri;">CRC</span><span style="font-family:'宋体';">检验值，需要注意的是，此表的生成需要配合所使用的</span><span style="font-family:Calibri;">CRC</span><span style="font-family:'宋体';">算法的配置，如输入数据是否要反转，输入数据反转和不反转对应的表是不一样的。还有很重要的一点，表的生成是以</span><span style="color:rgb(255,0,0);"><span style="font-family:'宋体';">初始值为</span>0<span style="font-family:'宋体';">时</span></span>生成的检验值，否则会出错，以下我是生成的表数据：</p> 
  <p>//输入、输出数据不反转使用查表法时的表数据<br></p> 
  <p>uint32_t CRC32_TABLE[256] = {<br> 0x00000000 , 0x04C11DB7 , 0x09823B6E , 0x0D4326D9 , 0x130476DC , 0x17C56B6B , 0x1A864DB2 , 0x1E475005 ,<br> 0x2608EDB8 , 0x22C9F00F , 0x2F8AD6D6 , 0x2B4BCB61 , 0x350C9B64 , 0x31CD86D3 , 0x3C8EA00A , 0x384FBDBD ,<br> 0x4C11DB70 , 0x48D0C6C7 , 0x4593E01E , 0x4152FDA9 , 0x5F15ADAC , 0x5BD4B01B , 0x569796C2 , 0x52568B75 ,<br> 0x6A1936C8 , 0x6ED82B7F , 0x639B0DA6 , 0x675A1011 , 0x791D4014 , 0x7DDC5DA3 , 0x709F7B7A , 0x745E66CD ,<br> 0x9823B6E0 , 0x9CE2AB57 , 0x91A18D8E , 0x95609039 , 0x8B27C03C , 0x8FE6DD8B , 0x82A5FB52 , 0x8664E6E5 ,<br> 0xBE2B5B58 , 0xBAEA46EF , 0xB7A96036 , 0xB3687D81 , 0xAD2F2D84 , 0xA9EE3033 , 0xA4AD16EA , 0xA06C0B5D ,<br> 0xD4326D90 , 0xD0F37027 , 0xDDB056FE , 0xD9714B49 , 0xC7361B4C , 0xC3F706FB , 0xCEB42022 , 0xCA753D95 ,<br> 0xF23A8028 , 0xF6FB9D9F , 0xFBB8BB46 , 0xFF79A6F1 , 0xE13EF6F4 , 0xE5FFEB43 , 0xE8BCCD9A , 0xEC7DD02D ,<br> 0x34867077 , 0x30476DC0 , 0x3D044B19 , 0x39C556AE , 0x278206AB , 0x23431B1C , 0x2E003DC5 , 0x2AC12072 ,<br> 0x128E9DCF , 0x164F8078 , 0x1B0CA6A1 , 0x1FCDBB16 , 0x018AEB13 , 0x054BF6A4 , 0x0808D07D , 0x0CC9CDCA ,<br> 0x7897AB07 , 0x7C56B6B0 , 0x71159069 , 0x75D48DDE , 0x6B93DDDB , 0x6F52C06C , 0x6211E6B5 , 0x66D0FB02 ,<br> 0x5E9F46BF , 0x5A5E5B08 , 0x571D7DD1 , 0x53DC6066 , 0x4D9B3063 , 0x495A2DD4 , 0x44190B0D , 0x40D816BA ,<br> 0xACA5C697 , 0xA864DB20 , 0xA527FDF9 , 0xA1E6E04E , 0xBFA1B04B , 0xBB60ADFC , 0xB6238B25 , 0xB2E29692 ,<br> 0x8AAD2B2F , 0x8E6C3698 , 0x832F1041 , 0x87EE0DF6 , 0x99A95DF3 , 0x9D684044 , 0x902B669D , 0x94EA7B2A ,<br> 0xE0B41DE7 , 0xE4750050 , 0xE9362689 , 0xEDF73B3E , 0xF3B06B3B , 0xF771768C , 0xFA325055 , 0xFEF34DE2 ,<br> 0xC6BCF05F , 0xC27DEDE8 , 0xCF3ECB31 , 0xCBFFD686 , 0xD5B88683 , 0xD1799B34 , 0xDC3ABDED , 0xD8FBA05A ,<br> 0x690CE0EE , 0x6DCDFD59 , 0x608EDB80 , 0x644FC637 , 0x7A089632 , 0x7EC98B85 , 0x738AAD5C , 0x774BB0EB ,<br> 0x4F040D56 , 0x4BC510E1 , 0x46863638 , 0x42472B8F , 0x5C007B8A , 0x58C1663D , 0x558240E4 , 0x51435D53 ,<br> 0x251D3B9E , 0x21DC2629 , 0x2C9F00F0 , 0x285E1D47 , 0x36194D42 , 0x32D850F5 , 0x3F9B762C , 0x3B5A6B9B ,<br> 0x0315D626 , 0x07D4CB91 , 0x0A97ED48 , 0x0E56F0FF , 0x1011A0FA , 0x14D0BD4D , 0x19939B94 , 0x1D528623 ,<br> 0xF12F560E , 0xF5EE4BB9 , 0xF8AD6D60 , 0xFC6C70D7 , 0xE22B20D2 , 0xE6EA3D65 , 0xEBA91BBC , 0xEF68060B ,<br> 0xD727BBB6 , 0xD3E6A601 , 0xDEA580D8 , 0xDA649D6F , 0xC423CD6A , 0xC0E2D0DD , 0xCDA1F604 , 0xC960EBB3 ,<br> 0xBD3E8D7E , 0xB9FF90C9 , 0xB4BCB610 , 0xB07DABA7 , 0xAE3AFBA2 , 0xAAFBE615 , 0xA7B8C0CC , 0xA379DD7B ,<br> 0x9B3660C6 , 0x9FF77D71 , 0x92B45BA8 , 0x9675461F , 0x8832161A , 0x8CF30BAD , 0x81B02D74 , 0x857130C3 ,<br> 0x5D8A9099 , 0x594B8D2E , 0x5408ABF7 , 0x50C9B640 , 0x4E8EE645 , 0x4A4FFBF2 , 0x470CDD2B , 0x43CDC09C ,<br> 0x7B827D21 , 0x7F436096 , 0x7200464F , 0x76C15BF8 , 0x68860BFD , 0x6C47164A , 0x61043093 , 0x65C52D24 ,<br> 0x119B4BE9 , 0x155A565E , 0x18197087 , 0x1CD86D30 , 0x029F3D35 , 0x065E2082 , 0x0B1D065B , 0x0FDC1BEC ,<br> 0x3793A651 , 0x3352BBE6 , 0x3E119D3F , 0x3AD08088 , 0x2497D08D , 0x2056CD3A , 0x2D15EBE3 , 0x29D4F654 ,<br> 0xC5A92679 , 0xC1683BCE , 0xCC2B1D17 , 0xC8EA00A0 , 0xD6AD50A5 , 0xD26C4D12 , 0xDF2F6BCB , 0xDBEE767C ,<br> 0xE3A1CBC1 , 0xE760D676 , 0xEA23F0AF , 0xEEE2ED18 , 0xF0A5BD1D , 0xF464A0AA , 0xF9278673 , 0xFDE69BC4 ,<br> 0x89B8FD09 , 0x8D79E0BE , 0x803AC667 , 0x84FBDBD0 , 0x9ABC8BD5 , 0x9E7D9662 , 0x933EB0BB , 0x97FFAD0C ,<br> 0xAFB010B1 , 0xAB710D06 , 0xA6322BDF , 0xA2F33668 , 0xBCB4666D , 0xB8757BDA , 0xB5365D03 , 0xB1F740B4 ,<br> };<br><br><br> //输入、输出数据反转使用查表法时的表数据<br> uint32_t CRC32_TABLE_INV[256] = {<br> 0x00000000 , 0x77073096 , 0xEE0E612C , 0x990951BA , 0x076DC419 , 0x706AF48F , 0xE963A535 , 0x9E6495A3 ,<br> 0x0EDB8832 , 0x79DCB8A4 , 0xE0D5E91E , 0x97D2D988 , 0x09B64C2B , 0x7EB17CBD , 0xE7B82D07 , 0x90BF1D91 ,<br> 0x1DB71064 , 0x6AB020F2 , 0xF3B97148 , 0x84BE41DE , 0x1ADAD47D , 0x6DDDE4EB , 0xF4D4B551 , 0x83D385C7 ,<br> 0x136C9856 , 0x646BA8C0 , 0xFD62F97A , 0x8A65C9EC , 0x14015C4F , 0x63066CD9 , 0xFA0F3D63 , 0x8D080DF5 ,<br> 0x3B6E20C8 , 0x4C69105E , 0xD56041E4 , 0xA2677172 , 0x3C03E4D1 , 0x4B04D447 , 0xD20D85FD , 0xA50AB56B ,<br> 0x35B5A8FA , 0x42B2986C , 0xDBBBC9D6 , 0xACBCF940 , 0x32D86CE3 , 0x45DF5C75 , 0xDCD60DCF , 0xABD13D59 ,<br> 0x26D930AC , 0x51DE003A , 0xC8D75180 , 0xBFD06116 , 0x21B4F4B5 , 0x56B3C423 , 0xCFBA9599 , 0xB8BDA50F ,<br> 0x2802B89E , 0x5F058808 , 0xC60CD9B2 , 0xB10BE924 , 0x2F6F7C87 , 0x58684C11 , 0xC1611DAB , 0xB6662D3D ,<br> 0x76DC4190 , 0x01DB7106 , 0x98D220BC , 0xEFD5102A , 0x71B18589 , 0x06B6B51F , 0x9FBFE4A5 , 0xE8B8D433 ,<br> 0x7807C9A2 , 0x0F00F934 , 0x9609A88E , 0xE10E9818 , 0x7F6A0DBB , 0x086D3D2D , 0x91646C97 , 0xE6635C01 ,<br> 0x6B6B51F4 , 0x1C6C6162 , 0x856530D8 , 0xF262004E , 0x6C0695ED , 0x1B01A57B , 0x8208F4C1 , 0xF50FC457 ,<br> 0x65B0D9C6 , 0x12B7E950 , 0x8BBEB8EA , 0xFCB9887C , 0x62DD1DDF , 0x15DA2D49 , 0x8CD37CF3 , 0xFBD44C65 ,<br> 0x4DB26158 , 0x3AB551CE , 0xA3BC0074 , 0xD4BB30E2 , 0x4ADFA541 , 0x3DD895D7 , 0xA4D1C46D , 0xD3D6F4FB ,<br> 0x4369E96A , 0x346ED9FC , 0xAD678846 , 0xDA60B8D0 , 0x44042D73 , 0x33031DE5 , 0xAA0A4C5F , 0xDD0D7CC9 ,<br> 0x5005713C , 0x270241AA , 0xBE0B1010 , 0xC90C2086 , 0x5768B525 , 0x206F85B3 , 0xB966D409 , 0xCE61E49F ,<br> 0x5EDEF90E , 0x29D9C998 , 0xB0D09822 , 0xC7D7A8B4 , 0x59B33D17 , 0x2EB40D81 , 0xB7BD5C3B , 0xC0BA6CAD ,<br> 0xEDB88320 , 0x9ABFB3B6 , 0x03B6E20C , 0x74B1D29A , 0xEAD54739 , 0x9DD277AF , 0x04DB2615 , 0x73DC1683 ,<br> 0xE3630B12 , 0x94643B84 , 0x0D6D6A3E , 0x7A6A5AA8 , 0xE40ECF0B , 0x9309FF9D , 0x0A00AE27 , 0x7D079EB1 ,<br> 0xF00F9344 , 0x8708A3D2 , 0x1E01F268 , 0x6906C2FE , 0xF762575D , 0x806567CB , 0x196C3671 , 0x6E6B06E7 ,<br> 0xFED41B76 , 0x89D32BE0 , 0x10DA7A5A , 0x67DD4ACC , 0xF9B9DF6F , 0x8EBEEFF9 , 0x17B7BE43 , 0x60B08ED5 ,<br> 0xD6D6A3E8 , 0xA1D1937E , 0x38D8C2C4 , 0x4FDFF252 , 0xD1BB67F1 , 0xA6BC5767 , 0x3FB506DD , 0x48B2364B ,<br> 0xD80D2BDA , 0xAF0A1B4C , 0x36034AF6 , 0x41047A60 , 0xDF60EFC3 , 0xA867DF55 , 0x316E8EEF , 0x4669BE79 ,<br> 0xCB61B38C , 0xBC66831A , 0x256FD2A0 , 0x5268E236 , 0xCC0C7795 , 0xBB0B4703 , 0x220216B9 , 0x5505262F ,<br> 0xC5BA3BBE , 0xB2BD0B28 , 0x2BB45A92 , 0x5CB36A04 , 0xC2D7FFA7 , 0xB5D0CF31 , 0x2CD99E8B , 0x5BDEAE1D ,<br> 0x9B64C2B0 , 0xEC63F226 , 0x756AA39C , 0x026D930A , 0x9C0906A9 , 0xEB0E363F , 0x72076785 , 0x05005713 ,<br> 0x95BF4A82 , 0xE2B87A14 , 0x7BB12BAE , 0x0CB61B38 , 0x92D28E9B , 0xE5D5BE0D , 0x7CDCEFB7 , 0x0BDBDF21 ,<br> 0x86D3D2D4 , 0xF1D4E242 , 0x68DDB3F8 , 0x1FDA836E , 0x81BE16CD , 0xF6B9265B , 0x6FB077E1 , 0x18B74777 ,<br> 0x88085AE6 , 0xFF0F6A70 , 0x66063BCA , 0x11010B5C , 0x8F659EFF , 0xF862AE69 , 0x616BFFD3 , 0x166CCF45 ,<br> 0xA00AE278 , 0xD70DD2EE , 0x4E048354 , 0x3903B3C2 , 0xA7672661 , 0xD06016F7 , 0x4969474D , 0x3E6E77DB ,<br> 0xAED16A4A , 0xD9D65ADC , 0x40DF0B66 , 0x37D83BF0 , 0xA9BCAE53 , 0xDEBB9EC5 , 0x47B2CF7F , 0x30B5FFE9 ,<br> 0xBDBDF21C , 0xCABAC28A , 0x53B39330 , 0x24B4A3A6 , 0xBAD03605 , 0xCDD70693 , 0x54DE5729 , 0x23D967BF ,<br> 0xB3667A2E , 0xC4614AB8 , 0x5D681B02 , 0x2A6F2B94 , 0xB40BBE37 , 0xC30C8EA1 , 0x5A05DF1B , 0x2D02EF8D ,<br> };<br></p> 
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bobde163/article/details/78760213,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bobde163/article/details/78760213,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
