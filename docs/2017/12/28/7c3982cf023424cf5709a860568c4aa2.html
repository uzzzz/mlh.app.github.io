<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>fabric多节点集群部署（4+1）详解 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="fabric多节点集群部署（4+1）详解" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="fabric多节点集群部署（4+1）详解 本文也是在参考前人的资料下开始进行搭建并成功的，部署这个之前需要已经了解并成功部署过单节点。 前期工作：下载fabric代码，下载go，docker，docker-compose，并实现了单节点部署。 本文主要任务是在5台linux系统的电脑或虚拟机中完成fabric的集群部署。 机器相关配置： 名称 节点名字 组织 ip地址 Computer1 orderer.example.com Orderer 192.168.44.129 Computer2 peer0.org1.example.com Org1 192.168.44.132 Computer3 peer1.org1.example.com Org1 192.168.44.133 Computer4 peer0.org2.example.com Org2 192.168.44.134 Computer5 peer1.org2.example.com Org2 192.168.44.135 一 生成公私钥，证书等信息 生成相关信息我们只需要在一台机器上生成，然后通过ssh复制到其他机器相应的位置就行 方法一：直接通过系统脚本一键生成 注：我的fabric代码存放地址:home/ckt/go_code/src/github.com/hyperledger/fabric 进入项目： cd go_code/src/github.com/hyperledger/fabric/examples/e2e_cli/ 生成公私钥，证书，创世区块等信息： ./generateArtifacts.sh mychannel 方法二：手动一步步的生成 其实手动的步骤只是把generateArtifacts.sh这个脚本中的步骤拆分来，不过这样能对整个业务逻辑更熟悉 1.1 编译生成cryptogen make -C ../.. release 1.2 配置crypto-config.yaml 这个暂时不用配置，默认就行。 1.3 生成证书 ../../release/linux-amd64/bin/cryptogen generate --config=./crypto-config.yaml 代码执行后会在当前目录生成crypto-config目录，里面含有crypto-config.yaml刚刚配置好的组织及成员证书 二 生成创世区块和Channel配置区块 方法一：直接通过系统脚本一键生成 在一中采用脚本自动生成公私钥和证书时，已经把创世区块和channel配置一并生成完毕了，不需要在额外生成。 方法二：手动一步步的生成 2.1 编译生成configtxgen make -C ../.. release 2.2 配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3 生成创世区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后会生成genesis.block区块并保存到本地channel-artifacts文件夹中 2.4 生成Channel配置区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 2.5 更新锚节点 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 三 配置相关的docker-compose文件 3.1 配置docker-compose-orderer 先把docker-compose-cli.yaml复制一份并命名docker-compose-orderer.yaml cp ./docker-compose-cli.yaml ./docker-compose-orderer.yaml 然后打开并编辑docker-compose-orderer.yaml，去掉peer和cli的代码部分，只留下orderer相关代码 生成后大概如下 # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.2 配置docker-compose-peer 先把docker-compose-cli.yaml复制一份并命名docker-compose-peer.yaml cp ./docker-compose-cli.yaml ./docker-compose-peer.yaml 然后打开并编辑docker-compose-peer.yaml，去掉orderer的代码部分，去掉其他多余peer部分（编辑peer0.org1时，删掉其他三个peer代码部分），只留下一个peer和cli相关代码。 接下来再进行部分代码修改（以peer0.org1为例）： peer节点部分添加extra_hosts，添加后代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; cli中将command那一行代码前加#注释掉，或者删除该行代码 删除多余depend_on，添加extra_hosts，最后cli中部分代码如下： depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; - &quot;peer1.org1.example.com:192.168.44.133&quot; - &quot;peer0.org2.example.com:192.168.44.134&quot; - &quot;peer1.org2.example.com:192.168.44.135&quot; 以上就将peer节点配置成功了，但是有一个小细节，在peer1.org1主机中配置时，还需要在extra_hosts中加入peer0.org1的信息（同理在配置peer1.org2时需要加入peer0.org2的信息），具体代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; 3.2 配置base/docker-compose-base.yaml 将base/docker-compose-base.yaml中所有peer的端口映射都改为相同的： ports: - 7051:7051 - 7052:7052 - 7053:7053 四 启动fabric环境 4.1 启动peer和orderer 在peer节点主机上输入如下命令启动peer和orderer： docker-compose -f docker-compose-peer.yaml up -d 在orderer节点主机上输入： docker-compose -f docker-compose-orderer.yaml up -d 4.2 查看启动情况： docker ps -a 可以看到peer节点下有peer和cli容器，orderer中有orderer，则表示成功。 4.3 进入cli 这里我们以在peer0.org1中示范进入 docker exec -it cli bash 当显示：root@81aebc129d03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 的时候表示成功进入cli。 快速启动 接下来步骤可以直接通过快速启动来操作，也可以一步步的来添加，快速启动代码： ./script/script.sh mychannel 4.4 创建Channel ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 创建完成后ls可以看到原来的目录下多了一个mychannel.block文件 4.5 各个Peer加入Channel CLI默认连接的是peer0.org1，那么我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 其他几个Peer又该怎么加入Channel呢？这里就需要修改CLI的环境变量，使其指向另外的Peer。比如我们要把peer1.org1加入mychannel，那么命令是： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 peer channel join -b mychannel.block 系统会返回成功加入Channel的消息。 同样的方法，将peer0.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 最后把peer1.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 peer channel join -b mychannel.block 4.6 更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 整个Fabric网络和Channel都准备完毕。 五 链上代码的安装与运行 安装和运行ChainCode，以系统给的Example02为例。该例子定义了a，b两个账户，两者相互之间可以转账。 5.1 Install ChainCode–安装链上代码 仍然是保持在CLI的命令行下，我们先切换到peer0.org1这个节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 使用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 其他节点由于暂时还没使用到，我们可以先不安装，等到了步骤5.4的时候再安装。 5.2 Instantiate ChainCode–实例化链上代码 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 如果我们新开一个Ubuntu终端，去查看peer0.org1上的日志，那么就可以知道整个实例化的过程到底干了什么： docker logs -f peer0.org1.example.com 使用docker ps可以看到有新的容器正在运行： 5.3 在一个Peer上查询并发起交易 现在链上代码的实例也有了，并且在实例化的时候指定了a账户100，b账户200，我们可以试着调用ChainCode的查询代码，验证一下，在cli容器内执行： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果：Query Result: 100 接下来我们可以试着把a账户的10元转给b。对应的代码： ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再查询一下a的账户，发现a的账户余额变成了90 5.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？我们试着给peer0.org2安装链上代码： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 这个时候我们发现运行该命令后要等很久（我这里花了40秒）才返回结果： Query Result: 90 这是因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果。我们到peer0.org2机器的Ubuntu终端，执行docker ps，可以看到原本的容器中又多了一个容器 以上就是多节点集群部署的全部过程，如有错误，欢迎提出改正。 阅读更多" />
<meta property="og:description" content="fabric多节点集群部署（4+1）详解 本文也是在参考前人的资料下开始进行搭建并成功的，部署这个之前需要已经了解并成功部署过单节点。 前期工作：下载fabric代码，下载go，docker，docker-compose，并实现了单节点部署。 本文主要任务是在5台linux系统的电脑或虚拟机中完成fabric的集群部署。 机器相关配置： 名称 节点名字 组织 ip地址 Computer1 orderer.example.com Orderer 192.168.44.129 Computer2 peer0.org1.example.com Org1 192.168.44.132 Computer3 peer1.org1.example.com Org1 192.168.44.133 Computer4 peer0.org2.example.com Org2 192.168.44.134 Computer5 peer1.org2.example.com Org2 192.168.44.135 一 生成公私钥，证书等信息 生成相关信息我们只需要在一台机器上生成，然后通过ssh复制到其他机器相应的位置就行 方法一：直接通过系统脚本一键生成 注：我的fabric代码存放地址:home/ckt/go_code/src/github.com/hyperledger/fabric 进入项目： cd go_code/src/github.com/hyperledger/fabric/examples/e2e_cli/ 生成公私钥，证书，创世区块等信息： ./generateArtifacts.sh mychannel 方法二：手动一步步的生成 其实手动的步骤只是把generateArtifacts.sh这个脚本中的步骤拆分来，不过这样能对整个业务逻辑更熟悉 1.1 编译生成cryptogen make -C ../.. release 1.2 配置crypto-config.yaml 这个暂时不用配置，默认就行。 1.3 生成证书 ../../release/linux-amd64/bin/cryptogen generate --config=./crypto-config.yaml 代码执行后会在当前目录生成crypto-config目录，里面含有crypto-config.yaml刚刚配置好的组织及成员证书 二 生成创世区块和Channel配置区块 方法一：直接通过系统脚本一键生成 在一中采用脚本自动生成公私钥和证书时，已经把创世区块和channel配置一并生成完毕了，不需要在额外生成。 方法二：手动一步步的生成 2.1 编译生成configtxgen make -C ../.. release 2.2 配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3 生成创世区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后会生成genesis.block区块并保存到本地channel-artifacts文件夹中 2.4 生成Channel配置区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 2.5 更新锚节点 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 三 配置相关的docker-compose文件 3.1 配置docker-compose-orderer 先把docker-compose-cli.yaml复制一份并命名docker-compose-orderer.yaml cp ./docker-compose-cli.yaml ./docker-compose-orderer.yaml 然后打开并编辑docker-compose-orderer.yaml，去掉peer和cli的代码部分，只留下orderer相关代码 生成后大概如下 # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.2 配置docker-compose-peer 先把docker-compose-cli.yaml复制一份并命名docker-compose-peer.yaml cp ./docker-compose-cli.yaml ./docker-compose-peer.yaml 然后打开并编辑docker-compose-peer.yaml，去掉orderer的代码部分，去掉其他多余peer部分（编辑peer0.org1时，删掉其他三个peer代码部分），只留下一个peer和cli相关代码。 接下来再进行部分代码修改（以peer0.org1为例）： peer节点部分添加extra_hosts，添加后代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; cli中将command那一行代码前加#注释掉，或者删除该行代码 删除多余depend_on，添加extra_hosts，最后cli中部分代码如下： depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; - &quot;peer1.org1.example.com:192.168.44.133&quot; - &quot;peer0.org2.example.com:192.168.44.134&quot; - &quot;peer1.org2.example.com:192.168.44.135&quot; 以上就将peer节点配置成功了，但是有一个小细节，在peer1.org1主机中配置时，还需要在extra_hosts中加入peer0.org1的信息（同理在配置peer1.org2时需要加入peer0.org2的信息），具体代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; 3.2 配置base/docker-compose-base.yaml 将base/docker-compose-base.yaml中所有peer的端口映射都改为相同的： ports: - 7051:7051 - 7052:7052 - 7053:7053 四 启动fabric环境 4.1 启动peer和orderer 在peer节点主机上输入如下命令启动peer和orderer： docker-compose -f docker-compose-peer.yaml up -d 在orderer节点主机上输入： docker-compose -f docker-compose-orderer.yaml up -d 4.2 查看启动情况： docker ps -a 可以看到peer节点下有peer和cli容器，orderer中有orderer，则表示成功。 4.3 进入cli 这里我们以在peer0.org1中示范进入 docker exec -it cli bash 当显示：root@81aebc129d03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 的时候表示成功进入cli。 快速启动 接下来步骤可以直接通过快速启动来操作，也可以一步步的来添加，快速启动代码： ./script/script.sh mychannel 4.4 创建Channel ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 创建完成后ls可以看到原来的目录下多了一个mychannel.block文件 4.5 各个Peer加入Channel CLI默认连接的是peer0.org1，那么我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 其他几个Peer又该怎么加入Channel呢？这里就需要修改CLI的环境变量，使其指向另外的Peer。比如我们要把peer1.org1加入mychannel，那么命令是： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 peer channel join -b mychannel.block 系统会返回成功加入Channel的消息。 同样的方法，将peer0.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 最后把peer1.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 peer channel join -b mychannel.block 4.6 更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 整个Fabric网络和Channel都准备完毕。 五 链上代码的安装与运行 安装和运行ChainCode，以系统给的Example02为例。该例子定义了a，b两个账户，两者相互之间可以转账。 5.1 Install ChainCode–安装链上代码 仍然是保持在CLI的命令行下，我们先切换到peer0.org1这个节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 使用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 其他节点由于暂时还没使用到，我们可以先不安装，等到了步骤5.4的时候再安装。 5.2 Instantiate ChainCode–实例化链上代码 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 如果我们新开一个Ubuntu终端，去查看peer0.org1上的日志，那么就可以知道整个实例化的过程到底干了什么： docker logs -f peer0.org1.example.com 使用docker ps可以看到有新的容器正在运行： 5.3 在一个Peer上查询并发起交易 现在链上代码的实例也有了，并且在实例化的时候指定了a账户100，b账户200，我们可以试着调用ChainCode的查询代码，验证一下，在cli容器内执行： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果：Query Result: 100 接下来我们可以试着把a账户的10元转给b。对应的代码： ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再查询一下a的账户，发现a的账户余额变成了90 5.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？我们试着给peer0.org2安装链上代码： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 这个时候我们发现运行该命令后要等很久（我这里花了40秒）才返回结果： Query Result: 90 这是因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果。我们到peer0.org2机器的Ubuntu终端，执行docker ps，可以看到原本的容器中又多了一个容器 以上就是多节点集群部署的全部过程，如有错误，欢迎提出改正。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"fabric多节点集群部署（4+1）详解 本文也是在参考前人的资料下开始进行搭建并成功的，部署这个之前需要已经了解并成功部署过单节点。 前期工作：下载fabric代码，下载go，docker，docker-compose，并实现了单节点部署。 本文主要任务是在5台linux系统的电脑或虚拟机中完成fabric的集群部署。 机器相关配置： 名称 节点名字 组织 ip地址 Computer1 orderer.example.com Orderer 192.168.44.129 Computer2 peer0.org1.example.com Org1 192.168.44.132 Computer3 peer1.org1.example.com Org1 192.168.44.133 Computer4 peer0.org2.example.com Org2 192.168.44.134 Computer5 peer1.org2.example.com Org2 192.168.44.135 一 生成公私钥，证书等信息 生成相关信息我们只需要在一台机器上生成，然后通过ssh复制到其他机器相应的位置就行 方法一：直接通过系统脚本一键生成 注：我的fabric代码存放地址:home/ckt/go_code/src/github.com/hyperledger/fabric 进入项目： cd go_code/src/github.com/hyperledger/fabric/examples/e2e_cli/ 生成公私钥，证书，创世区块等信息： ./generateArtifacts.sh mychannel 方法二：手动一步步的生成 其实手动的步骤只是把generateArtifacts.sh这个脚本中的步骤拆分来，不过这样能对整个业务逻辑更熟悉 1.1 编译生成cryptogen make -C ../.. release 1.2 配置crypto-config.yaml 这个暂时不用配置，默认就行。 1.3 生成证书 ../../release/linux-amd64/bin/cryptogen generate --config=./crypto-config.yaml 代码执行后会在当前目录生成crypto-config目录，里面含有crypto-config.yaml刚刚配置好的组织及成员证书 二 生成创世区块和Channel配置区块 方法一：直接通过系统脚本一键生成 在一中采用脚本自动生成公私钥和证书时，已经把创世区块和channel配置一并生成完毕了，不需要在额外生成。 方法二：手动一步步的生成 2.1 编译生成configtxgen make -C ../.. release 2.2 配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3 生成创世区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后会生成genesis.block区块并保存到本地channel-artifacts文件夹中 2.4 生成Channel配置区块 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 2.5 更新锚节点 ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 三 配置相关的docker-compose文件 3.1 配置docker-compose-orderer 先把docker-compose-cli.yaml复制一份并命名docker-compose-orderer.yaml cp ./docker-compose-cli.yaml ./docker-compose-orderer.yaml 然后打开并编辑docker-compose-orderer.yaml，去掉peer和cli的代码部分，只留下orderer相关代码 生成后大概如下 # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.2 配置docker-compose-peer 先把docker-compose-cli.yaml复制一份并命名docker-compose-peer.yaml cp ./docker-compose-cli.yaml ./docker-compose-peer.yaml 然后打开并编辑docker-compose-peer.yaml，去掉orderer的代码部分，去掉其他多余peer部分（编辑peer0.org1时，删掉其他三个peer代码部分），只留下一个peer和cli相关代码。 接下来再进行部分代码修改（以peer0.org1为例）： peer节点部分添加extra_hosts，添加后代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; cli中将command那一行代码前加#注释掉，或者删除该行代码 删除多余depend_on，添加extra_hosts，最后cli中部分代码如下： depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; - &quot;peer1.org1.example.com:192.168.44.133&quot; - &quot;peer0.org2.example.com:192.168.44.134&quot; - &quot;peer1.org2.example.com:192.168.44.135&quot; 以上就将peer节点配置成功了，但是有一个小细节，在peer1.org1主机中配置时，还需要在extra_hosts中加入peer0.org1的信息（同理在配置peer1.org2时需要加入peer0.org2的信息），具体代码如下： peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.44.129&quot; - &quot;peer0.org1.example.com:192.168.44.132&quot; 3.2 配置base/docker-compose-base.yaml 将base/docker-compose-base.yaml中所有peer的端口映射都改为相同的： ports: - 7051:7051 - 7052:7052 - 7053:7053 四 启动fabric环境 4.1 启动peer和orderer 在peer节点主机上输入如下命令启动peer和orderer： docker-compose -f docker-compose-peer.yaml up -d 在orderer节点主机上输入： docker-compose -f docker-compose-orderer.yaml up -d 4.2 查看启动情况： docker ps -a 可以看到peer节点下有peer和cli容器，orderer中有orderer，则表示成功。 4.3 进入cli 这里我们以在peer0.org1中示范进入 docker exec -it cli bash 当显示：root@81aebc129d03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 的时候表示成功进入cli。 快速启动 接下来步骤可以直接通过快速启动来操作，也可以一步步的来添加，快速启动代码： ./script/script.sh mychannel 4.4 创建Channel ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 创建完成后ls可以看到原来的目录下多了一个mychannel.block文件 4.5 各个Peer加入Channel CLI默认连接的是peer0.org1，那么我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 其他几个Peer又该怎么加入Channel呢？这里就需要修改CLI的环境变量，使其指向另外的Peer。比如我们要把peer1.org1加入mychannel，那么命令是： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 peer channel join -b mychannel.block 系统会返回成功加入Channel的消息。 同样的方法，将peer0.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 最后把peer1.org2加入mychannel： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 peer channel join -b mychannel.block 4.6 更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 整个Fabric网络和Channel都准备完毕。 五 链上代码的安装与运行 安装和运行ChainCode，以系统给的Example02为例。该例子定义了a，b两个账户，两者相互之间可以转账。 5.1 Install ChainCode–安装链上代码 仍然是保持在CLI的命令行下，我们先切换到peer0.org1这个节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 使用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 其他节点由于暂时还没使用到，我们可以先不安装，等到了步骤5.4的时候再安装。 5.2 Instantiate ChainCode–实例化链上代码 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 如果我们新开一个Ubuntu终端，去查看peer0.org1上的日志，那么就可以知道整个实例化的过程到底干了什么： docker logs -f peer0.org1.example.com 使用docker ps可以看到有新的容器正在运行： 5.3 在一个Peer上查询并发起交易 现在链上代码的实例也有了，并且在实例化的时候指定了a账户100，b账户200，我们可以试着调用ChainCode的查询代码，验证一下，在cli容器内执行： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果：Query Result: 100 接下来我们可以试着把a账户的10元转给b。对应的代码： ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再查询一下a的账户，发现a的账户余额变成了90 5.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？我们试着给peer0.org2安装链上代码： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 这个时候我们发现运行该命令后要等很久（我这里花了40秒）才返回结果： Query Result: 90 这是因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果。我们到peer0.org2机器的Ubuntu终端，执行docker ps，可以看到原本的容器中又多了一个容器 以上就是多节点集群部署的全部过程，如有错误，欢迎提出改正。 阅读更多","@type":"BlogPosting","url":"/2017/12/28/7c3982cf023424cf5709a860568c4aa2.html","headline":"fabric多节点集群部署（4+1）详解","dateModified":"2017-12-28T00:00:00+08:00","datePublished":"2017-12-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/12/28/7c3982cf023424cf5709a860568c4aa2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>fabric多节点集群部署（4+1）详解</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="fabric多节点集群部署41详解"><strong>fabric多节点集群部署（4+1）详解</strong></h1> 
  <p>本文也是在参考前人的资料下开始进行搭建并成功的，部署这个之前需要已经了解并成功部署过单节点。</p> 
  <p>前期工作：下载fabric代码，下载go，docker，docker-compose，并实现了单节点部署。</p> 
  <p>本文主要任务是在5台linux系统的电脑或虚拟机中完成fabric的集群部署。</p> 
  <p><strong>机器相关配置</strong>：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>名称</th> 
     <th>节点名字</th> 
     <th>组织</th> 
     <th>ip地址</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>Computer1</td> 
     <td>orderer.example.com</td> 
     <td>Orderer</td> 
     <td>192.168.44.129</td> 
    </tr> 
    <tr> 
     <td>Computer2</td> 
     <td>peer0.org1.example.com</td> 
     <td>Org1</td> 
     <td>192.168.44.132</td> 
    </tr> 
    <tr> 
     <td>Computer3</td> 
     <td>peer1.org1.example.com</td> 
     <td>Org1</td> 
     <td>192.168.44.133</td> 
    </tr> 
    <tr> 
     <td>Computer4</td> 
     <td>peer0.org2.example.com</td> 
     <td>Org2</td> 
     <td>192.168.44.134</td> 
    </tr> 
    <tr> 
     <td>Computer5</td> 
     <td>peer1.org2.example.com</td> 
     <td>Org2</td> 
     <td>192.168.44.135</td> 
    </tr> 
   </tbody>
  </table> 
  <h2 id="一-生成公私钥证书等信息">一 生成公私钥，证书等信息</h2> 
  <p>生成相关信息我们只需要在一台机器上生成，然后通过ssh复制到其他机器相应的位置就行</p> 
  <h3 id="方法一直接通过系统脚本一键生成">方法一：直接通过系统脚本一键生成</h3> 
  <p>注：我的fabric代码存放地址:home/ckt/go_code/src/github.com/hyperledger/fabric</p> 
  <p>进入项目：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">cd go_code/src/github.com/hyperledger/fabric/examples/e2e_cli/
</code></pre> 
  <p>生成公私钥，证书，创世区块等信息：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">./generateArtifacts.sh mychannel</code></pre> 
  <h3 id="方法二手动一步步的生成">方法二：手动一步步的生成</h3> 
  <p>其实手动的步骤只是把generateArtifacts.sh这个脚本中的步骤拆分来，不过这样能对整个业务逻辑更熟悉</p> 
  <h4 id="11-编译生成cryptogen">1.1 编译生成cryptogen</h4> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-built_in">make</span> -C ../.. release</code></pre> 
  <h4 id="12-配置crypto-configyaml">1.2 配置crypto-config.yaml</h4> 
  <p>这个暂时不用配置，默认就行。</p> 
  <h4 id="13-生成证书">1.3 生成证书</h4> 
  <pre class="prettyprint"><code class="language-go hljs ">../../release/linux-amd64/bin/cryptogen generate --config=./crypto-config.yaml</code></pre> 
  <p>代码执行后会在当前目录生成crypto-config目录，里面含有crypto-config.yaml刚刚配置好的组织及成员证书</p> 
  <h2 id="二-生成创世区块和channel配置区块">二 生成创世区块和Channel配置区块</h2> 
  <h3 id="方法一直接通过系统脚本一键生成-1">方法一：直接通过系统脚本一键生成</h3> 
  <p>在一中采用脚本自动生成公私钥和证书时，已经把创世区块和channel配置一并生成完毕了，不需要在额外生成。</p> 
  <h3 id="方法二手动一步步的生成-1">方法二：手动一步步的生成</h3> 
  <h4 id="21-编译生成configtxgen">2.1 编译生成configtxgen</h4> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-built_in">make</span> -C ../.. release</code></pre> 
  <h4 id="22-配置configtxyaml">2.2 配置configtx.yaml</h4> 
  <p>官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。</p> 
  <h4 id="23-生成创世区块">2.3 生成创世区块</h4> 
  <pre class="prettyprint"><code class="language-go hljs ">../../release/linux-amd64/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</code></pre> 
  <p>执行后会生成genesis.block区块并保存到本地channel-artifacts文件夹中</p> 
  <h4 id="24-生成channel配置区块">2.4 生成Channel配置区块</h4> 
  <pre class="prettyprint"><code class="language-go hljs ">../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel</code></pre> 
  <h4 id="25-更新锚节点">2.5 更新锚节点</h4> 
  <pre class="prettyprint"><code class="language-go hljs ">../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">../../release/linux-amd64/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $mychannel -asOrg Org2MSP</code></pre> 
  <p>最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。</p> 
  <p>channel-artifacts/ <br> ├── channel.tx <br> ├── genesis.block <br> ├── Org1MSPanchors.tx <br> └── Org2MSPanchors.tx</p> 
  <h2 id="三-配置相关的docker-compose文件">三 配置相关的docker-compose文件</h2> 
  <h3 id="31-配置docker-compose-orderer">3.1 配置docker-compose-orderer</h3> 
  <p>先把docker-compose-cli.yaml复制一份并命名docker-compose-orderer.yaml</p> 
  <pre class="prettyprint"><code class="language-go hljs ">cp ./docker-compose-cli.yaml ./docker-compose-orderer.yaml</code></pre> 
  <p>然后打开并编辑docker-compose-orderer.yaml，去掉peer和cli的代码部分，只留下orderer相关代码 <br> 生成后大概如下</p> 
  <pre class="prettyprint"><code class="language-go hljs "># Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache<span class="hljs-number">-2.0</span>
#

version: <span class="hljs-string">'2'</span>

services:

  orderer.example.com:
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.example.com
    container_name: orderer.example.com
</code></pre> 
  <h3 id="32-配置docker-compose-peer">3.2 配置docker-compose-peer</h3> 
  <p>先把docker-compose-cli.yaml复制一份并命名docker-compose-peer.yaml</p> 
  <pre class="prettyprint"><code class="language-go hljs ">cp ./docker-compose-cli.yaml ./docker-compose-peer.yaml</code></pre> 
  <p>然后打开并编辑docker-compose-peer.yaml，去掉orderer的代码部分，去掉其他多余peer部分（编辑peer0.org1时，删掉其他三个peer代码部分），只留下一个peer和cli相关代码。 <br> 接下来再进行部分代码修改（以peer0.org1为例）： <br> peer节点部分添加extra_hosts，添加后代码如下：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer0.org1.example.com:
    container_name: peer0.org1.example.com
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org1.example.com
    extra_hosts:
     - <span class="hljs-string">"orderer.example.com:192.168.44.129"</span></code></pre> 
  <p><strong>cli中将command那一行代码前加#注释掉，或者删除该行代码</strong> <br> 删除多余depend_on，添加extra_hosts，最后cli中部分代码如下：</p> 
  <pre class="prettyprint"><code class="language-go hljs "> depends_on:
      - peer0.org1.example.com
    extra_hosts:
      - <span class="hljs-string">"orderer.example.com:192.168.44.129"</span>
      - <span class="hljs-string">"peer0.org1.example.com:192.168.44.132"</span>
      - <span class="hljs-string">"peer1.org1.example.com:192.168.44.133"</span>
      - <span class="hljs-string">"peer0.org2.example.com:192.168.44.134"</span>
      - <span class="hljs-string">"peer1.org2.example.com:192.168.44.135"</span>
</code></pre> 
  <p>以上就将peer节点配置成功了，但是有一个小细节，在peer1.org1主机中配置时，还需要在extra_hosts中加入peer0.org1的信息（同理在配置peer1.org2时需要加入peer0.org2的信息），具体代码如下：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer0.org1.example.com:
    container_name: peer0.org1.example.com
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org1.example.com
    extra_hosts:
     - <span class="hljs-string">"orderer.example.com:192.168.44.129"</span>
     - <span class="hljs-string">"peer0.org1.example.com:192.168.44.132"</span></code></pre> 
  <h3 id="32-配置basedocker-compose-baseyaml">3.2 配置base/docker-compose-base.yaml</h3> 
  <p>将base/docker-compose-base.yaml中所有peer的端口映射都改为相同的：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">ports: 
   -<span class="hljs-number"> 7051</span><span class="hljs-number">:7051</span> 
   -<span class="hljs-number"> 7052</span><span class="hljs-number">:7052</span> 
   -<span class="hljs-number"> 7053</span><span class="hljs-number">:7053</span></code></pre> 
  <h2 id="四-启动fabric环境">四 启动fabric环境</h2> 
  <h3 id="41-启动peer和orderer">4.1 启动peer和orderer</h3> 
  <p>在peer节点主机上输入如下命令启动peer和orderer：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">docker-compose -f docker-compose-peer.yaml up -d</code></pre> 
  <p>在orderer节点主机上输入：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">docker-compose -f docker-compose-orderer.yaml up -d</code></pre> 
  <h3 id="42-查看启动情况">4.2 查看启动情况：</h3> 
  <pre class="prettyprint"><code class="language-go hljs ">docker ps -a</code></pre> 
  <p>可以看到peer节点下有peer和cli容器，orderer中有orderer，则表示成功。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228164526706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228164549266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h3 id="43-进入cli">4.3 进入cli</h3> 
  <p>这里我们以在peer0.org1中示范进入</p> 
  <pre class="prettyprint"><code class="language-go hljs ">docker exec -it cli bash</code></pre> 
  <p>当显示：root@81aebc129d03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 的时候表示成功进入cli。</p> 
  <h3 id="快速启动"><strong>快速启动</strong></h3> 
  <p><strong>接下来步骤可以直接通过快速启动来操作，也可以一步步的来添加，快速启动代码：</strong></p> 
  <pre class="prettyprint"><code class="language-go hljs ">./script/script.sh mychannel</code></pre> 
  <h3 id="44-创建channel">4.4 创建Channel</h3> 
  <pre class="prettyprint"><code class="language-go hljs ">ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

peer channel create -o orderer.example.com<span class="hljs-number">:7050</span> -c mychannel -f ./channel-artifacts/channel.tx --tls <span class="hljs-constant">true</span> --cafile $ORDERER_CA</code></pre> 
  <p>创建完成后ls可以看到原来的目录下多了一个mychannel.block文件 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228165541652?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h3 id="45-各个peer加入channel">4.5 各个Peer加入Channel</h3> 
  <p>CLI默认连接的是peer0.org1，那么我们要将这个Peer加入mychannel就很简单，只需要运行如下命令：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel join -b mychannel.block</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228171355399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 其他几个Peer又该怎么加入Channel呢？这里就需要修改CLI的环境变量，使其指向另外的Peer。比如我们要把peer1.org1加入mychannel，那么命令是：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org1MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 
CORE_PEER_ADDRESS=peer1.org1.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel join -b mychannel.block</code></pre> 
  <p>系统会返回成功加入Channel的消息。</p> 
  <p>同样的方法，将peer0.org2加入mychannel：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel join -b mychannel.block</code></pre> 
  <p>最后把peer1.org2加入mychannel：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer1.org2.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel join -b mychannel.block
</code></pre> 
  <h3 id="46-更新锚节点">4.6 更新锚节点</h3> 
  <p>对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org1MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 
CORE_PEER_ADDRESS=peer0.org1.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel update -o orderer.example.com<span class="hljs-number">:7050</span> -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls <span class="hljs-constant">true</span> --cafile $ORDERER_CA</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228171546038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>对于Org2，peer0.org2是锚节点，对应的更新代码是：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer channel update -o orderer.example.com<span class="hljs-number">:7050</span> -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls <span class="hljs-constant">true</span> --cafile $ORDERER_CA</code></pre> 
  <p>整个Fabric网络和Channel都准备完毕。</p> 
  <h2 id="五-链上代码的安装与运行">五 链上代码的安装与运行</h2> 
  <p>安装和运行ChainCode，以系统给的Example02为例。该例子定义了a，b两个账户，两者相互之间可以转账。</p> 
  <h3 id="51-install-chaincode安装链上代码">5.1 Install ChainCode–安装链上代码</h3> 
  <p>仍然是保持在CLI的命令行下，我们先切换到peer0.org1这个节点：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org1MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 
CORE_PEER_ADDRESS=peer0.org1.example.com<span class="hljs-number">:7051</span></code></pre> 
  <p>使用peer chaincode install命令可以安装指定的ChainCode并对其命名：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode install -n mycc -v<span class="hljs-number"> 1.0</span> -p github.com/hyperledger/fabric/examples/chaincode/<span class="hljs-keyword">go</span>/chaincode_example02</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228171733678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。</p> 
  <p>其他节点由于暂时还没使用到，我们可以先不安装，等到了步骤5.4的时候再安装。</p> 
  <h3 id="52-instantiate-chaincode实例化链上代码">5.2 Instantiate ChainCode–实例化链上代码</h3> 
  <p>实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们运行以下命令完成实例化：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode instantiate -o orderer.example.com<span class="hljs-number">:7050</span> --tls <span class="hljs-constant">true</span> --cafile $ORDERER_CA -C mychannel -n mycc -v<span class="hljs-number"> 1.0</span> -c <span class="hljs-string">'{"Args":["init","a","100","b","200"]}'</span> -P <span class="hljs-string">"OR ('Org1MSP.member','Org2MSP.member')"</span></code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228171915394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 如果我们新开一个Ubuntu终端，去查看peer0.org1上的日志，那么就可以知道整个实例化的过程到底干了什么：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">docker logs -f peer0.org1.example.com</code></pre> 
  <p>使用docker ps可以看到有新的容器正在运行： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228172025607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h3 id="53-在一个peer上查询并发起交易">5.3 在一个Peer上查询并发起交易</h3> 
  <p>现在链上代码的实例也有了，并且在实例化的时候指定了a账户100，b账户200，我们可以试着调用ChainCode的查询代码，验证一下，在cli容器内执行：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode query -C mychannel -n mycc -c <span class="hljs-string">'{"Args":["query","a"]}'</span></code></pre> 
  <p>返回结果：Query Result: 100 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228172259056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>接下来我们可以试着把a账户的10元转给b。对应的代码：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode invoke -o orderer.example.com<span class="hljs-number">:7050</span>  --tls <span class="hljs-constant">true</span> --cafile $ORDERER_CA -C mychannel -n mycc -c <span class="hljs-string">'{"Args":["invoke","a","b","10"]}'</span></code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228172316562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 再查询一下a的账户，发现a的账户余额变成了90 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171228172326409?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3OTMzNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h3 id="54-在另一个节点上查询交易">5.4 在另一个节点上查询交易</h3> 
  <p>前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？我们试着给peer0.org2安装链上代码：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com<span class="hljs-number">:7051</span></code></pre> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode install -n mycc -v<span class="hljs-number"> 1.0</span> -p github.com/hyperledger/fabric/examples/chaincode/<span class="hljs-keyword">go</span>/chaincode_example02</code></pre> 
  <p>由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令：</p> 
  <pre class="prettyprint"><code class="language-go hljs ">peer chaincode query -C mychannel -n mycc -c <span class="hljs-string">'{"Args":["query","a"]}'</span></code></pre> 
  <p>这个时候我们发现运行该命令后要等很久（我这里花了40秒）才返回结果：</p> 
  <p>Query Result: 90</p> 
  <p>这是因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果。我们到peer0.org2机器的Ubuntu终端，执行docker ps，可以看到原本的容器中又多了一个容器</p> 
  <p>以上就是多节点集群部署的全部过程，如有错误，欢迎提出改正。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36793353/article/details/78922369,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36793353/article/details/78922369,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
