<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【密码学】一万字带您走进密码学的世界（下） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【密码学】一万字带您走进密码学的世界（下）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="引文 密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。 在《一万字带您走进密码学的世界（上）》的文章中我们探讨了对称密码体系，哈希函数等技术，本文继续探讨密码学剩余的部分，本文的主要内容包括，非对称密码体系，签名算法等，因为本部分是区块链技术的基石，所以我会讲的更加详细一点，虽然我已经尽最大努力使思想简化，但是其中的数学理论对于很多人还是很晦涩，建议读者开始之前先读下数论的有关知识。本部分的主要结构如下： 非对称密码 前面的文章我们探讨了对称加密，在对称秘钥加密的体系中，加密和解密使用同一个秘钥，显而易见的是这种方式存在一个很严重的弊端，那就是秘钥的分发和管理，一旦秘钥在分发过程中被人窃取，加密形同虚设。秘钥的管理也相当繁琐，如下图，如果我们要同时与n个人通信，那么每个人都将保存n-1个秘钥。 非对称的存在的意义就是为了克服这些问题，在非对称秘钥体系中，通信双方各有一个公钥和私钥，加密者使用私钥进行加密，然后传递解密者，解密者使用对方的公钥直接就可以解开，不存在秘钥秘钥传递的问题，为了更好的解释这个问题，下面用个简单的例子讲解一下。 一个简单的例子 Alice和Bob用传统信件进行沟通，假设Alice和Bob不相信有邮政系统，他们想在通信的时候把信件用箱子锁住，并且在箱子外面加上一个锁。 在公钥加密体系中，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用钥匙打开，很显然，这个钥匙一定是alice钥匙的副本，不然打不开 在上面的例子中我们知道，秘钥交换是一定存在的，在沟通之前一定要进行秘钥的交换，那么有没有其他的方案可以不进行秘钥交换呢，答案是有的，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用锁锁上，然后在返回给Alice，这个时候盒子上是有两把锁的，然后Alice去掉自己的锁，这样盒子上就剩下Bob的一把锁了，然后在将盒子发给Bob，Bob用自己的钥匙打开自己的锁，就看到其中的消息。 上面的方法是可以实现不用秘钥交换，但是确定就是过于复杂，那么有没有更好的方式呢？在对称密码体系中，问题将变得简单，Bob直接将自己的打开的锁发给Alice，Alice收到锁后，然后用这个锁加密锁住装有消息的盒子，然后发给Bob，Bob可以很轻易的打开自己的锁。 在这个方法中一个重要的环节就是在已知Bob的锁和箱子的时候时候，没有BOb的钥匙是一定是打不开，在显示生活中很容易理解，可以在计算机的世界中如何寻找到这样合适的算法，目前已知的算法有两种，一种是基于离散对数的问题，另一种是椭圆曲线连对数问题，在下面的算法中我们着重讲解离散对数的问题。 Diffie-Hellman密钥交换 Diffie-Hellman密钥交换首次出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学，因此该算法通常称之为Diffie-Hellman密钥交换。这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密。 Diffie-Hellman加密算法的有效性依赖于计算离散对数的难度。简言之，可以如下定义离散对数： 首先定义一个素数p的原根，为其各次幂产生从1 到p-1的所有整数根，也就是说，如果a是素数p的一个原根，那么数值&nbsp;amodpamodp,a1modpa1modp,…,ap-1 mod p 是各不相同的整数，并且以某种排列方式组成了从1到p-1的所有整数。对于一个整数b和素数p的一个原根a，可以找到惟一的指数i，使得 b = ai mod p 其中0 ≤ i ≤ (p-1）指数i称为b的以a为基数的模p的离散对数或者指数，该值被记为inda，p(b)。 上面的一段引用看的一脸懵逼对吧，其实我也有又这样的感觉，我始终觉得一个优秀的学术工作者，要写出能读懂的文章，而不是别人看不懂的东西去彰显自己的高大上。好了就不吐槽了，我们开始用简单的例子解释上面的意思 首先说取摩运算，就是我们经常说的取余，比如我们对3对12进行取余就是3,9对12取余就是9,27对12取余就是3 简单点说：3xmod12=y3xmod12=y&nbsp;其中&nbsp;x∈(1,2,3…n)x∈(1,2,3…n)&nbsp;在这里如果我们已知x，可以很轻易的计算出y的值，及时x的值比较大，利用计算机也可以很轻易的算出，但是如果已经y,即使用高性能的计算机也很难计算出x,这就是离散对数的问题。 离散对数公钥加密算法是目前最为热门的公钥加密算法 ，其安全性要远远高于基于大数分解的RSA算法，首先说明一下上述三位科学家公钥密码体制的运作过程（假定A和B两个人要在一个不安全通道如因特网上形成密钥以备日后加密解密所用）。 首先，A、B两人要共同公开约定一个素数q和有限域Fq中的一个生成元g； A选定一个随机数a∈{1，2，…，q-1}（a可以认为是A之私钥），并将ga(modq)ga(modq)传送给B； B选定一个随机数b∈{1，2，…，q-1}（b可以认为是B之私钥），并将gb(modq)gb(modq)传送给A； 此时A可以算出(gb)a(modq)(gb)a(modq)，B也可以算出(ga)b(modq)(ga)b(modq)，由于(gb)a(modq)=(ga)b(modq)=gab(modq)(gb)a(modq)=(ga)b(modq)=gab(modq)， 因此，A和B就形成了一个公共的密钥gab(modq)gab(modq)，日后便可以此钥来进行传统的加密解密计算，从而达到在不安全的通道上进行保密通讯的目的。 显然，敌方可以截获到g，q，ga(modq)，gb(modq)g，q，ga(modq)，gb(modq)。因此，如果敌方有快速的求解离散对数的算法，就能从已截获的上述信息中迅速求出a或b，从而算出gab(modq)gab(modq)。遗憾的是，目前世界上根本就没有快速的求解离散对数的算法，因此当所选的有限域Fq很大时，a或b就很难算出。 Diffie-Hellman的算法举例可以参考我之前的文章《【密码学】Diffie-Hellman密钥交换》 ElGamal算法 在密码学中，ElGamal加密系统是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。 ElGamal加密算法可以定义在任何循环群GG&nbsp;上。它的安全性取决于&nbsp;GG&nbsp;上的离散对数难题。 ElGamal 加密被用于免费的GNU隐私保护软件、PGP 近期的版本和其他密码系统中 此部分的详细讲解，请看下篇文章《【密码学】ElGamal算法详解》 Cramer-Shoup 加密系统 Cramer–Shoup 系统是一个非对称秘钥加密算法，而且被证实是第一个针对适应性选择米文攻击所采用的标准加密猜想所用的安全有效的项目。其安全性是基于决定性Diffie–Hellman猜想的计算难解性（广泛接受，但未被证实）的计算难解性的。由 Ronald Cramer （罗纳德·克莱默）和 Victor Shoup （维克多·苏伯）于1998年研发，是 ElGamal 加密系统的延伸。与 ElGamal 相反，它具有很强的延展性，Cramer–Shoup 添加了另外的成分来确保甚至是遭受广泛的攻击时保证其非延展性。这一非延展性是通过使用抗撞击哈希函数和额外的计算而取得的，导致了密文是 ElGamal 的两倍大 ECC 椭圆曲线算法 椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开金钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。 ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。 RSA加密算法 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 因为此部分是区块链的算法结合比较紧密，我将花更多的篇幅讲解，从上面的讲解我们知道，我们需要构建一个锁和一把钥匙，然后将锁分配给每个人，然后自己保留钥匙，在这里这把锁就相当于相当于公钥，自己的钥匙就相当于私钥，下面我们开始用离散对数问题来构建我们的公钥和私钥。虽然在部分我会尽量写的详细，但是在开始之前，读者最好能对数论知识有个基本的了解，可以参数我之前的文章《【密码学】RSA算法解析-数论基础》 我们前面已经提到离散对数的问题，形如 memodN=cmemodN=c 我们在已知c和N和m的情况下很难图导出e.同样的道理，你在已知c和N和e,的情况下也很难推出来m,这就是一个典型的单项函数 &nbsp; m是明文，c是密文，e是加密的钥匙，d是解密的钥匙，按照我们上面的解释，在下面的加密解密过程都是严谨的单向过程 memodN=c公式1memodN=c公式1 我们找到一个d使下面的公式也成立 cdmodN=m公式2cdmodN=m公式2 1.接下来我们的目标就是找到合适的e和d,我们开始推导，将公式1带入到公式2中 （memodN）dmodN=m公式3（memodN）dmodN=m公式3 &nbsp; （me）dmodN=m公式4（me）dmodN=m公式4 &nbsp; medmodN=m公式5medmodN=m公式5 2.我们将一个数n的子集存在互质关系个数定义为φ(n),那么一个合数的公约数是不固定的，但是一个素数的公约数一定只有自己，所以对于素数φ(n) = n-1 这个求解过程叫欧拉函数，可以参考我之前的文章 3.欧拉函数主要应用在欧拉定理上，”欧拉定理”指的是：如果两个正整数m和N互质，则n的欧拉函数 φ(n) 可以让下面的等式成立： mϕ(n)≡1(modN)公式6mϕ(n)≡1(modN)公式6 转换后就是： mϕ(n)modN≡1公式7mϕ(n)modN≡1公式7 然后两边同时乘以m mϕ(n)+1modN≡m公式8mϕ(n)+1modN≡m公式8 有上面的公式5我们知道 medmodN=m公式5medmodN=m公式5 因此可以得出 medmodN=mϕ(n)+1modNmedmodN=mϕ(n)+1modN &nbsp; ed=ϕ(n)+1ed=ϕ(n)+1 &nbsp; ed−ϕ(n)y=1此处增加y表示任意数字ed−ϕ(n)y=1此处增加y表示任意数字 我们目前已经知道的条件，我们已知N，一般N都是两个素数的乘积，已经知道加密秘钥e,求解解密秘钥d 为了便于讲解，我们假设在这里N=77，则phi(n)=6∗10=60phi(n)=6∗10=60, e等于67，则计算过程如下， 67d−60y=167d−60y=1 以为y可以为负数，因此 这是有一个二项式的接，其实有多个答案，我们只需获取其中一个就可以，根据欧几里得拓展定理可以算出私钥d的值为43，计算机过程参考《【密码学】RSA算法解析-加密解密》 最终加密过程 7567≡c(mod77)7567≡c(mod77) 在计算机中可以很轻易的计算出c=26 解密过程 2643≡m(mod77)2643≡m(mod77) 在计算机中可以很轻易的计算出m=75 &nbsp; 演示代码 python源码地址： https://cloud.sagemath.com/projects/dc18d6fb-c4ae-47c4-8ea4-b2a1887ccb6b/files/RSA_CASE.sagews 到这里RSA完整的讲完了，虽然我已经写得很详细了，但是肯定还是有些读者不能完全理解，如果还是不能理解，建议先学习点数论的知识预热。 签名算法 我们在讨论签名算法之前，先来回忆一下之前讲的hash函数，我们有一份文件可以计算出他的Hash值，一旦文件被篡改做产生的Hash值也将变化，Hash函数解决了完整性的问题，然而并没有解决认证的问题，如果攻击者不但把文件给篡改了还把hash值给改了，这样接收者就察觉不到文件已经出了问题。 我们需要一种签名机制，这种签名机制能保证所有人都能对文件的完整性进行认证，同时又能验证这份文件确实是发送者发的，攻击者无法伪造这个签名。 设计原则 数字签名常常和哈希函数在一起使用，给定一段明文M，我们可以计算出明文的哈希值h(M),然后将哈希值进行某种加密S后，附在明文上，结构如下： M|S(h(M))M|S(h(M)) 在上述结构主要依赖于哈希值不存在对撞，即不同的明文之间不会存在相同的哈希值，实际上每种公钥加密体系都能实现，下面我们主要探究3种： Schnorr签名，Digital Signature Algorithm（数字证书签名），RSA签名 &nbsp; Schnorr签名 Schnorr签名是基于ElGamal算法的，它的安全性取决于离散对数的难题。 DSA签名 使用SHA哈希加密函数，它的安全性也取决于离散对数的难题。它是1990被提出，并且已经被US FIPS所接受，他的具体原理如下： 1.选择一个1024位的素数p,此时有一个群组ZpZp 2.选择另一个160位的素数q，q除以p-1和q都在群组GqGq中，并且群组GqGq属于ZpZp 3.其中要到的哈希算法是SHA-1秘钥生成： 1.选择p和q,条件就是上面所表达的，换成数学的表达方式就是p=zq+1p=zq+1&nbsp;并且z属于群组ZpZp 2.选择一个g，使下面的公式成立，jz=g(modp)jz=g(modp)&nbsp;并且&nbsp;1&lt;j&lt;p1&lt;j&lt;p 3.在范围1,…..q−11,…..q−1&nbsp;的选择一个随机数x 4.计算出来y=gxmodpy=gxmodp 5.其中公钥就是K1=(p,q,g,y)K1=(p,q,g,y),私钥就是K2=(p,q,g,x)K2=(p,q,g,x)签名过程： 1.在范围1,…..q−11,…..q−1的选择一个随机数r 2.计算出来s=(grmodp)modqs=(grmodp)modq 3.计算出t=((SHA−1(M)+xs)r−1)modqt=((SHA−1(M)+xs)r−1)modq 4.将签名结果(s,t)(s,t)附属在消息上。验签过程： 1.计算出u1=(SHA−1(M)t−1)modqu1=(SHA−1(M)t−1)modq 2.计算出u2=(s∗t−1)modqu2=(s∗t−1)modq 3.计算签名s1=((gu1yu2)modp)modqs1=((gu1yu2)modp)modq 4.比较s1s1是否与s相同 RSA签名 一种从RSA算法演变而来的签名，它的安全性取决大素数分解难题。下面我们来看看具体的实现过程秘钥生成 1.选择两个大素数，p和q 2.计算出他们的欧拉函数，ϕ(n)=(p−1)(q−1)ϕ(n)=(p−1)(q−1) 3.我们选择一个整数e&gt;1,并使gcd(e,ϕ(n))=1gcd(e,ϕ(n))=1&nbsp;即e要和欧拉函数（非公约的个数），互为素数。 4.我们使de=1(modϕ(n))de=1(modϕ(n))&nbsp;,根据欧几里得拓展定理计算出d. 5.然后我们就得到了公钥K1=(e,n)K1=(e,n)，然后对外发布公钥 6.私钥就是k2=dk2=d 签名过程： 我们假设需要加密的信息为M，其中M在1,,,,n−11,,,,n−1这个范围内，h为哈希加密函数，则签名的过程如下： s=h(M)dmodns=h(M)dmodn 验签过程： 计算出明文的哈希值h(M)比较h(M)是否和sensen相应，如果相同则验签成功。 &nbsp; 总结 本文主要阐述了密码学中的非对称密码和签名算法，不得不说对于一个开发人员来说，今天的讲解过的理论化，但是理论是实践的基础，不是吗？ 声明 本文45%为翻译组合,55%为原创 引用 http://www.jiamisoft.com/blog/index.php/3165-diffie-hellmanjiamisuanfa.html https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95 http://baike.baidu.com/link?url=14BKIalgIoeD2Wbq7X6rxUBoYrTEHlhxlX3x337N7_7qLaDh6XMK1MMStd5zIfROme-meST7ZJPQqWDjb7MgUJHxPiVeEJqeP2PB1i2eSNOZAzy_c-BgpCQLLUjn1GHg https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/checkpoint-advanced-lessons&nbsp;http://en.wikipedia.org/wiki/Cramer–Shoup_cryptosystem https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6 阅读更多" />
<meta property="og:description" content="引文 密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。 在《一万字带您走进密码学的世界（上）》的文章中我们探讨了对称密码体系，哈希函数等技术，本文继续探讨密码学剩余的部分，本文的主要内容包括，非对称密码体系，签名算法等，因为本部分是区块链技术的基石，所以我会讲的更加详细一点，虽然我已经尽最大努力使思想简化，但是其中的数学理论对于很多人还是很晦涩，建议读者开始之前先读下数论的有关知识。本部分的主要结构如下： 非对称密码 前面的文章我们探讨了对称加密，在对称秘钥加密的体系中，加密和解密使用同一个秘钥，显而易见的是这种方式存在一个很严重的弊端，那就是秘钥的分发和管理，一旦秘钥在分发过程中被人窃取，加密形同虚设。秘钥的管理也相当繁琐，如下图，如果我们要同时与n个人通信，那么每个人都将保存n-1个秘钥。 非对称的存在的意义就是为了克服这些问题，在非对称秘钥体系中，通信双方各有一个公钥和私钥，加密者使用私钥进行加密，然后传递解密者，解密者使用对方的公钥直接就可以解开，不存在秘钥秘钥传递的问题，为了更好的解释这个问题，下面用个简单的例子讲解一下。 一个简单的例子 Alice和Bob用传统信件进行沟通，假设Alice和Bob不相信有邮政系统，他们想在通信的时候把信件用箱子锁住，并且在箱子外面加上一个锁。 在公钥加密体系中，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用钥匙打开，很显然，这个钥匙一定是alice钥匙的副本，不然打不开 在上面的例子中我们知道，秘钥交换是一定存在的，在沟通之前一定要进行秘钥的交换，那么有没有其他的方案可以不进行秘钥交换呢，答案是有的，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用锁锁上，然后在返回给Alice，这个时候盒子上是有两把锁的，然后Alice去掉自己的锁，这样盒子上就剩下Bob的一把锁了，然后在将盒子发给Bob，Bob用自己的钥匙打开自己的锁，就看到其中的消息。 上面的方法是可以实现不用秘钥交换，但是确定就是过于复杂，那么有没有更好的方式呢？在对称密码体系中，问题将变得简单，Bob直接将自己的打开的锁发给Alice，Alice收到锁后，然后用这个锁加密锁住装有消息的盒子，然后发给Bob，Bob可以很轻易的打开自己的锁。 在这个方法中一个重要的环节就是在已知Bob的锁和箱子的时候时候，没有BOb的钥匙是一定是打不开，在显示生活中很容易理解，可以在计算机的世界中如何寻找到这样合适的算法，目前已知的算法有两种，一种是基于离散对数的问题，另一种是椭圆曲线连对数问题，在下面的算法中我们着重讲解离散对数的问题。 Diffie-Hellman密钥交换 Diffie-Hellman密钥交换首次出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学，因此该算法通常称之为Diffie-Hellman密钥交换。这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密。 Diffie-Hellman加密算法的有效性依赖于计算离散对数的难度。简言之，可以如下定义离散对数： 首先定义一个素数p的原根，为其各次幂产生从1 到p-1的所有整数根，也就是说，如果a是素数p的一个原根，那么数值&nbsp;amodpamodp,a1modpa1modp,…,ap-1 mod p 是各不相同的整数，并且以某种排列方式组成了从1到p-1的所有整数。对于一个整数b和素数p的一个原根a，可以找到惟一的指数i，使得 b = ai mod p 其中0 ≤ i ≤ (p-1）指数i称为b的以a为基数的模p的离散对数或者指数，该值被记为inda，p(b)。 上面的一段引用看的一脸懵逼对吧，其实我也有又这样的感觉，我始终觉得一个优秀的学术工作者，要写出能读懂的文章，而不是别人看不懂的东西去彰显自己的高大上。好了就不吐槽了，我们开始用简单的例子解释上面的意思 首先说取摩运算，就是我们经常说的取余，比如我们对3对12进行取余就是3,9对12取余就是9,27对12取余就是3 简单点说：3xmod12=y3xmod12=y&nbsp;其中&nbsp;x∈(1,2,3…n)x∈(1,2,3…n)&nbsp;在这里如果我们已知x，可以很轻易的计算出y的值，及时x的值比较大，利用计算机也可以很轻易的算出，但是如果已经y,即使用高性能的计算机也很难计算出x,这就是离散对数的问题。 离散对数公钥加密算法是目前最为热门的公钥加密算法 ，其安全性要远远高于基于大数分解的RSA算法，首先说明一下上述三位科学家公钥密码体制的运作过程（假定A和B两个人要在一个不安全通道如因特网上形成密钥以备日后加密解密所用）。 首先，A、B两人要共同公开约定一个素数q和有限域Fq中的一个生成元g； A选定一个随机数a∈{1，2，…，q-1}（a可以认为是A之私钥），并将ga(modq)ga(modq)传送给B； B选定一个随机数b∈{1，2，…，q-1}（b可以认为是B之私钥），并将gb(modq)gb(modq)传送给A； 此时A可以算出(gb)a(modq)(gb)a(modq)，B也可以算出(ga)b(modq)(ga)b(modq)，由于(gb)a(modq)=(ga)b(modq)=gab(modq)(gb)a(modq)=(ga)b(modq)=gab(modq)， 因此，A和B就形成了一个公共的密钥gab(modq)gab(modq)，日后便可以此钥来进行传统的加密解密计算，从而达到在不安全的通道上进行保密通讯的目的。 显然，敌方可以截获到g，q，ga(modq)，gb(modq)g，q，ga(modq)，gb(modq)。因此，如果敌方有快速的求解离散对数的算法，就能从已截获的上述信息中迅速求出a或b，从而算出gab(modq)gab(modq)。遗憾的是，目前世界上根本就没有快速的求解离散对数的算法，因此当所选的有限域Fq很大时，a或b就很难算出。 Diffie-Hellman的算法举例可以参考我之前的文章《【密码学】Diffie-Hellman密钥交换》 ElGamal算法 在密码学中，ElGamal加密系统是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。 ElGamal加密算法可以定义在任何循环群GG&nbsp;上。它的安全性取决于&nbsp;GG&nbsp;上的离散对数难题。 ElGamal 加密被用于免费的GNU隐私保护软件、PGP 近期的版本和其他密码系统中 此部分的详细讲解，请看下篇文章《【密码学】ElGamal算法详解》 Cramer-Shoup 加密系统 Cramer–Shoup 系统是一个非对称秘钥加密算法，而且被证实是第一个针对适应性选择米文攻击所采用的标准加密猜想所用的安全有效的项目。其安全性是基于决定性Diffie–Hellman猜想的计算难解性（广泛接受，但未被证实）的计算难解性的。由 Ronald Cramer （罗纳德·克莱默）和 Victor Shoup （维克多·苏伯）于1998年研发，是 ElGamal 加密系统的延伸。与 ElGamal 相反，它具有很强的延展性，Cramer–Shoup 添加了另外的成分来确保甚至是遭受广泛的攻击时保证其非延展性。这一非延展性是通过使用抗撞击哈希函数和额外的计算而取得的，导致了密文是 ElGamal 的两倍大 ECC 椭圆曲线算法 椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开金钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。 ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。 RSA加密算法 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 因为此部分是区块链的算法结合比较紧密，我将花更多的篇幅讲解，从上面的讲解我们知道，我们需要构建一个锁和一把钥匙，然后将锁分配给每个人，然后自己保留钥匙，在这里这把锁就相当于相当于公钥，自己的钥匙就相当于私钥，下面我们开始用离散对数问题来构建我们的公钥和私钥。虽然在部分我会尽量写的详细，但是在开始之前，读者最好能对数论知识有个基本的了解，可以参数我之前的文章《【密码学】RSA算法解析-数论基础》 我们前面已经提到离散对数的问题，形如 memodN=cmemodN=c 我们在已知c和N和m的情况下很难图导出e.同样的道理，你在已知c和N和e,的情况下也很难推出来m,这就是一个典型的单项函数 &nbsp; m是明文，c是密文，e是加密的钥匙，d是解密的钥匙，按照我们上面的解释，在下面的加密解密过程都是严谨的单向过程 memodN=c公式1memodN=c公式1 我们找到一个d使下面的公式也成立 cdmodN=m公式2cdmodN=m公式2 1.接下来我们的目标就是找到合适的e和d,我们开始推导，将公式1带入到公式2中 （memodN）dmodN=m公式3（memodN）dmodN=m公式3 &nbsp; （me）dmodN=m公式4（me）dmodN=m公式4 &nbsp; medmodN=m公式5medmodN=m公式5 2.我们将一个数n的子集存在互质关系个数定义为φ(n),那么一个合数的公约数是不固定的，但是一个素数的公约数一定只有自己，所以对于素数φ(n) = n-1 这个求解过程叫欧拉函数，可以参考我之前的文章 3.欧拉函数主要应用在欧拉定理上，”欧拉定理”指的是：如果两个正整数m和N互质，则n的欧拉函数 φ(n) 可以让下面的等式成立： mϕ(n)≡1(modN)公式6mϕ(n)≡1(modN)公式6 转换后就是： mϕ(n)modN≡1公式7mϕ(n)modN≡1公式7 然后两边同时乘以m mϕ(n)+1modN≡m公式8mϕ(n)+1modN≡m公式8 有上面的公式5我们知道 medmodN=m公式5medmodN=m公式5 因此可以得出 medmodN=mϕ(n)+1modNmedmodN=mϕ(n)+1modN &nbsp; ed=ϕ(n)+1ed=ϕ(n)+1 &nbsp; ed−ϕ(n)y=1此处增加y表示任意数字ed−ϕ(n)y=1此处增加y表示任意数字 我们目前已经知道的条件，我们已知N，一般N都是两个素数的乘积，已经知道加密秘钥e,求解解密秘钥d 为了便于讲解，我们假设在这里N=77，则phi(n)=6∗10=60phi(n)=6∗10=60, e等于67，则计算过程如下， 67d−60y=167d−60y=1 以为y可以为负数，因此 这是有一个二项式的接，其实有多个答案，我们只需获取其中一个就可以，根据欧几里得拓展定理可以算出私钥d的值为43，计算机过程参考《【密码学】RSA算法解析-加密解密》 最终加密过程 7567≡c(mod77)7567≡c(mod77) 在计算机中可以很轻易的计算出c=26 解密过程 2643≡m(mod77)2643≡m(mod77) 在计算机中可以很轻易的计算出m=75 &nbsp; 演示代码 python源码地址： https://cloud.sagemath.com/projects/dc18d6fb-c4ae-47c4-8ea4-b2a1887ccb6b/files/RSA_CASE.sagews 到这里RSA完整的讲完了，虽然我已经写得很详细了，但是肯定还是有些读者不能完全理解，如果还是不能理解，建议先学习点数论的知识预热。 签名算法 我们在讨论签名算法之前，先来回忆一下之前讲的hash函数，我们有一份文件可以计算出他的Hash值，一旦文件被篡改做产生的Hash值也将变化，Hash函数解决了完整性的问题，然而并没有解决认证的问题，如果攻击者不但把文件给篡改了还把hash值给改了，这样接收者就察觉不到文件已经出了问题。 我们需要一种签名机制，这种签名机制能保证所有人都能对文件的完整性进行认证，同时又能验证这份文件确实是发送者发的，攻击者无法伪造这个签名。 设计原则 数字签名常常和哈希函数在一起使用，给定一段明文M，我们可以计算出明文的哈希值h(M),然后将哈希值进行某种加密S后，附在明文上，结构如下： M|S(h(M))M|S(h(M)) 在上述结构主要依赖于哈希值不存在对撞，即不同的明文之间不会存在相同的哈希值，实际上每种公钥加密体系都能实现，下面我们主要探究3种： Schnorr签名，Digital Signature Algorithm（数字证书签名），RSA签名 &nbsp; Schnorr签名 Schnorr签名是基于ElGamal算法的，它的安全性取决于离散对数的难题。 DSA签名 使用SHA哈希加密函数，它的安全性也取决于离散对数的难题。它是1990被提出，并且已经被US FIPS所接受，他的具体原理如下： 1.选择一个1024位的素数p,此时有一个群组ZpZp 2.选择另一个160位的素数q，q除以p-1和q都在群组GqGq中，并且群组GqGq属于ZpZp 3.其中要到的哈希算法是SHA-1秘钥生成： 1.选择p和q,条件就是上面所表达的，换成数学的表达方式就是p=zq+1p=zq+1&nbsp;并且z属于群组ZpZp 2.选择一个g，使下面的公式成立，jz=g(modp)jz=g(modp)&nbsp;并且&nbsp;1&lt;j&lt;p1&lt;j&lt;p 3.在范围1,…..q−11,…..q−1&nbsp;的选择一个随机数x 4.计算出来y=gxmodpy=gxmodp 5.其中公钥就是K1=(p,q,g,y)K1=(p,q,g,y),私钥就是K2=(p,q,g,x)K2=(p,q,g,x)签名过程： 1.在范围1,…..q−11,…..q−1的选择一个随机数r 2.计算出来s=(grmodp)modqs=(grmodp)modq 3.计算出t=((SHA−1(M)+xs)r−1)modqt=((SHA−1(M)+xs)r−1)modq 4.将签名结果(s,t)(s,t)附属在消息上。验签过程： 1.计算出u1=(SHA−1(M)t−1)modqu1=(SHA−1(M)t−1)modq 2.计算出u2=(s∗t−1)modqu2=(s∗t−1)modq 3.计算签名s1=((gu1yu2)modp)modqs1=((gu1yu2)modp)modq 4.比较s1s1是否与s相同 RSA签名 一种从RSA算法演变而来的签名，它的安全性取决大素数分解难题。下面我们来看看具体的实现过程秘钥生成 1.选择两个大素数，p和q 2.计算出他们的欧拉函数，ϕ(n)=(p−1)(q−1)ϕ(n)=(p−1)(q−1) 3.我们选择一个整数e&gt;1,并使gcd(e,ϕ(n))=1gcd(e,ϕ(n))=1&nbsp;即e要和欧拉函数（非公约的个数），互为素数。 4.我们使de=1(modϕ(n))de=1(modϕ(n))&nbsp;,根据欧几里得拓展定理计算出d. 5.然后我们就得到了公钥K1=(e,n)K1=(e,n)，然后对外发布公钥 6.私钥就是k2=dk2=d 签名过程： 我们假设需要加密的信息为M，其中M在1,,,,n−11,,,,n−1这个范围内，h为哈希加密函数，则签名的过程如下： s=h(M)dmodns=h(M)dmodn 验签过程： 计算出明文的哈希值h(M)比较h(M)是否和sensen相应，如果相同则验签成功。 &nbsp; 总结 本文主要阐述了密码学中的非对称密码和签名算法，不得不说对于一个开发人员来说，今天的讲解过的理论化，但是理论是实践的基础，不是吗？ 声明 本文45%为翻译组合,55%为原创 引用 http://www.jiamisoft.com/blog/index.php/3165-diffie-hellmanjiamisuanfa.html https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95 http://baike.baidu.com/link?url=14BKIalgIoeD2Wbq7X6rxUBoYrTEHlhxlX3x337N7_7qLaDh6XMK1MMStd5zIfROme-meST7ZJPQqWDjb7MgUJHxPiVeEJqeP2PB1i2eSNOZAzy_c-BgpCQLLUjn1GHg https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/checkpoint-advanced-lessons&nbsp;http://en.wikipedia.org/wiki/Cramer–Shoup_cryptosystem https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/01/30/3db49bfc6e723a42633a8246672ece4b.html" />
<meta property="og:url" content="https://mlh.app/2017/01/30/3db49bfc6e723a42633a8246672ece4b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"引文 密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。 在《一万字带您走进密码学的世界（上）》的文章中我们探讨了对称密码体系，哈希函数等技术，本文继续探讨密码学剩余的部分，本文的主要内容包括，非对称密码体系，签名算法等，因为本部分是区块链技术的基石，所以我会讲的更加详细一点，虽然我已经尽最大努力使思想简化，但是其中的数学理论对于很多人还是很晦涩，建议读者开始之前先读下数论的有关知识。本部分的主要结构如下： 非对称密码 前面的文章我们探讨了对称加密，在对称秘钥加密的体系中，加密和解密使用同一个秘钥，显而易见的是这种方式存在一个很严重的弊端，那就是秘钥的分发和管理，一旦秘钥在分发过程中被人窃取，加密形同虚设。秘钥的管理也相当繁琐，如下图，如果我们要同时与n个人通信，那么每个人都将保存n-1个秘钥。 非对称的存在的意义就是为了克服这些问题，在非对称秘钥体系中，通信双方各有一个公钥和私钥，加密者使用私钥进行加密，然后传递解密者，解密者使用对方的公钥直接就可以解开，不存在秘钥秘钥传递的问题，为了更好的解释这个问题，下面用个简单的例子讲解一下。 一个简单的例子 Alice和Bob用传统信件进行沟通，假设Alice和Bob不相信有邮政系统，他们想在通信的时候把信件用箱子锁住，并且在箱子外面加上一个锁。 在公钥加密体系中，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用钥匙打开，很显然，这个钥匙一定是alice钥匙的副本，不然打不开 在上面的例子中我们知道，秘钥交换是一定存在的，在沟通之前一定要进行秘钥的交换，那么有没有其他的方案可以不进行秘钥交换呢，答案是有的，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用锁锁上，然后在返回给Alice，这个时候盒子上是有两把锁的，然后Alice去掉自己的锁，这样盒子上就剩下Bob的一把锁了，然后在将盒子发给Bob，Bob用自己的钥匙打开自己的锁，就看到其中的消息。 上面的方法是可以实现不用秘钥交换，但是确定就是过于复杂，那么有没有更好的方式呢？在对称密码体系中，问题将变得简单，Bob直接将自己的打开的锁发给Alice，Alice收到锁后，然后用这个锁加密锁住装有消息的盒子，然后发给Bob，Bob可以很轻易的打开自己的锁。 在这个方法中一个重要的环节就是在已知Bob的锁和箱子的时候时候，没有BOb的钥匙是一定是打不开，在显示生活中很容易理解，可以在计算机的世界中如何寻找到这样合适的算法，目前已知的算法有两种，一种是基于离散对数的问题，另一种是椭圆曲线连对数问题，在下面的算法中我们着重讲解离散对数的问题。 Diffie-Hellman密钥交换 Diffie-Hellman密钥交换首次出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学，因此该算法通常称之为Diffie-Hellman密钥交换。这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密。 Diffie-Hellman加密算法的有效性依赖于计算离散对数的难度。简言之，可以如下定义离散对数： 首先定义一个素数p的原根，为其各次幂产生从1 到p-1的所有整数根，也就是说，如果a是素数p的一个原根，那么数值&nbsp;amodpamodp,a1modpa1modp,…,ap-1 mod p 是各不相同的整数，并且以某种排列方式组成了从1到p-1的所有整数。对于一个整数b和素数p的一个原根a，可以找到惟一的指数i，使得 b = ai mod p 其中0 ≤ i ≤ (p-1）指数i称为b的以a为基数的模p的离散对数或者指数，该值被记为inda，p(b)。 上面的一段引用看的一脸懵逼对吧，其实我也有又这样的感觉，我始终觉得一个优秀的学术工作者，要写出能读懂的文章，而不是别人看不懂的东西去彰显自己的高大上。好了就不吐槽了，我们开始用简单的例子解释上面的意思 首先说取摩运算，就是我们经常说的取余，比如我们对3对12进行取余就是3,9对12取余就是9,27对12取余就是3 简单点说：3xmod12=y3xmod12=y&nbsp;其中&nbsp;x∈(1,2,3…n)x∈(1,2,3…n)&nbsp;在这里如果我们已知x，可以很轻易的计算出y的值，及时x的值比较大，利用计算机也可以很轻易的算出，但是如果已经y,即使用高性能的计算机也很难计算出x,这就是离散对数的问题。 离散对数公钥加密算法是目前最为热门的公钥加密算法 ，其安全性要远远高于基于大数分解的RSA算法，首先说明一下上述三位科学家公钥密码体制的运作过程（假定A和B两个人要在一个不安全通道如因特网上形成密钥以备日后加密解密所用）。 首先，A、B两人要共同公开约定一个素数q和有限域Fq中的一个生成元g； A选定一个随机数a∈{1，2，…，q-1}（a可以认为是A之私钥），并将ga(modq)ga(modq)传送给B； B选定一个随机数b∈{1，2，…，q-1}（b可以认为是B之私钥），并将gb(modq)gb(modq)传送给A； 此时A可以算出(gb)a(modq)(gb)a(modq)，B也可以算出(ga)b(modq)(ga)b(modq)，由于(gb)a(modq)=(ga)b(modq)=gab(modq)(gb)a(modq)=(ga)b(modq)=gab(modq)， 因此，A和B就形成了一个公共的密钥gab(modq)gab(modq)，日后便可以此钥来进行传统的加密解密计算，从而达到在不安全的通道上进行保密通讯的目的。 显然，敌方可以截获到g，q，ga(modq)，gb(modq)g，q，ga(modq)，gb(modq)。因此，如果敌方有快速的求解离散对数的算法，就能从已截获的上述信息中迅速求出a或b，从而算出gab(modq)gab(modq)。遗憾的是，目前世界上根本就没有快速的求解离散对数的算法，因此当所选的有限域Fq很大时，a或b就很难算出。 Diffie-Hellman的算法举例可以参考我之前的文章《【密码学】Diffie-Hellman密钥交换》 ElGamal算法 在密码学中，ElGamal加密系统是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。 ElGamal加密算法可以定义在任何循环群GG&nbsp;上。它的安全性取决于&nbsp;GG&nbsp;上的离散对数难题。 ElGamal 加密被用于免费的GNU隐私保护软件、PGP 近期的版本和其他密码系统中 此部分的详细讲解，请看下篇文章《【密码学】ElGamal算法详解》 Cramer-Shoup 加密系统 Cramer–Shoup 系统是一个非对称秘钥加密算法，而且被证实是第一个针对适应性选择米文攻击所采用的标准加密猜想所用的安全有效的项目。其安全性是基于决定性Diffie–Hellman猜想的计算难解性（广泛接受，但未被证实）的计算难解性的。由 Ronald Cramer （罗纳德·克莱默）和 Victor Shoup （维克多·苏伯）于1998年研发，是 ElGamal 加密系统的延伸。与 ElGamal 相反，它具有很强的延展性，Cramer–Shoup 添加了另外的成分来确保甚至是遭受广泛的攻击时保证其非延展性。这一非延展性是通过使用抗撞击哈希函数和额外的计算而取得的，导致了密文是 ElGamal 的两倍大 ECC 椭圆曲线算法 椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开金钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。 ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。 RSA加密算法 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 因为此部分是区块链的算法结合比较紧密，我将花更多的篇幅讲解，从上面的讲解我们知道，我们需要构建一个锁和一把钥匙，然后将锁分配给每个人，然后自己保留钥匙，在这里这把锁就相当于相当于公钥，自己的钥匙就相当于私钥，下面我们开始用离散对数问题来构建我们的公钥和私钥。虽然在部分我会尽量写的详细，但是在开始之前，读者最好能对数论知识有个基本的了解，可以参数我之前的文章《【密码学】RSA算法解析-数论基础》 我们前面已经提到离散对数的问题，形如 memodN=cmemodN=c 我们在已知c和N和m的情况下很难图导出e.同样的道理，你在已知c和N和e,的情况下也很难推出来m,这就是一个典型的单项函数 &nbsp; m是明文，c是密文，e是加密的钥匙，d是解密的钥匙，按照我们上面的解释，在下面的加密解密过程都是严谨的单向过程 memodN=c公式1memodN=c公式1 我们找到一个d使下面的公式也成立 cdmodN=m公式2cdmodN=m公式2 1.接下来我们的目标就是找到合适的e和d,我们开始推导，将公式1带入到公式2中 （memodN）dmodN=m公式3（memodN）dmodN=m公式3 &nbsp; （me）dmodN=m公式4（me）dmodN=m公式4 &nbsp; medmodN=m公式5medmodN=m公式5 2.我们将一个数n的子集存在互质关系个数定义为φ(n),那么一个合数的公约数是不固定的，但是一个素数的公约数一定只有自己，所以对于素数φ(n) = n-1 这个求解过程叫欧拉函数，可以参考我之前的文章 3.欧拉函数主要应用在欧拉定理上，”欧拉定理”指的是：如果两个正整数m和N互质，则n的欧拉函数 φ(n) 可以让下面的等式成立： mϕ(n)≡1(modN)公式6mϕ(n)≡1(modN)公式6 转换后就是： mϕ(n)modN≡1公式7mϕ(n)modN≡1公式7 然后两边同时乘以m mϕ(n)+1modN≡m公式8mϕ(n)+1modN≡m公式8 有上面的公式5我们知道 medmodN=m公式5medmodN=m公式5 因此可以得出 medmodN=mϕ(n)+1modNmedmodN=mϕ(n)+1modN &nbsp; ed=ϕ(n)+1ed=ϕ(n)+1 &nbsp; ed−ϕ(n)y=1此处增加y表示任意数字ed−ϕ(n)y=1此处增加y表示任意数字 我们目前已经知道的条件，我们已知N，一般N都是两个素数的乘积，已经知道加密秘钥e,求解解密秘钥d 为了便于讲解，我们假设在这里N=77，则phi(n)=6∗10=60phi(n)=6∗10=60, e等于67，则计算过程如下， 67d−60y=167d−60y=1 以为y可以为负数，因此 这是有一个二项式的接，其实有多个答案，我们只需获取其中一个就可以，根据欧几里得拓展定理可以算出私钥d的值为43，计算机过程参考《【密码学】RSA算法解析-加密解密》 最终加密过程 7567≡c(mod77)7567≡c(mod77) 在计算机中可以很轻易的计算出c=26 解密过程 2643≡m(mod77)2643≡m(mod77) 在计算机中可以很轻易的计算出m=75 &nbsp; 演示代码 python源码地址： https://cloud.sagemath.com/projects/dc18d6fb-c4ae-47c4-8ea4-b2a1887ccb6b/files/RSA_CASE.sagews 到这里RSA完整的讲完了，虽然我已经写得很详细了，但是肯定还是有些读者不能完全理解，如果还是不能理解，建议先学习点数论的知识预热。 签名算法 我们在讨论签名算法之前，先来回忆一下之前讲的hash函数，我们有一份文件可以计算出他的Hash值，一旦文件被篡改做产生的Hash值也将变化，Hash函数解决了完整性的问题，然而并没有解决认证的问题，如果攻击者不但把文件给篡改了还把hash值给改了，这样接收者就察觉不到文件已经出了问题。 我们需要一种签名机制，这种签名机制能保证所有人都能对文件的完整性进行认证，同时又能验证这份文件确实是发送者发的，攻击者无法伪造这个签名。 设计原则 数字签名常常和哈希函数在一起使用，给定一段明文M，我们可以计算出明文的哈希值h(M),然后将哈希值进行某种加密S后，附在明文上，结构如下： M|S(h(M))M|S(h(M)) 在上述结构主要依赖于哈希值不存在对撞，即不同的明文之间不会存在相同的哈希值，实际上每种公钥加密体系都能实现，下面我们主要探究3种： Schnorr签名，Digital Signature Algorithm（数字证书签名），RSA签名 &nbsp; Schnorr签名 Schnorr签名是基于ElGamal算法的，它的安全性取决于离散对数的难题。 DSA签名 使用SHA哈希加密函数，它的安全性也取决于离散对数的难题。它是1990被提出，并且已经被US FIPS所接受，他的具体原理如下： 1.选择一个1024位的素数p,此时有一个群组ZpZp 2.选择另一个160位的素数q，q除以p-1和q都在群组GqGq中，并且群组GqGq属于ZpZp 3.其中要到的哈希算法是SHA-1秘钥生成： 1.选择p和q,条件就是上面所表达的，换成数学的表达方式就是p=zq+1p=zq+1&nbsp;并且z属于群组ZpZp 2.选择一个g，使下面的公式成立，jz=g(modp)jz=g(modp)&nbsp;并且&nbsp;1&lt;j&lt;p1&lt;j&lt;p 3.在范围1,…..q−11,…..q−1&nbsp;的选择一个随机数x 4.计算出来y=gxmodpy=gxmodp 5.其中公钥就是K1=(p,q,g,y)K1=(p,q,g,y),私钥就是K2=(p,q,g,x)K2=(p,q,g,x)签名过程： 1.在范围1,…..q−11,…..q−1的选择一个随机数r 2.计算出来s=(grmodp)modqs=(grmodp)modq 3.计算出t=((SHA−1(M)+xs)r−1)modqt=((SHA−1(M)+xs)r−1)modq 4.将签名结果(s,t)(s,t)附属在消息上。验签过程： 1.计算出u1=(SHA−1(M)t−1)modqu1=(SHA−1(M)t−1)modq 2.计算出u2=(s∗t−1)modqu2=(s∗t−1)modq 3.计算签名s1=((gu1yu2)modp)modqs1=((gu1yu2)modp)modq 4.比较s1s1是否与s相同 RSA签名 一种从RSA算法演变而来的签名，它的安全性取决大素数分解难题。下面我们来看看具体的实现过程秘钥生成 1.选择两个大素数，p和q 2.计算出他们的欧拉函数，ϕ(n)=(p−1)(q−1)ϕ(n)=(p−1)(q−1) 3.我们选择一个整数e&gt;1,并使gcd(e,ϕ(n))=1gcd(e,ϕ(n))=1&nbsp;即e要和欧拉函数（非公约的个数），互为素数。 4.我们使de=1(modϕ(n))de=1(modϕ(n))&nbsp;,根据欧几里得拓展定理计算出d. 5.然后我们就得到了公钥K1=(e,n)K1=(e,n)，然后对外发布公钥 6.私钥就是k2=dk2=d 签名过程： 我们假设需要加密的信息为M，其中M在1,,,,n−11,,,,n−1这个范围内，h为哈希加密函数，则签名的过程如下： s=h(M)dmodns=h(M)dmodn 验签过程： 计算出明文的哈希值h(M)比较h(M)是否和sensen相应，如果相同则验签成功。 &nbsp; 总结 本文主要阐述了密码学中的非对称密码和签名算法，不得不说对于一个开发人员来说，今天的讲解过的理论化，但是理论是实践的基础，不是吗？ 声明 本文45%为翻译组合,55%为原创 引用 http://www.jiamisoft.com/blog/index.php/3165-diffie-hellmanjiamisuanfa.html https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95 http://baike.baidu.com/link?url=14BKIalgIoeD2Wbq7X6rxUBoYrTEHlhxlX3x337N7_7qLaDh6XMK1MMStd5zIfROme-meST7ZJPQqWDjb7MgUJHxPiVeEJqeP2PB1i2eSNOZAzy_c-BgpCQLLUjn1GHg https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/checkpoint-advanced-lessons&nbsp;http://en.wikipedia.org/wiki/Cramer–Shoup_cryptosystem https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/01/30/3db49bfc6e723a42633a8246672ece4b.html","headline":"【密码学】一万字带您走进密码学的世界（下）","dateModified":"2017-01-30T00:00:00+08:00","datePublished":"2017-01-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/01/30/3db49bfc6e723a42633a8246672ece4b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【密码学】一万字带您走进密码学的世界（下）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2>引文</h2> 
  <blockquote> 
   <p>密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。</p> 
  </blockquote> 
  <p>在《一万字带您走进密码学的世界（上）》的文章中我们探讨了对称密码体系，哈希函数等技术，本文继续探讨密码学剩余的部分，本文的主要内容包括，非对称密码体系，签名算法等，因为本部分是区块链技术的基石，所以我会讲的更加详细一点，虽然我已经尽最大努力使思想简化，但是其中的数学理论对于很多人还是很晦涩，建议读者开始之前先读下数论的有关知识。本部分的主要结构如下：</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_6.jpg?t=2%3E" alt="图片名称"></p> 
  <h2>非对称密码</h2> 
  <p>前面的文章我们探讨了对称加密，在对称秘钥加密的体系中，加密和解密使用同一个秘钥，显而易见的是这种方式存在一个很严重的弊端，那就是秘钥的分发和管理，一旦秘钥在分发过程中被人窃取，加密形同虚设。秘钥的管理也相当繁琐，如下图，如果我们要同时与n个人通信，那么每个人都将保存n-1个秘钥。</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_0.jpg?t=2%3E" alt="图片名称"></p> 
  <p>非对称的存在的意义就是为了克服这些问题，在非对称秘钥体系中，通信双方各有一个公钥和私钥，加密者使用私钥进行加密，然后传递解密者，解密者使用对方的公钥直接就可以解开，不存在秘钥秘钥传递的问题，为了更好的解释这个问题，下面用个简单的例子讲解一下。</p> 
  <h3>一个简单的例子</h3> 
  <p>Alice和Bob用传统信件进行沟通，假设Alice和Bob不相信有邮政系统，他们想在通信的时候把信件用箱子锁住，并且在箱子外面加上一个锁。</p> 
  <p>在公钥加密体系中，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用钥匙打开，很显然，这个钥匙一定是alice钥匙的副本，不然打不开</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_1.png?t=2%3E" alt="图片名称"></p> 
  <p>在上面的例子中我们知道，秘钥交换是一定存在的，在沟通之前一定要进行秘钥的交换，那么有没有其他的方案可以不进行秘钥交换呢，答案是有的，Alice首先将消息放在盒子中，然后锁上盒子用她的钥匙，然后将盒子发给bob，Bob收到盒子后然后用锁锁上，然后在返回给Alice，这个时候盒子上是有两把锁的，然后Alice去掉自己的锁，这样盒子上就剩下Bob的一把锁了，然后在将盒子发给Bob，Bob用自己的钥匙打开自己的锁，就看到其中的消息。</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_2.png?t=2%3E" alt="图片名称"></p> 
  <p>上面的方法是可以实现不用秘钥交换，但是确定就是过于复杂，那么有没有更好的方式呢？在对称密码体系中，问题将变得简单，Bob直接将自己的打开的锁发给Alice，Alice收到锁后，然后用这个锁加密锁住装有消息的盒子，然后发给Bob，Bob可以很轻易的打开自己的锁。</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_3.png?t=2%3E" alt="图片名称"></p> 
  <p>在这个方法中一个重要的环节就是在已知Bob的锁和箱子的时候时候，没有BOb的钥匙是一定是打不开，在显示生活中很容易理解，可以在计算机的世界中如何寻找到这样合适的算法，目前已知的算法有两种，一种是基于离散对数的问题，另一种是椭圆曲线连对数问题，在下面的算法中我们着重讲解离散对数的问题。</p> 
  <h3>Diffie-Hellman密钥交换</h3> 
  <p>Diffie-Hellman密钥交换首次出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学，因此该算法通常称之为Diffie-Hellman密钥交换。这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密。</p> 
  <p>Diffie-Hellman加密算法的有效性依赖于计算离散对数的难度。简言之，可以如下定义离散对数：</p> 
  <blockquote> 
   <p class="has-jax">首先定义一个素数p的原根，为其各次幂产生从1 到p-1的所有整数根，也就是说，如果a是素数p的一个原根，那么数值&nbsp;<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">a<span class="mi">m<span class="mi">o<span class="mi">d<span class="mi">p</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">amodp,<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">a<span class="mn">1<span class="mi">m<span class="mi">o<span class="mi">d<span class="mi">p</span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">a1modp,…,ap-1 mod p 是各不相同的整数，并且以某种排列方式组成了从1到p-1的所有整数。对于一个整数b和素数p的一个原根a，可以找到惟一的指数i，使得 b = ai mod p 其中0 ≤ i ≤ (p-1）指数i称为b的以a为基数的模p的离散对数或者指数，该值被记为inda，p(b)。</span></span></span></span></p> 
  </blockquote> 
  <p>上面的一段引用看的一脸懵逼对吧，其实我也有又这样的感觉，我始终觉得一个优秀的学术工作者，要写出能读懂的文章，而不是别人看不懂的东西去彰显自己的高大上。好了就不吐槽了，我们开始用简单的例子解释上面的意思</p> 
  <p class="has-jax">首先说取摩运算，就是我们经常说的取余，比如我们对3对12进行取余就是3,9对12取余就是9,27对12取余就是3 简单点说：<br><span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mn">3<span class="mi">x<span class="mi">m<span class="mi">o<span class="mi">d<span class="mn">12<span class="mo">=<span class="mi">y</span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">3xmod12=y&nbsp;其中&nbsp;<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">x<span class="mo">∈<span class="mo">(<span class="mn">1<span class="mo">,<span class="mn">2<span class="mo">,<span class="mn">3<span class="mo">…<span class="mi">n<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">x∈(1,2,3…n)&nbsp;在这里如果我们已知x，可以很轻易的计算出y的值，及时x的值比较大，利用计算机也可以很轻易的算出，但是如果已经y,即使用高性能的计算机也很难计算出x,这就是离散对数的问题。</span></span></span></span></p> 
  <p>离散对数公钥加密算法是目前最为热门的公钥加密算法 ，其安全性要远远高于基于大数分解的RSA算法，首先说明一下上述三位科学家公钥密码体制的运作过程（假定A和B两个人要在一个不安全通道如因特网上形成密钥以备日后加密解密所用）。</p> 
  <p class="has-jax">首先，A、B两人要共同公开约定一个素数q和有限域Fq中的一个生成元g；<br> A选定一个随机数a∈{1，2，…，q-1}（a可以认为是A之私钥），并将<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">g<span class="mi">a<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">ga(modq)传送给B；<br> B选定一个随机数b∈{1，2，…，q-1}（b可以认为是B之私钥），并将<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">g<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">gb(modq)传送给A；<br> 此时A可以算出<span class="MathJax"><span class="math"><span class="mrow"><span class="mo">(<span class="msubsup"><span class="mi">g<span class="mi">b<span class="msubsup"><span class="mo">)<span class="mi">a<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">(gb)a(modq)，B也可以算出<span class="MathJax"><span class="math"><span class="mrow"><span class="mo">(<span class="msubsup"><span class="mi">g<span class="mi">a<span class="msubsup"><span class="mo">)<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">(ga)b(modq)，由于<br><span class="MathJax"><span class="math"><span class="mrow"><span class="mo">(<span class="msubsup"><span class="mi">g<span class="mi">b<span class="msubsup"><span class="mo">)<span class="mi">a<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)<span class="mo">=<span class="mo">(<span class="msubsup"><span class="mi">g<span class="mi">a<span class="msubsup"><span class="mo">)<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)<span class="mo">=<span class="msubsup"><span class="mi">g<span class="texatom"><span class="mrow"><span class="mi">a<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">(gb)a(modq)=(ga)b(modq)=gab(modq)，</span></span></span></span></span></span></span></span></span></span></p> 
  <p class="has-jax">因此，A和B就形成了一个公共的密钥<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">g<span class="texatom"><span class="mrow"><span class="mi">a<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">gab(modq)，日后便可以此钥来进行传统的加密解密计算，从而达到在不安全的通道上进行保密通讯的目的。 显然，敌方可以截获到<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">g<span class="texatom"><span class="mrow"><span class="mo">，<span class="mi">q<span class="texatom"><span class="mrow"><span class="mo">，<span class="msubsup"><span class="mi">g<span class="mi">a<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)<span class="texatom"><span class="mrow"><span class="mo">，<span class="msubsup"><span class="mi">g<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">g，q，ga(modq)，gb(modq)。因此，如果敌方有快速的求解离散对数的算法，就能从已截获的上述信息中迅速求出a或b，从而算出<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">g<span class="mi">a<span class="mi">b<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">gab(modq)。遗憾的是，目前世界上根本就没有快速的求解离散对数的算法，因此当所选的有限域Fq很大时，a或b就很难算出。<br> Diffie-Hellman的算法举例可以参考我之前的文章《【密码学】Diffie-Hellman密钥交换》</span></span></span></span></span></span></p> 
  <h3>ElGamal算法</h3> 
  <p class="has-jax">在密码学中，ElGamal加密系统是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。<br> ElGamal加密算法可以定义在任何循环群<span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mstyle"><span class="mrow"><span class="mi">G</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">G&nbsp;上。它的安全性取决于&nbsp;<span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mstyle"><span class="mrow"><span class="mi">G</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">G&nbsp;上的离散对数难题。<br> ElGamal 加密被用于免费的GNU隐私保护软件、PGP 近期的版本和其他密码系统中</span></span></span></span></p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_8.png?t=2%3E" alt="图片名称"></p> 
  <p>此部分的详细讲解，请看下篇文章《【密码学】ElGamal算法详解》</p> 
  <h3>Cramer-Shoup 加密系统</h3> 
  <p>Cramer–Shoup 系统是一个非对称秘钥加密算法，而且被证实是第一个针对适应性选择米文攻击所采用的标准加密猜想所用的安全有效的项目。其安全性是基于决定性Diffie–Hellman猜想的计算难解性（广泛接受，但未被证实）的计算难解性的。由 Ronald Cramer （罗纳德·克莱默）和 Victor Shoup （维克多·苏伯）于1998年研发，是 ElGamal 加密系统的延伸。与 ElGamal 相反，它具有很强的延展性，Cramer–Shoup 添加了另外的成分来确保甚至是遭受广泛的攻击时保证其非延展性。这一非延展性是通过使用抗撞击哈希函数和额外的计算而取得的，导致了密文是 ElGamal 的两倍大</p> 
  <h3>ECC 椭圆曲线算法</h3> 
  <p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为ECC），一种建立公开金钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p> 
  <p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。</p> 
  <h3>RSA加密算法</h3> 
  <p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_7.png?t=2%3E" alt="图片名称"></p> 
  <p>因为此部分是区块链的算法结合比较紧密，我将花更多的篇幅讲解，从上面的讲解我们知道，我们需要构建一个锁和一把钥匙，然后将锁分配给每个人，然后自己保留钥匙，在这里这把锁就相当于相当于公钥，自己的钥匙就相当于私钥，下面我们开始用离散对数问题来构建我们的公钥和私钥。虽然在部分我会尽量写的详细，但是在开始之前，读者最好能对数论知识有个基本的了解，可以参数我之前的文章《【密码学】RSA算法解析-数论基础》</p> 
  <p class="has-jax">我们前面已经提到离散对数的问题，形如</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="mi">e<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">c</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">memodN=c</span></span>
  </div> 
  <p><br> 我们在已知c和N和m的情况下很难图导出e.同样的道理，你在已知c和N和e,的情况下也很难推出来m,这就是一个典型的单项函数</p> 
  <p>&nbsp;</p> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_4.jpg?t=1%3E" alt="图片名称"></p> 
  <p class="has-jax"> m是明文，c是密文，e是加密的钥匙，d是解密的钥匙，按照我们上面的解释，在下面的加密解密过程都是严谨的单向过程</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="mi">e<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">c<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">memodN=c公式1</span></span>
  </div> 
  <p><br> 我们找到一个d使下面的公式也成立</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">c<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">cdmodN=m公式2</span></span>
  </div> 
  <p><br> 1.接下来我们的目标就是找到合适的e和d,我们开始推导，将公式1带入到公式2中</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mo">（<span class="msubsup"><span class="mi">m<span class="mi">e<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="msubsup"><span class="texatom"><span class="mrow"><span class="mo">）<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">3</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">（memodN）dmodN=m公式3</span></span>
  </div> 
  <p>&nbsp;</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mo">（<span class="msubsup"><span class="mi">m<span class="mi">e<span class="msubsup"><span class="texatom"><span class="mrow"><span class="mo">）<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">4</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">（me）dmodN=m公式4</span></span>
  </div> 
  <p>&nbsp;</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">e<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">5</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">medmodN=m公式5</span></span>
  </div> 
  <p><br> 2.我们将一个数n的子集存在互质关系个数定义为φ(n),那么一个合数的公约数是不固定的，但是一个素数的公约数一定只有自己，所以对于素数φ(n) = n-1 这个求解过程叫欧拉函数，可以参考我之前的文章<br> 3.欧拉函数主要应用在欧拉定理上，”欧拉定理”指的是：如果两个正整数m和N互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mo">≡<span class="mn">1<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">)<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">6</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">mϕ(n)≡1(modN)公式6</span></span>
  </div> 
  <p><br> 转换后就是：</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">≡<span class="mn">1<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">7</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">mϕ(n)modN≡1公式7</span></span>
  </div> 
  <p><br> 然后两边同时乘以m</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mo">+<span class="mn">1<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">≡<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">8</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">mϕ(n)+1modN≡m公式8</span></span>
  </div> 
  <p><br> 有上面的公式5我们知道</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">e<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="mi">m<span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">公<span class="texatom"><span class="mrow"><span class="mo">式<span class="mn">5</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">medmodN=m公式5</span></span>
  </div> 
  <p><br> 因此可以得出</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">e<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N<span class="mo">=<span class="msubsup"><span class="mi">m<span class="texatom"><span class="mrow"><span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mo">+<span class="mn">1<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">N</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">medmodN=mϕ(n)+1modN</span></span>
  </div> 
  <p>&nbsp;</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="mi">e<span class="mi">d<span class="mo">=<span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mo">+<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">ed=ϕ(n)+1</span></span>
  </div> 
  <p>&nbsp;</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="mi">e<span class="mi">d<span class="mo">−<span class="mi">ϕ<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mi">y<span class="mo">=<span class="mn">1<span class="mspace"><span class="mspace"><span class="mspace"><span class="texatom"><span class="mrow"><span class="mo">此<span class="texatom"><span class="mrow"><span class="mo">处<span class="texatom"><span class="mrow"><span class="mo">增<span class="texatom"><span class="mrow"><span class="mo">加<span class="mi">y<span class="texatom"><span class="mrow"><span class="mo">表<span class="texatom"><span class="mrow"><span class="mo">示<span class="texatom"><span class="mrow"><span class="mo">任<span class="texatom"><span class="mrow"><span class="mo">意<span class="texatom"><span class="mrow"><span class="mo">数<span class="texatom"><span class="mrow"><span class="mo">字</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">ed−ϕ(n)y=1此处增加y表示任意数字</span></span>
  </div> 
  <p><br> 我们目前已经知道的条件，我们已知N，一般N都是两个素数的乘积，已经知道加密秘钥e,求解解密秘钥d<br> 为了便于讲解，我们假设在这里N=77，则<span class="MathJax"><span class="MathJax"><span class="math"><span class="mrow"><span class="mi">p<span class="mi">h<span class="mi">i<span class="mo">(<span class="texatom"><span class="mrow"><span class="mi">n<span class="mo">)<span class="mo">=<span class="mn">6<span class="mo">∗<span class="mn">10<span class="mo">=<span class="mn">60</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">phi(n)=6∗10=60, e等于67，则计算过程如下，<br></span></span></span></p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="mn">67<span class="mi">d<span class="mo">−<span class="mn">60<span class="mi">y<span class="mo">=<span class="mn">1</span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">67d−60y=1</span></span>
  </div> 
  <p><span class="MathJax"><span class="MathJax"><span class="MJX_Assistive_MathML"><br> 以为y可以为负数，因此<br> 这是有一个二项式的接，其实有多个答案，我们只需获取其中一个就可以，根据欧几里得拓展定理可以算出私钥d的值为43，计算机过程参考《【密码学】RSA算法解析-加密解密》<br> 最终加密过程<br></span></span></span></p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mn">75<span class="texatom"><span class="mrow"><span class="mn">67<span class="mo">≡<span class="mi">c<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mn">77<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">7567≡c(mod77)</span></span>
  </div> 
  <p><span class="MathJax"><span class="MathJax"><span class="MJX_Assistive_MathML"><br> 在计算机中可以很轻易的计算出c=26<br> 解密过程<br></span></span></span></p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mn">26<span class="texatom"><span class="mrow"><span class="mn">43<span class="mo">≡<span class="mi">m<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mn">77<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">2643≡m(mod77)</span></span>
  </div> 
  <p><span class="MathJax"><span class="MathJax"><span class="MJX_Assistive_MathML"><br> 在计算机中可以很轻易的计算出m=75</span></span></span></p> 
  <p>&nbsp;</p> 
  <h4>演示代码</h4> 
  <p><img src="http://www.ehcoo.com/images/2017/01/cryptology1_5.jpg?t=2%3E" alt="图片名称"></p> 
  <p>python源码地址：<br> https://cloud.sagemath.com/projects/dc18d6fb-c4ae-47c4-8ea4-b2a1887ccb6b/files/RSA_CASE.sagews</p> 
  <p>到这里RSA完整的讲完了，虽然我已经写得很详细了，但是肯定还是有些读者不能完全理解，如果还是不能理解，建议先学习点数论的知识预热。</p> 
  <h2>签名算法</h2> 
  <p>我们在讨论签名算法之前，先来回忆一下之前讲的hash函数，我们有一份文件可以计算出他的Hash值，一旦文件被篡改做产生的Hash值也将变化，Hash函数解决了完整性的问题，然而并没有解决认证的问题，如果攻击者不但把文件给篡改了还把hash值给改了，这样接收者就察觉不到文件已经出了问题。</p> 
  <p>我们需要一种签名机制，这种签名机制能保证所有人都能对文件的完整性进行认证，同时又能验证这份文件确实是发送者发的，攻击者无法伪造这个签名。</p> 
  <h3>设计原则</h3> 
  <p class="has-jax">数字签名常常和哈希函数在一起使用，给定一段明文M，我们可以计算出明文的哈希值h(M),然后将哈希值进行某种加密S后，附在明文上，结构如下：</p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="mi">M<span class="texatom"><span class="mrow"><span class="mo">|<span class="mi">S<span class="mo">(<span class="mi">h<span class="mo">(<span class="mi">M<span class="mo">)<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">M|S(h(M))</span></span>
  </div> 
  <p><span class="MathJax"><span class="MathJax"><span class="MJX_Assistive_MathML"><br> 在上述结构主要依赖于哈希值不存在对撞，即不同的明文之间不会存在相同的哈希值，实际上每种公钥加密体系都能实现，下面我们主要探究3种： Schnorr签名，Digital Signature Algorithm（数字证书签名），RSA签名</span></span></span></p> 
  <p>&nbsp;</p> 
  <h3>Schnorr签名</h3> 
  <p>Schnorr签名是基于ElGamal算法的，它的安全性取决于离散对数的难题。</p> 
  <h3>DSA签名</h3> 
  <p class="has-jax"> 使用SHA哈希加密函数，它的安全性也取决于离散对数的难题。它是1990被提出，并且已经被US FIPS所接受，他的具体原理如下：<br> 1.选择一个1024位的素数p,此时有一个群组<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">Z<span class="mi">p</span></span></span></span></span><span class="MJX_Assistive_MathML">Zp<br> 2.选择另一个160位的素数q，q除以p-1和q都在群组<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">G<span class="mi">q</span></span></span></span></span><span class="MJX_Assistive_MathML">Gq中，并且群组<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">G<span class="mi">q</span></span></span></span></span><span class="MJX_Assistive_MathML">Gq属于<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">Z<span class="mi">p</span></span></span></span></span><span class="MJX_Assistive_MathML">Zp<br> 3.其中要到的哈希算法是SHA-1<br><strong>秘钥生成：</strong><br> 1.选择p和q,条件就是上面所表达的，换成数学的表达方式就是<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">p<span class="mo">=<span class="mi">z<span class="mi">q<span class="mo">+<span class="mn">1</span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">p=zq+1&nbsp;并且z属于群组<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">Z<span class="mi">p</span></span></span></span></span><span class="MJX_Assistive_MathML">Zp<br> 2.选择一个g，使下面的公式成立，<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">j<span class="mi">z<span class="mo">=<span class="mi">g<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">p<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">jz=g(modp)&nbsp;并且&nbsp;<span class="MathJax"><span class="math"><span class="mrow"><span class="mn">1<span class="mo">&lt;<span class="mi">j<span class="mo">&lt;<span class="mi">p</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">1&lt;j&lt;p<br> 3.在范围<span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mn">1<span class="mo">,<span class="mo">…<span class="mo">.<span class="mo">.<span class="mi">q<span class="mo">−<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">1,…..q−1&nbsp;的选择一个随机数x<br> 4.计算出来<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">y<span class="mo">=<span class="msubsup"><span class="mi">g<span class="mi">x<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">p</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">y=gxmodp<br> 5.其中公钥就是<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">K<span class="mn">1<span class="mo">=<span class="mo">(<span class="mi">p<span class="mo">,<span class="mi">q<span class="mo">,<span class="mi">g<span class="mo">,<span class="mi">y<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">K1=(p,q,g,y),私钥就是<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">K<span class="mn">2<span class="mo">=<span class="mo">(<span class="mi">p<span class="mo">,<span class="mi">q<span class="mo">,<span class="mi">g<span class="mo">,<span class="mi">x<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">K2=(p,q,g,x)<br><strong>签名过程：</strong><br> 1.在范围<span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mn">1<span class="mo">,<span class="mo">…<span class="mo">.<span class="mo">.<span class="mi">q<span class="mo">−<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">1,…..q−1的选择一个随机数r<br> 2.计算出来<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">s<span class="mo">=<span class="mo">(<span class="msubsup"><span class="mi">g<span class="mi">r<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">p<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">s=(grmodp)modq<br> 3.计算出<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">t<span class="mo">=<span class="mo">(<span class="mo">(<span class="mi">S<span class="mi">H<span class="mi">A<span class="mo">−<span class="mn">1<span class="mo">(<span class="mi">M<span class="mo">)<span class="mo">+<span class="mi">x<span class="mi">s<span class="mo">)<span class="msubsup"><span class="mi">r<span class="texatom"><span class="mrow"><span class="mo">−<span class="mn">1<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">t=((SHA−1(M)+xs)r−1)modq<br> 4.将签名结果<span class="MathJax"><span class="math"><span class="mrow"><span class="mo">(<span class="mi">s<span class="mo">,<span class="mi">t<span class="mo">)</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">(s,t)附属在消息上。<br><strong>验签过程：</strong><br> 1.计算出<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">u<span class="mn">1<span class="mo">=<span class="mo">(<span class="mi">S<span class="mi">H<span class="mi">A<span class="mo">−<span class="mn">1<span class="mo">(<span class="mi">M<span class="mo">)<span class="msubsup"><span class="mi">t<span class="texatom"><span class="mrow"><span class="mo">−<span class="mn">1<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">u1=(SHA−1(M)t−1)modq<br> 2.计算出<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">u<span class="mn">2<span class="mo">=<span class="mo">(<span class="mi">s<span class="mo">∗<span class="msubsup"><span class="mi">t<span class="texatom"><span class="mrow"><span class="mo">−<span class="mn">1<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">u2=(s∗t−1)modq<br> 3.计算签名<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">s<span class="mn">1<span class="mo">=<span class="mo">(<span class="mo">(<span class="msubsup"><span class="mi">g<span class="texatom"><span class="mrow"><span class="msubsup"><span class="mi">u<span class="mn">1<span class="msubsup"><span class="mi">y<span class="texatom"><span class="mrow"><span class="msubsup"><span class="mi">u<span class="mn">2<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">p<span class="mo">)<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">q</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">s1=((gu1yu2)modp)modq<br> 4.比较<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">s<span class="mn">1</span></span></span></span></span><span class="MJX_Assistive_MathML">s1是否与s相同</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
  <h3>RSA签名</h3> 
  <p class="has-jax">一种从RSA算法演变而来的签名，它的安全性取决大素数分解难题。下面我们来看看具体的实现过程<br><strong>秘钥生成</strong><br> 1.选择两个大素数，p和q<br> 2.计算出他们的欧拉函数，<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">ϕ<span class="mo">(<span class="mi">n<span class="mo">)<span class="mo">=<span class="mo">(<span class="mi">p<span class="mo">−<span class="mn">1<span class="mo">)<span class="mo">(<span class="mi">q<span class="mo">−<span class="mn">1<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">ϕ(n)=(p−1)(q−1)<br> 3.我们选择一个整数e&gt;1,并使<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">g<span class="mi">c<span class="mi">d<span class="mo">(<span class="mi">e<span class="mo">,<span class="mi">ϕ<span class="mo">(<span class="mi">n<span class="mo">)<span class="mo">)<span class="mo">=<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">gcd(e,ϕ(n))=1&nbsp;即e要和欧拉函数（非公约的个数），互为素数。<br> 4.我们使<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">d<span class="mi">e<span class="mo">=<span class="mn">1<span class="mo">(<span class="mi">m<span class="mi">o<span class="mi">d<span class="mi">ϕ<span class="mo">(<span class="mi">n<span class="mo">)<span class="mo">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">de=1(modϕ(n))&nbsp;,根据欧几里得拓展定理计算出d.<br> 5.然后我们就得到了公钥<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">K<span class="mn">1<span class="mo">=<span class="mo">(<span class="mi">e<span class="mo">,<span class="mi">n<span class="mo">)</span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">K1=(e,n)，然后对外发布公钥<br> 6.私钥就是<span class="MathJax"><span class="math"><span class="mrow"><span class="mi">k<span class="mn">2<span class="mo">=<span class="mi">d</span></span></span></span></span></span><span class="MJX_Assistive_MathML">k2=d</span></span></span></span></span></span></span></span></span></span></p> 
  <p class="has-jax"><strong>签名过程：</strong><br> 我们假设需要加密的信息为M，其中M在<span class="MathJax"><span class="math"><span class="mrow"><span class="texatom"><span class="mrow"><span class="mn">1<span class="mo">,<span class="mo">,<span class="mo">,<span class="mo">,<span class="mi">n<span class="mo">−<span class="mn">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">1,,,,n−1这个范围内，h为哈希加密函数，则签名的过程如下：<br></span></span></p> 
  <div class="MathJax_Display">
   <span class="MathJax"><span class="math"><span class="mrow"><span class="mi">s<span class="mo">=<span class="mi">h<span class="mo">(<span class="mi">M<span class="msubsup"><span class="mo">)<span class="mi">d<span class="mi">m<span class="mi">o<span class="mi">d<span class="mspace"><span class="mi">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">s=h(M)dmodn</span></span>
  </div> 
  <p><span class="MathJax"><span class="MathJax"><span class="MJX_Assistive_MathML"><br><strong>验签过程：</strong><br> 计算出明文的哈希值h(M)比较h(M)是否和<span class="MathJax"><span class="math"><span class="mrow"><span class="msubsup"><span class="mi">s<span class="mi">e<span class="mspace"><span class="mi">n</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">sen相应，如果相同则验签成功。</span></span></span></span></span></p> 
  <p>&nbsp;</p> 
  <h2>总结</h2> 
  <p>本文主要阐述了密码学中的<span style="color:#00ffff;">非对称密码和签名算法</span>，不得不说对于一个开发人员来说，今天的讲解过的理论化，但是理论是实践的基础，不是吗？</p> 
  <h2>声明</h2> 
  <p>本文45%为翻译组合,<strong>55%为原创</strong></p> 
  <h2>引用</h2> 
  <p>http://www.jiamisoft.com/blog/index.php/3165-diffie-hellmanjiamisuanfa.html<br> https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95<br> http://baike.baidu.com/link?url=14BKIalgIoeD2Wbq7X6rxUBoYrTEHlhxlX3x337N7_7qLaDh6XMK1MMStd5zIfROme-meST7ZJPQqWDjb7MgUJHxPiVeEJqeP2PB1i2eSNOZAzy_c-BgpCQLLUjn1GHg<br> https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/checkpoint-advanced-lessons&nbsp;http://en.wikipedia.org/wiki/Cramer–Shoup_cryptosystem<br> https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ppf19159/article/details/54782717,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ppf19159/article/details/54782717,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
