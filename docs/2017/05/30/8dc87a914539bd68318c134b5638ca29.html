<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链开发专题(P2P技术如何验证消息) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链开发专题(P2P技术如何验证消息)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链爱好者（QQ：53016353） &nbsp; 摘要：我们提出了一个使用低可靠性分布式 P2P 协议的系统，使用户能够安全地发送/接收消息，订阅/广播消息。除了一个相对较短（约 36 字符）的地址，用户无需交换任何其它数据即可确保安全性，不需要任何公钥和私钥的概念即可使用该系统。它还被设计成掩盖非消息内容的数据，如那些通信内容并不包括的消息发送者和接收者的信息。 1、介绍 电子邮件是普及而不安全的。发送加密邮件的能力是有必要的，但目前的解决方案对人们来说难以使用：用户必须通过可信的渠道（如当面或通过电话）交换电子邮件地址和密钥。除非是须特别关注的邮件内容，否则即使那些知道如何使用 PGP/GPG 等工具的用户，也很少努力这样做。新手学习使用这些软件会有一个困难的过程，因为公私钥对之间关系、它们的用途等是陌生的概念。即使用户确实已经使用 PGP/GPG 进行通信，单靠加密并不能隐蔽消息的发送者和接收者。一些国家的政府机构正在收集所有私人的详细呼叫记录，并将它们存储在大型数据库中用于社交网络分析[1] [2] [3]。没有什么能阻止他们收集电话和消息内容，确实有官员告诉纽约时报，美国国家安全局已在从事“过分的收集”[4]。隐藏自己的身份是困难的。即使放弃常用的电子邮件地址，用户也必须连接到一个邮件服务器来发送和接收消息，即暴露自己的 IP 地址。如果人们使用 Tor 连接 Web 服务器，它们的安全依赖于 X.509 系统。该系统已使 HTTPS.X.509 证书当局在最近几年遭受黑客袭击，其中包括在伊朗使用欺诈性的但数字签名有效的证书——该证书由已被黑客攻击的证书颁发机构（DigiNotar）签署——针对其公民使用诸如 Gmail 等谷歌服务进行 man-in-the-middle 攻击[5] [6]。由于 HTTPS 的安全性只与可靠的或合格的证书颁发机构的安全性相同，事实上， Windows或 Firefox 浏览器信任的 CA 证书有超过 1000 个，为数百个不同的组织[7]所拥有，这会对所有用户造成极大困扰。另外，即使如果这些组织中只有一个由政府机构运行，并且如果他们有一定的网络硬件位于用户服务器和目标服务器之间，那么他们将能够随意对看似安全的通信进行有针对性的 man-in-the-middle 攻击。现在所需要的是一种通信协议及其软件：可以对消息进行加密，消息的发送者和接收者对其他人隐蔽，并保证消息的发送者是不能伪造的，没有信任依赖，密钥管理的细节不加重用户的负担。在本文中，我们提出了这样的协议。 2、认证 我们提出了一个系统，用户交换一个公钥的哈希值——也是用户的地址。如果公钥可以通过底层协议，那么它可以很容易地被哈希验证为它预期所属的收件人。由用户交换的数据包括一个版本号（表示转发能力）、一个流数（其目的将在后面讨论）和一个校验和。用 base58 编码 ， 并 在 前 面 加 上 识 别 字 符 （ 如 Bitmessage 的 BM ）， 例 如 地 址 是 ：BM-2nTX1KchxgnmHvy9ntCN9r7sgKTraxczzyE。比电子邮件地址复杂的部分，理所当然的被制作成没有太多的手动输入，也可以制成 QR 码。用户已经证明这一点是可以接受的，比如类似Bitcoin 的地址格式、长度[8]。此地址格式对电子邮件来说是优越的，因为它保证了消息明确来自于一个特定的用户或组织。消息发送者无法被伪造。 3、消息传递 我们提出了一个消息传递机制，类似于比特币的交易和块传输系统[8]，但每条消息都有工作证明。用户之间通过运行 Bitmessage 客户端，形成一个 P2P 网络，并尽最大努力转发邮件。为了通过网络发送邮件，必须完成一个哈希碰撞形式的工作证明。工作证明的难度应该和该消息的大小成正比，并应设置成一个典型大小的消息发送须一台普通计算机平均花费四分钟。随着软件进步，工作证明的难度可以调节。每个消息都必须包括时间戳，以防止恶意流量攻击。如果消息的时间戳太旧，网络节点不会转发。如果消息发送者没有收到确认信息，并希望重发消息，他必须更新时间戳并重新计算工作证明。像 Bitcoin 的交易和区块一样，所有用户都将收到所有消息，并尝试用各自的私钥解码每条消息以确认消息接受者是自己。 4、可扩展性 如果所有节点接收所有消息，自然要关注系统的可扩展性。为了解决这个问题，我们建议，在消息发送通过 Bitmessage 网络的数量达到了一定的阈值时，节点开始自我分离到大集群或流。用户开始将只使用流 1，流数被编码到每一个地址，流被布置在一个层次。 一个 Bitmessage 客户端会占用可以忽略不计的的硬盘空间和运算处理能力。一旦开始超过合理阈值，新的地址会在子流里建立，创建这些地址的节点会把自己视为该流中的一个并共同动作。从这时起，如果该节点在父流中没有活动地址，就只需要保持与子流中的节点连接。除了流 1（根流）中的节点，节点应该偶尔连接父流节点以通报它们的存在。每个节点都应该维护一个列表，其中包含它的流和两个子流中的对等节点。要发送一个消息，节点必须首先连接 Bitmessage 地址中的流编码。如果不知道目标流中的任何节点，则连接到最近的父流，然后下载自己所在的两个子流的列表。然后，可以连接到子流，并继续该过程直到到达目标流。在消息发送并收到确认后，可以断开与该流中节点的连接。如果用户回复消息，他们的Bitmessage 的客户端重复同样的过程，连接到原发件人的流。在完成一次该连接过程后，因为发送节点已经保存了流节点列表，第二次连接目标流节点就微不足道了。父流和子流运算公式很简单： 5、广播 因为所有用户会收到所有邮件，该系统自然衍伸支持广播消息。通过口口相传，用户接收他们感兴趣的广播发布的内容。把广播的 Bitmessage 地址加入 Bitmessage 客户端的“订阅”部分，广播的消息会出现在用户的收件箱中，或出现在另一个支持 Bitmessage 协议的其它用途的应用程序中。这将允许任何个人或机构用已经验证的身份，向每个希望收听的人匿名广播。 6、接收器离线时的行为 一个公钥请求的对象，一个公钥，一条个人对个人的消息，或一条广播消息。对象经过整个 Bitmessage 流转播。我们提出节点把所有对象存储两天，然后删除。加入网络的节点向对等节点请求自己没有的对象列表。这样，它将收到两天内所有发向它的转播消息。如果某个节点离线超过两天，发送节点会注意到从来没有收到它的确认，并在另一个两天后重播消息。这将按照指数退避算法永远继续重播消息。在最坏的情况下，如果一个用户处于离线状态 n 天，那么他必须重新在线并保持连接 n 天（或每两天连接一次，保持 n 天），以获得他的所有消息。 7、被动工作模式 有特别偏执的人，希望通过指定一个完全被动模式（标志连接他的公钥）接收邮件而不回复确认。也许，对他明智是，由另一个可能的随机节点代替他的节点回复确认，而其它节点甚至都没有意识到自己已经为他此目的服务。假设 Alice 向 Bradley 发送一条消息，但 Bradley 过于偏执不回复确认，因为他担心攻击者Eve 窃听他的详细 Internet 连接并试图找到他。Eve 可能看到 Bradley 的回复确认从他的机器发出比从其他机器发出的早，这表明他在该位置运行。Bradley 可能反而选择把确认打包进另一条消息，并发送给他的一个朋友或一个随机的 Bitmessage 公钥（假设是 Charlie 的）。如果 Charlie在线，他将立刻在一次广播中同时承认这两个确认。Bradley 也可以选择把他的公钥分发，广播或按他的方式请求公钥。例如，他可以把他的公钥作为确认数据，包含在他发送给朋友的下一条消息中或在一封发给 Charlie 的空白邮件中。这将有助于同时确认收到 Bradley 的消息，并且他公钥的分发无需源于他未加密的互联网连接。即使 Eve 监测 Charlie 的互联网连接，她也不会知道 Bradley 是否真正在该位置（或者可能 Bradley 和 Charlie 可能实际上是同一个人）。事实上，Bradley 可能不在当地，或者 Bradley 和 Charlie 甚至不认识彼此。即使大多数人都不会使用这种操作模式，现实中人们却很可能提供那些似是而非的身份指认或否认。 8、垃圾 现有的工作证明请求可能足以使垃圾邮件制造者不经济。如果不是，有这样几个行为可采用： ◆增加工作证明的难度。 ◆为实际使用的公钥，给每个客户端分配ｘ个公钥。确认消息绑定这些公钥，但从来不向用户显示消息。垃圾邮件制造者将需要ｘ倍的计算量来发送垃圾消息。 ◆包含冗余位的 Bitmessage 地址，并要求这些位被包含在消息中，从而证明了发送者的 Bitmessage 地址。包含两个字节的冗余位，会使一个 Bitmessage 地址长度延长 9％，但垃圾邮件制造者将需要 65536 倍的计算量。搜索引擎抓取网页寻找 Bitmessage 地址将阻碍该选项。 9、结论 我们已经提出了一个系统，不仅桥接了电子邮件易用性和 PGP/GPG 安全性之间的差距，也隐藏了对“非内容”数据的窥探。不用被迫相信会犯错（或恶意）的中心，因此而保有隐私的获益应该大于抵消使用一个非人本友好的地址所造成的麻烦。广播和订阅功能，对任何希望经常匿名发布内容的人，是特别有用的。搭配 BitTorrent 协议，个人可以发布任何尺寸的内容。 阅读更多" />
<meta property="og:description" content="区块链爱好者（QQ：53016353） &nbsp; 摘要：我们提出了一个使用低可靠性分布式 P2P 协议的系统，使用户能够安全地发送/接收消息，订阅/广播消息。除了一个相对较短（约 36 字符）的地址，用户无需交换任何其它数据即可确保安全性，不需要任何公钥和私钥的概念即可使用该系统。它还被设计成掩盖非消息内容的数据，如那些通信内容并不包括的消息发送者和接收者的信息。 1、介绍 电子邮件是普及而不安全的。发送加密邮件的能力是有必要的，但目前的解决方案对人们来说难以使用：用户必须通过可信的渠道（如当面或通过电话）交换电子邮件地址和密钥。除非是须特别关注的邮件内容，否则即使那些知道如何使用 PGP/GPG 等工具的用户，也很少努力这样做。新手学习使用这些软件会有一个困难的过程，因为公私钥对之间关系、它们的用途等是陌生的概念。即使用户确实已经使用 PGP/GPG 进行通信，单靠加密并不能隐蔽消息的发送者和接收者。一些国家的政府机构正在收集所有私人的详细呼叫记录，并将它们存储在大型数据库中用于社交网络分析[1] [2] [3]。没有什么能阻止他们收集电话和消息内容，确实有官员告诉纽约时报，美国国家安全局已在从事“过分的收集”[4]。隐藏自己的身份是困难的。即使放弃常用的电子邮件地址，用户也必须连接到一个邮件服务器来发送和接收消息，即暴露自己的 IP 地址。如果人们使用 Tor 连接 Web 服务器，它们的安全依赖于 X.509 系统。该系统已使 HTTPS.X.509 证书当局在最近几年遭受黑客袭击，其中包括在伊朗使用欺诈性的但数字签名有效的证书——该证书由已被黑客攻击的证书颁发机构（DigiNotar）签署——针对其公民使用诸如 Gmail 等谷歌服务进行 man-in-the-middle 攻击[5] [6]。由于 HTTPS 的安全性只与可靠的或合格的证书颁发机构的安全性相同，事实上， Windows或 Firefox 浏览器信任的 CA 证书有超过 1000 个，为数百个不同的组织[7]所拥有，这会对所有用户造成极大困扰。另外，即使如果这些组织中只有一个由政府机构运行，并且如果他们有一定的网络硬件位于用户服务器和目标服务器之间，那么他们将能够随意对看似安全的通信进行有针对性的 man-in-the-middle 攻击。现在所需要的是一种通信协议及其软件：可以对消息进行加密，消息的发送者和接收者对其他人隐蔽，并保证消息的发送者是不能伪造的，没有信任依赖，密钥管理的细节不加重用户的负担。在本文中，我们提出了这样的协议。 2、认证 我们提出了一个系统，用户交换一个公钥的哈希值——也是用户的地址。如果公钥可以通过底层协议，那么它可以很容易地被哈希验证为它预期所属的收件人。由用户交换的数据包括一个版本号（表示转发能力）、一个流数（其目的将在后面讨论）和一个校验和。用 base58 编码 ， 并 在 前 面 加 上 识 别 字 符 （ 如 Bitmessage 的 BM ）， 例 如 地 址 是 ：BM-2nTX1KchxgnmHvy9ntCN9r7sgKTraxczzyE。比电子邮件地址复杂的部分，理所当然的被制作成没有太多的手动输入，也可以制成 QR 码。用户已经证明这一点是可以接受的，比如类似Bitcoin 的地址格式、长度[8]。此地址格式对电子邮件来说是优越的，因为它保证了消息明确来自于一个特定的用户或组织。消息发送者无法被伪造。 3、消息传递 我们提出了一个消息传递机制，类似于比特币的交易和块传输系统[8]，但每条消息都有工作证明。用户之间通过运行 Bitmessage 客户端，形成一个 P2P 网络，并尽最大努力转发邮件。为了通过网络发送邮件，必须完成一个哈希碰撞形式的工作证明。工作证明的难度应该和该消息的大小成正比，并应设置成一个典型大小的消息发送须一台普通计算机平均花费四分钟。随着软件进步，工作证明的难度可以调节。每个消息都必须包括时间戳，以防止恶意流量攻击。如果消息的时间戳太旧，网络节点不会转发。如果消息发送者没有收到确认信息，并希望重发消息，他必须更新时间戳并重新计算工作证明。像 Bitcoin 的交易和区块一样，所有用户都将收到所有消息，并尝试用各自的私钥解码每条消息以确认消息接受者是自己。 4、可扩展性 如果所有节点接收所有消息，自然要关注系统的可扩展性。为了解决这个问题，我们建议，在消息发送通过 Bitmessage 网络的数量达到了一定的阈值时，节点开始自我分离到大集群或流。用户开始将只使用流 1，流数被编码到每一个地址，流被布置在一个层次。 一个 Bitmessage 客户端会占用可以忽略不计的的硬盘空间和运算处理能力。一旦开始超过合理阈值，新的地址会在子流里建立，创建这些地址的节点会把自己视为该流中的一个并共同动作。从这时起，如果该节点在父流中没有活动地址，就只需要保持与子流中的节点连接。除了流 1（根流）中的节点，节点应该偶尔连接父流节点以通报它们的存在。每个节点都应该维护一个列表，其中包含它的流和两个子流中的对等节点。要发送一个消息，节点必须首先连接 Bitmessage 地址中的流编码。如果不知道目标流中的任何节点，则连接到最近的父流，然后下载自己所在的两个子流的列表。然后，可以连接到子流，并继续该过程直到到达目标流。在消息发送并收到确认后，可以断开与该流中节点的连接。如果用户回复消息，他们的Bitmessage 的客户端重复同样的过程，连接到原发件人的流。在完成一次该连接过程后，因为发送节点已经保存了流节点列表，第二次连接目标流节点就微不足道了。父流和子流运算公式很简单： 5、广播 因为所有用户会收到所有邮件，该系统自然衍伸支持广播消息。通过口口相传，用户接收他们感兴趣的广播发布的内容。把广播的 Bitmessage 地址加入 Bitmessage 客户端的“订阅”部分，广播的消息会出现在用户的收件箱中，或出现在另一个支持 Bitmessage 协议的其它用途的应用程序中。这将允许任何个人或机构用已经验证的身份，向每个希望收听的人匿名广播。 6、接收器离线时的行为 一个公钥请求的对象，一个公钥，一条个人对个人的消息，或一条广播消息。对象经过整个 Bitmessage 流转播。我们提出节点把所有对象存储两天，然后删除。加入网络的节点向对等节点请求自己没有的对象列表。这样，它将收到两天内所有发向它的转播消息。如果某个节点离线超过两天，发送节点会注意到从来没有收到它的确认，并在另一个两天后重播消息。这将按照指数退避算法永远继续重播消息。在最坏的情况下，如果一个用户处于离线状态 n 天，那么他必须重新在线并保持连接 n 天（或每两天连接一次，保持 n 天），以获得他的所有消息。 7、被动工作模式 有特别偏执的人，希望通过指定一个完全被动模式（标志连接他的公钥）接收邮件而不回复确认。也许，对他明智是，由另一个可能的随机节点代替他的节点回复确认，而其它节点甚至都没有意识到自己已经为他此目的服务。假设 Alice 向 Bradley 发送一条消息，但 Bradley 过于偏执不回复确认，因为他担心攻击者Eve 窃听他的详细 Internet 连接并试图找到他。Eve 可能看到 Bradley 的回复确认从他的机器发出比从其他机器发出的早，这表明他在该位置运行。Bradley 可能反而选择把确认打包进另一条消息，并发送给他的一个朋友或一个随机的 Bitmessage 公钥（假设是 Charlie 的）。如果 Charlie在线，他将立刻在一次广播中同时承认这两个确认。Bradley 也可以选择把他的公钥分发，广播或按他的方式请求公钥。例如，他可以把他的公钥作为确认数据，包含在他发送给朋友的下一条消息中或在一封发给 Charlie 的空白邮件中。这将有助于同时确认收到 Bradley 的消息，并且他公钥的分发无需源于他未加密的互联网连接。即使 Eve 监测 Charlie 的互联网连接，她也不会知道 Bradley 是否真正在该位置（或者可能 Bradley 和 Charlie 可能实际上是同一个人）。事实上，Bradley 可能不在当地，或者 Bradley 和 Charlie 甚至不认识彼此。即使大多数人都不会使用这种操作模式，现实中人们却很可能提供那些似是而非的身份指认或否认。 8、垃圾 现有的工作证明请求可能足以使垃圾邮件制造者不经济。如果不是，有这样几个行为可采用： ◆增加工作证明的难度。 ◆为实际使用的公钥，给每个客户端分配ｘ个公钥。确认消息绑定这些公钥，但从来不向用户显示消息。垃圾邮件制造者将需要ｘ倍的计算量来发送垃圾消息。 ◆包含冗余位的 Bitmessage 地址，并要求这些位被包含在消息中，从而证明了发送者的 Bitmessage 地址。包含两个字节的冗余位，会使一个 Bitmessage 地址长度延长 9％，但垃圾邮件制造者将需要 65536 倍的计算量。搜索引擎抓取网页寻找 Bitmessage 地址将阻碍该选项。 9、结论 我们已经提出了一个系统，不仅桥接了电子邮件易用性和 PGP/GPG 安全性之间的差距，也隐藏了对“非内容”数据的窥探。不用被迫相信会犯错（或恶意）的中心，因此而保有隐私的获益应该大于抵消使用一个非人本友好的地址所造成的麻烦。广播和订阅功能，对任何希望经常匿名发布内容的人，是特别有用的。搭配 BitTorrent 协议，个人可以发布任何尺寸的内容。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/05/30/8dc87a914539bd68318c134b5638ca29.html" />
<meta property="og:url" content="https://mlh.app/2017/05/30/8dc87a914539bd68318c134b5638ca29.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-05-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链爱好者（QQ：53016353） &nbsp; 摘要：我们提出了一个使用低可靠性分布式 P2P 协议的系统，使用户能够安全地发送/接收消息，订阅/广播消息。除了一个相对较短（约 36 字符）的地址，用户无需交换任何其它数据即可确保安全性，不需要任何公钥和私钥的概念即可使用该系统。它还被设计成掩盖非消息内容的数据，如那些通信内容并不包括的消息发送者和接收者的信息。 1、介绍 电子邮件是普及而不安全的。发送加密邮件的能力是有必要的，但目前的解决方案对人们来说难以使用：用户必须通过可信的渠道（如当面或通过电话）交换电子邮件地址和密钥。除非是须特别关注的邮件内容，否则即使那些知道如何使用 PGP/GPG 等工具的用户，也很少努力这样做。新手学习使用这些软件会有一个困难的过程，因为公私钥对之间关系、它们的用途等是陌生的概念。即使用户确实已经使用 PGP/GPG 进行通信，单靠加密并不能隐蔽消息的发送者和接收者。一些国家的政府机构正在收集所有私人的详细呼叫记录，并将它们存储在大型数据库中用于社交网络分析[1] [2] [3]。没有什么能阻止他们收集电话和消息内容，确实有官员告诉纽约时报，美国国家安全局已在从事“过分的收集”[4]。隐藏自己的身份是困难的。即使放弃常用的电子邮件地址，用户也必须连接到一个邮件服务器来发送和接收消息，即暴露自己的 IP 地址。如果人们使用 Tor 连接 Web 服务器，它们的安全依赖于 X.509 系统。该系统已使 HTTPS.X.509 证书当局在最近几年遭受黑客袭击，其中包括在伊朗使用欺诈性的但数字签名有效的证书——该证书由已被黑客攻击的证书颁发机构（DigiNotar）签署——针对其公民使用诸如 Gmail 等谷歌服务进行 man-in-the-middle 攻击[5] [6]。由于 HTTPS 的安全性只与可靠的或合格的证书颁发机构的安全性相同，事实上， Windows或 Firefox 浏览器信任的 CA 证书有超过 1000 个，为数百个不同的组织[7]所拥有，这会对所有用户造成极大困扰。另外，即使如果这些组织中只有一个由政府机构运行，并且如果他们有一定的网络硬件位于用户服务器和目标服务器之间，那么他们将能够随意对看似安全的通信进行有针对性的 man-in-the-middle 攻击。现在所需要的是一种通信协议及其软件：可以对消息进行加密，消息的发送者和接收者对其他人隐蔽，并保证消息的发送者是不能伪造的，没有信任依赖，密钥管理的细节不加重用户的负担。在本文中，我们提出了这样的协议。 2、认证 我们提出了一个系统，用户交换一个公钥的哈希值——也是用户的地址。如果公钥可以通过底层协议，那么它可以很容易地被哈希验证为它预期所属的收件人。由用户交换的数据包括一个版本号（表示转发能力）、一个流数（其目的将在后面讨论）和一个校验和。用 base58 编码 ， 并 在 前 面 加 上 识 别 字 符 （ 如 Bitmessage 的 BM ）， 例 如 地 址 是 ：BM-2nTX1KchxgnmHvy9ntCN9r7sgKTraxczzyE。比电子邮件地址复杂的部分，理所当然的被制作成没有太多的手动输入，也可以制成 QR 码。用户已经证明这一点是可以接受的，比如类似Bitcoin 的地址格式、长度[8]。此地址格式对电子邮件来说是优越的，因为它保证了消息明确来自于一个特定的用户或组织。消息发送者无法被伪造。 3、消息传递 我们提出了一个消息传递机制，类似于比特币的交易和块传输系统[8]，但每条消息都有工作证明。用户之间通过运行 Bitmessage 客户端，形成一个 P2P 网络，并尽最大努力转发邮件。为了通过网络发送邮件，必须完成一个哈希碰撞形式的工作证明。工作证明的难度应该和该消息的大小成正比，并应设置成一个典型大小的消息发送须一台普通计算机平均花费四分钟。随着软件进步，工作证明的难度可以调节。每个消息都必须包括时间戳，以防止恶意流量攻击。如果消息的时间戳太旧，网络节点不会转发。如果消息发送者没有收到确认信息，并希望重发消息，他必须更新时间戳并重新计算工作证明。像 Bitcoin 的交易和区块一样，所有用户都将收到所有消息，并尝试用各自的私钥解码每条消息以确认消息接受者是自己。 4、可扩展性 如果所有节点接收所有消息，自然要关注系统的可扩展性。为了解决这个问题，我们建议，在消息发送通过 Bitmessage 网络的数量达到了一定的阈值时，节点开始自我分离到大集群或流。用户开始将只使用流 1，流数被编码到每一个地址，流被布置在一个层次。 一个 Bitmessage 客户端会占用可以忽略不计的的硬盘空间和运算处理能力。一旦开始超过合理阈值，新的地址会在子流里建立，创建这些地址的节点会把自己视为该流中的一个并共同动作。从这时起，如果该节点在父流中没有活动地址，就只需要保持与子流中的节点连接。除了流 1（根流）中的节点，节点应该偶尔连接父流节点以通报它们的存在。每个节点都应该维护一个列表，其中包含它的流和两个子流中的对等节点。要发送一个消息，节点必须首先连接 Bitmessage 地址中的流编码。如果不知道目标流中的任何节点，则连接到最近的父流，然后下载自己所在的两个子流的列表。然后，可以连接到子流，并继续该过程直到到达目标流。在消息发送并收到确认后，可以断开与该流中节点的连接。如果用户回复消息，他们的Bitmessage 的客户端重复同样的过程，连接到原发件人的流。在完成一次该连接过程后，因为发送节点已经保存了流节点列表，第二次连接目标流节点就微不足道了。父流和子流运算公式很简单： 5、广播 因为所有用户会收到所有邮件，该系统自然衍伸支持广播消息。通过口口相传，用户接收他们感兴趣的广播发布的内容。把广播的 Bitmessage 地址加入 Bitmessage 客户端的“订阅”部分，广播的消息会出现在用户的收件箱中，或出现在另一个支持 Bitmessage 协议的其它用途的应用程序中。这将允许任何个人或机构用已经验证的身份，向每个希望收听的人匿名广播。 6、接收器离线时的行为 一个公钥请求的对象，一个公钥，一条个人对个人的消息，或一条广播消息。对象经过整个 Bitmessage 流转播。我们提出节点把所有对象存储两天，然后删除。加入网络的节点向对等节点请求自己没有的对象列表。这样，它将收到两天内所有发向它的转播消息。如果某个节点离线超过两天，发送节点会注意到从来没有收到它的确认，并在另一个两天后重播消息。这将按照指数退避算法永远继续重播消息。在最坏的情况下，如果一个用户处于离线状态 n 天，那么他必须重新在线并保持连接 n 天（或每两天连接一次，保持 n 天），以获得他的所有消息。 7、被动工作模式 有特别偏执的人，希望通过指定一个完全被动模式（标志连接他的公钥）接收邮件而不回复确认。也许，对他明智是，由另一个可能的随机节点代替他的节点回复确认，而其它节点甚至都没有意识到自己已经为他此目的服务。假设 Alice 向 Bradley 发送一条消息，但 Bradley 过于偏执不回复确认，因为他担心攻击者Eve 窃听他的详细 Internet 连接并试图找到他。Eve 可能看到 Bradley 的回复确认从他的机器发出比从其他机器发出的早，这表明他在该位置运行。Bradley 可能反而选择把确认打包进另一条消息，并发送给他的一个朋友或一个随机的 Bitmessage 公钥（假设是 Charlie 的）。如果 Charlie在线，他将立刻在一次广播中同时承认这两个确认。Bradley 也可以选择把他的公钥分发，广播或按他的方式请求公钥。例如，他可以把他的公钥作为确认数据，包含在他发送给朋友的下一条消息中或在一封发给 Charlie 的空白邮件中。这将有助于同时确认收到 Bradley 的消息，并且他公钥的分发无需源于他未加密的互联网连接。即使 Eve 监测 Charlie 的互联网连接，她也不会知道 Bradley 是否真正在该位置（或者可能 Bradley 和 Charlie 可能实际上是同一个人）。事实上，Bradley 可能不在当地，或者 Bradley 和 Charlie 甚至不认识彼此。即使大多数人都不会使用这种操作模式，现实中人们却很可能提供那些似是而非的身份指认或否认。 8、垃圾 现有的工作证明请求可能足以使垃圾邮件制造者不经济。如果不是，有这样几个行为可采用： ◆增加工作证明的难度。 ◆为实际使用的公钥，给每个客户端分配ｘ个公钥。确认消息绑定这些公钥，但从来不向用户显示消息。垃圾邮件制造者将需要ｘ倍的计算量来发送垃圾消息。 ◆包含冗余位的 Bitmessage 地址，并要求这些位被包含在消息中，从而证明了发送者的 Bitmessage 地址。包含两个字节的冗余位，会使一个 Bitmessage 地址长度延长 9％，但垃圾邮件制造者将需要 65536 倍的计算量。搜索引擎抓取网页寻找 Bitmessage 地址将阻碍该选项。 9、结论 我们已经提出了一个系统，不仅桥接了电子邮件易用性和 PGP/GPG 安全性之间的差距，也隐藏了对“非内容”数据的窥探。不用被迫相信会犯错（或恶意）的中心，因此而保有隐私的获益应该大于抵消使用一个非人本友好的地址所造成的麻烦。广播和订阅功能，对任何希望经常匿名发布内容的人，是特别有用的。搭配 BitTorrent 协议，个人可以发布任何尺寸的内容。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/05/30/8dc87a914539bd68318c134b5638ca29.html","headline":"区块链开发专题(P2P技术如何验证消息)","dateModified":"2017-05-30T00:00:00+08:00","datePublished":"2017-05-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/05/30/8dc87a914539bd68318c134b5638ca29.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链开发专题(P2P技术如何验证消息)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;"><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353） &nbsp;</span><br></p> 
  <p><br></p> 
  <p>摘要：我们提出了一个使用低可靠性分布式 P2P 协议的系统，使用户能够安全地发送/接收消息，订阅/广播消息。除了一个相对较短（约 36 字符）的地址，用户无需交换任何其它数据即可确保安全性，不需要任何公钥和私钥的概念即可使用该系统。它还被设计成掩盖非消息内容的数据，如那些通信内容并不包括的消息发送者和接收者的信息。</p> 1、介绍
  <br> 电子邮件是普及而不安全的。发送加密邮件的能力是有必要的，但目前的解决方案对人们来说难以使用：用户必须通过可信的渠道（如当面或通过电话）交换电子邮件地址和密钥。除非是须特别关注的邮件内容，否则即使那些知道如何使用 PGP/GPG 等工具的用户，也很少努力这样做。新手学习使用这些软件会有一个困难的过程，因为公私钥对之间关系、它们的用途等是陌生的概念。即使用户确实已经使用 PGP/GPG 进行通信，单靠加密并不能隐蔽消息的发送者和接收者。一些国家的政府机构正在收集所有私人的详细呼叫记录，并将它们存储在大型数据库中用于社交网络分析[1] [2] [3]。没有什么能阻止他们收集电话和消息内容，确实有官员告诉纽约时报，美国国家安全局已在从事“过分的收集”[4]。隐藏自己的身份是困难的。即使放弃常用的电子邮件地址，用户也必须连接到一个邮件服务器来发送和接收消息，即暴露自己的 IP 地址。如果人们使用 Tor 连接 Web 服务器，它们的安全依赖于 X.509 系统。该系统已使 HTTPS.X.509 证书当局在最近几年遭受黑客袭击，其中包括在伊朗使用欺诈性的但数字签名有效的证书——该证书由已被黑客攻击的证书颁发机构（DigiNotar）签署——针对其公民使用诸如 Gmail 等谷歌服务进行 man-in-the-middle 攻击[5] [6]。由于 HTTPS 的安全性只与可靠的或合格的证书颁发机构的安全性相同，事实上， Windows或 Firefox 浏览器信任的 CA 证书有超过 1000 个，为数百个不同的组织[7]所拥有，这会对所有用户造成极大困扰。另外，即使如果这些组织中只有一个由政府机构运行，并且如果他们有一定的网络硬件位于用户服务器和目标服务器之间，那么他们将能够随意对看似安全的通信进行有针对性的 man-in-the-middle 攻击。现在所需要的是一种通信协议及其软件：可以对消息进行加密，消息的发送者和接收者对其他人隐蔽，并保证消息的发送者是不能伪造的，没有信任依赖，密钥管理的细节不加重用户的负担。在本文中，我们提出了这样的协议。
  <br> 2、认证
  <br> 我们提出了一个系统，用户交换一个公钥的哈希值——也是用户的地址。如果公钥可以通过底层协议，那么它可以很容易地被哈希验证为它预期所属的收件人。由用户交换的数据包括一个版本号（表示转发能力）、一个流数（其目的将在后面讨论）和一个校验和。用 base58 编码 ， 并 在 前 面 加 上 识 别 字 符 （ 如 Bitmessage 的 BM ）， 例 如 地 址 是 ：BM-2nTX1KchxgnmHvy9ntCN9r7sgKTraxczzyE。比电子邮件地址复杂的部分，理所当然的被制作成没有太多的手动输入，也可以制成 QR 码。用户已经证明这一点是可以接受的，比如类似Bitcoin 的地址格式、长度[8]。此地址格式对电子邮件来说是优越的，因为它保证了消息明确来自于一个特定的用户或组织。消息发送者无法被伪造。
  <br> 3、消息传递
  <br> 我们提出了一个消息传递机制，类似于比特币的交易和块传输系统[8]，但每条消息都有工作证明。用户之间通过运行 Bitmessage 客户端，形成一个 P2P 网络，并尽最大努力转发邮件。为了通过网络发送邮件，必须完成一个哈希碰撞形式的工作证明。工作证明的难度应该和该消息的大小成正比，并应设置成一个典型大小的消息发送须一台普通计算机平均花费四分钟。随着软件进步，工作证明的难度可以调节。每个消息都必须包括时间戳，以防止恶意流量攻击。如果消息的时间戳太旧，网络节点不会转发。如果消息发送者没有收到确认信息，并希望重发消息，他必须更新时间戳并重新计算工作证明。像 Bitcoin 的交易和区块一样，所有用户都将收到所有消息，并尝试用各自的私钥解码每条消息以确认消息接受者是自己。
  <br> 4、可扩展性
  <br> 如果所有节点接收所有消息，自然要关注系统的可扩展性。为了解决这个问题，我们建议，在消息发送通过 Bitmessage 网络的数量达到了一定的阈值时，节点开始自我分离到大集群或流。用户开始将只使用流 1，流数被编码到每一个地址，流被布置在一个层次。
  <br>
  <br>
  <br>
  <br>
  <br> 一个 Bitmessage 客户端会占用可以忽略不计的的硬盘空间和运算处理能力。一旦开始超过合理阈值，新的地址会在子流里建立，创建这些地址的节点会把自己视为该流中的一个并共同动作。从这时起，如果该节点在父流中没有活动地址，就只需要保持与子流中的节点连接。除了流 1（根流）中的节点，节点应该偶尔连接父流节点以通报它们的存在。每个节点都应该维护一个列表，其中包含它的流和两个子流中的对等节点。要发送一个消息，节点必须首先连接 Bitmessage 地址中的流编码。如果不知道目标流中的任何节点，则连接到最近的父流，然后下载自己所在的两个子流的列表。然后，可以连接到子流，并继续该过程直到到达目标流。在消息发送并收到确认后，可以断开与该流中节点的连接。如果用户回复消息，他们的Bitmessage 的客户端重复同样的过程，连接到原发件人的流。在完成一次该连接过程后，因为发送节点已经保存了流节点列表，第二次连接目标流节点就微不足道了。父流和子流运算公式很简单：
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br> 5、广播
  <br> 因为所有用户会收到所有邮件，该系统自然衍伸支持广播消息。通过口口相传，用户接收他们感兴趣的广播发布的内容。把广播的 Bitmessage 地址加入 Bitmessage 客户端的“订阅”部分，广播的消息会出现在用户的收件箱中，或出现在另一个支持 Bitmessage 协议的其它用途的应用程序中。这将允许任何个人或机构用已经验证的身份，向每个希望收听的人匿名广播。
  <br> 6、接收器离线时的行为
  <br> 一个公钥请求的对象，一个公钥，一条个人对个人的消息，或一条广播消息。对象经过整个 Bitmessage 流转播。我们提出节点把所有对象存储两天，然后删除。加入网络的节点向对等节点请求自己没有的对象列表。这样，它将收到两天内所有发向它的转播消息。如果某个节点离线超过两天，发送节点会注意到从来没有收到它的确认，并在另一个两天后重播消息。这将按照指数退避算法永远继续重播消息。在最坏的情况下，如果一个用户处于离线状态 n 天，那么他必须重新在线并保持连接 n 天（或每两天连接一次，保持 n 天），以获得他的所有消息。
  <br> 7、被动工作模式
  <br> 有特别偏执的人，希望通过指定一个完全被动模式（标志连接他的公钥）接收邮件而不回复确认。也许，对他明智是，由另一个可能的随机节点代替他的节点回复确认，而其它节点甚至都没有意识到自己已经为他此目的服务。假设 Alice 向 Bradley 发送一条消息，但 Bradley 过于偏执不回复确认，因为他担心攻击者Eve 窃听他的详细 Internet 连接并试图找到他。Eve 可能看到 Bradley 的回复确认从他的机器发出比从其他机器发出的早，这表明他在该位置运行。Bradley 可能反而选择把确认打包进另一条消息，并发送给他的一个朋友或一个随机的 Bitmessage 公钥（假设是 Charlie 的）。如果 Charlie在线，他将立刻在一次广播中同时承认这两个确认。Bradley 也可以选择把他的公钥分发，广播或按他的方式请求公钥。例如，他可以把他的公钥作为确认数据，包含在他发送给朋友的下一条消息中或在一封发给 Charlie 的空白邮件中。这将有助于同时确认收到 Bradley 的消息，并且他公钥的分发无需源于他未加密的互联网连接。即使 Eve 监测 Charlie 的互联网连接，她也不会知道 Bradley 是否真正在该位置（或者可能 Bradley 和 Charlie 可能实际上是同一个人）。事实上，Bradley 可能不在当地，或者 Bradley 和 Charlie 甚至不认识彼此。即使大多数人都不会使用这种操作模式，现实中人们却很可能提供那些似是而非的身份指认或否认。
  <br> 8、垃圾
  <br> 现有的工作证明请求可能足以使垃圾邮件制造者不经济。如果不是，有这样几个行为可采用：
  <br> ◆增加工作证明的难度。
  <br> ◆为实际使用的公钥，给每个客户端分配ｘ个公钥。确认消息绑定这些公钥，但从来不向用户显示消息。垃圾邮件制造者将需要ｘ倍的计算量来发送垃圾消息。
  <br> ◆包含冗余位的 Bitmessage 地址，并要求这些位被包含在消息中，从而证明了发送者的
  <br> Bitmessage 地址。包含两个字节的冗余位，会使一个 Bitmessage 地址长度延长 9％，但垃圾邮件制造者将需要 65536 倍的计算量。搜索引擎抓取网页寻找 Bitmessage 地址将阻碍该选项。
  <br>
  <br>
  <br> 9、结论
  <br> 我们已经提出了一个系统，不仅桥接了电子邮件易用性和 PGP/GPG 安全性之间的差距，也隐藏了对“非内容”数据的窥探。不用被迫相信会犯错（或恶意）的中心，因此而保有隐私的获益应该大于抵消使用一个非人本友好的地址所造成的麻烦。广播和订阅功能，对任何希望经常匿名发布内容的人，是特别有用的。搭配 BitTorrent 协议，个人可以发布任何尺寸的内容。 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/72811063,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/72811063,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
