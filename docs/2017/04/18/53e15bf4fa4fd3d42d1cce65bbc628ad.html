<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>C++连接CTP接口实现简单量化交易（行情、交易、k线、策略） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="C++连接CTP接口实现简单量化交易（行情、交易、k线、策略）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/70195889 对于量化交易来说，量化策略和技术系统缺一不可，为了知其所以然，本文实现了一个C++连接CTP接口进行仿真交易的demo，从接收行情、下订单、数据处理到添加策略、挂载运行交易等多个环节来看一下量化交易的最简单流程，管中窥豹，一探究竟。 &nbsp; 准备工作 交易所接口 这里使用上期所提供的CTP接口API，通过CTP可以连接交易所进行行情接收交易。下载地址：CTP下载 本文使用的win32版本的，linux版本用法类似。 CTP接口包含以下内容： &nbsp; ThostFtdcTraderApi.h：C++头文件，包含交易相关的指令，如报单。 ThostFtdcMdApi.h：C++头文件，包含获取行情相关的指令。 ThostFtdcUserApiStruct.h：包含了所有用到的数据结构。 ThostFtdcUserApiDataType.h：包含了所有用到的数据类型。 thosttraderapi.lib、thosttraderapi.dll：交易部分的动态链接库和静态链接库。 thostmduserapi.lib、thostmduserapi.dll：行情部分的动态链接库和静态链接库。 error.dtd、error.xml：包含所有可能的错误信息。 &nbsp; &nbsp; 整个开发包有2个核心头文件包括4个核心接口， CThostFtdcMdApi接口和CThostFtdcTraderApi两个头文件，一个处理行情，一个处理交易。 （1）处理行情的CThostFtdcMdApi接口有两个类，分别是CThostFtdcMdApi和CThostFtdcMdSpi,以Api结尾的是用来下命令的，以Spi结尾的是用来响应命令的回调。 （2）处理交易的CThostFtdcTraderApi接口也有两个类，分别是CThostFtdcTraderApi和CThostFtdcTraderSpi, &nbsp;通过CThostFtdcTraderApi向CTP发送操作请求，通过CThostFtdcTraderSpi接收CTP的操作响应。 &nbsp; 期货账户 要连接期货交易所交易，需要开设自己的账户，实现期货交易、银期转账、保证金等功能，由于小白一般不会用实盘资金交易，所以此处推荐用上期所提供的simnow虚拟交易平台simnow申请一个虚拟账户。 SIMNOW提供两类数据前置地址： （1）交易时段的地址，如09:00-15:00和21:00-02:30，使用第一套地址，这些数据是真实的行情数据，只是时间上比真实的行情会有延迟30秒左右(SIMNOW从交易所接收后转发出来的)。 （2）非交易时段地址，这时的数据是历史行情的播放，比如昨天的数据之类的，可以用来做程序调试。 &nbsp; 建议选择申请那个7x24行情的账户，便于开发调试。 &nbsp; 开发步骤 工程总览 &nbsp; 其中， &nbsp; CTP的API文件配置到工程 CustomMdSpi.h，CustomMdSpi.cpp是派生的行情回调类 CustomTradeSpi.h，CustomTradeSpi.cpp是派生的交易回调类 TickToKlineHelper.h，TickToKlineHelper.cpp是处理时序数据，转换成K线的类 StrategyTrade.h，StrategyTrade.cpp是策略类 main.cpp是程序的入口 一个简单的程序化交易系统需要完成的业务可以划分为： 1.基本操作，比如登录，订阅等； 2.行情操作，比如对行情数据的接收，存储等 3.订单操作，比如报单；对报单，成交状况的查询；报单，成交状况的私有回报等。 4.数据监听和处理操作，比如接收到新数据之后的统计处理，满足统计条件后的报单处理（其实这里就是我们的策略所在） &nbsp; 导入CTP接口库 visual studio创建工程后，首先需要将ctp的头文件以及链接库（lib和dll）目录配置到工程 &nbsp; &nbsp; &nbsp; // 链接库 #pragma comment (lib, &quot;thostmduserapi.lib&quot;) #pragma comment (lib, &quot;thosttraderapi.lib&quot;) &nbsp; &nbsp; 全局参数 连接到交易所，需要配置经纪商代码、帐户名、密码以及订阅合约和买卖合约的相关参数 // ---- 全局变量 ---- // // 公共参数 TThostFtdcBrokerIDType gBrokerID = &quot;9999&quot;; // 模拟经纪商代码 TThostFtdcInvestorIDType gInvesterID = &quot;&quot;; // 投资者账户名 TThostFtdcPasswordType gInvesterPassword = &quot;&quot;; // 投资者密码 // 行情参数 CThostFtdcMdApi *g_pMdUserApi = nullptr; // 行情指针 char gMdFrontAddr[] = &quot;tcp://180.168.146.187:10010&quot;; // 模拟行情前置地址 char *g_pInstrumentID[] = {&quot;TF1706&quot;, &quot;zn1705&quot;, &quot;cs1801&quot;, &quot;CF705&quot;}; // 行情合约代码列表，中、上、大、郑交易所各选一种 int instrumentNum = 4; // 行情合约订阅数量 unordered_map&lt;string, TickToKlineHelper&gt; g_KlineHash; // 不同合约的k线存储表 // 交易参数 CThostFtdcTraderApi *g_pTradeUserApi = nullptr; // 交易指针 char gTradeFrontAddr[] = &quot;tcp://180.168.146.187:10001&quot;; // 模拟交易前置地址 TThostFtdcInstrumentIDType g_pTradeInstrumentID = &quot;m1709&quot;; // 所交易的合约代码 TThostFtdcDirectionType gTradeDirection = THOST_FTDC_D_Sell; // 买卖方向 TThostFtdcPriceType gLimitPrice = 2818; // 交易价格 这里只是简单的写一下，真实完整的交易系统中，一般用配置文件，有用户去定制 &nbsp; 行情回调类 继承CThostFtdcMdSpi实现自己的行情回调类CustomMdSpi，在系统运行时这些重写的函数会被CTP的系统api回调从而实现个性化行情 CustomMdSpi头文件 &nbsp; #pragma once // ---- 派生的行情类 ---- // #include &lt;vector&gt; #include &quot;CTP_API/ThostFtdcMdApi.h&quot; class CustomMdSpi: public CThostFtdcMdSpi { // ---- 继承自CTP父类的回调接口并实现 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 ///@param nReason 错误原因 /// 0x1001 网络读失败 /// 0x1002 网络写失败 /// 0x2001 接收心跳超时 /// 0x2002 发送心跳失败 /// 0x2003 收到错误报文 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 ///@param nTimeLapse 距离上次接收报文的时间 void OnHeartBeatWarning(int nTimeLapse); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅行情应答 void OnRspSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅行情应答 void OnRspUnSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅询价应答 void OnRspSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅询价应答 void OnRspUnSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///深度行情通知 void OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData); ///询价通知 void OnRtnForQuoteRsp(CThostFtdcForQuoteRspField *pForQuoteRsp); }; &nbsp; 都是重写回调函数 连接应答 &nbsp; // 连接成功应答 void CustomMdSpi::OnFrontConnected() { std::cout &lt;&lt; &quot;=====建立网络连接成功=====&quot; &lt;&lt; std::endl; // 开始登录 CThostFtdcReqUserLoginField loginReq; memset(&amp;loginReq, 0, sizeof(loginReq)); strcpy(loginReq.BrokerID, gBrokerID); strcpy(loginReq.UserID, gInvesterID); strcpy(loginReq.Password, gInvesterPassword); static int requestID = 0; // 请求编号 int rt = g_pMdUserApi-&gt;ReqUserLogin(&amp;loginReq, requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送登录请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送登录请求失败&quot; &lt;&lt; std::endl; } &nbsp; 登录应答 &nbsp; // 登录应答 void CustomMdSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 开始订阅行情 int rt = g_pMdUserApi-&gt;SubscribeMarketData(g_pInstrumentID, instrumentNum); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送订阅行情请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送订阅行情请求失败&quot; &lt;&lt; std::endl; } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 订阅行情应答 &nbsp; // 订阅行情应答 void CustomMdSpi::OnRspSubMarketData( CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====订阅行情成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pSpecificInstrument-&gt;InstrumentID &lt;&lt; std::endl; // 如果需要存入文件或者数据库，在这里创建表头,不同的合约单独存储 char filePath[100] = {&#39;\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pSpecificInstrument-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::out); // 新开文件 outFile &lt;&lt; &quot;合约代码&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;更新时间&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;最新价&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;成交量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;持仓量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;换手率&quot; &lt;&lt; std::endl; outFile.close(); } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 因为是异步接口，这里连接、登录、订阅行情是一步套一步来调用的，在运行过程中，会启动一个行情线程，交易所每500ms会推送一个订阅的行情tick数据，因此，某些接口会被连续间隔调用，直到连接关闭 收到行情后除了存在内存，也可以用文本文件或者数据库等形式存储起来，在这里创建初始文件或者建库 深度行情通知 // 行情详情通知 void CustomMdSpi::OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData) { // 打印行情，字段较多，截取部分 std::cout &lt;&lt; &quot;=====获得深度行情=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pDepthMarketData-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;最新价： &quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;数量： &quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; std::endl; // 如果只获取某一个合约行情，可以逐tick地存入文件或数据库 char filePath[100] = {&#39;\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pDepthMarketData-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::app); // 文件追加写入 outFile &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;UpdateTime &lt;&lt; &quot;.&quot; &lt;&lt; pDepthMarketData-&gt;UpdateMillisec &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;OpenInterest &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Turnover &lt;&lt; std::endl; outFile.close(); // 计算实时k线 std::string instrumentKey = std::string(pDepthMarketData-&gt;InstrumentID); if (g_KlineHash.find(instrumentKey) == g_KlineHash.end()) g_KlineHash[instrumentKey] = TickToKlineHelper(); g_KlineHash[instrumentKey].KLineFromRealtimeData(pDepthMarketData); // 取消订阅行情 //int rt = g_pMdUserApi-&gt;UnSubscribeMarketData(g_pInstrumentID, instrumentNum); //if (!rt) // std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送取消订阅行情请求成功&quot; &lt;&lt; std::endl; //else // std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送取消订阅行情请求失败&quot; &lt;&lt; std::endl; } 每个tick世间节点系统都会调用这个函数，推送具体的行情截面数据 可以在此处将行情写到本地，或者做一些数据处理（例如实时K线计算，判断是否触发策略等） &nbsp; 交易回调类 同理，也需要继承CThostFtdcTraderSpi来实现自己的CustomTradeSpi类，用于交易下单、报单等操作的回调 CustomTradeSpi头文件 &nbsp; #pragma once // ---- 派生的交易类 ---- // #include &quot;CTP_API/ThostFtdcTraderApi.h&quot; class CustomTradeSpi : public CThostFtdcTraderSpi { // ---- ctp_api部分回调接口 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 void OnHeartBeatWarning(int nTimeLapse); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///投资者结算结果确认响应 void OnRspSettlementInfoConfirm(CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询合约响应 void OnRspQryInstrument(CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询资金账户响应 void OnRspQryTradingAccount(CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询投资者持仓响应 void OnRspQryInvestorPosition(CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单录入请求响应 void OnRspOrderInsert(CThostFtdcInputOrderField *pInputOrder, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单操作请求响应 void OnRspOrderAction(CThostFtdcInputOrderActionField *pInputOrderAction, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单通知 void OnRtnOrder(CThostFtdcOrderField *pOrder); ///成交通知 void OnRtnTrade(CThostFtdcTradeField *pTrade); // ---- 自定义函数 ---- // public: bool loginFlag; // 登陆成功的标识 void reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); // 个性化报单录入，外部调用 private: void reqUserLogin(); // 登录请求 void reqUserLogout(); // 登出请求 void reqSettlementInfoConfirm(); // 投资者结果确认 void reqQueryInstrument(); // 请求查询合约 void reqQueryTradingAccount(); // 请求查询资金帐户 void reqQueryInvestorPosition(); // 请求查询投资者持仓 void reqOrderInsert(); // 请求报单录入 void reqOrderAction(CThostFtdcOrderField *pOrder); // 请求报单操作 bool isErrorRspInfo(CThostFtdcRspInfoField *pRspInfo); // 是否收到错误信息 bool isMyOrder(CThostFtdcOrderField *pOrder); // 是否我的报单回报 bool isTradingOrder(CThostFtdcOrderField *pOrder); // 是否正在交易的报单 }; &nbsp; &nbsp; 除了重写的基类函数，还自己封装一些主动调用的操作函数，比如登入登出、下单报单、查询报单等 &nbsp; &nbsp; &nbsp; 登录应答 &nbsp; void CustomTradeSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; loginFlag = true; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 保存会话参数 trade_front_id = pRspUserLogin-&gt;FrontID; session_id = pRspUserLogin-&gt;SessionID; strcpy(order_ref, pRspUserLogin-&gt;MaxOrderRef); // 投资者结算结果确认 reqSettlementInfoConfirm(); } } 查询投资者结算结果应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspSettlementInfoConfirm( CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====投资者结算结果确认成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认日期： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认时间： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmTime &lt;&lt; std::endl; // 请求查询合约 reqQueryInstrument(); } } 查询合约应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInstrument( CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询合约结果成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInstrument-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;执行价： &quot; &lt;&lt; pInstrument-&gt;StrikePrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;到期日： &quot; &lt;&lt; pInstrument-&gt;EndDelivDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前交易状态： &quot; &lt;&lt; pInstrument-&gt;IsTrading &lt;&lt; std::endl; // 请求查询投资者资金账户 reqQueryTradingAccount(); } } 查询投资者资金帐户应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryTradingAccount( CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者资金账户成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;投资者账号： &quot; &lt;&lt; pTradingAccount-&gt;AccountID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可用资金： &quot; &lt;&lt; pTradingAccount-&gt;Available &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可取资金： &quot; &lt;&lt; pTradingAccount-&gt;WithdrawQuota &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前保证金: &quot; &lt;&lt; pTradingAccount-&gt;CurrMargin &lt;&lt; std::endl; std::cout &lt;&lt; &quot;平仓盈亏： &quot; &lt;&lt; pTradingAccount-&gt;CloseProfit &lt;&lt; std::endl; // 请求查询投资者持仓 reqQueryInvestorPosition(); } } 查询投资者持仓应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInvestorPosition( CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者持仓成功=====&quot; &lt;&lt; std::endl; if (pInvestorPosition) { std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInvestorPosition-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓价格： &quot; &lt;&lt; pInvestorPosition-&gt;OpenAmount &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓量： &quot; &lt;&lt; pInvestorPosition-&gt;OpenVolume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓方向： &quot; &lt;&lt; pInvestorPosition-&gt;PosiDirection &lt;&lt; std::endl; std::cout &lt;&lt; &quot;占用保证金：&quot; &lt;&lt; pInvestorPosition-&gt;UseMargin &lt;&lt; std::endl; } else std::cout &lt;&lt; &quot;-----&gt;该合约未持仓&quot; &lt;&lt; std::endl; // 报单录入请求（这里是一部接口，此处是按顺序执行） /*if (loginFlag) reqOrderInsert();*/ if (loginFlag) reqOrderInsert(g_pTradeInstrumentID, gLimitPrice, 1, gTradeDirection); // 自定义一笔交易 // 策略交易 /*std::cout &lt;&lt; &quot;=====开始进入策略交易=====&quot; &lt;&lt; std::endl; while (loginFlag) StrategyCheckAndTrade(g_pTradeInstrumentID, this);*/ } } 这里把下单录入的操作放在了持仓结果出来之后的回调里面，策略交易也简单的放在了这里，真实的情况下，应该是由行情触发某个策略条件开一个线程进行策略交易 &nbsp; 下单操作 &nbsp; &nbsp; void CustomTradeSpi::reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction) { CThostFtdcInputOrderField orderInsertReq; memset(&amp;orderInsertReq, 0, sizeof(orderInsertReq)); ///经纪公司代码 strcpy(orderInsertReq.BrokerID, gBrokerID); ///投资者代码 strcpy(orderInsertReq.InvestorID, gInvesterID); ///合约代码 strcpy(orderInsertReq.InstrumentID, instrumentID); ///报单引用 strcpy(orderInsertReq.OrderRef, order_ref); ///报单价格条件: 限价 orderInsertReq.OrderPriceType = THOST_FTDC_OPT_LimitPrice; ///买卖方向: orderInsertReq.Direction = direction; ///组合开平标志: 开仓 orderInsertReq.CombOffsetFlag[0] = THOST_FTDC_OF_Open; ///组合投机套保标志 orderInsertReq.CombHedgeFlag[0] = THOST_FTDC_HF_Speculation; ///价格 orderInsertReq.LimitPrice = price; ///数量：1 orderInsertReq.VolumeTotalOriginal = volume; ///有效期类型: 当日有效 orderInsertReq.TimeCondition = THOST_FTDC_TC_GFD; ///成交量类型: 任何数量 orderInsertReq.VolumeCondition = THOST_FTDC_VC_AV; ///最小成交量: 1 orderInsertReq.MinVolume = 1; ///触发条件: 立即 orderInsertReq.ContingentCondition = THOST_FTDC_CC_Immediately; ///强平原因: 非强平 orderInsertReq.ForceCloseReason = THOST_FTDC_FCC_NotForceClose; ///自动挂起标志: 否 orderInsertReq.IsAutoSuspend = 0; ///用户强评标志: 否 orderInsertReq.UserForceClose = 0; static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderInsert(&amp;orderInsertReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单录入请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单录入请求失败&quot; &lt;&lt; std::endl; } 通过重载写了两个函数，一个是用默认参数下单，一个可以传参下单，比如设定合约代码、价格、数量等 &nbsp; 报单操作 &nbsp; void CustomTradeSpi::reqOrderAction(CThostFtdcOrderField *pOrder) { static bool orderActionSentFlag = false; // 是否发送了报单 if (orderActionSentFlag) return; CThostFtdcInputOrderActionField orderActionReq; memset(&amp;orderActionReq, 0, sizeof(orderActionReq)); ///经纪公司代码 strcpy(orderActionReq.BrokerID, pOrder-&gt;BrokerID); ///投资者代码 strcpy(orderActionReq.InvestorID, pOrder-&gt;InvestorID); ///报单操作引用 // TThostFtdcOrderActionRefType OrderActionRef; ///报单引用 strcpy(orderActionReq.OrderRef, pOrder-&gt;OrderRef); ///请求编号 // TThostFtdcRequestIDType RequestID; ///前置编号 orderActionReq.FrontID = trade_front_id; ///会话编号 orderActionReq.SessionID = session_id; ///交易所代码 // TThostFtdcExchangeIDType ExchangeID; ///报单编号 // TThostFtdcOrderSysIDType OrderSysID; ///操作标志 orderActionReq.ActionFlag = THOST_FTDC_AF_Delete; ///价格 // TThostFtdcPriceType LimitPrice; ///数量变化 // TThostFtdcVolumeType VolumeChange; ///用户代码 // TThostFtdcUserIDType UserID; ///合约代码 strcpy(orderActionReq.InstrumentID, pOrder-&gt;InstrumentID); static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderAction(&amp;orderActionReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单操作请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单操作请求失败&quot; &lt;&lt; std::endl; orderActionSentFlag = true; } &nbsp; 主要是对于未成交的订单进行编辑或者撤销操作 &nbsp; &nbsp; 报单应答 &nbsp; void CustomTradeSpi::OnRtnOrder(CThostFtdcOrderField *pOrder) { char str[10]; sprintf(str, &quot;%d&quot;, pOrder-&gt;OrderSubmitStatus); int orderState = atoi(str) - 48; //报单状态0=已经提交，3=已经接受 std::cout &lt;&lt; &quot;=====收到报单应答=====&quot; &lt;&lt; std::endl; if (isMyOrder(pOrder)) { if (isTradingOrder(pOrder)) { std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 等待成交中！&quot; &lt;&lt; std::endl; //reqOrderAction(pOrder); // 这里可以撤单 //reqUserLogout(); // 登出测试 } else if (pOrder-&gt;OrderStatus == THOST_FTDC_OST_Canceled) std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 撤单成功！&quot; &lt;&lt; std::endl; } } void CustomTradeSpi::OnRtnTrade(CThostFtdcTradeField *pTrade) { std::cout &lt;&lt; &quot;=====报单成功成交=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交时间： &quot; &lt;&lt; pTrade-&gt;TradeTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pTrade-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交价格： &quot; &lt;&lt; pTrade-&gt;Price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交量： &quot; &lt;&lt; pTrade-&gt;Volume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开平仓方向： &quot; &lt;&lt; pTrade-&gt;Direction &lt;&lt; std::endl; } 等待成交进行轮询可以选择报单操作，成交完成后的应答 &nbsp; 时间序列转K线 从交易拿到的tick数据是时间序列数据，在证券交易中其实还需要根据时间序列算出一些技术指标数据，例如MACD，KDJ、K线等，这里简单地对数据做一下处理，写一个TickToKlineHelper将时间序列专程K线 &nbsp; &nbsp; K线数据结构 &nbsp; // k线数据结构 struct KLineDataType { double open_price; // 开 double high_price; // 高 double low_price; // 低 double close_price; // 收 int volume; // 量 }; 转换函数 &nbsp; &nbsp; void TickToKlineHelper::KLineFromLocalData(const std::string &amp;sFilePath, const std::string &amp;dFilePath) { // 先清理残留数据 m_priceVec.clear(); m_volumeVec.clear(); m_KLineDataArray.clear(); std::cout &lt;&lt; &quot;开始转换tick到k线...&quot; &lt;&lt; std::endl; // 默认读取的tick数据表有4个字段：合约代码、更新时间、最新价、成交量 std::ifstream srcInFile; std::ofstream dstOutFile; srcInFile.open(sFilePath, std::ios::in); dstOutFile.open(dFilePath, std::ios::out); dstOutFile &lt;&lt; &quot;开盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最高价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最低价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;收盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;成交量&quot; &lt;&lt; std::endl; // 一遍解析文件一边计算k线数据，1分钟k线每次读取60 * 2 = 120行数据 std::string lineStr; bool isFirstLine = true; while (std::getline(srcInFile, lineStr)) { if (isFirstLine) { // 跳过第一行表头 isFirstLine = false; continue; } std::istringstream ss(lineStr); std::string fieldStr; int count = 4; while (std::getline(ss, fieldStr, &#39;,&#39;)) { count--; if (count == 1) m_priceVec.push_back(std::atof(fieldStr.c_str())); else if (count == 0) { m_volumeVec.push_back(std::atoi(fieldStr.c_str())); break; } } // 计算k线 if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); //m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 dstOutFile &lt;&lt; k_line_data.open_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.high_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.low_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.close_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.volume &lt;&lt; std::endl; m_priceVec.clear(); m_volumeVec.clear(); } } srcInFile.close(); dstOutFile.close(); std::cout &lt;&lt; &quot;k线生成成功&quot; &lt;&lt; std::endl; } void TickToKlineHelper::KLineFromRealtimeData(CThostFtdcDepthMarketDataField *pDepthMarketData) { m_priceVec.push_back(pDepthMarketData-&gt;LastPrice); m_volumeVec.push_back(pDepthMarketData-&gt;Volume); if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 m_priceVec.clear(); m_volumeVec.clear(); } } &nbsp; 可以从本地文件中读取行情数据，进行离线转换，也可以在接受到行情时进行实时计算 基本思想是，针对每个合约代码，建立字典，维持一个行情数组，当时间间隔达到要求（例如分钟、分时、分日）时计算该时段的开、高、低、收、成交量等数据存入K线数组 最低时间单位的K线计算出来之后，高时间间隔的K线数据可以根据低时间间隔的K线计算出来（例如，算出了分钟K，那么分时K就根据分钟K来算） 本例子中只是实现了一个大概的原理，非常不精确，仅供参考 策略交易 量化交易系统最终是需要将编写的策略代码挂载到系统中进行策略交易的，这里做了一个简单的实现 StrategyTrade.h #pragma once // ---- 简单策略交易的类 ---- // #include &lt;functional&gt; #include &quot;CTP_API/ThostFtdcUserApiStruct.h&quot; #include &quot;TickToKlineHelper.h&quot; #include &quot;CustomTradeSpi.h&quot; typedef void(*reqOrderInsertFun)( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); using ReqOrderInsertFunctionType = std::function&lt; void(TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction)&gt;; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi); StrategyTrade.cpp #include &lt;vector&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &quot;StrategyTrade.h&quot; #include &quot;CustomTradeSpi.h&quot; extern std::unordered_map&lt;std::string, TickToKlineHelper&gt; g_KlineHash; // 线程互斥量 std::mutex marketDataMutex; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi) { // 加锁 std::lock_guard&lt;std::mutex&gt; lk(marketDataMutex); TickToKlineHelper tickToKlineObject = g_KlineHash.at(std::string(instrumentID)); // 策略 std::vector&lt;double&gt; priceVec = tickToKlineObject.m_priceVec; if (priceVec.size() &gt;= 3) { int len = priceVec.size(); // 最后连续三个上涨就买开仓,反之就卖开仓,这里暂时用最后一个价格下单 if (priceVec[len - 1] &gt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &gt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); else if (priceVec[len - 1] &lt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &lt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); } } 基本思想，针对指定合约，判断如果连续三个上涨就买开仓，连续三个下跌就卖开仓，价格都是用最新价 因为行情和交易是分开的线程，涉及到线程竞争，所以在实际下单时需要加入互斥锁，线程同步 策略如何被行情触发然后交易其实需要用事件驱动来做的，这里没有实现T_T 入口 main.cpp int main() { // 账号密码 cout &lt;&lt; &quot;请输入账号： &quot;; scanf(&quot;%s&quot;, gInvesterID); cout &lt;&lt; &quot;请输入密码： &quot;; scanf(&quot;%s&quot;, gInvesterPassword); // 初始化行情线程 cout &lt;&lt; &quot;初始化行情...&quot; &lt;&lt; endl; g_pMdUserApi = CThostFtdcMdApi::CreateFtdcMdApi(); // 创建行情实例 CThostFtdcMdSpi *pMdUserSpi = new CustomMdSpi; // 创建行情回调实例 g_pMdUserApi-&gt;RegisterSpi(pMdUserSpi); // 注册事件类 g_pMdUserApi-&gt;RegisterFront(gMdFrontAddr); // 设置行情前置地址 g_pMdUserApi-&gt;Init(); // 连接运行 // 初始化交易线程 cout &lt;&lt; &quot;初始化交易...&quot; &lt;&lt; endl; g_pTradeUserApi = CThostFtdcTraderApi::CreateFtdcTraderApi(); // 创建交易实例 //CThostFtdcTraderSpi *pTradeSpi = new CustomTradeSpi; CustomTradeSpi *pTradeSpi = new CustomTradeSpi; // 创建交易回调实例 g_pTradeUserApi-&gt;RegisterSpi(pTradeSpi); // 注册事件类 g_pTradeUserApi-&gt;SubscribePublicTopic(THOST_TERT_RESTART); // 订阅公共流 g_pTradeUserApi-&gt;SubscribePrivateTopic(THOST_TERT_RESTART); // 订阅私有流 g_pTradeUserApi-&gt;RegisterFront(gTradeFrontAddr); // 设置交易前置地址 g_pTradeUserApi-&gt;Init(); // 连接运行 // 等到线程退出 g_pMdUserApi-&gt;Join(); delete pMdUserSpi; g_pMdUserApi-&gt;Release(); g_pTradeUserApi-&gt;Join(); delete pTradeSpi; g_pTradeUserApi-&gt;Release(); // 转换本地k线数据 //TickToKlineHelper tickToKlineHelper; //tickToKlineHelper.KLineFromLocalData(&quot;market_data.csv&quot;, &quot;K_line_data.csv&quot;); getchar(); return 0; } CThostFtdcMdApi跟CustomMdSpi要建立关联，CThostFtdcTraderApi跟CustomTradeSpi建立关联，其实就是类似于函数注册 配置行情和交易地址 行情和交易分别是不同的线程，注意线程同步 记得内存回收 运行结果 行情 应答日志 &nbsp; 存成csv表格 &nbsp; 交易 应答日志 &nbsp; &nbsp; K线数据 &nbsp; &nbsp; &nbsp; &nbsp; 报单情况 用上期所的快期软件，登录上自己的账号之后，从过程序下单，在这个界面里能看到实时的报单成交状况 &nbsp; &nbsp; 源码下载 &nbsp; csdn：demo &nbsp; github：demo &nbsp; 结语 &nbsp; 本文旨在为刚接触CTP的小白们抛砖引玉，各交易接口的深度运用还需要看官方开发文档。 另外，对于完整的量化交易系统来说，不仅要具备行情、交易、策略模块，事件驱动、风控、回测模块以及底层的数据存储、网络并发都是需要深入钻研的方面，金融工程的Quant Researcher可以只专注于数据的分析、策略的研发，但是对于程序员Quant Developer来说，如何设计和开发一个高并发、低延迟、功能完善与策略结合紧密的量化交易系统的确是一项需要不断完善的工程。 &nbsp; ps：如果需要更高级和细致甚至可以用于实盘的功能，比如完整的开源交易系统，数据系统，算法交易，数据和交易接口等完备的解决方案，由于博客回复不现实，只能私信联系啦～ 支持是知识分享的动力，有问题可扫码哦 &nbsp; 阅读更多" />
<meta property="og:description" content="版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/70195889 对于量化交易来说，量化策略和技术系统缺一不可，为了知其所以然，本文实现了一个C++连接CTP接口进行仿真交易的demo，从接收行情、下订单、数据处理到添加策略、挂载运行交易等多个环节来看一下量化交易的最简单流程，管中窥豹，一探究竟。 &nbsp; 准备工作 交易所接口 这里使用上期所提供的CTP接口API，通过CTP可以连接交易所进行行情接收交易。下载地址：CTP下载 本文使用的win32版本的，linux版本用法类似。 CTP接口包含以下内容： &nbsp; ThostFtdcTraderApi.h：C++头文件，包含交易相关的指令，如报单。 ThostFtdcMdApi.h：C++头文件，包含获取行情相关的指令。 ThostFtdcUserApiStruct.h：包含了所有用到的数据结构。 ThostFtdcUserApiDataType.h：包含了所有用到的数据类型。 thosttraderapi.lib、thosttraderapi.dll：交易部分的动态链接库和静态链接库。 thostmduserapi.lib、thostmduserapi.dll：行情部分的动态链接库和静态链接库。 error.dtd、error.xml：包含所有可能的错误信息。 &nbsp; &nbsp; 整个开发包有2个核心头文件包括4个核心接口， CThostFtdcMdApi接口和CThostFtdcTraderApi两个头文件，一个处理行情，一个处理交易。 （1）处理行情的CThostFtdcMdApi接口有两个类，分别是CThostFtdcMdApi和CThostFtdcMdSpi,以Api结尾的是用来下命令的，以Spi结尾的是用来响应命令的回调。 （2）处理交易的CThostFtdcTraderApi接口也有两个类，分别是CThostFtdcTraderApi和CThostFtdcTraderSpi, &nbsp;通过CThostFtdcTraderApi向CTP发送操作请求，通过CThostFtdcTraderSpi接收CTP的操作响应。 &nbsp; 期货账户 要连接期货交易所交易，需要开设自己的账户，实现期货交易、银期转账、保证金等功能，由于小白一般不会用实盘资金交易，所以此处推荐用上期所提供的simnow虚拟交易平台simnow申请一个虚拟账户。 SIMNOW提供两类数据前置地址： （1）交易时段的地址，如09:00-15:00和21:00-02:30，使用第一套地址，这些数据是真实的行情数据，只是时间上比真实的行情会有延迟30秒左右(SIMNOW从交易所接收后转发出来的)。 （2）非交易时段地址，这时的数据是历史行情的播放，比如昨天的数据之类的，可以用来做程序调试。 &nbsp; 建议选择申请那个7x24行情的账户，便于开发调试。 &nbsp; 开发步骤 工程总览 &nbsp; 其中， &nbsp; CTP的API文件配置到工程 CustomMdSpi.h，CustomMdSpi.cpp是派生的行情回调类 CustomTradeSpi.h，CustomTradeSpi.cpp是派生的交易回调类 TickToKlineHelper.h，TickToKlineHelper.cpp是处理时序数据，转换成K线的类 StrategyTrade.h，StrategyTrade.cpp是策略类 main.cpp是程序的入口 一个简单的程序化交易系统需要完成的业务可以划分为： 1.基本操作，比如登录，订阅等； 2.行情操作，比如对行情数据的接收，存储等 3.订单操作，比如报单；对报单，成交状况的查询；报单，成交状况的私有回报等。 4.数据监听和处理操作，比如接收到新数据之后的统计处理，满足统计条件后的报单处理（其实这里就是我们的策略所在） &nbsp; 导入CTP接口库 visual studio创建工程后，首先需要将ctp的头文件以及链接库（lib和dll）目录配置到工程 &nbsp; &nbsp; &nbsp; // 链接库 #pragma comment (lib, &quot;thostmduserapi.lib&quot;) #pragma comment (lib, &quot;thosttraderapi.lib&quot;) &nbsp; &nbsp; 全局参数 连接到交易所，需要配置经纪商代码、帐户名、密码以及订阅合约和买卖合约的相关参数 // ---- 全局变量 ---- // // 公共参数 TThostFtdcBrokerIDType gBrokerID = &quot;9999&quot;; // 模拟经纪商代码 TThostFtdcInvestorIDType gInvesterID = &quot;&quot;; // 投资者账户名 TThostFtdcPasswordType gInvesterPassword = &quot;&quot;; // 投资者密码 // 行情参数 CThostFtdcMdApi *g_pMdUserApi = nullptr; // 行情指针 char gMdFrontAddr[] = &quot;tcp://180.168.146.187:10010&quot;; // 模拟行情前置地址 char *g_pInstrumentID[] = {&quot;TF1706&quot;, &quot;zn1705&quot;, &quot;cs1801&quot;, &quot;CF705&quot;}; // 行情合约代码列表，中、上、大、郑交易所各选一种 int instrumentNum = 4; // 行情合约订阅数量 unordered_map&lt;string, TickToKlineHelper&gt; g_KlineHash; // 不同合约的k线存储表 // 交易参数 CThostFtdcTraderApi *g_pTradeUserApi = nullptr; // 交易指针 char gTradeFrontAddr[] = &quot;tcp://180.168.146.187:10001&quot;; // 模拟交易前置地址 TThostFtdcInstrumentIDType g_pTradeInstrumentID = &quot;m1709&quot;; // 所交易的合约代码 TThostFtdcDirectionType gTradeDirection = THOST_FTDC_D_Sell; // 买卖方向 TThostFtdcPriceType gLimitPrice = 2818; // 交易价格 这里只是简单的写一下，真实完整的交易系统中，一般用配置文件，有用户去定制 &nbsp; 行情回调类 继承CThostFtdcMdSpi实现自己的行情回调类CustomMdSpi，在系统运行时这些重写的函数会被CTP的系统api回调从而实现个性化行情 CustomMdSpi头文件 &nbsp; #pragma once // ---- 派生的行情类 ---- // #include &lt;vector&gt; #include &quot;CTP_API/ThostFtdcMdApi.h&quot; class CustomMdSpi: public CThostFtdcMdSpi { // ---- 继承自CTP父类的回调接口并实现 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 ///@param nReason 错误原因 /// 0x1001 网络读失败 /// 0x1002 网络写失败 /// 0x2001 接收心跳超时 /// 0x2002 发送心跳失败 /// 0x2003 收到错误报文 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 ///@param nTimeLapse 距离上次接收报文的时间 void OnHeartBeatWarning(int nTimeLapse); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅行情应答 void OnRspSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅行情应答 void OnRspUnSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅询价应答 void OnRspSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅询价应答 void OnRspUnSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///深度行情通知 void OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData); ///询价通知 void OnRtnForQuoteRsp(CThostFtdcForQuoteRspField *pForQuoteRsp); }; &nbsp; 都是重写回调函数 连接应答 &nbsp; // 连接成功应答 void CustomMdSpi::OnFrontConnected() { std::cout &lt;&lt; &quot;=====建立网络连接成功=====&quot; &lt;&lt; std::endl; // 开始登录 CThostFtdcReqUserLoginField loginReq; memset(&amp;loginReq, 0, sizeof(loginReq)); strcpy(loginReq.BrokerID, gBrokerID); strcpy(loginReq.UserID, gInvesterID); strcpy(loginReq.Password, gInvesterPassword); static int requestID = 0; // 请求编号 int rt = g_pMdUserApi-&gt;ReqUserLogin(&amp;loginReq, requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送登录请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送登录请求失败&quot; &lt;&lt; std::endl; } &nbsp; 登录应答 &nbsp; // 登录应答 void CustomMdSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 开始订阅行情 int rt = g_pMdUserApi-&gt;SubscribeMarketData(g_pInstrumentID, instrumentNum); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送订阅行情请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送订阅行情请求失败&quot; &lt;&lt; std::endl; } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 订阅行情应答 &nbsp; // 订阅行情应答 void CustomMdSpi::OnRspSubMarketData( CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====订阅行情成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pSpecificInstrument-&gt;InstrumentID &lt;&lt; std::endl; // 如果需要存入文件或者数据库，在这里创建表头,不同的合约单独存储 char filePath[100] = {&#39;\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pSpecificInstrument-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::out); // 新开文件 outFile &lt;&lt; &quot;合约代码&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;更新时间&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;最新价&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;成交量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;持仓量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;换手率&quot; &lt;&lt; std::endl; outFile.close(); } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 因为是异步接口，这里连接、登录、订阅行情是一步套一步来调用的，在运行过程中，会启动一个行情线程，交易所每500ms会推送一个订阅的行情tick数据，因此，某些接口会被连续间隔调用，直到连接关闭 收到行情后除了存在内存，也可以用文本文件或者数据库等形式存储起来，在这里创建初始文件或者建库 深度行情通知 // 行情详情通知 void CustomMdSpi::OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData) { // 打印行情，字段较多，截取部分 std::cout &lt;&lt; &quot;=====获得深度行情=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pDepthMarketData-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;最新价： &quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;数量： &quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; std::endl; // 如果只获取某一个合约行情，可以逐tick地存入文件或数据库 char filePath[100] = {&#39;\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pDepthMarketData-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::app); // 文件追加写入 outFile &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;UpdateTime &lt;&lt; &quot;.&quot; &lt;&lt; pDepthMarketData-&gt;UpdateMillisec &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;OpenInterest &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Turnover &lt;&lt; std::endl; outFile.close(); // 计算实时k线 std::string instrumentKey = std::string(pDepthMarketData-&gt;InstrumentID); if (g_KlineHash.find(instrumentKey) == g_KlineHash.end()) g_KlineHash[instrumentKey] = TickToKlineHelper(); g_KlineHash[instrumentKey].KLineFromRealtimeData(pDepthMarketData); // 取消订阅行情 //int rt = g_pMdUserApi-&gt;UnSubscribeMarketData(g_pInstrumentID, instrumentNum); //if (!rt) // std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送取消订阅行情请求成功&quot; &lt;&lt; std::endl; //else // std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送取消订阅行情请求失败&quot; &lt;&lt; std::endl; } 每个tick世间节点系统都会调用这个函数，推送具体的行情截面数据 可以在此处将行情写到本地，或者做一些数据处理（例如实时K线计算，判断是否触发策略等） &nbsp; 交易回调类 同理，也需要继承CThostFtdcTraderSpi来实现自己的CustomTradeSpi类，用于交易下单、报单等操作的回调 CustomTradeSpi头文件 &nbsp; #pragma once // ---- 派生的交易类 ---- // #include &quot;CTP_API/ThostFtdcTraderApi.h&quot; class CustomTradeSpi : public CThostFtdcTraderSpi { // ---- ctp_api部分回调接口 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 void OnHeartBeatWarning(int nTimeLapse); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///投资者结算结果确认响应 void OnRspSettlementInfoConfirm(CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询合约响应 void OnRspQryInstrument(CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询资金账户响应 void OnRspQryTradingAccount(CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询投资者持仓响应 void OnRspQryInvestorPosition(CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单录入请求响应 void OnRspOrderInsert(CThostFtdcInputOrderField *pInputOrder, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单操作请求响应 void OnRspOrderAction(CThostFtdcInputOrderActionField *pInputOrderAction, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单通知 void OnRtnOrder(CThostFtdcOrderField *pOrder); ///成交通知 void OnRtnTrade(CThostFtdcTradeField *pTrade); // ---- 自定义函数 ---- // public: bool loginFlag; // 登陆成功的标识 void reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); // 个性化报单录入，外部调用 private: void reqUserLogin(); // 登录请求 void reqUserLogout(); // 登出请求 void reqSettlementInfoConfirm(); // 投资者结果确认 void reqQueryInstrument(); // 请求查询合约 void reqQueryTradingAccount(); // 请求查询资金帐户 void reqQueryInvestorPosition(); // 请求查询投资者持仓 void reqOrderInsert(); // 请求报单录入 void reqOrderAction(CThostFtdcOrderField *pOrder); // 请求报单操作 bool isErrorRspInfo(CThostFtdcRspInfoField *pRspInfo); // 是否收到错误信息 bool isMyOrder(CThostFtdcOrderField *pOrder); // 是否我的报单回报 bool isTradingOrder(CThostFtdcOrderField *pOrder); // 是否正在交易的报单 }; &nbsp; &nbsp; 除了重写的基类函数，还自己封装一些主动调用的操作函数，比如登入登出、下单报单、查询报单等 &nbsp; &nbsp; &nbsp; 登录应答 &nbsp; void CustomTradeSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; loginFlag = true; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 保存会话参数 trade_front_id = pRspUserLogin-&gt;FrontID; session_id = pRspUserLogin-&gt;SessionID; strcpy(order_ref, pRspUserLogin-&gt;MaxOrderRef); // 投资者结算结果确认 reqSettlementInfoConfirm(); } } 查询投资者结算结果应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspSettlementInfoConfirm( CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====投资者结算结果确认成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认日期： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认时间： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmTime &lt;&lt; std::endl; // 请求查询合约 reqQueryInstrument(); } } 查询合约应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInstrument( CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询合约结果成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInstrument-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;执行价： &quot; &lt;&lt; pInstrument-&gt;StrikePrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;到期日： &quot; &lt;&lt; pInstrument-&gt;EndDelivDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前交易状态： &quot; &lt;&lt; pInstrument-&gt;IsTrading &lt;&lt; std::endl; // 请求查询投资者资金账户 reqQueryTradingAccount(); } } 查询投资者资金帐户应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryTradingAccount( CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者资金账户成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;投资者账号： &quot; &lt;&lt; pTradingAccount-&gt;AccountID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可用资金： &quot; &lt;&lt; pTradingAccount-&gt;Available &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可取资金： &quot; &lt;&lt; pTradingAccount-&gt;WithdrawQuota &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前保证金: &quot; &lt;&lt; pTradingAccount-&gt;CurrMargin &lt;&lt; std::endl; std::cout &lt;&lt; &quot;平仓盈亏： &quot; &lt;&lt; pTradingAccount-&gt;CloseProfit &lt;&lt; std::endl; // 请求查询投资者持仓 reqQueryInvestorPosition(); } } 查询投资者持仓应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInvestorPosition( CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者持仓成功=====&quot; &lt;&lt; std::endl; if (pInvestorPosition) { std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInvestorPosition-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓价格： &quot; &lt;&lt; pInvestorPosition-&gt;OpenAmount &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓量： &quot; &lt;&lt; pInvestorPosition-&gt;OpenVolume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓方向： &quot; &lt;&lt; pInvestorPosition-&gt;PosiDirection &lt;&lt; std::endl; std::cout &lt;&lt; &quot;占用保证金：&quot; &lt;&lt; pInvestorPosition-&gt;UseMargin &lt;&lt; std::endl; } else std::cout &lt;&lt; &quot;-----&gt;该合约未持仓&quot; &lt;&lt; std::endl; // 报单录入请求（这里是一部接口，此处是按顺序执行） /*if (loginFlag) reqOrderInsert();*/ if (loginFlag) reqOrderInsert(g_pTradeInstrumentID, gLimitPrice, 1, gTradeDirection); // 自定义一笔交易 // 策略交易 /*std::cout &lt;&lt; &quot;=====开始进入策略交易=====&quot; &lt;&lt; std::endl; while (loginFlag) StrategyCheckAndTrade(g_pTradeInstrumentID, this);*/ } } 这里把下单录入的操作放在了持仓结果出来之后的回调里面，策略交易也简单的放在了这里，真实的情况下，应该是由行情触发某个策略条件开一个线程进行策略交易 &nbsp; 下单操作 &nbsp; &nbsp; void CustomTradeSpi::reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction) { CThostFtdcInputOrderField orderInsertReq; memset(&amp;orderInsertReq, 0, sizeof(orderInsertReq)); ///经纪公司代码 strcpy(orderInsertReq.BrokerID, gBrokerID); ///投资者代码 strcpy(orderInsertReq.InvestorID, gInvesterID); ///合约代码 strcpy(orderInsertReq.InstrumentID, instrumentID); ///报单引用 strcpy(orderInsertReq.OrderRef, order_ref); ///报单价格条件: 限价 orderInsertReq.OrderPriceType = THOST_FTDC_OPT_LimitPrice; ///买卖方向: orderInsertReq.Direction = direction; ///组合开平标志: 开仓 orderInsertReq.CombOffsetFlag[0] = THOST_FTDC_OF_Open; ///组合投机套保标志 orderInsertReq.CombHedgeFlag[0] = THOST_FTDC_HF_Speculation; ///价格 orderInsertReq.LimitPrice = price; ///数量：1 orderInsertReq.VolumeTotalOriginal = volume; ///有效期类型: 当日有效 orderInsertReq.TimeCondition = THOST_FTDC_TC_GFD; ///成交量类型: 任何数量 orderInsertReq.VolumeCondition = THOST_FTDC_VC_AV; ///最小成交量: 1 orderInsertReq.MinVolume = 1; ///触发条件: 立即 orderInsertReq.ContingentCondition = THOST_FTDC_CC_Immediately; ///强平原因: 非强平 orderInsertReq.ForceCloseReason = THOST_FTDC_FCC_NotForceClose; ///自动挂起标志: 否 orderInsertReq.IsAutoSuspend = 0; ///用户强评标志: 否 orderInsertReq.UserForceClose = 0; static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderInsert(&amp;orderInsertReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单录入请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单录入请求失败&quot; &lt;&lt; std::endl; } 通过重载写了两个函数，一个是用默认参数下单，一个可以传参下单，比如设定合约代码、价格、数量等 &nbsp; 报单操作 &nbsp; void CustomTradeSpi::reqOrderAction(CThostFtdcOrderField *pOrder) { static bool orderActionSentFlag = false; // 是否发送了报单 if (orderActionSentFlag) return; CThostFtdcInputOrderActionField orderActionReq; memset(&amp;orderActionReq, 0, sizeof(orderActionReq)); ///经纪公司代码 strcpy(orderActionReq.BrokerID, pOrder-&gt;BrokerID); ///投资者代码 strcpy(orderActionReq.InvestorID, pOrder-&gt;InvestorID); ///报单操作引用 // TThostFtdcOrderActionRefType OrderActionRef; ///报单引用 strcpy(orderActionReq.OrderRef, pOrder-&gt;OrderRef); ///请求编号 // TThostFtdcRequestIDType RequestID; ///前置编号 orderActionReq.FrontID = trade_front_id; ///会话编号 orderActionReq.SessionID = session_id; ///交易所代码 // TThostFtdcExchangeIDType ExchangeID; ///报单编号 // TThostFtdcOrderSysIDType OrderSysID; ///操作标志 orderActionReq.ActionFlag = THOST_FTDC_AF_Delete; ///价格 // TThostFtdcPriceType LimitPrice; ///数量变化 // TThostFtdcVolumeType VolumeChange; ///用户代码 // TThostFtdcUserIDType UserID; ///合约代码 strcpy(orderActionReq.InstrumentID, pOrder-&gt;InstrumentID); static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderAction(&amp;orderActionReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单操作请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单操作请求失败&quot; &lt;&lt; std::endl; orderActionSentFlag = true; } &nbsp; 主要是对于未成交的订单进行编辑或者撤销操作 &nbsp; &nbsp; 报单应答 &nbsp; void CustomTradeSpi::OnRtnOrder(CThostFtdcOrderField *pOrder) { char str[10]; sprintf(str, &quot;%d&quot;, pOrder-&gt;OrderSubmitStatus); int orderState = atoi(str) - 48; //报单状态0=已经提交，3=已经接受 std::cout &lt;&lt; &quot;=====收到报单应答=====&quot; &lt;&lt; std::endl; if (isMyOrder(pOrder)) { if (isTradingOrder(pOrder)) { std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 等待成交中！&quot; &lt;&lt; std::endl; //reqOrderAction(pOrder); // 这里可以撤单 //reqUserLogout(); // 登出测试 } else if (pOrder-&gt;OrderStatus == THOST_FTDC_OST_Canceled) std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 撤单成功！&quot; &lt;&lt; std::endl; } } void CustomTradeSpi::OnRtnTrade(CThostFtdcTradeField *pTrade) { std::cout &lt;&lt; &quot;=====报单成功成交=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交时间： &quot; &lt;&lt; pTrade-&gt;TradeTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pTrade-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交价格： &quot; &lt;&lt; pTrade-&gt;Price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交量： &quot; &lt;&lt; pTrade-&gt;Volume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开平仓方向： &quot; &lt;&lt; pTrade-&gt;Direction &lt;&lt; std::endl; } 等待成交进行轮询可以选择报单操作，成交完成后的应答 &nbsp; 时间序列转K线 从交易拿到的tick数据是时间序列数据，在证券交易中其实还需要根据时间序列算出一些技术指标数据，例如MACD，KDJ、K线等，这里简单地对数据做一下处理，写一个TickToKlineHelper将时间序列专程K线 &nbsp; &nbsp; K线数据结构 &nbsp; // k线数据结构 struct KLineDataType { double open_price; // 开 double high_price; // 高 double low_price; // 低 double close_price; // 收 int volume; // 量 }; 转换函数 &nbsp; &nbsp; void TickToKlineHelper::KLineFromLocalData(const std::string &amp;sFilePath, const std::string &amp;dFilePath) { // 先清理残留数据 m_priceVec.clear(); m_volumeVec.clear(); m_KLineDataArray.clear(); std::cout &lt;&lt; &quot;开始转换tick到k线...&quot; &lt;&lt; std::endl; // 默认读取的tick数据表有4个字段：合约代码、更新时间、最新价、成交量 std::ifstream srcInFile; std::ofstream dstOutFile; srcInFile.open(sFilePath, std::ios::in); dstOutFile.open(dFilePath, std::ios::out); dstOutFile &lt;&lt; &quot;开盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最高价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最低价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;收盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;成交量&quot; &lt;&lt; std::endl; // 一遍解析文件一边计算k线数据，1分钟k线每次读取60 * 2 = 120行数据 std::string lineStr; bool isFirstLine = true; while (std::getline(srcInFile, lineStr)) { if (isFirstLine) { // 跳过第一行表头 isFirstLine = false; continue; } std::istringstream ss(lineStr); std::string fieldStr; int count = 4; while (std::getline(ss, fieldStr, &#39;,&#39;)) { count--; if (count == 1) m_priceVec.push_back(std::atof(fieldStr.c_str())); else if (count == 0) { m_volumeVec.push_back(std::atoi(fieldStr.c_str())); break; } } // 计算k线 if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); //m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 dstOutFile &lt;&lt; k_line_data.open_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.high_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.low_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.close_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.volume &lt;&lt; std::endl; m_priceVec.clear(); m_volumeVec.clear(); } } srcInFile.close(); dstOutFile.close(); std::cout &lt;&lt; &quot;k线生成成功&quot; &lt;&lt; std::endl; } void TickToKlineHelper::KLineFromRealtimeData(CThostFtdcDepthMarketDataField *pDepthMarketData) { m_priceVec.push_back(pDepthMarketData-&gt;LastPrice); m_volumeVec.push_back(pDepthMarketData-&gt;Volume); if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 m_priceVec.clear(); m_volumeVec.clear(); } } &nbsp; 可以从本地文件中读取行情数据，进行离线转换，也可以在接受到行情时进行实时计算 基本思想是，针对每个合约代码，建立字典，维持一个行情数组，当时间间隔达到要求（例如分钟、分时、分日）时计算该时段的开、高、低、收、成交量等数据存入K线数组 最低时间单位的K线计算出来之后，高时间间隔的K线数据可以根据低时间间隔的K线计算出来（例如，算出了分钟K，那么分时K就根据分钟K来算） 本例子中只是实现了一个大概的原理，非常不精确，仅供参考 策略交易 量化交易系统最终是需要将编写的策略代码挂载到系统中进行策略交易的，这里做了一个简单的实现 StrategyTrade.h #pragma once // ---- 简单策略交易的类 ---- // #include &lt;functional&gt; #include &quot;CTP_API/ThostFtdcUserApiStruct.h&quot; #include &quot;TickToKlineHelper.h&quot; #include &quot;CustomTradeSpi.h&quot; typedef void(*reqOrderInsertFun)( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); using ReqOrderInsertFunctionType = std::function&lt; void(TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction)&gt;; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi); StrategyTrade.cpp #include &lt;vector&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &quot;StrategyTrade.h&quot; #include &quot;CustomTradeSpi.h&quot; extern std::unordered_map&lt;std::string, TickToKlineHelper&gt; g_KlineHash; // 线程互斥量 std::mutex marketDataMutex; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi) { // 加锁 std::lock_guard&lt;std::mutex&gt; lk(marketDataMutex); TickToKlineHelper tickToKlineObject = g_KlineHash.at(std::string(instrumentID)); // 策略 std::vector&lt;double&gt; priceVec = tickToKlineObject.m_priceVec; if (priceVec.size() &gt;= 3) { int len = priceVec.size(); // 最后连续三个上涨就买开仓,反之就卖开仓,这里暂时用最后一个价格下单 if (priceVec[len - 1] &gt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &gt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); else if (priceVec[len - 1] &lt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &lt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); } } 基本思想，针对指定合约，判断如果连续三个上涨就买开仓，连续三个下跌就卖开仓，价格都是用最新价 因为行情和交易是分开的线程，涉及到线程竞争，所以在实际下单时需要加入互斥锁，线程同步 策略如何被行情触发然后交易其实需要用事件驱动来做的，这里没有实现T_T 入口 main.cpp int main() { // 账号密码 cout &lt;&lt; &quot;请输入账号： &quot;; scanf(&quot;%s&quot;, gInvesterID); cout &lt;&lt; &quot;请输入密码： &quot;; scanf(&quot;%s&quot;, gInvesterPassword); // 初始化行情线程 cout &lt;&lt; &quot;初始化行情...&quot; &lt;&lt; endl; g_pMdUserApi = CThostFtdcMdApi::CreateFtdcMdApi(); // 创建行情实例 CThostFtdcMdSpi *pMdUserSpi = new CustomMdSpi; // 创建行情回调实例 g_pMdUserApi-&gt;RegisterSpi(pMdUserSpi); // 注册事件类 g_pMdUserApi-&gt;RegisterFront(gMdFrontAddr); // 设置行情前置地址 g_pMdUserApi-&gt;Init(); // 连接运行 // 初始化交易线程 cout &lt;&lt; &quot;初始化交易...&quot; &lt;&lt; endl; g_pTradeUserApi = CThostFtdcTraderApi::CreateFtdcTraderApi(); // 创建交易实例 //CThostFtdcTraderSpi *pTradeSpi = new CustomTradeSpi; CustomTradeSpi *pTradeSpi = new CustomTradeSpi; // 创建交易回调实例 g_pTradeUserApi-&gt;RegisterSpi(pTradeSpi); // 注册事件类 g_pTradeUserApi-&gt;SubscribePublicTopic(THOST_TERT_RESTART); // 订阅公共流 g_pTradeUserApi-&gt;SubscribePrivateTopic(THOST_TERT_RESTART); // 订阅私有流 g_pTradeUserApi-&gt;RegisterFront(gTradeFrontAddr); // 设置交易前置地址 g_pTradeUserApi-&gt;Init(); // 连接运行 // 等到线程退出 g_pMdUserApi-&gt;Join(); delete pMdUserSpi; g_pMdUserApi-&gt;Release(); g_pTradeUserApi-&gt;Join(); delete pTradeSpi; g_pTradeUserApi-&gt;Release(); // 转换本地k线数据 //TickToKlineHelper tickToKlineHelper; //tickToKlineHelper.KLineFromLocalData(&quot;market_data.csv&quot;, &quot;K_line_data.csv&quot;); getchar(); return 0; } CThostFtdcMdApi跟CustomMdSpi要建立关联，CThostFtdcTraderApi跟CustomTradeSpi建立关联，其实就是类似于函数注册 配置行情和交易地址 行情和交易分别是不同的线程，注意线程同步 记得内存回收 运行结果 行情 应答日志 &nbsp; 存成csv表格 &nbsp; 交易 应答日志 &nbsp; &nbsp; K线数据 &nbsp; &nbsp; &nbsp; &nbsp; 报单情况 用上期所的快期软件，登录上自己的账号之后，从过程序下单，在这个界面里能看到实时的报单成交状况 &nbsp; &nbsp; 源码下载 &nbsp; csdn：demo &nbsp; github：demo &nbsp; 结语 &nbsp; 本文旨在为刚接触CTP的小白们抛砖引玉，各交易接口的深度运用还需要看官方开发文档。 另外，对于完整的量化交易系统来说，不仅要具备行情、交易、策略模块，事件驱动、风控、回测模块以及底层的数据存储、网络并发都是需要深入钻研的方面，金融工程的Quant Researcher可以只专注于数据的分析、策略的研发，但是对于程序员Quant Developer来说，如何设计和开发一个高并发、低延迟、功能完善与策略结合紧密的量化交易系统的确是一项需要不断完善的工程。 &nbsp; ps：如果需要更高级和细致甚至可以用于实盘的功能，比如完整的开源交易系统，数据系统，算法交易，数据和交易接口等完备的解决方案，由于博客回复不现实，只能私信联系啦～ 支持是知识分享的动力，有问题可扫码哦 &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/70195889 对于量化交易来说，量化策略和技术系统缺一不可，为了知其所以然，本文实现了一个C++连接CTP接口进行仿真交易的demo，从接收行情、下订单、数据处理到添加策略、挂载运行交易等多个环节来看一下量化交易的最简单流程，管中窥豹，一探究竟。 &nbsp; 准备工作 交易所接口 这里使用上期所提供的CTP接口API，通过CTP可以连接交易所进行行情接收交易。下载地址：CTP下载 本文使用的win32版本的，linux版本用法类似。 CTP接口包含以下内容： &nbsp; ThostFtdcTraderApi.h：C++头文件，包含交易相关的指令，如报单。 ThostFtdcMdApi.h：C++头文件，包含获取行情相关的指令。 ThostFtdcUserApiStruct.h：包含了所有用到的数据结构。 ThostFtdcUserApiDataType.h：包含了所有用到的数据类型。 thosttraderapi.lib、thosttraderapi.dll：交易部分的动态链接库和静态链接库。 thostmduserapi.lib、thostmduserapi.dll：行情部分的动态链接库和静态链接库。 error.dtd、error.xml：包含所有可能的错误信息。 &nbsp; &nbsp; 整个开发包有2个核心头文件包括4个核心接口， CThostFtdcMdApi接口和CThostFtdcTraderApi两个头文件，一个处理行情，一个处理交易。 （1）处理行情的CThostFtdcMdApi接口有两个类，分别是CThostFtdcMdApi和CThostFtdcMdSpi,以Api结尾的是用来下命令的，以Spi结尾的是用来响应命令的回调。 （2）处理交易的CThostFtdcTraderApi接口也有两个类，分别是CThostFtdcTraderApi和CThostFtdcTraderSpi, &nbsp;通过CThostFtdcTraderApi向CTP发送操作请求，通过CThostFtdcTraderSpi接收CTP的操作响应。 &nbsp; 期货账户 要连接期货交易所交易，需要开设自己的账户，实现期货交易、银期转账、保证金等功能，由于小白一般不会用实盘资金交易，所以此处推荐用上期所提供的simnow虚拟交易平台simnow申请一个虚拟账户。 SIMNOW提供两类数据前置地址： （1）交易时段的地址，如09:00-15:00和21:00-02:30，使用第一套地址，这些数据是真实的行情数据，只是时间上比真实的行情会有延迟30秒左右(SIMNOW从交易所接收后转发出来的)。 （2）非交易时段地址，这时的数据是历史行情的播放，比如昨天的数据之类的，可以用来做程序调试。 &nbsp; 建议选择申请那个7x24行情的账户，便于开发调试。 &nbsp; 开发步骤 工程总览 &nbsp; 其中， &nbsp; CTP的API文件配置到工程 CustomMdSpi.h，CustomMdSpi.cpp是派生的行情回调类 CustomTradeSpi.h，CustomTradeSpi.cpp是派生的交易回调类 TickToKlineHelper.h，TickToKlineHelper.cpp是处理时序数据，转换成K线的类 StrategyTrade.h，StrategyTrade.cpp是策略类 main.cpp是程序的入口 一个简单的程序化交易系统需要完成的业务可以划分为： 1.基本操作，比如登录，订阅等； 2.行情操作，比如对行情数据的接收，存储等 3.订单操作，比如报单；对报单，成交状况的查询；报单，成交状况的私有回报等。 4.数据监听和处理操作，比如接收到新数据之后的统计处理，满足统计条件后的报单处理（其实这里就是我们的策略所在） &nbsp; 导入CTP接口库 visual studio创建工程后，首先需要将ctp的头文件以及链接库（lib和dll）目录配置到工程 &nbsp; &nbsp; &nbsp; // 链接库 #pragma comment (lib, &quot;thostmduserapi.lib&quot;) #pragma comment (lib, &quot;thosttraderapi.lib&quot;) &nbsp; &nbsp; 全局参数 连接到交易所，需要配置经纪商代码、帐户名、密码以及订阅合约和买卖合约的相关参数 // ---- 全局变量 ---- // // 公共参数 TThostFtdcBrokerIDType gBrokerID = &quot;9999&quot;; // 模拟经纪商代码 TThostFtdcInvestorIDType gInvesterID = &quot;&quot;; // 投资者账户名 TThostFtdcPasswordType gInvesterPassword = &quot;&quot;; // 投资者密码 // 行情参数 CThostFtdcMdApi *g_pMdUserApi = nullptr; // 行情指针 char gMdFrontAddr[] = &quot;tcp://180.168.146.187:10010&quot;; // 模拟行情前置地址 char *g_pInstrumentID[] = {&quot;TF1706&quot;, &quot;zn1705&quot;, &quot;cs1801&quot;, &quot;CF705&quot;}; // 行情合约代码列表，中、上、大、郑交易所各选一种 int instrumentNum = 4; // 行情合约订阅数量 unordered_map&lt;string, TickToKlineHelper&gt; g_KlineHash; // 不同合约的k线存储表 // 交易参数 CThostFtdcTraderApi *g_pTradeUserApi = nullptr; // 交易指针 char gTradeFrontAddr[] = &quot;tcp://180.168.146.187:10001&quot;; // 模拟交易前置地址 TThostFtdcInstrumentIDType g_pTradeInstrumentID = &quot;m1709&quot;; // 所交易的合约代码 TThostFtdcDirectionType gTradeDirection = THOST_FTDC_D_Sell; // 买卖方向 TThostFtdcPriceType gLimitPrice = 2818; // 交易价格 这里只是简单的写一下，真实完整的交易系统中，一般用配置文件，有用户去定制 &nbsp; 行情回调类 继承CThostFtdcMdSpi实现自己的行情回调类CustomMdSpi，在系统运行时这些重写的函数会被CTP的系统api回调从而实现个性化行情 CustomMdSpi头文件 &nbsp; #pragma once // ---- 派生的行情类 ---- // #include &lt;vector&gt; #include &quot;CTP_API/ThostFtdcMdApi.h&quot; class CustomMdSpi: public CThostFtdcMdSpi { // ---- 继承自CTP父类的回调接口并实现 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 ///@param nReason 错误原因 /// 0x1001 网络读失败 /// 0x1002 网络写失败 /// 0x2001 接收心跳超时 /// 0x2002 发送心跳失败 /// 0x2003 收到错误报文 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 ///@param nTimeLapse 距离上次接收报文的时间 void OnHeartBeatWarning(int nTimeLapse); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅行情应答 void OnRspSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅行情应答 void OnRspUnSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///订阅询价应答 void OnRspSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///取消订阅询价应答 void OnRspUnSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///深度行情通知 void OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData); ///询价通知 void OnRtnForQuoteRsp(CThostFtdcForQuoteRspField *pForQuoteRsp); }; &nbsp; 都是重写回调函数 连接应答 &nbsp; // 连接成功应答 void CustomMdSpi::OnFrontConnected() { std::cout &lt;&lt; &quot;=====建立网络连接成功=====&quot; &lt;&lt; std::endl; // 开始登录 CThostFtdcReqUserLoginField loginReq; memset(&amp;loginReq, 0, sizeof(loginReq)); strcpy(loginReq.BrokerID, gBrokerID); strcpy(loginReq.UserID, gInvesterID); strcpy(loginReq.Password, gInvesterPassword); static int requestID = 0; // 请求编号 int rt = g_pMdUserApi-&gt;ReqUserLogin(&amp;loginReq, requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送登录请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送登录请求失败&quot; &lt;&lt; std::endl; } &nbsp; 登录应答 &nbsp; // 登录应答 void CustomMdSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 开始订阅行情 int rt = g_pMdUserApi-&gt;SubscribeMarketData(g_pInstrumentID, instrumentNum); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送订阅行情请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送订阅行情请求失败&quot; &lt;&lt; std::endl; } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 订阅行情应答 &nbsp; // 订阅行情应答 void CustomMdSpi::OnRspSubMarketData( CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0); if (!bResult) { std::cout &lt;&lt; &quot;=====订阅行情成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pSpecificInstrument-&gt;InstrumentID &lt;&lt; std::endl; // 如果需要存入文件或者数据库，在这里创建表头,不同的合约单独存储 char filePath[100] = {&#39;\\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pSpecificInstrument-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::out); // 新开文件 outFile &lt;&lt; &quot;合约代码&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;更新时间&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;最新价&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;成交量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;买量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖价一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;卖量一&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;持仓量&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;换手率&quot; &lt;&lt; std::endl; outFile.close(); } else std::cerr &lt;&lt; &quot;返回错误---&gt;&gt;&gt; ErrorID=&quot; &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; &quot;, ErrorMsg=&quot; &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl; } &nbsp; 因为是异步接口，这里连接、登录、订阅行情是一步套一步来调用的，在运行过程中，会启动一个行情线程，交易所每500ms会推送一个订阅的行情tick数据，因此，某些接口会被连续间隔调用，直到连接关闭 收到行情后除了存在内存，也可以用文本文件或者数据库等形式存储起来，在这里创建初始文件或者建库 深度行情通知 // 行情详情通知 void CustomMdSpi::OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData) { // 打印行情，字段较多，截取部分 std::cout &lt;&lt; &quot;=====获得深度行情=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pDepthMarketData-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pDepthMarketData-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;最新价： &quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;数量： &quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; std::endl; // 如果只获取某一个合约行情，可以逐tick地存入文件或数据库 char filePath[100] = {&#39;\\0&#39;}; sprintf(filePath, &quot;%s_market_data.csv&quot;, pDepthMarketData-&gt;InstrumentID); std::ofstream outFile; outFile.open(filePath, std::ios::app); // 文件追加写入 outFile &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;UpdateTime &lt;&lt; &quot;.&quot; &lt;&lt; pDepthMarketData-&gt;UpdateMillisec &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;BidVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskPrice1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;AskVolume1 &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;OpenInterest &lt;&lt; &quot;,&quot; &lt;&lt; pDepthMarketData-&gt;Turnover &lt;&lt; std::endl; outFile.close(); // 计算实时k线 std::string instrumentKey = std::string(pDepthMarketData-&gt;InstrumentID); if (g_KlineHash.find(instrumentKey) == g_KlineHash.end()) g_KlineHash[instrumentKey] = TickToKlineHelper(); g_KlineHash[instrumentKey].KLineFromRealtimeData(pDepthMarketData); // 取消订阅行情 //int rt = g_pMdUserApi-&gt;UnSubscribeMarketData(g_pInstrumentID, instrumentNum); //if (!rt) // std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送取消订阅行情请求成功&quot; &lt;&lt; std::endl; //else // std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送取消订阅行情请求失败&quot; &lt;&lt; std::endl; } 每个tick世间节点系统都会调用这个函数，推送具体的行情截面数据 可以在此处将行情写到本地，或者做一些数据处理（例如实时K线计算，判断是否触发策略等） &nbsp; 交易回调类 同理，也需要继承CThostFtdcTraderSpi来实现自己的CustomTradeSpi类，用于交易下单、报单等操作的回调 CustomTradeSpi头文件 &nbsp; #pragma once // ---- 派生的交易类 ---- // #include &quot;CTP_API/ThostFtdcTraderApi.h&quot; class CustomTradeSpi : public CThostFtdcTraderSpi { // ---- ctp_api部分回调接口 ---- // public: ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。 void OnFrontConnected(); ///登录请求响应 void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///错误应答 void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。 void OnFrontDisconnected(int nReason); ///心跳超时警告。当长时间未收到报文时，该方法被调用。 void OnHeartBeatWarning(int nTimeLapse); ///登出请求响应 void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///投资者结算结果确认响应 void OnRspSettlementInfoConfirm(CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询合约响应 void OnRspQryInstrument(CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询资金账户响应 void OnRspQryTradingAccount(CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///请求查询投资者持仓响应 void OnRspQryInvestorPosition(CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单录入请求响应 void OnRspOrderInsert(CThostFtdcInputOrderField *pInputOrder, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单操作请求响应 void OnRspOrderAction(CThostFtdcInputOrderActionField *pInputOrderAction, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast); ///报单通知 void OnRtnOrder(CThostFtdcOrderField *pOrder); ///成交通知 void OnRtnTrade(CThostFtdcTradeField *pTrade); // ---- 自定义函数 ---- // public: bool loginFlag; // 登陆成功的标识 void reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); // 个性化报单录入，外部调用 private: void reqUserLogin(); // 登录请求 void reqUserLogout(); // 登出请求 void reqSettlementInfoConfirm(); // 投资者结果确认 void reqQueryInstrument(); // 请求查询合约 void reqQueryTradingAccount(); // 请求查询资金帐户 void reqQueryInvestorPosition(); // 请求查询投资者持仓 void reqOrderInsert(); // 请求报单录入 void reqOrderAction(CThostFtdcOrderField *pOrder); // 请求报单操作 bool isErrorRspInfo(CThostFtdcRspInfoField *pRspInfo); // 是否收到错误信息 bool isMyOrder(CThostFtdcOrderField *pOrder); // 是否我的报单回报 bool isTradingOrder(CThostFtdcOrderField *pOrder); // 是否正在交易的报单 }; &nbsp; &nbsp; 除了重写的基类函数，还自己封装一些主动调用的操作函数，比如登入登出、下单报单、查询报单等 &nbsp; &nbsp; &nbsp; 登录应答 &nbsp; void CustomTradeSpi::OnRspUserLogin( CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====账户登录成功=====&quot; &lt;&lt; std::endl; loginFlag = true; std::cout &lt;&lt; &quot;交易日： &quot; &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl; std::cout &lt;&lt; &quot;登录时间： &quot; &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;经纪商： &quot; &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;帐户名： &quot; &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl; // 保存会话参数 trade_front_id = pRspUserLogin-&gt;FrontID; session_id = pRspUserLogin-&gt;SessionID; strcpy(order_ref, pRspUserLogin-&gt;MaxOrderRef); // 投资者结算结果确认 reqSettlementInfoConfirm(); } } 查询投资者结算结果应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspSettlementInfoConfirm( CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====投资者结算结果确认成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认日期： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;确认时间： &quot; &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmTime &lt;&lt; std::endl; // 请求查询合约 reqQueryInstrument(); } } 查询合约应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInstrument( CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询合约结果成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;交易所代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInstrument-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约在交易所的代码： &quot; &lt;&lt; pInstrument-&gt;ExchangeInstID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;执行价： &quot; &lt;&lt; pInstrument-&gt;StrikePrice &lt;&lt; std::endl; std::cout &lt;&lt; &quot;到期日： &quot; &lt;&lt; pInstrument-&gt;EndDelivDate &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前交易状态： &quot; &lt;&lt; pInstrument-&gt;IsTrading &lt;&lt; std::endl; // 请求查询投资者资金账户 reqQueryTradingAccount(); } } 查询投资者资金帐户应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryTradingAccount( CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者资金账户成功=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;投资者账号： &quot; &lt;&lt; pTradingAccount-&gt;AccountID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可用资金： &quot; &lt;&lt; pTradingAccount-&gt;Available &lt;&lt; std::endl; std::cout &lt;&lt; &quot;可取资金： &quot; &lt;&lt; pTradingAccount-&gt;WithdrawQuota &lt;&lt; std::endl; std::cout &lt;&lt; &quot;当前保证金: &quot; &lt;&lt; pTradingAccount-&gt;CurrMargin &lt;&lt; std::endl; std::cout &lt;&lt; &quot;平仓盈亏： &quot; &lt;&lt; pTradingAccount-&gt;CloseProfit &lt;&lt; std::endl; // 请求查询投资者持仓 reqQueryInvestorPosition(); } } 查询投资者持仓应答 &nbsp; &nbsp; void CustomTradeSpi::OnRspQryInvestorPosition( CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast) { if (!isErrorRspInfo(pRspInfo)) { std::cout &lt;&lt; &quot;=====查询投资者持仓成功=====&quot; &lt;&lt; std::endl; if (pInvestorPosition) { std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pInvestorPosition-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓价格： &quot; &lt;&lt; pInvestorPosition-&gt;OpenAmount &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓量： &quot; &lt;&lt; pInvestorPosition-&gt;OpenVolume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开仓方向： &quot; &lt;&lt; pInvestorPosition-&gt;PosiDirection &lt;&lt; std::endl; std::cout &lt;&lt; &quot;占用保证金：&quot; &lt;&lt; pInvestorPosition-&gt;UseMargin &lt;&lt; std::endl; } else std::cout &lt;&lt; &quot;-----&gt;该合约未持仓&quot; &lt;&lt; std::endl; // 报单录入请求（这里是一部接口，此处是按顺序执行） /*if (loginFlag) reqOrderInsert();*/ if (loginFlag) reqOrderInsert(g_pTradeInstrumentID, gLimitPrice, 1, gTradeDirection); // 自定义一笔交易 // 策略交易 /*std::cout &lt;&lt; &quot;=====开始进入策略交易=====&quot; &lt;&lt; std::endl; while (loginFlag) StrategyCheckAndTrade(g_pTradeInstrumentID, this);*/ } } 这里把下单录入的操作放在了持仓结果出来之后的回调里面，策略交易也简单的放在了这里，真实的情况下，应该是由行情触发某个策略条件开一个线程进行策略交易 &nbsp; 下单操作 &nbsp; &nbsp; void CustomTradeSpi::reqOrderInsert( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction) { CThostFtdcInputOrderField orderInsertReq; memset(&amp;orderInsertReq, 0, sizeof(orderInsertReq)); ///经纪公司代码 strcpy(orderInsertReq.BrokerID, gBrokerID); ///投资者代码 strcpy(orderInsertReq.InvestorID, gInvesterID); ///合约代码 strcpy(orderInsertReq.InstrumentID, instrumentID); ///报单引用 strcpy(orderInsertReq.OrderRef, order_ref); ///报单价格条件: 限价 orderInsertReq.OrderPriceType = THOST_FTDC_OPT_LimitPrice; ///买卖方向: orderInsertReq.Direction = direction; ///组合开平标志: 开仓 orderInsertReq.CombOffsetFlag[0] = THOST_FTDC_OF_Open; ///组合投机套保标志 orderInsertReq.CombHedgeFlag[0] = THOST_FTDC_HF_Speculation; ///价格 orderInsertReq.LimitPrice = price; ///数量：1 orderInsertReq.VolumeTotalOriginal = volume; ///有效期类型: 当日有效 orderInsertReq.TimeCondition = THOST_FTDC_TC_GFD; ///成交量类型: 任何数量 orderInsertReq.VolumeCondition = THOST_FTDC_VC_AV; ///最小成交量: 1 orderInsertReq.MinVolume = 1; ///触发条件: 立即 orderInsertReq.ContingentCondition = THOST_FTDC_CC_Immediately; ///强平原因: 非强平 orderInsertReq.ForceCloseReason = THOST_FTDC_FCC_NotForceClose; ///自动挂起标志: 否 orderInsertReq.IsAutoSuspend = 0; ///用户强评标志: 否 orderInsertReq.UserForceClose = 0; static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderInsert(&amp;orderInsertReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单录入请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单录入请求失败&quot; &lt;&lt; std::endl; } 通过重载写了两个函数，一个是用默认参数下单，一个可以传参下单，比如设定合约代码、价格、数量等 &nbsp; 报单操作 &nbsp; void CustomTradeSpi::reqOrderAction(CThostFtdcOrderField *pOrder) { static bool orderActionSentFlag = false; // 是否发送了报单 if (orderActionSentFlag) return; CThostFtdcInputOrderActionField orderActionReq; memset(&amp;orderActionReq, 0, sizeof(orderActionReq)); ///经纪公司代码 strcpy(orderActionReq.BrokerID, pOrder-&gt;BrokerID); ///投资者代码 strcpy(orderActionReq.InvestorID, pOrder-&gt;InvestorID); ///报单操作引用 // TThostFtdcOrderActionRefType OrderActionRef; ///报单引用 strcpy(orderActionReq.OrderRef, pOrder-&gt;OrderRef); ///请求编号 // TThostFtdcRequestIDType RequestID; ///前置编号 orderActionReq.FrontID = trade_front_id; ///会话编号 orderActionReq.SessionID = session_id; ///交易所代码 // TThostFtdcExchangeIDType ExchangeID; ///报单编号 // TThostFtdcOrderSysIDType OrderSysID; ///操作标志 orderActionReq.ActionFlag = THOST_FTDC_AF_Delete; ///价格 // TThostFtdcPriceType LimitPrice; ///数量变化 // TThostFtdcVolumeType VolumeChange; ///用户代码 // TThostFtdcUserIDType UserID; ///合约代码 strcpy(orderActionReq.InstrumentID, pOrder-&gt;InstrumentID); static int requestID = 0; // 请求编号 int rt = g_pTradeUserApi-&gt;ReqOrderAction(&amp;orderActionReq, ++requestID); if (!rt) std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;发送报单操作请求成功&quot; &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;---&gt;&gt;&gt;发送报单操作请求失败&quot; &lt;&lt; std::endl; orderActionSentFlag = true; } &nbsp; 主要是对于未成交的订单进行编辑或者撤销操作 &nbsp; &nbsp; 报单应答 &nbsp; void CustomTradeSpi::OnRtnOrder(CThostFtdcOrderField *pOrder) { char str[10]; sprintf(str, &quot;%d&quot;, pOrder-&gt;OrderSubmitStatus); int orderState = atoi(str) - 48; //报单状态0=已经提交，3=已经接受 std::cout &lt;&lt; &quot;=====收到报单应答=====&quot; &lt;&lt; std::endl; if (isMyOrder(pOrder)) { if (isTradingOrder(pOrder)) { std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 等待成交中！&quot; &lt;&lt; std::endl; //reqOrderAction(pOrder); // 这里可以撤单 //reqUserLogout(); // 登出测试 } else if (pOrder-&gt;OrderStatus == THOST_FTDC_OST_Canceled) std::cout &lt;&lt; &quot;---&gt;&gt;&gt; 撤单成功！&quot; &lt;&lt; std::endl; } } void CustomTradeSpi::OnRtnTrade(CThostFtdcTradeField *pTrade) { std::cout &lt;&lt; &quot;=====报单成功成交=====&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交时间： &quot; &lt;&lt; pTrade-&gt;TradeTime &lt;&lt; std::endl; std::cout &lt;&lt; &quot;合约代码： &quot; &lt;&lt; pTrade-&gt;InstrumentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交价格： &quot; &lt;&lt; pTrade-&gt;Price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;成交量： &quot; &lt;&lt; pTrade-&gt;Volume &lt;&lt; std::endl; std::cout &lt;&lt; &quot;开平仓方向： &quot; &lt;&lt; pTrade-&gt;Direction &lt;&lt; std::endl; } 等待成交进行轮询可以选择报单操作，成交完成后的应答 &nbsp; 时间序列转K线 从交易拿到的tick数据是时间序列数据，在证券交易中其实还需要根据时间序列算出一些技术指标数据，例如MACD，KDJ、K线等，这里简单地对数据做一下处理，写一个TickToKlineHelper将时间序列专程K线 &nbsp; &nbsp; K线数据结构 &nbsp; // k线数据结构 struct KLineDataType { double open_price; // 开 double high_price; // 高 double low_price; // 低 double close_price; // 收 int volume; // 量 }; 转换函数 &nbsp; &nbsp; void TickToKlineHelper::KLineFromLocalData(const std::string &amp;sFilePath, const std::string &amp;dFilePath) { // 先清理残留数据 m_priceVec.clear(); m_volumeVec.clear(); m_KLineDataArray.clear(); std::cout &lt;&lt; &quot;开始转换tick到k线...&quot; &lt;&lt; std::endl; // 默认读取的tick数据表有4个字段：合约代码、更新时间、最新价、成交量 std::ifstream srcInFile; std::ofstream dstOutFile; srcInFile.open(sFilePath, std::ios::in); dstOutFile.open(dFilePath, std::ios::out); dstOutFile &lt;&lt; &quot;开盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最高价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;最低价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;收盘价&quot; &lt;&lt; &#39;,&#39; &lt;&lt; &quot;成交量&quot; &lt;&lt; std::endl; // 一遍解析文件一边计算k线数据，1分钟k线每次读取60 * 2 = 120行数据 std::string lineStr; bool isFirstLine = true; while (std::getline(srcInFile, lineStr)) { if (isFirstLine) { // 跳过第一行表头 isFirstLine = false; continue; } std::istringstream ss(lineStr); std::string fieldStr; int count = 4; while (std::getline(ss, fieldStr, &#39;,&#39;)) { count--; if (count == 1) m_priceVec.push_back(std::atof(fieldStr.c_str())); else if (count == 0) { m_volumeVec.push_back(std::atoi(fieldStr.c_str())); break; } } // 计算k线 if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); //m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 dstOutFile &lt;&lt; k_line_data.open_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.high_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.low_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.close_price &lt;&lt; &#39;,&#39; &lt;&lt; k_line_data.volume &lt;&lt; std::endl; m_priceVec.clear(); m_volumeVec.clear(); } } srcInFile.close(); dstOutFile.close(); std::cout &lt;&lt; &quot;k线生成成功&quot; &lt;&lt; std::endl; } void TickToKlineHelper::KLineFromRealtimeData(CThostFtdcDepthMarketDataField *pDepthMarketData) { m_priceVec.push_back(pDepthMarketData-&gt;LastPrice); m_volumeVec.push_back(pDepthMarketData-&gt;Volume); if (m_priceVec.size() == kDataLineNum) { KLineDataType k_line_data; k_line_data.open_price = m_priceVec.front(); k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend()); k_line_data.close_price = m_priceVec.back(); // 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量 k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存 m_priceVec.clear(); m_volumeVec.clear(); } } &nbsp; 可以从本地文件中读取行情数据，进行离线转换，也可以在接受到行情时进行实时计算 基本思想是，针对每个合约代码，建立字典，维持一个行情数组，当时间间隔达到要求（例如分钟、分时、分日）时计算该时段的开、高、低、收、成交量等数据存入K线数组 最低时间单位的K线计算出来之后，高时间间隔的K线数据可以根据低时间间隔的K线计算出来（例如，算出了分钟K，那么分时K就根据分钟K来算） 本例子中只是实现了一个大概的原理，非常不精确，仅供参考 策略交易 量化交易系统最终是需要将编写的策略代码挂载到系统中进行策略交易的，这里做了一个简单的实现 StrategyTrade.h #pragma once // ---- 简单策略交易的类 ---- // #include &lt;functional&gt; #include &quot;CTP_API/ThostFtdcUserApiStruct.h&quot; #include &quot;TickToKlineHelper.h&quot; #include &quot;CustomTradeSpi.h&quot; typedef void(*reqOrderInsertFun)( TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction); using ReqOrderInsertFunctionType = std::function&lt; void(TThostFtdcInstrumentIDType instrumentID, TThostFtdcPriceType price, TThostFtdcVolumeType volume, TThostFtdcDirectionType direction)&gt;; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi); StrategyTrade.cpp #include &lt;vector&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &quot;StrategyTrade.h&quot; #include &quot;CustomTradeSpi.h&quot; extern std::unordered_map&lt;std::string, TickToKlineHelper&gt; g_KlineHash; // 线程互斥量 std::mutex marketDataMutex; void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi) { // 加锁 std::lock_guard&lt;std::mutex&gt; lk(marketDataMutex); TickToKlineHelper tickToKlineObject = g_KlineHash.at(std::string(instrumentID)); // 策略 std::vector&lt;double&gt; priceVec = tickToKlineObject.m_priceVec; if (priceVec.size() &gt;= 3) { int len = priceVec.size(); // 最后连续三个上涨就买开仓,反之就卖开仓,这里暂时用最后一个价格下单 if (priceVec[len - 1] &gt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &gt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); else if (priceVec[len - 1] &lt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &lt; priceVec[len - 3]) customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy); } } 基本思想，针对指定合约，判断如果连续三个上涨就买开仓，连续三个下跌就卖开仓，价格都是用最新价 因为行情和交易是分开的线程，涉及到线程竞争，所以在实际下单时需要加入互斥锁，线程同步 策略如何被行情触发然后交易其实需要用事件驱动来做的，这里没有实现T_T 入口 main.cpp int main() { // 账号密码 cout &lt;&lt; &quot;请输入账号： &quot;; scanf(&quot;%s&quot;, gInvesterID); cout &lt;&lt; &quot;请输入密码： &quot;; scanf(&quot;%s&quot;, gInvesterPassword); // 初始化行情线程 cout &lt;&lt; &quot;初始化行情...&quot; &lt;&lt; endl; g_pMdUserApi = CThostFtdcMdApi::CreateFtdcMdApi(); // 创建行情实例 CThostFtdcMdSpi *pMdUserSpi = new CustomMdSpi; // 创建行情回调实例 g_pMdUserApi-&gt;RegisterSpi(pMdUserSpi); // 注册事件类 g_pMdUserApi-&gt;RegisterFront(gMdFrontAddr); // 设置行情前置地址 g_pMdUserApi-&gt;Init(); // 连接运行 // 初始化交易线程 cout &lt;&lt; &quot;初始化交易...&quot; &lt;&lt; endl; g_pTradeUserApi = CThostFtdcTraderApi::CreateFtdcTraderApi(); // 创建交易实例 //CThostFtdcTraderSpi *pTradeSpi = new CustomTradeSpi; CustomTradeSpi *pTradeSpi = new CustomTradeSpi; // 创建交易回调实例 g_pTradeUserApi-&gt;RegisterSpi(pTradeSpi); // 注册事件类 g_pTradeUserApi-&gt;SubscribePublicTopic(THOST_TERT_RESTART); // 订阅公共流 g_pTradeUserApi-&gt;SubscribePrivateTopic(THOST_TERT_RESTART); // 订阅私有流 g_pTradeUserApi-&gt;RegisterFront(gTradeFrontAddr); // 设置交易前置地址 g_pTradeUserApi-&gt;Init(); // 连接运行 // 等到线程退出 g_pMdUserApi-&gt;Join(); delete pMdUserSpi; g_pMdUserApi-&gt;Release(); g_pTradeUserApi-&gt;Join(); delete pTradeSpi; g_pTradeUserApi-&gt;Release(); // 转换本地k线数据 //TickToKlineHelper tickToKlineHelper; //tickToKlineHelper.KLineFromLocalData(&quot;market_data.csv&quot;, &quot;K_line_data.csv&quot;); getchar(); return 0; } CThostFtdcMdApi跟CustomMdSpi要建立关联，CThostFtdcTraderApi跟CustomTradeSpi建立关联，其实就是类似于函数注册 配置行情和交易地址 行情和交易分别是不同的线程，注意线程同步 记得内存回收 运行结果 行情 应答日志 &nbsp; 存成csv表格 &nbsp; 交易 应答日志 &nbsp; &nbsp; K线数据 &nbsp; &nbsp; &nbsp; &nbsp; 报单情况 用上期所的快期软件，登录上自己的账号之后，从过程序下单，在这个界面里能看到实时的报单成交状况 &nbsp; &nbsp; 源码下载 &nbsp; csdn：demo &nbsp; github：demo &nbsp; 结语 &nbsp; 本文旨在为刚接触CTP的小白们抛砖引玉，各交易接口的深度运用还需要看官方开发文档。 另外，对于完整的量化交易系统来说，不仅要具备行情、交易、策略模块，事件驱动、风控、回测模块以及底层的数据存储、网络并发都是需要深入钻研的方面，金融工程的Quant Researcher可以只专注于数据的分析、策略的研发，但是对于程序员Quant Developer来说，如何设计和开发一个高并发、低延迟、功能完善与策略结合紧密的量化交易系统的确是一项需要不断完善的工程。 &nbsp; ps：如果需要更高级和细致甚至可以用于实盘的功能，比如完整的开源交易系统，数据系统，算法交易，数据和交易接口等完备的解决方案，由于博客回复不现实，只能私信联系啦～ 支持是知识分享的动力，有问题可扫码哦 &nbsp; 阅读更多","@type":"BlogPosting","url":"/2017/04/18/53e15bf4fa4fd3d42d1cce65bbc628ad.html","headline":"C++连接CTP接口实现简单量化交易（行情、交易、k线、策略）","dateModified":"2017-04-18T00:00:00+08:00","datePublished":"2017-04-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/04/18/53e15bf4fa4fd3d42d1cce65bbc628ad.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>C++连接CTP接口实现简单量化交易（行情、交易、k线、策略）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/70195889 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css"> 
 <div class="htmledit_views"> 
  <p>对于量化交易来说，量化策略和技术系统缺一不可，为了知其所以然，本文实现了一个C++连接CTP接口进行仿真交易的demo，从接收行情、下订单、数据处理到添加策略、挂载运行交易等多个环节来看一下量化交易的最简单流程，管中窥豹，一探究竟。<img alt="大笑" class="has" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif"></p> 
  <p>&nbsp;</p> 
  <h1>准备工作</h1> 
  <h2>交易所接口</h2> 
  <p>这里使用上期所提供的CTP接口API，通过CTP可以连接交易所进行行情接收交易。下载地址：<a href="http://www.simnow.com.cn/static/softwareDownload.action" rel="nofollow">CTP下载</a></p> 
  <p>本文使用的win32版本的，linux版本用法类似。</p> 
  <p>CTP接口包含以下内容：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170418184846197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <ul>
   <li>ThostFtdcTraderApi.h：C++头文件，包含交易相关的指令，如报单。</li> 
   <li>ThostFtdcMdApi.h：C++头文件，包含获取行情相关的指令。</li> 
   <li>ThostFtdcUserApiStruct.h：包含了所有用到的数据结构。</li> 
   <li>ThostFtdcUserApiDataType.h：包含了所有用到的数据类型。</li> 
   <li>thosttraderapi.lib、thosttraderapi.dll：交易部分的动态链接库和静态链接库。</li> 
   <li>thostmduserapi.lib、thostmduserapi.dll：行情部分的动态链接库和静态链接库。</li> 
   <li>error.dtd、error.xml：包含所有可能的错误信息。</li> 
  </ul>
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>整个开发包有2个核心头文件包括<strong>4个核心接口</strong>，<br> CThostFtdcMdApi接口和CThostFtdcTraderApi两个头文件，一个处理<strong>行情</strong>，一个处理<strong>交易</strong>。</p> 
  <p>（1）处理行情的CThostFtdcMdApi接口有两个类，分别是CThostFtdcMdApi和CThostFtdcMdSpi,以Api结尾的是用来下命令的，以Spi结尾的是用来响应命令的回调。</p> 
  <p>（2）处理交易的CThostFtdcTraderApi接口也有两个类，分别是CThostFtdcTraderApi和CThostFtdcTraderSpi, &nbsp;通过CThostFtdcTraderApi向CTP发送操作请求，通过CThostFtdcTraderSpi接收CTP的操作响应。</p> 
  <p>&nbsp;</p> 
  <h2>期货账户</h2> 
  <p>要连接期货交易所交易，需要开设自己的账户，实现期货交易、银期转账、保证金等功能，由于小白一般不会用实盘资金交易，所以此处推荐用上期所提供的simnow虚拟交易平台<a href="http://www.simnow.com.cn/" rel="nofollow">simnow</a>申请一个虚拟账户。</p> 
  <p>SIMNOW提供两类数据前置地址：</p> 
  <p>（1）交易时段的地址，如09:00-15:00和21:00-02:30，使用第一套地址，这些数据是真实的行情数据，只是时间上比真实的行情会有延迟30秒左右(SIMNOW从交易所接收后转发出来的)。</p> 
  <p>（2）非交易时段地址，这时的数据是历史行情的播放，比如昨天的数据之类的，可以用来做程序调试。</p> 
  <p>&nbsp;</p> 
  <p>建议选择申请那个7x24行情的账户，便于开发调试。</p> 
  <p>&nbsp;</p> 
  <h1>开发步骤</h1> 
  <h2>工程总览</h2> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170418191422809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <p>其中，</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>CTP的API文件配置到工程</li> 
   <li>CustomMdSpi.h，CustomMdSpi.cpp是派生的行情回调类</li> 
   <li>CustomTradeSpi.h，CustomTradeSpi.cpp是派生的交易回调类</li> 
   <li>TickToKlineHelper.h，TickToKlineHelper.cpp是处理时序数据，转换成K线的类</li> 
   <li>StrategyTrade.h，StrategyTrade.cpp是策略类</li> 
   <li>main.cpp是程序的入口</li> 
  </ul>
  <p>一个简单的程序化交易系统需要完成的业务可以划分为：<br> 1.基本操作，比如登录，订阅等；<br> 2.行情操作，比如对行情数据的接收，存储等<br> 3.订单操作，比如报单；对报单，成交状况的查询；报单，成交状况的私有回报等。<br> 4.数据监听和处理操作，比如接收到新数据之后的统计处理，满足统计条件后的报单处理（其实这里就是我们的策略所在）</p> 
  <p>&nbsp;</p> 
  <h2>导入CTP接口库</h2> 
  <p>visual studio创建工程后，首先需要将ctp的头文件以及链接库（lib和dll）目录配置到工程</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170418204556890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// 链接库
#pragma comment (lib, "thostmduserapi.lib")
#pragma comment (lib, "thosttraderapi.lib")</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2>全局参数</h2> 
  <p>连接到交易所，需要配置经纪商代码、帐户名、密码以及订阅合约和买卖合约的相关参数</p> 
  <pre class="has">
<code class="language-cpp">// ---- 全局变量 ---- //
// 公共参数
TThostFtdcBrokerIDType gBrokerID = "9999";                         // 模拟经纪商代码
TThostFtdcInvestorIDType gInvesterID = "";                         // 投资者账户名
TThostFtdcPasswordType gInvesterPassword = "";                     // 投资者密码

// 行情参数
CThostFtdcMdApi *g_pMdUserApi = nullptr;                           // 行情指针
char gMdFrontAddr[] = "tcp://180.168.146.187:10010";               // 模拟行情前置地址
char *g_pInstrumentID[] = {"TF1706", "zn1705", "cs1801", "CF705"}; // 行情合约代码列表，中、上、大、郑交易所各选一种
int instrumentNum = 4;                                             // 行情合约订阅数量
unordered_map&lt;string, TickToKlineHelper&gt; g_KlineHash;              // 不同合约的k线存储表

// 交易参数
CThostFtdcTraderApi *g_pTradeUserApi = nullptr;                    // 交易指针
char gTradeFrontAddr[] = "tcp://180.168.146.187:10001";            // 模拟交易前置地址
TThostFtdcInstrumentIDType g_pTradeInstrumentID = "m1709";         // 所交易的合约代码
TThostFtdcDirectionType gTradeDirection = THOST_FTDC_D_Sell;       // 买卖方向
TThostFtdcPriceType gLimitPrice = 2818;                            // 交易价格
</code>
</pre> 
  <p><br> 这里只是简单的写一下，真实完整的交易系统中，一般用配置文件，有用户去定制</p> 
  <p>&nbsp;</p> 
  <h2>行情回调类</h2> 
  <p>继承CThostFtdcMdSpi实现自己的行情回调类CustomMdSpi，在系统运行时这些重写的函数会被CTP的系统api回调从而实现个性化行情</p> 
  <p><strong>CustomMdSpi头文件</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">#pragma once
// ---- 派生的行情类 ---- //
#include &lt;vector&gt;
#include "CTP_API/ThostFtdcMdApi.h"

class CustomMdSpi: public CThostFtdcMdSpi
{
	// ---- 继承自CTP父类的回调接口并实现 ---- //
public:
	///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。
	void OnFrontConnected();

	///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。
	///@param nReason 错误原因
	///        0x1001 网络读失败
	///        0x1002 网络写失败
	///        0x2001 接收心跳超时
	///        0x2002 发送心跳失败
	///        0x2003 收到错误报文
	void OnFrontDisconnected(int nReason);

	///心跳超时警告。当长时间未收到报文时，该方法被调用。
	///@param nTimeLapse 距离上次接收报文的时间
	void OnHeartBeatWarning(int nTimeLapse);

	///登录请求响应
	void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///登出请求响应
	void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///错误应答
	void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///订阅行情应答
	void OnRspSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///取消订阅行情应答
	void OnRspUnSubMarketData(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///订阅询价应答
	void OnRspSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///取消订阅询价应答
	void OnRspUnSubForQuoteRsp(CThostFtdcSpecificInstrumentField *pSpecificInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///深度行情通知
	void OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData);

	///询价通知
	void OnRtnForQuoteRsp(CThostFtdcForQuoteRspField *pForQuoteRsp);
};</code></pre> 
  <p>&nbsp;</p> 
  <p>都是重写回调函数</p> 
  <p><strong>连接应答</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// 连接成功应答
void CustomMdSpi::OnFrontConnected()
{
	std::cout &lt;&lt; "=====建立网络连接成功=====" &lt;&lt; std::endl;
	// 开始登录
	CThostFtdcReqUserLoginField loginReq;
	memset(&amp;loginReq, 0, sizeof(loginReq));
	strcpy(loginReq.BrokerID, gBrokerID);
	strcpy(loginReq.UserID, gInvesterID);
	strcpy(loginReq.Password, gInvesterPassword);
	static int requestID = 0; // 请求编号
	int rt = g_pMdUserApi-&gt;ReqUserLogin(&amp;loginReq, requestID);
	if (!rt)
		std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;发送登录请求成功" &lt;&lt; std::endl;
	else
		std::cerr &lt;&lt; "---&gt;&gt;&gt;发送登录请求失败" &lt;&lt; std::endl;
}</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>登录应答</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// 登录应答
void CustomMdSpi::OnRspUserLogin(
	CThostFtdcRspUserLoginField *pRspUserLogin, 
	CThostFtdcRspInfoField *pRspInfo, 
	int nRequestID, 
	bool bIsLast)
{
	bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0);
	if (!bResult)
	{
		std::cout &lt;&lt; "=====账户登录成功=====" &lt;&lt; std::endl;
		std::cout &lt;&lt; "交易日： " &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl;
		std::cout &lt;&lt; "登录时间： " &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl;
		std::cout &lt;&lt; "经纪商： " &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl;
		std::cout &lt;&lt; "帐户名： " &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl;
		// 开始订阅行情
		int rt = g_pMdUserApi-&gt;SubscribeMarketData(g_pInstrumentID, instrumentNum);
		if (!rt)
			std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;发送订阅行情请求成功" &lt;&lt; std::endl;
		else
			std::cerr &lt;&lt; "---&gt;&gt;&gt;发送订阅行情请求失败" &lt;&lt; std::endl;
	}
	else
		std::cerr &lt;&lt; "返回错误---&gt;&gt;&gt; ErrorID=" &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; ", ErrorMsg=" &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl;
}
</code>
</pre> 
  <p>&nbsp;</p> 
  <p><strong>订阅行情应答</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// 订阅行情应答
void CustomMdSpi::OnRspSubMarketData(
	CThostFtdcSpecificInstrumentField *pSpecificInstrument, 
	CThostFtdcRspInfoField *pRspInfo, 
	int nRequestID, 
	bool bIsLast)
{
	bool bResult = pRspInfo &amp;&amp; (pRspInfo-&gt;ErrorID != 0);
	if (!bResult)
	{
		std::cout &lt;&lt; "=====订阅行情成功=====" &lt;&lt; std::endl;
		std::cout &lt;&lt; "合约代码： " &lt;&lt; pSpecificInstrument-&gt;InstrumentID &lt;&lt; std::endl;
		// 如果需要存入文件或者数据库，在这里创建表头,不同的合约单独存储
		char filePath[100] = {'\0'};
		sprintf(filePath, "%s_market_data.csv", pSpecificInstrument-&gt;InstrumentID);
		std::ofstream outFile;
		outFile.open(filePath, std::ios::out); // 新开文件
		outFile &lt;&lt; "合约代码" &lt;&lt; ","
			&lt;&lt; "更新时间" &lt;&lt; ","
			&lt;&lt; "最新价" &lt;&lt; ","
			&lt;&lt; "成交量" &lt;&lt; ","
			&lt;&lt; "买价一" &lt;&lt; ","
			&lt;&lt; "买量一" &lt;&lt; ","
			&lt;&lt; "卖价一" &lt;&lt; ","
			&lt;&lt; "卖量一" &lt;&lt; ","
			&lt;&lt; "持仓量" &lt;&lt; ","
			&lt;&lt; "换手率"
			&lt;&lt; std::endl;
		outFile.close();
	}
	else
		std::cerr &lt;&lt; "返回错误---&gt;&gt;&gt; ErrorID=" &lt;&lt; pRspInfo-&gt;ErrorID &lt;&lt; ", ErrorMsg=" &lt;&lt; pRspInfo-&gt;ErrorMsg &lt;&lt; std::endl;
}</code></pre> 
  <p>&nbsp;</p> 
  <ul>
   <li>因为是异步接口，这里连接、登录、订阅行情是一步套一步来调用的，在运行过程中，会启动一个行情线程，交易所每500ms会推送一个订阅的行情tick数据，因此，某些接口会被连续间隔调用，直到连接关闭</li> 
   <li>收到行情后除了存在内存，也可以用文本文件或者数据库等形式存储起来，在这里创建初始文件或者建库</li> 
  </ul>
  <p><strong>深度行情通知</strong></p> 
  <pre class="has">
<code class="language-cpp">// 行情详情通知
void CustomMdSpi::OnRtnDepthMarketData(CThostFtdcDepthMarketDataField *pDepthMarketData)
{
	// 打印行情，字段较多，截取部分
	std::cout &lt;&lt; "=====获得深度行情=====" &lt;&lt; std::endl;
	std::cout &lt;&lt; "交易日： " &lt;&lt; pDepthMarketData-&gt;TradingDay &lt;&lt; std::endl;
	std::cout &lt;&lt; "交易所代码： " &lt;&lt; pDepthMarketData-&gt;ExchangeID &lt;&lt; std::endl;
	std::cout &lt;&lt; "合约代码： " &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; std::endl;
	std::cout &lt;&lt; "合约在交易所的代码： " &lt;&lt; pDepthMarketData-&gt;ExchangeInstID &lt;&lt; std::endl;
	std::cout &lt;&lt; "最新价： " &lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; std::endl;
	std::cout &lt;&lt; "数量： " &lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; std::endl;
	// 如果只获取某一个合约行情，可以逐tick地存入文件或数据库
	char filePath[100] = {'\0'};
	sprintf(filePath, "%s_market_data.csv", pDepthMarketData-&gt;InstrumentID);
	std::ofstream outFile;
	outFile.open(filePath, std::ios::app); // 文件追加写入 
	outFile &lt;&lt; pDepthMarketData-&gt;InstrumentID &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;UpdateTime &lt;&lt; "." &lt;&lt; pDepthMarketData-&gt;UpdateMillisec &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;LastPrice &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;Volume &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;BidPrice1 &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;BidVolume1 &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;AskPrice1 &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;AskVolume1 &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;OpenInterest &lt;&lt; "," 
		&lt;&lt; pDepthMarketData-&gt;Turnover &lt;&lt; std::endl;
	outFile.close();

	// 计算实时k线
	std::string instrumentKey = std::string(pDepthMarketData-&gt;InstrumentID);
	if (g_KlineHash.find(instrumentKey) == g_KlineHash.end())
		g_KlineHash[instrumentKey] = TickToKlineHelper();
	g_KlineHash[instrumentKey].KLineFromRealtimeData(pDepthMarketData);


	// 取消订阅行情
	//int rt = g_pMdUserApi-&gt;UnSubscribeMarketData(g_pInstrumentID, instrumentNum);
	//if (!rt)
	//	std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;发送取消订阅行情请求成功" &lt;&lt; std::endl;
	//else
	//	std::cerr &lt;&lt; "---&gt;&gt;&gt;发送取消订阅行情请求失败" &lt;&lt; std::endl;
}</code></pre> 
  <ul>
   <li>每个tick世间节点系统都会调用这个函数，推送具体的行情截面数据</li> 
   <li>可以在此处将行情写到本地，或者做一些数据处理（例如实时K线计算，判断是否触发策略等）</li> 
  </ul>
  <p>&nbsp;</p> 
  <h2>交易回调类</h2> 
  <p>同理，也需要继承CThostFtdcTraderSpi来实现自己的CustomTradeSpi类，用于交易下单、报单等操作的回调</p> 
  <p><strong>CustomTradeSpi头文件</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">#pragma once
// ---- 派生的交易类 ---- //
#include "CTP_API/ThostFtdcTraderApi.h"

class CustomTradeSpi : public CThostFtdcTraderSpi
{
// ---- ctp_api部分回调接口 ---- //
public:
	///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。
	void OnFrontConnected();

	///登录请求响应
	void OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///错误应答
	void OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///当客户端与交易后台通信连接断开时，该方法被调用。当发生这个情况后，API会自动重新连接，客户端可不做处理。
	void OnFrontDisconnected(int nReason);

	///心跳超时警告。当长时间未收到报文时，该方法被调用。
	void OnHeartBeatWarning(int nTimeLapse);

	///登出请求响应
	void OnRspUserLogout(CThostFtdcUserLogoutField *pUserLogout, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///投资者结算结果确认响应
	void OnRspSettlementInfoConfirm(CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///请求查询合约响应
	void OnRspQryInstrument(CThostFtdcInstrumentField *pInstrument, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///请求查询资金账户响应
	void OnRspQryTradingAccount(CThostFtdcTradingAccountField *pTradingAccount, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///请求查询投资者持仓响应
	void OnRspQryInvestorPosition(CThostFtdcInvestorPositionField *pInvestorPosition, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///报单录入请求响应
	void OnRspOrderInsert(CThostFtdcInputOrderField *pInputOrder, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///报单操作请求响应
	void OnRspOrderAction(CThostFtdcInputOrderActionField *pInputOrderAction, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast);

	///报单通知
	void OnRtnOrder(CThostFtdcOrderField *pOrder);

	///成交通知
	void OnRtnTrade(CThostFtdcTradeField *pTrade);
	
// ---- 自定义函数 ---- //
public:
	bool loginFlag; // 登陆成功的标识
	void reqOrderInsert(
		TThostFtdcInstrumentIDType instrumentID,
		TThostFtdcPriceType price,
		TThostFtdcVolumeType volume,
		TThostFtdcDirectionType direction); // 个性化报单录入，外部调用
private:
	void reqUserLogin(); // 登录请求
	void reqUserLogout(); // 登出请求
	void reqSettlementInfoConfirm(); // 投资者结果确认
	void reqQueryInstrument(); // 请求查询合约
	void reqQueryTradingAccount(); // 请求查询资金帐户
	void reqQueryInvestorPosition(); // 请求查询投资者持仓
	void reqOrderInsert(); // 请求报单录入
	
	void reqOrderAction(CThostFtdcOrderField *pOrder); // 请求报单操作
	bool isErrorRspInfo(CThostFtdcRspInfoField *pRspInfo); // 是否收到错误信息
	bool isMyOrder(CThostFtdcOrderField *pOrder); // 是否我的报单回报
	bool isTradingOrder(CThostFtdcOrderField *pOrder); // 是否正在交易的报单
};</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>除了重写的基类函数，还自己封装一些主动调用的操作函数，比如登入登出、下单报单、查询报单等</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><strong>登录应答</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRspUserLogin(
	CThostFtdcRspUserLoginField *pRspUserLogin,
	CThostFtdcRspInfoField *pRspInfo,
	int nRequestID,
	bool bIsLast)
{
	if (!isErrorRspInfo(pRspInfo))
	{
		std::cout &lt;&lt; "=====账户登录成功=====" &lt;&lt; std::endl;
		loginFlag = true;
		std::cout &lt;&lt; "交易日： " &lt;&lt; pRspUserLogin-&gt;TradingDay &lt;&lt; std::endl;
		std::cout &lt;&lt; "登录时间： " &lt;&lt; pRspUserLogin-&gt;LoginTime &lt;&lt; std::endl;
		std::cout &lt;&lt; "经纪商： " &lt;&lt; pRspUserLogin-&gt;BrokerID &lt;&lt; std::endl;
		std::cout &lt;&lt; "帐户名： " &lt;&lt; pRspUserLogin-&gt;UserID &lt;&lt; std::endl;
		// 保存会话参数
		trade_front_id = pRspUserLogin-&gt;FrontID;
		session_id = pRspUserLogin-&gt;SessionID;
		strcpy(order_ref, pRspUserLogin-&gt;MaxOrderRef);

		// 投资者结算结果确认
		reqSettlementInfoConfirm();
	}
}</code></pre> 
  <p><strong>查询投资者结算结果应答</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRspSettlementInfoConfirm(
	CThostFtdcSettlementInfoConfirmField *pSettlementInfoConfirm,
	CThostFtdcRspInfoField *pRspInfo,
	int nRequestID,
	bool bIsLast)
{
	if (!isErrorRspInfo(pRspInfo))
	{
		std::cout &lt;&lt; "=====投资者结算结果确认成功=====" &lt;&lt; std::endl;
		std::cout &lt;&lt; "确认日期： " &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmDate &lt;&lt; std::endl;
		std::cout &lt;&lt; "确认时间： " &lt;&lt; pSettlementInfoConfirm-&gt;ConfirmTime &lt;&lt; std::endl;
		// 请求查询合约
		reqQueryInstrument();
	}
}</code></pre> 
  <p><strong>查询合约应答</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRspQryInstrument(
	CThostFtdcInstrumentField *pInstrument,
	CThostFtdcRspInfoField *pRspInfo,
	int nRequestID,
	bool bIsLast)
{
	if (!isErrorRspInfo(pRspInfo))
	{
		std::cout &lt;&lt; "=====查询合约结果成功=====" &lt;&lt; std::endl;
		std::cout &lt;&lt; "交易所代码： " &lt;&lt; pInstrument-&gt;ExchangeID &lt;&lt; std::endl;
		std::cout &lt;&lt; "合约代码： " &lt;&lt; pInstrument-&gt;InstrumentID &lt;&lt; std::endl;
		std::cout &lt;&lt; "合约在交易所的代码： " &lt;&lt; pInstrument-&gt;ExchangeInstID &lt;&lt; std::endl;
		std::cout &lt;&lt; "执行价： " &lt;&lt; pInstrument-&gt;StrikePrice &lt;&lt; std::endl;
		std::cout &lt;&lt; "到期日： " &lt;&lt; pInstrument-&gt;EndDelivDate &lt;&lt; std::endl;
		std::cout &lt;&lt; "当前交易状态： " &lt;&lt; pInstrument-&gt;IsTrading &lt;&lt; std::endl;
		// 请求查询投资者资金账户
		reqQueryTradingAccount();
	}
}</code></pre> 
  <p><strong>查询投资者资金帐户应答</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRspQryTradingAccount(
	CThostFtdcTradingAccountField *pTradingAccount,
	CThostFtdcRspInfoField *pRspInfo,
	int nRequestID,
	bool bIsLast)
{
	if (!isErrorRspInfo(pRspInfo))
	{
		std::cout &lt;&lt; "=====查询投资者资金账户成功=====" &lt;&lt; std::endl;
		std::cout &lt;&lt; "投资者账号： " &lt;&lt; pTradingAccount-&gt;AccountID &lt;&lt; std::endl;
		std::cout &lt;&lt; "可用资金： " &lt;&lt; pTradingAccount-&gt;Available &lt;&lt; std::endl;
		std::cout &lt;&lt; "可取资金： " &lt;&lt; pTradingAccount-&gt;WithdrawQuota &lt;&lt; std::endl;
		std::cout &lt;&lt; "当前保证金: " &lt;&lt; pTradingAccount-&gt;CurrMargin &lt;&lt; std::endl;
		std::cout &lt;&lt; "平仓盈亏： " &lt;&lt; pTradingAccount-&gt;CloseProfit &lt;&lt; std::endl;
		// 请求查询投资者持仓
		reqQueryInvestorPosition();
	}
}</code></pre> 
  <p><strong>查询投资者持仓应答</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRspQryInvestorPosition(
	CThostFtdcInvestorPositionField *pInvestorPosition,
	CThostFtdcRspInfoField *pRspInfo,
	int nRequestID,
	bool bIsLast)
{
	if (!isErrorRspInfo(pRspInfo))
	{
		std::cout &lt;&lt; "=====查询投资者持仓成功=====" &lt;&lt; std::endl;
		if (pInvestorPosition)
		{
			std::cout &lt;&lt; "合约代码： " &lt;&lt; pInvestorPosition-&gt;InstrumentID &lt;&lt; std::endl;
			std::cout &lt;&lt; "开仓价格： " &lt;&lt; pInvestorPosition-&gt;OpenAmount &lt;&lt; std::endl;
			std::cout &lt;&lt; "开仓量： " &lt;&lt; pInvestorPosition-&gt;OpenVolume &lt;&lt; std::endl;
			std::cout &lt;&lt; "开仓方向： " &lt;&lt; pInvestorPosition-&gt;PosiDirection &lt;&lt; std::endl;
			std::cout &lt;&lt; "占用保证金：" &lt;&lt; pInvestorPosition-&gt;UseMargin &lt;&lt; std::endl;
		}
		else
			std::cout &lt;&lt; "-----&gt;该合约未持仓" &lt;&lt; std::endl;
		
		// 报单录入请求（这里是一部接口，此处是按顺序执行）
		/*if (loginFlag)
			reqOrderInsert();*/
		if (loginFlag)
			reqOrderInsert(g_pTradeInstrumentID, gLimitPrice, 1, gTradeDirection); // 自定义一笔交易

		// 策略交易
		/*std::cout &lt;&lt; "=====开始进入策略交易=====" &lt;&lt; std::endl;
		while (loginFlag)
			StrategyCheckAndTrade(g_pTradeInstrumentID, this);*/
	}
}</code></pre> 
  <p>这里把下单录入的操作放在了持仓结果出来之后的回调里面，策略交易也简单的放在了这里，真实的情况下，应该是由行情触发某个策略条件开一个线程进行策略交易</p> 
  <p>&nbsp;</p> 
  <p><strong>下单操作</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::reqOrderInsert(
	TThostFtdcInstrumentIDType instrumentID,
	TThostFtdcPriceType price,
	TThostFtdcVolumeType volume,
	TThostFtdcDirectionType direction)
{
	CThostFtdcInputOrderField orderInsertReq;
	memset(&amp;orderInsertReq, 0, sizeof(orderInsertReq));
	///经纪公司代码
	strcpy(orderInsertReq.BrokerID, gBrokerID);
	///投资者代码
	strcpy(orderInsertReq.InvestorID, gInvesterID);
	///合约代码
	strcpy(orderInsertReq.InstrumentID, instrumentID);
	///报单引用
	strcpy(orderInsertReq.OrderRef, order_ref);
	///报单价格条件: 限价
	orderInsertReq.OrderPriceType = THOST_FTDC_OPT_LimitPrice;
	///买卖方向: 
	orderInsertReq.Direction = direction;
	///组合开平标志: 开仓
	orderInsertReq.CombOffsetFlag[0] = THOST_FTDC_OF_Open;
	///组合投机套保标志
	orderInsertReq.CombHedgeFlag[0] = THOST_FTDC_HF_Speculation;
	///价格
	orderInsertReq.LimitPrice = price;
	///数量：1
	orderInsertReq.VolumeTotalOriginal = volume;
	///有效期类型: 当日有效
	orderInsertReq.TimeCondition = THOST_FTDC_TC_GFD;
	///成交量类型: 任何数量
	orderInsertReq.VolumeCondition = THOST_FTDC_VC_AV;
	///最小成交量: 1
	orderInsertReq.MinVolume = 1;
	///触发条件: 立即
	orderInsertReq.ContingentCondition = THOST_FTDC_CC_Immediately;
	///强平原因: 非强平
	orderInsertReq.ForceCloseReason = THOST_FTDC_FCC_NotForceClose;
	///自动挂起标志: 否
	orderInsertReq.IsAutoSuspend = 0;
	///用户强评标志: 否
	orderInsertReq.UserForceClose = 0;

	static int requestID = 0; // 请求编号
	int rt = g_pTradeUserApi-&gt;ReqOrderInsert(&amp;orderInsertReq, ++requestID);
	if (!rt)
		std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;发送报单录入请求成功" &lt;&lt; std::endl;
	else
		std::cerr &lt;&lt; "---&gt;&gt;&gt;发送报单录入请求失败" &lt;&lt; std::endl;
}</code></pre> 
  <p>通过重载写了两个函数，一个是用默认参数下单，一个可以传参下单，比如设定合约代码、价格、数量等</p> 
  <p>&nbsp;</p> 
  <p><strong>报单操作</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::reqOrderAction(CThostFtdcOrderField *pOrder)
{
	static bool orderActionSentFlag = false; // 是否发送了报单
	if (orderActionSentFlag)
		return;

	CThostFtdcInputOrderActionField orderActionReq;
	memset(&amp;orderActionReq, 0, sizeof(orderActionReq));
	///经纪公司代码
	strcpy(orderActionReq.BrokerID, pOrder-&gt;BrokerID);
	///投资者代码
	strcpy(orderActionReq.InvestorID, pOrder-&gt;InvestorID);
	///报单操作引用
	//	TThostFtdcOrderActionRefType	OrderActionRef;
	///报单引用
	strcpy(orderActionReq.OrderRef, pOrder-&gt;OrderRef);
	///请求编号
	//	TThostFtdcRequestIDType	RequestID;
	///前置编号
	orderActionReq.FrontID = trade_front_id;
	///会话编号
	orderActionReq.SessionID = session_id;
	///交易所代码
	//	TThostFtdcExchangeIDType	ExchangeID;
	///报单编号
	//	TThostFtdcOrderSysIDType	OrderSysID;
	///操作标志
	orderActionReq.ActionFlag = THOST_FTDC_AF_Delete;
	///价格
	//	TThostFtdcPriceType	LimitPrice;
	///数量变化
	//	TThostFtdcVolumeType	VolumeChange;
	///用户代码
	//	TThostFtdcUserIDType	UserID;
	///合约代码
	strcpy(orderActionReq.InstrumentID, pOrder-&gt;InstrumentID);
	static int requestID = 0; // 请求编号
	int rt = g_pTradeUserApi-&gt;ReqOrderAction(&amp;orderActionReq, ++requestID);
	if (!rt)
		std::cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;发送报单操作请求成功" &lt;&lt; std::endl;
	else
		std::cerr &lt;&lt; "---&gt;&gt;&gt;发送报单操作请求失败" &lt;&lt; std::endl;
	orderActionSentFlag = true;
}</code></pre> 
  <p>&nbsp;</p> 
  <p>主要是对于未成交的订单进行编辑或者撤销操作</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><strong>报单应答</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void CustomTradeSpi::OnRtnOrder(CThostFtdcOrderField *pOrder)
{
	char str[10];
	sprintf(str, "%d", pOrder-&gt;OrderSubmitStatus);
	int orderState = atoi(str) - 48;	//报单状态0=已经提交，3=已经接受

	std::cout &lt;&lt; "=====收到报单应答=====" &lt;&lt; std::endl;

	if (isMyOrder(pOrder))
	{
		if (isTradingOrder(pOrder))
		{
			std::cout &lt;&lt; "---&gt;&gt;&gt; 等待成交中！" &lt;&lt; std::endl;
			//reqOrderAction(pOrder); // 这里可以撤单
			//reqUserLogout(); // 登出测试
		}
		else if (pOrder-&gt;OrderStatus == THOST_FTDC_OST_Canceled)
			std::cout &lt;&lt; "---&gt;&gt;&gt; 撤单成功！" &lt;&lt; std::endl;
	}
}

void CustomTradeSpi::OnRtnTrade(CThostFtdcTradeField *pTrade)
{
	std::cout &lt;&lt; "=====报单成功成交=====" &lt;&lt; std::endl;
	std::cout &lt;&lt; "成交时间： " &lt;&lt; pTrade-&gt;TradeTime &lt;&lt; std::endl;
	std::cout &lt;&lt; "合约代码： " &lt;&lt; pTrade-&gt;InstrumentID &lt;&lt; std::endl;
	std::cout &lt;&lt; "成交价格： " &lt;&lt; pTrade-&gt;Price &lt;&lt; std::endl;
	std::cout &lt;&lt; "成交量： " &lt;&lt; pTrade-&gt;Volume &lt;&lt; std::endl;
	std::cout &lt;&lt; "开平仓方向： " &lt;&lt; pTrade-&gt;Direction &lt;&lt; std::endl;
}</code></pre> 
  <p>等待成交进行轮询可以选择报单操作，成交完成后的应答</p> 
  <p>&nbsp;</p> 
  <h2>时间序列转K线</h2> 
  <p>从交易拿到的tick数据是时间序列数据，在证券交易中其实还需要根据时间序列算出一些技术指标数据，例如MACD，KDJ、K线等，这里简单地对数据做一下处理，写一个TickToKlineHelper将时间序列专程K线</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><strong>K线数据结构</strong></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// k线数据结构
struct KLineDataType
{
	double open_price;   // 开
	double high_price;   // 高
	double low_price;    // 低
	double close_price;  // 收
	int volume;          // 量
};</code></pre> 
  <p><br><strong>转换函数</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">void TickToKlineHelper::KLineFromLocalData(const std::string &amp;sFilePath, const std::string &amp;dFilePath)
{
	// 先清理残留数据
	m_priceVec.clear();
	m_volumeVec.clear();
	m_KLineDataArray.clear();

	std::cout &lt;&lt; "开始转换tick到k线..." &lt;&lt; std::endl;
	// 默认读取的tick数据表有4个字段：合约代码、更新时间、最新价、成交量
	std::ifstream srcInFile;
	std::ofstream dstOutFile;
	srcInFile.open(sFilePath, std::ios::in);
	dstOutFile.open(dFilePath, std::ios::out);
	dstOutFile &lt;&lt; "开盘价" &lt;&lt; ','
		&lt;&lt; "最高价" &lt;&lt; ','
		&lt;&lt; "最低价" &lt;&lt; ','
		&lt;&lt; "收盘价" &lt;&lt; ',' 
		&lt;&lt; "成交量" &lt;&lt; std::endl;

	// 一遍解析文件一边计算k线数据，1分钟k线每次读取60 * 2 = 120行数据
	std::string lineStr;
	bool isFirstLine = true;
	while (std::getline(srcInFile, lineStr))
	{
		if (isFirstLine)
		{
			// 跳过第一行表头
			isFirstLine = false;
			continue;
		}
		std::istringstream ss(lineStr);
		std::string fieldStr;
		int count = 4;
		while (std::getline(ss, fieldStr, ','))
		{
			count--;
			if (count == 1)
				m_priceVec.push_back(std::atof(fieldStr.c_str()));
			else if (count == 0)
			{
				m_volumeVec.push_back(std::atoi(fieldStr.c_str()));
				break;
			}
		}

		// 计算k线

		if (m_priceVec.size() == kDataLineNum)
		{
			KLineDataType k_line_data;
			k_line_data.open_price = m_priceVec.front();
			k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend());
			k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend());
			k_line_data.close_price = m_priceVec.back();
			// 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量
			k_line_data.volume = m_volumeVec.back() - m_volumeVec.front(); 
			//m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存
			
			dstOutFile &lt;&lt; k_line_data.open_price &lt;&lt; ','
				&lt;&lt; k_line_data.high_price &lt;&lt; ','
				&lt;&lt; k_line_data.low_price &lt;&lt; ','
				&lt;&lt; k_line_data.close_price &lt;&lt; ','
				&lt;&lt; k_line_data.volume &lt;&lt; std::endl;

			m_priceVec.clear();
			m_volumeVec.clear();
		}
	}

	srcInFile.close();
	dstOutFile.close();

	std::cout &lt;&lt; "k线生成成功" &lt;&lt; std::endl;
}

void TickToKlineHelper::KLineFromRealtimeData(CThostFtdcDepthMarketDataField *pDepthMarketData)
{
	m_priceVec.push_back(pDepthMarketData-&gt;LastPrice);
	m_volumeVec.push_back(pDepthMarketData-&gt;Volume);
	if (m_priceVec.size() == kDataLineNum)
	{
		KLineDataType k_line_data;
		k_line_data.open_price = m_priceVec.front();
		k_line_data.high_price = *std::max_element(m_priceVec.cbegin(), m_priceVec.cend());
		k_line_data.low_price = *std::min_element(m_priceVec.cbegin(), m_priceVec.cend());
		k_line_data.close_price = m_priceVec.back();
		// 成交量的真实的算法是当前区间最后一个成交量减去上去一个区间最后一个成交量
		k_line_data.volume = m_volumeVec.back() - m_volumeVec.front();
		m_KLineDataArray.push_back(k_line_data); // 此处可以存到内存

		m_priceVec.clear();
		m_volumeVec.clear();
	}
}
</code>
</pre> 
  <p>&nbsp;</p> 
  <ul>
   <li>可以从本地文件中读取行情数据，进行离线转换，也可以在接受到行情时进行实时计算</li> 
   <li>基本思想是，针对每个合约代码，建立字典，维持一个行情数组，当时间间隔达到要求（例如分钟、分时、分日）时计算该时段的开、高、低、收、成交量等数据存入K线数组</li> 
   <li>最低时间单位的K线计算出来之后，高时间间隔的K线数据可以根据低时间间隔的K线计算出来（例如，算出了分钟K，那么分时K就根据分钟K来算）</li> 
   <li>本例子中只是实现了一个大概的原理，非常不精确，仅供参考</li> 
  </ul>
  <h2>策略交易</h2> 
  <p>量化交易系统最终是需要将编写的策略代码挂载到系统中进行策略交易的，这里做了一个简单的实现</p> 
  <p>StrategyTrade.h</p> 
  <pre class="has">
<code class="language-cpp">#pragma once
// ---- 简单策略交易的类 ---- //

#include &lt;functional&gt;
#include "CTP_API/ThostFtdcUserApiStruct.h"
#include "TickToKlineHelper.h"
#include "CustomTradeSpi.h"

typedef void(*reqOrderInsertFun)(
	TThostFtdcInstrumentIDType instrumentID,
	TThostFtdcPriceType price,
	TThostFtdcVolumeType volume,
	TThostFtdcDirectionType direction);

using ReqOrderInsertFunctionType = std::function&lt;
	void(TThostFtdcInstrumentIDType instrumentID,
	TThostFtdcPriceType price,
	TThostFtdcVolumeType volume,
	TThostFtdcDirectionType direction)&gt;;

void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi);
</code>
</pre> 
  <p><br> StrategyTrade.cpp</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include "StrategyTrade.h"
#include "CustomTradeSpi.h"

extern std::unordered_map&lt;std::string, TickToKlineHelper&gt; g_KlineHash;

// 线程互斥量
std::mutex marketDataMutex;

void StrategyCheckAndTrade(TThostFtdcInstrumentIDType instrumentID, CustomTradeSpi *customTradeSpi)
{
	// 加锁
	std::lock_guard&lt;std::mutex&gt; lk(marketDataMutex);
	TickToKlineHelper tickToKlineObject = g_KlineHash.at(std::string(instrumentID));
	// 策略
	std::vector&lt;double&gt; priceVec = tickToKlineObject.m_priceVec;
	if (priceVec.size() &gt;= 3)
	{
		int len = priceVec.size();
		// 最后连续三个上涨就买开仓,反之就卖开仓,这里暂时用最后一个价格下单
		if (priceVec[len - 1] &gt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &gt; priceVec[len - 3])
			customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy);
		else if (priceVec[len - 1] &lt; priceVec[len - 2] &amp;&amp; priceVec[len - 2] &lt; priceVec[len - 3])
			customTradeSpi-&gt;reqOrderInsert(instrumentID, priceVec[len - 1], 1, THOST_FTDC_D_Buy);
	}
}
</code>
</pre> 
  <ul>
   <li>基本思想，针对指定合约，判断如果连续三个上涨就买开仓，连续三个下跌就卖开仓，价格都是用最新价</li> 
   <li>因为行情和交易是分开的线程，涉及到线程竞争，所以在实际下单时需要加入互斥锁，线程同步</li> 
   <li>策略如何被行情触发然后交易其实需要用事件驱动来做的，这里没有实现T_T</li> 
  </ul>
  <h2>入口</h2> 
  <p>main.cpp</p> 
  <pre class="has">
<code class="language-cpp">int main()
{
	// 账号密码
	cout &lt;&lt; "请输入账号： ";
	scanf("%s", gInvesterID);
	cout &lt;&lt; "请输入密码： ";
	scanf("%s", gInvesterPassword);

	// 初始化行情线程
	cout &lt;&lt; "初始化行情..." &lt;&lt; endl;
	g_pMdUserApi = CThostFtdcMdApi::CreateFtdcMdApi();   // 创建行情实例
	CThostFtdcMdSpi *pMdUserSpi = new CustomMdSpi;       // 创建行情回调实例
	g_pMdUserApi-&gt;RegisterSpi(pMdUserSpi);               // 注册事件类
	g_pMdUserApi-&gt;RegisterFront(gMdFrontAddr);           // 设置行情前置地址
	g_pMdUserApi-&gt;Init();                                // 连接运行
	


	// 初始化交易线程
	cout &lt;&lt; "初始化交易..." &lt;&lt; endl;
	g_pTradeUserApi = CThostFtdcTraderApi::CreateFtdcTraderApi(); // 创建交易实例
	//CThostFtdcTraderSpi *pTradeSpi = new CustomTradeSpi;
	CustomTradeSpi *pTradeSpi = new CustomTradeSpi;               // 创建交易回调实例
	g_pTradeUserApi-&gt;RegisterSpi(pTradeSpi);                      // 注册事件类
	g_pTradeUserApi-&gt;SubscribePublicTopic(THOST_TERT_RESTART);    // 订阅公共流
	g_pTradeUserApi-&gt;SubscribePrivateTopic(THOST_TERT_RESTART);   // 订阅私有流
	g_pTradeUserApi-&gt;RegisterFront(gTradeFrontAddr);              // 设置交易前置地址
	g_pTradeUserApi-&gt;Init();                                      // 连接运行
		

	// 等到线程退出
	g_pMdUserApi-&gt;Join();
	delete pMdUserSpi;
	g_pMdUserApi-&gt;Release();

	g_pTradeUserApi-&gt;Join();
	delete pTradeSpi;
	g_pTradeUserApi-&gt;Release();

	// 转换本地k线数据
	//TickToKlineHelper tickToKlineHelper;
	//tickToKlineHelper.KLineFromLocalData("market_data.csv", "K_line_data.csv");
	
	getchar();
	return 0;
}</code></pre> 
  <ul>
   <li>CThostFtdcMdApi跟CustomMdSpi要建立关联，CThostFtdcTraderApi跟CustomTradeSpi建立关联，其实就是类似于函数注册</li> 
   <li>配置行情和交易地址</li> 
   <li>行情和交易分别是不同的线程，注意线程同步</li> 
   <li>记得内存回收</li> 
  </ul>
  <h1>运行结果</h1> 
  <h2>行情</h2> 
  <p>应答日志</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170417215811398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>存成csv表格</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170418214637074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <h2>交易</h2> 
  <p>应答日志</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170417215830533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2>K线数据</h2> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170418214714089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2>报单情况</h2> 
  <p>用上期所的<a href="http://www.kuaiqi.net/portal.php?mod=view&amp;aid=47" rel="nofollow">快期软件</a>，登录上自己的账号之后，从过程序下单，在这个界面里能看到实时的报单成交状况</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170417215848789?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h1>源码下载</h1> 
  <p>&nbsp;</p> 
  <p>csdn：<a href="http://download.csdn.net/detail/u012234115/9818093" rel="nofollow">demo</a></p> 
  <p>&nbsp;</p> 
  <p>github：<a href="https://github.com/tashaxing/CTPtest" rel="nofollow">demo</a></p> 
  <p>&nbsp;</p> 
  <h1>结语</h1> 
  <p>&nbsp;</p> 
  <p>本文旨在为刚接触CTP的小白们抛砖引玉，各交易接口的深度运用还需要看官方开发文档。</p> 
  <p>另外，对于完整的量化交易系统来说，不仅要具备行情、交易、策略模块，事件驱动、风控、回测模块以及底层的数据存储、网络并发都是需要深入钻研的方面，金融工程的Quant Researcher可以只专注于数据的分析、策略的研发，但是对于程序员Quant Developer来说，如何设计和开发一个高并发、低延迟、功能完善与策略结合紧密的量化交易系统的确是一项需要不断完善的工程。</p> 
  <p>&nbsp;</p> 
  <p>ps：如果需要更高级和细致甚至可以用于实盘的功能，比如完整的开源交易系统，数据系统，算法交易，数据和交易接口等完备的解决方案，由于博客回复不现实，只能私信联系啦～</p> 
  <div style="text-align:center;"> 
   <figure class="image has">
    <img alt="" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180814152012355?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyMzQxMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
    <figcaption>
     支持是知识分享的动力，有问题可扫码哦
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012234115/article/details/70195889,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012234115/article/details/70195889,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
