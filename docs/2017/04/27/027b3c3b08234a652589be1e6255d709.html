<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>数字货币开发专题（安全散列算法SHA256） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="数字货币开发专题（安全散列算法SHA256）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; 区块链爱好者（QQ：53016353） &nbsp;&nbsp; 数字货币开发使用椭圆曲线算法生成公钥和私钥，选择的是secp256k1曲线。生成的公钥是33字节的大数，私钥是32字节的大数，钱包文件wallet.dat中直接保存了公钥和私钥。我们在接收和发送比特币时用到的比特币地址是公钥经过算法处理后得到的，具体过程是公钥先经过SHA-256算法处理得到32字节的哈希结果，再经过RIPEMED算法处理后得到20字节的摘要结果，再经过字符转换过程得到我们看到的地址。这个字符转换过程与私钥的字符转换过程完成相同，步骤是先把输入的内容（对于公钥就是20字节的摘要结果，对于私钥就是32字节的大数）增加版本号，经过连续两次SHA-256算法，取后一次哈希结果的前4字节作为校验码附在输入内容的后面，然后再经过Base58编码，得到字符串。 &nbsp; &nbsp; &nbsp; &nbsp;数字货币开发这里需要提一下的是Base58编码为了让输出字符串易于辨别，所以编码时故意排除了4个字符：&#39;0&#39;、&#39;I&#39;、&#39;l&#39;、&#39;O&#39;，如果你想生成一个带特殊词缀的地址那就不要带这4个符了，比如我的ID（walker）也就不能生成了。 安全散列算法SHA（Secure Hash Algorithm）是美国国家安全局 （NSA） 设计，美国国家标准与技术研究院（NIST） 发布的一系列密码散列函数，包括 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512 等变体。主要适用于数字签名标准（DigitalSignature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。下面以 SHA-1为例，介绍该算法计算消息摘要的原理。 对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 　　SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。 　　一、术语和概念 　　（一）位(Bit)，字节（Byte）和字（Word） 　　SHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串:0x616263. 　　（二）运算符和符号 　　下面的逻辑运算符都被运用于“字”（Word） 　　X^Y = X，Y逻辑与 　　X \/ Y = X，Y逻辑或 　　X XOR Y= X，Y逻辑异或 　　~X = X逻辑取反 　　X+Y定义如下： 　　字 X 和Y 代表两个整数 x 和y, 其中0 &lt;= x &lt; 2^32 且 0 &lt;= y &lt; 2^32. 令整数z= (x + y) mod 2^32. 这时候 0 &lt;= z &lt; 2^32. 将z转换成字Z,那么就是 Z = X + Y. 　　循环左移位操作符Sn(X)。X是一个字，n是一个整数，0&lt;=n&lt;=32。Sn(X)= (X&lt;&gt;32-n) 　　X&lt;定义如下：抛弃最左边的n位数字，将各个位依次向左移动n位，然后用0填补右边的n位（最后结果还是32位）。X&gt;&gt;n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算 　　二、SHA1算法描述 　　在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下： 　　01100001 0110001001100011 　　――――――――――――― 　　‘a’=97 ‘b’=98‘c’=99 　　这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。 　　（一）补位 　　消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。 　　补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。 　　原始信息：01100001 01100010 01100011 　　补位第一步：0110000101100010 01100011 1 　　首先补一个“1” 　　补位第二步：0110000101100010 01100011 10…..0 　　然后补423个“0” 　　我们可以把最后补位完成后的数据用16进制写成下面的样子 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 00000000 　　现在，数据的长度是448了，我们可以进行下一步操作。 　　（二）补长度 　　所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式） 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000018 　　如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。 　　（三）使用的常量 　　一系列的常量字K(0),K(1), ... , K(79)，如果以16进制给出。它们如下： 　　Kt = 0x5A827999 (0&lt;= t &lt;= 19) 　　Kt = 0x6ED9EBA1 (20&lt;= t &lt;= 39) 　　Kt = 0x8F1BBCDC (40&lt;= t &lt;= 59) 　　Kt = 0xCA62C1D6 (60&lt;= t &lt;= 79). 　　（四）需要使用的函数 　　在SHA1中我们需要一系列的函数。每个函数ft (0 &lt;= t &lt;= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义 　　ft(B,C,D) = (B ANDC) or ((NOT B) AND D) ( 0 &lt;= t &lt;= 19) 　　ft(B,C,D) = B XOR CXOR D (20 &lt;= t &lt;= 39) 　　ft(B,C,D) = (B ANDC) or (B AND D) or (C AND D) (40 &lt;= t &lt;= 59) 　　ft(B,C,D) = B XOR CXOR D (60 &lt;= t &lt;= 79). 　　（五）计算消息摘要 　　必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0,H1, H2, H3, H4。80个字的缓冲区被标识为W0,W1,..., W79 　　另外还需要一个一个字的TEMP缓冲区。 　　为了产生消息摘要，在第4部分中定义的16个字的数据块M1,M2,..., Mn 　　会依次进行处理，处理每个数据块Mi 包含80个步骤。 　　在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制） 　　H0 = 0x67452301 　　H1 = 0xEFCDAB89 　　H2 = 0x98BADCFE 　　H3 = 0x10325476 　　H4 = 0xC3D2E1F0. 　　现在开始处理M1, M2,... , Mn。为了处理 Mi,需要进行下面的步骤 　　(1). 将Mi 分成 16 个字 W0, W1, ... , W15,W0 是最左边的字 　　(2). 对于t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8XOR Wt- 14 XOR Wt-16). 　　(3). 令A = H0, B = H1, C = H2, D = H3, E = H4. 　　(4) 对于t = 0 到 79，执行下面的循环 　　TEMP = S5(A) +ft(B,C,D) + E + Wt + Kt; 　　E = D; D = C; C =S30(B); B = A; A = TEMP; 　　(5). 令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 　　在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识 　　H0 H1 H2 H3 H4. 　　对于SHA256、SHA384、SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。 　 &nbsp;三、SHA算法被破解了吗？ 2013年9月10日美国约翰霍普金斯大学的计算机科学教授，知名的加密算法专家，Matthew Green被NSA要求删除他的一份关于破解加密算法的与NSA有关的博客。 同时约翰霍普金斯大学服务器上的该博客镜像也被要求删除。 matt-green 加密算法专家，美国约翰霍普金斯大学教授Matthew Green 但当记者向该大学求证时，该校称从未收到来自NSA的要求要删除博客或镜像的资料，但记者却无法在原网址再找到该博客。幸运的是，从谷歌的缓存可以找到该博客。该博客提到NSA每年花费2.5亿美元来为自己在解密信息方面获取优势，并列举了NSA的一系列见不得人的做法。 on-the-nsa 在BitcoinTalk上，已经掀起了一轮争论：到底SHA-2是否安全？ 部分认为不安全的观点包括： NSA制造了sha-2, 我们不相信NSA，他们不可能不留后门。 棱镜事件已经明白的告诉我们，政府会用一切可能的手段来监视与解密。 虽然有很多人会研究SHA-2，且目前没有公开的证据表明有漏洞。但没有公开这并不能代表就没有，因为发现漏洞的人一定更倾向于保留这个秘密来自己利用，而不是公布。 部分认为安全的观点包括： SHA-2是应用广泛的算法，应该已经经历了实践的检验。 美国的对头中国和俄国都有很多杰出的数学家，如果有问题的话，他们肯定已经发现了。 如果真的不安全，世界上安全的东西就太少了，我不能生活在提心吊胆里，所以我选择相信安全。 &nbsp;security 阅读更多" />
<meta property="og:description" content="&nbsp; 区块链爱好者（QQ：53016353） &nbsp;&nbsp; 数字货币开发使用椭圆曲线算法生成公钥和私钥，选择的是secp256k1曲线。生成的公钥是33字节的大数，私钥是32字节的大数，钱包文件wallet.dat中直接保存了公钥和私钥。我们在接收和发送比特币时用到的比特币地址是公钥经过算法处理后得到的，具体过程是公钥先经过SHA-256算法处理得到32字节的哈希结果，再经过RIPEMED算法处理后得到20字节的摘要结果，再经过字符转换过程得到我们看到的地址。这个字符转换过程与私钥的字符转换过程完成相同，步骤是先把输入的内容（对于公钥就是20字节的摘要结果，对于私钥就是32字节的大数）增加版本号，经过连续两次SHA-256算法，取后一次哈希结果的前4字节作为校验码附在输入内容的后面，然后再经过Base58编码，得到字符串。 &nbsp; &nbsp; &nbsp; &nbsp;数字货币开发这里需要提一下的是Base58编码为了让输出字符串易于辨别，所以编码时故意排除了4个字符：&#39;0&#39;、&#39;I&#39;、&#39;l&#39;、&#39;O&#39;，如果你想生成一个带特殊词缀的地址那就不要带这4个符了，比如我的ID（walker）也就不能生成了。 安全散列算法SHA（Secure Hash Algorithm）是美国国家安全局 （NSA） 设计，美国国家标准与技术研究院（NIST） 发布的一系列密码散列函数，包括 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512 等变体。主要适用于数字签名标准（DigitalSignature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。下面以 SHA-1为例，介绍该算法计算消息摘要的原理。 对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 　　SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。 　　一、术语和概念 　　（一）位(Bit)，字节（Byte）和字（Word） 　　SHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串:0x616263. 　　（二）运算符和符号 　　下面的逻辑运算符都被运用于“字”（Word） 　　X^Y = X，Y逻辑与 　　X \/ Y = X，Y逻辑或 　　X XOR Y= X，Y逻辑异或 　　~X = X逻辑取反 　　X+Y定义如下： 　　字 X 和Y 代表两个整数 x 和y, 其中0 &lt;= x &lt; 2^32 且 0 &lt;= y &lt; 2^32. 令整数z= (x + y) mod 2^32. 这时候 0 &lt;= z &lt; 2^32. 将z转换成字Z,那么就是 Z = X + Y. 　　循环左移位操作符Sn(X)。X是一个字，n是一个整数，0&lt;=n&lt;=32。Sn(X)= (X&lt;&gt;32-n) 　　X&lt;定义如下：抛弃最左边的n位数字，将各个位依次向左移动n位，然后用0填补右边的n位（最后结果还是32位）。X&gt;&gt;n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算 　　二、SHA1算法描述 　　在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下： 　　01100001 0110001001100011 　　――――――――――――― 　　‘a’=97 ‘b’=98‘c’=99 　　这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。 　　（一）补位 　　消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。 　　补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。 　　原始信息：01100001 01100010 01100011 　　补位第一步：0110000101100010 01100011 1 　　首先补一个“1” 　　补位第二步：0110000101100010 01100011 10…..0 　　然后补423个“0” 　　我们可以把最后补位完成后的数据用16进制写成下面的样子 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 00000000 　　现在，数据的长度是448了，我们可以进行下一步操作。 　　（二）补长度 　　所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式） 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000018 　　如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。 　　（三）使用的常量 　　一系列的常量字K(0),K(1), ... , K(79)，如果以16进制给出。它们如下： 　　Kt = 0x5A827999 (0&lt;= t &lt;= 19) 　　Kt = 0x6ED9EBA1 (20&lt;= t &lt;= 39) 　　Kt = 0x8F1BBCDC (40&lt;= t &lt;= 59) 　　Kt = 0xCA62C1D6 (60&lt;= t &lt;= 79). 　　（四）需要使用的函数 　　在SHA1中我们需要一系列的函数。每个函数ft (0 &lt;= t &lt;= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义 　　ft(B,C,D) = (B ANDC) or ((NOT B) AND D) ( 0 &lt;= t &lt;= 19) 　　ft(B,C,D) = B XOR CXOR D (20 &lt;= t &lt;= 39) 　　ft(B,C,D) = (B ANDC) or (B AND D) or (C AND D) (40 &lt;= t &lt;= 59) 　　ft(B,C,D) = B XOR CXOR D (60 &lt;= t &lt;= 79). 　　（五）计算消息摘要 　　必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0,H1, H2, H3, H4。80个字的缓冲区被标识为W0,W1,..., W79 　　另外还需要一个一个字的TEMP缓冲区。 　　为了产生消息摘要，在第4部分中定义的16个字的数据块M1,M2,..., Mn 　　会依次进行处理，处理每个数据块Mi 包含80个步骤。 　　在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制） 　　H0 = 0x67452301 　　H1 = 0xEFCDAB89 　　H2 = 0x98BADCFE 　　H3 = 0x10325476 　　H4 = 0xC3D2E1F0. 　　现在开始处理M1, M2,... , Mn。为了处理 Mi,需要进行下面的步骤 　　(1). 将Mi 分成 16 个字 W0, W1, ... , W15,W0 是最左边的字 　　(2). 对于t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8XOR Wt- 14 XOR Wt-16). 　　(3). 令A = H0, B = H1, C = H2, D = H3, E = H4. 　　(4) 对于t = 0 到 79，执行下面的循环 　　TEMP = S5(A) +ft(B,C,D) + E + Wt + Kt; 　　E = D; D = C; C =S30(B); B = A; A = TEMP; 　　(5). 令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 　　在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识 　　H0 H1 H2 H3 H4. 　　对于SHA256、SHA384、SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。 　 &nbsp;三、SHA算法被破解了吗？ 2013年9月10日美国约翰霍普金斯大学的计算机科学教授，知名的加密算法专家，Matthew Green被NSA要求删除他的一份关于破解加密算法的与NSA有关的博客。 同时约翰霍普金斯大学服务器上的该博客镜像也被要求删除。 matt-green 加密算法专家，美国约翰霍普金斯大学教授Matthew Green 但当记者向该大学求证时，该校称从未收到来自NSA的要求要删除博客或镜像的资料，但记者却无法在原网址再找到该博客。幸运的是，从谷歌的缓存可以找到该博客。该博客提到NSA每年花费2.5亿美元来为自己在解密信息方面获取优势，并列举了NSA的一系列见不得人的做法。 on-the-nsa 在BitcoinTalk上，已经掀起了一轮争论：到底SHA-2是否安全？ 部分认为不安全的观点包括： NSA制造了sha-2, 我们不相信NSA，他们不可能不留后门。 棱镜事件已经明白的告诉我们，政府会用一切可能的手段来监视与解密。 虽然有很多人会研究SHA-2，且目前没有公开的证据表明有漏洞。但没有公开这并不能代表就没有，因为发现漏洞的人一定更倾向于保留这个秘密来自己利用，而不是公布。 部分认为安全的观点包括： SHA-2是应用广泛的算法，应该已经经历了实践的检验。 美国的对头中国和俄国都有很多杰出的数学家，如果有问题的话，他们肯定已经发现了。 如果真的不安全，世界上安全的东西就太少了，我不能生活在提心吊胆里，所以我选择相信安全。 &nbsp;security 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/04/27/027b3c3b08234a652589be1e6255d709.html" />
<meta property="og:url" content="https://mlh.app/2017/04/27/027b3c3b08234a652589be1e6255d709.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; 区块链爱好者（QQ：53016353） &nbsp;&nbsp; 数字货币开发使用椭圆曲线算法生成公钥和私钥，选择的是secp256k1曲线。生成的公钥是33字节的大数，私钥是32字节的大数，钱包文件wallet.dat中直接保存了公钥和私钥。我们在接收和发送比特币时用到的比特币地址是公钥经过算法处理后得到的，具体过程是公钥先经过SHA-256算法处理得到32字节的哈希结果，再经过RIPEMED算法处理后得到20字节的摘要结果，再经过字符转换过程得到我们看到的地址。这个字符转换过程与私钥的字符转换过程完成相同，步骤是先把输入的内容（对于公钥就是20字节的摘要结果，对于私钥就是32字节的大数）增加版本号，经过连续两次SHA-256算法，取后一次哈希结果的前4字节作为校验码附在输入内容的后面，然后再经过Base58编码，得到字符串。 &nbsp; &nbsp; &nbsp; &nbsp;数字货币开发这里需要提一下的是Base58编码为了让输出字符串易于辨别，所以编码时故意排除了4个字符：&#39;0&#39;、&#39;I&#39;、&#39;l&#39;、&#39;O&#39;，如果你想生成一个带特殊词缀的地址那就不要带这4个符了，比如我的ID（walker）也就不能生成了。 安全散列算法SHA（Secure Hash Algorithm）是美国国家安全局 （NSA） 设计，美国国家标准与技术研究院（NIST） 发布的一系列密码散列函数，包括 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512 等变体。主要适用于数字签名标准（DigitalSignature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。下面以 SHA-1为例，介绍该算法计算消息摘要的原理。 对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 　　SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。 　　一、术语和概念 　　（一）位(Bit)，字节（Byte）和字（Word） 　　SHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串:0x616263. 　　（二）运算符和符号 　　下面的逻辑运算符都被运用于“字”（Word） 　　X^Y = X，Y逻辑与 　　X \\/ Y = X，Y逻辑或 　　X XOR Y= X，Y逻辑异或 　　~X = X逻辑取反 　　X+Y定义如下： 　　字 X 和Y 代表两个整数 x 和y, 其中0 &lt;= x &lt; 2^32 且 0 &lt;= y &lt; 2^32. 令整数z= (x + y) mod 2^32. 这时候 0 &lt;= z &lt; 2^32. 将z转换成字Z,那么就是 Z = X + Y. 　　循环左移位操作符Sn(X)。X是一个字，n是一个整数，0&lt;=n&lt;=32。Sn(X)= (X&lt;&gt;32-n) 　　X&lt;定义如下：抛弃最左边的n位数字，将各个位依次向左移动n位，然后用0填补右边的n位（最后结果还是32位）。X&gt;&gt;n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算 　　二、SHA1算法描述 　　在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下： 　　01100001 0110001001100011 　　――――――――――――― 　　‘a’=97 ‘b’=98‘c’=99 　　这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。 　　（一）补位 　　消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。 　　补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。 　　原始信息：01100001 01100010 01100011 　　补位第一步：0110000101100010 01100011 1 　　首先补一个“1” 　　补位第二步：0110000101100010 01100011 10…..0 　　然后补423个“0” 　　我们可以把最后补位完成后的数据用16进制写成下面的样子 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 00000000 　　现在，数据的长度是448了，我们可以进行下一步操作。 　　（二）补长度 　　所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式） 　　61626380 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000000 　　00000000 0000000000000000 00000018 　　如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。 　　（三）使用的常量 　　一系列的常量字K(0),K(1), ... , K(79)，如果以16进制给出。它们如下： 　　Kt = 0x5A827999 (0&lt;= t &lt;= 19) 　　Kt = 0x6ED9EBA1 (20&lt;= t &lt;= 39) 　　Kt = 0x8F1BBCDC (40&lt;= t &lt;= 59) 　　Kt = 0xCA62C1D6 (60&lt;= t &lt;= 79). 　　（四）需要使用的函数 　　在SHA1中我们需要一系列的函数。每个函数ft (0 &lt;= t &lt;= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义 　　ft(B,C,D) = (B ANDC) or ((NOT B) AND D) ( 0 &lt;= t &lt;= 19) 　　ft(B,C,D) = B XOR CXOR D (20 &lt;= t &lt;= 39) 　　ft(B,C,D) = (B ANDC) or (B AND D) or (C AND D) (40 &lt;= t &lt;= 59) 　　ft(B,C,D) = B XOR CXOR D (60 &lt;= t &lt;= 79). 　　（五）计算消息摘要 　　必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0,H1, H2, H3, H4。80个字的缓冲区被标识为W0,W1,..., W79 　　另外还需要一个一个字的TEMP缓冲区。 　　为了产生消息摘要，在第4部分中定义的16个字的数据块M1,M2,..., Mn 　　会依次进行处理，处理每个数据块Mi 包含80个步骤。 　　在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制） 　　H0 = 0x67452301 　　H1 = 0xEFCDAB89 　　H2 = 0x98BADCFE 　　H3 = 0x10325476 　　H4 = 0xC3D2E1F0. 　　现在开始处理M1, M2,... , Mn。为了处理 Mi,需要进行下面的步骤 　　(1). 将Mi 分成 16 个字 W0, W1, ... , W15,W0 是最左边的字 　　(2). 对于t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8XOR Wt- 14 XOR Wt-16). 　　(3). 令A = H0, B = H1, C = H2, D = H3, E = H4. 　　(4) 对于t = 0 到 79，执行下面的循环 　　TEMP = S5(A) +ft(B,C,D) + E + Wt + Kt; 　　E = D; D = C; C =S30(B); B = A; A = TEMP; 　　(5). 令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 　　在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识 　　H0 H1 H2 H3 H4. 　　对于SHA256、SHA384、SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。 　 &nbsp;三、SHA算法被破解了吗？ 2013年9月10日美国约翰霍普金斯大学的计算机科学教授，知名的加密算法专家，Matthew Green被NSA要求删除他的一份关于破解加密算法的与NSA有关的博客。 同时约翰霍普金斯大学服务器上的该博客镜像也被要求删除。 matt-green 加密算法专家，美国约翰霍普金斯大学教授Matthew Green 但当记者向该大学求证时，该校称从未收到来自NSA的要求要删除博客或镜像的资料，但记者却无法在原网址再找到该博客。幸运的是，从谷歌的缓存可以找到该博客。该博客提到NSA每年花费2.5亿美元来为自己在解密信息方面获取优势，并列举了NSA的一系列见不得人的做法。 on-the-nsa 在BitcoinTalk上，已经掀起了一轮争论：到底SHA-2是否安全？ 部分认为不安全的观点包括： NSA制造了sha-2, 我们不相信NSA，他们不可能不留后门。 棱镜事件已经明白的告诉我们，政府会用一切可能的手段来监视与解密。 虽然有很多人会研究SHA-2，且目前没有公开的证据表明有漏洞。但没有公开这并不能代表就没有，因为发现漏洞的人一定更倾向于保留这个秘密来自己利用，而不是公布。 部分认为安全的观点包括： SHA-2是应用广泛的算法，应该已经经历了实践的检验。 美国的对头中国和俄国都有很多杰出的数学家，如果有问题的话，他们肯定已经发现了。 如果真的不安全，世界上安全的东西就太少了，我不能生活在提心吊胆里，所以我选择相信安全。 &nbsp;security 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/04/27/027b3c3b08234a652589be1e6255d709.html","headline":"数字货币开发专题（安全散列算法SHA256）","dateModified":"2017-04-27T00:00:00+08:00","datePublished":"2017-04-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/04/27/027b3c3b08234a652589be1e6255d709.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>数字货币开发专题（安全散列算法SHA256）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;">&nbsp; <span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;"> 区块链爱好者（QQ：53016353） &nbsp;</span>&nbsp;</p> 
  <p>数字货币开发使用椭圆曲线算法生成公钥和私钥，选择的是secp256k1曲线。生成的公钥是33字节的大数，私钥是32字节的大数，钱包文件wallet.dat中直接保存了公钥和私钥。我们在接收和发送比特币时用到的比特币地址是公钥经过算法处理后得到的，具体过程是公钥先经过SHA-256算法处理得到32字节的哈希结果，再经过RIPEMED算法处理后得到20字节的摘要结果，再经过字符转换过程得到我们看到的地址。这个字符转换过程与私钥的字符转换过程完成相同，步骤是先把输入的内容（对于公钥就是20字节的摘要结果，对于私钥就是32字节的大数）增加版本号，经过连续两次SHA-256算法，取后一次哈希结果的前4字节作为校验码附在输入内容的后面，然后再经过Base58编码，得到字符串。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;数字货币开发这里需要提一下的是Base58编码为了让输出字符串易于辨别，所以编码时故意排除了4个字符：'0'、'I'、'l'、'O'，如果你想生成一个带特殊词缀的地址那就不要带这4个符了，比如我的ID（walker）也就不能生成了。<br></p> 
  <p><br><br> 安全散列算法SHA（Secure Hash Algorithm）是美国国家安全局 （NSA） 设计，美国国家标准与技术研究院（NIST） 发布的一系列密码散列函数，包括 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512 等变体。主要适用于数字签名标准（DigitalSignature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。下面以 SHA-1为例，介绍该算法计算消息摘要的原理。<br><br><br> 对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。<br> 　　SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。<br> 　　一、术语和概念<br> 　　（一）位(Bit)，字节（Byte）和字（Word）<br> 　　SHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串:0x616263.<br> 　　（二）运算符和符号<br> 　　下面的逻辑运算符都被运用于“字”（Word）<br> 　　X^Y = X，Y逻辑与<br> 　　X \/ Y = X，Y逻辑或<br> 　　X XOR Y= X，Y逻辑异或<br> 　　~X = X逻辑取反<br> 　　X+Y定义如下：<br> 　　字 X 和Y 代表两个整数 x 和y, 其中0 &lt;= x &lt; 2^32 且 0 &lt;= y &lt; 2^32. 令整数z= (x + y) mod 2^32. 这时候 0 &lt;= z &lt; 2^32. 将z转换成字Z,那么就是 Z = X + Y.<br> 　　循环左移位操作符Sn(X)。X是一个字，n是一个整数，0&lt;=n&lt;=32。Sn(X)= (X&lt;&gt;32-n)<br> 　　X&lt;定义如下：抛弃最左边的n位数字，将各个位依次向左移动n位，然后用0填补右边的n位（最后结果还是32位）。X&gt;&gt;n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算<br> 　　二、SHA1算法描述<br> 　　在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下：<br> 　　01100001 0110001001100011<br> 　　―――――――――――――<br> 　　‘a’=97 ‘b’=98‘c’=99<br> 　　这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。<br> 　　（一）补位<br> 　　消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。<br> 　　补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。<br> 　　原始信息：01100001 01100010 01100011<br> 　　补位第一步：0110000101100010 01100011 1<br> 　　首先补一个“1”<br> 　　补位第二步：0110000101100010 01100011 10…..0<br> 　　然后补423个“0”<br> 　　我们可以把最后补位完成后的数据用16进制写成下面的样子<br> 　　61626380 0000000000000000 00000000<br> 　　00000000 0000000000000000 00000000<br> 　　00000000 0000000000000000 00000000<br> 　　00000000 00000000<br> 　　现在，数据的长度是448了，我们可以进行下一步操作。<br> 　　（二）补长度<br> 　　所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）<br> 　　61626380 0000000000000000 00000000<br> 　　00000000 0000000000000000 00000000<br> 　　00000000 0000000000000000 00000000<br> 　　00000000 0000000000000000 00000018<br> 　　如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。<br> 　　（三）使用的常量<br> 　　一系列的常量字K(0),K(1), ... , K(79)，如果以16进制给出。它们如下：<br> 　　Kt = 0x5A827999 (0&lt;= t &lt;= 19)<br> 　　Kt = 0x6ED9EBA1 (20&lt;= t &lt;= 39)<br> 　　Kt = 0x8F1BBCDC (40&lt;= t &lt;= 59)<br> 　　Kt = 0xCA62C1D6 (60&lt;= t &lt;= 79).<br> 　　（四）需要使用的函数<br> 　　在SHA1中我们需要一系列的函数。每个函数ft (0 &lt;= t &lt;= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义<br> 　　ft(B,C,D) = (B ANDC) or ((NOT B) AND D) ( 0 &lt;= t &lt;= 19)<br> 　　ft(B,C,D) = B XOR CXOR D (20 &lt;= t &lt;= 39)<br> 　　ft(B,C,D) = (B ANDC) or (B AND D) or (C AND D) (40 &lt;= t &lt;= 59)<br> 　　ft(B,C,D) = B XOR CXOR D (60 &lt;= t &lt;= 79).<br> 　　（五）计算消息摘要<br> 　　必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0,H1, H2, H3, H4。80个字的缓冲区被标识为W0,W1,..., W79<br> 　　另外还需要一个一个字的TEMP缓冲区。<br> 　　为了产生消息摘要，在第4部分中定义的16个字的数据块M1,M2,..., Mn<br> 　　会依次进行处理，处理每个数据块Mi 包含80个步骤。<br> 　　在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制）<br> 　　H0 = 0x67452301<br> 　　H1 = 0xEFCDAB89<br> 　　H2 = 0x98BADCFE<br> 　　H3 = 0x10325476<br> 　　H4 = 0xC3D2E1F0.<br> 　　现在开始处理M1, M2,... , Mn。为了处理 Mi,需要进行下面的步骤<br> 　　(1). 将Mi 分成 16 个字 W0, W1, ... , W15,W0 是最左边的字<br> 　　(2). 对于t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8XOR Wt- 14 XOR Wt-16).<br> 　　(3). 令A = H0, B = H1, C = H2, D = H3, E = H4.<br> 　　(4) 对于t = 0 到 79，执行下面的循环<br> 　　TEMP = S5(A) +ft(B,C,D) + E + Wt + Kt;<br> 　　E = D; D = C; C =S30(B); B = A; A = TEMP;<br> 　　(5). 令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.<br> 　　在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识<br> 　　H0 H1 H2 H3 H4.<br> 　　对于SHA256、SHA384、SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。<br> 　 &nbsp;三、SHA算法被破解了吗？<br> 2013年9月10日美国约翰霍普金斯大学的计算机科学教授，知名的加密算法专家，Matthew Green被NSA要求删除他的一份关于破解加密算法的与NSA有关的博客。 同时约翰霍普金斯大学服务器上的该博客镜像也被要求删除。<br> matt-green<br><br><br> 加密算法专家，美国约翰霍普金斯大学教授Matthew Green<br><br><br> 但当记者向该大学求证时，该校称从未收到来自NSA的要求要删除博客或镜像的资料，但记者却无法在原网址再找到该博客。幸运的是，从谷歌的缓存可以找到该博客。该博客提到NSA每年花费2.5亿美元来为自己在解密信息方面获取优势，并列举了NSA的一系列见不得人的做法。<br><br><br> on-the-nsa<br><br><br> 在BitcoinTalk上，已经掀起了一轮争论：到底SHA-2是否安全？<br><br><br> 部分认为不安全的观点包括：<br><br><br> NSA制造了sha-2, 我们不相信NSA，他们不可能不留后门。<br> 棱镜事件已经明白的告诉我们，政府会用一切可能的手段来监视与解密。<br> 虽然有很多人会研究SHA-2，且目前没有公开的证据表明有漏洞。但没有公开这并不能代表就没有，因为发现漏洞的人一定更倾向于保留这个秘密来自己利用，而不是公布。<br> 部分认为安全的观点包括：<br><br><br> SHA-2是应用广泛的算法，应该已经经历了实践的检验。<br> 美国的对头中国和俄国都有很多杰出的数学家，如果有问题的话，他们肯定已经发现了。<br> 如果真的不安全，世界上安全的东西就太少了，我不能生活在提心吊胆里，所以我选择相信安全。<br> &nbsp;security<br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/70844254,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/70844254,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
