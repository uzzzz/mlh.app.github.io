<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>使用vendor管理Golang项目依赖 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="使用vendor管理Golang项目依赖" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Vendor Tool for Go go get -u github.com/kardianos/govendor New users please read theFAQ Package developers should read the developer guide. For a high level overview read the whitepaper Uses the go1.5+ vendor folder. Multiple workflows supported, single tool. Copy existing dependencies from$GOPATH with&nbsp;govendor add/update&nbsp;. If you ignore&nbsp;vendor/*/&nbsp;, restore dependencies with&nbsp;govendor sync&nbsp;. Pull in new dependencies or update existing dependencies directly from&nbsp;remotes with&nbsp;govendor fetch&nbsp;. Migrate from legacy systems with&nbsp;govendor migrate&nbsp;. SupportsLinux, OS X, Windows, probably all others. Supports git, hg, svn, bzr(must be installed an on the PATH). Notes The project must be within a $GOPATH. If using go1.5, ensure you&nbsp;set GO15VENDOREXPERIMENT=1&nbsp;. Quick Start, also see theFAQ Setup your project. cd &quot;my project in GOPATH&quot; govendor init Add existing GOPATH files to vendor. govendor add +external View your work. govendor list Look at what is using a package govendor list -v fmt Specify a specific version or revision to fetch govendor fetchgolang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55 govendor fetch golang.org/x/net/context@v1 # Get latest v1.&nbsp;.&nbsp;tag or branch. govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. Update a package to latest, given any prior version constraint govendor fetch golang.org/x/net/context Format your repository only govendor fmt +local Build everything in your repository only govendor install +local Test your repository only govendor test +local Sub-commands init Create the &quot;vendor&quot; folder and the &quot;vendor.json&quot; file. list List and filter existing dependencies and packages. add Add packages from $GOPATH. update Update packages from $GOPATH. remove Remove packages from the vendor folder. status Lists any packages missing, out-of-date, or modified locally. fetch Add new or update vendor folder packages from remote repository. sync Pull packages into vendor folder from remote repository with revisions from vendor.json file. migrate Move packages from a legacy tool to the vendor folder with metadata. get Like &quot;go get&quot; but copies dependencies into a &quot;vendor&quot; folder. license List discovered licenses for the given status or import paths. shell Run a &quot;shell&quot; to make multiple sub-commands more efficient for large projects. gotool commands that are wrapped: &nbsp;&nbsp;`+&lt;status&gt;` package selection may be used with them fmt, build, install, clean, test, vet, generate, tool &nbsp; Status Packages can be specified by their “status”. +local (l) packages in your project +external (e) referenced packages in GOPATH but not in current project +vendor (v) packages in the vendor folder +std (s) packages in the standard library +excluded (x) externalpackagesexplicitelyexcludedfromvendoring +unused&nbsp;&nbsp;(u) packagesin thevendorfolder, butunused +missing&nbsp;&nbsp;(m) referencedpackagesbutnot found &nbsp; +program&nbsp;&nbsp;(p) package is a mainpackage &nbsp; +outside&nbsp;&nbsp;+external +missing +all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+allpackages &nbsp; Status can be referenced by their initial letters. +std&nbsp;same as&nbsp;+s +external&nbsp;same as&nbsp;+ext&nbsp;same as&nbsp;+e +excluded&nbsp;same as&nbsp;+exc&nbsp;same as&nbsp;+x Status can be logically composed: +local,program&nbsp;(local AND program) local packages that are also programs +local +vendor&nbsp;(local OR vendor) local packages or vendor packages +vendor,program +std&nbsp;((vendor AND program) OR std) vendor packages that are also programs&nbsp; or std library packages +vendor,^program&nbsp;(vendor AND NOT program) vendor package that are not “main” packages. Package specifier The full package-spec is: &lt;path&gt;[::&lt;origin&gt;][{/...|/^}][@[&lt;version-spec&gt;]] Some examples: github.com/kardianos/govendor&nbsp;specifies a single package and single folder. github.com/kardianos/govendor/...&nbsp;specifies&nbsp;govendor&nbsp;and all referenced&nbsp; packages under that path. github.com/kardianos/govendor/^&nbsp;specifies the&nbsp;govendor&nbsp;folder and all&nbsp; sub-folders. Useful for resources or if you don’t want a partial repository. github.com/kardianos/govendor/^::github.com/myself/govendor&nbsp;same as above&nbsp; but fetch from user “myself”. github.com/kardianos/govendor/...@abc12032&nbsp;all referenced packages at&nbsp; revision&nbsp;abc12032&nbsp;. github.com/kardianos/govendor/...@v1&nbsp;same as above, but get the most recent&nbsp; “v1” tag, such as “v1.4.3”. github.com/kardianos/govendor/...@=v1&nbsp;get the exact version “v1”. Packages and Status You may specify multiple package-specs and multiple status in a single command. Commands that accept status and package-spec: list add update remove fetch You may pass arguments to govendor through stdin if the last argument is a “-“. For example&nbsp;echo +vendor | govendor list -&nbsp;will list all vendor packages. Ignoring build tags and excluding packages Ignoring build tags is opt-out and is designed to be the opposite of the build file directives which are opt-in when specified. Typically a developer will want to support cross platform builds, but selectively opt out of tags, tests, and architectures as desired. To ignore additional tags edit the “vendor.json” file and add tag to the vendor “ignore” file field. The field uses spaces to separate tags to ignore. For example the following will ignore both test and appengine files. { &quot;ignore&quot;: &quot;test appengine&quot;, } Similarly, some specific packages can be excluded from the vendoring process. These packages will be listed as&nbsp;excluded&nbsp;(&nbsp;x&nbsp;), and will not be copied to the “vendor” folder when running&nbsp;govendor add|fetch|update&nbsp;. Any sub-package&nbsp;foo/bar&nbsp;of an excluded package&nbsp;foo&nbsp;is also excluded (but package&nbsp;bar/foo&nbsp;is not). The import dependencies of excluded packages are not listed, and thus not vendored. To exclude packages, also use the “ignore” field of the “vendor.json” file. Packages are identified by their name, they should contain a “/” character (possibly at the end): { &quot;ignore&quot;: &quot;test appengine foo/&quot;, } Go项目包管理工具 govendor Go 1.5中(目前最新版本go1.5beta3)加入了一个experimental feature:&nbsp;vendor/。这个feature不是Go 1.5的正式功能，但却是Go Authors们在解决Go被外界诟病的包依赖管理的道路上的一次重要尝试。目前关于Go vendor机制的资料有限，主要的包括如下几个： 1、Russ Cox在Golang-dev group上的一个名 为&quot;proposal: external packages&quot; topic上的reply。 2、Go 1.5beta版发布后Russ Cox根据上面topic整理的一个doc。 3、medium.com上一篇名为“Go 1.5 vendor/ experiment&quot;的文章。 但由于Go 1.5稳定版还未发布(最新消息是2015.8月中旬发布)，因此估计真正采用vendor的repo尚没有。但既然是Go官方解决方案，后续从 expreimental变成official的可能性就很大（Russ的初步计划：如果试验顺利，1.6版本默认 GO15VENDOREXPERIMENT=&quot;1&quot;；1.7中将去掉GO15VENDOREXPERIMENT环境变量）。因此对于Gophers们，搞 清楚vendor还是很必要的。本文就和大家一起来理解下vendor这个新feature。 一、vendor由来 Go第三方包依赖和管理的问题由来已久，民间知名的解决方案就有godep、&nbsp;gb等。这次Go team在推出vendor前已经在Golang-dev group上做了长时间的调研，最终Russ Cox在Keith Rarick的proposal的基础上做了改良，形成了Go 1.5中的vendor。 Russ Cox基于前期调研的结果，给出了vendor机制的群众意见基础：&nbsp;&nbsp;&nbsp; – 不rewrite gopath &nbsp;&nbsp;&nbsp; – go tool来解决 &nbsp;&nbsp;&nbsp; – go get兼容 &nbsp;&nbsp;&nbsp; – 可reproduce building process 并给出了vendor机制的&quot;4行&quot;诠释： If there is a source directory d/vendor, then, when compiling a source file within the subtree rooted at d, import &quot;p&quot; is interpreted as import &quot;d/vendor/p&quot; if that exists. When there are multiple possible resolutions,the most specific (longest) path wins. The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. Import comments are ignored in vendored packages. 这四行诠释在group中引起了强烈的讨论，短小精悍的背后是理解上的不小差异。我们下面逐一举例理解。 二、vendor基本样例 Russ Cox诠释中的第一条是vendor机制的基础。粗犷的理解就是如果有如下这样的目录结构： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go 如果mypkg/main.go中有&quot;import p&quot;，那么这个p就会被go工具解析为&quot;d/vendor/p&quot;，而不是$GOPATH/src/p。 现在我们就来复现这个例子，我们在go15-vendor-examples/src/basic下建立如上目录结构（其中go15-vendor-examples为GOPATH路径）： $ls -R d/ ./d: mypkg/&nbsp;&nbsp;&nbsp; vendor/ ./d/mypkg: main.go ./d/vendor: p/ ./d/vendor/p: p.go 其中main.go代码如下： //main.go package main import &quot;p&quot; func main() { &nbsp;&nbsp;&nbsp; p.P() } p.go代码如下： //p.go package p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/p&quot;) } 在未开启vendor时，我们编译d/mypkg/main.go会得到如下错误结果： $ go build main.go main.go:3:8: cannot find package &quot;p&quot; in any of: &nbsp;&nbsp;&nbsp; /Users/tony/.bin/go15beta3/src/p (from $GOROOT) &nbsp;&nbsp;&nbsp; /Users/tony/OpenSource/github.com/experiments/go15-vendor-examples/src/p (from $GOPATH) 错误原因很显然：go编译器无法找到package p，d/vendor下的p此时无效。 这时开启vendor：export GO15VENDOREXPERIMENT=1，我们再来编译执行一次：$go run main.go P in d/vendor/p 开启了vendor机制的go tool在d/vendor下找到了package p。 也就是说拥有了vendor后，你的project依赖的第三方包统统放在vendor/下就好了。这样go get时会将第三方包同时download下来，使得你的project无论被下载到那里都可以无需依赖目标环境而编译通过(reproduce the building process)。 三、嵌套vendor 那么问题来了！如果vendor中的第三方包中也包含了vendor目录，go tool是如何choose第三方包的呢？我们来看看下面目录结构(go15-vendor-examples/src/embeded)： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go embeded目录下出现了嵌套vendor结构：main.go依赖的q包本身还有一个vendor目录，该vendor目录下有一个p包，这样我们就有了两个p包。到底go工具会选择哪个p包呢？显然为了验证一些结论，我们源文件也要变化一下： d/vendor/p/p.go的代码不变。 //d/vendor/q/q.go package q import ( &nbsp;&nbsp;&nbsp; &quot;fmt&quot; &nbsp;&nbsp;&nbsp; &quot;p&quot; ) func Q() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;Q in d/vendor/q&quot;) &nbsp;&nbsp;&nbsp; p.P() } //d/vendor/q/vendor/p/p.gopackage p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/q/vendor/p&quot;) } //mypkg/main.go package main import ( &nbsp;&nbsp;&nbsp; &quot;p&quot; &nbsp;&nbsp;&nbsp; &quot;q&quot; ) func main() { &nbsp;&nbsp;&nbsp; p.P() &nbsp;&nbsp;&nbsp; fmt.Println(&quot;&quot;) &nbsp;&nbsp;&nbsp; q.Q() } 目录和代码编排完毕，我们就来到了见证奇迹的时刻了！我们执行一下main.go： $go run main.go P in d/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p 可以看出main.go中最终引用的是d/vendor/p，而q.Q()中调用的p.P()则是d/vendor/q/vendor/p包的实现。go tool到底是如何在嵌套vendor情况下选择包的呢？我们回到Russ Cox关于vendor诠释内容的第二条： &nbsp;&nbsp; When there are multiple possible resolutions,the most specific (longest) path wins. 这句话很简略，但却引来的巨大争论。&quot;longest path wins&quot;让人迷惑不解。如果仅仅从字面含义来看，上面main.go的执行结果更应该是： P in d/vendor/q/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p d/vendor/q/vendor/p可比d/vendor/p路径更long，但go tool显然并未这么做。它到底是怎么做的呢？talk is cheap, show you the code。我们粗略翻看一下go tool的实现代码： 在$GOROOT/src/cmd/go/pkg.go中有一个方法vendoredImportPath,这个方法在go tool中广泛被使用： // vendoredImportPath returns the expansion of path when it appears in parent. // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path, // x/vendor/path, vendor/path, or else stay x/y/z if none of those exist. // vendoredImportPath returns the expanded path or, if no expansion is found, the original. // If no expansion is found, vendoredImportPath also returns a list of vendor directories // it searched along the way, to help prepare a useful error message should path turn // out not to exist. func vendoredImportPath(parent *Package, path string) (found string, searched []string) 这个方法的doc讲述的很清楚，这个方法返回所有可能的vendor path，以parentpath为x/y/z为例： x/y/z作为parentpath输入后，返回的vendorpath包括： &nbsp;&nbsp;&nbsp;x/y/z/vendor/pathx/y/vendor/pathx/vendor/path vendor/path 这么说还不是很直观，我们结合我们的embeded vendor的例子来说明一下，为什么结果是像上面那样！go tool是如何resolve p包的！我们模仿go tool对main.go代码进行编译（此时vendor已经开启）。 根据go程序的package init顺序，go tool首先编译p包。如何找到p包呢？此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在p包，于是go tool将p包resolve为d/vendor/p，于是下面的p.P()就会输出：P in d/vendor/p 接下来初始化q包。与p类似，go tool对main.go代码进行编译，此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在q包，于是乎go tool将q包resolve为d/vendor/q，由于q包自身还依赖p包，于是go tool继续对q中依赖的p包进行选择，此时go tool的编译对象变为了d/vendor/q/q.go，parent = d/vendor/q，于是经过vendordImportPath处理，可能的vendor路径为： d/vendor/q/vendor d/vendor/vendor d/vendor 存在p包的路径包括： d/vendor/q/vendor/p d/vendor/p 此时按照Russ Cox的诠释2：choose longest，于是go tool选择了d/vendor/q/vendor/p，于是q.Q()中的p.P()输出的内容就是: &quot;P in d/vendor/q/vendor/p&quot; 如果目录结构足够复杂，这个resolve过程也是蛮繁琐的，但按照这个思路依然是可以分析出正确的包的。 另外vendoredImportPath传入的parent x/y/z并不是一个绝对路径，而是一个相对于$GOPATH/src的路径。 BTW，上述测试样例代码在这里可以下载到。 四、第三和第四条 最难理解的第二条已经pass了，剩下两条就比较好理解了。 The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. 这条就是说，你在源码中不用理会vendor这个路径的存在，该怎么import包就怎么import，不要出现import &quot;d/vendor/p&quot;的情况。vendor是由go tool隐式处理的。 Import comments are ignored in vendored packages. go 1.4引入了canonical imports机制，如: package pdf // import &quot;rsc.io/pdf&quot; 如果你引用的pdf不是来自rsc.io/pdf，那么编译器会报错。但由于vendor机制的存在，go tool不会校验vendor中package的import path是否与canonical import路径是否一致了。 五、问题 根据小节三中的分析，对于vendor中包的resolving过程类似是一个recursive(递归）过程。 main.go中的p使用d/vendor/p；而q.go中的p使用的是d/vendor/q/vendor/p，这样就会存在一个问题：一个工程中存 在着两个版本的p包，这也许不会带来问题，也许也会是问题的根源，但目前来看从go tool的视角来看似乎没有更好的办法。Russ Cox期望大家良好设计工程布局，作为lib的包不携带vendor更佳。 这样一个project内的所有vendor都集中在顶层vendor里面。就像下面这样： d/ &nbsp;&nbsp;&nbsp; vendor/&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … … &nbsp;&nbsp;&nbsp; mypkg1 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; mypkg2 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; … … 另外Go vendor不支持第三方包的版本管理，没有类似godep的Godeps.json这样的存储包元信息的文件。不过目前已经有第三方的vendor specs放在了github上，之前Go team的Brad Fizpatrick也在Golang-dev上征集过类似的方案，不知未来vendor是否会支持。 六、vendor vs. internal 在golang-dev有人提到：有了vendor，internal似乎没用了。这显然是混淆了internal和vendor所要解决的问题。 internal故名思议：内部包，不是对所有源文件都可见的。vendor是存储和管理外部依赖包，更类似于external，里面的包都是copy自 外部的，工程内所有源文件均可import vendor中的包。另外internal在1.4版本中已经加入到go核心，是不可能轻易去除的，虽然到目前为止我们还没能亲自体会到internal 包的作用。 在《Go 1.5中值得关注的几个变化》一文中我提到过go 1.5 beta1似乎“不支持”internal，beta3发布后，我又试了试看beta3是否支持internal包。 结果是beta3中，build依旧不报错。但go list -json会提示错误：&quot;DepsErrors&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;ImportStack&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;otherpkg&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;mypkg/internal/foo&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ], &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Pos&quot;: &quot;&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Err&quot;: &quot;use of internal package not allowed&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; ] 难道真的要到最终go 1.5版本才会让internal包发挥作用? 长期以来，golang 对外部依赖都没有很好的管理方式，只能从 $GOPATH 下查找依赖。这就造成不同用户在安装同一个项目适合可能从外部获取到不同的依赖库版本，同时当无法联网时，无法编译依赖缺失的项目。 自 1.5 版本开始引入 govendor 工具，该工具将项目依赖的外部包放到项目下的 vendor 目录下（对比 nodejs 的 node_modules 目录），并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。 对于 govendor 来说，主要存在三种位置的包：项目自身的包组织为本地（local）包；传统的存放在 $GOPATH 下的依赖包为外部（external）依赖包；被 govendor 管理的放在 vendor 目录下的依赖包则为 vendor 包。 具体来看，这些包可能的类型如下： 状态 缩写状态 含义 +local l 本地包，即项目自身的包组织 +external e 外部包，即被 $GOPATH 管理，但不在 vendor 目录下 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside &nbsp; 外部包和缺失的包 +all &nbsp; 所有的包 常见的命令如下，格式为&nbsp;govendor COMMAND。 通过指定包类型，可以过滤仅对指定包进行操作。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 add PKG_PATH 添加指定的依赖包到 vendor 目录 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似&nbsp;go get&nbsp;目录，拉取依赖包到 vendor 目录 阅读更多" />
<meta property="og:description" content="The Vendor Tool for Go go get -u github.com/kardianos/govendor New users please read theFAQ Package developers should read the developer guide. For a high level overview read the whitepaper Uses the go1.5+ vendor folder. Multiple workflows supported, single tool. Copy existing dependencies from$GOPATH with&nbsp;govendor add/update&nbsp;. If you ignore&nbsp;vendor/*/&nbsp;, restore dependencies with&nbsp;govendor sync&nbsp;. Pull in new dependencies or update existing dependencies directly from&nbsp;remotes with&nbsp;govendor fetch&nbsp;. Migrate from legacy systems with&nbsp;govendor migrate&nbsp;. SupportsLinux, OS X, Windows, probably all others. Supports git, hg, svn, bzr(must be installed an on the PATH). Notes The project must be within a $GOPATH. If using go1.5, ensure you&nbsp;set GO15VENDOREXPERIMENT=1&nbsp;. Quick Start, also see theFAQ Setup your project. cd &quot;my project in GOPATH&quot; govendor init Add existing GOPATH files to vendor. govendor add +external View your work. govendor list Look at what is using a package govendor list -v fmt Specify a specific version or revision to fetch govendor fetchgolang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55 govendor fetch golang.org/x/net/context@v1 # Get latest v1.&nbsp;.&nbsp;tag or branch. govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. Update a package to latest, given any prior version constraint govendor fetch golang.org/x/net/context Format your repository only govendor fmt +local Build everything in your repository only govendor install +local Test your repository only govendor test +local Sub-commands init Create the &quot;vendor&quot; folder and the &quot;vendor.json&quot; file. list List and filter existing dependencies and packages. add Add packages from $GOPATH. update Update packages from $GOPATH. remove Remove packages from the vendor folder. status Lists any packages missing, out-of-date, or modified locally. fetch Add new or update vendor folder packages from remote repository. sync Pull packages into vendor folder from remote repository with revisions from vendor.json file. migrate Move packages from a legacy tool to the vendor folder with metadata. get Like &quot;go get&quot; but copies dependencies into a &quot;vendor&quot; folder. license List discovered licenses for the given status or import paths. shell Run a &quot;shell&quot; to make multiple sub-commands more efficient for large projects. gotool commands that are wrapped: &nbsp;&nbsp;`+&lt;status&gt;` package selection may be used with them fmt, build, install, clean, test, vet, generate, tool &nbsp; Status Packages can be specified by their “status”. +local (l) packages in your project +external (e) referenced packages in GOPATH but not in current project +vendor (v) packages in the vendor folder +std (s) packages in the standard library +excluded (x) externalpackagesexplicitelyexcludedfromvendoring +unused&nbsp;&nbsp;(u) packagesin thevendorfolder, butunused +missing&nbsp;&nbsp;(m) referencedpackagesbutnot found &nbsp; +program&nbsp;&nbsp;(p) package is a mainpackage &nbsp; +outside&nbsp;&nbsp;+external +missing +all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+allpackages &nbsp; Status can be referenced by their initial letters. +std&nbsp;same as&nbsp;+s +external&nbsp;same as&nbsp;+ext&nbsp;same as&nbsp;+e +excluded&nbsp;same as&nbsp;+exc&nbsp;same as&nbsp;+x Status can be logically composed: +local,program&nbsp;(local AND program) local packages that are also programs +local +vendor&nbsp;(local OR vendor) local packages or vendor packages +vendor,program +std&nbsp;((vendor AND program) OR std) vendor packages that are also programs&nbsp; or std library packages +vendor,^program&nbsp;(vendor AND NOT program) vendor package that are not “main” packages. Package specifier The full package-spec is: &lt;path&gt;[::&lt;origin&gt;][{/...|/^}][@[&lt;version-spec&gt;]] Some examples: github.com/kardianos/govendor&nbsp;specifies a single package and single folder. github.com/kardianos/govendor/...&nbsp;specifies&nbsp;govendor&nbsp;and all referenced&nbsp; packages under that path. github.com/kardianos/govendor/^&nbsp;specifies the&nbsp;govendor&nbsp;folder and all&nbsp; sub-folders. Useful for resources or if you don’t want a partial repository. github.com/kardianos/govendor/^::github.com/myself/govendor&nbsp;same as above&nbsp; but fetch from user “myself”. github.com/kardianos/govendor/...@abc12032&nbsp;all referenced packages at&nbsp; revision&nbsp;abc12032&nbsp;. github.com/kardianos/govendor/...@v1&nbsp;same as above, but get the most recent&nbsp; “v1” tag, such as “v1.4.3”. github.com/kardianos/govendor/...@=v1&nbsp;get the exact version “v1”. Packages and Status You may specify multiple package-specs and multiple status in a single command. Commands that accept status and package-spec: list add update remove fetch You may pass arguments to govendor through stdin if the last argument is a “-“. For example&nbsp;echo +vendor | govendor list -&nbsp;will list all vendor packages. Ignoring build tags and excluding packages Ignoring build tags is opt-out and is designed to be the opposite of the build file directives which are opt-in when specified. Typically a developer will want to support cross platform builds, but selectively opt out of tags, tests, and architectures as desired. To ignore additional tags edit the “vendor.json” file and add tag to the vendor “ignore” file field. The field uses spaces to separate tags to ignore. For example the following will ignore both test and appengine files. { &quot;ignore&quot;: &quot;test appengine&quot;, } Similarly, some specific packages can be excluded from the vendoring process. These packages will be listed as&nbsp;excluded&nbsp;(&nbsp;x&nbsp;), and will not be copied to the “vendor” folder when running&nbsp;govendor add|fetch|update&nbsp;. Any sub-package&nbsp;foo/bar&nbsp;of an excluded package&nbsp;foo&nbsp;is also excluded (but package&nbsp;bar/foo&nbsp;is not). The import dependencies of excluded packages are not listed, and thus not vendored. To exclude packages, also use the “ignore” field of the “vendor.json” file. Packages are identified by their name, they should contain a “/” character (possibly at the end): { &quot;ignore&quot;: &quot;test appengine foo/&quot;, } Go项目包管理工具 govendor Go 1.5中(目前最新版本go1.5beta3)加入了一个experimental feature:&nbsp;vendor/。这个feature不是Go 1.5的正式功能，但却是Go Authors们在解决Go被外界诟病的包依赖管理的道路上的一次重要尝试。目前关于Go vendor机制的资料有限，主要的包括如下几个： 1、Russ Cox在Golang-dev group上的一个名 为&quot;proposal: external packages&quot; topic上的reply。 2、Go 1.5beta版发布后Russ Cox根据上面topic整理的一个doc。 3、medium.com上一篇名为“Go 1.5 vendor/ experiment&quot;的文章。 但由于Go 1.5稳定版还未发布(最新消息是2015.8月中旬发布)，因此估计真正采用vendor的repo尚没有。但既然是Go官方解决方案，后续从 expreimental变成official的可能性就很大（Russ的初步计划：如果试验顺利，1.6版本默认 GO15VENDOREXPERIMENT=&quot;1&quot;；1.7中将去掉GO15VENDOREXPERIMENT环境变量）。因此对于Gophers们，搞 清楚vendor还是很必要的。本文就和大家一起来理解下vendor这个新feature。 一、vendor由来 Go第三方包依赖和管理的问题由来已久，民间知名的解决方案就有godep、&nbsp;gb等。这次Go team在推出vendor前已经在Golang-dev group上做了长时间的调研，最终Russ Cox在Keith Rarick的proposal的基础上做了改良，形成了Go 1.5中的vendor。 Russ Cox基于前期调研的结果，给出了vendor机制的群众意见基础：&nbsp;&nbsp;&nbsp; – 不rewrite gopath &nbsp;&nbsp;&nbsp; – go tool来解决 &nbsp;&nbsp;&nbsp; – go get兼容 &nbsp;&nbsp;&nbsp; – 可reproduce building process 并给出了vendor机制的&quot;4行&quot;诠释： If there is a source directory d/vendor, then, when compiling a source file within the subtree rooted at d, import &quot;p&quot; is interpreted as import &quot;d/vendor/p&quot; if that exists. When there are multiple possible resolutions,the most specific (longest) path wins. The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. Import comments are ignored in vendored packages. 这四行诠释在group中引起了强烈的讨论，短小精悍的背后是理解上的不小差异。我们下面逐一举例理解。 二、vendor基本样例 Russ Cox诠释中的第一条是vendor机制的基础。粗犷的理解就是如果有如下这样的目录结构： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go 如果mypkg/main.go中有&quot;import p&quot;，那么这个p就会被go工具解析为&quot;d/vendor/p&quot;，而不是$GOPATH/src/p。 现在我们就来复现这个例子，我们在go15-vendor-examples/src/basic下建立如上目录结构（其中go15-vendor-examples为GOPATH路径）： $ls -R d/ ./d: mypkg/&nbsp;&nbsp;&nbsp; vendor/ ./d/mypkg: main.go ./d/vendor: p/ ./d/vendor/p: p.go 其中main.go代码如下： //main.go package main import &quot;p&quot; func main() { &nbsp;&nbsp;&nbsp; p.P() } p.go代码如下： //p.go package p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/p&quot;) } 在未开启vendor时，我们编译d/mypkg/main.go会得到如下错误结果： $ go build main.go main.go:3:8: cannot find package &quot;p&quot; in any of: &nbsp;&nbsp;&nbsp; /Users/tony/.bin/go15beta3/src/p (from $GOROOT) &nbsp;&nbsp;&nbsp; /Users/tony/OpenSource/github.com/experiments/go15-vendor-examples/src/p (from $GOPATH) 错误原因很显然：go编译器无法找到package p，d/vendor下的p此时无效。 这时开启vendor：export GO15VENDOREXPERIMENT=1，我们再来编译执行一次：$go run main.go P in d/vendor/p 开启了vendor机制的go tool在d/vendor下找到了package p。 也就是说拥有了vendor后，你的project依赖的第三方包统统放在vendor/下就好了。这样go get时会将第三方包同时download下来，使得你的project无论被下载到那里都可以无需依赖目标环境而编译通过(reproduce the building process)。 三、嵌套vendor 那么问题来了！如果vendor中的第三方包中也包含了vendor目录，go tool是如何choose第三方包的呢？我们来看看下面目录结构(go15-vendor-examples/src/embeded)： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go embeded目录下出现了嵌套vendor结构：main.go依赖的q包本身还有一个vendor目录，该vendor目录下有一个p包，这样我们就有了两个p包。到底go工具会选择哪个p包呢？显然为了验证一些结论，我们源文件也要变化一下： d/vendor/p/p.go的代码不变。 //d/vendor/q/q.go package q import ( &nbsp;&nbsp;&nbsp; &quot;fmt&quot; &nbsp;&nbsp;&nbsp; &quot;p&quot; ) func Q() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;Q in d/vendor/q&quot;) &nbsp;&nbsp;&nbsp; p.P() } //d/vendor/q/vendor/p/p.gopackage p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/q/vendor/p&quot;) } //mypkg/main.go package main import ( &nbsp;&nbsp;&nbsp; &quot;p&quot; &nbsp;&nbsp;&nbsp; &quot;q&quot; ) func main() { &nbsp;&nbsp;&nbsp; p.P() &nbsp;&nbsp;&nbsp; fmt.Println(&quot;&quot;) &nbsp;&nbsp;&nbsp; q.Q() } 目录和代码编排完毕，我们就来到了见证奇迹的时刻了！我们执行一下main.go： $go run main.go P in d/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p 可以看出main.go中最终引用的是d/vendor/p，而q.Q()中调用的p.P()则是d/vendor/q/vendor/p包的实现。go tool到底是如何在嵌套vendor情况下选择包的呢？我们回到Russ Cox关于vendor诠释内容的第二条： &nbsp;&nbsp; When there are multiple possible resolutions,the most specific (longest) path wins. 这句话很简略，但却引来的巨大争论。&quot;longest path wins&quot;让人迷惑不解。如果仅仅从字面含义来看，上面main.go的执行结果更应该是： P in d/vendor/q/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p d/vendor/q/vendor/p可比d/vendor/p路径更long，但go tool显然并未这么做。它到底是怎么做的呢？talk is cheap, show you the code。我们粗略翻看一下go tool的实现代码： 在$GOROOT/src/cmd/go/pkg.go中有一个方法vendoredImportPath,这个方法在go tool中广泛被使用： // vendoredImportPath returns the expansion of path when it appears in parent. // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path, // x/vendor/path, vendor/path, or else stay x/y/z if none of those exist. // vendoredImportPath returns the expanded path or, if no expansion is found, the original. // If no expansion is found, vendoredImportPath also returns a list of vendor directories // it searched along the way, to help prepare a useful error message should path turn // out not to exist. func vendoredImportPath(parent *Package, path string) (found string, searched []string) 这个方法的doc讲述的很清楚，这个方法返回所有可能的vendor path，以parentpath为x/y/z为例： x/y/z作为parentpath输入后，返回的vendorpath包括： &nbsp;&nbsp;&nbsp;x/y/z/vendor/pathx/y/vendor/pathx/vendor/path vendor/path 这么说还不是很直观，我们结合我们的embeded vendor的例子来说明一下，为什么结果是像上面那样！go tool是如何resolve p包的！我们模仿go tool对main.go代码进行编译（此时vendor已经开启）。 根据go程序的package init顺序，go tool首先编译p包。如何找到p包呢？此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在p包，于是go tool将p包resolve为d/vendor/p，于是下面的p.P()就会输出：P in d/vendor/p 接下来初始化q包。与p类似，go tool对main.go代码进行编译，此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在q包，于是乎go tool将q包resolve为d/vendor/q，由于q包自身还依赖p包，于是go tool继续对q中依赖的p包进行选择，此时go tool的编译对象变为了d/vendor/q/q.go，parent = d/vendor/q，于是经过vendordImportPath处理，可能的vendor路径为： d/vendor/q/vendor d/vendor/vendor d/vendor 存在p包的路径包括： d/vendor/q/vendor/p d/vendor/p 此时按照Russ Cox的诠释2：choose longest，于是go tool选择了d/vendor/q/vendor/p，于是q.Q()中的p.P()输出的内容就是: &quot;P in d/vendor/q/vendor/p&quot; 如果目录结构足够复杂，这个resolve过程也是蛮繁琐的，但按照这个思路依然是可以分析出正确的包的。 另外vendoredImportPath传入的parent x/y/z并不是一个绝对路径，而是一个相对于$GOPATH/src的路径。 BTW，上述测试样例代码在这里可以下载到。 四、第三和第四条 最难理解的第二条已经pass了，剩下两条就比较好理解了。 The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. 这条就是说，你在源码中不用理会vendor这个路径的存在，该怎么import包就怎么import，不要出现import &quot;d/vendor/p&quot;的情况。vendor是由go tool隐式处理的。 Import comments are ignored in vendored packages. go 1.4引入了canonical imports机制，如: package pdf // import &quot;rsc.io/pdf&quot; 如果你引用的pdf不是来自rsc.io/pdf，那么编译器会报错。但由于vendor机制的存在，go tool不会校验vendor中package的import path是否与canonical import路径是否一致了。 五、问题 根据小节三中的分析，对于vendor中包的resolving过程类似是一个recursive(递归）过程。 main.go中的p使用d/vendor/p；而q.go中的p使用的是d/vendor/q/vendor/p，这样就会存在一个问题：一个工程中存 在着两个版本的p包，这也许不会带来问题，也许也会是问题的根源，但目前来看从go tool的视角来看似乎没有更好的办法。Russ Cox期望大家良好设计工程布局，作为lib的包不携带vendor更佳。 这样一个project内的所有vendor都集中在顶层vendor里面。就像下面这样： d/ &nbsp;&nbsp;&nbsp; vendor/&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … … &nbsp;&nbsp;&nbsp; mypkg1 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; mypkg2 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; … … 另外Go vendor不支持第三方包的版本管理，没有类似godep的Godeps.json这样的存储包元信息的文件。不过目前已经有第三方的vendor specs放在了github上，之前Go team的Brad Fizpatrick也在Golang-dev上征集过类似的方案，不知未来vendor是否会支持。 六、vendor vs. internal 在golang-dev有人提到：有了vendor，internal似乎没用了。这显然是混淆了internal和vendor所要解决的问题。 internal故名思议：内部包，不是对所有源文件都可见的。vendor是存储和管理外部依赖包，更类似于external，里面的包都是copy自 外部的，工程内所有源文件均可import vendor中的包。另外internal在1.4版本中已经加入到go核心，是不可能轻易去除的，虽然到目前为止我们还没能亲自体会到internal 包的作用。 在《Go 1.5中值得关注的几个变化》一文中我提到过go 1.5 beta1似乎“不支持”internal，beta3发布后，我又试了试看beta3是否支持internal包。 结果是beta3中，build依旧不报错。但go list -json会提示错误：&quot;DepsErrors&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;ImportStack&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;otherpkg&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;mypkg/internal/foo&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ], &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Pos&quot;: &quot;&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Err&quot;: &quot;use of internal package not allowed&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; ] 难道真的要到最终go 1.5版本才会让internal包发挥作用? 长期以来，golang 对外部依赖都没有很好的管理方式，只能从 $GOPATH 下查找依赖。这就造成不同用户在安装同一个项目适合可能从外部获取到不同的依赖库版本，同时当无法联网时，无法编译依赖缺失的项目。 自 1.5 版本开始引入 govendor 工具，该工具将项目依赖的外部包放到项目下的 vendor 目录下（对比 nodejs 的 node_modules 目录），并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。 对于 govendor 来说，主要存在三种位置的包：项目自身的包组织为本地（local）包；传统的存放在 $GOPATH 下的依赖包为外部（external）依赖包；被 govendor 管理的放在 vendor 目录下的依赖包则为 vendor 包。 具体来看，这些包可能的类型如下： 状态 缩写状态 含义 +local l 本地包，即项目自身的包组织 +external e 外部包，即被 $GOPATH 管理，但不在 vendor 目录下 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside &nbsp; 外部包和缺失的包 +all &nbsp; 所有的包 常见的命令如下，格式为&nbsp;govendor COMMAND。 通过指定包类型，可以过滤仅对指定包进行操作。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 add PKG_PATH 添加指定的依赖包到 vendor 目录 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似&nbsp;go get&nbsp;目录，拉取依赖包到 vendor 目录 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/02/23/7f2a89155f3046cae883e95303ab8566.html" />
<meta property="og:url" content="https://mlh.app/2017/02/23/7f2a89155f3046cae883e95303ab8566.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-23T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"The Vendor Tool for Go go get -u github.com/kardianos/govendor New users please read theFAQ Package developers should read the developer guide. For a high level overview read the whitepaper Uses the go1.5+ vendor folder. Multiple workflows supported, single tool. Copy existing dependencies from$GOPATH with&nbsp;govendor add/update&nbsp;. If you ignore&nbsp;vendor/*/&nbsp;, restore dependencies with&nbsp;govendor sync&nbsp;. Pull in new dependencies or update existing dependencies directly from&nbsp;remotes with&nbsp;govendor fetch&nbsp;. Migrate from legacy systems with&nbsp;govendor migrate&nbsp;. SupportsLinux, OS X, Windows, probably all others. Supports git, hg, svn, bzr(must be installed an on the PATH). Notes The project must be within a $GOPATH. If using go1.5, ensure you&nbsp;set GO15VENDOREXPERIMENT=1&nbsp;. Quick Start, also see theFAQ Setup your project. cd &quot;my project in GOPATH&quot; govendor init Add existing GOPATH files to vendor. govendor add +external View your work. govendor list Look at what is using a package govendor list -v fmt Specify a specific version or revision to fetch govendor fetchgolang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55 govendor fetch golang.org/x/net/context@v1 # Get latest v1.&nbsp;.&nbsp;tag or branch. govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. Update a package to latest, given any prior version constraint govendor fetch golang.org/x/net/context Format your repository only govendor fmt +local Build everything in your repository only govendor install +local Test your repository only govendor test +local Sub-commands init Create the &quot;vendor&quot; folder and the &quot;vendor.json&quot; file. list List and filter existing dependencies and packages. add Add packages from $GOPATH. update Update packages from $GOPATH. remove Remove packages from the vendor folder. status Lists any packages missing, out-of-date, or modified locally. fetch Add new or update vendor folder packages from remote repository. sync Pull packages into vendor folder from remote repository with revisions from vendor.json file. migrate Move packages from a legacy tool to the vendor folder with metadata. get Like &quot;go get&quot; but copies dependencies into a &quot;vendor&quot; folder. license List discovered licenses for the given status or import paths. shell Run a &quot;shell&quot; to make multiple sub-commands more efficient for large projects. gotool commands that are wrapped: &nbsp;&nbsp;`+&lt;status&gt;` package selection may be used with them fmt, build, install, clean, test, vet, generate, tool &nbsp; Status Packages can be specified by their “status”. +local (l) packages in your project +external (e) referenced packages in GOPATH but not in current project +vendor (v) packages in the vendor folder +std (s) packages in the standard library +excluded (x) externalpackagesexplicitelyexcludedfromvendoring +unused&nbsp;&nbsp;(u) packagesin thevendorfolder, butunused +missing&nbsp;&nbsp;(m) referencedpackagesbutnot found &nbsp; +program&nbsp;&nbsp;(p) package is a mainpackage &nbsp; +outside&nbsp;&nbsp;+external +missing +all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+allpackages &nbsp; Status can be referenced by their initial letters. +std&nbsp;same as&nbsp;+s +external&nbsp;same as&nbsp;+ext&nbsp;same as&nbsp;+e +excluded&nbsp;same as&nbsp;+exc&nbsp;same as&nbsp;+x Status can be logically composed: +local,program&nbsp;(local AND program) local packages that are also programs +local +vendor&nbsp;(local OR vendor) local packages or vendor packages +vendor,program +std&nbsp;((vendor AND program) OR std) vendor packages that are also programs&nbsp; or std library packages +vendor,^program&nbsp;(vendor AND NOT program) vendor package that are not “main” packages. Package specifier The full package-spec is: &lt;path&gt;[::&lt;origin&gt;][{/...|/^}][@[&lt;version-spec&gt;]] Some examples: github.com/kardianos/govendor&nbsp;specifies a single package and single folder. github.com/kardianos/govendor/...&nbsp;specifies&nbsp;govendor&nbsp;and all referenced&nbsp; packages under that path. github.com/kardianos/govendor/^&nbsp;specifies the&nbsp;govendor&nbsp;folder and all&nbsp; sub-folders. Useful for resources or if you don’t want a partial repository. github.com/kardianos/govendor/^::github.com/myself/govendor&nbsp;same as above&nbsp; but fetch from user “myself”. github.com/kardianos/govendor/...@abc12032&nbsp;all referenced packages at&nbsp; revision&nbsp;abc12032&nbsp;. github.com/kardianos/govendor/...@v1&nbsp;same as above, but get the most recent&nbsp; “v1” tag, such as “v1.4.3”. github.com/kardianos/govendor/...@=v1&nbsp;get the exact version “v1”. Packages and Status You may specify multiple package-specs and multiple status in a single command. Commands that accept status and package-spec: list add update remove fetch You may pass arguments to govendor through stdin if the last argument is a “-“. For example&nbsp;echo +vendor | govendor list -&nbsp;will list all vendor packages. Ignoring build tags and excluding packages Ignoring build tags is opt-out and is designed to be the opposite of the build file directives which are opt-in when specified. Typically a developer will want to support cross platform builds, but selectively opt out of tags, tests, and architectures as desired. To ignore additional tags edit the “vendor.json” file and add tag to the vendor “ignore” file field. The field uses spaces to separate tags to ignore. For example the following will ignore both test and appengine files. { &quot;ignore&quot;: &quot;test appengine&quot;, } Similarly, some specific packages can be excluded from the vendoring process. These packages will be listed as&nbsp;excluded&nbsp;(&nbsp;x&nbsp;), and will not be copied to the “vendor” folder when running&nbsp;govendor add|fetch|update&nbsp;. Any sub-package&nbsp;foo/bar&nbsp;of an excluded package&nbsp;foo&nbsp;is also excluded (but package&nbsp;bar/foo&nbsp;is not). The import dependencies of excluded packages are not listed, and thus not vendored. To exclude packages, also use the “ignore” field of the “vendor.json” file. Packages are identified by their name, they should contain a “/” character (possibly at the end): { &quot;ignore&quot;: &quot;test appengine foo/&quot;, } Go项目包管理工具 govendor Go 1.5中(目前最新版本go1.5beta3)加入了一个experimental feature:&nbsp;vendor/。这个feature不是Go 1.5的正式功能，但却是Go Authors们在解决Go被外界诟病的包依赖管理的道路上的一次重要尝试。目前关于Go vendor机制的资料有限，主要的包括如下几个： 1、Russ Cox在Golang-dev group上的一个名 为&quot;proposal: external packages&quot; topic上的reply。 2、Go 1.5beta版发布后Russ Cox根据上面topic整理的一个doc。 3、medium.com上一篇名为“Go 1.5 vendor/ experiment&quot;的文章。 但由于Go 1.5稳定版还未发布(最新消息是2015.8月中旬发布)，因此估计真正采用vendor的repo尚没有。但既然是Go官方解决方案，后续从 expreimental变成official的可能性就很大（Russ的初步计划：如果试验顺利，1.6版本默认 GO15VENDOREXPERIMENT=&quot;1&quot;；1.7中将去掉GO15VENDOREXPERIMENT环境变量）。因此对于Gophers们，搞 清楚vendor还是很必要的。本文就和大家一起来理解下vendor这个新feature。 一、vendor由来 Go第三方包依赖和管理的问题由来已久，民间知名的解决方案就有godep、&nbsp;gb等。这次Go team在推出vendor前已经在Golang-dev group上做了长时间的调研，最终Russ Cox在Keith Rarick的proposal的基础上做了改良，形成了Go 1.5中的vendor。 Russ Cox基于前期调研的结果，给出了vendor机制的群众意见基础：&nbsp;&nbsp;&nbsp; – 不rewrite gopath &nbsp;&nbsp;&nbsp; – go tool来解决 &nbsp;&nbsp;&nbsp; – go get兼容 &nbsp;&nbsp;&nbsp; – 可reproduce building process 并给出了vendor机制的&quot;4行&quot;诠释： If there is a source directory d/vendor, then, when compiling a source file within the subtree rooted at d, import &quot;p&quot; is interpreted as import &quot;d/vendor/p&quot; if that exists. When there are multiple possible resolutions,the most specific (longest) path wins. The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. Import comments are ignored in vendored packages. 这四行诠释在group中引起了强烈的讨论，短小精悍的背后是理解上的不小差异。我们下面逐一举例理解。 二、vendor基本样例 Russ Cox诠释中的第一条是vendor机制的基础。粗犷的理解就是如果有如下这样的目录结构： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go 如果mypkg/main.go中有&quot;import p&quot;，那么这个p就会被go工具解析为&quot;d/vendor/p&quot;，而不是$GOPATH/src/p。 现在我们就来复现这个例子，我们在go15-vendor-examples/src/basic下建立如上目录结构（其中go15-vendor-examples为GOPATH路径）： $ls -R d/ ./d: mypkg/&nbsp;&nbsp;&nbsp; vendor/ ./d/mypkg: main.go ./d/vendor: p/ ./d/vendor/p: p.go 其中main.go代码如下： //main.go package main import &quot;p&quot; func main() { &nbsp;&nbsp;&nbsp; p.P() } p.go代码如下： //p.go package p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/p&quot;) } 在未开启vendor时，我们编译d/mypkg/main.go会得到如下错误结果： $ go build main.go main.go:3:8: cannot find package &quot;p&quot; in any of: &nbsp;&nbsp;&nbsp; /Users/tony/.bin/go15beta3/src/p (from $GOROOT) &nbsp;&nbsp;&nbsp; /Users/tony/OpenSource/github.com/experiments/go15-vendor-examples/src/p (from $GOPATH) 错误原因很显然：go编译器无法找到package p，d/vendor下的p此时无效。 这时开启vendor：export GO15VENDOREXPERIMENT=1，我们再来编译执行一次：$go run main.go P in d/vendor/p 开启了vendor机制的go tool在d/vendor下找到了package p。 也就是说拥有了vendor后，你的project依赖的第三方包统统放在vendor/下就好了。这样go get时会将第三方包同时download下来，使得你的project无论被下载到那里都可以无需依赖目标环境而编译通过(reproduce the building process)。 三、嵌套vendor 那么问题来了！如果vendor中的第三方包中也包含了vendor目录，go tool是如何choose第三方包的呢？我们来看看下面目录结构(go15-vendor-examples/src/embeded)： d/ &nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vendor/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go &nbsp;&nbsp; mypkg/ &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go embeded目录下出现了嵌套vendor结构：main.go依赖的q包本身还有一个vendor目录，该vendor目录下有一个p包，这样我们就有了两个p包。到底go工具会选择哪个p包呢？显然为了验证一些结论，我们源文件也要变化一下： d/vendor/p/p.go的代码不变。 //d/vendor/q/q.go package q import ( &nbsp;&nbsp;&nbsp; &quot;fmt&quot; &nbsp;&nbsp;&nbsp; &quot;p&quot; ) func Q() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;Q in d/vendor/q&quot;) &nbsp;&nbsp;&nbsp; p.P() } //d/vendor/q/vendor/p/p.gopackage p import &quot;fmt&quot; func P() { &nbsp;&nbsp;&nbsp; fmt.Println(&quot;P in d/vendor/q/vendor/p&quot;) } //mypkg/main.go package main import ( &nbsp;&nbsp;&nbsp; &quot;p&quot; &nbsp;&nbsp;&nbsp; &quot;q&quot; ) func main() { &nbsp;&nbsp;&nbsp; p.P() &nbsp;&nbsp;&nbsp; fmt.Println(&quot;&quot;) &nbsp;&nbsp;&nbsp; q.Q() } 目录和代码编排完毕，我们就来到了见证奇迹的时刻了！我们执行一下main.go： $go run main.go P in d/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p 可以看出main.go中最终引用的是d/vendor/p，而q.Q()中调用的p.P()则是d/vendor/q/vendor/p包的实现。go tool到底是如何在嵌套vendor情况下选择包的呢？我们回到Russ Cox关于vendor诠释内容的第二条： &nbsp;&nbsp; When there are multiple possible resolutions,the most specific (longest) path wins. 这句话很简略，但却引来的巨大争论。&quot;longest path wins&quot;让人迷惑不解。如果仅仅从字面含义来看，上面main.go的执行结果更应该是： P in d/vendor/q/vendor/p Q in d/vendor/q P in d/vendor/q/vendor/p d/vendor/q/vendor/p可比d/vendor/p路径更long，但go tool显然并未这么做。它到底是怎么做的呢？talk is cheap, show you the code。我们粗略翻看一下go tool的实现代码： 在$GOROOT/src/cmd/go/pkg.go中有一个方法vendoredImportPath,这个方法在go tool中广泛被使用： // vendoredImportPath returns the expansion of path when it appears in parent. // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path, // x/vendor/path, vendor/path, or else stay x/y/z if none of those exist. // vendoredImportPath returns the expanded path or, if no expansion is found, the original. // If no expansion is found, vendoredImportPath also returns a list of vendor directories // it searched along the way, to help prepare a useful error message should path turn // out not to exist. func vendoredImportPath(parent *Package, path string) (found string, searched []string) 这个方法的doc讲述的很清楚，这个方法返回所有可能的vendor path，以parentpath为x/y/z为例： x/y/z作为parentpath输入后，返回的vendorpath包括： &nbsp;&nbsp;&nbsp;x/y/z/vendor/pathx/y/vendor/pathx/vendor/path vendor/path 这么说还不是很直观，我们结合我们的embeded vendor的例子来说明一下，为什么结果是像上面那样！go tool是如何resolve p包的！我们模仿go tool对main.go代码进行编译（此时vendor已经开启）。 根据go程序的package init顺序，go tool首先编译p包。如何找到p包呢？此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在p包，于是go tool将p包resolve为d/vendor/p，于是下面的p.P()就会输出：P in d/vendor/p 接下来初始化q包。与p类似，go tool对main.go代码进行编译，此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为： d/mypkg/vendor d/vendor 但只有d/vendor/下存在q包，于是乎go tool将q包resolve为d/vendor/q，由于q包自身还依赖p包，于是go tool继续对q中依赖的p包进行选择，此时go tool的编译对象变为了d/vendor/q/q.go，parent = d/vendor/q，于是经过vendordImportPath处理，可能的vendor路径为： d/vendor/q/vendor d/vendor/vendor d/vendor 存在p包的路径包括： d/vendor/q/vendor/p d/vendor/p 此时按照Russ Cox的诠释2：choose longest，于是go tool选择了d/vendor/q/vendor/p，于是q.Q()中的p.P()输出的内容就是: &quot;P in d/vendor/q/vendor/p&quot; 如果目录结构足够复杂，这个resolve过程也是蛮繁琐的，但按照这个思路依然是可以分析出正确的包的。 另外vendoredImportPath传入的parent x/y/z并不是一个绝对路径，而是一个相对于$GOPATH/src的路径。 BTW，上述测试样例代码在这里可以下载到。 四、第三和第四条 最难理解的第二条已经pass了，剩下两条就比较好理解了。 The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly. 这条就是说，你在源码中不用理会vendor这个路径的存在，该怎么import包就怎么import，不要出现import &quot;d/vendor/p&quot;的情况。vendor是由go tool隐式处理的。 Import comments are ignored in vendored packages. go 1.4引入了canonical imports机制，如: package pdf // import &quot;rsc.io/pdf&quot; 如果你引用的pdf不是来自rsc.io/pdf，那么编译器会报错。但由于vendor机制的存在，go tool不会校验vendor中package的import path是否与canonical import路径是否一致了。 五、问题 根据小节三中的分析，对于vendor中包的resolving过程类似是一个recursive(递归）过程。 main.go中的p使用d/vendor/p；而q.go中的p使用的是d/vendor/q/vendor/p，这样就会存在一个问题：一个工程中存 在着两个版本的p包，这也许不会带来问题，也许也会是问题的根源，但目前来看从go tool的视角来看似乎没有更好的办法。Russ Cox期望大家良好设计工程布局，作为lib的包不携带vendor更佳。 这样一个project内的所有vendor都集中在顶层vendor里面。就像下面这样： d/ &nbsp;&nbsp;&nbsp; vendor/&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q/ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … … &nbsp;&nbsp;&nbsp; mypkg1 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; mypkg2 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go &nbsp;&nbsp;&nbsp; … … 另外Go vendor不支持第三方包的版本管理，没有类似godep的Godeps.json这样的存储包元信息的文件。不过目前已经有第三方的vendor specs放在了github上，之前Go team的Brad Fizpatrick也在Golang-dev上征集过类似的方案，不知未来vendor是否会支持。 六、vendor vs. internal 在golang-dev有人提到：有了vendor，internal似乎没用了。这显然是混淆了internal和vendor所要解决的问题。 internal故名思议：内部包，不是对所有源文件都可见的。vendor是存储和管理外部依赖包，更类似于external，里面的包都是copy自 外部的，工程内所有源文件均可import vendor中的包。另外internal在1.4版本中已经加入到go核心，是不可能轻易去除的，虽然到目前为止我们还没能亲自体会到internal 包的作用。 在《Go 1.5中值得关注的几个变化》一文中我提到过go 1.5 beta1似乎“不支持”internal，beta3发布后，我又试了试看beta3是否支持internal包。 结果是beta3中，build依旧不报错。但go list -json会提示错误：&quot;DepsErrors&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;ImportStack&quot;: [ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;otherpkg&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;mypkg/internal/foo&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ], &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Pos&quot;: &quot;&quot;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &quot;Err&quot;: &quot;use of internal package not allowed&quot; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; ] 难道真的要到最终go 1.5版本才会让internal包发挥作用? 长期以来，golang 对外部依赖都没有很好的管理方式，只能从 $GOPATH 下查找依赖。这就造成不同用户在安装同一个项目适合可能从外部获取到不同的依赖库版本，同时当无法联网时，无法编译依赖缺失的项目。 自 1.5 版本开始引入 govendor 工具，该工具将项目依赖的外部包放到项目下的 vendor 目录下（对比 nodejs 的 node_modules 目录），并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。 对于 govendor 来说，主要存在三种位置的包：项目自身的包组织为本地（local）包；传统的存放在 $GOPATH 下的依赖包为外部（external）依赖包；被 govendor 管理的放在 vendor 目录下的依赖包则为 vendor 包。 具体来看，这些包可能的类型如下： 状态 缩写状态 含义 +local l 本地包，即项目自身的包组织 +external e 外部包，即被 $GOPATH 管理，但不在 vendor 目录下 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside &nbsp; 外部包和缺失的包 +all &nbsp; 所有的包 常见的命令如下，格式为&nbsp;govendor COMMAND。 通过指定包类型，可以过滤仅对指定包进行操作。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 add PKG_PATH 添加指定的依赖包到 vendor 目录 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似&nbsp;go get&nbsp;目录，拉取依赖包到 vendor 目录 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/02/23/7f2a89155f3046cae883e95303ab8566.html","headline":"使用vendor管理Golang项目依赖","dateModified":"2017-02-23T00:00:00+08:00","datePublished":"2017-02-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/02/23/7f2a89155f3046cae883e95303ab8566.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>使用vendor管理Golang项目依赖</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> The Vendor Tool for Go</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">go get -u github.com/kardianos/govendor</code></pre> 
  <p></p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> New users please read the<strong>FAQ</strong></p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Package developers should read the developer guide.</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> For a high level overview read the whitepaper</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Uses the <strong>go1.5+ vendor folder. Multiple workflows supported, single tool.</strong></p> 
  <div style="font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> 
   <p style="line-height:1.7em;text-indent:1em;"> </p> 
  </div> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">Copy</span> existing dependencies</strong><span style="color:#333333;"> from</span><span style="color:rgb(51,51,51);">$GOPATH</span><span style="color:#333333;"> with&nbsp;</span><strong><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><span style="color:#ff0000;">govendor add/update</span></code><span style="color:#333333;">&nbsp;.</span></strong></li>
   <li style="line-height:1.7em;list-style-type:disc;"><span style="color:#333333;">If you ignore&nbsp;</span><code style="color:rgb(51,51,51);font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><strong>vendor/*/</strong></code><span style="color:#333333;">&nbsp;, restore dependencies with&nbsp;</span><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><strong><span style="color:#ff0000;">govendor sync</span></strong></code><span style="color:#333333;">&nbsp;.</span></li>
   <li style="line-height:1.7em;list-style-type:disc;"><span style="color:#333333;">Pull in new dependencies or update existing dependencies directly from&nbsp;</span><br><span style="color:#333333;">remotes with&nbsp;</span><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><strong><span style="color:#ff0000;">govendor fetch</span></strong></code><span style="color:#333333;">&nbsp;.</span></li>
   <li style="line-height:1.7em;list-style-type:disc;"><span style="color:#333333;">Migrate from legacy systems with&nbsp;</span><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><strong><span style="color:#ff0000;">govendor migrate</span></strong></code><span style="color:#333333;">&nbsp;.</span></li>
   <li style="color:rgb(51,51,51);line-height:1.7em;list-style-type:disc;">Supports<strong>Linux, OS X, Windows</strong>, probably all others.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><span style="color:#333333;">Supports</span><span style="color:rgb(51,51,51);"> git, hg, svn, bzr</span><span style="color:#333333;">(</span><strong><span style="color:#ff0000;">must be installed an on the PATH</span></strong><span style="color:#333333;">).</span></li>
  </ul>
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Notes</h2> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="color:rgb(51,51,51);line-height:1.7em;list-style-type:disc;">The <strong> project </strong>must be within a <strong>$GOPATH</strong>.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><span style="color:#333333;">If using go1.5, ensure you&nbsp;</span><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-size:14px;"><strong><span style="color:#ff0000;">set GO15VENDOREXPERIMENT=1</span></strong></code><span style="color:#333333;">&nbsp;.</span></li>
  </ul>
  <h3 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Quick Start, also see theFAQ</h3> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;"></code><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;"></code></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Setup your project</span><span style="color:rgb(51,51,51);">.</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> cd "my project in GOPATH"</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor init</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:rgb(51,51,51);">Add </span><span style="color:#ff0000;">existing GOPATH files</span><span style="color:#333333;"> to vendor.</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor add +external</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> View your work.</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor list</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Look at what is using a package</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor list -v fmt</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:rgb(51,51,51);">Specify a </span><span style="color:#ff0000;">specific version</span><span style="color:#333333;"> or revision to fetch</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <strong><span style="color:#ff0000;">govendor fetch</span></strong><span style="color:#333333;"><strong>golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</strong></span></p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> govendor fetch <strong>golang.org/x/net/context@v1 # Get latest v1.&nbsp;<em>.</em>&nbsp;tag or branch.</strong></p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> govendor fetch <strong>golang.org/x/net/context@=v1 # Get the tag or branch named "v1".</strong></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Update</span><span style="color:rgb(51,51,51);"> a package to latest, given any prior version constraint</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor fetch golang.org/x/net/context</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Format </span><span style="color:rgb(51,51,51);">your repository only</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor fmt +local</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Build</span><span style="color:rgb(51,51,51);"> everything in your repository only</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor install +local</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Test</span><span style="color:rgb(51,51,51);"> your repository only</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <pre><code class="language-cpp">govendor test +local</code></pre> 
  <p></p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> <span style="color:#ff0000;">Sub-commands</span></h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;"></code></p> 
  <pre><code class="language-sql"><span style="color:#444444;"> </span><strong><span style="color:#ff0000;">init</span></strong><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Create</span><span style="color:#444444;"> the </span><span class="hljs-string" style="color:rgb(136,0,0);">"vendor"</span><span style="color:#444444;"> folder </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">and</span><span style="color:#444444;"> the </span><span class="hljs-string" style="color:rgb(136,0,0);">"vendor.json"</span><span style="color:#444444;"> file. </span><span class="hljs-keyword"><strong><span style="color:#ff0000;">list</span></strong></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">List</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">and</span><span style="color:#444444;"> filter existing dependencies </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">and</span><span style="color:#444444;"> packages. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">add</span></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Add</span><span style="color:#444444;"> packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> $GOPATH. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">update</span></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Update</span><span style="color:#444444;"> packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> $GOPATH. </span><span style="color:#ff0000;"><strong>remove</strong></span><span style="color:#444444;"> Remove packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> the vendor folder. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">status</span></span><span style="color:#444444;"> Lists </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">any</span><span style="color:#444444;"> packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">missing</span><span style="color:#444444;">, </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">out</span><span style="color:#444444;">-</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">of</span><span style="color:#444444;">-</span><span class="hljs-built_in" style="color:rgb(57,115,0);">date</span><span style="color:#444444;">, </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">or</span><span style="color:#444444;"> modified locally. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">fetch</span></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Add</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">new</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">or</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">update</span><span style="color:#444444;"> vendor folder packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> remote repository. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">sync</span></span><span style="color:#444444;"> Pull packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">into</span><span style="color:#444444;"> vendor folder </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> remote repository </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">with</span><span style="color:#444444;"> revisions </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> vendor.json file. </span><span style="color:#ff0000;"><strong>migrate</strong></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Move</span><span style="color:#444444;"> packages </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">from</span><span style="color:#444444;"> a legacy tool </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">to</span><span style="color:#444444;"> the vendor folder </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">with</span><span style="color:#444444;"> metadata. </span><span class="hljs-keyword" style="font-weight:700;"><span style="color:#ff0000;">get</span></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">Like</span><span style="color:#444444;"> </span><span class="hljs-string" style="color:rgb(136,0,0);">"go get"</span><span style="color:#444444;"> but copies dependencies </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">into</span><span style="color:#444444;"> a </span><span class="hljs-string" style="color:rgb(136,0,0);">"vendor"</span><span style="color:#444444;"> folder. </span><span style="color:#ff0000;"><strong>license</strong></span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">List</span><span style="color:#444444;"> discovered licenses </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">for</span><span style="color:#444444;"> the given </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">status</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">or</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">import</span><span style="color:#444444;"> paths. </span><span style="color:#ff0000;"><strong>shell</strong></span><span style="color:#444444;"> Run a </span><span class="hljs-string" style="color:rgb(136,0,0);">"shell"</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">to</span><span style="color:#444444;"> make multiple sub-commands more efficient </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">for</span><span style="color:#444444;"> </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">large</span><span style="color:#444444;"> projects.</span></code></pre> 
  <pre class="prettyprint hljs verilog" style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:rgb(68,68,68);font-size:14px;line-height:1.5em;background-color:rgb(246,246,246);border:none;">gotool commands that are wrapped:
&nbsp;&nbsp;<span class="hljs-meta" style="color:rgb(31,113,153);">`+&lt;status&gt;` package selection may be used with them</span>
fmt, build, install, clean, test, vet, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">generate</span>, tool
&nbsp;</pre> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Status</h2> 
  <div style="font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> 
   <p style="line-height:1.7em;text-indent:1em;"> Packages can be specified by their “status”.</p> 
   <code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;"></code> 
   <pre><code class="language-delphi">    +<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">local</span>    (l) packages <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">in</span> your project

    +<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">external</span> (e) referenced packages <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">in</span> GOPATH but <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">not</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">in</span> current project

    +vendor   (v) packages <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">in</span> the vendor folder

    +std      (s) packages <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">in</span> the standard <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:700;">library</span></code></pre> 
  </div> 
  <pre class="prettyprint hljs diff" style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:rgb(68,68,68);font-size:14px;line-height:1.5em;background-color:rgb(246,246,246);border:none;"><span class="hljs-addition" style="color:rgb(57,115,0);">+excluded (x) externalpackagesexplicitelyexcludedfromvendoring</span>
<span class="hljs-addition" style="color:rgb(57,115,0);">+unused&nbsp;&nbsp;(u) packagesin thevendorfolder, butunused</span>
<span class="hljs-addition" style="color:rgb(57,115,0);">+missing&nbsp;&nbsp;(m) referencedpackagesbutnot found</span>
&nbsp;
<span class="hljs-addition" style="color:rgb(57,115,0);">+program&nbsp;&nbsp;(p) package is a mainpackage</span>
&nbsp;
<span class="hljs-addition" style="color:rgb(57,115,0);">+outside&nbsp;&nbsp;+external +missing</span>
<span class="hljs-addition" style="color:rgb(57,115,0);">+all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+allpackages</span>
&nbsp;
</pre> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Status can be referenced by their initial letters.</p> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+std</code>&nbsp;same as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+s</code></li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+external</code>&nbsp;same as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+ext</code>&nbsp;same as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+e</code></li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+excluded</code>&nbsp;same as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+exc</code>&nbsp;same as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+x</code></li>
  </ul>
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Status can be logically composed:</p> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+local,program</code>&nbsp;(local AND program) local packages that are also programs</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+local +vendor</code>&nbsp;(local OR vendor) local packages or vendor packages</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+vendor,program +std</code>&nbsp;((vendor AND program) OR std) vendor packages that are also programs&nbsp;<br> or std library packages</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">+vendor,^program</code>&nbsp;(vendor AND NOT program) vendor package that are not “main” packages.</li>
  </ul>
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Package specifier</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> The full package-spec is:</p> 
  <code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">&lt;path&gt;[::&lt;origin&gt;][{/...|/^}][@[&lt;version-spec&gt;]]</code>
  <span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;font-size:16px;background-color:rgb(254,254,254);"></span> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <strong><span style="color:#ff0000;">Some examples:</span></strong></p> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor</code>&nbsp;specifies a single package and single folder.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/...</code>&nbsp;specifies&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">govendor</code>&nbsp;and all referenced&nbsp;<br> packages under that path.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/^</code>&nbsp;specifies the&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">govendor</code>&nbsp;folder and all&nbsp;<br> sub-folders. Useful for resources or if you don’t want a partial repository.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/^::github.com/myself/govendor</code>&nbsp;same as above&nbsp;<br> but fetch from user “myself”.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/...@abc12032</code>&nbsp;all referenced packages at&nbsp;<br> revision&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">abc12032</code>&nbsp;.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/...@v1</code>&nbsp;same as above, but get the most recent&nbsp;<br> “v1” tag, such as “v1.4.3”.</li>
   <li style="line-height:1.7em;list-style-type:disc;"><code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">github.com/kardianos/govendor/...@=v1</code>&nbsp;get the exact version “v1”.</li>
  </ul>
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Packages and Status</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> You may specify multiple package-specs and multiple status in a single command.</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Commands that accept status and package-spec:</p> 
  <ul style="list-style-type:none;font-size:16px;line-height:1.7em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);">
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">list</span></strong></li>
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">add</span></strong></li>
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">update</span></strong></li>
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">remove</span></strong></li>
   <li style="line-height:1.7em;list-style-type:disc;"><strong><span style="color:#ff0000;">fetch</span></strong></li>
  </ul>
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> You may pass arguments to govendor through stdin if the last argument is a “-“.</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> For example&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">echo +vendor | govendor list -</code>&nbsp;will list all vendor packages.</p> 
  <h2 style="font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;line-height:1.6em;color:rgb(51,51,51);font-size:18px;text-indent:1em;background-color:rgb(254,254,254);"> Ignoring build tags and excluding packages</h2> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Ignoring build tags is opt-out and is designed to be the opposite of the build</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> file directives which are opt-in when specified. Typically a developer will</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> want to support cross platform builds, but selectively opt out of tags, tests,</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> and architectures as desired.</p> 
  <div style="font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> 
   <p style="line-height:1.7em;text-indent:1em;"> To ignore additional tags edit the “vendor.json” file and add tag to the vendor</p> 
   <p style="line-height:1.7em;text-indent:1em;"> “ignore” file field. The field uses spaces to separate tags to ignore.</p> 
   <p style="line-height:1.7em;text-indent:1em;"> For example the following will ignore both test and appengine files.</p> 
   <pre class="hljs json" style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:rgb(68,68,68);font-size:14px;line-height:1.5em;background-color:rgb(246,246,246);border:none;">{

    <span class="hljs-attr">"ignore"</span>: <span class="hljs-string" style="color:rgb(136,0,0);">"test appengine"</span>,

}</pre> 
  </div> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Similarly, some specific packages can be excluded from the vendoring process.</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> These packages will be listed as&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">excluded</code>&nbsp;(&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">x</code>&nbsp;), and will not be copied to the</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> “vendor” folder when running&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">govendor add|fetch|update</code>&nbsp;.</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> Any sub-package&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">foo/bar</code>&nbsp;of an excluded package&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">foo</code>&nbsp;is also excluded (but</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> package&nbsp;<code style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;background-color:rgb(247,247,249);border:none;font-weight:600;font-size:14px;">bar/foo</code>&nbsp;is not). The import dependencies of excluded packages are not</p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> listed, and thus not vendored.</p> 
  <div style="font-size:16px;line-height:1.7em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> 
   <p style="line-height:1.7em;text-indent:1em;"> To exclude packages, also use the “ignore” field of the “vendor.json” file.</p> 
   <p style="line-height:1.7em;text-indent:1em;"> Packages are identified by their name, they should contain a “/” character</p> 
   <p style="line-height:1.7em;text-indent:1em;"> (possibly at the end):</p> 
   <pre class="hljs json" style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;color:rgb(68,68,68);font-size:14px;line-height:1.5em;background-color:rgb(246,246,246);border:none;">{

    <span class="hljs-attr">"ignore"</span>: <span class="hljs-string" style="color:rgb(136,0,0);">"test appengine foo/"</span>,

}</pre> 
  </div> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <strong><span style="color:#c0c0c0;">Go项目包管理工具 govendor</span></strong></p> 
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> </p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <a href="http://tonybai.com/2015/07/10/some-changes-in-go-1-5/" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Go 1.5</a>中(目前最新版本go1.5beta3)加入了一个experimental feature:&nbsp;<span>vendor/</span>。这个feature不是<a href="https://tip.golang.org/doc/go1.5" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Go 1.5</a>的正式功能，但却是Go Authors们在解决Go被外界诟病的包<strong>依赖管理</strong>的道路上的一次重要尝试。目前关于Go vendor机制的资料有限，主要的包括如下几个：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">1、Russ Cox在<a href="https://groups.google.com/forum/#!forum/golang-dev" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Golang-dev group</a>上的一个名 为"<a href="https://groups.google.com/d/topic/golang-dev/74zjMON9glU%20/discussion" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">proposal: external packages</a>" topic上的reply。<br> 2、Go 1.5beta版发布后Russ Cox根据上面topic整理的一个<a href="https://golang.org/s/go15vendor" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">doc</a>。<br> 3、medium.com上一篇名为“<a href="https://medium.com/@freeformz/go-1-5-s-vendor-experiment-fd3e830f52c3" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Go 1.5 vendor/ experiment</a>"的文章。</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 但由于Go 1.5稳定版还未发布(最新消息是2015.8月中旬发布)，因此估计真正采用vendor的repo尚没有。但既然是Go官方解决方案，后续从 expreimental变成official的可能性就很大（Russ的初步计划：如果试验顺利，1.6版本默认 GO15VENDOREXPERIMENT="1"；1.7中将去掉GO15VENDOREXPERIMENT环境变量）。因此对于Gophers们，搞 清楚vendor还是很必要的。本文就和大家一起来理解下vendor这个新feature。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>一、vendor由来</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <a href="http://tonybai.com/tag/go" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Go</a>第三方包依赖和管理的问题由来已久，民间知名的解决方案就有<a href="https://github.com/tools/godep" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">godep</a>、&nbsp;<a href="https://github.com/constabulary/gb" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">gb</a>等。这次Go team在推出vendor前已经在Golang-dev group上做了长时间的调研，最终Russ Cox在<a href="https://github.com/kr" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Keith Rarick</a>的proposal的基础上做了改良，形成了Go 1.5中的vendor。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> Russ Cox基于前期调研的结果，给出了vendor机制的群众意见基础：<br><span style="font-family:'Courier New';">&nbsp;&nbsp;&nbsp; – 不rewrite gopath<br> &nbsp;&nbsp;&nbsp; – go tool来解决<br> &nbsp;&nbsp;&nbsp; – go get兼容<br> &nbsp;&nbsp;&nbsp; – 可reproduce building process</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 并给出了vendor机制的"4行"诠释：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">If there is a source directory d/vendor, then, when compiling a source file within the subtree rooted at d, import "p" is interpreted as import "d/vendor/p" if that exists.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">When there are multiple possible resolutions,the most specific (longest) path wins.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">Import comments are ignored in vendored packages.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 这四行诠释在group中引起了强烈的讨论，短小精悍的背后是理解上的不小差异。我们下面逐一举例理解。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>二、vendor基本样例</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> Russ Cox诠释中的第一条是vendor机制的基础。粗犷的理解就是如果有如下这样的目录结构：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/<br> &nbsp;&nbsp; vendor/<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go<br> &nbsp;&nbsp; mypkg/<br> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">如果mypkg/main.go中有"import p"，那么这个p就会被go工具解析为"d/vendor/p"，而不是$GOPATH/src/p。</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 现在我们就来复现这个例子，我们在go15-vendor-examples/src/basic下建立如上目录结构（其中go15-vendor-examples为GOPATH路径）：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">$ls -R<br> d/</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">./d:<br> mypkg/&nbsp;&nbsp;&nbsp; vendor/</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">./d/mypkg:<br> main.go</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">./d/vendor:<br> p/</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">./d/vendor/p:<br> p.go</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 其中main.go代码如下：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">//main.go<br> package main</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">import "p"</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">func main() {<br> &nbsp;&nbsp;&nbsp; p.P()<br> }</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> p.go代码如下：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">//p.go<br> package p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">import "fmt"</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">func P() {<br> &nbsp;&nbsp;&nbsp; fmt.Println("P in d/vendor/p")<br> }</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 在未开启vendor时，我们编译d/mypkg/main.go会得到如下错误结果：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">$ go build main.go<br> main.go:3:8: cannot find package "p" in any of:<br> &nbsp;&nbsp;&nbsp; /Users/tony/.bin/go15beta3/src/p (from $GOROOT)<br> &nbsp;&nbsp;&nbsp; /Users/tony/OpenSource/github.com/experiments/go15-vendor-examples/src/p (from $GOPATH)</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 错误原因很显然：go编译器无法找到package p，d/vendor下的p此时无效。</p> 
  <p style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="color:#333333;">这时</span><span style="color:#ff0000;"><strong>开启vendor：</strong><span style="font-family:'Courier New';"><strong>export GO15VENDOREXPERIMENT=1</strong></span></span><span style="color:#333333;">，我们再来编译执行一次：</span><br><span style="color:rgb(51,51,51);font-family:'Courier New';">$go run main.go<br> P in d/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 开启了vendor机制的go tool在d/vendor下找到了package p。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 也就是说拥有了vendor后，你的project依赖的第三方包统统放在vendor/下就好了。这样go get时会将第三方包同时download下来，使得你的project无论被下载到那里都可以无需依赖目标环境而编译通过(reproduce the building process)。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>三、嵌套vendor</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 那么问题来了！如果vendor中的第三方包中也包含了vendor目录，go tool是如何choose第三方包的呢？我们来看看下面目录结构(go15-vendor-examples/src/embeded)：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/<br> &nbsp;&nbsp; vendor/<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p.go<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q/<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.go<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vendor/<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p/<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.go<br> &nbsp;&nbsp; mypkg/<br> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> embeded目录下出现了嵌套vendor结构：main.go依赖的q包本身还有一个vendor目录，该vendor目录下有一个p包，这样我们就有了两个p包。到底go工具会选择哪个p包呢？显然为了验证一些结论，我们源文件也要变化一下：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/vendor/p/p.go</span>的代码不变。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">//d/vendor/q/q.go<br> package q</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">import (<br> &nbsp;&nbsp;&nbsp; "fmt"<br> &nbsp;&nbsp;&nbsp; "p"<br> )</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">func Q() {<br> &nbsp;&nbsp;&nbsp; fmt.Println("Q in d/vendor/q")<br> &nbsp;&nbsp;&nbsp; p.P()<br> }</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> //<span style="font-family:'Courier New';">d/vendor/q/vendor/p/p.go</span><br><span style="font-family:'Courier New';">package p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">import "fmt"</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">func P() {<br> &nbsp;&nbsp;&nbsp; fmt.Println("P in d/vendor/q/vendor/p")<br> }</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">//mypkg/main.go<br> package main</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">import (<br> &nbsp;&nbsp;&nbsp; "p"<br> &nbsp;&nbsp;&nbsp; "q"<br> )</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">func main() {<br> &nbsp;&nbsp;&nbsp; p.P()<br> &nbsp;&nbsp;&nbsp; fmt.Println("")<br> &nbsp;&nbsp;&nbsp; q.Q()<br> }</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 目录和代码编排完毕，我们就来到了见证奇迹的时刻了！我们执行一下main.go：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">$go run main.go<br> P in d/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">Q in d/vendor/q<br> P in d/vendor/q/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 可以看出main.go中最终引用的是d/vendor/p，而q.Q()中调用的p.P()则是d/vendor/q/vendor/p包的实现。go tool到底是如何在嵌套vendor情况下选择包的呢？我们回到Russ Cox关于vendor诠释内容的第二条：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">&nbsp;&nbsp; When there are multiple possible resolutions,the most specific (longest) path wins.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 这句话很简略，但却引来的巨大争论。<span style="font-family:'Courier New';">"longest path wins"</span>让人迷惑不解。如果仅仅从字面含义来看，上面main.go的执行结果更应该是：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">P in d/vendor/q/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">Q in d/vendor/q<br> P in d/vendor/q/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/vendor/q/vendor/p可比</span><span style="font-family:'Courier New';">d/vendor/p路径更long，但go tool显然并未这么做。它到底是怎么做的呢？talk is cheap, show you the code。我们粗略翻看一下</span>go tool的实现代码：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 在$GOROOT/src/cmd/go/pkg.go中有一个方法<span style="font-family:'Courier New';">vendoredImportPath,这个方法在go tool中广泛被使用</span>：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">// vendoredImportPath returns the expansion of path when it appears in parent.<br> // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,<br> // x/vendor/path, vendor/path, or else stay x/y/z if none of those exist.<br> // vendoredImportPath returns the expanded path or, if no expansion is found, the original.<br> // If no expansion is found, vendoredImportPath also returns a list of vendor directories<br> // it searched along the way, to help prepare a useful error message should path turn<br> // out not to exist.<br> func vendoredImportPath(parent *Package, path string) (found string, searched []string)</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 这个方法的doc讲述的很清楚，这个方法返回所有可能的vendor path，以parentpath为x/y/z为例：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> x/y/z作为parentpath输入后，返回的vendorpath包括：<br> &nbsp;&nbsp;&nbsp;<br><span style="font-family:'Courier New';">x/y/z/vendor/path</span><br><span style="font-family:'Courier New';">x/y/vendor/path</span><br><span style="font-family:'Courier New';">x/vendor/path<br> vendor/path</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">这么说还不是很直观，我们结合我们的embeded vendor的例子来说明一下，为什么结果是像上面那样！go tool是如何resolve p包的！我们模仿go tool对main.go代码进行编译（此时vendor已经开启）。</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">根据go程序的package init顺序，go tool首先编译p包。如何找到p包呢？此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为：</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/mypkg/vendor<br> d/vendor</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">但只有d/vendor/下存在p包，于是go tool将p包resolve为d/vendor/p，于是下面的p.P()就会输出：</span><br><span style="font-family:'Courier New';">P in d/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">接下来初始化q包。与p类似，go tool</span><span style="font-family:'Courier New';">对main.go代码进行编译，此时的编译对象是d/mypkg/main.go，于是乎parent = d/mypkg，经过vendordImportPath处理，可能的vendor路径为：</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/mypkg/vendor<br> d/vendor</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">但只有d/vendor/下存在q包，于是乎go tool将q包resolve为d/vendor/q，由于q包自身还依赖p包，于是go tool继续对q中依赖的p包进行选择，此时go tool的编译对象变为了d/vendor/q/q.go，parent = d/vendor/q，于是经过</span><span style="font-family:'Courier New';">vendordImportPath处理，可能的vendor路径为：</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> d/vendor/q/vendor<br> d/vendor/vendor<br> d/vendor</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 存在p包的路径包括：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/vendor/q/vendor/p<br> d/vendor/p</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">此时按照Russ Cox的诠释2：choose longest，于是go tool选择了d/vendor/q/vendor/p，于是q.Q()中的p.P()输出的内容就是:<br> "</span><span style="font-family:'Courier New';">P in d/vendor/q/vendor/p"</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 如果目录结构足够复杂，这个resolve过程也是蛮繁琐的，但按照这个思路依然是可以分析出正确的包的。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 另外<span style="font-family:'Courier New';">vendoredImportPath传入的parent x/y/z并不是一个绝对路径，而是一个相对于$GOPATH/src的路径。</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> BTW，上述测试样例代码在<a href="https://github.com/bigwhite/experiments/tree/master/go15-vendor-examples" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">这里</a>可以下载到。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>四、</span>第三和第四条</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 最难理解的第二条已经pass了，剩下两条就比较好理解了。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">The short form must always be used: no import path can&nbsp; contain “/vendor/” explicitly.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">这条就是说，你在源码中不用理会vendor这个路径的存在，该怎么import包就怎么import，不要出现import "d/vendor/p"的情况。vendor是由go tool隐式处理的。</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">Import comments are ignored in vendored packages.</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <a href="http://tonybai.com/2014/11/04/some-changes-in-go-1-4/" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">go 1.4</a>引入了canonical imports机制，如:</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> package pdf // import "rsc.io/pdf"</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 如果你引用的pdf不是来自rsc.io/pdf，那么编译器会报错。但由于vendor机制的存在，go tool不会校验vendor中package的import path是否与canonical import路径是否一致了。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>五、问题</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 根据小节三中的分析，对于vendor中包的resolving过程类似是一个recursive(递归）过程。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> main.go中的p使用d/vendor/p；而q.go中的p使用的是d/vendor/q/vendor/p，这样就会存在一个问题：一个工程中存 在着两个版本的p包，这也许不会带来问题，也许也会是问题的根源，但目前来看从go tool的视角来看似乎没有更好的办法。Russ Cox期望大家良好设计工程布局，作为lib的包不携带vendor更佳。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 这样一个project内的所有vendor都集中在顶层vendor里面。就像下面这样：</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span style="font-family:'Courier New';">d/<br> &nbsp;&nbsp;&nbsp; vendor/&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q/<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p/<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … …<br> &nbsp;&nbsp;&nbsp; mypkg1<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go<br> &nbsp;&nbsp;&nbsp; mypkg2<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; main.go<br> &nbsp;&nbsp;&nbsp; … …</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 另外Go vendor不支持第三方包的版本管理，没有类似godep的Godeps.json这样的存储包元信息的文件。不过目前已经有第三方的<a href="https://github.com/kardianos/vendor-spec" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">vendor specs</a>放在了github上，之前Go team的Brad Fizpatrick也在Golang-dev上征集过类似的方案，不知未来vendor是否会支持。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> <span>六、vendor vs. internal</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 在golang-dev有人提到：有了vendor，internal似乎没用了。这显然是混淆了internal和vendor所要解决的问题。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> internal故名思议：内部包，不是对所有源文件都可见的。vendor是存储和管理外部依赖包，更类似于external，里面的包都是copy自 外部的，工程内所有源文件均可import vendor中的包。另外internal在1.4版本中已经加入到go核心，是不可能轻易去除的，虽然到目前为止我们还没能亲自体会到internal 包的作用。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 在《<a href="http://tonybai.com/2015/07/10/some-changes-in-go-1-5/" rel="nofollow" style="background:transparent;color:rgb(39,128,227);text-decoration:none;">Go 1.5中值得关注的几个变化</a>》一文中我提到过go 1.5 beta1似乎“不支持”internal，beta3发布后，我又试了试看beta3是否支持internal包。</p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 结果是beta3中，build依旧不报错。但go list -json会提示错误：<br><span style="font-family:'Courier New';">"DepsErrors": [<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "ImportStack": [<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "otherpkg",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mypkg/internal/foo"<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ],<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "Pos": "",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "Err": "use of internal package not allowed"<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; ]</span></p> 
  <p style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;"> 难道真的要到最终go 1.5版本才会让internal包发挥作用?</p> 
  <p><br></p> 
  <p></p> 
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 长期以来，golang 对外部依赖都没有很好的管理方式，只能从 $GOPATH 下查找依赖。这就造成不同用户在安装同一个项目适合可能从外部获取到不同的依赖库版本，同时当无法联网时，无法编译依赖缺失的项目。</p> 
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 自 1.5 版本开始引入 govendor 工具，该工具将项目依赖的外部包放到项目下的 vendor 目录下（对比 nodejs 的 node_modules 目录），并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。</p> 
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 对于 govendor 来说，主要存在三种位置的包：项目自身的包组织为本地（local）包；传统的存放在 $GOPATH 下的依赖包为外部（external）依赖包；被 govendor 管理的放在 vendor 目录下的依赖包则为 vendor 包。</p> 
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 具体来看，这些包可能的类型如下：</p> 
  <table style="color:rgb(51,51,51);font-family:Arial;border-spacing:0px;border-collapse:collapse;display:block;overflow:auto;font-size:16px;line-height:24px;">
   <thead>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <th style="border:1px solid rgb(221,221,221);">状态</th> 
     <th style="border:1px solid rgb(221,221,221);">缩写状态</th> 
     <th style="border:1px solid rgb(221,221,221);">含义</th> 
    </tr>
   </thead>
   <tbody>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);">+local</td> 
     <td style="border:1px solid rgb(221,221,221);">l</td> 
     <td style="border:1px solid rgb(221,221,221);">本地包，即项目自身的包组织</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);">+external</td> 
     <td style="border:1px solid rgb(221,221,221);">e</td> 
     <td style="border:1px solid rgb(221,221,221);">外部包，即被 $GOPATH 管理，但不在 vendor 目录下</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);">+vendor</td> 
     <td style="border:1px solid rgb(221,221,221);">v</td> 
     <td style="border:1px solid rgb(221,221,221);">已被 govendor 管理，即在 vendor 目录下</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);">+std</td> 
     <td style="border:1px solid rgb(221,221,221);">s</td> 
     <td style="border:1px solid rgb(221,221,221);">标准库中的包</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);">+unused</td> 
     <td style="border:1px solid rgb(221,221,221);">u</td> 
     <td style="border:1px solid rgb(221,221,221);">未使用的包，即包在 vendor 目录下，但项目并没有用到</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);">+missing</td> 
     <td style="border:1px solid rgb(221,221,221);">m</td> 
     <td style="border:1px solid rgb(221,221,221);">代码引用了依赖包，但该包并没有找到</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);">+program</td> 
     <td style="border:1px solid rgb(221,221,221);">p</td> 
     <td style="border:1px solid rgb(221,221,221);">主程序包，意味着可以编译为执行文件</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);">+outside</td> 
     <td style="border:1px solid rgb(221,221,221);">&nbsp;</td> 
     <td style="border:1px solid rgb(221,221,221);">外部包和缺失的包</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);">+all</td> 
     <td style="border:1px solid rgb(221,221,221);">&nbsp;</td> 
     <td style="border:1px solid rgb(221,221,221);">所有的包</td> 
    </tr>
   </tbody>
  </table>
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 常见的命令如下，格式为&nbsp;<code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">govendor COMMAND</code>。</p> 
  <p style="color:rgb(51,51,51);font-family:Arial;font-size:16px;line-height:24px;"> 通过指定包类型，可以过滤仅对指定包进行操作。</p> 
  <table style="color:rgb(51,51,51);font-family:Arial;border-spacing:0px;border-collapse:collapse;display:block;overflow:auto;font-size:16px;line-height:24px;">
   <thead>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <th style="border:1px solid rgb(221,221,221);">命令</th> 
     <th style="border:1px solid rgb(221,221,221);">功能</th> 
    </tr>
   </thead>
   <tbody>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">init</code></td> 
     <td style="border:1px solid rgb(221,221,221);">初始化 vendor 目录</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">list</code></td> 
     <td style="border:1px solid rgb(221,221,221);">列出所有的依赖包</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">add</code></td> 
     <td style="border:1px solid rgb(221,221,221);">添加包到 vendor 目录，如 govendor add +external 添加所有外部包</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">add PKG_PATH</code></td> 
     <td style="border:1px solid rgb(221,221,221);">添加指定的依赖包到 vendor 目录</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">update</code></td> 
     <td style="border:1px solid rgb(221,221,221);">从 $GOPATH 更新依赖包到 vendor 目录</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">remove</code></td> 
     <td style="border:1px solid rgb(221,221,221);">从 vendor 管理中删除依赖</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">status</code></td> 
     <td style="border:1px solid rgb(221,221,221);">列出所有缺失、过期和修改过的包</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">fetch</code></td> 
     <td style="border:1px solid rgb(221,221,221);">添加或更新包到本地 vendor 目录</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">sync</code></td> 
     <td style="border:1px solid rgb(221,221,221);">本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本</td> 
    </tr>
    <tr style="border-top:1px solid rgb(204,204,204);background-color:rgb(248,248,248);">
     <td style="border:1px solid rgb(221,221,221);"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">get</code></td> 
     <td style="border:1px solid rgb(221,221,221);">类似&nbsp;<code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:13.6px;">go get</code>&nbsp;目录，拉取依赖包到 vendor 目录</td> 
    </tr>
   </tbody>
  </table>
  <br>
  <p style="font-size:16px;line-height:1.7em;text-indent:1em;color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', '微软雅黑', sans-serif;background-color:rgb(254,254,254);"> <br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/williamfan21c/article/details/56680139,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/williamfan21c/article/details/56680139,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
