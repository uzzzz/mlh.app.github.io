<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>C# RSA加密、解密、加签、验签、支持JAVA格式公钥私钥、PEM格式公钥私钥、.NET格式公钥私钥 -变态模式【支持私钥加密，公钥解密】（二） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="C# RSA加密、解密、加签、验签、支持JAVA格式公钥私钥、PEM格式公钥私钥、.NET格式公钥私钥 -变态模式【支持私钥加密，公钥解密】（二）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/gzy11/article/details/58609719 RSA变态模式：【私钥加密，公钥解密】 一般这种写法都是JAVA弄的。.NET原生不支持。为啥，我也不清楚，大概是因为安全性问题吧，毕竟公钥是人人都可是持有的。私钥只有自己拥有。 对接注意事项：http://blog.csdn.net/gzy11/article/details/54573973 一般方法请看：http://blog.csdn.net/gzy11/article/details/54573973 签名一直都是【私钥加签、公钥验签】只为证明该消息是你发出来的。 这里使用了BouncyCastle1.8.1.0 nuget包。 所有加签、加密返回结果都是base64的，注意格式换。如下： byte[] dataBytes = Convert.FromBase64String(data); string base64Str = Convert.ToBase64String(signer.GenerateSignature()); RSAHelper类 基于BouncyCastle部分 #region 私钥加密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA私钥加密 /// &lt;/summary&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string EncryptPrivateKeyJava(string privateKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); byte[] cipherbytes = Encoding.GetEncoding(encoding).GetBytes(data); RsaEngine rsa = new RsaEngine(); rsa.Init(true, privateKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Convert.ToBase64String(cipherbytes); } #endregion #region 公钥解密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA公钥解密 /// &lt;/summary&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string DecryptPublicKeyJava(string publicKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); byte[] cipherbytes = Convert.FromBase64String(data); RsaEngine rsa = new RsaEngine(); rsa.Init(false, publicKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Encoding.GetEncoding(encoding).GetString(cipherbytes); } #endregion #region 加签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string RSASignJavaBouncyCastle(string data, string privateKeyJava, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(true, privateKeyParam);//参数为true验签，参数为false加签 var dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //return Encoding.GetEncoding(encoding).GetString(signer.GenerateSignature()); //签名结果 非Base64String return Convert.ToBase64String(signer.GenerateSignature()); } #endregion #region 验签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;源数据&lt;/param&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;signature&quot;&gt;base64签名&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool VerifyJavaBouncyCastle(string data, string publicKeyJava, string signature, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(false, publicKeyParam); byte[] dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //byte[] signatureByte = Encoding.GetEncoding(encoding).GetBytes(signature);// 非Base64String byte[] signatureByte = Convert.FromBase64String(signature); return signer.VerifySignature(signatureByte); } #endregion PEM格式秘钥，自己改了下源代码，能直接加载PEM的string格式的RSA。不用读取文件。改的有些不太合理，就不发了。单元测试及调用方法 &nbsp;//注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small Algorithms请参见GetAlgorithms()方法。这个都是从BouncyCastle源码里拿出来的。注意.NET对应的格式。 /// &lt;summary&gt; /// BouncyCastle加签/验签 /// &lt;/summary&gt; [TestMethod] public void BouncyCastleSignVerify() { string publicKeyJava = @&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiRpgGZSOYKG36k6f56D0bHHOQZubt344qgRAVrSmw0udQCV8YsN/qpjlVAeT3gpQ1kKf7YvuR3KylXu0/ckvwya7AYsfEGiRahZcH6uElfyLKcR/6PioMvNLDB2mxgfvZXRRqfxOss8Byb6SP1/xSHPwcJQUc/u5wiczEEWKwNyVRTkjKSIKp5iA+bjN9WGdscdBkNYxZTbbKwDJvzyouiniKR5kSa/6LUMmVDlqz1ZgGfj0WK+6He1o/QoR9s7o143+JjNEzLaLkaolyOBWiBaSYYcQzpdlbi4OOvpHVpVrZ00aJDo9Q2/Dui7orKoKRcCqVDizJd80n47Tf6uVEQIDAQAB&quot;; string privateKeyJava = @&quot;MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCJGmAZlI5gobfqTp/noPRscc5Bm5u3fjiqBEBWtKbDS51AJXxiw3+qmOVUB5PeClDWQp/ti+5HcrKVe7T9yS/DJrsBix8QaJFqFlwfq4SV/IspxH/o+Kgy80sMHabGB+9ldFGp/E6yzwHJvpI/X/FIc/BwlBRz+7nCJzMQRYrA3JVFOSMpIgqnmID5uM31YZ2xx0GQ1jFlNtsrAMm/PKi6KeIpHmRJr/otQyZUOWrPVmAZ+PRYr7od7Wj9ChH2zujXjf4mM0TMtouRqiXI4FaIFpJhhxDOl2VuLg46+kdWlWtnTRokOj1Db8O6LuisqgpFwKpUOLMl3zSfjtN/q5URAgMBAAECggEAaLkfzIo/kqoUPEHgPGIiMS9gt5Zvg+JC0AK9Tj1g3+3C6Ht5nkrsGlf9W4kKNmE0y+RKGn12/VYr+KhsYCmrdOoBj7U/fh4RbLI1ne86MAKeHcI9XauJdpmFqnR/reXjw1/s/OV/C2+5Uutg9E2JlKkScDt7v/f4NMgSZgxoZtU0waPYj5ubhJfbvlWAGol6u0TRlklcfpuhlJAtD4WgAEQm0XmGEVkS3/eKO9vywexkM7YGV2IXqQgvdCVuCl0YGpW4v4qvVixC1b5KU+jgvcFUdHnIFfrEhtVw+byfj4sUfRFk9TCj3HwSsQNa0PnhZINKftnKJGQsP1bC43UgwQKBgQDb4wyA6UPlhR4C2jTn3RE3C87Pl6h8oYAgHzRBLvuDJctKZ3sB4AW+AJhd5Wgdhl6sr0TKPUP+UQicQhD2W8DEPT8Obo3FnCASxBIdJqyDXFL9fQ/g6WrTJ1Dojx1uAPfxWJQJsf6Fev//LbJxukQ1N2pFk/FZljYNtbWkZZqo6QKBgQCfnsBVlW27/ZL98MmlXLnIeDPqj2QtE2jAfyAP0GfaCq94QEyWYavPG9W+jPf114yebwYe4T9MUgVzLZKRFwHBKyBjKz2GgjQgC4s3v18XP/v3lS68E0mYfgiSIJ3X6CMf//RR00XX4fdBmvFxPjv85upgV5WK299gkiDkDvFx6QKBgFwBTtQJxq0c3AfZgdWavH9J44kdLhSoBtJp/BViMT8Y600Aq4mHUR/FY/u157Ci7q5Wz/PHWtHo2i93vV032xrBfcbuH0gWIZ14iRPFgN2eHeOPFrvHLzmW89W7PFcw9I35wEemQJdddgwx9L59b9jMjRz74DraDVgDNjPJh8MxAoGARyrczkvFlV/FvfsxrMze+Ia/fwFXxNE2jz0e6m4dH5ZMDe19OD9r/veGIWNw2ue0Bp+xturu8fRQAb577ry3R40W76BD2kkLPI5pD/3/Q7p/eS/Gmoxu79Kht6VbOvyBTK8uG517MnnJaDLRG5CH5oZ+UV47iqHlwoTkrUoMVKECgYB1MUZZfGFG0fP03O1zwUddUq7Z/y1MLA3fs+vDFTeM3WKGYy7C1e8/vPtNmyaD/UYBpS6FxKVBNx4+mItbJzlHE42eNR5qX0GXwWJfyBTs3DCW9NIAiOT+0dXRma2leS8mPsKzidbtnKVj+tFW2+0cPqWRgzTVAgd1Srm86S/92w==&quot;; var algorithms = GetAlgorithms(); string data = &quot;helo world!&quot;; //int bbc = 0; foreach (var item in algorithms.Keys) { if (!item.ToString().Contains(&quot;RSA&quot;)) continue; if (item.ToString() == &quot;SHA-512WITHRSA/PSS&quot;) { //注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small } string signResult = RSAHelper.RSASignJavaBouncyCastle(data, privateKeyJava, item.ToString()); bool result = RSAHelper.VerifyJavaBouncyCastle(data, publicKeyJava, signResult, item.ToString()); if (!result) { int a = 0; int b = 0 / a; } } } private IDictionary GetAlgorithms() { IDictionary algorithms = new Hashtable(); algorithms[&quot;MD2WITHRSA&quot;] = &quot;MD2withRSA&quot;; algorithms[&quot;MD2WITHRSAENCRYPTION&quot;] = &quot;MD2withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD2WithRsaEncryption.Id] = &quot;MD2withRSA&quot;; algorithms[&quot;MD4WITHRSA&quot;] = &quot;MD4withRSA&quot;; algorithms[&quot;MD4WITHRSAENCRYPTION&quot;] = &quot;MD4withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD4WithRsaEncryption.Id] = &quot;MD4withRSA&quot;; algorithms[&quot;MD5WITHRSA&quot;] = &quot;MD5withRSA&quot;; algorithms[&quot;MD5WITHRSAENCRYPTION&quot;] = &quot;MD5withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD5WithRsaEncryption.Id] = &quot;MD5withRSA&quot;; algorithms[&quot;SHA1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA1WITHRSAENCRYPTION&quot;] = &quot;SHA-1withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha1WithRsaEncryption.Id] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA-1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA224WITHRSAENCRYPTION&quot;] = &quot;SHA-224withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha224WithRsaEncryption.Id] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA-224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA256WITHRSAENCRYPTION&quot;] = &quot;SHA-256withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha256WithRsaEncryption.Id] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA-256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA384WITHRSAENCRYPTION&quot;] = &quot;SHA-384withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha384WithRsaEncryption.Id] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA-384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA512WITHRSAENCRYPTION&quot;] = &quot;SHA-512withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha512WithRsaEncryption.Id] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA-512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;PSSWITHRSA&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSASSA-PSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[PkcsObjectIdentifiers.IdRsassaPss.Id] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSAPSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;SHA1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;RIPEMD128WITHRSA&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD128WITHRSAENCRYPTION&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD128.Id] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSA&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSAENCRYPTION&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD160.Id] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSA&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSAENCRYPTION&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD256.Id] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;NONEWITHRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RSAWITHNONE&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSASSA-PSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSAWITHNONE&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;RAWDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA-1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[X9ObjectIdentifiers.IdDsaWithSha1.Id] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA-224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha224.Id] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA-256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha256.Id] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA-384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha384.Id] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;DSAWITHSHA-512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha512.Id] = &quot;SHA-512withDSA&quot;; algorithms[&quot;NONEWITHECDSA&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSAWITHNONE&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha224.Id] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha256.Id] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha384.Id] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha512.Id] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;RIPEMD160/ECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;ECDSAWITHRIPEMD160&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;RIPEMD160WITHECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithRipeMD160.Id] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;GOST-3410&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST-3410-94&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST3411WITHGOST3410&quot;] = &quot;GOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x94.Id] = &quot;GOST3410&quot;; algorithms[&quot;ECGOST-3410&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;ECGOST-3410-2001&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;GOST3411WITHECGOST3410&quot;] = &quot;ECGOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x2001.Id] = &quot;ECGOST3410&quot;; return algorithms; } 源码下载地址： http://download.csdn.net/detail/gzy11/9766593 CSDN下载不靠谱，不要积分的现在下的人多了积分要那么多，谁没事老去整积分啊。要源码的可以直接留言，留下邮箱。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/gzy11/article/details/58609719 RSA变态模式：【私钥加密，公钥解密】 一般这种写法都是JAVA弄的。.NET原生不支持。为啥，我也不清楚，大概是因为安全性问题吧，毕竟公钥是人人都可是持有的。私钥只有自己拥有。 对接注意事项：http://blog.csdn.net/gzy11/article/details/54573973 一般方法请看：http://blog.csdn.net/gzy11/article/details/54573973 签名一直都是【私钥加签、公钥验签】只为证明该消息是你发出来的。 这里使用了BouncyCastle1.8.1.0 nuget包。 所有加签、加密返回结果都是base64的，注意格式换。如下： byte[] dataBytes = Convert.FromBase64String(data); string base64Str = Convert.ToBase64String(signer.GenerateSignature()); RSAHelper类 基于BouncyCastle部分 #region 私钥加密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA私钥加密 /// &lt;/summary&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string EncryptPrivateKeyJava(string privateKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); byte[] cipherbytes = Encoding.GetEncoding(encoding).GetBytes(data); RsaEngine rsa = new RsaEngine(); rsa.Init(true, privateKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Convert.ToBase64String(cipherbytes); } #endregion #region 公钥解密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA公钥解密 /// &lt;/summary&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string DecryptPublicKeyJava(string publicKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); byte[] cipherbytes = Convert.FromBase64String(data); RsaEngine rsa = new RsaEngine(); rsa.Init(false, publicKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Encoding.GetEncoding(encoding).GetString(cipherbytes); } #endregion #region 加签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string RSASignJavaBouncyCastle(string data, string privateKeyJava, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(true, privateKeyParam);//参数为true验签，参数为false加签 var dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //return Encoding.GetEncoding(encoding).GetString(signer.GenerateSignature()); //签名结果 非Base64String return Convert.ToBase64String(signer.GenerateSignature()); } #endregion #region 验签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;源数据&lt;/param&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;signature&quot;&gt;base64签名&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool VerifyJavaBouncyCastle(string data, string publicKeyJava, string signature, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(false, publicKeyParam); byte[] dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //byte[] signatureByte = Encoding.GetEncoding(encoding).GetBytes(signature);// 非Base64String byte[] signatureByte = Convert.FromBase64String(signature); return signer.VerifySignature(signatureByte); } #endregion PEM格式秘钥，自己改了下源代码，能直接加载PEM的string格式的RSA。不用读取文件。改的有些不太合理，就不发了。单元测试及调用方法 &nbsp;//注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small Algorithms请参见GetAlgorithms()方法。这个都是从BouncyCastle源码里拿出来的。注意.NET对应的格式。 /// &lt;summary&gt; /// BouncyCastle加签/验签 /// &lt;/summary&gt; [TestMethod] public void BouncyCastleSignVerify() { string publicKeyJava = @&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiRpgGZSOYKG36k6f56D0bHHOQZubt344qgRAVrSmw0udQCV8YsN/qpjlVAeT3gpQ1kKf7YvuR3KylXu0/ckvwya7AYsfEGiRahZcH6uElfyLKcR/6PioMvNLDB2mxgfvZXRRqfxOss8Byb6SP1/xSHPwcJQUc/u5wiczEEWKwNyVRTkjKSIKp5iA+bjN9WGdscdBkNYxZTbbKwDJvzyouiniKR5kSa/6LUMmVDlqz1ZgGfj0WK+6He1o/QoR9s7o143+JjNEzLaLkaolyOBWiBaSYYcQzpdlbi4OOvpHVpVrZ00aJDo9Q2/Dui7orKoKRcCqVDizJd80n47Tf6uVEQIDAQAB&quot;; string privateKeyJava = @&quot;MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCJGmAZlI5gobfqTp/noPRscc5Bm5u3fjiqBEBWtKbDS51AJXxiw3+qmOVUB5PeClDWQp/ti+5HcrKVe7T9yS/DJrsBix8QaJFqFlwfq4SV/IspxH/o+Kgy80sMHabGB+9ldFGp/E6yzwHJvpI/X/FIc/BwlBRz+7nCJzMQRYrA3JVFOSMpIgqnmID5uM31YZ2xx0GQ1jFlNtsrAMm/PKi6KeIpHmRJr/otQyZUOWrPVmAZ+PRYr7od7Wj9ChH2zujXjf4mM0TMtouRqiXI4FaIFpJhhxDOl2VuLg46+kdWlWtnTRokOj1Db8O6LuisqgpFwKpUOLMl3zSfjtN/q5URAgMBAAECggEAaLkfzIo/kqoUPEHgPGIiMS9gt5Zvg+JC0AK9Tj1g3+3C6Ht5nkrsGlf9W4kKNmE0y+RKGn12/VYr+KhsYCmrdOoBj7U/fh4RbLI1ne86MAKeHcI9XauJdpmFqnR/reXjw1/s/OV/C2+5Uutg9E2JlKkScDt7v/f4NMgSZgxoZtU0waPYj5ubhJfbvlWAGol6u0TRlklcfpuhlJAtD4WgAEQm0XmGEVkS3/eKO9vywexkM7YGV2IXqQgvdCVuCl0YGpW4v4qvVixC1b5KU+jgvcFUdHnIFfrEhtVw+byfj4sUfRFk9TCj3HwSsQNa0PnhZINKftnKJGQsP1bC43UgwQKBgQDb4wyA6UPlhR4C2jTn3RE3C87Pl6h8oYAgHzRBLvuDJctKZ3sB4AW+AJhd5Wgdhl6sr0TKPUP+UQicQhD2W8DEPT8Obo3FnCASxBIdJqyDXFL9fQ/g6WrTJ1Dojx1uAPfxWJQJsf6Fev//LbJxukQ1N2pFk/FZljYNtbWkZZqo6QKBgQCfnsBVlW27/ZL98MmlXLnIeDPqj2QtE2jAfyAP0GfaCq94QEyWYavPG9W+jPf114yebwYe4T9MUgVzLZKRFwHBKyBjKz2GgjQgC4s3v18XP/v3lS68E0mYfgiSIJ3X6CMf//RR00XX4fdBmvFxPjv85upgV5WK299gkiDkDvFx6QKBgFwBTtQJxq0c3AfZgdWavH9J44kdLhSoBtJp/BViMT8Y600Aq4mHUR/FY/u157Ci7q5Wz/PHWtHo2i93vV032xrBfcbuH0gWIZ14iRPFgN2eHeOPFrvHLzmW89W7PFcw9I35wEemQJdddgwx9L59b9jMjRz74DraDVgDNjPJh8MxAoGARyrczkvFlV/FvfsxrMze+Ia/fwFXxNE2jz0e6m4dH5ZMDe19OD9r/veGIWNw2ue0Bp+xturu8fRQAb577ry3R40W76BD2kkLPI5pD/3/Q7p/eS/Gmoxu79Kht6VbOvyBTK8uG517MnnJaDLRG5CH5oZ+UV47iqHlwoTkrUoMVKECgYB1MUZZfGFG0fP03O1zwUddUq7Z/y1MLA3fs+vDFTeM3WKGYy7C1e8/vPtNmyaD/UYBpS6FxKVBNx4+mItbJzlHE42eNR5qX0GXwWJfyBTs3DCW9NIAiOT+0dXRma2leS8mPsKzidbtnKVj+tFW2+0cPqWRgzTVAgd1Srm86S/92w==&quot;; var algorithms = GetAlgorithms(); string data = &quot;helo world!&quot;; //int bbc = 0; foreach (var item in algorithms.Keys) { if (!item.ToString().Contains(&quot;RSA&quot;)) continue; if (item.ToString() == &quot;SHA-512WITHRSA/PSS&quot;) { //注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small } string signResult = RSAHelper.RSASignJavaBouncyCastle(data, privateKeyJava, item.ToString()); bool result = RSAHelper.VerifyJavaBouncyCastle(data, publicKeyJava, signResult, item.ToString()); if (!result) { int a = 0; int b = 0 / a; } } } private IDictionary GetAlgorithms() { IDictionary algorithms = new Hashtable(); algorithms[&quot;MD2WITHRSA&quot;] = &quot;MD2withRSA&quot;; algorithms[&quot;MD2WITHRSAENCRYPTION&quot;] = &quot;MD2withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD2WithRsaEncryption.Id] = &quot;MD2withRSA&quot;; algorithms[&quot;MD4WITHRSA&quot;] = &quot;MD4withRSA&quot;; algorithms[&quot;MD4WITHRSAENCRYPTION&quot;] = &quot;MD4withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD4WithRsaEncryption.Id] = &quot;MD4withRSA&quot;; algorithms[&quot;MD5WITHRSA&quot;] = &quot;MD5withRSA&quot;; algorithms[&quot;MD5WITHRSAENCRYPTION&quot;] = &quot;MD5withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD5WithRsaEncryption.Id] = &quot;MD5withRSA&quot;; algorithms[&quot;SHA1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA1WITHRSAENCRYPTION&quot;] = &quot;SHA-1withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha1WithRsaEncryption.Id] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA-1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA224WITHRSAENCRYPTION&quot;] = &quot;SHA-224withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha224WithRsaEncryption.Id] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA-224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA256WITHRSAENCRYPTION&quot;] = &quot;SHA-256withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha256WithRsaEncryption.Id] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA-256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA384WITHRSAENCRYPTION&quot;] = &quot;SHA-384withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha384WithRsaEncryption.Id] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA-384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA512WITHRSAENCRYPTION&quot;] = &quot;SHA-512withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha512WithRsaEncryption.Id] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA-512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;PSSWITHRSA&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSASSA-PSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[PkcsObjectIdentifiers.IdRsassaPss.Id] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSAPSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;SHA1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;RIPEMD128WITHRSA&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD128WITHRSAENCRYPTION&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD128.Id] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSA&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSAENCRYPTION&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD160.Id] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSA&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSAENCRYPTION&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD256.Id] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;NONEWITHRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RSAWITHNONE&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSASSA-PSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSAWITHNONE&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;RAWDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA-1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[X9ObjectIdentifiers.IdDsaWithSha1.Id] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA-224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha224.Id] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA-256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha256.Id] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA-384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha384.Id] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;DSAWITHSHA-512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha512.Id] = &quot;SHA-512withDSA&quot;; algorithms[&quot;NONEWITHECDSA&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSAWITHNONE&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha224.Id] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha256.Id] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha384.Id] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha512.Id] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;RIPEMD160/ECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;ECDSAWITHRIPEMD160&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;RIPEMD160WITHECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithRipeMD160.Id] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;GOST-3410&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST-3410-94&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST3411WITHGOST3410&quot;] = &quot;GOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x94.Id] = &quot;GOST3410&quot;; algorithms[&quot;ECGOST-3410&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;ECGOST-3410-2001&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;GOST3411WITHECGOST3410&quot;] = &quot;ECGOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x2001.Id] = &quot;ECGOST3410&quot;; return algorithms; } 源码下载地址： http://download.csdn.net/detail/gzy11/9766593 CSDN下载不靠谱，不要积分的现在下的人多了积分要那么多，谁没事老去整积分啊。要源码的可以直接留言，留下邮箱。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/gzy11/article/details/58609719 RSA变态模式：【私钥加密，公钥解密】 一般这种写法都是JAVA弄的。.NET原生不支持。为啥，我也不清楚，大概是因为安全性问题吧，毕竟公钥是人人都可是持有的。私钥只有自己拥有。 对接注意事项：http://blog.csdn.net/gzy11/article/details/54573973 一般方法请看：http://blog.csdn.net/gzy11/article/details/54573973 签名一直都是【私钥加签、公钥验签】只为证明该消息是你发出来的。 这里使用了BouncyCastle1.8.1.0 nuget包。 所有加签、加密返回结果都是base64的，注意格式换。如下： byte[] dataBytes = Convert.FromBase64String(data); string base64Str = Convert.ToBase64String(signer.GenerateSignature()); RSAHelper类 基于BouncyCastle部分 #region 私钥加密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA私钥加密 /// &lt;/summary&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string EncryptPrivateKeyJava(string privateKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); byte[] cipherbytes = Encoding.GetEncoding(encoding).GetBytes(data); RsaEngine rsa = new RsaEngine(); rsa.Init(true, privateKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Convert.ToBase64String(cipherbytes); } #endregion #region 公钥解密 /// &lt;summary&gt; /// 基于BouncyCastle的RSA公钥解密 /// &lt;/summary&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string DecryptPublicKeyJava(string publicKeyJava, string data, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); byte[] cipherbytes = Convert.FromBase64String(data); RsaEngine rsa = new RsaEngine(); rsa.Init(false, publicKeyParam);//参数true表示加密/false表示解密。 cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length); return Encoding.GetEncoding(encoding).GetString(cipherbytes); } #endregion #region 加签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;privateKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string RSASignJavaBouncyCastle(string data, string privateKeyJava, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(true, privateKeyParam);//参数为true验签，参数为false加签 var dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //return Encoding.GetEncoding(encoding).GetString(signer.GenerateSignature()); //签名结果 非Base64String return Convert.ToBase64String(signer.GenerateSignature()); } #endregion #region 验签 /// &lt;summary&gt; /// 基于BouncyCastle的RSA签名 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;源数据&lt;/param&gt; /// &lt;param name=&quot;publicKeyJava&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;signature&quot;&gt;base64签名&lt;/param&gt; /// &lt;param name=&quot;hashAlgorithm&quot;&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt; /// &lt;param name=&quot;encoding&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool VerifyJavaBouncyCastle(string data, string publicKeyJava, string signature, string hashAlgorithm = &quot;MD5withRSA&quot;, string encoding = &quot;UTF-8&quot;) { RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava)); ISigner signer = SignerUtilities.GetSigner(hashAlgorithm); signer.Init(false, publicKeyParam); byte[] dataByte = Encoding.GetEncoding(encoding).GetBytes(data); signer.BlockUpdate(dataByte, 0, dataByte.Length); //byte[] signatureByte = Encoding.GetEncoding(encoding).GetBytes(signature);// 非Base64String byte[] signatureByte = Convert.FromBase64String(signature); return signer.VerifySignature(signatureByte); } #endregion PEM格式秘钥，自己改了下源代码，能直接加载PEM的string格式的RSA。不用读取文件。改的有些不太合理，就不发了。单元测试及调用方法 &nbsp;//注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small Algorithms请参见GetAlgorithms()方法。这个都是从BouncyCastle源码里拿出来的。注意.NET对应的格式。 /// &lt;summary&gt; /// BouncyCastle加签/验签 /// &lt;/summary&gt; [TestMethod] public void BouncyCastleSignVerify() { string publicKeyJava = @&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiRpgGZSOYKG36k6f56D0bHHOQZubt344qgRAVrSmw0udQCV8YsN/qpjlVAeT3gpQ1kKf7YvuR3KylXu0/ckvwya7AYsfEGiRahZcH6uElfyLKcR/6PioMvNLDB2mxgfvZXRRqfxOss8Byb6SP1/xSHPwcJQUc/u5wiczEEWKwNyVRTkjKSIKp5iA+bjN9WGdscdBkNYxZTbbKwDJvzyouiniKR5kSa/6LUMmVDlqz1ZgGfj0WK+6He1o/QoR9s7o143+JjNEzLaLkaolyOBWiBaSYYcQzpdlbi4OOvpHVpVrZ00aJDo9Q2/Dui7orKoKRcCqVDizJd80n47Tf6uVEQIDAQAB&quot;; string privateKeyJava = @&quot;MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCJGmAZlI5gobfqTp/noPRscc5Bm5u3fjiqBEBWtKbDS51AJXxiw3+qmOVUB5PeClDWQp/ti+5HcrKVe7T9yS/DJrsBix8QaJFqFlwfq4SV/IspxH/o+Kgy80sMHabGB+9ldFGp/E6yzwHJvpI/X/FIc/BwlBRz+7nCJzMQRYrA3JVFOSMpIgqnmID5uM31YZ2xx0GQ1jFlNtsrAMm/PKi6KeIpHmRJr/otQyZUOWrPVmAZ+PRYr7od7Wj9ChH2zujXjf4mM0TMtouRqiXI4FaIFpJhhxDOl2VuLg46+kdWlWtnTRokOj1Db8O6LuisqgpFwKpUOLMl3zSfjtN/q5URAgMBAAECggEAaLkfzIo/kqoUPEHgPGIiMS9gt5Zvg+JC0AK9Tj1g3+3C6Ht5nkrsGlf9W4kKNmE0y+RKGn12/VYr+KhsYCmrdOoBj7U/fh4RbLI1ne86MAKeHcI9XauJdpmFqnR/reXjw1/s/OV/C2+5Uutg9E2JlKkScDt7v/f4NMgSZgxoZtU0waPYj5ubhJfbvlWAGol6u0TRlklcfpuhlJAtD4WgAEQm0XmGEVkS3/eKO9vywexkM7YGV2IXqQgvdCVuCl0YGpW4v4qvVixC1b5KU+jgvcFUdHnIFfrEhtVw+byfj4sUfRFk9TCj3HwSsQNa0PnhZINKftnKJGQsP1bC43UgwQKBgQDb4wyA6UPlhR4C2jTn3RE3C87Pl6h8oYAgHzRBLvuDJctKZ3sB4AW+AJhd5Wgdhl6sr0TKPUP+UQicQhD2W8DEPT8Obo3FnCASxBIdJqyDXFL9fQ/g6WrTJ1Dojx1uAPfxWJQJsf6Fev//LbJxukQ1N2pFk/FZljYNtbWkZZqo6QKBgQCfnsBVlW27/ZL98MmlXLnIeDPqj2QtE2jAfyAP0GfaCq94QEyWYavPG9W+jPf114yebwYe4T9MUgVzLZKRFwHBKyBjKz2GgjQgC4s3v18XP/v3lS68E0mYfgiSIJ3X6CMf//RR00XX4fdBmvFxPjv85upgV5WK299gkiDkDvFx6QKBgFwBTtQJxq0c3AfZgdWavH9J44kdLhSoBtJp/BViMT8Y600Aq4mHUR/FY/u157Ci7q5Wz/PHWtHo2i93vV032xrBfcbuH0gWIZ14iRPFgN2eHeOPFrvHLzmW89W7PFcw9I35wEemQJdddgwx9L59b9jMjRz74DraDVgDNjPJh8MxAoGARyrczkvFlV/FvfsxrMze+Ia/fwFXxNE2jz0e6m4dH5ZMDe19OD9r/veGIWNw2ue0Bp+xturu8fRQAb577ry3R40W76BD2kkLPI5pD/3/Q7p/eS/Gmoxu79Kht6VbOvyBTK8uG517MnnJaDLRG5CH5oZ+UV47iqHlwoTkrUoMVKECgYB1MUZZfGFG0fP03O1zwUddUq7Z/y1MLA3fs+vDFTeM3WKGYy7C1e8/vPtNmyaD/UYBpS6FxKVBNx4+mItbJzlHE42eNR5qX0GXwWJfyBTs3DCW9NIAiOT+0dXRma2leS8mPsKzidbtnKVj+tFW2+0cPqWRgzTVAgd1Srm86S/92w==&quot;; var algorithms = GetAlgorithms(); string data = &quot;helo world!&quot;; //int bbc = 0; foreach (var item in algorithms.Keys) { if (!item.ToString().Contains(&quot;RSA&quot;)) continue; if (item.ToString() == &quot;SHA-512WITHRSA/PSS&quot;) { //注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small } string signResult = RSAHelper.RSASignJavaBouncyCastle(data, privateKeyJava, item.ToString()); bool result = RSAHelper.VerifyJavaBouncyCastle(data, publicKeyJava, signResult, item.ToString()); if (!result) { int a = 0; int b = 0 / a; } } } private IDictionary GetAlgorithms() { IDictionary algorithms = new Hashtable(); algorithms[&quot;MD2WITHRSA&quot;] = &quot;MD2withRSA&quot;; algorithms[&quot;MD2WITHRSAENCRYPTION&quot;] = &quot;MD2withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD2WithRsaEncryption.Id] = &quot;MD2withRSA&quot;; algorithms[&quot;MD4WITHRSA&quot;] = &quot;MD4withRSA&quot;; algorithms[&quot;MD4WITHRSAENCRYPTION&quot;] = &quot;MD4withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD4WithRsaEncryption.Id] = &quot;MD4withRSA&quot;; algorithms[&quot;MD5WITHRSA&quot;] = &quot;MD5withRSA&quot;; algorithms[&quot;MD5WITHRSAENCRYPTION&quot;] = &quot;MD5withRSA&quot;; algorithms[PkcsObjectIdentifiers.MD5WithRsaEncryption.Id] = &quot;MD5withRSA&quot;; algorithms[&quot;SHA1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA1WITHRSAENCRYPTION&quot;] = &quot;SHA-1withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha1WithRsaEncryption.Id] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA-1WITHRSA&quot;] = &quot;SHA-1withRSA&quot;; algorithms[&quot;SHA224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA224WITHRSAENCRYPTION&quot;] = &quot;SHA-224withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha224WithRsaEncryption.Id] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA-224WITHRSA&quot;] = &quot;SHA-224withRSA&quot;; algorithms[&quot;SHA256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA256WITHRSAENCRYPTION&quot;] = &quot;SHA-256withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha256WithRsaEncryption.Id] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA-256WITHRSA&quot;] = &quot;SHA-256withRSA&quot;; algorithms[&quot;SHA384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA384WITHRSAENCRYPTION&quot;] = &quot;SHA-384withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha384WithRsaEncryption.Id] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA-384WITHRSA&quot;] = &quot;SHA-384withRSA&quot;; algorithms[&quot;SHA512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA512WITHRSAENCRYPTION&quot;] = &quot;SHA-512withRSA&quot;; algorithms[PkcsObjectIdentifiers.Sha512WithRsaEncryption.Id] = &quot;SHA-512withRSA&quot;; algorithms[&quot;SHA-512WITHRSA&quot;] = &quot;SHA-512withRSA&quot;; algorithms[&quot;PSSWITHRSA&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSASSA-PSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[PkcsObjectIdentifiers.IdRsassaPss.Id] = &quot;PSSwithRSA&quot;; algorithms[&quot;RSAPSS&quot;] = &quot;PSSwithRSA&quot;; algorithms[&quot;SHA1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSAANDMGF1&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA-1WITHRSA/PSS&quot;] = &quot;SHA-1withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSAANDMGF1&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA-224WITHRSA/PSS&quot;] = &quot;SHA-224withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSAANDMGF1&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA-256WITHRSA/PSS&quot;] = &quot;SHA-256withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSAANDMGF1&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA-384WITHRSA/PSS&quot;] = &quot;SHA-384withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSAANDMGF1&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;SHA-512WITHRSA/PSS&quot;] = &quot;SHA-512withRSAandMGF1&quot;; algorithms[&quot;RIPEMD128WITHRSA&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD128WITHRSAENCRYPTION&quot;] = &quot;RIPEMD128withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD128.Id] = &quot;RIPEMD128withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSA&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD160WITHRSAENCRYPTION&quot;] = &quot;RIPEMD160withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD160.Id] = &quot;RIPEMD160withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSA&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;RIPEMD256WITHRSAENCRYPTION&quot;] = &quot;RIPEMD256withRSA&quot;; algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD256.Id] = &quot;RIPEMD256withRSA&quot;; algorithms[&quot;NONEWITHRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RSAWITHNONE&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSA&quot;] = &quot;RSA&quot;; algorithms[&quot;RAWRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSAPSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHRSASSA-PSS&quot;] = &quot;RAWRSASSA-PSS&quot;; algorithms[&quot;NONEWITHDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSAWITHNONE&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;RAWDSA&quot;] = &quot;NONEwithDSA&quot;; algorithms[&quot;DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA-1&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1/DSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[&quot;SHA-1WITHDSA&quot;] = &quot;SHA-1withDSA&quot;; algorithms[X9ObjectIdentifiers.IdDsaWithSha1.Id] = &quot;SHA-1withDSA&quot;; algorithms[&quot;DSAWITHSHA224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA-224&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224/DSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[&quot;SHA-224WITHDSA&quot;] = &quot;SHA-224withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha224.Id] = &quot;SHA-224withDSA&quot;; algorithms[&quot;DSAWITHSHA256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA-256&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256/DSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[&quot;SHA-256WITHDSA&quot;] = &quot;SHA-256withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha256.Id] = &quot;SHA-256withDSA&quot;; algorithms[&quot;DSAWITHSHA384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA-384&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384/DSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[&quot;SHA-384WITHDSA&quot;] = &quot;SHA-384withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha384.Id] = &quot;SHA-384withDSA&quot;; algorithms[&quot;DSAWITHSHA512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;DSAWITHSHA-512&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512/DSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[&quot;SHA-512WITHDSA&quot;] = &quot;SHA-512withDSA&quot;; algorithms[NistObjectIdentifiers.DsaWithSha512.Id] = &quot;SHA-512withDSA&quot;; algorithms[&quot;NONEWITHECDSA&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSAWITHNONE&quot;] = &quot;NONEwithECDSA&quot;; algorithms[&quot;ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1/ECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-1&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA-1WITHECDSA&quot;] = &quot;SHA-1withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithSha1.Id] = &quot;SHA-1withECDSA&quot;; algorithms[&quot;SHA224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224/ECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-224&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA-224WITHECDSA&quot;] = &quot;SHA-224withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha224.Id] = &quot;SHA-224withECDSA&quot;; algorithms[&quot;SHA256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256/ECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-256&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA-256WITHECDSA&quot;] = &quot;SHA-256withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha256.Id] = &quot;SHA-256withECDSA&quot;; algorithms[&quot;SHA384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384/ECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-384&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA-384WITHECDSA&quot;] = &quot;SHA-384withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha384.Id] = &quot;SHA-384withECDSA&quot;; algorithms[&quot;SHA512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512/ECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;ECDSAWITHSHA-512&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;SHA-512WITHECDSA&quot;] = &quot;SHA-512withECDSA&quot;; algorithms[X9ObjectIdentifiers.ECDsaWithSha512.Id] = &quot;SHA-512withECDSA&quot;; algorithms[&quot;RIPEMD160/ECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;ECDSAWITHRIPEMD160&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;RIPEMD160WITHECDSA&quot;] = &quot;RIPEMD160withECDSA&quot;; algorithms[TeleTrusTObjectIdentifiers.ECSignWithRipeMD160.Id] = &quot;RIPEMD160withECDSA&quot;; algorithms[&quot;GOST-3410&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST-3410-94&quot;] = &quot;GOST3410&quot;; algorithms[&quot;GOST3411WITHGOST3410&quot;] = &quot;GOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x94.Id] = &quot;GOST3410&quot;; algorithms[&quot;ECGOST-3410&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;ECGOST-3410-2001&quot;] = &quot;ECGOST3410&quot;; algorithms[&quot;GOST3411WITHECGOST3410&quot;] = &quot;ECGOST3410&quot;; algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x2001.Id] = &quot;ECGOST3410&quot;; return algorithms; } 源码下载地址： http://download.csdn.net/detail/gzy11/9766593 CSDN下载不靠谱，不要积分的现在下的人多了积分要那么多，谁没事老去整积分啊。要源码的可以直接留言，留下邮箱。 阅读更多","@type":"BlogPosting","url":"/2017/02/28/2f260bb2fb4db8d4b6ccda446c4555e5.html","headline":"C# RSA加密、解密、加签、验签、支持JAVA格式公钥私钥、PEM格式公钥私钥、.NET格式公钥私钥 -变态模式【支持私钥加密，公钥解密】（二）","dateModified":"2017-02-28T00:00:00+08:00","datePublished":"2017-02-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/02/28/2f260bb2fb4db8d4b6ccda446c4555e5.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>C# RSA加密、解密、加签、验签、支持JAVA格式公钥私钥、PEM格式公钥私钥、.NET格式公钥私钥 -变态模式【支持私钥加密，公钥解密】（二）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/gzy11/article/details/58609719 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css"> 
 <div class="htmledit_views"> 
  <p>RSA变态模式：【私钥加密，公钥解密】</p> 
  <p>一般这种写法都是JAVA弄的。.NET原生不支持。为啥，我也不清楚，大概是因为安全性问题吧，毕竟公钥是人人都可是持有的。私钥只有自己拥有。</p> 
  <p>对接注意事项：<a href="http://blog.csdn.net/gzy11/article/details/54573973" rel="nofollow">http://blog.csdn.net/gzy11/article/details/54573973</a></p> 
  <p>一般方法请看：<a href="http://blog.csdn.net/gzy11/article/details/54573973" rel="nofollow">http://blog.csdn.net/gzy11/article/details/54573973</a></p> 
  <p>签名一直都是【私钥加签、公钥验签】只为证明该消息是你发出来的。</p> 
  <p><br></p> 
  <p>这里使用了<span style="color:#ff0000;">BouncyCastle1.8.1.0</span> nuget包。</p> 
  <p>所有加签、加密返回结果都是base64的，注意格式换。如下：</p> 
  <pre><code class="language-csharp">byte[] dataBytes = Convert.FromBase64String(data);
string base64Str = Convert.ToBase64String(signer.GenerateSignature());</code></pre> 
  <p>RSAHelper类</p> 
  <p>基于BouncyCastle部分</p> 
  <pre><code class="language-csharp"></code></pre>
  <pre class="csharp"><code class="language-csharp"> #region 私钥加密
        /// &lt;summary&gt;
        /// 基于BouncyCastle的RSA私钥加密
        /// &lt;/summary&gt;
        /// &lt;param name="privateKeyJava"&gt;&lt;/param&gt;
        /// &lt;param name="data"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string EncryptPrivateKeyJava(string privateKeyJava, string data, string encoding = "UTF-8")
        {
            RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava));
            byte[] cipherbytes = Encoding.GetEncoding(encoding).GetBytes(data);
            RsaEngine rsa = new RsaEngine();
            rsa.Init(true, privateKeyParam);//参数true表示加密/false表示解密。
            cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length);
            return Convert.ToBase64String(cipherbytes);
        }
        #endregion

        #region  公钥解密
        /// &lt;summary&gt;
        /// 基于BouncyCastle的RSA公钥解密
        /// &lt;/summary&gt;
        /// &lt;param name="publicKeyJava"&gt;&lt;/param&gt;
        /// &lt;param name="data"&gt;&lt;/param&gt;
        /// &lt;param name="encoding"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string DecryptPublicKeyJava(string publicKeyJava, string data, string encoding = "UTF-8")
        {
            RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava));
            byte[] cipherbytes = Convert.FromBase64String(data);
            RsaEngine rsa = new RsaEngine();
            rsa.Init(false, publicKeyParam);//参数true表示加密/false表示解密。
            cipherbytes = rsa.ProcessBlock(cipherbytes, 0, cipherbytes.Length);
            return Encoding.GetEncoding(encoding).GetString(cipherbytes);
        }
        #endregion
        #region 加签    
        /// &lt;summary&gt;
        /// 基于BouncyCastle的RSA签名
        /// &lt;/summary&gt;
        /// &lt;param name="data"&gt;&lt;/param&gt;
        /// &lt;param name="privateKeyJava"&gt;&lt;/param&gt;
        /// &lt;param name="hashAlgorithm"&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt;
        /// &lt;param name="encoding"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string RSASignJavaBouncyCastle(string data, string privateKeyJava, string hashAlgorithm = "MD5withRSA", string encoding = "UTF-8")
        {
            RsaKeyParameters privateKeyParam = (RsaKeyParameters)PrivateKeyFactory.CreateKey(Convert.FromBase64String(privateKeyJava));
            ISigner signer = SignerUtilities.GetSigner(hashAlgorithm);
            signer.Init(true, privateKeyParam);//参数为true验签，参数为false加签
            var dataByte = Encoding.GetEncoding(encoding).GetBytes(data);
            signer.BlockUpdate(dataByte, 0, dataByte.Length);
            //return Encoding.GetEncoding(encoding).GetString(signer.GenerateSignature()); //签名结果 非Base64String
            return Convert.ToBase64String(signer.GenerateSignature());
        }
        #endregion
        #region 验签
        /// &lt;summary&gt;
        /// 基于BouncyCastle的RSA签名
        /// &lt;/summary&gt;
        /// &lt;param name="data"&gt;源数据&lt;/param&gt;
        /// &lt;param name="publicKeyJava"&gt;&lt;/param&gt;
        /// &lt;param name="signature"&gt;base64签名&lt;/param&gt;
        /// &lt;param name="hashAlgorithm"&gt;JAVA的和.NET的不一样，如：MD5(.NET)等同于MD5withRSA(JAVA)&lt;/param&gt;
        /// &lt;param name="encoding"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool VerifyJavaBouncyCastle(string data, string publicKeyJava, string signature, string hashAlgorithm = "MD5withRSA", string encoding = "UTF-8")
        {
            RsaKeyParameters publicKeyParam = (RsaKeyParameters)PublicKeyFactory.CreateKey(Convert.FromBase64String(publicKeyJava));
            ISigner signer = SignerUtilities.GetSigner(hashAlgorithm);
            signer.Init(false, publicKeyParam);
            byte[] dataByte = Encoding.GetEncoding(encoding).GetBytes(data);           
            signer.BlockUpdate(dataByte, 0, dataByte.Length);
            //byte[] signatureByte = Encoding.GetEncoding(encoding).GetBytes(signature);// 非Base64String
            byte[] signatureByte = Convert.FromBase64String(signature);
            return signer.VerifySignature(signatureByte);
        }
        #endregion</code></pre> 
  <p><br> PEM格式秘钥，自己改了下源代码，能直接加载PEM的string格式的RSA。不用读取文件。改的有些不太合理，就不发了。<br><strong><span style="font-size:14px;">单元测试及调用方法</span></strong></p> 
  <p>&nbsp;//注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small</p> 
  <p>Algorithms请参见GetAlgorithms()方法。这个都是从BouncyCastle源码里拿出来的。注意.NET对应的格式。</p> 
  <pre><code class="language-csharp">     /// &lt;summary&gt;
        /// BouncyCastle加签/验签
        /// &lt;/summary&gt;
        [TestMethod]
        public void BouncyCastleSignVerify()
        {
           string publicKeyJava = @"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiRpgGZSOYKG36k6f56D0bHHOQZubt344qgRAVrSmw0udQCV8YsN/qpjlVAeT3gpQ1kKf7YvuR3KylXu0/ckvwya7AYsfEGiRahZcH6uElfyLKcR/6PioMvNLDB2mxgfvZXRRqfxOss8Byb6SP1/xSHPwcJQUc/u5wiczEEWKwNyVRTkjKSIKp5iA+bjN9WGdscdBkNYxZTbbKwDJvzyouiniKR5kSa/6LUMmVDlqz1ZgGfj0WK+6He1o/QoR9s7o143+JjNEzLaLkaolyOBWiBaSYYcQzpdlbi4OOvpHVpVrZ00aJDo9Q2/Dui7orKoKRcCqVDizJd80n47Tf6uVEQIDAQAB";
           string privateKeyJava = @"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCJGmAZlI5gobfqTp/noPRscc5Bm5u3fjiqBEBWtKbDS51AJXxiw3+qmOVUB5PeClDWQp/ti+5HcrKVe7T9yS/DJrsBix8QaJFqFlwfq4SV/IspxH/o+Kgy80sMHabGB+9ldFGp/E6yzwHJvpI/X/FIc/BwlBRz+7nCJzMQRYrA3JVFOSMpIgqnmID5uM31YZ2xx0GQ1jFlNtsrAMm/PKi6KeIpHmRJr/otQyZUOWrPVmAZ+PRYr7od7Wj9ChH2zujXjf4mM0TMtouRqiXI4FaIFpJhhxDOl2VuLg46+kdWlWtnTRokOj1Db8O6LuisqgpFwKpUOLMl3zSfjtN/q5URAgMBAAECggEAaLkfzIo/kqoUPEHgPGIiMS9gt5Zvg+JC0AK9Tj1g3+3C6Ht5nkrsGlf9W4kKNmE0y+RKGn12/VYr+KhsYCmrdOoBj7U/fh4RbLI1ne86MAKeHcI9XauJdpmFqnR/reXjw1/s/OV/C2+5Uutg9E2JlKkScDt7v/f4NMgSZgxoZtU0waPYj5ubhJfbvlWAGol6u0TRlklcfpuhlJAtD4WgAEQm0XmGEVkS3/eKO9vywexkM7YGV2IXqQgvdCVuCl0YGpW4v4qvVixC1b5KU+jgvcFUdHnIFfrEhtVw+byfj4sUfRFk9TCj3HwSsQNa0PnhZINKftnKJGQsP1bC43UgwQKBgQDb4wyA6UPlhR4C2jTn3RE3C87Pl6h8oYAgHzRBLvuDJctKZ3sB4AW+AJhd5Wgdhl6sr0TKPUP+UQicQhD2W8DEPT8Obo3FnCASxBIdJqyDXFL9fQ/g6WrTJ1Dojx1uAPfxWJQJsf6Fev//LbJxukQ1N2pFk/FZljYNtbWkZZqo6QKBgQCfnsBVlW27/ZL98MmlXLnIeDPqj2QtE2jAfyAP0GfaCq94QEyWYavPG9W+jPf114yebwYe4T9MUgVzLZKRFwHBKyBjKz2GgjQgC4s3v18XP/v3lS68E0mYfgiSIJ3X6CMf//RR00XX4fdBmvFxPjv85upgV5WK299gkiDkDvFx6QKBgFwBTtQJxq0c3AfZgdWavH9J44kdLhSoBtJp/BViMT8Y600Aq4mHUR/FY/u157Ci7q5Wz/PHWtHo2i93vV032xrBfcbuH0gWIZ14iRPFgN2eHeOPFrvHLzmW89W7PFcw9I35wEemQJdddgwx9L59b9jMjRz74DraDVgDNjPJh8MxAoGARyrczkvFlV/FvfsxrMze+Ia/fwFXxNE2jz0e6m4dH5ZMDe19OD9r/veGIWNw2ue0Bp+xturu8fRQAb577ry3R40W76BD2kkLPI5pD/3/Q7p/eS/Gmoxu79Kht6VbOvyBTK8uG517MnnJaDLRG5CH5oZ+UV47iqHlwoTkrUoMVKECgYB1MUZZfGFG0fP03O1zwUddUq7Z/y1MLA3fs+vDFTeM3WKGYy7C1e8/vPtNmyaD/UYBpS6FxKVBNx4+mItbJzlHE42eNR5qX0GXwWJfyBTs3DCW9NIAiOT+0dXRma2leS8mPsKzidbtnKVj+tFW2+0cPqWRgzTVAgd1Srm86S/92w==";

            var algorithms = GetAlgorithms();
            string data = "helo world!";
            //int bbc = 0;
            foreach (var item in algorithms.Keys)
            {
                if (!item.ToString().Contains("RSA"))
                    continue;
                if (item.ToString() == "SHA-512WITHRSA/PSS")
                {
                    //注意SHA-512WITHRSA/PSS 对应的公私钥大小，不满足需求会报错的 key is too small
                }
                string signResult = RSAHelper.RSASignJavaBouncyCastle(data, privateKeyJava, item.ToString());
                bool result = RSAHelper.VerifyJavaBouncyCastle(data, publicKeyJava, signResult, item.ToString());
                if (!result)
                {
                    int a = 0;
                    int b = 0 / a;
                }
            }
        }
        private IDictionary GetAlgorithms()
        {
            IDictionary algorithms = new Hashtable();
            algorithms["MD2WITHRSA"] = "MD2withRSA";
            algorithms["MD2WITHRSAENCRYPTION"] = "MD2withRSA";
            algorithms[PkcsObjectIdentifiers.MD2WithRsaEncryption.Id] = "MD2withRSA";

            algorithms["MD4WITHRSA"] = "MD4withRSA";
            algorithms["MD4WITHRSAENCRYPTION"] = "MD4withRSA";
            algorithms[PkcsObjectIdentifiers.MD4WithRsaEncryption.Id] = "MD4withRSA";

            algorithms["MD5WITHRSA"] = "MD5withRSA";
            algorithms["MD5WITHRSAENCRYPTION"] = "MD5withRSA";
            algorithms[PkcsObjectIdentifiers.MD5WithRsaEncryption.Id] = "MD5withRSA";

            algorithms["SHA1WITHRSA"] = "SHA-1withRSA";
            algorithms["SHA1WITHRSAENCRYPTION"] = "SHA-1withRSA";
            algorithms[PkcsObjectIdentifiers.Sha1WithRsaEncryption.Id] = "SHA-1withRSA";
            algorithms["SHA-1WITHRSA"] = "SHA-1withRSA";

            algorithms["SHA224WITHRSA"] = "SHA-224withRSA";
            algorithms["SHA224WITHRSAENCRYPTION"] = "SHA-224withRSA";
            algorithms[PkcsObjectIdentifiers.Sha224WithRsaEncryption.Id] = "SHA-224withRSA";
            algorithms["SHA-224WITHRSA"] = "SHA-224withRSA";

            algorithms["SHA256WITHRSA"] = "SHA-256withRSA";
            algorithms["SHA256WITHRSAENCRYPTION"] = "SHA-256withRSA";
            algorithms[PkcsObjectIdentifiers.Sha256WithRsaEncryption.Id] = "SHA-256withRSA";
            algorithms["SHA-256WITHRSA"] = "SHA-256withRSA";

            algorithms["SHA384WITHRSA"] = "SHA-384withRSA";
            algorithms["SHA384WITHRSAENCRYPTION"] = "SHA-384withRSA";
            algorithms[PkcsObjectIdentifiers.Sha384WithRsaEncryption.Id] = "SHA-384withRSA";
            algorithms["SHA-384WITHRSA"] = "SHA-384withRSA";

            algorithms["SHA512WITHRSA"] = "SHA-512withRSA";
            algorithms["SHA512WITHRSAENCRYPTION"] = "SHA-512withRSA";
            algorithms[PkcsObjectIdentifiers.Sha512WithRsaEncryption.Id] = "SHA-512withRSA";
            algorithms["SHA-512WITHRSA"] = "SHA-512withRSA";

            algorithms["PSSWITHRSA"] = "PSSwithRSA";
            algorithms["RSASSA-PSS"] = "PSSwithRSA";
            algorithms[PkcsObjectIdentifiers.IdRsassaPss.Id] = "PSSwithRSA";
            algorithms["RSAPSS"] = "PSSwithRSA";

            algorithms["SHA1WITHRSAANDMGF1"] = "SHA-1withRSAandMGF1";
            algorithms["SHA-1WITHRSAANDMGF1"] = "SHA-1withRSAandMGF1";
            algorithms["SHA1WITHRSA/PSS"] = "SHA-1withRSAandMGF1";
            algorithms["SHA-1WITHRSA/PSS"] = "SHA-1withRSAandMGF1";

            algorithms["SHA224WITHRSAANDMGF1"] = "SHA-224withRSAandMGF1";
            algorithms["SHA-224WITHRSAANDMGF1"] = "SHA-224withRSAandMGF1";
            algorithms["SHA224WITHRSA/PSS"] = "SHA-224withRSAandMGF1";
            algorithms["SHA-224WITHRSA/PSS"] = "SHA-224withRSAandMGF1";

            algorithms["SHA256WITHRSAANDMGF1"] = "SHA-256withRSAandMGF1";
            algorithms["SHA-256WITHRSAANDMGF1"] = "SHA-256withRSAandMGF1";
            algorithms["SHA256WITHRSA/PSS"] = "SHA-256withRSAandMGF1";
            algorithms["SHA-256WITHRSA/PSS"] = "SHA-256withRSAandMGF1";

            algorithms["SHA384WITHRSAANDMGF1"] = "SHA-384withRSAandMGF1";
            algorithms["SHA-384WITHRSAANDMGF1"] = "SHA-384withRSAandMGF1";
            algorithms["SHA384WITHRSA/PSS"] = "SHA-384withRSAandMGF1";
            algorithms["SHA-384WITHRSA/PSS"] = "SHA-384withRSAandMGF1";

            algorithms["SHA512WITHRSAANDMGF1"] = "SHA-512withRSAandMGF1";
            algorithms["SHA-512WITHRSAANDMGF1"] = "SHA-512withRSAandMGF1";
            algorithms["SHA512WITHRSA/PSS"] = "SHA-512withRSAandMGF1";
            algorithms["SHA-512WITHRSA/PSS"] = "SHA-512withRSAandMGF1";

            algorithms["RIPEMD128WITHRSA"] = "RIPEMD128withRSA";
            algorithms["RIPEMD128WITHRSAENCRYPTION"] = "RIPEMD128withRSA";
            algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD128.Id] = "RIPEMD128withRSA";

            algorithms["RIPEMD160WITHRSA"] = "RIPEMD160withRSA";
            algorithms["RIPEMD160WITHRSAENCRYPTION"] = "RIPEMD160withRSA";
            algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD160.Id] = "RIPEMD160withRSA";

            algorithms["RIPEMD256WITHRSA"] = "RIPEMD256withRSA";
            algorithms["RIPEMD256WITHRSAENCRYPTION"] = "RIPEMD256withRSA";
            algorithms[TeleTrusTObjectIdentifiers.RsaSignatureWithRipeMD256.Id] = "RIPEMD256withRSA";

            algorithms["NONEWITHRSA"] = "RSA";
            algorithms["RSAWITHNONE"] = "RSA";
            algorithms["RAWRSA"] = "RSA";

            algorithms["RAWRSAPSS"] = "RAWRSASSA-PSS";
            algorithms["NONEWITHRSAPSS"] = "RAWRSASSA-PSS";
            algorithms["NONEWITHRSASSA-PSS"] = "RAWRSASSA-PSS";

            algorithms["NONEWITHDSA"] = "NONEwithDSA";
            algorithms["DSAWITHNONE"] = "NONEwithDSA";
            algorithms["RAWDSA"] = "NONEwithDSA";

            algorithms["DSA"] = "SHA-1withDSA";
            algorithms["DSAWITHSHA1"] = "SHA-1withDSA";
            algorithms["DSAWITHSHA-1"] = "SHA-1withDSA";
            algorithms["SHA/DSA"] = "SHA-1withDSA";
            algorithms["SHA1/DSA"] = "SHA-1withDSA";
            algorithms["SHA-1/DSA"] = "SHA-1withDSA";
            algorithms["SHA1WITHDSA"] = "SHA-1withDSA";
            algorithms["SHA-1WITHDSA"] = "SHA-1withDSA";
            algorithms[X9ObjectIdentifiers.IdDsaWithSha1.Id] = "SHA-1withDSA";

            algorithms["DSAWITHSHA224"] = "SHA-224withDSA";
            algorithms["DSAWITHSHA-224"] = "SHA-224withDSA";
            algorithms["SHA224/DSA"] = "SHA-224withDSA";
            algorithms["SHA-224/DSA"] = "SHA-224withDSA";
            algorithms["SHA224WITHDSA"] = "SHA-224withDSA";
            algorithms["SHA-224WITHDSA"] = "SHA-224withDSA";
            algorithms[NistObjectIdentifiers.DsaWithSha224.Id] = "SHA-224withDSA";

            algorithms["DSAWITHSHA256"] = "SHA-256withDSA";
            algorithms["DSAWITHSHA-256"] = "SHA-256withDSA";
            algorithms["SHA256/DSA"] = "SHA-256withDSA";
            algorithms["SHA-256/DSA"] = "SHA-256withDSA";
            algorithms["SHA256WITHDSA"] = "SHA-256withDSA";
            algorithms["SHA-256WITHDSA"] = "SHA-256withDSA";
            algorithms[NistObjectIdentifiers.DsaWithSha256.Id] = "SHA-256withDSA";

            algorithms["DSAWITHSHA384"] = "SHA-384withDSA";
            algorithms["DSAWITHSHA-384"] = "SHA-384withDSA";
            algorithms["SHA384/DSA"] = "SHA-384withDSA";
            algorithms["SHA-384/DSA"] = "SHA-384withDSA";
            algorithms["SHA384WITHDSA"] = "SHA-384withDSA";
            algorithms["SHA-384WITHDSA"] = "SHA-384withDSA";
            algorithms[NistObjectIdentifiers.DsaWithSha384.Id] = "SHA-384withDSA";

            algorithms["DSAWITHSHA512"] = "SHA-512withDSA";
            algorithms["DSAWITHSHA-512"] = "SHA-512withDSA";
            algorithms["SHA512/DSA"] = "SHA-512withDSA";
            algorithms["SHA-512/DSA"] = "SHA-512withDSA";
            algorithms["SHA512WITHDSA"] = "SHA-512withDSA";
            algorithms["SHA-512WITHDSA"] = "SHA-512withDSA";
            algorithms[NistObjectIdentifiers.DsaWithSha512.Id] = "SHA-512withDSA";

            algorithms["NONEWITHECDSA"] = "NONEwithECDSA";
            algorithms["ECDSAWITHNONE"] = "NONEwithECDSA";

            algorithms["ECDSA"] = "SHA-1withECDSA";
            algorithms["SHA1/ECDSA"] = "SHA-1withECDSA";
            algorithms["SHA-1/ECDSA"] = "SHA-1withECDSA";
            algorithms["ECDSAWITHSHA1"] = "SHA-1withECDSA";
            algorithms["ECDSAWITHSHA-1"] = "SHA-1withECDSA";
            algorithms["SHA1WITHECDSA"] = "SHA-1withECDSA";
            algorithms["SHA-1WITHECDSA"] = "SHA-1withECDSA";
            algorithms[X9ObjectIdentifiers.ECDsaWithSha1.Id] = "SHA-1withECDSA";
            algorithms[TeleTrusTObjectIdentifiers.ECSignWithSha1.Id] = "SHA-1withECDSA";

            algorithms["SHA224/ECDSA"] = "SHA-224withECDSA";
            algorithms["SHA-224/ECDSA"] = "SHA-224withECDSA";
            algorithms["ECDSAWITHSHA224"] = "SHA-224withECDSA";
            algorithms["ECDSAWITHSHA-224"] = "SHA-224withECDSA";
            algorithms["SHA224WITHECDSA"] = "SHA-224withECDSA";
            algorithms["SHA-224WITHECDSA"] = "SHA-224withECDSA";
            algorithms[X9ObjectIdentifiers.ECDsaWithSha224.Id] = "SHA-224withECDSA";

            algorithms["SHA256/ECDSA"] = "SHA-256withECDSA";
            algorithms["SHA-256/ECDSA"] = "SHA-256withECDSA";
            algorithms["ECDSAWITHSHA256"] = "SHA-256withECDSA";
            algorithms["ECDSAWITHSHA-256"] = "SHA-256withECDSA";
            algorithms["SHA256WITHECDSA"] = "SHA-256withECDSA";
            algorithms["SHA-256WITHECDSA"] = "SHA-256withECDSA";
            algorithms[X9ObjectIdentifiers.ECDsaWithSha256.Id] = "SHA-256withECDSA";

            algorithms["SHA384/ECDSA"] = "SHA-384withECDSA";
            algorithms["SHA-384/ECDSA"] = "SHA-384withECDSA";
            algorithms["ECDSAWITHSHA384"] = "SHA-384withECDSA";
            algorithms["ECDSAWITHSHA-384"] = "SHA-384withECDSA";
            algorithms["SHA384WITHECDSA"] = "SHA-384withECDSA";
            algorithms["SHA-384WITHECDSA"] = "SHA-384withECDSA";
            algorithms[X9ObjectIdentifiers.ECDsaWithSha384.Id] = "SHA-384withECDSA";

            algorithms["SHA512/ECDSA"] = "SHA-512withECDSA";
            algorithms["SHA-512/ECDSA"] = "SHA-512withECDSA";
            algorithms["ECDSAWITHSHA512"] = "SHA-512withECDSA";
            algorithms["ECDSAWITHSHA-512"] = "SHA-512withECDSA";
            algorithms["SHA512WITHECDSA"] = "SHA-512withECDSA";
            algorithms["SHA-512WITHECDSA"] = "SHA-512withECDSA";
            algorithms[X9ObjectIdentifiers.ECDsaWithSha512.Id] = "SHA-512withECDSA";

            algorithms["RIPEMD160/ECDSA"] = "RIPEMD160withECDSA";
            algorithms["ECDSAWITHRIPEMD160"] = "RIPEMD160withECDSA";
            algorithms["RIPEMD160WITHECDSA"] = "RIPEMD160withECDSA";
            algorithms[TeleTrusTObjectIdentifiers.ECSignWithRipeMD160.Id] = "RIPEMD160withECDSA";

            algorithms["GOST-3410"] = "GOST3410";
            algorithms["GOST-3410-94"] = "GOST3410";
            algorithms["GOST3411WITHGOST3410"] = "GOST3410";
            algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x94.Id] = "GOST3410";

            algorithms["ECGOST-3410"] = "ECGOST3410";
            algorithms["ECGOST-3410-2001"] = "ECGOST3410";
            algorithms["GOST3411WITHECGOST3410"] = "ECGOST3410";
            algorithms[CryptoProObjectIdentifiers.GostR3411x94WithGostR3410x2001.Id] = "ECGOST3410";
            return algorithms;
        }</code></pre> 
  <div>
   <br>
  </div> 
  <div>
   源码下载地址：
   <a href="http://download.csdn.net/detail/gzy11/9766593" rel="nofollow">http://download.csdn.net/detail/gzy11/9766593</a>
  </div> 
  <div>
   CSDN下载不靠谱，不要积分的现在下的人多了积分要那么多，谁没事老去整积分啊。要源码的可以直接留言，留下邮箱。
  </div> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gzy11/article/details/58609719,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gzy11/article/details/58609719,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
