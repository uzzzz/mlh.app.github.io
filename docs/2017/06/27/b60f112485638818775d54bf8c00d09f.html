<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于fabric 0.6定制智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于fabric 0.6定制智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="fabric部署与管理 1 git地址 2 部署 3 使用chaincode fabric源码智能合约源码解析 1 go语言又称golang 2 智能合约例子 3 核心接口 定制智能合约 1 智能合约 2 编译调试 目前fabric 0.6为稳定版本，fabric 1.0为最新版，并持续更新中 IBM中国研究院开发的超能云（SuperVessel）平台提供了给区块链爱好者、开发者的区块链开发测试环境。通过该平台，用户能够免费、超快速创建基于Hyperledger Fabric的多节点区块链、并在自己的链上花式玩转智能合约。 https://my.oschina.net/u/1431433/blog/712869 1 fabric部署与管理 1.1 git地址 https://github.com/hyperledger/fabric 默认是最新版1.0，可以自己切换到v0.6分支 1.2 部署 环境：Ubuntu 16.04 64位 安装Docker，Docker-compose，fabric部署，以pbft模式启动fabric 参考文档：http://www.cnblogs.com/sclczk/p/6552845.html 重启服务 systemctl restart docker.service 启动 4 个 PBFT peer 节点 + 1 个 CA 节点 + 1 个 Blockchain-explorer，并启用 CA 功能。 docker-compose -f 4-peers-with-membersrvc-explorer.yml up 1.3 使用chaincode https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/usage.html 或参考https://bitshuo.com/topic/58870c418d8be16a4ff73081 进入一个节点 docker exec -it pbft_vp0_1 bash 2 fabric源码智能合约源码解析 2.1 go语言（又称golang） go IDE：Gogland http://www.mamicode.com/info-detail-1701831.html 2.2 智能合约例子 相关例子在如下文件夹中 这里列举了如何做一个map和table 2.3 核心接口 在fabric/core/chaincode/shim中的interfaces.go type ChaincodeStubInterface interface { // Get the arguments to the stub call as a 2D byte array GetArgs() [][]byte // Get the arguments to the stub call as a string array GetStringArgs() []string // Get the transaction ID GetTxID() string // InvokeChaincode locally calls the specified chaincode `Invoke` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. InvokeChaincode(chaincodeName string, args [][]byte) ([]byte, error) // QueryChaincode locally calls the specified chaincode `Query` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. QueryChaincode(chaincodeName string, args [][]byte) ([]byte, error) // GetState returns the byte array value specified by the `key`. GetState(key string) ([]byte, error) // PutState writes the specified `value` and `key` into the ledger. PutState(key string, value []byte) error // DelState removes the specified `key` and its value from the ledger. DelState(key string) error // RangeQueryState function can be invoked by a chaincode to query of a range // of keys in the state. Assuming the startKey and endKey are in lexical // an iterator will be returned that can be used to iterate over all keys // between the startKey and endKey, inclusive. The order in which keys are // returned by the iterator is random. RangeQueryState(startKey, endKey string) (StateRangeQueryIteratorInterface, error) // CreateTable creates a new table given the table name and column definitions CreateTable(name string, columnDefinitions []*ColumnDefinition) error // GetTable returns the table for the specified table name or ErrTableNotFound // if the table does not exist. GetTable(tableName string) (*Table, error) // DeleteTable deletes an entire table and all associated rows. DeleteTable(tableName string) error // InsertRow inserts a new row into the specified table. // Returns - // true and no error if the row is successfully inserted. // false and no error if a row already exists for the given key. // false and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. InsertRow(tableName string, row Row) (bool, error) // ReplaceRow updates the row in the specified table. // Returns - // true and no error if the row is successfully updated. // false and no error if a row does not exist the given key. // flase and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. ReplaceRow(tableName string, row Row) (bool, error) // GetRow fetches a row from the specified table for the given key. GetRow(tableName string, key []Column) (Row, error) // GetRows returns multiple rows based on a partial key. For example, given table // | A | B | C | D | // where A, C and D are keys, GetRows can be called with [A, C] to return // all rows that have A, C and any value for D as their key. GetRows could // also be called with A only to return all rows that have A and any value // for C and D as their key. GetRows(tableName string, key []Column) (&lt;-chan Row, error) // DeleteRow deletes the row for the given key from the specified table. DeleteRow(tableName string, key []Column) error // ReadCertAttribute is used to read an specific attribute from the transaction certificate, // *attributeName* is passed as input parameter to this function. // Example: // attrValue,error:=stub.ReadCertAttribute(&quot;position&quot;) ReadCertAttribute(attributeName string) ([]byte, error) // VerifyAttribute is used to verify if the transaction certificate has an attribute // with name *attributeName* and value *attributeValue* which are the input parameters // received by this function. // Example: // containsAttr, error := stub.VerifyAttribute(&quot;position&quot;, &quot;Software Engineer&quot;) VerifyAttribute(attributeName string, attributeValue []byte) (bool, error) // VerifyAttributes does the same as VerifyAttribute but it checks for a list of // attributes and their respective values instead of a single attribute/value pair // Example: // containsAttrs, error:= stub.VerifyAttributes(&amp;attr.Attribute{&quot;position&quot;, &quot;Software Engineer&quot;}, &amp;attr.Attribute{&quot;company&quot;, &quot;ACompany&quot;}) VerifyAttributes(attrs ...*attr.Attribute) (bool, error) // VerifySignature verifies the transaction signature and returns `true` if // correct and `false` otherwise VerifySignature(certificate, signature, message []byte) (bool, error) // GetCallerCertificate returns caller certificate GetCallerCertificate() ([]byte, error) // GetCallerMetadata returns caller metadata GetCallerMetadata() ([]byte, error) // GetBinding returns the transaction binding GetBinding() ([]byte, error) // GetPayload returns transaction payload, which is a `ChaincodeSpec` defined // in fabric/protos/chaincode.proto GetPayload() ([]byte, error) // GetTxTimestamp returns transaction created timestamp, which is currently // taken from the peer receiving the transaction. Note that this timestamp // may not be the same with the other peers&#39; time. GetTxTimestamp() (*timestamp.Timestamp, error) // SetEvent saves the event to be sent when a transaction is made part of a block SetEvent(name string, payload []byte) error } 3 定制智能合约 3.1 智能合约 写的一个例子： package main import ( &quot;errors&quot; &quot;fmt&quot; &quot;encoding/json&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; ) // SimpleChaincode example simple Chaincode implementation type SimpleChaincode struct { } func main() { err := shim.Start(new(SimpleChaincode)) if err != nil { fmt.Printf(&quot;Error starting Simple chaincode: %s&quot;, err) } } type Location struct { Id string Status string locx string locy string } // Init resets all the things func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting 1&quot;) } return nil, nil } // Invoke isur entry point to invoke a chaincode function func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;invoke is running &quot; + function) // Handle different functions if function == &quot;init&quot; { return t.Init(stub, &quot;init&quot;, args) } else if function == &quot;write&quot; { return t.write(stub, args) } fmt.Println(&quot;invoke did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function invocation&quot;) } // Query is our entry point for queries func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;query is running &quot; + function) // Handle different functions if function == &quot;read&quot; { //read a variable return t.read(stub, args) } fmt.Println(&quot;query did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function query&quot;) } // write - invoke function to write key/value pair func (t *SimpleChaincode) write(stub shim.ChaincodeStubInterface, args []string) ([]byte,error) { if len(args) != 4{ return nil, errors.New(&quot;Incorrect number of arguments. Expecting 4&quot;) } var err error location := Location {Id:args[0],Status:args[1]+&quot;,&quot;+args[2]+&quot;,&quot;+args[3],locx:args[2],locy:args[3]} locationlBytes,err:= json.Marshal(&amp;location) str := string(locationlBytes[:]) fmt.Println(str) if err != nil{ fmt.Print(err) } err = stub.PutState(location.Id,locationlBytes) if err !=nil{ return nil,errors.New(&quot;PutState Error&quot; + err.Error()) } return nil,nil } // read - query function to read key/value pair func (t *SimpleChaincode) read(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) { var key, jsonResp string var err error if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting name of the key to query&quot;) } key = args[0] valAsbytes, err := stub.GetState(key) if err != nil { jsonResp = &quot;{\&quot;Error\&quot;:\&quot;Failed to get state for &quot; + key + &quot;\&quot;}&quot; return nil, errors.New(jsonResp) } return valAsbytes, nil } 3.2 编译调试 go build http://blog.csdn.net/h363659487/article/details/72768211 部署自己写的智能合约时，先上传到github，然后进入一个vp节点： docker exec -it pbft_vp0_1 bash， 通过github下载到节点里面。 注意路径中的github.com其实就是一个文件名 阅读更多" />
<meta property="og:description" content="fabric部署与管理 1 git地址 2 部署 3 使用chaincode fabric源码智能合约源码解析 1 go语言又称golang 2 智能合约例子 3 核心接口 定制智能合约 1 智能合约 2 编译调试 目前fabric 0.6为稳定版本，fabric 1.0为最新版，并持续更新中 IBM中国研究院开发的超能云（SuperVessel）平台提供了给区块链爱好者、开发者的区块链开发测试环境。通过该平台，用户能够免费、超快速创建基于Hyperledger Fabric的多节点区块链、并在自己的链上花式玩转智能合约。 https://my.oschina.net/u/1431433/blog/712869 1 fabric部署与管理 1.1 git地址 https://github.com/hyperledger/fabric 默认是最新版1.0，可以自己切换到v0.6分支 1.2 部署 环境：Ubuntu 16.04 64位 安装Docker，Docker-compose，fabric部署，以pbft模式启动fabric 参考文档：http://www.cnblogs.com/sclczk/p/6552845.html 重启服务 systemctl restart docker.service 启动 4 个 PBFT peer 节点 + 1 个 CA 节点 + 1 个 Blockchain-explorer，并启用 CA 功能。 docker-compose -f 4-peers-with-membersrvc-explorer.yml up 1.3 使用chaincode https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/usage.html 或参考https://bitshuo.com/topic/58870c418d8be16a4ff73081 进入一个节点 docker exec -it pbft_vp0_1 bash 2 fabric源码智能合约源码解析 2.1 go语言（又称golang） go IDE：Gogland http://www.mamicode.com/info-detail-1701831.html 2.2 智能合约例子 相关例子在如下文件夹中 这里列举了如何做一个map和table 2.3 核心接口 在fabric/core/chaincode/shim中的interfaces.go type ChaincodeStubInterface interface { // Get the arguments to the stub call as a 2D byte array GetArgs() [][]byte // Get the arguments to the stub call as a string array GetStringArgs() []string // Get the transaction ID GetTxID() string // InvokeChaincode locally calls the specified chaincode `Invoke` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. InvokeChaincode(chaincodeName string, args [][]byte) ([]byte, error) // QueryChaincode locally calls the specified chaincode `Query` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. QueryChaincode(chaincodeName string, args [][]byte) ([]byte, error) // GetState returns the byte array value specified by the `key`. GetState(key string) ([]byte, error) // PutState writes the specified `value` and `key` into the ledger. PutState(key string, value []byte) error // DelState removes the specified `key` and its value from the ledger. DelState(key string) error // RangeQueryState function can be invoked by a chaincode to query of a range // of keys in the state. Assuming the startKey and endKey are in lexical // an iterator will be returned that can be used to iterate over all keys // between the startKey and endKey, inclusive. The order in which keys are // returned by the iterator is random. RangeQueryState(startKey, endKey string) (StateRangeQueryIteratorInterface, error) // CreateTable creates a new table given the table name and column definitions CreateTable(name string, columnDefinitions []*ColumnDefinition) error // GetTable returns the table for the specified table name or ErrTableNotFound // if the table does not exist. GetTable(tableName string) (*Table, error) // DeleteTable deletes an entire table and all associated rows. DeleteTable(tableName string) error // InsertRow inserts a new row into the specified table. // Returns - // true and no error if the row is successfully inserted. // false and no error if a row already exists for the given key. // false and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. InsertRow(tableName string, row Row) (bool, error) // ReplaceRow updates the row in the specified table. // Returns - // true and no error if the row is successfully updated. // false and no error if a row does not exist the given key. // flase and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. ReplaceRow(tableName string, row Row) (bool, error) // GetRow fetches a row from the specified table for the given key. GetRow(tableName string, key []Column) (Row, error) // GetRows returns multiple rows based on a partial key. For example, given table // | A | B | C | D | // where A, C and D are keys, GetRows can be called with [A, C] to return // all rows that have A, C and any value for D as their key. GetRows could // also be called with A only to return all rows that have A and any value // for C and D as their key. GetRows(tableName string, key []Column) (&lt;-chan Row, error) // DeleteRow deletes the row for the given key from the specified table. DeleteRow(tableName string, key []Column) error // ReadCertAttribute is used to read an specific attribute from the transaction certificate, // *attributeName* is passed as input parameter to this function. // Example: // attrValue,error:=stub.ReadCertAttribute(&quot;position&quot;) ReadCertAttribute(attributeName string) ([]byte, error) // VerifyAttribute is used to verify if the transaction certificate has an attribute // with name *attributeName* and value *attributeValue* which are the input parameters // received by this function. // Example: // containsAttr, error := stub.VerifyAttribute(&quot;position&quot;, &quot;Software Engineer&quot;) VerifyAttribute(attributeName string, attributeValue []byte) (bool, error) // VerifyAttributes does the same as VerifyAttribute but it checks for a list of // attributes and their respective values instead of a single attribute/value pair // Example: // containsAttrs, error:= stub.VerifyAttributes(&amp;attr.Attribute{&quot;position&quot;, &quot;Software Engineer&quot;}, &amp;attr.Attribute{&quot;company&quot;, &quot;ACompany&quot;}) VerifyAttributes(attrs ...*attr.Attribute) (bool, error) // VerifySignature verifies the transaction signature and returns `true` if // correct and `false` otherwise VerifySignature(certificate, signature, message []byte) (bool, error) // GetCallerCertificate returns caller certificate GetCallerCertificate() ([]byte, error) // GetCallerMetadata returns caller metadata GetCallerMetadata() ([]byte, error) // GetBinding returns the transaction binding GetBinding() ([]byte, error) // GetPayload returns transaction payload, which is a `ChaincodeSpec` defined // in fabric/protos/chaincode.proto GetPayload() ([]byte, error) // GetTxTimestamp returns transaction created timestamp, which is currently // taken from the peer receiving the transaction. Note that this timestamp // may not be the same with the other peers&#39; time. GetTxTimestamp() (*timestamp.Timestamp, error) // SetEvent saves the event to be sent when a transaction is made part of a block SetEvent(name string, payload []byte) error } 3 定制智能合约 3.1 智能合约 写的一个例子： package main import ( &quot;errors&quot; &quot;fmt&quot; &quot;encoding/json&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; ) // SimpleChaincode example simple Chaincode implementation type SimpleChaincode struct { } func main() { err := shim.Start(new(SimpleChaincode)) if err != nil { fmt.Printf(&quot;Error starting Simple chaincode: %s&quot;, err) } } type Location struct { Id string Status string locx string locy string } // Init resets all the things func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting 1&quot;) } return nil, nil } // Invoke isur entry point to invoke a chaincode function func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;invoke is running &quot; + function) // Handle different functions if function == &quot;init&quot; { return t.Init(stub, &quot;init&quot;, args) } else if function == &quot;write&quot; { return t.write(stub, args) } fmt.Println(&quot;invoke did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function invocation&quot;) } // Query is our entry point for queries func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;query is running &quot; + function) // Handle different functions if function == &quot;read&quot; { //read a variable return t.read(stub, args) } fmt.Println(&quot;query did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function query&quot;) } // write - invoke function to write key/value pair func (t *SimpleChaincode) write(stub shim.ChaincodeStubInterface, args []string) ([]byte,error) { if len(args) != 4{ return nil, errors.New(&quot;Incorrect number of arguments. Expecting 4&quot;) } var err error location := Location {Id:args[0],Status:args[1]+&quot;,&quot;+args[2]+&quot;,&quot;+args[3],locx:args[2],locy:args[3]} locationlBytes,err:= json.Marshal(&amp;location) str := string(locationlBytes[:]) fmt.Println(str) if err != nil{ fmt.Print(err) } err = stub.PutState(location.Id,locationlBytes) if err !=nil{ return nil,errors.New(&quot;PutState Error&quot; + err.Error()) } return nil,nil } // read - query function to read key/value pair func (t *SimpleChaincode) read(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) { var key, jsonResp string var err error if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting name of the key to query&quot;) } key = args[0] valAsbytes, err := stub.GetState(key) if err != nil { jsonResp = &quot;{\&quot;Error\&quot;:\&quot;Failed to get state for &quot; + key + &quot;\&quot;}&quot; return nil, errors.New(jsonResp) } return valAsbytes, nil } 3.2 编译调试 go build http://blog.csdn.net/h363659487/article/details/72768211 部署自己写的智能合约时，先上传到github，然后进入一个vp节点： docker exec -it pbft_vp0_1 bash， 通过github下载到节点里面。 注意路径中的github.com其实就是一个文件名 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"fabric部署与管理 1 git地址 2 部署 3 使用chaincode fabric源码智能合约源码解析 1 go语言又称golang 2 智能合约例子 3 核心接口 定制智能合约 1 智能合约 2 编译调试 目前fabric 0.6为稳定版本，fabric 1.0为最新版，并持续更新中 IBM中国研究院开发的超能云（SuperVessel）平台提供了给区块链爱好者、开发者的区块链开发测试环境。通过该平台，用户能够免费、超快速创建基于Hyperledger Fabric的多节点区块链、并在自己的链上花式玩转智能合约。 https://my.oschina.net/u/1431433/blog/712869 1 fabric部署与管理 1.1 git地址 https://github.com/hyperledger/fabric 默认是最新版1.0，可以自己切换到v0.6分支 1.2 部署 环境：Ubuntu 16.04 64位 安装Docker，Docker-compose，fabric部署，以pbft模式启动fabric 参考文档：http://www.cnblogs.com/sclczk/p/6552845.html 重启服务 systemctl restart docker.service 启动 4 个 PBFT peer 节点 + 1 个 CA 节点 + 1 个 Blockchain-explorer，并启用 CA 功能。 docker-compose -f 4-peers-with-membersrvc-explorer.yml up 1.3 使用chaincode https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/usage.html 或参考https://bitshuo.com/topic/58870c418d8be16a4ff73081 进入一个节点 docker exec -it pbft_vp0_1 bash 2 fabric源码智能合约源码解析 2.1 go语言（又称golang） go IDE：Gogland http://www.mamicode.com/info-detail-1701831.html 2.2 智能合约例子 相关例子在如下文件夹中 这里列举了如何做一个map和table 2.3 核心接口 在fabric/core/chaincode/shim中的interfaces.go type ChaincodeStubInterface interface { // Get the arguments to the stub call as a 2D byte array GetArgs() [][]byte // Get the arguments to the stub call as a string array GetStringArgs() []string // Get the transaction ID GetTxID() string // InvokeChaincode locally calls the specified chaincode `Invoke` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. InvokeChaincode(chaincodeName string, args [][]byte) ([]byte, error) // QueryChaincode locally calls the specified chaincode `Query` using the // same transaction context; that is, chaincode calling chaincode doesn&#39;t // create a new transaction message. QueryChaincode(chaincodeName string, args [][]byte) ([]byte, error) // GetState returns the byte array value specified by the `key`. GetState(key string) ([]byte, error) // PutState writes the specified `value` and `key` into the ledger. PutState(key string, value []byte) error // DelState removes the specified `key` and its value from the ledger. DelState(key string) error // RangeQueryState function can be invoked by a chaincode to query of a range // of keys in the state. Assuming the startKey and endKey are in lexical // an iterator will be returned that can be used to iterate over all keys // between the startKey and endKey, inclusive. The order in which keys are // returned by the iterator is random. RangeQueryState(startKey, endKey string) (StateRangeQueryIteratorInterface, error) // CreateTable creates a new table given the table name and column definitions CreateTable(name string, columnDefinitions []*ColumnDefinition) error // GetTable returns the table for the specified table name or ErrTableNotFound // if the table does not exist. GetTable(tableName string) (*Table, error) // DeleteTable deletes an entire table and all associated rows. DeleteTable(tableName string) error // InsertRow inserts a new row into the specified table. // Returns - // true and no error if the row is successfully inserted. // false and no error if a row already exists for the given key. // false and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. InsertRow(tableName string, row Row) (bool, error) // ReplaceRow updates the row in the specified table. // Returns - // true and no error if the row is successfully updated. // false and no error if a row does not exist the given key. // flase and a TableNotFoundError if the specified table name does not exist. // false and an error if there is an unexpected error condition. ReplaceRow(tableName string, row Row) (bool, error) // GetRow fetches a row from the specified table for the given key. GetRow(tableName string, key []Column) (Row, error) // GetRows returns multiple rows based on a partial key. For example, given table // | A | B | C | D | // where A, C and D are keys, GetRows can be called with [A, C] to return // all rows that have A, C and any value for D as their key. GetRows could // also be called with A only to return all rows that have A and any value // for C and D as their key. GetRows(tableName string, key []Column) (&lt;-chan Row, error) // DeleteRow deletes the row for the given key from the specified table. DeleteRow(tableName string, key []Column) error // ReadCertAttribute is used to read an specific attribute from the transaction certificate, // *attributeName* is passed as input parameter to this function. // Example: // attrValue,error:=stub.ReadCertAttribute(&quot;position&quot;) ReadCertAttribute(attributeName string) ([]byte, error) // VerifyAttribute is used to verify if the transaction certificate has an attribute // with name *attributeName* and value *attributeValue* which are the input parameters // received by this function. // Example: // containsAttr, error := stub.VerifyAttribute(&quot;position&quot;, &quot;Software Engineer&quot;) VerifyAttribute(attributeName string, attributeValue []byte) (bool, error) // VerifyAttributes does the same as VerifyAttribute but it checks for a list of // attributes and their respective values instead of a single attribute/value pair // Example: // containsAttrs, error:= stub.VerifyAttributes(&amp;attr.Attribute{&quot;position&quot;, &quot;Software Engineer&quot;}, &amp;attr.Attribute{&quot;company&quot;, &quot;ACompany&quot;}) VerifyAttributes(attrs ...*attr.Attribute) (bool, error) // VerifySignature verifies the transaction signature and returns `true` if // correct and `false` otherwise VerifySignature(certificate, signature, message []byte) (bool, error) // GetCallerCertificate returns caller certificate GetCallerCertificate() ([]byte, error) // GetCallerMetadata returns caller metadata GetCallerMetadata() ([]byte, error) // GetBinding returns the transaction binding GetBinding() ([]byte, error) // GetPayload returns transaction payload, which is a `ChaincodeSpec` defined // in fabric/protos/chaincode.proto GetPayload() ([]byte, error) // GetTxTimestamp returns transaction created timestamp, which is currently // taken from the peer receiving the transaction. Note that this timestamp // may not be the same with the other peers&#39; time. GetTxTimestamp() (*timestamp.Timestamp, error) // SetEvent saves the event to be sent when a transaction is made part of a block SetEvent(name string, payload []byte) error } 3 定制智能合约 3.1 智能合约 写的一个例子： package main import ( &quot;errors&quot; &quot;fmt&quot; &quot;encoding/json&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; ) // SimpleChaincode example simple Chaincode implementation type SimpleChaincode struct { } func main() { err := shim.Start(new(SimpleChaincode)) if err != nil { fmt.Printf(&quot;Error starting Simple chaincode: %s&quot;, err) } } type Location struct { Id string Status string locx string locy string } // Init resets all the things func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting 1&quot;) } return nil, nil } // Invoke isur entry point to invoke a chaincode function func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;invoke is running &quot; + function) // Handle different functions if function == &quot;init&quot; { return t.Init(stub, &quot;init&quot;, args) } else if function == &quot;write&quot; { return t.write(stub, args) } fmt.Println(&quot;invoke did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function invocation&quot;) } // Query is our entry point for queries func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { fmt.Println(&quot;query is running &quot; + function) // Handle different functions if function == &quot;read&quot; { //read a variable return t.read(stub, args) } fmt.Println(&quot;query did not find func: &quot; + function) return nil, errors.New(&quot;Received unknown function query&quot;) } // write - invoke function to write key/value pair func (t *SimpleChaincode) write(stub shim.ChaincodeStubInterface, args []string) ([]byte,error) { if len(args) != 4{ return nil, errors.New(&quot;Incorrect number of arguments. Expecting 4&quot;) } var err error location := Location {Id:args[0],Status:args[1]+&quot;,&quot;+args[2]+&quot;,&quot;+args[3],locx:args[2],locy:args[3]} locationlBytes,err:= json.Marshal(&amp;location) str := string(locationlBytes[:]) fmt.Println(str) if err != nil{ fmt.Print(err) } err = stub.PutState(location.Id,locationlBytes) if err !=nil{ return nil,errors.New(&quot;PutState Error&quot; + err.Error()) } return nil,nil } // read - query function to read key/value pair func (t *SimpleChaincode) read(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) { var key, jsonResp string var err error if len(args) != 1 { return nil, errors.New(&quot;Incorrect number of arguments. Expecting name of the key to query&quot;) } key = args[0] valAsbytes, err := stub.GetState(key) if err != nil { jsonResp = &quot;{\\&quot;Error\\&quot;:\\&quot;Failed to get state for &quot; + key + &quot;\\&quot;}&quot; return nil, errors.New(jsonResp) } return valAsbytes, nil } 3.2 编译调试 go build http://blog.csdn.net/h363659487/article/details/72768211 部署自己写的智能合约时，先上传到github，然后进入一个vp节点： docker exec -it pbft_vp0_1 bash， 通过github下载到节点里面。 注意路径中的github.com其实就是一个文件名 阅读更多","@type":"BlogPosting","url":"/2017/06/27/b60f112485638818775d54bf8c00d09f.html","headline":"基于fabric 0.6定制智能合约","dateModified":"2017-06-27T00:00:00+08:00","datePublished":"2017-06-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/06/27/b60f112485638818775d54bf8c00d09f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于fabric 0.6定制智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p></p>
  <div class="toc">
   <div class="toc"> 
    <ul> 
     <li><a href="#1-fabric部署与管理" rel="nofollow">fabric部署与管理</a>
      <ul> 
       <li><a href="#11-git地址" rel="nofollow">1 git地址</a></li> 
       <li><a href="#12-部署" rel="nofollow">2 部署</a></li> 
       <li><a href="#13-使用chaincode" rel="nofollow">3 使用chaincode</a></li> 
      </ul> </li> 
     <li><a href="#2-fabric源码智能合约源码解析" rel="nofollow">fabric源码智能合约源码解析</a>
      <ul> 
       <li><a href="#21-go语言又称golang" rel="nofollow">1 go语言又称golang</a></li> 
       <li><a href="#22-智能合约例子" rel="nofollow">2 智能合约例子</a></li> 
       <li><a href="#23-核心接口" rel="nofollow">3 核心接口</a></li> 
      </ul> </li> 
     <li><a href="#3-定制智能合约" rel="nofollow">定制智能合约</a>
      <ul> 
       <li><a href="#31-智能合约" rel="nofollow">1 智能合约</a></li> 
       <li><a href="#32-编译调试" rel="nofollow">2 编译调试</a></li> 
      </ul> </li> 
    </ul> 
   </div> 
  </div> 
  <p></p> 
  <p>目前fabric 0.6为稳定版本，fabric 1.0为最新版，并持续更新中</p> 
  <p>IBM中国研究院开发的超能云（SuperVessel）平台提供了给区块链爱好者、开发者的区块链开发测试环境。通过该平台，用户能够免费、超快速创建基于Hyperledger Fabric的多节点区块链、并在自己的链上花式玩转智能合约。 <br> <a href="https://my.oschina.net/u/1431433/blog/712869" rel="nofollow" target="_blank">https://my.oschina.net/u/1431433/blog/712869</a></p> 
  <h1 id="1-fabric部署与管理">1 fabric部署与管理</h1> 
  <h2 id="11-git地址">1.1 git地址</h2> 
  <p><a href="https://github.com/hyperledger/fabric" rel="nofollow" target="_blank">https://github.com/hyperledger/fabric</a> <br> 默认是最新版1.0，可以自己切换到v0.6分支</p> 
  <h2 id="12-部署">1.2 部署</h2> 
  <p>环境：Ubuntu 16.04 64位 <br> 安装Docker，Docker-compose，fabric部署，以pbft模式启动fabric <br> 参考文档：<a href="http://www.cnblogs.com/sclczk/p/6552845.html" rel="nofollow" target="_blank">http://www.cnblogs.com/sclczk/p/6552845.html</a></p> 
  <p>重启服务</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">systemctl restart docker<span class="hljs-preprocessor">.service</span></code></pre> 
  <p>启动 4 个 PBFT peer 节点 + 1 个 CA 节点 + 1 个 Blockchain-explorer，并启用 CA 功能。</p> 
  <pre class="prettyprint"><code class=" hljs lasso">docker<span class="hljs-attribute">-compose</span> <span class="hljs-attribute">-f</span> <span class="hljs-number">4</span><span class="hljs-attribute">-peers</span><span class="hljs-attribute">-with</span><span class="hljs-attribute">-membersrvc</span><span class="hljs-attribute">-explorer</span><span class="hljs-built_in">.</span>yml up</code></pre> 
  <h2 id="13-使用chaincode">1.3 使用chaincode</h2> 
  <p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/usage.html" rel="nofollow">https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/usage.html</a> <br> 或参考<a href="https://bitshuo.com/topic/58870c418d8be16a4ff73081" rel="nofollow">https://bitshuo.com/topic/58870c418d8be16a4ff73081</a></p> 
  <p>进入一个节点</p> 
  <pre class="prettyprint"><code class=" hljs bash">docker <span class="hljs-keyword">exec</span> -it pbft_vp0_1 bash</code></pre> 
  <h1 id="2-fabric源码智能合约源码解析">2 fabric源码智能合约源码解析</h1> 
  <h2 id="21-go语言又称golang">2.1 go语言（又称golang）</h2> 
  <p>go IDE：Gogland <br> <a href="http://www.mamicode.com/info-detail-1701831.html" rel="nofollow" target="_blank">http://www.mamicode.com/info-detail-1701831.html</a></p> 
  <h2 id="22-智能合约例子">2.2 智能合约例子</h2> 
  <p>相关例子在如下文件夹中 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170627215322631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmloYW9tYW5paGFvMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 这里列举了如何做一个map和table</p> 
  <h2 id="23-核心接口">2.3 核心接口</h2> 
  <p>在fabric/core/chaincode/shim中的interfaces.go</p> 
  <pre class="prettyprint"><code class=" hljs sql">type ChaincodeStubInterface interface {
    // Get the arguments to the stub <span class="hljs-operator"><span class="hljs-keyword">call</span> <span class="hljs-keyword">as</span> a <span class="hljs-number">2</span>D byte array GetArgs() [][]byte // <span class="hljs-keyword">Get</span> the arguments <span class="hljs-keyword">to</span> the stub <span class="hljs-keyword">call</span> <span class="hljs-keyword">as</span> a string array GetStringArgs() []string // <span class="hljs-keyword">Get</span> the <span class="hljs-keyword">transaction</span> ID GetTxID() string // InvokeChaincode locally calls the specified chaincode <span class="hljs-string">`Invoke`</span> <span class="hljs-keyword">using</span> the // same <span class="hljs-keyword">transaction</span> context;</span> that is, chaincode calling chaincode doesn't
    // <span class="hljs-operator"><span class="hljs-keyword">create</span> a new <span class="hljs-keyword">transaction</span> message. InvokeChaincode(chaincodeName string, args [][]byte) ([]byte, error) // QueryChaincode locally calls the specified chaincode <span class="hljs-string">`Query`</span> <span class="hljs-keyword">using</span> the // same <span class="hljs-keyword">transaction</span> context;</span> that is, chaincode calling chaincode doesn't
    // <span class="hljs-operator"><span class="hljs-keyword">create</span> a new <span class="hljs-keyword">transaction</span> message. QueryChaincode(chaincodeName string, args [][]byte) ([]byte, error) // GetState returns the byte array <span class="hljs-keyword">value</span> specified <span class="hljs-keyword">by</span> the <span class="hljs-string">`key`</span>. GetState(<span class="hljs-keyword">key</span> string) ([]byte, error) // PutState writes the specified <span class="hljs-string">`value`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`key`</span> <span class="hljs-keyword">into</span> the ledger. PutState(<span class="hljs-keyword">key</span> string, <span class="hljs-keyword">value</span> []byte) error // DelState removes the specified <span class="hljs-string">`key`</span> <span class="hljs-keyword">and</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">from</span> the ledger. DelState(<span class="hljs-keyword">key</span> string) error // RangeQueryState function can be invoked <span class="hljs-keyword">by</span> a chaincode <span class="hljs-keyword">to</span> query <span class="hljs-keyword">of</span> a range // <span class="hljs-keyword">of</span> keys <span class="hljs-keyword">in</span> the state. Assuming the startKey <span class="hljs-keyword">and</span> endKey <span class="hljs-keyword">are</span> <span class="hljs-keyword">in</span> lexical // an iterator will be returned that can be used <span class="hljs-keyword">to</span> iterate over <span class="hljs-keyword">all</span> keys // between the startKey <span class="hljs-keyword">and</span> endKey, inclusive. The <span class="hljs-keyword">order</span> <span class="hljs-keyword">in</span> which keys <span class="hljs-keyword">are</span> // returned <span class="hljs-keyword">by</span> the iterator <span class="hljs-keyword">is</span> random. RangeQueryState(startKey, endKey string) (StateRangeQueryIteratorInterface, error) // CreateTable creates a new <span class="hljs-keyword">table</span> given the <span class="hljs-keyword">table</span> name <span class="hljs-keyword">and</span> <span class="hljs-keyword">column</span> definitions CreateTable(name string, columnDefinitions []*ColumnDefinition) error // GetTable returns the <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> the specified <span class="hljs-keyword">table</span> name <span class="hljs-keyword">or</span> ErrTableNotFound // <span class="hljs-keyword">if</span> the <span class="hljs-keyword">table</span> does <span class="hljs-keyword">not</span> exist. GetTable(tableName string) (*<span class="hljs-keyword">Table</span>, error) // DeleteTable deletes an entire <span class="hljs-keyword">table</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">all</span> associated <span class="hljs-keyword">rows</span>. DeleteTable(tableName string) error // InsertRow inserts a new <span class="hljs-keyword">row</span> <span class="hljs-keyword">into</span> the specified <span class="hljs-keyword">table</span>. // Returns - // <span class="hljs-keyword">true</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> error <span class="hljs-keyword">if</span> the <span class="hljs-keyword">row</span> <span class="hljs-keyword">is</span> successfully inserted. // <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> error <span class="hljs-keyword">if</span> a <span class="hljs-keyword">row</span> already <span class="hljs-keyword">exists</span> <span class="hljs-keyword">for</span> the given <span class="hljs-keyword">key</span>. // <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> a TableNotFoundError <span class="hljs-keyword">if</span> the specified <span class="hljs-keyword">table</span> name does <span class="hljs-keyword">not</span> exist. // <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> an error <span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> an unexpected error condition. InsertRow(tableName string, <span class="hljs-keyword">row</span> <span class="hljs-keyword">Row</span>) (bool, error) // ReplaceRow updates the <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> the specified <span class="hljs-keyword">table</span>. // Returns - // <span class="hljs-keyword">true</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> error <span class="hljs-keyword">if</span> the <span class="hljs-keyword">row</span> <span class="hljs-keyword">is</span> successfully updated. // <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> error <span class="hljs-keyword">if</span> a <span class="hljs-keyword">row</span> does <span class="hljs-keyword">not</span> exist the given <span class="hljs-keyword">key</span>. // flase <span class="hljs-keyword">and</span> a TableNotFoundError <span class="hljs-keyword">if</span> the specified <span class="hljs-keyword">table</span> name does <span class="hljs-keyword">not</span> exist. // <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> an error <span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> an unexpected error condition. ReplaceRow(tableName string, <span class="hljs-keyword">row</span> <span class="hljs-keyword">Row</span>) (bool, error) // GetRow fetches a <span class="hljs-keyword">row</span> <span class="hljs-keyword">from</span> the specified <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> the given <span class="hljs-keyword">key</span>. GetRow(tableName string, <span class="hljs-keyword">key</span> []<span class="hljs-keyword">Column</span>) (<span class="hljs-keyword">Row</span>, error) // GetRows returns multiple <span class="hljs-keyword">rows</span> based <span class="hljs-keyword">on</span> a <span class="hljs-keyword">partial</span> <span class="hljs-keyword">key</span>. <span class="hljs-keyword">For</span> example, given <span class="hljs-keyword">table</span> // | A | B | C | D | // <span class="hljs-keyword">where</span> A, C <span class="hljs-keyword">and</span> D <span class="hljs-keyword">are</span> keys, GetRows can be called <span class="hljs-keyword">with</span> [A, C] <span class="hljs-keyword">to</span> return // <span class="hljs-keyword">all</span> <span class="hljs-keyword">rows</span> that have A, C <span class="hljs-keyword">and</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">for</span> D <span class="hljs-keyword">as</span> their <span class="hljs-keyword">key</span>. GetRows could // also be called <span class="hljs-keyword">with</span> A <span class="hljs-keyword">only</span> <span class="hljs-keyword">to</span> return <span class="hljs-keyword">all</span> <span class="hljs-keyword">rows</span> that have A <span class="hljs-keyword">and</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">value</span> // <span class="hljs-keyword">for</span> C <span class="hljs-keyword">and</span> D <span class="hljs-keyword">as</span> their <span class="hljs-keyword">key</span>. GetRows(tableName string, <span class="hljs-keyword">key</span> []<span class="hljs-keyword">Column</span>) (&lt;-chan <span class="hljs-keyword">Row</span>, error) // DeleteRow deletes the <span class="hljs-keyword">row</span> <span class="hljs-keyword">for</span> the given <span class="hljs-keyword">key</span> <span class="hljs-keyword">from</span> the specified <span class="hljs-keyword">table</span>. DeleteRow(tableName string, <span class="hljs-keyword">key</span> []<span class="hljs-keyword">Column</span>) error // ReadCertAttribute <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span> an specific attribute <span class="hljs-keyword">from</span> the <span class="hljs-keyword">transaction</span> certificate, // *attributeName* <span class="hljs-keyword">is</span> passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">input</span> parameter <span class="hljs-keyword">to</span> this function. // Example: // attrValue,error:=stub.ReadCertAttribute(<span class="hljs-string">"position"</span>) ReadCertAttribute(attributeName string) ([]byte, error) // VerifyAttribute <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> verify <span class="hljs-keyword">if</span> the <span class="hljs-keyword">transaction</span> certificate has an attribute // <span class="hljs-keyword">with</span> name *attributeName* <span class="hljs-keyword">and</span> <span class="hljs-keyword">value</span> *attributeValue* which <span class="hljs-keyword">are</span> the <span class="hljs-keyword">input</span> parameters // received <span class="hljs-keyword">by</span> this function. // Example: // containsAttr, error := stub.VerifyAttribute(<span class="hljs-string">"position"</span>, <span class="hljs-string">"Software Engineer"</span>) VerifyAttribute(attributeName string, attributeValue []byte) (bool, error) // VerifyAttributes does the same <span class="hljs-keyword">as</span> VerifyAttribute but it checks <span class="hljs-keyword">for</span> a list <span class="hljs-keyword">of</span> // attributes <span class="hljs-keyword">and</span> their respective <span class="hljs-keyword">values</span> instead <span class="hljs-keyword">of</span> a single attribute/<span class="hljs-keyword">value</span> pair // Example: // containsAttrs, error:= stub.VerifyAttributes(&amp;attr.Attribute{<span class="hljs-string">"position"</span>, <span class="hljs-string">"Software Engineer"</span>}, &amp;attr.Attribute{<span class="hljs-string">"company"</span>, <span class="hljs-string">"ACompany"</span>}) VerifyAttributes(attrs ...*attr.Attribute) (bool, error) // VerifySignature verifies the <span class="hljs-keyword">transaction</span> signature <span class="hljs-keyword">and</span> returns <span class="hljs-string">`true`</span> <span class="hljs-keyword">if</span> // correct <span class="hljs-keyword">and</span> <span class="hljs-string">`false`</span> otherwise VerifySignature(certificate, signature, message []byte) (bool, error) // GetCallerCertificate returns caller certificate GetCallerCertificate() ([]byte, error) // GetCallerMetadata returns caller metadata GetCallerMetadata() ([]byte, error) // GetBinding returns the <span class="hljs-keyword">transaction</span> binding GetBinding() ([]byte, error) // GetPayload returns <span class="hljs-keyword">transaction</span> payload, which <span class="hljs-keyword">is</span> a <span class="hljs-string">`ChaincodeSpec`</span> defined // <span class="hljs-keyword">in</span> fabric/protos/chaincode.proto GetPayload() ([]byte, error) // GetTxTimestamp returns <span class="hljs-keyword">transaction</span> created <span class="hljs-keyword">timestamp</span>, which <span class="hljs-keyword">is</span> currently // taken <span class="hljs-keyword">from</span> the peer receiving the <span class="hljs-keyword">transaction</span>. Note that this <span class="hljs-keyword">timestamp</span> // may <span class="hljs-keyword">not</span> be the same <span class="hljs-keyword">with</span> the other peers<span class="hljs-string">' time. GetTxTimestamp() (*timestamp.Timestamp, error) // SetEvent saves the event to be sent when a transaction is made part of a block SetEvent(name string, payload []byte) error }</span></span></code></pre> 
  <h1 id="3-定制智能合约">3 定制智能合约</h1> 
  <h2 id="31-智能合约">3.1 智能合约</h2> 
  <p>写的一个例子：</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"errors"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"encoding/json"</span>
    <span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span>
)

<span class="hljs-comment">// SimpleChaincode example simple Chaincode implementation</span>
<span class="hljs-keyword">type</span> SimpleChaincode <span class="hljs-keyword">struct</span> {
}

<span class="hljs-keyword">func</span> main() {
    err := shim.Start(<span class="hljs-built_in">new</span>(SimpleChaincode))
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        fmt.Printf(<span class="hljs-string">"Error starting Simple chaincode: %s"</span>, err)
    }
}
<span class="hljs-keyword">type</span> Location <span class="hljs-keyword">struct</span> {
    Id <span class="hljs-typename">string</span>
    Status <span class="hljs-typename">string</span>
    locx <span class="hljs-typename">string</span>
    locy <span class="hljs-typename">string</span>

}
<span class="hljs-comment">// Init resets all the things</span>
<span class="hljs-keyword">func</span> (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function <span class="hljs-typename">string</span>, args []<span class="hljs-typename">string</span>) ([]<span class="hljs-typename">byte</span>, error) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) !=<span class="hljs-number"> 1</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(<span class="hljs-string">"Incorrect number of arguments. Expecting 1"</span>)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, <span class="hljs-constant">nil</span>
}

<span class="hljs-comment">// Invoke isur entry point to invoke a chaincode function</span>
<span class="hljs-keyword">func</span> (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function <span class="hljs-typename">string</span>, args []<span class="hljs-typename">string</span>) ([]<span class="hljs-typename">byte</span>, error) {
    fmt.Println(<span class="hljs-string">"invoke is running "</span> + function)

    <span class="hljs-comment">// Handle different functions</span>
    <span class="hljs-keyword">if</span> function == <span class="hljs-string">"init"</span> {
        <span class="hljs-keyword">return</span> t.Init(stub, <span class="hljs-string">"init"</span>, args)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> function == <span class="hljs-string">"write"</span> {
        <span class="hljs-keyword">return</span> t.write(stub, args)
    }
    fmt.Println(<span class="hljs-string">"invoke did not find func: "</span> + function)

    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(<span class="hljs-string">"Received unknown function invocation"</span>)
}

<span class="hljs-comment">// Query is our entry point for queries</span>
<span class="hljs-keyword">func</span> (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function <span class="hljs-typename">string</span>, args []<span class="hljs-typename">string</span>) ([]<span class="hljs-typename">byte</span>, error) {
    fmt.Println(<span class="hljs-string">"query is running "</span> + function)

    <span class="hljs-comment">// Handle different functions</span>
    <span class="hljs-keyword">if</span> function == <span class="hljs-string">"read"</span> { <span class="hljs-comment">//read a variable</span>
        <span class="hljs-keyword">return</span> t.read(stub, args)
    }
    fmt.Println(<span class="hljs-string">"query did not find func: "</span> + function)

    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(<span class="hljs-string">"Received unknown function query"</span>)
}

<span class="hljs-comment">// write - invoke function to write key/value pair</span>
<span class="hljs-keyword">func</span> (t *SimpleChaincode) write(stub shim.ChaincodeStubInterface, args []<span class="hljs-typename">string</span>) ([]<span class="hljs-typename">byte</span>,error) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) !=<span class="hljs-number"> 4</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(<span class="hljs-string">"Incorrect number of arguments. Expecting 4"</span>)
    }
    <span class="hljs-keyword">var</span> err error
    location := Location {Id:args<span class="hljs-number">[0</span>],Status:args<span class="hljs-number">[1</span>]+<span class="hljs-string">","</span>+args<span class="hljs-number">[2</span>]+<span class="hljs-string">","</span>+args<span class="hljs-number">[3</span>],locx:args<span class="hljs-number">[2</span>],locy:args<span class="hljs-number">[3</span>]}

    locationlBytes,err:= json.Marshal(&amp;location)

    str := <span class="hljs-typename">string</span>(locationlBytes[:])
    fmt.Println(str)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span>{
        fmt.Print(err)
    }
    err = stub.PutState(location.Id,locationlBytes)
    <span class="hljs-keyword">if</span> err !=<span class="hljs-constant">nil</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>,errors.New(<span class="hljs-string">"PutState Error"</span> + err.Error())
    }
    <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>,<span class="hljs-constant">nil</span>
}

<span class="hljs-comment">// read - query function to read key/value pair</span>
<span class="hljs-keyword">func</span> (t *SimpleChaincode) read(stub shim.ChaincodeStubInterface, args []<span class="hljs-typename">string</span>) ([]<span class="hljs-typename">byte</span>, error) {
    <span class="hljs-keyword">var</span> key, jsonResp <span class="hljs-typename">string</span>
    <span class="hljs-keyword">var</span> err error
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) !=<span class="hljs-number"> 1</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(<span class="hljs-string">"Incorrect number of arguments. Expecting name of the key to query"</span>)
    }
    key = args<span class="hljs-number">[0</span>]
    valAsbytes, err := stub.GetState(key)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        jsonResp = <span class="hljs-string">"{\"Error\":\"Failed to get state for "</span> + key + <span class="hljs-string">"\"}"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, errors.New(jsonResp)
    }

    <span class="hljs-keyword">return</span> valAsbytes, <span class="hljs-constant">nil</span>
}</code></pre> 
  <h2 id="32-编译调试">3.2 编译调试</h2> 
  <p>go build <br> <a href="http://blog.csdn.net/h363659487/article/details/72768211" rel="nofollow" target="_blank">http://blog.csdn.net/h363659487/article/details/72768211</a></p> 
  <p>部署自己写的智能合约时，先上传到github，然后进入一个vp节点： <br> <code>docker exec -it pbft_vp0_1 bash</code>， <br> 通过github下载到节点里面。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170627215724030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmloYW9tYW5paGFvMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 注意路径中的github.com其实就是一个文件名</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/nihaomanihao11/article/details/73824163,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/nihaomanihao11/article/details/73824163,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
