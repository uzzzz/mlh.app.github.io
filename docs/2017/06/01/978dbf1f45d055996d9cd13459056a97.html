<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>量化交易中VWAP/TWAP算法的基本原理和简单源码实现（C++和python） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="量化交易中VWAP/TWAP算法的基本原理和简单源码实现（C++和python）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/72830003 参考文献： https://en.wikipedia.org/wiki/Time-weighted_average_price https://en.wikipedia.org/wiki/Volume-weighted_average_price http://blog.sina.com.cn/s/blog_163a2b9700102wdy0.html https://www.douban.com/note/214362575 算法交易其实主要是用在基金公司、券商量化比较多。例如我已经选好股，要大量买入，但是单凭交易员的操作海量单而且要完成买入100万股这些的操作是有点的困难的。那么这时候怎样解决拆单，防止冲击成本的问题呢？只有依靠算法交易了。 根据各个算法交易中算法的主动程度不同，可以把算法交易分为被动型算法交易、主动型算法交易、综合型算法交易三大类。而TWAP（时间加权平均价格）、VWAP（成交量加权平均价格）就属于被动型算法交易，也是在日常算法交易中应用最为广泛的策略算法。 VWAP VWAP是Volume Weighted Average Price的缩写，译为成交量加权平均价，VWAP策略是一种拆分大额委托单，在约定时间段内分批执行，以期使得最终买入或卖出成交均价尽量接近这段时间内整个市场成交均价的交易策略。它是量化交易系统中常用的一个基准。作为一个基准量，VWAP就是一个计算公式： Vwap=∑ni=1pricei∗volumei∑ni=1volumei 要做到这一点，VWAP模型必须把母单分割成为许多小的子单，并在一个指定的时间段内逐步送出去。这样做的效果就是降低了大单对市场的冲击，改善了执行效果；同时增加了大单的隐秘性。显然，VWAP模型的核心就是如何在市场千变万化的情况下，有的放矢地确定子单的大小、价格和发送时间。 VWAP模型做到这一点的关键是历史成交量、未来成交量的预测、市场动态总成交量以及拆单的时间段（就是总共要将总单拆分成多少单分别以怎样的时间频率交易）。较为高级的VWAP模型要使用交易所单簿（Order Book）的详细信息，这要求系统能够得到即时的第二级市场数据（Level II Market Data）。 VWAP模型对于在几个小时内执行大单的效果最好。在交易量大的市场中，VWAP效果比在流动性差的市场中要好。在市场出现重要事件的时候往往效果不那么好。如果订单非常大，譬如超过市场日交易量的1%的话，即便VWAP可以在相当大的程度上改善市场冲击，但市场冲击仍然会以积累的方式改变市场，最终使得模型的效果差于预期。 VWAP算法交易的目的是最小化冲击成本，并不寻求最小化所有成本。理论上，在没有额外的信息，也没有针对股票价格趋势的预测的情况下，VWAP 是最优的算法交易策略。 TWAP TWAP交易时间加权平均价格Time Weighted Average Price 模型是把一个母单的数量平均地分配到一个交易时段上。该模型将交易时间进行均匀分割，并在每个分割节点上将拆分的订单进行提交。例如，可以将某个交易日的交易时间平均分为N 段，TWAP 策略会将该交易日需要执行的订单均匀分配在这N 个时间段上去执行，从而使得交易均价跟踪TWAP，也是一个计算公式： Twap=∑ni=1pricein TWAP不考虑交易量的因素。TWAP的基准是交易时段的平均价格，它试图付出比此时段内平均买卖差价小的代价执行一个大订单。TWAP模型设计的目的是使交易对市场影响减小的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。在分时成交量无法准确估计的情况下，该模型可以较好地实现算法交易的基本目的。但是使用TWAP过程中的一个问题是，在订单规模很大的情况下，均匀分配到每个节点上的下单量仍然较大，当市场流动性不足时仍可能对市场造成一定的冲击。另一方面，真实市场的成交量总是在波动变化的，将所有的订单均匀分配到每个节点上显然是不够合理的。因此，算法交易研究人员很快建立了基于成交量变动预测的VWAP 模型。不过，由于TWAP 操作和理解起来非常简单，因此其对于流动性较好的市场和订单规模较小的交易仍然适用。 代码实现 以A股 平安银行 的股票某一天的分钟线行情为例，分别用C++和python实现twap和vwap的求解。 在实际的交易系统中，将得到的价格分不同时段将大单拆成小单挂单交易，以下是twap和vwap计算的简单实现 C++ // calculate vwap value double calc_vwap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double total_sum = 0.0; int volume_sum = 0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; int volume = atoi(marketDataTable[i][11].c_str()); // compute total sum and volume sum total_sum += price * volume; volume_sum += volume; } return total_sum / volume_sum; } // calculate twap value double calc_twap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double price_sum = 0.0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; // compute price sum and time sum // here use the 1 min K-line data, so total time is n minutes price_sum += price; } return price_sum / n; } python # calculate vwap value def calc_vwap(marketDataTable): n = len(marketDataTable) - 1 total_sum = 0.0 volume_sum = 0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 volume = int(marketDataTable[i][11]) total_sum += price * volume volume_sum += volume return total_sum / volume_sum # calculate vwap value def calc_twap(marketDataTable): n = len(marketDataTable) - 1 price_sum = 0.0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 price_sum += price return price_sum / n 运行结果 reading market data calculating TWAP and VWAP VWAP: 8.66789 TWAP: 8.66475 完整demo下载 csdn: twap/vwap code github: twap/vwap code 阅读更多" />
<meta property="og:description" content="版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/72830003 参考文献： https://en.wikipedia.org/wiki/Time-weighted_average_price https://en.wikipedia.org/wiki/Volume-weighted_average_price http://blog.sina.com.cn/s/blog_163a2b9700102wdy0.html https://www.douban.com/note/214362575 算法交易其实主要是用在基金公司、券商量化比较多。例如我已经选好股，要大量买入，但是单凭交易员的操作海量单而且要完成买入100万股这些的操作是有点的困难的。那么这时候怎样解决拆单，防止冲击成本的问题呢？只有依靠算法交易了。 根据各个算法交易中算法的主动程度不同，可以把算法交易分为被动型算法交易、主动型算法交易、综合型算法交易三大类。而TWAP（时间加权平均价格）、VWAP（成交量加权平均价格）就属于被动型算法交易，也是在日常算法交易中应用最为广泛的策略算法。 VWAP VWAP是Volume Weighted Average Price的缩写，译为成交量加权平均价，VWAP策略是一种拆分大额委托单，在约定时间段内分批执行，以期使得最终买入或卖出成交均价尽量接近这段时间内整个市场成交均价的交易策略。它是量化交易系统中常用的一个基准。作为一个基准量，VWAP就是一个计算公式： Vwap=∑ni=1pricei∗volumei∑ni=1volumei 要做到这一点，VWAP模型必须把母单分割成为许多小的子单，并在一个指定的时间段内逐步送出去。这样做的效果就是降低了大单对市场的冲击，改善了执行效果；同时增加了大单的隐秘性。显然，VWAP模型的核心就是如何在市场千变万化的情况下，有的放矢地确定子单的大小、价格和发送时间。 VWAP模型做到这一点的关键是历史成交量、未来成交量的预测、市场动态总成交量以及拆单的时间段（就是总共要将总单拆分成多少单分别以怎样的时间频率交易）。较为高级的VWAP模型要使用交易所单簿（Order Book）的详细信息，这要求系统能够得到即时的第二级市场数据（Level II Market Data）。 VWAP模型对于在几个小时内执行大单的效果最好。在交易量大的市场中，VWAP效果比在流动性差的市场中要好。在市场出现重要事件的时候往往效果不那么好。如果订单非常大，譬如超过市场日交易量的1%的话，即便VWAP可以在相当大的程度上改善市场冲击，但市场冲击仍然会以积累的方式改变市场，最终使得模型的效果差于预期。 VWAP算法交易的目的是最小化冲击成本，并不寻求最小化所有成本。理论上，在没有额外的信息，也没有针对股票价格趋势的预测的情况下，VWAP 是最优的算法交易策略。 TWAP TWAP交易时间加权平均价格Time Weighted Average Price 模型是把一个母单的数量平均地分配到一个交易时段上。该模型将交易时间进行均匀分割，并在每个分割节点上将拆分的订单进行提交。例如，可以将某个交易日的交易时间平均分为N 段，TWAP 策略会将该交易日需要执行的订单均匀分配在这N 个时间段上去执行，从而使得交易均价跟踪TWAP，也是一个计算公式： Twap=∑ni=1pricein TWAP不考虑交易量的因素。TWAP的基准是交易时段的平均价格，它试图付出比此时段内平均买卖差价小的代价执行一个大订单。TWAP模型设计的目的是使交易对市场影响减小的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。在分时成交量无法准确估计的情况下，该模型可以较好地实现算法交易的基本目的。但是使用TWAP过程中的一个问题是，在订单规模很大的情况下，均匀分配到每个节点上的下单量仍然较大，当市场流动性不足时仍可能对市场造成一定的冲击。另一方面，真实市场的成交量总是在波动变化的，将所有的订单均匀分配到每个节点上显然是不够合理的。因此，算法交易研究人员很快建立了基于成交量变动预测的VWAP 模型。不过，由于TWAP 操作和理解起来非常简单，因此其对于流动性较好的市场和订单规模较小的交易仍然适用。 代码实现 以A股 平安银行 的股票某一天的分钟线行情为例，分别用C++和python实现twap和vwap的求解。 在实际的交易系统中，将得到的价格分不同时段将大单拆成小单挂单交易，以下是twap和vwap计算的简单实现 C++ // calculate vwap value double calc_vwap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double total_sum = 0.0; int volume_sum = 0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; int volume = atoi(marketDataTable[i][11].c_str()); // compute total sum and volume sum total_sum += price * volume; volume_sum += volume; } return total_sum / volume_sum; } // calculate twap value double calc_twap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double price_sum = 0.0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; // compute price sum and time sum // here use the 1 min K-line data, so total time is n minutes price_sum += price; } return price_sum / n; } python # calculate vwap value def calc_vwap(marketDataTable): n = len(marketDataTable) - 1 total_sum = 0.0 volume_sum = 0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 volume = int(marketDataTable[i][11]) total_sum += price * volume volume_sum += volume return total_sum / volume_sum # calculate vwap value def calc_twap(marketDataTable): n = len(marketDataTable) - 1 price_sum = 0.0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 price_sum += price return price_sum / n 运行结果 reading market data calculating TWAP and VWAP VWAP: 8.66789 TWAP: 8.66475 完整demo下载 csdn: twap/vwap code github: twap/vwap code 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/06/01/978dbf1f45d055996d9cd13459056a97.html" />
<meta property="og:url" content="https://mlh.app/2017/06/01/978dbf1f45d055996d9cd13459056a97.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/72830003 参考文献： https://en.wikipedia.org/wiki/Time-weighted_average_price https://en.wikipedia.org/wiki/Volume-weighted_average_price http://blog.sina.com.cn/s/blog_163a2b9700102wdy0.html https://www.douban.com/note/214362575 算法交易其实主要是用在基金公司、券商量化比较多。例如我已经选好股，要大量买入，但是单凭交易员的操作海量单而且要完成买入100万股这些的操作是有点的困难的。那么这时候怎样解决拆单，防止冲击成本的问题呢？只有依靠算法交易了。 根据各个算法交易中算法的主动程度不同，可以把算法交易分为被动型算法交易、主动型算法交易、综合型算法交易三大类。而TWAP（时间加权平均价格）、VWAP（成交量加权平均价格）就属于被动型算法交易，也是在日常算法交易中应用最为广泛的策略算法。 VWAP VWAP是Volume Weighted Average Price的缩写，译为成交量加权平均价，VWAP策略是一种拆分大额委托单，在约定时间段内分批执行，以期使得最终买入或卖出成交均价尽量接近这段时间内整个市场成交均价的交易策略。它是量化交易系统中常用的一个基准。作为一个基准量，VWAP就是一个计算公式： Vwap=∑ni=1pricei∗volumei∑ni=1volumei 要做到这一点，VWAP模型必须把母单分割成为许多小的子单，并在一个指定的时间段内逐步送出去。这样做的效果就是降低了大单对市场的冲击，改善了执行效果；同时增加了大单的隐秘性。显然，VWAP模型的核心就是如何在市场千变万化的情况下，有的放矢地确定子单的大小、价格和发送时间。 VWAP模型做到这一点的关键是历史成交量、未来成交量的预测、市场动态总成交量以及拆单的时间段（就是总共要将总单拆分成多少单分别以怎样的时间频率交易）。较为高级的VWAP模型要使用交易所单簿（Order Book）的详细信息，这要求系统能够得到即时的第二级市场数据（Level II Market Data）。 VWAP模型对于在几个小时内执行大单的效果最好。在交易量大的市场中，VWAP效果比在流动性差的市场中要好。在市场出现重要事件的时候往往效果不那么好。如果订单非常大，譬如超过市场日交易量的1%的话，即便VWAP可以在相当大的程度上改善市场冲击，但市场冲击仍然会以积累的方式改变市场，最终使得模型的效果差于预期。 VWAP算法交易的目的是最小化冲击成本，并不寻求最小化所有成本。理论上，在没有额外的信息，也没有针对股票价格趋势的预测的情况下，VWAP 是最优的算法交易策略。 TWAP TWAP交易时间加权平均价格Time Weighted Average Price 模型是把一个母单的数量平均地分配到一个交易时段上。该模型将交易时间进行均匀分割，并在每个分割节点上将拆分的订单进行提交。例如，可以将某个交易日的交易时间平均分为N 段，TWAP 策略会将该交易日需要执行的订单均匀分配在这N 个时间段上去执行，从而使得交易均价跟踪TWAP，也是一个计算公式： Twap=∑ni=1pricein TWAP不考虑交易量的因素。TWAP的基准是交易时段的平均价格，它试图付出比此时段内平均买卖差价小的代价执行一个大订单。TWAP模型设计的目的是使交易对市场影响减小的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。在分时成交量无法准确估计的情况下，该模型可以较好地实现算法交易的基本目的。但是使用TWAP过程中的一个问题是，在订单规模很大的情况下，均匀分配到每个节点上的下单量仍然较大，当市场流动性不足时仍可能对市场造成一定的冲击。另一方面，真实市场的成交量总是在波动变化的，将所有的订单均匀分配到每个节点上显然是不够合理的。因此，算法交易研究人员很快建立了基于成交量变动预测的VWAP 模型。不过，由于TWAP 操作和理解起来非常简单，因此其对于流动性较好的市场和订单规模较小的交易仍然适用。 代码实现 以A股 平安银行 的股票某一天的分钟线行情为例，分别用C++和python实现twap和vwap的求解。 在实际的交易系统中，将得到的价格分不同时段将大单拆成小单挂单交易，以下是twap和vwap计算的简单实现 C++ // calculate vwap value double calc_vwap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double total_sum = 0.0; int volume_sum = 0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; int volume = atoi(marketDataTable[i][11].c_str()); // compute total sum and volume sum total_sum += price * volume; volume_sum += volume; } return total_sum / volume_sum; } // calculate twap value double calc_twap(std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;marketDataTable) { int n = marketDataTable.size() - 1; // skip the first title line double price_sum = 0.0; for (int i = 1; i &lt;= n; i++) { // get the price and volume according to table structure double high_price = atof(marketDataTable[i][9].c_str()); double low_price = atof(marketDataTable[i][10].c_str()); double price = (high_price + low_price) / 2; // compute price sum and time sum // here use the 1 min K-line data, so total time is n minutes price_sum += price; } return price_sum / n; } python # calculate vwap value def calc_vwap(marketDataTable): n = len(marketDataTable) - 1 total_sum = 0.0 volume_sum = 0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 volume = int(marketDataTable[i][11]) total_sum += price * volume volume_sum += volume return total_sum / volume_sum # calculate vwap value def calc_twap(marketDataTable): n = len(marketDataTable) - 1 price_sum = 0.0 for i in range(1, n + 1): high_price = float(marketDataTable[i][9]) low_price = float(marketDataTable[i][10]) price = (high_price + low_price) / 2 price_sum += price return price_sum / n 运行结果 reading market data calculating TWAP and VWAP VWAP: 8.66789 TWAP: 8.66475 完整demo下载 csdn: twap/vwap code github: twap/vwap code 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/06/01/978dbf1f45d055996d9cd13459056a97.html","headline":"量化交易中VWAP/TWAP算法的基本原理和简单源码实现（C++和python）","dateModified":"2017-06-01T00:00:00+08:00","datePublished":"2017-06-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/06/01/978dbf1f45d055996d9cd13459056a97.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>量化交易中VWAP/TWAP算法的基本原理和简单源码实现（C++和python）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：原创文章如需转载，请在左侧博主描述栏目扫码联系我并取得授权，谢谢 https://blog.csdn.net/u012234115/article/details/72830003 
 </div> 
 <div class="markdown_views prism-github-gist"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <blockquote> 
   <p>参考文献： <br> <a href="https://en.wikipedia.org/wiki/Time-weighted_average_price" rel="nofollow">https://en.wikipedia.org/wiki/Time-weighted_average_price</a> <br> <a href="https://en.wikipedia.org/wiki/Volume-weighted_average_price" rel="nofollow">https://en.wikipedia.org/wiki/Volume-weighted_average_price</a> <br> <a href="http://blog.sina.com.cn/s/blog_163a2b9700102wdy0.html" rel="nofollow">http://blog.sina.com.cn/s/blog_163a2b9700102wdy0.html</a> <br> <a href="https://www.douban.com/note/214362575" rel="nofollow">https://www.douban.com/note/214362575</a></p> 
  </blockquote> 
  <p>算法交易其实主要是用在基金公司、券商量化比较多。例如我已经选好股，要大量买入，但是单凭交易员的操作海量单而且要完成买入100万股这些的操作是有点的困难的。那么这时候怎样解决拆单，防止冲击成本的问题呢？只有依靠算法交易了。 <br> 根据各个算法交易中算法的主动程度不同，可以把算法交易分为被动型算法交易、主动型算法交易、综合型算法交易三大类。而TWAP（时间加权平均价格）、VWAP（成交量加权平均价格）就属于被动型算法交易，也是在日常算法交易中应用最为广泛的策略算法。</p> 
  <h1 id="vwap">VWAP</h1> 
  <p>VWAP是<strong>Volume Weighted Average Price</strong>的缩写，译为成交量加权平均价，VWAP策略是一种拆分大额委托单，<strong>在约定时间段内分批执行，以期使得最终买入或卖出成交均价尽量接近这段时间内整个市场成交均价</strong>的交易策略。它是量化交易系统中常用的一个基准。作为一个基准量，VWAP就是一个计算公式： <br> <span class="MathJax_Preview"></span></p>
  <div class="MathJax_Display" role="textbox" aria-readonly="true" style="text-align: center;">
   <span class="MathJax" id="MathJax-Element-1-Frame">
    <nobr>
     <span class="math" id="MathJax-Span-1" style="width: 16.154em; display: inline-block;"><span style="display: inline-block; position: relative; width: 13.119em; height: 0px; font-size: 123%;"><span style="position: absolute; clip: rect(0.545em 1000em 3.526em -0.431em); top: -2.274em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">V<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.165em;"></span></span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">w</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-7" style="font-family: MathJax_Main; padding-left: 0.274em;">=</span><span class="mfrac" id="MathJax-Span-8" style="padding-left: 0.274em;"><span style="display: inline-block; position: relative; width: 9.163em; height: 0px; margin-right: 0.111em; margin-left: 0.111em;"><span style="position: absolute; clip: rect(1.304em 1000em 2.713em -0.431em); top: -3.033em; left: 50%; margin-left: -4.496em;"><span class="mrow" id="MathJax-Span-9"><span class="munderover" id="MathJax-Span-10"><span style="display: inline-block; position: relative; width: 2.225em; height: 0px;"><span style="position: absolute; clip: rect(1.412em 1000em 2.767em -0.431em); top: -2.328em; left: 0.003em;"><span class="mo" id="MathJax-Span-11" style="font-family: MathJax_Size1; vertical-align: 0.003em;">∑</span><span style="display: inline-block; width: 0px; height: 2.333em;"></span></span><span style="position: absolute; clip: rect(1.791em 1000em 2.442em -0.485em); top: -2.762em; left: 1.033em;"><span class="texatom" id="MathJax-Span-12"><span class="mrow" id="MathJax-Span-13"><span class="mi" id="MathJax-Span-14" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(1.629em 1000em 2.442em -0.485em); top: -2.003em; left: 1.033em;"><span class="texatom" id="MathJax-Span-15"><span class="mrow" id="MathJax-Span-16"><span class="mi" id="MathJax-Span-17" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mo" id="MathJax-Span-18" style="font-size: 70.7%; font-family: MathJax_Main;">=</span><span class="mn" id="MathJax-Span-19" style="font-size: 70.7%; font-family: MathJax_Main;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">p</span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math-italic;">c</span><span class="msubsup" id="MathJax-Span-24"><span style="display: inline-block; position: relative; width: 0.707em; height: 0px;"><span style="position: absolute; clip: rect(1.683em 1000em 2.442em -0.431em); top: -2.274em; left: 0.003em;"><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">e</span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; top: -2.111em; left: 0.436em;"><span class="texatom" id="MathJax-Span-26"><span class="mrow" id="MathJax-Span-27"><span class="mi" id="MathJax-Span-28" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span><span class="mo" id="MathJax-Span-29" style="font-family: MathJax_Main; padding-left: 0.22em;">∗</span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Math-italic; padding-left: 0.22em;">v</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math-italic;">m</span><span class="msubsup" id="MathJax-Span-35"><span style="display: inline-block; position: relative; width: 0.707em; height: 0px;"><span style="position: absolute; clip: rect(1.683em 1000em 2.442em -0.431em); top: -2.274em; left: 0.003em;"><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math-italic;">e</span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; top: -2.111em; left: 0.436em;"><span class="texatom" id="MathJax-Span-37"><span class="mrow" id="MathJax-Span-38"><span class="mi" id="MathJax-Span-39" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(1.304em 1000em 2.713em -0.431em); top: -1.515em; left: 50%; margin-left: -2.87em;"><span class="mrow" id="MathJax-Span-40"><span class="munderover" id="MathJax-Span-41"><span style="display: inline-block; position: relative; width: 2.225em; height: 0px;"><span style="position: absolute; clip: rect(1.412em 1000em 2.767em -0.431em); top: -2.328em; left: 0.003em;"><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Size1; vertical-align: 0.003em;">∑</span><span style="display: inline-block; width: 0px; height: 2.333em;"></span></span><span style="position: absolute; clip: rect(1.791em 1000em 2.442em -0.485em); top: -2.762em; left: 1.033em;"><span class="texatom" id="MathJax-Span-43"><span class="mrow" id="MathJax-Span-44"><span class="mi" id="MathJax-Span-45" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(1.629em 1000em 2.442em -0.485em); top: -2.003em; left: 1.033em;"><span class="texatom" id="MathJax-Span-46"><span class="mrow" id="MathJax-Span-47"><span class="mi" id="MathJax-Span-48" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mo" id="MathJax-Span-49" style="font-size: 70.7%; font-family: MathJax_Main;">=</span><span class="mn" id="MathJax-Span-50" style="font-size: 70.7%; font-family: MathJax_Main;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span><span class="mi" id="MathJax-Span-51" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">v</span><span class="mi" id="MathJax-Span-52" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-54" style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math-italic;">m</span><span class="msubsup" id="MathJax-Span-56"><span style="display: inline-block; position: relative; width: 0.707em; height: 0px;"><span style="position: absolute; clip: rect(1.683em 1000em 2.442em -0.431em); top: -2.274em; left: 0.003em;"><span class="mi" id="MathJax-Span-57" style="font-family: MathJax_Math-italic;">e</span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; top: -2.111em; left: 0.436em;"><span class="texatom" id="MathJax-Span-58"><span class="mrow" id="MathJax-Span-59"><span class="mi" id="MathJax-Span-60" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(0.87em 1000em 1.249em -0.485em); top: -1.298em; left: 0.003em;"><span style="border-left: 9.163em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.087em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 3.337em; vertical-align: -1.397em;"></span></span>
    </nobr></span>
  </div>
  <script type="math/tex; mode=display" id="MathJax-Element-1">Vwap = \frac{\sum_{i = 1} ^ {n}price_{i} * volume_{i}} {\sum_{i = 1} ^ {n} volume_{i}}</script> 
  <br> 要做到这一点，VWAP模型必须把母单分割成为许多小的子单，并在一个指定的时间段内逐步送出去。这样做的效果就是降低了大单对市场的冲击，改善了执行效果；同时增加了大单的隐秘性。显然，VWAP模型的核心就是如何在市场千变万化的情况下，有的放矢地确定子单的大小、价格和发送时间。 
  <br> VWAP模型做到这一点的关键是历史成交量、未来成交量的预测、市场动态总成交量以及拆单的时间段（就是总共要将总单拆分成多少单分别以怎样的时间频率交易）。较为高级的VWAP模型要使用交易所单簿（Order Book）的详细信息，这要求系统能够得到即时的第二级市场数据（Level II Market Data）。 
  <br> VWAP模型对于在几个小时内执行大单的效果最好。在交易量大的市场中，VWAP效果比在流动性差的市场中要好。在市场出现重要事件的时候往往效果不那么好。如果订单非常大，譬如超过市场日交易量的1%的话，即便VWAP可以在相当大的程度上改善市场冲击，但市场冲击仍然会以积累的方式改变市场，最终使得模型的效果差于预期。 
  <br> VWAP算法交易的目的是最小化冲击成本，并不寻求最小化所有成本。理论上，在没有额外的信息，也没有针对股票价格趋势的预测的情况下，VWAP 是最优的算法交易策略。
  <p></p> 
  <h1 id="twap">TWAP</h1> 
  <p>TWAP交易时间加权平均价格<strong>Time Weighted Average Price</strong> 模型是<strong>把一个母单的数量平均地分配到一个交易时段上</strong>。该模型将交易时间进行均匀分割，并在每个分割节点上将拆分的订单进行提交。例如，可以将某个交易日的交易时间平均分为N 段，TWAP 策略会将该交易日需要执行的订单均匀分配在这N 个时间段上去执行，从而使得交易均价跟踪TWAP，也是一个计算公式： <br> <span class="MathJax_Preview"></span></p>
  <div class="MathJax_Display" role="textbox" aria-readonly="true" style="text-align: center;">
   <span class="MathJax" id="MathJax-Element-2-Frame">
    <nobr>
     <span class="math" id="MathJax-Span-61" style="width: 10.897em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.837em; height: 0px; font-size: 123%;"><span style="position: absolute; clip: rect(0.545em 1000em 3.146em -0.485em); top: -2.274em; left: 0.003em;"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.111em;"></span></span><span class="mi" id="MathJax-Span-64" style="font-family: MathJax_Math-italic;">w</span><span class="mi" id="MathJax-Span-65" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-66" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-67" style="font-family: MathJax_Main; padding-left: 0.274em;">=</span><span class="mfrac" id="MathJax-Span-68" style="padding-left: 0.274em;"><span style="display: inline-block; position: relative; width: 4.881em; height: 0px; margin-right: 0.111em; margin-left: 0.111em;"><span style="position: absolute; clip: rect(1.304em 1000em 2.713em -0.431em); top: -3.033em; left: 50%; margin-left: -2.382em;"><span class="mrow" id="MathJax-Span-69"><span class="munderover" id="MathJax-Span-70"><span style="display: inline-block; position: relative; width: 2.225em; height: 0px;"><span style="position: absolute; clip: rect(1.412em 1000em 2.767em -0.431em); top: -2.328em; left: 0.003em;"><span class="mo" id="MathJax-Span-71" style="font-family: MathJax_Size1; vertical-align: 0.003em;">∑</span><span style="display: inline-block; width: 0px; height: 2.333em;"></span></span><span style="position: absolute; clip: rect(1.791em 1000em 2.442em -0.485em); top: -2.762em; left: 1.033em;"><span class="texatom" id="MathJax-Span-72"><span class="mrow" id="MathJax-Span-73"><span class="mi" id="MathJax-Span-74" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(1.629em 1000em 2.442em -0.485em); top: -2.003em; left: 1.033em;"><span class="texatom" id="MathJax-Span-75"><span class="mrow" id="MathJax-Span-76"><span class="mi" id="MathJax-Span-77" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mo" id="MathJax-Span-78" style="font-size: 70.7%; font-family: MathJax_Main;">=</span><span class="mn" id="MathJax-Span-79" style="font-size: 70.7%; font-family: MathJax_Main;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span><span class="mi" id="MathJax-Span-80" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">p</span><span class="mi" id="MathJax-Span-81" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-82" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-83" style="font-family: MathJax_Math-italic;">c</span><span class="msubsup" id="MathJax-Span-84"><span style="display: inline-block; position: relative; width: 0.707em; height: 0px;"><span style="position: absolute; clip: rect(1.683em 1000em 2.442em -0.431em); top: -2.274em; left: 0.003em;"><span class="mi" id="MathJax-Span-85" style="font-family: MathJax_Math-italic;">e</span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; top: -2.111em; left: 0.436em;"><span class="texatom" id="MathJax-Span-86"><span class="mrow" id="MathJax-Span-87"><span class="mi" id="MathJax-Span-88" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(1.683em 1000em 2.442em -0.485em); top: -1.569em; left: 50%; margin-left: -0.268em;"><span class="mi" id="MathJax-Span-89" style="font-family: MathJax_Math-italic;">n</span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; clip: rect(0.87em 1000em 1.249em -0.485em); top: -1.298em; left: 0.003em;"><span style="border-left: 4.881em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.087em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 2.937em; vertical-align: -0.93em;"></span></span>
    </nobr></span>
  </div>
  <script type="math/tex; mode=display" id="MathJax-Element-2">Twap = \frac{\sum_{i = 1} ^ {n}price_{i}}{n}</script> 
  <br> TWAP不考虑交易量的因素。TWAP的基准是交易时段的平均价格，它试图付出比此时段内平均买卖差价小的代价执行一个大订单。TWAP模型设计的目的是使交易对市场影响减小的同时提供一个较低的平均成交价格，从而达到减小交易成本的目的。在分时成交量无法准确估计的情况下，该模型可以较好地实现算法交易的基本目的。但是使用TWAP过程中的一个问题是，在订单规模很大的情况下，均匀分配到每个节点上的下单量仍然较大，当市场流动性不足时仍可能对市场造成一定的冲击。另一方面，真实市场的成交量总是在波动变化的，将所有的订单均匀分配到每个节点上显然是不够合理的。因此，算法交易研究人员很快建立了基于成交量变动预测的VWAP 模型。不过，由于TWAP 操作和理解起来非常简单，因此其对于流动性较好的市场和订单规模较小的交易仍然适用。
  <p></p> 
  <h1 id="代码实现">代码实现</h1> 
  <p>以A股 平安银行 的股票某一天的分钟线行情为例，分别用C++和python实现twap和vwap的求解。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170601220915361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzNDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>在实际的交易系统中，将得到的价格分不同时段将大单拆成小单挂单交易，以下是twap和vwap计算的简单实现</p> 
  <p><strong>C++</strong></p> 
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// calculate vwap value</span>
<span class="hljs-keyword">double</span> calc_vwap(<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&gt;</span> &amp;marketDataTable)
{
    <span class="hljs-keyword">int</span> n = marketDataTable.size() - <span class="hljs-number">1</span>; <span class="hljs-comment">// skip the first title line</span>
    <span class="hljs-keyword">double</span> total_sum = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">int</span> volume_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    {
        <span class="hljs-comment">// get the price and volume according to table structure</span>
        <span class="hljs-keyword">double</span> high_price = atof(marketDataTable[i][<span class="hljs-number">9</span>].c_str());
        <span class="hljs-keyword">double</span> low_price = atof(marketDataTable[i][<span class="hljs-number">10</span>].c_str());
        <span class="hljs-keyword">double</span> price = (high_price + low_price) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> volume = atoi(marketDataTable[i][<span class="hljs-number">11</span>].c_str());
        <span class="hljs-comment">// compute total sum and volume sum</span>
        total_sum += price * volume;
        volume_sum += volume;
    }

    <span class="hljs-keyword">return</span> total_sum / volume_sum;
}

<span class="hljs-comment">// calculate twap value</span>
<span class="hljs-keyword">double</span> calc_twap(<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span>&gt;</span> &amp;marketDataTable)
{
    <span class="hljs-keyword">int</span> n = marketDataTable.size() - <span class="hljs-number">1</span>; <span class="hljs-comment">// skip the first title line</span>
    <span class="hljs-keyword">double</span> price_sum = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    {
        <span class="hljs-comment">// get the price and volume according to table structure</span>
        <span class="hljs-keyword">double</span> high_price = atof(marketDataTable[i][<span class="hljs-number">9</span>].c_str());
        <span class="hljs-keyword">double</span> low_price = atof(marketDataTable[i][<span class="hljs-number">10</span>].c_str());
        <span class="hljs-keyword">double</span> price = (high_price + low_price) / <span class="hljs-number">2</span>;
        <span class="hljs-comment">// compute price sum and time sum</span>
        <span class="hljs-comment">// here use the 1 min K-line data, so total time is n minutes</span>
        price_sum += price;
    }

    <span class="hljs-keyword">return</span> price_sum / n;
}</code></pre> 
  <p><strong>python</strong></p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># calculate vwap value</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_vwap</span><span class="hljs-params">(marketDataTable)</span>:</span>
    n = len(marketDataTable) - <span class="hljs-number">1</span>
    total_sum = <span class="hljs-number">0.0</span>
    volume_sum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        high_price = float(marketDataTable[i][<span class="hljs-number">9</span>])
        low_price = float(marketDataTable[i][<span class="hljs-number">10</span>])
        price = (high_price + low_price) / <span class="hljs-number">2</span>
        volume = int(marketDataTable[i][<span class="hljs-number">11</span>])
        total_sum += price * volume
        volume_sum += volume

    <span class="hljs-keyword">return</span> total_sum / volume_sum

<span class="hljs-comment"># calculate vwap value</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_twap</span><span class="hljs-params">(marketDataTable)</span>:</span>
    n = len(marketDataTable) - <span class="hljs-number">1</span>
    price_sum = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        high_price = float(marketDataTable[i][<span class="hljs-number">9</span>])
        low_price = float(marketDataTable[i][<span class="hljs-number">10</span>])
        price = (high_price + low_price) / <span class="hljs-number">2</span>
        price_sum += price

    <span class="hljs-keyword">return</span> price_sum / n</code></pre> 
  <p><strong>运行结果</strong></p> 
  <pre class="prettyprint"><code class=" hljs avrasm">reading market data
calculating TWAP <span class="hljs-keyword">and</span> VWAP
<span class="hljs-label">VWAP:</span> <span class="hljs-number">8.66789</span>
<span class="hljs-label">TWAP:</span> <span class="hljs-number">8.66475</span></code></pre> 
  <p><strong>完整demo下载</strong> <br> csdn: <a href="http://download.csdn.net/detail/u012234115/9859440" rel="nofollow">twap/vwap code</a> <br> github: <a href="https://github.com/tashaxing/TWAP_VWAP_code/" rel="nofollow">twap/vwap code</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012234115/article/details/72830003,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012234115/article/details/72830003,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
