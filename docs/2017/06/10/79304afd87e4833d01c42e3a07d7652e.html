<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链开发专题(真正的区块链定义) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链开发专题(真正的区块链定义)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="‘区块链爱好者（QQ：53016353）&nbsp;&nbsp; 真正的区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储真正的区块链元数据。区块被从后向前有序地链接在这个链条里，每个区块都指向前一个区块。真正的区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在其他区块之上。用栈来形象化表示区块依次堆叠这一概念后，我们便可以使用一些术语，例如：“高度”来表示区块与首区块之间的距离；以及“顶部”或“顶端”来表示最新添加的区块。 对每个区块头进行SHA256加密哈希，可生成一个哈希值。通过这个哈希值，可以识别出真正的区块链中的对应区块。同时，每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块（父区块）。也就是说，每个区块头都包含它的父区块哈希值。这样把每个真正的区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一个区块（创世区块）的链条。 虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的（父区块）哈希值。一个区块出现多个子区块的情况被称为“真正的区块链分叉”。真正的区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生（参见“8.10.1 真正的区块链分叉”）。最终，只有一个子区块会成为真正的区块链的一部分，同时解决了“真正的区块链分叉”的问题。尽管一个区块可能会有不止一个子区块，但每一区块只有一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。 由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值因此也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，等等以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是因为这样的重新计算需要耗费巨大的计算量，所以一个长真正的区块链的存在可以让真正的区块链的历史不可改变，这也是比特币安全性的一个关键特征。 你可以把真正的区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在真正的区块链里，最近的几个区块可能会由于真正的区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在真正的区块链中的位置越深，被改变的可能性就越小。在100个区块以后，真正的区块链已经足够稳定，这时coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的真正的区块链将变成确定的历史，永远不会改变。 7.2 区块结构 区块是一种被包含在公开账簿（真正的区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。表7-1描述了一个区块结构。 表7-1 区块结构 大小 字段 描述 4字节 区块大小 用字节表示的该字段之后的区块大小 80字节 区块头 组成区块头的几个字段 1-9 （可变整数） 交易计数器 交易的数量 可变的 交易 记录在区块里的交易信息 7.3 区块头 区块头由三组区块元数据组成。首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与真正的区块链中前一区块相连接。第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，详见第8章。第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。表7-2描述了区块头的数据结构。 表7-2 区块头结构 大小 字段 描述 4字节 版本 版本号，用于跟踪软件/协议的更新 32字节 父区块哈希值 引用真正的区块链中父区块的哈希值 32字节 Merkle根 该区块中交易的merkle树根的哈希值 4字节 时间戳 该区块产生的近似时间（精确到秒的Unix时间戳） 4字节 难度目标 该区块工作量证明算法的难度目标 4字节 Nonce 用于工作量证明算法的计数器 Nonce、难度目标和时间戳会用于挖矿过程，更多细节将在第8章讨论。 7.4 区块标识符：区块头哈希值和区块高度 区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。 请注意，区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为真正的区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。 第二种识别区块的方式是通过该区块在真正的区块链中的位置，即“区块高度（block height）”。第一个区块，其区块高度为0，和之前哈希值000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f所引用的区块为同一个区块。因此，区块可以通过两种方式被识别：区块哈希值或者区块高度。每一个随后被存储在第一个区块之上的区块在真正的区块链中都比前一区块“高”出一个位置，就像箱子一个接一个堆叠在其他箱子之上。2014年1月1日的区块高度大约是278,000，说明已经有278,000个区块被堆叠在2009年1月创建的第一个区块之上。 和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在真正的区块链里争夺同一位置。这种情况在“8.10.1 真正的区块链分叉”一节中有详细讨论。区块高度也不是区块数据结构的一部分，它并不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在真正的区块链里的位置（区块高度）。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。 &nbsp; 一个区块的区块哈希值总是能唯一地识别出一个特定区块。一个区块也总是有特定的区块高度。但是，一个特定的区块高度并不一定总是能唯一地识别出一个特定区块。更确切地说，两个或者更多数量的区块也许会为了区块中的一个位置而竞争。 7.5 创世区块 真正的区块链里的第一个区块创建于2009年，被称为创世区块。它是真正的区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。 因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的真正的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为真正的区块链的首区块，从而构建了一个安全的、可信的真正的区块链的根。 在chainparams.cpp里可以看到创世区块被编入到比特币核心客户端里。 创世区块的哈希值为： 0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 你可以在任何区块浏览网站搜索这个区块哈希值，如blockchain.info，你会发现一个用包含这个哈希值的链接来描述这一区块内容的页面： https://blockchain.info/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f https://blockexplorer.com/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 在命令行使用比特币核心客户端： $ bitcoindgetblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f{ &nbsp; &nbsp;&quot;hash&quot;:&quot;000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f&quot;, &nbsp; &nbsp;&quot;confirmations&quot;:308321, &nbsp; &nbsp;&quot;size&quot;:285, &nbsp; &nbsp;&quot;height&quot;:0, &nbsp; &nbsp;&quot;version&quot;:1, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;, &nbsp; &nbsp;&quot;tx&quot;:[&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;], &nbsp; &nbsp;&quot;time&quot;:1231006505, &nbsp; &nbsp;&quot;nonce&quot;:2083236893, &nbsp; &nbsp;&quot;bits&quot;:&quot;1d00ffff&quot;, &nbsp; &nbsp;&quot;difficulty&quot;:1.00000000, &nbsp; &nbsp;&quot;nextblockhash&quot;:&quot;00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048&quot;} 创世区块包含一个隐藏的信息。在其Coinbase交易的输入中包含这样一句话“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题，引用这句话，既是对该区块产生时间的说明，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，同时告诉人们随着比特币的发展，一场前所未有的世界性货币革命将要发生。该消息是由比特币的创立者中本聪嵌入创世区块中。 7.6 区块的连接 比特币的完整节点保存了真正的区块链从创世区块起的一个本地副本。随着新的区块的产生，该真正的区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的真正的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。 让我们假设，例如，一个节点在真正的区块链的本地副本中有277,314个区块。该节点知道最后一个区块为第277,314个区块，这个区块的区块头哈希值为：00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249。 然后该比特币节点从网络上接收到一个新的区块，该区块描述如下： { &nbsp; &nbsp;&quot;size&quot;:43560, &nbsp; &nbsp;&quot;version&quot;:2, &nbsp; &nbsp;&quot;previousblockhash&quot;:&quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &nbsp; &nbsp;&quot;time&quot;:1388185038, &nbsp; &nbsp;&quot;difficulty&quot;:1180923195.25802612, &nbsp; &nbsp;&quot;nonce&quot;:4215469401, &nbsp; &nbsp;&quot;tx&quot;:[&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, &nbsp; &nbsp; &nbsp; &nbsp;#[...many more transactions omitted...] &nbsp; &nbsp; &nbsp; &nbsp;&quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; &nbsp; &nbsp;]} 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块的哈希值。这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块是这个链条里的最后一个区块的子区块，因此现有的真正的区块链得以扩展。节点将新的区块添加至链条的尾端，使真正的区块链变长到一个新的高度277,315。图7-1显示了通过“父区块哈希值”字段进行连接三个区块的链。 &nbsp; 图7-1 区块通过引用父区块的区块头哈希值的方式，以链条的形式进行相连 7.7 Merkle 树 真正的区块链中的每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。 Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。这种二叉树包含加密哈希值。术语“树”在计算机学科中常被用来描述一种具有分支的数据结构，但是树常常被倒置显示，“根”在图的上部同时“叶子”在图的下部，你会在后续章节中看到相应的例子。 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。 当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。 Merkle树是自底向上构建的。在如下的例子中，我们从A、B、C、D四个构成Merkle树树叶的交易开始，如图7-2。起始时所有的交易都还未存储在Merkle树中，而是先将数据哈希化，然后将哈希值存储至相应的叶子节点。这些叶子节点分别是HA、HB、HC和HD： H~A~ = SHA256(SHA256(交易A)) 通过串联相邻叶子节点的哈希值然后哈希之，这对叶子节点随后被归纳为父节点。 例如，为了创建父节点HAB，子节点A和子节点B的两个32字节的哈希值将被串联成64字节的字符串。随后将字符串进行两次哈希来产生父节点的哈希值: H~AB~=SHA256(SHA256(H~A~ + H~B~)) 继续类似的操作直到只剩下顶部的一个节点，即Merkle根。产生的32字节哈希值存储在区块头，同时归纳了四个交易的所有数据。 图7-2 在Merkle树中计算节点 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。如图7-3所示，C节点被复制了一份。 图7-3 复制一份数据节点，使整个树中数据节点个数是偶数 由四个交易构造Merkle树的方法同样适用于从任意交易数量构造Merkle树。在比特币中，在单个区块中有成百上千的交易是非常普遍的，这些交易都会采用同样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。在图7-4中，你会看见一个从16个交易形成的树。需要注意的是，尽管图中的根看起来比所有叶子节点都大，但实际上它们都是32字节的相同大小。无论区块中有一个交易或者有十万个交易，Merkle根总会把所有交易归纳为32字节。 图7-4 一颗囊括了许多数据元素的Merkle树 为了证明区块中存在某个特定的交易，一个节点只需要计算log2(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可。随着交易数量的急剧增加，这样的计算量就显得异常重要，因为相对于交易数量的增长，以基底为2的交易数量的对数的增长会缓慢许多。这使得比特币节点能够高效地产生一条10或者12个哈希值（320-384字节）的路径，来证明了在一个巨量字节大小的区块中上千交易中的某笔交易的存在。 在图7-5中，一个节点能够通过生成一条仅有4个32字节哈希值长度（总128字节）的Merkle路径，来证明区块中存在一笔交易K。该路径有4个哈希值（在图7-5中由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（在图中由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。 图7-5 一条为了证明树中包含某个数据元素而使用的Merkle路径 例7-1中的代码借用libbitcoin库中的一些辅助程序，演示了从叶子节点哈希至根创建整个Merkle树的过程。 例7-1 构造Merkle树 #include bc::hash_digest create_merkle(bc::hash_digest_list&amp; merkle){// Stop if hash list is empty. &nbsp; &nbsp;if (merkle.empty()) &nbsp; &nbsp; &nbsp; &nbsp;return bc::null_hash; &nbsp; &nbsp;else if (merkle.size() == 1) &nbsp; &nbsp; &nbsp; &nbsp;return merkle[0]; &nbsp; &nbsp; // While there is more than 1 hash in the list, keep looping… &nbsp; &nbsp;while (merkle.size() &gt; 1) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;// If number of hashes is odd, duplicate last hash in the list. &nbsp; &nbsp; &nbsp; &nbsp;if (merkle.size() % 2 != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;merkle.push_back(merkle.back()); &nbsp; &nbsp; &nbsp; &nbsp;// List size is now even. &nbsp; &nbsp; &nbsp; &nbsp;assert(merkle.size() % 2 == 0); &nbsp; &nbsp; &nbsp; &nbsp;// New hash list. &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest_list new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// Loop through hashes 2 at a time. &nbsp; &nbsp; &nbsp; &nbsp;for (auto it = merkle.begin(); it != merkle.end(); it += 2) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Join both current hashes together (concatenate). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::data_chunk concat_data(bc::hash_size * 2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto concat = bc::make_serializer(concat_data.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*it); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*(it + 1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assert(concat.iterator() == concat_data.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Hash both of the hashes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest new_root = bc::bitcoin_hash(concat_data); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add this to the new list. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_merkle.push_back(new_root); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;// This is the new list. &nbsp; &nbsp; &nbsp; &nbsp;merkle = new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// DEBUG output ------------------------------------- &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot;Current merkle hash list:&quot; &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;for (const auto&amp; hash: merkle) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot; &quot; &lt;&lt; bc::encode_hex(hash) &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;// -------------------------------------------------- &nbsp; &nbsp;} &nbsp; &nbsp;// Finally we end up with a single item. &nbsp; &nbsp;return merkle[0]; }int main(){ &nbsp; &nbsp;// Replace these hashes with ones from a block to reproduce the same merkle root. &nbsp; &nbsp;bc::hash_digest_list tx_hashes{ &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000011&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000022&quot;), &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;}; &nbsp; &nbsp;const bc::hash_digest merkle_root = create_merkle(tx_hashes); &nbsp; &nbsp;std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; bc::encode_hex(merkle_root) &lt;&lt; std::endl; &nbsp; &nbsp;return 0;} 例7-2展示了编译以及运行上述代码后的结果。 例7-2 编译以及运行构造Merkle树代码 $ # Compile the merkle.cpp code$ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable$ ./merkleCurrent merkle hash list:32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d2700630861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4Current merkle hash list: &nbsp; &nbsp;d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 Merkle树的高效随着交易规模的增加而变得异常明显。表7-3展示了为了证明区块中存在某交易而所需转化为Merkle路径的数据量。 表7-3 Merkle树的效率 交易数量 区块的近似大小 路径大小（哈希数量） 路径大小（字节） 16笔交易 4KB 4个哈希 128字节 512笔交易 128KB 9个哈希 288字节 2048笔交易 512KB 11个哈希 352字节 65,535笔交易 16MB 16个哈希 512字节 依表可得，当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，为证明交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。有了Merkle树，一个节点能够仅下载区块头（80字节/区块），然后通过从一个满节点回溯一条小的Merkle路径就能认证一笔交易的存在，而不需要存储或者传输大量真正的区块链中大多数内容，这些内容可能有几个G的大小。这种不需要维护一条完整的真正的区块链的节点，又被称作简单支付验证（SPV）节点，它不需要下载整个区块而通过Merkle路径去验证交易的存在。 7.8 Merkle树和简单支付验证（SPV） Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。 例如，一个SPV节点欲知它钱包中某个比特币地址即将到达的支付，该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkle区块消息的形式发送该区块。Merkle区块消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和真正的区块链中的区域区块。这两种关联，交易与区块、区块和真正的区块链，证明交易存在于真正的区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千倍有余。 阅读更多" />
<meta property="og:description" content="‘区块链爱好者（QQ：53016353）&nbsp;&nbsp; 真正的区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储真正的区块链元数据。区块被从后向前有序地链接在这个链条里，每个区块都指向前一个区块。真正的区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在其他区块之上。用栈来形象化表示区块依次堆叠这一概念后，我们便可以使用一些术语，例如：“高度”来表示区块与首区块之间的距离；以及“顶部”或“顶端”来表示最新添加的区块。 对每个区块头进行SHA256加密哈希，可生成一个哈希值。通过这个哈希值，可以识别出真正的区块链中的对应区块。同时，每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块（父区块）。也就是说，每个区块头都包含它的父区块哈希值。这样把每个真正的区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一个区块（创世区块）的链条。 虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的（父区块）哈希值。一个区块出现多个子区块的情况被称为“真正的区块链分叉”。真正的区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生（参见“8.10.1 真正的区块链分叉”）。最终，只有一个子区块会成为真正的区块链的一部分，同时解决了“真正的区块链分叉”的问题。尽管一个区块可能会有不止一个子区块，但每一区块只有一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。 由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值因此也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，等等以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是因为这样的重新计算需要耗费巨大的计算量，所以一个长真正的区块链的存在可以让真正的区块链的历史不可改变，这也是比特币安全性的一个关键特征。 你可以把真正的区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在真正的区块链里，最近的几个区块可能会由于真正的区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在真正的区块链中的位置越深，被改变的可能性就越小。在100个区块以后，真正的区块链已经足够稳定，这时coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的真正的区块链将变成确定的历史，永远不会改变。 7.2 区块结构 区块是一种被包含在公开账簿（真正的区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。表7-1描述了一个区块结构。 表7-1 区块结构 大小 字段 描述 4字节 区块大小 用字节表示的该字段之后的区块大小 80字节 区块头 组成区块头的几个字段 1-9 （可变整数） 交易计数器 交易的数量 可变的 交易 记录在区块里的交易信息 7.3 区块头 区块头由三组区块元数据组成。首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与真正的区块链中前一区块相连接。第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，详见第8章。第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。表7-2描述了区块头的数据结构。 表7-2 区块头结构 大小 字段 描述 4字节 版本 版本号，用于跟踪软件/协议的更新 32字节 父区块哈希值 引用真正的区块链中父区块的哈希值 32字节 Merkle根 该区块中交易的merkle树根的哈希值 4字节 时间戳 该区块产生的近似时间（精确到秒的Unix时间戳） 4字节 难度目标 该区块工作量证明算法的难度目标 4字节 Nonce 用于工作量证明算法的计数器 Nonce、难度目标和时间戳会用于挖矿过程，更多细节将在第8章讨论。 7.4 区块标识符：区块头哈希值和区块高度 区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。 请注意，区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为真正的区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。 第二种识别区块的方式是通过该区块在真正的区块链中的位置，即“区块高度（block height）”。第一个区块，其区块高度为0，和之前哈希值000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f所引用的区块为同一个区块。因此，区块可以通过两种方式被识别：区块哈希值或者区块高度。每一个随后被存储在第一个区块之上的区块在真正的区块链中都比前一区块“高”出一个位置，就像箱子一个接一个堆叠在其他箱子之上。2014年1月1日的区块高度大约是278,000，说明已经有278,000个区块被堆叠在2009年1月创建的第一个区块之上。 和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在真正的区块链里争夺同一位置。这种情况在“8.10.1 真正的区块链分叉”一节中有详细讨论。区块高度也不是区块数据结构的一部分，它并不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在真正的区块链里的位置（区块高度）。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。 &nbsp; 一个区块的区块哈希值总是能唯一地识别出一个特定区块。一个区块也总是有特定的区块高度。但是，一个特定的区块高度并不一定总是能唯一地识别出一个特定区块。更确切地说，两个或者更多数量的区块也许会为了区块中的一个位置而竞争。 7.5 创世区块 真正的区块链里的第一个区块创建于2009年，被称为创世区块。它是真正的区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。 因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的真正的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为真正的区块链的首区块，从而构建了一个安全的、可信的真正的区块链的根。 在chainparams.cpp里可以看到创世区块被编入到比特币核心客户端里。 创世区块的哈希值为： 0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 你可以在任何区块浏览网站搜索这个区块哈希值，如blockchain.info，你会发现一个用包含这个哈希值的链接来描述这一区块内容的页面： https://blockchain.info/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f https://blockexplorer.com/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 在命令行使用比特币核心客户端： $ bitcoindgetblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f{ &nbsp; &nbsp;&quot;hash&quot;:&quot;000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f&quot;, &nbsp; &nbsp;&quot;confirmations&quot;:308321, &nbsp; &nbsp;&quot;size&quot;:285, &nbsp; &nbsp;&quot;height&quot;:0, &nbsp; &nbsp;&quot;version&quot;:1, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;, &nbsp; &nbsp;&quot;tx&quot;:[&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;], &nbsp; &nbsp;&quot;time&quot;:1231006505, &nbsp; &nbsp;&quot;nonce&quot;:2083236893, &nbsp; &nbsp;&quot;bits&quot;:&quot;1d00ffff&quot;, &nbsp; &nbsp;&quot;difficulty&quot;:1.00000000, &nbsp; &nbsp;&quot;nextblockhash&quot;:&quot;00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048&quot;} 创世区块包含一个隐藏的信息。在其Coinbase交易的输入中包含这样一句话“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题，引用这句话，既是对该区块产生时间的说明，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，同时告诉人们随着比特币的发展，一场前所未有的世界性货币革命将要发生。该消息是由比特币的创立者中本聪嵌入创世区块中。 7.6 区块的连接 比特币的完整节点保存了真正的区块链从创世区块起的一个本地副本。随着新的区块的产生，该真正的区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的真正的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。 让我们假设，例如，一个节点在真正的区块链的本地副本中有277,314个区块。该节点知道最后一个区块为第277,314个区块，这个区块的区块头哈希值为：00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249。 然后该比特币节点从网络上接收到一个新的区块，该区块描述如下： { &nbsp; &nbsp;&quot;size&quot;:43560, &nbsp; &nbsp;&quot;version&quot;:2, &nbsp; &nbsp;&quot;previousblockhash&quot;:&quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &nbsp; &nbsp;&quot;time&quot;:1388185038, &nbsp; &nbsp;&quot;difficulty&quot;:1180923195.25802612, &nbsp; &nbsp;&quot;nonce&quot;:4215469401, &nbsp; &nbsp;&quot;tx&quot;:[&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, &nbsp; &nbsp; &nbsp; &nbsp;#[...many more transactions omitted...] &nbsp; &nbsp; &nbsp; &nbsp;&quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; &nbsp; &nbsp;]} 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块的哈希值。这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块是这个链条里的最后一个区块的子区块，因此现有的真正的区块链得以扩展。节点将新的区块添加至链条的尾端，使真正的区块链变长到一个新的高度277,315。图7-1显示了通过“父区块哈希值”字段进行连接三个区块的链。 &nbsp; 图7-1 区块通过引用父区块的区块头哈希值的方式，以链条的形式进行相连 7.7 Merkle 树 真正的区块链中的每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。 Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。这种二叉树包含加密哈希值。术语“树”在计算机学科中常被用来描述一种具有分支的数据结构，但是树常常被倒置显示，“根”在图的上部同时“叶子”在图的下部，你会在后续章节中看到相应的例子。 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。 当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。 Merkle树是自底向上构建的。在如下的例子中，我们从A、B、C、D四个构成Merkle树树叶的交易开始，如图7-2。起始时所有的交易都还未存储在Merkle树中，而是先将数据哈希化，然后将哈希值存储至相应的叶子节点。这些叶子节点分别是HA、HB、HC和HD： H~A~ = SHA256(SHA256(交易A)) 通过串联相邻叶子节点的哈希值然后哈希之，这对叶子节点随后被归纳为父节点。 例如，为了创建父节点HAB，子节点A和子节点B的两个32字节的哈希值将被串联成64字节的字符串。随后将字符串进行两次哈希来产生父节点的哈希值: H~AB~=SHA256(SHA256(H~A~ + H~B~)) 继续类似的操作直到只剩下顶部的一个节点，即Merkle根。产生的32字节哈希值存储在区块头，同时归纳了四个交易的所有数据。 图7-2 在Merkle树中计算节点 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。如图7-3所示，C节点被复制了一份。 图7-3 复制一份数据节点，使整个树中数据节点个数是偶数 由四个交易构造Merkle树的方法同样适用于从任意交易数量构造Merkle树。在比特币中，在单个区块中有成百上千的交易是非常普遍的，这些交易都会采用同样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。在图7-4中，你会看见一个从16个交易形成的树。需要注意的是，尽管图中的根看起来比所有叶子节点都大，但实际上它们都是32字节的相同大小。无论区块中有一个交易或者有十万个交易，Merkle根总会把所有交易归纳为32字节。 图7-4 一颗囊括了许多数据元素的Merkle树 为了证明区块中存在某个特定的交易，一个节点只需要计算log2(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可。随着交易数量的急剧增加，这样的计算量就显得异常重要，因为相对于交易数量的增长，以基底为2的交易数量的对数的增长会缓慢许多。这使得比特币节点能够高效地产生一条10或者12个哈希值（320-384字节）的路径，来证明了在一个巨量字节大小的区块中上千交易中的某笔交易的存在。 在图7-5中，一个节点能够通过生成一条仅有4个32字节哈希值长度（总128字节）的Merkle路径，来证明区块中存在一笔交易K。该路径有4个哈希值（在图7-5中由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（在图中由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。 图7-5 一条为了证明树中包含某个数据元素而使用的Merkle路径 例7-1中的代码借用libbitcoin库中的一些辅助程序，演示了从叶子节点哈希至根创建整个Merkle树的过程。 例7-1 构造Merkle树 #include bc::hash_digest create_merkle(bc::hash_digest_list&amp; merkle){// Stop if hash list is empty. &nbsp; &nbsp;if (merkle.empty()) &nbsp; &nbsp; &nbsp; &nbsp;return bc::null_hash; &nbsp; &nbsp;else if (merkle.size() == 1) &nbsp; &nbsp; &nbsp; &nbsp;return merkle[0]; &nbsp; &nbsp; // While there is more than 1 hash in the list, keep looping… &nbsp; &nbsp;while (merkle.size() &gt; 1) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;// If number of hashes is odd, duplicate last hash in the list. &nbsp; &nbsp; &nbsp; &nbsp;if (merkle.size() % 2 != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;merkle.push_back(merkle.back()); &nbsp; &nbsp; &nbsp; &nbsp;// List size is now even. &nbsp; &nbsp; &nbsp; &nbsp;assert(merkle.size() % 2 == 0); &nbsp; &nbsp; &nbsp; &nbsp;// New hash list. &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest_list new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// Loop through hashes 2 at a time. &nbsp; &nbsp; &nbsp; &nbsp;for (auto it = merkle.begin(); it != merkle.end(); it += 2) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Join both current hashes together (concatenate). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::data_chunk concat_data(bc::hash_size * 2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto concat = bc::make_serializer(concat_data.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*it); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*(it + 1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assert(concat.iterator() == concat_data.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Hash both of the hashes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest new_root = bc::bitcoin_hash(concat_data); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add this to the new list. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_merkle.push_back(new_root); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;// This is the new list. &nbsp; &nbsp; &nbsp; &nbsp;merkle = new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// DEBUG output ------------------------------------- &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot;Current merkle hash list:&quot; &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;for (const auto&amp; hash: merkle) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot; &quot; &lt;&lt; bc::encode_hex(hash) &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;// -------------------------------------------------- &nbsp; &nbsp;} &nbsp; &nbsp;// Finally we end up with a single item. &nbsp; &nbsp;return merkle[0]; }int main(){ &nbsp; &nbsp;// Replace these hashes with ones from a block to reproduce the same merkle root. &nbsp; &nbsp;bc::hash_digest_list tx_hashes{ &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000011&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000022&quot;), &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;}; &nbsp; &nbsp;const bc::hash_digest merkle_root = create_merkle(tx_hashes); &nbsp; &nbsp;std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; bc::encode_hex(merkle_root) &lt;&lt; std::endl; &nbsp; &nbsp;return 0;} 例7-2展示了编译以及运行上述代码后的结果。 例7-2 编译以及运行构造Merkle树代码 $ # Compile the merkle.cpp code$ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable$ ./merkleCurrent merkle hash list:32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d2700630861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4Current merkle hash list: &nbsp; &nbsp;d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 Merkle树的高效随着交易规模的增加而变得异常明显。表7-3展示了为了证明区块中存在某交易而所需转化为Merkle路径的数据量。 表7-3 Merkle树的效率 交易数量 区块的近似大小 路径大小（哈希数量） 路径大小（字节） 16笔交易 4KB 4个哈希 128字节 512笔交易 128KB 9个哈希 288字节 2048笔交易 512KB 11个哈希 352字节 65,535笔交易 16MB 16个哈希 512字节 依表可得，当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，为证明交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。有了Merkle树，一个节点能够仅下载区块头（80字节/区块），然后通过从一个满节点回溯一条小的Merkle路径就能认证一笔交易的存在，而不需要存储或者传输大量真正的区块链中大多数内容，这些内容可能有几个G的大小。这种不需要维护一条完整的真正的区块链的节点，又被称作简单支付验证（SPV）节点，它不需要下载整个区块而通过Merkle路径去验证交易的存在。 7.8 Merkle树和简单支付验证（SPV） Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。 例如，一个SPV节点欲知它钱包中某个比特币地址即将到达的支付，该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkle区块消息的形式发送该区块。Merkle区块消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和真正的区块链中的区域区块。这两种关联，交易与区块、区块和真正的区块链，证明交易存在于真正的区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千倍有余。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/06/10/79304afd87e4833d01c42e3a07d7652e.html" />
<meta property="og:url" content="https://mlh.app/2017/06/10/79304afd87e4833d01c42e3a07d7652e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"‘区块链爱好者（QQ：53016353）&nbsp;&nbsp; 真正的区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储真正的区块链元数据。区块被从后向前有序地链接在这个链条里，每个区块都指向前一个区块。真正的区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在其他区块之上。用栈来形象化表示区块依次堆叠这一概念后，我们便可以使用一些术语，例如：“高度”来表示区块与首区块之间的距离；以及“顶部”或“顶端”来表示最新添加的区块。 对每个区块头进行SHA256加密哈希，可生成一个哈希值。通过这个哈希值，可以识别出真正的区块链中的对应区块。同时，每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块（父区块）。也就是说，每个区块头都包含它的父区块哈希值。这样把每个真正的区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一个区块（创世区块）的链条。 虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的（父区块）哈希值。一个区块出现多个子区块的情况被称为“真正的区块链分叉”。真正的区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生（参见“8.10.1 真正的区块链分叉”）。最终，只有一个子区块会成为真正的区块链的一部分，同时解决了“真正的区块链分叉”的问题。尽管一个区块可能会有不止一个子区块，但每一区块只有一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。 由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值因此也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，等等以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是因为这样的重新计算需要耗费巨大的计算量，所以一个长真正的区块链的存在可以让真正的区块链的历史不可改变，这也是比特币安全性的一个关键特征。 你可以把真正的区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在真正的区块链里，最近的几个区块可能会由于真正的区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在真正的区块链中的位置越深，被改变的可能性就越小。在100个区块以后，真正的区块链已经足够稳定，这时coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的真正的区块链将变成确定的历史，永远不会改变。 7.2 区块结构 区块是一种被包含在公开账簿（真正的区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。表7-1描述了一个区块结构。 表7-1 区块结构 大小 字段 描述 4字节 区块大小 用字节表示的该字段之后的区块大小 80字节 区块头 组成区块头的几个字段 1-9 （可变整数） 交易计数器 交易的数量 可变的 交易 记录在区块里的交易信息 7.3 区块头 区块头由三组区块元数据组成。首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与真正的区块链中前一区块相连接。第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，详见第8章。第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。表7-2描述了区块头的数据结构。 表7-2 区块头结构 大小 字段 描述 4字节 版本 版本号，用于跟踪软件/协议的更新 32字节 父区块哈希值 引用真正的区块链中父区块的哈希值 32字节 Merkle根 该区块中交易的merkle树根的哈希值 4字节 时间戳 该区块产生的近似时间（精确到秒的Unix时间戳） 4字节 难度目标 该区块工作量证明算法的难度目标 4字节 Nonce 用于工作量证明算法的计数器 Nonce、难度目标和时间戳会用于挖矿过程，更多细节将在第8章讨论。 7.4 区块标识符：区块头哈希值和区块高度 区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。 请注意，区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为真正的区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。 第二种识别区块的方式是通过该区块在真正的区块链中的位置，即“区块高度（block height）”。第一个区块，其区块高度为0，和之前哈希值000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f所引用的区块为同一个区块。因此，区块可以通过两种方式被识别：区块哈希值或者区块高度。每一个随后被存储在第一个区块之上的区块在真正的区块链中都比前一区块“高”出一个位置，就像箱子一个接一个堆叠在其他箱子之上。2014年1月1日的区块高度大约是278,000，说明已经有278,000个区块被堆叠在2009年1月创建的第一个区块之上。 和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在真正的区块链里争夺同一位置。这种情况在“8.10.1 真正的区块链分叉”一节中有详细讨论。区块高度也不是区块数据结构的一部分，它并不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在真正的区块链里的位置（区块高度）。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。 &nbsp; 一个区块的区块哈希值总是能唯一地识别出一个特定区块。一个区块也总是有特定的区块高度。但是，一个特定的区块高度并不一定总是能唯一地识别出一个特定区块。更确切地说，两个或者更多数量的区块也许会为了区块中的一个位置而竞争。 7.5 创世区块 真正的区块链里的第一个区块创建于2009年，被称为创世区块。它是真正的区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。 因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的真正的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为真正的区块链的首区块，从而构建了一个安全的、可信的真正的区块链的根。 在chainparams.cpp里可以看到创世区块被编入到比特币核心客户端里。 创世区块的哈希值为： 0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 你可以在任何区块浏览网站搜索这个区块哈希值，如blockchain.info，你会发现一个用包含这个哈希值的链接来描述这一区块内容的页面： https://blockchain.info/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f https://blockexplorer.com/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 在命令行使用比特币核心客户端： $ bitcoindgetblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f{ &nbsp; &nbsp;&quot;hash&quot;:&quot;000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f&quot;, &nbsp; &nbsp;&quot;confirmations&quot;:308321, &nbsp; &nbsp;&quot;size&quot;:285, &nbsp; &nbsp;&quot;height&quot;:0, &nbsp; &nbsp;&quot;version&quot;:1, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;, &nbsp; &nbsp;&quot;tx&quot;:[&quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;], &nbsp; &nbsp;&quot;time&quot;:1231006505, &nbsp; &nbsp;&quot;nonce&quot;:2083236893, &nbsp; &nbsp;&quot;bits&quot;:&quot;1d00ffff&quot;, &nbsp; &nbsp;&quot;difficulty&quot;:1.00000000, &nbsp; &nbsp;&quot;nextblockhash&quot;:&quot;00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048&quot;} 创世区块包含一个隐藏的信息。在其Coinbase交易的输入中包含这样一句话“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题，引用这句话，既是对该区块产生时间的说明，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，同时告诉人们随着比特币的发展，一场前所未有的世界性货币革命将要发生。该消息是由比特币的创立者中本聪嵌入创世区块中。 7.6 区块的连接 比特币的完整节点保存了真正的区块链从创世区块起的一个本地副本。随着新的区块的产生，该真正的区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的真正的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。 让我们假设，例如，一个节点在真正的区块链的本地副本中有277,314个区块。该节点知道最后一个区块为第277,314个区块，这个区块的区块头哈希值为：00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249。 然后该比特币节点从网络上接收到一个新的区块，该区块描述如下： { &nbsp; &nbsp;&quot;size&quot;:43560, &nbsp; &nbsp;&quot;version&quot;:2, &nbsp; &nbsp;&quot;previousblockhash&quot;:&quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &nbsp; &nbsp;&quot;merkleroot&quot;:&quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &nbsp; &nbsp;&quot;time&quot;:1388185038, &nbsp; &nbsp;&quot;difficulty&quot;:1180923195.25802612, &nbsp; &nbsp;&quot;nonce&quot;:4215469401, &nbsp; &nbsp;&quot;tx&quot;:[&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, &nbsp; &nbsp; &nbsp; &nbsp;#[...many more transactions omitted...] &nbsp; &nbsp; &nbsp; &nbsp;&quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; &nbsp; &nbsp;]} 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块的哈希值。这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块是这个链条里的最后一个区块的子区块，因此现有的真正的区块链得以扩展。节点将新的区块添加至链条的尾端，使真正的区块链变长到一个新的高度277,315。图7-1显示了通过“父区块哈希值”字段进行连接三个区块的链。 &nbsp; 图7-1 区块通过引用父区块的区块头哈希值的方式，以链条的形式进行相连 7.7 Merkle 树 真正的区块链中的每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。 Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。这种二叉树包含加密哈希值。术语“树”在计算机学科中常被用来描述一种具有分支的数据结构，但是树常常被倒置显示，“根”在图的上部同时“叶子”在图的下部，你会在后续章节中看到相应的例子。 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。 当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。 Merkle树是自底向上构建的。在如下的例子中，我们从A、B、C、D四个构成Merkle树树叶的交易开始，如图7-2。起始时所有的交易都还未存储在Merkle树中，而是先将数据哈希化，然后将哈希值存储至相应的叶子节点。这些叶子节点分别是HA、HB、HC和HD： H~A~ = SHA256(SHA256(交易A)) 通过串联相邻叶子节点的哈希值然后哈希之，这对叶子节点随后被归纳为父节点。 例如，为了创建父节点HAB，子节点A和子节点B的两个32字节的哈希值将被串联成64字节的字符串。随后将字符串进行两次哈希来产生父节点的哈希值: H~AB~=SHA256(SHA256(H~A~ + H~B~)) 继续类似的操作直到只剩下顶部的一个节点，即Merkle根。产生的32字节哈希值存储在区块头，同时归纳了四个交易的所有数据。 图7-2 在Merkle树中计算节点 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。如图7-3所示，C节点被复制了一份。 图7-3 复制一份数据节点，使整个树中数据节点个数是偶数 由四个交易构造Merkle树的方法同样适用于从任意交易数量构造Merkle树。在比特币中，在单个区块中有成百上千的交易是非常普遍的，这些交易都会采用同样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。在图7-4中，你会看见一个从16个交易形成的树。需要注意的是，尽管图中的根看起来比所有叶子节点都大，但实际上它们都是32字节的相同大小。无论区块中有一个交易或者有十万个交易，Merkle根总会把所有交易归纳为32字节。 图7-4 一颗囊括了许多数据元素的Merkle树 为了证明区块中存在某个特定的交易，一个节点只需要计算log2(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可。随着交易数量的急剧增加，这样的计算量就显得异常重要，因为相对于交易数量的增长，以基底为2的交易数量的对数的增长会缓慢许多。这使得比特币节点能够高效地产生一条10或者12个哈希值（320-384字节）的路径，来证明了在一个巨量字节大小的区块中上千交易中的某笔交易的存在。 在图7-5中，一个节点能够通过生成一条仅有4个32字节哈希值长度（总128字节）的Merkle路径，来证明区块中存在一笔交易K。该路径有4个哈希值（在图7-5中由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（在图中由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。 图7-5 一条为了证明树中包含某个数据元素而使用的Merkle路径 例7-1中的代码借用libbitcoin库中的一些辅助程序，演示了从叶子节点哈希至根创建整个Merkle树的过程。 例7-1 构造Merkle树 #include bc::hash_digest create_merkle(bc::hash_digest_list&amp; merkle){// Stop if hash list is empty. &nbsp; &nbsp;if (merkle.empty()) &nbsp; &nbsp; &nbsp; &nbsp;return bc::null_hash; &nbsp; &nbsp;else if (merkle.size() == 1) &nbsp; &nbsp; &nbsp; &nbsp;return merkle[0]; &nbsp; &nbsp; // While there is more than 1 hash in the list, keep looping… &nbsp; &nbsp;while (merkle.size() &gt; 1) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;// If number of hashes is odd, duplicate last hash in the list. &nbsp; &nbsp; &nbsp; &nbsp;if (merkle.size() % 2 != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;merkle.push_back(merkle.back()); &nbsp; &nbsp; &nbsp; &nbsp;// List size is now even. &nbsp; &nbsp; &nbsp; &nbsp;assert(merkle.size() % 2 == 0); &nbsp; &nbsp; &nbsp; &nbsp;// New hash list. &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest_list new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// Loop through hashes 2 at a time. &nbsp; &nbsp; &nbsp; &nbsp;for (auto it = merkle.begin(); it != merkle.end(); it += 2) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Join both current hashes together (concatenate). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::data_chunk concat_data(bc::hash_size * 2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto concat = bc::make_serializer(concat_data.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*it); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*(it + 1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assert(concat.iterator() == concat_data.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Hash both of the hashes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest new_root = bc::bitcoin_hash(concat_data); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add this to the new list. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_merkle.push_back(new_root); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;// This is the new list. &nbsp; &nbsp; &nbsp; &nbsp;merkle = new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// DEBUG output ------------------------------------- &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot;Current merkle hash list:&quot; &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;for (const auto&amp; hash: merkle) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; &quot; &quot; &lt;&lt; bc::encode_hex(hash) &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;// -------------------------------------------------- &nbsp; &nbsp;} &nbsp; &nbsp;// Finally we end up with a single item. &nbsp; &nbsp;return merkle[0]; }int main(){ &nbsp; &nbsp;// Replace these hashes with ones from a block to reproduce the same merkle root. &nbsp; &nbsp;bc::hash_digest_list tx_hashes{ &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000011&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash(&quot;0000000000000000000000000000000000000000000000000000000000000022&quot;), &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;}; &nbsp; &nbsp;const bc::hash_digest merkle_root = create_merkle(tx_hashes); &nbsp; &nbsp;std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; bc::encode_hex(merkle_root) &lt;&lt; std::endl; &nbsp; &nbsp;return 0;} 例7-2展示了编译以及运行上述代码后的结果。 例7-2 编译以及运行构造Merkle树代码 $ # Compile the merkle.cpp code$ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable$ ./merkleCurrent merkle hash list:32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d2700630861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4Current merkle hash list: &nbsp; &nbsp;d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 Merkle树的高效随着交易规模的增加而变得异常明显。表7-3展示了为了证明区块中存在某交易而所需转化为Merkle路径的数据量。 表7-3 Merkle树的效率 交易数量 区块的近似大小 路径大小（哈希数量） 路径大小（字节） 16笔交易 4KB 4个哈希 128字节 512笔交易 128KB 9个哈希 288字节 2048笔交易 512KB 11个哈希 352字节 65,535笔交易 16MB 16个哈希 512字节 依表可得，当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，为证明交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。有了Merkle树，一个节点能够仅下载区块头（80字节/区块），然后通过从一个满节点回溯一条小的Merkle路径就能认证一笔交易的存在，而不需要存储或者传输大量真正的区块链中大多数内容，这些内容可能有几个G的大小。这种不需要维护一条完整的真正的区块链的节点，又被称作简单支付验证（SPV）节点，它不需要下载整个区块而通过Merkle路径去验证交易的存在。 7.8 Merkle树和简单支付验证（SPV） Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。 例如，一个SPV节点欲知它钱包中某个比特币地址即将到达的支付，该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkle区块消息的形式发送该区块。Merkle区块消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和真正的区块链中的区域区块。这两种关联，交易与区块、区块和真正的区块链，证明交易存在于真正的区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千倍有余。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/06/10/79304afd87e4833d01c42e3a07d7652e.html","headline":"区块链开发专题(真正的区块链定义)","dateModified":"2017-06-10T00:00:00+08:00","datePublished":"2017-06-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/06/10/79304afd87e4833d01c42e3a07d7652e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链开发专题(真正的区块链定义)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;">‘<span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353）&nbsp;&nbsp;</span></p> 
  <p>真正的区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储真正的区块链元数据。区块被从后向前有序地链接在这个链条里，每个区块都指向前一个区块。真正的区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在其他区块之上。用栈来形象化表示区块依次堆叠这一概念后，我们便可以使用一些术语，例如：“高度”来表示区块与首区块之间的距离；以及“顶部”或“顶端”来表示最新添加的区块。</p> 对每个区块头进行SHA256加密哈希，可生成一个哈希值。通过这个哈希值，可以识别出真正的区块链中的对应区块。同时，每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块（父区块）。也就是说，每个区块头都包含它的父区块哈希值。这样把每个真正的区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一个区块（创世区块）的链条。
  <br> 虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的（父区块）哈希值。一个区块出现多个子区块的情况被称为“真正的区块链分叉”。真正的区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生（参见“8.10.1 真正的区块链分叉”）。最终，只有一个子区块会成为真正的区块链的一部分，同时解决了“真正的区块链分叉”的问题。尽管一个区块可能会有不止一个子区块，但每一区块只有一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。
  <br> 由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值因此也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，等等以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是因为这样的重新计算需要耗费巨大的计算量，所以一个长真正的区块链的存在可以让真正的区块链的历史不可改变，这也是比特币安全性的一个关键特征。
  <br> 你可以把真正的区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在真正的区块链里，最近的几个区块可能会由于真正的区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在真正的区块链中的位置越深，被改变的可能性就越小。在100个区块以后，真正的区块链已经足够稳定，这时coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的真正的区块链将变成确定的历史，永远不会改变。
  <br> 7.2 区块结构
  <br> 区块是一种被包含在公开账簿（真正的区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。表7-1描述了一个区块结构。
  <br> 表7-1 区块结构
  <br> 大小
  <span> </span>字段
  <span> </span>描述
  <br> 4字节
  <span> </span>区块大小
  <span> </span> 用字节表示的该字段之后的区块大小
  <br> 80字节
  <span> </span>区块头
  <span> </span> 组成区块头的几个字段
  <br> 1-9 （可变整数）
  <span> </span>交易计数器
  <span> </span>交易的数量
  <br> 可变的
  <span> </span>交易
  <span> </span> 记录在区块里的交易信息
  <br> 7.3 区块头
  <br> 区块头由三组区块元数据组成。首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与真正的区块链中前一区块相连接。第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，详见第8章。第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。表7-2描述了区块头的数据结构。
  <br> 表7-2 区块头结构
  <br> 大小
  <span> </span>字段
  <span> </span>描述
  <br> 4字节
  <span> </span>版本
  <span> </span> 版本号，用于跟踪软件/协议的更新
  <br> 32字节
  <span> </span>父区块哈希值
  <span> </span> 引用真正的区块链中父区块的哈希值
  <br> 32字节
  <span> </span>Merkle根
  <span> </span> 该区块中交易的merkle树根的哈希值
  <br> 4字节
  <span> </span>时间戳
  <span> </span> 该区块产生的近似时间（精确到秒的Unix时间戳）
  <br> 4字节
  <span> </span>难度目标
  <span> </span> 该区块工作量证明算法的难度目标
  <br> 4字节
  <span> </span>Nonce
  <span> </span> 用于工作量证明算法的计数器
  <br> Nonce、难度目标和时间戳会用于挖矿过程，更多细节将在第8章讨论。
  <br> 7.4 区块标识符：区块头哈希值和区块高度
  <br> 区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。
  <br> 请注意，区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为真正的区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。
  <br> 第二种识别区块的方式是通过该区块在真正的区块链中的位置，即“区块高度（block height）”。第一个区块，其区块高度为0，和之前哈希值000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f所引用的区块为同一个区块。因此，区块可以通过两种方式被识别：区块哈希值或者区块高度。每一个随后被存储在第一个区块之上的区块在真正的区块链中都比前一区块“高”出一个位置，就像箱子一个接一个堆叠在其他箱子之上。2014年1月1日的区块高度大约是278,000，说明已经有278,000个区块被堆叠在2009年1月创建的第一个区块之上。
  <br> 和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在真正的区块链里争夺同一位置。这种情况在“8.10.1 真正的区块链分叉”一节中有详细讨论。区块高度也不是区块数据结构的一部分，它并不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在真正的区块链里的位置（区块高度）。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。
  <br> &nbsp;
  <br> 一个区块的区块哈希值总是能唯一地识别出一个特定区块。一个区块也总是有特定的区块高度。但是，一个特定的区块高度并不一定总是能唯一地识别出一个特定区块。更确切地说，两个或者更多数量的区块也许会为了区块中的一个位置而竞争。
  <br> 7.5 创世区块
  <br> 真正的区块链里的第一个区块创建于2009年，被称为创世区块。它是真正的区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。
  <br> 因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的真正的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为真正的区块链的首区块，从而构建了一个安全的、可信的真正的区块链的根。
  <br> 在chainparams.cpp里可以看到创世区块被编入到比特币核心客户端里。
  <br> 创世区块的哈希值为：
  <br> 0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
  <br> 你可以在任何区块浏览网站搜索这个区块哈希值，如blockchain.info，你会发现一个用包含这个哈希值的链接来描述这一区块内容的页面：
  <br> https://blockchain.info/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
  <br> https://blockexplorer.com/block/ 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
  <br> 在命令行使用比特币核心客户端：
  <br> $ bitcoindgetblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f{ &nbsp; &nbsp;"hash":"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", &nbsp; &nbsp;"confirmations":308321, &nbsp; &nbsp;"size":285, &nbsp; &nbsp;"height":0, &nbsp; &nbsp;"version":1, &nbsp; &nbsp;"merkleroot":"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", &nbsp; &nbsp;"tx":["4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"], &nbsp; &nbsp;"time":1231006505, &nbsp; &nbsp;"nonce":2083236893, &nbsp; &nbsp;"bits":"1d00ffff", &nbsp; &nbsp;"difficulty":1.00000000, &nbsp; &nbsp;"nextblockhash":"00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048"}
  <br> 创世区块包含一个隐藏的信息。在其Coinbase交易的输入中包含这样一句话“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题，引用这句话，既是对该区块产生时间的说明，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，同时告诉人们随着比特币的发展，一场前所未有的世界性货币革命将要发生。该消息是由比特币的创立者中本聪嵌入创世区块中。
  <br> 7.6 区块的连接
  <br> 比特币的完整节点保存了真正的区块链从创世区块起的一个本地副本。随着新的区块的产生，该真正的区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的真正的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。
  <br> 让我们假设，例如，一个节点在真正的区块链的本地副本中有277,314个区块。该节点知道最后一个区块为第277,314个区块，这个区块的区块头哈希值为：00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249。
  <br> 然后该比特币节点从网络上接收到一个新的区块，该区块描述如下：
  <br> { &nbsp; &nbsp;"size":43560, &nbsp; &nbsp;"version":2, &nbsp; &nbsp;"previousblockhash":"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249", &nbsp; &nbsp;"merkleroot":"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d", &nbsp; &nbsp;"time":1388185038, &nbsp; &nbsp;"difficulty":1180923195.25802612, &nbsp; &nbsp;"nonce":4215469401, &nbsp; &nbsp;"tx":["257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77", &nbsp; &nbsp; &nbsp; &nbsp;#[...many more transactions omitted...] &nbsp; &nbsp; &nbsp; &nbsp;"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634" &nbsp; &nbsp;]}
  <br> 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块的哈希值。这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块是这个链条里的最后一个区块的子区块，因此现有的真正的区块链得以扩展。节点将新的区块添加至链条的尾端，使真正的区块链变长到一个新的高度277,315。图7-1显示了通过“父区块哈希值”字段进行连接三个区块的链。
  <br> &nbsp;
  <br> 图7-1 区块通过引用父区块的区块头哈希值的方式，以链条的形式进行相连
  <br> 7.7 Merkle 树
  <br> 真正的区块链中的每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。
  <br> Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。这种二叉树包含加密哈希值。术语“树”在计算机学科中常被用来描述一种具有分支的数据结构，但是树常常被倒置显示，“根”在图的上部同时“叶子”在图的下部，你会在后续章节中看到相应的例子。
  <br> 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。
  <br> 当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。
  <br> Merkle树是自底向上构建的。在如下的例子中，我们从A、B、C、D四个构成Merkle树树叶的交易开始，如图7-2。起始时所有的交易都还未存储在Merkle树中，而是先将数据哈希化，然后将哈希值存储至相应的叶子节点。这些叶子节点分别是HA、HB、HC和HD：
  <br> H~A~ = SHA256(SHA256(交易A))
  <br> 通过串联相邻叶子节点的哈希值然后哈希之，这对叶子节点随后被归纳为父节点。 例如，为了创建父节点HAB，子节点A和子节点B的两个32字节的哈希值将被串联成64字节的字符串。随后将字符串进行两次哈希来产生父节点的哈希值:
  <br> H~AB~=SHA256(SHA256(H~A~ + H~B~))
  <br> 继续类似的操作直到只剩下顶部的一个节点，即Merkle根。产生的32字节哈希值存储在区块头，同时归纳了四个交易的所有数据。
  <br>
  <br>
  <br> 图7-2 在Merkle树中计算节点
  <br> 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。如图7-3所示，C节点被复制了一份。
  <br>
  <br>
  <br> 图7-3 复制一份数据节点，使整个树中数据节点个数是偶数
  <br> 由四个交易构造Merkle树的方法同样适用于从任意交易数量构造Merkle树。在比特币中，在单个区块中有成百上千的交易是非常普遍的，这些交易都会采用同样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。在图7-4中，你会看见一个从16个交易形成的树。需要注意的是，尽管图中的根看起来比所有叶子节点都大，但实际上它们都是32字节的相同大小。无论区块中有一个交易或者有十万个交易，Merkle根总会把所有交易归纳为32字节。
  <br>
  <br>
  <br> 图7-4 一颗囊括了许多数据元素的Merkle树
  <br> 为了证明区块中存在某个特定的交易，一个节点只需要计算log2(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可。随着交易数量的急剧增加，这样的计算量就显得异常重要，因为相对于交易数量的增长，以基底为2的交易数量的对数的增长会缓慢许多。这使得比特币节点能够高效地产生一条10或者12个哈希值（320-384字节）的路径，来证明了在一个巨量字节大小的区块中上千交易中的某笔交易的存在。
  <br> 在图7-5中，一个节点能够通过生成一条仅有4个32字节哈希值长度（总128字节）的Merkle路径，来证明区块中存在一笔交易K。该路径有4个哈希值（在图7-5中由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（在图中由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。
  <br>
  <br>
  <br> 图7-5 一条为了证明树中包含某个数据元素而使用的Merkle路径
  <br> 例7-1中的代码借用libbitcoin库中的一些辅助程序，演示了从叶子节点哈希至根创建整个Merkle树的过程。
  <br> 例7-1 构造Merkle树
  <br> #include bc::hash_digest create_merkle(bc::hash_digest_list&amp; merkle){// Stop if hash list is empty. &nbsp; &nbsp;if (merkle.empty()) &nbsp; &nbsp; &nbsp; &nbsp;return bc::null_hash; &nbsp; &nbsp;else if (merkle.size() == 1) &nbsp; &nbsp; &nbsp; &nbsp;return merkle[0]; &nbsp; &nbsp; // While there is more than 1 hash in the list, keep looping… &nbsp; &nbsp;while (merkle.size() &gt; 1) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;// If number of hashes is odd, duplicate last hash in the list. &nbsp; &nbsp; &nbsp; &nbsp;if (merkle.size() % 2 != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;merkle.push_back(merkle.back()); &nbsp; &nbsp; &nbsp; &nbsp;// List size is now even. &nbsp; &nbsp; &nbsp; &nbsp;assert(merkle.size() % 2 == 0); &nbsp; &nbsp; &nbsp; &nbsp;// New hash list. &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest_list new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// Loop through hashes 2 at a time. &nbsp; &nbsp; &nbsp; &nbsp;for (auto it = merkle.begin(); it != merkle.end(); it += 2) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Join both current hashes together (concatenate). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::data_chunk concat_data(bc::hash_size * 2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto concat = bc::make_serializer(concat_data.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*it); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;concat.write_hash(*(it + 1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assert(concat.iterator() == concat_data.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Hash both of the hashes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::hash_digest new_root = bc::bitcoin_hash(concat_data); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add this to the new list. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_merkle.push_back(new_root); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;// This is the new list. &nbsp; &nbsp; &nbsp; &nbsp;merkle = new_merkle; &nbsp; &nbsp; &nbsp; &nbsp;// DEBUG output ------------------------------------- &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; "Current merkle hash list:" &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;for (const auto&amp; hash: merkle) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; " " &lt;&lt; bc::encode_hex(hash) &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; std::endl; &nbsp; &nbsp; &nbsp; &nbsp;// -------------------------------------------------- &nbsp; &nbsp;} &nbsp; &nbsp;// Finally we end up with a single item. &nbsp; &nbsp;return merkle[0]; }int main(){ &nbsp; &nbsp;// Replace these hashes with ones from a block to reproduce the same merkle root. &nbsp; &nbsp;bc::hash_digest_list tx_hashes{ &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash("0000000000000000000000000000000000000000000000000000000000000000"), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash("0000000000000000000000000000000000000000000000000000000000000011"), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bc::decode_hash("0000000000000000000000000000000000000000000000000000000000000022"), &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;}; &nbsp; &nbsp;const bc::hash_digest merkle_root = create_merkle(tx_hashes); &nbsp; &nbsp;std::cout &lt;&lt; "Result: " &lt;&lt; bc::encode_hex(merkle_root) &lt;&lt; std::endl; &nbsp; &nbsp;return 0;}
  <br> 例7-2展示了编译以及运行上述代码后的结果。
  <br> 例7-2 编译以及运行构造Merkle树代码
  <br> $ # Compile the merkle.cpp code$ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable$ ./merkleCurrent merkle hash list:32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d2700630861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4Current merkle hash list: &nbsp; &nbsp;d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3
  <br> Merkle树的高效随着交易规模的增加而变得异常明显。表7-3展示了为了证明区块中存在某交易而所需转化为Merkle路径的数据量。
  <br> 表7-3 Merkle树的效率
  <br> 交易数量
  <span> </span>区块的近似大小
  <span> </span> 路径大小（哈希数量）
  <span> </span>路径大小（字节）
  <br> 16笔交易
  <span> </span>4KB
  <span> </span> 4个哈希
  <span> </span>128字节
  <br> 512笔交易
  <span> </span>128KB
  <span> </span> 9个哈希
  <span> </span>288字节
  <br> 2048笔交易
  <span> </span>512KB
  <span> </span> 11个哈希
  <span> </span>352字节
  <br> 65,535笔交易
  <span> </span>16MB
  <span> </span>16个哈希
  <span> </span>512字节
  <br> 依表可得，当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，为证明交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。有了Merkle树，一个节点能够仅下载区块头（80字节/区块），然后通过从一个满节点回溯一条小的Merkle路径就能认证一笔交易的存在，而不需要存储或者传输大量真正的区块链中大多数内容，这些内容可能有几个G的大小。这种不需要维护一条完整的真正的区块链的节点，又被称作简单支付验证（SPV）节点，它不需要下载整个区块而通过Merkle路径去验证交易的存在。
  <br> 7.8 Merkle树和简单支付验证（SPV）
  <br> Merkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。
  <br> 例如，一个SPV节点欲知它钱包中某个比特币地址即将到达的支付，该节点会在节点间的通信链接上建立起bloom过滤器，限制只接受含有目标比特币地址的交易。当节点探测到某交易符合bloom过滤器，它将以Merkle区块消息的形式发送该区块。Merkle区块消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的有无。SPV节点同时也使用区块头去关联区块和真正的区块链中的区域区块。这两种关联，交易与区块、区块和真正的区块链，证明交易存在于真正的区块链。简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千倍有余。 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/72986771,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/72986771,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
