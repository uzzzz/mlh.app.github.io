<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>虚拟币开发专题(山寨币怎样通过RPC命令实现区块浏览器) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="虚拟币开发专题(山寨币怎样通过RPC命令实现区块浏览器)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链爱好者（QQ：53016353） 基本架构如下： 前端web基于或者REST实现， 后端加一层mongodb/mysql等数据库来代替单机leveldb做数据存储 目的应该是： 1. 加速查询 2. 做更高层的数据分析 3.做分布式数据库 思考: 这些online的查询固然可以方便我们的日常用， 那如何与相关应用集成呢? 我们是否可以通过简单的rpc命令实现同等的效果? 有几个用处： 1 . 大家都可以做自己的qukuai.com或blockchain.info的查询：） 2. &nbsp;集成RPC命令到自己的店铺，收款后查询用 3. &nbsp;集成到钱包应用 4. &nbsp;其他应用场景 cmd分析： 根据高度height查block hash ./bitcoin-cli getblockhash 19999 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 2. 然后根据block hash查block 信息 ./bitcoin-cli getblock 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 { &nbsp; &nbsp; &quot;hash&quot; : &quot;00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124&quot;, &nbsp; &nbsp; &quot;confirmations&quot; : 263032, &nbsp; &nbsp; &quot;size&quot; : 215, &nbsp; &nbsp; &quot;height&quot; : 19999, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;merkleroot&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;tx&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot; &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;time&quot; : 1248291140, &nbsp; &nbsp; &quot;nonce&quot; : 1085206531, &nbsp; &nbsp; &quot;bits&quot; : &quot;1d00ffff&quot;, &nbsp; &nbsp; &quot;difficulty&quot; : 1.00000000, &nbsp; &nbsp; &quot;chainwork&quot; : &quot;00000000000000000000000000000000000000000000000000004e204e204e20&quot;, &nbsp; &nbsp; &quot;previousblockhash&quot; : &quot;000000006eb5c2799b0f5fafab6435daeecef8e7f609b731c9879c3f74f28c73&quot;, &nbsp; &nbsp; &quot;nextblockhash&quot; : &quot;00000000770ebe897270ca5f6d539d8afb4ea4f4e757761a34ca82e17207d886&quot; } 3. 根据tx查询单笔交易的信息： 没建index时，只能查询自己钱包的信息，若不是钱包的交易，则返回如下： ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 error: {&quot;code&quot;:-5,&quot;message&quot;:&quot;Invalid or non-wallet transaction id&quot;} 那怎么办呢? 直接分析代码找原因： // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock bool GetTransaction(const uint256 &amp;hash, CTransaction &amp;txOut, uint256 &amp;hashBlock, bool fAllowSlow) { &nbsp; &nbsp; CBlockIndex *pindexSlow = NULL; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; LOCK(cs_main); &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mempool.lookup(hash, txOut)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fTxIndex) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos postx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pblocktree-&gt;ReadTxIndex(hash, postx)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockHeader header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(file, postx.nTxOffset, SEEK_CUR); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; txOut; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (std::exception &amp;e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : Deserialize or I/O error - %s&quot;, __func__, e.what()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = header.GetHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txOut.GetHash() != hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : txid mismatch&quot;, __func__); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nHeight = -1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoinsViewCache &amp;view = *pcoinsTip; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoins coins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (view.GetCoins(hash, coins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nHeight = coins.nHeight; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nHeight &gt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexSlow = chainActive[nHeight]; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; if (pindexSlow) { &nbsp; &nbsp; &nbsp; &nbsp; CBlock block; &nbsp; &nbsp; &nbsp; &nbsp; if (ReadBlockFromDisk(block, pindexSlow)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOST_FOREACH(const CTransaction &amp;tx, block.vtx) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tx.GetHash() == hash) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txOut = tx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = pindexSlow-&gt;GetBlockHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return false; } 我们可以看出若fTxIndex为true，则可以直接搜索index获取block信息 通过-reindex -txindex建立索引，调用： ./bitcoind -reindex -txindex 这个过程在我的mac上跑了数个小时。。。。。。 -txindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maintain a full transaction index (default: 0) -reindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rebuild block chain index from current blk000??.dat files 再次查询 ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 解码交易数据 ./bitcoin-cli decoderawtransaction 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 { &nbsp; &nbsp; &quot;txid&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;locktime&quot; : 0, &nbsp; &nbsp; &quot;vin&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;coinbase&quot; : &quot;04ffff001d0168&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;sequence&quot; : 4294967295 &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;vout&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;value&quot; : 50.00000000, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;n&quot; : 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;scriptPubKey&quot; : { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;asm&quot; : &quot;04cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60 OP_CHECKSIG&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;hex&quot; : &quot;4104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;reqSigs&quot; : 1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;type&quot; : &quot;pubkey&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;addresses&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1KWj3Jk8xvS6fDdhQBsfmerscSGsS6CMiS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } } 以上过程基本满足了大部分的查询需求：输入交易ID、区块高度或哈希值（BTC） 至于通过&quot;地址&quot;查询，需要通过搜集这个地址对应的交易输入输出存入数据库 部分代码如下： function updateKeys($hash160,$pubkey,$blockhash) { &nbsp; &nbsp; &nbsp; &nbsp; global $db; &nbsp; &nbsp; &nbsp; &nbsp; $address=hash160ToAddress($hash160); &nbsp; &nbsp; &nbsp; &nbsp; $result=pg_fetch_assoc(pg_query_params($db,&quot;SELECT pubkey,encode(hash160,&#39;hex&#39;) AS hash160 FROM keys WHERE hash160=decode($1,&#39;hex&#39;)&quot;,array($hash160))); &nbsp; &nbsp; &nbsp; &nbsp; if(!$result &amp;&amp; !is_null($pubkey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;),decode($4,&#39;hex&#39;));&quot;,array($hash160,$address,$pubkey,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if(!$result) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys(hash160,address,firstseen) VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;));&quot;,array($hash160,$address,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if($result &amp;&amp; !is_null($pubkey) &amp;&amp; is_null($result[&quot;pubkey&quot;])) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($result[&quot;hash160&quot;]!=strtolower(hash160($pubkey))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep(10); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die(&quot;Hashes don&#39;t match&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;UPDATE keys SET pubkey = decode($1,&#39;hex&#39;) WHERE hash160=decode($2,&#39;hex&#39;);&quot;,array($pubkey,$hash160)); &nbsp; &nbsp; &nbsp; &nbsp; } } 案例分析：如何获取一笔交易的输入地址？（此case可用在获取打款地址上） 如何根据txid获取打款地址呢？其实可以基于blockchain的链式结构逆向推导 首先 gettransaction &nbsp;txid &nbsp; &nbsp; [vin] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [txid] =&gt; 63876d10a13f3810a1d568c6ac7154f9b8a590cfc91cf8a17756fb099addf2b5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [vout] =&gt; 1 获取到此次的tx得信息详细，根据vin里的txid逆向查找， txid二次查询，gettransaction &nbsp;vin-&gt;txid 然后根据vout索引得到输入address &nbsp; &nbsp; [vout] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [value] =&gt; 0.16928006 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [n] =&gt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [scriptPubKey] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [asm] =&gt; OP_DUP OP_HASH160 1715447427ac1cdfb7c5ba359154c37c5e9caa2b OP_EQUALVERIFY OP_CHECKSIG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [hex] =&gt; 76a9141715447427ac1cdfb7c5ba359154c37c5e9caa2b88ac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [reqSigs] =&gt; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [type] =&gt; pubkeyhash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [addresses] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; LML1HJvP8jfeiwgSVmYfNGsedYfDrzKmq3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) 阅读更多" />
<meta property="og:description" content="区块链爱好者（QQ：53016353） 基本架构如下： 前端web基于或者REST实现， 后端加一层mongodb/mysql等数据库来代替单机leveldb做数据存储 目的应该是： 1. 加速查询 2. 做更高层的数据分析 3.做分布式数据库 思考: 这些online的查询固然可以方便我们的日常用， 那如何与相关应用集成呢? 我们是否可以通过简单的rpc命令实现同等的效果? 有几个用处： 1 . 大家都可以做自己的qukuai.com或blockchain.info的查询：） 2. &nbsp;集成RPC命令到自己的店铺，收款后查询用 3. &nbsp;集成到钱包应用 4. &nbsp;其他应用场景 cmd分析： 根据高度height查block hash ./bitcoin-cli getblockhash 19999 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 2. 然后根据block hash查block 信息 ./bitcoin-cli getblock 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 { &nbsp; &nbsp; &quot;hash&quot; : &quot;00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124&quot;, &nbsp; &nbsp; &quot;confirmations&quot; : 263032, &nbsp; &nbsp; &quot;size&quot; : 215, &nbsp; &nbsp; &quot;height&quot; : 19999, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;merkleroot&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;tx&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot; &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;time&quot; : 1248291140, &nbsp; &nbsp; &quot;nonce&quot; : 1085206531, &nbsp; &nbsp; &quot;bits&quot; : &quot;1d00ffff&quot;, &nbsp; &nbsp; &quot;difficulty&quot; : 1.00000000, &nbsp; &nbsp; &quot;chainwork&quot; : &quot;00000000000000000000000000000000000000000000000000004e204e204e20&quot;, &nbsp; &nbsp; &quot;previousblockhash&quot; : &quot;000000006eb5c2799b0f5fafab6435daeecef8e7f609b731c9879c3f74f28c73&quot;, &nbsp; &nbsp; &quot;nextblockhash&quot; : &quot;00000000770ebe897270ca5f6d539d8afb4ea4f4e757761a34ca82e17207d886&quot; } 3. 根据tx查询单笔交易的信息： 没建index时，只能查询自己钱包的信息，若不是钱包的交易，则返回如下： ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 error: {&quot;code&quot;:-5,&quot;message&quot;:&quot;Invalid or non-wallet transaction id&quot;} 那怎么办呢? 直接分析代码找原因： // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock bool GetTransaction(const uint256 &amp;hash, CTransaction &amp;txOut, uint256 &amp;hashBlock, bool fAllowSlow) { &nbsp; &nbsp; CBlockIndex *pindexSlow = NULL; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; LOCK(cs_main); &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mempool.lookup(hash, txOut)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fTxIndex) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos postx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pblocktree-&gt;ReadTxIndex(hash, postx)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockHeader header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(file, postx.nTxOffset, SEEK_CUR); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; txOut; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (std::exception &amp;e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : Deserialize or I/O error - %s&quot;, __func__, e.what()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = header.GetHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txOut.GetHash() != hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : txid mismatch&quot;, __func__); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nHeight = -1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoinsViewCache &amp;view = *pcoinsTip; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoins coins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (view.GetCoins(hash, coins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nHeight = coins.nHeight; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nHeight &gt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexSlow = chainActive[nHeight]; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; if (pindexSlow) { &nbsp; &nbsp; &nbsp; &nbsp; CBlock block; &nbsp; &nbsp; &nbsp; &nbsp; if (ReadBlockFromDisk(block, pindexSlow)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOST_FOREACH(const CTransaction &amp;tx, block.vtx) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tx.GetHash() == hash) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txOut = tx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = pindexSlow-&gt;GetBlockHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return false; } 我们可以看出若fTxIndex为true，则可以直接搜索index获取block信息 通过-reindex -txindex建立索引，调用： ./bitcoind -reindex -txindex 这个过程在我的mac上跑了数个小时。。。。。。 -txindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maintain a full transaction index (default: 0) -reindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rebuild block chain index from current blk000??.dat files 再次查询 ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 解码交易数据 ./bitcoin-cli decoderawtransaction 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 { &nbsp; &nbsp; &quot;txid&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;locktime&quot; : 0, &nbsp; &nbsp; &quot;vin&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;coinbase&quot; : &quot;04ffff001d0168&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;sequence&quot; : 4294967295 &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;vout&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;value&quot; : 50.00000000, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;n&quot; : 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;scriptPubKey&quot; : { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;asm&quot; : &quot;04cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60 OP_CHECKSIG&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;hex&quot; : &quot;4104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;reqSigs&quot; : 1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;type&quot; : &quot;pubkey&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;addresses&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1KWj3Jk8xvS6fDdhQBsfmerscSGsS6CMiS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } } 以上过程基本满足了大部分的查询需求：输入交易ID、区块高度或哈希值（BTC） 至于通过&quot;地址&quot;查询，需要通过搜集这个地址对应的交易输入输出存入数据库 部分代码如下： function updateKeys($hash160,$pubkey,$blockhash) { &nbsp; &nbsp; &nbsp; &nbsp; global $db; &nbsp; &nbsp; &nbsp; &nbsp; $address=hash160ToAddress($hash160); &nbsp; &nbsp; &nbsp; &nbsp; $result=pg_fetch_assoc(pg_query_params($db,&quot;SELECT pubkey,encode(hash160,&#39;hex&#39;) AS hash160 FROM keys WHERE hash160=decode($1,&#39;hex&#39;)&quot;,array($hash160))); &nbsp; &nbsp; &nbsp; &nbsp; if(!$result &amp;&amp; !is_null($pubkey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;),decode($4,&#39;hex&#39;));&quot;,array($hash160,$address,$pubkey,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if(!$result) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys(hash160,address,firstseen) VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;));&quot;,array($hash160,$address,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if($result &amp;&amp; !is_null($pubkey) &amp;&amp; is_null($result[&quot;pubkey&quot;])) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($result[&quot;hash160&quot;]!=strtolower(hash160($pubkey))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep(10); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die(&quot;Hashes don&#39;t match&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;UPDATE keys SET pubkey = decode($1,&#39;hex&#39;) WHERE hash160=decode($2,&#39;hex&#39;);&quot;,array($pubkey,$hash160)); &nbsp; &nbsp; &nbsp; &nbsp; } } 案例分析：如何获取一笔交易的输入地址？（此case可用在获取打款地址上） 如何根据txid获取打款地址呢？其实可以基于blockchain的链式结构逆向推导 首先 gettransaction &nbsp;txid &nbsp; &nbsp; [vin] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [txid] =&gt; 63876d10a13f3810a1d568c6ac7154f9b8a590cfc91cf8a17756fb099addf2b5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [vout] =&gt; 1 获取到此次的tx得信息详细，根据vin里的txid逆向查找， txid二次查询，gettransaction &nbsp;vin-&gt;txid 然后根据vout索引得到输入address &nbsp; &nbsp; [vout] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [value] =&gt; 0.16928006 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [n] =&gt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [scriptPubKey] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [asm] =&gt; OP_DUP OP_HASH160 1715447427ac1cdfb7c5ba359154c37c5e9caa2b OP_EQUALVERIFY OP_CHECKSIG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [hex] =&gt; 76a9141715447427ac1cdfb7c5ba359154c37c5e9caa2b88ac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [reqSigs] =&gt; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [type] =&gt; pubkeyhash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [addresses] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; LML1HJvP8jfeiwgSVmYfNGsedYfDrzKmq3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链爱好者（QQ：53016353） 基本架构如下： 前端web基于或者REST实现， 后端加一层mongodb/mysql等数据库来代替单机leveldb做数据存储 目的应该是： 1. 加速查询 2. 做更高层的数据分析 3.做分布式数据库 思考: 这些online的查询固然可以方便我们的日常用， 那如何与相关应用集成呢? 我们是否可以通过简单的rpc命令实现同等的效果? 有几个用处： 1 . 大家都可以做自己的qukuai.com或blockchain.info的查询：） 2. &nbsp;集成RPC命令到自己的店铺，收款后查询用 3. &nbsp;集成到钱包应用 4. &nbsp;其他应用场景 cmd分析： 根据高度height查block hash ./bitcoin-cli getblockhash 19999 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 2. 然后根据block hash查block 信息 ./bitcoin-cli getblock 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124 { &nbsp; &nbsp; &quot;hash&quot; : &quot;00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124&quot;, &nbsp; &nbsp; &quot;confirmations&quot; : 263032, &nbsp; &nbsp; &quot;size&quot; : 215, &nbsp; &nbsp; &quot;height&quot; : 19999, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;merkleroot&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;tx&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot; &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;time&quot; : 1248291140, &nbsp; &nbsp; &quot;nonce&quot; : 1085206531, &nbsp; &nbsp; &quot;bits&quot; : &quot;1d00ffff&quot;, &nbsp; &nbsp; &quot;difficulty&quot; : 1.00000000, &nbsp; &nbsp; &quot;chainwork&quot; : &quot;00000000000000000000000000000000000000000000000000004e204e204e20&quot;, &nbsp; &nbsp; &quot;previousblockhash&quot; : &quot;000000006eb5c2799b0f5fafab6435daeecef8e7f609b731c9879c3f74f28c73&quot;, &nbsp; &nbsp; &quot;nextblockhash&quot; : &quot;00000000770ebe897270ca5f6d539d8afb4ea4f4e757761a34ca82e17207d886&quot; } 3. 根据tx查询单笔交易的信息： 没建index时，只能查询自己钱包的信息，若不是钱包的交易，则返回如下： ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 error: {&quot;code&quot;:-5,&quot;message&quot;:&quot;Invalid or non-wallet transaction id&quot;} 那怎么办呢? 直接分析代码找原因： // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock bool GetTransaction(const uint256 &amp;hash, CTransaction &amp;txOut, uint256 &amp;hashBlock, bool fAllowSlow) { &nbsp; &nbsp; CBlockIndex *pindexSlow = NULL; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; LOCK(cs_main); &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mempool.lookup(hash, txOut)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fTxIndex) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos postx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pblocktree-&gt;ReadTxIndex(hash, postx)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockHeader header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(file, postx.nTxOffset, SEEK_CUR); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; txOut; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (std::exception &amp;e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : Deserialize or I/O error - %s&quot;, __func__, e.what()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = header.GetHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txOut.GetHash() != hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;%s : txid mismatch&quot;, __func__); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nHeight = -1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoinsViewCache &amp;view = *pcoinsTip; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoins coins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (view.GetCoins(hash, coins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nHeight = coins.nHeight; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nHeight &gt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexSlow = chainActive[nHeight]; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; if (pindexSlow) { &nbsp; &nbsp; &nbsp; &nbsp; CBlock block; &nbsp; &nbsp; &nbsp; &nbsp; if (ReadBlockFromDisk(block, pindexSlow)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOST_FOREACH(const CTransaction &amp;tx, block.vtx) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tx.GetHash() == hash) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txOut = tx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = pindexSlow-&gt;GetBlockHash(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return false; } 我们可以看出若fTxIndex为true，则可以直接搜索index获取block信息 通过-reindex -txindex建立索引，调用： ./bitcoind -reindex -txindex 这个过程在我的mac上跑了数个小时。。。。。。 -txindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maintain a full transaction index (default: 0) -reindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rebuild block chain index from current blk000??.dat files 再次查询 ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 解码交易数据 ./bitcoin-cli decoderawtransaction 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000 { &nbsp; &nbsp; &quot;txid&quot; : &quot;c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98&quot;, &nbsp; &nbsp; &quot;version&quot; : 1, &nbsp; &nbsp; &quot;locktime&quot; : 0, &nbsp; &nbsp; &quot;vin&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;coinbase&quot; : &quot;04ffff001d0168&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;sequence&quot; : 4294967295 &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; ], &nbsp; &nbsp; &quot;vout&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;value&quot; : 50.00000000, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;n&quot; : 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;scriptPubKey&quot; : { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;asm&quot; : &quot;04cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60 OP_CHECKSIG&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;hex&quot; : &quot;4104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;reqSigs&quot; : 1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;type&quot; : &quot;pubkey&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;addresses&quot; : [ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1KWj3Jk8xvS6fDdhQBsfmerscSGsS6CMiS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } } 以上过程基本满足了大部分的查询需求：输入交易ID、区块高度或哈希值（BTC） 至于通过&quot;地址&quot;查询，需要通过搜集这个地址对应的交易输入输出存入数据库 部分代码如下： function updateKeys($hash160,$pubkey,$blockhash) { &nbsp; &nbsp; &nbsp; &nbsp; global $db; &nbsp; &nbsp; &nbsp; &nbsp; $address=hash160ToAddress($hash160); &nbsp; &nbsp; &nbsp; &nbsp; $result=pg_fetch_assoc(pg_query_params($db,&quot;SELECT pubkey,encode(hash160,&#39;hex&#39;) AS hash160 FROM keys WHERE hash160=decode($1,&#39;hex&#39;)&quot;,array($hash160))); &nbsp; &nbsp; &nbsp; &nbsp; if(!$result &amp;&amp; !is_null($pubkey)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;),decode($4,&#39;hex&#39;));&quot;,array($hash160,$address,$pubkey,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if(!$result) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;INSERT INTO keys(hash160,address,firstseen) VALUES (decode($1,&#39;hex&#39;),$2,decode($3,&#39;hex&#39;));&quot;,array($hash160,$address,$blockhash)); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; else if($result &amp;&amp; !is_null($pubkey) &amp;&amp; is_null($result[&quot;pubkey&quot;])) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($result[&quot;hash160&quot;]!=strtolower(hash160($pubkey))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep(10); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die(&quot;Hashes don&#39;t match&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, &quot;UPDATE keys SET pubkey = decode($1,&#39;hex&#39;) WHERE hash160=decode($2,&#39;hex&#39;);&quot;,array($pubkey,$hash160)); &nbsp; &nbsp; &nbsp; &nbsp; } } 案例分析：如何获取一笔交易的输入地址？（此case可用在获取打款地址上） 如何根据txid获取打款地址呢？其实可以基于blockchain的链式结构逆向推导 首先 gettransaction &nbsp;txid &nbsp; &nbsp; [vin] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [txid] =&gt; 63876d10a13f3810a1d568c6ac7154f9b8a590cfc91cf8a17756fb099addf2b5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [vout] =&gt; 1 获取到此次的tx得信息详细，根据vin里的txid逆向查找， txid二次查询，gettransaction &nbsp;vin-&gt;txid 然后根据vout索引得到输入address &nbsp; &nbsp; [vout] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [value] =&gt; 0.16928006 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [n] =&gt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [scriptPubKey] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [asm] =&gt; OP_DUP OP_HASH160 1715447427ac1cdfb7c5ba359154c37c5e9caa2b OP_EQUALVERIFY OP_CHECKSIG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [hex] =&gt; 76a9141715447427ac1cdfb7c5ba359154c37c5e9caa2b88ac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [reqSigs] =&gt; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [type] =&gt; pubkeyhash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [addresses] =&gt; Array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; LML1HJvP8jfeiwgSVmYfNGsedYfDrzKmq3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) 阅读更多","@type":"BlogPosting","url":"/2017/08/19/f1a828b28ebb11c16b4cafa3bd483dd4.html","headline":"虚拟币开发专题(山寨币怎样通过RPC命令实现区块浏览器)","dateModified":"2017-08-19T00:00:00+08:00","datePublished":"2017-08-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/08/19/f1a828b28ebb11c16b4cafa3bd483dd4.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>虚拟币开发专题(山寨币怎样通过RPC命令实现区块浏览器)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;"><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353）</span><br></p> 
  <p>基本架构如下：</p> 前端web基于或者REST实现，
  <br> 后端加一层mongodb/mysql等数据库来代替单机leveldb做数据存储
  <br>
  <br>
  <br> 目的应该是：
  <br> 1. 加速查询
  <br> 2. 做更高层的数据分析
  <br> 3.做分布式数据库
  <br>
  <br>
  <br> 思考:
  <br> 这些online的查询固然可以方便我们的日常用， 那如何与相关应用集成呢? 我们是否可以通过简单的rpc命令实现同等的效果?
  <br> 有几个用处：
  <br> 1 . 大家都可以做自己的qukuai.com或blockchain.info的查询：）
  <br> 2. &nbsp;集成RPC命令到自己的店铺，收款后查询用
  <br> 3. &nbsp;集成到钱包应用
  <br> 4. &nbsp;其他应用场景
  <br>
  <br>
  <br> cmd分析：
  <br>
  <br>
  <br> 根据高度height查block hash
  <br>
  <br>
  <br> ./bitcoin-cli getblockhash 19999
  <br>
  <br>
  <br> 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124
  <br>
  <br>
  <br> 2. 然后根据block hash查block 信息
  <br> ./bitcoin-cli getblock 00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124
  <br> {
  <br> &nbsp; &nbsp; "hash" : "00000000ba36eb929dc90170a96ee3efb76cbebee0e0e5c4da9eb0b6e74d9124",
  <br> &nbsp; &nbsp; "confirmations" : 263032,
  <br> &nbsp; &nbsp; "size" : 215,
  <br> &nbsp; &nbsp; "height" : 19999,
  <br> &nbsp; &nbsp; "version" : 1,
  <br> &nbsp; &nbsp; "merkleroot" : "c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98",
  <br> &nbsp; &nbsp; "tx" : [
  <br> &nbsp; &nbsp; &nbsp; &nbsp; "c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98"
  <br> &nbsp; &nbsp; ],
  <br> &nbsp; &nbsp; "time" : 1248291140,
  <br> &nbsp; &nbsp; "nonce" : 1085206531,
  <br> &nbsp; &nbsp; "bits" : "1d00ffff",
  <br> &nbsp; &nbsp; "difficulty" : 1.00000000,
  <br> &nbsp; &nbsp; "chainwork" : "00000000000000000000000000000000000000000000000000004e204e204e20",
  <br> &nbsp; &nbsp; "previousblockhash" : "000000006eb5c2799b0f5fafab6435daeecef8e7f609b731c9879c3f74f28c73",
  <br> &nbsp; &nbsp; "nextblockhash" : "00000000770ebe897270ca5f6d539d8afb4ea4f4e757761a34ca82e17207d886"
  <br> }
  <br>
  <br>
  <br>
  <br>
  <br> 3. 根据tx查询单笔交易的信息：
  <br> 没建index时，只能查询自己钱包的信息，若不是钱包的交易，则返回如下：
  <br> ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98
  <br>
  <br>
  <br> error: {"code":-5,"message":"Invalid or non-wallet transaction id"}
  <br>
  <br>
  <br> 那怎么办呢? 直接分析代码找原因：
  <br> // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock
  <br> bool GetTransaction(const uint256 &amp;hash, CTransaction &amp;txOut, uint256 &amp;hashBlock, bool fAllowSlow)
  <br> {
  <br> &nbsp; &nbsp; CBlockIndex *pindexSlow = NULL;
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; LOCK(cs_main);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mempool.lookup(hash, txOut))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (fTxIndex) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos postx;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pblocktree-&gt;ReadTxIndex(hash, postx)) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockHeader header;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; header;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(file, postx.nTxOffset, SEEK_CUR);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file &gt;&gt; txOut;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (std::exception &amp;e) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error("%s : Deserialize or I/O error - %s", __func__, e.what());
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = header.GetHash();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txOut.GetHash() != hash)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error("%s : txid mismatch", __func__);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nHeight = -1;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoinsViewCache &amp;view = *pcoinsTip;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CCoins coins;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (view.GetCoins(hash, coins))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nHeight = coins.nHeight;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nHeight &gt; 0)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexSlow = chainActive[nHeight];
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; if (pindexSlow) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (ReadBlockFromDisk(block, pindexSlow)) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOST_FOREACH(const CTransaction &amp;tx, block.vtx) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tx.GetHash() == hash) {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txOut = tx;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashBlock = pindexSlow-&gt;GetBlockHash();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; return false;
  <br> }
  <br>
  <br>
  <br>
  <br>
  <br> 我们可以看出若fTxIndex为true，则可以直接搜索index获取block信息
  <br> 通过-reindex -txindex建立索引，调用：
  <br> ./bitcoind -reindex -txindex
  <br> 这个过程在我的mac上跑了数个小时。。。。。。
  <br> -txindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maintain a full transaction index (default: 0)
  <br> -reindex &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rebuild block chain index from current blk000??.dat files
  <br> 再次查询
  <br> ./bitcoin-cli getrawtransaction c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98
  <br>
  <br>
  <br> 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000
  <br>
  <br>
  <br> 解码交易数据
  <br> ./bitcoin-cli decoderawtransaction 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0168ffffffff0100f2052a01000000434104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac00000000
  <br> {
  <br> &nbsp; &nbsp; "txid" : "c1b09fa6bdc0b12b15cc1400d598ffed29dd33b2e282093a48646d1b7b380c98",
  <br> &nbsp; &nbsp; "version" : 1,
  <br> &nbsp; &nbsp; "locktime" : 0,
  <br> &nbsp; &nbsp; "vin" : [
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "coinbase" : "04ffff001d0168",
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "sequence" : 4294967295
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; ],
  <br> &nbsp; &nbsp; "vout" : [
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "value" : 50.00000000,
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "n" : 0,
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "scriptPubKey" : {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "asm" : "04cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60 OP_CHECKSIG",
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "hex" : "4104cab13751ae7f0e0e49f8fb345e931bc6a6349502da0cbcad98e9d95110ebde5ca7af9eb09639c022ac251b44d0fa200b54011198a405984a8ff92ea9028d6d60ac",
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "reqSigs" : 1,
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type" : "pubkey",
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "addresses" : [
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "1KWj3Jk8xvS6fDdhQBsfmerscSGsS6CMiS"
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> }
  <br>
  <br>
  <br> 以上过程基本满足了大部分的查询需求：输入交易ID、区块高度或哈希值（BTC）
  <br> 至于通过"地址"查询，需要通过搜集这个地址对应的交易输入输出存入数据库
  <br> 部分代码如下：
  <br> function updateKeys($hash160,$pubkey,$blockhash)
  <br> {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; global $db;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; $address=hash160ToAddress($hash160);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; $result=pg_fetch_assoc(pg_query_params($db,"SELECT pubkey,encode(hash160,'hex') AS hash160 FROM keys WHERE hash160=decode($1,'hex')",array($hash160)));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if(!$result &amp;&amp; !is_null($pubkey))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, "INSERT INTO keys VALUES (decode($1,'hex'),$2,decode($3,'hex'),decode($4,'hex'));",array($hash160,$address,$pubkey,$blockhash));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; else if(!$result)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, "INSERT INTO keys(hash160,address,firstseen) VALUES (decode($1,'hex'),$2,decode($3,'hex'));",array($hash160,$address,$blockhash));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; else if($result &amp;&amp; !is_null($pubkey) &amp;&amp; is_null($result["pubkey"]))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($result["hash160"]!=strtolower(hash160($pubkey)))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep(10);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die("Hashes don't match");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_query_params($db, "UPDATE keys SET pubkey = decode($1,'hex') WHERE hash160=decode($2,'hex');",array($pubkey,$hash160));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> }
  <br>
  <br>
  <br> 案例分析：如何获取一笔交易的输入地址？（此case可用在获取打款地址上）
  <br> 如何根据txid获取打款地址呢？其实可以基于blockchain的链式结构逆向推导
  <br>
  <br>
  <br> 首先 gettransaction &nbsp;txid
  <br> &nbsp; &nbsp; [vin] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [txid] =&gt; 63876d10a13f3810a1d568c6ac7154f9b8a590cfc91cf8a17756fb099addf2b5
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [vout] =&gt; 1
  <br> 获取到此次的tx得信息详细，根据vin里的txid逆向查找， txid二次查询，gettransaction &nbsp;vin-&gt;txid
  <br> 然后根据vout索引得到输入address
  <br> &nbsp; &nbsp; [vout] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [value] =&gt; 0.16928006
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [n] =&gt; 0
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [scriptPubKey] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [asm] =&gt; OP_DUP OP_HASH160 1715447427ac1cdfb7c5ba359154c37c5e9caa2b OP_EQUALVERIFY OP_CHECKSIG
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [hex] =&gt; 76a9141715447427ac1cdfb7c5ba359154c37c5e9caa2b88ac
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [reqSigs] =&gt; 1
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [type] =&gt; pubkeyhash
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [addresses] =&gt; Array
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; LML1HJvP8jfeiwgSVmYfNGsedYfDrzKmq3
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )
  <br>
  <br>
  <br>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/77394627,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/77394627,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
