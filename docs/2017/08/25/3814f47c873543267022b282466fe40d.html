<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>质数的验证！你了解多少（从零开始学区块链 193） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="质数的验证！你了解多少（从零开始学区块链 193）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="素数又称为质数，在数论领域是研究的重点，同时关于质数的产生和大数质数分解也是密码学中的重要课题，区块链世界也诞生过使用质数验证作为工作量证明的素数币 本文主要科普一下关于质数的验证的几种方式，质数验证可以用于通过随机数产生大质数这类的算法。 质数的验证也称为素性验证，是检验一个给定的整数是否为素数的测试，素数是除了自身和1以外，没有其它素数因子的自然数。自从欧几里得证明了有无穷个素数以后，人们就企图寻找一个可以构造所有素数的公式，寻找判定一个自然数是不是素数的方法。因为素数的地位非常重要。鉴别一个自然数是素数还是合数，这个问题在中世纪就引起人们注意，当时人们试图寻找质数公式，到了高斯时代，基本上确认了简单的质数公式是不存在的，因此，高斯认为对素性判定是一个相当困难的问题。从此以后，这个问题吸引了大批数学家。 素性判断算法可分为两大类，确定性算法及随机算法。前者可给出确定的结果但通常较慢，后者存在偶然不确定结果但是速度较快。 确定性算法 试除法（埃拉托斯特尼筛法） 尝试从2到的平方根n整数是否整除N。给定一个合数n（这里，n是待分解的正整数），试除法看成是用小于等于平方根n的每个素数去试除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。试除法一定能够找到n的因子。因为它检查n的所有可能的因子，所以如果这个算法“失败”，也就证明了n是个素数。试除法效率非常低，对于小质数的验证可用，大质数一般不适用这种方法。 卢卡斯-莱默检验法 数学中，卢卡斯-莱默检验法是检验梅森数的素性检验，是由爱德华·卢卡斯于1878年完善，德里克·亨利·莱默随后于1930年代将其改进。因特网梅森素数大搜索用这个检验法找到了不少很大的素数，最近几个最大的素数就是这个项目发现的。由于梅森数比随机选择的整数更有可能是素数，因此他们认为这是一个极有用的方法。卢卡斯－莱默检验法原理是这样：令梅森数&nbsp;Mp&nbsp;=&nbsp;2p−&nbsp;1作为检验对象（预设p是素数，否则Mp就是合数了）。 AKS素数测试 AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法&nbsp;，由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal和Nitin Saxena，在2002年8月6日发表于一篇题为素数属于P的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。 AKS最关键的重要性在于它是第一个被发表的一般的、多项式的、确定性的和无仰赖的素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。 1、AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。 2、算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。 3、算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。 4、AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。 随机算法 费马素性检验 利用费马小定理来测试一个数是否是素数的方法 根据费马小定理：如果p是素数，1≤a≤p−1，那么 ap−1≡1(mod&nbsp;p) 如果我们想知道n是否是素数，我们在中间选取a，看看上面等式是否成立。如果对于数值a等式不成立，那么n是合数。如果有很多的a能够使等式成立，那么我们可以说n可能是素数，或者伪素数。在我们检验过程中，有可能我们选取的a都能让等式成立，然而n却是合数。这时等式 an−1≡1(mod&nbsp;n) 被称为Fermat liar。如果我们选取满足下面等式的a an−1≢1(modn) 那么a也就是对于n的合数判定的Fermat witness。 费马测试的缺点在于，对于卡米歇尔数n，全部的a都会令gcd(a,n)=1，我们称之为费马骗子数（Fermat liars）。尽管卡米歇尔数很是稀有，但是却足够令费马素性检验无法像如米勒-拉宾和Solovay-Strassen的素性检验般，成为被经常实际应用的素性检验 米勒-拉宾检验 利用随机化算法判断一个数是合数还是可能是素数。卡内基梅隆大学的计算机系教授Gary Lee Miller首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。 要测试N是否为素数，首先将N−1分解为2sd。在每次测试开始时，先随机选一个介于[1,N−1]的整数aa，之后如果对所有的r∈[0,s−1]r∈[0,s−1]，若admodN≠1admodN≠1且a2rdmodN≠−1a2rdmodN≠−1，则N是合数。否则，N有34的概率为素数。 目前在RSA的算法的部分实现中，米勒-拉宾验证被大量使用，有大量开源的这个算法实现。 普罗斯定理 普罗斯定理是数论的一个定理，可以判断普罗斯数是否是质数。 如果p是普罗斯数，也就是满足k2n&nbsp;+ 1形式的数，其中k为奇数，且k&nbsp;&lt; 2n，那么如果对于某个整数a，有 a(p−1)/2≡−1(mod&nbsp;p) 则p是素数。此时p称为普罗斯质数。这是一个有实际用途的方法，因为如果p是素数，任何选定的a都有百分之50的机会满足这个关系式。 若a是是模p的二次非剩余，则上述定理的逆定理也成立，因此有一种可以找a的方式，就是在最小的质数中依序找a，计算雅可比符号，直到下式成立为止 (a|p)=−1 蒙地卡罗算法的素性测试是乱数算法，可能会产生伪阳性的结果（不是素数的数却通过素性测试），根据普罗斯定理的算法是拉斯维加斯算法，其答案都是对的，但要找到答案的时间则是随机变化。 后记 原来知道质数测试比较复杂，但是查阅wiki资料后才发现的确非常复杂，部分公式完全看不懂，索性还是发出来全当自己收藏，在这些理论中我比较感兴趣卡米歇尔数这个伪质数，在大数中比较难寻找，或许可以作为一中新的pow算法基础，部分观点认为，由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块，可能因为这些基于质数的pow算法没有很好的发展，但是肯定有人没有放弃在继续这方面的研究。 另外有人问过我关于量子计算对于密码学的攻击问题，我觉得最后能真正摧毁一个加密体系的应该是诞生天才数学家，如果有数学家能找到快速分解大整数为质数乘积的数学方法，RSA系列的加密算法应该就结束了，相比量子计算机我觉得数学家更恐怖 :) 关于本文 这是一篇科普，大部分资料来源于wiki，汇总一下便于收藏，部分公式由于显示原因会出错；您也可以将本文分享出去让更多人了解这些知识，您的支持和鼓励是我最大的动力，长按二维码关注 长按关注，探索未来 相关内容阅读 高冷牛的Ed25519算法介绍（从零开始学区块链176） IT世界的10大算法（从零开始学区块链 77） 分布式系统φ累计失败检测算法介绍（从零开始学区块链 99） Chord算法详解（从零开始学区块链 93） 聊聊离散对数加密算法（从零开始学区块链 62） 默默无闻的Viewstamps算法（从零开始学区块链 60） 你必须知道的椭圆曲线算法（从零开始学区块链 31） 关于鸽巢原理的应用（从零开始学区块链 140） 评估区块链的网络效应（从零开始学区块链 129） 从CAP到BASE（从零开始学区块链 47） CTO必须要了解的ACID原则（从零开始学区块链 73） FLP 不可能性的证明过程（从零开始学区块链 71） LevelDB结构分析（LevelDB专题 2） FLP不可能性定理简介（从零开始学区块链 59） 阅读更多" />
<meta property="og:description" content="素数又称为质数，在数论领域是研究的重点，同时关于质数的产生和大数质数分解也是密码学中的重要课题，区块链世界也诞生过使用质数验证作为工作量证明的素数币 本文主要科普一下关于质数的验证的几种方式，质数验证可以用于通过随机数产生大质数这类的算法。 质数的验证也称为素性验证，是检验一个给定的整数是否为素数的测试，素数是除了自身和1以外，没有其它素数因子的自然数。自从欧几里得证明了有无穷个素数以后，人们就企图寻找一个可以构造所有素数的公式，寻找判定一个自然数是不是素数的方法。因为素数的地位非常重要。鉴别一个自然数是素数还是合数，这个问题在中世纪就引起人们注意，当时人们试图寻找质数公式，到了高斯时代，基本上确认了简单的质数公式是不存在的，因此，高斯认为对素性判定是一个相当困难的问题。从此以后，这个问题吸引了大批数学家。 素性判断算法可分为两大类，确定性算法及随机算法。前者可给出确定的结果但通常较慢，后者存在偶然不确定结果但是速度较快。 确定性算法 试除法（埃拉托斯特尼筛法） 尝试从2到的平方根n整数是否整除N。给定一个合数n（这里，n是待分解的正整数），试除法看成是用小于等于平方根n的每个素数去试除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。试除法一定能够找到n的因子。因为它检查n的所有可能的因子，所以如果这个算法“失败”，也就证明了n是个素数。试除法效率非常低，对于小质数的验证可用，大质数一般不适用这种方法。 卢卡斯-莱默检验法 数学中，卢卡斯-莱默检验法是检验梅森数的素性检验，是由爱德华·卢卡斯于1878年完善，德里克·亨利·莱默随后于1930年代将其改进。因特网梅森素数大搜索用这个检验法找到了不少很大的素数，最近几个最大的素数就是这个项目发现的。由于梅森数比随机选择的整数更有可能是素数，因此他们认为这是一个极有用的方法。卢卡斯－莱默检验法原理是这样：令梅森数&nbsp;Mp&nbsp;=&nbsp;2p−&nbsp;1作为检验对象（预设p是素数，否则Mp就是合数了）。 AKS素数测试 AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法&nbsp;，由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal和Nitin Saxena，在2002年8月6日发表于一篇题为素数属于P的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。 AKS最关键的重要性在于它是第一个被发表的一般的、多项式的、确定性的和无仰赖的素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。 1、AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。 2、算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。 3、算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。 4、AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。 随机算法 费马素性检验 利用费马小定理来测试一个数是否是素数的方法 根据费马小定理：如果p是素数，1≤a≤p−1，那么 ap−1≡1(mod&nbsp;p) 如果我们想知道n是否是素数，我们在中间选取a，看看上面等式是否成立。如果对于数值a等式不成立，那么n是合数。如果有很多的a能够使等式成立，那么我们可以说n可能是素数，或者伪素数。在我们检验过程中，有可能我们选取的a都能让等式成立，然而n却是合数。这时等式 an−1≡1(mod&nbsp;n) 被称为Fermat liar。如果我们选取满足下面等式的a an−1≢1(modn) 那么a也就是对于n的合数判定的Fermat witness。 费马测试的缺点在于，对于卡米歇尔数n，全部的a都会令gcd(a,n)=1，我们称之为费马骗子数（Fermat liars）。尽管卡米歇尔数很是稀有，但是却足够令费马素性检验无法像如米勒-拉宾和Solovay-Strassen的素性检验般，成为被经常实际应用的素性检验 米勒-拉宾检验 利用随机化算法判断一个数是合数还是可能是素数。卡内基梅隆大学的计算机系教授Gary Lee Miller首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。 要测试N是否为素数，首先将N−1分解为2sd。在每次测试开始时，先随机选一个介于[1,N−1]的整数aa，之后如果对所有的r∈[0,s−1]r∈[0,s−1]，若admodN≠1admodN≠1且a2rdmodN≠−1a2rdmodN≠−1，则N是合数。否则，N有34的概率为素数。 目前在RSA的算法的部分实现中，米勒-拉宾验证被大量使用，有大量开源的这个算法实现。 普罗斯定理 普罗斯定理是数论的一个定理，可以判断普罗斯数是否是质数。 如果p是普罗斯数，也就是满足k2n&nbsp;+ 1形式的数，其中k为奇数，且k&nbsp;&lt; 2n，那么如果对于某个整数a，有 a(p−1)/2≡−1(mod&nbsp;p) 则p是素数。此时p称为普罗斯质数。这是一个有实际用途的方法，因为如果p是素数，任何选定的a都有百分之50的机会满足这个关系式。 若a是是模p的二次非剩余，则上述定理的逆定理也成立，因此有一种可以找a的方式，就是在最小的质数中依序找a，计算雅可比符号，直到下式成立为止 (a|p)=−1 蒙地卡罗算法的素性测试是乱数算法，可能会产生伪阳性的结果（不是素数的数却通过素性测试），根据普罗斯定理的算法是拉斯维加斯算法，其答案都是对的，但要找到答案的时间则是随机变化。 后记 原来知道质数测试比较复杂，但是查阅wiki资料后才发现的确非常复杂，部分公式完全看不懂，索性还是发出来全当自己收藏，在这些理论中我比较感兴趣卡米歇尔数这个伪质数，在大数中比较难寻找，或许可以作为一中新的pow算法基础，部分观点认为，由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块，可能因为这些基于质数的pow算法没有很好的发展，但是肯定有人没有放弃在继续这方面的研究。 另外有人问过我关于量子计算对于密码学的攻击问题，我觉得最后能真正摧毁一个加密体系的应该是诞生天才数学家，如果有数学家能找到快速分解大整数为质数乘积的数学方法，RSA系列的加密算法应该就结束了，相比量子计算机我觉得数学家更恐怖 :) 关于本文 这是一篇科普，大部分资料来源于wiki，汇总一下便于收藏，部分公式由于显示原因会出错；您也可以将本文分享出去让更多人了解这些知识，您的支持和鼓励是我最大的动力，长按二维码关注 长按关注，探索未来 相关内容阅读 高冷牛的Ed25519算法介绍（从零开始学区块链176） IT世界的10大算法（从零开始学区块链 77） 分布式系统φ累计失败检测算法介绍（从零开始学区块链 99） Chord算法详解（从零开始学区块链 93） 聊聊离散对数加密算法（从零开始学区块链 62） 默默无闻的Viewstamps算法（从零开始学区块链 60） 你必须知道的椭圆曲线算法（从零开始学区块链 31） 关于鸽巢原理的应用（从零开始学区块链 140） 评估区块链的网络效应（从零开始学区块链 129） 从CAP到BASE（从零开始学区块链 47） CTO必须要了解的ACID原则（从零开始学区块链 73） FLP 不可能性的证明过程（从零开始学区块链 71） LevelDB结构分析（LevelDB专题 2） FLP不可能性定理简介（从零开始学区块链 59） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/08/25/3814f47c873543267022b282466fe40d.html" />
<meta property="og:url" content="https://mlh.app/2017/08/25/3814f47c873543267022b282466fe40d.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-25T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"素数又称为质数，在数论领域是研究的重点，同时关于质数的产生和大数质数分解也是密码学中的重要课题，区块链世界也诞生过使用质数验证作为工作量证明的素数币 本文主要科普一下关于质数的验证的几种方式，质数验证可以用于通过随机数产生大质数这类的算法。 质数的验证也称为素性验证，是检验一个给定的整数是否为素数的测试，素数是除了自身和1以外，没有其它素数因子的自然数。自从欧几里得证明了有无穷个素数以后，人们就企图寻找一个可以构造所有素数的公式，寻找判定一个自然数是不是素数的方法。因为素数的地位非常重要。鉴别一个自然数是素数还是合数，这个问题在中世纪就引起人们注意，当时人们试图寻找质数公式，到了高斯时代，基本上确认了简单的质数公式是不存在的，因此，高斯认为对素性判定是一个相当困难的问题。从此以后，这个问题吸引了大批数学家。 素性判断算法可分为两大类，确定性算法及随机算法。前者可给出确定的结果但通常较慢，后者存在偶然不确定结果但是速度较快。 确定性算法 试除法（埃拉托斯特尼筛法） 尝试从2到的平方根n整数是否整除N。给定一个合数n（这里，n是待分解的正整数），试除法看成是用小于等于平方根n的每个素数去试除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。试除法一定能够找到n的因子。因为它检查n的所有可能的因子，所以如果这个算法“失败”，也就证明了n是个素数。试除法效率非常低，对于小质数的验证可用，大质数一般不适用这种方法。 卢卡斯-莱默检验法 数学中，卢卡斯-莱默检验法是检验梅森数的素性检验，是由爱德华·卢卡斯于1878年完善，德里克·亨利·莱默随后于1930年代将其改进。因特网梅森素数大搜索用这个检验法找到了不少很大的素数，最近几个最大的素数就是这个项目发现的。由于梅森数比随机选择的整数更有可能是素数，因此他们认为这是一个极有用的方法。卢卡斯－莱默检验法原理是这样：令梅森数&nbsp;Mp&nbsp;=&nbsp;2p−&nbsp;1作为检验对象（预设p是素数，否则Mp就是合数了）。 AKS素数测试 AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法&nbsp;，由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal和Nitin Saxena，在2002年8月6日发表于一篇题为素数属于P的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。 AKS最关键的重要性在于它是第一个被发表的一般的、多项式的、确定性的和无仰赖的素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。 1、AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。 2、算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。 3、算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。 4、AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。 随机算法 费马素性检验 利用费马小定理来测试一个数是否是素数的方法 根据费马小定理：如果p是素数，1≤a≤p−1，那么 ap−1≡1(mod&nbsp;p) 如果我们想知道n是否是素数，我们在中间选取a，看看上面等式是否成立。如果对于数值a等式不成立，那么n是合数。如果有很多的a能够使等式成立，那么我们可以说n可能是素数，或者伪素数。在我们检验过程中，有可能我们选取的a都能让等式成立，然而n却是合数。这时等式 an−1≡1(mod&nbsp;n) 被称为Fermat liar。如果我们选取满足下面等式的a an−1≢1(modn) 那么a也就是对于n的合数判定的Fermat witness。 费马测试的缺点在于，对于卡米歇尔数n，全部的a都会令gcd(a,n)=1，我们称之为费马骗子数（Fermat liars）。尽管卡米歇尔数很是稀有，但是却足够令费马素性检验无法像如米勒-拉宾和Solovay-Strassen的素性检验般，成为被经常实际应用的素性检验 米勒-拉宾检验 利用随机化算法判断一个数是合数还是可能是素数。卡内基梅隆大学的计算机系教授Gary Lee Miller首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。 要测试N是否为素数，首先将N−1分解为2sd。在每次测试开始时，先随机选一个介于[1,N−1]的整数aa，之后如果对所有的r∈[0,s−1]r∈[0,s−1]，若admodN≠1admodN≠1且a2rdmodN≠−1a2rdmodN≠−1，则N是合数。否则，N有34的概率为素数。 目前在RSA的算法的部分实现中，米勒-拉宾验证被大量使用，有大量开源的这个算法实现。 普罗斯定理 普罗斯定理是数论的一个定理，可以判断普罗斯数是否是质数。 如果p是普罗斯数，也就是满足k2n&nbsp;+ 1形式的数，其中k为奇数，且k&nbsp;&lt; 2n，那么如果对于某个整数a，有 a(p−1)/2≡−1(mod&nbsp;p) 则p是素数。此时p称为普罗斯质数。这是一个有实际用途的方法，因为如果p是素数，任何选定的a都有百分之50的机会满足这个关系式。 若a是是模p的二次非剩余，则上述定理的逆定理也成立，因此有一种可以找a的方式，就是在最小的质数中依序找a，计算雅可比符号，直到下式成立为止 (a|p)=−1 蒙地卡罗算法的素性测试是乱数算法，可能会产生伪阳性的结果（不是素数的数却通过素性测试），根据普罗斯定理的算法是拉斯维加斯算法，其答案都是对的，但要找到答案的时间则是随机变化。 后记 原来知道质数测试比较复杂，但是查阅wiki资料后才发现的确非常复杂，部分公式完全看不懂，索性还是发出来全当自己收藏，在这些理论中我比较感兴趣卡米歇尔数这个伪质数，在大数中比较难寻找，或许可以作为一中新的pow算法基础，部分观点认为，由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块，可能因为这些基于质数的pow算法没有很好的发展，但是肯定有人没有放弃在继续这方面的研究。 另外有人问过我关于量子计算对于密码学的攻击问题，我觉得最后能真正摧毁一个加密体系的应该是诞生天才数学家，如果有数学家能找到快速分解大整数为质数乘积的数学方法，RSA系列的加密算法应该就结束了，相比量子计算机我觉得数学家更恐怖 :) 关于本文 这是一篇科普，大部分资料来源于wiki，汇总一下便于收藏，部分公式由于显示原因会出错；您也可以将本文分享出去让更多人了解这些知识，您的支持和鼓励是我最大的动力，长按二维码关注 长按关注，探索未来 相关内容阅读 高冷牛的Ed25519算法介绍（从零开始学区块链176） IT世界的10大算法（从零开始学区块链 77） 分布式系统φ累计失败检测算法介绍（从零开始学区块链 99） Chord算法详解（从零开始学区块链 93） 聊聊离散对数加密算法（从零开始学区块链 62） 默默无闻的Viewstamps算法（从零开始学区块链 60） 你必须知道的椭圆曲线算法（从零开始学区块链 31） 关于鸽巢原理的应用（从零开始学区块链 140） 评估区块链的网络效应（从零开始学区块链 129） 从CAP到BASE（从零开始学区块链 47） CTO必须要了解的ACID原则（从零开始学区块链 73） FLP 不可能性的证明过程（从零开始学区块链 71） LevelDB结构分析（LevelDB专题 2） FLP不可能性定理简介（从零开始学区块链 59） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/08/25/3814f47c873543267022b282466fe40d.html","headline":"质数的验证！你了解多少（从零开始学区块链 193）","dateModified":"2017-08-25T00:00:00+08:00","datePublished":"2017-08-25T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/08/25/3814f47c873543267022b282466fe40d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>质数的验证！你了解多少（从零开始学区块链 193）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content" id="js_content">
    素数又称为质数，在数论领域是研究的重点，同时关于质数的产生和大数质数分解也是密码学中的重要课题，区块链世界也诞生过使用质数验证作为工作量证明的素数币
   <p><br></p>
   <p>本文主要科普一下关于质数的验证的几种方式，质数验证可以用于通过随机数产生大质数这类的算法。</p>
   <p><br></p>
   <p>质数的验证也称为素性验证，是检验一个给定的整数是否为素数的测试，素数是除了自身和1以外，没有其它素数因子的自然数。自从欧几里得证明了有无穷个素数以后，人们就企图寻找一个可以构造所有素数的公式，寻找判定一个自然数是不是素数的方法。因为素数的地位非常重要。鉴别一个自然数是素数还是合数，这个问题在中世纪就引起人们注意，当时人们试图寻找质数公式，到了高斯时代，基本上确认了简单的质数公式是不存在的，因此，高斯认为对素性判定是一个相当困难的问题。从此以后，这个问题吸引了大批数学家。 素性判断算法可分为两大类，确定性算法及随机算法。前者可给出确定的结果但通常较慢，后者存在偶然不确定结果但是速度较快。</p>
   <p><br></p>确定性算法
   <p><br></p>
   <p><strong>试除法（埃拉托斯特尼筛法）</strong></p>
   <p>尝试从2到的平方根n整数是否整除N。给定一个合数n（这里，n是待分解的正整数），试除法看成是用小于等于平方根n的每个素数去试除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。试除法一定能够找到n的因子。因为它检查n的所有可能的因子，所以如果这个算法“失败”，也就证明了n是个素数。试除法效率非常低，对于小质数的验证可用，大质数一般不适用这种方法。</p>
   <p><br></p>
   <p><strong>卢卡斯-莱默检验法</strong></p>
   <p>数学中，卢卡斯-莱默检验法是检验梅森数的素性检验，是由爱德华·卢卡斯于1878年完善，德里克·亨利·莱默随后于1930年代将其改进。因特网梅森素数大搜索用这个检验法找到了不少很大的素数，最近几个最大的素数就是这个项目发现的。由于梅森数比随机选择的整数更有可能是素数，因此他们认为这是一个极有用的方法。卢卡斯－莱默检验法原理是这样：令梅森数&nbsp;Mp&nbsp;=&nbsp;2p−&nbsp;1作为检验对象（预设p是素数，否则Mp就是合数了）。</p>
   <p><br></p>
   <p><strong>AKS素数测试</strong></p>
   <p>AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法&nbsp;，由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal和Nitin Saxena，在2002年8月6日发表于一篇题为素数属于P的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。</p>
   <p><br></p>
   <p>AKS最关键的重要性在于它是第一个被发表的一般的、多项式的、确定性的和无仰赖的素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。</p>
   <p><br></p>
   <p>1、AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。</p>
   <p><br></p>
   <p>2、算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。</p>
   <p><br></p>
   <p>3、算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。</p>
   <p><br></p>
   <p>4、AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。</p>
   <p><br></p>随机算法
   <p><br></p>
   <p><strong>费马素性检验</strong></p>
   <p>利用费马小定理来测试一个数是否是素数的方法</p>
   <p>根据费马小定理：如果p是素数，1≤a≤p−1，那么</p>
   <ul class="list-paddingleft-2">
    <li><p>ap−1≡1(mod&nbsp;p)<br></p></li>
   </ul>
   <p>如果我们想知道n是否是素数，我们在中间选取a，看看上面等式是否成立。如果对于数值a等式不成立，那么n是合数。如果有很多的a能够使等式成立，那么我们可以说n可能是素数，或者伪素数。在我们检验过程中，有可能我们选取的a都能让等式成立，然而n却是合数。这时等式</p>
   <ul class="list-paddingleft-2">
    <li><p>an−1≡1(mod&nbsp;n)</p></li>
   </ul>
   <p>被称为Fermat liar。如果我们选取满足下面等式的a</p>
   <ul class="list-paddingleft-2">
    <li><p>an−1≢1(modn)</p></li>
   </ul>
   <p>那么a也就是对于n的合数判定的Fermat witness。</p>
   <p><br></p>
   <p>费马测试的缺点在于，对于卡米歇尔数n，全部的a都会令gcd(a,n)=1，我们称之为费马骗子数（Fermat liars）。尽管卡米歇尔数很是稀有，但是却足够令费马素性检验无法像如米勒-拉宾和Solovay-Strassen的素性检验般，成为被经常实际应用的素性检验</p>
   <p><strong><br></strong></p>
   <p><strong>米勒-拉宾检验</strong></p>
   <p>利用随机化算法判断一个数是合数还是可能是素数。卡内基梅隆大学的计算机系教授Gary Lee Miller首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。</p>
   <p><br></p>
   <p>要测试N是否为素数，首先将N−1分解为2sd<span style="color:#444444;font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;background-color:rgba(112,138,153,.0980392);">。</span>在每次测试开始时，先随机选一个介于[1,N−1]的整数aa，之后如果对所有<span style="color:#444444;font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;background-color:rgba(112,138,153,.0980392);">的</span><span class="MathJax" style="display:inline;line-height:normal;min-width:0px;min-height:0px;border:0px;color:rgb(68,68,68);font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;"><span class="math" style="font-size:19.200000762939453px;display:inline;border:0px;vertical-align:0px;line-height:normal;"><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">r</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">∈</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">[</span><span class="mn" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">0</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">,</span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">s</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">−</span><span class="mn" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">1</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">]</span></span><span class="MJX_Assistive_MathML" style="vertical-align:0px;line-height:normal;border:0px !important;overflow:hidden !important;display:block !important;">r∈[0,s−1]</span></span><span style="color:#444444;font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;background-color:rgba(112,138,153,.0980392);">，若</span><span class="MathJax" style="display:inline;line-height:normal;min-width:0px;min-height:0px;border:0px;color:rgb(68,68,68);font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;"><span class="math" style="font-size:19.200000762939453px;display:inline;border:0px;vertical-align:0px;line-height:normal;"><span class="msubsup" style="display:inline-block;border:0px;vertical-align:0px;line-height:normal;"><span style="border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">a</span><span style="border:0px;vertical-align:0px;line-height:normal;font-size:13.5743989944458px;font-family:'STIXGeneral-Italic';">d</span></span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">mod</span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">N</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">≠</span><span class="mn" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">1</span></span><span class="MJX_Assistive_MathML" style="vertical-align:0px;line-height:normal;border:0px !important;overflow:hidden !important;display:block !important;">admodN≠1</span></span><span style="color:#444444;font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;background-color:rgba(112,138,153,.0980392);">且</span><span class="MathJax" style="display:inline;line-height:normal;min-width:0px;min-height:0px;border:0px;color:rgb(68,68,68);font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;"><span class="math" style="font-size:19.200000762939453px;display:inline;border:0px;vertical-align:0px;line-height:normal;"><span class="msubsup" style="display:inline-block;border:0px;vertical-align:0px;line-height:normal;"><span style="border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">a</span><span style="border:0px;vertical-align:0px;line-height:normal;"><span class="msubsup" style="display:inline-block;border:0px;vertical-align:0px;line-height:normal;"><span style="border:0px;vertical-align:0px;line-height:normal;font-size:13.5743989944458px;font-family:'STIXGeneral-Regular';">2</span><span style="border:0px;vertical-align:0px;line-height:normal;font-size:9.600000381469727px;font-family:'STIXGeneral-Italic';">r</span></span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-size:13.5743989944458px;font-family:'STIXGeneral-Italic';">d</span></span></span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">mod</span><span class="mi" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Italic';">N</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">≠</span><span class="mo" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">−</span><span class="mn" style="display:inline;border:0px;vertical-align:0px;line-height:normal;font-family:'STIXGeneral-Regular';">1</span></span><span class="MJX_Assistive_MathML" style="vertical-align:0px;line-height:normal;border:0px !important;overflow:hidden !important;display:block !important;">a2rdmodN≠−1</span></span><span style="color:#444444;font-family:'Helvetica Neue', Helvetica, Arial, 'Microsoft YaHei', sans-serif;background-color:rgba(112,138,153,.0980392);">，</span>则N是合数。否则，N有34的概率为素数。</p>
   <p><br></p>
   <p>目前在RSA的算法的部分实现中，米勒-拉宾验证被大量使用，有大量开源的这个算法实现。</p>
   <p><strong><br></strong></p>
   <p><strong>普罗斯定理</strong></p>
   <p>普罗斯定理是数论的一个定理，可以判断普罗斯数是否是质数。</p>
   <p>如果p是普罗斯数，也就是满足k2n&nbsp;+ 1形式的数，其中k为奇数，且k&nbsp;&lt; 2n，那么如果对于某个整数a，有</p>
   <ul class="list-paddingleft-2">
    <li><p>a(p−1)/2≡−1(mod&nbsp;p)</p></li>
   </ul>
   <p>则p是素数。此时p称为普罗斯质数。这是一个有实际用途的方法，因为如果p是素数，任何选定的a都有百分之50的机会满足这个关系式。</p>
   <p><br></p>
   <p>若a是是模p的二次非剩余，则上述定理的逆定理也成立，因此有一种可以找a的方式，就是在最小的质数中依序找a，计算雅可比符号，直到下式成立为止</p>
   <ul class="list-paddingleft-2">
    <li>
     <ul style="list-style-type:square;" class="list-paddingleft-2">
      <li><p><br></p>
       <ul style="list-style-type:circle;" class="list-paddingleft-2">
        <li><p>(a|p)=−1</p></li>
       </ul></li>
     </ul></li>
   </ul>
   <p>蒙地卡罗算法的素性测试是乱数算法，可能会产生伪阳性的结果（不是素数的数却通过素性测试），根据普罗斯定理的算法是拉斯维加斯算法，其答案都是对的，但要找到答案的时间则是随机变化。</p>
   <p><br></p>后记
   <p><br></p>
   <p>原来知道质数测试比较复杂，但是查阅wiki资料后才发现的确非常复杂，部分公式完全看不懂，索性还是发出来全当自己收藏，在这些理论中我比较感兴趣卡米歇尔数这个伪质数，在大数中比较难寻找，或许可以作为一中新的pow算法基础，部分观点认为，由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块，可能因为这些基于质数的pow算法没有很好的发展，但是肯定有人没有放弃在继续这方面的研究。</p>
   <p><br></p>
   <p>另外有人问过我关于量子计算对于密码学的攻击问题，我觉得最后能真正摧毁一个加密体系的应该是诞生天才数学家，如果有数学家能找到快速分解大整数为质数乘积的数学方法，RSA系列的加密算法应该就结束了，相比量子计算机我觉得数学家更恐怖 :)</p>
   <p><br></p>
   <span style="font-size:14px;"><strong style="line-height:32px;"><span style="color:rgb(255,255,255);background-color:rgb(239,112,96);">关于本文</span></strong></span>
   <p style="min-height:1em;color:rgb(51,51,51);background-color:rgb(239,239,239);"><span style="color:rgb(255,104,39);font-size:14px;">这是一篇科普，大部分资料来源于wiki，汇总一下便于收藏，部分公式由于显示原因会出错；您也可以将本文分享出去让更多人了解这些知识，您的支持和鼓励是我最大的动力，长按二维码关注</span></p>
   <p style="min-height:1em;color:rgb(51,51,51);text-align:center;background-color:rgb(239,239,239);"><img style="visibility:visible !important;" class="img_loading" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz/aqZlFmib0UrAiaZrCBibNFF2zJX3icFaZqTbicicjlRfWicNv9XoVuq7mRt0dTptlesOR4ibDDdLdF05Re6o4hQxZlM8ibw/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"><br><strong style="color:rgb(255,255,255);font-size:1em;background-color:rgb(239,112,96);">长按关注，探索未来</strong></p>
   <p><br></p>
   <p><br></p>
   <span style="color:rgb(255,255,255);">相关内容阅读</span>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394887&amp;idx=1&amp;sn=f47e7031c56fae7b8ad89aec566e6eb0&amp;chksm=f3eebfb1c49936a71435e10341735c30b60fc2c02f538297b76a49665aa227ae82a3c026d042&amp;scene=21#wechat_redirect" rel="nofollow">高冷牛的Ed25519算法介绍（从零开始学区块链176）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394311&amp;idx=1&amp;sn=21cdc839bec4a40476abc587f6eec067&amp;chksm=f3eeb971c49930678cb556fc4b9d58cc4d5e3a0ed588fc548b6cbe6cab1928516d6dd96fdf21&amp;scene=21#wechat_redirect" rel="nofollow">IT世界的10大算法（从零开始学区块链 77）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394482&amp;idx=1&amp;sn=f6985f676a0f734dfe0911a9e333cec6&amp;chksm=f3eeb9c4c49930d280fd0be75265f8680545208283bc1f4ad6fe1aec338ef4fef7599dceeb6f&amp;scene=21#wechat_redirect" rel="nofollow">分布式系统φ累计失败检测算法介绍（从零开始学区块链 99）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394445&amp;idx=1&amp;sn=74df4de3f0d83d5de5d6a60a3132ead1&amp;chksm=f3eeb9fbc49930ed8a21ac2da938c8258bd0919988c5133f89fe93a27d46100f996d0a129ee7&amp;scene=21#wechat_redirect" rel="nofollow">Chord算法详解（从零开始学区块链 93）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394216&amp;idx=1&amp;sn=ab036956dcaa08a0119eaac097de87ae&amp;chksm=f3eeb8dec49931c8cf9cedc65a00e4db9c1faca5e873044ce6b4b75538e13c3336ab7dd41919&amp;scene=21#wechat_redirect" rel="nofollow">聊聊离散对数加密算法（从零开始学区块链 62）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394210&amp;idx=1&amp;sn=ad85de478add933487c9b6af1620a1b6&amp;chksm=f3eeb8d4c49931c27daa2ad2e9a6d9b44486fc25c1e593698d137e1c32a19dbd402f4e8b6705&amp;scene=21#wechat_redirect" rel="nofollow">默默无闻的Viewstamps算法（从零开始学区块链 60）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394001&amp;idx=1&amp;sn=96a23e27d90c1e89766af6637e9cd262&amp;chksm=f3eeb827c499313198a1cc23631c362f95d209d7713d3f4266a2d3a3258ecac3fb81987f8343&amp;scene=21#wechat_redirect" rel="nofollow">你必须知道的椭圆曲线算法（从零开始学区块链 31）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394750&amp;idx=1&amp;sn=9c7a88038db8a2e7d740d70aef717fed&amp;chksm=f3eebec8c49937deca6c398392863c0daff0fa1762fcbb87e6c173e91fe8d3c53d355fc55375&amp;scene=21#wechat_redirect" rel="nofollow">关于鸽巢原理的应用（从零开始学区块链 140）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394703&amp;idx=1&amp;sn=547cc7951f9c7af6cb1ea59b8ee5ea83&amp;chksm=f3eebef9c49937ef554ba78a52a672c0afbade83e9fe3ff5ebbb2fd611ab75900d3ff3ef3d8d&amp;scene=21#wechat_redirect" rel="nofollow">评估区块链的网络效应（从零开始学区块链 129）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394108&amp;idx=1&amp;sn=4f0f277de7192ba36e43161f2f90cdb1&amp;chksm=f3eeb84ac499315c9b5f2c216ad7cce7480810ca18fb80b8066ecb3836674e40529b70ca87f6&amp;scene=21#wechat_redirect" rel="nofollow">从CAP到BASE（从零开始学区块链 47）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394293&amp;idx=1&amp;sn=666d5126182eeffb0f875d8299cf7a03&amp;chksm=f3eeb903c4993015973a57318728fdd352f3a4d2238a1c8cfcae7443013936fedec22838b0c9&amp;scene=21#wechat_redirect" rel="nofollow">CTO必须要了解的ACID原则（从零开始学区块链 73）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394284&amp;idx=1&amp;sn=23be878562b73af3d383dd2ba4b79b88&amp;chksm=f3eeb91ac499300c6dabaa48716c0f03b6b75a5efb1fba1ac05a00369821f70ce1e191c79c08&amp;scene=21#wechat_redirect" rel="nofollow">FLP 不可能性的证明过程（从零开始学区块链 71）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394343&amp;idx=1&amp;sn=bb5e4971e8db4445239b3dabdcda7f0e&amp;chksm=f3eeb951c4993047d79e3eadbedf974b22b1df439aceaeeb47028ab1d54351d0e6605cb6b8ec&amp;scene=21#wechat_redirect" rel="nofollow">LevelDB结构分析（LevelDB专题 2）</a><br></p>
   <p style="color:rgb(51,51,51);"><a href="http://mp.weixin.qq.com/s?__biz=MzIyNTI3MTY0MQ==&amp;mid=2652394209&amp;idx=1&amp;sn=920eb2cf91914cffa63fdf5ccf0e7a2f&amp;chksm=f3eeb8d7c49931c1caad880037132a9b8042eaa08d8220b87180923102eee5b6c1878bb20c7b&amp;scene=21#wechat_redirect" rel="nofollow">FLP不可能性定理简介（从零开始学区块链 59）</a><br></p>
   <p><br></p>
   <p><br></p> 
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/IXRKw146s9Z/article/details/77988075,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/IXRKw146s9Z/article/details/77988075,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
