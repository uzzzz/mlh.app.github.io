<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>AsicBoost——比特币挖矿捷径 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="AsicBoost——比特币挖矿捷径" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="参考自更全资料 AsicBoost is a method to speed up Bitcoin mining by a factor of approximately 20%. AsicBoost is an algorithmic optimization and therefore applicable to all types of mining hardware. SHA 256 SHA 256先把数据分成64字节的chunk单元，然后经过Expander Function得到Message Schedule，然后经过Compressor得到最终的hash摘要。 比特币的double SHA 256 比特币区块头结构 比特币的double SHA 256概述 根据区块头的字段进一步细化 注意： 关于Mid state指的是SHA 256(0)后得到的H0，更多挖矿算法和详细内容 Mid state以及Message统称为 Work item The components shown in red lie in the inner loop and update at high frequency. The components shown in green lie in the outer loop and update less frequently. All Bitcoin mining ASICs process only the inner loop internally. The work items are precomputed and passed to the ASIC from outside. 关于Work items Each work item is constructed from a new block header candidate which in turn is constructed from a new Merkle root . Since the Merkle root spans both chunks of the block header, updating the Merkle root affects both components of the work item: Midstate (depending on chunk 1) and Message (depending on chunk 2). Therefore, it is usually not the case that different work items share either of the two components. This is the reason why the information in Message Schedule 1 cannot be reused across the processing of multiple work items. AsicBoost 什么是Colliding Work Items？ AsicBoost achieves its performance gain by highly reusing Message Schedule 1 across multiple work items. In order to do so, AsicBoost generates many block header candidates that all share a common Message part. We speak of block header candidates as colliding if they collide in the Message part, or, in other words, if they differ from each other only in chunk 1. The work items derived from colliding block header candidates all share a common Message component and differ only in the Mid state component. We speak of work items as colliding if they collide in the Message component. AsicBoost算法流程 A set of colliding block headers allows AsicBoos t to swap the inner and outer mining loops as shown below. The Message is constant throughout the processing of the entire set of colliding block headers. AsicBoost’s inner loop iterates over the Mid states of all colliding block headers. The Nonce is now updated in the outer loop rather than the inner loop. Message schedule 1 is updated less frequently and its information is reused across multiple Mid states. AsicBoost对挖矿效率的提高 The AsicBoost method eliminates the Expander 1 function from the inner loop, leaving only Compressor 1, Expander 2 and Compressor 2 to be processed at high frequency. Since each of the four functions have similar complexity, up to one quarter of the total computational work can be saved by this approach. The exact gain depends on the size of the set of colliding work items. Suppose the Expander 1 takes x percent of the computational work of the four functions combined. Having n colliding work items then gives a total gain of x (n − 1)/n percent. 说明： 本来大小为n的colliding集合要算n次Message schedule1，并执行Expander 1，而现在集合的Message schedule1相同，执行一次Expander 1即可，所以提高的效率为1-1/n，最后在乘上Expander 1所占的比例x即可。 如何构建colliding block header candidates 方法1 Merkle root collisions One way is to calculate many merkle roots at random and filter them based on their last 4 bytes until sufficiently many are found that collide in their last 4 bytes. There are a number of tradeoffs to be considered when filtering for collisions. The optimal process depends on the targeted value for n and the number and speed of the hashing cores to be served. There are several methods to calculate merkle tree roots that are more efficient than changing the coinbase field. One method is based on permuting the order of transactions inside the block, or, in other words, permuting the leafs of the merkle tree. 其它方法(不该Merkle Root看chunk 1有什么地方可以改的) Another, more efficient way to produce colliding block headers is by using bits inside Chunk 1 but outside the merkle root that are free for the miner to choose. This does not require finding any merkle root collisions. Instead, one merkle root is chosen and fixed. The free bits are then updated in a loop and the respective Mid states are computed from Chunk 1. Each Mid state obtained in this way gives a new colliding work item, so that this method is extremely efficient. 疑惑 据说算法鼓励挖空区块，这点我看不出所以然，欢迎讨论（个人认为并不会） 隔离见证版本后堵住了这个漏洞，是怎么堵住的，欢迎讨论和补充资料 阅读更多" />
<meta property="og:description" content="参考自更全资料 AsicBoost is a method to speed up Bitcoin mining by a factor of approximately 20%. AsicBoost is an algorithmic optimization and therefore applicable to all types of mining hardware. SHA 256 SHA 256先把数据分成64字节的chunk单元，然后经过Expander Function得到Message Schedule，然后经过Compressor得到最终的hash摘要。 比特币的double SHA 256 比特币区块头结构 比特币的double SHA 256概述 根据区块头的字段进一步细化 注意： 关于Mid state指的是SHA 256(0)后得到的H0，更多挖矿算法和详细内容 Mid state以及Message统称为 Work item The components shown in red lie in the inner loop and update at high frequency. The components shown in green lie in the outer loop and update less frequently. All Bitcoin mining ASICs process only the inner loop internally. The work items are precomputed and passed to the ASIC from outside. 关于Work items Each work item is constructed from a new block header candidate which in turn is constructed from a new Merkle root . Since the Merkle root spans both chunks of the block header, updating the Merkle root affects both components of the work item: Midstate (depending on chunk 1) and Message (depending on chunk 2). Therefore, it is usually not the case that different work items share either of the two components. This is the reason why the information in Message Schedule 1 cannot be reused across the processing of multiple work items. AsicBoost 什么是Colliding Work Items？ AsicBoost achieves its performance gain by highly reusing Message Schedule 1 across multiple work items. In order to do so, AsicBoost generates many block header candidates that all share a common Message part. We speak of block header candidates as colliding if they collide in the Message part, or, in other words, if they differ from each other only in chunk 1. The work items derived from colliding block header candidates all share a common Message component and differ only in the Mid state component. We speak of work items as colliding if they collide in the Message component. AsicBoost算法流程 A set of colliding block headers allows AsicBoos t to swap the inner and outer mining loops as shown below. The Message is constant throughout the processing of the entire set of colliding block headers. AsicBoost’s inner loop iterates over the Mid states of all colliding block headers. The Nonce is now updated in the outer loop rather than the inner loop. Message schedule 1 is updated less frequently and its information is reused across multiple Mid states. AsicBoost对挖矿效率的提高 The AsicBoost method eliminates the Expander 1 function from the inner loop, leaving only Compressor 1, Expander 2 and Compressor 2 to be processed at high frequency. Since each of the four functions have similar complexity, up to one quarter of the total computational work can be saved by this approach. The exact gain depends on the size of the set of colliding work items. Suppose the Expander 1 takes x percent of the computational work of the four functions combined. Having n colliding work items then gives a total gain of x (n − 1)/n percent. 说明： 本来大小为n的colliding集合要算n次Message schedule1，并执行Expander 1，而现在集合的Message schedule1相同，执行一次Expander 1即可，所以提高的效率为1-1/n，最后在乘上Expander 1所占的比例x即可。 如何构建colliding block header candidates 方法1 Merkle root collisions One way is to calculate many merkle roots at random and filter them based on their last 4 bytes until sufficiently many are found that collide in their last 4 bytes. There are a number of tradeoffs to be considered when filtering for collisions. The optimal process depends on the targeted value for n and the number and speed of the hashing cores to be served. There are several methods to calculate merkle tree roots that are more efficient than changing the coinbase field. One method is based on permuting the order of transactions inside the block, or, in other words, permuting the leafs of the merkle tree. 其它方法(不该Merkle Root看chunk 1有什么地方可以改的) Another, more efficient way to produce colliding block headers is by using bits inside Chunk 1 but outside the merkle root that are free for the miner to choose. This does not require finding any merkle root collisions. Instead, one merkle root is chosen and fixed. The free bits are then updated in a loop and the respective Mid states are computed from Chunk 1. Each Mid state obtained in this way gives a new colliding work item, so that this method is extremely efficient. 疑惑 据说算法鼓励挖空区块，这点我看不出所以然，欢迎讨论（个人认为并不会） 隔离见证版本后堵住了这个漏洞，是怎么堵住的，欢迎讨论和补充资料 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-03T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"参考自更全资料 AsicBoost is a method to speed up Bitcoin mining by a factor of approximately 20%. AsicBoost is an algorithmic optimization and therefore applicable to all types of mining hardware. SHA 256 SHA 256先把数据分成64字节的chunk单元，然后经过Expander Function得到Message Schedule，然后经过Compressor得到最终的hash摘要。 比特币的double SHA 256 比特币区块头结构 比特币的double SHA 256概述 根据区块头的字段进一步细化 注意： 关于Mid state指的是SHA 256(0)后得到的H0，更多挖矿算法和详细内容 Mid state以及Message统称为 Work item The components shown in red lie in the inner loop and update at high frequency. The components shown in green lie in the outer loop and update less frequently. All Bitcoin mining ASICs process only the inner loop internally. The work items are precomputed and passed to the ASIC from outside. 关于Work items Each work item is constructed from a new block header candidate which in turn is constructed from a new Merkle root . Since the Merkle root spans both chunks of the block header, updating the Merkle root affects both components of the work item: Midstate (depending on chunk 1) and Message (depending on chunk 2). Therefore, it is usually not the case that different work items share either of the two components. This is the reason why the information in Message Schedule 1 cannot be reused across the processing of multiple work items. AsicBoost 什么是Colliding Work Items？ AsicBoost achieves its performance gain by highly reusing Message Schedule 1 across multiple work items. In order to do so, AsicBoost generates many block header candidates that all share a common Message part. We speak of block header candidates as colliding if they collide in the Message part, or, in other words, if they differ from each other only in chunk 1. The work items derived from colliding block header candidates all share a common Message component and differ only in the Mid state component. We speak of work items as colliding if they collide in the Message component. AsicBoost算法流程 A set of colliding block headers allows AsicBoos t to swap the inner and outer mining loops as shown below. The Message is constant throughout the processing of the entire set of colliding block headers. AsicBoost’s inner loop iterates over the Mid states of all colliding block headers. The Nonce is now updated in the outer loop rather than the inner loop. Message schedule 1 is updated less frequently and its information is reused across multiple Mid states. AsicBoost对挖矿效率的提高 The AsicBoost method eliminates the Expander 1 function from the inner loop, leaving only Compressor 1, Expander 2 and Compressor 2 to be processed at high frequency. Since each of the four functions have similar complexity, up to one quarter of the total computational work can be saved by this approach. The exact gain depends on the size of the set of colliding work items. Suppose the Expander 1 takes x percent of the computational work of the four functions combined. Having n colliding work items then gives a total gain of x (n − 1)/n percent. 说明： 本来大小为n的colliding集合要算n次Message schedule1，并执行Expander 1，而现在集合的Message schedule1相同，执行一次Expander 1即可，所以提高的效率为1-1/n，最后在乘上Expander 1所占的比例x即可。 如何构建colliding block header candidates 方法1 Merkle root collisions One way is to calculate many merkle roots at random and filter them based on their last 4 bytes until sufficiently many are found that collide in their last 4 bytes. There are a number of tradeoffs to be considered when filtering for collisions. The optimal process depends on the targeted value for n and the number and speed of the hashing cores to be served. There are several methods to calculate merkle tree roots that are more efficient than changing the coinbase field. One method is based on permuting the order of transactions inside the block, or, in other words, permuting the leafs of the merkle tree. 其它方法(不该Merkle Root看chunk 1有什么地方可以改的) Another, more efficient way to produce colliding block headers is by using bits inside Chunk 1 but outside the merkle root that are free for the miner to choose. This does not require finding any merkle root collisions. Instead, one merkle root is chosen and fixed. The free bits are then updated in a loop and the respective Mid states are computed from Chunk 1. Each Mid state obtained in this way gives a new colliding work item, so that this method is extremely efficient. 疑惑 据说算法鼓励挖空区块，这点我看不出所以然，欢迎讨论（个人认为并不会） 隔离见证版本后堵住了这个漏洞，是怎么堵住的，欢迎讨论和补充资料 阅读更多","@type":"BlogPosting","url":"/2017/08/03/fb3e4deac64cc0b1c7c089257bac459b.html","headline":"AsicBoost——比特币挖矿捷径","dateModified":"2017-08-03T00:00:00+08:00","datePublished":"2017-08-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/08/03/fb3e4deac64cc0b1c7c089257bac459b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>AsicBoost——比特币挖矿捷径</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><a href="https://arxiv.org/ftp/arxiv/papers/1604/1604.00575.pdf" rel="nofollow">参考自更全资料</a> <br> AsicBoost is a method to speed up Bitcoin mining by a factor of approximately <strong>20%</strong>. AsicBoost is <strong>an algorithmic optimization</strong> and therefore applicable to all types of mining hardware.</p> 
  <h1 id="sha-256">SHA 256</h1> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170804143003698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb25fY3VpamlhaHVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>SHA 256先把数据分成64字节的chunk单元，然后经过Expander Function得到Message Schedule，然后经过Compressor得到最终的hash摘要。</p> 
  <h1 id="比特币的double-sha-256">比特币的double SHA 256</h1> 
  <h2 id="比特币区块头结构">比特币区块头结构</h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170804113731686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb25fY3VpamlhaHVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h2 id="比特币的double-sha-256概述"><a href="http://blog.csdn.net/jason_cuijiahui/article/details/76672775" rel="nofollow" target="_blank">比特币的double SHA 256概述</a></h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170804143720887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb25fY3VpamlhaHVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h2 id="根据区块头的字段进一步细化">根据区块头的字段进一步细化</h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170804113756190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb25fY3VpamlhaHVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>注意：</p> 
  <ol> 
   <li>关于Mid state指的是SHA 256(0)后得到的H0，<a href="http://blog.csdn.net/jason_cuijiahui/article/details/76672775" rel="nofollow" target="_blank">更多挖矿算法和详细内容</a></li> 
   <li>Mid state以及Message统称为 <strong>Work item</strong></li> 
   <li>The components shown in red lie in the inner loop and update at high frequency. </li> 
   <li>The components shown in green lie in the outer loop and update less frequently.</li> 
   <li><strong>All Bitcoin mining ASICs process only the inner loop internally. The work items are precomputed and passed to the ASIC from outside</strong>.</li> 
  </ol> 
  <h3 id="关于work-items">关于Work items</h3> 
  <p>Each work item is constructed from a new block header candidate which in turn is constructed from a new Merkle root . </p> 
  <p>Since the Merkle root spans both chunks of the block header, updating the Merkle root affects both components of the work item: Midstate (depending on chunk 1) and Message (depending on chunk 2). </p> 
  <p>Therefore, it is usually not the case that different work items share either of the two components. This is the reason why the information in Message Schedule 1 cannot be reused across the processing of multiple work items.</p> 
  <h1 id="asicboost">AsicBoost</h1> 
  <h2 id="什么是colliding-work-items">什么是Colliding Work Items？</h2> 
  <p>AsicBoost achieves its performance gain by highly reusing Message Schedule 1 across multiple work items.</p> 
  <p>In order to do so, AsicBoost generates many <strong>block header candidates that all share a common Message part</strong>. </p> 
  <p>We speak of block header candidates as colliding if they collide in the Message part, or, in other words, if they differ from each other only in chunk 1.</p> 
  <p><strong>The work items derived from colliding block header candidates all share a common Message component and differ only in the Mid state component</strong>. We speak of work items as colliding if they collide in the Message component.</p> 
  <h2 id="asicboost算法流程">AsicBoost算法流程</h2> 
  <p>A set of colliding block headers allows AsicBoos t to swap the inner and outer mining loops as shown below. <strong>The Message is constant throughout the processing of the entire set of colliding block headers</strong>. </p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170804145430818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb25fY3VpamlhaHVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <ol> 
   <li>AsicBoost’s inner loop iterates over the Mid states of all colliding block headers. </li> 
   <li><strong>The Nonce is now updated in the outer loop rather than the inner loop</strong>. </li> 
   <li>Message schedule 1 is updated less frequently and its information is reused across multiple Mid states.</li> 
  </ol> 
  <h2 id="asicboost对挖矿效率的提高">AsicBoost对挖矿效率的提高</h2> 
  <p><strong>The AsicBoost method eliminates the Expander 1 function from the inner loop, leaving only Compressor 1, Expander 2 and Compressor 2 to be processed at high frequency. </strong></p> 
  <p><strong>Since each of the four functions have similar complexity, up to one quarter of the total computational work can be saved by this approach</strong>.</p> 
  <p><strong>The exact gain depends on the size of the set of colliding work items</strong>. </p> 
  <p>Suppose the Expander 1 takes x percent of the computational work of the four functions combined. Having n colliding work items then gives a total gain of x (n − 1)/n percent. </p> 
  <p>说明：</p> 
  <p>本来大小为n的colliding集合要算n次Message schedule1，并执行Expander 1，而现在集合的Message schedule1相同，执行一次Expander 1即可，所以提高的效率为<strong>1-1/n</strong>，最后在乘上Expander 1所占的比例x即可。</p> 
  <h2 id="如何构建colliding-block-header-candidates">如何构建colliding block header candidates</h2> 
  <h3 id="方法1-merkle-root-collisions">方法1 Merkle root collisions</h3> 
  <p><strong>One way is to calculate many merkle roots at random and filter them based on their last 4 bytes until sufficiently many are found that collide in their last 4 bytes.</strong></p> 
  <p>There are a number of tradeoffs to be considered when filtering for collisions. The optimal process depends on the targeted value for n and the number and speed of the hashing cores to be served. </p> 
  <p><strong>There are several methods to calculate merkle tree roots that are more efficient than changing the coinbase field</strong>. </p> 
  <p>One method is based on permuting the order of transactions inside the block, or, in other words, permuting the leafs of the merkle tree. </p> 
  <h3 id="其它方法不该merkle-root看chunk-1有什么地方可以改的">其它方法(不该Merkle Root看chunk 1有什么地方可以改的)</h3> 
  <p>Another, more efficient way to produce colliding block headers is by using bits inside Chunk 1 but outside the merkle root that are free for the miner to choose. </p> 
  <p>This does not require finding any merkle root collisions. Instead, one merkle root is chosen and fixed. The free bits are then updated in a loop and the respective Mid states are computed from Chunk 1. Each Mid state obtained in this way gives a new colliding work item, so that this method is extremely efficient.</p> 
  <h2 id="疑惑">疑惑</h2> 
  <ol> 
   <li>据说算法鼓励挖空区块，这点我看不出所以然，欢迎讨论（个人认为并不会）</li> 
   <li>隔离见证版本后堵住了这个漏洞，是怎么堵住的，欢迎讨论和补充资料</li> 
  </ol> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jason_cuijiahui/article/details/76615080,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jason_cuijiahui/article/details/76615080,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
