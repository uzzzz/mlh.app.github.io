<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【支付系统学习笔记】-二支付系统设计（支付网关设计） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【支付系统学习笔记】-二支付系统设计（支付网关设计）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前言： &nbsp; 本文属于学习笔记，首先感谢原作者：凤凰牌老熊，博客链接：http://blog.lixf.cn/ 一 概述 在支付系统中，支付网关和支付渠道的对接是最核心的功能。其中支付网关是对外提供服务的接口，所有需要渠道支持的资金操作都需要通过网关分发到对应的渠道模块上。一旦定型，后续就很少，也很难调整。而支付渠道模块是接收网关的请求，调用渠道接口执行真正的资金操作。每个渠道的接口，传输方式都不尽相同，所以在这里，支付网关相对于支付渠道模块的作用，类似设计模式中的wrapper，封装各个渠道的差异，对网关呈现统一的接口。而网关的功能是为业务提供通用接口，一些和渠道交互的公共操作，也会放置到网关中。 我理解的是从上往下看流程就行。 支付系统对其他系统，特别是交易系统，提供的支付服务包括签约，支付，退款，充值，转帐，解约等。有些地方还会额外提供签约并支付的接口，用于支持在支付过程中绑卡。 每个服务实现的流程也是基本类似，包括下单，取消订单，退单，查单等操作。每个操作实现，都包括参数校验，支付路由，生成订单，风险评估，调用渠道服务，更新订单和发送消息这7步，对于一些比较复杂的渠道服务，还会涉及到异步同通知处理的步骤。 商户侧应用发起支付请求。注意，这个请求一般是从服务器端发起的。比如用户在手机端提交“立即支付”按钮后，商户的服务器端会先生成订单，然后请求支付网关执行支付。 支付请求被发送到支付（API)网关上。网关对这个请求进行一些通用的处理，比如QPS控制、验签等，然后根据支付请求的场景（网银、快捷、外卡等），调用对应的支付产品。 支付产品对用户请求进行预处理，包括执行参数校验、根据支付路由寻找合适的支付通道、评估交易风险、生成订单、调用通道落地执行支付、响应通道的结果并将交易结果通知到商户侧。 支付产品调用支付通道执行支付。这个请求并不是直接落地到通道上，而是通过支付通道前置来封装，由支付通道前置来完成和通道的交付。 支付产品是按照可以提供的支付服务来设计的。 支付通道前置，（以下在不引起混淆的情况下，都简称支付通道）负责和支付通道之间的通讯，调用支付通道接口完成最终的支付操作。 *********************************************************************************** 作者博客跟微信的不太一致，这里把相关内容整理过来： 1. 执行参数校验 所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击。 验证输入参数中各字段的有效性验证，比如用户ID,商户ID,价格，返回地址等参数。 验证账户状态。交易主体、交易对手等账户的状态是处于可交易的状态。 验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个URL地址，还需要校验下单时间和支付时间是否超过预定的间隔。 验证签名。签名也是为了防止支付接口被伪造。 一般签名是使用分发给商户的key来对输入参数拼接成的字符串做MD5 Hash或者RSA加密，然后作为一个参数随其他参数一起提交到服务器端。 2. 根据支付路由寻找合适的支付服务 根据用户选择的支付方式确定用来完成该操作的合适的支付渠道。用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或者银联来完成。那如何选择合适的支付渠道，就通过支付路由来实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案。 3. 评估交易风险 检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易。 阻断交易，说明该交易是高风险的，需要终止，不执行第5个步骤； 增强验证，说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易。 放行交易，即本次交易是安全的，可以继续往下走。 4 生成交易订单 将订单信息持久化到数据库中。当访问压力大的时候，数据库写入会成为一个瓶颈。 5. 调用支付渠道提供的服务 所有的支付服务都需要第三方通道来完成执行。一般银行渠道的调用比较简单，可以直接返回结果。一些第三方支付，支付宝，微信支付等，会通过异步接口来告知支付结果。 6. 更新订单 对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理。 7. 发送消息 通过消息来通知相关系统关于订单的变更。风控，信用BI等，都需要依赖这数据做准实时计算。 8. 异步通知 如上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时。引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果。对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方。 异步通知需要调用方提供一个回调地址，一般以http或者https的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔。 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统。 二 支付网关 支付网关是直接对接业务系统的接口，它本身并不执行任何支付相关的业务逻辑。它将支付产品接口中和业务无关的功能提取出来，在这里统一实现。这样在具体产品接口中，就无需考虑这些和业务无关的逻辑。支付网关设计还和对外的接口参数有关。 作者下面举例，支付宝（json）和微信(xml)的参数,PayPal是标准的Restful设计. 对电商支付平台来说，其定位更接近于一个聚合支付。聚合多种支付方式，为公司各个业务提供支持。 在这里，支付网关和支付产品的设计尤为关键。合理的接口设计能够大大降低支付渠道对接的开发工作量。一般支付产品不会超过10个，而根据公司的规模，对接的支付渠道超过100个都有可能。 三 设计原则 根据支付网关上实现的主要功能： API路由。在聚合支付场景下，当有多个支付产品可以提供支持时，使用支付网关可以让接入方对接时无需考虑支付产品的部署问题。 接口安全： 熔断、限流与隔离。 这对支付服务来说尤为重要。&nbsp; 如下功能，是在支付产品中提供： 风控拦截： 风控是和支付产品有关，不同产品的风控措施、处理对策也是不同的，所以风控是在产品层实现。 支付路由： 路由也是和产品有关。不同产品路由策略也不同。 参数校验： 这也是和支付产品相关的，不同的产品接口其参数也不同。 支付流程： 生成交易记录、落地渠道执行支付、同步和异步通知等操作。 如下功能，可以在产品层或者网关层实现： 身份验证： 确认付款方、收款方、渠道是否有执行当前操作的权限。 在那一层实现取决于这些信息是否有提炼为公共行为。 验签： 对接口参数进行签名并验证其签名。这是为了避免接口被盗刷和篡改的必要手段。如果对各个接口采用统一的签名规则，则可以在网关层实现。 原文作者还介绍了通用的签名和验签 ************************************************************ 四&nbsp;整体架构 支付网关前置 支付网关前置是对接业务系统，为其提供支付服务的模块。它是所有支付服务接口的集成前置，将不同支付渠道提供的接口通过统一的方式呈现给业务方。这样接入方就只需要对接支付网关，增加和调整支付渠道对业务方是透明的。 支付网关前置的设计对整个支付系统的稳定性、功能、性能以及其他非功能性需求有着直接的影响。 在支付网关中需要完成大量的操作，为了保证性能，这些操作都尽量异步化来处理。 支付网关前置应保持稳定，尽量减少系统重启等操作对业务方的影响。支付网关也避免不了升级和重启。这可通过基于Nginx的LBS(Load Balance System)网关来解决。LBS在这里有两个作用： 一个是实现负载均衡，一个是隔离支付网关重启对调用的影响。 支付网关也采用多台机器分布式部署，重启时，每个服务器逐个启动。某台服务器重启时，首先从LBS系统中取消注册，重启完成后，再重新注册到LBS上。这个过程对调用方是无感知的。 为了避免接口受攻击，在安全上，还得要求业务方通过HTTPS来访问接口，并提供防篡改机制。防篡改则通过接口参数签名来处理。现在主流的签名是对接口参数按照参数名称排序后，做加密和散列，参考微信的签名规范。 交易流水和记账 每一笔交易都需要记录流水，并登记到个人和机构的分户账户上，统计和分析也需要根据交易流水来更新相关数据。 而个人和机构账户总额更新、交易流水记录以及库存的处理，更是需要事务处理机制的支持。 从性能角度， 可以弱化了事务处理的要求，采用消息机制来异步化和交易相关的数据处理。 在支付网关前置的主流程中，仅记录交易流水，即将当前的请求保存到数据库中。 完成数据记录后，发送MQ出来，记账、统计、分析，都是接收MQ来完成数据处理。 涉及到本地资金支付，比如钱包支付，会需要分布式事务处理，扣减账号余额，记账，扣减库存等，每个操作失败，都要回滚。阿里有很不错的分享，这里不详细描述。 当交易量上来后，需要考虑交易表的分表分库的事情。分表分库有两个策略，按照流水号或者交易主体id来走。后者可以支持按用户来获取交易记录。我们用的是前者。后者可以走elastic，确保数据库专用。风控，信用和统计所需要的数据，通过MQ同步到Hbase里面。作为支付系统最有价值的数据，在存储上做到专库专用，无可厚非，毕竟存储成本还是廉价的。 风控模块 风控对支付的重要性怎么强调都不过分。有些系统在风控出问题时可以旁路风控，但是在支付系统中，风控出问题必须停止交易。 整体上，风控可以分为数据采集，数据分析，实时计算，规则配置，实时拦截等模块。风控本身是个大话题，以后专门讨论。又欠一个债。 但风控和交易的接口比较简单。对每一次交易，风控一般返回三个结果:拦截，增强验证，通过。通过指交易没有问题，可以直接放行。拦截则是阻止本次交易。增强验证则是交易存疑，需要用户进一步核实身份才能继续，比如输入手机号或者身份证号，一般用于身份被盗用的场景。而人工核实则是对交易有疑问，一般用于个人恶意消费满场景。 支付路由 需要平衡，用户少的银行考虑三方对接，不能只依赖单一第三方，遇到不稳定或者意外。总之，得对接多个渠道。对于交易量大的银行，还得考虑直联。支付路由的作用是定义对用户选用的银行卡或者其他支付方式，使用什么渠道来完成支付。 一般来说，银行会提供两种支付途径：无跳转的快捷支付接口和带跳转的网银接口。前者在绑卡，支付的时候，不需要跳到银行页面上去处理，后者则需要在银行的网银页面上完成。显然前者对用户来说体验要好多了，用户流程不会被打断。快捷支付要求支付系统在本地保存用户的支付信息，如卡号，登记手机。系统要确保这些信息不被泄漏。风险非常好，所以大部分银行要求接入方必须经过ADSS检验才能够接入快捷支付。 这种固定方式的接入有单点故障的问题，一旦某个渠道出问题，绑定的支付方式就无法使用。改进策略是为每个支付方式定义多个渠道，第一个渠道出问题即选择第二个，以此类推。当然，更进一步，可以为候选渠道定义权重，按照权重来选择支付方式。当渠道出问题，自动调整权重。 路由实现上还会更复杂，对同一张银行卡，运营上会要求在不同的系统上，比如android，iOS，windows上，或者不同地区，如大陆，台湾，香港，北美等，甚至不同业务上，采用不同渠道来支付。 我理解这里就是实践出真知，坑肯定不少。印象中给很久之前给网站做对接网银，就是各家银行不太一样。 支付渠道 如果采用微服务来实现，整体设计上，可以考虑将支付渠道分离、支付网关前置分离。支付渠道的微服务实现有两种策略，一种是按照服务来拆分，一种是按照渠道来拆分。 按渠道拆分，指每个渠道单独部署在一个容器中，对支付网关提供相同的服务。 按服务拆分，是按接口来拆分，分为支付，对账，退款等子系统，每个服务单独部署，所有容器的服务都实现在一起。 渠道拆分 按照服务来拆分的一个典型案例是大众点评网的早期实现。&nbsp;大众点评支付渠道网关系统的实践之路。 每个支付服务接口实现为一个独立的子系统，独立部署，通过支付网关前置来对外提供服务。 这篇文章里面也提到这种方式存在的问题， 银行的加密客户端会有各种奇葩的需求，有些可以支持linux，有些要windows系统，如何在一个容器中满足所有需求？ 这样拆分后，每个渠道接口独立部署。某个渠道出问题也不会影响其他渠道。至于渠道访问量小导致资源浪费问题，可以通过虚机或者docker的资源调度来解决，谁也不会在物理机上玩微服务。 对接渠道难点在于对输入输出做加密和解密，以及组装和解析报文。同一个渠道对不同的服务的加密解密方式是一样的，报文格式也是一样的。按渠道来构建服务可以共用这样方法，减少开发投入。 从安全的角度，按渠道划分也有优势。一般渠道都要求只对接到特定ip的机器，这样每个渠道对接系统所在的机器仅开放对渠道和支付网关前置机的访问白名单即可，尽可能的缩减被暴露的风险。 接入渠道 对于支付渠道，首先考虑的是接入哪些渠道。要对接的渠道按优先级有： 第三方支付，对大部分应用来说，支付宝和微信支付都是必须的，一般来说，这两者可以占到90%以上的交易量。用户不需要绑卡，授权后直接支付就行。各种平台都支持，性能和稳定性都不错。对于一些特殊业务，比如游戏，企业支付，可以查看一些专用的第三方支付平台。 银联，这货的存在，极大方便了和银行的对接。和第三方支付主要不同在两个地方一是需要绑卡，也就是用户先把卡号，手机，身份证号提供出来。这一步会折损不少用户。绑卡后，以后的支付操作就简单了，用户只需要输入密码就行。手机客户端不需要像第三方支付那样安装SDK，都在服务器端完成。当然，这是针对快捷支付。网银支付还是挺麻烦的。银联接入也需要ADSS认证。 银行，建议先看这一篇文章，了解下对接银行的难度。那最终需要选择哪些银行？先看个统计数据。 截至 2015 年底，我国银行业金融机构包括 5 家大型商业银行、12 家股份制商业银行、133 家城市商业银行、5 家民营银行、859 家农村商业银行、71 家农村合作银行、1373家农村信用社、1 家邮政储蓄银行、3 家政策性银行、 311 家村镇银行、48 家农村资金互助社。优先选择5家商业银行，他们占40%的交易量。其次是股份制银行和邮储。这就18家银行了。老板要是不满意，城商行和农商行加起来有1000多家呢。一般对接一个银行预计有3周左右的工作量，大部分银行需要专线接入，费用和带宽有关，一年也得几万费用。不同银行对接入环境有不同要求，这也是成本。另外，还有一个重大风险，就是央行在搞得网联系统，毕竟还没有出来，相关资料参考知乎上关于网联的一篇讨论。 手机支付，现在不少厂商都内置了各种支付，比如苹果的In-App支付， 三星支付、华为支付等， 这些支付仅针对特定的手机型号， 支持NFC等，根据业务需要也可以接入。 就是目前用户群不大，收益不明显。 话费支付， 这一块容易被人忽略，但考虑到国内不少职场人士，话费是公司报销的，每个月多的用不完，所以这块支付还是相当有市场的。 问题是，联通和移动两大运营商，不仅接口不能互通，内部各个地域也是各自为政，所以对接起来还是有点麻烦。不过话费支付领域也有类似支付宝微信的第三方支付公司，比如虹软、联动优势等公司。 阅读更多" />
<meta property="og:description" content="前言： &nbsp; 本文属于学习笔记，首先感谢原作者：凤凰牌老熊，博客链接：http://blog.lixf.cn/ 一 概述 在支付系统中，支付网关和支付渠道的对接是最核心的功能。其中支付网关是对外提供服务的接口，所有需要渠道支持的资金操作都需要通过网关分发到对应的渠道模块上。一旦定型，后续就很少，也很难调整。而支付渠道模块是接收网关的请求，调用渠道接口执行真正的资金操作。每个渠道的接口，传输方式都不尽相同，所以在这里，支付网关相对于支付渠道模块的作用，类似设计模式中的wrapper，封装各个渠道的差异，对网关呈现统一的接口。而网关的功能是为业务提供通用接口，一些和渠道交互的公共操作，也会放置到网关中。 我理解的是从上往下看流程就行。 支付系统对其他系统，特别是交易系统，提供的支付服务包括签约，支付，退款，充值，转帐，解约等。有些地方还会额外提供签约并支付的接口，用于支持在支付过程中绑卡。 每个服务实现的流程也是基本类似，包括下单，取消订单，退单，查单等操作。每个操作实现，都包括参数校验，支付路由，生成订单，风险评估，调用渠道服务，更新订单和发送消息这7步，对于一些比较复杂的渠道服务，还会涉及到异步同通知处理的步骤。 商户侧应用发起支付请求。注意，这个请求一般是从服务器端发起的。比如用户在手机端提交“立即支付”按钮后，商户的服务器端会先生成订单，然后请求支付网关执行支付。 支付请求被发送到支付（API)网关上。网关对这个请求进行一些通用的处理，比如QPS控制、验签等，然后根据支付请求的场景（网银、快捷、外卡等），调用对应的支付产品。 支付产品对用户请求进行预处理，包括执行参数校验、根据支付路由寻找合适的支付通道、评估交易风险、生成订单、调用通道落地执行支付、响应通道的结果并将交易结果通知到商户侧。 支付产品调用支付通道执行支付。这个请求并不是直接落地到通道上，而是通过支付通道前置来封装，由支付通道前置来完成和通道的交付。 支付产品是按照可以提供的支付服务来设计的。 支付通道前置，（以下在不引起混淆的情况下，都简称支付通道）负责和支付通道之间的通讯，调用支付通道接口完成最终的支付操作。 *********************************************************************************** 作者博客跟微信的不太一致，这里把相关内容整理过来： 1. 执行参数校验 所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击。 验证输入参数中各字段的有效性验证，比如用户ID,商户ID,价格，返回地址等参数。 验证账户状态。交易主体、交易对手等账户的状态是处于可交易的状态。 验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个URL地址，还需要校验下单时间和支付时间是否超过预定的间隔。 验证签名。签名也是为了防止支付接口被伪造。 一般签名是使用分发给商户的key来对输入参数拼接成的字符串做MD5 Hash或者RSA加密，然后作为一个参数随其他参数一起提交到服务器端。 2. 根据支付路由寻找合适的支付服务 根据用户选择的支付方式确定用来完成该操作的合适的支付渠道。用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或者银联来完成。那如何选择合适的支付渠道，就通过支付路由来实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案。 3. 评估交易风险 检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易。 阻断交易，说明该交易是高风险的，需要终止，不执行第5个步骤； 增强验证，说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易。 放行交易，即本次交易是安全的，可以继续往下走。 4 生成交易订单 将订单信息持久化到数据库中。当访问压力大的时候，数据库写入会成为一个瓶颈。 5. 调用支付渠道提供的服务 所有的支付服务都需要第三方通道来完成执行。一般银行渠道的调用比较简单，可以直接返回结果。一些第三方支付，支付宝，微信支付等，会通过异步接口来告知支付结果。 6. 更新订单 对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理。 7. 发送消息 通过消息来通知相关系统关于订单的变更。风控，信用BI等，都需要依赖这数据做准实时计算。 8. 异步通知 如上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时。引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果。对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方。 异步通知需要调用方提供一个回调地址，一般以http或者https的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔。 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统。 二 支付网关 支付网关是直接对接业务系统的接口，它本身并不执行任何支付相关的业务逻辑。它将支付产品接口中和业务无关的功能提取出来，在这里统一实现。这样在具体产品接口中，就无需考虑这些和业务无关的逻辑。支付网关设计还和对外的接口参数有关。 作者下面举例，支付宝（json）和微信(xml)的参数,PayPal是标准的Restful设计. 对电商支付平台来说，其定位更接近于一个聚合支付。聚合多种支付方式，为公司各个业务提供支持。 在这里，支付网关和支付产品的设计尤为关键。合理的接口设计能够大大降低支付渠道对接的开发工作量。一般支付产品不会超过10个，而根据公司的规模，对接的支付渠道超过100个都有可能。 三 设计原则 根据支付网关上实现的主要功能： API路由。在聚合支付场景下，当有多个支付产品可以提供支持时，使用支付网关可以让接入方对接时无需考虑支付产品的部署问题。 接口安全： 熔断、限流与隔离。 这对支付服务来说尤为重要。&nbsp; 如下功能，是在支付产品中提供： 风控拦截： 风控是和支付产品有关，不同产品的风控措施、处理对策也是不同的，所以风控是在产品层实现。 支付路由： 路由也是和产品有关。不同产品路由策略也不同。 参数校验： 这也是和支付产品相关的，不同的产品接口其参数也不同。 支付流程： 生成交易记录、落地渠道执行支付、同步和异步通知等操作。 如下功能，可以在产品层或者网关层实现： 身份验证： 确认付款方、收款方、渠道是否有执行当前操作的权限。 在那一层实现取决于这些信息是否有提炼为公共行为。 验签： 对接口参数进行签名并验证其签名。这是为了避免接口被盗刷和篡改的必要手段。如果对各个接口采用统一的签名规则，则可以在网关层实现。 原文作者还介绍了通用的签名和验签 ************************************************************ 四&nbsp;整体架构 支付网关前置 支付网关前置是对接业务系统，为其提供支付服务的模块。它是所有支付服务接口的集成前置，将不同支付渠道提供的接口通过统一的方式呈现给业务方。这样接入方就只需要对接支付网关，增加和调整支付渠道对业务方是透明的。 支付网关前置的设计对整个支付系统的稳定性、功能、性能以及其他非功能性需求有着直接的影响。 在支付网关中需要完成大量的操作，为了保证性能，这些操作都尽量异步化来处理。 支付网关前置应保持稳定，尽量减少系统重启等操作对业务方的影响。支付网关也避免不了升级和重启。这可通过基于Nginx的LBS(Load Balance System)网关来解决。LBS在这里有两个作用： 一个是实现负载均衡，一个是隔离支付网关重启对调用的影响。 支付网关也采用多台机器分布式部署，重启时，每个服务器逐个启动。某台服务器重启时，首先从LBS系统中取消注册，重启完成后，再重新注册到LBS上。这个过程对调用方是无感知的。 为了避免接口受攻击，在安全上，还得要求业务方通过HTTPS来访问接口，并提供防篡改机制。防篡改则通过接口参数签名来处理。现在主流的签名是对接口参数按照参数名称排序后，做加密和散列，参考微信的签名规范。 交易流水和记账 每一笔交易都需要记录流水，并登记到个人和机构的分户账户上，统计和分析也需要根据交易流水来更新相关数据。 而个人和机构账户总额更新、交易流水记录以及库存的处理，更是需要事务处理机制的支持。 从性能角度， 可以弱化了事务处理的要求，采用消息机制来异步化和交易相关的数据处理。 在支付网关前置的主流程中，仅记录交易流水，即将当前的请求保存到数据库中。 完成数据记录后，发送MQ出来，记账、统计、分析，都是接收MQ来完成数据处理。 涉及到本地资金支付，比如钱包支付，会需要分布式事务处理，扣减账号余额，记账，扣减库存等，每个操作失败，都要回滚。阿里有很不错的分享，这里不详细描述。 当交易量上来后，需要考虑交易表的分表分库的事情。分表分库有两个策略，按照流水号或者交易主体id来走。后者可以支持按用户来获取交易记录。我们用的是前者。后者可以走elastic，确保数据库专用。风控，信用和统计所需要的数据，通过MQ同步到Hbase里面。作为支付系统最有价值的数据，在存储上做到专库专用，无可厚非，毕竟存储成本还是廉价的。 风控模块 风控对支付的重要性怎么强调都不过分。有些系统在风控出问题时可以旁路风控，但是在支付系统中，风控出问题必须停止交易。 整体上，风控可以分为数据采集，数据分析，实时计算，规则配置，实时拦截等模块。风控本身是个大话题，以后专门讨论。又欠一个债。 但风控和交易的接口比较简单。对每一次交易，风控一般返回三个结果:拦截，增强验证，通过。通过指交易没有问题，可以直接放行。拦截则是阻止本次交易。增强验证则是交易存疑，需要用户进一步核实身份才能继续，比如输入手机号或者身份证号，一般用于身份被盗用的场景。而人工核实则是对交易有疑问，一般用于个人恶意消费满场景。 支付路由 需要平衡，用户少的银行考虑三方对接，不能只依赖单一第三方，遇到不稳定或者意外。总之，得对接多个渠道。对于交易量大的银行，还得考虑直联。支付路由的作用是定义对用户选用的银行卡或者其他支付方式，使用什么渠道来完成支付。 一般来说，银行会提供两种支付途径：无跳转的快捷支付接口和带跳转的网银接口。前者在绑卡，支付的时候，不需要跳到银行页面上去处理，后者则需要在银行的网银页面上完成。显然前者对用户来说体验要好多了，用户流程不会被打断。快捷支付要求支付系统在本地保存用户的支付信息，如卡号，登记手机。系统要确保这些信息不被泄漏。风险非常好，所以大部分银行要求接入方必须经过ADSS检验才能够接入快捷支付。 这种固定方式的接入有单点故障的问题，一旦某个渠道出问题，绑定的支付方式就无法使用。改进策略是为每个支付方式定义多个渠道，第一个渠道出问题即选择第二个，以此类推。当然，更进一步，可以为候选渠道定义权重，按照权重来选择支付方式。当渠道出问题，自动调整权重。 路由实现上还会更复杂，对同一张银行卡，运营上会要求在不同的系统上，比如android，iOS，windows上，或者不同地区，如大陆，台湾，香港，北美等，甚至不同业务上，采用不同渠道来支付。 我理解这里就是实践出真知，坑肯定不少。印象中给很久之前给网站做对接网银，就是各家银行不太一样。 支付渠道 如果采用微服务来实现，整体设计上，可以考虑将支付渠道分离、支付网关前置分离。支付渠道的微服务实现有两种策略，一种是按照服务来拆分，一种是按照渠道来拆分。 按渠道拆分，指每个渠道单独部署在一个容器中，对支付网关提供相同的服务。 按服务拆分，是按接口来拆分，分为支付，对账，退款等子系统，每个服务单独部署，所有容器的服务都实现在一起。 渠道拆分 按照服务来拆分的一个典型案例是大众点评网的早期实现。&nbsp;大众点评支付渠道网关系统的实践之路。 每个支付服务接口实现为一个独立的子系统，独立部署，通过支付网关前置来对外提供服务。 这篇文章里面也提到这种方式存在的问题， 银行的加密客户端会有各种奇葩的需求，有些可以支持linux，有些要windows系统，如何在一个容器中满足所有需求？ 这样拆分后，每个渠道接口独立部署。某个渠道出问题也不会影响其他渠道。至于渠道访问量小导致资源浪费问题，可以通过虚机或者docker的资源调度来解决，谁也不会在物理机上玩微服务。 对接渠道难点在于对输入输出做加密和解密，以及组装和解析报文。同一个渠道对不同的服务的加密解密方式是一样的，报文格式也是一样的。按渠道来构建服务可以共用这样方法，减少开发投入。 从安全的角度，按渠道划分也有优势。一般渠道都要求只对接到特定ip的机器，这样每个渠道对接系统所在的机器仅开放对渠道和支付网关前置机的访问白名单即可，尽可能的缩减被暴露的风险。 接入渠道 对于支付渠道，首先考虑的是接入哪些渠道。要对接的渠道按优先级有： 第三方支付，对大部分应用来说，支付宝和微信支付都是必须的，一般来说，这两者可以占到90%以上的交易量。用户不需要绑卡，授权后直接支付就行。各种平台都支持，性能和稳定性都不错。对于一些特殊业务，比如游戏，企业支付，可以查看一些专用的第三方支付平台。 银联，这货的存在，极大方便了和银行的对接。和第三方支付主要不同在两个地方一是需要绑卡，也就是用户先把卡号，手机，身份证号提供出来。这一步会折损不少用户。绑卡后，以后的支付操作就简单了，用户只需要输入密码就行。手机客户端不需要像第三方支付那样安装SDK，都在服务器端完成。当然，这是针对快捷支付。网银支付还是挺麻烦的。银联接入也需要ADSS认证。 银行，建议先看这一篇文章，了解下对接银行的难度。那最终需要选择哪些银行？先看个统计数据。 截至 2015 年底，我国银行业金融机构包括 5 家大型商业银行、12 家股份制商业银行、133 家城市商业银行、5 家民营银行、859 家农村商业银行、71 家农村合作银行、1373家农村信用社、1 家邮政储蓄银行、3 家政策性银行、 311 家村镇银行、48 家农村资金互助社。优先选择5家商业银行，他们占40%的交易量。其次是股份制银行和邮储。这就18家银行了。老板要是不满意，城商行和农商行加起来有1000多家呢。一般对接一个银行预计有3周左右的工作量，大部分银行需要专线接入，费用和带宽有关，一年也得几万费用。不同银行对接入环境有不同要求，这也是成本。另外，还有一个重大风险，就是央行在搞得网联系统，毕竟还没有出来，相关资料参考知乎上关于网联的一篇讨论。 手机支付，现在不少厂商都内置了各种支付，比如苹果的In-App支付， 三星支付、华为支付等， 这些支付仅针对特定的手机型号， 支持NFC等，根据业务需要也可以接入。 就是目前用户群不大，收益不明显。 话费支付， 这一块容易被人忽略，但考虑到国内不少职场人士，话费是公司报销的，每个月多的用不完，所以这块支付还是相当有市场的。 问题是，联通和移动两大运营商，不仅接口不能互通，内部各个地域也是各自为政，所以对接起来还是有点麻烦。不过话费支付领域也有类似支付宝微信的第三方支付公司，比如虹软、联动优势等公司。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"前言： &nbsp; 本文属于学习笔记，首先感谢原作者：凤凰牌老熊，博客链接：http://blog.lixf.cn/ 一 概述 在支付系统中，支付网关和支付渠道的对接是最核心的功能。其中支付网关是对外提供服务的接口，所有需要渠道支持的资金操作都需要通过网关分发到对应的渠道模块上。一旦定型，后续就很少，也很难调整。而支付渠道模块是接收网关的请求，调用渠道接口执行真正的资金操作。每个渠道的接口，传输方式都不尽相同，所以在这里，支付网关相对于支付渠道模块的作用，类似设计模式中的wrapper，封装各个渠道的差异，对网关呈现统一的接口。而网关的功能是为业务提供通用接口，一些和渠道交互的公共操作，也会放置到网关中。 我理解的是从上往下看流程就行。 支付系统对其他系统，特别是交易系统，提供的支付服务包括签约，支付，退款，充值，转帐，解约等。有些地方还会额外提供签约并支付的接口，用于支持在支付过程中绑卡。 每个服务实现的流程也是基本类似，包括下单，取消订单，退单，查单等操作。每个操作实现，都包括参数校验，支付路由，生成订单，风险评估，调用渠道服务，更新订单和发送消息这7步，对于一些比较复杂的渠道服务，还会涉及到异步同通知处理的步骤。 商户侧应用发起支付请求。注意，这个请求一般是从服务器端发起的。比如用户在手机端提交“立即支付”按钮后，商户的服务器端会先生成订单，然后请求支付网关执行支付。 支付请求被发送到支付（API)网关上。网关对这个请求进行一些通用的处理，比如QPS控制、验签等，然后根据支付请求的场景（网银、快捷、外卡等），调用对应的支付产品。 支付产品对用户请求进行预处理，包括执行参数校验、根据支付路由寻找合适的支付通道、评估交易风险、生成订单、调用通道落地执行支付、响应通道的结果并将交易结果通知到商户侧。 支付产品调用支付通道执行支付。这个请求并不是直接落地到通道上，而是通过支付通道前置来封装，由支付通道前置来完成和通道的交付。 支付产品是按照可以提供的支付服务来设计的。 支付通道前置，（以下在不引起混淆的情况下，都简称支付通道）负责和支付通道之间的通讯，调用支付通道接口完成最终的支付操作。 *********************************************************************************** 作者博客跟微信的不太一致，这里把相关内容整理过来： 1. 执行参数校验 所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击。 验证输入参数中各字段的有效性验证，比如用户ID,商户ID,价格，返回地址等参数。 验证账户状态。交易主体、交易对手等账户的状态是处于可交易的状态。 验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个URL地址，还需要校验下单时间和支付时间是否超过预定的间隔。 验证签名。签名也是为了防止支付接口被伪造。 一般签名是使用分发给商户的key来对输入参数拼接成的字符串做MD5 Hash或者RSA加密，然后作为一个参数随其他参数一起提交到服务器端。 2. 根据支付路由寻找合适的支付服务 根据用户选择的支付方式确定用来完成该操作的合适的支付渠道。用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或者银联来完成。那如何选择合适的支付渠道，就通过支付路由来实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案。 3. 评估交易风险 检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易。 阻断交易，说明该交易是高风险的，需要终止，不执行第5个步骤； 增强验证，说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易。 放行交易，即本次交易是安全的，可以继续往下走。 4 生成交易订单 将订单信息持久化到数据库中。当访问压力大的时候，数据库写入会成为一个瓶颈。 5. 调用支付渠道提供的服务 所有的支付服务都需要第三方通道来完成执行。一般银行渠道的调用比较简单，可以直接返回结果。一些第三方支付，支付宝，微信支付等，会通过异步接口来告知支付结果。 6. 更新订单 对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理。 7. 发送消息 通过消息来通知相关系统关于订单的变更。风控，信用BI等，都需要依赖这数据做准实时计算。 8. 异步通知 如上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时。引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果。对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方。 异步通知需要调用方提供一个回调地址，一般以http或者https的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔。 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统。 二 支付网关 支付网关是直接对接业务系统的接口，它本身并不执行任何支付相关的业务逻辑。它将支付产品接口中和业务无关的功能提取出来，在这里统一实现。这样在具体产品接口中，就无需考虑这些和业务无关的逻辑。支付网关设计还和对外的接口参数有关。 作者下面举例，支付宝（json）和微信(xml)的参数,PayPal是标准的Restful设计. 对电商支付平台来说，其定位更接近于一个聚合支付。聚合多种支付方式，为公司各个业务提供支持。 在这里，支付网关和支付产品的设计尤为关键。合理的接口设计能够大大降低支付渠道对接的开发工作量。一般支付产品不会超过10个，而根据公司的规模，对接的支付渠道超过100个都有可能。 三 设计原则 根据支付网关上实现的主要功能： API路由。在聚合支付场景下，当有多个支付产品可以提供支持时，使用支付网关可以让接入方对接时无需考虑支付产品的部署问题。 接口安全： 熔断、限流与隔离。 这对支付服务来说尤为重要。&nbsp; 如下功能，是在支付产品中提供： 风控拦截： 风控是和支付产品有关，不同产品的风控措施、处理对策也是不同的，所以风控是在产品层实现。 支付路由： 路由也是和产品有关。不同产品路由策略也不同。 参数校验： 这也是和支付产品相关的，不同的产品接口其参数也不同。 支付流程： 生成交易记录、落地渠道执行支付、同步和异步通知等操作。 如下功能，可以在产品层或者网关层实现： 身份验证： 确认付款方、收款方、渠道是否有执行当前操作的权限。 在那一层实现取决于这些信息是否有提炼为公共行为。 验签： 对接口参数进行签名并验证其签名。这是为了避免接口被盗刷和篡改的必要手段。如果对各个接口采用统一的签名规则，则可以在网关层实现。 原文作者还介绍了通用的签名和验签 ************************************************************ 四&nbsp;整体架构 支付网关前置 支付网关前置是对接业务系统，为其提供支付服务的模块。它是所有支付服务接口的集成前置，将不同支付渠道提供的接口通过统一的方式呈现给业务方。这样接入方就只需要对接支付网关，增加和调整支付渠道对业务方是透明的。 支付网关前置的设计对整个支付系统的稳定性、功能、性能以及其他非功能性需求有着直接的影响。 在支付网关中需要完成大量的操作，为了保证性能，这些操作都尽量异步化来处理。 支付网关前置应保持稳定，尽量减少系统重启等操作对业务方的影响。支付网关也避免不了升级和重启。这可通过基于Nginx的LBS(Load Balance System)网关来解决。LBS在这里有两个作用： 一个是实现负载均衡，一个是隔离支付网关重启对调用的影响。 支付网关也采用多台机器分布式部署，重启时，每个服务器逐个启动。某台服务器重启时，首先从LBS系统中取消注册，重启完成后，再重新注册到LBS上。这个过程对调用方是无感知的。 为了避免接口受攻击，在安全上，还得要求业务方通过HTTPS来访问接口，并提供防篡改机制。防篡改则通过接口参数签名来处理。现在主流的签名是对接口参数按照参数名称排序后，做加密和散列，参考微信的签名规范。 交易流水和记账 每一笔交易都需要记录流水，并登记到个人和机构的分户账户上，统计和分析也需要根据交易流水来更新相关数据。 而个人和机构账户总额更新、交易流水记录以及库存的处理，更是需要事务处理机制的支持。 从性能角度， 可以弱化了事务处理的要求，采用消息机制来异步化和交易相关的数据处理。 在支付网关前置的主流程中，仅记录交易流水，即将当前的请求保存到数据库中。 完成数据记录后，发送MQ出来，记账、统计、分析，都是接收MQ来完成数据处理。 涉及到本地资金支付，比如钱包支付，会需要分布式事务处理，扣减账号余额，记账，扣减库存等，每个操作失败，都要回滚。阿里有很不错的分享，这里不详细描述。 当交易量上来后，需要考虑交易表的分表分库的事情。分表分库有两个策略，按照流水号或者交易主体id来走。后者可以支持按用户来获取交易记录。我们用的是前者。后者可以走elastic，确保数据库专用。风控，信用和统计所需要的数据，通过MQ同步到Hbase里面。作为支付系统最有价值的数据，在存储上做到专库专用，无可厚非，毕竟存储成本还是廉价的。 风控模块 风控对支付的重要性怎么强调都不过分。有些系统在风控出问题时可以旁路风控，但是在支付系统中，风控出问题必须停止交易。 整体上，风控可以分为数据采集，数据分析，实时计算，规则配置，实时拦截等模块。风控本身是个大话题，以后专门讨论。又欠一个债。 但风控和交易的接口比较简单。对每一次交易，风控一般返回三个结果:拦截，增强验证，通过。通过指交易没有问题，可以直接放行。拦截则是阻止本次交易。增强验证则是交易存疑，需要用户进一步核实身份才能继续，比如输入手机号或者身份证号，一般用于身份被盗用的场景。而人工核实则是对交易有疑问，一般用于个人恶意消费满场景。 支付路由 需要平衡，用户少的银行考虑三方对接，不能只依赖单一第三方，遇到不稳定或者意外。总之，得对接多个渠道。对于交易量大的银行，还得考虑直联。支付路由的作用是定义对用户选用的银行卡或者其他支付方式，使用什么渠道来完成支付。 一般来说，银行会提供两种支付途径：无跳转的快捷支付接口和带跳转的网银接口。前者在绑卡，支付的时候，不需要跳到银行页面上去处理，后者则需要在银行的网银页面上完成。显然前者对用户来说体验要好多了，用户流程不会被打断。快捷支付要求支付系统在本地保存用户的支付信息，如卡号，登记手机。系统要确保这些信息不被泄漏。风险非常好，所以大部分银行要求接入方必须经过ADSS检验才能够接入快捷支付。 这种固定方式的接入有单点故障的问题，一旦某个渠道出问题，绑定的支付方式就无法使用。改进策略是为每个支付方式定义多个渠道，第一个渠道出问题即选择第二个，以此类推。当然，更进一步，可以为候选渠道定义权重，按照权重来选择支付方式。当渠道出问题，自动调整权重。 路由实现上还会更复杂，对同一张银行卡，运营上会要求在不同的系统上，比如android，iOS，windows上，或者不同地区，如大陆，台湾，香港，北美等，甚至不同业务上，采用不同渠道来支付。 我理解这里就是实践出真知，坑肯定不少。印象中给很久之前给网站做对接网银，就是各家银行不太一样。 支付渠道 如果采用微服务来实现，整体设计上，可以考虑将支付渠道分离、支付网关前置分离。支付渠道的微服务实现有两种策略，一种是按照服务来拆分，一种是按照渠道来拆分。 按渠道拆分，指每个渠道单独部署在一个容器中，对支付网关提供相同的服务。 按服务拆分，是按接口来拆分，分为支付，对账，退款等子系统，每个服务单独部署，所有容器的服务都实现在一起。 渠道拆分 按照服务来拆分的一个典型案例是大众点评网的早期实现。&nbsp;大众点评支付渠道网关系统的实践之路。 每个支付服务接口实现为一个独立的子系统，独立部署，通过支付网关前置来对外提供服务。 这篇文章里面也提到这种方式存在的问题， 银行的加密客户端会有各种奇葩的需求，有些可以支持linux，有些要windows系统，如何在一个容器中满足所有需求？ 这样拆分后，每个渠道接口独立部署。某个渠道出问题也不会影响其他渠道。至于渠道访问量小导致资源浪费问题，可以通过虚机或者docker的资源调度来解决，谁也不会在物理机上玩微服务。 对接渠道难点在于对输入输出做加密和解密，以及组装和解析报文。同一个渠道对不同的服务的加密解密方式是一样的，报文格式也是一样的。按渠道来构建服务可以共用这样方法，减少开发投入。 从安全的角度，按渠道划分也有优势。一般渠道都要求只对接到特定ip的机器，这样每个渠道对接系统所在的机器仅开放对渠道和支付网关前置机的访问白名单即可，尽可能的缩减被暴露的风险。 接入渠道 对于支付渠道，首先考虑的是接入哪些渠道。要对接的渠道按优先级有： 第三方支付，对大部分应用来说，支付宝和微信支付都是必须的，一般来说，这两者可以占到90%以上的交易量。用户不需要绑卡，授权后直接支付就行。各种平台都支持，性能和稳定性都不错。对于一些特殊业务，比如游戏，企业支付，可以查看一些专用的第三方支付平台。 银联，这货的存在，极大方便了和银行的对接。和第三方支付主要不同在两个地方一是需要绑卡，也就是用户先把卡号，手机，身份证号提供出来。这一步会折损不少用户。绑卡后，以后的支付操作就简单了，用户只需要输入密码就行。手机客户端不需要像第三方支付那样安装SDK，都在服务器端完成。当然，这是针对快捷支付。网银支付还是挺麻烦的。银联接入也需要ADSS认证。 银行，建议先看这一篇文章，了解下对接银行的难度。那最终需要选择哪些银行？先看个统计数据。 截至 2015 年底，我国银行业金融机构包括 5 家大型商业银行、12 家股份制商业银行、133 家城市商业银行、5 家民营银行、859 家农村商业银行、71 家农村合作银行、1373家农村信用社、1 家邮政储蓄银行、3 家政策性银行、 311 家村镇银行、48 家农村资金互助社。优先选择5家商业银行，他们占40%的交易量。其次是股份制银行和邮储。这就18家银行了。老板要是不满意，城商行和农商行加起来有1000多家呢。一般对接一个银行预计有3周左右的工作量，大部分银行需要专线接入，费用和带宽有关，一年也得几万费用。不同银行对接入环境有不同要求，这也是成本。另外，还有一个重大风险，就是央行在搞得网联系统，毕竟还没有出来，相关资料参考知乎上关于网联的一篇讨论。 手机支付，现在不少厂商都内置了各种支付，比如苹果的In-App支付， 三星支付、华为支付等， 这些支付仅针对特定的手机型号， 支持NFC等，根据业务需要也可以接入。 就是目前用户群不大，收益不明显。 话费支付， 这一块容易被人忽略，但考虑到国内不少职场人士，话费是公司报销的，每个月多的用不完，所以这块支付还是相当有市场的。 问题是，联通和移动两大运营商，不仅接口不能互通，内部各个地域也是各自为政，所以对接起来还是有点麻烦。不过话费支付领域也有类似支付宝微信的第三方支付公司，比如虹软、联动优势等公司。 阅读更多","@type":"BlogPosting","url":"/2017/08/13/929338031579ccf8f58ef492dbe0b807.html","headline":"【支付系统学习笔记】-二支付系统设计（支付网关设计）","dateModified":"2017-08-13T00:00:00+08:00","datePublished":"2017-08-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/08/13/929338031579ccf8f58ef492dbe0b807.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【支付系统学习笔记】-二支付系统设计（支付网关设计）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <p>前言：</p> 
  <p>&nbsp; 本文属于学习笔记，<span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;line-height:35px;">首先感谢原作者：凤凰牌老熊，博客链接：</span><span style="color:rgb(62,62,62);font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;font-size:16px;line-height:24px;"><a href="http://blog.lixf.cn/" rel="nofollow" style="text-decoration:none;color:rgb(12,137,207);">http://blog.lixf.cn/</a></span></p> 
  <h1>一 概述</h1> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">在支付系统中，支付网关和支付渠道的对接是最核心的功能。其中支付网关是对外提供服务的接口，所有需要渠道支持的资金操作都需要通过网关分发到对应的渠道模块上。一旦定型，后续就很少，也很难调整。而支付渠道模块是接收网关的请求，调用渠道接口执行真正的资金操作。每个渠道的接口，传输方式都不尽相同，所以在这里，支付网关相对于支付渠道模块的作用，类似设计模式中的wrapper，封装各个渠道的差异，对网关呈现统一的接口。而网关的功能是为业务提供通用接口，一些和渠道交互的公共操作，也会放置到网关中。</span><br></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170813214346157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9odTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">我理解的是从上往下看流程就行。</span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">支付系统对其他系统，特别是交易系统，提供的支付服务包括签约，支付，退款，充值，转帐，解约等。有些地方还会额外提供签约并支付的接口，用于支持在支付过程中绑卡。 每个服务实现的流程也是基本类似，包括下单，取消订单，退单，查单等操作。每个操作实现，都包括参数校验，支付路由，生成订单，风险评估，调用渠道服务，更新订单和发送消息这7步，对于一些比较复杂的渠道服务，还会涉及到异步同通知处理的步骤。</span><br></span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170813215051915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9odTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></span></p> 
  <p></p> 
  <ol style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">
   <li>商户侧应用发起支付请求。注意，这个请求一般是从服务器端发起的。比如用户在手机端提交“立即支付”按钮后，商户的服务器端会先生成订单，然后请求支付网关执行支付。</li>
   <li>支付请求被发送到支付（API)网关上。网关对这个请求进行一些通用的处理，比如QPS控制、验签等，然后根据支付请求的场景（网银、快捷、外卡等），调用对应的支付产品。</li>
   <li>支付产品对用户请求进行预处理，包括执行参数校验、根据支付路由寻找合适的支付通道、评估交易风险、生成订单、调用通道落地执行支付、响应通道的结果并将交易结果通知到商户侧。</li>
   <li>支付产品调用支付通道执行支付。这个请求并不是直接落地到通道上，而是通过支付通道前置来封装，由支付通道前置来完成和通道的交付。 支付产品是按照可以提供的支付服务来设计的。</li>
   <li>支付通道前置，（以下在不引起混淆的情况下，都简称支付通道）负责和支付通道之间的通讯，调用支付通道接口完成最终的支付操作。</li>
  </ol>
  <div>
   <span style="color:#404040;"><span style="font-size:16px;line-height:27.2px;">***********************************************************************************</span></span>
  </div> 
  <div>
   <span style="color:#404040;"><span style="font-size:16px;line-height:27.2px;">作者博客跟微信的不太一致，这里把相关内容整理过来：</span></span>
  </div> 
  <div> 
   <p style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;clear:both;min-height:1em;"> <span style="font-weight:700;">1. 执行参数校验</span></p> 
   <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击。</span></p> 
   <ul class="list-paddingleft-2">
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">验证输入参数中各字段的有效性验证，比如用户ID,商户ID,价格，返回地址等参数。</span></p> </li>
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">验证账户状态。交易主体、交易对手等账户的状态是处于可交易的状态。</span></p> </li>
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个URL地址，还需要校验下单时间和支付时间是否超过预定的间隔。</span></p> </li>
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">验证签名。签名也是为了防止支付接口被伪造。 一般签名是使用分发给商户的key来对输入参数拼接成的字符串做MD5 Hash或者RSA加密，然后作为一个参数随其他参数一起提交到服务器端。</span></p> </li>
   </ul>
   <span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><strong>2. 根据支付路由寻找合适的支付服务</strong></span>
   <br>
  </div> 
  <div>
   <span style="font-size:14px;"><span></span>根据用户选择的支付方式确定用来完成该操作的合适的支付渠道。用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或者银联来完成。那如何选择合适的支付渠道，就通过支付路由来实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案。</span>
   <br>
  </div> 
  <div>
   <span style="color:#404040;"><span style="font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><strong>3. 评估交易风险</strong></span><br></span></span>
  </div> 
  <div>
   <span style="font-size:14px;">检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易。<br></span>
  </div> 
  <div> 
   <ol class="list-paddingleft-2">
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">阻断交易，说明该交易是高风险的，需要终止，不执行第5个步骤；</span></p> </li>
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">增强验证，说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易。</span></p> </li>
    <li> <p style="clear:both;min-height:1em;"> <span style="font-size:14px;">放行交易，即本次交易是安全的，可以继续往下走。</span></p> </li>
   </ol>
   <div>
    <span style="font-size:14px;">4</span>
    <span style="font-weight:700;color:rgb(64,64,64);font-size:16px;line-height:27.2px;">生成交易订单</span>
    <span style="font-size:14px;"></span> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 将订单信息持久化到数据库中。当访问压力大的时候，数据库写入会成为一个瓶颈。</p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> <span style="font-weight:700;">5. 调用支付渠道提供的服务</span></p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 所有的支付服务都需要第三方通道来完成执行。一般银行渠道的调用比较简单，可以直接返回结果。一些第三方支付，支付宝，微信支付等，会通过异步接口来告知支付结果。</p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> <span style="font-weight:700;">6. 更新订单</span></p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理。</p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> <span style="font-weight:700;">7. 发送消息</span></p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 通过消息来通知相关系统关于订单的变更。风控，信用BI等，都需要依赖这数据做准实时计算。</p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> <span style="font-weight:700;">8. 异步通知</span></p> 
    <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 如上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时。引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果。对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方。 异步通知需要调用方提供一个回调地址，一般以http或者https的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔。 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统。</p> 
   </div> 
  </div> 
  <h1>二 支付网关</h1> 
  <p>支付网关是直接对接业务系统的接口，它本身并不执行任何支付相关的业务逻辑。它将支付产品接口中和业务无关的功能提取出来，在这里统一实现。这样在具体产品接口中，就无需考虑这些和业务无关的逻辑。支付网关设计还和对外的接口参数有关。<br></p> 
  <p>作者下面举例，支付宝（json）和微信(xml)的参数,PayPal是标准的Restful设计.</p> 
  <p>对电商支付平台来说，其定位更接近于一个聚合支付。聚合多种支付方式，为公司各个业务提供支持。 在这里，支付网关和支付产品的设计尤为关键。合理的接口设计能够大大降低支付渠道对接的开发工作量。一般支付产品不会超过10个，而根据公司的规模，对接的支付渠道超过100个都有可能。<br></p> 
  <h1>三 设计原则</h1> 
  <p><span style="font-size:14px;">根据支付网关上实现的主要功能：</span></p> 
  <ol>
   <li><span style="font-size:14px;">API路由。在聚合支付场景下，当有多个支付产品可以提供支持时，使用支付网关可以让接入方对接时无需考虑支付产品的部署问题。</span></li>
  </ol>
  <ol>
   <li><span style="font-size:14px;">接口安全： 熔断、限流与隔离。 这对支付服务来说尤为重要。&nbsp;</span></li>
  </ol>
  <div> 
   <p><span style="font-size:14px;">如下功能，是在支付产品中提供：</span></p> 
   <ol>
    <li><span style="font-size:14px;">风控拦截： 风控是和支付产品有关，不同产品的风控措施、处理对策也是不同的，所以风控是在产品层实现。</span></li>
    <li><span style="font-size:14px;">支付路由： 路由也是和产品有关。不同产品路由策略也不同。</span></li>
    <li><span style="font-size:14px;">参数校验： 这也是和支付产品相关的，不同的产品接口其参数也不同。</span></li>
    <li><span style="font-size:14px;">支付流程： 生成交易记录、落地渠道执行支付、同步和异步通知等操作。</span></li>
   </ol>
   <span style="font-size:14px;">如下功能，可以在产品层或者网关层实现：</span>
   <ol>
    <li><span style="font-size:14px;">身份验证： 确认付款方、收款方、渠道是否有执行当前操作的权限。 在那一层实现取决于这些信息是否有提炼为公共行为。</span></li>
    <li><span style="font-size:14px;">验签： 对接口参数进行签名并验证其签名。这是为了避免接口被盗刷和篡改的必要手段。如果对各个接口采用统一的签名规则，则可以在网关层实现。</span></li>
   </ol>
   <div>
    <span style="color:#404040;"><span style="font-size:16px;line-height:27.2px;">原文作者还介绍了通用的签名和验签</span></span>
   </div> ************************************************************
  </div> 
  <p></p> 
  <h1>四&nbsp;整体架构</h1> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170813225329092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9odTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"></span></span></p> 
  <h1 style="font-size:36px;line-height:1.1;color:rgb(64,64,64);"> 支付网关前置<a></a></h1> 
  <p></p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 支付网关前置是对接业务系统，为其提供支付服务的模块。它是所有支付服务接口的集成前置，将不同支付渠道提供的接口通过统一的方式呈现给业务方。这样接入方就只需要对接支付网关，增加和调整支付渠道对业务方是透明的。 支付网关前置的设计对整个支付系统的稳定性、功能、性能以及其他非功能性需求有着直接的影响。</p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 在支付网关中需要完成大量的操作，为了保证性能，这些操作都尽量异步化来处理。</p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 支付网关前置应保持稳定，尽量减少系统重启等操作对业务方的影响。支付网关也避免不了升级和重启。这可通过基于Nginx的LBS(Load Balance System)网关来解决。LBS在这里有两个作用： 一个是实现负载均衡，一个是隔离支付网关重启对调用的影响。 支付网关也采用多台机器分布式部署，重启时，每个服务器逐个启动。某台服务器重启时，首先从LBS系统中取消注册，重启完成后，再重新注册到LBS上。这个过程对调用方是无感知的。</p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 为了避免接口受攻击，在安全上，还得要求业务方通过HTTPS来访问接口，并提供防篡改机制。防篡改则通过接口参数签名来处理。现在主流的签名是对接口参数按照参数名称排序后，做加密和散列，参考<a style="color:rgb(51,122,183);background-color:transparent;">微信的签名规范</a>。</p> 
  <h1 style="font-size:36px;line-height:1.1;color:rgb(64,64,64);"> 交易流水和记账<a></a></h1> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 每一笔交易都需要记录流水，并登记到个人和机构的分户账户上，统计和分析也需要根据交易流水来更新相关数据。 而个人和机构账户总额更新、交易流水记录以及库存的处理，更是需要事务处理机制的支持。 从性能角度， 可以弱化了事务处理的要求，采用消息机制来异步化和交易相关的数据处理。</p> 
  <ol class="list-paddingleft-2" style="font-size:16px;color:rgb(64,64,64);line-height:27.2px;">
   <li> <p style="clear:both;min-height:1em;"> 在支付网关前置的主流程中，仅记录交易流水，即将当前的请求保存到数据库中。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 完成数据记录后，发送MQ出来，记账、统计、分析，都是接收MQ来完成数据处理。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 涉及到本地资金支付，比如钱包支付，会需要分布式事务处理，扣减账号余额，记账，扣减库存等，每个操作失败，都要回滚。<a style="color:rgb(51,122,183);background-color:transparent;">阿里</a>有很不错的分享，这里不详细描述。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 当交易量上来后，需要考虑交易表的分表分库的事情。分表分库有两个策略，按照流水号或者交易主体id来走。后者可以支持按用户来获取交易记录。我们用的是前者。后者可以走elastic，确保数据库专用。风控，信用和统计所需要的数据，通过MQ同步到Hbase里面。作为支付系统最有价值的数据，在存储上做到专库专用，无可厚非，毕竟存储成本还是廉价的。</p> </li>
  </ol>
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170813225511808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9odTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
  <br>
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;"></span></span></p> 
  <h1 style="font-size:36px;line-height:1.1;color:rgb(64,64,64);"> 风控模块<a></a></h1> 
  <p></p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 风控对支付的重要性怎么强调都不过分。有些系统在风控出问题时可以旁路风控，但是在支付系统中，风控出问题必须停止交易。 整体上，风控可以分为数据采集，数据分析，实时计算，规则配置，实时拦截等模块。风控本身是个大话题，以后专门讨论。又欠一个债。 但风控和交易的接口比较简单。对每一次交易，风控一般返回三个结果:拦截，增强验证，通过。通过指交易没有问题，可以直接放行。拦截则是阻止本次交易。增强验证则是交易存疑，需要用户进一步核实身份才能继续，比如输入手机号或者身份证号，一般用于身份被盗用的场景。而人工核实则是对交易有疑问，一般用于个人恶意消费满场景。</p> 
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170813225649243?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9odTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
  <br>
  <p></p> 
  <h1 style="color:rgb(64,64,64);font-size:36px;line-height:1.1;"> 支付路由</h1> 
  <p></p> 
  <p>需要平衡，用户少的银行考虑三方对接，不能只依赖单一第三方，遇到不稳定或者意外。总之，得对接多个渠道。对于交易量大的银行，还得考虑直联。<span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">支付路由的作用是定义对用户选用的银行卡或者其他支付方式，使用什么渠道来完成支付。</span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">一般来说，银行会提供两种支付途径：无跳转的快捷支付接口和带跳转的网银接口。前者在绑卡，支付的时候，不需要跳到银行页面上去处理，后者则需要在银行的网银页面上完成。显然前者对用户来说体验要好多了，用户流程不会被打断。快捷支付要求支付系统在本地保存用户的支付信息，如卡号，登记手机。系统要确保这些信息不被泄漏。风险非常好，所以大部分银行要求接入方必须经过ADSS检验才能够接入快捷支付。</span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">这种固定方式的接入有单点故障的问题，一旦某个渠道出问题，绑定的支付方式就无法使用。改进策略是为每个支付方式定义多个渠道，第一个渠道出问题即选择第二个，以此类推。</span><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">当然，更进一步，可以为候选渠道定义权重，按照权重来选择支付方式。当渠道出问题，自动调整权重。</span></p> 
  <p><span style="color:rgb(64,64,64);font-size:16px;line-height:27.2px;">路由实现上还会更复杂，对同一张银行卡，运营上会要求在不同的系统上，比如android，iOS，windows上，或者不同地区，如大陆，台湾，香港，北美等，甚至不同业务上，采用不同渠道来支付。</span></p> 
  <p><span style="color:#404040;"><span style="font-size:16px;line-height:27.2px;">我理解这里就是实践出真知，坑肯定不少。印象中给很久之前给网站做对接网银，就是各家银行不太一样。</span></span></p> 
  <p></p> 
  <h1 style="font-size:36px;line-height:1.1;color:rgb(64,64,64);"> 支付渠道<a></a></h1> 
  <p></p> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 如果采用微服务来实现，整体设计上，可以考虑将支付渠道分离、支付网关前置分离。支付渠道的微服务实现有两种策略，一种是按照服务来拆分，一种是按照渠道来拆分。</p> 
  <ul class="list-paddingleft-2" style="font-size:16px;color:rgb(64,64,64);line-height:27.2px;">
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">按渠道拆分</span>，指每个渠道单独部署在一个容器中，对支付网关提供相同的服务。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">按服务拆分</span>，是按接口来拆分，分为支付，对账，退款等子系统，每个服务单独部署，所有容器的服务都实现在一起。</p> </li>
  </ul>
  <h2 style="font-size:30px;line-height:1.1;color:rgb(64,64,64);"> 渠道拆分<a></a></h2> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 按照服务来拆分的一个典型案例是大众点评网的早期实现。&nbsp;<a style="color:rgb(51,122,183);background-color:transparent;">大众点评支付渠道网关系统的实践之路</a>。 每个支付服务接口实现为一个独立的子系统，独立部署，通过支付网关前置来对外提供服务。 这篇文章里面也提到这种方式存在的问题，</p> 
  <ul class="list-paddingleft-2" style="font-size:16px;color:rgb(64,64,64);line-height:27.2px;">
   <li> <p style="clear:both;min-height:1em;"> 银行的加密客户端会有各种奇葩的需求，有些可以支持linux，有些要windows系统，如何在一个容器中满足所有需求？</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 这样拆分后，每个渠道接口独立部署。某个渠道出问题也不会影响其他渠道。至于渠道访问量小导致资源浪费问题，可以通过虚机或者docker的资源调度来解决，谁也不会在物理机上玩微服务。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 对接渠道难点在于对输入输出做加密和解密，以及组装和解析报文。同一个渠道对不同的服务的加密解密方式是一样的，报文格式也是一样的。按渠道来构建服务可以共用这样方法，减少开发投入。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> 从安全的角度，按渠道划分也有优势。一般渠道都要求只对接到特定ip的机器，这样每个渠道对接系统所在的机器仅开放对渠道和支付网关前置机的访问白名单即可，尽可能的缩减被暴露的风险。</p> </li>
  </ul>
  <h2 style="font-size:30px;line-height:1.1;color:rgb(64,64,64);"> 接入渠道<a></a></h2> 
  <p style="clear:both;min-height:1em;font-size:16px;color:rgb(64,64,64);line-height:27.2px;"> 对于支付渠道，首先考虑的是接入哪些渠道。要对接的渠道按优先级有：</p> 
  <ul class="list-paddingleft-2" style="font-size:16px;color:rgb(64,64,64);line-height:27.2px;">
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">第三方支付</span>，对大部分应用来说，支付宝和微信支付都是必须的，一般来说，这两者可以占到90%以上的交易量。用户不需要绑卡，授权后直接支付就行。各种平台都支持，性能和稳定性都不错。对于一些特殊业务，比如游戏，企业支付，可以查看一些专用的第三方支付平台。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">银联</span>，这货的存在，极大方便了和银行的对接。和第三方支付主要不同在两个地方一是需要绑卡，也就是用户先把卡号，手机，身份证号提供出来。这一步会折损不少用户。绑卡后，以后的支付操作就简单了，用户只需要输入密码就行。手机客户端不需要像第三方支付那样安装SDK，都在服务器端完成。当然，这是针对快捷支付。网银支付还是挺麻烦的。银联接入也需要ADSS认证。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">银行</span>，建议先看这一篇文章，了解下对接银行的难度。那最终需要选择哪些银行？先看个统计数据。 截至 2015 年底，我国银行业金融机构包括 5 家大型商业银行、12 家股份制商业银行、133 家城市商业银行、5 家民营银行、859 家农村商业银行、71 家农村合作银行、1373家农村信用社、1 家邮政储蓄银行、3 家政策性银行、 311 家村镇银行、48 家农村资金互助社。优先选择5家商业银行，他们占40%的交易量。其次是股份制银行和邮储。这就18家银行了。老板要是不满意，城商行和农商行加起来有1000多家呢。一般对接一个银行预计有3周左右的工作量，大部分银行需要专线接入，费用和带宽有关，一年也得几万费用。不同银行对接入环境有不同要求，这也是成本。另外，还有一个重大风险，就是央行在搞得网联系统，毕竟还没有出来，相关资料参考<a style="color:rgb(51,122,183);background-color:transparent;">知乎上关于网联的一篇讨论</a>。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">手机支付</span>，现在不少厂商都内置了各种支付，比如苹果的In-App支付， 三星支付、华为支付等， 这些支付仅针对特定的手机型号， 支持NFC等，根据业务需要也可以接入。 就是目前用户群不大，收益不明显。</p> </li>
   <li> <p style="clear:both;min-height:1em;"> <span style="font-weight:700;">话费支付</span>， 这一块容易被人忽略，但考虑到国内不少职场人士，话费是公司报销的，每个月多的用不完，所以这块支付还是相当有市场的。 问题是，联通和移动两大运营商，不仅接口不能互通，内部各个地域也是各自为政，所以对接起来还是有点麻烦。不过话费支付领域也有类似支付宝微信的第三方支付公司，比如虹软、联动优势等公司。</p> </li>
  </ul> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bohu83/article/details/77150460,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bohu83/article/details/77150460,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
