<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Rust :公钥、私钥与keypair、signature、verify 三部曲 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Rust :公钥、私钥与keypair、signature、verify 三部曲" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="如何理解签名体制包含3个算法：KeyGen（密钥生成算法），Sign（签名算法），Verify（验证算法）； 以及以下话： “公钥加密，私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。 私钥加密，公钥解密是签名，保证消息来源是私钥持有者。” 什么是公钥，什么是私钥？长什么形状？ 一、标准库的hash值 use std::collections::hash_map::DefaultHasher; use std::hash::{Hash, Hasher}; fn calculate_hash&lt;T: Hash&gt;(t: &amp;T) -&gt; u64 { let mut s = DefaultHasher::new(); t.hash(&amp;mut s); s.finish() } fn main() { let st = SystemTime::now(); let text = &quot;10086&quot;.as_bytes(); println!(&quot;text:{:?}&quot;, text); let mut hasher1 = DefaultHasher::new(); hasher1.write(text); println!(&quot;Hash1(低16位表示) is {:x}&quot;, hasher1.finish()); println!(&quot;Hash1 is {}&quot;, hasher1.finish()); let mut hasher2 = DefaultHasher::new(); text.hash(&amp;mut hasher2); println!(&quot;Hash2(低16位表示) is {:x}&quot;, hasher2.finish()); println!(&quot;Hash2 is {}&quot;, hasher2.finish()); println!(&quot;calculate_hash:-&gt;Hash :{:?}&quot;, calculate_hash(&amp;text)); let mt1 = SystemTime::now(); println!(&quot;is_fit_num time:{:?}&quot;, mt1.duration_since(st).unwrap()); thread::sleep_ms(500000); } output: text:[49, 48, 48, 56, 54] Hash1(低16位表示) is 85f84a89780553ce Hash1 is 9653547755553248206 Hash2(低16位表示) is 4b5a264ac7932dc5 Hash2 is 5429694403366301125 calculate_hash:-&gt;Hash :5429694403366301125 思考 ： hash1为什么和hash2不同？ 二、关于keypair、signature、verify 三部曲 我们看rust-crypto库的原代码的例子 https://github.com/DaGenix/rust-crypto/blob/cc1a5fde1ce957bd1a8a2e30169443cdb4780111/src/ed25519.rs use digest::Digest; use sha2::{Sha512}; use curve25519::{GeP2, GeP3, ge_scalarmult_base, sc_reduce, sc_muladd, curve25519, Fe}; use util::{fixed_time_eq}; use std::ops::{Add, Sub, Mul}; static L: [u8; 32] = [ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xde, 0xf9, 0xde, 0xa2, 0xf7, 0x9c, 0xd6, 0x58, 0x12, 0x63, 0x1a, 0x5c, 0xf5, 0xd3, 0xed ]; pub fn keypair(seed: &amp;[u8]) -&gt; ([u8; 64], [u8; 32]) { let mut secret: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let a = ge_scalarmult_base(&amp;secret[0..32]); let public_key = a.to_bytes(); for (dest, src) in (&amp;mut secret[32..64]).iter_mut().zip(public_key.iter()) { *dest = *src; } for (dest, src) in (&amp;mut secret[0..32]).iter_mut().zip(seed.iter()) { *dest = *src; } (secret, public_key) } pub fn signature(message: &amp;[u8], secret_key: &amp;[u8]) -&gt; [u8; 64] { let seed = &amp;secret_key[0..32]; let public_key = &amp;secret_key[32..64]; let az: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let nonce = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(&amp;az[32..64]); hasher.input(message); hasher.result(&amp;mut hash_output); sc_reduce(&amp;mut hash_output[0..64]); hash_output }; let mut signature: [u8; 64] = [0; 64]; let r: GeP3 = ge_scalarmult_base(&amp;nonce[0..32]); for (result_byte, source_byte) in (&amp;mut signature[0..32]).iter_mut().zip(r.to_bytes().iter()) { *result_byte = *source_byte; } for (result_byte, source_byte) in (&amp;mut signature[32..64]).iter_mut().zip(public_key.iter()) { *result_byte = *source_byte; } { let mut hasher = Sha512::new(); hasher.input(signature.as_ref()); hasher.input(message); let mut hram: [u8; 64] = [0; 64]; hasher.result(&amp;mut hram); sc_reduce(&amp;mut hram); sc_muladd(&amp;mut signature[32..64], &amp;hram[0..32], &amp;az[0..32], &amp;nonce[0..32]); } signature } fn check_s_lt_l(s: &amp;[u8]) -&gt; bool { let mut c: u8 = 0; let mut n: u8 = 1; let mut i = 31; loop { c |= ((((s[i] as i32) - (L[i] as i32)) &gt;&gt; 8) as u8) &amp; n; n &amp;= (((((s[i] ^ L[i]) as i32)) - 1) &gt;&gt; 8) as u8; if i == 0 { break; } else { i -= 1; } } c == 0 } pub fn verify(message: &amp;[u8], public_key: &amp;[u8], signature: &amp;[u8]) -&gt; bool { if check_s_lt_l(&amp;signature[32..64]) { return false; } let a = match GeP3::from_bytes_negate_vartime(public_key) { Some(g) =&gt; g, None =&gt; { return false; } }; let mut d = 0; for pk_byte in public_key.iter() { d |= *pk_byte; } if d == 0 { return false; } let mut hasher = Sha512::new(); hasher.input(&amp;signature[0..32]); hasher.input(public_key); hasher.input(message); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); sc_reduce(&amp;mut hash); let r = GeP2::double_scalarmult_vartime(hash.as_ref(), a, &amp;signature[32..64]); let rcheck = r.to_bytes(); fixed_time_eq(rcheck.as_ref(), &amp;signature[0..32]) } pub fn exchange(public_key: &amp;[u8], private_key: &amp;[u8]) -&gt; [u8; 32] { let ed_y = Fe::from_bytes(&amp;public_key); // Produce public key in Montgomery form. let mont_x = edwards_to_montgomery_x(ed_y); // Produce private key from seed component (bytes 0 to 32) // of the Ed25519 extended private key (64 bytes). let mut hasher = Sha512::new(); hasher.input(&amp;private_key[0..32]); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); // Clamp the hash such that it is a valid private key hash[0] &amp;= 248; hash[31] &amp;= 127; hash[31] |= 64; let shared_mont_x : [u8; 32] = curve25519(&amp;hash, &amp;mont_x.to_bytes()); // priv., pub. shared_mont_x } 三、如何用？ 看一个私钥签名，公钥解密的例子。 extern crate crypto; use crypto::*; use ed25519::{keypair, signature, verify, exchange}; use curve25519::{curve25519_base, curve25519}; use digest::Digest; use sha2::Sha512; fn main() { let seed: &amp;[u8] = &amp;[0x26, 0x27, 0xf6, 0x85, 0x97, 0x15, 0xad, 0x1d, 0xd2, 0x94, 0xdd, 0xc4, 0x76, 0x19, 0x39, 0x31, 0xf1, 0xad, 0xb5, 0x58, 0xf0, 0x93, 0x97, 0x32, 0x19, 0x2b, 0xd1, 0xc0, 0xfd, 0x16, 0x8e, 0x4e];//32位 // KEYGEN let (private_key, public_key) = keypair(seed); //[U8,64] let message = b&quot;This is my message!&quot;; //私钥签名 let sig = signature(message, &amp;private_key); //[U8,64] //private_key println!(&quot;private_key: {:?} &quot;, private_key.to_vec()); println!(&quot;private_key_len :{:? }&quot;, private_key.len()); // public_key println!(&quot;public_key :{:?}&quot;, public_key.to_vec()); println!(&quot;public_key_len :{:?}&quot;, public_key.len()); //signature println!(&quot;signature:{:?}&quot;, sig.to_vec()); println!(&quot;signature_len:{:?}&quot;, sig.len()); // verify println!(&quot;验证是否成功：{:?} &quot;,verify(message, &amp;public_key, &amp;sig)); } private_key: [38, 39, 246, 133, 151, 21, 173, 29, 210, 148, 221, 196, 118, 25, 57, 49, 241, 173, 181, 88, 240, 147, 151, 50, 25, 43, 209, 192, 253, 22, 142, 78, 93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] private_key_len :64 public_key :[93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] public_key_len :32 signature:[163, 41, 56, 4, 173, 251, 241, 219, 149, 58, 146, 122, 98, 42, 27, 108, 25, 3, 130, 238, 94, 244, 235, 181, 70, 68, 226, 117, 98, 88, 135, 182, 110, 110, 122, 203 , 190, 66, 6, 139, 6, 242, 94, 98, 107, 99, 144, 208, 145, 218, 120, 236, 223, 60, 87, 19, 245, 249, 177, 246, 212, 160, 10, 10] signature_len:64 验证是否成功：true 阅读更多" />
<meta property="og:description" content="如何理解签名体制包含3个算法：KeyGen（密钥生成算法），Sign（签名算法），Verify（验证算法）； 以及以下话： “公钥加密，私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。 私钥加密，公钥解密是签名，保证消息来源是私钥持有者。” 什么是公钥，什么是私钥？长什么形状？ 一、标准库的hash值 use std::collections::hash_map::DefaultHasher; use std::hash::{Hash, Hasher}; fn calculate_hash&lt;T: Hash&gt;(t: &amp;T) -&gt; u64 { let mut s = DefaultHasher::new(); t.hash(&amp;mut s); s.finish() } fn main() { let st = SystemTime::now(); let text = &quot;10086&quot;.as_bytes(); println!(&quot;text:{:?}&quot;, text); let mut hasher1 = DefaultHasher::new(); hasher1.write(text); println!(&quot;Hash1(低16位表示) is {:x}&quot;, hasher1.finish()); println!(&quot;Hash1 is {}&quot;, hasher1.finish()); let mut hasher2 = DefaultHasher::new(); text.hash(&amp;mut hasher2); println!(&quot;Hash2(低16位表示) is {:x}&quot;, hasher2.finish()); println!(&quot;Hash2 is {}&quot;, hasher2.finish()); println!(&quot;calculate_hash:-&gt;Hash :{:?}&quot;, calculate_hash(&amp;text)); let mt1 = SystemTime::now(); println!(&quot;is_fit_num time:{:?}&quot;, mt1.duration_since(st).unwrap()); thread::sleep_ms(500000); } output: text:[49, 48, 48, 56, 54] Hash1(低16位表示) is 85f84a89780553ce Hash1 is 9653547755553248206 Hash2(低16位表示) is 4b5a264ac7932dc5 Hash2 is 5429694403366301125 calculate_hash:-&gt;Hash :5429694403366301125 思考 ： hash1为什么和hash2不同？ 二、关于keypair、signature、verify 三部曲 我们看rust-crypto库的原代码的例子 https://github.com/DaGenix/rust-crypto/blob/cc1a5fde1ce957bd1a8a2e30169443cdb4780111/src/ed25519.rs use digest::Digest; use sha2::{Sha512}; use curve25519::{GeP2, GeP3, ge_scalarmult_base, sc_reduce, sc_muladd, curve25519, Fe}; use util::{fixed_time_eq}; use std::ops::{Add, Sub, Mul}; static L: [u8; 32] = [ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xde, 0xf9, 0xde, 0xa2, 0xf7, 0x9c, 0xd6, 0x58, 0x12, 0x63, 0x1a, 0x5c, 0xf5, 0xd3, 0xed ]; pub fn keypair(seed: &amp;[u8]) -&gt; ([u8; 64], [u8; 32]) { let mut secret: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let a = ge_scalarmult_base(&amp;secret[0..32]); let public_key = a.to_bytes(); for (dest, src) in (&amp;mut secret[32..64]).iter_mut().zip(public_key.iter()) { *dest = *src; } for (dest, src) in (&amp;mut secret[0..32]).iter_mut().zip(seed.iter()) { *dest = *src; } (secret, public_key) } pub fn signature(message: &amp;[u8], secret_key: &amp;[u8]) -&gt; [u8; 64] { let seed = &amp;secret_key[0..32]; let public_key = &amp;secret_key[32..64]; let az: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let nonce = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(&amp;az[32..64]); hasher.input(message); hasher.result(&amp;mut hash_output); sc_reduce(&amp;mut hash_output[0..64]); hash_output }; let mut signature: [u8; 64] = [0; 64]; let r: GeP3 = ge_scalarmult_base(&amp;nonce[0..32]); for (result_byte, source_byte) in (&amp;mut signature[0..32]).iter_mut().zip(r.to_bytes().iter()) { *result_byte = *source_byte; } for (result_byte, source_byte) in (&amp;mut signature[32..64]).iter_mut().zip(public_key.iter()) { *result_byte = *source_byte; } { let mut hasher = Sha512::new(); hasher.input(signature.as_ref()); hasher.input(message); let mut hram: [u8; 64] = [0; 64]; hasher.result(&amp;mut hram); sc_reduce(&amp;mut hram); sc_muladd(&amp;mut signature[32..64], &amp;hram[0..32], &amp;az[0..32], &amp;nonce[0..32]); } signature } fn check_s_lt_l(s: &amp;[u8]) -&gt; bool { let mut c: u8 = 0; let mut n: u8 = 1; let mut i = 31; loop { c |= ((((s[i] as i32) - (L[i] as i32)) &gt;&gt; 8) as u8) &amp; n; n &amp;= (((((s[i] ^ L[i]) as i32)) - 1) &gt;&gt; 8) as u8; if i == 0 { break; } else { i -= 1; } } c == 0 } pub fn verify(message: &amp;[u8], public_key: &amp;[u8], signature: &amp;[u8]) -&gt; bool { if check_s_lt_l(&amp;signature[32..64]) { return false; } let a = match GeP3::from_bytes_negate_vartime(public_key) { Some(g) =&gt; g, None =&gt; { return false; } }; let mut d = 0; for pk_byte in public_key.iter() { d |= *pk_byte; } if d == 0 { return false; } let mut hasher = Sha512::new(); hasher.input(&amp;signature[0..32]); hasher.input(public_key); hasher.input(message); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); sc_reduce(&amp;mut hash); let r = GeP2::double_scalarmult_vartime(hash.as_ref(), a, &amp;signature[32..64]); let rcheck = r.to_bytes(); fixed_time_eq(rcheck.as_ref(), &amp;signature[0..32]) } pub fn exchange(public_key: &amp;[u8], private_key: &amp;[u8]) -&gt; [u8; 32] { let ed_y = Fe::from_bytes(&amp;public_key); // Produce public key in Montgomery form. let mont_x = edwards_to_montgomery_x(ed_y); // Produce private key from seed component (bytes 0 to 32) // of the Ed25519 extended private key (64 bytes). let mut hasher = Sha512::new(); hasher.input(&amp;private_key[0..32]); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); // Clamp the hash such that it is a valid private key hash[0] &amp;= 248; hash[31] &amp;= 127; hash[31] |= 64; let shared_mont_x : [u8; 32] = curve25519(&amp;hash, &amp;mont_x.to_bytes()); // priv., pub. shared_mont_x } 三、如何用？ 看一个私钥签名，公钥解密的例子。 extern crate crypto; use crypto::*; use ed25519::{keypair, signature, verify, exchange}; use curve25519::{curve25519_base, curve25519}; use digest::Digest; use sha2::Sha512; fn main() { let seed: &amp;[u8] = &amp;[0x26, 0x27, 0xf6, 0x85, 0x97, 0x15, 0xad, 0x1d, 0xd2, 0x94, 0xdd, 0xc4, 0x76, 0x19, 0x39, 0x31, 0xf1, 0xad, 0xb5, 0x58, 0xf0, 0x93, 0x97, 0x32, 0x19, 0x2b, 0xd1, 0xc0, 0xfd, 0x16, 0x8e, 0x4e];//32位 // KEYGEN let (private_key, public_key) = keypair(seed); //[U8,64] let message = b&quot;This is my message!&quot;; //私钥签名 let sig = signature(message, &amp;private_key); //[U8,64] //private_key println!(&quot;private_key: {:?} &quot;, private_key.to_vec()); println!(&quot;private_key_len :{:? }&quot;, private_key.len()); // public_key println!(&quot;public_key :{:?}&quot;, public_key.to_vec()); println!(&quot;public_key_len :{:?}&quot;, public_key.len()); //signature println!(&quot;signature:{:?}&quot;, sig.to_vec()); println!(&quot;signature_len:{:?}&quot;, sig.len()); // verify println!(&quot;验证是否成功：{:?} &quot;,verify(message, &amp;public_key, &amp;sig)); } private_key: [38, 39, 246, 133, 151, 21, 173, 29, 210, 148, 221, 196, 118, 25, 57, 49, 241, 173, 181, 88, 240, 147, 151, 50, 25, 43, 209, 192, 253, 22, 142, 78, 93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] private_key_len :64 public_key :[93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] public_key_len :32 signature:[163, 41, 56, 4, 173, 251, 241, 219, 149, 58, 146, 122, 98, 42, 27, 108, 25, 3, 130, 238, 94, 244, 235, 181, 70, 68, 226, 117, 98, 88, 135, 182, 110, 110, 122, 203 , 190, 66, 6, 139, 6, 242, 94, 98, 107, 99, 144, 208, 145, 218, 120, 236, 223, 60, 87, 19, 245, 249, 177, 246, 212, 160, 10, 10] signature_len:64 验证是否成功：true 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/08/16/63394bae55cfd7a2c1b2553bc9706a33.html" />
<meta property="og:url" content="https://mlh.app/2017/08/16/63394bae55cfd7a2c1b2553bc9706a33.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"如何理解签名体制包含3个算法：KeyGen（密钥生成算法），Sign（签名算法），Verify（验证算法）； 以及以下话： “公钥加密，私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。 私钥加密，公钥解密是签名，保证消息来源是私钥持有者。” 什么是公钥，什么是私钥？长什么形状？ 一、标准库的hash值 use std::collections::hash_map::DefaultHasher; use std::hash::{Hash, Hasher}; fn calculate_hash&lt;T: Hash&gt;(t: &amp;T) -&gt; u64 { let mut s = DefaultHasher::new(); t.hash(&amp;mut s); s.finish() } fn main() { let st = SystemTime::now(); let text = &quot;10086&quot;.as_bytes(); println!(&quot;text:{:?}&quot;, text); let mut hasher1 = DefaultHasher::new(); hasher1.write(text); println!(&quot;Hash1(低16位表示) is {:x}&quot;, hasher1.finish()); println!(&quot;Hash1 is {}&quot;, hasher1.finish()); let mut hasher2 = DefaultHasher::new(); text.hash(&amp;mut hasher2); println!(&quot;Hash2(低16位表示) is {:x}&quot;, hasher2.finish()); println!(&quot;Hash2 is {}&quot;, hasher2.finish()); println!(&quot;calculate_hash:-&gt;Hash :{:?}&quot;, calculate_hash(&amp;text)); let mt1 = SystemTime::now(); println!(&quot;is_fit_num time:{:?}&quot;, mt1.duration_since(st).unwrap()); thread::sleep_ms(500000); } output: text:[49, 48, 48, 56, 54] Hash1(低16位表示) is 85f84a89780553ce Hash1 is 9653547755553248206 Hash2(低16位表示) is 4b5a264ac7932dc5 Hash2 is 5429694403366301125 calculate_hash:-&gt;Hash :5429694403366301125 思考 ： hash1为什么和hash2不同？ 二、关于keypair、signature、verify 三部曲 我们看rust-crypto库的原代码的例子 https://github.com/DaGenix/rust-crypto/blob/cc1a5fde1ce957bd1a8a2e30169443cdb4780111/src/ed25519.rs use digest::Digest; use sha2::{Sha512}; use curve25519::{GeP2, GeP3, ge_scalarmult_base, sc_reduce, sc_muladd, curve25519, Fe}; use util::{fixed_time_eq}; use std::ops::{Add, Sub, Mul}; static L: [u8; 32] = [ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xde, 0xf9, 0xde, 0xa2, 0xf7, 0x9c, 0xd6, 0x58, 0x12, 0x63, 0x1a, 0x5c, 0xf5, 0xd3, 0xed ]; pub fn keypair(seed: &amp;[u8]) -&gt; ([u8; 64], [u8; 32]) { let mut secret: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let a = ge_scalarmult_base(&amp;secret[0..32]); let public_key = a.to_bytes(); for (dest, src) in (&amp;mut secret[32..64]).iter_mut().zip(public_key.iter()) { *dest = *src; } for (dest, src) in (&amp;mut secret[0..32]).iter_mut().zip(seed.iter()) { *dest = *src; } (secret, public_key) } pub fn signature(message: &amp;[u8], secret_key: &amp;[u8]) -&gt; [u8; 64] { let seed = &amp;secret_key[0..32]; let public_key = &amp;secret_key[32..64]; let az: [u8; 64] = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(seed); hasher.result(&amp;mut hash_output); hash_output[0] &amp;= 248; hash_output[31] &amp;= 63; hash_output[31] |= 64; hash_output }; let nonce = { let mut hash_output: [u8; 64] = [0; 64]; let mut hasher = Sha512::new(); hasher.input(&amp;az[32..64]); hasher.input(message); hasher.result(&amp;mut hash_output); sc_reduce(&amp;mut hash_output[0..64]); hash_output }; let mut signature: [u8; 64] = [0; 64]; let r: GeP3 = ge_scalarmult_base(&amp;nonce[0..32]); for (result_byte, source_byte) in (&amp;mut signature[0..32]).iter_mut().zip(r.to_bytes().iter()) { *result_byte = *source_byte; } for (result_byte, source_byte) in (&amp;mut signature[32..64]).iter_mut().zip(public_key.iter()) { *result_byte = *source_byte; } { let mut hasher = Sha512::new(); hasher.input(signature.as_ref()); hasher.input(message); let mut hram: [u8; 64] = [0; 64]; hasher.result(&amp;mut hram); sc_reduce(&amp;mut hram); sc_muladd(&amp;mut signature[32..64], &amp;hram[0..32], &amp;az[0..32], &amp;nonce[0..32]); } signature } fn check_s_lt_l(s: &amp;[u8]) -&gt; bool { let mut c: u8 = 0; let mut n: u8 = 1; let mut i = 31; loop { c |= ((((s[i] as i32) - (L[i] as i32)) &gt;&gt; 8) as u8) &amp; n; n &amp;= (((((s[i] ^ L[i]) as i32)) - 1) &gt;&gt; 8) as u8; if i == 0 { break; } else { i -= 1; } } c == 0 } pub fn verify(message: &amp;[u8], public_key: &amp;[u8], signature: &amp;[u8]) -&gt; bool { if check_s_lt_l(&amp;signature[32..64]) { return false; } let a = match GeP3::from_bytes_negate_vartime(public_key) { Some(g) =&gt; g, None =&gt; { return false; } }; let mut d = 0; for pk_byte in public_key.iter() { d |= *pk_byte; } if d == 0 { return false; } let mut hasher = Sha512::new(); hasher.input(&amp;signature[0..32]); hasher.input(public_key); hasher.input(message); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); sc_reduce(&amp;mut hash); let r = GeP2::double_scalarmult_vartime(hash.as_ref(), a, &amp;signature[32..64]); let rcheck = r.to_bytes(); fixed_time_eq(rcheck.as_ref(), &amp;signature[0..32]) } pub fn exchange(public_key: &amp;[u8], private_key: &amp;[u8]) -&gt; [u8; 32] { let ed_y = Fe::from_bytes(&amp;public_key); // Produce public key in Montgomery form. let mont_x = edwards_to_montgomery_x(ed_y); // Produce private key from seed component (bytes 0 to 32) // of the Ed25519 extended private key (64 bytes). let mut hasher = Sha512::new(); hasher.input(&amp;private_key[0..32]); let mut hash: [u8; 64] = [0; 64]; hasher.result(&amp;mut hash); // Clamp the hash such that it is a valid private key hash[0] &amp;= 248; hash[31] &amp;= 127; hash[31] |= 64; let shared_mont_x : [u8; 32] = curve25519(&amp;hash, &amp;mont_x.to_bytes()); // priv., pub. shared_mont_x } 三、如何用？ 看一个私钥签名，公钥解密的例子。 extern crate crypto; use crypto::*; use ed25519::{keypair, signature, verify, exchange}; use curve25519::{curve25519_base, curve25519}; use digest::Digest; use sha2::Sha512; fn main() { let seed: &amp;[u8] = &amp;[0x26, 0x27, 0xf6, 0x85, 0x97, 0x15, 0xad, 0x1d, 0xd2, 0x94, 0xdd, 0xc4, 0x76, 0x19, 0x39, 0x31, 0xf1, 0xad, 0xb5, 0x58, 0xf0, 0x93, 0x97, 0x32, 0x19, 0x2b, 0xd1, 0xc0, 0xfd, 0x16, 0x8e, 0x4e];//32位 // KEYGEN let (private_key, public_key) = keypair(seed); //[U8,64] let message = b&quot;This is my message!&quot;; //私钥签名 let sig = signature(message, &amp;private_key); //[U8,64] //private_key println!(&quot;private_key: {:?} &quot;, private_key.to_vec()); println!(&quot;private_key_len :{:? }&quot;, private_key.len()); // public_key println!(&quot;public_key :{:?}&quot;, public_key.to_vec()); println!(&quot;public_key_len :{:?}&quot;, public_key.len()); //signature println!(&quot;signature:{:?}&quot;, sig.to_vec()); println!(&quot;signature_len:{:?}&quot;, sig.len()); // verify println!(&quot;验证是否成功：{:?} &quot;,verify(message, &amp;public_key, &amp;sig)); } private_key: [38, 39, 246, 133, 151, 21, 173, 29, 210, 148, 221, 196, 118, 25, 57, 49, 241, 173, 181, 88, 240, 147, 151, 50, 25, 43, 209, 192, 253, 22, 142, 78, 93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] private_key_len :64 public_key :[93, 109, 35, 107, 82, 209, 142, 58, 182, 214, 7, 47, 182, 228, 199, 212, 107, 213, 154, 217, 204, 25, 71, 38, 95, 0, 183, 32, 250, 44, 143, 102] public_key_len :32 signature:[163, 41, 56, 4, 173, 251, 241, 219, 149, 58, 146, 122, 98, 42, 27, 108, 25, 3, 130, 238, 94, 244, 235, 181, 70, 68, 226, 117, 98, 88, 135, 182, 110, 110, 122, 203 , 190, 66, 6, 139, 6, 242, 94, 98, 107, 99, 144, 208, 145, 218, 120, 236, 223, 60, 87, 19, 245, 249, 177, 246, 212, 160, 10, 10] signature_len:64 验证是否成功：true 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/08/16/63394bae55cfd7a2c1b2553bc9706a33.html","headline":"Rust :公钥、私钥与keypair、signature、verify 三部曲","dateModified":"2017-08-16T00:00:00+08:00","datePublished":"2017-08-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/08/16/63394bae55cfd7a2c1b2553bc9706a33.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Rust :公钥、私钥与keypair、signature、verify 三部曲</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>如何理解签名体制包含3个算法：KeyGen（密钥生成算法），Sign（签名算法），Verify（验证算法）；</p> 
  <p>以及以下话：</p> 
  <p>“公钥加密，私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。 <br> 私钥加密，公钥解密是签名，保证消息来源是私钥持有者。”</p> 
  <p>什么是公钥，什么是私钥？长什么形状？</p> 
  <p>一、标准库的hash值</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">use</span> std::collections::hash_map::DefaultHasher;
<span class="hljs-keyword">use</span> std::hash::{Hash, Hasher};
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_hash</span>&lt;</span>T: Hash&gt;(t: &amp;T) -&gt; <span class="hljs-keyword">u64</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = DefaultHasher::new();
    t.hash(&amp;<span class="hljs-keyword">mut</span> s);
    s.finish()
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
    <span class="hljs-keyword">let</span> st = SystemTime::now();
    <span class="hljs-keyword">let</span> text = <span class="hljs-string">"10086"</span>.as_bytes();
    println!(<span class="hljs-string">"text:{:?}"</span>, text);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher1 = DefaultHasher::new();
    hasher1.write(text);

    println!(<span class="hljs-string">"Hash1(低16位表示) is {:x}"</span>, hasher1.finish());
    println!(<span class="hljs-string">"Hash1 is {}"</span>, hasher1.finish());


    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher2 = DefaultHasher::new();
    text.hash(&amp;<span class="hljs-keyword">mut</span> hasher2);
    println!(<span class="hljs-string">"Hash2(低16位表示) is {:x}"</span>, hasher2.finish());
    println!(<span class="hljs-string">"Hash2 is {}"</span>, hasher2.finish()); 
    println!(<span class="hljs-string">"calculate_hash:-&gt;Hash :{:?}"</span>, calculate_hash(&amp;text));

    <span class="hljs-keyword">let</span> mt1 = SystemTime::now();
    println!(<span class="hljs-string">"is_fit_num time:{:?}"</span>, mt1.duration_since(st).unwrap());
    thread::sleep_ms(<span class="hljs-number">500000</span>);
}</code></pre> 
  <p>output:</p> 
  <pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-keyword">text</span>:[<span class="hljs-number">49</span>, <span class="hljs-number">48</span>, <span class="hljs-number">48</span>, <span class="hljs-number">56</span>, <span class="hljs-number">54</span>]

Hash1(低<span class="hljs-number">16</span>位表示) <span class="hljs-keyword">is</span> <span class="hljs-number">85</span>f84a89780553ce
Hash1 <span class="hljs-keyword">is</span> <span class="hljs-number">9653547755553248206</span>

Hash2(低<span class="hljs-number">16</span>位表示) <span class="hljs-keyword">is</span> <span class="hljs-number">4</span>b5a264ac7932dc5
Hash2 <span class="hljs-keyword">is</span> <span class="hljs-number">5429694403366301125</span>

calculate_hash:-&gt;Hash :<span class="hljs-number">5429694403366301125</span></code></pre> 
  <p>思考 ： hash1为什么和hash2不同？</p> 
  <p>二、关于keypair、signature、verify 三部曲</p> 
  <p>我们看rust-crypto库的原代码的例子 <br> <a href="https://github.com/DaGenix/rust-crypto/blob/cc1a5fde1ce957bd1a8a2e30169443cdb4780111/src/ed25519.rs" rel="nofollow" target="_blank">https://github.com/DaGenix/rust-crypto/blob/cc1a5fde1ce957bd1a8a2e30169443cdb4780111/src/ed25519.rs</a></p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">use</span> digest::Digest;
<span class="hljs-keyword">use</span> sha2::{Sha512};
<span class="hljs-keyword">use</span> curve25519::{GeP2, GeP3, ge_scalarmult_base, sc_reduce, sc_muladd, curve25519, Fe};
<span class="hljs-keyword">use</span> util::{fixed_time_eq};
<span class="hljs-keyword">use</span> std::ops::{Add, Sub, Mul};

<span class="hljs-keyword">static</span> L: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">32</span>] =
      [ <span class="hljs-number">0x10</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,
        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,
        <span class="hljs-number">0x14</span>, <span class="hljs-number">0xde</span>, <span class="hljs-number">0xf9</span>, <span class="hljs-number">0xde</span>, <span class="hljs-number">0xa2</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x9c</span>, <span class="hljs-number">0xd6</span>,
        <span class="hljs-number">0x58</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x1a</span>, <span class="hljs-number">0x5c</span>, <span class="hljs-number">0xf5</span>, <span class="hljs-number">0xd3</span>, <span class="hljs-number">0xed</span> ];

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">keypair</span>(</span>seed: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; ([<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>], [<span class="hljs-keyword">u8</span>; <span class="hljs-number">32</span>]) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> secret: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hash_output: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
        hasher.input(seed);
        hasher.result(&amp;<span class="hljs-keyword">mut</span> hash_output);
        hash_output[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>;
        hash_output[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">63</span>;
        hash_output[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>;
        hash_output
    };

    <span class="hljs-keyword">let</span> a = ge_scalarmult_base(&amp;secret[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]);
    <span class="hljs-keyword">let</span> public_key = a.to_bytes();
    <span class="hljs-keyword">for</span> (dest, src) in (&amp;<span class="hljs-keyword">mut</span> secret[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>]).iter_mut().zip(public_key.iter()) {
        *dest = *src;
    }
    <span class="hljs-keyword">for</span> (dest, src) in (&amp;<span class="hljs-keyword">mut</span> secret[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]).iter_mut().zip(seed.iter()) {
        *dest = *src;
    }
    (secret, public_key)
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">signature</span>(</span>message: &amp;[<span class="hljs-keyword">u8</span>], secret_key: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] {
    <span class="hljs-keyword">let</span> seed = &amp;secret_key[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>];
    <span class="hljs-keyword">let</span> public_key = &amp;secret_key[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>];
    <span class="hljs-keyword">let</span> az: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hash_output: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
        hasher.input(seed);
        hasher.result(&amp;<span class="hljs-keyword">mut</span> hash_output);
        hash_output[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>;
        hash_output[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">63</span>;
        hash_output[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>;
        hash_output
    };

    <span class="hljs-keyword">let</span> nonce = {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hash_output: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
        hasher.input(&amp;az[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>]);
        hasher.input(message);
        hasher.result(&amp;<span class="hljs-keyword">mut</span> hash_output);
        sc_reduce(&amp;<span class="hljs-keyword">mut</span> hash_output[<span class="hljs-number">0</span>..<span class="hljs-number">64</span>]);
        hash_output
    };

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> signature: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
    <span class="hljs-keyword">let</span> r: GeP3 = ge_scalarmult_base(&amp;nonce[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]);
    <span class="hljs-keyword">for</span> (result_byte, source_byte) in (&amp;<span class="hljs-keyword">mut</span> signature[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]).iter_mut().zip(r.to_bytes().iter()) {
        *result_byte = *source_byte;
    }
    <span class="hljs-keyword">for</span> (result_byte, source_byte) in (&amp;<span class="hljs-keyword">mut</span> signature[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>]).iter_mut().zip(public_key.iter()) {
        *result_byte = *source_byte;
    }

    {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
        hasher.input(signature.as_ref());
        hasher.input(message);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hram: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
        hasher.result(&amp;<span class="hljs-keyword">mut</span> hram);
        sc_reduce(&amp;<span class="hljs-keyword">mut</span> hram);
        sc_muladd(&amp;<span class="hljs-keyword">mut</span> signature[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>], &amp;hram[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>], &amp;az[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>], &amp;nonce[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]);
    }

    signature
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check_s_lt_l</span>(</span>s: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; <span class="hljs-keyword">bool</span>
{
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c: <span class="hljs-keyword">u8</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> n: <span class="hljs-keyword">u8</span> = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> i = <span class="hljs-number">31</span>;
    <span class="hljs-keyword">loop</span> {
        c |= ((((s[i] as <span class="hljs-keyword">i32</span>) - (L[i] as <span class="hljs-keyword">i32</span>)) &gt;&gt; <span class="hljs-number">8</span>) as <span class="hljs-keyword">u8</span>) &amp; n;
        n &amp;= (((((s[i] ^ L[i]) as <span class="hljs-keyword">i32</span>)) - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>) as <span class="hljs-keyword">u8</span>;
        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
            i -= <span class="hljs-number">1</span>;
        }
    }

    c == <span class="hljs-number">0</span>
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">verify</span>(</span>message: &amp;[<span class="hljs-keyword">u8</span>], public_key: &amp;[<span class="hljs-keyword">u8</span>], signature: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; <span class="hljs-keyword">bool</span> {
    <span class="hljs-keyword">if</span> check_s_lt_l(&amp;signature[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>]) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">match</span> GeP3::from_bytes_negate_vartime(public_key) {
        Some(g) =&gt; g,
        None =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; }
    };
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> d = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> pk_byte in public_key.iter() {
        d |= *pk_byte;
    }
    <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
    hasher.input(&amp;signature[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]);
    hasher.input(public_key);
    hasher.input(message);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hash: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
    hasher.result(&amp;<span class="hljs-keyword">mut</span> hash);
    sc_reduce(&amp;<span class="hljs-keyword">mut</span> hash);

    <span class="hljs-keyword">let</span> r = GeP2::double_scalarmult_vartime(hash.as_ref(), a, &amp;signature[<span class="hljs-number">32</span>..<span class="hljs-number">64</span>]);
    <span class="hljs-keyword">let</span> rcheck = r.to_bytes();

    fixed_time_eq(rcheck.as_ref(), &amp;signature[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>])
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">exchange</span>(</span>public_key: &amp;[<span class="hljs-keyword">u8</span>], private_key: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; [<span class="hljs-keyword">u8</span>; <span class="hljs-number">32</span>] {
    <span class="hljs-keyword">let</span> ed_y = Fe::from_bytes(&amp;public_key);
    <span class="hljs-comment">// Produce public key in Montgomery form.</span>
    <span class="hljs-keyword">let</span> mont_x = edwards_to_montgomery_x(ed_y);

    <span class="hljs-comment">// Produce private key from seed component (bytes 0 to 32)</span>
    <span class="hljs-comment">// of the Ed25519 extended private key (64 bytes).</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = Sha512::new();
    hasher.input(&amp;private_key[<span class="hljs-number">0</span>..<span class="hljs-number">32</span>]);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hash: [<span class="hljs-keyword">u8</span>; <span class="hljs-number">64</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">64</span>];
    hasher.result(&amp;<span class="hljs-keyword">mut</span> hash);
    <span class="hljs-comment">// Clamp the hash such that it is a valid private key</span>
    hash[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>;
    hash[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">127</span>;
    hash[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>;

    <span class="hljs-keyword">let</span> shared_mont_x : [<span class="hljs-keyword">u8</span>; <span class="hljs-number">32</span>] = curve25519(&amp;hash, &amp;mont_x.to_bytes()); <span class="hljs-comment">// priv., pub.</span>

    shared_mont_x
}</code></pre> 
  <p>三、如何用？</p> 
  <p>看一个私钥签名，公钥解密的例子。</p> 
  <pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-keyword">extern</span> crate crypto;
<span class="hljs-keyword">use</span> crypto::*;
<span class="hljs-keyword">use</span> ed25519::{keypair, signature, verify, exchange};
<span class="hljs-keyword">use</span> curve25519::{curve25519_base, curve25519};
<span class="hljs-keyword">use</span> digest::Digest;
<span class="hljs-keyword">use</span> sha2::Sha512;
fn main() {
    <span class="hljs-keyword">let</span> seed: &amp;[u8] = &amp;[<span class="hljs-number">0x26</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0xf6</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0xc4</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf1</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xb5</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0xfd</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x8e</span>, <span class="hljs-number">0x4e</span>];<span class="hljs-comment">//32位</span>

    <span class="hljs-comment">// KEYGEN </span>
    <span class="hljs-keyword">let</span> (private_key, public_key) = keypair(seed); <span class="hljs-comment">//[U8,64]</span>

    <span class="hljs-keyword">let</span> message = b<span class="hljs-string">"This is my message!"</span>;

    <span class="hljs-comment">//私钥签名</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">sig</span> = signature(message, &amp;private_key); <span class="hljs-comment">//[U8,64]</span>

    <span class="hljs-comment">//private_key</span>
    println!(<span class="hljs-string">"private_key: {:?} "</span>, private_key.to_vec());
    println!(<span class="hljs-string">"private_key_len :{:? }"</span>, private_key.len());

    <span class="hljs-comment">// public_key</span>
    println!(<span class="hljs-string">"public_key :{:?}"</span>, public_key.to_vec());
    println!(<span class="hljs-string">"public_key_len :{:?}"</span>, public_key.len());

    <span class="hljs-comment">//signature</span>
    println!(<span class="hljs-string">"signature:{:?}"</span>, <span class="hljs-keyword">sig</span>.to_vec());
    println!(<span class="hljs-string">"signature_len:{:?}"</span>, <span class="hljs-keyword">sig</span>.len());

    <span class="hljs-comment">// verify</span>
    println!(<span class="hljs-string">"验证是否成功：{:?} "</span>,verify(message, &amp;public_key, &amp;<span class="hljs-keyword">sig</span>));
}
</code></pre> 
  <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">private_key:</span> [<span class="hljs-number">38</span>, <span class="hljs-number">39</span>, <span class="hljs-number">246</span>, <span class="hljs-number">133</span>, <span class="hljs-number">151</span>, <span class="hljs-number">21</span>, <span class="hljs-number">173</span>, <span class="hljs-number">29</span>, <span class="hljs-number">210</span>, <span class="hljs-number">148</span>, <span class="hljs-number">221</span>, <span class="hljs-number">196</span>, <span class="hljs-number">118</span>, <span class="hljs-number">25</span>, <span class="hljs-number">57</span>, <span class="hljs-number">49</span>, <span class="hljs-number">241</span>, <span class="hljs-number">173</span>, <span class="hljs-number">181</span>, <span class="hljs-number">88</span>, <span class="hljs-number">240</span>, <span class="hljs-number">147</span>, <span class="hljs-number">151</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">43</span>, <span class="hljs-number">209</span>, <span class="hljs-number">192</span>, <span class="hljs-number">253</span>, <span class="hljs-number">22</span>, <span class="hljs-number">142</span>, <span class="hljs-number">78</span>, <span class="hljs-number">93</span>, <span class="hljs-number">109</span>, <span class="hljs-number">35</span>,
 <span class="hljs-number">107</span>, <span class="hljs-number">82</span>, <span class="hljs-number">209</span>, <span class="hljs-number">142</span>, <span class="hljs-number">58</span>, <span class="hljs-number">182</span>, <span class="hljs-number">214</span>, <span class="hljs-number">7</span>, <span class="hljs-number">47</span>, <span class="hljs-number">182</span>, <span class="hljs-number">228</span>, <span class="hljs-number">199</span>, <span class="hljs-number">212</span>, <span class="hljs-number">107</span>, <span class="hljs-number">213</span>, <span class="hljs-number">154</span>, <span class="hljs-number">217</span>, <span class="hljs-number">204</span>, <span class="hljs-number">25</span>, <span class="hljs-number">71</span>, <span class="hljs-number">38</span>, <span class="hljs-number">95</span>, <span class="hljs-number">0</span>, <span class="hljs-number">183</span>, <span class="hljs-number">32</span>, <span class="hljs-number">250</span>, <span class="hljs-number">44</span>, <span class="hljs-number">143</span>, <span class="hljs-number">102</span>]
private_key_len :<span class="hljs-number">64</span>

public_key :[<span class="hljs-number">93</span>, <span class="hljs-number">109</span>, <span class="hljs-number">35</span>, <span class="hljs-number">107</span>, <span class="hljs-number">82</span>, <span class="hljs-number">209</span>, <span class="hljs-number">142</span>, <span class="hljs-number">58</span>, <span class="hljs-number">182</span>, <span class="hljs-number">214</span>, <span class="hljs-number">7</span>, <span class="hljs-number">47</span>, <span class="hljs-number">182</span>, <span class="hljs-number">228</span>, <span class="hljs-number">199</span>, <span class="hljs-number">212</span>, <span class="hljs-number">107</span>, <span class="hljs-number">213</span>, <span class="hljs-number">154</span>, <span class="hljs-number">217</span>, <span class="hljs-number">204</span>, <span class="hljs-number">25</span>, <span class="hljs-number">71</span>, <span class="hljs-number">38</span>, <span class="hljs-number">95</span>, <span class="hljs-number">0</span>, <span class="hljs-number">183</span>, <span class="hljs-number">32</span>, <span class="hljs-number">250</span>, <span class="hljs-number">44</span>, <span class="hljs-number">143</span>, <span class="hljs-number">102</span>]
public_key_len :<span class="hljs-number">32</span>
<span class="hljs-label">signature:</span>[<span class="hljs-number">163</span>, <span class="hljs-number">41</span>, <span class="hljs-number">56</span>, <span class="hljs-number">4</span>, <span class="hljs-number">173</span>, <span class="hljs-number">251</span>, <span class="hljs-number">241</span>, <span class="hljs-number">219</span>, <span class="hljs-number">149</span>, <span class="hljs-number">58</span>, <span class="hljs-number">146</span>, <span class="hljs-number">122</span>, <span class="hljs-number">98</span>, <span class="hljs-number">42</span>, <span class="hljs-number">27</span>, <span class="hljs-number">108</span>, <span class="hljs-number">25</span>, <span class="hljs-number">3</span>, <span class="hljs-number">130</span>, <span class="hljs-number">238</span>, <span class="hljs-number">94</span>, <span class="hljs-number">244</span>, <span class="hljs-number">235</span>, <span class="hljs-number">181</span>, <span class="hljs-number">70</span>, <span class="hljs-number">68</span>, <span class="hljs-number">226</span>, <span class="hljs-number">117</span>, <span class="hljs-number">98</span>, <span class="hljs-number">88</span>, <span class="hljs-number">135</span>, <span class="hljs-number">182</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>, <span class="hljs-number">122</span>, <span class="hljs-number">203</span>
, <span class="hljs-number">190</span>, <span class="hljs-number">66</span>, <span class="hljs-number">6</span>, <span class="hljs-number">139</span>, <span class="hljs-number">6</span>, <span class="hljs-number">242</span>, <span class="hljs-number">94</span>, <span class="hljs-number">98</span>, <span class="hljs-number">107</span>, <span class="hljs-number">99</span>, <span class="hljs-number">144</span>, <span class="hljs-number">208</span>, <span class="hljs-number">145</span>, <span class="hljs-number">218</span>, <span class="hljs-number">120</span>, <span class="hljs-number">236</span>, <span class="hljs-number">223</span>, <span class="hljs-number">60</span>, <span class="hljs-number">87</span>, <span class="hljs-number">19</span>, <span class="hljs-number">245</span>, <span class="hljs-number">249</span>, <span class="hljs-number">177</span>, <span class="hljs-number">246</span>, <span class="hljs-number">212</span>, <span class="hljs-number">160</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]
<span class="hljs-label">signature_len:</span><span class="hljs-number">64</span>

验证是否成功：true
</code></pre> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wowotuo/article/details/77272216,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wowotuo/article/details/77272216,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
