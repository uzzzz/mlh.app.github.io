<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链解读7-区块链1.0（比特币技术） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链解读7-区块链1.0（比特币技术）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="解读区块链，区块链1.0（比特币技术） 区块链技术随着不断的发展，逐渐被定3个阶段： 区块链1.0：以比特币为代表的虚拟货币，目前最成功的毫无疑问就是比特币，虽然它一直被质疑有能源的浪费，难以监管、甚至被一些不法的应用，但1.0的状态下，仍然给我们勾勒了一个理想的场景–全球统一货币，起点很高，远景很美好，实现路途艰难。 区块链2.0：区块链技术被广泛应用在各个金融领域，比如股票、债券、期货、银行存贷、抵押、智能合同等方面。2.0目前典型代表就是以太坊和超级账本、面对应用于公众的公有链和应用于企业的联盟链。区块链2.0和1.0从技术角度上还具有图灵完备、支持智能合约、定位于平台去实现各种应用等技术更新。 区块链3.0：就和互联网一样，区块链3.0被理解将应用到更广阔的领域，覆盖人们的日常生活，以区块链技术来证明实现个人信息的自证明，不再需要第三方信任认证托管机构，实现信息的共享，应用在司法，医疗，物流，艺术、收藏等领域。 笔者通过对比特币运行机制的解读，概括区块链技术1.0 首先讲一个故事：（帮助理解） 我们假设有一个村子，村子里有一个卖苹果和一个卖西瓜的小商贩，每次卖苹果想吃西瓜了就拿苹果去和卖西瓜的换西瓜，相反卖西瓜的也用西瓜换苹果吃。 然后有一天卖西瓜的先吃橘子，先用西瓜去和卖橘子的小贩换，结果橘子小贩不喜欢吃西瓜，用苹果换，橘子小贩也不喜欢吃苹果，问题就来了。 于是三个小贩直接约定，用一个大家都喜欢物品作为交易等价物，他们选择了黄金，每个人都接受黄金，每个人都愿意用黄金来买卖其他货物。 过了一段时间发现获取黄金这个方式还是很麻烦了，不是人人都能挖到黄金，而且黄金是实物，携带不方便还容易磨损，一块金币被来回交易，过段时间可能就剩下三分之二了。于是大家决定我们用纸，纸上写多少黄金，就是多少黄金。但是不是谁都能写这个纸的，大家找到了村长，村子根据各家拥有的黄金数量，写多少，然后签名盖章，这个纸上的数字才能生效对应多少黄金。然后每一户拿着村长写的纸就可以流通买卖了。 后来村长发现，每天都有很多纸币被损耗掉，然后不停有人来找他换，他觉得很麻烦，就开始告诉每一个人，你们以后买卖东西，不用真正用纸币去买卖了，我找了我兄弟，到他那里记账，各家的交易记录在账本上了，每个人加加减减就可以了。 然后大家突然每家有多少钱都记录在村长兄弟那里，村长兄弟是否可以修改每家的钱，村长是否知道他兄弟是不是偷偷把账本上的数字都改了呢，万一村长兄弟一不小心把账本丢了，那每家的纪录还怎么找回来呢。 众多疑问出现后，针对这个账本出现了比特币。 每个人对自己账户和交易的安全性肯定是最为关注的，在比特币中利用密码学数学函数来保障，哈希函数要达到密码安全有三个条件： 碰撞阻力collision-resistance：简单理解 x、y， x不等于y，H(x)=H（y），理论上碰撞时确实存在的，根据鸽巢理论（pigeonhole principle）可以想象输入空间远远大于输出空间，必将会有一定的不同字符串输入会产生一样的输出，针对一个256位的固定输出，那输入+1次就会产生相同输出，通过生日悖论（birthday paradox）你在输入+1次就有99.8%的概念得到相同输出。这是理论上的，事实上目前的计算节点针对这种运算，即使每秒运算上万次，也需要一个远超越地球诞生至今的时间才有可能实现。 隐秘性hiding：知道y，y=H（x），无法推算出x，如果一个输入z选自一个高阶最小熵（high min-entroy）的概率分布，那在给定H（z||x）条件下，确定x是不可行的，换成通俗说话就是，z是从长度为256位的字符串中选择出来的，随意选择，那么任何特定字符串被选中的概率就是1/，这个值十分小。 谜题友好puzzle-friendliness：如果对于任意n位输出值y，假设k选择高阶最小熵分布，如果无法在比小很多时间内找到H（k||x）=y中x值，那么H哈希函数谜题友好。 比特币中用的是SHA-256算法，被称为安全哈希算法： SHA-256算法简化步骤（笔记忽略吧~~） SHA-256是一种将接受固定长度转变为接受任意长度输入的哈希函数，这个称为MD转换（MD5熟悉吧），也可称为压缩函数，所谓压缩函数就是输入m长度的值，产生一些长度短一点的n的输出，输入可以任意大小，被分为m-n的区块，然后将每个区块和之前区块的输出一起代入压缩函数，输出长度就变成了（m-n）+n=m，对第一个区块来说，没有之前的初始向量了，没有就补一个初始向量，每次调用哈希函数，这些数字就再使用一次，最后一个区块就是返回结果。SHA-256就是把一个768位的输入压缩称为256位的输出，每一个区块是512位。具体见上图。 在区块链中还用到哈希指针，简单理解就是指针经过哈希运算，保证不被篡改，如果有人想修改区块K的数据，那么数据改变后，区块K+1的哈希值将不会匹配链接下去了。区块链也被认为是一个防篡改日志，比特币中修改区块数据后将不会被链接，系统中默认最长链为有效链。 链接见图： 哈希函数还运用在merkle 树（前文有详细介绍）、公钥、私钥、地址、隶属证明。这些等下在交易过程中具体说明。 既然由密码数学函数保证，我们认为我们的账户和交易的输入输出是安全的。接下来说下交易的流程。 回到刚才的故事，苹果小贩和西瓜小贩开始交易了10个BTC 这是一个直观图，具体来说比特币的交易是转账，有输入和输出组成，每个交易输入就是前一笔交易的输出，最终到最初的源头，那是一个没有输入的交易，这个称为coinbase，这类交易是奖励挖矿产生的交易，一般位于区块的第一笔。比特币中有过单笔1.5亿的交易。 再分析交易程序代码： 元数据：内部信息，包含交易规模、输入和输出的数量，还有该笔交易的哈希值，哈希指针指向。 输入：输入格式固定，输入前要说明之前一笔交易的输出来对应这个输入，包含之前一笔交易的哈希值、之前输出的索引、签名，签名保证来验证是否合法。 输出：输出分两部分，输出金额之和小于或者等于输入金额之和，输入和输出的差额最为交易费给记账的旷工。还有一部分是脚本，接下去就说脚本了。 输出中不仅包含了一个公钥，还有一个是脚本，脚本出现在输出代码中，但是一个输入必须去验证之前的输出，所有输入、输出都有有脚本的，可以理解为：输出脚本是题目、输入脚本是题解。笔者结合书和http://www.8btc.com/understand-bitcoin-script明白脚本。 比特币交易中使用的脚本系统与FORTH(一种编译语言)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完备（图灵完备被认为是区块链2.0必备），没有LOOP语句。 上图结合输人输出脚本的范例 OP_DUP:复制堆栈顶端数据 OP_HASH160:计算哈希两次，第一次是sha-256，第二次是RIPEMD-160 阅读更多" />
<meta property="og:description" content="解读区块链，区块链1.0（比特币技术） 区块链技术随着不断的发展，逐渐被定3个阶段： 区块链1.0：以比特币为代表的虚拟货币，目前最成功的毫无疑问就是比特币，虽然它一直被质疑有能源的浪费，难以监管、甚至被一些不法的应用，但1.0的状态下，仍然给我们勾勒了一个理想的场景–全球统一货币，起点很高，远景很美好，实现路途艰难。 区块链2.0：区块链技术被广泛应用在各个金融领域，比如股票、债券、期货、银行存贷、抵押、智能合同等方面。2.0目前典型代表就是以太坊和超级账本、面对应用于公众的公有链和应用于企业的联盟链。区块链2.0和1.0从技术角度上还具有图灵完备、支持智能合约、定位于平台去实现各种应用等技术更新。 区块链3.0：就和互联网一样，区块链3.0被理解将应用到更广阔的领域，覆盖人们的日常生活，以区块链技术来证明实现个人信息的自证明，不再需要第三方信任认证托管机构，实现信息的共享，应用在司法，医疗，物流，艺术、收藏等领域。 笔者通过对比特币运行机制的解读，概括区块链技术1.0 首先讲一个故事：（帮助理解） 我们假设有一个村子，村子里有一个卖苹果和一个卖西瓜的小商贩，每次卖苹果想吃西瓜了就拿苹果去和卖西瓜的换西瓜，相反卖西瓜的也用西瓜换苹果吃。 然后有一天卖西瓜的先吃橘子，先用西瓜去和卖橘子的小贩换，结果橘子小贩不喜欢吃西瓜，用苹果换，橘子小贩也不喜欢吃苹果，问题就来了。 于是三个小贩直接约定，用一个大家都喜欢物品作为交易等价物，他们选择了黄金，每个人都接受黄金，每个人都愿意用黄金来买卖其他货物。 过了一段时间发现获取黄金这个方式还是很麻烦了，不是人人都能挖到黄金，而且黄金是实物，携带不方便还容易磨损，一块金币被来回交易，过段时间可能就剩下三分之二了。于是大家决定我们用纸，纸上写多少黄金，就是多少黄金。但是不是谁都能写这个纸的，大家找到了村长，村子根据各家拥有的黄金数量，写多少，然后签名盖章，这个纸上的数字才能生效对应多少黄金。然后每一户拿着村长写的纸就可以流通买卖了。 后来村长发现，每天都有很多纸币被损耗掉，然后不停有人来找他换，他觉得很麻烦，就开始告诉每一个人，你们以后买卖东西，不用真正用纸币去买卖了，我找了我兄弟，到他那里记账，各家的交易记录在账本上了，每个人加加减减就可以了。 然后大家突然每家有多少钱都记录在村长兄弟那里，村长兄弟是否可以修改每家的钱，村长是否知道他兄弟是不是偷偷把账本上的数字都改了呢，万一村长兄弟一不小心把账本丢了，那每家的纪录还怎么找回来呢。 众多疑问出现后，针对这个账本出现了比特币。 每个人对自己账户和交易的安全性肯定是最为关注的，在比特币中利用密码学数学函数来保障，哈希函数要达到密码安全有三个条件： 碰撞阻力collision-resistance：简单理解 x、y， x不等于y，H(x)=H（y），理论上碰撞时确实存在的，根据鸽巢理论（pigeonhole principle）可以想象输入空间远远大于输出空间，必将会有一定的不同字符串输入会产生一样的输出，针对一个256位的固定输出，那输入+1次就会产生相同输出，通过生日悖论（birthday paradox）你在输入+1次就有99.8%的概念得到相同输出。这是理论上的，事实上目前的计算节点针对这种运算，即使每秒运算上万次，也需要一个远超越地球诞生至今的时间才有可能实现。 隐秘性hiding：知道y，y=H（x），无法推算出x，如果一个输入z选自一个高阶最小熵（high min-entroy）的概率分布，那在给定H（z||x）条件下，确定x是不可行的，换成通俗说话就是，z是从长度为256位的字符串中选择出来的，随意选择，那么任何特定字符串被选中的概率就是1/，这个值十分小。 谜题友好puzzle-friendliness：如果对于任意n位输出值y，假设k选择高阶最小熵分布，如果无法在比小很多时间内找到H（k||x）=y中x值，那么H哈希函数谜题友好。 比特币中用的是SHA-256算法，被称为安全哈希算法： SHA-256算法简化步骤（笔记忽略吧~~） SHA-256是一种将接受固定长度转变为接受任意长度输入的哈希函数，这个称为MD转换（MD5熟悉吧），也可称为压缩函数，所谓压缩函数就是输入m长度的值，产生一些长度短一点的n的输出，输入可以任意大小，被分为m-n的区块，然后将每个区块和之前区块的输出一起代入压缩函数，输出长度就变成了（m-n）+n=m，对第一个区块来说，没有之前的初始向量了，没有就补一个初始向量，每次调用哈希函数，这些数字就再使用一次，最后一个区块就是返回结果。SHA-256就是把一个768位的输入压缩称为256位的输出，每一个区块是512位。具体见上图。 在区块链中还用到哈希指针，简单理解就是指针经过哈希运算，保证不被篡改，如果有人想修改区块K的数据，那么数据改变后，区块K+1的哈希值将不会匹配链接下去了。区块链也被认为是一个防篡改日志，比特币中修改区块数据后将不会被链接，系统中默认最长链为有效链。 链接见图： 哈希函数还运用在merkle 树（前文有详细介绍）、公钥、私钥、地址、隶属证明。这些等下在交易过程中具体说明。 既然由密码数学函数保证，我们认为我们的账户和交易的输入输出是安全的。接下来说下交易的流程。 回到刚才的故事，苹果小贩和西瓜小贩开始交易了10个BTC 这是一个直观图，具体来说比特币的交易是转账，有输入和输出组成，每个交易输入就是前一笔交易的输出，最终到最初的源头，那是一个没有输入的交易，这个称为coinbase，这类交易是奖励挖矿产生的交易，一般位于区块的第一笔。比特币中有过单笔1.5亿的交易。 再分析交易程序代码： 元数据：内部信息，包含交易规模、输入和输出的数量，还有该笔交易的哈希值，哈希指针指向。 输入：输入格式固定，输入前要说明之前一笔交易的输出来对应这个输入，包含之前一笔交易的哈希值、之前输出的索引、签名，签名保证来验证是否合法。 输出：输出分两部分，输出金额之和小于或者等于输入金额之和，输入和输出的差额最为交易费给记账的旷工。还有一部分是脚本，接下去就说脚本了。 输出中不仅包含了一个公钥，还有一个是脚本，脚本出现在输出代码中，但是一个输入必须去验证之前的输出，所有输入、输出都有有脚本的，可以理解为：输出脚本是题目、输入脚本是题解。笔者结合书和http://www.8btc.com/understand-bitcoin-script明白脚本。 比特币交易中使用的脚本系统与FORTH(一种编译语言)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完备（图灵完备被认为是区块链2.0必备），没有LOOP语句。 上图结合输人输出脚本的范例 OP_DUP:复制堆栈顶端数据 OP_HASH160:计算哈希两次，第一次是sha-256，第二次是RIPEMD-160 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/08/12/64c69e2b62e2480db62e3d4ce8fe7f84.html" />
<meta property="og:url" content="https://mlh.app/2017/08/12/64c69e2b62e2480db62e3d4ce8fe7f84.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"解读区块链，区块链1.0（比特币技术） 区块链技术随着不断的发展，逐渐被定3个阶段： 区块链1.0：以比特币为代表的虚拟货币，目前最成功的毫无疑问就是比特币，虽然它一直被质疑有能源的浪费，难以监管、甚至被一些不法的应用，但1.0的状态下，仍然给我们勾勒了一个理想的场景–全球统一货币，起点很高，远景很美好，实现路途艰难。 区块链2.0：区块链技术被广泛应用在各个金融领域，比如股票、债券、期货、银行存贷、抵押、智能合同等方面。2.0目前典型代表就是以太坊和超级账本、面对应用于公众的公有链和应用于企业的联盟链。区块链2.0和1.0从技术角度上还具有图灵完备、支持智能合约、定位于平台去实现各种应用等技术更新。 区块链3.0：就和互联网一样，区块链3.0被理解将应用到更广阔的领域，覆盖人们的日常生活，以区块链技术来证明实现个人信息的自证明，不再需要第三方信任认证托管机构，实现信息的共享，应用在司法，医疗，物流，艺术、收藏等领域。 笔者通过对比特币运行机制的解读，概括区块链技术1.0 首先讲一个故事：（帮助理解） 我们假设有一个村子，村子里有一个卖苹果和一个卖西瓜的小商贩，每次卖苹果想吃西瓜了就拿苹果去和卖西瓜的换西瓜，相反卖西瓜的也用西瓜换苹果吃。 然后有一天卖西瓜的先吃橘子，先用西瓜去和卖橘子的小贩换，结果橘子小贩不喜欢吃西瓜，用苹果换，橘子小贩也不喜欢吃苹果，问题就来了。 于是三个小贩直接约定，用一个大家都喜欢物品作为交易等价物，他们选择了黄金，每个人都接受黄金，每个人都愿意用黄金来买卖其他货物。 过了一段时间发现获取黄金这个方式还是很麻烦了，不是人人都能挖到黄金，而且黄金是实物，携带不方便还容易磨损，一块金币被来回交易，过段时间可能就剩下三分之二了。于是大家决定我们用纸，纸上写多少黄金，就是多少黄金。但是不是谁都能写这个纸的，大家找到了村长，村子根据各家拥有的黄金数量，写多少，然后签名盖章，这个纸上的数字才能生效对应多少黄金。然后每一户拿着村长写的纸就可以流通买卖了。 后来村长发现，每天都有很多纸币被损耗掉，然后不停有人来找他换，他觉得很麻烦，就开始告诉每一个人，你们以后买卖东西，不用真正用纸币去买卖了，我找了我兄弟，到他那里记账，各家的交易记录在账本上了，每个人加加减减就可以了。 然后大家突然每家有多少钱都记录在村长兄弟那里，村长兄弟是否可以修改每家的钱，村长是否知道他兄弟是不是偷偷把账本上的数字都改了呢，万一村长兄弟一不小心把账本丢了，那每家的纪录还怎么找回来呢。 众多疑问出现后，针对这个账本出现了比特币。 每个人对自己账户和交易的安全性肯定是最为关注的，在比特币中利用密码学数学函数来保障，哈希函数要达到密码安全有三个条件： 碰撞阻力collision-resistance：简单理解 x、y， x不等于y，H(x)=H（y），理论上碰撞时确实存在的，根据鸽巢理论（pigeonhole principle）可以想象输入空间远远大于输出空间，必将会有一定的不同字符串输入会产生一样的输出，针对一个256位的固定输出，那输入+1次就会产生相同输出，通过生日悖论（birthday paradox）你在输入+1次就有99.8%的概念得到相同输出。这是理论上的，事实上目前的计算节点针对这种运算，即使每秒运算上万次，也需要一个远超越地球诞生至今的时间才有可能实现。 隐秘性hiding：知道y，y=H（x），无法推算出x，如果一个输入z选自一个高阶最小熵（high min-entroy）的概率分布，那在给定H（z||x）条件下，确定x是不可行的，换成通俗说话就是，z是从长度为256位的字符串中选择出来的，随意选择，那么任何特定字符串被选中的概率就是1/，这个值十分小。 谜题友好puzzle-friendliness：如果对于任意n位输出值y，假设k选择高阶最小熵分布，如果无法在比小很多时间内找到H（k||x）=y中x值，那么H哈希函数谜题友好。 比特币中用的是SHA-256算法，被称为安全哈希算法： SHA-256算法简化步骤（笔记忽略吧~~） SHA-256是一种将接受固定长度转变为接受任意长度输入的哈希函数，这个称为MD转换（MD5熟悉吧），也可称为压缩函数，所谓压缩函数就是输入m长度的值，产生一些长度短一点的n的输出，输入可以任意大小，被分为m-n的区块，然后将每个区块和之前区块的输出一起代入压缩函数，输出长度就变成了（m-n）+n=m，对第一个区块来说，没有之前的初始向量了，没有就补一个初始向量，每次调用哈希函数，这些数字就再使用一次，最后一个区块就是返回结果。SHA-256就是把一个768位的输入压缩称为256位的输出，每一个区块是512位。具体见上图。 在区块链中还用到哈希指针，简单理解就是指针经过哈希运算，保证不被篡改，如果有人想修改区块K的数据，那么数据改变后，区块K+1的哈希值将不会匹配链接下去了。区块链也被认为是一个防篡改日志，比特币中修改区块数据后将不会被链接，系统中默认最长链为有效链。 链接见图： 哈希函数还运用在merkle 树（前文有详细介绍）、公钥、私钥、地址、隶属证明。这些等下在交易过程中具体说明。 既然由密码数学函数保证，我们认为我们的账户和交易的输入输出是安全的。接下来说下交易的流程。 回到刚才的故事，苹果小贩和西瓜小贩开始交易了10个BTC 这是一个直观图，具体来说比特币的交易是转账，有输入和输出组成，每个交易输入就是前一笔交易的输出，最终到最初的源头，那是一个没有输入的交易，这个称为coinbase，这类交易是奖励挖矿产生的交易，一般位于区块的第一笔。比特币中有过单笔1.5亿的交易。 再分析交易程序代码： 元数据：内部信息，包含交易规模、输入和输出的数量，还有该笔交易的哈希值，哈希指针指向。 输入：输入格式固定，输入前要说明之前一笔交易的输出来对应这个输入，包含之前一笔交易的哈希值、之前输出的索引、签名，签名保证来验证是否合法。 输出：输出分两部分，输出金额之和小于或者等于输入金额之和，输入和输出的差额最为交易费给记账的旷工。还有一部分是脚本，接下去就说脚本了。 输出中不仅包含了一个公钥，还有一个是脚本，脚本出现在输出代码中，但是一个输入必须去验证之前的输出，所有输入、输出都有有脚本的，可以理解为：输出脚本是题目、输入脚本是题解。笔者结合书和http://www.8btc.com/understand-bitcoin-script明白脚本。 比特币交易中使用的脚本系统与FORTH(一种编译语言)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完备（图灵完备被认为是区块链2.0必备），没有LOOP语句。 上图结合输人输出脚本的范例 OP_DUP:复制堆栈顶端数据 OP_HASH160:计算哈希两次，第一次是sha-256，第二次是RIPEMD-160 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/08/12/64c69e2b62e2480db62e3d4ce8fe7f84.html","headline":"区块链解读7-区块链1.0（比特币技术）","dateModified":"2017-08-12T00:00:00+08:00","datePublished":"2017-08-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/08/12/64c69e2b62e2480db62e3d4ce8fe7f84.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链解读7-区块链1.0（比特币技术）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>解读区块链，区块链1.0（比特币技术） <br> 区块链技术随着不断的发展，逐渐被定3个阶段： <br> 区块链1.0：以比特币为代表的虚拟货币，目前最成功的毫无疑问就是比特币，虽然它一直被质疑有能源的浪费，难以监管、甚至被一些不法的应用，但1.0的状态下，仍然给我们勾勒了一个理想的场景–全球统一货币，起点很高，远景很美好，实现路途艰难。 <br> 区块链2.0：区块链技术被广泛应用在各个金融领域，比如股票、债券、期货、银行存贷、抵押、智能合同等方面。2.0目前典型代表就是以太坊和超级账本、面对应用于公众的公有链和应用于企业的联盟链。区块链2.0和1.0从技术角度上还具有图灵完备、支持智能合约、定位于平台去实现各种应用等技术更新。 <br> 区块链3.0：就和互联网一样，区块链3.0被理解将应用到更广阔的领域，覆盖人们的日常生活，以区块链技术来证明实现个人信息的自证明，不再需要第三方信任认证托管机构，实现信息的共享，应用在司法，医疗，物流，艺术、收藏等领域。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171821445?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>笔者通过对比特币运行机制的解读，概括区块链技术1.0 <br> 首先讲一个故事：（帮助理解） <br> 我们假设有一个村子，村子里有一个卖苹果和一个卖西瓜的小商贩，每次卖苹果想吃西瓜了就拿苹果去和卖西瓜的换西瓜，相反卖西瓜的也用西瓜换苹果吃。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171835940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 然后有一天卖西瓜的先吃橘子，先用西瓜去和卖橘子的小贩换，结果橘子小贩不喜欢吃西瓜，用苹果换，橘子小贩也不喜欢吃苹果，问题就来了。 <br> 于是三个小贩直接约定，用一个大家都喜欢物品作为交易等价物，他们选择了黄金，每个人都接受黄金，每个人都愿意用黄金来买卖其他货物。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171848950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 过了一段时间发现获取黄金这个方式还是很麻烦了，不是人人都能挖到黄金，而且黄金是实物，携带不方便还容易磨损，一块金币被来回交易，过段时间可能就剩下三分之二了。于是大家决定我们用纸，纸上写多少黄金，就是多少黄金。但是不是谁都能写这个纸的，大家找到了村长，村子根据各家拥有的黄金数量，写多少，然后签名盖章，这个纸上的数字才能生效对应多少黄金。然后每一户拿着村长写的纸就可以流通买卖了。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171903010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 后来村长发现，每天都有很多纸币被损耗掉，然后不停有人来找他换，他觉得很麻烦，就开始告诉每一个人，你们以后买卖东西，不用真正用纸币去买卖了，我找了我兄弟，到他那里记账，各家的交易记录在账本上了，每个人加加减减就可以了。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171912564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 然后大家突然每家有多少钱都记录在村长兄弟那里，村长兄弟是否可以修改每家的钱，村长是否知道他兄弟是不是偷偷把账本上的数字都改了呢，万一村长兄弟一不小心把账本丢了，那每家的纪录还怎么找回来呢。 <br> 众多疑问出现后，针对这个账本出现了比特币。 <br> 每个人对自己账户和交易的安全性肯定是最为关注的，在比特币中利用密码学数学函数来保障，哈希函数要达到密码安全有三个条件： <br> 碰撞阻力collision-resistance：简单理解 x、y， x不等于y，H(x)=H（y），理论上碰撞时确实存在的，根据鸽巢理论（pigeonhole principle）可以想象输入空间远远大于输出空间，必将会有一定的不同字符串输入会产生一样的输出，针对一个256位的固定输出，那输入+1次就会产生相同输出，通过生日悖论（birthday paradox）你在输入+1次就有99.8%的概念得到相同输出。这是理论上的，事实上目前的计算节点针对这种运算，即使每秒运算上万次，也需要一个远超越地球诞生至今的时间才有可能实现。 <br> 隐秘性hiding：知道y，y=H（x），无法推算出x，如果一个输入z选自一个高阶最小熵（high min-entroy）的概率分布，那在给定H（z||x）条件下，确定x是不可行的，换成通俗说话就是，z是从长度为256位的字符串中选择出来的，随意选择，那么任何特定字符串被选中的概率就是1/，这个值十分小。 <br> 谜题友好puzzle-friendliness：如果对于任意n位输出值y，假设k选择高阶最小熵分布，如果无法在比小很多时间内找到H（k||x）=y中x值，那么H哈希函数谜题友好。 <br> 比特币中用的是SHA-256算法，被称为安全哈希算法： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171931609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> SHA-256算法简化步骤（笔记忽略吧~~） <br> SHA-256是一种将接受固定长度转变为接受任意长度输入的哈希函数，这个称为MD转换（MD5熟悉吧），也可称为压缩函数，所谓压缩函数就是输入m长度的值，产生一些长度短一点的n的输出，输入可以任意大小，被分为m-n的区块，然后将每个区块和之前区块的输出一起代入压缩函数，输出长度就变成了（m-n）+n=m，对第一个区块来说，没有之前的初始向量了，没有就补一个初始向量，每次调用哈希函数，这些数字就再使用一次，最后一个区块就是返回结果。SHA-256就是把一个768位的输入压缩称为256位的输出，每一个区块是512位。具体见上图。 <br> 在区块链中还用到哈希指针，简单理解就是指针经过哈希运算，保证不被篡改，如果有人想修改区块K的数据，那么数据改变后，区块K+1的哈希值将不会匹配链接下去了。区块链也被认为是一个防篡改日志，比特币中修改区块数据后将不会被链接，系统中默认最长链为有效链。 <br> 链接见图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171942322?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 哈希函数还运用在merkle 树（前文有详细介绍）、公钥、私钥、地址、隶属证明。这些等下在交易过程中具体说明。 <br> 既然由密码数学函数保证，我们认为我们的账户和交易的输入输出是安全的。接下来说下交易的流程。 <br> 回到刚才的故事，苹果小贩和西瓜小贩开始交易了10个BTC <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812171959057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 这是一个直观图，具体来说比特币的交易是转账，有输入和输出组成，每个交易输入就是前一笔交易的输出，最终到最初的源头，那是一个没有输入的交易，这个称为coinbase，这类交易是奖励挖矿产生的交易，一般位于区块的第一笔。比特币中有过单笔1.5亿的交易。 <br> 再分析交易程序代码： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812172007933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 元数据：内部信息，包含交易规模、输入和输出的数量，还有该笔交易的哈希值，哈希指针指向。 <br> 输入：输入格式固定，输入前要说明之前一笔交易的输出来对应这个输入，包含之前一笔交易的哈希值、之前输出的索引、签名，签名保证来验证是否合法。 <br> 输出：输出分两部分，输出金额之和小于或者等于输入金额之和，输入和输出的差额最为交易费给记账的旷工。还有一部分是脚本，接下去就说脚本了。 <br> 输出中不仅包含了一个公钥，还有一个是脚本，脚本出现在输出代码中，但是一个输入必须去验证之前的输出，所有输入、输出都有有脚本的，可以理解为：输出脚本是题目、输入脚本是题解。笔者结合书和<a href="http://www.8btc.com/understand-bitcoin-script" rel="nofollow">http://www.8btc.com/understand-bitcoin-script</a>明白脚本。 <br> 比特币交易中使用的脚本系统与FORTH(一种编译语言)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完备（图灵完备被认为是区块链2.0必备），没有LOOP语句。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170812172025997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqaW5taW5namll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 上图结合输人输出脚本的范例 <br> OP_DUP:复制堆栈顶端数据 <br> OP_HASH160:计算哈希两次，第一次是sha-256，第二次是RIPEMD-160 <br> </p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sxjinmingjie/article/details/77124462,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sxjinmingjie/article/details/77124462,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
