<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Ethereum数据存储分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Ethereum数据存储分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ethereum数据存储分析 第一部分看看geth客户端的整体结构&nbsp;创建私链的时候已经指定创世块genesis.json都放在private-geth目录下，现在是已经挖矿过的目录。 Current里面的内容是MANIFEST-000007 ~ &nbsp; 进入真正的存放数据的目录private-geth/data/00&nbsp; geth中保存的是区块链的相关数据&nbsp; keystore中保存的是该链条中的用户信息 History记录历史信息 之前我们这个节点已经创建了两个账户，现在我们可以看到keystore里面有两个账户信息的文件 每个账户都由一对钥匙定义，一个私钥和一个公钥。账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20个字节。每对私钥 /地址都编码在一个钥匙文件里。钥匙文件是JSON文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分，账户私钥，通常用你创建帐户时设置的密码进行加密。钥匙文件的文件名格式为UTC。账号列出时是按字母顺序排列，但是由于时间戳格式，实际上它是按创建顺序排列。如果把秘钥丢了钥匙文件可以在以太坊节点数据目录的keystore子目录下找到，接下来我们进入一个keystore目录文件看看他的信息： &nbsp; 警告：记住密码并”备份钥匙文件”。为了从账号发送交易，包括发送以太币，你必须同时有钥匙文件和密码。确保钥匙文件有个备份并牢记密码，尽可能安全地存储它们。这里没有逃亡路径，如果钥匙文件丢失或忘记密码，就会丢失所有的以太币。没有密码不可能进入账号，也没有忘记密码选项。所以一定不要忘记密码。 接下来进入geth可以看到chaindata，lightchaindata，nodes目录 进入nodes（我们这条私链有三个节点，所以这里有三个ldb文件） 进入chaindata，区块链最后的本地存储都是以ldb文件 Lightchaindata是一个轻客户端的模式，该模式无需下载较大的以太坊区块链，免去了繁琐的流程 第二部分看看源码的结构 1 Core/types/block.Go&nbsp;首先看到的是一个区块的结构 区块主要分为区块体和区块头，下面是去块体的结构，主要是交易列表和叔块列表 &nbsp; &nbsp; 这是区块头的结构体 我们知道了一个区块的结构，那它是怎么存储的呢 区块和交易等数据最终都是存储在leveldb数据库中的，数据库的存储位置在datadir/geth/chaindata中，在core/database_util.go中封装了所有与区块存储和读取相关的代码，通过这些代码可以弄清楚区块、交易等数据结构在数据库中是如何存储的。 leveldb是一个key-value数据库，所有数据都是以键-值对的形式存储。key一般与hash相关，value一般是要存储的数据结构的RLP编码。区块存储时将区块头和区块体分开存储。 区块头的存储格式为： headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) 其中key由区块头前缀、区块号（uint64大端格式）、区块hash构成，value是区块头的RLP编码。 区块体的存储格式为： bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) 其中key由区块体前缀、区块号（uint64大端格式）、区块hash构成，value是区块体的RLP编码。 key中的前缀可以用来区分数据的类型，在core/database_util.go中定义了各种前缀： headerPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;h&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash -&gt; header tdSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;t&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td numSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;n&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash blockHashPrefix&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;H&quot;)&nbsp;&nbsp; //blockHashPrefix + hash -&gt; num (uint64 big endian) bodyPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;b&quot;)&nbsp;&nbsp; //bodyPrefix + num (uint64 big endian) + hash -&gt; block body 其中headerPrefix定义了区块头key的前缀为h，bodyPrefix定义了区块体key的前缀为b。 下面是存储区块头的函数： // WriteHeader serializes a block header into thedatabase. funcWriteHeader(db ethdb.Database, header*types.Header) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(header) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; hash :=header.Hash().Bytes() &nbsp;&nbsp;&nbsp; num :=header.Number.Uint64() &nbsp;&nbsp;&nbsp; encNum:= encodeBlockNumber(num) &nbsp;&nbsp;&nbsp; key := append(blockHashPrefix, hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store hash to numbermapping into database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store header intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored header#%v [%x…]&quot;, header.Number, hash[:4]) &nbsp;&nbsp;&nbsp; returnnil } 它是先对区块头进行RLP编码，encodeBlockNumber将区块号转换成大端格式，然后组装key。这里先向数据库中存储一条&nbsp;区块hash-&gt;区块号&nbsp;的记录，最后将区块头的RLP编码写到数据库中。 下面是存储区块体的函数： // WriteBody serializes the body of a block intothe database. funcWriteBody(db ethdb.Database, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(body) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return WriteBodyRLP(db, hash, number, data) } &nbsp; // WriteBodyRLP writes a serialized body of ablock into the database. funcWriteBodyRLP(db ethdb.Database, hash common.Hash,number uint64, rlp rlp.RawValue)error { &nbsp;&nbsp;&nbsp; key := append(append(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, rlp); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store block body intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored blockbody [%x…]&quot;, hash.Bytes()[:4]) &nbsp;&nbsp;&nbsp; returnnil } WriteBody先对区块体进行RLP编码，然后调用WriteBodyRLP将区块体的RLP编码写到数据库中。WriteBodyRLP根据上面的规则组装key，然后向数据库中写入一条记录。 还有一个WriteBlock函数分别调用WriteBody和WriteHeader将区块写到数据库中。此外还有GetHeader&nbsp;GetBody&nbsp;GetBlock函数用于从数据库中读取区块。 2 这是一个交易的结构体&nbsp; Core/types/transaction.go 1ContractTransaction的区别在于：Recipient == nil ； &nbsp;2. Transaction能以RLP算法进行Encode和Decode； 3. hash/size/from字段是cache之用，避免多次 hash/sign导致性能损失； 交易存储 除了区块外，数据库中还存储了所有的交易，每条交易的存储格式如下： txHash -&gt; rlpEncode(tx) txHash + txMetaSuffix -&gt; rlpEncode(txMeta) 每条交易对应存储两条数据，一条是交易本身，一条是交易的元信息（meta）。交易以交易的hash为key、交易的RLP编码为value存储；元信息以txHash+txMetaSuffix为key、元信息的RLP编码为value存储。元信息中包含交易所在区块的区块hash、区块号、交易在区块中的索引。具体可以看WriteTransactions函数： // WriteTransactions stores the transactionsassociated with a specific block // into the given database. Beside writing thetransaction, the function also // stores a metadata entry along with thetransaction, detailing the position // of this within the blockchain. funcWriteTransactions(db ethdb.Database,block *types.Block) error { &nbsp;&nbsp;&nbsp; batch:= db.NewBatch() &nbsp; &nbsp;&nbsp;&nbsp; // Iterate over each transaction and encode it with its metadata &nbsp;&nbsp;&nbsp; for i, tx := range block.Transactions() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err := rlp.EncodeToBytes(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(tx.Hash().Bytes(), data); err!= nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction metadata for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta := struct { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash&nbsp; common.Hash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash:&nbsp; block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64(i), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err = rlp.EncodeToBytes(meta) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(append(tx.Hash().Bytes(), txMetaSuffix...), data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; // Write the scheduled data into the database &nbsp;&nbsp;&nbsp; if err := batch.Write(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store transactionsinto database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; returnnil } 此外还有GetTransaction函数，根据交易hash从数据库中读取交易，它返回对应的交易、交易所在区块的区块hash、交易所在区块的区块号、交易在区块中的索引。 3Receiptroot我们刚刚在区块头有看到，那他具体包含的是什么呢？它是一个交易的结果，主要包括了poststate,交易所花费的gas,bloom和logs 4 一个个交易被打包到区块上面，那区块又是怎么变成区块链的呢？&nbsp; Core/blockchain.go 注意：1. BlockChain无结构化查询需求，仅Hash查询， Key/Value数据库最方便； 2. 低层用LevelDB存储，性能好 5 stateDB用来存储世界状态&nbsp; Core/state/statedb.go &nbsp; &nbsp; &nbsp; &nbsp; 那我们接下来看看stateObject结构体&nbsp; Core/state/state_object.go &nbsp; 注意：1.StateDB完整记录Transaction的执行情况； &nbsp;2. StateDB的重点是StateObjects； 3. StateDB中的stateObjects，Account的Address为 key，记录其Balance、nonce、code、codeHash ，以及tire中的 {string:Hash}等信息； &nbsp; &nbsp; &nbsp; 6所有的结构凑明朗了，那具体的验证过程是怎么样的呢&nbsp; Core/state_processor.go&nbsp; Core/state_transition.go&nbsp; Core/block_validator.go StateProcessor 1. 调用StateTransition，验证（执行）Transaction； 2. 计算Gas、Recipt、Uncle Reward StateTransition&nbsp; 1. 验证（执行）Transaction；&nbsp; 3. 扣除transaction.data.payload计算数据所需要消耗的gas；&nbsp; 4. 在vm中执行code（生成contract or 执行contract）；vm执行过程中，其gas会被自动消耗。如果gas不足，vm会自选退出；&nbsp; 5. 将多余的gas退回到sender.balance中；&nbsp; 6. 将消耗的gas换成balance加到当前env.Coinbase()中； &nbsp; &nbsp; BlockValidator&nbsp; 1. 验证UsedGas&nbsp; 2. 验证Bloom&nbsp; 3. 验证receiptSha&nbsp; 4. 验证stateDB.IntermediateRoot &nbsp; 7&nbsp;&nbsp;可以注意到刚才的state和block都是写进db数据库的，那我们看一下leveldb数据库结构。Ethdb/dabase.go &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="Ethereum数据存储分析 第一部分看看geth客户端的整体结构&nbsp;创建私链的时候已经指定创世块genesis.json都放在private-geth目录下，现在是已经挖矿过的目录。 Current里面的内容是MANIFEST-000007 ~ &nbsp; 进入真正的存放数据的目录private-geth/data/00&nbsp; geth中保存的是区块链的相关数据&nbsp; keystore中保存的是该链条中的用户信息 History记录历史信息 之前我们这个节点已经创建了两个账户，现在我们可以看到keystore里面有两个账户信息的文件 每个账户都由一对钥匙定义，一个私钥和一个公钥。账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20个字节。每对私钥 /地址都编码在一个钥匙文件里。钥匙文件是JSON文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分，账户私钥，通常用你创建帐户时设置的密码进行加密。钥匙文件的文件名格式为UTC。账号列出时是按字母顺序排列，但是由于时间戳格式，实际上它是按创建顺序排列。如果把秘钥丢了钥匙文件可以在以太坊节点数据目录的keystore子目录下找到，接下来我们进入一个keystore目录文件看看他的信息： &nbsp; 警告：记住密码并”备份钥匙文件”。为了从账号发送交易，包括发送以太币，你必须同时有钥匙文件和密码。确保钥匙文件有个备份并牢记密码，尽可能安全地存储它们。这里没有逃亡路径，如果钥匙文件丢失或忘记密码，就会丢失所有的以太币。没有密码不可能进入账号，也没有忘记密码选项。所以一定不要忘记密码。 接下来进入geth可以看到chaindata，lightchaindata，nodes目录 进入nodes（我们这条私链有三个节点，所以这里有三个ldb文件） 进入chaindata，区块链最后的本地存储都是以ldb文件 Lightchaindata是一个轻客户端的模式，该模式无需下载较大的以太坊区块链，免去了繁琐的流程 第二部分看看源码的结构 1 Core/types/block.Go&nbsp;首先看到的是一个区块的结构 区块主要分为区块体和区块头，下面是去块体的结构，主要是交易列表和叔块列表 &nbsp; &nbsp; 这是区块头的结构体 我们知道了一个区块的结构，那它是怎么存储的呢 区块和交易等数据最终都是存储在leveldb数据库中的，数据库的存储位置在datadir/geth/chaindata中，在core/database_util.go中封装了所有与区块存储和读取相关的代码，通过这些代码可以弄清楚区块、交易等数据结构在数据库中是如何存储的。 leveldb是一个key-value数据库，所有数据都是以键-值对的形式存储。key一般与hash相关，value一般是要存储的数据结构的RLP编码。区块存储时将区块头和区块体分开存储。 区块头的存储格式为： headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) 其中key由区块头前缀、区块号（uint64大端格式）、区块hash构成，value是区块头的RLP编码。 区块体的存储格式为： bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) 其中key由区块体前缀、区块号（uint64大端格式）、区块hash构成，value是区块体的RLP编码。 key中的前缀可以用来区分数据的类型，在core/database_util.go中定义了各种前缀： headerPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;h&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash -&gt; header tdSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;t&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td numSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;n&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash blockHashPrefix&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;H&quot;)&nbsp;&nbsp; //blockHashPrefix + hash -&gt; num (uint64 big endian) bodyPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;b&quot;)&nbsp;&nbsp; //bodyPrefix + num (uint64 big endian) + hash -&gt; block body 其中headerPrefix定义了区块头key的前缀为h，bodyPrefix定义了区块体key的前缀为b。 下面是存储区块头的函数： // WriteHeader serializes a block header into thedatabase. funcWriteHeader(db ethdb.Database, header*types.Header) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(header) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; hash :=header.Hash().Bytes() &nbsp;&nbsp;&nbsp; num :=header.Number.Uint64() &nbsp;&nbsp;&nbsp; encNum:= encodeBlockNumber(num) &nbsp;&nbsp;&nbsp; key := append(blockHashPrefix, hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store hash to numbermapping into database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store header intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored header#%v [%x…]&quot;, header.Number, hash[:4]) &nbsp;&nbsp;&nbsp; returnnil } 它是先对区块头进行RLP编码，encodeBlockNumber将区块号转换成大端格式，然后组装key。这里先向数据库中存储一条&nbsp;区块hash-&gt;区块号&nbsp;的记录，最后将区块头的RLP编码写到数据库中。 下面是存储区块体的函数： // WriteBody serializes the body of a block intothe database. funcWriteBody(db ethdb.Database, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(body) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return WriteBodyRLP(db, hash, number, data) } &nbsp; // WriteBodyRLP writes a serialized body of ablock into the database. funcWriteBodyRLP(db ethdb.Database, hash common.Hash,number uint64, rlp rlp.RawValue)error { &nbsp;&nbsp;&nbsp; key := append(append(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, rlp); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store block body intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored blockbody [%x…]&quot;, hash.Bytes()[:4]) &nbsp;&nbsp;&nbsp; returnnil } WriteBody先对区块体进行RLP编码，然后调用WriteBodyRLP将区块体的RLP编码写到数据库中。WriteBodyRLP根据上面的规则组装key，然后向数据库中写入一条记录。 还有一个WriteBlock函数分别调用WriteBody和WriteHeader将区块写到数据库中。此外还有GetHeader&nbsp;GetBody&nbsp;GetBlock函数用于从数据库中读取区块。 2 这是一个交易的结构体&nbsp; Core/types/transaction.go 1ContractTransaction的区别在于：Recipient == nil ； &nbsp;2. Transaction能以RLP算法进行Encode和Decode； 3. hash/size/from字段是cache之用，避免多次 hash/sign导致性能损失； 交易存储 除了区块外，数据库中还存储了所有的交易，每条交易的存储格式如下： txHash -&gt; rlpEncode(tx) txHash + txMetaSuffix -&gt; rlpEncode(txMeta) 每条交易对应存储两条数据，一条是交易本身，一条是交易的元信息（meta）。交易以交易的hash为key、交易的RLP编码为value存储；元信息以txHash+txMetaSuffix为key、元信息的RLP编码为value存储。元信息中包含交易所在区块的区块hash、区块号、交易在区块中的索引。具体可以看WriteTransactions函数： // WriteTransactions stores the transactionsassociated with a specific block // into the given database. Beside writing thetransaction, the function also // stores a metadata entry along with thetransaction, detailing the position // of this within the blockchain. funcWriteTransactions(db ethdb.Database,block *types.Block) error { &nbsp;&nbsp;&nbsp; batch:= db.NewBatch() &nbsp; &nbsp;&nbsp;&nbsp; // Iterate over each transaction and encode it with its metadata &nbsp;&nbsp;&nbsp; for i, tx := range block.Transactions() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err := rlp.EncodeToBytes(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(tx.Hash().Bytes(), data); err!= nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction metadata for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta := struct { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash&nbsp; common.Hash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash:&nbsp; block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64(i), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err = rlp.EncodeToBytes(meta) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(append(tx.Hash().Bytes(), txMetaSuffix...), data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; // Write the scheduled data into the database &nbsp;&nbsp;&nbsp; if err := batch.Write(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store transactionsinto database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; returnnil } 此外还有GetTransaction函数，根据交易hash从数据库中读取交易，它返回对应的交易、交易所在区块的区块hash、交易所在区块的区块号、交易在区块中的索引。 3Receiptroot我们刚刚在区块头有看到，那他具体包含的是什么呢？它是一个交易的结果，主要包括了poststate,交易所花费的gas,bloom和logs 4 一个个交易被打包到区块上面，那区块又是怎么变成区块链的呢？&nbsp; Core/blockchain.go 注意：1. BlockChain无结构化查询需求，仅Hash查询， Key/Value数据库最方便； 2. 低层用LevelDB存储，性能好 5 stateDB用来存储世界状态&nbsp; Core/state/statedb.go &nbsp; &nbsp; &nbsp; &nbsp; 那我们接下来看看stateObject结构体&nbsp; Core/state/state_object.go &nbsp; 注意：1.StateDB完整记录Transaction的执行情况； &nbsp;2. StateDB的重点是StateObjects； 3. StateDB中的stateObjects，Account的Address为 key，记录其Balance、nonce、code、codeHash ，以及tire中的 {string:Hash}等信息； &nbsp; &nbsp; &nbsp; 6所有的结构凑明朗了，那具体的验证过程是怎么样的呢&nbsp; Core/state_processor.go&nbsp; Core/state_transition.go&nbsp; Core/block_validator.go StateProcessor 1. 调用StateTransition，验证（执行）Transaction； 2. 计算Gas、Recipt、Uncle Reward StateTransition&nbsp; 1. 验证（执行）Transaction；&nbsp; 3. 扣除transaction.data.payload计算数据所需要消耗的gas；&nbsp; 4. 在vm中执行code（生成contract or 执行contract）；vm执行过程中，其gas会被自动消耗。如果gas不足，vm会自选退出；&nbsp; 5. 将多余的gas退回到sender.balance中；&nbsp; 6. 将消耗的gas换成balance加到当前env.Coinbase()中； &nbsp; &nbsp; BlockValidator&nbsp; 1. 验证UsedGas&nbsp; 2. 验证Bloom&nbsp; 3. 验证receiptSha&nbsp; 4. 验证stateDB.IntermediateRoot &nbsp; 7&nbsp;&nbsp;可以注意到刚才的state和block都是写进db数据库的，那我们看一下leveldb数据库结构。Ethdb/dabase.go &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-23T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Ethereum数据存储分析 第一部分看看geth客户端的整体结构&nbsp;创建私链的时候已经指定创世块genesis.json都放在private-geth目录下，现在是已经挖矿过的目录。 Current里面的内容是MANIFEST-000007 ~ &nbsp; 进入真正的存放数据的目录private-geth/data/00&nbsp; geth中保存的是区块链的相关数据&nbsp; keystore中保存的是该链条中的用户信息 History记录历史信息 之前我们这个节点已经创建了两个账户，现在我们可以看到keystore里面有两个账户信息的文件 每个账户都由一对钥匙定义，一个私钥和一个公钥。账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20个字节。每对私钥 /地址都编码在一个钥匙文件里。钥匙文件是JSON文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分，账户私钥，通常用你创建帐户时设置的密码进行加密。钥匙文件的文件名格式为UTC。账号列出时是按字母顺序排列，但是由于时间戳格式，实际上它是按创建顺序排列。如果把秘钥丢了钥匙文件可以在以太坊节点数据目录的keystore子目录下找到，接下来我们进入一个keystore目录文件看看他的信息： &nbsp; 警告：记住密码并”备份钥匙文件”。为了从账号发送交易，包括发送以太币，你必须同时有钥匙文件和密码。确保钥匙文件有个备份并牢记密码，尽可能安全地存储它们。这里没有逃亡路径，如果钥匙文件丢失或忘记密码，就会丢失所有的以太币。没有密码不可能进入账号，也没有忘记密码选项。所以一定不要忘记密码。 接下来进入geth可以看到chaindata，lightchaindata，nodes目录 进入nodes（我们这条私链有三个节点，所以这里有三个ldb文件） 进入chaindata，区块链最后的本地存储都是以ldb文件 Lightchaindata是一个轻客户端的模式，该模式无需下载较大的以太坊区块链，免去了繁琐的流程 第二部分看看源码的结构 1 Core/types/block.Go&nbsp;首先看到的是一个区块的结构 区块主要分为区块体和区块头，下面是去块体的结构，主要是交易列表和叔块列表 &nbsp; &nbsp; 这是区块头的结构体 我们知道了一个区块的结构，那它是怎么存储的呢 区块和交易等数据最终都是存储在leveldb数据库中的，数据库的存储位置在datadir/geth/chaindata中，在core/database_util.go中封装了所有与区块存储和读取相关的代码，通过这些代码可以弄清楚区块、交易等数据结构在数据库中是如何存储的。 leveldb是一个key-value数据库，所有数据都是以键-值对的形式存储。key一般与hash相关，value一般是要存储的数据结构的RLP编码。区块存储时将区块头和区块体分开存储。 区块头的存储格式为： headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) 其中key由区块头前缀、区块号（uint64大端格式）、区块hash构成，value是区块头的RLP编码。 区块体的存储格式为： bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) 其中key由区块体前缀、区块号（uint64大端格式）、区块hash构成，value是区块体的RLP编码。 key中的前缀可以用来区分数据的类型，在core/database_util.go中定义了各种前缀： headerPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;h&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash -&gt; header tdSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;t&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td numSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;n&quot;)&nbsp;&nbsp; //headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash blockHashPrefix&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;H&quot;)&nbsp;&nbsp; //blockHashPrefix + hash -&gt; num (uint64 big endian) bodyPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []byte(&quot;b&quot;)&nbsp;&nbsp; //bodyPrefix + num (uint64 big endian) + hash -&gt; block body 其中headerPrefix定义了区块头key的前缀为h，bodyPrefix定义了区块体key的前缀为b。 下面是存储区块头的函数： // WriteHeader serializes a block header into thedatabase. funcWriteHeader(db ethdb.Database, header*types.Header) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(header) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; hash :=header.Hash().Bytes() &nbsp;&nbsp;&nbsp; num :=header.Number.Uint64() &nbsp;&nbsp;&nbsp; encNum:= encodeBlockNumber(num) &nbsp;&nbsp;&nbsp; key := append(blockHashPrefix, hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store hash to numbermapping into database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store header intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored header#%v [%x…]&quot;, header.Number, hash[:4]) &nbsp;&nbsp;&nbsp; returnnil } 它是先对区块头进行RLP编码，encodeBlockNumber将区块号转换成大端格式，然后组装key。这里先向数据库中存储一条&nbsp;区块hash-&gt;区块号&nbsp;的记录，最后将区块头的RLP编码写到数据库中。 下面是存储区块体的函数： // WriteBody serializes the body of a block intothe database. funcWriteBody(db ethdb.Database, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(body) &nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return WriteBodyRLP(db, hash, number, data) } &nbsp; // WriteBodyRLP writes a serialized body of ablock into the database. funcWriteBodyRLP(db ethdb.Database, hash common.Hash,number uint64, rlp rlp.RawValue)error { &nbsp;&nbsp;&nbsp; key := append(append(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...) &nbsp;&nbsp;&nbsp; if err := db.Put(key, rlp); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store block body intodatabase: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(&quot;stored blockbody [%x…]&quot;, hash.Bytes()[:4]) &nbsp;&nbsp;&nbsp; returnnil } WriteBody先对区块体进行RLP编码，然后调用WriteBodyRLP将区块体的RLP编码写到数据库中。WriteBodyRLP根据上面的规则组装key，然后向数据库中写入一条记录。 还有一个WriteBlock函数分别调用WriteBody和WriteHeader将区块写到数据库中。此外还有GetHeader&nbsp;GetBody&nbsp;GetBlock函数用于从数据库中读取区块。 2 这是一个交易的结构体&nbsp; Core/types/transaction.go 1ContractTransaction的区别在于：Recipient == nil ； &nbsp;2. Transaction能以RLP算法进行Encode和Decode； 3. hash/size/from字段是cache之用，避免多次 hash/sign导致性能损失； 交易存储 除了区块外，数据库中还存储了所有的交易，每条交易的存储格式如下： txHash -&gt; rlpEncode(tx) txHash + txMetaSuffix -&gt; rlpEncode(txMeta) 每条交易对应存储两条数据，一条是交易本身，一条是交易的元信息（meta）。交易以交易的hash为key、交易的RLP编码为value存储；元信息以txHash+txMetaSuffix为key、元信息的RLP编码为value存储。元信息中包含交易所在区块的区块hash、区块号、交易在区块中的索引。具体可以看WriteTransactions函数： // WriteTransactions stores the transactionsassociated with a specific block // into the given database. Beside writing thetransaction, the function also // stores a metadata entry along with thetransaction, detailing the position // of this within the blockchain. funcWriteTransactions(db ethdb.Database,block *types.Block) error { &nbsp;&nbsp;&nbsp; batch:= db.NewBatch() &nbsp; &nbsp;&nbsp;&nbsp; // Iterate over each transaction and encode it with its metadata &nbsp;&nbsp;&nbsp; for i, tx := range block.Transactions() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err := rlp.EncodeToBytes(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(tx.Hash().Bytes(), data); err!= nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Encode and queue up the transaction metadata for storage &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta := struct { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash&nbsp; common.Hash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash:&nbsp; block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64(i), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err = rlp.EncodeToBytes(meta) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err := batch.Put(append(tx.Hash().Bytes(), txMetaSuffix...), data); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; // Write the scheduled data into the database &nbsp;&nbsp;&nbsp; if err := batch.Write(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(&quot;failed to store transactionsinto database: %v&quot;, err) &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; returnnil } 此外还有GetTransaction函数，根据交易hash从数据库中读取交易，它返回对应的交易、交易所在区块的区块hash、交易所在区块的区块号、交易在区块中的索引。 3Receiptroot我们刚刚在区块头有看到，那他具体包含的是什么呢？它是一个交易的结果，主要包括了poststate,交易所花费的gas,bloom和logs 4 一个个交易被打包到区块上面，那区块又是怎么变成区块链的呢？&nbsp; Core/blockchain.go 注意：1. BlockChain无结构化查询需求，仅Hash查询， Key/Value数据库最方便； 2. 低层用LevelDB存储，性能好 5 stateDB用来存储世界状态&nbsp; Core/state/statedb.go &nbsp; &nbsp; &nbsp; &nbsp; 那我们接下来看看stateObject结构体&nbsp; Core/state/state_object.go &nbsp; 注意：1.StateDB完整记录Transaction的执行情况； &nbsp;2. StateDB的重点是StateObjects； 3. StateDB中的stateObjects，Account的Address为 key，记录其Balance、nonce、code、codeHash ，以及tire中的 {string:Hash}等信息； &nbsp; &nbsp; &nbsp; 6所有的结构凑明朗了，那具体的验证过程是怎么样的呢&nbsp; Core/state_processor.go&nbsp; Core/state_transition.go&nbsp; Core/block_validator.go StateProcessor 1. 调用StateTransition，验证（执行）Transaction； 2. 计算Gas、Recipt、Uncle Reward StateTransition&nbsp; 1. 验证（执行）Transaction；&nbsp; 3. 扣除transaction.data.payload计算数据所需要消耗的gas；&nbsp; 4. 在vm中执行code（生成contract or 执行contract）；vm执行过程中，其gas会被自动消耗。如果gas不足，vm会自选退出；&nbsp; 5. 将多余的gas退回到sender.balance中；&nbsp; 6. 将消耗的gas换成balance加到当前env.Coinbase()中； &nbsp; &nbsp; BlockValidator&nbsp; 1. 验证UsedGas&nbsp; 2. 验证Bloom&nbsp; 3. 验证receiptSha&nbsp; 4. 验证stateDB.IntermediateRoot &nbsp; 7&nbsp;&nbsp;可以注意到刚才的state和block都是写进db数据库的，那我们看一下leveldb数据库结构。Ethdb/dabase.go &nbsp; &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"/2017/08/23/806f9bc2d46e44172167344342b80106.html","headline":"Ethereum数据存储分析","dateModified":"2017-08-23T00:00:00+08:00","datePublished":"2017-08-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/08/23/806f9bc2d46e44172167344342b80106.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Ethereum数据存储分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>Ethereum数据存储分析</strong></p> 
  <p align="left"><strong><span style="color:#3F3F3F;">第一部分</span><span style="color:#3F3F3F;">看看</span><span style="color:#3F3F3F;">geth</span><span style="color:#3F3F3F;">客户端的整体结构</span></strong><span style="color:#3F3F3F;">&nbsp;<br></span><span style="color:#3F3F3F;">创建私链的时候已经指定创世块</span><span style="color:#3F3F3F;">genesis.json</span><span style="color:#3F3F3F;">都放在</span><span style="color:#3F3F3F;">private-geth</span><span style="color:#3F3F3F;">目录下，现在是已经挖矿过的目录。</span></p> 
  <p align="left"><img src="" alt=""></p> 
  <p align="left"><span style="color:#3F3F3F;">Current</span><span style="color:#3F3F3F;">里面的内容是</span><span style="color:#3F3F3F;">MANIFEST-000007</span></p> 
  <p align="left"><span style="color:#3F3F3F;">~<img src="" alt=""></span></p> 
  <p align="left"><span style="color:#3F3F3F;">&nbsp;</span></p> 
  <p></p> 
  <p><span style="color:rgb(63,63,63);">进入真正的存放数据的目录</span><span style="color:rgb(63,63,63);">private-geth/data/00&nbsp;</span><span style="color:#3F3F3F;"><br> geth</span><span style="color:rgb(63,63,63);">中保存的是</span><a href="http://lib.csdn.net/base/blockchain" rel="nofollow" title="区块链知识库"><strong><span style="color:rgb(223,52,52);">区块链</span></strong></a><span style="color:rgb(63,63,63);">的相关数据</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> keystore</span><span style="color:rgb(63,63,63);">中保存的是该链条中的用户信息</span></p> 
  <p><span style="color:rgb(63,63,63);">History</span><span style="color:rgb(63,63,63);">记录历史信息</span></p> 
  <p><img src="" alt=""></p> 
  <p><span style="color:rgb(63,63,63);">之前我们这个节点已经创建了两个账户，现在我们可以看到</span><span style="color:rgb(63,63,63);">keystore</span><span style="color:rgb(63,63,63);">里面有两个账户信息的文件</span></p> 
  <p><img src="" alt=""></p> 
  <p><span style="color:rgb(63,63,63);">每个账户都由一对钥匙定义，一个私钥和一个公钥。</span><span style="color:rgb(63,63,63);">账户以地址为索引，地址由公钥衍生而来，取公钥的最后</span><span style="color:rgb(63,63,63);"> 20</span><span style="color:rgb(63,63,63);">个字节。每对私钥</span><span style="color:rgb(63,63,63);"> /</span><span style="color:rgb(63,63,63);">地址都编码在一个钥匙文件里。钥匙文件是</span><span style="color:rgb(63,63,63);">JSON</span><span style="color:rgb(63,63,63);">文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分，账户私钥，通常用你创建帐户时设置的密码进行加密。钥匙文件的文件名格式为</span><span style="color:rgb(63,63,63);">UTC</span><span style="color:rgb(63,63,63);">。账号列出时是按字母顺序排列，但是由于时间戳格式，实际上它是按创建顺序排列。如果把秘钥丢了钥匙文件可以在以太坊节点数据目录的</span><span style="color:rgb(63,63,63);">keystore</span><span style="color:rgb(63,63,63);">子目录下找到，接下来我们进入一个</span><span style="color:rgb(63,63,63);">keystore</span><span style="color:rgb(63,63,63);">目录文件看看他的信息：</span></p> 
  <p></p> 
  <p>&nbsp;<img src="" alt=""></p> 
  <p><span style="color:#3F3F3F;">警告：记住密码并</span><span style="color:#3F3F3F;">”</span><span style="color:#3F3F3F;">备份钥匙文件</span><span style="color:#3F3F3F;">”</span><span style="color:#3F3F3F;">。为了从账号发送交易，包括发送以太币，你必须同时有钥匙文件和密码。确保钥匙文件有个备份并牢记密码，尽可能安全地存储它们。这里没有逃亡路径，如果钥匙文件丢失或忘记密码，就会丢失所有的以太币。没有密码不可能进入账号，也没有忘记密码选项。所以一定不要忘记密码。</span></p> 
  <p><span style="color:#3F3F3F;">接下来进入</span><span style="color:#3F3F3F;">geth</span><span style="color:#3F3F3F;">可以看到</span><span style="color:#3F3F3F;">chaindata</span><span style="color:#3F3F3F;">，</span><span style="color:#3F3F3F;">lightchaindata</span><span style="color:#3F3F3F;">，</span><span style="color:#3F3F3F;">nodes</span><span style="color:#3F3F3F;">目录</span></p> 
  <p><img src="" alt=""></p> 
  <p><span style="color:rgb(63,63,63);">进入</span><span style="color:rgb(63,63,63);">nodes</span><span style="color:rgb(63,63,63);">（我们这条私链有三个节点，所以这里有三个</span><span style="color:rgb(63,63,63);">ldb</span><span style="color:rgb(63,63,63);">文件）</span></p> 
  <p><img src="" alt=""></p> 
  <p><span style="color:rgb(63,63,63);">进入</span><span style="color:rgb(63,63,63);">chaindata</span><span style="color:rgb(63,63,63);">，区块链最后的本地存储都是以</span><span style="color:rgb(63,63,63);">ldb</span><span style="color:rgb(63,63,63);">文件</span></p> 
  <p><img src="" alt=""></p> 
  <p align="left"><a name="OLE_LINK4"></a><a name="OLE_LINK3"><span style="color:#3F3F3F;">Lightchaindata</span></a><span style="color:#3F3F3F;">是一个轻客户端的模式，该模式无需下载较大的以太坊区块链，免去了繁琐的流程</span></p> 
  <p><img src="" alt=""></p> 
  <p><br></p> 
  <p><br></p> 
  <p><strong><span style="color:#3F3F3F;">第二部分</span><span style="color:#3F3F3F;">看看源码的结构</span></strong></p> 
  <p><span style="color:#3F3F3F;">1 Core/types/block.</span><a href="http://lib.csdn.net/base/go" rel="nofollow" title="Go知识库"><strong><span style="color:#DF3434;">Go</span></strong></a><span style="color:#3F3F3F;">&nbsp;<br></span><span style="color:#3F3F3F;">首先看到的是一个</span><strong><span style="color:#FF0000;">区块的结构</span></strong></p> 
  <p><img src="" alt=""></p> 
  <p>区块主要分为区块体和区块头，下面是去块体的结构，主要是交易列表和叔块列表</p> 
  <p></p> 
  <p>&nbsp;<img src="" alt=""></p> 
  <p>&nbsp;</p> 
  <p>这是区块头的结构体</p> 
  <p><img src="" alt=""></p> 
  <p align="left"><span style="color:#3F3F3F;">我们知道了一个区块的结构，那它是怎么存储的呢</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3F3F3F;">区块和交易等数据最终都是存储在</span><span style="color:#3F3F3F;">leveldb</span><span style="color:#3F3F3F;">数据库中的，数据库的存储位置在</span><span style="color:#3F3F3F;">datadir/geth/chaindata</span><span style="color:#3F3F3F;">中，在</span><span style="color:#3F3F3F;">core/database_util.go</span><span style="color:#3F3F3F;">中封装了所有与区块存储和读取相关的代码，通过这些代码可以弄清楚区块、交易等数据结构在数据库中是如何存储的。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3F3F3F;">leveldb</span><span style="color:#3F3F3F;">是一个</span><span style="color:#3F3F3F;">key-value</span><span style="color:#3F3F3F;">数据库，所有数据都是以键</span><span style="color:#3F3F3F;">-</span><span style="color:#3F3F3F;">值对的形式存储。</span><span style="color:#3F3F3F;">key</span><span style="color:#3F3F3F;">一般与</span><span style="color:#3F3F3F;">hash</span><span style="color:#3F3F3F;">相关，</span><span style="color:#3F3F3F;">value</span><span style="color:#3F3F3F;">一般是要存储的数据结构的</span><a href="https://my.oschina.net/u/2349981/blog/894117" rel="nofollow"><span style="color:rgb(63,63,63);">RLP</span><span style="color:rgb(63,63,63);">编码</span></a><span style="color:#3F3F3F;">。区块存储时将区块头和区块体分开存储。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><strong><span style="color:#3D464D;">区块头的存储格式为：</span></strong></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>headerPrefix + num (</span><span style="color:rgb(239,239,143);">uint64</span><span> big endian) + hash -&gt; rlpEncode(</span><span style="color:rgb(239,239,143);">header</span><span>)</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">其中</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">由区块头前缀、区块号（</span><span style="color:#3D464D;">uint64</span><span style="color:#3D464D;">大端格式）、区块</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">构成，</span><span style="color:#3D464D;">value</span><span style="color:#3D464D;">是区块头的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><strong><span style="color:#3D464D;">区块体的存储格式为：</span></strong></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>bodyPrefix + num (</span><span style="color:rgb(239,239,143);">uint64</span><span> big endian) + hash -&gt; rlpEncode(</span><span style="color:rgb(239,239,143);">block</span><span> body)</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">其中</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">由区块体前缀、区块号（</span><span style="color:#3D464D;">uint64</span><span style="color:#3D464D;">大端格式）、区块</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">构成，</span><span style="color:#3D464D;">value</span><span style="color:#3D464D;">是区块体的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">key</span><span style="color:#3D464D;">中的前缀可以用来区分数据的类型，在</span><span style="color:#3D464D;">core/database_util.go</span><span style="color:#3D464D;">中定义了各种前缀：</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>headerPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []</span><span style="color:rgb(227,206,171);">byte</span><span>(</span><span style="color:rgb(204,147,147);">"h"</span><span>)&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">//headerPrefix + num (uint64 big endian) + hash -&gt; header</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>tdSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []</span><span style="color:rgb(227,206,171);">byte</span><span>(</span><span style="color:rgb(204,147,147);">"t"</span><span>)&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">//headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>numSuffix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []</span><span style="color:rgb(227,206,171);">byte</span><span>(</span><span style="color:rgb(204,147,147);">"n"</span><span>)&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">//headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>blockHashPrefix&nbsp;&nbsp;&nbsp;&nbsp; = []</span><span style="color:rgb(227,206,171);">byte</span><span>(</span><span style="color:rgb(204,147,147);">"H"</span><span>)&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">//blockHashPrefix + hash -&gt; num (uint64 big endian)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>bodyPrefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = []</span><span style="color:rgb(227,206,171);">byte</span><span>(</span><span style="color:rgb(204,147,147);">"b"</span><span>)&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">//bodyPrefix + num (uint64 big endian) + hash -&gt; block body</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">其中</span><span style="color:#3D464D;">headerPrefix</span><span style="color:#3D464D;">定义了区块头</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">的前缀为</span><span style="color:#3D464D;">h</span><span style="color:#3D464D;">，</span><span style="color:#3D464D;">bodyPrefix</span><span style="color:#3D464D;">定义了区块体</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">的前缀为</span><span style="color:#3D464D;">b</span><span style="color:#3D464D;">。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">下面是存储区块头的函数：</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// WriteHeader serializes a block header into thedatabase.</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(227,206,171);">func</span><span style="color:rgb(239,239,143);">WriteHeader</span><span>(db ethdb.Database, header*types.Header) </span><span style="color:rgb(239,239,143);">error</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(header)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; hash :=header.Hash().Bytes()</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; num :=header.Number.Uint64()</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; encNum:= encodeBlockNumber(num)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; key := </span><span style="color:rgb(204,147,147);">append</span><span>(blockHashPrefix, hash...)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := db.Put(key, encNum); err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(</span><span style="color:rgb(204,147,147);">"failed to store hash to numbermapping into database: %v"</span><span>, err)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; key = </span><span style="color:rgb(204,147,147);">append</span><span>(</span><span style="color:rgb(204,147,147);">append</span><span>(headerPrefix, encNum...), hash...)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := db.Put(key, data); err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(</span><span style="color:rgb(204,147,147);">"failed to store header intodatabase: %v"</span><span>, err)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(</span><span style="color:rgb(204,147,147);">"stored header#%v [%x…]"</span><span>, header.Number, hash[:</span><span style="color:rgb(140,208,211);">4</span><span>])</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span style="color:rgb(239,239,175);">nil</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>}</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">它是先对区块头进行</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码，</span><span style="color:#3D464D;">encodeBlockNumber</span><span style="color:#3D464D;">将区块号转换成大端格式，然后组装</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">。这里先向数据库中存储一条</span><span style="color:#3D464D;">&nbsp;</span><span style="color:#3D464D;">区块hash-&gt;</span>区块号<span style="color:#3D464D;">&nbsp;</span><span style="color:#3D464D;">的记录，最后将区块头的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码写到数据库中。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">下面是存储区块体的函数：</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// WriteBody serializes the body of a block intothe database.</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(227,206,171);">func</span><span style="color:rgb(239,239,143);">WriteBody</span><span>(db ethdb.Database, hash common.Hash, number </span><span style="color:rgb(227,206,171);">uint64</span><span>, body *types.Body) </span><span style="color:rgb(239,239,143);">error</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; data,err := rlp.EncodeToBytes(body)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span> WriteBodyRLP(db, hash, number, data)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>}</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// WriteBodyRLP writes a serialized body of ablock into the database.</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(227,206,171);">func</span><span style="color:rgb(239,239,143);">WriteBodyRLP</span><span>(db ethdb.Database, hash common.Hash,number </span><span style="color:rgb(227,206,171);">uint64</span><span>, rlp rlp.RawValue)</span><span style="color:rgb(239,239,143);">error</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; key := </span><span style="color:rgb(204,147,147);">append</span><span>(</span><span style="color:rgb(204,147,147);">append</span><span>(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := db.Put(key, rlp); err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(</span><span style="color:rgb(204,147,147);">"failed to store block body intodatabase: %v"</span><span>, err)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;glog.V(logger.Debug).Infof(</span><span style="color:rgb(204,147,147);">"stored blockbody [%x…]"</span><span>, hash.Bytes()[:</span><span style="color:rgb(140,208,211);">4</span><span>])</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span style="color:rgb(239,239,175);">nil</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>}</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">WriteBody</span><span style="color:#3D464D;">先对区块体进行</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码，然后调用</span><span style="color:#3D464D;">WriteBodyRLP</span><span style="color:#3D464D;">将区块体的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码写到数据库中。</span><span style="color:#3D464D;">WriteBodyRLP</span><span style="color:#3D464D;">根据上面的规则组装</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">，然后向数据库中写入一条记录。</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">还有一个</span><span style="color:#3D464D;">WriteBlock</span><span style="color:#3D464D;">函数分别调用</span><span style="color:#3D464D;">WriteBody</span><span style="color:#3D464D;">和</span><span style="color:#3D464D;">WriteHeader</span><span style="color:#3D464D;">将区块写到数据库中。此外还有</span><span style="color:#3D464D;">GetHeader</span><span style="color:#3D464D;">&nbsp;</span><span style="color:#3D464D;">GetBody</span><span style="color:#3D464D;">&nbsp;</span><span style="color:#3D464D;">GetBlock</span><span style="color:#3D464D;">函数用于从数据库中读取区块。</span></p> 
  <p align="left"><span style="color:#3F3F3F;">2 </span><span style="color:#3F3F3F;">这是一个</span><strong><span style="color:#FF0000;">交易的结构体</span></strong><span style="color:#3F3F3F;">&nbsp;<br> Core/types/transaction.</span><a href="http://lib.csdn.net/base/go" rel="nofollow" title="Go知识库"><strong><span style="color:rgb(223,52,52);">go</span></strong></a></p> 
  <p align="left"><span style="color:#3D464D;">1ContractTransaction</span><span style="color:#3D464D;">的区别在于：Recipient == nil </span>；</p> 
  <p align="left"><span style="color:#3D464D;">&nbsp;2. Transaction</span><span style="color:#3D464D;">能以RLP</span>算法进行Encode和Decode； </p> 
  <p align="left"><span style="color:#3D464D;">3. hash/size/from</span><span style="color:#3D464D;">字段是cache</span>之用，避免多次 hash/sign导致性能损失；</p> 
  <p align="left"></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">交易存储</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">除了区块外，数据库中还存储了所有的交易，每条交易的存储格式如下：</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>txHash -&gt; rlpEncode(</span><span style="color:rgb(239,239,143);">tx</span><span>)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>txHash + txMetaSuffix -&gt; rlpEncode(</span><span style="color:rgb(239,239,143);">txMeta</span><span>)</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">每条交易对应存储两条数据，一条是交易本身，一条是交易的元信息（</span><span style="color:#3D464D;">meta</span><span style="color:#3D464D;">）。交易以交易的</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">为</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">、交易的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码为</span><span style="color:#3D464D;">value</span><span style="color:#3D464D;">存储；元信息以</span><span style="color:#3D464D;">txHash+txMetaSuffix</span><span style="color:#3D464D;">为</span><span style="color:#3D464D;">key</span><span style="color:#3D464D;">、元信息的</span><span style="color:#3D464D;">RLP</span><span style="color:#3D464D;">编码为</span><span style="color:#3D464D;">value</span><span style="color:#3D464D;">存储。元信息中包含交易所在区块的区块</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">、区块号、交易在区块中的索引。具体可以看</span><span style="color:#3D464D;">WriteTransactions</span><span style="color:#3D464D;">函数：</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// WriteTransactions stores the transactionsassociated with a specific block</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// into the given database. Beside writing thetransaction, the function also</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// stores a metadata entry along with thetransaction, detailing the position</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(127,159,127);">// of this within the blockchain.</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span style="color:rgb(227,206,171);">func</span><span style="color:rgb(239,239,143);">WriteTransactions</span><span>(db ethdb.Database,block *types.Block) </span><span style="color:rgb(239,239,143);">error</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; batch:= db.NewBatch()</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">// Iterate over each transaction and encode it with its metadata</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">for</span><span> i, tx := </span><span style="color:rgb(227,206,171);">range</span><span> block.Transactions() {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">// Encode and queue up the transaction for storage</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err := rlp.EncodeToBytes(tx)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := batch.Put(tx.Hash().Bytes(), data); err!= </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">// Encode and queue up the transaction metadata for storage</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta := </span><span style="color:rgb(227,206,171);">struct</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash&nbsp; common.Hash</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex </span><span style="color:rgb(227,206,171);">uint64</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">uint64</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }{</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockHash:&nbsp; block.Hash(),</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockIndex: block.NumberU64(),</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">uint64</span><span>(i),</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data, err = rlp.EncodeToBytes(meta)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := batch.Put(</span><span style="color:rgb(204,147,147);">append</span><span>(tx.Hash().Bytes(), txMetaSuffix...), data); err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:rgb(227,206,171);">return</span><span> err</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(127,159,127);">// Write the scheduled data into the database</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">if</span><span> err := batch.Write(); err != </span><span style="color:rgb(239,239,175);">nil</span><span> {</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glog.Fatalf(</span><span style="color:rgb(204,147,147);">"failed to store transactionsinto database: %v"</span><span>, err)</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; }</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>&nbsp;&nbsp;&nbsp; </span><span style="color:rgb(227,206,171);">return</span><span style="color:rgb(239,239,175);">nil</span></p> 
  <p align="left" style="background:rgb(63,63,63);"><span>}</span></p> 
  <p align="left" style="background:rgb(248,248,248);"><span style="color:#3D464D;">此外还有</span><span style="color:#3D464D;">GetTransaction</span><span style="color:#3D464D;">函数，根据交易</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">从数据库中读取交易，它返回对应的交易、交易所在区块的区块</span><span style="color:#3D464D;">hash</span><span style="color:#3D464D;">、交易所在区块的区块号、交易在区块中的索引。</span></p> 
  <p align="left"><span style="color:rgb(63,63,63);">3</span><strong><span style="color:#FF0000;">Receiptroot</span></strong><span style="color:rgb(63,63,63);">我们刚刚在区块头有看到，那他具体包含的是什么呢？它是一个交易的结果，主要包括了</span><span style="color:rgb(63,63,63);">poststate,</span><span style="color:rgb(63,63,63);">交易所花费的</span><span style="color:rgb(63,63,63);">gas,bloom</span><span style="color:rgb(63,63,63);">和</span><span style="color:rgb(63,63,63);">logs</span></p> 
  <p align="left"></p> 
  <p align="left"><span style="color:rgb(63,63,63);">4 </span><span style="color:rgb(63,63,63);">一个个交易被打包到区块上面，那区块又是怎么变成</span><strong><span style="color:#FF0000;">区块链</span></strong><span style="color:rgb(63,63,63);">的呢？</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> Core/blockchain.go</span></p> 
  <p></p> 
  <p><span style="color:#3F3F3F;">注意：</span><span style="color:#3F3F3F;">1. BlockChain</span><span style="color:#3F3F3F;">无结构化查询需求，仅</span><span style="color:#3F3F3F;">Hash</span><span style="color:#3F3F3F;">查询，</span><span style="color:#3F3F3F;"> Key/Value</span><a href="http://lib.csdn.net/base/mysql" rel="nofollow" title="MySQL知识库"><strong><span style="color:#DF3434;">数据库</span></strong></a><span style="color:#3F3F3F;">最方便；</span><span style="color:#3F3F3F;"> 2. </span><span style="color:#3F3F3F;">低层用</span><span style="color:#3F3F3F;">LevelDB</span><span style="color:#3F3F3F;">存储，性能好</span></p> 
  <p><span style="color:#3F3F3F;">5 </span><strong><span style="color:#FF0000;">stateDB</span></strong><span style="color:#3F3F3F;">用来存储世界状态</span><span style="color:#3F3F3F;">&nbsp;<br> Core/state/statedb.go</span></p> 
  <p><span style="color:#3F3F3F;">&nbsp;</span></p> 
  <p><span style="color:#3F3F3F;">&nbsp;<img src="" alt=""></span></p> 
  <p>&nbsp;</p> 
  <p></p> 
  <p><span style="color:#3F3F3F;">&nbsp;</span></p> 
  <p><span style="color:rgb(63,63,63);">那我们接下来看看</span><span style="color:rgb(63,63,63);">stateObject</span><span style="color:rgb(63,63,63);">结构体</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> Core/state/state_object.go</span></p> 
  <p><img src="" alt=""></p> 
  <p>&nbsp;</p> 
  <p><span style="color:rgb(63,63,63);">注意：</span><span style="color:rgb(63,63,63);">1.StateDB</span><span style="color:rgb(63,63,63);">完整记录</span><span style="color:rgb(63,63,63);">Transaction</span><span style="color:rgb(63,63,63);">的执行情况；</span></p> 
  <p><span style="color:rgb(63,63,63);">&nbsp;2. StateDB</span><span style="color:rgb(63,63,63);">的重点是</span><span style="color:rgb(63,63,63);">StateObjects</span><span style="color:rgb(63,63,63);">；</span></p> 
  <p><span style="color:rgb(63,63,63);">3. StateDB</span><span style="color:rgb(63,63,63);">中的</span><span style="color:rgb(63,63,63);">stateObjects</span><span style="color:rgb(63,63,63);">，</span><span style="color:rgb(63,63,63);">Account</span><span style="color:rgb(63,63,63);">的</span><span style="color:rgb(63,63,63);">Address</span><span style="color:rgb(63,63,63);">为</span><span style="color:rgb(63,63,63);"> key</span><span style="color:rgb(63,63,63);">，记录其</span><span style="color:rgb(63,63,63);">Balance</span><span style="color:rgb(63,63,63);">、</span><span style="color:rgb(63,63,63);">nonce</span><span style="color:rgb(63,63,63);">、</span><span style="color:rgb(63,63,63);">code</span><span style="color:rgb(63,63,63);">、</span><span style="color:rgb(63,63,63);">codeHash </span><span style="color:rgb(63,63,63);">，以及</span><span style="color:rgb(63,63,63);">tire</span><span style="color:rgb(63,63,63);">中的</span><span style="color:rgb(63,63,63);"> {string:Hash}</span><span style="color:rgb(63,63,63);">等信息；</span></p> 
  <p><span style="color:rgb(63,63,63);">&nbsp;</span></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>6<span style="color:#3F3F3F;">所有的结构凑明朗了，那具体的</span><strong><span style="color:#FF0000;">验证过程</span></strong><span style="color:#3F3F3F;">是怎么样的呢</span><span style="color:#3F3F3F;">&nbsp;<br> Core/state_processor.go&nbsp;<br> Core/state_transition.go&nbsp;<br> Core/block_validator.go</span></p> 
  <p><span style="color:#3F3F3F;">StateProcessor 1. </span><span style="color:#3F3F3F;">调用</span><span style="color:#3F3F3F;">StateTransition</span><span style="color:#3F3F3F;">，验证（执行）</span><span style="color:#3F3F3F;">Transaction</span><span style="color:#3F3F3F;">；</span><span style="color:#3F3F3F;"> 2. </span><span style="color:#3F3F3F;">计算</span><span style="color:#3F3F3F;">Gas</span><span style="color:#3F3F3F;">、</span><span style="color:#3F3F3F;">Recipt</span><span style="color:#3F3F3F;">、</span><span style="color:#3F3F3F;">Uncle Reward</span></p> 
  <p><img src="" alt=""></p> 
  <p><span style="color:rgb(63,63,63);">StateTransition&nbsp;</span><span style="color:#3F3F3F;"><br> 1. </span><span style="color:rgb(63,63,63);">验证（执行）</span><span style="color:rgb(63,63,63);">Transaction</span><span style="color:rgb(63,63,63);">；</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> 3. </span><span style="color:rgb(63,63,63);">扣除</span><span style="color:rgb(63,63,63);">transaction.data.payload</span><span style="color:rgb(63,63,63);">计算数据所需要消耗的</span><span style="color:rgb(63,63,63);">gas</span><span style="color:rgb(63,63,63);">；</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> 4. </span><span style="color:rgb(63,63,63);">在</span><span style="color:rgb(63,63,63);">vm</span><span style="color:rgb(63,63,63);">中执行</span><span style="color:rgb(63,63,63);">code</span><span style="color:rgb(63,63,63);">（生成</span><span style="color:rgb(63,63,63);">contract or </span><span style="color:rgb(63,63,63);">执行</span><span style="color:rgb(63,63,63);">contract</span><span style="color:rgb(63,63,63);">）；</span><span style="color:rgb(63,63,63);">vm</span><span style="color:rgb(63,63,63);">执</span><span style="color:rgb(63,63,63);">行过程中，其</span><span style="color:rgb(63,63,63);">gas</span><span style="color:rgb(63,63,63);">会被自动消耗。如果</span><span style="color:rgb(63,63,63);">gas</span><span style="color:rgb(63,63,63);">不足，</span><span style="color:rgb(63,63,63);">vm</span><span style="color:rgb(63,63,63);">会自</span><span style="color:rgb(63,63,63);">选退出；</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> 5. </span><span style="color:rgb(63,63,63);">将多余的</span><span style="color:rgb(63,63,63);">gas</span><span style="color:rgb(63,63,63);">退回到</span><span style="color:rgb(63,63,63);">sender.balance</span><span style="color:rgb(63,63,63);">中；</span><span style="color:rgb(63,63,63);">&nbsp;</span><span style="color:#3F3F3F;"><br> 6. </span><span style="color:rgb(63,63,63);">将消耗的</span><span style="color:rgb(63,63,63);">gas</span><span style="color:rgb(63,63,63);">换成</span><span style="color:rgb(63,63,63);">balance</span><span style="color:rgb(63,63,63);">加到当前</span><span style="color:rgb(63,63,63);">env.Coinbase()</span><span style="color:rgb(63,63,63);">中；</span></p> 
  <p></p> 
  <p>&nbsp;<img src="" alt=""></p> 
  <p>&nbsp;</p> 
  <p><span style="color:rgb(63,63,63);">BlockValidator&nbsp;</span><span style="color:#3F3F3F;"><br> 1. </span><span style="color:rgb(63,63,63);">验证</span><span style="color:rgb(63,63,63);">UsedGas&nbsp;</span><span style="color:#3F3F3F;"><br> 2. </span><span style="color:rgb(63,63,63);">验证</span><span style="color:rgb(63,63,63);">Bloom&nbsp;</span><span style="color:#3F3F3F;"><br> 3. </span><span style="color:rgb(63,63,63);">验证</span><span style="color:rgb(63,63,63);">receiptSha&nbsp;</span><span style="color:#3F3F3F;"><br> 4. </span><span style="color:rgb(63,63,63);">验证</span><span style="color:rgb(63,63,63);">stateDB.IntermediateRoot</span></p> 
  <p><span style="color:rgb(63,63,63);">&nbsp;<img src="" alt=""></span></p> 
  <p><span style="color:rgb(63,63,63);"><span style="font-size:13.3333px;color:rgb(63,63,63);">7&nbsp;&nbsp;</span><span style="font-size:13.3333px;color:rgb(63,63,63);">可以注意到刚才的</span><span style="font-size:13.3333px;color:rgb(63,63,63);">state</span><span style="font-size:13.3333px;color:rgb(63,63,63);">和</span><span style="font-size:13.3333px;color:rgb(63,63,63);">block</span><span style="font-size:13.3333px;color:rgb(63,63,63);">都是写进</span><span style="font-size:13.3333px;color:rgb(63,63,63);">db</span><span style="font-size:13.3333px;color:rgb(63,63,63);">数据库的，那我们看一下</span><span style="font-size:13.3333px;"><strong><span style="color:#FF0000;">leveldb</span></strong></span><span style="font-size:13.3333px;color:rgb(63,63,63);">数据库结构。</span><span style="font-size:13.3333px;color:rgb(63,63,63);">Ethdb/dabase.go</span><br></span></p> 
  <p><span style="color:rgb(63,63,63);"><img src="" alt=""><br></span></p> 
  <p></p> 
  <p>&nbsp;</p> 
  <p><br></p> 
  <p></p> 
  <p>&nbsp;<img src="" alt=""></p> 
  <p>&nbsp;</p> 
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/DDFFR/article/details/77500513,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/DDFFR/article/details/77500513,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/DDFFR/article/details/77500513,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/DDFFR/article/details/77500513,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
