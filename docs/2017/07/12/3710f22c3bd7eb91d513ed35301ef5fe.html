<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>虚拟币开发专题（自己动手制作山寨币教程） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="虚拟币开发专题（自己动手制作山寨币教程）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/75006233 源代码地址： https://github.com/imharrywu/fastcoin 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论 306888500(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，Linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 如果看完此文您觉得有用，欢迎捐赠博主： 1MMkfgNEw96B83DQq3DFtL9WxcTN7keFPG 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin Git clone https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件 chainparams.cpp [cpp] view plain copy /**&nbsp; &nbsp;* Build the genesis block. Note that the output of the genesis coinbase cannot&nbsp; &nbsp;* be spent as it did not originally exist in the database.&nbsp; &nbsp;* &nbsp; &nbsp;* CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)&nbsp; &nbsp;* &nbsp; CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)&nbsp; &nbsp;* &nbsp; &nbsp; CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)&nbsp; &nbsp;* &nbsp; &nbsp; CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)&nbsp; &nbsp;* &nbsp; vMerkleTree: 4a5e1e&nbsp; &nbsp;*/ &nbsp; &nbsp;&nbsp; // HarryWu, generate genesis block by genesis.py as following: &nbsp; // &nbsp; // localhost genesis # python genesis.py \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-t $(date +%s) \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-a SHA256 \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-v 10000000000 &nbsp; // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 &nbsp; // algorithm: SHA256 &nbsp; // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b &nbsp; // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 &nbsp; // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc &nbsp; // time: 1411650667 &nbsp; // bits: 0x1d00ffff &nbsp; // Searching for genesis hash.. &nbsp; // &nbsp; // nonce: 1456993276 &nbsp; // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 &nbsp; &nbsp;&nbsp; const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; &nbsp; CMutableTransaction txNew; &nbsp; txNew.vin.resize(1); &nbsp; txNew.vout.resize(1); &nbsp; txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); &nbsp; txNew.vout[0].nValue = nGenesisSubsidy * COIN; &nbsp; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; &nbsp; genesis.vtx.push_back(txNew); &nbsp; genesis.hashPrevBlock = 0; &nbsp; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); &nbsp; genesis.nVersion = 1; &nbsp; genesis.nTime &nbsp; &nbsp;= 1411666331; &nbsp; genesis.nBits &nbsp; &nbsp;= 0x1d00ffff; &nbsp; genesis.nNonce &nbsp; = 2056985438; &nbsp; &nbsp;&nbsp; hashGenesisBlock = genesis.GetHash(); &nbsp; assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); &nbsp; assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); &nbsp; （3）修改网络协议魔数 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件 chainparams.cpp [cpp] view plain copy base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; 有一个wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 [cpp] view plain copy /**&nbsp; &nbsp;* Testnet (v3)&nbsp; &nbsp;*/ &nbsp; class CTestNetParams : public CMainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CTestNetParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::TESTNET; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;test&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0xC0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x1d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 19999; &nbsp; [cpp] view plain copy /**&nbsp; &nbsp;* Regression test&nbsp; &nbsp;*/ &nbsp; class CRegTestParams : public CTestNetParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CRegTestParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::REGTEST; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;regtest&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x0b; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0xad; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 29999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; &nbsp; （6）修改种子网络连接参数 源文件 chainparams.cpp [cpp] view plain copy //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); &nbsp; &nbsp;&nbsp; base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; &nbsp;&nbsp; //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); &nbsp; 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， [cpp] view plain copy // &nbsp; // ScanHash scans nonces looking for a hash with at least some zero bits. &nbsp; // The nonce is usually preserved between calls, but periodically or if the &nbsp; // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at &nbsp; // zero. &nbsp; // &nbsp; bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) &nbsp; { &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; //CHash256 hasher; &nbsp; &nbsp; &nbsp; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; //ss &lt;&lt; *pblock; &nbsp; &nbsp; &nbsp; //assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; //hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nNonce++; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the last 4 bytes of the block header (the nonce) to a copy of &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the double-SHA256 state, and compute the result. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *phash = pblock-&gt;ComputePowHash(nNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Return the nonce if the hash has at least some zero bits, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // caller will check if it has enough to reach the target &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (((uint16_t*)phash)[15] == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If nothing found after trying for a while, return -1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xffff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xfff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boost::this_thread::interruption_point(); &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) [cpp] view plain copy fMiningRequiresPeers = !true; // See BitcoinMiner() for details. &nbsp; 挖矿代码： [cpp] view plain copy void static BitcoinMiner(CWallet *pwallet) &nbsp; { &nbsp; &nbsp; &nbsp; LogPrintf(&quot;FastCoinMiner started\n&quot;); &nbsp; &nbsp; &nbsp; SetThreadPriority(THREAD_PRIORITY_LOWEST); &nbsp; &nbsp; &nbsp; RenameThread(&quot;fastcoin-miner&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Each thread has its own key and counter &nbsp; &nbsp; &nbsp; CReserveKey reservekey(pwallet); &nbsp; &nbsp; &nbsp; unsigned int nExtraNonce = 0; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (Params().MiningRequiresPeers()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Busy-wait for the network to come online so we don&#39;t waste time mining &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // on an obsolete chain. In regtest mode we expect to fly solo. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (vNodes.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MilliSleep(1000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Create new block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindexPrev = chainActive.Tip(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pblocktemplate.get()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock *pblock = &amp;pblocktemplate-&gt;block; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\n&quot;, pblock-&gt;vtx.size(), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); &nbsp; 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： [cpp] view plain copy uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const &nbsp; { &nbsp; &nbsp; &nbsp; if (nVersion == 1 || nVersion == 2){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Use SHA256+SHA256 to make PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 3){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Scrypt PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 4){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp;Scrypt+SHA256 PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; }else if (nVersion == 5){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256 hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Abort, unknown block version. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ~(uint256)0; &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h [cpp] view plain copy /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ &nbsp; static const int COINBASE_MATURITY = 14; &nbsp; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h [cpp] view plain copy /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has&nbsp; &nbsp; &nbsp; multiple outputs.&nbsp; &nbsp;*/ &nbsp; class TransactionRecord &nbsp; { &nbsp; public: &nbsp; &nbsp; &nbsp; enum Type &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Other, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generated, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvWithAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvFromOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToSelf &nbsp; &nbsp; &nbsp; }; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; /** Number of confirmation recommended for accepting a transaction */ &nbsp; &nbsp; &nbsp; static const int RecommendedNumConfirmations = 2; &nbsp; （9）修改难度配置 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubsidyHalvingInterval = 210000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nEnforceBlockUpgradeMajority = 750; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRejectBlockOutdatedMajority = 950; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nToCheckBlockUpgradeMajority = 1000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nMinerThreads = 1; // 0 for all available cpus. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetTimespan = 60 * 60; // re-targeting every one hour &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGenesisSubsidy = 100; &nbsp; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。 上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 [cpp] view plain copy CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) &nbsp; { &nbsp; &nbsp; &nbsp; CAmount nSubsidy = Params().GenesisSubsidy() * COIN; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; int halvings = nHeight / Params().SubsidyHalvingInterval(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Force block reward to zero when right shift is undefined. &nbsp; &nbsp; &nbsp; if (halvings &gt;= 64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nFees; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. &nbsp; &nbsp; &nbsp; nSubsidy &gt;&gt;= halvings; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; return nSubsidy + nFees; &nbsp; } &nbsp; 很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. 这里的设置是60分钟（3600秒），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 区块挖掘超时设置，在网络算力足够的情况下，一个节点可以挖矿的时间是有限的，比如这里这是的1分钟（60秒），超过这个时间，要么提交目前已找到的block（nNonce），要放弃自己的挖掘结果（使用网络上其他节点找到的一个最优结果）来寻找下一个block。否则其他节点也已经开始寻找next了，不过这个前提是算力足够，比如btc网络（现在应该到78个0的位置了吧），你如果10分钟内找不到，那么好了，可以放弃了，用别人的block吧，赶紧进入下一个回合的挖掘，否则很可能是浪费时间。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试 P2pool &nbsp;&amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/75006233 源代码地址： https://github.com/imharrywu/fastcoin 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论 306888500(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，Linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 如果看完此文您觉得有用，欢迎捐赠博主： 1MMkfgNEw96B83DQq3DFtL9WxcTN7keFPG 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin Git clone https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件 chainparams.cpp [cpp] view plain copy /**&nbsp; &nbsp;* Build the genesis block. Note that the output of the genesis coinbase cannot&nbsp; &nbsp;* be spent as it did not originally exist in the database.&nbsp; &nbsp;* &nbsp; &nbsp;* CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)&nbsp; &nbsp;* &nbsp; CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)&nbsp; &nbsp;* &nbsp; &nbsp; CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)&nbsp; &nbsp;* &nbsp; &nbsp; CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)&nbsp; &nbsp;* &nbsp; vMerkleTree: 4a5e1e&nbsp; &nbsp;*/ &nbsp; &nbsp;&nbsp; // HarryWu, generate genesis block by genesis.py as following: &nbsp; // &nbsp; // localhost genesis # python genesis.py \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-t $(date +%s) \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-a SHA256 \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-v 10000000000 &nbsp; // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 &nbsp; // algorithm: SHA256 &nbsp; // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b &nbsp; // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 &nbsp; // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc &nbsp; // time: 1411650667 &nbsp; // bits: 0x1d00ffff &nbsp; // Searching for genesis hash.. &nbsp; // &nbsp; // nonce: 1456993276 &nbsp; // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 &nbsp; &nbsp;&nbsp; const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; &nbsp; CMutableTransaction txNew; &nbsp; txNew.vin.resize(1); &nbsp; txNew.vout.resize(1); &nbsp; txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); &nbsp; txNew.vout[0].nValue = nGenesisSubsidy * COIN; &nbsp; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; &nbsp; genesis.vtx.push_back(txNew); &nbsp; genesis.hashPrevBlock = 0; &nbsp; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); &nbsp; genesis.nVersion = 1; &nbsp; genesis.nTime &nbsp; &nbsp;= 1411666331; &nbsp; genesis.nBits &nbsp; &nbsp;= 0x1d00ffff; &nbsp; genesis.nNonce &nbsp; = 2056985438; &nbsp; &nbsp;&nbsp; hashGenesisBlock = genesis.GetHash(); &nbsp; assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); &nbsp; assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); &nbsp; （3）修改网络协议魔数 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件 chainparams.cpp [cpp] view plain copy base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; 有一个wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 [cpp] view plain copy /**&nbsp; &nbsp;* Testnet (v3)&nbsp; &nbsp;*/ &nbsp; class CTestNetParams : public CMainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CTestNetParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::TESTNET; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;test&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0xC0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x1d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 19999; &nbsp; [cpp] view plain copy /**&nbsp; &nbsp;* Regression test&nbsp; &nbsp;*/ &nbsp; class CRegTestParams : public CTestNetParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CRegTestParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::REGTEST; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;regtest&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x0b; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0xad; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 29999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; &nbsp; （6）修改种子网络连接参数 源文件 chainparams.cpp [cpp] view plain copy //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); &nbsp; &nbsp;&nbsp; base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; &nbsp;&nbsp; //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); &nbsp; 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， [cpp] view plain copy // &nbsp; // ScanHash scans nonces looking for a hash with at least some zero bits. &nbsp; // The nonce is usually preserved between calls, but periodically or if the &nbsp; // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at &nbsp; // zero. &nbsp; // &nbsp; bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) &nbsp; { &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; //CHash256 hasher; &nbsp; &nbsp; &nbsp; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; //ss &lt;&lt; *pblock; &nbsp; &nbsp; &nbsp; //assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; //hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nNonce++; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the last 4 bytes of the block header (the nonce) to a copy of &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the double-SHA256 state, and compute the result. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *phash = pblock-&gt;ComputePowHash(nNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Return the nonce if the hash has at least some zero bits, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // caller will check if it has enough to reach the target &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (((uint16_t*)phash)[15] == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If nothing found after trying for a while, return -1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xffff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xfff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boost::this_thread::interruption_point(); &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) [cpp] view plain copy fMiningRequiresPeers = !true; // See BitcoinMiner() for details. &nbsp; 挖矿代码： [cpp] view plain copy void static BitcoinMiner(CWallet *pwallet) &nbsp; { &nbsp; &nbsp; &nbsp; LogPrintf(&quot;FastCoinMiner started\n&quot;); &nbsp; &nbsp; &nbsp; SetThreadPriority(THREAD_PRIORITY_LOWEST); &nbsp; &nbsp; &nbsp; RenameThread(&quot;fastcoin-miner&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Each thread has its own key and counter &nbsp; &nbsp; &nbsp; CReserveKey reservekey(pwallet); &nbsp; &nbsp; &nbsp; unsigned int nExtraNonce = 0; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (Params().MiningRequiresPeers()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Busy-wait for the network to come online so we don&#39;t waste time mining &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // on an obsolete chain. In regtest mode we expect to fly solo. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (vNodes.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MilliSleep(1000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Create new block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindexPrev = chainActive.Tip(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pblocktemplate.get()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock *pblock = &amp;pblocktemplate-&gt;block; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\n&quot;, pblock-&gt;vtx.size(), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); &nbsp; 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： [cpp] view plain copy uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const &nbsp; { &nbsp; &nbsp; &nbsp; if (nVersion == 1 || nVersion == 2){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Use SHA256+SHA256 to make PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 3){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Scrypt PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 4){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp;Scrypt+SHA256 PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; }else if (nVersion == 5){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256 hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Abort, unknown block version. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ~(uint256)0; &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h [cpp] view plain copy /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ &nbsp; static const int COINBASE_MATURITY = 14; &nbsp; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h [cpp] view plain copy /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has&nbsp; &nbsp; &nbsp; multiple outputs.&nbsp; &nbsp;*/ &nbsp; class TransactionRecord &nbsp; { &nbsp; public: &nbsp; &nbsp; &nbsp; enum Type &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Other, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generated, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvWithAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvFromOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToSelf &nbsp; &nbsp; &nbsp; }; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; /** Number of confirmation recommended for accepting a transaction */ &nbsp; &nbsp; &nbsp; static const int RecommendedNumConfirmations = 2; &nbsp; （9）修改难度配置 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubsidyHalvingInterval = 210000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nEnforceBlockUpgradeMajority = 750; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRejectBlockOutdatedMajority = 950; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nToCheckBlockUpgradeMajority = 1000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nMinerThreads = 1; // 0 for all available cpus. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetTimespan = 60 * 60; // re-targeting every one hour &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGenesisSubsidy = 100; &nbsp; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。 上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 [cpp] view plain copy CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) &nbsp; { &nbsp; &nbsp; &nbsp; CAmount nSubsidy = Params().GenesisSubsidy() * COIN; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; int halvings = nHeight / Params().SubsidyHalvingInterval(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Force block reward to zero when right shift is undefined. &nbsp; &nbsp; &nbsp; if (halvings &gt;= 64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nFees; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. &nbsp; &nbsp; &nbsp; nSubsidy &gt;&gt;= halvings; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; return nSubsidy + nFees; &nbsp; } &nbsp; 很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. 这里的设置是60分钟（3600秒），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 区块挖掘超时设置，在网络算力足够的情况下，一个节点可以挖矿的时间是有限的，比如这里这是的1分钟（60秒），超过这个时间，要么提交目前已找到的block（nNonce），要放弃自己的挖掘结果（使用网络上其他节点找到的一个最优结果）来寻找下一个block。否则其他节点也已经开始寻找next了，不过这个前提是算力足够，比如btc网络（现在应该到78个0的位置了吧），你如果10分钟内找不到，那么好了，可以放弃了，用别人的block吧，赶紧进入下一个回合的挖掘，否则很可能是浪费时间。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试 P2pool &nbsp;&amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/75006233 源代码地址： https://github.com/imharrywu/fastcoin 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论 306888500(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。 在线编译目前提供三种安装包： 1，Linux/unix的daemon程序（带钱包功能） 2，Mac钱包安装包&nbsp; 3，windows钱包安装包 如果看完此文您觉得有用，欢迎捐赠博主： 1MMkfgNEw96B83DQq3DFtL9WxcTN7keFPG 1、 &nbsp;截图预览 (1) 安装图1 （2）安装图2 （3）安装图3 （4）安装图4 （5）安装图5 （6）概览图 已经挖到3个block 奖励了300个FTC （7）交易记录图 （8）点击显示交易细节 显示为挖矿所得 并且还没有确认 （9）版权页 （10）调试窗口 （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点 （12）2个节点构成的p2p通信网络 2、 山寨币修改步骤： （1）迁出最新的比特币源代码 比特币官方代码: https://github.com/bitcoin/bitcoin 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin Git clone https://github.com/imharrywu/fastcoin&nbsp; 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。 （2）修改创世块 源文件 chainparams.cpp [cpp] view plain copy /**&nbsp; &nbsp;* Build the genesis block. Note that the output of the genesis coinbase cannot&nbsp; &nbsp;* be spent as it did not originally exist in the database.&nbsp; &nbsp;* &nbsp; &nbsp;* CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)&nbsp; &nbsp;* &nbsp; CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)&nbsp; &nbsp;* &nbsp; &nbsp; CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)&nbsp; &nbsp;* &nbsp; &nbsp; CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)&nbsp; &nbsp;* &nbsp; vMerkleTree: 4a5e1e&nbsp; &nbsp;*/ &nbsp; &nbsp;&nbsp; // HarryWu, generate genesis block by genesis.py as following: &nbsp; // &nbsp; // localhost genesis # python genesis.py \\ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-t $(date +%s) \\ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-z &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot; \\ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-a SHA256 \\ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \\ &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-v 10000000000 &nbsp; // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 &nbsp; // algorithm: SHA256 &nbsp; // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b &nbsp; // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 &nbsp; // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc &nbsp; // time: 1411650667 &nbsp; // bits: 0x1d00ffff &nbsp; // Searching for genesis hash.. &nbsp; // &nbsp; // nonce: 1456993276 &nbsp; // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 &nbsp; &nbsp;&nbsp; const char* pszTimestamp = &quot;shanghai stock index closed at 2343.57, on 24th Sept., 2014&quot;; &nbsp; CMutableTransaction txNew; &nbsp; txNew.vin.resize(1); &nbsp; txNew.vout.resize(1); &nbsp; txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); &nbsp; txNew.vout[0].nValue = nGenesisSubsidy * COIN; &nbsp; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex(&quot;049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc&quot;) &lt;&lt; OP_CHECKSIG; &nbsp; genesis.vtx.push_back(txNew); &nbsp; genesis.hashPrevBlock = 0; &nbsp; genesis.hashMerkleRoot = genesis.BuildMerkleTree(); &nbsp; genesis.nVersion = 1; &nbsp; genesis.nTime &nbsp; &nbsp;= 1411666331; &nbsp; genesis.nBits &nbsp; &nbsp;= 0x1d00ffff; &nbsp; genesis.nNonce &nbsp; = 2056985438; &nbsp; &nbsp;&nbsp; hashGenesisBlock = genesis.GetHash(); &nbsp; assert(hashGenesisBlock == uint256(&quot;0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942&quot;)); &nbsp; assert(genesis.hashMerkleRoot == uint256(&quot;0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb&quot;)); &nbsp; （3）修改网络协议魔数 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。 另外：对应的修改TESTNET和REGTESTNET的参数 （4）修改地址前缀 源文件 chainparams.cpp [cpp] view plain copy base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; 有一个wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。 （5）修改网络端口 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; 修改了nDefaultPort=9999，比特币默认是8333 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可 [cpp] view plain copy /**&nbsp; &nbsp;* Testnet (v3)&nbsp; &nbsp;*/ &nbsp; class CTestNetParams : public CMainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CTestNetParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::TESTNET; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;test&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0xC0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x1d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 19999; &nbsp; [cpp] view plain copy /**&nbsp; &nbsp;* Regression test&nbsp; &nbsp;*/ &nbsp; class CRegTestParams : public CTestNetParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CRegTestParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::REGTEST; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;regtest&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x0b; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0xad; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 29999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; &nbsp; （6）修改种子网络连接参数 源文件 chainparams.cpp [cpp] view plain copy //vSeeds.push_back(CDNSSeedData(&quot;bitcoin.sipa.be&quot;, &quot;seed.bitcoin.sipa.be&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bluematt.me&quot;, &quot;dnsseed.bluematt.me&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;dashjr.org&quot;, &quot;dnsseed.bitcoin.dashjr.org&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitcoinstats.com&quot;, &quot;seed.bitcoinstats.com&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;bitnodes.io&quot;, &quot;seed.bitnodes.io&quot;)); &nbsp; //vSeeds.push_back(CDNSSeedData(&quot;xf2.org&quot;, &quot;bitseed.xf2.org&quot;)); &nbsp; &nbsp;&nbsp; base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp; base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp; base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp; base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp; base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp; &nbsp;&nbsp; //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); &nbsp; 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com 对应的修改一下TESTNET和REGTESTNET的网络节点地址。 （7）修改工作量机制 源文件 miner.cpp 比特币在函数ScanHash（）里面搜索随机数， [cpp] view plain copy // &nbsp; // ScanHash scans nonces looking for a hash with at least some zero bits. &nbsp; // The nonce is usually preserved between calls, but periodically or if the &nbsp; // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at &nbsp; // zero. &nbsp; // &nbsp; bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) &nbsp; { &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; //CHash256 hasher; &nbsp; &nbsp; &nbsp; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; //ss &lt;&lt; *pblock; &nbsp; &nbsp; &nbsp; //assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; //hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nNonce++; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the last 4 bytes of the block header (the nonce) to a copy of &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the double-SHA256 state, and compute the result. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *phash = pblock-&gt;ComputePowHash(nNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Return the nonce if the hash has at least some zero bits, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // caller will check if it has enough to reach the target &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (((uint16_t*)phash)[15] == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If nothing found after trying for a while, return -1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xffff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xfff) == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boost::this_thread::interruption_point(); &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。 注意：设置独立挖矿的条件(chainparams.cpp里面设置) [cpp] view plain copy fMiningRequiresPeers = !true; // See BitcoinMiner() for details. &nbsp; 挖矿代码： [cpp] view plain copy void static BitcoinMiner(CWallet *pwallet) &nbsp; { &nbsp; &nbsp; &nbsp; LogPrintf(&quot;FastCoinMiner started\\n&quot;); &nbsp; &nbsp; &nbsp; SetThreadPriority(THREAD_PRIORITY_LOWEST); &nbsp; &nbsp; &nbsp; RenameThread(&quot;fastcoin-miner&quot;); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Each thread has its own key and counter &nbsp; &nbsp; &nbsp; CReserveKey reservekey(pwallet); &nbsp; &nbsp; &nbsp; unsigned int nExtraNonce = 0; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (Params().MiningRequiresPeers()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Busy-wait for the network to come online so we don&#39;t waste time mining &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // on an obsolete chain. In regtest mode we expect to fly solo. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (vNodes.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MilliSleep(1000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Create new block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindexPrev = chainActive.Tip(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pblocktemplate.get()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock *pblock = &amp;pblocktemplate-&gt;block; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf(&quot;Running FastCoinMiner with %u transactions in block (%u bytes)\\n&quot;, pblock-&gt;vtx.size(), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); &nbsp; 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。 看代码吧： [cpp] view plain copy uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const &nbsp; { &nbsp; &nbsp; &nbsp; if (nVersion == 1 || nVersion == 2){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Use SHA256+SHA256 to make PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 3){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Scrypt PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else if (nVersion == 4){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp;Scrypt+SHA256 PoW&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; }else if (nVersion == 5){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256 hasher; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Abort, unknown block version. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ~(uint256)0; &nbsp; &nbsp; &nbsp; } &nbsp; } &nbsp; （8）修改奖励机制 参考9.3 8.1) 修改挖矿奖励的成熟时间 源代码：main.h [cpp] view plain copy /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ &nbsp; static const int COINBASE_MATURITY = 14; &nbsp; 8.2) 修改交易确认块数推荐值 源代码 qt/transactionrecord.h [cpp] view plain copy /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has&nbsp; &nbsp; &nbsp; multiple outputs.&nbsp; &nbsp;*/ &nbsp; class TransactionRecord &nbsp; { &nbsp; public: &nbsp; &nbsp; &nbsp; enum Type &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Other, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generated, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvWithAddress, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecvFromOther, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendToSelf &nbsp; &nbsp; &nbsp; }; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; /** Number of confirmation recommended for accepting a transaction */ &nbsp; &nbsp; &nbsp; static const int RecommendedNumConfirmations = 2; &nbsp; （9）修改难度配置 源文件 chainparams.cpp [cpp] view plain copy class CMainParams : public CChainParams { &nbsp; public: &nbsp; &nbsp; &nbsp; CMainParams() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = &quot;main&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex(&quot;04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSubsidyHalvingInterval = 210000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nEnforceBlockUpgradeMajority = 750; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRejectBlockOutdatedMajority = 950; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nToCheckBlockUpgradeMajority = 1000; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nMinerThreads = 1; // 0 for all available cpus. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetTimespan = 60 * 60; // re-targeting every one hour &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGenesisSubsidy = 100; &nbsp; a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32; 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。 b) nGenesisSubsidy = 100; 初始津贴，比特币的第一个块的奖励是50个btc。 c) nSubsidyHavlingInterval = 210000;&nbsp; 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。 上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节 [cpp] view plain copy CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) &nbsp; { &nbsp; &nbsp; &nbsp; CAmount nSubsidy = Params().GenesisSubsidy() * COIN; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; int halvings = nHeight / Params().SubsidyHalvingInterval(); &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Force block reward to zero when right shift is undefined. &nbsp; &nbsp; &nbsp; if (halvings &gt;= 64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nFees; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. &nbsp; &nbsp; &nbsp; nSubsidy &gt;&gt;= halvings; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; return nSubsidy + nFees; &nbsp; } &nbsp; 很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。 d）难度调节周期 nTargetTimespan = 60 * 60; // re-targeting every one hour nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. 这里的设置是60分钟（3600秒），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。 区块挖掘超时设置，在网络算力足够的情况下，一个节点可以挖矿的时间是有限的，比如这里这是的1分钟（60秒），超过这个时间，要么提交目前已找到的block（nNonce），要放弃自己的挖掘结果（使用网络上其他节点找到的一个最优结果）来寻找下一个block。否则其他节点也已经开始寻找next了，不过这个前提是算力足够，比如btc网络（现在应该到78个0的位置了吧），你如果10分钟内找不到，那么好了，可以放弃了，用别人的block吧，赶紧进入下一个回合的挖掘，否则很可能是浪费时间。 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016 参考：http://bitcoindifficulty.com/blog/ https://en.bitcoin.it/wiki/Difficulty (10) 修改checkpoints检查 (11) 修改界面 github地址 TODO: 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。 2）矿池搭建与节点测试 P2pool &nbsp;&amp;Poclbm 3）移动支付和网页支付 4）应用生态 5）交易备注 6）复杂交易应用(脚本，非标准交易） 备注： 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 阅读更多","@type":"BlogPosting","url":"/2017/07/12/3710f22c3bd7eb91d513ed35301ef5fe.html","headline":"虚拟币开发专题（自己动手制作山寨币教程）","dateModified":"2017-07-12T00:00:00+08:00","datePublished":"2017-07-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/07/12/3710f22c3bd7eb91d513ed35301ef5fe.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>虚拟币开发专题（自己动手制作山寨币教程）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/75006233 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <br>
  <br> 源代码地址：
  <br> https://github.com/imharrywu/fastcoin
  <br>
  <br>
  <br> 程序猿朋友可以自己动手编译生成安装包，有问题可以直接加群讨论 306888500(注明：csdn)，也欢迎程序猿朋友PullRequest给我，只有知识共享才能促进比特币的繁荣。
  <br>
  <br>
  <br> 可以支持任何算法（sha256，scrypt，x11，x13，nist，grostel，以及这些算法的串联）和参数定制。
  <br>
  <br>
  <br> 目前预先内置了比特币的SHA256和莱特币的scypt，以及SHA3-256(KECCAK)。
  <br>
  <br>
  <br> 在线编译目前提供三种安装包：
  <br> 1，Linux/unix的daemon程序（带钱包功能）
  <br> 2，Mac钱包安装包&nbsp;
  <br> 3，windows钱包安装包
  <br>
  <br>
  <br> 如果看完此文您觉得有用，欢迎捐赠博主：
  <br> 1MMkfgNEw96B83DQq3DFtL9WxcTN7keFPG
  <br>
  <br>
  <br> 1、 &nbsp;截图预览
  <br> (1) 安装图1
  <br>
  <br>
  <br> （2）安装图2
  <br>
  <br>
  <br> （3）安装图3
  <br>
  <br>
  <br> （4）安装图4
  <br>
  <br>
  <br> （5）安装图5
  <br>
  <br>
  <br>
  <br>
  <br> （6）概览图 已经挖到3个block 奖励了300个FTC
  <br>
  <br>
  <br> （7）交易记录图
  <br>
  <br>
  <br> （8）点击显示交易细节 显示为挖矿所得 并且还没有确认
  <br>
  <br>
  <br> （9）版权页
  <br>
  <br>
  <br> （10）调试窗口
  <br>
  <br>
  <br>
  <br>
  <br> （11）显示已经连接的p2p网络节点 一个在虚拟机里面运行的节点
  <br>
  <br>
  <br>
  <br>
  <br> （12）2个节点构成的p2p通信网络
  <br>
  <br>
  <br>
  <br>
  <br> 2、 山寨币修改步骤：
  <br> （1）迁出最新的比特币源代码
  <br> 比特币官方代码: https://github.com/bitcoin/bitcoin
  <br> 山寨币代码地址（紧跟bitcoin更新）:https://github.com/imharrywu/fastcoin
  <br> Git clone https://github.com/imharrywu/fastcoin&nbsp;
  <br>
  <br>
  <br> 一下修改都是一些代码片段，请用eclipse打开迁出的代码，对照查看。
  <br>
  <br>
  <br> （2）修改创世块
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> /**&nbsp;
  <br> &nbsp;* Build the genesis block. Note that the output of the genesis coinbase cannot&nbsp;
  <br> &nbsp;* be spent as it did not originally exist in the database.&nbsp;
  <br> &nbsp;* &nbsp;
  <br> &nbsp;* CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)&nbsp;
  <br> &nbsp;* &nbsp; CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)&nbsp;
  <br> &nbsp;* &nbsp; &nbsp; CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)&nbsp;
  <br> &nbsp;* &nbsp; &nbsp; CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)&nbsp;
  <br> &nbsp;* &nbsp; vMerkleTree: 4a5e1e&nbsp;
  <br> &nbsp;*/ &nbsp;
  <br> &nbsp;&nbsp;
  <br> // HarryWu, generate genesis block by genesis.py as following: &nbsp;
  <br> // &nbsp;
  <br> // localhost genesis # python genesis.py \ &nbsp;
  <br> // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-t $(date +%s) \ &nbsp;
  <br> // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-z "shanghai stock index closed at 2343.57, on 24th Sept., 2014" \ &nbsp;
  <br> // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-a SHA256 \ &nbsp;
  <br> // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-p 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc \ &nbsp;
  <br> // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-v 10000000000 &nbsp;
  <br> // Raw block data: 04ffff001d01043b7368616e676861692073746f636b20696e64657820636c6f73656420617420323334332e35372c206f6e203234746820536570742e2c2032303134 &nbsp;
  <br> // algorithm: SHA256 &nbsp;
  <br> // merkle hash: 1c395aad7fab156523a095a869d3fcdf3249a8a97c8d7337adb4f33d826da32b &nbsp;
  <br> // pszTimestamp: shanghai stock index closed at 2343.57, on 24th Sept., 2014 &nbsp;
  <br> // pubkey: 049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc &nbsp;
  <br> // time: 1411650667 &nbsp;
  <br> // bits: 0x1d00ffff &nbsp;
  <br> // Searching for genesis hash.. &nbsp;
  <br> // &nbsp;
  <br> // nonce: 1456993276 &nbsp;
  <br> // genesis hash: 000000004df0288b461e17d9a20e557fd296861c604f1944eb9e2cca866af0a5 &nbsp;
  <br> &nbsp;&nbsp;
  <br> const char* pszTimestamp = "shanghai stock index closed at 2343.57, on 24th Sept., 2014"; &nbsp;
  <br> CMutableTransaction txNew; &nbsp;
  <br> txNew.vin.resize(1); &nbsp;
  <br> txNew.vout.resize(1); &nbsp;
  <br> txNew.vin[0].scriptSig = CScript() &lt;&lt; 0x1d00ffff &lt;&lt; CScriptNum(4) &lt;&lt; vector&lt;unsigned char&gt;((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp)); &nbsp;
  <br> txNew.vout[0].nValue = nGenesisSubsidy * COIN; &nbsp;
  <br> txNew.vout[0].scriptPubKey = CScript() &lt;&lt; ParseHex("049e02fa9aa3c19a3b112a58bab503c5caf797972f5cfe1006275aa5485a01b48f9f648bc5380ee1e82dc6f474c8e0f7e2f6bbd0de9355f92496e3ea327ccb19cc") &lt;&lt; OP_CHECKSIG; &nbsp;
  <br> genesis.vtx.push_back(txNew); &nbsp;
  <br> genesis.hashPrevBlock = 0; &nbsp;
  <br> genesis.hashMerkleRoot = genesis.BuildMerkleTree(); &nbsp;
  <br> genesis.nVersion = 1; &nbsp;
  <br> genesis.nTime &nbsp; &nbsp;= 1411666331; &nbsp;
  <br> genesis.nBits &nbsp; &nbsp;= 0x1d00ffff; &nbsp;
  <br> genesis.nNonce &nbsp; = 2056985438; &nbsp;
  <br> &nbsp;&nbsp;
  <br> hashGenesisBlock = genesis.GetHash(); &nbsp;
  <br> assert(hashGenesisBlock == uint256("0x0000000061b1aca334b059920fed7bace2336ea4d23d63428c7aee04da49e942")); &nbsp;
  <br> assert(genesis.hashMerkleRoot == uint256("0x7bf229f629a6666596c1ce57117c28d1d29299e8a5303347929bd70847c49adb")); &nbsp;
  <br>
  <br>
  <br>
  <br>
  <br> （3）修改网络协议魔数
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> class CMainParams : public CChainParams { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; CMainParams() { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = "main"; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp;
  <br>
  <br>
  <br> 0xgoodcafe(好咖啡的意思），大家可以自己选择，但是也有一些基本建议，看上面那个英文注释就好了，就是和某些常用的字符集可用字段不要冲突。
  <br> 另外：对应的修改TESTNET和REGTESTNET的参数
  <br>
  <br>
  <br> （4）修改地址前缀
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp;
  <br> base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp;
  <br> base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp;
  <br> base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp;
  <br> base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp;
  <br>
  <br>
  <br> 有一个wiki的对照表可以用来悬在公钥和脚本地址的前缀，但是这个表不使用私钥等（因为长度不一样，规律不一样）。
  <br>
  <br>
  <br> （5）修改网络端口
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> class CMainParams : public CChainParams { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; CMainParams() { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = "main"; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex("04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85"); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp;
  <br>
  <br>
  <br> 修改了nDefaultPort=9999，比特币默认是8333
  <br> 另外同时修改一下TESTNET和REGTESTNET的端口配置，一般加10000和20000即可
  <br> [cpp] view plain copy
  <br> /**&nbsp;
  <br> &nbsp;* Testnet (v3)&nbsp;
  <br> &nbsp;*/ &nbsp;
  <br> class CTestNetParams : public CMainParams { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; CTestNetParams() { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::TESTNET; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = "test"; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0xC0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x1d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex("045d2d29beffb0a0cbea44f266286ff8b1d11c035538fbb4dadcf6b4073b08f318afea74f01d5a3782e72a22273fb01ab40e99d93adff488236585cc8031323e7c"); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 19999; &nbsp;
  <br>
  <br>
  <br> [cpp] view plain copy
  <br> /**&nbsp;
  <br> &nbsp;* Regression test&nbsp;
  <br> &nbsp;*/ &nbsp;
  <br> class CRegTestParams : public CTestNetParams { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; CRegTestParams() { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::REGTEST; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = "regtest"; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x0b; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0xad; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 29999; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 1; &nbsp;
  <br>
  <br>
  <br>
  <br>
  <br> （6）修改种子网络连接参数
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> //vSeeds.push_back(CDNSSeedData("bitcoin.sipa.be", "seed.bitcoin.sipa.be")); &nbsp;
  <br> //vSeeds.push_back(CDNSSeedData("bluematt.me", "dnsseed.bluematt.me")); &nbsp;
  <br> //vSeeds.push_back(CDNSSeedData("dashjr.org", "dnsseed.bitcoin.dashjr.org")); &nbsp;
  <br> //vSeeds.push_back(CDNSSeedData("bitcoinstats.com", "seed.bitcoinstats.com")); &nbsp;
  <br> //vSeeds.push_back(CDNSSeedData("bitnodes.io", "seed.bitnodes.io")); &nbsp;
  <br> //vSeeds.push_back(CDNSSeedData("xf2.org", "bitseed.xf2.org")); &nbsp;
  <br> &nbsp;&nbsp;
  <br> base58Prefixes[PUBKEY_ADDRESS] = list_of(35); // F prefix &nbsp;
  <br> base58Prefixes[SCRIPT_ADDRESS] = list_of(65); // T prefix &nbsp;
  <br> base58Prefixes[SECRET_KEY] = &nbsp; &nbsp; list_of(45); // 7 prefix &nbsp;
  <br> base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xEE)(0x35); &nbsp;
  <br> base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xEE)(0x45); &nbsp;
  <br> &nbsp;&nbsp;
  <br> //convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main)); &nbsp;
  <br>
  <br>
  <br> 如果你有7x24在线的服务器运行节点，那么请在这里加入他们的地址，可以是dns也可以是ip地址（v4，v6，--enable-ipv6）。
  <br> 如果没有的话，可以考虑和我一样暂时注释掉，在运行时候指定连接参数-addnoe=123.123.123.123 或者-dns -addnode=mynode.domain.com
  <br> 对应的修改一下TESTNET和REGTESTNET的网络节点地址。
  <br>
  <br>
  <br> （7）修改工作量机制
  <br> 源文件 miner.cpp
  <br> 比特币在函数ScanHash（）里面搜索随机数，
  <br> [cpp] view plain copy
  <br> // &nbsp;
  <br> // ScanHash scans nonces looking for a hash with at least some zero bits. &nbsp;
  <br> // The nonce is usually preserved between calls, but periodically or if the &nbsp;
  <br> // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at &nbsp;
  <br> // zero. &nbsp;
  <br> // &nbsp;
  <br> bool static ScanHash(const CBlockHeader *pblock, uint32_t&amp; nNonce, uint256 *phash) &nbsp;
  <br> { &nbsp;
  <br> &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp;
  <br> &nbsp; &nbsp; //CHash256 hasher; &nbsp;
  <br> &nbsp; &nbsp; //CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp;
  <br> &nbsp; &nbsp; //ss &lt;&lt; *pblock; &nbsp;
  <br> &nbsp; &nbsp; //assert(ss.size() == 80); &nbsp;
  <br> &nbsp; &nbsp; //hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; while (true) { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nNonce++; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Write the last 4 bytes of the block header (the nonce) to a copy of &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // the double-SHA256 state, and compute the result. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; //CHash256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)phash); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; *phash = pblock-&gt;ComputePowHash(nNonce); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Return the nonce if the hash has at least some zero bits, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // caller will check if it has enough to reach the target &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (((uint16_t*)phash)[15] == 0) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // If nothing found after trying for a while, return -1 &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xffff) == 0) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if ((nNonce &amp; 0xfff) == 0) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boost::this_thread::interruption_point(); &nbsp;
  <br> &nbsp; &nbsp; } &nbsp;
  <br> } &nbsp;
  <br>
  <br>
  <br>
  <br>
  <br> 在函数BitcoinMiner()里面创建新的block，设定时间戳(扰动1)，获取mempool里面的最新交易(扰动2)，调用ScanHash()搜索随机数(扰动3），直到找到满足条件的hash。
  <br> 另外比特币的工作量证明的hash同时用作这个block的索引，litecoin里面这2个概念是区分的对待的(sha256的hash作为索引，scrypt出来的pow hash作为工作量证明)。
  <br> 注意：设置独立挖矿的条件(chainparams.cpp里面设置)
  <br> [cpp] view plain copy
  <br> fMiningRequiresPeers = !true; // See BitcoinMiner() for details. &nbsp;
  <br>
  <br>
  <br> 挖矿代码：
  <br> [cpp] view plain copy
  <br> void static BitcoinMiner(CWallet *pwallet) &nbsp;
  <br> { &nbsp;
  <br> &nbsp; &nbsp; LogPrintf("FastCoinMiner started\n"); &nbsp;
  <br> &nbsp; &nbsp; SetThreadPriority(THREAD_PRIORITY_LOWEST); &nbsp;
  <br> &nbsp; &nbsp; RenameThread("fastcoin-miner"); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; // Each thread has its own key and counter &nbsp;
  <br> &nbsp; &nbsp; CReserveKey reservekey(pwallet); &nbsp;
  <br> &nbsp; &nbsp; unsigned int nExtraNonce = 0; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; try { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; while (true) { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (Params().MiningRequiresPeers()) { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Busy-wait for the network to come online so we don't waste time mining &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // on an obsolete chain. In regtest mode we expect to fly solo. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (vNodes.empty()) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MilliSleep(1000); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Create new block &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated(); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindexPrev = chainActive.Tip(); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlockTemplate&gt; pblocktemplate(CreateNewBlockWithKey(reservekey)); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pblocktemplate.get()) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf("Error in FastCoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n"); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock *pblock = &amp;pblocktemplate-&gt;block; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IncrementExtraNonce(pblock, pindexPrev, nExtraNonce); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogPrintf("Running FastCoinMiner with %u transactions in block (%u bytes)\n", pblock-&gt;vtx.size(), &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION)); &nbsp;
  <br>
  <br>
  <br> 博主稍作修改，设置了几个预置的hash算法（sha256，scrypt，keccak（即SHA3))，可以通过block的版本号区分，那么在scanhash里面调用ComputePowHash的时候，可以选择不同的pow算法，甚至你可以把这些算法串联起来，以增加算法被破解的方攻击性。
  <br> 看代码吧：
  <br> [cpp] view plain copy
  <br> uint256 CBlockHeader::ComputePowHash(uint32_t nNonce) const &nbsp;
  <br> { &nbsp;
  <br> &nbsp; &nbsp; if (nVersion == 1 || nVersion == 2){ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Use SHA256+SHA256 to make PoW&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Write the first 76 bytes of the block header to a double-SHA256 state. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow hasher; // TODO: Create a new PowHasher named CPowHash256 &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CDoubleSHA256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp;
  <br> &nbsp; &nbsp; }else if (nVersion == 3){ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Scrypt PoW&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow hasher; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CScryptHash256Pow(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp;
  <br> &nbsp; &nbsp; }else if (nVersion == 4){ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp;Scrypt+SHA256 PoW&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; }else if (nVersion == 5){ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Keccak(1088,512,256) or Known as SHA3-256(fips202draft) Pow&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256 hasher; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; *this; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; assert(ss.size() == 80); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; hasher.Write((unsigned char*)&amp;ss[0], 76); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; uint256 powHash; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CKeccak_256(hasher).Write((unsigned char*)&amp;nNonce, 4).Finalize((unsigned char*)&amp;powHash); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return powHash; &nbsp;
  <br> &nbsp; &nbsp; }else{ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Abort, unknown block version. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; assert(false); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return ~(uint256)0; &nbsp;
  <br> &nbsp; &nbsp; } &nbsp;
  <br> } &nbsp;
  <br>
  <br>
  <br>
  <br>
  <br> （8）修改奖励机制
  <br> 参考9.3
  <br> 8.1) 修改挖矿奖励的成熟时间
  <br> 源代码：main.h
  <br> [cpp] view plain copy
  <br> /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */ &nbsp;
  <br> static const int COINBASE_MATURITY = 14; &nbsp;
  <br>
  <br>
  <br> 8.2) 修改交易确认块数推荐值
  <br> 源代码 qt/transactionrecord.h
  <br> [cpp] view plain copy
  <br> /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has&nbsp;
  <br> &nbsp; &nbsp; multiple outputs.&nbsp;
  <br> &nbsp;*/ &nbsp;
  <br> class TransactionRecord &nbsp;
  <br> { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; enum Type &nbsp;
  <br> &nbsp; &nbsp; { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; Other, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; Generated, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SendToAddress, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SendToOther, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; RecvWithAddress, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; RecvFromOther, &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SendToSelf &nbsp;
  <br> &nbsp; &nbsp; }; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; /** Number of confirmation recommended for accepting a transaction */ &nbsp;
  <br> &nbsp; &nbsp; static const int RecommendedNumConfirmations = 2; &nbsp;
  <br>
  <br>
  <br> （9）修改难度配置
  <br> 源文件 chainparams.cpp
  <br> [cpp] view plain copy
  <br> class CMainParams : public CChainParams { &nbsp;
  <br> public: &nbsp;
  <br> &nbsp; &nbsp; CMainParams() { &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; networkID = CBaseChainParams::MAIN; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; strNetworkID = "main"; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; /** &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The message start string is designed to be unlikely to occur in normal data.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The characters are rarely used upper ASCII, not valid as UTF-8, and produce&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a large 4-byte int at any alignment.&nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[0] = 0x90; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[1] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[2] = 0xf0; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; pchMessageStart[3] = 0x0d; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vAlertPubKey = ParseHex("04e01590abdc5967eb550413fcf04bbd7cead46f13579b58d52ea2f08d71a1a94196c476cd4fa60c30b51737fe3d9c8c88a04a6bec2282ebb1f22286130a153b85"); &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nDefaultPort = 9999; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; bnProofOfWorkLimit = ~uint256(0) &gt;&gt; 32; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nSubsidyHalvingInterval = 210000; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nEnforceBlockUpgradeMajority = 750; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nRejectBlockOutdatedMajority = 950; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nToCheckBlockUpgradeMajority = 1000; &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nMinerThreads = 1; // 0 for all available cpus. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nTargetTimespan = 60 * 60; // re-targeting every one hour &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes. &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; nGenesisSubsidy = 100; &nbsp;
  <br>
  <br>
  <br> a) bnProofOfWorkLimit=~uint256(0) &gt;&gt; 32;
  <br> 是一个大整数（256bit）表示，前面32个位数是0，这个参数表示全网允许的最小难度，低于这个难度的block是不会被挖掘的。
  <br>
  <br>
  <br> b) nGenesisSubsidy = 100;
  <br> 初始津贴，比特币的第一个块的奖励是50个btc。
  <br>
  <br>
  <br> c) nSubsidyHavlingInterval = 210000;&nbsp;
  <br> 这个参数决定了多少个block以后比特币的奖励（补贴，挖矿奖励)会减半。这个参数结合初始奖励（比如比特币50）基本可以估算全网总的货币产量（比如比特币的2100万），这个初始津贴也是可以配置的，如2）所示。比如比特币，一个等比数列求和公式就可以计算货币总量 50(1/(1 - 0.5))*210000=2100万btc。
  <br> 上面2个参数在查询区块奖励的时候用到，请查看main.cpp 的 GetBlockValue(height, fees)找到细节
  <br> [cpp] view plain copy
  <br> CAmount GetBlockValue(int nHeight, const CAmount&amp; nFees) &nbsp;
  <br> { &nbsp;
  <br> &nbsp; &nbsp; CAmount nSubsidy = Params().GenesisSubsidy() * COIN; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; int halvings = nHeight / Params().SubsidyHalvingInterval(); &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; // Force block reward to zero when right shift is undefined. &nbsp;
  <br> &nbsp; &nbsp; if (halvings &gt;= 64) &nbsp;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return nFees; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. &nbsp;
  <br> &nbsp; &nbsp; nSubsidy &gt;&gt;= halvings; &nbsp;
  <br> &nbsp;&nbsp;
  <br> &nbsp; &nbsp; return nSubsidy + nFees; &nbsp;
  <br> } &nbsp;
  <br> 很多山寨比也是在这里修改货币分布的，比如 nHeight==1 的时候，奖励1000万个，其他块都不予奖励，这个即使预挖模式了吧。
  <br> 另外，关于货币分布，这里satoshi同学可能已经考虑很多，他为什么设置到很多年以后才矿源枯竭，为什么采取递减的方式，可能都是出于保护区块链的目的（timestampserver）。
  <br> d）难度调节周期
  <br> nTargetTimespan = 60 * 60; // re-targeting every one hour
  <br> nTargetSpacing = 1 * 60; &nbsp;// do new pow every 1 minutes.
  <br> 这里的设置是60分钟（3600秒），重新评估难度，下一个块的挖掘可能就要使用新的难度设置了。
  <br> 区块挖掘超时设置，在网络算力足够的情况下，一个节点可以挖矿的时间是有限的，比如这里这是的1分钟（60秒），超过这个时间，要么提交目前已找到的block（nNonce），要放弃自己的挖掘结果（使用网络上其他节点找到的一个最优结果）来寻找下一个block。否则其他节点也已经开始寻找next了，不过这个前提是算力足够，比如btc网络（现在应该到78个0的位置了吧），你如果10分钟内找不到，那么好了，可以放弃了，用别人的block吧，赶紧进入下一个回合的挖掘，否则很可能是浪费时间。
  <br> 比特币的调节周期是 2周/每10分钟，也就是 2 * 7 * 24 * 6 = 2016
  <br> 参考：http://bitcoindifficulty.com/blog/
  <br> https://en.bitcoin.it/wiki/Difficulty
  <br>
  <br>
  <br> (10) 修改checkpoints检查
  <br>
  <br>
  <br> (11) 修改界面
  <br>
  <br>
  <br> github地址
  <br>
  <br>
  <br> TODO:
  <br> 1）模板化的山寨币生成，可配置修改部分通过宏或者变量提取出来，用脚本批量替换修改。
  <br> 2）矿池搭建与节点测试 P2pool &nbsp;&amp;Poclbm
  <br> 3）移动支付和网页支付
  <br> 4）应用生态
  <br> 5）交易备注
  <br> 6）复杂交易应用(脚本，非标准交易）
  <br>
  <br>
  <br> 备注：
  <br> 1）记得加上-checkpoints=0 参数启动，否则，会导致daemon报错，“FastCoin is downloading blocks...” 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/75006233,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/75006233,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
