<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>OpenSSL和Python实现RSA Key数字签名和验证 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="OpenSSL和Python实现RSA Key数字签名和验证" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为guyongqiangx原创，欢迎评论、转载和收藏。微信公众号：洛奇看世界。 https://blog.csdn.net/guyongqiangx/article/details/74454969 基于非对称算法的RSA Key主要有两个用途，数字签名和验证（私钥签名，公钥验证），以及非对称加解密（公钥加密，私钥解密）。本文提供一个基于OpenSSL命令行和Python的数字签名和验证过程的例子，另外会另起一篇使用OpenSSL和Python进行非对称加解密的例子。 1. OpenSSL实现数字签名和验证 1.1 生成私钥 生成2048 bit的PEM格式的RSA Key：Key.pem # 生成私钥文件Key.pem $ openssl genrsa -out Key.pem -f4 2048 Generating RSA private key, 2048 bit long modulus .+++ ...................................................................+++ e is 65537 (0x10001) # 查看私钥文件内容 $ cat Key.pem -----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAoZZKNO89UcDkEgdulOtAK0d9dQ0xfnpt4QNUg16ISeNuAFYv OeXn/ToGounX67+bkYpH92dXCnNpOsERLogenWQT533tsRU9KByeCz+PRgjc5cBn wAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjRSe7+h2sF7va3tGPn8cLpDUoLLk2e ugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkAoHI14hrz3xDssg0wlHqbptwsmwAQ 1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bPiFZJRFIqRRg0UNWkUBR+BJhWZ7Zc Dud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZRlQIDAQABAoIBABTN+uPx4Z1DDppb pps55tsrqzWE61hzfu43tYvsgfOxeppEfnQf68yoye3z2b8avnbwrO9nuMc5sNTF wuaQ1BBDsGRfzFi+eU9Oz/J2zoWf4oEaUsFfxjK5v1cgNz0ugfAVnP5Wwv+wmkGT aNinI7s3MEJTP0JTNbfeHSD9jXAOYhXH1M6/gq+TxLlsFISbQgmIbnDkDU/biXC+ b4r4/3xBieaeYOSV5s7pziXcxPmZCrWdcggtcxxJeDFtvQbSU4PXM7n7NgcsGQiX kwlHF3TiSQpQRuthV1ioW4FFFtwKw38mwzYcexem5Pyv353xSfb4vGg2+mcUEaf9 oNYYasECgYEA0tpP8th2L1zVT4eyumE5KE95iH4Nr6RWkQpfWQ84MDmiK7cNFeBL 0l4kwUo4oQeNEfDHYlxZ/guaflDLOKJ7DampMEuc+Dl8hmwXhdhqeQzxNRnaoDV1 iIyyHUs9c/9ormjTsycas2VfH1sPm3SrwH2rQe4ttkVBS8mcouNlg3kCgYEAxC+G qgsN+IifgVoeHIw2ak0MxTdt0LfGWcygx4hzXCpYrnqns080Z4vGDxClhqfdM9OJ 0Y6GkaNIHay/4bUIsBYFoV78vV80oQykHs6nwdJqLZJeQohBUlO2LlGzatPtWWuc v3N9W/OjSd3q6UgApmFT4+cMmEUZjB7QsHhau/0CgYBRotDdd02a3NiB6Eocu1PD 9bFaVWO7I2eY1GlCNBBPK6FMR507YRI6KtUUOUZfomrODWlE/fih0aBJU8K69L2r 9opY9o2Z1bgO237oBXiD0az6ID5zVP9ilQbJLL5oUPUYweFlNbiyyIbhvwH18GAn MQDDkBIGxh2X2EFbF6vQEQKBgHW5Bxe2dnWylfQqvXLn+CclgQo+zpi2DkIIdloF WSPvDTP1yffhCVMxHnIfzRPWWvgkccjbu4hc8INOC/5GgaYYMNy6gPKp1IznZvxN iYDW4HvkHsfRt1DNhr6YrA7oiL5lwrNne8vXkR5cGgBOAoXUVWCmXnpozIG2ZAfg 0KGJAoGANO46bePCNaVlP37hW3vjraW4gzKPS0xscG7pLnLrv+T628PnFS7j7D7a 6v6BBBSgBTFnuEOk2F4bfIRvE04m2S9vzg6Mt2aJHn6RQjQVZPZF+qFvrXxjzqRU 4R+06Hk2Zm2D3x/XJTu2QmzT1kqp6AtsnfOCz3M0a1oyd5eCVdk= -----END RSA PRIVATE KEY----- 1.2 导出公钥 从私钥导出公钥：Key_pub.pem # 从私钥导出公钥，很简单，使用参数-pubout就可以 $ openssl rsa -in Key.pem -pubout -out Key_pub.pem writing RSA key # 查看公钥文件内容 $ cat Key_pub.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoZZKNO89UcDkEgdulOtA K0d9dQ0xfnpt4QNUg16ISeNuAFYvOeXn/ToGounX67+bkYpH92dXCnNpOsERLoge nWQT533tsRU9KByeCz+PRgjc5cBnwAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjR Se7+h2sF7va3tGPn8cLpDUoLLk2eugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkA oHI14hrz3xDssg0wlHqbptwsmwAQ1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bP iFZJRFIqRRg0UNWkUBR+BJhWZ7ZcDud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZR lQIDAQAB -----END PUBLIC KEY----- 1.3 准备签名数据 为了简单起见，生成16字节全0的数据作为测试文件：data.bin # 使用dd命令生成16字节的data.bin $ dd if=/dev/zero of=data.bin bs=1 count=16 16+0 records in 16+0 records out 16 bytes (16 B) copied, 0.000189593 s, 84.4 kB/s # 使用hexdump查看data.bin的内容，16个字节全都是0 $ hexdump -Cv data.bin 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010 1.4 计算sha256哈希 直接计算data.bin的sha256哈希值： # 调用openssl dgst计算sha256 $ openssl dgst -sha256 data.bin SHA256(data.bin)= 374708fff7719dd5979ec875d56cd2286f6d3cf7ec317a3b25632aab28ec37bb 也可以将data.bin的sha256哈希值存储到单独的文件：data.bin.sha256 # 将sha256结果输出到文件data.bin.sha256 $ openssl dgst -sha256 -binary -out data.bin.sha256 data.bin # 使用hexdump查看data.bin.sha256文件的内容 $ hexdump -Cv data.bin.sha256 00000000 37 47 08 ff f7 71 9d d5 97 9e c8 75 d5 6c d2 28 |7G...q.....u.l.(| 00000010 6f 6d 3c f7 ec 31 7a 3b 25 63 2a ab 28 ec 37 bb |om&lt;..1z;%c*.(.7.| 00000020 1.5 私钥签名 对数据data.bin使用私钥Key.pem进行签名，生成签名文件：data.bin.signature # 使用Key.pem对data.bin进行签名，并将签名结果输出到文件data.bin.signature $ openssl dgst -sha256 -out data.bin.signature -sign Key.pem data.bin # 使用hexdump查看签名结果文件data.bin.signature的内容 $ hexdump -Cv data.bin.signature 00000000 7e 59 0f b5 b2 d9 31 f6 af 95 34 79 8d d8 5a a4 |~Y....1...4y..Z.| 00000010 69 02 b9 29 a9 f5 1d 00 6d 84 93 69 8c 65 d3 c9 |i..)....m..i.e..| 00000020 9b 6e 52 48 46 c7 1a b2 71 83 c6 6e 2e bb 6a b0 |.nRHF...q..n..j.| 00000030 bb cf 48 16 49 4d 57 f7 9b e9 0c a6 87 7b 15 cd |..H.IMW......{..| 00000040 f0 ef ac 39 47 ff 81 95 20 eb 67 29 f4 bb 90 bb |...9G... .g)....| 00000050 a2 f8 77 5b 14 14 e4 41 26 cc 1a cd 79 22 de 50 |..w[...A&amp;...y&quot;.P| 00000060 d6 c3 8c bc 79 68 38 1d 0c 65 fc 21 72 48 a9 97 |....yh8..e.!rH..| 00000070 4c 55 fc 7e 33 7b 65 0c d9 67 2c 64 01 3f 81 5b |LU.~3{e..g,d.?.[| 00000080 50 16 54 12 7a eb 96 b8 26 a2 13 28 68 8a 6e 7e |P.T.z...&amp;..(h.n~| 00000090 b9 12 ee 49 3e 51 5c 43 ff fd 5d 3a 90 5e 5f 2f |...I&gt;Q\C..]:.^_/| 000000a0 f1 4e 93 73 aa 86 6f 00 e2 b6 0d dc 3d dd 90 da |.N.s..o.....=...| 000000b0 df 7b e7 ae 15 2b 55 04 81 af c3 16 c6 36 79 3b |.{...+U......6y;| 000000c0 74 63 7b 72 f1 ac c8 9f 6f c0 4f 45 74 36 38 27 |tc{r....o.OEt68&#39;| 000000d0 73 2b c2 0b 99 ca 58 14 2b 1e 39 d9 6d 8b 5d e3 |s+....X.+.9.m.].| 000000e0 05 40 99 ef 0e 47 e8 e0 ec d4 c6 f6 a3 50 55 0e |.@...G.......PU.| 000000f0 4a 00 50 d3 80 a0 61 73 38 3a 98 57 15 11 eb 47 |J.P...as8:.W...G| 00000100 这里使用： - -out选项指定将签名结果存放到data.bin.signature - -sign选项指定签名使用的私钥Key.pem 这里data.bin.signature是如何生成的呢？ - 第1步，计算sha256的哈希值 - 第2步，对sha256哈希结果进行BER编码，并使用PKCS #1.5进行填充 - 第3步，使用私钥对第2步填充后的内容进行加密得到签名结果 下一节会对这个操作进行验证 1.6 公钥验证 使用公钥Key_pub.pem验证签名文件data.bin.signature： $ openssl dgst -sha256 -verify Key_pub.pem -signature data.bin.signature data.bin Verified OK 这里使用： - -verify选项指定用于验证签名的公钥文件 - -signature选项指定需要待验证的签名，此处指定待验证的签名文件时data.bin.signature文件 输出比较简单，只显示了验证结果为”Verified OK”。 根据上一节签名结果的生成过程，我们不妨反推下验证过程： - 第1步，使用公钥解密签名数据 - 第2步，对解密的签名数据去掉填充，得到BER编码后的格式 - 第3步，从BER编码中提取哈希数据 - 第4步，计算原始数据的sha256哈希，并同签名文件中得到的哈希进行比较 找遍了openssl的命令，就是没有找到如何使用公钥进行解密的~~ 我所知的OpenSSL跟解密相关的两个命令： - openssl rsautl -decrypt 需要指定私钥进行解密 - openssl enc -d 基于对称密钥进行解密，这里的非对称加解密显然不适合 哪位大神知道的请指点下，这里如何使用公钥解密签名数据？ 不过，OpenSSL提供了一个命令openssl rsautil -verify，该命令使用公钥验证签名，可以使用这个命令来达到解密签名数据的效果： - 解密原始的签名数据（使用BER编码，且带PKCS #1.5填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump -raw 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 31 30 .............010 00d0 - 0d 06 09 60 86 48 01 65-03 04 02 01 05 00 04 20 ...`.H.e....... 00e0 - 37 47 08 ff f7 71 9d d5-97 9e c8 75 d5 6c d2 28 7G...q.....u.l.( 00f0 - 6f 6d 3c f7 ec 31 7a 3b-25 63 2a ab 28 ec 37 bb om&lt;..1z;%c*.(.7. 解密原始的签名数据（BER编码，但不带填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump 0000 - 30 31 30 0d 06 09 60 86-48 01 65 03 04 02 01 05 010...`.H.e..... 0010 - 00 04 20 37 47 08 ff f7-71 9d d5 97 9e c8 75 d5 .. 7G...q.....u. 0020 - 6c d2 28 6f 6d 3c f7 ec-31 7a 3b 25 63 2a ab 28 l.(om&lt;..1z;%c*.( 0030 - ec 37 bb .7. 填充与不填充的区别在于-raw选项。 以上操作以签名结果data.bin.signature作为输入，并非使用原始数据data.bin作为输入。对比sha256的输出文件data.bin.sha256，解密结果的最后32个字节（对于填充输出，刚好是最后两行）就是原始数据的哈希，所以验证成功。 2. Python实现数字签名和验证 Python签名和验证操作复用OpenSSL生成的文件： - 私钥 Key.pem - 公钥 Key_pub.pem - 数据 data.bin 2.1 安装cryptography库 数字签名和验证基于Python3下的cryptograhpy库，所以需要预先安装： $ sudo pip3 install cryptography 由于cryptography依赖于cffi库，安装中可能会出错，此时只需要先安装libcffi-dev，再重新安装就好了。 $ sudo apt-get install libffi-dev 本文验证环境： $ python3 --version Python 3.4.3 $ pip3 list ... cryptography (1.9) ... cryptograhpy库的官方文档： https://cryptography.io/en/latest/ 2.2 私钥签名 rsa-sign.py使用指定的私钥Key.pem对数据文件data.bin进行签名，并将签名结果输出到文件signature.bin中，代码如下： # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding # 签名函数 def sign(data_file_name, signature_file_name, private_key_file_name): &quot;&quot;&quot; 签名函数使用指定的私钥Key对文件进行签名，并将签名结果写入文件中 :param data_file_name: 待签名的数据文件 :param signature_file_name: 存放签名结果的文件 :param private_key_file_name: 用于签名的私钥文件 :return: 签名数据 &quot;&quot;&quot; # 读取待签名数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 从PEM文件中读取私钥数据 key_file = open(private_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载私钥 private_key = serialization.load_pem_private_key( key_data, password=None, backend=default_backend() ) # 使用私钥对数据进行签名 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 signature = private_key.sign( data, padding.PKCS1v15(), hashes.SHA256() ) # 将签名数据写入结果文件中 signature_file = open(signature_file_name, &#39;wb&#39;) signature_file.write(signature) signature_file.close() # 返回签名数据 return signature if __name__ == &#39;__main__&#39;: # 指定数据文件 data_file = r&#39;data.bin&#39; # 指定签名结果文件 signature_file = r&#39;signature.bin&#39; # 指定签名的私钥 private_key_file = r&#39;Key.pem&#39; # 签名并返回签名结果 signature = sign(data_file, signature_file, private_key_file) # 打印签名数据 [print(&#39;%02x&#39; % x, end=&#39;&#39;) for x in signature] 运行，控制台会打印一长窜签名结果数据： $ python3 rsa-sign.py 7e590fb5b2d931f6af9534798dd85aa46902b929a9f51d006d8493698c65d3c99b6e524846c71ab27183c66e2ebb6ab0bbcf4816494d57f79be90ca6877b15cdf0efac3947ff819520eb6729f4bb90bba2f8775b1414e44126cc1acd7922de50d6c38cbc7968381d0c65fc217248a9974c55fc7e337b650cd9672c64013f815b501654127aeb96b826a21328688a6e7eb912ee493e515c43fffd5d3a905e5f2ff14e9373aa866f00e2b60ddc3ddd90dadf7be7ae152b550481afc316c636793b74637b72f1acc89f6fc04f4574363827732bc20b99ca58142b1e39d96d8b5de3054099ef0e47e8e0ecd4c6f6a350550e4a0050d380a06173383a98571511eb47 比较Python脚本生成的签名文件signature.bin和使用OpenSSL计算得到的结果： $ md5sum data.bin.signature signature.bin 2778de7c17b259d8d0a34538622e2338 data.bin.signature 2778de7c17b259d8d0a34538622e2338 signature.bin 二者的md5结果一致，说明其内容是一样的。 2.3 公钥验证 rsa-verify.py使用指定的公钥Key.pem对对上一节生成的签名文件signature.bin进行验证，代码如下： #!/usr/bin/env python3 # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding from cryptography.exceptions import InvalidSignature # 验证函数 def verify(data_file_name, signature_file_name, public_key_file_name): &quot;&quot;&quot; 验证函数使用指定的公钥对签名结果进行验证 :param data_file_name: 原始数据文件 :param signature_file_name: 签名验证文件 :param public_key_file_name: 用于验证的公钥文件 :return: 成功返回True, 失败返回False &quot;&quot;&quot; # 读取原始数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 读取待验证的签名数据 signature_file = open(signature_file_name, &#39;rb&#39;) signature = signature_file.read() signature_file.close() # 从PEM文件中读取公钥数据 key_file = open(public_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载公钥 public_key = serialization.load_pem_public_key( key_data, backend=default_backend() ) # 验证结果，默认为False verify_ok = False try: # 使用公钥对签名数据进行验证 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 public_key.verify( signature, data, padding.PKCS1v15(), hashes.SHA256() ) # 签名验证失败会触发名为InvalidSignature的exception except InvalidSignature: # 打印失败消息 print(&#39;invalid signature!&#39;) else: # 验证通过，设置True verify_ok = True # 返回验证结果 return verify_ok if __name__ == &#39;__main__&#39;: data_file = r&#39;data.bin&#39; signature_file = r&#39;signature.bin&#39; public_key_file = r&#39;Key_pub.pem&#39; verify_ok = verify(data_file, signature_file, public_key_file) if verify_ok: print(&#39;verify ok!&#39;) else: print(&#39;verify fail!&#39;) 运行脚本，对前一节生成的签名数据进行验证，控制台打印”verify ok!”： $ python3 rsa-verify.py verify ok! 2.4 源码下载 点击这里下载本文提到的Python源码：example-rsa-sign.tar.bz2 3. 联系和福利 关注微信公众号“洛奇看世界” 回复关键词“Android电子书”，获取超过150本Android相关的电子书和文档。电子书包含了Android开发相关的方方面面，从此你再也不需要到处找Android开发的电子书了。 个人微信号，添加请备注“微信公众号”。 阅读更多" />
<meta property="og:description" content="版权声明：本文为guyongqiangx原创，欢迎评论、转载和收藏。微信公众号：洛奇看世界。 https://blog.csdn.net/guyongqiangx/article/details/74454969 基于非对称算法的RSA Key主要有两个用途，数字签名和验证（私钥签名，公钥验证），以及非对称加解密（公钥加密，私钥解密）。本文提供一个基于OpenSSL命令行和Python的数字签名和验证过程的例子，另外会另起一篇使用OpenSSL和Python进行非对称加解密的例子。 1. OpenSSL实现数字签名和验证 1.1 生成私钥 生成2048 bit的PEM格式的RSA Key：Key.pem # 生成私钥文件Key.pem $ openssl genrsa -out Key.pem -f4 2048 Generating RSA private key, 2048 bit long modulus .+++ ...................................................................+++ e is 65537 (0x10001) # 查看私钥文件内容 $ cat Key.pem -----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAoZZKNO89UcDkEgdulOtAK0d9dQ0xfnpt4QNUg16ISeNuAFYv OeXn/ToGounX67+bkYpH92dXCnNpOsERLogenWQT533tsRU9KByeCz+PRgjc5cBn wAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjRSe7+h2sF7va3tGPn8cLpDUoLLk2e ugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkAoHI14hrz3xDssg0wlHqbptwsmwAQ 1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bPiFZJRFIqRRg0UNWkUBR+BJhWZ7Zc Dud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZRlQIDAQABAoIBABTN+uPx4Z1DDppb pps55tsrqzWE61hzfu43tYvsgfOxeppEfnQf68yoye3z2b8avnbwrO9nuMc5sNTF wuaQ1BBDsGRfzFi+eU9Oz/J2zoWf4oEaUsFfxjK5v1cgNz0ugfAVnP5Wwv+wmkGT aNinI7s3MEJTP0JTNbfeHSD9jXAOYhXH1M6/gq+TxLlsFISbQgmIbnDkDU/biXC+ b4r4/3xBieaeYOSV5s7pziXcxPmZCrWdcggtcxxJeDFtvQbSU4PXM7n7NgcsGQiX kwlHF3TiSQpQRuthV1ioW4FFFtwKw38mwzYcexem5Pyv353xSfb4vGg2+mcUEaf9 oNYYasECgYEA0tpP8th2L1zVT4eyumE5KE95iH4Nr6RWkQpfWQ84MDmiK7cNFeBL 0l4kwUo4oQeNEfDHYlxZ/guaflDLOKJ7DampMEuc+Dl8hmwXhdhqeQzxNRnaoDV1 iIyyHUs9c/9ormjTsycas2VfH1sPm3SrwH2rQe4ttkVBS8mcouNlg3kCgYEAxC+G qgsN+IifgVoeHIw2ak0MxTdt0LfGWcygx4hzXCpYrnqns080Z4vGDxClhqfdM9OJ 0Y6GkaNIHay/4bUIsBYFoV78vV80oQykHs6nwdJqLZJeQohBUlO2LlGzatPtWWuc v3N9W/OjSd3q6UgApmFT4+cMmEUZjB7QsHhau/0CgYBRotDdd02a3NiB6Eocu1PD 9bFaVWO7I2eY1GlCNBBPK6FMR507YRI6KtUUOUZfomrODWlE/fih0aBJU8K69L2r 9opY9o2Z1bgO237oBXiD0az6ID5zVP9ilQbJLL5oUPUYweFlNbiyyIbhvwH18GAn MQDDkBIGxh2X2EFbF6vQEQKBgHW5Bxe2dnWylfQqvXLn+CclgQo+zpi2DkIIdloF WSPvDTP1yffhCVMxHnIfzRPWWvgkccjbu4hc8INOC/5GgaYYMNy6gPKp1IznZvxN iYDW4HvkHsfRt1DNhr6YrA7oiL5lwrNne8vXkR5cGgBOAoXUVWCmXnpozIG2ZAfg 0KGJAoGANO46bePCNaVlP37hW3vjraW4gzKPS0xscG7pLnLrv+T628PnFS7j7D7a 6v6BBBSgBTFnuEOk2F4bfIRvE04m2S9vzg6Mt2aJHn6RQjQVZPZF+qFvrXxjzqRU 4R+06Hk2Zm2D3x/XJTu2QmzT1kqp6AtsnfOCz3M0a1oyd5eCVdk= -----END RSA PRIVATE KEY----- 1.2 导出公钥 从私钥导出公钥：Key_pub.pem # 从私钥导出公钥，很简单，使用参数-pubout就可以 $ openssl rsa -in Key.pem -pubout -out Key_pub.pem writing RSA key # 查看公钥文件内容 $ cat Key_pub.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoZZKNO89UcDkEgdulOtA K0d9dQ0xfnpt4QNUg16ISeNuAFYvOeXn/ToGounX67+bkYpH92dXCnNpOsERLoge nWQT533tsRU9KByeCz+PRgjc5cBnwAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjR Se7+h2sF7va3tGPn8cLpDUoLLk2eugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkA oHI14hrz3xDssg0wlHqbptwsmwAQ1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bP iFZJRFIqRRg0UNWkUBR+BJhWZ7ZcDud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZR lQIDAQAB -----END PUBLIC KEY----- 1.3 准备签名数据 为了简单起见，生成16字节全0的数据作为测试文件：data.bin # 使用dd命令生成16字节的data.bin $ dd if=/dev/zero of=data.bin bs=1 count=16 16+0 records in 16+0 records out 16 bytes (16 B) copied, 0.000189593 s, 84.4 kB/s # 使用hexdump查看data.bin的内容，16个字节全都是0 $ hexdump -Cv data.bin 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010 1.4 计算sha256哈希 直接计算data.bin的sha256哈希值： # 调用openssl dgst计算sha256 $ openssl dgst -sha256 data.bin SHA256(data.bin)= 374708fff7719dd5979ec875d56cd2286f6d3cf7ec317a3b25632aab28ec37bb 也可以将data.bin的sha256哈希值存储到单独的文件：data.bin.sha256 # 将sha256结果输出到文件data.bin.sha256 $ openssl dgst -sha256 -binary -out data.bin.sha256 data.bin # 使用hexdump查看data.bin.sha256文件的内容 $ hexdump -Cv data.bin.sha256 00000000 37 47 08 ff f7 71 9d d5 97 9e c8 75 d5 6c d2 28 |7G...q.....u.l.(| 00000010 6f 6d 3c f7 ec 31 7a 3b 25 63 2a ab 28 ec 37 bb |om&lt;..1z;%c*.(.7.| 00000020 1.5 私钥签名 对数据data.bin使用私钥Key.pem进行签名，生成签名文件：data.bin.signature # 使用Key.pem对data.bin进行签名，并将签名结果输出到文件data.bin.signature $ openssl dgst -sha256 -out data.bin.signature -sign Key.pem data.bin # 使用hexdump查看签名结果文件data.bin.signature的内容 $ hexdump -Cv data.bin.signature 00000000 7e 59 0f b5 b2 d9 31 f6 af 95 34 79 8d d8 5a a4 |~Y....1...4y..Z.| 00000010 69 02 b9 29 a9 f5 1d 00 6d 84 93 69 8c 65 d3 c9 |i..)....m..i.e..| 00000020 9b 6e 52 48 46 c7 1a b2 71 83 c6 6e 2e bb 6a b0 |.nRHF...q..n..j.| 00000030 bb cf 48 16 49 4d 57 f7 9b e9 0c a6 87 7b 15 cd |..H.IMW......{..| 00000040 f0 ef ac 39 47 ff 81 95 20 eb 67 29 f4 bb 90 bb |...9G... .g)....| 00000050 a2 f8 77 5b 14 14 e4 41 26 cc 1a cd 79 22 de 50 |..w[...A&amp;...y&quot;.P| 00000060 d6 c3 8c bc 79 68 38 1d 0c 65 fc 21 72 48 a9 97 |....yh8..e.!rH..| 00000070 4c 55 fc 7e 33 7b 65 0c d9 67 2c 64 01 3f 81 5b |LU.~3{e..g,d.?.[| 00000080 50 16 54 12 7a eb 96 b8 26 a2 13 28 68 8a 6e 7e |P.T.z...&amp;..(h.n~| 00000090 b9 12 ee 49 3e 51 5c 43 ff fd 5d 3a 90 5e 5f 2f |...I&gt;Q\C..]:.^_/| 000000a0 f1 4e 93 73 aa 86 6f 00 e2 b6 0d dc 3d dd 90 da |.N.s..o.....=...| 000000b0 df 7b e7 ae 15 2b 55 04 81 af c3 16 c6 36 79 3b |.{...+U......6y;| 000000c0 74 63 7b 72 f1 ac c8 9f 6f c0 4f 45 74 36 38 27 |tc{r....o.OEt68&#39;| 000000d0 73 2b c2 0b 99 ca 58 14 2b 1e 39 d9 6d 8b 5d e3 |s+....X.+.9.m.].| 000000e0 05 40 99 ef 0e 47 e8 e0 ec d4 c6 f6 a3 50 55 0e |.@...G.......PU.| 000000f0 4a 00 50 d3 80 a0 61 73 38 3a 98 57 15 11 eb 47 |J.P...as8:.W...G| 00000100 这里使用： - -out选项指定将签名结果存放到data.bin.signature - -sign选项指定签名使用的私钥Key.pem 这里data.bin.signature是如何生成的呢？ - 第1步，计算sha256的哈希值 - 第2步，对sha256哈希结果进行BER编码，并使用PKCS #1.5进行填充 - 第3步，使用私钥对第2步填充后的内容进行加密得到签名结果 下一节会对这个操作进行验证 1.6 公钥验证 使用公钥Key_pub.pem验证签名文件data.bin.signature： $ openssl dgst -sha256 -verify Key_pub.pem -signature data.bin.signature data.bin Verified OK 这里使用： - -verify选项指定用于验证签名的公钥文件 - -signature选项指定需要待验证的签名，此处指定待验证的签名文件时data.bin.signature文件 输出比较简单，只显示了验证结果为”Verified OK”。 根据上一节签名结果的生成过程，我们不妨反推下验证过程： - 第1步，使用公钥解密签名数据 - 第2步，对解密的签名数据去掉填充，得到BER编码后的格式 - 第3步，从BER编码中提取哈希数据 - 第4步，计算原始数据的sha256哈希，并同签名文件中得到的哈希进行比较 找遍了openssl的命令，就是没有找到如何使用公钥进行解密的~~ 我所知的OpenSSL跟解密相关的两个命令： - openssl rsautl -decrypt 需要指定私钥进行解密 - openssl enc -d 基于对称密钥进行解密，这里的非对称加解密显然不适合 哪位大神知道的请指点下，这里如何使用公钥解密签名数据？ 不过，OpenSSL提供了一个命令openssl rsautil -verify，该命令使用公钥验证签名，可以使用这个命令来达到解密签名数据的效果： - 解密原始的签名数据（使用BER编码，且带PKCS #1.5填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump -raw 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 31 30 .............010 00d0 - 0d 06 09 60 86 48 01 65-03 04 02 01 05 00 04 20 ...`.H.e....... 00e0 - 37 47 08 ff f7 71 9d d5-97 9e c8 75 d5 6c d2 28 7G...q.....u.l.( 00f0 - 6f 6d 3c f7 ec 31 7a 3b-25 63 2a ab 28 ec 37 bb om&lt;..1z;%c*.(.7. 解密原始的签名数据（BER编码，但不带填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump 0000 - 30 31 30 0d 06 09 60 86-48 01 65 03 04 02 01 05 010...`.H.e..... 0010 - 00 04 20 37 47 08 ff f7-71 9d d5 97 9e c8 75 d5 .. 7G...q.....u. 0020 - 6c d2 28 6f 6d 3c f7 ec-31 7a 3b 25 63 2a ab 28 l.(om&lt;..1z;%c*.( 0030 - ec 37 bb .7. 填充与不填充的区别在于-raw选项。 以上操作以签名结果data.bin.signature作为输入，并非使用原始数据data.bin作为输入。对比sha256的输出文件data.bin.sha256，解密结果的最后32个字节（对于填充输出，刚好是最后两行）就是原始数据的哈希，所以验证成功。 2. Python实现数字签名和验证 Python签名和验证操作复用OpenSSL生成的文件： - 私钥 Key.pem - 公钥 Key_pub.pem - 数据 data.bin 2.1 安装cryptography库 数字签名和验证基于Python3下的cryptograhpy库，所以需要预先安装： $ sudo pip3 install cryptography 由于cryptography依赖于cffi库，安装中可能会出错，此时只需要先安装libcffi-dev，再重新安装就好了。 $ sudo apt-get install libffi-dev 本文验证环境： $ python3 --version Python 3.4.3 $ pip3 list ... cryptography (1.9) ... cryptograhpy库的官方文档： https://cryptography.io/en/latest/ 2.2 私钥签名 rsa-sign.py使用指定的私钥Key.pem对数据文件data.bin进行签名，并将签名结果输出到文件signature.bin中，代码如下： # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding # 签名函数 def sign(data_file_name, signature_file_name, private_key_file_name): &quot;&quot;&quot; 签名函数使用指定的私钥Key对文件进行签名，并将签名结果写入文件中 :param data_file_name: 待签名的数据文件 :param signature_file_name: 存放签名结果的文件 :param private_key_file_name: 用于签名的私钥文件 :return: 签名数据 &quot;&quot;&quot; # 读取待签名数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 从PEM文件中读取私钥数据 key_file = open(private_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载私钥 private_key = serialization.load_pem_private_key( key_data, password=None, backend=default_backend() ) # 使用私钥对数据进行签名 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 signature = private_key.sign( data, padding.PKCS1v15(), hashes.SHA256() ) # 将签名数据写入结果文件中 signature_file = open(signature_file_name, &#39;wb&#39;) signature_file.write(signature) signature_file.close() # 返回签名数据 return signature if __name__ == &#39;__main__&#39;: # 指定数据文件 data_file = r&#39;data.bin&#39; # 指定签名结果文件 signature_file = r&#39;signature.bin&#39; # 指定签名的私钥 private_key_file = r&#39;Key.pem&#39; # 签名并返回签名结果 signature = sign(data_file, signature_file, private_key_file) # 打印签名数据 [print(&#39;%02x&#39; % x, end=&#39;&#39;) for x in signature] 运行，控制台会打印一长窜签名结果数据： $ python3 rsa-sign.py 7e590fb5b2d931f6af9534798dd85aa46902b929a9f51d006d8493698c65d3c99b6e524846c71ab27183c66e2ebb6ab0bbcf4816494d57f79be90ca6877b15cdf0efac3947ff819520eb6729f4bb90bba2f8775b1414e44126cc1acd7922de50d6c38cbc7968381d0c65fc217248a9974c55fc7e337b650cd9672c64013f815b501654127aeb96b826a21328688a6e7eb912ee493e515c43fffd5d3a905e5f2ff14e9373aa866f00e2b60ddc3ddd90dadf7be7ae152b550481afc316c636793b74637b72f1acc89f6fc04f4574363827732bc20b99ca58142b1e39d96d8b5de3054099ef0e47e8e0ecd4c6f6a350550e4a0050d380a06173383a98571511eb47 比较Python脚本生成的签名文件signature.bin和使用OpenSSL计算得到的结果： $ md5sum data.bin.signature signature.bin 2778de7c17b259d8d0a34538622e2338 data.bin.signature 2778de7c17b259d8d0a34538622e2338 signature.bin 二者的md5结果一致，说明其内容是一样的。 2.3 公钥验证 rsa-verify.py使用指定的公钥Key.pem对对上一节生成的签名文件signature.bin进行验证，代码如下： #!/usr/bin/env python3 # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding from cryptography.exceptions import InvalidSignature # 验证函数 def verify(data_file_name, signature_file_name, public_key_file_name): &quot;&quot;&quot; 验证函数使用指定的公钥对签名结果进行验证 :param data_file_name: 原始数据文件 :param signature_file_name: 签名验证文件 :param public_key_file_name: 用于验证的公钥文件 :return: 成功返回True, 失败返回False &quot;&quot;&quot; # 读取原始数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 读取待验证的签名数据 signature_file = open(signature_file_name, &#39;rb&#39;) signature = signature_file.read() signature_file.close() # 从PEM文件中读取公钥数据 key_file = open(public_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载公钥 public_key = serialization.load_pem_public_key( key_data, backend=default_backend() ) # 验证结果，默认为False verify_ok = False try: # 使用公钥对签名数据进行验证 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 public_key.verify( signature, data, padding.PKCS1v15(), hashes.SHA256() ) # 签名验证失败会触发名为InvalidSignature的exception except InvalidSignature: # 打印失败消息 print(&#39;invalid signature!&#39;) else: # 验证通过，设置True verify_ok = True # 返回验证结果 return verify_ok if __name__ == &#39;__main__&#39;: data_file = r&#39;data.bin&#39; signature_file = r&#39;signature.bin&#39; public_key_file = r&#39;Key_pub.pem&#39; verify_ok = verify(data_file, signature_file, public_key_file) if verify_ok: print(&#39;verify ok!&#39;) else: print(&#39;verify fail!&#39;) 运行脚本，对前一节生成的签名数据进行验证，控制台打印”verify ok!”： $ python3 rsa-verify.py verify ok! 2.4 源码下载 点击这里下载本文提到的Python源码：example-rsa-sign.tar.bz2 3. 联系和福利 关注微信公众号“洛奇看世界” 回复关键词“Android电子书”，获取超过150本Android相关的电子书和文档。电子书包含了Android开发相关的方方面面，从此你再也不需要到处找Android开发的电子书了。 个人微信号，添加请备注“微信公众号”。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为guyongqiangx原创，欢迎评论、转载和收藏。微信公众号：洛奇看世界。 https://blog.csdn.net/guyongqiangx/article/details/74454969 基于非对称算法的RSA Key主要有两个用途，数字签名和验证（私钥签名，公钥验证），以及非对称加解密（公钥加密，私钥解密）。本文提供一个基于OpenSSL命令行和Python的数字签名和验证过程的例子，另外会另起一篇使用OpenSSL和Python进行非对称加解密的例子。 1. OpenSSL实现数字签名和验证 1.1 生成私钥 生成2048 bit的PEM格式的RSA Key：Key.pem # 生成私钥文件Key.pem $ openssl genrsa -out Key.pem -f4 2048 Generating RSA private key, 2048 bit long modulus .+++ ...................................................................+++ e is 65537 (0x10001) # 查看私钥文件内容 $ cat Key.pem -----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAoZZKNO89UcDkEgdulOtAK0d9dQ0xfnpt4QNUg16ISeNuAFYv OeXn/ToGounX67+bkYpH92dXCnNpOsERLogenWQT533tsRU9KByeCz+PRgjc5cBn wAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjRSe7+h2sF7va3tGPn8cLpDUoLLk2e ugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkAoHI14hrz3xDssg0wlHqbptwsmwAQ 1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bPiFZJRFIqRRg0UNWkUBR+BJhWZ7Zc Dud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZRlQIDAQABAoIBABTN+uPx4Z1DDppb pps55tsrqzWE61hzfu43tYvsgfOxeppEfnQf68yoye3z2b8avnbwrO9nuMc5sNTF wuaQ1BBDsGRfzFi+eU9Oz/J2zoWf4oEaUsFfxjK5v1cgNz0ugfAVnP5Wwv+wmkGT aNinI7s3MEJTP0JTNbfeHSD9jXAOYhXH1M6/gq+TxLlsFISbQgmIbnDkDU/biXC+ b4r4/3xBieaeYOSV5s7pziXcxPmZCrWdcggtcxxJeDFtvQbSU4PXM7n7NgcsGQiX kwlHF3TiSQpQRuthV1ioW4FFFtwKw38mwzYcexem5Pyv353xSfb4vGg2+mcUEaf9 oNYYasECgYEA0tpP8th2L1zVT4eyumE5KE95iH4Nr6RWkQpfWQ84MDmiK7cNFeBL 0l4kwUo4oQeNEfDHYlxZ/guaflDLOKJ7DampMEuc+Dl8hmwXhdhqeQzxNRnaoDV1 iIyyHUs9c/9ormjTsycas2VfH1sPm3SrwH2rQe4ttkVBS8mcouNlg3kCgYEAxC+G qgsN+IifgVoeHIw2ak0MxTdt0LfGWcygx4hzXCpYrnqns080Z4vGDxClhqfdM9OJ 0Y6GkaNIHay/4bUIsBYFoV78vV80oQykHs6nwdJqLZJeQohBUlO2LlGzatPtWWuc v3N9W/OjSd3q6UgApmFT4+cMmEUZjB7QsHhau/0CgYBRotDdd02a3NiB6Eocu1PD 9bFaVWO7I2eY1GlCNBBPK6FMR507YRI6KtUUOUZfomrODWlE/fih0aBJU8K69L2r 9opY9o2Z1bgO237oBXiD0az6ID5zVP9ilQbJLL5oUPUYweFlNbiyyIbhvwH18GAn MQDDkBIGxh2X2EFbF6vQEQKBgHW5Bxe2dnWylfQqvXLn+CclgQo+zpi2DkIIdloF WSPvDTP1yffhCVMxHnIfzRPWWvgkccjbu4hc8INOC/5GgaYYMNy6gPKp1IznZvxN iYDW4HvkHsfRt1DNhr6YrA7oiL5lwrNne8vXkR5cGgBOAoXUVWCmXnpozIG2ZAfg 0KGJAoGANO46bePCNaVlP37hW3vjraW4gzKPS0xscG7pLnLrv+T628PnFS7j7D7a 6v6BBBSgBTFnuEOk2F4bfIRvE04m2S9vzg6Mt2aJHn6RQjQVZPZF+qFvrXxjzqRU 4R+06Hk2Zm2D3x/XJTu2QmzT1kqp6AtsnfOCz3M0a1oyd5eCVdk= -----END RSA PRIVATE KEY----- 1.2 导出公钥 从私钥导出公钥：Key_pub.pem # 从私钥导出公钥，很简单，使用参数-pubout就可以 $ openssl rsa -in Key.pem -pubout -out Key_pub.pem writing RSA key # 查看公钥文件内容 $ cat Key_pub.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoZZKNO89UcDkEgdulOtA K0d9dQ0xfnpt4QNUg16ISeNuAFYvOeXn/ToGounX67+bkYpH92dXCnNpOsERLoge nWQT533tsRU9KByeCz+PRgjc5cBnwAA6z+F7JFUkY3GAaZDe7dmSIES/FH+9YKjR Se7+h2sF7va3tGPn8cLpDUoLLk2eugWvmuWgEpCE6Wyed7UV3Vzdf2R+9oya9jkA oHI14hrz3xDssg0wlHqbptwsmwAQ1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bP iFZJRFIqRRg0UNWkUBR+BJhWZ7ZcDud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZR lQIDAQAB -----END PUBLIC KEY----- 1.3 准备签名数据 为了简单起见，生成16字节全0的数据作为测试文件：data.bin # 使用dd命令生成16字节的data.bin $ dd if=/dev/zero of=data.bin bs=1 count=16 16+0 records in 16+0 records out 16 bytes (16 B) copied, 0.000189593 s, 84.4 kB/s # 使用hexdump查看data.bin的内容，16个字节全都是0 $ hexdump -Cv data.bin 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010 1.4 计算sha256哈希 直接计算data.bin的sha256哈希值： # 调用openssl dgst计算sha256 $ openssl dgst -sha256 data.bin SHA256(data.bin)= 374708fff7719dd5979ec875d56cd2286f6d3cf7ec317a3b25632aab28ec37bb 也可以将data.bin的sha256哈希值存储到单独的文件：data.bin.sha256 # 将sha256结果输出到文件data.bin.sha256 $ openssl dgst -sha256 -binary -out data.bin.sha256 data.bin # 使用hexdump查看data.bin.sha256文件的内容 $ hexdump -Cv data.bin.sha256 00000000 37 47 08 ff f7 71 9d d5 97 9e c8 75 d5 6c d2 28 |7G...q.....u.l.(| 00000010 6f 6d 3c f7 ec 31 7a 3b 25 63 2a ab 28 ec 37 bb |om&lt;..1z;%c*.(.7.| 00000020 1.5 私钥签名 对数据data.bin使用私钥Key.pem进行签名，生成签名文件：data.bin.signature # 使用Key.pem对data.bin进行签名，并将签名结果输出到文件data.bin.signature $ openssl dgst -sha256 -out data.bin.signature -sign Key.pem data.bin # 使用hexdump查看签名结果文件data.bin.signature的内容 $ hexdump -Cv data.bin.signature 00000000 7e 59 0f b5 b2 d9 31 f6 af 95 34 79 8d d8 5a a4 |~Y....1...4y..Z.| 00000010 69 02 b9 29 a9 f5 1d 00 6d 84 93 69 8c 65 d3 c9 |i..)....m..i.e..| 00000020 9b 6e 52 48 46 c7 1a b2 71 83 c6 6e 2e bb 6a b0 |.nRHF...q..n..j.| 00000030 bb cf 48 16 49 4d 57 f7 9b e9 0c a6 87 7b 15 cd |..H.IMW......{..| 00000040 f0 ef ac 39 47 ff 81 95 20 eb 67 29 f4 bb 90 bb |...9G... .g)....| 00000050 a2 f8 77 5b 14 14 e4 41 26 cc 1a cd 79 22 de 50 |..w[...A&amp;...y&quot;.P| 00000060 d6 c3 8c bc 79 68 38 1d 0c 65 fc 21 72 48 a9 97 |....yh8..e.!rH..| 00000070 4c 55 fc 7e 33 7b 65 0c d9 67 2c 64 01 3f 81 5b |LU.~3{e..g,d.?.[| 00000080 50 16 54 12 7a eb 96 b8 26 a2 13 28 68 8a 6e 7e |P.T.z...&amp;..(h.n~| 00000090 b9 12 ee 49 3e 51 5c 43 ff fd 5d 3a 90 5e 5f 2f |...I&gt;Q\\C..]:.^_/| 000000a0 f1 4e 93 73 aa 86 6f 00 e2 b6 0d dc 3d dd 90 da |.N.s..o.....=...| 000000b0 df 7b e7 ae 15 2b 55 04 81 af c3 16 c6 36 79 3b |.{...+U......6y;| 000000c0 74 63 7b 72 f1 ac c8 9f 6f c0 4f 45 74 36 38 27 |tc{r....o.OEt68&#39;| 000000d0 73 2b c2 0b 99 ca 58 14 2b 1e 39 d9 6d 8b 5d e3 |s+....X.+.9.m.].| 000000e0 05 40 99 ef 0e 47 e8 e0 ec d4 c6 f6 a3 50 55 0e |.@...G.......PU.| 000000f0 4a 00 50 d3 80 a0 61 73 38 3a 98 57 15 11 eb 47 |J.P...as8:.W...G| 00000100 这里使用： - -out选项指定将签名结果存放到data.bin.signature - -sign选项指定签名使用的私钥Key.pem 这里data.bin.signature是如何生成的呢？ - 第1步，计算sha256的哈希值 - 第2步，对sha256哈希结果进行BER编码，并使用PKCS #1.5进行填充 - 第3步，使用私钥对第2步填充后的内容进行加密得到签名结果 下一节会对这个操作进行验证 1.6 公钥验证 使用公钥Key_pub.pem验证签名文件data.bin.signature： $ openssl dgst -sha256 -verify Key_pub.pem -signature data.bin.signature data.bin Verified OK 这里使用： - -verify选项指定用于验证签名的公钥文件 - -signature选项指定需要待验证的签名，此处指定待验证的签名文件时data.bin.signature文件 输出比较简单，只显示了验证结果为”Verified OK”。 根据上一节签名结果的生成过程，我们不妨反推下验证过程： - 第1步，使用公钥解密签名数据 - 第2步，对解密的签名数据去掉填充，得到BER编码后的格式 - 第3步，从BER编码中提取哈希数据 - 第4步，计算原始数据的sha256哈希，并同签名文件中得到的哈希进行比较 找遍了openssl的命令，就是没有找到如何使用公钥进行解密的~~ 我所知的OpenSSL跟解密相关的两个命令： - openssl rsautl -decrypt 需要指定私钥进行解密 - openssl enc -d 基于对称密钥进行解密，这里的非对称加解密显然不适合 哪位大神知道的请指点下，这里如何使用公钥解密签名数据？ 不过，OpenSSL提供了一个命令openssl rsautil -verify，该命令使用公钥验证签名，可以使用这个命令来达到解密签名数据的效果： - 解密原始的签名数据（使用BER编码，且带PKCS #1.5填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump -raw 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................ 00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 31 30 .............010 00d0 - 0d 06 09 60 86 48 01 65-03 04 02 01 05 00 04 20 ...`.H.e....... 00e0 - 37 47 08 ff f7 71 9d d5-97 9e c8 75 d5 6c d2 28 7G...q.....u.l.( 00f0 - 6f 6d 3c f7 ec 31 7a 3b-25 63 2a ab 28 ec 37 bb om&lt;..1z;%c*.(.7. 解密原始的签名数据（BER编码，但不带填充） $ openssl rsautl -in data.bin.signature -inkey Key_pub.pem -pubin -verify -hexdump 0000 - 30 31 30 0d 06 09 60 86-48 01 65 03 04 02 01 05 010...`.H.e..... 0010 - 00 04 20 37 47 08 ff f7-71 9d d5 97 9e c8 75 d5 .. 7G...q.....u. 0020 - 6c d2 28 6f 6d 3c f7 ec-31 7a 3b 25 63 2a ab 28 l.(om&lt;..1z;%c*.( 0030 - ec 37 bb .7. 填充与不填充的区别在于-raw选项。 以上操作以签名结果data.bin.signature作为输入，并非使用原始数据data.bin作为输入。对比sha256的输出文件data.bin.sha256，解密结果的最后32个字节（对于填充输出，刚好是最后两行）就是原始数据的哈希，所以验证成功。 2. Python实现数字签名和验证 Python签名和验证操作复用OpenSSL生成的文件： - 私钥 Key.pem - 公钥 Key_pub.pem - 数据 data.bin 2.1 安装cryptography库 数字签名和验证基于Python3下的cryptograhpy库，所以需要预先安装： $ sudo pip3 install cryptography 由于cryptography依赖于cffi库，安装中可能会出错，此时只需要先安装libcffi-dev，再重新安装就好了。 $ sudo apt-get install libffi-dev 本文验证环境： $ python3 --version Python 3.4.3 $ pip3 list ... cryptography (1.9) ... cryptograhpy库的官方文档： https://cryptography.io/en/latest/ 2.2 私钥签名 rsa-sign.py使用指定的私钥Key.pem对数据文件data.bin进行签名，并将签名结果输出到文件signature.bin中，代码如下： # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding # 签名函数 def sign(data_file_name, signature_file_name, private_key_file_name): &quot;&quot;&quot; 签名函数使用指定的私钥Key对文件进行签名，并将签名结果写入文件中 :param data_file_name: 待签名的数据文件 :param signature_file_name: 存放签名结果的文件 :param private_key_file_name: 用于签名的私钥文件 :return: 签名数据 &quot;&quot;&quot; # 读取待签名数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 从PEM文件中读取私钥数据 key_file = open(private_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载私钥 private_key = serialization.load_pem_private_key( key_data, password=None, backend=default_backend() ) # 使用私钥对数据进行签名 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 signature = private_key.sign( data, padding.PKCS1v15(), hashes.SHA256() ) # 将签名数据写入结果文件中 signature_file = open(signature_file_name, &#39;wb&#39;) signature_file.write(signature) signature_file.close() # 返回签名数据 return signature if __name__ == &#39;__main__&#39;: # 指定数据文件 data_file = r&#39;data.bin&#39; # 指定签名结果文件 signature_file = r&#39;signature.bin&#39; # 指定签名的私钥 private_key_file = r&#39;Key.pem&#39; # 签名并返回签名结果 signature = sign(data_file, signature_file, private_key_file) # 打印签名数据 [print(&#39;%02x&#39; % x, end=&#39;&#39;) for x in signature] 运行，控制台会打印一长窜签名结果数据： $ python3 rsa-sign.py 7e590fb5b2d931f6af9534798dd85aa46902b929a9f51d006d8493698c65d3c99b6e524846c71ab27183c66e2ebb6ab0bbcf4816494d57f79be90ca6877b15cdf0efac3947ff819520eb6729f4bb90bba2f8775b1414e44126cc1acd7922de50d6c38cbc7968381d0c65fc217248a9974c55fc7e337b650cd9672c64013f815b501654127aeb96b826a21328688a6e7eb912ee493e515c43fffd5d3a905e5f2ff14e9373aa866f00e2b60ddc3ddd90dadf7be7ae152b550481afc316c636793b74637b72f1acc89f6fc04f4574363827732bc20b99ca58142b1e39d96d8b5de3054099ef0e47e8e0ecd4c6f6a350550e4a0050d380a06173383a98571511eb47 比较Python脚本生成的签名文件signature.bin和使用OpenSSL计算得到的结果： $ md5sum data.bin.signature signature.bin 2778de7c17b259d8d0a34538622e2338 data.bin.signature 2778de7c17b259d8d0a34538622e2338 signature.bin 二者的md5结果一致，说明其内容是一样的。 2.3 公钥验证 rsa-verify.py使用指定的公钥Key.pem对对上一节生成的签名文件signature.bin进行验证，代码如下： #!/usr/bin/env python3 # 导入cryptography库的相关模块和函数 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding from cryptography.exceptions import InvalidSignature # 验证函数 def verify(data_file_name, signature_file_name, public_key_file_name): &quot;&quot;&quot; 验证函数使用指定的公钥对签名结果进行验证 :param data_file_name: 原始数据文件 :param signature_file_name: 签名验证文件 :param public_key_file_name: 用于验证的公钥文件 :return: 成功返回True, 失败返回False &quot;&quot;&quot; # 读取原始数据 data_file = open(data_file_name, &#39;rb&#39;) data = data_file.read() data_file.close() # 读取待验证的签名数据 signature_file = open(signature_file_name, &#39;rb&#39;) signature = signature_file.read() signature_file.close() # 从PEM文件中读取公钥数据 key_file = open(public_key_file_name, &#39;rb&#39;) key_data = key_file.read() key_file.close() # 从PEM文件数据中加载公钥 public_key = serialization.load_pem_public_key( key_data, backend=default_backend() ) # 验证结果，默认为False verify_ok = False try: # 使用公钥对签名数据进行验证 # 指定填充方式为PKCS1v15 # 指定hash方式为sha256 public_key.verify( signature, data, padding.PKCS1v15(), hashes.SHA256() ) # 签名验证失败会触发名为InvalidSignature的exception except InvalidSignature: # 打印失败消息 print(&#39;invalid signature!&#39;) else: # 验证通过，设置True verify_ok = True # 返回验证结果 return verify_ok if __name__ == &#39;__main__&#39;: data_file = r&#39;data.bin&#39; signature_file = r&#39;signature.bin&#39; public_key_file = r&#39;Key_pub.pem&#39; verify_ok = verify(data_file, signature_file, public_key_file) if verify_ok: print(&#39;verify ok!&#39;) else: print(&#39;verify fail!&#39;) 运行脚本，对前一节生成的签名数据进行验证，控制台打印”verify ok!”： $ python3 rsa-verify.py verify ok! 2.4 源码下载 点击这里下载本文提到的Python源码：example-rsa-sign.tar.bz2 3. 联系和福利 关注微信公众号“洛奇看世界” 回复关键词“Android电子书”，获取超过150本Android相关的电子书和文档。电子书包含了Android开发相关的方方面面，从此你再也不需要到处找Android开发的电子书了。 个人微信号，添加请备注“微信公众号”。 阅读更多","@type":"BlogPosting","url":"/2017/07/05/a2825bba973538f78609b0e7fe3b94a4.html","headline":"OpenSSL和Python实现RSA Key数字签名和验证","dateModified":"2017-07-05T00:00:00+08:00","datePublished":"2017-07-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/07/05/a2825bba973538f78609b0e7fe3b94a4.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>OpenSSL和Python实现RSA Key数字签名和验证</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为guyongqiangx原创，欢迎评论、转载和收藏。微信公众号：洛奇看世界。 https://blog.csdn.net/guyongqiangx/article/details/74454969 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>基于非对称算法的RSA Key主要有两个用途，数字签名和验证（私钥签名，公钥验证），以及非对称加解密（公钥加密，私钥解密）。本文提供一个基于OpenSSL命令行和Python的数字签名和验证过程的例子，另外会另起一篇使用OpenSSL和Python进行非对称加解密的例子。</p> 
  <h2 id="1-openssl实现数字签名和验证">1. OpenSSL实现数字签名和验证</h2> 
  <h3 id="11-生成私钥">1.1 生成私钥</h3> 
  <p>生成2048 bit的PEM格式的RSA Key：Key.pem</p> 
  <pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-preprocessor"># 生成私钥文件Key.pem</span>
$ openssl genrsa -out <span class="hljs-keyword">Key</span>.pem -f4 <span class="hljs-number">2048</span>
Generating RSA <span class="hljs-keyword">private</span> <span class="hljs-keyword">key</span>, <span class="hljs-number">2048</span> bit <span class="hljs-built_in">long</span> modulus
.+++
...................................................................+++
e <span class="hljs-keyword">is</span> <span class="hljs-number">65537</span> (<span class="hljs-number">0x10001</span>)
<span class="hljs-preprocessor"># 查看私钥文件内容</span>
$ cat <span class="hljs-keyword">Key</span>.pem 
-----BEGIN RSA <span class="hljs-keyword">PRIVATE</span> <span class="hljs-keyword">KEY</span>-----
MIIEogIBAAKCAQEAoZZKNO89UcDkEgdulOtAK0d9dQ0xfnpt4QNUg16ISeNuAFYv
OeXn/ToGounX67+bkYpH92dXCnNpOsERLogenWQT533tsRU9KByeCz+PRgjc5cBn
wAA6z+F7JFUkY3GAaZDe7dmSIES/FH+<span class="hljs-number">9</span>YKjRSe7+h2sF7va3tGPn8cLpDUoLLk2e
ugWvmuWgEpCE6Wyed7UV3Vzdf2R+<span class="hljs-number">9</span>oya9jkAoHI14hrz3xDssg0wlHqbptwsmwAQ
<span class="hljs-number">1</span>ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bPiFZJRFIqRRg0UNWkUBR+BJhWZ7Zc
Dud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZRlQIDAQABAoIBABTN+uPx4Z1DDppb
pps55tsrqzWE61hzfu43tYvsgfOxeppEfnQf68yoye3z2b8avnbwrO9nuMc5sNTF
wuaQ1BBDsGRfzFi+eU9Oz/J2zoWf4oEaUsFfxjK5v1cgNz0ugfAVnP5Wwv+wmkGT
aNinI7s3MEJTP0JTNbfeHSD9jXAOYhXH1M6/gq+TxLlsFISbQgmIbnDkDU/biXC+
b4r4/<span class="hljs-number">3</span>xBieaeYOSV5s7pziXcxPmZCrWdcggtcxxJeDFtvQbSU4PXM7n7NgcsGQiX
kwlHF3TiSQpQRuthV1ioW4FFFtwKw38mwzYcexem5Pyv353xSfb4vGg2+mcUEaf9
oNYYasECgYEA0tpP8th2L1zVT4eyumE5KE95iH4Nr6RWkQpfWQ84MDmiK7cNFeBL
<span class="hljs-number">0</span>l4kwUo4oQeNEfDHYlxZ/guaflDLOKJ7DampMEuc+Dl8hmwXhdhqeQzxNRnaoDV1
iIyyHUs9c/<span class="hljs-number">9</span>ormjTsycas2VfH1sPm3SrwH2rQe4ttkVBS8mcouNlg3kCgYEAxC+G
qgsN+IifgVoeHIw2ak0MxTdt0LfGWcygx4hzXCpYrnqns080Z4vGDxClhqfdM9OJ
<span class="hljs-number">0</span>Y6GkaNIHay/<span class="hljs-number">4</span>bUIsBYFoV78vV80oQykHs6nwdJqLZJeQohBUlO2LlGzatPtWWuc
v3N9W/OjSd3q6UgApmFT4+cMmEUZjB7QsHhau/<span class="hljs-number">0</span>CgYBRotDdd02a3NiB6Eocu1PD
<span class="hljs-number">9</span>bFaVWO7I2eY1GlCNBBPK6FMR507YRI6KtUUOUZfomrODWlE/fih0aBJU8K69L2r
<span class="hljs-number">9</span>opY9o2Z1bgO237oBXiD0az6ID5zVP9ilQbJLL5oUPUYweFlNbiyyIbhvwH18GAn
MQDDkBIGxh2X2EFbF6vQEQKBgHW5Bxe2dnWylfQqvXLn+CclgQo+zpi2DkIIdloF
WSPvDTP1yffhCVMxHnIfzRPWWvgkccjbu4hc8INOC/<span class="hljs-number">5</span>GgaYYMNy6gPKp1IznZvxN
iYDW4HvkHsfRt1DNhr6YrA7oiL5lwrNne8vXkR5cGgBOAoXUVWCmXnpozIG2ZAfg
<span class="hljs-number">0</span>KGJAoGANO46bePCNaVlP37hW3vjraW4gzKPS0xscG7pLnLrv+T628PnFS7j7D7a
<span class="hljs-number">6</span>v6BBBSgBTFnuEOk2F4bfIRvE04m2S9vzg6Mt2aJHn6RQjQVZPZF+qFvrXxjzqRU
<span class="hljs-number">4</span>R+<span class="hljs-number">06</span>Hk2Zm2D3x/XJTu2QmzT1kqp6AtsnfOCz3M0a1oyd5eCVdk=
-----<span class="hljs-keyword">END</span> RSA <span class="hljs-keyword">PRIVATE</span> <span class="hljs-keyword">KEY</span>-----</code></pre> 
  <h3 id="12-导出公钥">1.2 导出公钥</h3> 
  <p>从私钥导出公钥：Key_pub.pem</p> 
  <pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-preprocessor"># 从私钥导出公钥，很简单，使用参数-pubout就可以</span>
$ openssl rsa -<span class="hljs-keyword">in</span> <span class="hljs-keyword">Key</span>.pem -pubout -out Key_pub.pem
writing RSA <span class="hljs-keyword">key</span>
<span class="hljs-preprocessor"># 查看公钥文件内容</span>
$ cat Key_pub.pem 
-----BEGIN <span class="hljs-keyword">PUBLIC</span> <span class="hljs-keyword">KEY</span>-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoZZKNO89UcDkEgdulOtA
K0d9dQ0xfnpt4QNUg16ISeNuAFYvOeXn/ToGounX67+bkYpH92dXCnNpOsERLoge
nWQT533tsRU9KByeCz+PRgjc5cBnwAA6z+F7JFUkY3GAaZDe7dmSIES/FH+<span class="hljs-number">9</span>YKjR
Se7+h2sF7va3tGPn8cLpDUoLLk2eugWvmuWgEpCE6Wyed7UV3Vzdf2R+<span class="hljs-number">9</span>oya9jkA
oHI14hrz3xDssg0wlHqbptwsmwAQ1ZBDSB1MpqaLCaUvV8NvtSBLDsZlzwkOj7bP
iFZJRFIqRRg0UNWkUBR+BJhWZ7ZcDud2kJcH0mX8/rfthfFa5Oy38Iz8UQOW0uZR
lQIDAQAB
-----<span class="hljs-keyword">END</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-keyword">KEY</span>-----</code></pre> 
  <h3 id="13-准备签名数据">1.3 准备签名数据</h3> 
  <p>为了简单起见，生成16字节全0的数据作为测试文件：data.bin</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-preprocessor"># 使用dd命令生成16字节的data.bin</span>
$ dd <span class="hljs-keyword">if</span>=/dev/zero <span class="hljs-keyword">of</span>=<span class="hljs-typedef"><span class="hljs-keyword">data</span>.bin bs=1 count=16</span>
<span class="hljs-number">16</span>+<span class="hljs-number">0</span> records <span class="hljs-keyword">in</span>
<span class="hljs-number">16</span>+<span class="hljs-number">0</span> records out
<span class="hljs-number">16</span> bytes (<span class="hljs-number">16</span> <span class="hljs-type">B</span>) copied, <span class="hljs-number">0.000189593</span> s, <span class="hljs-number">84.4</span> kB/s
<span class="hljs-preprocessor"># 使用hexdump查看data.bin的内容，16个字节全都是0</span>
$ hexdump -<span class="hljs-type">Cv</span> <span class="hljs-typedef"><span class="hljs-keyword">data</span>.bin </span>
<span class="hljs-number">00000000</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  |................|
<span class="hljs-number">00000010</span></code></pre> 
  <h3 id="14-计算sha256哈希">1.4 计算sha256哈希</h3> 
  <p>直接计算data.bin的sha256哈希值：</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-preprocessor"># 调用openssl dgst计算sha256</span>
$ openssl dgst -sha256 <span class="hljs-typedef"><span class="hljs-keyword">data</span>.bin </span>
<span class="hljs-type">SHA256</span>(<span class="hljs-typedef"><span class="hljs-keyword">data</span>.bin)= 374708fff7719dd5979ec875d56cd2286f6d3cf7ec317a3b25632aab28ec37bb</span></code></pre> 
  <p>也可以将data.bin的sha256哈希值存储到单独的文件：data.bin.sha256</p> 
  <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor"># 将sha256结果输出到文件data.bin.sha256</span>
$ openssl dgst -sha256 -binary -<span class="hljs-keyword">out</span> data<span class="hljs-preprocessor">.bin</span><span class="hljs-preprocessor">.sha</span>256 data<span class="hljs-preprocessor">.bin</span>    
<span class="hljs-preprocessor"># 使用hexdump查看data.bin.sha256文件的内容</span>
$ hexdump -Cv data<span class="hljs-preprocessor">.bin</span><span class="hljs-preprocessor">.sha</span>256 
<span class="hljs-number">00000000</span>  <span class="hljs-number">37</span> <span class="hljs-number">47</span> <span class="hljs-number">08</span> ff f7 <span class="hljs-number">71</span> <span class="hljs-number">9</span>d d5  <span class="hljs-number">97</span> <span class="hljs-number">9</span>e c8 <span class="hljs-number">75</span> d5 <span class="hljs-number">6</span>c d2 <span class="hljs-number">28</span>  |<span class="hljs-number">7</span>G..<span class="hljs-preprocessor">.q</span>....<span class="hljs-preprocessor">.u</span><span class="hljs-preprocessor">.l</span>.(|
<span class="hljs-number">00000010</span>  <span class="hljs-number">6</span>f <span class="hljs-number">6</span>d <span class="hljs-number">3</span>c f7 ec <span class="hljs-number">31</span> <span class="hljs-number">7</span>a <span class="hljs-number">3</span>b  <span class="hljs-number">25</span> <span class="hljs-number">63</span> <span class="hljs-number">2</span>a ab <span class="hljs-number">28</span> ec <span class="hljs-number">37</span> bb  |om&lt;.<span class="hljs-number">.1</span><span class="hljs-built_in">z</span><span class="hljs-comment">;%c*.(.7.|</span>
<span class="hljs-number">00000020</span></code></pre> 
  <h3 id="15-私钥签名">1.5 私钥签名</h3> 
  <p>对数据data.bin使用私钥Key.pem进行签名，生成签名文件：data.bin.signature</p> 
  <pre class="prettyprint"><code class=" hljs 1c"><span class="hljs-preprocessor"># 使用Key.pem对data.bin进行签名，并将签名结果输出到文件data.bin.signature</span>
$ openssl dgst -sha256 -out data.bin.signature -sign Key.pem data.bin
<span class="hljs-preprocessor"># 使用hexdump查看签名结果文件data.bin.signature的内容</span>
$ hexdump -Cv data.bin.signature 
<span class="hljs-number">00000000</span>  <span class="hljs-number">7</span>e <span class="hljs-number">59</span> <span class="hljs-number">0</span>f b5 b2 d9 <span class="hljs-number">31</span> f6  af <span class="hljs-number">95</span> <span class="hljs-number">34</span> <span class="hljs-number">79</span> <span class="hljs-number">8</span>d d8 <span class="hljs-number">5</span>a a4  <span class="hljs-string">|~Y....1...4y..Z.|</span>
<span class="hljs-number">00000010</span>  <span class="hljs-number">69</span> <span class="hljs-number">02</span> b9 <span class="hljs-number">29</span> a9 f5 <span class="hljs-number">1</span>d <span class="hljs-number">00</span>  <span class="hljs-number">6</span>d <span class="hljs-number">84</span> <span class="hljs-number">93</span> <span class="hljs-number">69</span> <span class="hljs-number">8</span>c <span class="hljs-number">65</span> d3 c9  <span class="hljs-string">|i..)....m..i.e..|</span>
<span class="hljs-number">00000020</span>  <span class="hljs-number">9</span>b <span class="hljs-number">6</span>e <span class="hljs-number">52</span> <span class="hljs-number">48</span> <span class="hljs-number">46</span> c7 <span class="hljs-number">1</span>a b2  <span class="hljs-number">71</span> <span class="hljs-number">83</span> c6 <span class="hljs-number">6</span>e <span class="hljs-number">2</span>e bb <span class="hljs-number">6</span>a b0  <span class="hljs-string">|.nRHF...q..n..j.|</span>
<span class="hljs-number">00000030</span>  bb cf <span class="hljs-number">48</span> <span class="hljs-number">16</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span>d <span class="hljs-number">57</span> f7  <span class="hljs-number">9</span>b e9 <span class="hljs-number">0</span>c a6 <span class="hljs-number">87</span> <span class="hljs-number">7</span>b <span class="hljs-number">15</span> cd  <span class="hljs-string">|..H.IMW......{..|</span>
<span class="hljs-number">00000040</span>  f0 ef ac <span class="hljs-number">39</span> <span class="hljs-number">47</span> ff <span class="hljs-number">81</span> <span class="hljs-number">95</span>  <span class="hljs-number">20</span> eb <span class="hljs-number">67</span> <span class="hljs-number">29</span> f4 bb <span class="hljs-number">90</span> bb  <span class="hljs-string">|...9G... .g)....|</span>
<span class="hljs-number">00000050</span>  a2 f8 <span class="hljs-number">77</span> <span class="hljs-number">5</span>b <span class="hljs-number">14</span> <span class="hljs-number">14</span> e4 <span class="hljs-number">41</span>  <span class="hljs-number">26</span> cc <span class="hljs-number">1</span>a cd <span class="hljs-number">79</span> <span class="hljs-number">22</span> de <span class="hljs-number">50</span>  <span class="hljs-string">|..w[...A&amp;...y"</span>.P<span class="hljs-string">|</span>
<span class="hljs-number">00000060</span>  d6 c3 <span class="hljs-number">8</span>c bc <span class="hljs-number">79</span> <span class="hljs-number">68</span> <span class="hljs-number">38</span> <span class="hljs-number">1</span>d  <span class="hljs-number">0</span>c <span class="hljs-number">65</span> fc <span class="hljs-number">21</span> <span class="hljs-number">72</span> <span class="hljs-number">48</span> a9 <span class="hljs-number">97</span>  <span class="hljs-string">|....yh8..e.!rH..|</span>
<span class="hljs-number">00000070</span>  <span class="hljs-number">4</span>c <span class="hljs-number">55</span> fc <span class="hljs-number">7</span>e <span class="hljs-number">33</span> <span class="hljs-number">7</span>b <span class="hljs-number">65</span> <span class="hljs-number">0</span>c  d9 <span class="hljs-number">67</span> <span class="hljs-number">2</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">3</span>f <span class="hljs-number">81</span> <span class="hljs-number">5</span>b  <span class="hljs-string">|LU.~3{e..g,d.?.[|</span>
<span class="hljs-number">00000080</span>  <span class="hljs-number">50</span> <span class="hljs-number">16</span> <span class="hljs-number">54</span> <span class="hljs-number">12</span> <span class="hljs-number">7</span>a eb <span class="hljs-number">96</span> b8  <span class="hljs-number">26</span> a2 <span class="hljs-number">13</span> <span class="hljs-number">28</span> <span class="hljs-number">68</span> <span class="hljs-number">8</span>a <span class="hljs-number">6</span>e <span class="hljs-number">7</span>e  <span class="hljs-string">|P.T.z...&amp;..(h.n~|</span>
<span class="hljs-number">00000090</span>  b9 <span class="hljs-number">12</span> ee <span class="hljs-number">49</span> <span class="hljs-number">3</span>e <span class="hljs-number">51</span> <span class="hljs-number">5</span>c <span class="hljs-number">43</span>  ff fd <span class="hljs-number">5</span>d <span class="hljs-number">3</span>a <span class="hljs-number">90</span> <span class="hljs-number">5</span>e <span class="hljs-number">5</span>f <span class="hljs-number">2</span>f  <span class="hljs-string">|...I&gt;Q\C..]:.^_/|</span>
<span class="hljs-number">000000</span>a0  f1 <span class="hljs-number">4</span>e <span class="hljs-number">93</span> <span class="hljs-number">73</span> aa <span class="hljs-number">86</span> <span class="hljs-number">6</span>f <span class="hljs-number">00</span>  e2 b6 <span class="hljs-number">0</span>d dc <span class="hljs-number">3</span>d dd <span class="hljs-number">90</span> da  <span class="hljs-string">|.N.s..o.....=...|</span>
<span class="hljs-number">000000</span>b0  df <span class="hljs-number">7</span>b e7 ae <span class="hljs-number">15</span> <span class="hljs-number">2</span>b <span class="hljs-number">55</span> <span class="hljs-number">04</span>  <span class="hljs-number">81</span> af c3 <span class="hljs-number">16</span> c6 <span class="hljs-number">36</span> <span class="hljs-number">79</span> <span class="hljs-number">3</span>b  <span class="hljs-string">|.{...+U......6y;|</span>
<span class="hljs-number">000000</span>c0  <span class="hljs-number">74</span> <span class="hljs-number">63</span> <span class="hljs-number">7</span>b <span class="hljs-number">72</span> f1 ac c8 <span class="hljs-number">9</span>f  <span class="hljs-number">6</span>f c0 <span class="hljs-number">4</span>f <span class="hljs-number">45</span> <span class="hljs-number">74</span> <span class="hljs-number">36</span> <span class="hljs-number">38</span> <span class="hljs-number">27</span>  <span class="hljs-string">|tc{r....o.OEt68'|</span>
<span class="hljs-number">000000</span>d0  <span class="hljs-number">73</span> <span class="hljs-number">2</span>b c2 <span class="hljs-number">0</span>b <span class="hljs-number">99</span> ca <span class="hljs-number">58</span> <span class="hljs-number">14</span>  <span class="hljs-number">2</span>b <span class="hljs-number">1</span>e <span class="hljs-number">39</span> d9 <span class="hljs-number">6</span>d <span class="hljs-number">8</span>b <span class="hljs-number">5</span>d e3  <span class="hljs-string">|s+....X.+.9.m.].|</span>
<span class="hljs-number">000000</span>e0  <span class="hljs-number">05</span> <span class="hljs-number">40</span> <span class="hljs-number">99</span> ef <span class="hljs-number">0</span>e <span class="hljs-number">47</span> e8 e0  ec d4 c6 f6 a3 <span class="hljs-number">50</span> <span class="hljs-number">55</span> <span class="hljs-number">0</span>e  <span class="hljs-string">|.@...G.......PU.|</span>
<span class="hljs-number">000000</span>f0  <span class="hljs-number">4</span>a <span class="hljs-number">00</span> <span class="hljs-number">50</span> d3 <span class="hljs-number">80</span> a0 <span class="hljs-number">61</span> <span class="hljs-number">73</span>  <span class="hljs-number">38</span> <span class="hljs-number">3</span>a <span class="hljs-number">98</span> <span class="hljs-number">57</span> <span class="hljs-number">15</span> <span class="hljs-number">11</span> eb <span class="hljs-number">47</span>  <span class="hljs-string">|J.P...as8:.W...G|</span>
<span class="hljs-number">00000100</span></code></pre> 
  <p>这里使用： <br> - <code>-out</code>选项指定将签名结果存放到data.bin.signature <br> - <code>-sign</code>选项指定签名使用的私钥Key.pem</p> 
  <p>这里data.bin.signature是如何生成的呢？ <br> - 第1步，计算sha256的哈希值 <br> - 第2步，对sha256哈希结果进行BER编码，并使用PKCS #1.5进行填充 <br> - 第3步，使用私钥对第2步填充后的内容进行加密得到签名结果</p> 
  <p>下一节会对这个操作进行验证</p> 
  <h3 id="16-公钥验证">1.6 公钥验证</h3> 
  <p>使用公钥Key_pub.pem验证签名文件data.bin.signature：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ openssl dgst <span class="hljs-attribute">-sha256</span> <span class="hljs-attribute">-verify</span> Key_pub<span class="hljs-built_in">.</span>pem <span class="hljs-attribute">-signature</span> <span class="hljs-built_in">data</span><span class="hljs-built_in">.</span>bin<span class="hljs-built_in">.</span>signature <span class="hljs-built_in">data</span><span class="hljs-built_in">.</span>bin
Verified OK</code></pre> 
  <p>这里使用： <br> - <code>-verify</code>选项指定用于验证签名的公钥文件 <br> - <code>-signature</code>选项指定需要待验证的签名，此处指定待验证的签名文件时data.bin.signature文件</p> 
  <p>输出比较简单，只显示了验证结果为”Verified OK”。</p> 
  <p>根据上一节签名结果的生成过程，我们不妨反推下验证过程： <br> - 第1步，使用公钥解密签名数据 <br> - 第2步，对解密的签名数据去掉填充，得到BER编码后的格式 <br> - 第3步，从BER编码中提取哈希数据 <br> - 第4步，计算原始数据的sha256哈希，并同签名文件中得到的哈希进行比较</p> 
  <p>找遍了<code>openssl</code>的命令，就是没有找到如何使用公钥进行解密的~~ <br> 我所知的OpenSSL跟解密相关的两个命令： <br> - <code>openssl rsautl -decrypt</code> 需要指定私钥进行解密 <br> - <code>openssl enc -d</code> 基于对称密钥进行解密，这里的非对称加解密显然不适合</p> 
  <p>哪位大神知道的请指点下，这里如何使用公钥解密签名数据？</p> 
  <p>不过，OpenSSL提供了一个命令<code>openssl rsautil -verify</code>，该命令使用公钥验证签名，可以使用这个命令来达到解密签名数据的效果： <br> - 解密原始的签名数据（使用BER编码，且带PKCS #1.5填充）</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ openssl rsautl <span class="hljs-attribute">-in</span> <span class="hljs-built_in">data</span><span class="hljs-built_in">.</span>bin<span class="hljs-built_in">.</span>signature <span class="hljs-attribute">-inkey</span> Key_pub<span class="hljs-built_in">.</span>pem <span class="hljs-attribute">-pubin</span> <span class="hljs-attribute">-verify</span> <span class="hljs-attribute">-hexdump</span> <span class="hljs-attribute">-raw</span>
<span class="hljs-number">0000</span> <span class="hljs-subst">-</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0010</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0020</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0030</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0040</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0050</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0060</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0070</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0080</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">0090</span> <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">00</span>a0 <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">00</span>b0 <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff ff ff ff ff   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>
<span class="hljs-number">00</span>c0 <span class="hljs-subst">-</span> ff ff ff ff ff ff ff ff<span class="hljs-attribute">-ff</span> ff ff ff <span class="hljs-number">00</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span>   <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-attribute">...</span><span class="hljs-number">.010</span>
<span class="hljs-number">00</span>d0 <span class="hljs-subst">-</span> <span class="hljs-number">0</span>d <span class="hljs-number">06</span> <span class="hljs-number">09</span> <span class="hljs-number">60</span> <span class="hljs-number">86</span> <span class="hljs-number">48</span> <span class="hljs-number">01</span> <span class="hljs-number">65</span><span class="hljs-subst">-</span><span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">20</span>   <span class="hljs-attribute">...</span><span class="hljs-string">`.H.e....... 00e0 - 37 47 08 ff f7 71 9d d5-97 9e c8 75 d5 6c d2 28 7G...q.....u.l.( 00f0 - 6f 6d 3c f7 ec 31 7a 3b-25 63 2a ab 28 ec 37 bb om&lt;..1z;%c*.(.7.</span></code></pre> 
  <ul> 
   <li>解密原始的签名数据（BER编码，但不带填充）</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs avrasm">$ openssl rsautl -<span class="hljs-keyword">in</span> data<span class="hljs-preprocessor">.bin</span><span class="hljs-preprocessor">.signature</span> -inkey Key_pub<span class="hljs-preprocessor">.pem</span> -pubin -verify -hexdump
<span class="hljs-number">0000</span> - <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">0</span>d <span class="hljs-number">06</span> <span class="hljs-number">09</span> <span class="hljs-number">60</span> <span class="hljs-number">86</span>-<span class="hljs-number">48</span> <span class="hljs-number">01</span> <span class="hljs-number">65</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span>   <span class="hljs-number">010.</span>..`<span class="hljs-preprocessor">.H</span><span class="hljs-preprocessor">.e</span>.....
<span class="hljs-number">0010</span> - <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">20</span> <span class="hljs-number">37</span> <span class="hljs-number">47</span> <span class="hljs-number">08</span> ff f7-<span class="hljs-number">71</span> <span class="hljs-number">9</span>d d5 <span class="hljs-number">97</span> <span class="hljs-number">9</span>e c8 <span class="hljs-number">75</span> d5   .. <span class="hljs-number">7</span>G..<span class="hljs-preprocessor">.q</span>....<span class="hljs-preprocessor">.u</span>.
<span class="hljs-number">0020</span> - <span class="hljs-number">6</span>c d2 <span class="hljs-number">28</span> <span class="hljs-number">6</span>f <span class="hljs-number">6</span>d <span class="hljs-number">3</span>c f7 ec-<span class="hljs-number">31</span> <span class="hljs-number">7</span>a <span class="hljs-number">3</span>b <span class="hljs-number">25</span> <span class="hljs-number">63</span> <span class="hljs-number">2</span>a ab <span class="hljs-number">28</span>   l.(om&lt;.<span class="hljs-number">.1</span><span class="hljs-built_in">z</span><span class="hljs-comment">;%c*.(</span>
<span class="hljs-number">0030</span> - ec <span class="hljs-number">37</span> bb                                          <span class="hljs-number">.7</span>.</code></pre> 
  <p>填充与不填充的区别在于<code>-raw</code>选项。</p> 
  <p>以上操作以签名结果data.bin.signature作为输入，并非使用原始数据data.bin作为输入。对比sha256的输出文件data.bin.sha256，解密结果的最后32个字节（对于填充输出，刚好是最后两行）就是原始数据的哈希，所以验证成功。</p> 
  <h2 id="2-python实现数字签名和验证">2. Python实现数字签名和验证</h2> 
  <p>Python签名和验证操作复用OpenSSL生成的文件： <br> - 私钥 Key.pem <br> - 公钥 Key_pub.pem <br> - 数据 data.bin</p> 
  <h3 id="21-安装cryptography库">2.1 安装<code>cryptography</code>库</h3> 
  <p>数字签名和验证基于Python3下的<code>cryptograhpy</code>库，所以需要预先安装：</p> 
  <pre class="prettyprint"><code class=" hljs bash">$ <span class="hljs-built_in">sudo</span> pip3 install cryptography</code></pre> 
  <p>由于<code>cryptography</code>依赖于<code>cffi</code>库，安装中可能会出错，此时只需要先安装<code>libcffi-dev</code>，再重新安装就好了。</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ sudo apt<span class="hljs-attribute">-get</span> install libffi<span class="hljs-attribute">-dev</span></code></pre> 
  <blockquote> 
   <p>本文验证环境：</p> 
   <pre class="prettyprint"><code class=" hljs r">$ python3 --version
Python <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>
$ pip3 list
<span class="hljs-keyword">...</span>
cryptography (<span class="hljs-number">1.9</span>)
<span class="hljs-keyword">...</span></code></pre> 
   <p><code>cryptograhpy</code>库的官方文档： <a href="https://cryptography.io/en/latest/" rel="nofollow">https://cryptography.io/en/latest/</a></p> 
  </blockquote> 
  <h3 id="22-私钥签名">2.2 私钥签名</h3> 
  <p><code>rsa-sign.py</code>使用指定的私钥Key.pem对数据文件data.bin进行签名，并将签名结果输出到文件signature.bin中，代码如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">
<span class="hljs-comment"># 导入cryptography库的相关模块和函数</span>
<span class="hljs-keyword">from</span> cryptography.hazmat.backends <span class="hljs-keyword">import</span> default_backend
<span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> serialization

<span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> hashes
<span class="hljs-keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="hljs-keyword">import</span> padding


<span class="hljs-comment"># 签名函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign</span><span class="hljs-params">(data_file_name, signature_file_name, private_key_file_name)</span>:</span>
    <span class="hljs-string">""" 签名函数使用指定的私钥Key对文件进行签名，并将签名结果写入文件中 :param data_file_name: 待签名的数据文件 :param signature_file_name: 存放签名结果的文件 :param private_key_file_name: 用于签名的私钥文件 :return: 签名数据 """</span>

    <span class="hljs-comment"># 读取待签名数据</span>
    data_file = open(data_file_name, <span class="hljs-string">'rb'</span>)
    data = data_file.read()
    data_file.close()

    <span class="hljs-comment"># 从PEM文件中读取私钥数据</span>
    key_file = open(private_key_file_name, <span class="hljs-string">'rb'</span>)
    key_data = key_file.read()
    key_file.close()

    <span class="hljs-comment"># 从PEM文件数据中加载私钥</span>
    private_key = serialization.load_pem_private_key(
        key_data,
        password=<span class="hljs-keyword">None</span>,
        backend=default_backend()
    )

    <span class="hljs-comment"># 使用私钥对数据进行签名</span>
    <span class="hljs-comment"># 指定填充方式为PKCS1v15</span>
    <span class="hljs-comment"># 指定hash方式为sha256</span>
    signature = private_key.sign(
        data,
        padding.PKCS1v15(),
        hashes.SHA256()
    )

    <span class="hljs-comment"># 将签名数据写入结果文件中</span>
    signature_file = open(signature_file_name, <span class="hljs-string">'wb'</span>)
    signature_file.write(signature)
    signature_file.close()

    <span class="hljs-comment"># 返回签名数据</span>
    <span class="hljs-keyword">return</span> signature


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 指定数据文件</span>
    data_file = <span class="hljs-string">r'data.bin'</span>
    <span class="hljs-comment"># 指定签名结果文件</span>
    signature_file = <span class="hljs-string">r'signature.bin'</span>
    <span class="hljs-comment"># 指定签名的私钥</span>
    private_key_file = <span class="hljs-string">r'Key.pem'</span>

    <span class="hljs-comment"># 签名并返回签名结果</span>
    signature = sign(data_file, signature_file, private_key_file)
    <span class="hljs-comment"># 打印签名数据</span>
    [print(<span class="hljs-string">'%02x'</span> % x, end=<span class="hljs-string">''</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> signature]</code></pre> 
  <p>运行，控制台会打印一长窜签名结果数据：</p> 
  <pre class="prettyprint"><code class=" hljs bash">$ python3 rsa-sign.py 
<span class="hljs-number">7</span>e590fb5b2d931f6af9534798dd85aa46902b929a9f51d006d8493698c65d3c99b6e524846c71ab27183c66e2ebb6ab0bbcf4816494d57f79be90ca6877b15cdf0efac3947ff819520eb6729f4bb90bba2f8775b1414e44126cc1acd7922de50d6c38cbc7968381d0c65fc217248a9974c55fc7e337b650<span class="hljs-built_in">cd</span>9672c64013f815b501654127aeb96b826a21328688a6e7eb912ee493e515c43fffd5d3a905e5f2ff14e9373aa866f00e2b60ddc3ddd90dadf7be7ae152b550481afc316c636793b74637b72f1acc89f6fc04f4574363827732bc20b99ca58142b1e39d96d8b5de3054099ef0e47e8e0ecd4c6f6a350550e4a0050d380a06173383a98571511eb47</code></pre> 
  <p>比较Python脚本生成的签名文件signature.bin和使用OpenSSL计算得到的结果：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">$ md5sum data<span class="hljs-preprocessor">.bin</span><span class="hljs-preprocessor">.signature</span> signature<span class="hljs-preprocessor">.bin</span>           
<span class="hljs-number">2778</span>de7c17b259d8d0a34538622e2338  data<span class="hljs-preprocessor">.bin</span><span class="hljs-preprocessor">.signature</span>
<span class="hljs-number">2778</span>de7c17b259d8d0a34538622e2338  signature<span class="hljs-preprocessor">.bin</span></code></pre> 
  <p>二者的md5结果一致，说明其内容是一样的。</p> 
  <h3 id="23-公钥验证">2.3 公钥验证</h3> 
  <p><code>rsa-verify.py</code>使用指定的公钥Key.pem对对上一节生成的签名文件signature.bin进行验证，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-comment"># 导入cryptography库的相关模块和函数</span>
<span class="hljs-keyword">from</span> cryptography.hazmat.backends <span class="hljs-keyword">import</span> default_backend
<span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> serialization

<span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> hashes
<span class="hljs-keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="hljs-keyword">import</span> padding

<span class="hljs-keyword">from</span> cryptography.exceptions <span class="hljs-keyword">import</span> InvalidSignature

<span class="hljs-comment"># 验证函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify</span><span class="hljs-params">(data_file_name, signature_file_name, public_key_file_name)</span>:</span>
    <span class="hljs-string">""" 验证函数使用指定的公钥对签名结果进行验证 :param data_file_name: 原始数据文件 :param signature_file_name: 签名验证文件 :param public_key_file_name: 用于验证的公钥文件 :return: 成功返回True, 失败返回False """</span>

    <span class="hljs-comment"># 读取原始数据</span>
    data_file = open(data_file_name, <span class="hljs-string">'rb'</span>)
    data = data_file.read()
    data_file.close()

    <span class="hljs-comment"># 读取待验证的签名数据</span>
    signature_file = open(signature_file_name, <span class="hljs-string">'rb'</span>)
    signature = signature_file.read()
    signature_file.close()

    <span class="hljs-comment"># 从PEM文件中读取公钥数据</span>
    key_file = open(public_key_file_name, <span class="hljs-string">'rb'</span>)
    key_data = key_file.read()
    key_file.close()

    <span class="hljs-comment"># 从PEM文件数据中加载公钥</span>
    public_key = serialization.load_pem_public_key(
        key_data,
        backend=default_backend()
    )

    <span class="hljs-comment"># 验证结果，默认为False</span>
    verify_ok = <span class="hljs-keyword">False</span>

    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 使用公钥对签名数据进行验证</span>
        <span class="hljs-comment"># 指定填充方式为PKCS1v15</span>
        <span class="hljs-comment"># 指定hash方式为sha256</span>
        public_key.verify(
            signature,
            data,
            padding.PKCS1v15(),
            hashes.SHA256()
        )
    <span class="hljs-comment"># 签名验证失败会触发名为InvalidSignature的exception</span>
    <span class="hljs-keyword">except</span> InvalidSignature:
        <span class="hljs-comment"># 打印失败消息</span>
        print(<span class="hljs-string">'invalid signature!'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># 验证通过，设置True</span>
        verify_ok = <span class="hljs-keyword">True</span>

    <span class="hljs-comment"># 返回验证结果</span>
    <span class="hljs-keyword">return</span> verify_ok


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    data_file = <span class="hljs-string">r'data.bin'</span>
    signature_file = <span class="hljs-string">r'signature.bin'</span>
    public_key_file = <span class="hljs-string">r'Key_pub.pem'</span>

    verify_ok = verify(data_file, signature_file, public_key_file)
    <span class="hljs-keyword">if</span> verify_ok:
        print(<span class="hljs-string">'verify ok!'</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">'verify fail!'</span>)</code></pre> 
  <p>运行脚本，对前一节生成的签名数据进行验证，控制台打印”verify ok!”：</p> 
  <pre class="prettyprint"><code class=" hljs erlang-repl">$ <span class="hljs-function_or_atom">python3</span> <span class="hljs-function_or_atom">rsa</span>-<span class="hljs-function_or_atom">verify</span>.<span class="hljs-function_or_atom">py</span> 
<span class="hljs-function_or_atom">verify</span> <span class="hljs-ok">ok</span><span class="hljs-exclamation_mark">!</span></code></pre> 
  <h3 id="24-源码下载">2.4 源码下载</h3> 
  <p>点击这里下载本文提到的Python源码：<a href="https://github.com/guyongqiangx/blog/blob/dev/openssl/source/example-rsa-sign.tar.bz2?raw=true" rel="nofollow">example-rsa-sign.tar.bz2</a></p> 
  <h2 id="3-联系和福利">3. 联系和福利</h2> 
  <ul> 
   <li><p>关注微信公众号“洛奇看世界”</p> 
    <ul>
     <li>回复关键词“Android电子书”，获取超过150本Android相关的电子书和文档。电子书包含了Android开发相关的方方面面，从此你再也不需要到处找Android开发的电子书了。</li>
    </ul> <p><img src="https://github.com/guyongqiangx/blog/blob/dev/shell/images/qrcode-public-account.jpg?raw=true" alt="image" title=""></p></li> 
  </ul> 
  <hr> 
  <ul> 
   <li><p>个人微信号，添加请备注“微信公众号”。</p> <p><img src="https://github.com/guyongqiangx/blog/blob/dev/shell/images/qrcode-personal.jpg?raw=true" alt="image" title=""></p></li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/guyongqiangx/article/details/74454969,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/guyongqiangx/article/details/74454969,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
