<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Ubuntu下Geth客户端搭建私有网络集群 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Ubuntu下Geth客户端搭建私有网络集群" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本篇博客主要介绍一下在一台机器上建立多个节点，并且把节点连接在一起形成一个集群的方法笔记，以及配置时遇到的一些问题。 本文基于Ubuntu14.04 和 Geth 1.4.5-stable 建立一个私有节点时常用参数： --nodiscover 使用这个参数，你的节点就不会被其他人发现，除非手动添加你的节点。否则，就只有一个被无意添加到一个陌生区块链上的可能，那就是跟你有相同的genesis文件和networkID。 --maxpeers 0 如果你不想有人连上你的测试链，就用maxpeers 0。或者，你可以调整参数，当你确切的知道有几个节点要连接上来的时候。 --rpc 允许RPC操作你的节点。这个参数在Geth上是默认的。 --rpcapi &quot;db,eth,net,web3&quot; 这个命令指示了允许通过RPC访问的命令。默认情况下，Geth允许web3。 --rpcport &quot;8080&quot; --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; --datadir &quot;/home/etherTest&quot; 私有链存放路径（最好跟公有链路径不同） --port &quot;30303&quot; 网络监听端口，用来和其他节点手动连接 --identity “yooliee&quot; 用来标识你的节点的，方便在一大群节点中识别出自己的节点 --networkid 1990 你自己的私有网络的id号 --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; 指定可以远程访问你的节点的URL， 值为&quot;*&quot;时是指任何地方都可以远程访问（避免使用*） 本地建立多个节点 为了能在本地建立多个节点，你必须确保： 每个节点所在路径不同（–datadir的值不同） 每个节点运行在不同的端口上（包括eth和rpc) (–port和–rpcport不同） ipc端点是唯一的或者禁用ipc接口（–ipcpath唯一或者–ipcdisable 为了建立一个本地集群，除了上面几个参数值不同以外，必须确保–networkid相同，即节点是属于同一个网络；创世区块相同、集群中的节点必须知道彼此。本测试建立三个节点，然后三个节点彼此相连，形成一个集群。 首先，建立一个文件夹，用来存放三个节点： mkdir ether 所有节点的genesis.json文件必须相同： { &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;timestamp&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x0&quot;, &quot;gasLimit&quot;: &quot;0x80000000&quot;, &quot;difficulty&quot;: &quot;0x1&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;, &quot;alloc&quot;: { } } 建立第一个节点: # 在ether目录下创建第一个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 01 &amp;&amp; cd 01 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/01 init genesis.json # 此时01目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第一个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/01 --port &quot;30301&quot; --nodiscover --rpcport 8101 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/01/geth.log 此时第一个节点启动成功了，可以通过eth.getBlock(0)，查看创世区块信息，如下： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 通过admin.nodeInfo查看此节点的节点信息： &gt; admin.nodeInfo { enode: &quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;, id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, ip: &quot;::&quot;, listenAddr: &quot;[::]:30301&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, ports: { discovery: 0, listener: 30301 }, protocols: { eth: { difficulty: 13919423, genesis: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, head: &quot;0xdf1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, network: 1998 } } } 当连接同一个网络中的其他节点时，使用的就是上面的第一个字段enode的值，注意一下。 建立第二个节点 # 在ether目录下创建第二个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 02 &amp;&amp; cd 02 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/02 init genesis.json # 此时02目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第二个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/02 --port &quot;30302&quot; --nodiscover --rpcport 8102 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/02/geth.log 同样，第二个节点成功启动，可以通过eth.getBlock(0)查看区块信息： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 可以发现，02下的创世区块信息和01下的创世区块信息完全一样，因为是由同一个genesis.json生成，同一个网络中的创世区块也必须相同。 现在，已经创建好了两个节点，但是它们都还不知道彼此，两个节点是相对独立的存在。接下来，我们把两个节点连接起来： # 在02节点的控制台里通过admin.addPeer(enodeUrlOfFirstInstance)添加第一个节点的信息，使节点1和节点2相连。 &gt;admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) &gt; net.peerCount #检测有没有连接的节点 1 &gt; admin.peers #查看连在02节点上的节点信息，可以看见id就是之前的01节点的id [{ caps: [&quot;eth/61&quot;, &quot;eth/62&quot;, &quot;eth/63&quot;], id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, network: { localAddress: &quot;[::1]:36114&quot;, remoteAddress: &quot;[::1]:30301&quot; }, protocols: { eth: { difficulty: 13919423, head: &quot;df1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, version: 63 } } }] 同理，创建第三个节点 # 在ether目录下创建第三个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 03 &amp;&amp; cd 03 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/03 init genesis.json # 此时03目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第三个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/03 --port &quot;30303&quot; --nodiscover --rpcport 8103 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/03/geth.log 然后在启动的控制台里面添加第一个节点： &gt; admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) true &gt; net.peerCount 1 此时03节点添加了01节点，02节点添加了01节点，在01控制台中输入： &gt; net.peerCount 2 可以看见01节点现在有两个节点跟它相连。现在，三个节点相连，形成了一个小的集群，任意一个节点挖矿，挖到区块之后，都会同步到其他的两个节点。 以上是正确配置集群时用的方法，如果genesis.json文件不相同或者networkid不相同时，都不能添加成功。genesis.json不同，将会生成不一样的创世区块，networkid不同就是两个不同的网络，自然就不能添加成功。 在一台电脑上创建多个节点，然后把多个节点连接起来形成一个集群网络是成功的。但是，现在我想在Windows下，同样用geth客户端，同样的genesis.json文件，最后在控制台下查看创世区块时跟上面的一样，但是在添加节点时总是失败的，没有添加成功，不知道为什么（Windows下geth节点连接上面在Ubuntu下建立的集群）。哪位大神知道原因的帮忙的留个言，谢谢分享。 阅读更多" />
<meta property="og:description" content="本篇博客主要介绍一下在一台机器上建立多个节点，并且把节点连接在一起形成一个集群的方法笔记，以及配置时遇到的一些问题。 本文基于Ubuntu14.04 和 Geth 1.4.5-stable 建立一个私有节点时常用参数： --nodiscover 使用这个参数，你的节点就不会被其他人发现，除非手动添加你的节点。否则，就只有一个被无意添加到一个陌生区块链上的可能，那就是跟你有相同的genesis文件和networkID。 --maxpeers 0 如果你不想有人连上你的测试链，就用maxpeers 0。或者，你可以调整参数，当你确切的知道有几个节点要连接上来的时候。 --rpc 允许RPC操作你的节点。这个参数在Geth上是默认的。 --rpcapi &quot;db,eth,net,web3&quot; 这个命令指示了允许通过RPC访问的命令。默认情况下，Geth允许web3。 --rpcport &quot;8080&quot; --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; --datadir &quot;/home/etherTest&quot; 私有链存放路径（最好跟公有链路径不同） --port &quot;30303&quot; 网络监听端口，用来和其他节点手动连接 --identity “yooliee&quot; 用来标识你的节点的，方便在一大群节点中识别出自己的节点 --networkid 1990 你自己的私有网络的id号 --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; 指定可以远程访问你的节点的URL， 值为&quot;*&quot;时是指任何地方都可以远程访问（避免使用*） 本地建立多个节点 为了能在本地建立多个节点，你必须确保： 每个节点所在路径不同（–datadir的值不同） 每个节点运行在不同的端口上（包括eth和rpc) (–port和–rpcport不同） ipc端点是唯一的或者禁用ipc接口（–ipcpath唯一或者–ipcdisable 为了建立一个本地集群，除了上面几个参数值不同以外，必须确保–networkid相同，即节点是属于同一个网络；创世区块相同、集群中的节点必须知道彼此。本测试建立三个节点，然后三个节点彼此相连，形成一个集群。 首先，建立一个文件夹，用来存放三个节点： mkdir ether 所有节点的genesis.json文件必须相同： { &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;timestamp&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x0&quot;, &quot;gasLimit&quot;: &quot;0x80000000&quot;, &quot;difficulty&quot;: &quot;0x1&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;, &quot;alloc&quot;: { } } 建立第一个节点: # 在ether目录下创建第一个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 01 &amp;&amp; cd 01 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/01 init genesis.json # 此时01目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第一个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/01 --port &quot;30301&quot; --nodiscover --rpcport 8101 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/01/geth.log 此时第一个节点启动成功了，可以通过eth.getBlock(0)，查看创世区块信息，如下： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 通过admin.nodeInfo查看此节点的节点信息： &gt; admin.nodeInfo { enode: &quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;, id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, ip: &quot;::&quot;, listenAddr: &quot;[::]:30301&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, ports: { discovery: 0, listener: 30301 }, protocols: { eth: { difficulty: 13919423, genesis: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, head: &quot;0xdf1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, network: 1998 } } } 当连接同一个网络中的其他节点时，使用的就是上面的第一个字段enode的值，注意一下。 建立第二个节点 # 在ether目录下创建第二个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 02 &amp;&amp; cd 02 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/02 init genesis.json # 此时02目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第二个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/02 --port &quot;30302&quot; --nodiscover --rpcport 8102 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/02/geth.log 同样，第二个节点成功启动，可以通过eth.getBlock(0)查看区块信息： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 可以发现，02下的创世区块信息和01下的创世区块信息完全一样，因为是由同一个genesis.json生成，同一个网络中的创世区块也必须相同。 现在，已经创建好了两个节点，但是它们都还不知道彼此，两个节点是相对独立的存在。接下来，我们把两个节点连接起来： # 在02节点的控制台里通过admin.addPeer(enodeUrlOfFirstInstance)添加第一个节点的信息，使节点1和节点2相连。 &gt;admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) &gt; net.peerCount #检测有没有连接的节点 1 &gt; admin.peers #查看连在02节点上的节点信息，可以看见id就是之前的01节点的id [{ caps: [&quot;eth/61&quot;, &quot;eth/62&quot;, &quot;eth/63&quot;], id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, network: { localAddress: &quot;[::1]:36114&quot;, remoteAddress: &quot;[::1]:30301&quot; }, protocols: { eth: { difficulty: 13919423, head: &quot;df1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, version: 63 } } }] 同理，创建第三个节点 # 在ether目录下创建第三个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 03 &amp;&amp; cd 03 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/03 init genesis.json # 此时03目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第三个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/03 --port &quot;30303&quot; --nodiscover --rpcport 8103 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/03/geth.log 然后在启动的控制台里面添加第一个节点： &gt; admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) true &gt; net.peerCount 1 此时03节点添加了01节点，02节点添加了01节点，在01控制台中输入： &gt; net.peerCount 2 可以看见01节点现在有两个节点跟它相连。现在，三个节点相连，形成了一个小的集群，任意一个节点挖矿，挖到区块之后，都会同步到其他的两个节点。 以上是正确配置集群时用的方法，如果genesis.json文件不相同或者networkid不相同时，都不能添加成功。genesis.json不同，将会生成不一样的创世区块，networkid不同就是两个不同的网络，自然就不能添加成功。 在一台电脑上创建多个节点，然后把多个节点连接起来形成一个集群网络是成功的。但是，现在我想在Windows下，同样用geth客户端，同样的genesis.json文件，最后在控制台下查看创世区块时跟上面的一样，但是在添加节点时总是失败的，没有添加成功，不知道为什么（Windows下geth节点连接上面在Ubuntu下建立的集群）。哪位大神知道原因的帮忙的留个言，谢谢分享。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/07/18/1e63f8717ca492dc7d0060a70ba374c3.html" />
<meta property="og:url" content="https://mlh.app/2017/07/18/1e63f8717ca492dc7d0060a70ba374c3.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本篇博客主要介绍一下在一台机器上建立多个节点，并且把节点连接在一起形成一个集群的方法笔记，以及配置时遇到的一些问题。 本文基于Ubuntu14.04 和 Geth 1.4.5-stable 建立一个私有节点时常用参数： --nodiscover 使用这个参数，你的节点就不会被其他人发现，除非手动添加你的节点。否则，就只有一个被无意添加到一个陌生区块链上的可能，那就是跟你有相同的genesis文件和networkID。 --maxpeers 0 如果你不想有人连上你的测试链，就用maxpeers 0。或者，你可以调整参数，当你确切的知道有几个节点要连接上来的时候。 --rpc 允许RPC操作你的节点。这个参数在Geth上是默认的。 --rpcapi &quot;db,eth,net,web3&quot; 这个命令指示了允许通过RPC访问的命令。默认情况下，Geth允许web3。 --rpcport &quot;8080&quot; --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; --datadir &quot;/home/etherTest&quot; 私有链存放路径（最好跟公有链路径不同） --port &quot;30303&quot; 网络监听端口，用来和其他节点手动连接 --identity “yooliee&quot; 用来标识你的节点的，方便在一大群节点中识别出自己的节点 --networkid 1990 你自己的私有网络的id号 --rpccorsdomain &quot;http://chriseth.github.io/browser-solidity/&quot; 指定可以远程访问你的节点的URL， 值为&quot;*&quot;时是指任何地方都可以远程访问（避免使用*） 本地建立多个节点 为了能在本地建立多个节点，你必须确保： 每个节点所在路径不同（–datadir的值不同） 每个节点运行在不同的端口上（包括eth和rpc) (–port和–rpcport不同） ipc端点是唯一的或者禁用ipc接口（–ipcpath唯一或者–ipcdisable 为了建立一个本地集群，除了上面几个参数值不同以外，必须确保–networkid相同，即节点是属于同一个网络；创世区块相同、集群中的节点必须知道彼此。本测试建立三个节点，然后三个节点彼此相连，形成一个集群。 首先，建立一个文件夹，用来存放三个节点： mkdir ether 所有节点的genesis.json文件必须相同： { &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;timestamp&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x0&quot;, &quot;gasLimit&quot;: &quot;0x80000000&quot;, &quot;difficulty&quot;: &quot;0x1&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;, &quot;alloc&quot;: { } } 建立第一个节点: # 在ether目录下创建第一个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 01 &amp;&amp; cd 01 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/01 init genesis.json # 此时01目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第一个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/01 --port &quot;30301&quot; --nodiscover --rpcport 8101 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/01/geth.log 此时第一个节点启动成功了，可以通过eth.getBlock(0)，查看创世区块信息，如下： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 通过admin.nodeInfo查看此节点的节点信息： &gt; admin.nodeInfo { enode: &quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;, id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, ip: &quot;::&quot;, listenAddr: &quot;[::]:30301&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, ports: { discovery: 0, listener: 30301 }, protocols: { eth: { difficulty: 13919423, genesis: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, head: &quot;0xdf1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, network: 1998 } } } 当连接同一个网络中的其他节点时，使用的就是上面的第一个字段enode的值，注意一下。 建立第二个节点 # 在ether目录下创建第二个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 02 &amp;&amp; cd 02 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/02 init genesis.json # 此时02目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第二个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/02 --port &quot;30302&quot; --nodiscover --rpcport 8102 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/02/geth.log 同样，第二个节点成功启动，可以通过eth.getBlock(0)查看区块信息： &gt; eth.getBlock(0) { difficulty: 1, extraData: &quot;0x00&quot;, gasLimit: 2147483648, gasUsed: 0, hash: &quot;0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x3333333333333333333333333333333333333333&quot;, nonce: &quot;0x0000000000000042&quot;, number: 0, parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, receiptRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 505, stateRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, timestamp: 0, totalDifficulty: 1, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: [] } 可以发现，02下的创世区块信息和01下的创世区块信息完全一样，因为是由同一个genesis.json生成，同一个网络中的创世区块也必须相同。 现在，已经创建好了两个节点，但是它们都还不知道彼此，两个节点是相对独立的存在。接下来，我们把两个节点连接起来： # 在02节点的控制台里通过admin.addPeer(enodeUrlOfFirstInstance)添加第一个节点的信息，使节点1和节点2相连。 &gt;admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) &gt; net.peerCount #检测有没有连接的节点 1 &gt; admin.peers #查看连在02节点上的节点信息，可以看见id就是之前的01节点的id [{ caps: [&quot;eth/61&quot;, &quot;eth/62&quot;, &quot;eth/63&quot;], id: &quot;2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91&quot;, name: &quot;Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test&quot;, network: { localAddress: &quot;[::1]:36114&quot;, remoteAddress: &quot;[::1]:30301&quot; }, protocols: { eth: { difficulty: 13919423, head: &quot;df1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5&quot;, version: 63 } } }] 同理，创建第三个节点 # 在ether目录下创建第三个目录，然后把上面的genesis.json文件复制到此目录下 $ cd ether $ mkdir 03 &amp;&amp; cd 03 # 用genesis.json生成创世区块 $ geth --datadir ~/ether/03 init genesis.json # 此时03目录中生成了chaindata目录，里面就是存放区块链数据的地方 # 启动第三个节点 $ geth --identity &quot;test&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir ~/ether/03 --port &quot;30303&quot; --nodiscover --rpcport 8103 --rpcapi &quot;db,eth,net,web3&quot; --networkid 1998 console 2&gt;&gt; ~/ether/03/geth.log 然后在启动的控制台里面添加第一个节点： &gt; admin.addPeer(&quot;enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0&quot;) true &gt; net.peerCount 1 此时03节点添加了01节点，02节点添加了01节点，在01控制台中输入： &gt; net.peerCount 2 可以看见01节点现在有两个节点跟它相连。现在，三个节点相连，形成了一个小的集群，任意一个节点挖矿，挖到区块之后，都会同步到其他的两个节点。 以上是正确配置集群时用的方法，如果genesis.json文件不相同或者networkid不相同时，都不能添加成功。genesis.json不同，将会生成不一样的创世区块，networkid不同就是两个不同的网络，自然就不能添加成功。 在一台电脑上创建多个节点，然后把多个节点连接起来形成一个集群网络是成功的。但是，现在我想在Windows下，同样用geth客户端，同样的genesis.json文件，最后在控制台下查看创世区块时跟上面的一样，但是在添加节点时总是失败的，没有添加成功，不知道为什么（Windows下geth节点连接上面在Ubuntu下建立的集群）。哪位大神知道原因的帮忙的留个言，谢谢分享。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/07/18/1e63f8717ca492dc7d0060a70ba374c3.html","headline":"Ubuntu下Geth客户端搭建私有网络集群","dateModified":"2017-07-18T00:00:00+08:00","datePublished":"2017-07-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/07/18/1e63f8717ca492dc7d0060a70ba374c3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Ubuntu下Geth客户端搭建私有网络集群</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>本篇博客主要介绍一下在一台机器上建立多个节点，并且把节点连接在一起形成一个集群的方法笔记，以及配置时遇到的一些问题。 <br> 本文基于Ubuntu14.04 和 Geth 1.4.5-stable</p> 
  <h4 id="建立一个私有节点时常用参数">建立一个私有节点时常用参数：</h4> 
  <pre class="prettyprint"><code class=" hljs haml">-<span class="ruby">-nodiscover 使用这个参数，你的节点就不会被其他人发现，除非手动添加你的节点。否则，就只有一个被无意添加到一个陌生区块链上的可能，那就是跟你有相同的genesis文件和networkID。 </span>-<span class="ruby">-maxpeers <span class="hljs-number">0</span> 如果你不想有人连上你的测试链，就用maxpeers <span class="hljs-number">0</span>。或者，你可以调整参数，当你确切的知道有几个节点要连接上来的时候。 </span>-<span class="ruby">-rpc 允许<span class="hljs-constant">RPC</span>操作你的节点。这个参数在<span class="hljs-constant">Geth</span>上是默认的。 </span>-<span class="ruby">-rpcapi <span class="hljs-string">"db,eth,net,web3"</span> 这个命令指示了允许通过<span class="hljs-constant">RPC</span>访问的命令。默认情况下，<span class="hljs-constant">Geth</span>允许web3。 </span>-<span class="ruby">-rpcport <span class="hljs-string">"8080"</span> </span>-<span class="ruby">-rpccorsdomain <span class="hljs-string">"http://chriseth.github.io/browser-solidity/"</span> </span>-<span class="ruby">-datadir <span class="hljs-string">"/home/etherTest"</span> 私有链存放路径（最好跟公有链路径不同） </span>-<span class="ruby">-port <span class="hljs-string">"30303"</span> 网络监听端口，用来和其他节点手动连接 </span>-<span class="ruby">-identity “yooliee<span class="hljs-string">" 用来标识你的节点的，方便在一大群节点中识别出自己的节点 </span></span>-<span class="ruby">-networkid <span class="hljs-number">1990</span> 你自己的私有网络的id号 </span>-<span class="ruby">-rpccorsdomain <span class="hljs-string">"http://chriseth.github.io/browser-solidity/"</span> 指定可以远程访问你的节点的<span class="hljs-constant">URL</span>， 值为<span class="hljs-string">"*"</span>时是指任何地方都可以远程访问（避免使用*）</span></code></pre> 
  <h4 id="本地建立多个节点">本地建立多个节点</h4> 
  <p>为了能在本地建立多个节点，你必须确保：</p> 
  <ul> 
   <li>每个节点所在路径不同（–datadir的值不同）</li> 
   <li>每个节点运行在不同的端口上（包括eth和rpc) (–port和–rpcport不同）</li> 
   <li>ipc端点是唯一的或者禁用ipc接口（–ipcpath唯一或者–ipcdisable</li> 
  </ul> 
  <p>为了建立一个本地集群，除了上面几个参数值不同以外，必须确保–networkid相同，即节点是属于同一个网络；创世区块相同、集群中的节点必须知道彼此。本测试建立三个节点，然后三个节点彼此相连，形成一个集群。</p> 
  <p>首先，建立一个文件夹，用来存放三个节点：</p> 
  <pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">mkdir</span> ether</code></pre> 
  <p>所有节点的genesis.json文件必须相同：</p> 
  <pre class="prettyprint"><code class=" hljs json">{
  "<span class="hljs-attribute">nonce</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000042"</span></span>,
  "<span class="hljs-attribute">timestamp</span>": <span class="hljs-value"><span class="hljs-string">"0x0"</span></span>,
  "<span class="hljs-attribute">parentHash</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span></span>,
  "<span class="hljs-attribute">extraData</span>": <span class="hljs-value"><span class="hljs-string">"0x0"</span></span>,
  "<span class="hljs-attribute">gasLimit</span>": <span class="hljs-value"><span class="hljs-string">"0x80000000"</span></span>,
  "<span class="hljs-attribute">difficulty</span>": <span class="hljs-value"><span class="hljs-string">"0x1"</span></span>,
  "<span class="hljs-attribute">mixhash</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span></span>,
  "<span class="hljs-attribute">coinbase</span>": <span class="hljs-value"><span class="hljs-string">"0x3333333333333333333333333333333333333333"</span></span>,
  "<span class="hljs-attribute">alloc</span>": <span class="hljs-value">{ } </span>}</code></pre> 
  <h4 id="建立第一个节点">建立第一个节点:</h4> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-comment"># 在ether目录下创建第一个目录，然后把上面的genesis.json文件复制到此目录下</span>
<span class="hljs-variable">$ </span>cd ether
<span class="hljs-variable">$ </span>mkdir <span class="hljs-number">01</span> &amp;&amp; cd <span class="hljs-number">01</span>
<span class="hljs-comment"># 用genesis.json生成创世区块</span>
<span class="hljs-variable">$ </span>geth --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">01</span> init genesis.json
<span class="hljs-comment"># 此时01目录中生成了chaindata目录，里面就是存放区块链数据的地方</span>
<span class="hljs-comment"># 启动第一个节点</span>
<span class="hljs-variable">$ </span>geth --identity <span class="hljs-string">"test"</span> --rpc --rpccorsdomain <span class="hljs-string">"*"</span> --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">01</span> --port <span class="hljs-string">"30301"</span> --nodiscover --rpcport <span class="hljs-number">8101</span> --rpcapi <span class="hljs-string">"db,eth,net,web3"</span> --networkid <span class="hljs-number">1998</span> console <span class="hljs-number">2</span>&gt;&gt; ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">01</span>/geth.log</code></pre> 
  <p>此时第一个节点启动成功了，可以通过eth.getBlock(0)，查看创世区块信息，如下：</p> 
  <pre class="prettyprint"><code class=" hljs css">&gt; <span class="hljs-tag">eth</span><span class="hljs-class">.getBlock</span>(0)
<span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">difficulty</span>:<span class="hljs-value"> <span class="hljs-number">1</span>, extraData: <span class="hljs-string">"0x00"</span>, gasLimit: <span class="hljs-number">2147483648</span>, gasUsed: <span class="hljs-number">0</span>, hash: <span class="hljs-string">"0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624"</span>, logsBloom: <span class="hljs-string">"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</span>, miner: <span class="hljs-string">"0x3333333333333333333333333333333333333333"</span>, nonce: <span class="hljs-string">"0x0000000000000042"</span>, number: <span class="hljs-number">0</span>, parentHash: <span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>, receiptRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, sha3Uncles: <span class="hljs-string">"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"</span>, size: <span class="hljs-number">505</span>, stateRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, timestamp: <span class="hljs-number">0</span>, totalDifficulty: <span class="hljs-number">1</span>, transactions: [], transactionsRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, uncles: [] </span></span></span>}</code></pre> 
  <p>通过admin.nodeInfo查看此节点的节点信息：</p> 
  <pre class="prettyprint"><code class=" hljs css">&gt; <span class="hljs-tag">admin</span><span class="hljs-class">.nodeInfo</span>
<span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">enode</span>:<span class="hljs-value"> <span class="hljs-string">"enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0"</span>, id: <span class="hljs-string">"2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91"</span>, ip: <span class="hljs-string">"::"</span>, listenAddr: <span class="hljs-string">"[::]:30301"</span>, name: <span class="hljs-string">"Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test"</span>, ports: { discovery: <span class="hljs-number">0</span>, listener: <span class="hljs-number">30301</span> </span></span></span>},
  <span class="hljs-tag">protocols</span>: <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">eth</span>:<span class="hljs-value"> { difficulty: <span class="hljs-number">13919423</span>, genesis: <span class="hljs-string">"0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624"</span>, head: <span class="hljs-string">"0xdf1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5"</span>, network: <span class="hljs-number">1998</span> </span></span></span>}
  }
}</code></pre> 
  <p>当连接同一个网络中的其他节点时，使用的就是上面的第一个字段enode的值，注意一下。</p> 
  <h4 id="建立第二个节点">建立第二个节点</h4> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-comment"># 在ether目录下创建第二个目录，然后把上面的genesis.json文件复制到此目录下</span>
<span class="hljs-variable">$ </span>cd ether
<span class="hljs-variable">$ </span>mkdir <span class="hljs-number">02</span> &amp;&amp; cd <span class="hljs-number">02</span>
<span class="hljs-comment"># 用genesis.json生成创世区块</span>
<span class="hljs-variable">$ </span>geth --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">02</span> init genesis.json
<span class="hljs-comment"># 此时02目录中生成了chaindata目录，里面就是存放区块链数据的地方</span>
<span class="hljs-comment"># 启动第二个节点</span>
<span class="hljs-variable">$ </span>geth --identity <span class="hljs-string">"test"</span> --rpc --rpccorsdomain <span class="hljs-string">"*"</span> --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">02</span> --port <span class="hljs-string">"30302"</span> --nodiscover --rpcport <span class="hljs-number">8102</span> --rpcapi <span class="hljs-string">"db,eth,net,web3"</span> --networkid <span class="hljs-number">1998</span> console <span class="hljs-number">2</span>&gt;&gt; ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">02</span>/geth.log</code></pre> 
  <p>同样，第二个节点成功启动，可以通过eth.getBlock(0)查看区块信息：</p> 
  <pre class="prettyprint"><code class=" hljs css">&gt; <span class="hljs-tag">eth</span><span class="hljs-class">.getBlock</span>(0)
<span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">difficulty</span>:<span class="hljs-value"> <span class="hljs-number">1</span>, extraData: <span class="hljs-string">"0x00"</span>, gasLimit: <span class="hljs-number">2147483648</span>, gasUsed: <span class="hljs-number">0</span>, hash: <span class="hljs-string">"0x6099b65e564bd511f49e8f39ba27b6a68b6b78fd1481592257f06bbf93abe624"</span>, logsBloom: <span class="hljs-string">"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</span>, miner: <span class="hljs-string">"0x3333333333333333333333333333333333333333"</span>, nonce: <span class="hljs-string">"0x0000000000000042"</span>, number: <span class="hljs-number">0</span>, parentHash: <span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>, receiptRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, sha3Uncles: <span class="hljs-string">"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"</span>, size: <span class="hljs-number">505</span>, stateRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, timestamp: <span class="hljs-number">0</span>, totalDifficulty: <span class="hljs-number">1</span>, transactions: [], transactionsRoot: <span class="hljs-string">"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"</span>, uncles: [] </span></span></span>}</code></pre> 
  <p>可以发现，02下的创世区块信息和01下的创世区块信息完全一样，因为是由同一个genesis.json生成，同一个网络中的创世区块也必须相同。</p> 
  <p>现在，已经创建好了两个节点，但是它们都还不知道彼此，两个节点是相对独立的存在。接下来，我们把两个节点连接起来：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor"># 在02节点的控制台里通过admin.addPeer(enodeUrlOfFirstInstance)添加第一个节点的信息，使节点1和节点2相连。</span>
&gt;admin<span class="hljs-preprocessor">.addPeer</span>(<span class="hljs-string">"enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0"</span>)
&gt; net<span class="hljs-preprocessor">.peerCount</span>  <span class="hljs-preprocessor">#检测有没有连接的节点</span>
<span class="hljs-number">1</span>
&gt; admin<span class="hljs-preprocessor">.peers</span>   <span class="hljs-preprocessor">#查看连在02节点上的节点信息，可以看见id就是之前的01节点的id</span>
[{
    caps: [<span class="hljs-string">"eth/61"</span>, <span class="hljs-string">"eth/62"</span>, <span class="hljs-string">"eth/63"</span>],
    id: <span class="hljs-string">"2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91"</span>,
    name: <span class="hljs-string">"Geth/v1.4.5-stable-a269a713/linux/go1.4.2/test"</span>,
    network: {
      localAddress: <span class="hljs-string">"[::1]:36114"</span>,
      remoteAddress: <span class="hljs-string">"[::1]:30301"</span>
    },
    protocols: {
      eth: {
        difficulty: <span class="hljs-number">13919423</span>,
        head: <span class="hljs-string">"df1d69ee935ac6091eecf8a0f495f9dcdb644445feb265ea11f961ff9f5b45b5"</span>,
        version: <span class="hljs-number">63</span>
      }
    }
}]</code></pre> 
  <p>同理，创建第三个节点</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-comment"># 在ether目录下创建第三个目录，然后把上面的genesis.json文件复制到此目录下</span>
<span class="hljs-variable">$ </span>cd ether
<span class="hljs-variable">$ </span>mkdir <span class="hljs-number">03</span> &amp;&amp; cd <span class="hljs-number">03</span>
<span class="hljs-comment"># 用genesis.json生成创世区块</span>
<span class="hljs-variable">$ </span>geth --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">03</span> init genesis.json
<span class="hljs-comment"># 此时03目录中生成了chaindata目录，里面就是存放区块链数据的地方</span>
<span class="hljs-comment"># 启动第三个节点</span>
<span class="hljs-variable">$ </span>geth --identity <span class="hljs-string">"test"</span> --rpc --rpccorsdomain <span class="hljs-string">"*"</span> --datadir ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">03</span> --port <span class="hljs-string">"30303"</span> --nodiscover --rpcport <span class="hljs-number">8103</span> --rpcapi <span class="hljs-string">"db,eth,net,web3"</span> --networkid <span class="hljs-number">1998</span> console <span class="hljs-number">2</span>&gt;&gt; ~<span class="hljs-regexp">/ether/</span><span class="hljs-number">03</span>/geth.log</code></pre> 
  <p>然后在启动的控制台里面添加第一个节点：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">&gt; admin<span class="hljs-preprocessor">.addPeer</span>(<span class="hljs-string">"enode://2f86dbb18242371fa0a8e7098cb13a012ad9d8ee80f0bbba94a798b16d3c6c3c247d3e333b8da27a591b38365f927a25359376d4bf38575bb0371a1365294f91@[::]:30301?discport=0"</span>)
true
&gt; net<span class="hljs-preprocessor">.peerCount</span>
<span class="hljs-number">1</span></code></pre> 
  <p>此时03节点添加了01节点，02节点添加了01节点，在01控制台中输入：</p> 
  <pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-blockquote">&gt; net.peerCount</span>
2</code></pre> 
  <p>可以看见01节点现在有两个节点跟它相连。现在，三个节点相连，形成了一个小的集群，任意一个节点挖矿，挖到区块之后，都会同步到其他的两个节点。</p> 
  <p>以上是正确配置集群时用的方法，如果genesis.json文件不相同或者networkid不相同时，都不能添加成功。genesis.json不同，将会生成不一样的创世区块，networkid不同就是两个不同的网络，自然就不能添加成功。</p> 
  <p>在一台电脑上创建多个节点，然后把多个节点连接起来形成一个集群网络是成功的。但是，现在我想在Windows下，同样用geth客户端，同样的genesis.json文件，最后在控制台下查看创世区块时跟上面的一样，但是在添加节点时总是失败的，没有添加成功，不知道为什么（Windows下geth节点连接上面在Ubuntu下建立的集群）。哪位大神知道原因的帮忙的留个言，谢谢分享。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yooliee/article/details/75331002,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yooliee/article/details/75331002,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
