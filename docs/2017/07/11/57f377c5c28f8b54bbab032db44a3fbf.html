<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>POW-挖矿介绍-比特币 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="POW-挖矿介绍-比特币" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="通过SHA256算法 计算（挖矿）出最优值的矿机获得收益（例：比特币） SHA256是最开始的算法，后来不同的电子币使用不同的算法 需要以下参数 &nbsp;&nbsp;&nbsp; block的版本 version &nbsp;&nbsp;&nbsp; 上一个block的hash值: prev_hash &nbsp;&nbsp;&nbsp; 需要写入的交易记录的hash树的值: merkle_root &nbsp;&nbsp;&nbsp; 更新时间: ntime &nbsp;&nbsp;&nbsp; 当前难度: nbits 挖矿的过程就是找到x使得 SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET 上式的x的范围是0~2^32, TARGET可以根据当前难度求出的。除了x之外，你还可以尝试改动merkle_root和ntime。由于hash的特性，找这样一个x只能暴力搜索。 一旦你找到了x，你就可以广播一个新的block，其他客户端会验证你的block是否合法。如果你的block被接受，由于每个block中的第一笔交易必须是将新产生25个比特币发送到某个地址，当然你会把这个地址设为你所拥有的地址来得到这25个比特币。 --------------------------------------------------------------- 比特币从开始到现在的每一笔交易记录都保存在网络上，整个比特币网络维护的一个巨大的交易记录文件(随着交易增加会越来越大)。 这个文件的更新周期平均是10分钟，新加入的交易记录叫做一个block，而这个硕大的文件由一串block组成，叫做block chain. 为什么是25个比特币？ 这是规定。最初是50个比特币，每产生剩下比特币的一半，这个所得就会减半，这样最终能产生的比特币总量趋近于2100万。如果你现在仍然声称挖到了50个比特币，这是不会被其他客户端接受的，这个block就算白挖了。 怎么保证更新周期平均是10分钟？ TARGET越小，解出x的难度就越大，每产生2016个block(约14天)，网络会根据这段时间产生新block的平均间隔调整之后的TARGET。 是不是计算速度最快的人总是先解出来？ 不是。你总是想把挖矿所得据为己有，所以每个人在计算时，发送挖矿所得的地址是不一样的，这样merkle_root就不同，也就是说每个人是从不同的初始状态开始求解的。 同时解出来怎么办？ blockchain会出现分叉，部分客户端接受了A，部分接受了B，直到某个分支变得更长，所有人就会选择这个更长的分支。如果你挖出来的不幸没有被选中，你的挖矿所得就无效了。 既然选更长的分支，那我用很低的难度去求解怎么办？ 客户端在众多分支中找到符合当前难度且最长的。 这些计算浪费了吗？ 如果你要把一笔钱花两次，你需要这么做。挖到一个新的block，但是藏着不广播，并继续挖矿。找到商家A，支付比特币，让网络上的其他人挖到block并写入这笔交易记录。找到商家B，支付比特币，写入自己挖的block。如果你能抢先挖到两个block并广播出去，所有人会以你这个更长的分支为当前的block chain，商家A收到的比特币就不被承认了。这样攻击成功的概率取决于你计算hash的速度。整个网络的计算力足够高的话，这样的攻击或者成功率极低，或者成本极大。 从目前情况来看，单独找到比特币越来越不容易了，有些人甚至连续用计算机运行3年都没有挖到任何比特币。当然，你可以任由一台计算设备开着，不停的做运算，不停的挖矿。但问题是，你耗费的计算资源的成本可能会远远大于你挖掘到的比特币的价值。这样一来，通过“矿池”来协作挖矿看起来就是更理性的选择。你可以跟一群人分享“矿池”所挖到的比特币，然后支付一定的费用给矿池，然后再根据贡献的多少分配。协作挖矿方法分享如下： 1. 获得一个钱包 2. 加入一个集体挖矿地 要协作挖矿，就得加入一个已经有比特币矿山的集体挖矿地（Pool）。目前最著名的集体挖矿地有Slush’s Pool、 BTC Guild。这些集体挖矿地之间的区别是每个矿山的手续费和人数的不同，以Slush’s pool为例，这家的手续费为每矿山2%。通常人数多的挖矿聚集地的收费费较低。 但这其中存在一个问题：你无法监控集体挖矿地的经营者是否公平的分配得到的财产。 3. 下载挖矿程序 现在有很多挖矿的程序可以选择，同一些集体协作的计算项目一样，用GPU（显卡）来计算要比用CPU更快。 4. 收钱 下载好程序，进行挖矿运算后，就可以得到来自集体挖矿地运营者分配的比特币了。“理论上来说，我可以把挖到的25个比特币全部据为己有，但我不会这么做的。你可以选择相信，或者不相信，但到哪个集体挖矿地是你的自由选择。比特币就是这样的一种自由的产物。” 阅读更多" />
<meta property="og:description" content="通过SHA256算法 计算（挖矿）出最优值的矿机获得收益（例：比特币） SHA256是最开始的算法，后来不同的电子币使用不同的算法 需要以下参数 &nbsp;&nbsp;&nbsp; block的版本 version &nbsp;&nbsp;&nbsp; 上一个block的hash值: prev_hash &nbsp;&nbsp;&nbsp; 需要写入的交易记录的hash树的值: merkle_root &nbsp;&nbsp;&nbsp; 更新时间: ntime &nbsp;&nbsp;&nbsp; 当前难度: nbits 挖矿的过程就是找到x使得 SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET 上式的x的范围是0~2^32, TARGET可以根据当前难度求出的。除了x之外，你还可以尝试改动merkle_root和ntime。由于hash的特性，找这样一个x只能暴力搜索。 一旦你找到了x，你就可以广播一个新的block，其他客户端会验证你的block是否合法。如果你的block被接受，由于每个block中的第一笔交易必须是将新产生25个比特币发送到某个地址，当然你会把这个地址设为你所拥有的地址来得到这25个比特币。 --------------------------------------------------------------- 比特币从开始到现在的每一笔交易记录都保存在网络上，整个比特币网络维护的一个巨大的交易记录文件(随着交易增加会越来越大)。 这个文件的更新周期平均是10分钟，新加入的交易记录叫做一个block，而这个硕大的文件由一串block组成，叫做block chain. 为什么是25个比特币？ 这是规定。最初是50个比特币，每产生剩下比特币的一半，这个所得就会减半，这样最终能产生的比特币总量趋近于2100万。如果你现在仍然声称挖到了50个比特币，这是不会被其他客户端接受的，这个block就算白挖了。 怎么保证更新周期平均是10分钟？ TARGET越小，解出x的难度就越大，每产生2016个block(约14天)，网络会根据这段时间产生新block的平均间隔调整之后的TARGET。 是不是计算速度最快的人总是先解出来？ 不是。你总是想把挖矿所得据为己有，所以每个人在计算时，发送挖矿所得的地址是不一样的，这样merkle_root就不同，也就是说每个人是从不同的初始状态开始求解的。 同时解出来怎么办？ blockchain会出现分叉，部分客户端接受了A，部分接受了B，直到某个分支变得更长，所有人就会选择这个更长的分支。如果你挖出来的不幸没有被选中，你的挖矿所得就无效了。 既然选更长的分支，那我用很低的难度去求解怎么办？ 客户端在众多分支中找到符合当前难度且最长的。 这些计算浪费了吗？ 如果你要把一笔钱花两次，你需要这么做。挖到一个新的block，但是藏着不广播，并继续挖矿。找到商家A，支付比特币，让网络上的其他人挖到block并写入这笔交易记录。找到商家B，支付比特币，写入自己挖的block。如果你能抢先挖到两个block并广播出去，所有人会以你这个更长的分支为当前的block chain，商家A收到的比特币就不被承认了。这样攻击成功的概率取决于你计算hash的速度。整个网络的计算力足够高的话，这样的攻击或者成功率极低，或者成本极大。 从目前情况来看，单独找到比特币越来越不容易了，有些人甚至连续用计算机运行3年都没有挖到任何比特币。当然，你可以任由一台计算设备开着，不停的做运算，不停的挖矿。但问题是，你耗费的计算资源的成本可能会远远大于你挖掘到的比特币的价值。这样一来，通过“矿池”来协作挖矿看起来就是更理性的选择。你可以跟一群人分享“矿池”所挖到的比特币，然后支付一定的费用给矿池，然后再根据贡献的多少分配。协作挖矿方法分享如下： 1. 获得一个钱包 2. 加入一个集体挖矿地 要协作挖矿，就得加入一个已经有比特币矿山的集体挖矿地（Pool）。目前最著名的集体挖矿地有Slush’s Pool、 BTC Guild。这些集体挖矿地之间的区别是每个矿山的手续费和人数的不同，以Slush’s pool为例，这家的手续费为每矿山2%。通常人数多的挖矿聚集地的收费费较低。 但这其中存在一个问题：你无法监控集体挖矿地的经营者是否公平的分配得到的财产。 3. 下载挖矿程序 现在有很多挖矿的程序可以选择，同一些集体协作的计算项目一样，用GPU（显卡）来计算要比用CPU更快。 4. 收钱 下载好程序，进行挖矿运算后，就可以得到来自集体挖矿地运营者分配的比特币了。“理论上来说，我可以把挖到的25个比特币全部据为己有，但我不会这么做的。你可以选择相信，或者不相信，但到哪个集体挖矿地是你的自由选择。比特币就是这样的一种自由的产物。” 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/07/11/57f377c5c28f8b54bbab032db44a3fbf.html" />
<meta property="og:url" content="https://mlh.app/2017/07/11/57f377c5c28f8b54bbab032db44a3fbf.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"通过SHA256算法 计算（挖矿）出最优值的矿机获得收益（例：比特币） SHA256是最开始的算法，后来不同的电子币使用不同的算法 需要以下参数 &nbsp;&nbsp;&nbsp; block的版本 version &nbsp;&nbsp;&nbsp; 上一个block的hash值: prev_hash &nbsp;&nbsp;&nbsp; 需要写入的交易记录的hash树的值: merkle_root &nbsp;&nbsp;&nbsp; 更新时间: ntime &nbsp;&nbsp;&nbsp; 当前难度: nbits 挖矿的过程就是找到x使得 SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET 上式的x的范围是0~2^32, TARGET可以根据当前难度求出的。除了x之外，你还可以尝试改动merkle_root和ntime。由于hash的特性，找这样一个x只能暴力搜索。 一旦你找到了x，你就可以广播一个新的block，其他客户端会验证你的block是否合法。如果你的block被接受，由于每个block中的第一笔交易必须是将新产生25个比特币发送到某个地址，当然你会把这个地址设为你所拥有的地址来得到这25个比特币。 --------------------------------------------------------------- 比特币从开始到现在的每一笔交易记录都保存在网络上，整个比特币网络维护的一个巨大的交易记录文件(随着交易增加会越来越大)。 这个文件的更新周期平均是10分钟，新加入的交易记录叫做一个block，而这个硕大的文件由一串block组成，叫做block chain. 为什么是25个比特币？ 这是规定。最初是50个比特币，每产生剩下比特币的一半，这个所得就会减半，这样最终能产生的比特币总量趋近于2100万。如果你现在仍然声称挖到了50个比特币，这是不会被其他客户端接受的，这个block就算白挖了。 怎么保证更新周期平均是10分钟？ TARGET越小，解出x的难度就越大，每产生2016个block(约14天)，网络会根据这段时间产生新block的平均间隔调整之后的TARGET。 是不是计算速度最快的人总是先解出来？ 不是。你总是想把挖矿所得据为己有，所以每个人在计算时，发送挖矿所得的地址是不一样的，这样merkle_root就不同，也就是说每个人是从不同的初始状态开始求解的。 同时解出来怎么办？ blockchain会出现分叉，部分客户端接受了A，部分接受了B，直到某个分支变得更长，所有人就会选择这个更长的分支。如果你挖出来的不幸没有被选中，你的挖矿所得就无效了。 既然选更长的分支，那我用很低的难度去求解怎么办？ 客户端在众多分支中找到符合当前难度且最长的。 这些计算浪费了吗？ 如果你要把一笔钱花两次，你需要这么做。挖到一个新的block，但是藏着不广播，并继续挖矿。找到商家A，支付比特币，让网络上的其他人挖到block并写入这笔交易记录。找到商家B，支付比特币，写入自己挖的block。如果你能抢先挖到两个block并广播出去，所有人会以你这个更长的分支为当前的block chain，商家A收到的比特币就不被承认了。这样攻击成功的概率取决于你计算hash的速度。整个网络的计算力足够高的话，这样的攻击或者成功率极低，或者成本极大。 从目前情况来看，单独找到比特币越来越不容易了，有些人甚至连续用计算机运行3年都没有挖到任何比特币。当然，你可以任由一台计算设备开着，不停的做运算，不停的挖矿。但问题是，你耗费的计算资源的成本可能会远远大于你挖掘到的比特币的价值。这样一来，通过“矿池”来协作挖矿看起来就是更理性的选择。你可以跟一群人分享“矿池”所挖到的比特币，然后支付一定的费用给矿池，然后再根据贡献的多少分配。协作挖矿方法分享如下： 1. 获得一个钱包 2. 加入一个集体挖矿地 要协作挖矿，就得加入一个已经有比特币矿山的集体挖矿地（Pool）。目前最著名的集体挖矿地有Slush’s Pool、 BTC Guild。这些集体挖矿地之间的区别是每个矿山的手续费和人数的不同，以Slush’s pool为例，这家的手续费为每矿山2%。通常人数多的挖矿聚集地的收费费较低。 但这其中存在一个问题：你无法监控集体挖矿地的经营者是否公平的分配得到的财产。 3. 下载挖矿程序 现在有很多挖矿的程序可以选择，同一些集体协作的计算项目一样，用GPU（显卡）来计算要比用CPU更快。 4. 收钱 下载好程序，进行挖矿运算后，就可以得到来自集体挖矿地运营者分配的比特币了。“理论上来说，我可以把挖到的25个比特币全部据为己有，但我不会这么做的。你可以选择相信，或者不相信，但到哪个集体挖矿地是你的自由选择。比特币就是这样的一种自由的产物。” 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/07/11/57f377c5c28f8b54bbab032db44a3fbf.html","headline":"POW-挖矿介绍-比特币","dateModified":"2017-07-11T00:00:00+08:00","datePublished":"2017-07-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/07/11/57f377c5c28f8b54bbab032db44a3fbf.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>POW-挖矿介绍-比特币</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>通过SHA256算法 计算（挖矿）出最优值的矿机获得收益（例：比特币）<br></p> 
  <p>SHA256是最开始的算法，后来不同的电子币使用不同的算法</p> 
  <p><br></p> 
  <p>需要以下参数</p> &nbsp;&nbsp;&nbsp; block的版本 version
  <br> &nbsp;&nbsp;&nbsp; 上一个block的hash值: prev_hash
  <br> &nbsp;&nbsp;&nbsp; 需要写入的交易记录的hash树的值: merkle_root
  <br> &nbsp;&nbsp;&nbsp; 更新时间: ntime
  <br> &nbsp;&nbsp;&nbsp; 当前难度: nbits
  <br>
  <br> 挖矿的过程就是找到x使得
  <br> SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET
  <br>
  <br> 上式的x的范围是0~2^32, TARGET可以根据当前难度求出的。除了x之外，你还可以尝试改动merkle_root和ntime。由于hash的特性，找这样一个x只能暴力搜索。
  <br>
  <br> 一旦你找到了x，你就可以广播一个新的block，其他客户端会验证你的block是否合法。如果你的block被接受，由于每个block中的第一笔交易必须是将新产生25个比特币发送到某个地址，当然你会把这个地址设为你所拥有的地址来得到这25个比特币。
  <br>
  <br> ---------------------------------------------------------------
  <br>
  <br> 比特币从开始到现在的每一笔交易记录都保存在网络上，整个比特币网络维护的一个巨大的交易记录文件(随着交易增加会越来越大)。 这个文件的更新周期平均是10分钟，新加入的交易记录叫做一个block，而这个硕大的文件由一串block组成，叫做block chain.
  <br>
  <br> 为什么是25个比特币？
  <br> 这是规定。最初是50个比特币，每产生剩下比特币的一半，这个所得就会减半，这样最终能产生的比特币总量趋近于2100万。如果你现在仍然声称挖到了50个比特币，这是不会被其他客户端接受的，这个block就算白挖了。
  <br>
  <br> 怎么保证更新周期平均是10分钟？
  <br> TARGET越小，解出x的难度就越大，每产生2016个block(约14天)，网络会根据这段时间产生新block的平均间隔调整之后的TARGET。
  <br>
  <br> 是不是计算速度最快的人总是先解出来？
  <br> 不是。你总是想把挖矿所得据为己有，所以每个人在计算时，发送挖矿所得的地址是不一样的，这样merkle_root就不同，也就是说每个人是从不同的初始状态开始求解的。
  <br>
  <br> 同时解出来怎么办？
  <br> blockchain会出现分叉，部分客户端接受了A，部分接受了B，直到某个分支变得更长，所有人就会选择这个更长的分支。如果你挖出来的不幸没有被选中，你的挖矿所得就无效了。
  <br>
  <br> 既然选更长的分支，那我用很低的难度去求解怎么办？
  <br> 客户端在众多分支中找到符合当前难度且最长的。
  <br>
  <br> 这些计算浪费了吗？
  <br> 如果你要把一笔钱花两次，你需要这么做。挖到一个新的block，但是藏着不广播，并继续挖矿。找到商家A，支付比特币，让网络上的其他人挖到block并写入这笔交易记录。找到商家B，支付比特币，写入自己挖的block。如果你能抢先挖到两个block并广播出去，所有人会以你这个更长的分支为当前的block chain，商家A收到的比特币就不被承认了。这样攻击成功的概率取决于你计算hash的速度。整个网络的计算力足够高的话，这样的攻击或者成功率极低，或者成本极大。
  <br>
  <br> 从目前情况来看，单独找到比特币越来越不容易了，有些人甚至连续用计算机运行3年都没有挖到任何比特币。当然，你可以任由一台计算设备开着，不停的做运算，不停的挖矿。但问题是，你耗费的计算资源的成本可能会远远大于你挖掘到的比特币的价值。这样一来，通过“矿池”来协作挖矿看起来就是更理性的选择。你可以跟一群人分享“矿池”所挖到的比特币，然后支付一定的费用给矿池，然后再根据贡献的多少分配。协作挖矿方法分享如下：
  <br> 1. 获得一个钱包
  <br> 2. 加入一个集体挖矿地
  <br> 要协作挖矿，就得加入一个已经有比特币矿山的集体挖矿地（Pool）。目前最著名的集体挖矿地有Slush’s Pool、 BTC Guild。这些集体挖矿地之间的区别是每个矿山的手续费和人数的不同，以Slush’s pool为例，这家的手续费为每矿山2%。通常人数多的挖矿聚集地的收费费较低。
  <br> 但这其中存在一个问题：你无法监控集体挖矿地的经营者是否公平的分配得到的财产。
  <br> 3. 下载挖矿程序
  <br> 现在有很多挖矿的程序可以选择，同一些集体协作的计算项目一样，用GPU（显卡）来计算要比用CPU更快。
  <br> 4. 收钱
  <br> 下载好程序，进行挖矿运算后，就可以得到来自集体挖矿地运营者分配的比特币了。“理论上来说，我可以把挖到的25个比特币全部据为己有，但我不会这么做的。你可以选择相信，或者不相信，但到哪个集体挖矿地是你的自由选择。比特币就是这样的一种自由的产物。”
  <br>
  <br>
  <br>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/talent210/article/details/74942512,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/talent210/article/details/74942512,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
