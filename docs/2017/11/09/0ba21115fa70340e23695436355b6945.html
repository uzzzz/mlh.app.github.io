<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【比特币】BIP 0015 详细说明 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【比特币】BIP 0015 详细说明" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="BIP 0015 详细说明 BIP: 15 Layer: Applications Title: 别名 Author: Amir Taaki &lt;genjix@riseup.net&gt; Comments-Summary: No comments yet. Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0015 Status: Deferred Type: Standards Track Created: 2011-12-10 BIP 0070（付款协议）可以被视为替代别名。 使用香草比特币发送资金到目的地，需要一个1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ的地址。 使用地址的问题是他们不容易记住。 如果域名不存在，则需要输入他们喜欢的网站的IP地址。 这个文件的目的是通过仔细的参数来设计一个比特币别名系统。 这是对协议的一个很大的修改，在将来不容易改变，并且有很大的影响。 有第一次纠正的动力。 别名必须是稳健的，安全的。 计划 这里有一些不同的建议和各系统的性能。 FirstBits FirstBits是将区块链用作地址簿的建议。 当比特币被发送到地址时，该地址就会被记录在区块链中。 因此，知道这个地址存在或确实存在，只要看到有一个付款的地址。 FirstBits是一个具有令人难忘的别名的方法。 首先将地址转换为小写，然后取前几个唯一字符。 这是你的FirstBits别名。 举个例子，布拉格的brmlab hackerspace有一个购买食物或饮料或捐款的地址： 1BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX 他们的FirstBits别名变成： 1brmlab 这是足够的信息被给予FirstBits别名1brmlab。 当有人想要购买时，如果没有FirstBits，他们要么手工输入他们的地址，扫描他们的二维码（这需要一个手机，这个作者不拥有），或在互联网上找到他们的地址复制和 粘贴到客户端发送比特币。 FirstBits通过提供简单的付款方式来缓解这种不切实际的情况。 与Vanitygen（虚荣发生器）一起，可以创建令人难忘的唯一命名地址。 地址是有意义的，而不是一个奇怪的字母和数字组合，但添加上下文到目的地。 然而FirstBits有它自己的问题。 一个是可能产生的别名受可用计算能力的限制。 生成一个完整或精确的别名可能是不可行的 - 只有近似值才有可能。 这也是计算资源密集型的，这意味着未来产生独特的别名需要大量的能量消耗，并且在普适计算的环境中不能扩展到家中的个人或手持设备的参与者的水平。 随着网络的增长，FirstBits的规模将非常差。 每个索引器或查找节点需要跟踪每个存在的比特币地址，并提供从别名到这些地址的快速查找。 随着网络线性增长，地址数量应该呈指数增长（假设（n-1）*（n-2）/ 2）的网络效应）使得该方案不可行。 部分merkle根类型的轻客户端依赖于可信第三方的别名查找。 考虑到他们在低资源设备上的典型使用情况，存储每个比特币地址的成本太高。 这个因素多于其他因素，意味着这个方案是次优的，必须被拒绝。 DNS TXT 记录 DNS允许创建包含任意数据的TXT记录。 在比特币别名系统中，由BIP标准共同定义的自定义格式将被用于存储从域名到比特币地址的映射。 这样的格式看起来不在本文的范围之内。 一个问题是，它要求那些希望创建这种映射的人熟悉配置DNS记录，并且能够运行必要的工具集来插入正确的数据。 虽然不是一个大问题，但这是一个可用性问题。 安全方面，DNS是不安全和不安全的设计。 可以通过与另一个主机位于同一网络来欺骗记录。 自二十世纪九十年代以来，DNSSEC幌子下的一系列修改工作已经开始，目前仍在进行中。 截至2011年12月，DNSSEC在互联网上还没有达到事实标准。 如果比特币网络的参与者希望使用DNS TXT记录，则他们除了必须配置DNS之外，还能够设置DNSSEC。 这可能是不可行的，尤其是在一些注册商只通过网页界面访问DNS的情况下。 DNS TXT记录的缺点是更新记录需要时间。 这鼓励人们不要使用每个具有一定安全问题的交易的新地址。 服务器服务 除了使用DNS TXT记录，另一种可能性是使用域名系统查找主机，然后联系预定义的端口上运行的服务，以获得比特币地址。 用户希望发送到foo@bar.net 客户端使用DNS查找bar.net的IP地址：123.123.123.123 客户端连接到端口123.123.123.123:4567，并请求用户foo的比特币地址 服务器响应地址或错误代码并终止连接。 客户将资金发送到地址 该服务将负责提供更改和存储服务映射的机制。 可以为希望使用该服务并在服务器上定制其帐户的用户提供前端Web界面。 这种方法具有积极的作用，为实现者提供最好的灵活性，然后将它们存储在数据库或纯文本文件中，然后使用通常用C编写的小型服务器端守护进程快速提供这些记录。这种方法具有高度可扩展性。 但是，这种方法也面临着依赖于DNS的问题，因此也容易受到欺骗。 因此DNSSEC也是必需的。 这种方法比DNS TXT记录稍好，因为它使得插入新用户和修改别名非常容易，这使得人们可以更便宜地运行这些服务器服务。 HTTPS Web服务 HTTPS通过加密连接提供额外的安全层，为用户提供非常需要的隐私。 与使用证书颁发机构一起，它解决了使用DNSSEC的问题，因为会引发错误，有人试图欺骗本地网络上的域名。 当试图发送到： genjix@foo.org 这个请求在@的最后一个出现处被分解成句柄（genjix）和域（foo.org）。 客户端然后构造一个将查询地址的请求。 https://foo.org/bitcoin-alias/?handle=genjix 比特币别名已经被选为查询后缀，因为它允许这个系统在另一个web根目录中很容易共存，而不用担心名称冲突。 查询将返回一个用于付款的地址。 1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ 每个查询是否返回一个唯一的地址，是否从一个预先存在的地址池中获取一个地址，等等的细节是每个服务器唯一的实现细节。 设置映射映射的别名依赖于可能具有Web界面的站点，并向用户提供免费服务，或者是为预先存在的地址提供私人定制服务。 这是留给管理层的政策，故意不在这里定义。 一个Web服务是微不足道的安装和成本低。 网络上有许多免费的提供商，允许任何具有最基本的网络技术知识的人创建自己的网站。 通过为用户提供一个软件包，任何人都可以快速设置自己的比特币别名。 它可以像PHP脚本一样简单，用户可以使用自定义设置进行编辑并上传自己的网站。 它也可以合理扩展 - 任何希望运行命名服务的人都可以使用各种数据库技术来附加后端，然后为用户提供一个Web前端来自定义和创建自己的别名。 作为一个例子，下面提供了一个天真的实现。 // resolv.h #ifndef NOMRESOLV_H__ #define NOMRESOLV_H__ #include &lt;string&gt; #include &quot;curl/curl.h&quot; using std::string; /* 这个类解决了服务器查找地址。 为了不与比特币地址冲突，我们在这里指的是人的手柄。 一个句柄的形式是： genjix@foo.org 大多数字符对用户名+密码有效（并进行相应处理），但域遵循通常的Web标准。 如果需要，可以粘贴一条路径， genjix@bar.com/path/to/ */ class NameResolutionService { public: NameResolutionService(); ~NameResolutionService(); // Three main methods map to RPC actions. string FetchAddress(const string&amp; strHandle, string&amp; strAddy); private: // A POST block class PostVariables { public: PostVariables(); ~PostVariables(); // Add a new key, value pair bool Add(const string&amp; strKey, const string&amp; strVal); curl_httppost* operator()() const; private: // CURL stores POST blocks as linked lists. curl_httppost *pBegin, *pEnd; }; // Explodes user@domain =&gt; user, domain static void ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain); // Perform the HTTP request. Returns true on success. bool Perform(); // CURL error message char pErrorBuffer[CURL_ERROR_SIZE]; // CURL response string strBuffer; // CURL handle CURL *curl; }; #endif // resolv.cpp #include &quot;resolv.h&quot; #include &lt;boost/lexical_cast.hpp&gt; #include &quot;access.h&quot; // callback used to write response from the server static int writer(char *pData, size_t nSize, size_t nNmemb, std::string *pBuffer) { int nResult = 0; if (pBuffer != NULL) { pBuffer-&gt;append(pData, nSize * nNmemb); // How much did we write? nResult = nSize * nNmemb; } return nResult; } NameResolutionService::NameResolutionService() { // Initialise CURL with our various options. curl = curl_easy_init(); // This goes first in case of any problems below. We get an error message. curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer); // fail when server sends &gt;= 404 curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1); curl_easy_setopt(curl, CURLOPT_HEADER, 0); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); curl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1); // server response goes in strBuffer curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;strBuffer); pErrorBuffer[0] = &#39;\0&#39;; } NameResolutionService::~NameResolutionService() { curl_easy_cleanup(curl); } void NameResolutionService::ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain) { // split address at @ furthrest to the right size_t nPosAtsym = strHandle.rfind(&#39;@&#39;); strNickname = strHandle.substr(0, nPosAtsym); strDomain = strHandle.substr(nPosAtsym + 1, strHandle.size()); } bool NameResolutionService::Perform() { // Called after everything has been setup. This actually does the request. CURLcode result = curl_easy_perform(curl); return (result == CURLE_OK); } string NameResolutionService::FetchAddress(const string&amp; strHandle, string&amp; strAddy) { // GET is defined for &#39;getting&#39; data, so we use GET for the low risk fetching of people&#39;s addresses if (!curl) // For some reason CURL didn&#39;t start... return pErrorBuffer; // Expand the handle string strNickname, strDomain; ExplodeHandle(strHandle, strNickname, strDomain); // url encode the nickname for get request const char* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size()); if (!pszEncodedNick) return &quot;Unable to encode nickname.&quot;; // construct url for GET request string strRequestUrl = strDomain + &quot;/bitcoin-alias/?handle=&quot; + pszEncodedNick; // Pass URL to CURL curl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str()); if (!Perform()) return pErrorBuffer; // Server should respond with a JSON that has the address in. strAddy = strBuffer; return &quot;&quot;; // no error } NameResolutionService::PostVariables::PostVariables() { // pBegin/pEnd *must* be null before calling curl_formadd pBegin = NULL; pEnd = NULL; } NameResolutionService::PostVariables::~PostVariables() { curl_formfree(pBegin); } bool NameResolutionService::PostVariables::Add(const string&amp; strKey, const string&amp; strVal) { // Copy strings to this block. Return true on success. return curl_formadd(&amp;pBegin, &amp;pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK; } curl_httppost* NameResolutionService::PostVariables::operator()() const { return pBegin; } &lt;/source&gt; &lt;source lang=&quot;cpp&quot;&gt; // rpc.cpp ... const Object CheckMaybeThrow(const string&amp; strJsonIn) { // Parse input JSON Value valRequest; if (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type) throw JSONRPCError(-32700, &quot;Parse error&quot;); const Object&amp; request = valRequest.get_obj(); // Now check for a key called &quot;error&quot; const Value&amp; error = find_value(request, &quot;error&quot;); // It&#39;s an error JSON! so propagate the error. if (error.type() != null_type) throw JSONRPCError(-4, error.get_str()); // Return JSON object return request; } const string CollectAddress(const string&amp; strIn) { // If the handle does not have an @ in it, then it&#39;s a normal base58 bitcoin address if (strIn.find(&#39;@&#39;) == (size_t)-1) return strIn; // Open the lookup service NameResolutionService ns; // We established that the input string is not a BTC address, so we use it as a handle now. string strHandle = strIn, strAddy; string strError = ns.FetchAddress(strHandle, strAddy); if (!strError.empty()) throw JSONRPCError(-4, strError); const Object&amp; request(CheckMaybeThrow(strAddy)); // Get the BTC address from the JSON const Value&amp; address = find_value(request, &quot;address&quot;); if (address.type() != str_type) throw JSONRPCError(-32600, &quot;Server responded with malformed reply.&quot;); return address.get_str(); } // Named this way to prevent possible conflicts. Value rpc_send(const Array&amp; params, bool fHelp) { if (fHelp || params.size() != 2) throw runtime_error( &quot;send &lt;name@domain or address&gt; &lt;amount&gt;\n&quot; &quot;&lt;amount&gt; is a real and is rounded to the nearest 0.01&quot;); // Intelligent function which looks up address given handle, or returns address string strAddy = CollectAddress(params[0].get_str()); int64 nAmount = AmountFromValue(params[1]); // Do the send CWalletTx wtx; string strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx); if (!strError.empty()) throw JSONRPCError(-4, strError); return wtx.GetHash().GetHex(); } ... IP交易 一个IP交易是比特币中一个旧的交易格式，被禁用，可能会被弃用。 它涉及被给予一个IP地址付款。 当连接到节点并使用“checkorder”请求他们的公钥时，他们将用以下格式的脚本进行响应： &lt;public key&gt; OP_CHECKSIG 类似于coinbase输出交易。 IP事务具有能够包含额外的元数据的优点，这在许多事务中可能是有用的。 目前没有进行认证，使得该方案对中间人（MITM）攻击不安全。 此提案旨在为IP事务启用DNS查找。 “checkorder”消息将包含一个目标帐户，该目标帐户可映射到在同一主机下运行的不同的独立密钥对/钱包集。 从checkorder参考信息到本地系统的确切映射是实现定义的。 通过使用DNS查找，通过将公钥存储在DNS TXT记录中，可以缓解IP事务的MITM问题。 这个公钥将被用于所有将来从该主机发出的“回复”消息。 首次使用需要确认接受该公钥; 像SSH一样。 如果“回复”消息与接受的公钥不匹配，则主机将被给出错误。 Namecoin ID 此建议使用Namecoin区块链将别名与比特币地址相关联。 比特币查询名称币结点。 这将检索包含与该别名相关联的比特币地址的结构化数据。 使用像Namecoin这样的分散的域名系统，意味着不像这里列出的其他提案那样需要信任外部服务器或实体。 这表明系统具有高可用性和易于输入的优点（不限制用户创建别名）。 下面介绍两个例子。 第一个显示了一个更简单的格式，而第二个显示了几个比特币地址的结构化格式。 $ namecoind name_show id/khal { &quot;bitcoin&quot; : &quot;1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T&quot; } ``` $ namecoind name_show id/khal { “bitcoin” : { “default” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “donation”: “1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4” } } 更多可能性： - 允许安全使用不安全的渠道 你可以把一个网址和一个比特币地址，用来签署的结果。 这意味着对这个URL的查询将返回一个比特币地址和签名。 比特币然后可以检查（使用verify_message函数）返回的地址还没有被另一个替换。 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getnewaddres/“, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T” } } - 允许每次或每个用户获得不同的地址，每个订单等 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getaddres/{Your customer id}”, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “useOnce”: false } } “` 在上面的例子中，比特币会要求用户输入“Your customer id”，然后在发出http请求之前将该值替换为url。 商家将收到请求，并为用户提供与该客户相关的付款地址。 任何文字可以被放入括号，允许商家以使其适应他们的需求。 规范是可扩展的 可以稍后添加新功能来支持未发现的案例。 有关更多信息，请参阅Namecoin ID的规范。 总结 11年提出来的，现在被搁置，问题是比特币的地址太长，所以想通过别名的方式来解决。 原文档的连接已经失效了，但是内容还能谷歌出来。 参考资料 https://github.com/exploitagency/vanitygen-plus https://github.com/samr7/vanitygen https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh https://wiki.namecoin.org/index.php?title=Welcome 阅读更多" />
<meta property="og:description" content="BIP 0015 详细说明 BIP: 15 Layer: Applications Title: 别名 Author: Amir Taaki &lt;genjix@riseup.net&gt; Comments-Summary: No comments yet. Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0015 Status: Deferred Type: Standards Track Created: 2011-12-10 BIP 0070（付款协议）可以被视为替代别名。 使用香草比特币发送资金到目的地，需要一个1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ的地址。 使用地址的问题是他们不容易记住。 如果域名不存在，则需要输入他们喜欢的网站的IP地址。 这个文件的目的是通过仔细的参数来设计一个比特币别名系统。 这是对协议的一个很大的修改，在将来不容易改变，并且有很大的影响。 有第一次纠正的动力。 别名必须是稳健的，安全的。 计划 这里有一些不同的建议和各系统的性能。 FirstBits FirstBits是将区块链用作地址簿的建议。 当比特币被发送到地址时，该地址就会被记录在区块链中。 因此，知道这个地址存在或确实存在，只要看到有一个付款的地址。 FirstBits是一个具有令人难忘的别名的方法。 首先将地址转换为小写，然后取前几个唯一字符。 这是你的FirstBits别名。 举个例子，布拉格的brmlab hackerspace有一个购买食物或饮料或捐款的地址： 1BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX 他们的FirstBits别名变成： 1brmlab 这是足够的信息被给予FirstBits别名1brmlab。 当有人想要购买时，如果没有FirstBits，他们要么手工输入他们的地址，扫描他们的二维码（这需要一个手机，这个作者不拥有），或在互联网上找到他们的地址复制和 粘贴到客户端发送比特币。 FirstBits通过提供简单的付款方式来缓解这种不切实际的情况。 与Vanitygen（虚荣发生器）一起，可以创建令人难忘的唯一命名地址。 地址是有意义的，而不是一个奇怪的字母和数字组合，但添加上下文到目的地。 然而FirstBits有它自己的问题。 一个是可能产生的别名受可用计算能力的限制。 生成一个完整或精确的别名可能是不可行的 - 只有近似值才有可能。 这也是计算资源密集型的，这意味着未来产生独特的别名需要大量的能量消耗，并且在普适计算的环境中不能扩展到家中的个人或手持设备的参与者的水平。 随着网络的增长，FirstBits的规模将非常差。 每个索引器或查找节点需要跟踪每个存在的比特币地址，并提供从别名到这些地址的快速查找。 随着网络线性增长，地址数量应该呈指数增长（假设（n-1）*（n-2）/ 2）的网络效应）使得该方案不可行。 部分merkle根类型的轻客户端依赖于可信第三方的别名查找。 考虑到他们在低资源设备上的典型使用情况，存储每个比特币地址的成本太高。 这个因素多于其他因素，意味着这个方案是次优的，必须被拒绝。 DNS TXT 记录 DNS允许创建包含任意数据的TXT记录。 在比特币别名系统中，由BIP标准共同定义的自定义格式将被用于存储从域名到比特币地址的映射。 这样的格式看起来不在本文的范围之内。 一个问题是，它要求那些希望创建这种映射的人熟悉配置DNS记录，并且能够运行必要的工具集来插入正确的数据。 虽然不是一个大问题，但这是一个可用性问题。 安全方面，DNS是不安全和不安全的设计。 可以通过与另一个主机位于同一网络来欺骗记录。 自二十世纪九十年代以来，DNSSEC幌子下的一系列修改工作已经开始，目前仍在进行中。 截至2011年12月，DNSSEC在互联网上还没有达到事实标准。 如果比特币网络的参与者希望使用DNS TXT记录，则他们除了必须配置DNS之外，还能够设置DNSSEC。 这可能是不可行的，尤其是在一些注册商只通过网页界面访问DNS的情况下。 DNS TXT记录的缺点是更新记录需要时间。 这鼓励人们不要使用每个具有一定安全问题的交易的新地址。 服务器服务 除了使用DNS TXT记录，另一种可能性是使用域名系统查找主机，然后联系预定义的端口上运行的服务，以获得比特币地址。 用户希望发送到foo@bar.net 客户端使用DNS查找bar.net的IP地址：123.123.123.123 客户端连接到端口123.123.123.123:4567，并请求用户foo的比特币地址 服务器响应地址或错误代码并终止连接。 客户将资金发送到地址 该服务将负责提供更改和存储服务映射的机制。 可以为希望使用该服务并在服务器上定制其帐户的用户提供前端Web界面。 这种方法具有积极的作用，为实现者提供最好的灵活性，然后将它们存储在数据库或纯文本文件中，然后使用通常用C编写的小型服务器端守护进程快速提供这些记录。这种方法具有高度可扩展性。 但是，这种方法也面临着依赖于DNS的问题，因此也容易受到欺骗。 因此DNSSEC也是必需的。 这种方法比DNS TXT记录稍好，因为它使得插入新用户和修改别名非常容易，这使得人们可以更便宜地运行这些服务器服务。 HTTPS Web服务 HTTPS通过加密连接提供额外的安全层，为用户提供非常需要的隐私。 与使用证书颁发机构一起，它解决了使用DNSSEC的问题，因为会引发错误，有人试图欺骗本地网络上的域名。 当试图发送到： genjix@foo.org 这个请求在@的最后一个出现处被分解成句柄（genjix）和域（foo.org）。 客户端然后构造一个将查询地址的请求。 https://foo.org/bitcoin-alias/?handle=genjix 比特币别名已经被选为查询后缀，因为它允许这个系统在另一个web根目录中很容易共存，而不用担心名称冲突。 查询将返回一个用于付款的地址。 1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ 每个查询是否返回一个唯一的地址，是否从一个预先存在的地址池中获取一个地址，等等的细节是每个服务器唯一的实现细节。 设置映射映射的别名依赖于可能具有Web界面的站点，并向用户提供免费服务，或者是为预先存在的地址提供私人定制服务。 这是留给管理层的政策，故意不在这里定义。 一个Web服务是微不足道的安装和成本低。 网络上有许多免费的提供商，允许任何具有最基本的网络技术知识的人创建自己的网站。 通过为用户提供一个软件包，任何人都可以快速设置自己的比特币别名。 它可以像PHP脚本一样简单，用户可以使用自定义设置进行编辑并上传自己的网站。 它也可以合理扩展 - 任何希望运行命名服务的人都可以使用各种数据库技术来附加后端，然后为用户提供一个Web前端来自定义和创建自己的别名。 作为一个例子，下面提供了一个天真的实现。 // resolv.h #ifndef NOMRESOLV_H__ #define NOMRESOLV_H__ #include &lt;string&gt; #include &quot;curl/curl.h&quot; using std::string; /* 这个类解决了服务器查找地址。 为了不与比特币地址冲突，我们在这里指的是人的手柄。 一个句柄的形式是： genjix@foo.org 大多数字符对用户名+密码有效（并进行相应处理），但域遵循通常的Web标准。 如果需要，可以粘贴一条路径， genjix@bar.com/path/to/ */ class NameResolutionService { public: NameResolutionService(); ~NameResolutionService(); // Three main methods map to RPC actions. string FetchAddress(const string&amp; strHandle, string&amp; strAddy); private: // A POST block class PostVariables { public: PostVariables(); ~PostVariables(); // Add a new key, value pair bool Add(const string&amp; strKey, const string&amp; strVal); curl_httppost* operator()() const; private: // CURL stores POST blocks as linked lists. curl_httppost *pBegin, *pEnd; }; // Explodes user@domain =&gt; user, domain static void ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain); // Perform the HTTP request. Returns true on success. bool Perform(); // CURL error message char pErrorBuffer[CURL_ERROR_SIZE]; // CURL response string strBuffer; // CURL handle CURL *curl; }; #endif // resolv.cpp #include &quot;resolv.h&quot; #include &lt;boost/lexical_cast.hpp&gt; #include &quot;access.h&quot; // callback used to write response from the server static int writer(char *pData, size_t nSize, size_t nNmemb, std::string *pBuffer) { int nResult = 0; if (pBuffer != NULL) { pBuffer-&gt;append(pData, nSize * nNmemb); // How much did we write? nResult = nSize * nNmemb; } return nResult; } NameResolutionService::NameResolutionService() { // Initialise CURL with our various options. curl = curl_easy_init(); // This goes first in case of any problems below. We get an error message. curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer); // fail when server sends &gt;= 404 curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1); curl_easy_setopt(curl, CURLOPT_HEADER, 0); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); curl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1); // server response goes in strBuffer curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;strBuffer); pErrorBuffer[0] = &#39;\0&#39;; } NameResolutionService::~NameResolutionService() { curl_easy_cleanup(curl); } void NameResolutionService::ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain) { // split address at @ furthrest to the right size_t nPosAtsym = strHandle.rfind(&#39;@&#39;); strNickname = strHandle.substr(0, nPosAtsym); strDomain = strHandle.substr(nPosAtsym + 1, strHandle.size()); } bool NameResolutionService::Perform() { // Called after everything has been setup. This actually does the request. CURLcode result = curl_easy_perform(curl); return (result == CURLE_OK); } string NameResolutionService::FetchAddress(const string&amp; strHandle, string&amp; strAddy) { // GET is defined for &#39;getting&#39; data, so we use GET for the low risk fetching of people&#39;s addresses if (!curl) // For some reason CURL didn&#39;t start... return pErrorBuffer; // Expand the handle string strNickname, strDomain; ExplodeHandle(strHandle, strNickname, strDomain); // url encode the nickname for get request const char* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size()); if (!pszEncodedNick) return &quot;Unable to encode nickname.&quot;; // construct url for GET request string strRequestUrl = strDomain + &quot;/bitcoin-alias/?handle=&quot; + pszEncodedNick; // Pass URL to CURL curl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str()); if (!Perform()) return pErrorBuffer; // Server should respond with a JSON that has the address in. strAddy = strBuffer; return &quot;&quot;; // no error } NameResolutionService::PostVariables::PostVariables() { // pBegin/pEnd *must* be null before calling curl_formadd pBegin = NULL; pEnd = NULL; } NameResolutionService::PostVariables::~PostVariables() { curl_formfree(pBegin); } bool NameResolutionService::PostVariables::Add(const string&amp; strKey, const string&amp; strVal) { // Copy strings to this block. Return true on success. return curl_formadd(&amp;pBegin, &amp;pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK; } curl_httppost* NameResolutionService::PostVariables::operator()() const { return pBegin; } &lt;/source&gt; &lt;source lang=&quot;cpp&quot;&gt; // rpc.cpp ... const Object CheckMaybeThrow(const string&amp; strJsonIn) { // Parse input JSON Value valRequest; if (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type) throw JSONRPCError(-32700, &quot;Parse error&quot;); const Object&amp; request = valRequest.get_obj(); // Now check for a key called &quot;error&quot; const Value&amp; error = find_value(request, &quot;error&quot;); // It&#39;s an error JSON! so propagate the error. if (error.type() != null_type) throw JSONRPCError(-4, error.get_str()); // Return JSON object return request; } const string CollectAddress(const string&amp; strIn) { // If the handle does not have an @ in it, then it&#39;s a normal base58 bitcoin address if (strIn.find(&#39;@&#39;) == (size_t)-1) return strIn; // Open the lookup service NameResolutionService ns; // We established that the input string is not a BTC address, so we use it as a handle now. string strHandle = strIn, strAddy; string strError = ns.FetchAddress(strHandle, strAddy); if (!strError.empty()) throw JSONRPCError(-4, strError); const Object&amp; request(CheckMaybeThrow(strAddy)); // Get the BTC address from the JSON const Value&amp; address = find_value(request, &quot;address&quot;); if (address.type() != str_type) throw JSONRPCError(-32600, &quot;Server responded with malformed reply.&quot;); return address.get_str(); } // Named this way to prevent possible conflicts. Value rpc_send(const Array&amp; params, bool fHelp) { if (fHelp || params.size() != 2) throw runtime_error( &quot;send &lt;name@domain or address&gt; &lt;amount&gt;\n&quot; &quot;&lt;amount&gt; is a real and is rounded to the nearest 0.01&quot;); // Intelligent function which looks up address given handle, or returns address string strAddy = CollectAddress(params[0].get_str()); int64 nAmount = AmountFromValue(params[1]); // Do the send CWalletTx wtx; string strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx); if (!strError.empty()) throw JSONRPCError(-4, strError); return wtx.GetHash().GetHex(); } ... IP交易 一个IP交易是比特币中一个旧的交易格式，被禁用，可能会被弃用。 它涉及被给予一个IP地址付款。 当连接到节点并使用“checkorder”请求他们的公钥时，他们将用以下格式的脚本进行响应： &lt;public key&gt; OP_CHECKSIG 类似于coinbase输出交易。 IP事务具有能够包含额外的元数据的优点，这在许多事务中可能是有用的。 目前没有进行认证，使得该方案对中间人（MITM）攻击不安全。 此提案旨在为IP事务启用DNS查找。 “checkorder”消息将包含一个目标帐户，该目标帐户可映射到在同一主机下运行的不同的独立密钥对/钱包集。 从checkorder参考信息到本地系统的确切映射是实现定义的。 通过使用DNS查找，通过将公钥存储在DNS TXT记录中，可以缓解IP事务的MITM问题。 这个公钥将被用于所有将来从该主机发出的“回复”消息。 首次使用需要确认接受该公钥; 像SSH一样。 如果“回复”消息与接受的公钥不匹配，则主机将被给出错误。 Namecoin ID 此建议使用Namecoin区块链将别名与比特币地址相关联。 比特币查询名称币结点。 这将检索包含与该别名相关联的比特币地址的结构化数据。 使用像Namecoin这样的分散的域名系统，意味着不像这里列出的其他提案那样需要信任外部服务器或实体。 这表明系统具有高可用性和易于输入的优点（不限制用户创建别名）。 下面介绍两个例子。 第一个显示了一个更简单的格式，而第二个显示了几个比特币地址的结构化格式。 $ namecoind name_show id/khal { &quot;bitcoin&quot; : &quot;1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T&quot; } ``` $ namecoind name_show id/khal { “bitcoin” : { “default” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “donation”: “1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4” } } 更多可能性： - 允许安全使用不安全的渠道 你可以把一个网址和一个比特币地址，用来签署的结果。 这意味着对这个URL的查询将返回一个比特币地址和签名。 比特币然后可以检查（使用verify_message函数）返回的地址还没有被另一个替换。 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getnewaddres/“, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T” } } - 允许每次或每个用户获得不同的地址，每个订单等 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getaddres/{Your customer id}”, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “useOnce”: false } } “` 在上面的例子中，比特币会要求用户输入“Your customer id”，然后在发出http请求之前将该值替换为url。 商家将收到请求，并为用户提供与该客户相关的付款地址。 任何文字可以被放入括号，允许商家以使其适应他们的需求。 规范是可扩展的 可以稍后添加新功能来支持未发现的案例。 有关更多信息，请参阅Namecoin ID的规范。 总结 11年提出来的，现在被搁置，问题是比特币的地址太长，所以想通过别名的方式来解决。 原文档的连接已经失效了，但是内容还能谷歌出来。 参考资料 https://github.com/exploitagency/vanitygen-plus https://github.com/samr7/vanitygen https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh https://wiki.namecoin.org/index.php?title=Welcome 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"BIP 0015 详细说明 BIP: 15 Layer: Applications Title: 别名 Author: Amir Taaki &lt;genjix@riseup.net&gt; Comments-Summary: No comments yet. Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0015 Status: Deferred Type: Standards Track Created: 2011-12-10 BIP 0070（付款协议）可以被视为替代别名。 使用香草比特币发送资金到目的地，需要一个1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ的地址。 使用地址的问题是他们不容易记住。 如果域名不存在，则需要输入他们喜欢的网站的IP地址。 这个文件的目的是通过仔细的参数来设计一个比特币别名系统。 这是对协议的一个很大的修改，在将来不容易改变，并且有很大的影响。 有第一次纠正的动力。 别名必须是稳健的，安全的。 计划 这里有一些不同的建议和各系统的性能。 FirstBits FirstBits是将区块链用作地址簿的建议。 当比特币被发送到地址时，该地址就会被记录在区块链中。 因此，知道这个地址存在或确实存在，只要看到有一个付款的地址。 FirstBits是一个具有令人难忘的别名的方法。 首先将地址转换为小写，然后取前几个唯一字符。 这是你的FirstBits别名。 举个例子，布拉格的brmlab hackerspace有一个购买食物或饮料或捐款的地址： 1BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX 他们的FirstBits别名变成： 1brmlab 这是足够的信息被给予FirstBits别名1brmlab。 当有人想要购买时，如果没有FirstBits，他们要么手工输入他们的地址，扫描他们的二维码（这需要一个手机，这个作者不拥有），或在互联网上找到他们的地址复制和 粘贴到客户端发送比特币。 FirstBits通过提供简单的付款方式来缓解这种不切实际的情况。 与Vanitygen（虚荣发生器）一起，可以创建令人难忘的唯一命名地址。 地址是有意义的，而不是一个奇怪的字母和数字组合，但添加上下文到目的地。 然而FirstBits有它自己的问题。 一个是可能产生的别名受可用计算能力的限制。 生成一个完整或精确的别名可能是不可行的 - 只有近似值才有可能。 这也是计算资源密集型的，这意味着未来产生独特的别名需要大量的能量消耗，并且在普适计算的环境中不能扩展到家中的个人或手持设备的参与者的水平。 随着网络的增长，FirstBits的规模将非常差。 每个索引器或查找节点需要跟踪每个存在的比特币地址，并提供从别名到这些地址的快速查找。 随着网络线性增长，地址数量应该呈指数增长（假设（n-1）*（n-2）/ 2）的网络效应）使得该方案不可行。 部分merkle根类型的轻客户端依赖于可信第三方的别名查找。 考虑到他们在低资源设备上的典型使用情况，存储每个比特币地址的成本太高。 这个因素多于其他因素，意味着这个方案是次优的，必须被拒绝。 DNS TXT 记录 DNS允许创建包含任意数据的TXT记录。 在比特币别名系统中，由BIP标准共同定义的自定义格式将被用于存储从域名到比特币地址的映射。 这样的格式看起来不在本文的范围之内。 一个问题是，它要求那些希望创建这种映射的人熟悉配置DNS记录，并且能够运行必要的工具集来插入正确的数据。 虽然不是一个大问题，但这是一个可用性问题。 安全方面，DNS是不安全和不安全的设计。 可以通过与另一个主机位于同一网络来欺骗记录。 自二十世纪九十年代以来，DNSSEC幌子下的一系列修改工作已经开始，目前仍在进行中。 截至2011年12月，DNSSEC在互联网上还没有达到事实标准。 如果比特币网络的参与者希望使用DNS TXT记录，则他们除了必须配置DNS之外，还能够设置DNSSEC。 这可能是不可行的，尤其是在一些注册商只通过网页界面访问DNS的情况下。 DNS TXT记录的缺点是更新记录需要时间。 这鼓励人们不要使用每个具有一定安全问题的交易的新地址。 服务器服务 除了使用DNS TXT记录，另一种可能性是使用域名系统查找主机，然后联系预定义的端口上运行的服务，以获得比特币地址。 用户希望发送到foo@bar.net 客户端使用DNS查找bar.net的IP地址：123.123.123.123 客户端连接到端口123.123.123.123:4567，并请求用户foo的比特币地址 服务器响应地址或错误代码并终止连接。 客户将资金发送到地址 该服务将负责提供更改和存储服务映射的机制。 可以为希望使用该服务并在服务器上定制其帐户的用户提供前端Web界面。 这种方法具有积极的作用，为实现者提供最好的灵活性，然后将它们存储在数据库或纯文本文件中，然后使用通常用C编写的小型服务器端守护进程快速提供这些记录。这种方法具有高度可扩展性。 但是，这种方法也面临着依赖于DNS的问题，因此也容易受到欺骗。 因此DNSSEC也是必需的。 这种方法比DNS TXT记录稍好，因为它使得插入新用户和修改别名非常容易，这使得人们可以更便宜地运行这些服务器服务。 HTTPS Web服务 HTTPS通过加密连接提供额外的安全层，为用户提供非常需要的隐私。 与使用证书颁发机构一起，它解决了使用DNSSEC的问题，因为会引发错误，有人试图欺骗本地网络上的域名。 当试图发送到： genjix@foo.org 这个请求在@的最后一个出现处被分解成句柄（genjix）和域（foo.org）。 客户端然后构造一个将查询地址的请求。 https://foo.org/bitcoin-alias/?handle=genjix 比特币别名已经被选为查询后缀，因为它允许这个系统在另一个web根目录中很容易共存，而不用担心名称冲突。 查询将返回一个用于付款的地址。 1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ 每个查询是否返回一个唯一的地址，是否从一个预先存在的地址池中获取一个地址，等等的细节是每个服务器唯一的实现细节。 设置映射映射的别名依赖于可能具有Web界面的站点，并向用户提供免费服务，或者是为预先存在的地址提供私人定制服务。 这是留给管理层的政策，故意不在这里定义。 一个Web服务是微不足道的安装和成本低。 网络上有许多免费的提供商，允许任何具有最基本的网络技术知识的人创建自己的网站。 通过为用户提供一个软件包，任何人都可以快速设置自己的比特币别名。 它可以像PHP脚本一样简单，用户可以使用自定义设置进行编辑并上传自己的网站。 它也可以合理扩展 - 任何希望运行命名服务的人都可以使用各种数据库技术来附加后端，然后为用户提供一个Web前端来自定义和创建自己的别名。 作为一个例子，下面提供了一个天真的实现。 // resolv.h #ifndef NOMRESOLV_H__ #define NOMRESOLV_H__ #include &lt;string&gt; #include &quot;curl/curl.h&quot; using std::string; /* 这个类解决了服务器查找地址。 为了不与比特币地址冲突，我们在这里指的是人的手柄。 一个句柄的形式是： genjix@foo.org 大多数字符对用户名+密码有效（并进行相应处理），但域遵循通常的Web标准。 如果需要，可以粘贴一条路径， genjix@bar.com/path/to/ */ class NameResolutionService { public: NameResolutionService(); ~NameResolutionService(); // Three main methods map to RPC actions. string FetchAddress(const string&amp; strHandle, string&amp; strAddy); private: // A POST block class PostVariables { public: PostVariables(); ~PostVariables(); // Add a new key, value pair bool Add(const string&amp; strKey, const string&amp; strVal); curl_httppost* operator()() const; private: // CURL stores POST blocks as linked lists. curl_httppost *pBegin, *pEnd; }; // Explodes user@domain =&gt; user, domain static void ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain); // Perform the HTTP request. Returns true on success. bool Perform(); // CURL error message char pErrorBuffer[CURL_ERROR_SIZE]; // CURL response string strBuffer; // CURL handle CURL *curl; }; #endif // resolv.cpp #include &quot;resolv.h&quot; #include &lt;boost/lexical_cast.hpp&gt; #include &quot;access.h&quot; // callback used to write response from the server static int writer(char *pData, size_t nSize, size_t nNmemb, std::string *pBuffer) { int nResult = 0; if (pBuffer != NULL) { pBuffer-&gt;append(pData, nSize * nNmemb); // How much did we write? nResult = nSize * nNmemb; } return nResult; } NameResolutionService::NameResolutionService() { // Initialise CURL with our various options. curl = curl_easy_init(); // This goes first in case of any problems below. We get an error message. curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer); // fail when server sends &gt;= 404 curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1); curl_easy_setopt(curl, CURLOPT_HEADER, 0); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); curl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer); curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1); // server response goes in strBuffer curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;strBuffer); pErrorBuffer[0] = &#39;\\0&#39;; } NameResolutionService::~NameResolutionService() { curl_easy_cleanup(curl); } void NameResolutionService::ExplodeHandle(const string&amp; strHandle, string&amp; strNickname, string&amp; strDomain) { // split address at @ furthrest to the right size_t nPosAtsym = strHandle.rfind(&#39;@&#39;); strNickname = strHandle.substr(0, nPosAtsym); strDomain = strHandle.substr(nPosAtsym + 1, strHandle.size()); } bool NameResolutionService::Perform() { // Called after everything has been setup. This actually does the request. CURLcode result = curl_easy_perform(curl); return (result == CURLE_OK); } string NameResolutionService::FetchAddress(const string&amp; strHandle, string&amp; strAddy) { // GET is defined for &#39;getting&#39; data, so we use GET for the low risk fetching of people&#39;s addresses if (!curl) // For some reason CURL didn&#39;t start... return pErrorBuffer; // Expand the handle string strNickname, strDomain; ExplodeHandle(strHandle, strNickname, strDomain); // url encode the nickname for get request const char* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size()); if (!pszEncodedNick) return &quot;Unable to encode nickname.&quot;; // construct url for GET request string strRequestUrl = strDomain + &quot;/bitcoin-alias/?handle=&quot; + pszEncodedNick; // Pass URL to CURL curl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str()); if (!Perform()) return pErrorBuffer; // Server should respond with a JSON that has the address in. strAddy = strBuffer; return &quot;&quot;; // no error } NameResolutionService::PostVariables::PostVariables() { // pBegin/pEnd *must* be null before calling curl_formadd pBegin = NULL; pEnd = NULL; } NameResolutionService::PostVariables::~PostVariables() { curl_formfree(pBegin); } bool NameResolutionService::PostVariables::Add(const string&amp; strKey, const string&amp; strVal) { // Copy strings to this block. Return true on success. return curl_formadd(&amp;pBegin, &amp;pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK; } curl_httppost* NameResolutionService::PostVariables::operator()() const { return pBegin; } &lt;/source&gt; &lt;source lang=&quot;cpp&quot;&gt; // rpc.cpp ... const Object CheckMaybeThrow(const string&amp; strJsonIn) { // Parse input JSON Value valRequest; if (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type) throw JSONRPCError(-32700, &quot;Parse error&quot;); const Object&amp; request = valRequest.get_obj(); // Now check for a key called &quot;error&quot; const Value&amp; error = find_value(request, &quot;error&quot;); // It&#39;s an error JSON! so propagate the error. if (error.type() != null_type) throw JSONRPCError(-4, error.get_str()); // Return JSON object return request; } const string CollectAddress(const string&amp; strIn) { // If the handle does not have an @ in it, then it&#39;s a normal base58 bitcoin address if (strIn.find(&#39;@&#39;) == (size_t)-1) return strIn; // Open the lookup service NameResolutionService ns; // We established that the input string is not a BTC address, so we use it as a handle now. string strHandle = strIn, strAddy; string strError = ns.FetchAddress(strHandle, strAddy); if (!strError.empty()) throw JSONRPCError(-4, strError); const Object&amp; request(CheckMaybeThrow(strAddy)); // Get the BTC address from the JSON const Value&amp; address = find_value(request, &quot;address&quot;); if (address.type() != str_type) throw JSONRPCError(-32600, &quot;Server responded with malformed reply.&quot;); return address.get_str(); } // Named this way to prevent possible conflicts. Value rpc_send(const Array&amp; params, bool fHelp) { if (fHelp || params.size() != 2) throw runtime_error( &quot;send &lt;name@domain or address&gt; &lt;amount&gt;\\n&quot; &quot;&lt;amount&gt; is a real and is rounded to the nearest 0.01&quot;); // Intelligent function which looks up address given handle, or returns address string strAddy = CollectAddress(params[0].get_str()); int64 nAmount = AmountFromValue(params[1]); // Do the send CWalletTx wtx; string strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx); if (!strError.empty()) throw JSONRPCError(-4, strError); return wtx.GetHash().GetHex(); } ... IP交易 一个IP交易是比特币中一个旧的交易格式，被禁用，可能会被弃用。 它涉及被给予一个IP地址付款。 当连接到节点并使用“checkorder”请求他们的公钥时，他们将用以下格式的脚本进行响应： &lt;public key&gt; OP_CHECKSIG 类似于coinbase输出交易。 IP事务具有能够包含额外的元数据的优点，这在许多事务中可能是有用的。 目前没有进行认证，使得该方案对中间人（MITM）攻击不安全。 此提案旨在为IP事务启用DNS查找。 “checkorder”消息将包含一个目标帐户，该目标帐户可映射到在同一主机下运行的不同的独立密钥对/钱包集。 从checkorder参考信息到本地系统的确切映射是实现定义的。 通过使用DNS查找，通过将公钥存储在DNS TXT记录中，可以缓解IP事务的MITM问题。 这个公钥将被用于所有将来从该主机发出的“回复”消息。 首次使用需要确认接受该公钥; 像SSH一样。 如果“回复”消息与接受的公钥不匹配，则主机将被给出错误。 Namecoin ID 此建议使用Namecoin区块链将别名与比特币地址相关联。 比特币查询名称币结点。 这将检索包含与该别名相关联的比特币地址的结构化数据。 使用像Namecoin这样的分散的域名系统，意味着不像这里列出的其他提案那样需要信任外部服务器或实体。 这表明系统具有高可用性和易于输入的优点（不限制用户创建别名）。 下面介绍两个例子。 第一个显示了一个更简单的格式，而第二个显示了几个比特币地址的结构化格式。 $ namecoind name_show id/khal { &quot;bitcoin&quot; : &quot;1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T&quot; } ``` $ namecoind name_show id/khal { “bitcoin” : { “default” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “donation”: “1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4” } } 更多可能性： - 允许安全使用不安全的渠道 你可以把一个网址和一个比特币地址，用来签署的结果。 这意味着对这个URL的查询将返回一个比特币地址和签名。 比特币然后可以检查（使用verify_message函数）返回的地址还没有被另一个替换。 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getnewaddres/“, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T” } } - 允许每次或每个用户获得不同的地址，每个订单等 $ namecoind name_show id/khal { “bitcoin” : { “url” : “http://merchant.com/bitcoin/getaddres/{Your customer id}”, “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, “useOnce”: false } } “` 在上面的例子中，比特币会要求用户输入“Your customer id”，然后在发出http请求之前将该值替换为url。 商家将收到请求，并为用户提供与该客户相关的付款地址。 任何文字可以被放入括号，允许商家以使其适应他们的需求。 规范是可扩展的 可以稍后添加新功能来支持未发现的案例。 有关更多信息，请参阅Namecoin ID的规范。 总结 11年提出来的，现在被搁置，问题是比特币的地址太长，所以想通过别名的方式来解决。 原文档的连接已经失效了，但是内容还能谷歌出来。 参考资料 https://github.com/exploitagency/vanitygen-plus https://github.com/samr7/vanitygen https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh https://wiki.namecoin.org/index.php?title=Welcome 阅读更多","@type":"BlogPosting","url":"/2017/11/09/0ba21115fa70340e23695436355b6945.html","headline":"【比特币】BIP 0015 详细说明","dateModified":"2017-11-09T00:00:00+08:00","datePublished":"2017-11-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/11/09/0ba21115fa70340e23695436355b6945.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【比特币】BIP 0015 详细说明</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="bip-0015-详细说明">BIP 0015 详细说明</h1> 
  <pre class="prettyprint"><code class=" hljs http">
  <span class="hljs-attribute">BIP</span>: <span class="hljs-string">15</span>
  <span class="hljs-attribute">Layer</span>: <span class="hljs-string">Applications</span>
  <span class="hljs-attribute">Title</span>: <span class="hljs-string">别名</span>
  <span class="hljs-attribute">Author</span>: <span class="hljs-string">Amir Taaki &lt;genjix@riseup.net&gt;</span>
  <span class="hljs-attribute">Comments-Summary</span>: <span class="hljs-string">No comments yet.</span>
  <span class="hljs-attribute">Comments-URI</span>: <span class="hljs-string">https://github.com/bitcoin/bips/wiki/Comments:BIP-0015</span>
  <span class="hljs-attribute">Status</span>: <span class="hljs-string">Deferred</span>
  <span class="hljs-attribute">Type</span>: <span class="hljs-string">Standards Track</span>
  <span class="hljs-attribute">Created</span>: <span class="hljs-string">2011-12-10</span>
</code></pre> 
  <p>BIP 0070（付款协议）可以被视为替代别名。</p> 
  <p>使用香草比特币发送资金到目的地，需要一个1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ的地址。 使用地址的问题是他们不容易记住。 如果域名不存在，则需要输入他们喜欢的网站的IP地址。</p> 
  <p>这个文件的目的是通过仔细的参数来设计一个比特币别名系统。 这是对协议的一个很大的修改，在将来不容易改变，并且有很大的影响。 有第一次纠正的动力。 别名必须是稳健的，安全的。</p> 
  <h2 id="计划">计划</h2> 
  <p>这里有一些不同的建议和各系统的性能。</p> 
  <h3 id="firstbits">FirstBits</h3> 
  <p>FirstBits是将区块链用作地址簿的建议。</p> 
  <p>当比特币被发送到地址时，该地址就会被记录在区块链中。 因此，知道这个地址存在或确实存在，只要看到有一个付款的地址。 FirstBits是一个具有令人难忘的别名的方法。 首先将地址转换为小写，然后取前几个唯一字符。 这是你的FirstBits别名。</p> 
  <p>举个例子，布拉格的brmlab hackerspace有一个购买食物或饮料或捐款的地址：</p> 
  <p><code>1BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX</code></p> 
  <p>他们的FirstBits别名变成：</p> 
  <p><code>1brmlab</code></p> 
  <p>这是足够的信息被给予FirstBits别名1brmlab。 当有人想要购买时，如果没有FirstBits，他们要么手工输入他们的地址，扫描他们的二维码（这需要一个手机，这个作者不拥有），或在互联网上找到他们的地址复制和 粘贴到客户端发送比特币。 FirstBits通过提供简单的付款方式来缓解这种不切实际的情况。</p> 
  <p>与Vanitygen（虚荣发生器）一起，可以创建令人难忘的唯一命名地址。 地址是有意义的，而不是一个奇怪的字母和数字组合，但添加上下文到目的地。</p> 
  <p>然而FirstBits有它自己的问题。 一个是可能产生的别名受可用计算能力的限制。 生成一个完整或精确的别名可能是不可行的 - 只有近似值才有可能。 这也是计算资源密集型的，这意味着未来产生独特的别名需要大量的能量消耗，并且在普适计算的环境中不能扩展到家中的个人或手持设备的参与者的水平。</p> 
  <p>随着网络的增长，FirstBits的规模将非常差。 每个索引器或查找节点需要跟踪每个存在的比特币地址，并提供从别名到这些地址的快速查找。 随着网络线性增长，地址数量应该呈指数增长（假设（n-1）*（n-2）/ 2）的网络效应）使得该方案不可行。</p> 
  <p>部分merkle根类型的轻客户端依赖于可信第三方的别名查找。 考虑到他们在低资源设备上的典型使用情况，存储每个比特币地址的成本太高。 这个因素多于其他因素，意味着这个方案是次优的，必须被拒绝。</p> 
  <h3 id="dns-txt-记录">DNS TXT 记录</h3> 
  <p>DNS允许创建包含任意数据的TXT记录。 在比特币别名系统中，由BIP标准共同定义的自定义格式将被用于存储从域名到比特币地址的映射。 这样的格式看起来不在本文的范围之内。</p> 
  <p>一个问题是，它要求那些希望创建这种映射的人熟悉配置DNS记录，并且能够运行必要的工具集来插入正确的数据。 虽然不是一个大问题，但这是一个可用性问题。</p> 
  <p>安全方面，DNS是不安全和不安全的设计。 可以通过与另一个主机位于同一网络来欺骗记录。 自二十世纪九十年代以来，DNSSEC幌子下的一系列修改工作已经开始，目前仍在进行中。</p> 
  <p>截至2011年12月，DNSSEC在互联网上还没有达到事实标准。 如果比特币网络的参与者希望使用DNS TXT记录，则他们除了必须配置DNS之外，还能够设置DNSSEC。 这可能是不可行的，尤其是在一些注册商只通过网页界面访问DNS的情况下。</p> 
  <p>DNS TXT记录的缺点是更新记录需要时间。 这鼓励人们不要使用每个具有一定安全问题的交易的新地址。</p> 
  <h3 id="服务器服务">服务器服务</h3> 
  <p>除了使用DNS TXT记录，另一种可能性是使用域名系统查找主机，然后联系预定义的端口上运行的服务，以获得比特币地址。</p> 
  <ol> 
   <li>用户希望发送到foo@bar.net</li> 
   <li>客户端使用DNS查找bar.net的IP地址：123.123.123.123</li> 
   <li>客户端连接到端口123.123.123.123:4567，并请求用户foo的比特币地址</li> 
   <li>服务器响应地址或错误代码并终止连接。</li> 
   <li>客户将资金发送到地址</li> 
  </ol> 
  <p>该服务将负责提供更改和存储服务映射的机制。 可以为希望使用该服务并在服务器上定制其帐户的用户提供前端Web界面。</p> 
  <p>这种方法具有积极的作用，为实现者提供最好的灵活性，然后将它们存储在数据库或纯文本文件中，然后使用通常用C编写的小型服务器端守护进程快速提供这些记录。这种方法具有高度可扩展性。</p> 
  <p>但是，这种方法也面临着依赖于DNS的问题，因此也容易受到欺骗。 因此DNSSEC也是必需的。 这种方法比DNS TXT记录稍好，因为它使得插入新用户和修改别名非常容易，这使得人们可以更便宜地运行这些服务器服务。</p> 
  <h3 id="https-web服务">HTTPS Web服务</h3> 
  <p>HTTPS通过加密连接提供额外的安全层，为用户提供非常需要的隐私。 与使用证书颁发机构一起，它解决了使用DNSSEC的问题，因为会引发错误，有人试图欺骗本地网络上的域名。</p> 
  <p>当试图发送到：</p> 
  <p><code>genjix@foo.org</code></p> 
  <p>这个请求在@的最后一个出现处被分解成句柄（genjix）和域（foo.org）。 客户端然后构造一个将查询地址的请求。</p> 
  <p><code>https://foo.org/bitcoin-alias/?handle=genjix</code></p> 
  <p>比特币别名已经被选为查询后缀，因为它允许这个系统在另一个web根目录中很容易共存，而不用担心名称冲突。</p> 
  <p>查询将返回一个用于付款的地址。</p> 
  <p><code>1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ</code></p> 
  <p>每个查询是否返回一个唯一的地址，是否从一个预先存在的地址池中获取一个地址，等等的细节是每个服务器唯一的实现细节。 设置映射映射的别名依赖于可能具有Web界面的站点，并向用户提供免费服务，或者是为预先存在的地址提供私人定制服务。 这是留给管理层的政策，故意不在这里定义。</p> 
  <p>一个Web服务是微不足道的安装和成本低。 网络上有许多免费的提供商，允许任何具有最基本的网络技术知识的人创建自己的网站。 通过为用户提供一个软件包，任何人都可以快速设置自己的比特币别名。 它可以像PHP脚本一样简单，用户可以使用自定义设置进行编辑并上传自己的网站。</p> 
  <p>它也可以合理扩展 - 任何希望运行命名服务的人都可以使用各种数据库技术来附加后端，然后为用户提供一个Web前端来自定义和创建自己的别名。</p> 
  <p>作为一个例子，下面提供了一个天真的实现。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// resolv.h</span>
<span class="hljs-preprocessor">#ifndef NOMRESOLV_H__</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> NOMRESOLV_H__</span>

<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include "curl/curl.h"</span>

<span class="hljs-keyword">using</span> std::<span class="hljs-keyword">string</span>;

<span class="hljs-comment">/* 这个类解决了服务器查找地址。 为了不与比特币地址冲突，我们在这里指的是人的手柄。 一个句柄的形式是： genjix@foo.org 大多数字符对用户名+密码有效（并进行相应处理），但域遵循通常的Web标准。 如果需要，可以粘贴一条路径， genjix@bar.com/path/to/ */</span>

class NameResolutionService
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">NameResolutionService</span>();
    ~NameResolutionService();

    <span class="hljs-comment">// Three main methods map to RPC actions.</span>
    <span class="hljs-keyword">string</span> FetchAddress(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strHandle, <span class="hljs-keyword">string</span>&amp; strAddy);

<span class="hljs-keyword">private</span>:
    // A POST block
    <span class="hljs-keyword">class</span> PostVariables
    {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-title">PostVariables</span>();
        ~PostVariables();
        <span class="hljs-comment">// Add a new key, value pair</span>
        <span class="hljs-keyword">bool</span> Add(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strKey, <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strVal);
        curl_httppost* <span class="hljs-keyword">operator</span>()() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">private</span>:
        // CURL stores POST blocks <span class="hljs-keyword">as</span> linked lists.
        curl_httppost *pBegin, *pEnd;
    };

    <span class="hljs-comment">// Explodes user@domain =&gt; user, domain</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ExplodeHandle(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strHandle, <span class="hljs-keyword">string</span>&amp; strNickname, <span class="hljs-keyword">string</span>&amp; strDomain);
    <span class="hljs-comment">// Perform the HTTP request. Returns true on success.</span>
    <span class="hljs-keyword">bool</span> Perform();

    <span class="hljs-comment">// CURL error message</span>
    <span class="hljs-keyword">char</span> pErrorBuffer[CURL_ERROR_SIZE];
    <span class="hljs-comment">// CURL response</span>
    <span class="hljs-keyword">string</span> strBuffer;
    <span class="hljs-comment">// CURL handle</span>
    CURL *curl;
};

<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span></code></pre> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// resolv.cpp</span>
<span class="hljs-preprocessor">#include "resolv.h"</span>

<span class="hljs-preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span>

<span class="hljs-preprocessor">#include "access.h"</span>

<span class="hljs-comment">// callback used to write response from the server</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> writer(<span class="hljs-keyword">char</span> *pData, size_t nSize, size_t nNmemb, std::<span class="hljs-keyword">string</span> *pBuffer)
{
  <span class="hljs-keyword">int</span> nResult = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (pBuffer != NULL)
  {
    pBuffer-&gt;append(pData, nSize * nNmemb);
    <span class="hljs-comment">// How much did we write?</span>
    nResult = nSize * nNmemb;
  }
  <span class="hljs-keyword">return</span> nResult;
}

NameResolutionService::NameResolutionService()
{
    <span class="hljs-comment">// Initialise CURL with our various options.</span>
    curl = curl_easy_init();
    <span class="hljs-comment">// This goes first in case of any problems below. We get an error message.</span>
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer);
    <span class="hljs-comment">// fail when server sends &gt;= 404</span>
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, <span class="hljs-number">1</span>);
    curl_easy_setopt(curl, CURLOPT_HEADER, <span class="hljs-number">0</span>);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, <span class="hljs-number">1</span>);
    curl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer);
    curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// server response goes in strBuffer</span>
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;strBuffer);
    pErrorBuffer[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;
}
NameResolutionService::~NameResolutionService()
{
    curl_easy_cleanup(curl);
}

<span class="hljs-keyword">void</span> NameResolutionService::ExplodeHandle(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strHandle, <span class="hljs-keyword">string</span>&amp; strNickname, <span class="hljs-keyword">string</span>&amp; strDomain)
{
    <span class="hljs-comment">// split address at @ furthrest to the right</span>
    size_t nPosAtsym = strHandle.rfind(<span class="hljs-string">'@'</span>);
    strNickname = strHandle.substr(<span class="hljs-number">0</span>, nPosAtsym);
    strDomain = strHandle.substr(nPosAtsym + <span class="hljs-number">1</span>, strHandle.size());
}
<span class="hljs-keyword">bool</span> NameResolutionService::Perform()
{
    <span class="hljs-comment">// Called after everything has been setup. This actually does the request.</span>
    CURLcode result = curl_easy_perform(curl);
    <span class="hljs-keyword">return</span> (result == CURLE_OK);
}

<span class="hljs-keyword">string</span> NameResolutionService::FetchAddress(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strHandle, <span class="hljs-keyword">string</span>&amp; strAddy)
{
    <span class="hljs-comment">// GET is defined for 'getting' data, so we use GET for the low risk fetching of people's addresses</span>
    <span class="hljs-keyword">if</span> (!curl)
        <span class="hljs-comment">// For some reason CURL didn't start...</span>
        <span class="hljs-keyword">return</span> pErrorBuffer;
    <span class="hljs-comment">// Expand the handle</span>
    <span class="hljs-keyword">string</span> strNickname, strDomain;
    ExplodeHandle(strHandle, strNickname, strDomain);
    <span class="hljs-comment">// url encode the nickname for get request</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size());
    <span class="hljs-keyword">if</span> (!pszEncodedNick)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Unable to encode nickname."</span>;
    <span class="hljs-comment">// construct url for GET request</span>
    <span class="hljs-keyword">string</span> strRequestUrl = strDomain + <span class="hljs-string">"/bitcoin-alias/?handle="</span> + pszEncodedNick;
    <span class="hljs-comment">// Pass URL to CURL</span>
    curl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str());
    <span class="hljs-keyword">if</span> (!Perform())
        <span class="hljs-keyword">return</span> pErrorBuffer;
    <span class="hljs-comment">// Server should respond with a JSON that has the address in.</span>
    strAddy = strBuffer;
    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;  <span class="hljs-comment">// no error</span>
}

NameResolutionService::PostVariables::PostVariables()
{
    <span class="hljs-comment">// pBegin/pEnd *must* be null before calling curl_formadd</span>
    pBegin = NULL;
    pEnd = NULL;
}
NameResolutionService::PostVariables::~PostVariables()
{
    curl_formfree(pBegin);
}
<span class="hljs-keyword">bool</span> NameResolutionService::PostVariables::Add(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strKey, <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strVal)
{
    <span class="hljs-comment">// Copy strings to this block. Return true on success.</span>
    <span class="hljs-keyword">return</span> curl_formadd(&amp;pBegin, &amp;pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK;
}

curl_httppost* NameResolutionService::PostVariables::<span class="hljs-keyword">operator</span>()() <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> pBegin;
}
&lt;/source&gt;

&lt;source lang=<span class="hljs-string">"cpp"</span>&gt;
<span class="hljs-comment">// rpc.cpp</span>
...

<span class="hljs-keyword">const</span> Object CheckMaybeThrow(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strJsonIn)
{
    <span class="hljs-comment">// Parse input JSON</span>
    Value valRequest;
    <span class="hljs-keyword">if</span> (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type)
        <span class="hljs-keyword">throw</span> JSONRPCError(-<span class="hljs-number">32700</span>, <span class="hljs-string">"Parse error"</span>);
    <span class="hljs-keyword">const</span> Object&amp; request = valRequest.get_obj();
    <span class="hljs-comment">// Now check for a key called "error"</span>
    <span class="hljs-keyword">const</span> Value&amp; error  = find_value(request, <span class="hljs-string">"error"</span>);
    <span class="hljs-comment">// It's an error JSON! so propagate the error.</span>
    <span class="hljs-keyword">if</span> (error.type() != null_type)
        <span class="hljs-keyword">throw</span> JSONRPCError(-<span class="hljs-number">4</span>, error.get_str());
    <span class="hljs-comment">// Return JSON object</span>
    <span class="hljs-keyword">return</span> request;
}

<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> CollectAddress(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; strIn)
{
    <span class="hljs-comment">// If the handle does not have an @ in it, then it's a normal base58 bitcoin address</span>
    <span class="hljs-keyword">if</span> (strIn.find(<span class="hljs-string">'@'</span>) == (size_t)-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> strIn;

    <span class="hljs-comment">// Open the lookup service</span>
    NameResolutionService ns;
    <span class="hljs-comment">// We established that the input string is not a BTC address, so we use it as a handle now.</span>
    <span class="hljs-keyword">string</span> strHandle = strIn, strAddy;
    <span class="hljs-keyword">string</span> strError = ns.FetchAddress(strHandle, strAddy);
    <span class="hljs-keyword">if</span> (!strError.empty())
        <span class="hljs-keyword">throw</span> JSONRPCError(-<span class="hljs-number">4</span>, strError);

    <span class="hljs-keyword">const</span> Object&amp; request(CheckMaybeThrow(strAddy));
    <span class="hljs-comment">// Get the BTC address from the JSON</span>
    <span class="hljs-keyword">const</span> Value&amp; address = find_value(request, <span class="hljs-string">"address"</span>);
    <span class="hljs-keyword">if</span> (address.type() != str_type)
        <span class="hljs-keyword">throw</span> JSONRPCError(-<span class="hljs-number">32600</span>, <span class="hljs-string">"Server responded with malformed reply."</span>);
    <span class="hljs-keyword">return</span> address.get_str();
}

<span class="hljs-comment">// Named this way to prevent possible conflicts.</span>
Value rpc_send(<span class="hljs-keyword">const</span> Array&amp; <span class="hljs-keyword">params</span>, <span class="hljs-keyword">bool</span> fHelp)
{
    <span class="hljs-keyword">if</span> (fHelp || <span class="hljs-keyword">params</span>.size() != <span class="hljs-number">2</span>)
        <span class="hljs-keyword">throw</span> runtime_error(
            <span class="hljs-string">"send &lt;name@domain or address&gt; &lt;amount&gt;\n"</span>
            <span class="hljs-string">"&lt;amount&gt; is a real and is rounded to the nearest 0.01"</span>);

    <span class="hljs-comment">// Intelligent function which looks up address given handle, or returns address</span>
    <span class="hljs-keyword">string</span> strAddy = CollectAddress(<span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>].get_str());
    int64 nAmount = AmountFromValue(<span class="hljs-keyword">params</span>[<span class="hljs-number">1</span>]);
    <span class="hljs-comment">// Do the send</span>
    CWalletTx wtx;
    <span class="hljs-keyword">string</span> strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx);
    <span class="hljs-keyword">if</span> (!strError.empty())
        <span class="hljs-keyword">throw</span> JSONRPCError(-<span class="hljs-number">4</span>, strError);
    <span class="hljs-keyword">return</span> wtx.GetHash().GetHex();
}

...</code></pre> 
  <h3 id="ip交易">IP交易</h3> 
  <p>一个IP交易是比特币中一个旧的交易格式，被禁用，可能会被弃用。 它涉及被给予一个IP地址付款。 当连接到节点并使用“checkorder”请求他们的公钥时，他们将用以下格式的脚本进行响应：</p> 
  <p><code>&lt;public key&gt; OP_CHECKSIG</code></p> 
  <p>类似于coinbase输出交易。 IP事务具有能够包含额外的元数据的优点，这在许多事务中可能是有用的。 目前没有进行认证，使得该方案对中间人（MITM）攻击不安全。</p> 
  <p>此提案旨在为IP事务启用DNS查找。</p> 
  <p>“checkorder”消息将包含一个目标帐户，该目标帐户可映射到在同一主机下运行的不同的独立密钥对/钱包集。 从checkorder参考信息到本地系统的确切映射是实现定义的。</p> 
  <p>通过使用DNS查找，通过将公钥存储在DNS TXT记录中，可以缓解IP事务的MITM问题。 这个公钥将被用于所有将来从该主机发出的“回复”消息。 首次使用需要确认接受该公钥; 像SSH一样。 如果“回复”消息与接受的公钥不匹配，则主机将被给出错误。</p> 
  <h3 id="namecoin-id">Namecoin ID</h3> 
  <p>此建议使用Namecoin区块链将别名与比特币地址相关联。 比特币查询名称币结点。 这将检索包含与该别名相关联的比特币地址的结构化数据。</p> 
  <p>使用像Namecoin这样的分散的域名系统，意味着不像这里列出的其他提案那样需要信任外部服务器或实体。 这表明系统具有高可用性和易于输入的优点（不限制用户创建别名）。</p> 
  <p>下面介绍两个例子。 第一个显示了一个更简单的格式，而第二个显示了几个比特币地址的结构化格式。</p> 
  <pre class="prettyprint"><code class=" hljs autohotkey">$ namecoind name_show id/khal
 {
   <span class="hljs-string">"bitcoin"</span> : <span class="hljs-string">"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T"</span>
 }
 <span class="hljs-escape">``</span><span class="hljs-escape">` </span></code></pre> 
  <p>$ namecoind name_show id/khal <br> { <br> “bitcoin” : <br> { <br> “default” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, <br> “donation”: “1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4” <br> } <br> }</p> 
  <pre class="prettyprint"><code class=" hljs http">

<span class="haml">更多可能性： -<span class="ruby"> 允许安全使用不安全的渠道 </span> 你可以把一个网址和一个比特币地址，用来签署的结果。 这意味着对这个URL的查询将返回一个比特币地址和签名。 比特币然后可以检查（使用verify_message函数）返回的地址还没有被另一个替换。 </span></code></pre> 
  <p>$ namecoind name_show id/khal <br> { <br> “bitcoin” : <br> { <br> “url” : “<a href="http://merchant.com/bitcoin/getnewaddres/" rel="nofollow" target="_blank">http://merchant.com/bitcoin/getnewaddres/</a>“, <br> “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T” <br> } <br> }</p> 
  <pre class="prettyprint"><code class=" hljs haml">
-<span class="ruby"> 允许每次或每个用户获得不同的地址，每个订单等 </span></code></pre> 
  <p>$ namecoind name_show id/khal <br> { <br> “bitcoin” : <br> { <br> “url” : “<a href="http://merchant.com/bitcoin/getaddres/" rel="nofollow" target="_blank">http://merchant.com/bitcoin/getaddres/</a>{Your customer id}”, <br> “signedWith” : “1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T”, <br> “useOnce”: false <br> } <br> } <br> “`</p> 
  <p>在上面的例子中，比特币会要求用户输入“Your customer id”，然后在发出http请求之前将该值替换为url。 商家将收到请求，并为用户提供与该客户相关的付款地址。</p> 
  <p>任何文字可以被放入括号，允许商家以使其适应他们的需求。</p> 
  <ul> 
   <li>规范是可扩展的</li> 
  </ul> 
  <p>可以稍后添加新功能来支持未发现的案例。 <br> 有关更多信息，请参阅Namecoin ID的规范。</p> 
  <h2 id="总结">总结</h2> 
  <p>11年提出来的，现在被搁置，问题是<strong>比特币的地址太长</strong>，所以想通过别名的方式来解决。</p> 
  <p>原文档的连接已经失效了，但是内容还能谷歌出来。</p> 
  <h2 id="参考资料">参考资料</h2> 
  <ul> 
   <li><a href="https://github.com/exploitagency/vanitygen-plus" rel="nofollow" target="_blank">https://github.com/exploitagency/vanitygen-plus</a></li> 
   <li><a href="https://github.com/samr7/vanitygen" rel="nofollow" target="_blank">https://github.com/samr7/vanitygen</a></li> 
   <li><a href="https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh" rel="nofollow" target="_blank">https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh</a></li> 
   <li><a href="https://wiki.namecoin.org/index.php?title=Welcome" rel="nofollow" target="_blank">https://wiki.namecoin.org/index.php?title=Welcome</a></li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78485713,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78485713,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
