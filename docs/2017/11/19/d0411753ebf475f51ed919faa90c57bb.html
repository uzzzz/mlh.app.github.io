<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链：区块链技术初探(一) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链：区块链技术初探(一)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、区块链技术 什么是区块链？ 去中心化的、分布式的、区块化存储的数据库 存储全部账户余额及交易流水的总账本 每个节点有完整的账本数据 账本数据记录了全部的历史交易数据 交易数据存储在区块上 每个区块包含前一区块ID及HASH，形成链 区块链基本原理 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。 交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录 区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识 链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。 区块链要解决的问题 如何去中心化地共享数据？ 如何确保账户不被冒用？ 如何确保账户余额足够？ 如何确保交易记录不被篡改？ 谁负责记账？ 怎么保障记账者的可信？ 怎么保障记账者的积极性？ 区块链特性 去中心化 开放性（没有限制，开源，数据公开） 去信任（仅信任机器） 自治性，集体维护 可靠的数据库（不可更改，永远可访问） 匿名性，隐私保护 核心技术 P2P网络、数字签名、区块化数据库，竞争记账权、共识算法、交易回溯。 二、P2P网络及通信技术（分布式计算网络） 自动发现 通过种子文件，获取初始节点（地址及端口） 连接初始节点，获取初始节点知道的Peer 把自己的地址及端口广播给各个Peer 接收各个Peer广播的地址信息，构建出网络的全貌或片段 技术领域 分布式存储、分布式计算、分布式协同 组播 流媒体 搜索引擎 通信协议 napster 、Gnutella、eDonkey、 Bittorrent（文件分发协议） XMPP、Jabber（即时通信协议） Paxos 、Gossip（分布式系统状态同步协议） JXTA 使用HASH算法及非对称加密及签名技术 每个节点、每个人有唯一的一对公钥及私钥 公钥同时也是每个节点、个人的地址和账号 私钥是证明”我就是我“的唯一手段 HASH算法对数据进行规整 算法 RSA、Elgamal、D-H、ECC SHA256、 RIMPED160 通常使用椭圆曲线算法生成密钥对 比特币密钥长度：256位 公钥哈希值=RIMPED160(SHA256(公钥)) 比特币地址=1+Base58(0+公钥哈希值+校验码) 校验码=前四字节(SHA256(SHA256(0+公钥哈希值))) 加密 发送方使用接收方的公钥加密数据 接收方使用本方的私钥解密数据 通常使用本方面交换对称加密的Key 签名 发送方使用HASH算法计算数据的HASH值 发送方使用本方的私钥加密HASH值，得到签名 接收方使用HASH算法计算数据的HASH值 接收方使用发送方的公钥解密签名得到发送的HASH值 比较两个HASH值的一致性 参考 ElGamal算法，是一种较为常见的加密算法，它是基于1984年提出的公钥密码体制和椭圆曲线加密体系。既能用于数据加密也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题。在加密过程中，生成的密文长度是明文的两倍，且每次加密后都会在密文中生成一个随机数K，在密码中主要应用离散对数问题的几个性质：求解离散对数（可能）是困难的，而其逆运算指数运算可以应用平方-乘的方法有效地计算。也就是说，在适当的群G中，指数函数是单向函数。 椭圆曲线密码体制是目前已知的公钥体制中，对每比特所提供加密强度最高的一种体制。解椭圆曲线上的离散对数问题的最好算法是Pollard rho方法，其时间复杂度为，是完全指数阶的。其中n为等式(2)中m的二进制表示的位数。当n=234, 约为2117，需要1.6x1023 MIPS 年的时间。而我们熟知的RSA所利用的是大整数分解的困难问题，目前对于一般情况下的因数分解的最好算法的时间复杂度是子指数阶的，当n=2048时，需要2x1020MIPS年的时间。也就是说当RSA的密钥使用2048位时，ECC的密钥使用234位所获得的安全强度还高出许多。它们之间的密钥长度却相差达9倍，当ECC的密钥更大时它们之间差距将更大。更ECC密钥短的优点是非常明显的，随加密强度的提高，密钥长度变化不大。 DH Diffie-Hellman算法(D-H算法)，密钥一致协议，是由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想。简单的说就是允许两名用户在公开媒体上交换信息以生成”一致”的、可以共享的密钥。换句话说，就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。以此为基线，作为数据传输保密基础，同时双方使用同一种对称加密算法构建本地密钥（SecretKey）对数据加密。这样，在互通了本地密钥（SecretKey）算法后，甲乙双方公开自己的公钥，使用对方的公钥和刚才产生的私钥加密数据，同时可以使用对方的公钥和自己的私钥对数据解密。不单单是甲乙双方两方，可以扩展为多方共享数据通讯，这样就完成了网络交互数据的安全通讯！该算法源于中国的同余定理——中国馀数定理。 三、区块链化数据库 典型特征 去中心化的、分布式的、区块化存储的数据库 区块（Header + Body） 链 随机数 时间戳 包含父区块创建之后、本区块创建之前的全部交易； 满足某个条件的区块HASH； a) SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET b) Target值由动态的难度系数确定，Target越小，难度越高； 参考 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。 默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 四、记账权竞争及奖励制度（挖矿） 概述 为防止可预期的记账节点被控制或攻击，导致错误记账行为，区块链技术采用竞争记账权的做法： 任何一个节点均可以参与记账，因而记账节点无法预期，也就不容易被控 竞争的过程就是看谁最先计算出满足条件的HASH值 每次计算必须以最后1个有效的区块为起点，必须消耗大量的计算机CPU，增加伪造记账数据的成本 计算的结果必须得到大部分节点的认可（共识算法），才会成为新的区块。实际算法中，如果该区块位于最长的区块链上，则为正式被认可的区块，也即大部分节点认可计算结果，并愿意在该结果下继续计算 这个过程被称为挖矿，或工作量证明（POW）。参与挖矿的节点称为矿工，协同挖矿的矿工联合体称为矿池 a ) 以前1区块为起点，计算满足条件的HASH值； b ) 将计算的结果广播给其他节点； c ) 其他节点验证计算结果无误时，认可该结果，并以该结果为起点重新进行计算； d ) 单位时间内达到共识认可要求时，该区块成为正式认可的区块。 这个过程被称系统为鼓励挖矿的积极性，给予竞争成功的记账节点奖励 a ) 给予每个区块挖矿者直接的“现金”奖励。例如，比特币网络给予25个比特币，以太坊给予5个以太币； b ) 以太坊：纳入该区块的交易的手续费，由发起节点和记账节点分成（发起75%，记账25%）。 参考 比特币使用的SHA256算法，会有2^256种输出，如果我们进行2^256+1次输入，那么必然会产生一次碰撞；甚至从概率的角度看，进行2^130次输入就会有99%的可能发生一次碰撞。不过我们可以计算一下，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次哈希！ 这时要考虑一种情况：如果同时有两个矿工各自得到一个正确答案，并各自生成了一个区块广播出去会发生什么呢？这时候在区块链上同一个位置就有了两个区块，所谓的“分叉”就出现了。分叉是绝对不允许的，所以当矿工发现区块链分叉之后，会选择最长的一条继续计算，短的那条区块链会被丢弃。这里的长短，不是简单意义上的长短，而是工作量证明合计值最大的那个链。 阅读更多" />
<meta property="og:description" content="一、区块链技术 什么是区块链？ 去中心化的、分布式的、区块化存储的数据库 存储全部账户余额及交易流水的总账本 每个节点有完整的账本数据 账本数据记录了全部的历史交易数据 交易数据存储在区块上 每个区块包含前一区块ID及HASH，形成链 区块链基本原理 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。 交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录 区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识 链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。 区块链要解决的问题 如何去中心化地共享数据？ 如何确保账户不被冒用？ 如何确保账户余额足够？ 如何确保交易记录不被篡改？ 谁负责记账？ 怎么保障记账者的可信？ 怎么保障记账者的积极性？ 区块链特性 去中心化 开放性（没有限制，开源，数据公开） 去信任（仅信任机器） 自治性，集体维护 可靠的数据库（不可更改，永远可访问） 匿名性，隐私保护 核心技术 P2P网络、数字签名、区块化数据库，竞争记账权、共识算法、交易回溯。 二、P2P网络及通信技术（分布式计算网络） 自动发现 通过种子文件，获取初始节点（地址及端口） 连接初始节点，获取初始节点知道的Peer 把自己的地址及端口广播给各个Peer 接收各个Peer广播的地址信息，构建出网络的全貌或片段 技术领域 分布式存储、分布式计算、分布式协同 组播 流媒体 搜索引擎 通信协议 napster 、Gnutella、eDonkey、 Bittorrent（文件分发协议） XMPP、Jabber（即时通信协议） Paxos 、Gossip（分布式系统状态同步协议） JXTA 使用HASH算法及非对称加密及签名技术 每个节点、每个人有唯一的一对公钥及私钥 公钥同时也是每个节点、个人的地址和账号 私钥是证明”我就是我“的唯一手段 HASH算法对数据进行规整 算法 RSA、Elgamal、D-H、ECC SHA256、 RIMPED160 通常使用椭圆曲线算法生成密钥对 比特币密钥长度：256位 公钥哈希值=RIMPED160(SHA256(公钥)) 比特币地址=1+Base58(0+公钥哈希值+校验码) 校验码=前四字节(SHA256(SHA256(0+公钥哈希值))) 加密 发送方使用接收方的公钥加密数据 接收方使用本方的私钥解密数据 通常使用本方面交换对称加密的Key 签名 发送方使用HASH算法计算数据的HASH值 发送方使用本方的私钥加密HASH值，得到签名 接收方使用HASH算法计算数据的HASH值 接收方使用发送方的公钥解密签名得到发送的HASH值 比较两个HASH值的一致性 参考 ElGamal算法，是一种较为常见的加密算法，它是基于1984年提出的公钥密码体制和椭圆曲线加密体系。既能用于数据加密也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题。在加密过程中，生成的密文长度是明文的两倍，且每次加密后都会在密文中生成一个随机数K，在密码中主要应用离散对数问题的几个性质：求解离散对数（可能）是困难的，而其逆运算指数运算可以应用平方-乘的方法有效地计算。也就是说，在适当的群G中，指数函数是单向函数。 椭圆曲线密码体制是目前已知的公钥体制中，对每比特所提供加密强度最高的一种体制。解椭圆曲线上的离散对数问题的最好算法是Pollard rho方法，其时间复杂度为，是完全指数阶的。其中n为等式(2)中m的二进制表示的位数。当n=234, 约为2117，需要1.6x1023 MIPS 年的时间。而我们熟知的RSA所利用的是大整数分解的困难问题，目前对于一般情况下的因数分解的最好算法的时间复杂度是子指数阶的，当n=2048时，需要2x1020MIPS年的时间。也就是说当RSA的密钥使用2048位时，ECC的密钥使用234位所获得的安全强度还高出许多。它们之间的密钥长度却相差达9倍，当ECC的密钥更大时它们之间差距将更大。更ECC密钥短的优点是非常明显的，随加密强度的提高，密钥长度变化不大。 DH Diffie-Hellman算法(D-H算法)，密钥一致协议，是由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想。简单的说就是允许两名用户在公开媒体上交换信息以生成”一致”的、可以共享的密钥。换句话说，就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。以此为基线，作为数据传输保密基础，同时双方使用同一种对称加密算法构建本地密钥（SecretKey）对数据加密。这样，在互通了本地密钥（SecretKey）算法后，甲乙双方公开自己的公钥，使用对方的公钥和刚才产生的私钥加密数据，同时可以使用对方的公钥和自己的私钥对数据解密。不单单是甲乙双方两方，可以扩展为多方共享数据通讯，这样就完成了网络交互数据的安全通讯！该算法源于中国的同余定理——中国馀数定理。 三、区块链化数据库 典型特征 去中心化的、分布式的、区块化存储的数据库 区块（Header + Body） 链 随机数 时间戳 包含父区块创建之后、本区块创建之前的全部交易； 满足某个条件的区块HASH； a) SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET b) Target值由动态的难度系数确定，Target越小，难度越高； 参考 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。 默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 四、记账权竞争及奖励制度（挖矿） 概述 为防止可预期的记账节点被控制或攻击，导致错误记账行为，区块链技术采用竞争记账权的做法： 任何一个节点均可以参与记账，因而记账节点无法预期，也就不容易被控 竞争的过程就是看谁最先计算出满足条件的HASH值 每次计算必须以最后1个有效的区块为起点，必须消耗大量的计算机CPU，增加伪造记账数据的成本 计算的结果必须得到大部分节点的认可（共识算法），才会成为新的区块。实际算法中，如果该区块位于最长的区块链上，则为正式被认可的区块，也即大部分节点认可计算结果，并愿意在该结果下继续计算 这个过程被称为挖矿，或工作量证明（POW）。参与挖矿的节点称为矿工，协同挖矿的矿工联合体称为矿池 a ) 以前1区块为起点，计算满足条件的HASH值； b ) 将计算的结果广播给其他节点； c ) 其他节点验证计算结果无误时，认可该结果，并以该结果为起点重新进行计算； d ) 单位时间内达到共识认可要求时，该区块成为正式认可的区块。 这个过程被称系统为鼓励挖矿的积极性，给予竞争成功的记账节点奖励 a ) 给予每个区块挖矿者直接的“现金”奖励。例如，比特币网络给予25个比特币，以太坊给予5个以太币； b ) 以太坊：纳入该区块的交易的手续费，由发起节点和记账节点分成（发起75%，记账25%）。 参考 比特币使用的SHA256算法，会有2^256种输出，如果我们进行2^256+1次输入，那么必然会产生一次碰撞；甚至从概率的角度看，进行2^130次输入就会有99%的可能发生一次碰撞。不过我们可以计算一下，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次哈希！ 这时要考虑一种情况：如果同时有两个矿工各自得到一个正确答案，并各自生成了一个区块广播出去会发生什么呢？这时候在区块链上同一个位置就有了两个区块，所谓的“分叉”就出现了。分叉是绝对不允许的，所以当矿工发现区块链分叉之后，会选择最长的一条继续计算，短的那条区块链会被丢弃。这里的长短，不是简单意义上的长短，而是工作量证明合计值最大的那个链。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/11/19/d0411753ebf475f51ed919faa90c57bb.html" />
<meta property="og:url" content="https://mlh.app/2017/11/19/d0411753ebf475f51ed919faa90c57bb.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、区块链技术 什么是区块链？ 去中心化的、分布式的、区块化存储的数据库 存储全部账户余额及交易流水的总账本 每个节点有完整的账本数据 账本数据记录了全部的历史交易数据 交易数据存储在区块上 每个区块包含前一区块ID及HASH，形成链 区块链基本原理 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。 交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录 区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识 链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。 区块链要解决的问题 如何去中心化地共享数据？ 如何确保账户不被冒用？ 如何确保账户余额足够？ 如何确保交易记录不被篡改？ 谁负责记账？ 怎么保障记账者的可信？ 怎么保障记账者的积极性？ 区块链特性 去中心化 开放性（没有限制，开源，数据公开） 去信任（仅信任机器） 自治性，集体维护 可靠的数据库（不可更改，永远可访问） 匿名性，隐私保护 核心技术 P2P网络、数字签名、区块化数据库，竞争记账权、共识算法、交易回溯。 二、P2P网络及通信技术（分布式计算网络） 自动发现 通过种子文件，获取初始节点（地址及端口） 连接初始节点，获取初始节点知道的Peer 把自己的地址及端口广播给各个Peer 接收各个Peer广播的地址信息，构建出网络的全貌或片段 技术领域 分布式存储、分布式计算、分布式协同 组播 流媒体 搜索引擎 通信协议 napster 、Gnutella、eDonkey、 Bittorrent（文件分发协议） XMPP、Jabber（即时通信协议） Paxos 、Gossip（分布式系统状态同步协议） JXTA 使用HASH算法及非对称加密及签名技术 每个节点、每个人有唯一的一对公钥及私钥 公钥同时也是每个节点、个人的地址和账号 私钥是证明”我就是我“的唯一手段 HASH算法对数据进行规整 算法 RSA、Elgamal、D-H、ECC SHA256、 RIMPED160 通常使用椭圆曲线算法生成密钥对 比特币密钥长度：256位 公钥哈希值=RIMPED160(SHA256(公钥)) 比特币地址=1+Base58(0+公钥哈希值+校验码) 校验码=前四字节(SHA256(SHA256(0+公钥哈希值))) 加密 发送方使用接收方的公钥加密数据 接收方使用本方的私钥解密数据 通常使用本方面交换对称加密的Key 签名 发送方使用HASH算法计算数据的HASH值 发送方使用本方的私钥加密HASH值，得到签名 接收方使用HASH算法计算数据的HASH值 接收方使用发送方的公钥解密签名得到发送的HASH值 比较两个HASH值的一致性 参考 ElGamal算法，是一种较为常见的加密算法，它是基于1984年提出的公钥密码体制和椭圆曲线加密体系。既能用于数据加密也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题。在加密过程中，生成的密文长度是明文的两倍，且每次加密后都会在密文中生成一个随机数K，在密码中主要应用离散对数问题的几个性质：求解离散对数（可能）是困难的，而其逆运算指数运算可以应用平方-乘的方法有效地计算。也就是说，在适当的群G中，指数函数是单向函数。 椭圆曲线密码体制是目前已知的公钥体制中，对每比特所提供加密强度最高的一种体制。解椭圆曲线上的离散对数问题的最好算法是Pollard rho方法，其时间复杂度为，是完全指数阶的。其中n为等式(2)中m的二进制表示的位数。当n=234, 约为2117，需要1.6x1023 MIPS 年的时间。而我们熟知的RSA所利用的是大整数分解的困难问题，目前对于一般情况下的因数分解的最好算法的时间复杂度是子指数阶的，当n=2048时，需要2x1020MIPS年的时间。也就是说当RSA的密钥使用2048位时，ECC的密钥使用234位所获得的安全强度还高出许多。它们之间的密钥长度却相差达9倍，当ECC的密钥更大时它们之间差距将更大。更ECC密钥短的优点是非常明显的，随加密强度的提高，密钥长度变化不大。 DH Diffie-Hellman算法(D-H算法)，密钥一致协议，是由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想。简单的说就是允许两名用户在公开媒体上交换信息以生成”一致”的、可以共享的密钥。换句话说，就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。以此为基线，作为数据传输保密基础，同时双方使用同一种对称加密算法构建本地密钥（SecretKey）对数据加密。这样，在互通了本地密钥（SecretKey）算法后，甲乙双方公开自己的公钥，使用对方的公钥和刚才产生的私钥加密数据，同时可以使用对方的公钥和自己的私钥对数据解密。不单单是甲乙双方两方，可以扩展为多方共享数据通讯，这样就完成了网络交互数据的安全通讯！该算法源于中国的同余定理——中国馀数定理。 三、区块链化数据库 典型特征 去中心化的、分布式的、区块化存储的数据库 区块（Header + Body） 链 随机数 时间戳 包含父区块创建之后、本区块创建之前的全部交易； 满足某个条件的区块HASH； a) SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET b) Target值由动态的难度系数确定，Target越小，难度越高； 参考 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。 默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 四、记账权竞争及奖励制度（挖矿） 概述 为防止可预期的记账节点被控制或攻击，导致错误记账行为，区块链技术采用竞争记账权的做法： 任何一个节点均可以参与记账，因而记账节点无法预期，也就不容易被控 竞争的过程就是看谁最先计算出满足条件的HASH值 每次计算必须以最后1个有效的区块为起点，必须消耗大量的计算机CPU，增加伪造记账数据的成本 计算的结果必须得到大部分节点的认可（共识算法），才会成为新的区块。实际算法中，如果该区块位于最长的区块链上，则为正式被认可的区块，也即大部分节点认可计算结果，并愿意在该结果下继续计算 这个过程被称为挖矿，或工作量证明（POW）。参与挖矿的节点称为矿工，协同挖矿的矿工联合体称为矿池 a ) 以前1区块为起点，计算满足条件的HASH值； b ) 将计算的结果广播给其他节点； c ) 其他节点验证计算结果无误时，认可该结果，并以该结果为起点重新进行计算； d ) 单位时间内达到共识认可要求时，该区块成为正式认可的区块。 这个过程被称系统为鼓励挖矿的积极性，给予竞争成功的记账节点奖励 a ) 给予每个区块挖矿者直接的“现金”奖励。例如，比特币网络给予25个比特币，以太坊给予5个以太币； b ) 以太坊：纳入该区块的交易的手续费，由发起节点和记账节点分成（发起75%，记账25%）。 参考 比特币使用的SHA256算法，会有2^256种输出，如果我们进行2^256+1次输入，那么必然会产生一次碰撞；甚至从概率的角度看，进行2^130次输入就会有99%的可能发生一次碰撞。不过我们可以计算一下，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次哈希！ 这时要考虑一种情况：如果同时有两个矿工各自得到一个正确答案，并各自生成了一个区块广播出去会发生什么呢？这时候在区块链上同一个位置就有了两个区块，所谓的“分叉”就出现了。分叉是绝对不允许的，所以当矿工发现区块链分叉之后，会选择最长的一条继续计算，短的那条区块链会被丢弃。这里的长短，不是简单意义上的长短，而是工作量证明合计值最大的那个链。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/11/19/d0411753ebf475f51ed919faa90c57bb.html","headline":"区块链：区块链技术初探(一)","dateModified":"2017-11-19T00:00:00+08:00","datePublished":"2017-11-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/11/19/d0411753ebf475f51ed919faa90c57bb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链：区块链技术初探(一)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p>一、区块链技术</p> 
  </blockquote> 
  <ol> 
   <li><p>什么是区块链？</p> 
    <ul>
     <li>去中心化的、分布式的、区块化存储的数据库</li> 
     <li>存储全部账户余额及交易流水的总账本</li> 
     <li>每个节点有完整的账本数据</li> 
     <li>账本数据记录了全部的历史交易数据</li> 
     <li>交易数据存储在区块上</li> 
     <li>每个区块包含前一区块ID及HASH，形成链</li>
    </ul></li> 
   <li><p>区块链基本原理 <br> 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。</p> 
    <ul>
     <li>交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录</li> 
     <li>区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识</li> 
     <li>链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。</li>
    </ul></li> 
   <li><p>区块链要解决的问题</p> 
    <ul>
     <li>如何去中心化地共享数据？</li> 
     <li>如何确保账户不被冒用？</li> 
     <li>如何确保账户余额足够？</li> 
     <li>如何确保交易记录不被篡改？</li> 
     <li>谁负责记账？</li> 
     <li>怎么保障记账者的可信？</li> 
     <li>怎么保障记账者的积极性？</li>
    </ul></li> 
   <li><p>区块链特性 </p> 
    <ul>
     <li>去中心化</li> 
     <li>开放性（没有限制，开源，数据公开）</li> 
     <li>去信任（仅信任机器）</li> 
     <li>自治性，集体维护</li> 
     <li>可靠的数据库（不可更改，永远可访问）</li> 
     <li>匿名性，隐私保护</li>
    </ul></li> 
   <li><p>核心技术 <br> P2P网络、数字签名、区块化数据库，竞争记账权、共识算法、交易回溯。</p></li> 
  </ol> 
  <blockquote> 
   <p>二、P2P网络及通信技术（分布式计算网络）</p> 
  </blockquote> 
  <ol> 
   <li><p>自动发现</p> 
    <ul>
     <li>通过种子文件，获取初始节点（地址及端口）</li> 
     <li>连接初始节点，获取初始节点知道的Peer</li> 
     <li>把自己的地址及端口广播给各个Peer</li> 
     <li>接收各个Peer广播的地址信息，构建出网络的全貌或片段</li>
    </ul></li> 
   <li><p>技术领域</p> 
    <ul>
     <li>分布式存储、分布式计算、分布式协同</li> 
     <li>组播</li> 
     <li>流媒体</li> 
     <li>搜索引擎</li>
    </ul></li> 
   <li><p>通信协议</p> 
    <ul>
     <li>napster 、Gnutella、eDonkey、 Bittorrent（文件分发协议）</li> 
     <li>XMPP、Jabber（即时通信协议）</li> 
     <li>Paxos 、Gossip（分布式系统状态同步协议）</li> 
     <li>JXTA</li>
    </ul></li> 
   <li><p>使用HASH算法及非对称加密及签名技术</p> 
    <ul>
     <li>每个节点、每个人有唯一的一对公钥及私钥</li> 
     <li>公钥同时也是每个节点、个人的地址和账号</li> 
     <li>私钥是证明”我就是我“的唯一手段</li> 
     <li>HASH算法对数据进行规整</li>
    </ul></li> 
   <li><p>算法</p> 
    <ul>
     <li>RSA、Elgamal、D-H、ECC</li> 
     <li>SHA256、 RIMPED160</li>
    </ul></li> 
   <li><p>通常使用椭圆曲线算法生成密钥对</p> 
    <ul>
     <li>比特币密钥长度：256位</li> 
     <li>公钥哈希值=RIMPED160(SHA256(公钥))</li> 
     <li>比特币地址=<em>1</em>+Base58(0+公钥哈希值+校验码)</li> 
     <li>校验码=前四字节(SHA256(SHA256(0+公钥哈希值)))</li>
    </ul></li> 
   <li><p>加密</p> 
    <ul>
     <li>发送方使用接收方的公钥加密数据</li> 
     <li>接收方使用本方的私钥解密数据</li> 
     <li>通常使用本方面交换对称加密的Key</li>
    </ul></li> 
   <li><p>签名</p> 
    <ul>
     <li>发送方使用HASH算法计算数据的HASH值</li> 
     <li>发送方使用本方的私钥加密HASH值，得到签名</li> 
     <li>接收方使用HASH算法计算数据的HASH值</li> 
     <li>接收方使用发送方的公钥解密签名得到发送的HASH值</li> 
     <li>比较两个HASH值的一致性</li>
    </ul></li> 
   <li><p>参考</p> 
    <ul>
     <li>ElGamal算法，是一种较为常见的加密算法，它是基于1984年提出的公钥密码体制和椭圆曲线加密体系。既能用于数据加密也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题。在加密过程中，生成的密文长度是明文的两倍，且每次加密后都会在密文中生成一个随机数K，在密码中主要应用离散对数问题的几个性质：求解离散对数（可能）是困难的，而其逆运算指数运算可以应用平方-乘的方法有效地计算。也就是说，在适当的群G中，指数函数是单向函数。</li> 
     <li>椭圆曲线密码体制是目前已知的公钥体制中，对每比特所提供加密强度最高的一种体制。解椭圆曲线上的离散对数问题的最好算法是Pollard rho方法，其时间复杂度为，是完全指数阶的。其中n为等式(2)中m的二进制表示的位数。当n=234, 约为2117，需要1.6x1023 MIPS 年的时间。而我们熟知的RSA所利用的是大整数分解的困难问题，目前对于一般情况下的因数分解的最好算法的时间复杂度是子指数阶的，当n=2048时，需要2x1020MIPS年的时间。也就是说当RSA的密钥使用2048位时，ECC的密钥使用234位所获得的安全强度还高出许多。它们之间的密钥长度却相差达9倍，当ECC的密钥更大时它们之间差距将更大。更ECC密钥短的优点是非常明显的，随加密强度的提高，密钥长度变化不大。</li> 
     <li>DH Diffie-Hellman算法(D-H算法)，密钥一致协议，是由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想。简单的说就是允许两名用户在公开媒体上交换信息以生成”一致”的、可以共享的密钥。换句话说，就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。以此为基线，作为数据传输保密基础，同时双方使用同一种对称加密算法构建本地密钥（SecretKey）对数据加密。这样，在互通了本地密钥（SecretKey）算法后，甲乙双方公开自己的公钥，使用对方的公钥和刚才产生的私钥加密数据，同时可以使用对方的公钥和自己的私钥对数据解密。不单单是甲乙双方两方，可以扩展为多方共享数据通讯，这样就完成了网络交互数据的安全通讯！该算法源于中国的同余定理——中国馀数定理。</li>
    </ul></li> 
  </ol> 
  <blockquote> 
   <p>三、区块链化数据库</p> 
  </blockquote> 
  <ol> 
   <li><p>典型特征</p> 
    <ul>
     <li>去中心化的、分布式的、区块化存储的数据库</li> 
     <li>区块（Header + Body）</li> 
     <li>链</li> 
     <li>随机数</li> 
     <li>时间戳</li> 
     <li>包含父区块创建之后、本区块创建之前的全部交易；</li> 
     <li>满足某个条件的区块HASH； <br> a) SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET <br> b) Target值由动态的难度系数确定，Target越小，难度越高； <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171119124757615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGluTGlhbk9yZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></li>
    </ul></li> 
   <li><p>参考</p> 
    <ul>
     <li>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。 <br> 默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。</li>
    </ul></li> 
  </ol> 
  <blockquote> 
   <p>四、记账权竞争及奖励制度（挖矿）</p> 
  </blockquote> 
  <ol> 
   <li><p>概述 <br> 为防止可预期的记账节点被控制或攻击，导致错误记账行为，区块链技术采用竞争记账权的做法：</p> 
    <ul>
     <li>任何一个节点均可以参与记账，因而记账节点无法预期，也就不容易被控</li> 
     <li>竞争的过程就是看谁最先计算出满足条件的HASH值</li> 
     <li>每次计算必须以最后1个有效的区块为起点，必须消耗大量的计算机CPU，增加伪造记账数据的成本</li> 
     <li>计算的结果必须得到大部分节点的认可（共识算法），才会成为新的区块。实际算法中，如果该区块位于最长的区块链上，则为正式被认可的区块，也即大部分节点认可计算结果，并愿意在该结果下继续计算</li> 
     <li>这个过程被称为挖矿，或工作量证明（POW）。参与挖矿的节点称为矿工，协同挖矿的矿工联合体称为矿池 <br> a ) 以前1区块为起点，计算满足条件的HASH值； <br> b ) 将计算的结果广播给其他节点； <br> c ) 其他节点验证计算结果无误时，认可该结果，并以该结果为起点重新进行计算； <br> d ) 单位时间内达到共识认可要求时，该区块成为正式认可的区块。</li> 
     <li>这个过程被称系统为鼓励挖矿的积极性，给予竞争成功的记账节点奖励 <br> a ) 给予每个区块挖矿者直接的“现金”奖励。例如，比特币网络给予25个比特币，以太坊给予5个以太币； <br> b ) 以太坊：纳入该区块的交易的手续费，由发起节点和记账节点分成（发起75%，记账25%）。</li>
    </ul></li> 
   <li><p>参考</p> 
    <ul>
     <li>比特币使用的SHA256算法，会有2^256种输出，如果我们进行2^256+1次输入，那么必然会产生一次碰撞；甚至从概率的角度看，进行2^130次输入就会有99%的可能发生一次碰撞。不过我们可以计算一下，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次哈希！ <br> 这时要考虑一种情况：如果同时有两个矿工各自得到一个正确答案，并各自生成了一个区块广播出去会发生什么呢？这时候在区块链上同一个位置就有了两个区块，所谓的“分叉”就出现了。分叉是绝对不允许的，所以当矿工发现区块链分叉之后，会选择最长的一条继续计算，短的那条区块链会被丢弃。这里的长短，不是简单意义上的长短，而是工作量证明合计值最大的那个链。</li>
    </ul></li> 
  </ol> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/XinLianOrg/article/details/78573714,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/XinLianOrg/article/details/78573714,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
