<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码解析(21) - 可执行程序 - Bitcoind | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码解析(21) - 可执行程序 - Bitcoind" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/78516016 0x00 摘要 经过前面20章的分析，我们已经渐渐接近比特币的核心功能部分了，也就是它的共识、交易处理等等。虽然前面基本上都是做的一些初始化的工作，但是这些工作对于比特币的整体运行来说都是必不可缺的，并且就像在之前讲过的信号处理、并发处理等等都是值得学习的部分，本章主要介绍AppInitMain中的Step 6，代码略微有些长所以就分割成小段来进行分析。 0x01 AppInitMain Step 6: network initialization // ********************************************************* Step 6: network initialization // Note that we absolutely cannot open any actual connections // until the very end (&quot;start node&quot;) as the UTXO/block state // is not yet setup and may end up being set up twice if we // need to reindex later. assert(!g_connman); g_connman = std::unique_ptr&lt;CConnman&gt;(new CConnman(GetRand(std::numeric_limits&lt;uint64_t&gt;::max()), GetRand(std::numeric_limits&lt;uint64_t&gt;::max()))); CConnman&amp; connman = *g_connman; peerLogic.reset(new PeerLogicValidation(&amp;connman)); RegisterValidationInterface(peerLogic.get()); RegisterNodeSignals(GetNodeSignals()); 先看开头注释，这里提示只有在最后Start node的时候才能进行实际的网络连接，也就是说这一段还是进行一些参数的设置，并不会实际开启连接，原因是区块的状态还没有配置好并且，如果后面设置了重新索引，那么区块的状态就会被设置两次。 PeerLogicValidation 再来看代码，首先一句断言确保g_connman为空，之前的代码中也经常看到断言语句，这是一种很好的习惯，能确保变量在指定的范围内，同时易于调试。接下来创建了一个CConnman对象，用于设置连接的参数，接着又创建了一个PeerLogicValidation类型的变量，这个类的实现如下， class PeerLogicValidation : public CValidationInterface { private: CConnman* connman; public: explicit PeerLogicValidation(CConnman* connmanIn); void BlockConnected(const std::shared_ptr&lt;const CBlock&gt;&amp; pblock, const CBlockIndex* pindexConnected, const std::vector&lt;CTransactionRef&gt;&amp; vtxConflicted) override; void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override; void BlockChecked(const CBlock&amp; block, const CValidationState&amp; state) override; void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr&lt;const CBlock&gt;&amp; pblock) override; }; 通过这几个函数名称大概可以看出来，这个类实现的是在产生一个新的block时，节点如何处理，这些函数的具体实现过程将在后面调用时再来分析。 注册节点之间的消息处理信号 void RegisterValidationInterface(CValidationInterface* pwalletIn) { g_signals.m_internals-&gt;UpdatedBlockTip.connect(boost::bind(&amp;CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;TransactionAddedToMempool.connect(boost::bind(&amp;CValidationInterface::TransactionAddedToMempool, pwalletIn, _1)); g_signals.m_internals-&gt;BlockConnected.connect(boost::bind(&amp;CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;BlockDisconnected.connect(boost::bind(&amp;CValidationInterface::BlockDisconnected, pwalletIn, _1)); g_signals.m_internals-&gt;SetBestChain.connect(boost::bind(&amp;CValidationInterface::SetBestChain, pwalletIn, _1)); g_signals.m_internals-&gt;Inventory.connect(boost::bind(&amp;CValidationInterface::Inventory, pwalletIn, _1)); g_signals.m_internals-&gt;Broadcast.connect(boost::bind(&amp;CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2)); g_signals.m_internals-&gt;BlockChecked.connect(boost::bind(&amp;CValidationInterface::BlockChecked, pwalletIn, _1, _2)); g_signals.m_internals-&gt;NewPoWValidBlock.connect(boost::bind(&amp;CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2)); } 注册节点信号 void RegisterNodeSignals(CNodeSignals&amp; nodeSignals) { nodeSignals.ProcessMessages.connect(&amp;ProcessMessages); nodeSignals.SendMessages.connect(&amp;SendMessages); nodeSignals.InitializeNode.connect(&amp;InitializeNode); nodeSignals.FinalizeNode.connect(&amp;FinalizeNode); } 这里是注册几个节点处理、发送消息的信号。 添加用户代理注释 // sanitize comments per BIP-0014, format user agent and check total size std::vector&lt;std::string&gt; uacomments; for (const std::string&amp; cmt : gArgs.GetArgs(&quot;-uacomment&quot;)) { if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT)) return InitError(strprintf(_(&quot;User Agent comment (%s) contains unsafe characters.&quot;), cmt)); uacomments.push_back(cmt); } strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments); if (strSubVersion.size() &gt; MAX_SUBVERSION_LENGTH) { return InitError(strprintf(_(&quot;Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.&quot;), strSubVersion.size(), MAX_SUBVERSION_LENGTH)); } -uacomment：给用户代理字符串添加注释。 首先将用户对代理的注释信息保存到uacomments中，将CLIENT_NAME、CLIENT_VERSION和uacomments按照/CLIENT_NAME:CLIENT_VERSION(comments1;comments2;...)/的格式连接起来，最后判断格式化后的字符串是否超过了最大长度限制，这个MAX_SUBVERSION_LENGTH在src/net.h中定义为256。 设定网络范围 if (gArgs.IsArgSet(&quot;-onlynet&quot;)) { std::set&lt;enum Network&gt; nets; for (const std::string&amp; snet : gArgs.GetArgs(&quot;-onlynet&quot;)) { enum Network net = ParseNetwork(snet); if (net == NET_UNROUTABLE) return InitError(strprintf(_(&quot;Unknown network specified in -onlynet: &#39;%s&#39;&quot;), snet)); nets.insert(net); } for (int n = 0; n &lt; NET_MAX; n++) { enum Network net = (enum Network)n; if (!nets.count(net)) SetLimited(net); } } -onlynet：只连接特定网络中的节点，取值有NET_UNROUTABLE,NET_IPV4,NET_IPV6,NET_TOR,NET_INTERNAL几种。 首先看看Network的定义， enum Network { NET_UNROUTABLE = 0, NET_IPV4, NET_IPV6, NET_TOR, NET_INTERNAL, NET_MAX, }; 定义了几种网络，-onlynet则将连接范围限定在某一种或几种网络内。 代理设置 // Check for host lookup allowed before parsing any network related parameters fNameLookup = gArgs.GetBoolArg(&quot;-dns&quot;, DEFAULT_NAME_LOOKUP); bool proxyRandomize = gArgs.GetBoolArg(&quot;-proxyrandomize&quot;, DEFAULT_PROXYRANDOMIZE); // -proxy sets a proxy for all outgoing network traffic // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default std::string proxyArg = gArgs.GetArg(&quot;-proxy&quot;, &quot;&quot;); SetLimited(NET_TOR); if (proxyArg != &quot;&quot; &amp;&amp; proxyArg != &quot;0&quot;) { CService proxyAddr; if (!Lookup(proxyArg.c_str(), proxyAddr, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); } proxyType addrProxy = proxyType(proxyAddr, proxyRandomize); if (!addrProxy.IsValid()) return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); SetProxy(NET_IPV4, addrProxy); SetProxy(NET_IPV6, addrProxy); SetProxy(NET_TOR, addrProxy); SetNameProxy(addrProxy); SetLimited(NET_TOR, false); // by default, -proxy sets onion as reachable, unless -noonion later } -dns：允许进行dns解析，默认为1. -proxyrandomize：为每个代理连接都随机颁发一个证书，默认为1. -proxy：为网络所有的通信设置一个代理，默认为空。 首先检查两个参数，然后通过SetLimited(NET_TOR)来禁用洋葱路由。然后检查如果代理不为空，那么根据代理域名进行dns查询，查到相应的ip并检查代理的合法性之后，再为IPV4、IPV6以及TOR设置代理。最后禁用TOR，因为在上面先禁用了，所以这里进行启用，其实这里设不设置都没关系，后面会根据-onion参数再进行相应的设置。 设置洋葱路由 // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses // -noonion (or -onion=0) disables connecting to .onion entirely // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none) std::string onionArg = gArgs.GetArg(&quot;-onion&quot;, &quot;&quot;); if (onionArg != &quot;&quot;) { if (onionArg == &quot;0&quot;) { // Handle -noonion/-onion=0 SetLimited(NET_TOR); // set onions as unreachable } else { CService onionProxy; if (!Lookup(onionArg.c_str(), onionProxy, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); } proxyType addrOnion = proxyType(onionProxy, proxyRandomize); if (!addrOnion.IsValid()) return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); SetProxy(NET_TOR, addrOnion); SetLimited(NET_TOR, false); } } 如果-onion!=&quot;&quot; &amp;&amp; != &quot;0&quot;那么跟设置代理类似，首先解析域名，启用洋葱路由。 设置external ip // see Step 2: parameter interactions for more information about these fListen = gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN); fDiscover = gArgs.GetBoolArg(&quot;-discover&quot;, true); fRelayTxes = !gArgs.GetBoolArg(&quot;-blocksonly&quot;, DEFAULT_BLOCKSONLY); for (const std::string&amp; strAddr : gArgs.GetArgs(&quot;-externalip&quot;)) { CService addrLocal; if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) &amp;&amp; addrLocal.IsValid()) AddLocal(addrLocal, LOCAL_MANUAL); else return InitError(ResolveErrMsg(&quot;externalip&quot;, strAddr)); } -listen：接受从某个地址的连接请求。 -discover：发现拥有的ip地址。 -blocksonly：让节点进入blocksonly模式。 -externalip：指定公有地址。 前面两个参数比较好理解，那么什么是blocksonly模式呢？根据https://bitcointalk.org/index.php?topic=1377345.0的解释， Bitcoin Core 0.12 introduced a new blocksonly setting. When set to blocksonly a node behaves normally but sends and receives no lose transactions; instead it handles only complete blocks. There are many applications for nodes where only confirmed transactions are interesting, and a node which still verifies and forwards blocks still contributes to network health– less, perhaps, than one that relays transactions: but it also consumes fewer resources to begin with. An additional downside they don’t get the latency advantages of signature caching since every transaction they see is totally new to them– this isn’t something miners should use. How much less bandwidth does blocksonly use in practice? I recently measured this using two techniques: Once by instrumenting a node to measure bandwidth used for blocks vs all other traffic, and again by repeatedly running in both modes for a day and monitoring the hosts total network usage; both modes gave effectively the same result. How much is the savings? Blocksonly reduced the node’s bandwidth usage by 88%. 简单来说，就是节点不接收临时的交易，只接受已确认的区块。 接下来对于指定的external ip首先查询对应的ip（指定的可以是域名，或者将字符串ip转换成CService），然后通过AddLocal将指定的ip添加到mapLocalHost中，由这个结构维护所有的本地ip。 ZMQ #if ENABLE_ZMQ pzmqNotificationInterface = CZMQNotificationInterface::Create(); if (pzmqNotificationInterface) { RegisterValidationInterface(pzmqNotificationInterface); } #endif uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME; if (gArgs.IsArgSet(&quot;-maxuploadtarget&quot;)) { nMaxOutboundLimit = gArgs.GetArg(&quot;-maxuploadtarget&quot;, DEFAULT_MAX_UPLOAD_TARGET)*1024*1024; } -maxuploadtarget：设置最大上传速度，单位为MB，默认值为0，表示没有限制。 首先通过一个宏定义来表示是否启用ZMQ，关于zmq的介绍，参考https://www.cnblogs.com/rainbowzc/p/3357594.html，简单来说，zmq封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。本章的前面介绍了RegisterValidationInterface函数，此函数注册了许多区块处理的信号。然后下面通过-maxuploadtarget参数来设置最大上传速度。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/78516016 0x00 摘要 经过前面20章的分析，我们已经渐渐接近比特币的核心功能部分了，也就是它的共识、交易处理等等。虽然前面基本上都是做的一些初始化的工作，但是这些工作对于比特币的整体运行来说都是必不可缺的，并且就像在之前讲过的信号处理、并发处理等等都是值得学习的部分，本章主要介绍AppInitMain中的Step 6，代码略微有些长所以就分割成小段来进行分析。 0x01 AppInitMain Step 6: network initialization // ********************************************************* Step 6: network initialization // Note that we absolutely cannot open any actual connections // until the very end (&quot;start node&quot;) as the UTXO/block state // is not yet setup and may end up being set up twice if we // need to reindex later. assert(!g_connman); g_connman = std::unique_ptr&lt;CConnman&gt;(new CConnman(GetRand(std::numeric_limits&lt;uint64_t&gt;::max()), GetRand(std::numeric_limits&lt;uint64_t&gt;::max()))); CConnman&amp; connman = *g_connman; peerLogic.reset(new PeerLogicValidation(&amp;connman)); RegisterValidationInterface(peerLogic.get()); RegisterNodeSignals(GetNodeSignals()); 先看开头注释，这里提示只有在最后Start node的时候才能进行实际的网络连接，也就是说这一段还是进行一些参数的设置，并不会实际开启连接，原因是区块的状态还没有配置好并且，如果后面设置了重新索引，那么区块的状态就会被设置两次。 PeerLogicValidation 再来看代码，首先一句断言确保g_connman为空，之前的代码中也经常看到断言语句，这是一种很好的习惯，能确保变量在指定的范围内，同时易于调试。接下来创建了一个CConnman对象，用于设置连接的参数，接着又创建了一个PeerLogicValidation类型的变量，这个类的实现如下， class PeerLogicValidation : public CValidationInterface { private: CConnman* connman; public: explicit PeerLogicValidation(CConnman* connmanIn); void BlockConnected(const std::shared_ptr&lt;const CBlock&gt;&amp; pblock, const CBlockIndex* pindexConnected, const std::vector&lt;CTransactionRef&gt;&amp; vtxConflicted) override; void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override; void BlockChecked(const CBlock&amp; block, const CValidationState&amp; state) override; void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr&lt;const CBlock&gt;&amp; pblock) override; }; 通过这几个函数名称大概可以看出来，这个类实现的是在产生一个新的block时，节点如何处理，这些函数的具体实现过程将在后面调用时再来分析。 注册节点之间的消息处理信号 void RegisterValidationInterface(CValidationInterface* pwalletIn) { g_signals.m_internals-&gt;UpdatedBlockTip.connect(boost::bind(&amp;CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;TransactionAddedToMempool.connect(boost::bind(&amp;CValidationInterface::TransactionAddedToMempool, pwalletIn, _1)); g_signals.m_internals-&gt;BlockConnected.connect(boost::bind(&amp;CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;BlockDisconnected.connect(boost::bind(&amp;CValidationInterface::BlockDisconnected, pwalletIn, _1)); g_signals.m_internals-&gt;SetBestChain.connect(boost::bind(&amp;CValidationInterface::SetBestChain, pwalletIn, _1)); g_signals.m_internals-&gt;Inventory.connect(boost::bind(&amp;CValidationInterface::Inventory, pwalletIn, _1)); g_signals.m_internals-&gt;Broadcast.connect(boost::bind(&amp;CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2)); g_signals.m_internals-&gt;BlockChecked.connect(boost::bind(&amp;CValidationInterface::BlockChecked, pwalletIn, _1, _2)); g_signals.m_internals-&gt;NewPoWValidBlock.connect(boost::bind(&amp;CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2)); } 注册节点信号 void RegisterNodeSignals(CNodeSignals&amp; nodeSignals) { nodeSignals.ProcessMessages.connect(&amp;ProcessMessages); nodeSignals.SendMessages.connect(&amp;SendMessages); nodeSignals.InitializeNode.connect(&amp;InitializeNode); nodeSignals.FinalizeNode.connect(&amp;FinalizeNode); } 这里是注册几个节点处理、发送消息的信号。 添加用户代理注释 // sanitize comments per BIP-0014, format user agent and check total size std::vector&lt;std::string&gt; uacomments; for (const std::string&amp; cmt : gArgs.GetArgs(&quot;-uacomment&quot;)) { if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT)) return InitError(strprintf(_(&quot;User Agent comment (%s) contains unsafe characters.&quot;), cmt)); uacomments.push_back(cmt); } strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments); if (strSubVersion.size() &gt; MAX_SUBVERSION_LENGTH) { return InitError(strprintf(_(&quot;Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.&quot;), strSubVersion.size(), MAX_SUBVERSION_LENGTH)); } -uacomment：给用户代理字符串添加注释。 首先将用户对代理的注释信息保存到uacomments中，将CLIENT_NAME、CLIENT_VERSION和uacomments按照/CLIENT_NAME:CLIENT_VERSION(comments1;comments2;...)/的格式连接起来，最后判断格式化后的字符串是否超过了最大长度限制，这个MAX_SUBVERSION_LENGTH在src/net.h中定义为256。 设定网络范围 if (gArgs.IsArgSet(&quot;-onlynet&quot;)) { std::set&lt;enum Network&gt; nets; for (const std::string&amp; snet : gArgs.GetArgs(&quot;-onlynet&quot;)) { enum Network net = ParseNetwork(snet); if (net == NET_UNROUTABLE) return InitError(strprintf(_(&quot;Unknown network specified in -onlynet: &#39;%s&#39;&quot;), snet)); nets.insert(net); } for (int n = 0; n &lt; NET_MAX; n++) { enum Network net = (enum Network)n; if (!nets.count(net)) SetLimited(net); } } -onlynet：只连接特定网络中的节点，取值有NET_UNROUTABLE,NET_IPV4,NET_IPV6,NET_TOR,NET_INTERNAL几种。 首先看看Network的定义， enum Network { NET_UNROUTABLE = 0, NET_IPV4, NET_IPV6, NET_TOR, NET_INTERNAL, NET_MAX, }; 定义了几种网络，-onlynet则将连接范围限定在某一种或几种网络内。 代理设置 // Check for host lookup allowed before parsing any network related parameters fNameLookup = gArgs.GetBoolArg(&quot;-dns&quot;, DEFAULT_NAME_LOOKUP); bool proxyRandomize = gArgs.GetBoolArg(&quot;-proxyrandomize&quot;, DEFAULT_PROXYRANDOMIZE); // -proxy sets a proxy for all outgoing network traffic // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default std::string proxyArg = gArgs.GetArg(&quot;-proxy&quot;, &quot;&quot;); SetLimited(NET_TOR); if (proxyArg != &quot;&quot; &amp;&amp; proxyArg != &quot;0&quot;) { CService proxyAddr; if (!Lookup(proxyArg.c_str(), proxyAddr, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); } proxyType addrProxy = proxyType(proxyAddr, proxyRandomize); if (!addrProxy.IsValid()) return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); SetProxy(NET_IPV4, addrProxy); SetProxy(NET_IPV6, addrProxy); SetProxy(NET_TOR, addrProxy); SetNameProxy(addrProxy); SetLimited(NET_TOR, false); // by default, -proxy sets onion as reachable, unless -noonion later } -dns：允许进行dns解析，默认为1. -proxyrandomize：为每个代理连接都随机颁发一个证书，默认为1. -proxy：为网络所有的通信设置一个代理，默认为空。 首先检查两个参数，然后通过SetLimited(NET_TOR)来禁用洋葱路由。然后检查如果代理不为空，那么根据代理域名进行dns查询，查到相应的ip并检查代理的合法性之后，再为IPV4、IPV6以及TOR设置代理。最后禁用TOR，因为在上面先禁用了，所以这里进行启用，其实这里设不设置都没关系，后面会根据-onion参数再进行相应的设置。 设置洋葱路由 // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses // -noonion (or -onion=0) disables connecting to .onion entirely // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none) std::string onionArg = gArgs.GetArg(&quot;-onion&quot;, &quot;&quot;); if (onionArg != &quot;&quot;) { if (onionArg == &quot;0&quot;) { // Handle -noonion/-onion=0 SetLimited(NET_TOR); // set onions as unreachable } else { CService onionProxy; if (!Lookup(onionArg.c_str(), onionProxy, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); } proxyType addrOnion = proxyType(onionProxy, proxyRandomize); if (!addrOnion.IsValid()) return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); SetProxy(NET_TOR, addrOnion); SetLimited(NET_TOR, false); } } 如果-onion!=&quot;&quot; &amp;&amp; != &quot;0&quot;那么跟设置代理类似，首先解析域名，启用洋葱路由。 设置external ip // see Step 2: parameter interactions for more information about these fListen = gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN); fDiscover = gArgs.GetBoolArg(&quot;-discover&quot;, true); fRelayTxes = !gArgs.GetBoolArg(&quot;-blocksonly&quot;, DEFAULT_BLOCKSONLY); for (const std::string&amp; strAddr : gArgs.GetArgs(&quot;-externalip&quot;)) { CService addrLocal; if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) &amp;&amp; addrLocal.IsValid()) AddLocal(addrLocal, LOCAL_MANUAL); else return InitError(ResolveErrMsg(&quot;externalip&quot;, strAddr)); } -listen：接受从某个地址的连接请求。 -discover：发现拥有的ip地址。 -blocksonly：让节点进入blocksonly模式。 -externalip：指定公有地址。 前面两个参数比较好理解，那么什么是blocksonly模式呢？根据https://bitcointalk.org/index.php?topic=1377345.0的解释， Bitcoin Core 0.12 introduced a new blocksonly setting. When set to blocksonly a node behaves normally but sends and receives no lose transactions; instead it handles only complete blocks. There are many applications for nodes where only confirmed transactions are interesting, and a node which still verifies and forwards blocks still contributes to network health– less, perhaps, than one that relays transactions: but it also consumes fewer resources to begin with. An additional downside they don’t get the latency advantages of signature caching since every transaction they see is totally new to them– this isn’t something miners should use. How much less bandwidth does blocksonly use in practice? I recently measured this using two techniques: Once by instrumenting a node to measure bandwidth used for blocks vs all other traffic, and again by repeatedly running in both modes for a day and monitoring the hosts total network usage; both modes gave effectively the same result. How much is the savings? Blocksonly reduced the node’s bandwidth usage by 88%. 简单来说，就是节点不接收临时的交易，只接受已确认的区块。 接下来对于指定的external ip首先查询对应的ip（指定的可以是域名，或者将字符串ip转换成CService），然后通过AddLocal将指定的ip添加到mapLocalHost中，由这个结构维护所有的本地ip。 ZMQ #if ENABLE_ZMQ pzmqNotificationInterface = CZMQNotificationInterface::Create(); if (pzmqNotificationInterface) { RegisterValidationInterface(pzmqNotificationInterface); } #endif uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME; if (gArgs.IsArgSet(&quot;-maxuploadtarget&quot;)) { nMaxOutboundLimit = gArgs.GetArg(&quot;-maxuploadtarget&quot;, DEFAULT_MAX_UPLOAD_TARGET)*1024*1024; } -maxuploadtarget：设置最大上传速度，单位为MB，默认值为0，表示没有限制。 首先通过一个宏定义来表示是否启用ZMQ，关于zmq的介绍，参考https://www.cnblogs.com/rainbowzc/p/3357594.html，简单来说，zmq封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。本章的前面介绍了RegisterValidationInterface函数，此函数注册了许多区块处理的信号。然后下面通过-maxuploadtarget参数来设置最大上传速度。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/11/12/e3cdb821951d79d72667abccdc181b9b.html" />
<meta property="og:url" content="https://mlh.app/2017/11/12/e3cdb821951d79d72667abccdc181b9b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/78516016 0x00 摘要 经过前面20章的分析，我们已经渐渐接近比特币的核心功能部分了，也就是它的共识、交易处理等等。虽然前面基本上都是做的一些初始化的工作，但是这些工作对于比特币的整体运行来说都是必不可缺的，并且就像在之前讲过的信号处理、并发处理等等都是值得学习的部分，本章主要介绍AppInitMain中的Step 6，代码略微有些长所以就分割成小段来进行分析。 0x01 AppInitMain Step 6: network initialization // ********************************************************* Step 6: network initialization // Note that we absolutely cannot open any actual connections // until the very end (&quot;start node&quot;) as the UTXO/block state // is not yet setup and may end up being set up twice if we // need to reindex later. assert(!g_connman); g_connman = std::unique_ptr&lt;CConnman&gt;(new CConnman(GetRand(std::numeric_limits&lt;uint64_t&gt;::max()), GetRand(std::numeric_limits&lt;uint64_t&gt;::max()))); CConnman&amp; connman = *g_connman; peerLogic.reset(new PeerLogicValidation(&amp;connman)); RegisterValidationInterface(peerLogic.get()); RegisterNodeSignals(GetNodeSignals()); 先看开头注释，这里提示只有在最后Start node的时候才能进行实际的网络连接，也就是说这一段还是进行一些参数的设置，并不会实际开启连接，原因是区块的状态还没有配置好并且，如果后面设置了重新索引，那么区块的状态就会被设置两次。 PeerLogicValidation 再来看代码，首先一句断言确保g_connman为空，之前的代码中也经常看到断言语句，这是一种很好的习惯，能确保变量在指定的范围内，同时易于调试。接下来创建了一个CConnman对象，用于设置连接的参数，接着又创建了一个PeerLogicValidation类型的变量，这个类的实现如下， class PeerLogicValidation : public CValidationInterface { private: CConnman* connman; public: explicit PeerLogicValidation(CConnman* connmanIn); void BlockConnected(const std::shared_ptr&lt;const CBlock&gt;&amp; pblock, const CBlockIndex* pindexConnected, const std::vector&lt;CTransactionRef&gt;&amp; vtxConflicted) override; void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override; void BlockChecked(const CBlock&amp; block, const CValidationState&amp; state) override; void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr&lt;const CBlock&gt;&amp; pblock) override; }; 通过这几个函数名称大概可以看出来，这个类实现的是在产生一个新的block时，节点如何处理，这些函数的具体实现过程将在后面调用时再来分析。 注册节点之间的消息处理信号 void RegisterValidationInterface(CValidationInterface* pwalletIn) { g_signals.m_internals-&gt;UpdatedBlockTip.connect(boost::bind(&amp;CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;TransactionAddedToMempool.connect(boost::bind(&amp;CValidationInterface::TransactionAddedToMempool, pwalletIn, _1)); g_signals.m_internals-&gt;BlockConnected.connect(boost::bind(&amp;CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3)); g_signals.m_internals-&gt;BlockDisconnected.connect(boost::bind(&amp;CValidationInterface::BlockDisconnected, pwalletIn, _1)); g_signals.m_internals-&gt;SetBestChain.connect(boost::bind(&amp;CValidationInterface::SetBestChain, pwalletIn, _1)); g_signals.m_internals-&gt;Inventory.connect(boost::bind(&amp;CValidationInterface::Inventory, pwalletIn, _1)); g_signals.m_internals-&gt;Broadcast.connect(boost::bind(&amp;CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2)); g_signals.m_internals-&gt;BlockChecked.connect(boost::bind(&amp;CValidationInterface::BlockChecked, pwalletIn, _1, _2)); g_signals.m_internals-&gt;NewPoWValidBlock.connect(boost::bind(&amp;CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2)); } 注册节点信号 void RegisterNodeSignals(CNodeSignals&amp; nodeSignals) { nodeSignals.ProcessMessages.connect(&amp;ProcessMessages); nodeSignals.SendMessages.connect(&amp;SendMessages); nodeSignals.InitializeNode.connect(&amp;InitializeNode); nodeSignals.FinalizeNode.connect(&amp;FinalizeNode); } 这里是注册几个节点处理、发送消息的信号。 添加用户代理注释 // sanitize comments per BIP-0014, format user agent and check total size std::vector&lt;std::string&gt; uacomments; for (const std::string&amp; cmt : gArgs.GetArgs(&quot;-uacomment&quot;)) { if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT)) return InitError(strprintf(_(&quot;User Agent comment (%s) contains unsafe characters.&quot;), cmt)); uacomments.push_back(cmt); } strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments); if (strSubVersion.size() &gt; MAX_SUBVERSION_LENGTH) { return InitError(strprintf(_(&quot;Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.&quot;), strSubVersion.size(), MAX_SUBVERSION_LENGTH)); } -uacomment：给用户代理字符串添加注释。 首先将用户对代理的注释信息保存到uacomments中，将CLIENT_NAME、CLIENT_VERSION和uacomments按照/CLIENT_NAME:CLIENT_VERSION(comments1;comments2;...)/的格式连接起来，最后判断格式化后的字符串是否超过了最大长度限制，这个MAX_SUBVERSION_LENGTH在src/net.h中定义为256。 设定网络范围 if (gArgs.IsArgSet(&quot;-onlynet&quot;)) { std::set&lt;enum Network&gt; nets; for (const std::string&amp; snet : gArgs.GetArgs(&quot;-onlynet&quot;)) { enum Network net = ParseNetwork(snet); if (net == NET_UNROUTABLE) return InitError(strprintf(_(&quot;Unknown network specified in -onlynet: &#39;%s&#39;&quot;), snet)); nets.insert(net); } for (int n = 0; n &lt; NET_MAX; n++) { enum Network net = (enum Network)n; if (!nets.count(net)) SetLimited(net); } } -onlynet：只连接特定网络中的节点，取值有NET_UNROUTABLE,NET_IPV4,NET_IPV6,NET_TOR,NET_INTERNAL几种。 首先看看Network的定义， enum Network { NET_UNROUTABLE = 0, NET_IPV4, NET_IPV6, NET_TOR, NET_INTERNAL, NET_MAX, }; 定义了几种网络，-onlynet则将连接范围限定在某一种或几种网络内。 代理设置 // Check for host lookup allowed before parsing any network related parameters fNameLookup = gArgs.GetBoolArg(&quot;-dns&quot;, DEFAULT_NAME_LOOKUP); bool proxyRandomize = gArgs.GetBoolArg(&quot;-proxyrandomize&quot;, DEFAULT_PROXYRANDOMIZE); // -proxy sets a proxy for all outgoing network traffic // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default std::string proxyArg = gArgs.GetArg(&quot;-proxy&quot;, &quot;&quot;); SetLimited(NET_TOR); if (proxyArg != &quot;&quot; &amp;&amp; proxyArg != &quot;0&quot;) { CService proxyAddr; if (!Lookup(proxyArg.c_str(), proxyAddr, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); } proxyType addrProxy = proxyType(proxyAddr, proxyRandomize); if (!addrProxy.IsValid()) return InitError(strprintf(_(&quot;Invalid -proxy address or hostname: &#39;%s&#39;&quot;), proxyArg)); SetProxy(NET_IPV4, addrProxy); SetProxy(NET_IPV6, addrProxy); SetProxy(NET_TOR, addrProxy); SetNameProxy(addrProxy); SetLimited(NET_TOR, false); // by default, -proxy sets onion as reachable, unless -noonion later } -dns：允许进行dns解析，默认为1. -proxyrandomize：为每个代理连接都随机颁发一个证书，默认为1. -proxy：为网络所有的通信设置一个代理，默认为空。 首先检查两个参数，然后通过SetLimited(NET_TOR)来禁用洋葱路由。然后检查如果代理不为空，那么根据代理域名进行dns查询，查到相应的ip并检查代理的合法性之后，再为IPV4、IPV6以及TOR设置代理。最后禁用TOR，因为在上面先禁用了，所以这里进行启用，其实这里设不设置都没关系，后面会根据-onion参数再进行相应的设置。 设置洋葱路由 // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses // -noonion (or -onion=0) disables connecting to .onion entirely // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none) std::string onionArg = gArgs.GetArg(&quot;-onion&quot;, &quot;&quot;); if (onionArg != &quot;&quot;) { if (onionArg == &quot;0&quot;) { // Handle -noonion/-onion=0 SetLimited(NET_TOR); // set onions as unreachable } else { CService onionProxy; if (!Lookup(onionArg.c_str(), onionProxy, 9050, fNameLookup)) { return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); } proxyType addrOnion = proxyType(onionProxy, proxyRandomize); if (!addrOnion.IsValid()) return InitError(strprintf(_(&quot;Invalid -onion address or hostname: &#39;%s&#39;&quot;), onionArg)); SetProxy(NET_TOR, addrOnion); SetLimited(NET_TOR, false); } } 如果-onion!=&quot;&quot; &amp;&amp; != &quot;0&quot;那么跟设置代理类似，首先解析域名，启用洋葱路由。 设置external ip // see Step 2: parameter interactions for more information about these fListen = gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN); fDiscover = gArgs.GetBoolArg(&quot;-discover&quot;, true); fRelayTxes = !gArgs.GetBoolArg(&quot;-blocksonly&quot;, DEFAULT_BLOCKSONLY); for (const std::string&amp; strAddr : gArgs.GetArgs(&quot;-externalip&quot;)) { CService addrLocal; if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) &amp;&amp; addrLocal.IsValid()) AddLocal(addrLocal, LOCAL_MANUAL); else return InitError(ResolveErrMsg(&quot;externalip&quot;, strAddr)); } -listen：接受从某个地址的连接请求。 -discover：发现拥有的ip地址。 -blocksonly：让节点进入blocksonly模式。 -externalip：指定公有地址。 前面两个参数比较好理解，那么什么是blocksonly模式呢？根据https://bitcointalk.org/index.php?topic=1377345.0的解释， Bitcoin Core 0.12 introduced a new blocksonly setting. When set to blocksonly a node behaves normally but sends and receives no lose transactions; instead it handles only complete blocks. There are many applications for nodes where only confirmed transactions are interesting, and a node which still verifies and forwards blocks still contributes to network health– less, perhaps, than one that relays transactions: but it also consumes fewer resources to begin with. An additional downside they don’t get the latency advantages of signature caching since every transaction they see is totally new to them– this isn’t something miners should use. How much less bandwidth does blocksonly use in practice? I recently measured this using two techniques: Once by instrumenting a node to measure bandwidth used for blocks vs all other traffic, and again by repeatedly running in both modes for a day and monitoring the hosts total network usage; both modes gave effectively the same result. How much is the savings? Blocksonly reduced the node’s bandwidth usage by 88%. 简单来说，就是节点不接收临时的交易，只接受已确认的区块。 接下来对于指定的external ip首先查询对应的ip（指定的可以是域名，或者将字符串ip转换成CService），然后通过AddLocal将指定的ip添加到mapLocalHost中，由这个结构维护所有的本地ip。 ZMQ #if ENABLE_ZMQ pzmqNotificationInterface = CZMQNotificationInterface::Create(); if (pzmqNotificationInterface) { RegisterValidationInterface(pzmqNotificationInterface); } #endif uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME; if (gArgs.IsArgSet(&quot;-maxuploadtarget&quot;)) { nMaxOutboundLimit = gArgs.GetArg(&quot;-maxuploadtarget&quot;, DEFAULT_MAX_UPLOAD_TARGET)*1024*1024; } -maxuploadtarget：设置最大上传速度，单位为MB，默认值为0，表示没有限制。 首先通过一个宏定义来表示是否启用ZMQ，关于zmq的介绍，参考https://www.cnblogs.com/rainbowzc/p/3357594.html，简单来说，zmq封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。本章的前面介绍了RegisterValidationInterface函数，此函数注册了许多区块处理的信号。然后下面通过-maxuploadtarget参数来设置最大上传速度。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/11/12/e3cdb821951d79d72667abccdc181b9b.html","headline":"比特币源码解析(21) - 可执行程序 - Bitcoind","dateModified":"2017-11-12T00:00:00+08:00","datePublished":"2017-11-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/11/12/e3cdb821951d79d72667abccdc181b9b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码解析(21) - 可执行程序 - Bitcoind</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/78516016 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2 id="0x00-摘要">0x00 摘要</h2> 
  <p>经过前面20章的分析，我们已经渐渐接近比特币的核心功能部分了，也就是它的共识、交易处理等等。虽然前面基本上都是做的一些初始化的工作，但是这些工作对于比特币的整体运行来说都是必不可缺的，并且就像在之前讲过的信号处理、并发处理等等都是值得学习的部分，本章主要介绍<code>AppInitMain</code>中的<code>Step 6</code>，代码略微有些长所以就分割成小段来进行分析。</p> 
  <h2 id="0x01-appinitmain-step-6-network-initialization">0x01 AppInitMain Step 6: network initialization</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs vhdl">    // ********************************************************* Step <span class="hljs-number">6</span>: network initialization
    // Note that we absolutely cannot <span class="hljs-keyword">open</span> any actual connections
    // <span class="hljs-keyword">until</span> the very <span class="hljs-keyword">end</span> (<span class="hljs-string">"start node"</span>) as the UTXO/<span class="hljs-keyword">block</span> state
    // <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet setup <span class="hljs-keyword">and</span> may <span class="hljs-keyword">end</span> up being set up twice <span class="hljs-keyword">if</span> we
    // need <span class="hljs-keyword">to</span> reindex later.

    <span class="hljs-keyword">assert</span>(!g_connman);
    g_connman = std::unique_ptr&lt;CConnman&gt;(<span class="hljs-keyword">new</span> CConnman(GetRand(std::numeric_limits&lt;uint64_t&gt;::max()), GetRand(std::numeric_limits&lt;uint64_t&gt;::max())));
    CConnman&amp; connman = *g_connman;

    peerLogic.reset(<span class="hljs-keyword">new</span> PeerLogicValidation(&amp;connman));
    RegisterValidationInterface(peerLogic.get());
    RegisterNodeSignals(GetNodeSignals());</code></pre> 
  <p>先看开头注释，这里提示只有在最后<code>Start node</code>的时候才能进行实际的网络连接，也就是说这一段还是进行一些参数的设置，并不会实际开启连接，原因是区块的状态还没有配置好并且，如果后面设置了重新索引，那么区块的状态就会被设置两次。</p> 
  <h3 id="peerlogicvalidation">PeerLogicValidation</h3> 
  <p>再来看代码，首先一句断言确保<code>g_connman</code>为空，之前的代码中也经常看到断言语句，这是一种很好的习惯，能确保变量在指定的范围内，同时易于调试。接下来创建了一个<code>CConnman</code>对象，用于设置连接的参数，接着又创建了一个<code>PeerLogicValidation</code>类型的变量，这个类的实现如下，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-keyword">class</span> PeerLogicValidation : <span class="hljs-keyword">public</span> CValidationInterface {
<span class="hljs-keyword">private</span>:
    CConnman* connman;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> PeerLogicValidation(CConnman* connmanIn);

    <span class="hljs-keyword">void</span> BlockConnected(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> CBlock&gt;&amp; pblock, <span class="hljs-keyword">const</span> CBlockIndex* pindexConnected, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CTransactionRef&gt;</span>&amp; vtxConflicted) override;
    <span class="hljs-keyword">void</span> UpdatedBlockTip(<span class="hljs-keyword">const</span> CBlockIndex *pindexNew, <span class="hljs-keyword">const</span> CBlockIndex *pindexFork, <span class="hljs-keyword">bool</span> fInitialDownload) override;
    <span class="hljs-keyword">void</span> BlockChecked(<span class="hljs-keyword">const</span> CBlock&amp; block, <span class="hljs-keyword">const</span> CValidationState&amp; state) override;
    <span class="hljs-keyword">void</span> NewPoWValidBlock(<span class="hljs-keyword">const</span> CBlockIndex *pindex, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> CBlock&gt;&amp; pblock) override;
};</code></pre> 
  <p>通过这几个函数名称大概可以看出来，这个类实现的是在产生一个新的block时，节点如何处理，这些函数的具体实现过程将在后面调用时再来分析。</p> 
  <h3 id="注册节点之间的消息处理信号">注册节点之间的消息处理信号</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs lasso"><span class="hljs-literal">void</span> RegisterValidationInterface(CValidationInterface<span class="hljs-subst">*</span> pwalletIn) {
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>UpdatedBlockTip<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::UpdatedBlockTip</span>, pwalletIn, _1, _2, _3));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>TransactionAddedToMempool<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::TransactionAddedToMempool</span>, pwalletIn, _1));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>BlockConnected<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::BlockConnected</span>, pwalletIn, _1, _2, _3));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>BlockDisconnected<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::BlockDisconnected</span>, pwalletIn, _1));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>SetBestChain<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::SetBestChain</span>, pwalletIn, _1));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>Inventory<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::Inventory</span>, pwalletIn, _1));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>Broadcast<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::ResendWalletTransactions</span>, pwalletIn, _1, _2));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>BlockChecked<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::BlockChecked</span>, pwalletIn, _1, _2));
    g_signals<span class="hljs-built_in">.</span>m_internals<span class="hljs-subst">-&gt;</span>NewPoWValidBlock<span class="hljs-built_in">.</span>connect(boost<span class="hljs-tag">::bind</span>(<span class="hljs-subst">&amp;</span>CValidationInterface<span class="hljs-tag">::NewPoWValidBlock</span>, pwalletIn, _1, _2));
}</code></pre> 
  <h3 id="注册节点信号">注册节点信号</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs avrasm">void RegisterNodeSignals(CNodeSignals&amp; nodeSignals)
{
    nodeSignals<span class="hljs-preprocessor">.ProcessMessages</span><span class="hljs-preprocessor">.connect</span>(&amp;ProcessMessages)<span class="hljs-comment">;</span>
    nodeSignals<span class="hljs-preprocessor">.SendMessages</span><span class="hljs-preprocessor">.connect</span>(&amp;SendMessages)<span class="hljs-comment">;</span>
    nodeSignals<span class="hljs-preprocessor">.InitializeNode</span><span class="hljs-preprocessor">.connect</span>(&amp;InitializeNode)<span class="hljs-comment">;</span>
    nodeSignals<span class="hljs-preprocessor">.FinalizeNode</span><span class="hljs-preprocessor">.connect</span>(&amp;FinalizeNode)<span class="hljs-comment">;</span>
}</code></pre> 
  <p>这里是注册几个节点处理、发送消息的信号。</p> 
  <h3 id="添加用户代理注释">添加用户代理注释</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    <span class="hljs-comment">// sanitize comments per BIP-0014, format user agent and check total size</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> uacomments;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; cmt : gArgs.GetArgs(<span class="hljs-string">"-uacomment"</span>)) {
        <span class="hljs-keyword">if</span> (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"User Agent comment (%s) contains unsafe characters."</span>), cmt));
        uacomments.push_back(cmt);
    }
    strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);
    <span class="hljs-keyword">if</span> (strSubVersion.size() &gt; MAX_SUBVERSION_LENGTH) {
        <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments."</span>),
            strSubVersion.size(), MAX_SUBVERSION_LENGTH));
    }</code></pre> 
  <blockquote> 
   <p><code>-uacomment</code>：给用户代理字符串添加注释。</p> 
  </blockquote> 
  <p>首先将用户对代理的注释信息保存到<code>uacomments</code>中，将<code>CLIENT_NAME</code>、<code>CLIENT_VERSION</code>和<code>uacomments</code>按照<code>/CLIENT_NAME:CLIENT_VERSION(comments1;comments2;...)/</code>的格式连接起来，最后判断格式化后的字符串是否超过了最大长度限制，这个<code>MAX_SUBVERSION_LENGTH</code>在<code>src/net.h</code>中定义为<code>256</code>。</p> 
  <h3 id="设定网络范围">设定网络范围</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    <span class="hljs-keyword">if</span> (gArgs.IsArgSet(<span class="hljs-string">"-onlynet"</span>)) {
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">enum</span> Network&gt;</span> nets;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; snet : gArgs.GetArgs(<span class="hljs-string">"-onlynet"</span>)) {
            <span class="hljs-keyword">enum</span> Network net = ParseNetwork(snet);
            <span class="hljs-keyword">if</span> (net == NET_UNROUTABLE)
                <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Unknown network specified in -onlynet: '%s'"</span>), snet));
            nets.insert(net);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; NET_MAX; n++) {
            <span class="hljs-keyword">enum</span> Network net = (<span class="hljs-keyword">enum</span> Network)n;
            <span class="hljs-keyword">if</span> (!nets.count(net))
                SetLimited(net);
        }
    }</code></pre> 
  <blockquote> 
   <p><code>-onlynet</code>：只连接特定网络中的节点，取值有<code>NET_UNROUTABLE,NET_IPV4,NET_IPV6,NET_TOR,NET_INTERNAL</code>几种。</p> 
  </blockquote> 
  <p>首先看看<code>Network</code>的定义，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title">Network</span>
{
    NET_UNROUTABLE = <span class="hljs-number">0</span>,
    NET_IPV4,
    NET_IPV6,
    NET_TOR,
    NET_INTERNAL,

    NET_MAX,
};</code></pre> 
  <p>定义了几种网络，<code>-onlynet</code>则将连接范围限定在某一种或几种网络内。</p> 
  <h3 id="代理设置">代理设置</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs coffeescript">    <span class="hljs-regexp">//</span> Check <span class="hljs-keyword">for</span> host lookup allowed before parsing any network related parameters
    fNameLookup = gArgs.GetBoolArg(<span class="hljs-string">"-dns"</span>, DEFAULT_NAME_LOOKUP);

    bool proxyRandomize = gArgs.GetBoolArg(<span class="hljs-string">"-proxyrandomize"</span>, DEFAULT_PROXYRANDOMIZE);
    <span class="hljs-regexp">//</span> -proxy sets a proxy <span class="hljs-keyword">for</span> all outgoing network traffic
    <span class="hljs-regexp">//</span> -noproxy (<span class="hljs-keyword">or</span> -proxy=<span class="hljs-number">0</span>) as well as the empty string can be used to <span class="hljs-keyword">not</span> set a proxy, <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> the <span class="hljs-reserved">default</span>
    <span class="hljs-attribute">std</span>::string proxyArg = gArgs.GetArg(<span class="hljs-string">"-proxy"</span>, <span class="hljs-string">""</span>);
    SetLimited(NET_TOR);
    <span class="hljs-keyword">if</span> (proxyArg != <span class="hljs-string">""</span> &amp;&amp; proxyArg != <span class="hljs-string">"0"</span>) {
        CService proxyAddr;
        <span class="hljs-keyword">if</span> (!Lookup(proxyArg.c_str(), proxyAddr, <span class="hljs-number">9050</span>, fNameLookup)) {
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Invalid -proxy address or hostname: '%s'"</span>), proxyArg));
        }

        proxyType addrProxy = proxyType(proxyAddr, proxyRandomize);
        <span class="hljs-keyword">if</span> (!addrProxy.IsValid())
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Invalid -proxy address or hostname: '%s'"</span>), proxyArg));

        SetProxy(NET_IPV4, addrProxy);
        SetProxy(NET_IPV6, addrProxy);
        SetProxy(NET_TOR, addrProxy);
        SetNameProxy(addrProxy);
        SetLimited(NET_TOR, <span class="hljs-literal">false</span>); <span class="hljs-regexp">//</span> <span class="hljs-keyword">by</span> <span class="hljs-reserved">default</span>, -proxy sets onion as reachable, <span class="hljs-keyword">unless</span> -noonion later
    }</code></pre> 
  <blockquote> 
   <p><code>-dns</code>：允许进行dns解析，默认为1.</p> 
   <p><code>-proxyrandomize</code>：为每个代理连接都随机颁发一个证书，默认为1.</p> 
   <p><code>-proxy</code>：为网络所有的通信设置一个代理，默认为空。</p> 
  </blockquote> 
  <p>首先检查两个参数，然后通过<code>SetLimited(NET_TOR)</code>来禁用洋葱路由。然后检查如果代理不为空，那么根据代理域名进行dns查询，查到相应的ip并检查代理的合法性之后，再为<code>IPV4</code>、<code>IPV6</code>以及<code>TOR</code>设置代理。最后禁用<code>TOR</code>，因为在上面先禁用了，所以这里进行启用，其实这里设不设置都没关系，后面会根据<code>-onion</code>参数再进行相应的设置。</p> 
  <h3 id="设置洋葱路由">设置洋葱路由</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs lua">    // -onion can be used to set only a proxy <span class="hljs-keyword">for</span> .onion, <span class="hljs-keyword">or</span> override normal proxy <span class="hljs-keyword">for</span> .onion addresses
    // -noonion (<span class="hljs-keyword">or</span> -onion=<span class="hljs-number">0</span>) disables connecting to .onion entirely
    // An empty <span class="hljs-built_in">string</span> is used to <span class="hljs-keyword">not</span> override the onion proxy (<span class="hljs-keyword">in</span> which case it defaults to -proxy set above, <span class="hljs-keyword">or</span> none)
    std::<span class="hljs-built_in">string</span> onionArg = gArgs.GetArg(<span class="hljs-string">"-onion"</span>, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">if</span> (onionArg != <span class="hljs-string">""</span>) {
        <span class="hljs-keyword">if</span> (onionArg == <span class="hljs-string">"0"</span>) { // Handle -noonion/-onion=<span class="hljs-number">0</span>
            SetLimited(NET_TOR); // set onions as unreachable
        } <span class="hljs-keyword">else</span> {
            CService onionProxy;
            <span class="hljs-keyword">if</span> (!Lookup(onionArg.c_str(), onionProxy, <span class="hljs-number">9050</span>, fNameLookup)) {
                <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Invalid -onion address or hostname: '%s'"</span>), onionArg));
            }
            proxyType addrOnion = proxyType(onionProxy, proxyRandomize);
            <span class="hljs-keyword">if</span> (!addrOnion.IsValid())
                <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Invalid -onion address or hostname: '%s'"</span>), onionArg));
            SetProxy(NET_TOR, addrOnion);
            SetLimited(NET_TOR, <span class="hljs-keyword">false</span>);
        }
    }</code></pre> 
  <p>如果<code>-onion!="" &amp;&amp; != "0"</code>那么跟设置代理类似，首先解析域名，启用洋葱路由。</p> 
  <h3 id="设置external-ip">设置external ip</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    <span class="hljs-comment">// see Step 2: parameter interactions for more information about these</span>
    fListen = gArgs.GetBoolArg(<span class="hljs-string">"-listen"</span>, DEFAULT_LISTEN);
    fDiscover = gArgs.GetBoolArg(<span class="hljs-string">"-discover"</span>, <span class="hljs-keyword">true</span>);
    fRelayTxes = !gArgs.GetBoolArg(<span class="hljs-string">"-blocksonly"</span>, DEFAULT_BLOCKSONLY);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strAddr : gArgs.GetArgs(<span class="hljs-string">"-externalip"</span>)) {
        CService addrLocal;
        <span class="hljs-keyword">if</span> (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) &amp;&amp; addrLocal.IsValid())
            AddLocal(addrLocal, LOCAL_MANUAL);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> InitError(ResolveErrMsg(<span class="hljs-string">"externalip"</span>, strAddr));
    }</code></pre> 
  <blockquote> 
   <p><code>-listen</code>：接受从某个地址的连接请求。</p> 
   <p><code>-discover</code>：发现拥有的ip地址。</p> 
   <p><code>-blocksonly</code>：让节点进入<code>blocksonly</code>模式。</p> 
   <p><code>-externalip</code>：指定公有地址。</p> 
  </blockquote> 
  <p>前面两个参数比较好理解，那么什么是<code>blocksonly</code>模式呢？根据<a href="https://bitcointalk.org/index.php?topic=1377345.0" rel="nofollow" target="_blank">https://bitcointalk.org/index.php?topic=1377345.0</a>的解释，</p> 
  <blockquote> 
   <p>Bitcoin Core 0.12 introduced a new blocksonly setting. When set to blocksonly a node behaves normally but sends and receives no lose transactions; instead it handles only complete blocks. There are many applications for nodes where only confirmed transactions are interesting, and a node which still verifies and forwards blocks still contributes to network health– less, perhaps, than one that relays transactions: but it also consumes fewer resources to begin with. An additional downside they don’t get the latency advantages of signature caching since every transaction they see is totally new to them– this isn’t something miners should use.</p> 
   <p>How much less bandwidth does blocksonly use in practice? I recently measured this using two techniques: Once by instrumenting a node to measure bandwidth used for blocks vs all other traffic, and again by repeatedly running in both modes for a day and monitoring the hosts total network usage; both modes gave effectively the same result.</p> 
   <p>How much is the savings? Blocksonly reduced the node’s bandwidth usage by <strong>88%</strong>.</p> 
  </blockquote> 
  <p>简单来说，就是节点不接收临时的交易，只接受已确认的区块。</p> 
  <p>接下来对于指定的<code>external ip</code>首先查询对应的ip（指定的可以是域名，或者将字符串ip转换成<code>CService</code>），然后通过<code>AddLocal</code>将指定的ip添加到<code>mapLocalHost</code>中，由这个结构维护所有的本地ip。</p> 
  <h3 id="zmq">ZMQ</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> ENABLE_ZMQ</span>
    pzmqNotificationInterface = CZMQNotificationInterface::Create();

    <span class="hljs-keyword">if</span> (pzmqNotificationInterface) {
        RegisterValidationInterface(pzmqNotificationInterface);
    }
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    uint64_t nMaxOutboundLimit = <span class="hljs-number">0</span>; <span class="hljs-comment">//unlimited unless -maxuploadtarget is set</span>
    uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME;

    <span class="hljs-keyword">if</span> (gArgs.IsArgSet(<span class="hljs-string">"-maxuploadtarget"</span>)) {
        nMaxOutboundLimit = gArgs.GetArg(<span class="hljs-string">"-maxuploadtarget"</span>, DEFAULT_MAX_UPLOAD_TARGET)*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;
    }</code></pre> 
  <blockquote> 
   <p><code>-maxuploadtarget</code>：设置最大上传速度，单位为MB，默认值为0，表示没有限制。</p> 
  </blockquote> 
  <p>首先通过一个宏定义来表示是否启用<code>ZMQ</code>，关于zmq的介绍，参考<a href="https://www.cnblogs.com/rainbowzc/p/3357594.html" rel="nofollow" target="_blank">https://www.cnblogs.com/rainbowzc/p/3357594.html</a>，简单来说，zmq封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。本章的前面介绍了<code>RegisterValidationInterface</code>函数，此函数注册了许多区块处理的信号。然后下面通过<code>-maxuploadtarget</code>参数来设置最大上传速度。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78516016,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78516016,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
