<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于以太坊代币开发数组增删改查的合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于以太坊代币开发数组增删改查的合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链爱好者（QQ：53016353） 一个简单的实现对数组增删改查的智能合约 pragma solidity 0.4.9; /*数组类型Demo*/ contract DemoTypes303 { &nbsp; /*String数组例子*/ &nbsp; string[] strArr; &nbsp; function add(string str){ &nbsp; &nbsp; strArr.push(str); &nbsp; } &nbsp; function getStrAt(uint n) constant returns (string s){ &nbsp; &nbsp; string tmp = strArr[n]; &nbsp; &nbsp; return tmp; &nbsp; } &nbsp; function updateStrAt(uint n, string str) { &nbsp; &nbsp; strArr[n] = str; &nbsp; } &nbsp; function deleteStrAt(uint index) { &nbsp; &nbsp; uint len = strArr.length; &nbsp; &nbsp; if (index &gt;= len) return; &nbsp; &nbsp; for (uint i = index; i&lt;len-1; i++) { &nbsp; &nbsp; &nbsp; strArr[i] = strArr[i+1]; &nbsp; &nbsp; } &nbsp; &nbsp; delete strArr[len-1]; &nbsp; &nbsp; strArr.length--; &nbsp; } } 代码分析 string[] strArr; 定义了一个字符串的数组变量strArr, 且该变量没有public因此不可见 strArr.push(str); 其中的push是数组类型的两个member之一，另一个是length. 这里的push就是给该数组增加一个元素。//这里实现了对数组的新增功能 function add(string str){ &nbsp; strArr.push(str); } getStrAt(uint n) 是一个简单的读取字符串的函数，//这里实现对数组的读取功能 updateStrAt(uint n, string str) // 实现对数组的更新功能 deleteStrAt(uint index) 这个值得一说，因为solidity默认的数组类型中没有删除功能，因此此处自己写了一个删除代码，核心方法就是保证删除某项后，后面的元素依次向前，同时删除数据，同时保证数组的member length正确。 Browser solidity 部署和调用p111 将上面的代码复制黏贴到Browser-solidity上面，可以看到编译成功，并生成了可部署的web3 deploy代码。 这里我们在内存中试试看该智能合约的4个基本方法 增删改查 1. add function p1 输入hello 01, 然后点击add按钮，我们可以看到在经过一部分gas的消耗后，该数据被执行成功！ PS：需要注意的是这里的getStrAt和add，update,delete等方法颜色不同，按上方的分类，一个是transaction，一个则是call，因此在geth上的调用方法也是不同的。 2. getStrAt function 既然已经增加了一个元素，我们就可以查看数组strArr的数值了，根据数组常识，我们只增加了一个元素，因此getStrAt[0] 应该为hello 01. 而getStrAt[1] 则应该为错误。 实际结果如下：getStrAt[0] p2 getStrAt[1]: p3 3. updateStrAt functoin p4 4. deleteStrAt function 要测试这个方法，稍微麻烦点，最好是 step 1需要先add(“hello 01”), add(“hello 02”)，add(“hello 03”) step 2然后调用deleteStrAt(0); step 3 检查是否第一项被删除，而getStrAt(0)应该等于”hello 02″, getStrAt(1)应该等于”hello 03″ 然后重复step1-3,作用于deleteStrAt(1),删除中间项目，或者deleteStrAt(2)删除最后一项，还有deleteStrAt(3)/deleteStrAt(100)/deleteStrAt(-100) 等检查是否做了边界检查。 这里时间有限，就不试验了，有兴趣的同学可以自己在browser solidity上面尝试。 作为礼物，这里有另外的几个简单的智能合约，有兴趣的同学都可以多用browser-solidity来尝试 pragma solidity ^0.4.4; contract DemoTypes { &nbsp; /*uint public resultOfF;*/ &nbsp; event LogUint(uint value); &nbsp; event LogInt (int value); &nbsp; function f(uint a) returns (uint b) &nbsp; { &nbsp; &nbsp; uint result = a * 8; &nbsp; &nbsp; /*resultOfF = result; //debug used only;*/ &nbsp; &nbsp; LogUint(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入长度宽度，返回面积*/ &nbsp; function f2(int width, int height) returns (int square) { &nbsp; &nbsp; if (width &lt; 0 || height &lt; 0) throw; &nbsp; &nbsp; int result = width * height; &nbsp; &nbsp; LogInt(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入N，计算N的阶乘，循环实现*/ &nbsp; function f3(uint n) returns (uint jiecheng) { &nbsp; &nbsp; if (n == 0) throw; uint result = 1; &nbsp; &nbsp; for (uint i=1; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result *= i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*计算从1到N的求和*/ &nbsp; function f4(uint n) returns (uint sum) { &nbsp; &nbsp; if (n == 0) throw; uint result = 0; &nbsp; &nbsp; for (uint i=0; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result +=i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } } 下一章我们将介绍一个简化版的代币合约，敬请期待！ ————————————————————————————————————— 先从最小化的Token合约开始； pragma solidity 0.4.9; contract Token { &nbsp; function Token() { &nbsp; } } 之前有说过，solidity是类js的语言，和所有的面向对象语言一样，solidity也拥有最基本的构造函数。 上面的代码就是一个最简单化的一个Token合约，function Token() {}是该contract 的构造函数。 该合约在browser-solidity上可以执行成功，这里就不演示了。 我们给这个Token代币合约添加一个数字数组，并赋予一个初值。 pragma solidity 0.4.9; contract Token2 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } } 这个合约很简单，先定义了一个public的变量balancesOf, 然后在构造阶段，就给这个变量添加两个初始值。100 &amp; 200 p5 用户先点击Token这个构造函数，然后再输入0和1,然后点击balancesOf 可以分别看到两个数值。 p6 给该Token合约添加一个账户转账功能 transfer() pragma solidity 0.4.9; contract Token3 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } } transfer功能的代码就是把一定量_amount 从_from转移到_to; 该功能在browser solidity调试成功，如下图所示： p7 给Token代币合约，增加一个挖矿方法 mint() 如上面的代码所示，我们可以看到，只有在构造函数的时候balancesOf才有赋值，之后的transfer无论如何操作，总量始终不变。因此我们可以增加一个挖矿方法，增加的金额默认都归纳到第一个账号中 balancesOf[0]中。 pragma solidity 0.4.9; contract Token4 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } &nbsp; function mint(uint value) { &nbsp; &nbsp; balancesOf[0] += value; &nbsp; } } 通过mint() 我们就可以随意的给balancesOf[0] 增加代币了。该代码有兴趣的同学，请在browser-solidity上实验。 注意以上代码只用于学习使用，很多场景还未考虑，例如transfer中没有考虑_amount&gt;当前账户余额的场景。不可用于商业化应用。 本文初步介绍了Token的核心功能，包括构造，挖矿、转账等。 但是，我们知道以太坊的核心是账户体系和智能合约，真正有意义的是在各个账户之间可以流通的代币合约。有了这些代币，我们才能用于众筹、众包等各种商业应用的实现。 下篇将介绍一个包含账户的代币合约 —————————————————————————————————————————— 基于账户地址的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } } mapping 关键词的定义 Mapping types are declared as mapping(_KeyType =&gt; _ValueType). Here _KeyType can be almost any type except for a mapping, a dynamically sized array, a contract, an enum and a struct. _ValueType can actually be any type, including mappings. Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s default value. 引用自here address的定义： address: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as base for all contracts. members of addresses: balance and send 引用自here 这里的address简单地说就是geth中的账户的地址（公钥） 因此此处的代码mapping (address =&gt; uint) balancesOf 代表定义了一个 key为address类型, value为uint类型的hashtable，名字为 balancesOf. 所以任何在区块链私链上的账户都可以通过balancesOf[address] 来查询他们的代币数量。 msg 的定义 msg就是指谁调用该智能合约时候发来的信息，之前说过智能合约也是一个账户。因此在以太坊中调用智能合约从底层看来就是一个账户给智能合约账户发送了一个transaction，里面包含了谁发送的，发送了多少以太币，发送了多少gas 下面是msg的一些变量 msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message 引用自here 最主要的就是msg.sender,代表那个账户调用该智能合约。msg.value 因此balancesOf[msg.sender] = 10000; 代表给msg.sender也就是创建该合约的地址赋予一个初始值 10000; 一个带transfer &amp; 挖矿的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; address public owner; &nbsp; function Token() { &nbsp; &nbsp; owner = msg.sender; &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } &nbsp; function transfer(address _to, uint _value) { &nbsp; &nbsp; if (balancesOf[msg.sender] &lt; _value) throw; //避免转移出去的代币超过当前的存货 &nbsp; &nbsp; if (balancesOf[_to] + _value &lt; balancesOf[_to]) throw; //避免自己调用自己，或者递归调用 &nbsp; &nbsp; balancesOf[msg.sender] -= _value; &nbsp; &nbsp; balancesOf[_to] += _value; &nbsp; } &nbsp; function mint(uint _amount) { &nbsp; &nbsp; balancesOf[owner] += _amount; &nbsp; } } 在上面的代码中，我们设置一个public owner, 保存下创建合约的msg.sender, 记录下创建者的地址。 在function transfer()中，我们设置了两个条件，避免转移出去的代币超过存货的情况，以及自己转移给自己的问题。 在function mint()中，我们给合约的owner增加我们定义的代币。从而让其方便的分给别人。 以上合约代码在Browser-solidity上调试通过，查看下图 p8 我们在代码中将owner = msg.sender,因此owner就是创建合约的地址。我们可以看到balancesOf[owner] 的数据为10000，和代码相同。 p9 调用方法mint(500)，自动给balancesOf[owner] += 500；查看存额从10000增加到10500. p10 调用方法 transfer(&quot;0xccccc&quot;,300), 可以看到owner的存额减少300，balancesOf[“0xccccc”]增加300. p11 这个合约实现了最简化的代币功能，但在browser-solidity中我们可以看到一个很明显的问题，那就是没有和我们在第二部分中所搭建的geth中的几个以太坊账号结合起来。 下一章我们将介绍另一个非常有用的工具Mist，从而将智能合约、Geth、Mist结合起来。真正在以太坊私有链上运行智能合约。 阅读更多" />
<meta property="og:description" content="区块链爱好者（QQ：53016353） 一个简单的实现对数组增删改查的智能合约 pragma solidity 0.4.9; /*数组类型Demo*/ contract DemoTypes303 { &nbsp; /*String数组例子*/ &nbsp; string[] strArr; &nbsp; function add(string str){ &nbsp; &nbsp; strArr.push(str); &nbsp; } &nbsp; function getStrAt(uint n) constant returns (string s){ &nbsp; &nbsp; string tmp = strArr[n]; &nbsp; &nbsp; return tmp; &nbsp; } &nbsp; function updateStrAt(uint n, string str) { &nbsp; &nbsp; strArr[n] = str; &nbsp; } &nbsp; function deleteStrAt(uint index) { &nbsp; &nbsp; uint len = strArr.length; &nbsp; &nbsp; if (index &gt;= len) return; &nbsp; &nbsp; for (uint i = index; i&lt;len-1; i++) { &nbsp; &nbsp; &nbsp; strArr[i] = strArr[i+1]; &nbsp; &nbsp; } &nbsp; &nbsp; delete strArr[len-1]; &nbsp; &nbsp; strArr.length--; &nbsp; } } 代码分析 string[] strArr; 定义了一个字符串的数组变量strArr, 且该变量没有public因此不可见 strArr.push(str); 其中的push是数组类型的两个member之一，另一个是length. 这里的push就是给该数组增加一个元素。//这里实现了对数组的新增功能 function add(string str){ &nbsp; strArr.push(str); } getStrAt(uint n) 是一个简单的读取字符串的函数，//这里实现对数组的读取功能 updateStrAt(uint n, string str) // 实现对数组的更新功能 deleteStrAt(uint index) 这个值得一说，因为solidity默认的数组类型中没有删除功能，因此此处自己写了一个删除代码，核心方法就是保证删除某项后，后面的元素依次向前，同时删除数据，同时保证数组的member length正确。 Browser solidity 部署和调用p111 将上面的代码复制黏贴到Browser-solidity上面，可以看到编译成功，并生成了可部署的web3 deploy代码。 这里我们在内存中试试看该智能合约的4个基本方法 增删改查 1. add function p1 输入hello 01, 然后点击add按钮，我们可以看到在经过一部分gas的消耗后，该数据被执行成功！ PS：需要注意的是这里的getStrAt和add，update,delete等方法颜色不同，按上方的分类，一个是transaction，一个则是call，因此在geth上的调用方法也是不同的。 2. getStrAt function 既然已经增加了一个元素，我们就可以查看数组strArr的数值了，根据数组常识，我们只增加了一个元素，因此getStrAt[0] 应该为hello 01. 而getStrAt[1] 则应该为错误。 实际结果如下：getStrAt[0] p2 getStrAt[1]: p3 3. updateStrAt functoin p4 4. deleteStrAt function 要测试这个方法，稍微麻烦点，最好是 step 1需要先add(“hello 01”), add(“hello 02”)，add(“hello 03”) step 2然后调用deleteStrAt(0); step 3 检查是否第一项被删除，而getStrAt(0)应该等于”hello 02″, getStrAt(1)应该等于”hello 03″ 然后重复step1-3,作用于deleteStrAt(1),删除中间项目，或者deleteStrAt(2)删除最后一项，还有deleteStrAt(3)/deleteStrAt(100)/deleteStrAt(-100) 等检查是否做了边界检查。 这里时间有限，就不试验了，有兴趣的同学可以自己在browser solidity上面尝试。 作为礼物，这里有另外的几个简单的智能合约，有兴趣的同学都可以多用browser-solidity来尝试 pragma solidity ^0.4.4; contract DemoTypes { &nbsp; /*uint public resultOfF;*/ &nbsp; event LogUint(uint value); &nbsp; event LogInt (int value); &nbsp; function f(uint a) returns (uint b) &nbsp; { &nbsp; &nbsp; uint result = a * 8; &nbsp; &nbsp; /*resultOfF = result; //debug used only;*/ &nbsp; &nbsp; LogUint(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入长度宽度，返回面积*/ &nbsp; function f2(int width, int height) returns (int square) { &nbsp; &nbsp; if (width &lt; 0 || height &lt; 0) throw; &nbsp; &nbsp; int result = width * height; &nbsp; &nbsp; LogInt(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入N，计算N的阶乘，循环实现*/ &nbsp; function f3(uint n) returns (uint jiecheng) { &nbsp; &nbsp; if (n == 0) throw; uint result = 1; &nbsp; &nbsp; for (uint i=1; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result *= i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*计算从1到N的求和*/ &nbsp; function f4(uint n) returns (uint sum) { &nbsp; &nbsp; if (n == 0) throw; uint result = 0; &nbsp; &nbsp; for (uint i=0; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result +=i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } } 下一章我们将介绍一个简化版的代币合约，敬请期待！ ————————————————————————————————————— 先从最小化的Token合约开始； pragma solidity 0.4.9; contract Token { &nbsp; function Token() { &nbsp; } } 之前有说过，solidity是类js的语言，和所有的面向对象语言一样，solidity也拥有最基本的构造函数。 上面的代码就是一个最简单化的一个Token合约，function Token() {}是该contract 的构造函数。 该合约在browser-solidity上可以执行成功，这里就不演示了。 我们给这个Token代币合约添加一个数字数组，并赋予一个初值。 pragma solidity 0.4.9; contract Token2 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } } 这个合约很简单，先定义了一个public的变量balancesOf, 然后在构造阶段，就给这个变量添加两个初始值。100 &amp; 200 p5 用户先点击Token这个构造函数，然后再输入0和1,然后点击balancesOf 可以分别看到两个数值。 p6 给该Token合约添加一个账户转账功能 transfer() pragma solidity 0.4.9; contract Token3 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } } transfer功能的代码就是把一定量_amount 从_from转移到_to; 该功能在browser solidity调试成功，如下图所示： p7 给Token代币合约，增加一个挖矿方法 mint() 如上面的代码所示，我们可以看到，只有在构造函数的时候balancesOf才有赋值，之后的transfer无论如何操作，总量始终不变。因此我们可以增加一个挖矿方法，增加的金额默认都归纳到第一个账号中 balancesOf[0]中。 pragma solidity 0.4.9; contract Token4 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } &nbsp; function mint(uint value) { &nbsp; &nbsp; balancesOf[0] += value; &nbsp; } } 通过mint() 我们就可以随意的给balancesOf[0] 增加代币了。该代码有兴趣的同学，请在browser-solidity上实验。 注意以上代码只用于学习使用，很多场景还未考虑，例如transfer中没有考虑_amount&gt;当前账户余额的场景。不可用于商业化应用。 本文初步介绍了Token的核心功能，包括构造，挖矿、转账等。 但是，我们知道以太坊的核心是账户体系和智能合约，真正有意义的是在各个账户之间可以流通的代币合约。有了这些代币，我们才能用于众筹、众包等各种商业应用的实现。 下篇将介绍一个包含账户的代币合约 —————————————————————————————————————————— 基于账户地址的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } } mapping 关键词的定义 Mapping types are declared as mapping(_KeyType =&gt; _ValueType). Here _KeyType can be almost any type except for a mapping, a dynamically sized array, a contract, an enum and a struct. _ValueType can actually be any type, including mappings. Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s default value. 引用自here address的定义： address: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as base for all contracts. members of addresses: balance and send 引用自here 这里的address简单地说就是geth中的账户的地址（公钥） 因此此处的代码mapping (address =&gt; uint) balancesOf 代表定义了一个 key为address类型, value为uint类型的hashtable，名字为 balancesOf. 所以任何在区块链私链上的账户都可以通过balancesOf[address] 来查询他们的代币数量。 msg 的定义 msg就是指谁调用该智能合约时候发来的信息，之前说过智能合约也是一个账户。因此在以太坊中调用智能合约从底层看来就是一个账户给智能合约账户发送了一个transaction，里面包含了谁发送的，发送了多少以太币，发送了多少gas 下面是msg的一些变量 msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message 引用自here 最主要的就是msg.sender,代表那个账户调用该智能合约。msg.value 因此balancesOf[msg.sender] = 10000; 代表给msg.sender也就是创建该合约的地址赋予一个初始值 10000; 一个带transfer &amp; 挖矿的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; address public owner; &nbsp; function Token() { &nbsp; &nbsp; owner = msg.sender; &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } &nbsp; function transfer(address _to, uint _value) { &nbsp; &nbsp; if (balancesOf[msg.sender] &lt; _value) throw; //避免转移出去的代币超过当前的存货 &nbsp; &nbsp; if (balancesOf[_to] + _value &lt; balancesOf[_to]) throw; //避免自己调用自己，或者递归调用 &nbsp; &nbsp; balancesOf[msg.sender] -= _value; &nbsp; &nbsp; balancesOf[_to] += _value; &nbsp; } &nbsp; function mint(uint _amount) { &nbsp; &nbsp; balancesOf[owner] += _amount; &nbsp; } } 在上面的代码中，我们设置一个public owner, 保存下创建合约的msg.sender, 记录下创建者的地址。 在function transfer()中，我们设置了两个条件，避免转移出去的代币超过存货的情况，以及自己转移给自己的问题。 在function mint()中，我们给合约的owner增加我们定义的代币。从而让其方便的分给别人。 以上合约代码在Browser-solidity上调试通过，查看下图 p8 我们在代码中将owner = msg.sender,因此owner就是创建合约的地址。我们可以看到balancesOf[owner] 的数据为10000，和代码相同。 p9 调用方法mint(500)，自动给balancesOf[owner] += 500；查看存额从10000增加到10500. p10 调用方法 transfer(&quot;0xccccc&quot;,300), 可以看到owner的存额减少300，balancesOf[“0xccccc”]增加300. p11 这个合约实现了最简化的代币功能，但在browser-solidity中我们可以看到一个很明显的问题，那就是没有和我们在第二部分中所搭建的geth中的几个以太坊账号结合起来。 下一章我们将介绍另一个非常有用的工具Mist，从而将智能合约、Geth、Mist结合起来。真正在以太坊私有链上运行智能合约。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/11/14/1b49c00d2793354170ff178b8a2f35e1.html" />
<meta property="og:url" content="https://mlh.app/2017/11/14/1b49c00d2793354170ff178b8a2f35e1.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链爱好者（QQ：53016353） 一个简单的实现对数组增删改查的智能合约 pragma solidity 0.4.9; /*数组类型Demo*/ contract DemoTypes303 { &nbsp; /*String数组例子*/ &nbsp; string[] strArr; &nbsp; function add(string str){ &nbsp; &nbsp; strArr.push(str); &nbsp; } &nbsp; function getStrAt(uint n) constant returns (string s){ &nbsp; &nbsp; string tmp = strArr[n]; &nbsp; &nbsp; return tmp; &nbsp; } &nbsp; function updateStrAt(uint n, string str) { &nbsp; &nbsp; strArr[n] = str; &nbsp; } &nbsp; function deleteStrAt(uint index) { &nbsp; &nbsp; uint len = strArr.length; &nbsp; &nbsp; if (index &gt;= len) return; &nbsp; &nbsp; for (uint i = index; i&lt;len-1; i++) { &nbsp; &nbsp; &nbsp; strArr[i] = strArr[i+1]; &nbsp; &nbsp; } &nbsp; &nbsp; delete strArr[len-1]; &nbsp; &nbsp; strArr.length--; &nbsp; } } 代码分析 string[] strArr; 定义了一个字符串的数组变量strArr, 且该变量没有public因此不可见 strArr.push(str); 其中的push是数组类型的两个member之一，另一个是length. 这里的push就是给该数组增加一个元素。//这里实现了对数组的新增功能 function add(string str){ &nbsp; strArr.push(str); } getStrAt(uint n) 是一个简单的读取字符串的函数，//这里实现对数组的读取功能 updateStrAt(uint n, string str) // 实现对数组的更新功能 deleteStrAt(uint index) 这个值得一说，因为solidity默认的数组类型中没有删除功能，因此此处自己写了一个删除代码，核心方法就是保证删除某项后，后面的元素依次向前，同时删除数据，同时保证数组的member length正确。 Browser solidity 部署和调用p111 将上面的代码复制黏贴到Browser-solidity上面，可以看到编译成功，并生成了可部署的web3 deploy代码。 这里我们在内存中试试看该智能合约的4个基本方法 增删改查 1. add function p1 输入hello 01, 然后点击add按钮，我们可以看到在经过一部分gas的消耗后，该数据被执行成功！ PS：需要注意的是这里的getStrAt和add，update,delete等方法颜色不同，按上方的分类，一个是transaction，一个则是call，因此在geth上的调用方法也是不同的。 2. getStrAt function 既然已经增加了一个元素，我们就可以查看数组strArr的数值了，根据数组常识，我们只增加了一个元素，因此getStrAt[0] 应该为hello 01. 而getStrAt[1] 则应该为错误。 实际结果如下：getStrAt[0] p2 getStrAt[1]: p3 3. updateStrAt functoin p4 4. deleteStrAt function 要测试这个方法，稍微麻烦点，最好是 step 1需要先add(“hello 01”), add(“hello 02”)，add(“hello 03”) step 2然后调用deleteStrAt(0); step 3 检查是否第一项被删除，而getStrAt(0)应该等于”hello 02″, getStrAt(1)应该等于”hello 03″ 然后重复step1-3,作用于deleteStrAt(1),删除中间项目，或者deleteStrAt(2)删除最后一项，还有deleteStrAt(3)/deleteStrAt(100)/deleteStrAt(-100) 等检查是否做了边界检查。 这里时间有限，就不试验了，有兴趣的同学可以自己在browser solidity上面尝试。 作为礼物，这里有另外的几个简单的智能合约，有兴趣的同学都可以多用browser-solidity来尝试 pragma solidity ^0.4.4; contract DemoTypes { &nbsp; /*uint public resultOfF;*/ &nbsp; event LogUint(uint value); &nbsp; event LogInt (int value); &nbsp; function f(uint a) returns (uint b) &nbsp; { &nbsp; &nbsp; uint result = a * 8; &nbsp; &nbsp; /*resultOfF = result; //debug used only;*/ &nbsp; &nbsp; LogUint(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入长度宽度，返回面积*/ &nbsp; function f2(int width, int height) returns (int square) { &nbsp; &nbsp; if (width &lt; 0 || height &lt; 0) throw; &nbsp; &nbsp; int result = width * height; &nbsp; &nbsp; LogInt(result); &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*输入N，计算N的阶乘，循环实现*/ &nbsp; function f3(uint n) returns (uint jiecheng) { &nbsp; &nbsp; if (n == 0) throw; uint result = 1; &nbsp; &nbsp; for (uint i=1; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result *= i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } &nbsp; /*计算从1到N的求和*/ &nbsp; function f4(uint n) returns (uint sum) { &nbsp; &nbsp; if (n == 0) throw; uint result = 0; &nbsp; &nbsp; for (uint i=0; i&lt;=n; i++) { &nbsp; &nbsp; &nbsp; result +=i; &nbsp; &nbsp; } &nbsp; &nbsp; return result; &nbsp; } } 下一章我们将介绍一个简化版的代币合约，敬请期待！ ————————————————————————————————————— 先从最小化的Token合约开始； pragma solidity 0.4.9; contract Token { &nbsp; function Token() { &nbsp; } } 之前有说过，solidity是类js的语言，和所有的面向对象语言一样，solidity也拥有最基本的构造函数。 上面的代码就是一个最简单化的一个Token合约，function Token() {}是该contract 的构造函数。 该合约在browser-solidity上可以执行成功，这里就不演示了。 我们给这个Token代币合约添加一个数字数组，并赋予一个初值。 pragma solidity 0.4.9; contract Token2 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } } 这个合约很简单，先定义了一个public的变量balancesOf, 然后在构造阶段，就给这个变量添加两个初始值。100 &amp; 200 p5 用户先点击Token这个构造函数，然后再输入0和1,然后点击balancesOf 可以分别看到两个数值。 p6 给该Token合约添加一个账户转账功能 transfer() pragma solidity 0.4.9; contract Token3 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } } transfer功能的代码就是把一定量_amount 从_from转移到_to; 该功能在browser solidity调试成功，如下图所示： p7 给Token代币合约，增加一个挖矿方法 mint() 如上面的代码所示，我们可以看到，只有在构造函数的时候balancesOf才有赋值，之后的transfer无论如何操作，总量始终不变。因此我们可以增加一个挖矿方法，增加的金额默认都归纳到第一个账号中 balancesOf[0]中。 pragma solidity 0.4.9; contract Token4 { &nbsp; uint[] public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf.push(100); &nbsp; &nbsp; balancesOf.push(200); &nbsp; } &nbsp; function transfer(uint _from, uint _to, uint _amount) { &nbsp; &nbsp; balancesOf[_from] -= _amount; &nbsp; &nbsp; balancesOf[_to] += _amount; &nbsp; } &nbsp; function mint(uint value) { &nbsp; &nbsp; balancesOf[0] += value; &nbsp; } } 通过mint() 我们就可以随意的给balancesOf[0] 增加代币了。该代码有兴趣的同学，请在browser-solidity上实验。 注意以上代码只用于学习使用，很多场景还未考虑，例如transfer中没有考虑_amount&gt;当前账户余额的场景。不可用于商业化应用。 本文初步介绍了Token的核心功能，包括构造，挖矿、转账等。 但是，我们知道以太坊的核心是账户体系和智能合约，真正有意义的是在各个账户之间可以流通的代币合约。有了这些代币，我们才能用于众筹、众包等各种商业应用的实现。 下篇将介绍一个包含账户的代币合约 —————————————————————————————————————————— 基于账户地址的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; function Token() { &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } } mapping 关键词的定义 Mapping types are declared as mapping(_KeyType =&gt; _ValueType). Here _KeyType can be almost any type except for a mapping, a dynamically sized array, a contract, an enum and a struct. _ValueType can actually be any type, including mappings. Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s default value. 引用自here address的定义： address: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as base for all contracts. members of addresses: balance and send 引用自here 这里的address简单地说就是geth中的账户的地址（公钥） 因此此处的代码mapping (address =&gt; uint) balancesOf 代表定义了一个 key为address类型, value为uint类型的hashtable，名字为 balancesOf. 所以任何在区块链私链上的账户都可以通过balancesOf[address] 来查询他们的代币数量。 msg 的定义 msg就是指谁调用该智能合约时候发来的信息，之前说过智能合约也是一个账户。因此在以太坊中调用智能合约从底层看来就是一个账户给智能合约账户发送了一个transaction，里面包含了谁发送的，发送了多少以太币，发送了多少gas 下面是msg的一些变量 msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message 引用自here 最主要的就是msg.sender,代表那个账户调用该智能合约。msg.value 因此balancesOf[msg.sender] = 10000; 代表给msg.sender也就是创建该合约的地址赋予一个初始值 10000; 一个带transfer &amp; 挖矿的Token合约 pragma solidity 0.4.9; contract Token { &nbsp; mapping (address =&gt; uint) public balancesOf; &nbsp; address public owner; &nbsp; function Token() { &nbsp; &nbsp; owner = msg.sender; &nbsp; &nbsp; balancesOf[msg.sender] = 10000; &nbsp; } &nbsp; function transfer(address _to, uint _value) { &nbsp; &nbsp; if (balancesOf[msg.sender] &lt; _value) throw; //避免转移出去的代币超过当前的存货 &nbsp; &nbsp; if (balancesOf[_to] + _value &lt; balancesOf[_to]) throw; //避免自己调用自己，或者递归调用 &nbsp; &nbsp; balancesOf[msg.sender] -= _value; &nbsp; &nbsp; balancesOf[_to] += _value; &nbsp; } &nbsp; function mint(uint _amount) { &nbsp; &nbsp; balancesOf[owner] += _amount; &nbsp; } } 在上面的代码中，我们设置一个public owner, 保存下创建合约的msg.sender, 记录下创建者的地址。 在function transfer()中，我们设置了两个条件，避免转移出去的代币超过存货的情况，以及自己转移给自己的问题。 在function mint()中，我们给合约的owner增加我们定义的代币。从而让其方便的分给别人。 以上合约代码在Browser-solidity上调试通过，查看下图 p8 我们在代码中将owner = msg.sender,因此owner就是创建合约的地址。我们可以看到balancesOf[owner] 的数据为10000，和代码相同。 p9 调用方法mint(500)，自动给balancesOf[owner] += 500；查看存额从10000增加到10500. p10 调用方法 transfer(&quot;0xccccc&quot;,300), 可以看到owner的存额减少300，balancesOf[“0xccccc”]增加300. p11 这个合约实现了最简化的代币功能，但在browser-solidity中我们可以看到一个很明显的问题，那就是没有和我们在第二部分中所搭建的geth中的几个以太坊账号结合起来。 下一章我们将介绍另一个非常有用的工具Mist，从而将智能合约、Geth、Mist结合起来。真正在以太坊私有链上运行智能合约。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/11/14/1b49c00d2793354170ff178b8a2f35e1.html","headline":"基于以太坊代币开发数组增删改查的合约","dateModified":"2017-11-14T00:00:00+08:00","datePublished":"2017-11-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/11/14/1b49c00d2793354170ff178b8a2f35e1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于以太坊代币开发数组增删改查的合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;"><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353）</span><br></p> 
  <p>一个简单的实现对数组增删改查的智能合约</p> pragma solidity 0.4.9;
  <br> /*数组类型Demo*/
  <br> contract DemoTypes303 {
  <br> &nbsp; /*String数组例子*/
  <br> &nbsp; string[] strArr;
  <br> &nbsp; function add(string str){
  <br> &nbsp; &nbsp; strArr.push(str);
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function getStrAt(uint n) constant returns (string s){
  <br> &nbsp; &nbsp; string tmp = strArr[n];
  <br> &nbsp; &nbsp; return tmp;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function updateStrAt(uint n, string str) {
  <br> &nbsp; &nbsp; strArr[n] = str;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function deleteStrAt(uint index) {
  <br> &nbsp; &nbsp; uint len = strArr.length;
  <br> &nbsp; &nbsp; if (index &gt;= len) return;
  <br> &nbsp; &nbsp; for (uint i = index; i&lt;len-1; i++) {
  <br> &nbsp; &nbsp; &nbsp; strArr[i] = strArr[i+1];
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; delete strArr[len-1];
  <br> &nbsp; &nbsp; strArr.length--;
  <br> &nbsp; }
  <br> }
  <br> 代码分析
  <br> string[] strArr; 定义了一个字符串的数组变量strArr, 且该变量没有public因此不可见
  <br> strArr.push(str); 其中的push是数组类型的两个member之一，另一个是length. 这里的push就是给该数组增加一个元素。//这里实现了对数组的新增功能
  <br> function add(string str){
  <br> &nbsp; strArr.push(str);
  <br> }
  <br> getStrAt(uint n) 是一个简单的读取字符串的函数，//这里实现对数组的读取功能
  <br> updateStrAt(uint n, string str) // 实现对数组的更新功能
  <br> deleteStrAt(uint index) 这个值得一说，因为solidity默认的数组类型中没有删除功能，因此此处自己写了一个删除代码，核心方法就是保证删除某项后，后面的元素依次向前，同时删除数据，同时保证数组的member length正确。
  <br> Browser solidity 部署和调用p111
  <br> 将上面的代码复制黏贴到Browser-solidity上面，可以看到编译成功，并生成了可部署的web3 deploy代码。
  <br> 这里我们在内存中试试看该智能合约的4个基本方法 增删改查
  <br>
  <br>
  <br> 1. add function
  <br>
  <br>
  <br> p1
  <br>
  <br>
  <br> 输入hello 01, 然后点击add按钮，我们可以看到在经过一部分gas的消耗后，该数据被执行成功！
  <br> PS：需要注意的是这里的getStrAt和add，update,delete等方法颜色不同，按上方的分类，一个是transaction，一个则是call，因此在geth上的调用方法也是不同的。
  <br> 2. getStrAt function
  <br>
  <br>
  <br> 既然已经增加了一个元素，我们就可以查看数组strArr的数值了，根据数组常识，我们只增加了一个元素，因此getStrAt[0] 应该为hello 01. 而getStrAt[1] 则应该为错误。
  <br>
  <br>
  <br> 实际结果如下：getStrAt[0]
  <br>
  <br>
  <br> p2
  <br>
  <br>
  <br> getStrAt[1]:
  <br>
  <br>
  <br> p3
  <br>
  <br>
  <br> 3. updateStrAt functoin
  <br>
  <br>
  <br> p4
  <br>
  <br>
  <br> 4. deleteStrAt function
  <br>
  <br>
  <br> 要测试这个方法，稍微麻烦点，最好是
  <br>
  <br>
  <br> step 1需要先add(“hello 01”), add(“hello 02”)，add(“hello 03”)
  <br> step 2然后调用deleteStrAt(0);
  <br> step 3 检查是否第一项被删除，而getStrAt(0)应该等于”hello 02″, getStrAt(1)应该等于”hello 03″
  <br> 然后重复step1-3,作用于deleteStrAt(1),删除中间项目，或者deleteStrAt(2)删除最后一项，还有deleteStrAt(3)/deleteStrAt(100)/deleteStrAt(-100) 等检查是否做了边界检查。
  <br> 这里时间有限，就不试验了，有兴趣的同学可以自己在browser solidity上面尝试。
  <br>
  <br>
  <br> 作为礼物，这里有另外的几个简单的智能合约，有兴趣的同学都可以多用browser-solidity来尝试
  <br>
  <br>
  <br> pragma solidity ^0.4.4;
  <br>
  <br>
  <br> contract DemoTypes {
  <br> &nbsp; /*uint public resultOfF;*/
  <br> &nbsp; event LogUint(uint value);
  <br> &nbsp; event LogInt (int value);
  <br>
  <br>
  <br> &nbsp; function f(uint a) returns (uint b)
  <br> &nbsp; {
  <br> &nbsp; &nbsp; uint result = a * 8;
  <br> &nbsp; &nbsp; /*resultOfF = result; //debug used only;*/
  <br> &nbsp; &nbsp; LogUint(result);
  <br> &nbsp; &nbsp; return result;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; /*输入长度宽度，返回面积*/
  <br> &nbsp; function f2(int width, int height) returns (int square) {
  <br> &nbsp; &nbsp; if (width &lt; 0 || height &lt; 0) throw;
  <br> &nbsp; &nbsp; int result = width * height;
  <br> &nbsp; &nbsp; LogInt(result);
  <br> &nbsp; &nbsp; return result;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; /*输入N，计算N的阶乘，循环实现*/
  <br> &nbsp; function f3(uint n) returns (uint jiecheng) {
  <br> &nbsp; &nbsp; if (n == 0) throw; uint result = 1;
  <br> &nbsp; &nbsp; for (uint i=1; i&lt;=n; i++) {
  <br> &nbsp; &nbsp; &nbsp; result *= i;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; return result;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; /*计算从1到N的求和*/
  <br> &nbsp; function f4(uint n) returns (uint sum) {
  <br> &nbsp; &nbsp; if (n == 0) throw; uint result = 0;
  <br> &nbsp; &nbsp; for (uint i=0; i&lt;=n; i++) {
  <br> &nbsp; &nbsp; &nbsp; result +=i;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; return result;
  <br> &nbsp; }
  <br> }
  <br> 下一章我们将介绍一个简化版的代币合约，敬请期待！
  <br> —————————————————————————————————————
  <br>
  <br>
  <br> 先从最小化的Token合约开始；
  <br> pragma solidity 0.4.9;
  <br> contract Token {
  <br> &nbsp; function Token() {
  <br>
  <br>
  <br> &nbsp; }
  <br> }
  <br> 之前有说过，solidity是类js的语言，和所有的面向对象语言一样，solidity也拥有最基本的构造函数。
  <br> 上面的代码就是一个最简单化的一个Token合约，function Token() {}是该contract 的构造函数。
  <br>
  <br>
  <br> 该合约在browser-solidity上可以执行成功，这里就不演示了。
  <br>
  <br>
  <br> 我们给这个Token代币合约添加一个数字数组，并赋予一个初值。
  <br> pragma solidity 0.4.9;
  <br>
  <br>
  <br> contract Token2 {
  <br> &nbsp; uint[] public balancesOf;
  <br> &nbsp; function Token() {
  <br> &nbsp; &nbsp; balancesOf.push(100);
  <br> &nbsp; &nbsp; balancesOf.push(200);
  <br> &nbsp; }
  <br> }
  <br> 这个合约很简单，先定义了一个public的变量balancesOf, 然后在构造阶段，就给这个变量添加两个初始值。100 &amp; 200
  <br>
  <br>
  <br> p5
  <br>
  <br>
  <br> 用户先点击Token这个构造函数，然后再输入0和1,然后点击balancesOf 可以分别看到两个数值。
  <br>
  <br>
  <br> p6
  <br>
  <br>
  <br> 给该Token合约添加一个账户转账功能 transfer()
  <br> pragma solidity 0.4.9;
  <br> contract Token3 {
  <br> &nbsp; uint[] public balancesOf;
  <br> &nbsp; function Token() {
  <br> &nbsp; &nbsp; balancesOf.push(100);
  <br> &nbsp; &nbsp; balancesOf.push(200);
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function transfer(uint _from, uint _to, uint _amount) {
  <br> &nbsp; &nbsp; balancesOf[_from] -= _amount;
  <br> &nbsp; &nbsp; balancesOf[_to] += _amount;
  <br> &nbsp; }
  <br> }
  <br> transfer功能的代码就是把一定量_amount 从_from转移到_to;
  <br>
  <br>
  <br> 该功能在browser solidity调试成功，如下图所示：
  <br>
  <br>
  <br> p7
  <br>
  <br>
  <br> 给Token代币合约，增加一个挖矿方法 mint()
  <br> 如上面的代码所示，我们可以看到，只有在构造函数的时候balancesOf才有赋值，之后的transfer无论如何操作，总量始终不变。因此我们可以增加一个挖矿方法，增加的金额默认都归纳到第一个账号中 balancesOf[0]中。
  <br>
  <br>
  <br> pragma solidity 0.4.9;
  <br>
  <br>
  <br> contract Token4 {
  <br> &nbsp; uint[] public balancesOf;
  <br> &nbsp; function Token() {
  <br> &nbsp; &nbsp; balancesOf.push(100);
  <br> &nbsp; &nbsp; balancesOf.push(200);
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function transfer(uint _from, uint _to, uint _amount) {
  <br> &nbsp; &nbsp; balancesOf[_from] -= _amount;
  <br> &nbsp; &nbsp; balancesOf[_to] += _amount;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function mint(uint value) {
  <br> &nbsp; &nbsp; balancesOf[0] += value;
  <br> &nbsp; }
  <br> }
  <br> 通过mint() 我们就可以随意的给balancesOf[0] 增加代币了。该代码有兴趣的同学，请在browser-solidity上实验。
  <br>
  <br>
  <br> 注意以上代码只用于学习使用，很多场景还未考虑，例如transfer中没有考虑_amount&gt;当前账户余额的场景。不可用于商业化应用。
  <br>
  <br>
  <br> 本文初步介绍了Token的核心功能，包括构造，挖矿、转账等。
  <br> 但是，我们知道以太坊的核心是账户体系和智能合约，真正有意义的是在各个账户之间可以流通的代币合约。有了这些代币，我们才能用于众筹、众包等各种商业应用的实现。
  <br>
  <br>
  <br> 下篇将介绍一个包含账户的代币合约
  <br> ——————————————————————————————————————————
  <br>
  <br>
  <br> 基于账户地址的Token合约
  <br> pragma solidity 0.4.9;
  <br> contract Token {
  <br> &nbsp; mapping (address =&gt; uint) public balancesOf;
  <br> &nbsp; function Token() {
  <br> &nbsp; &nbsp; balancesOf[msg.sender] = 10000;
  <br> &nbsp; }
  <br> }
  <br> mapping 关键词的定义
  <br>
  <br>
  <br> Mapping types are declared as mapping(_KeyType =&gt; _ValueType). Here _KeyType can be almost any type except for a mapping, a dynamically sized array, a contract, an enum and a struct. _ValueType can actually be any type, including mappings.
  <br> Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s default value. 引用自here
  <br>
  <br>
  <br> address的定义：
  <br>
  <br>
  <br> address: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as base for all contracts.
  <br> members of addresses: balance and send
  <br> 引用自here
  <br> 这里的address简单地说就是geth中的账户的地址（公钥）
  <br> 因此此处的代码mapping (address =&gt; uint) balancesOf 代表定义了一个 key为address类型, value为uint类型的hashtable，名字为 balancesOf.
  <br>
  <br>
  <br> 所以任何在区块链私链上的账户都可以通过balancesOf[address] 来查询他们的代币数量。
  <br>
  <br>
  <br> msg 的定义
  <br>
  <br>
  <br> msg就是指谁调用该智能合约时候发来的信息，之前说过智能合约也是一个账户。因此在以太坊中调用智能合约从底层看来就是一个账户给智能合约账户发送了一个transaction，里面包含了谁发送的，发送了多少以太币，发送了多少gas
  <br> 下面是msg的一些变量
  <br>
  <br>
  <br> msg.data (bytes): complete calldata
  <br> msg.gas (uint): remaining gas
  <br> msg.sender (address): sender of the message (current call)
  <br> msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier)
  <br> msg.value (uint): number of wei sent with the message 引用自here
  <br> 最主要的就是msg.sender,代表那个账户调用该智能合约。msg.value
  <br>
  <br>
  <br> 因此balancesOf[msg.sender] = 10000; 代表给msg.sender也就是创建该合约的地址赋予一个初始值 10000;
  <br> 一个带transfer &amp; 挖矿的Token合约
  <br> pragma solidity 0.4.9;
  <br> contract Token {
  <br> &nbsp; mapping (address =&gt; uint) public balancesOf;
  <br> &nbsp; address public owner;
  <br> &nbsp; function Token() {
  <br> &nbsp; &nbsp; owner = msg.sender;
  <br> &nbsp; &nbsp; balancesOf[msg.sender] = 10000;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function transfer(address _to, uint _value) {
  <br> &nbsp; &nbsp; if (balancesOf[msg.sender] &lt; _value) throw; //避免转移出去的代币超过当前的存货
  <br> &nbsp; &nbsp; if (balancesOf[_to] + _value &lt; balancesOf[_to]) throw; //避免自己调用自己，或者递归调用
  <br> &nbsp; &nbsp; balancesOf[msg.sender] -= _value;
  <br> &nbsp; &nbsp; balancesOf[_to] += _value;
  <br> &nbsp; }
  <br>
  <br>
  <br> &nbsp; function mint(uint _amount) {
  <br> &nbsp; &nbsp; balancesOf[owner] += _amount;
  <br> &nbsp; }
  <br> }
  <br> 在上面的代码中，我们设置一个public owner, 保存下创建合约的msg.sender, 记录下创建者的地址。
  <br> 在function transfer()中，我们设置了两个条件，避免转移出去的代币超过存货的情况，以及自己转移给自己的问题。
  <br> 在function mint()中，我们给合约的owner增加我们定义的代币。从而让其方便的分给别人。
  <br> 以上合约代码在Browser-solidity上调试通过，查看下图
  <br>
  <br>
  <br> p8
  <br>
  <br>
  <br> 我们在代码中将owner = msg.sender,因此owner就是创建合约的地址。我们可以看到balancesOf[owner] 的数据为10000，和代码相同。
  <br> p9
  <br>
  <br>
  <br> 调用方法mint(500)，自动给balancesOf[owner] += 500；查看存额从10000增加到10500.
  <br> p10
  <br>
  <br>
  <br> 调用方法 transfer("0xccccc",300), 可以看到owner的存额减少300，balancesOf[“0xccccc”]增加300.
  <br> p11
  <br>
  <br>
  <br> 这个合约实现了最简化的代币功能，但在browser-solidity中我们可以看到一个很明显的问题，那就是没有和我们在第二部分中所搭建的geth中的几个以太坊账号结合起来。
  <br>
  <br>
  <br> 下一章我们将介绍另一个非常有用的工具Mist，从而将智能合约、Geth、Mist结合起来。真正在以太坊私有链上运行智能合约。 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78528426,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78528426,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
