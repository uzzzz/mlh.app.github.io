<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊ETH代币开发教程源码学习笔记 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊ETH代币开发教程源码学习笔记" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/78580207 前言 区块链爱好者（QQ：53016353） 从事区块链的开发，不了解其底层核心技术是不够的。许多人在看了以太坊代币开发白皮书之后仍然不清楚以太坊代币开发是怎样实现的，因为以太坊代币开发的源码设计精巧，有许多设计白皮书未曾提及，加上本身以太坊代币开发的文档稀少，加大了新手理解的困难程度。尽管现在已经有许多介绍区块链的书和文章，却很少是从源码着手分析的。我通过半年时间对于区块链的学习，开始撰写一份以太坊代币开发源码的教程。本教程深入浅出，通过分析最经典的区块链——以太坊代币开发的C++客户端源码，让开发者用最短的时间上手区块链技术。了解以太坊代币开发源码可帮助开发者更好了解区块链的工作原理并在应用当中根据实际情况做出修改和调整。 本文所引用的源码均来自原始版以太坊代币开发客户端，即由中本聪发布的第一版源码。该客户端包括大约16000行代码。尽管经过数年的发展，以太坊代币开发客户端经过了几次较大更新，其数据结构和原理从诞生之日起一直延续至今。本文会尽可能保证文字的严谨准确，表达当中难免会产生疏漏，欢迎指正。 bitcoin-code &nbsp; 第一章 &nbsp; 本章节讲述以太坊代币开发客户端是怎样生成以太坊代币开发地址，并创建新的交易。 我们来看一下GenerateNewKey()方法，该方法位于main.cpp。 &nbsp; bool AddKey(const CKey&amp; key) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; mapKeys[key.GetPubKey()] = key.GetPrivKey(); &nbsp; &nbsp; &nbsp; &nbsp; mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey(); &nbsp; &nbsp; } &nbsp; &nbsp; return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey()); } vector&lt;unsigned char&gt; GenerateNewKey() { &nbsp; &nbsp; CKey key; &nbsp; &nbsp; key.MakeNewKey(); &nbsp; &nbsp; if (!AddKey(key)) &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GenerateNewKey() : AddKey failed\n&quot;); &nbsp; &nbsp; return key.GetPubKey(); } 该方法通过以下步骤生成一个新的公钥对： &nbsp; 首先建立一个新的CKey类型对象（第13行）。 调用addKey()方法将新建的key添加至1）全局映射mapKeys （第5行）2）全局map mapPubKeys（第6行）和钱包数据库wallet.dat（第8行）。 mapKeys建立公钥与私钥的一一对应关系。 mapPubKeys建立公钥的hash和公钥本身的对应关系。 返回公钥（第16行）。 该公钥为未压缩的格式，属于OpenSSL标准格式之一。在得到公钥之后，以太坊代币开发客户端会将该公钥传递至PubKeyToAddress()并调用Hash160ToAddress()方法生成地址。最后返回的Base58编码字符串值便是一个新生成的以太坊代币开发地址。Base58由1-9和除i，l，0，o之外的英文字符组成。 CTransaction类 CTransaction的定义位于main.h。在以太坊代币开发当中，所谓币的概念其实是一系列交易Tx的组合。这种方式虽然实现起来更为复杂，却提高了以太坊代币开发的安全性。用户可以为每一笔交易创建一个新的地址，地址在使用一次之后可以立即作废。因此，CTransaction是以太坊代币开发客户端最重要的类之一。 &nbsp; class CTransaction { public: &nbsp; &nbsp; int nVersion; &nbsp; &nbsp; vector&lt;CTxIn&gt; vin; &nbsp; &nbsp; vector&lt;CTxOut&gt; vout; &nbsp; &nbsp; int nLockTime; &nbsp; &nbsp; //...... } &nbsp; CTransaction包含两个容器类型：输入交易vin和输出交易vout。每个vin由若干CTxIn对象组成，每个vout则由CTxOut组成。 每笔交易Tx的输入交易（CTxIn类）包含一个COutPoint对象prevout，该对象引用另外一笔交易Tx的输出交易作为来源交易。来源交易使当前交易Tx从另一笔交易当中得到可花费的以太坊代币开发。一笔交易Tx可以拥有任意笔输入交易。 任何交易均由一个256位uint256哈希作为其唯一识别。若要引用某一笔来源交易TxSource当中某个特定的输出交易，我们需要两种信息：TxSource的哈希，和该输出交易在输出交易当中的位置n。这两种信息构成COutPoint类。一个COutPoint对象指向来源交易的某一笔输出交易TxSource.vout[n]。如果该笔输出交易被另外一笔交易Tx的位置i的输入交易所引用，例如Tx.vin[i].prevout，我们将其称为Tx的第i笔输入交易花费了TxSource中的第n笔输出交易。 uint256和uint160类 这两种类型的定义位于uint.h。一个uint256类包含有一个256位的哈希。它由一个长度为256/32=8的unsigned int数组构成。一个相似的数据结构是uint160，该结构的定义可在同一个文件当中找到。既然SHA-256的长度为256bit，读者不难推断出uint160的作用是存放RIPEMD-160哈希。uint256和uint160均由base_uint类继承而来。 &nbsp; class base_uint { protected: &nbsp; &nbsp; enum { WIDTH = BITS / 32 }; &nbsp; &nbsp; unsigned int pn[WIDTH]; public: &nbsp; &nbsp; bool operator!() const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; WIDTH; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pn[i] != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; } &nbsp; &nbsp; //...... &nbsp; &nbsp; unsigned int GetSerializeSize(int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; return sizeof(pn); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Serialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.write((char*)pn, sizeof(pn)); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Unserialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.read((char*)pn, sizeof(pn)); &nbsp; &nbsp; } } 该类重载了若干运算符。此外该类拥有3个序列化成员函数，GetSerializeSize()、Serialize()和Unserialize()。我们会在后面讲到这三种方法是如何工作的。 &nbsp; SendMoney() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; int64 nFeeRequired; &nbsp; &nbsp; &nbsp; &nbsp; if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string strError; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue + nFeeRequired &gt; GetBalance()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: This is an oversized transaction that requires a transaction fee of %s &quot;, FormatMoney(nFeeRequired).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: Transaction creation failed &quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(strError, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : %s\n&quot;, strError.c_str()); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!CommitTransactionSpent(wtxNew)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error finalizing transaction&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error finalizing transaction&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;SendMoney: %s\n&quot;, wtxNew.GetHash().ToString().substr(0,6).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; // Broadcast &nbsp; &nbsp; &nbsp; &nbsp; if (!wtxNew.AcceptTransaction()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // This must not fail. The transaction has already been signed and recorded. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;SendMoney() : wtxNew.AcceptTransaction() failed\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error: Transaction not valid&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error: Transaction not valid&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.RelayWalletTransaction(); &nbsp; &nbsp; } &nbsp; &nbsp; MainFrameRepaint(); &nbsp; &nbsp; return true; } &nbsp; 当用户发送以太坊代币开发到某一个地址时，以太坊代币开发客户端会调用SendMoney()方法。该方法包含三个参数： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue表示将要转账的金额。该金额并未包含交易费nTrasactionFee。 wtxNew是一个CWalletTx类的本地变量。该变量目前的值为空，之后会包含若干CMerkleTX类对象。该类由CTransaction衍生而来，并且添加了若干方法。我们暂时先不管具体细节，仅将其看作CTransaction类。 该方法的流程显而易见： 首先建立一笔新的交易（CreateTransaction(scriptPubKey, nValue, wtxNet, nFeeRequired)，第6行）。 尝试将这笔交易提交至数据库（CommitTransactionSpent(wtxNet)，第16行）。 如果该笔交易提交成功（wtxNew.AcceptTransaction()，第23行），将其广播至其他peer节点（wtxNew.RelayWalletTransaction()，第30行）。 这四个方法都与wtxNew相关。我们在本章介绍了第一个，其余三个将会在后续文章中介绍。 CreateTransaction() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew, int64&amp; nFeeRequiredRet) { &nbsp; &nbsp; nFeeRequiredRet = 0; &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // txdb must be opened before the mapWallet lock &nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;); &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nFee = nTransactionFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = nValue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValue += nFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose coins to use &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set&lt;CWalletTx*&gt; setCoins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!SelectCoins(nValue, setCoins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += pcoin-&gt;GetCredit(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[0] to the payee &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] back to self with any change &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValueIn &gt; nValue) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Use the same key as one of the coins &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txFirst = *(*setCoins.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, txFirst.vout) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vchPubKey.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] to ourself &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; vchPubKey &lt;&lt; OP_CHECKSIG; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SignSignature(*pcoin, wtxNew, nIn++); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Check that enough fee is included &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nFee &lt; wtxNew.GetMinFee(true)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFee = nFeeRequiredRet = wtxNew.GetMinFee(true); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vtxPrev by copying from previous transactions vtxPrev &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.AddSupportingTransactions(txdb); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.fTimeReceivedIsTxTime = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } &nbsp; 调用该方法时，它所需要的四个参数如下： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue是将要转账的数额，交易费nTransactionFee并未包括在内。 wtxNew是一个新的Tx实例。 nFeeRequiredRet是一笔用来支付交易费的输出交易，在该方法执行完成之后获得。 该方法的流程如下： 定义一个本地变量nValueOut = nValue来保存将转账的金额（第17行）。将nValue与交易费nFee相加得到新的包含转账费的nValue。 执行位于第21行的SelectCoins(nValue, setCoins)得到一系列币，并放入setCoins。setCoins包含支付给你本人地址的交易，即你所拥有的币。这些交易将成为wtxNew的来源交易。 执行位于第27行的wtxNew.vout.push_back(CTxOut (nValueOut,sciptPubKey))并添加一笔输出交易至wtxNew。该笔输出将支付给&lt;收款人地址160位哈希&gt;（包含在scriptPubKey里面）数量为的币。 如果需要找零（nValueIn &gt; nValue），添加另一笔输出交易至wtxNew并将零钱发回本人。该过程包含以下步骤： 从setCoin当中获取第一笔交易txFirst，依次检查txFirst.vout中的交易是否属于本人。如果是则从该笔输出交易当中提取出公钥，并放入本地变量vchPubKey 将vchPubKey放入脚本vchPubKey OP_CHECKSIG，并使用这段脚本代码为wtxNew添加一个支付给本人的输出交易（第45行）。 因为setCoins包含支付给本人的交易，所以每笔交易一定包括至少一笔支付给本人的交易。从第一笔交易txFirst中即可找到。 至此，wtxNew的输出交易容器vout已准备就绪。现在，该设置输入交易容器vin。记住每一个输入交易列表vin均引用一笔来源交易，而且wtxNew的每笔来源交易均可在setCoins中被找到。对于每一笔setCoins中的交易pcoin，逐个遍历其输出交易pcoin-&gt;vout[nOut]。如果第nOut笔输出支付给本人（意味着wtxNew从该笔输出交易中获得币），则向wtxNew添加一笔新的输入交易（wtxNew.vin(wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut))，第51行)。该输入交易指向pcoin中的第nOut笔输出交易，由此将wtxNew.vin与pcoin的第nOut笔输出相连接。 对于setCoins当中的每笔交易pcoin，逐个遍历其所有输出交易pcoin-&gt;vout[nOut]。如果该笔交易属于本人，调用SignSignature(*pcoin,wtxNew, nIn++)为第nIn笔输入交易添加签名。注意nIn为wtxNew的输入交易位置。 如果交易费nFee小于wtxNet.GetMinFee(true)，将nFee设为后者，清空wtxNew中的所有数据并重新开始整个过程。在位于第11行的第一次迭代当中，nFee是全局变量nTransactionFee = 0的本地复制。 如果你不明白为什么要如此费力地重新添满wtxNew，源码中的GetMinFee()提供了答案：交易的最低费用与交易的数据大小有关。wtxNew的大小只有在完整构建之后才可得知。如果wtxNew.GetMinFee(true)计算得到的最小交易费用大于之前创造wtxNew时假设的交易费nFee，则除了重新构建wtxNew之外别无他法。 这里遇到了一个先有鸡还是先有蛋的局面：若想创建一笔新的交易，则必须知道交易费用是多少。而交易费只有在整个交易被创建以后才可得知。为了打破这个循环，本地变量nFee被用来放置预计的交易费用，并且新的交易构建在此基础上。在构建完成之后，得到真实的交易费并与预估的交易费作比较。如果预估的交易费小于真实的交易费，则替换成真实交易费并重新构造整个交易。 这里是GetMinFee()的源码： &nbsp; int64 GetMinFee(bool fDiscount=false) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK); &nbsp; &nbsp; &nbsp; &nbsp; if (fDiscount &amp;&amp; nBytes &lt; 10000) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; return (1 + (int64)nBytes / 1000) * CENT; &nbsp; &nbsp; } &nbsp; 如果计算得到的交易费比之前预计的交易费更高，则跳出第11行开始的循环并返回整个函数（第67行）。在此之前，需要进行以下两个步骤： 执行wtxNew.AddSupportingTransactions(txdb)。这一部分以后会进行更详细介绍。 设置wtxNet.fTimeReceivedIsTxTime=true（第66行）。 现在来看一下如何通过SignSignature()签署新生成的交易wtxNew。 SignSignature() 该方法位于script.cpp。以下是该方法的源码： &nbsp; bool SignSignature(const CTransaction&amp; txFrom, CTransaction&amp; txTo, unsigned int nIn, int nHashType, CScript scriptPrereq) { &nbsp; &nbsp; assert(nIn &lt; txTo.vin.size()); &nbsp; &nbsp; CTxIn&amp; txin = txTo.vin[nIn]; &nbsp; &nbsp; assert(txin.prevout.n &lt; txFrom.vout.size()); &nbsp; &nbsp; const CTxOut&amp; txout = txFrom.vout[txin.prevout.n]; &nbsp; &nbsp; // Leave out the signature from the hash, since a signature can&#39;t sign itself. &nbsp; &nbsp; // The checksig op will also drop the signatures from its hash. &nbsp; &nbsp; uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType); &nbsp; &nbsp; if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; txin.scriptSig = scriptPrereq + txin.scriptSig; &nbsp; &nbsp; // Test solution &nbsp; &nbsp; if (scriptPrereq.empty()) &nbsp; &nbsp; &nbsp; &nbsp; if (!EvalScript(txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey, txTo, nIn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; return true; } &nbsp; 首先需要注意的是，该函数有5个参数，而CreateTransaction()只有3个。这是因为在script.h文件里，后两个参数已默认给出。 以下是传递给CreateTransaction()中的3个参数： txFrom是一个*pcoin对象。它是CreateTransaction()里setCoins中的所有币中的某一个。它同时也是一笔来源交易。它的若干输出交易当中包含了新交易将要花费的币。 txTo是CreateTransaction()里的wtxNew对象。它是将要花费来源交易txFrom的新交易。新交易需要被签署方可生效。 nIn是指向txTo中输入交易列表的索引位置。该输入交易列表包含一个对txFrom的输出交易列表的引用。更准确地讲，txin=txTo.vin[nIn]（第4行）是txTo中的输入交易；txout=txFrom.vout[txin.prev.out.n]（第6行）是txin所指向的txFrom中的输出交易。 以下是SignSignature()所做的工作： 调用SignatureHash()方法生成txTo的哈希值。 调用Solver()函数签署刚才生成的哈希。 调用EvalScript()来运行一小段脚本并检查签名是否合法。 我们一起看一下这三个函数。 SignatureHash() 该方法位于script.cpp。以下是SignatureHash()的源码。 &nbsp; uint256 SignatureHash(CScript scriptCode, const CTransaction&amp; txTo, unsigned int nIn, int nHashType) { &nbsp; &nbsp; if (nIn &gt;= txTo.vin.size()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nIn=%d out of range\n&quot;, nIn); &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; } &nbsp; &nbsp; CTransaction txTmp(txTo); &nbsp; &nbsp; // In case concatenating two scripts ends up with two codeseparators, &nbsp; &nbsp; // or an extra one at the end, this prevents all those possible incompatibilities. &nbsp; &nbsp; scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR)); &nbsp; &nbsp; // Blank out other inputs&#39; signatures &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].scriptSig = CScript(); &nbsp; &nbsp; txTmp.vin[nIn].scriptSig = scriptCode; &nbsp; &nbsp; // Blank out some of the outputs &nbsp; &nbsp; if ((nHashType &amp; 0x1f) == SIGHASH_NONE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Wildcard payee &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; else if ((nHashType &amp; 0x1f) == SIGHASH_SINGLE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Only lockin the txout payee at same index as txin &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nOut = nIn; &nbsp; &nbsp; &nbsp; &nbsp; if (nOut &gt;= txTmp.vout.size()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nOut=%d out of range\n&quot;, nOut); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.resize(nOut+1); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nOut; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout[i].SetNull(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; // Blank out other inputs completely, not recommended for open transactions &nbsp; &nbsp; if (nHashType &amp; SIGHASH_ANYONECANPAY) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[0] = txTmp.vin[nIn]; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin.resize(1); &nbsp; &nbsp; } &nbsp; &nbsp; // Serialize and hash &nbsp; &nbsp; CDataStream ss(SER_GETHASH); &nbsp; &nbsp; ss.reserve(10000); &nbsp; &nbsp; ss &lt;&lt; txTmp &lt;&lt; nHashType; &nbsp; &nbsp; return Hash(ss.begin(), ss.end()); } 以下是该函数所需要的参数： &nbsp; txTo是将要被签署的交易。它同时也是CreateTransaction()中的wtxNew对象。它的输入交易列表中的第nIn项，txTo.vin[nIn]，是该函数将要起作用的目标。 scriptCode是scriptPrereq + txout.scriptPubKey，其中txout是SignSignature()中定义的来源交易txFrom()的输出交易。由于此时scriptPrereq为空，scriptCode事实上是来源交易txFrom中的输出交易列表当中被txTo作为输入交易引用的那笔的脚本代码。txout.scriptPubKey有可能包含两类脚本： 脚本A：OP_DUP OP_HASH160 &lt;你地址的160位哈希&gt; OP_EQUALVERIFY OP_CECKSIG。该脚本将来源交易txFrom中的币发送给你，其中&lt;你地址的160位哈希&gt;是你的以太坊代币开发地址。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。该脚本将剩余的币退还至来源交易txFrom的发起人。由于你创建的新交易txTo/wtxNew将会花费来自txFrom的币，你必须同时也是txFrom的创建者。换句话讲，当你在创建txFrom的时候，你其实是在花费之前别人发送给你的币。因此，&lt;你的公钥&gt;即是txFrom创建者的公钥，也是你自己的公钥。 我们在此停留片刻，来思考一下脚本A和脚本B。你有可能会问，这些脚本是从哪来的。中本聪在创造以太坊代币开发的时候为以太坊代币开发添加了一套脚本语言系统，所以以太坊代币开发中的交易都是由脚本代码完成的。该脚本系统其实也是后来智能合约的雏形。脚本A来自第29行，位于方法CSendDialog::OnButtonSend()，脚本B则来自第44行，位于方法CreateTransaction()。 当用户发起一笔交易时，以太坊代币开发客户端会调用CSendDialog::OnButtonSend()方法并将脚本A添加至txFrom中的一笔输出交易中。由于该输出交易的收款方为你本人，从而脚本中的&lt;收款人地址160位哈希&gt;，就是&lt;你的地址160位哈希&gt;。 如果txFrom是你本人创建的，则脚本B会被添加至CreateTransaction()中txFrom的某一笔输出交易。在这里，第44行位于CreateTransaction()中的公钥vchPubKey是你本人的公钥。 在了解了输入交易之后，我们来一起了解SignatureHash()是怎样工作的。 SignatureHash()首先将txTO拷贝至txTmp，接着清空txTmp.vin中每一笔输入交易的scriptSig，除了txTmp.vin[nIn]之外，该输入交易的scriptSig被设为scriptCode(第14、15行）。 接着，该函数检验nHashType的值。该函数的调用者将一个枚举值传递至该函数nHashType = SIGHASH_ALL。 &nbsp; enum { &nbsp; &nbsp; SIGHASH_ALL = 1, &nbsp; &nbsp; SIGHASH_NONE = 2, &nbsp; &nbsp; SIGHASH_SINGLE = 3, &nbsp; &nbsp; SIGHASH_ANYONECANPAY = 0x80, }; 由于nHashType = SIGHASH_ALL，所有的if-else条件均不成立，该函数将直接执行最后4行代码。 &nbsp; 在最后4行代码中，txTmp和nHashType变成序列化后的类型CDataStream对象。该类型包括一个装有数据的字符容器类型。所返回的哈希值是Hash()方法在计算序列化后的数据所得到的。 一笔交易可以包含多笔输入交易。SignatureHash()取其中一笔作为目标。它通过以下步骤生成哈希： 清空除了目标交易之外的所有输入交易。 复制来源交易中被目标交易作为输入交易引用的那笔输出交易的脚本至目标交易的输入交易列表中。 为修改后的交易生成哈希值。 Hash() 该方法位于util.h。以下是生成哈希值的方法Hash()的源码： &nbsp; template&lt;typename T1&gt; inline uint256 Hash(const T1 pbegin, const T1 pend) { &nbsp; &nbsp; uint256 hash1; &nbsp; &nbsp; SHA256((unsigned char*)&amp;pbegin[0], (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&amp;hash1); &nbsp; &nbsp; uint256 hash2; &nbsp; &nbsp; SHA256((unsigned char*)&amp;hash1, sizeof(hash1), (unsigned char*)&amp;hash2); &nbsp; &nbsp; return hash2; } 该函数对目标数据执行两次SHA256()方法并返回结果。SHA256()的声明可在openssl/sha.h中找到。 &nbsp; Solver() 该方法位于script.cpp。Solver()在SignSignature()中紧接着SignatureHash()被执行。它是真正用来为SignatureHash()返回的哈希值生成签名的函数。 &nbsp; bool Solver(const CScript&amp; scriptPubKey, uint256 hash, int nHashType, CScript&amp; scriptSigRet) { &nbsp; &nbsp; scriptSigRet.clear(); &nbsp; &nbsp; vector&lt;pair&lt;opcodetype, valtype&gt; &gt; vSolution; &nbsp; &nbsp; if (!Solver(scriptPubKey, vSolution)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; // Compile solution &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(opcodetype, valtype)&amp; item, vSolution) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (item.first == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const valtype&amp; vchPubKey = item.second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (item.first == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign and give pubkey &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint160, valtype&gt;::iterator mi = mapPubKeys.find(uint160(item.second)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi == mapPubKeys.end()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const vector&lt;unsigned char&gt;&amp; vchPubKey = (*mi).second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig &lt;&lt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } 以下是该方法所需要的4个参数： &nbsp; 位于第10行的调用函数SignSignature()将txOut.scriptPubKey，来源交易txFrom的输出脚本，作为输入值传入第一个参数scriptPubKey。记住它可能包含脚本A或者脚本B。 第二个参数hash是由SignatureHash()生成的哈希值。 第三个参数nHashType的值为SIGHASH_ALL。 第四个参数是该函数的返回值，即调用函数SignSIgnature()中位于第12行的txin.scriptSig。记住txin是新生成的交易wtxNew（在调用函数SignSignature()中作为txTo引用）位于第nIn的输入交易。因此，wtxNew第nIn笔输入交易的scriptSig将存放该函数返回的签名。 该函数首先会调用另一个有2个参数的Solver()。我们来研究一下。 带有2个参数的Solver() 该方法位于script.cpp。以下是带有2个参数的Solver()的源码： &nbsp; bool Solver(const CScript&amp; scriptPubKey, vector&lt;pair&lt;opcodetype, valtype&gt; &gt;&amp; vSolutionRet) { &nbsp; &nbsp; // Templates &nbsp; &nbsp; static vector&lt;CScript&gt; vTemplates; &nbsp; &nbsp; if (vTemplates.empty()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Standard tx, sender provides pubkey, receiver adds signature &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; &nbsp; &nbsp; // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; } &nbsp; &nbsp; // Scan templates &nbsp; &nbsp; const CScript&amp; script1 = scriptPubKey; &nbsp; &nbsp; foreach(const CScript&amp; script2, vTemplates) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; &nbsp; &nbsp; opcodetype opcode1, opcode2; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vch1, vch2; &nbsp; &nbsp; &nbsp; &nbsp; // Compare &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc1 = script1.begin(); &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc2 = script2.begin(); &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f1 = script1.GetOp(pc1, opcode1, vch1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f2 = script2.GetOp(pc2, opcode2, vch2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!f1 &amp;&amp; !f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Success &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse(vSolutionRet.begin(), vSolutionRet.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (f1 != f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() &lt;= sizeof(uint256)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() != sizeof(uint160)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode1 != opcode2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; return false; } 第一个参数scriptPubKey可能包含脚本A也可能是脚本B。再一次说明，它是SignSignature()中来源交易txFrom的输出脚本。 &nbsp; 第二个参数用来存放输出交易。它是一个容器对，每个对由一个脚本运算符（opcodetype类型）和脚本操作元（valtype类型）构成。 该函数第8-10行首先定义两个模板： 模板A：OP_DUP OP_HASH160 OP_PUBKEYHASH OP_EQUALVERIFY OP_CHECKSIG。 模板B：OP_PUBKEY OP_CHECKSIG。 很明显，模板A、模板B与脚本A、脚本B相对应。为了便于对比，以下是脚本A和B的内容： 脚本A：OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。 该函数的作用是将scriptPubKey与两个模板相比较： 如果输入脚本为脚本A，则将模板A中的OP_PUBKEYHASH与脚本A中的&lt;你的地址160位哈希&gt;配对，并将该对放入vSolutionRet。 如果输入脚本为脚本B，则从模板B中提取运算符OP_PUBKEY，和从脚本B中提取运算元&lt;你的公钥&gt;，将二者配对并放入vSolutionRet。 如果输入脚本与两个模板均不匹配，则返回false。 回到Solver() 我们回到有4个参数的Solver()并继续对该函数的分析。现在我们清楚了该函数的工作原理。它会在两个分支中选择一个执行，取决于从vSolutionRet得到的对来自脚本A还是脚本B。如果来自脚本A，item.first &nbsp;== OP_PUBKEYHASH；如果来自脚本B，item.first &nbsp;== OP_PUBKEY。 item.first &nbsp;== OP_PUBKEY（脚本B）。在该情形下，item.second包含&lt;你的公钥&gt;。全局变量mapKeys将你的全部公钥映射至与之对应的私钥。如果mapKeys当中没有该公钥，则报错（第16行）。否则，用从mapKeys中提取出的私钥签署新生成的交易wtxNew的哈希值，其中哈希值作为第2个被传入的参数（CKey::Sign(mapKeys[vchPubKey], hash, vchSig)，第23行），再将结果放入vchSig，接着将其序列化成scriptSigRet（scriptSigRet &lt;&lt; vchSig，第24行）并返回。 item.first &nbsp;== OP_PUBKEYHASH（脚本A）。在该情形下，item.second包含&lt;你的地址160位哈希&gt;。该以太坊代币开发地址将被用于从位于第23行的全局映射mapPubKeys中找到其所对应的公钥。全局映射mapPubKeys将你的地址与生成它们的公钥建立一一对应关系（查看函数AddKey()）。接着，通过该公钥从mapKeys中找到所对应的私钥，并用该私钥签署第二个参数hash。签名和公钥将一同被序列化至scriptSigRet并返回（scriptSig &lt;&lt; vchSig &lt;&lt; vchPubkey，第24行）。 EvalScript() 该方法位于script.cpp。现在我们回到SignSignature()。在该函数的第12行之后，txin.scriptsig，即wtxNew的第nIn笔输入交易中的scriptSig部分，将插入一个签名。该签名可能是以下其中之一： vchSig vchPubKey（脚本A的签名A） vchSig（脚本B的签名B） 在下文当中，vchSig将被引用为&lt;你的签名_vchSig&gt;，vchPubKey则为&lt;你的公钥_vchPubKey&gt;，以强调它们分别是你本人的签名和公钥。 我们现在开始调查EvalScript()，该函数是SignSignature()调用的最后一个函数，位于第15行。EvalScript()带有3个参数，分别为： 第一个参数为txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey。它有可能是： 验证情形A：&lt;你的签名_vchSig&gt; &lt;你的公钥_vchPubKey&gt; OP_CODESEPARATOR OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG，即签名A + OP_CODESEPARATOR + 脚本A。 验证情形B：&lt;你的签名_vchSig&gt; OP_CODESEPARATOR &lt;你的公钥_vchPubKey&gt; OP_CHECKSIG，即签名B + OP_CODESEPARATOR + 脚本B。 第二个参数为新创建的交易txTo，即CreateTransaction()中的wtxNew。 第三个参数为nIn，即将被验证的交易在txTo输入交易列表中的位置。 验证过程我们会在后面详细讲述。简单地说，EvalScript()验证新创建交易wtxNew的第nIn笔输入交易是否包含有效的签名。至此，一笔新的以太坊代币开发交易便创建完成。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/78580207 前言 区块链爱好者（QQ：53016353） 从事区块链的开发，不了解其底层核心技术是不够的。许多人在看了以太坊代币开发白皮书之后仍然不清楚以太坊代币开发是怎样实现的，因为以太坊代币开发的源码设计精巧，有许多设计白皮书未曾提及，加上本身以太坊代币开发的文档稀少，加大了新手理解的困难程度。尽管现在已经有许多介绍区块链的书和文章，却很少是从源码着手分析的。我通过半年时间对于区块链的学习，开始撰写一份以太坊代币开发源码的教程。本教程深入浅出，通过分析最经典的区块链——以太坊代币开发的C++客户端源码，让开发者用最短的时间上手区块链技术。了解以太坊代币开发源码可帮助开发者更好了解区块链的工作原理并在应用当中根据实际情况做出修改和调整。 本文所引用的源码均来自原始版以太坊代币开发客户端，即由中本聪发布的第一版源码。该客户端包括大约16000行代码。尽管经过数年的发展，以太坊代币开发客户端经过了几次较大更新，其数据结构和原理从诞生之日起一直延续至今。本文会尽可能保证文字的严谨准确，表达当中难免会产生疏漏，欢迎指正。 bitcoin-code &nbsp; 第一章 &nbsp; 本章节讲述以太坊代币开发客户端是怎样生成以太坊代币开发地址，并创建新的交易。 我们来看一下GenerateNewKey()方法，该方法位于main.cpp。 &nbsp; bool AddKey(const CKey&amp; key) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; mapKeys[key.GetPubKey()] = key.GetPrivKey(); &nbsp; &nbsp; &nbsp; &nbsp; mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey(); &nbsp; &nbsp; } &nbsp; &nbsp; return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey()); } vector&lt;unsigned char&gt; GenerateNewKey() { &nbsp; &nbsp; CKey key; &nbsp; &nbsp; key.MakeNewKey(); &nbsp; &nbsp; if (!AddKey(key)) &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GenerateNewKey() : AddKey failed\n&quot;); &nbsp; &nbsp; return key.GetPubKey(); } 该方法通过以下步骤生成一个新的公钥对： &nbsp; 首先建立一个新的CKey类型对象（第13行）。 调用addKey()方法将新建的key添加至1）全局映射mapKeys （第5行）2）全局map mapPubKeys（第6行）和钱包数据库wallet.dat（第8行）。 mapKeys建立公钥与私钥的一一对应关系。 mapPubKeys建立公钥的hash和公钥本身的对应关系。 返回公钥（第16行）。 该公钥为未压缩的格式，属于OpenSSL标准格式之一。在得到公钥之后，以太坊代币开发客户端会将该公钥传递至PubKeyToAddress()并调用Hash160ToAddress()方法生成地址。最后返回的Base58编码字符串值便是一个新生成的以太坊代币开发地址。Base58由1-9和除i，l，0，o之外的英文字符组成。 CTransaction类 CTransaction的定义位于main.h。在以太坊代币开发当中，所谓币的概念其实是一系列交易Tx的组合。这种方式虽然实现起来更为复杂，却提高了以太坊代币开发的安全性。用户可以为每一笔交易创建一个新的地址，地址在使用一次之后可以立即作废。因此，CTransaction是以太坊代币开发客户端最重要的类之一。 &nbsp; class CTransaction { public: &nbsp; &nbsp; int nVersion; &nbsp; &nbsp; vector&lt;CTxIn&gt; vin; &nbsp; &nbsp; vector&lt;CTxOut&gt; vout; &nbsp; &nbsp; int nLockTime; &nbsp; &nbsp; //...... } &nbsp; CTransaction包含两个容器类型：输入交易vin和输出交易vout。每个vin由若干CTxIn对象组成，每个vout则由CTxOut组成。 每笔交易Tx的输入交易（CTxIn类）包含一个COutPoint对象prevout，该对象引用另外一笔交易Tx的输出交易作为来源交易。来源交易使当前交易Tx从另一笔交易当中得到可花费的以太坊代币开发。一笔交易Tx可以拥有任意笔输入交易。 任何交易均由一个256位uint256哈希作为其唯一识别。若要引用某一笔来源交易TxSource当中某个特定的输出交易，我们需要两种信息：TxSource的哈希，和该输出交易在输出交易当中的位置n。这两种信息构成COutPoint类。一个COutPoint对象指向来源交易的某一笔输出交易TxSource.vout[n]。如果该笔输出交易被另外一笔交易Tx的位置i的输入交易所引用，例如Tx.vin[i].prevout，我们将其称为Tx的第i笔输入交易花费了TxSource中的第n笔输出交易。 uint256和uint160类 这两种类型的定义位于uint.h。一个uint256类包含有一个256位的哈希。它由一个长度为256/32=8的unsigned int数组构成。一个相似的数据结构是uint160，该结构的定义可在同一个文件当中找到。既然SHA-256的长度为256bit，读者不难推断出uint160的作用是存放RIPEMD-160哈希。uint256和uint160均由base_uint类继承而来。 &nbsp; class base_uint { protected: &nbsp; &nbsp; enum { WIDTH = BITS / 32 }; &nbsp; &nbsp; unsigned int pn[WIDTH]; public: &nbsp; &nbsp; bool operator!() const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; WIDTH; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pn[i] != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; } &nbsp; &nbsp; //...... &nbsp; &nbsp; unsigned int GetSerializeSize(int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; return sizeof(pn); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Serialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.write((char*)pn, sizeof(pn)); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Unserialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.read((char*)pn, sizeof(pn)); &nbsp; &nbsp; } } 该类重载了若干运算符。此外该类拥有3个序列化成员函数，GetSerializeSize()、Serialize()和Unserialize()。我们会在后面讲到这三种方法是如何工作的。 &nbsp; SendMoney() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; int64 nFeeRequired; &nbsp; &nbsp; &nbsp; &nbsp; if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string strError; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue + nFeeRequired &gt; GetBalance()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: This is an oversized transaction that requires a transaction fee of %s &quot;, FormatMoney(nFeeRequired).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: Transaction creation failed &quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(strError, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : %s\n&quot;, strError.c_str()); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!CommitTransactionSpent(wtxNew)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error finalizing transaction&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error finalizing transaction&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;SendMoney: %s\n&quot;, wtxNew.GetHash().ToString().substr(0,6).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; // Broadcast &nbsp; &nbsp; &nbsp; &nbsp; if (!wtxNew.AcceptTransaction()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // This must not fail. The transaction has already been signed and recorded. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;SendMoney() : wtxNew.AcceptTransaction() failed\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error: Transaction not valid&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error: Transaction not valid&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.RelayWalletTransaction(); &nbsp; &nbsp; } &nbsp; &nbsp; MainFrameRepaint(); &nbsp; &nbsp; return true; } &nbsp; 当用户发送以太坊代币开发到某一个地址时，以太坊代币开发客户端会调用SendMoney()方法。该方法包含三个参数： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue表示将要转账的金额。该金额并未包含交易费nTrasactionFee。 wtxNew是一个CWalletTx类的本地变量。该变量目前的值为空，之后会包含若干CMerkleTX类对象。该类由CTransaction衍生而来，并且添加了若干方法。我们暂时先不管具体细节，仅将其看作CTransaction类。 该方法的流程显而易见： 首先建立一笔新的交易（CreateTransaction(scriptPubKey, nValue, wtxNet, nFeeRequired)，第6行）。 尝试将这笔交易提交至数据库（CommitTransactionSpent(wtxNet)，第16行）。 如果该笔交易提交成功（wtxNew.AcceptTransaction()，第23行），将其广播至其他peer节点（wtxNew.RelayWalletTransaction()，第30行）。 这四个方法都与wtxNew相关。我们在本章介绍了第一个，其余三个将会在后续文章中介绍。 CreateTransaction() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew, int64&amp; nFeeRequiredRet) { &nbsp; &nbsp; nFeeRequiredRet = 0; &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // txdb must be opened before the mapWallet lock &nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;); &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nFee = nTransactionFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = nValue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValue += nFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose coins to use &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set&lt;CWalletTx*&gt; setCoins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!SelectCoins(nValue, setCoins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += pcoin-&gt;GetCredit(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[0] to the payee &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] back to self with any change &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValueIn &gt; nValue) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Use the same key as one of the coins &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txFirst = *(*setCoins.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, txFirst.vout) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vchPubKey.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] to ourself &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; vchPubKey &lt;&lt; OP_CHECKSIG; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SignSignature(*pcoin, wtxNew, nIn++); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Check that enough fee is included &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nFee &lt; wtxNew.GetMinFee(true)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFee = nFeeRequiredRet = wtxNew.GetMinFee(true); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vtxPrev by copying from previous transactions vtxPrev &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.AddSupportingTransactions(txdb); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.fTimeReceivedIsTxTime = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } &nbsp; 调用该方法时，它所需要的四个参数如下： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue是将要转账的数额，交易费nTransactionFee并未包括在内。 wtxNew是一个新的Tx实例。 nFeeRequiredRet是一笔用来支付交易费的输出交易，在该方法执行完成之后获得。 该方法的流程如下： 定义一个本地变量nValueOut = nValue来保存将转账的金额（第17行）。将nValue与交易费nFee相加得到新的包含转账费的nValue。 执行位于第21行的SelectCoins(nValue, setCoins)得到一系列币，并放入setCoins。setCoins包含支付给你本人地址的交易，即你所拥有的币。这些交易将成为wtxNew的来源交易。 执行位于第27行的wtxNew.vout.push_back(CTxOut (nValueOut,sciptPubKey))并添加一笔输出交易至wtxNew。该笔输出将支付给&lt;收款人地址160位哈希&gt;（包含在scriptPubKey里面）数量为的币。 如果需要找零（nValueIn &gt; nValue），添加另一笔输出交易至wtxNew并将零钱发回本人。该过程包含以下步骤： 从setCoin当中获取第一笔交易txFirst，依次检查txFirst.vout中的交易是否属于本人。如果是则从该笔输出交易当中提取出公钥，并放入本地变量vchPubKey 将vchPubKey放入脚本vchPubKey OP_CHECKSIG，并使用这段脚本代码为wtxNew添加一个支付给本人的输出交易（第45行）。 因为setCoins包含支付给本人的交易，所以每笔交易一定包括至少一笔支付给本人的交易。从第一笔交易txFirst中即可找到。 至此，wtxNew的输出交易容器vout已准备就绪。现在，该设置输入交易容器vin。记住每一个输入交易列表vin均引用一笔来源交易，而且wtxNew的每笔来源交易均可在setCoins中被找到。对于每一笔setCoins中的交易pcoin，逐个遍历其输出交易pcoin-&gt;vout[nOut]。如果第nOut笔输出支付给本人（意味着wtxNew从该笔输出交易中获得币），则向wtxNew添加一笔新的输入交易（wtxNew.vin(wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut))，第51行)。该输入交易指向pcoin中的第nOut笔输出交易，由此将wtxNew.vin与pcoin的第nOut笔输出相连接。 对于setCoins当中的每笔交易pcoin，逐个遍历其所有输出交易pcoin-&gt;vout[nOut]。如果该笔交易属于本人，调用SignSignature(*pcoin,wtxNew, nIn++)为第nIn笔输入交易添加签名。注意nIn为wtxNew的输入交易位置。 如果交易费nFee小于wtxNet.GetMinFee(true)，将nFee设为后者，清空wtxNew中的所有数据并重新开始整个过程。在位于第11行的第一次迭代当中，nFee是全局变量nTransactionFee = 0的本地复制。 如果你不明白为什么要如此费力地重新添满wtxNew，源码中的GetMinFee()提供了答案：交易的最低费用与交易的数据大小有关。wtxNew的大小只有在完整构建之后才可得知。如果wtxNew.GetMinFee(true)计算得到的最小交易费用大于之前创造wtxNew时假设的交易费nFee，则除了重新构建wtxNew之外别无他法。 这里遇到了一个先有鸡还是先有蛋的局面：若想创建一笔新的交易，则必须知道交易费用是多少。而交易费只有在整个交易被创建以后才可得知。为了打破这个循环，本地变量nFee被用来放置预计的交易费用，并且新的交易构建在此基础上。在构建完成之后，得到真实的交易费并与预估的交易费作比较。如果预估的交易费小于真实的交易费，则替换成真实交易费并重新构造整个交易。 这里是GetMinFee()的源码： &nbsp; int64 GetMinFee(bool fDiscount=false) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK); &nbsp; &nbsp; &nbsp; &nbsp; if (fDiscount &amp;&amp; nBytes &lt; 10000) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; return (1 + (int64)nBytes / 1000) * CENT; &nbsp; &nbsp; } &nbsp; 如果计算得到的交易费比之前预计的交易费更高，则跳出第11行开始的循环并返回整个函数（第67行）。在此之前，需要进行以下两个步骤： 执行wtxNew.AddSupportingTransactions(txdb)。这一部分以后会进行更详细介绍。 设置wtxNet.fTimeReceivedIsTxTime=true（第66行）。 现在来看一下如何通过SignSignature()签署新生成的交易wtxNew。 SignSignature() 该方法位于script.cpp。以下是该方法的源码： &nbsp; bool SignSignature(const CTransaction&amp; txFrom, CTransaction&amp; txTo, unsigned int nIn, int nHashType, CScript scriptPrereq) { &nbsp; &nbsp; assert(nIn &lt; txTo.vin.size()); &nbsp; &nbsp; CTxIn&amp; txin = txTo.vin[nIn]; &nbsp; &nbsp; assert(txin.prevout.n &lt; txFrom.vout.size()); &nbsp; &nbsp; const CTxOut&amp; txout = txFrom.vout[txin.prevout.n]; &nbsp; &nbsp; // Leave out the signature from the hash, since a signature can&#39;t sign itself. &nbsp; &nbsp; // The checksig op will also drop the signatures from its hash. &nbsp; &nbsp; uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType); &nbsp; &nbsp; if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; txin.scriptSig = scriptPrereq + txin.scriptSig; &nbsp; &nbsp; // Test solution &nbsp; &nbsp; if (scriptPrereq.empty()) &nbsp; &nbsp; &nbsp; &nbsp; if (!EvalScript(txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey, txTo, nIn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; return true; } &nbsp; 首先需要注意的是，该函数有5个参数，而CreateTransaction()只有3个。这是因为在script.h文件里，后两个参数已默认给出。 以下是传递给CreateTransaction()中的3个参数： txFrom是一个*pcoin对象。它是CreateTransaction()里setCoins中的所有币中的某一个。它同时也是一笔来源交易。它的若干输出交易当中包含了新交易将要花费的币。 txTo是CreateTransaction()里的wtxNew对象。它是将要花费来源交易txFrom的新交易。新交易需要被签署方可生效。 nIn是指向txTo中输入交易列表的索引位置。该输入交易列表包含一个对txFrom的输出交易列表的引用。更准确地讲，txin=txTo.vin[nIn]（第4行）是txTo中的输入交易；txout=txFrom.vout[txin.prev.out.n]（第6行）是txin所指向的txFrom中的输出交易。 以下是SignSignature()所做的工作： 调用SignatureHash()方法生成txTo的哈希值。 调用Solver()函数签署刚才生成的哈希。 调用EvalScript()来运行一小段脚本并检查签名是否合法。 我们一起看一下这三个函数。 SignatureHash() 该方法位于script.cpp。以下是SignatureHash()的源码。 &nbsp; uint256 SignatureHash(CScript scriptCode, const CTransaction&amp; txTo, unsigned int nIn, int nHashType) { &nbsp; &nbsp; if (nIn &gt;= txTo.vin.size()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nIn=%d out of range\n&quot;, nIn); &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; } &nbsp; &nbsp; CTransaction txTmp(txTo); &nbsp; &nbsp; // In case concatenating two scripts ends up with two codeseparators, &nbsp; &nbsp; // or an extra one at the end, this prevents all those possible incompatibilities. &nbsp; &nbsp; scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR)); &nbsp; &nbsp; // Blank out other inputs&#39; signatures &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].scriptSig = CScript(); &nbsp; &nbsp; txTmp.vin[nIn].scriptSig = scriptCode; &nbsp; &nbsp; // Blank out some of the outputs &nbsp; &nbsp; if ((nHashType &amp; 0x1f) == SIGHASH_NONE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Wildcard payee &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; else if ((nHashType &amp; 0x1f) == SIGHASH_SINGLE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Only lockin the txout payee at same index as txin &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nOut = nIn; &nbsp; &nbsp; &nbsp; &nbsp; if (nOut &gt;= txTmp.vout.size()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nOut=%d out of range\n&quot;, nOut); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.resize(nOut+1); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nOut; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout[i].SetNull(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; // Blank out other inputs completely, not recommended for open transactions &nbsp; &nbsp; if (nHashType &amp; SIGHASH_ANYONECANPAY) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[0] = txTmp.vin[nIn]; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin.resize(1); &nbsp; &nbsp; } &nbsp; &nbsp; // Serialize and hash &nbsp; &nbsp; CDataStream ss(SER_GETHASH); &nbsp; &nbsp; ss.reserve(10000); &nbsp; &nbsp; ss &lt;&lt; txTmp &lt;&lt; nHashType; &nbsp; &nbsp; return Hash(ss.begin(), ss.end()); } 以下是该函数所需要的参数： &nbsp; txTo是将要被签署的交易。它同时也是CreateTransaction()中的wtxNew对象。它的输入交易列表中的第nIn项，txTo.vin[nIn]，是该函数将要起作用的目标。 scriptCode是scriptPrereq + txout.scriptPubKey，其中txout是SignSignature()中定义的来源交易txFrom()的输出交易。由于此时scriptPrereq为空，scriptCode事实上是来源交易txFrom中的输出交易列表当中被txTo作为输入交易引用的那笔的脚本代码。txout.scriptPubKey有可能包含两类脚本： 脚本A：OP_DUP OP_HASH160 &lt;你地址的160位哈希&gt; OP_EQUALVERIFY OP_CECKSIG。该脚本将来源交易txFrom中的币发送给你，其中&lt;你地址的160位哈希&gt;是你的以太坊代币开发地址。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。该脚本将剩余的币退还至来源交易txFrom的发起人。由于你创建的新交易txTo/wtxNew将会花费来自txFrom的币，你必须同时也是txFrom的创建者。换句话讲，当你在创建txFrom的时候，你其实是在花费之前别人发送给你的币。因此，&lt;你的公钥&gt;即是txFrom创建者的公钥，也是你自己的公钥。 我们在此停留片刻，来思考一下脚本A和脚本B。你有可能会问，这些脚本是从哪来的。中本聪在创造以太坊代币开发的时候为以太坊代币开发添加了一套脚本语言系统，所以以太坊代币开发中的交易都是由脚本代码完成的。该脚本系统其实也是后来智能合约的雏形。脚本A来自第29行，位于方法CSendDialog::OnButtonSend()，脚本B则来自第44行，位于方法CreateTransaction()。 当用户发起一笔交易时，以太坊代币开发客户端会调用CSendDialog::OnButtonSend()方法并将脚本A添加至txFrom中的一笔输出交易中。由于该输出交易的收款方为你本人，从而脚本中的&lt;收款人地址160位哈希&gt;，就是&lt;你的地址160位哈希&gt;。 如果txFrom是你本人创建的，则脚本B会被添加至CreateTransaction()中txFrom的某一笔输出交易。在这里，第44行位于CreateTransaction()中的公钥vchPubKey是你本人的公钥。 在了解了输入交易之后，我们来一起了解SignatureHash()是怎样工作的。 SignatureHash()首先将txTO拷贝至txTmp，接着清空txTmp.vin中每一笔输入交易的scriptSig，除了txTmp.vin[nIn]之外，该输入交易的scriptSig被设为scriptCode(第14、15行）。 接着，该函数检验nHashType的值。该函数的调用者将一个枚举值传递至该函数nHashType = SIGHASH_ALL。 &nbsp; enum { &nbsp; &nbsp; SIGHASH_ALL = 1, &nbsp; &nbsp; SIGHASH_NONE = 2, &nbsp; &nbsp; SIGHASH_SINGLE = 3, &nbsp; &nbsp; SIGHASH_ANYONECANPAY = 0x80, }; 由于nHashType = SIGHASH_ALL，所有的if-else条件均不成立，该函数将直接执行最后4行代码。 &nbsp; 在最后4行代码中，txTmp和nHashType变成序列化后的类型CDataStream对象。该类型包括一个装有数据的字符容器类型。所返回的哈希值是Hash()方法在计算序列化后的数据所得到的。 一笔交易可以包含多笔输入交易。SignatureHash()取其中一笔作为目标。它通过以下步骤生成哈希： 清空除了目标交易之外的所有输入交易。 复制来源交易中被目标交易作为输入交易引用的那笔输出交易的脚本至目标交易的输入交易列表中。 为修改后的交易生成哈希值。 Hash() 该方法位于util.h。以下是生成哈希值的方法Hash()的源码： &nbsp; template&lt;typename T1&gt; inline uint256 Hash(const T1 pbegin, const T1 pend) { &nbsp; &nbsp; uint256 hash1; &nbsp; &nbsp; SHA256((unsigned char*)&amp;pbegin[0], (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&amp;hash1); &nbsp; &nbsp; uint256 hash2; &nbsp; &nbsp; SHA256((unsigned char*)&amp;hash1, sizeof(hash1), (unsigned char*)&amp;hash2); &nbsp; &nbsp; return hash2; } 该函数对目标数据执行两次SHA256()方法并返回结果。SHA256()的声明可在openssl/sha.h中找到。 &nbsp; Solver() 该方法位于script.cpp。Solver()在SignSignature()中紧接着SignatureHash()被执行。它是真正用来为SignatureHash()返回的哈希值生成签名的函数。 &nbsp; bool Solver(const CScript&amp; scriptPubKey, uint256 hash, int nHashType, CScript&amp; scriptSigRet) { &nbsp; &nbsp; scriptSigRet.clear(); &nbsp; &nbsp; vector&lt;pair&lt;opcodetype, valtype&gt; &gt; vSolution; &nbsp; &nbsp; if (!Solver(scriptPubKey, vSolution)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; // Compile solution &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(opcodetype, valtype)&amp; item, vSolution) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (item.first == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const valtype&amp; vchPubKey = item.second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (item.first == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign and give pubkey &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint160, valtype&gt;::iterator mi = mapPubKeys.find(uint160(item.second)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi == mapPubKeys.end()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const vector&lt;unsigned char&gt;&amp; vchPubKey = (*mi).second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig &lt;&lt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } 以下是该方法所需要的4个参数： &nbsp; 位于第10行的调用函数SignSignature()将txOut.scriptPubKey，来源交易txFrom的输出脚本，作为输入值传入第一个参数scriptPubKey。记住它可能包含脚本A或者脚本B。 第二个参数hash是由SignatureHash()生成的哈希值。 第三个参数nHashType的值为SIGHASH_ALL。 第四个参数是该函数的返回值，即调用函数SignSIgnature()中位于第12行的txin.scriptSig。记住txin是新生成的交易wtxNew（在调用函数SignSignature()中作为txTo引用）位于第nIn的输入交易。因此，wtxNew第nIn笔输入交易的scriptSig将存放该函数返回的签名。 该函数首先会调用另一个有2个参数的Solver()。我们来研究一下。 带有2个参数的Solver() 该方法位于script.cpp。以下是带有2个参数的Solver()的源码： &nbsp; bool Solver(const CScript&amp; scriptPubKey, vector&lt;pair&lt;opcodetype, valtype&gt; &gt;&amp; vSolutionRet) { &nbsp; &nbsp; // Templates &nbsp; &nbsp; static vector&lt;CScript&gt; vTemplates; &nbsp; &nbsp; if (vTemplates.empty()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Standard tx, sender provides pubkey, receiver adds signature &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; &nbsp; &nbsp; // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; } &nbsp; &nbsp; // Scan templates &nbsp; &nbsp; const CScript&amp; script1 = scriptPubKey; &nbsp; &nbsp; foreach(const CScript&amp; script2, vTemplates) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; &nbsp; &nbsp; opcodetype opcode1, opcode2; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vch1, vch2; &nbsp; &nbsp; &nbsp; &nbsp; // Compare &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc1 = script1.begin(); &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc2 = script2.begin(); &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f1 = script1.GetOp(pc1, opcode1, vch1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f2 = script2.GetOp(pc2, opcode2, vch2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!f1 &amp;&amp; !f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Success &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse(vSolutionRet.begin(), vSolutionRet.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (f1 != f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() &lt;= sizeof(uint256)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() != sizeof(uint160)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode1 != opcode2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; return false; } 第一个参数scriptPubKey可能包含脚本A也可能是脚本B。再一次说明，它是SignSignature()中来源交易txFrom的输出脚本。 &nbsp; 第二个参数用来存放输出交易。它是一个容器对，每个对由一个脚本运算符（opcodetype类型）和脚本操作元（valtype类型）构成。 该函数第8-10行首先定义两个模板： 模板A：OP_DUP OP_HASH160 OP_PUBKEYHASH OP_EQUALVERIFY OP_CHECKSIG。 模板B：OP_PUBKEY OP_CHECKSIG。 很明显，模板A、模板B与脚本A、脚本B相对应。为了便于对比，以下是脚本A和B的内容： 脚本A：OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。 该函数的作用是将scriptPubKey与两个模板相比较： 如果输入脚本为脚本A，则将模板A中的OP_PUBKEYHASH与脚本A中的&lt;你的地址160位哈希&gt;配对，并将该对放入vSolutionRet。 如果输入脚本为脚本B，则从模板B中提取运算符OP_PUBKEY，和从脚本B中提取运算元&lt;你的公钥&gt;，将二者配对并放入vSolutionRet。 如果输入脚本与两个模板均不匹配，则返回false。 回到Solver() 我们回到有4个参数的Solver()并继续对该函数的分析。现在我们清楚了该函数的工作原理。它会在两个分支中选择一个执行，取决于从vSolutionRet得到的对来自脚本A还是脚本B。如果来自脚本A，item.first &nbsp;== OP_PUBKEYHASH；如果来自脚本B，item.first &nbsp;== OP_PUBKEY。 item.first &nbsp;== OP_PUBKEY（脚本B）。在该情形下，item.second包含&lt;你的公钥&gt;。全局变量mapKeys将你的全部公钥映射至与之对应的私钥。如果mapKeys当中没有该公钥，则报错（第16行）。否则，用从mapKeys中提取出的私钥签署新生成的交易wtxNew的哈希值，其中哈希值作为第2个被传入的参数（CKey::Sign(mapKeys[vchPubKey], hash, vchSig)，第23行），再将结果放入vchSig，接着将其序列化成scriptSigRet（scriptSigRet &lt;&lt; vchSig，第24行）并返回。 item.first &nbsp;== OP_PUBKEYHASH（脚本A）。在该情形下，item.second包含&lt;你的地址160位哈希&gt;。该以太坊代币开发地址将被用于从位于第23行的全局映射mapPubKeys中找到其所对应的公钥。全局映射mapPubKeys将你的地址与生成它们的公钥建立一一对应关系（查看函数AddKey()）。接着，通过该公钥从mapKeys中找到所对应的私钥，并用该私钥签署第二个参数hash。签名和公钥将一同被序列化至scriptSigRet并返回（scriptSig &lt;&lt; vchSig &lt;&lt; vchPubkey，第24行）。 EvalScript() 该方法位于script.cpp。现在我们回到SignSignature()。在该函数的第12行之后，txin.scriptsig，即wtxNew的第nIn笔输入交易中的scriptSig部分，将插入一个签名。该签名可能是以下其中之一： vchSig vchPubKey（脚本A的签名A） vchSig（脚本B的签名B） 在下文当中，vchSig将被引用为&lt;你的签名_vchSig&gt;，vchPubKey则为&lt;你的公钥_vchPubKey&gt;，以强调它们分别是你本人的签名和公钥。 我们现在开始调查EvalScript()，该函数是SignSignature()调用的最后一个函数，位于第15行。EvalScript()带有3个参数，分别为： 第一个参数为txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey。它有可能是： 验证情形A：&lt;你的签名_vchSig&gt; &lt;你的公钥_vchPubKey&gt; OP_CODESEPARATOR OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG，即签名A + OP_CODESEPARATOR + 脚本A。 验证情形B：&lt;你的签名_vchSig&gt; OP_CODESEPARATOR &lt;你的公钥_vchPubKey&gt; OP_CHECKSIG，即签名B + OP_CODESEPARATOR + 脚本B。 第二个参数为新创建的交易txTo，即CreateTransaction()中的wtxNew。 第三个参数为nIn，即将被验证的交易在txTo输入交易列表中的位置。 验证过程我们会在后面详细讲述。简单地说，EvalScript()验证新创建交易wtxNew的第nIn笔输入交易是否包含有效的签名。至此，一笔新的以太坊代币开发交易便创建完成。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/11/20/ad7400e7f5a5fb2fc38c20d07f1ea220.html" />
<meta property="og:url" content="https://mlh.app/2017/11/20/ad7400e7f5a5fb2fc38c20d07f1ea220.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/78580207 前言 区块链爱好者（QQ：53016353） 从事区块链的开发，不了解其底层核心技术是不够的。许多人在看了以太坊代币开发白皮书之后仍然不清楚以太坊代币开发是怎样实现的，因为以太坊代币开发的源码设计精巧，有许多设计白皮书未曾提及，加上本身以太坊代币开发的文档稀少，加大了新手理解的困难程度。尽管现在已经有许多介绍区块链的书和文章，却很少是从源码着手分析的。我通过半年时间对于区块链的学习，开始撰写一份以太坊代币开发源码的教程。本教程深入浅出，通过分析最经典的区块链——以太坊代币开发的C++客户端源码，让开发者用最短的时间上手区块链技术。了解以太坊代币开发源码可帮助开发者更好了解区块链的工作原理并在应用当中根据实际情况做出修改和调整。 本文所引用的源码均来自原始版以太坊代币开发客户端，即由中本聪发布的第一版源码。该客户端包括大约16000行代码。尽管经过数年的发展，以太坊代币开发客户端经过了几次较大更新，其数据结构和原理从诞生之日起一直延续至今。本文会尽可能保证文字的严谨准确，表达当中难免会产生疏漏，欢迎指正。 bitcoin-code &nbsp; 第一章 &nbsp; 本章节讲述以太坊代币开发客户端是怎样生成以太坊代币开发地址，并创建新的交易。 我们来看一下GenerateNewKey()方法，该方法位于main.cpp。 &nbsp; bool AddKey(const CKey&amp; key) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; mapKeys[key.GetPubKey()] = key.GetPrivKey(); &nbsp; &nbsp; &nbsp; &nbsp; mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey(); &nbsp; &nbsp; } &nbsp; &nbsp; return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey()); } vector&lt;unsigned char&gt; GenerateNewKey() { &nbsp; &nbsp; CKey key; &nbsp; &nbsp; key.MakeNewKey(); &nbsp; &nbsp; if (!AddKey(key)) &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GenerateNewKey() : AddKey failed\\n&quot;); &nbsp; &nbsp; return key.GetPubKey(); } 该方法通过以下步骤生成一个新的公钥对： &nbsp; 首先建立一个新的CKey类型对象（第13行）。 调用addKey()方法将新建的key添加至1）全局映射mapKeys （第5行）2）全局map mapPubKeys（第6行）和钱包数据库wallet.dat（第8行）。 mapKeys建立公钥与私钥的一一对应关系。 mapPubKeys建立公钥的hash和公钥本身的对应关系。 返回公钥（第16行）。 该公钥为未压缩的格式，属于OpenSSL标准格式之一。在得到公钥之后，以太坊代币开发客户端会将该公钥传递至PubKeyToAddress()并调用Hash160ToAddress()方法生成地址。最后返回的Base58编码字符串值便是一个新生成的以太坊代币开发地址。Base58由1-9和除i，l，0，o之外的英文字符组成。 CTransaction类 CTransaction的定义位于main.h。在以太坊代币开发当中，所谓币的概念其实是一系列交易Tx的组合。这种方式虽然实现起来更为复杂，却提高了以太坊代币开发的安全性。用户可以为每一笔交易创建一个新的地址，地址在使用一次之后可以立即作废。因此，CTransaction是以太坊代币开发客户端最重要的类之一。 &nbsp; class CTransaction { public: &nbsp; &nbsp; int nVersion; &nbsp; &nbsp; vector&lt;CTxIn&gt; vin; &nbsp; &nbsp; vector&lt;CTxOut&gt; vout; &nbsp; &nbsp; int nLockTime; &nbsp; &nbsp; //...... } &nbsp; CTransaction包含两个容器类型：输入交易vin和输出交易vout。每个vin由若干CTxIn对象组成，每个vout则由CTxOut组成。 每笔交易Tx的输入交易（CTxIn类）包含一个COutPoint对象prevout，该对象引用另外一笔交易Tx的输出交易作为来源交易。来源交易使当前交易Tx从另一笔交易当中得到可花费的以太坊代币开发。一笔交易Tx可以拥有任意笔输入交易。 任何交易均由一个256位uint256哈希作为其唯一识别。若要引用某一笔来源交易TxSource当中某个特定的输出交易，我们需要两种信息：TxSource的哈希，和该输出交易在输出交易当中的位置n。这两种信息构成COutPoint类。一个COutPoint对象指向来源交易的某一笔输出交易TxSource.vout[n]。如果该笔输出交易被另外一笔交易Tx的位置i的输入交易所引用，例如Tx.vin[i].prevout，我们将其称为Tx的第i笔输入交易花费了TxSource中的第n笔输出交易。 uint256和uint160类 这两种类型的定义位于uint.h。一个uint256类包含有一个256位的哈希。它由一个长度为256/32=8的unsigned int数组构成。一个相似的数据结构是uint160，该结构的定义可在同一个文件当中找到。既然SHA-256的长度为256bit，读者不难推断出uint160的作用是存放RIPEMD-160哈希。uint256和uint160均由base_uint类继承而来。 &nbsp; class base_uint { protected: &nbsp; &nbsp; enum { WIDTH = BITS / 32 }; &nbsp; &nbsp; unsigned int pn[WIDTH]; public: &nbsp; &nbsp; bool operator!() const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; WIDTH; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pn[i] != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; } &nbsp; &nbsp; //...... &nbsp; &nbsp; unsigned int GetSerializeSize(int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; return sizeof(pn); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Serialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.write((char*)pn, sizeof(pn)); &nbsp; &nbsp; } &nbsp; &nbsp; template &lt;typename Stream&gt; &nbsp; &nbsp; void Unserialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; s.read((char*)pn, sizeof(pn)); &nbsp; &nbsp; } } 该类重载了若干运算符。此外该类拥有3个序列化成员函数，GetSerializeSize()、Serialize()和Unserialize()。我们会在后面讲到这三种方法是如何工作的。 &nbsp; SendMoney() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew) { &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; int64 nFeeRequired; &nbsp; &nbsp; &nbsp; &nbsp; if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string strError; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue + nFeeRequired &gt; GetBalance()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: This is an oversized transaction that requires a transaction fee of %s &quot;, FormatMoney(nFeeRequired).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: Transaction creation failed &quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(strError, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : %s\\n&quot;, strError.c_str()); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!CommitTransactionSpent(wtxNew)) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error finalizing transaction&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error finalizing transaction&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;SendMoney: %s\\n&quot;, wtxNew.GetHash().ToString().substr(0,6).c_str()); &nbsp; &nbsp; &nbsp; &nbsp; // Broadcast &nbsp; &nbsp; &nbsp; &nbsp; if (!wtxNew.AcceptTransaction()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // This must not fail. The transaction has already been signed and recorded. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;SendMoney() : wtxNew.AcceptTransaction() failed\\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(&quot;Error: Transaction not valid&quot;, &quot;Sending...&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;SendMoney() : Error: Transaction not valid&quot;); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.RelayWalletTransaction(); &nbsp; &nbsp; } &nbsp; &nbsp; MainFrameRepaint(); &nbsp; &nbsp; return true; } &nbsp; 当用户发送以太坊代币开发到某一个地址时，以太坊代币开发客户端会调用SendMoney()方法。该方法包含三个参数： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue表示将要转账的金额。该金额并未包含交易费nTrasactionFee。 wtxNew是一个CWalletTx类的本地变量。该变量目前的值为空，之后会包含若干CMerkleTX类对象。该类由CTransaction衍生而来，并且添加了若干方法。我们暂时先不管具体细节，仅将其看作CTransaction类。 该方法的流程显而易见： 首先建立一笔新的交易（CreateTransaction(scriptPubKey, nValue, wtxNet, nFeeRequired)，第6行）。 尝试将这笔交易提交至数据库（CommitTransactionSpent(wtxNet)，第16行）。 如果该笔交易提交成功（wtxNew.AcceptTransaction()，第23行），将其广播至其他peer节点（wtxNew.RelayWalletTransaction()，第30行）。 这四个方法都与wtxNew相关。我们在本章介绍了第一个，其余三个将会在后续文章中介绍。 CreateTransaction() 该方法位于main.cpp。以下是该方法的源码： &nbsp; bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew, int64&amp; nFeeRequiredRet) { &nbsp; &nbsp; nFeeRequiredRet = 0; &nbsp; &nbsp; CRITICAL_BLOCK(cs_main) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // txdb must be opened before the mapWallet lock &nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;); &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nFee = nTransactionFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = nValue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValue += nFee; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose coins to use &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set&lt;CWalletTx*&gt; setCoins; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!SelectCoins(nValue, setCoins)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += pcoin-&gt;GetCredit(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[0] to the payee &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] back to self with any change &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValueIn &gt; nValue) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Use the same key as one of the coins &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txFirst = *(*setCoins.begin()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, txFirst.vout) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vchPubKey.empty()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] to ourself &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; vchPubKey &lt;&lt; OP_CHECKSIG; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nIn = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SignSignature(*pcoin, wtxNew, nIn++); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Check that enough fee is included &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nFee &lt; wtxNew.GetMinFee(true)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFee = nFeeRequiredRet = wtxNew.GetMinFee(true); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vtxPrev by copying from previous transactions vtxPrev &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.AddSupportingTransactions(txdb); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.fTimeReceivedIsTxTime = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } &nbsp; 调用该方法时，它所需要的四个参数如下： scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 nValue是将要转账的数额，交易费nTransactionFee并未包括在内。 wtxNew是一个新的Tx实例。 nFeeRequiredRet是一笔用来支付交易费的输出交易，在该方法执行完成之后获得。 该方法的流程如下： 定义一个本地变量nValueOut = nValue来保存将转账的金额（第17行）。将nValue与交易费nFee相加得到新的包含转账费的nValue。 执行位于第21行的SelectCoins(nValue, setCoins)得到一系列币，并放入setCoins。setCoins包含支付给你本人地址的交易，即你所拥有的币。这些交易将成为wtxNew的来源交易。 执行位于第27行的wtxNew.vout.push_back(CTxOut (nValueOut,sciptPubKey))并添加一笔输出交易至wtxNew。该笔输出将支付给&lt;收款人地址160位哈希&gt;（包含在scriptPubKey里面）数量为的币。 如果需要找零（nValueIn &gt; nValue），添加另一笔输出交易至wtxNew并将零钱发回本人。该过程包含以下步骤： 从setCoin当中获取第一笔交易txFirst，依次检查txFirst.vout中的交易是否属于本人。如果是则从该笔输出交易当中提取出公钥，并放入本地变量vchPubKey 将vchPubKey放入脚本vchPubKey OP_CHECKSIG，并使用这段脚本代码为wtxNew添加一个支付给本人的输出交易（第45行）。 因为setCoins包含支付给本人的交易，所以每笔交易一定包括至少一笔支付给本人的交易。从第一笔交易txFirst中即可找到。 至此，wtxNew的输出交易容器vout已准备就绪。现在，该设置输入交易容器vin。记住每一个输入交易列表vin均引用一笔来源交易，而且wtxNew的每笔来源交易均可在setCoins中被找到。对于每一笔setCoins中的交易pcoin，逐个遍历其输出交易pcoin-&gt;vout[nOut]。如果第nOut笔输出支付给本人（意味着wtxNew从该笔输出交易中获得币），则向wtxNew添加一笔新的输入交易（wtxNew.vin(wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut))，第51行)。该输入交易指向pcoin中的第nOut笔输出交易，由此将wtxNew.vin与pcoin的第nOut笔输出相连接。 对于setCoins当中的每笔交易pcoin，逐个遍历其所有输出交易pcoin-&gt;vout[nOut]。如果该笔交易属于本人，调用SignSignature(*pcoin,wtxNew, nIn++)为第nIn笔输入交易添加签名。注意nIn为wtxNew的输入交易位置。 如果交易费nFee小于wtxNet.GetMinFee(true)，将nFee设为后者，清空wtxNew中的所有数据并重新开始整个过程。在位于第11行的第一次迭代当中，nFee是全局变量nTransactionFee = 0的本地复制。 如果你不明白为什么要如此费力地重新添满wtxNew，源码中的GetMinFee()提供了答案：交易的最低费用与交易的数据大小有关。wtxNew的大小只有在完整构建之后才可得知。如果wtxNew.GetMinFee(true)计算得到的最小交易费用大于之前创造wtxNew时假设的交易费nFee，则除了重新构建wtxNew之外别无他法。 这里遇到了一个先有鸡还是先有蛋的局面：若想创建一笔新的交易，则必须知道交易费用是多少。而交易费只有在整个交易被创建以后才可得知。为了打破这个循环，本地变量nFee被用来放置预计的交易费用，并且新的交易构建在此基础上。在构建完成之后，得到真实的交易费并与预估的交易费作比较。如果预估的交易费小于真实的交易费，则替换成真实交易费并重新构造整个交易。 这里是GetMinFee()的源码： &nbsp; int64 GetMinFee(bool fDiscount=false) const &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK); &nbsp; &nbsp; &nbsp; &nbsp; if (fDiscount &amp;&amp; nBytes &lt; 10000) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; return (1 + (int64)nBytes / 1000) * CENT; &nbsp; &nbsp; } &nbsp; 如果计算得到的交易费比之前预计的交易费更高，则跳出第11行开始的循环并返回整个函数（第67行）。在此之前，需要进行以下两个步骤： 执行wtxNew.AddSupportingTransactions(txdb)。这一部分以后会进行更详细介绍。 设置wtxNet.fTimeReceivedIsTxTime=true（第66行）。 现在来看一下如何通过SignSignature()签署新生成的交易wtxNew。 SignSignature() 该方法位于script.cpp。以下是该方法的源码： &nbsp; bool SignSignature(const CTransaction&amp; txFrom, CTransaction&amp; txTo, unsigned int nIn, int nHashType, CScript scriptPrereq) { &nbsp; &nbsp; assert(nIn &lt; txTo.vin.size()); &nbsp; &nbsp; CTxIn&amp; txin = txTo.vin[nIn]; &nbsp; &nbsp; assert(txin.prevout.n &lt; txFrom.vout.size()); &nbsp; &nbsp; const CTxOut&amp; txout = txFrom.vout[txin.prevout.n]; &nbsp; &nbsp; // Leave out the signature from the hash, since a signature can&#39;t sign itself. &nbsp; &nbsp; // The checksig op will also drop the signatures from its hash. &nbsp; &nbsp; uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType); &nbsp; &nbsp; if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; txin.scriptSig = scriptPrereq + txin.scriptSig; &nbsp; &nbsp; // Test solution &nbsp; &nbsp; if (scriptPrereq.empty()) &nbsp; &nbsp; &nbsp; &nbsp; if (!EvalScript(txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey, txTo, nIn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; return true; } &nbsp; 首先需要注意的是，该函数有5个参数，而CreateTransaction()只有3个。这是因为在script.h文件里，后两个参数已默认给出。 以下是传递给CreateTransaction()中的3个参数： txFrom是一个*pcoin对象。它是CreateTransaction()里setCoins中的所有币中的某一个。它同时也是一笔来源交易。它的若干输出交易当中包含了新交易将要花费的币。 txTo是CreateTransaction()里的wtxNew对象。它是将要花费来源交易txFrom的新交易。新交易需要被签署方可生效。 nIn是指向txTo中输入交易列表的索引位置。该输入交易列表包含一个对txFrom的输出交易列表的引用。更准确地讲，txin=txTo.vin[nIn]（第4行）是txTo中的输入交易；txout=txFrom.vout[txin.prev.out.n]（第6行）是txin所指向的txFrom中的输出交易。 以下是SignSignature()所做的工作： 调用SignatureHash()方法生成txTo的哈希值。 调用Solver()函数签署刚才生成的哈希。 调用EvalScript()来运行一小段脚本并检查签名是否合法。 我们一起看一下这三个函数。 SignatureHash() 该方法位于script.cpp。以下是SignatureHash()的源码。 &nbsp; uint256 SignatureHash(CScript scriptCode, const CTransaction&amp; txTo, unsigned int nIn, int nHashType) { &nbsp; &nbsp; if (nIn &gt;= txTo.vin.size()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nIn=%d out of range\\n&quot;, nIn); &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; } &nbsp; &nbsp; CTransaction txTmp(txTo); &nbsp; &nbsp; // In case concatenating two scripts ends up with two codeseparators, &nbsp; &nbsp; // or an extra one at the end, this prevents all those possible incompatibilities. &nbsp; &nbsp; scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR)); &nbsp; &nbsp; // Blank out other inputs&#39; signatures &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].scriptSig = CScript(); &nbsp; &nbsp; txTmp.vin[nIn].scriptSig = scriptCode; &nbsp; &nbsp; // Blank out some of the outputs &nbsp; &nbsp; if ((nHashType &amp; 0x1f) == SIGHASH_NONE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Wildcard payee &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.clear(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; else if ((nHashType &amp; 0x1f) == SIGHASH_SINGLE) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Only lockin the txout payee at same index as txin &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nOut = nIn; &nbsp; &nbsp; &nbsp; &nbsp; if (nOut &gt;= txTmp.vout.size()) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SignatureHash() : nOut=%d out of range\\n&quot;, nOut); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.resize(nOut+1); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nOut; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout[i].SetNull(); &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0; &nbsp; &nbsp; } &nbsp; &nbsp; // Blank out other inputs completely, not recommended for open transactions &nbsp; &nbsp; if (nHashType &amp; SIGHASH_ANYONECANPAY) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[0] = txTmp.vin[nIn]; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin.resize(1); &nbsp; &nbsp; } &nbsp; &nbsp; // Serialize and hash &nbsp; &nbsp; CDataStream ss(SER_GETHASH); &nbsp; &nbsp; ss.reserve(10000); &nbsp; &nbsp; ss &lt;&lt; txTmp &lt;&lt; nHashType; &nbsp; &nbsp; return Hash(ss.begin(), ss.end()); } 以下是该函数所需要的参数： &nbsp; txTo是将要被签署的交易。它同时也是CreateTransaction()中的wtxNew对象。它的输入交易列表中的第nIn项，txTo.vin[nIn]，是该函数将要起作用的目标。 scriptCode是scriptPrereq + txout.scriptPubKey，其中txout是SignSignature()中定义的来源交易txFrom()的输出交易。由于此时scriptPrereq为空，scriptCode事实上是来源交易txFrom中的输出交易列表当中被txTo作为输入交易引用的那笔的脚本代码。txout.scriptPubKey有可能包含两类脚本： 脚本A：OP_DUP OP_HASH160 &lt;你地址的160位哈希&gt; OP_EQUALVERIFY OP_CECKSIG。该脚本将来源交易txFrom中的币发送给你，其中&lt;你地址的160位哈希&gt;是你的以太坊代币开发地址。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。该脚本将剩余的币退还至来源交易txFrom的发起人。由于你创建的新交易txTo/wtxNew将会花费来自txFrom的币，你必须同时也是txFrom的创建者。换句话讲，当你在创建txFrom的时候，你其实是在花费之前别人发送给你的币。因此，&lt;你的公钥&gt;即是txFrom创建者的公钥，也是你自己的公钥。 我们在此停留片刻，来思考一下脚本A和脚本B。你有可能会问，这些脚本是从哪来的。中本聪在创造以太坊代币开发的时候为以太坊代币开发添加了一套脚本语言系统，所以以太坊代币开发中的交易都是由脚本代码完成的。该脚本系统其实也是后来智能合约的雏形。脚本A来自第29行，位于方法CSendDialog::OnButtonSend()，脚本B则来自第44行，位于方法CreateTransaction()。 当用户发起一笔交易时，以太坊代币开发客户端会调用CSendDialog::OnButtonSend()方法并将脚本A添加至txFrom中的一笔输出交易中。由于该输出交易的收款方为你本人，从而脚本中的&lt;收款人地址160位哈希&gt;，就是&lt;你的地址160位哈希&gt;。 如果txFrom是你本人创建的，则脚本B会被添加至CreateTransaction()中txFrom的某一笔输出交易。在这里，第44行位于CreateTransaction()中的公钥vchPubKey是你本人的公钥。 在了解了输入交易之后，我们来一起了解SignatureHash()是怎样工作的。 SignatureHash()首先将txTO拷贝至txTmp，接着清空txTmp.vin中每一笔输入交易的scriptSig，除了txTmp.vin[nIn]之外，该输入交易的scriptSig被设为scriptCode(第14、15行）。 接着，该函数检验nHashType的值。该函数的调用者将一个枚举值传递至该函数nHashType = SIGHASH_ALL。 &nbsp; enum { &nbsp; &nbsp; SIGHASH_ALL = 1, &nbsp; &nbsp; SIGHASH_NONE = 2, &nbsp; &nbsp; SIGHASH_SINGLE = 3, &nbsp; &nbsp; SIGHASH_ANYONECANPAY = 0x80, }; 由于nHashType = SIGHASH_ALL，所有的if-else条件均不成立，该函数将直接执行最后4行代码。 &nbsp; 在最后4行代码中，txTmp和nHashType变成序列化后的类型CDataStream对象。该类型包括一个装有数据的字符容器类型。所返回的哈希值是Hash()方法在计算序列化后的数据所得到的。 一笔交易可以包含多笔输入交易。SignatureHash()取其中一笔作为目标。它通过以下步骤生成哈希： 清空除了目标交易之外的所有输入交易。 复制来源交易中被目标交易作为输入交易引用的那笔输出交易的脚本至目标交易的输入交易列表中。 为修改后的交易生成哈希值。 Hash() 该方法位于util.h。以下是生成哈希值的方法Hash()的源码： &nbsp; template&lt;typename T1&gt; inline uint256 Hash(const T1 pbegin, const T1 pend) { &nbsp; &nbsp; uint256 hash1; &nbsp; &nbsp; SHA256((unsigned char*)&amp;pbegin[0], (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&amp;hash1); &nbsp; &nbsp; uint256 hash2; &nbsp; &nbsp; SHA256((unsigned char*)&amp;hash1, sizeof(hash1), (unsigned char*)&amp;hash2); &nbsp; &nbsp; return hash2; } 该函数对目标数据执行两次SHA256()方法并返回结果。SHA256()的声明可在openssl/sha.h中找到。 &nbsp; Solver() 该方法位于script.cpp。Solver()在SignSignature()中紧接着SignatureHash()被执行。它是真正用来为SignatureHash()返回的哈希值生成签名的函数。 &nbsp; bool Solver(const CScript&amp; scriptPubKey, uint256 hash, int nHashType, CScript&amp; scriptSigRet) { &nbsp; &nbsp; scriptSigRet.clear(); &nbsp; &nbsp; vector&lt;pair&lt;opcodetype, valtype&gt; &gt; vSolution; &nbsp; &nbsp; if (!Solver(scriptPubKey, vSolution)) &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; // Compile solution &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(opcodetype, valtype)&amp; item, vSolution) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (item.first == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const valtype&amp; vchPubKey = item.second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (item.first == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign and give pubkey &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint160, valtype&gt;::iterator mi = mapPubKeys.find(uint160(item.second)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi == mapPubKeys.end()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const vector&lt;unsigned char&gt;&amp; vchPubKey = (*mi).second; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig &lt;&lt; vchPubKey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; return true; } 以下是该方法所需要的4个参数： &nbsp; 位于第10行的调用函数SignSignature()将txOut.scriptPubKey，来源交易txFrom的输出脚本，作为输入值传入第一个参数scriptPubKey。记住它可能包含脚本A或者脚本B。 第二个参数hash是由SignatureHash()生成的哈希值。 第三个参数nHashType的值为SIGHASH_ALL。 第四个参数是该函数的返回值，即调用函数SignSIgnature()中位于第12行的txin.scriptSig。记住txin是新生成的交易wtxNew（在调用函数SignSignature()中作为txTo引用）位于第nIn的输入交易。因此，wtxNew第nIn笔输入交易的scriptSig将存放该函数返回的签名。 该函数首先会调用另一个有2个参数的Solver()。我们来研究一下。 带有2个参数的Solver() 该方法位于script.cpp。以下是带有2个参数的Solver()的源码： &nbsp; bool Solver(const CScript&amp; scriptPubKey, vector&lt;pair&lt;opcodetype, valtype&gt; &gt;&amp; vSolutionRet) { &nbsp; &nbsp; // Templates &nbsp; &nbsp; static vector&lt;CScript&gt; vTemplates; &nbsp; &nbsp; if (vTemplates.empty()) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; // Standard tx, sender provides pubkey, receiver adds signature &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; &nbsp; &nbsp; // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG); &nbsp; &nbsp; } &nbsp; &nbsp; // Scan templates &nbsp; &nbsp; const CScript&amp; script1 = scriptPubKey; &nbsp; &nbsp; foreach(const CScript&amp; script2, vTemplates) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; &nbsp; &nbsp; opcodetype opcode1, opcode2; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vch1, vch2; &nbsp; &nbsp; &nbsp; &nbsp; // Compare &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc1 = script1.begin(); &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc2 = script2.begin(); &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f1 = script1.GetOp(pc1, opcode1, vch1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f2 = script2.GetOp(pc2, opcode2, vch2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!f1 &amp;&amp; !f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Success &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse(vSolutionRet.begin(), vSolutionRet.end()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (f1 != f2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEY) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() &lt;= sizeof(uint256)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEYHASH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() != sizeof(uint160)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode1 != opcode2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; &nbsp; vSolutionRet.clear(); &nbsp; &nbsp; return false; } 第一个参数scriptPubKey可能包含脚本A也可能是脚本B。再一次说明，它是SignSignature()中来源交易txFrom的输出脚本。 &nbsp; 第二个参数用来存放输出交易。它是一个容器对，每个对由一个脚本运算符（opcodetype类型）和脚本操作元（valtype类型）构成。 该函数第8-10行首先定义两个模板： 模板A：OP_DUP OP_HASH160 OP_PUBKEYHASH OP_EQUALVERIFY OP_CHECKSIG。 模板B：OP_PUBKEY OP_CHECKSIG。 很明显，模板A、模板B与脚本A、脚本B相对应。为了便于对比，以下是脚本A和B的内容： 脚本A：OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。 该函数的作用是将scriptPubKey与两个模板相比较： 如果输入脚本为脚本A，则将模板A中的OP_PUBKEYHASH与脚本A中的&lt;你的地址160位哈希&gt;配对，并将该对放入vSolutionRet。 如果输入脚本为脚本B，则从模板B中提取运算符OP_PUBKEY，和从脚本B中提取运算元&lt;你的公钥&gt;，将二者配对并放入vSolutionRet。 如果输入脚本与两个模板均不匹配，则返回false。 回到Solver() 我们回到有4个参数的Solver()并继续对该函数的分析。现在我们清楚了该函数的工作原理。它会在两个分支中选择一个执行，取决于从vSolutionRet得到的对来自脚本A还是脚本B。如果来自脚本A，item.first &nbsp;== OP_PUBKEYHASH；如果来自脚本B，item.first &nbsp;== OP_PUBKEY。 item.first &nbsp;== OP_PUBKEY（脚本B）。在该情形下，item.second包含&lt;你的公钥&gt;。全局变量mapKeys将你的全部公钥映射至与之对应的私钥。如果mapKeys当中没有该公钥，则报错（第16行）。否则，用从mapKeys中提取出的私钥签署新生成的交易wtxNew的哈希值，其中哈希值作为第2个被传入的参数（CKey::Sign(mapKeys[vchPubKey], hash, vchSig)，第23行），再将结果放入vchSig，接着将其序列化成scriptSigRet（scriptSigRet &lt;&lt; vchSig，第24行）并返回。 item.first &nbsp;== OP_PUBKEYHASH（脚本A）。在该情形下，item.second包含&lt;你的地址160位哈希&gt;。该以太坊代币开发地址将被用于从位于第23行的全局映射mapPubKeys中找到其所对应的公钥。全局映射mapPubKeys将你的地址与生成它们的公钥建立一一对应关系（查看函数AddKey()）。接着，通过该公钥从mapKeys中找到所对应的私钥，并用该私钥签署第二个参数hash。签名和公钥将一同被序列化至scriptSigRet并返回（scriptSig &lt;&lt; vchSig &lt;&lt; vchPubkey，第24行）。 EvalScript() 该方法位于script.cpp。现在我们回到SignSignature()。在该函数的第12行之后，txin.scriptsig，即wtxNew的第nIn笔输入交易中的scriptSig部分，将插入一个签名。该签名可能是以下其中之一： vchSig vchPubKey（脚本A的签名A） vchSig（脚本B的签名B） 在下文当中，vchSig将被引用为&lt;你的签名_vchSig&gt;，vchPubKey则为&lt;你的公钥_vchPubKey&gt;，以强调它们分别是你本人的签名和公钥。 我们现在开始调查EvalScript()，该函数是SignSignature()调用的最后一个函数，位于第15行。EvalScript()带有3个参数，分别为： 第一个参数为txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey。它有可能是： 验证情形A：&lt;你的签名_vchSig&gt; &lt;你的公钥_vchPubKey&gt; OP_CODESEPARATOR OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG，即签名A + OP_CODESEPARATOR + 脚本A。 验证情形B：&lt;你的签名_vchSig&gt; OP_CODESEPARATOR &lt;你的公钥_vchPubKey&gt; OP_CHECKSIG，即签名B + OP_CODESEPARATOR + 脚本B。 第二个参数为新创建的交易txTo，即CreateTransaction()中的wtxNew。 第三个参数为nIn，即将被验证的交易在txTo输入交易列表中的位置。 验证过程我们会在后面详细讲述。简单地说，EvalScript()验证新创建交易wtxNew的第nIn笔输入交易是否包含有效的签名。至此，一笔新的以太坊代币开发交易便创建完成。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/11/20/ad7400e7f5a5fb2fc38c20d07f1ea220.html","headline":"以太坊ETH代币开发教程源码学习笔记","dateModified":"2017-11-20T00:00:00+08:00","datePublished":"2017-11-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/11/20/ad7400e7f5a5fb2fc38c20d07f1ea220.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊ETH代币开发教程源码学习笔记</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/jQQ53016353/article/details/78580207 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e4c7a3727d.css"> 
 <div class="htmledit_views"> 
  <p>前言</p> 
  <p><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353）</span><br></p> 
  <p><br></p> 从事区块链的开发，不了解其底层核心技术是不够的。许多人在看了以太坊代币开发白皮书之后仍然不清楚以太坊代币开发是怎样实现的，因为以太坊代币开发的源码设计精巧，有许多设计白皮书未曾提及，加上本身以太坊代币开发的文档稀少，加大了新手理解的困难程度。尽管现在已经有许多介绍区块链的书和文章，却很少是从源码着手分析的。我通过半年时间对于区块链的学习，开始撰写一份以太坊代币开发源码的教程。本教程深入浅出，通过分析最经典的区块链——以太坊代币开发的C++客户端源码，让开发者用最短的时间上手区块链技术。了解以太坊代币开发源码可帮助开发者更好了解区块链的工作原理并在应用当中根据实际情况做出修改和调整。
  <br>
  <br>
  <br> 本文所引用的源码均来自原始版以太坊代币开发客户端，即由中本聪发布的第一版源码。该客户端包括大约16000行代码。尽管经过数年的发展，以太坊代币开发客户端经过了几次较大更新，其数据结构和原理从诞生之日起一直延续至今。本文会尽可能保证文字的严谨准确，表达当中难免会产生疏漏，欢迎指正。
  <br>
  <br>
  <br> bitcoin-code
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> 第一章
  <br> &nbsp;
  <br>
  <br>
  <br> 本章节讲述以太坊代币开发客户端是怎样生成以太坊代币开发地址，并创建新的交易。
  <br>
  <br>
  <br> 我们来看一下GenerateNewKey()方法，该方法位于main.cpp。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool AddKey(const CKey&amp; key)
  <br> {
  <br> &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; mapKeys[key.GetPubKey()] = key.GetPrivKey();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());
  <br> }
  <br>
  <br>
  <br> vector&lt;unsigned char&gt; GenerateNewKey()
  <br> {
  <br> &nbsp; &nbsp; CKey key;
  <br> &nbsp; &nbsp; key.MakeNewKey();
  <br> &nbsp; &nbsp; if (!AddKey(key))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error("GenerateNewKey() : AddKey failed\n");
  <br> &nbsp; &nbsp; return key.GetPubKey();
  <br> }
  <br> 该方法通过以下步骤生成一个新的公钥对：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> 首先建立一个新的CKey类型对象（第13行）。
  <br> 调用addKey()方法将新建的key添加至1）全局映射mapKeys （第5行）2）全局map mapPubKeys（第6行）和钱包数据库wallet.dat（第8行）。
  <br> mapKeys建立公钥与私钥的一一对应关系。
  <br> mapPubKeys建立公钥的hash和公钥本身的对应关系。
  <br>
  <br>
  <br> 返回公钥（第16行）。
  <br> 该公钥为未压缩的格式，属于OpenSSL标准格式之一。在得到公钥之后，以太坊代币开发客户端会将该公钥传递至PubKeyToAddress()并调用Hash160ToAddress()方法生成地址。最后返回的Base58编码字符串值便是一个新生成的以太坊代币开发地址。Base58由1-9和除i，l，0，o之外的英文字符组成。
  <br>
  <br>
  <br> CTransaction类
  <br> CTransaction的定义位于main.h。在以太坊代币开发当中，所谓币的概念其实是一系列交易Tx的组合。这种方式虽然实现起来更为复杂，却提高了以太坊代币开发的安全性。用户可以为每一笔交易创建一个新的地址，地址在使用一次之后可以立即作废。因此，CTransaction是以太坊代币开发客户端最重要的类之一。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> class CTransaction
  <br> {
  <br> public:
  <br> &nbsp; &nbsp; int nVersion;
  <br> &nbsp; &nbsp; vector&lt;CTxIn&gt; vin;
  <br> &nbsp; &nbsp; vector&lt;CTxOut&gt; vout;
  <br> &nbsp; &nbsp; int nLockTime;
  <br> &nbsp; &nbsp; //......
  <br> }
  <br> &nbsp;
  <br>
  <br>
  <br> CTransaction包含两个容器类型：输入交易vin和输出交易vout。每个vin由若干CTxIn对象组成，每个vout则由CTxOut组成。
  <br>
  <br>
  <br> 每笔交易Tx的输入交易（CTxIn类）包含一个COutPoint对象prevout，该对象引用另外一笔交易Tx的输出交易作为来源交易。来源交易使当前交易Tx从另一笔交易当中得到可花费的以太坊代币开发。一笔交易Tx可以拥有任意笔输入交易。
  <br>
  <br>
  <br> 任何交易均由一个256位uint256哈希作为其唯一识别。若要引用某一笔来源交易TxSource当中某个特定的输出交易，我们需要两种信息：TxSource的哈希，和该输出交易在输出交易当中的位置n。这两种信息构成COutPoint类。一个COutPoint对象指向来源交易的某一笔输出交易TxSource.vout[n]。如果该笔输出交易被另外一笔交易Tx的位置i的输入交易所引用，例如Tx.vin[i].prevout，我们将其称为Tx的第i笔输入交易花费了TxSource中的第n笔输出交易。
  <br>
  <br>
  <br> uint256和uint160类
  <br> 这两种类型的定义位于uint.h。一个uint256类包含有一个256位的哈希。它由一个长度为256/32=8的unsigned int数组构成。一个相似的数据结构是uint160，该结构的定义可在同一个文件当中找到。既然SHA-256的长度为256bit，读者不难推断出uint160的作用是存放RIPEMD-160哈希。uint256和uint160均由base_uint类继承而来。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> class base_uint {
  <br> protected:
  <br> &nbsp; &nbsp; enum { WIDTH = BITS / 32 };
  <br> &nbsp; &nbsp; unsigned int pn[WIDTH];
  <br>
  <br>
  <br> public:
  <br> &nbsp; &nbsp; bool operator!() const
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; WIDTH; i++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pn[i] != 0)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return true;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; //......
  <br> &nbsp; &nbsp; unsigned int GetSerializeSize(int nType = 0, int nVersion = VERSION) const
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return sizeof(pn);
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; template &lt;typename Stream&gt;
  <br> &nbsp; &nbsp; void Serialize(Stream&amp; s, int nType = 0, int nVersion = VERSION) const
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; s.write((char*)pn, sizeof(pn));
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; template &lt;typename Stream&gt;
  <br> &nbsp; &nbsp; void Unserialize(Stream&amp; s, int nType = 0, int nVersion = VERSION)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; s.read((char*)pn, sizeof(pn));
  <br> &nbsp; &nbsp; }
  <br> }
  <br> 该类重载了若干运算符。此外该类拥有3个序列化成员函数，GetSerializeSize()、Serialize()和Unserialize()。我们会在后面讲到这三种方法是如何工作的。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> SendMoney()
  <br> 该方法位于main.cpp。以下是该方法的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew)
  <br> {
  <br> &nbsp; &nbsp; CRITICAL_BLOCK(cs_main)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; int64 nFeeRequired;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string strError;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue + nFeeRequired &gt; GetBalance())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf("Error: This is an oversized transaction that requires a transaction fee of %s ", FormatMoney(nFeeRequired).c_str());
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = "Error: Transaction creation failed ";
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox(strError, "Sending...");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error("SendMoney() : %s\n", strError.c_str());
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (!CommitTransactionSpent(wtxNew))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox("Error finalizing transaction", "Sending...");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error("SendMoney() : Error finalizing transaction");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; printf("SendMoney: %s\n", wtxNew.GetHash().ToString().substr(0,6).c_str());
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Broadcast
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (!wtxNew.AcceptTransaction())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // This must not fail. The transaction has already been signed and recorded.
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error("SendMoney() : wtxNew.AcceptTransaction() failed\n");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wxMessageBox("Error: Transaction not valid", "Sending...");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error("SendMoney() : Error: Transaction not valid");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.RelayWalletTransaction();
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; MainFrameRepaint();
  <br> &nbsp; &nbsp; return true;
  <br> }
  <br> &nbsp;
  <br>
  <br>
  <br> 当用户发送以太坊代币开发到某一个地址时，以太坊代币开发客户端会调用SendMoney()方法。该方法包含三个参数：
  <br>
  <br>
  <br> scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。
  <br> nValue表示将要转账的金额。该金额并未包含交易费nTrasactionFee。
  <br> wtxNew是一个CWalletTx类的本地变量。该变量目前的值为空，之后会包含若干CMerkleTX类对象。该类由CTransaction衍生而来，并且添加了若干方法。我们暂时先不管具体细节，仅将其看作CTransaction类。
  <br> 该方法的流程显而易见：
  <br>
  <br>
  <br> 首先建立一笔新的交易（CreateTransaction(scriptPubKey, nValue, wtxNet, nFeeRequired)，第6行）。
  <br> 尝试将这笔交易提交至数据库（CommitTransactionSpent(wtxNet)，第16行）。
  <br> 如果该笔交易提交成功（wtxNew.AcceptTransaction()，第23行），将其广播至其他peer节点（wtxNew.RelayWalletTransaction()，第30行）。
  <br> 这四个方法都与wtxNew相关。我们在本章介绍了第一个，其余三个将会在后续文章中介绍。
  <br>
  <br>
  <br> CreateTransaction()
  <br> 该方法位于main.cpp。以下是该方法的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew, int64&amp; nFeeRequiredRet)
  <br> {
  <br> &nbsp; &nbsp; nFeeRequiredRet = 0;
  <br> &nbsp; &nbsp; CRITICAL_BLOCK(cs_main)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // txdb must be opened before the mapWallet lock
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb("r");
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nFee = nTransactionFee;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.clear();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.clear();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValue &lt; 0)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = nValue;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValue += nFee;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose coins to use
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set&lt;CWalletTx*&gt; setCoins;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!SelectCoins(nValue, setCoins))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += pcoin-&gt;GetCredit();
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[0] to the payee
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey));
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] back to self with any change
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nValueIn &gt; nValue)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Use the same key as one of the coins
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txFirst = *(*setCoins.begin());
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, txFirst.vout)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vchPubKey.empty())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] to ourself
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; vchPubKey &lt;&lt; OP_CHECKSIG;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vin
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut));
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nIn = 0;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SignSignature(*pcoin, wtxNew, nIn++);
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Check that enough fee is included
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nFee &lt; wtxNew.GetMinFee(true))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFee = nFeeRequiredRet = wtxNew.GetMinFee(true);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Fill vtxPrev by copying from previous transactions vtxPrev
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.AddSupportingTransactions(txdb);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtxNew.fTimeReceivedIsTxTime = true;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; return true;
  <br> }
  <br> &nbsp;
  <br>
  <br>
  <br> 调用该方法时，它所需要的四个参数如下：
  <br>
  <br>
  <br> scriptPubKey包含脚本代码OP_DUP OP_HASH160 &lt;收款人地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。
  <br> nValue是将要转账的数额，交易费nTransactionFee并未包括在内。
  <br> wtxNew是一个新的Tx实例。
  <br> nFeeRequiredRet是一笔用来支付交易费的输出交易，在该方法执行完成之后获得。
  <br> 该方法的流程如下：
  <br>
  <br>
  <br> 定义一个本地变量nValueOut = nValue来保存将转账的金额（第17行）。将nValue与交易费nFee相加得到新的包含转账费的nValue。
  <br> 执行位于第21行的SelectCoins(nValue, setCoins)得到一系列币，并放入setCoins。setCoins包含支付给你本人地址的交易，即你所拥有的币。这些交易将成为wtxNew的来源交易。
  <br> 执行位于第27行的wtxNew.vout.push_back(CTxOut (nValueOut,sciptPubKey))并添加一笔输出交易至wtxNew。该笔输出将支付给&lt;收款人地址160位哈希&gt;（包含在scriptPubKey里面）数量为的币。
  <br> 如果需要找零（nValueIn &gt; nValue），添加另一笔输出交易至wtxNew并将零钱发回本人。该过程包含以下步骤：
  <br> 从setCoin当中获取第一笔交易txFirst，依次检查txFirst.vout中的交易是否属于本人。如果是则从该笔输出交易当中提取出公钥，并放入本地变量vchPubKey
  <br> 将vchPubKey放入脚本vchPubKey OP_CHECKSIG，并使用这段脚本代码为wtxNew添加一个支付给本人的输出交易（第45行）。
  <br> 因为setCoins包含支付给本人的交易，所以每笔交易一定包括至少一笔支付给本人的交易。从第一笔交易txFirst中即可找到。
  <br> 至此，wtxNew的输出交易容器vout已准备就绪。现在，该设置输入交易容器vin。记住每一个输入交易列表vin均引用一笔来源交易，而且wtxNew的每笔来源交易均可在setCoins中被找到。对于每一笔setCoins中的交易pcoin，逐个遍历其输出交易pcoin-&gt;vout[nOut]。如果第nOut笔输出支付给本人（意味着wtxNew从该笔输出交易中获得币），则向wtxNew添加一笔新的输入交易（wtxNew.vin(wtxNew.vin.push_back(CTxIn(pcoin-&gt;GetHash(), nOut))，第51行)。该输入交易指向pcoin中的第nOut笔输出交易，由此将wtxNew.vin与pcoin的第nOut笔输出相连接。
  <br> 对于setCoins当中的每笔交易pcoin，逐个遍历其所有输出交易pcoin-&gt;vout[nOut]。如果该笔交易属于本人，调用SignSignature(*pcoin,wtxNew, nIn++)为第nIn笔输入交易添加签名。注意nIn为wtxNew的输入交易位置。
  <br> 如果交易费nFee小于wtxNet.GetMinFee(true)，将nFee设为后者，清空wtxNew中的所有数据并重新开始整个过程。在位于第11行的第一次迭代当中，nFee是全局变量nTransactionFee = 0的本地复制。
  <br> 如果你不明白为什么要如此费力地重新添满wtxNew，源码中的GetMinFee()提供了答案：交易的最低费用与交易的数据大小有关。wtxNew的大小只有在完整构建之后才可得知。如果wtxNew.GetMinFee(true)计算得到的最小交易费用大于之前创造wtxNew时假设的交易费nFee，则除了重新构建wtxNew之外别无他法。
  <br> 这里遇到了一个先有鸡还是先有蛋的局面：若想创建一笔新的交易，则必须知道交易费用是多少。而交易费只有在整个交易被创建以后才可得知。为了打破这个循环，本地变量nFee被用来放置预计的交易费用，并且新的交易构建在此基础上。在构建完成之后，得到真实的交易费并与预估的交易费作比较。如果预估的交易费小于真实的交易费，则替换成真实交易费并重新构造整个交易。
  <br> 这里是GetMinFee()的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> int64 GetMinFee(bool fDiscount=false) const
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (fDiscount &amp;&amp; nBytes &lt; 10000)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return (1 + (int64)nBytes / 1000) * CENT;
  <br> &nbsp; &nbsp; }
  <br> &nbsp;
  <br>
  <br>
  <br> 如果计算得到的交易费比之前预计的交易费更高，则跳出第11行开始的循环并返回整个函数（第67行）。在此之前，需要进行以下两个步骤：
  <br> 执行wtxNew.AddSupportingTransactions(txdb)。这一部分以后会进行更详细介绍。
  <br> 设置wtxNet.fTimeReceivedIsTxTime=true（第66行）。
  <br> 现在来看一下如何通过SignSignature()签署新生成的交易wtxNew。
  <br>
  <br>
  <br> SignSignature()
  <br> 该方法位于script.cpp。以下是该方法的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool SignSignature(const CTransaction&amp; txFrom, CTransaction&amp; txTo, unsigned int nIn, int nHashType, CScript scriptPrereq)
  <br> {
  <br> &nbsp; &nbsp; assert(nIn &lt; txTo.vin.size());
  <br> &nbsp; &nbsp; CTxIn&amp; txin = txTo.vin[nIn];
  <br> &nbsp; &nbsp; assert(txin.prevout.n &lt; txFrom.vout.size());
  <br> &nbsp; &nbsp; const CTxOut&amp; txout = txFrom.vout[txin.prevout.n];
  <br>
  <br>
  <br> &nbsp; &nbsp; // Leave out the signature from the hash, since a signature can't sign itself.
  <br> &nbsp; &nbsp; // The checksig op will also drop the signatures from its hash.
  <br> &nbsp; &nbsp; uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType);
  <br>
  <br>
  <br> &nbsp; &nbsp; if (!Solver(txout.scriptPubKey, hash, nHashType, txin.scriptSig))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br>
  <br>
  <br> &nbsp; &nbsp; txin.scriptSig = scriptPrereq + txin.scriptSig;
  <br>
  <br>
  <br> &nbsp; &nbsp; // Test solution
  <br> &nbsp; &nbsp; if (scriptPrereq.empty())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (!EvalScript(txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey, txTo, nIn))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br>
  <br>
  <br> &nbsp; &nbsp; return true;
  <br> }
  <br> &nbsp;
  <br>
  <br>
  <br> 首先需要注意的是，该函数有5个参数，而CreateTransaction()只有3个。这是因为在script.h文件里，后两个参数已默认给出。
  <br>
  <br>
  <br> 以下是传递给CreateTransaction()中的3个参数：
  <br>
  <br>
  <br> txFrom是一个*pcoin对象。它是CreateTransaction()里setCoins中的所有币中的某一个。它同时也是一笔来源交易。它的若干输出交易当中包含了新交易将要花费的币。
  <br> txTo是CreateTransaction()里的wtxNew对象。它是将要花费来源交易txFrom的新交易。新交易需要被签署方可生效。
  <br> nIn是指向txTo中输入交易列表的索引位置。该输入交易列表包含一个对txFrom的输出交易列表的引用。更准确地讲，txin=txTo.vin[nIn]（第4行）是txTo中的输入交易；txout=txFrom.vout[txin.prev.out.n]（第6行）是txin所指向的txFrom中的输出交易。
  <br> 以下是SignSignature()所做的工作：
  <br>
  <br>
  <br> 调用SignatureHash()方法生成txTo的哈希值。
  <br> 调用Solver()函数签署刚才生成的哈希。
  <br> 调用EvalScript()来运行一小段脚本并检查签名是否合法。
  <br> 我们一起看一下这三个函数。
  <br>
  <br>
  <br> SignatureHash()
  <br> 该方法位于script.cpp。以下是SignatureHash()的源码。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> uint256 SignatureHash(CScript scriptCode, const CTransaction&amp; txTo, unsigned int nIn, int nHashType)
  <br> {
  <br> &nbsp; &nbsp; if (nIn &gt;= txTo.vin.size())
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; printf("ERROR: SignatureHash() : nIn=%d out of range\n", nIn);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return 1;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; CTransaction txTmp(txTo);
  <br>
  <br>
  <br> &nbsp; &nbsp; // In case concatenating two scripts ends up with two codeseparators,
  <br> &nbsp; &nbsp; // or an extra one at the end, this prevents all those possible incompatibilities.
  <br> &nbsp; &nbsp; scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));
  <br>
  <br>
  <br> &nbsp; &nbsp; // Blank out other inputs' signatures
  <br> &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].scriptSig = CScript();
  <br> &nbsp; &nbsp; txTmp.vin[nIn].scriptSig = scriptCode;
  <br>
  <br>
  <br> &nbsp; &nbsp; // Blank out some of the outputs
  <br> &nbsp; &nbsp; if ((nHashType &amp; 0x1f) == SIGHASH_NONE)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Wildcard payee
  <br> &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.clear();
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will
  <br> &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; else if ((nHashType &amp; 0x1f) == SIGHASH_SINGLE)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Only lockin the txout payee at same index as txin
  <br> &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nOut = nIn;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; if (nOut &gt;= txTmp.vout.size())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("ERROR: SignatureHash() : nOut=%d out of range\n", nOut);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout.resize(nOut+1);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nOut; i++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vout[i].SetNull();
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Let the others update at will
  <br> &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; txTmp.vin.size(); i++)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i != nIn)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[i].nSequence = 0;
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; // Blank out other inputs completely, not recommended for open transactions
  <br> &nbsp; &nbsp; if (nHashType &amp; SIGHASH_ANYONECANPAY)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin[0] = txTmp.vin[nIn];
  <br> &nbsp; &nbsp; &nbsp; &nbsp; txTmp.vin.resize(1);
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; // Serialize and hash
  <br> &nbsp; &nbsp; CDataStream ss(SER_GETHASH);
  <br> &nbsp; &nbsp; ss.reserve(10000);
  <br> &nbsp; &nbsp; ss &lt;&lt; txTmp &lt;&lt; nHashType;
  <br> &nbsp; &nbsp; return Hash(ss.begin(), ss.end());
  <br> }
  <br> 以下是该函数所需要的参数：
  <br> &nbsp;
  <br>
  <br>
  <br> txTo是将要被签署的交易。它同时也是CreateTransaction()中的wtxNew对象。它的输入交易列表中的第nIn项，txTo.vin[nIn]，是该函数将要起作用的目标。
  <br> scriptCode是scriptPrereq + txout.scriptPubKey，其中txout是SignSignature()中定义的来源交易txFrom()的输出交易。由于此时scriptPrereq为空，scriptCode事实上是来源交易txFrom中的输出交易列表当中被txTo作为输入交易引用的那笔的脚本代码。txout.scriptPubKey有可能包含两类脚本：
  <br> 脚本A：OP_DUP OP_HASH160 &lt;你地址的160位哈希&gt; OP_EQUALVERIFY OP_CECKSIG。该脚本将来源交易txFrom中的币发送给你，其中&lt;你地址的160位哈希&gt;是你的以太坊代币开发地址。
  <br> 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。该脚本将剩余的币退还至来源交易txFrom的发起人。由于你创建的新交易txTo/wtxNew将会花费来自txFrom的币，你必须同时也是txFrom的创建者。换句话讲，当你在创建txFrom的时候，你其实是在花费之前别人发送给你的币。因此，&lt;你的公钥&gt;即是txFrom创建者的公钥，也是你自己的公钥。
  <br> 我们在此停留片刻，来思考一下脚本A和脚本B。你有可能会问，这些脚本是从哪来的。中本聪在创造以太坊代币开发的时候为以太坊代币开发添加了一套脚本语言系统，所以以太坊代币开发中的交易都是由脚本代码完成的。该脚本系统其实也是后来智能合约的雏形。脚本A来自第29行，位于方法CSendDialog::OnButtonSend()，脚本B则来自第44行，位于方法CreateTransaction()。
  <br>
  <br>
  <br> 当用户发起一笔交易时，以太坊代币开发客户端会调用CSendDialog::OnButtonSend()方法并将脚本A添加至txFrom中的一笔输出交易中。由于该输出交易的收款方为你本人，从而脚本中的&lt;收款人地址160位哈希&gt;，就是&lt;你的地址160位哈希&gt;。
  <br> 如果txFrom是你本人创建的，则脚本B会被添加至CreateTransaction()中txFrom的某一笔输出交易。在这里，第44行位于CreateTransaction()中的公钥vchPubKey是你本人的公钥。
  <br> 在了解了输入交易之后，我们来一起了解SignatureHash()是怎样工作的。
  <br>
  <br>
  <br> SignatureHash()首先将txTO拷贝至txTmp，接着清空txTmp.vin中每一笔输入交易的scriptSig，除了txTmp.vin[nIn]之外，该输入交易的scriptSig被设为scriptCode(第14、15行）。
  <br>
  <br>
  <br> 接着，该函数检验nHashType的值。该函数的调用者将一个枚举值传递至该函数nHashType = SIGHASH_ALL。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> enum
  <br> {
  <br> &nbsp; &nbsp; SIGHASH_ALL = 1,
  <br> &nbsp; &nbsp; SIGHASH_NONE = 2,
  <br> &nbsp; &nbsp; SIGHASH_SINGLE = 3,
  <br> &nbsp; &nbsp; SIGHASH_ANYONECANPAY = 0x80,
  <br> };
  <br> 由于nHashType = SIGHASH_ALL，所有的if-else条件均不成立，该函数将直接执行最后4行代码。
  <br> &nbsp;
  <br>
  <br>
  <br> 在最后4行代码中，txTmp和nHashType变成序列化后的类型CDataStream对象。该类型包括一个装有数据的字符容器类型。所返回的哈希值是Hash()方法在计算序列化后的数据所得到的。
  <br>
  <br>
  <br> 一笔交易可以包含多笔输入交易。SignatureHash()取其中一笔作为目标。它通过以下步骤生成哈希：
  <br>
  <br>
  <br> 清空除了目标交易之外的所有输入交易。
  <br> 复制来源交易中被目标交易作为输入交易引用的那笔输出交易的脚本至目标交易的输入交易列表中。
  <br> 为修改后的交易生成哈希值。
  <br> Hash()
  <br> 该方法位于util.h。以下是生成哈希值的方法Hash()的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> template&lt;typename T1&gt;
  <br> inline uint256 Hash(const T1 pbegin, const T1 pend)
  <br> {
  <br> &nbsp; &nbsp; uint256 hash1;
  <br> &nbsp; &nbsp; SHA256((unsigned char*)&amp;pbegin[0], (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&amp;hash1);
  <br> &nbsp; &nbsp; uint256 hash2;
  <br> &nbsp; &nbsp; SHA256((unsigned char*)&amp;hash1, sizeof(hash1), (unsigned char*)&amp;hash2);
  <br> &nbsp; &nbsp; return hash2;
  <br> }
  <br> 该函数对目标数据执行两次SHA256()方法并返回结果。SHA256()的声明可在openssl/sha.h中找到。
  <br> &nbsp;
  <br>
  <br>
  <br> Solver()
  <br> 该方法位于script.cpp。Solver()在SignSignature()中紧接着SignatureHash()被执行。它是真正用来为SignatureHash()返回的哈希值生成签名的函数。
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool Solver(const CScript&amp; scriptPubKey, uint256 hash, int nHashType, CScript&amp; scriptSigRet)
  <br> {
  <br> &nbsp; &nbsp; scriptSigRet.clear();
  <br>
  <br>
  <br> &nbsp; &nbsp; vector&lt;pair&lt;opcodetype, valtype&gt; &gt; vSolution;
  <br> &nbsp; &nbsp; if (!Solver(scriptPubKey, vSolution))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br>
  <br>
  <br> &nbsp; &nbsp; // Compile solution
  <br> &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(opcodetype, valtype)&amp; item, vSolution)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (item.first == OP_PUBKEY)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const valtype&amp; vchPubKey = item.second;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (item.first == OP_PUBKEYHASH)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sign and give pubkey
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint160, valtype&gt;::iterator mi = mapPubKeys.find(uint160(item.second));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi == mapPubKeys.end())
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const vector&lt;unsigned char&gt;&amp; vchPubKey = (*mi).second;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!mapKeys.count(vchPubKey))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash != 0)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchSig;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vchSig.push_back((unsigned char)nHashType);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scriptSigRet &lt;&lt; vchSig &lt;&lt; vchPubKey;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; return true;
  <br> }
  <br> 以下是该方法所需要的4个参数：
  <br> &nbsp;
  <br>
  <br>
  <br> 位于第10行的调用函数SignSignature()将txOut.scriptPubKey，来源交易txFrom的输出脚本，作为输入值传入第一个参数scriptPubKey。记住它可能包含脚本A或者脚本B。
  <br> 第二个参数hash是由SignatureHash()生成的哈希值。
  <br> 第三个参数nHashType的值为SIGHASH_ALL。
  <br> 第四个参数是该函数的返回值，即调用函数SignSIgnature()中位于第12行的txin.scriptSig。记住txin是新生成的交易wtxNew（在调用函数SignSignature()中作为txTo引用）位于第nIn的输入交易。因此，wtxNew第nIn笔输入交易的scriptSig将存放该函数返回的签名。
  <br> 该函数首先会调用另一个有2个参数的Solver()。我们来研究一下。
  <br>
  <br>
  <br> 带有2个参数的Solver()
  <br> 该方法位于script.cpp。以下是带有2个参数的Solver()的源码：
  <br>
  <br>
  <br> &nbsp;
  <br>
  <br>
  <br> bool Solver(const CScript&amp; scriptPubKey, vector&lt;pair&lt;opcodetype, valtype&gt; &gt;&amp; vSolutionRet)
  <br> {
  <br> &nbsp; &nbsp; // Templates
  <br> &nbsp; &nbsp; static vector&lt;CScript&gt; vTemplates;
  <br> &nbsp; &nbsp; if (vTemplates.empty())
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Standard tx, sender provides pubkey, receiver adds signature
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG);
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vTemplates.push_back(CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG);
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; // Scan templates
  <br> &nbsp; &nbsp; const CScript&amp; script1 = scriptPubKey;
  <br> &nbsp; &nbsp; foreach(const CScript&amp; script2, vTemplates)
  <br> &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.clear();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; opcodetype opcode1, opcode2;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vch1, vch2;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; // Compare
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc1 = script1.begin();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CScript::const_iterator pc2 = script2.begin();
  <br> &nbsp; &nbsp; &nbsp; &nbsp; loop
  <br> &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f1 = script1.GetOp(pc1, opcode1, vch1);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool f2 = script2.GetOp(pc2, opcode2, vch2);
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!f1 &amp;&amp; !f2)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Success
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse(vSolutionRet.begin(), vSolutionRet.end());
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (f1 != f2)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEY)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() &lt;= sizeof(uint256))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode2 == OP_PUBKEYHASH)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vch1.size() != sizeof(uint160))
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSolutionRet.push_back(make_pair(opcode2, vch1));
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (opcode1 != opcode2)
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; }
  <br>
  <br>
  <br> &nbsp; &nbsp; vSolutionRet.clear();
  <br> &nbsp; &nbsp; return false;
  <br> }
  <br> 第一个参数scriptPubKey可能包含脚本A也可能是脚本B。再一次说明，它是SignSignature()中来源交易txFrom的输出脚本。
  <br> &nbsp;
  <br>
  <br>
  <br> 第二个参数用来存放输出交易。它是一个容器对，每个对由一个脚本运算符（opcodetype类型）和脚本操作元（valtype类型）构成。
  <br>
  <br>
  <br> 该函数第8-10行首先定义两个模板：
  <br>
  <br>
  <br> 模板A：OP_DUP OP_HASH160 OP_PUBKEYHASH OP_EQUALVERIFY OP_CHECKSIG。
  <br> 模板B：OP_PUBKEY OP_CHECKSIG。
  <br> 很明显，模板A、模板B与脚本A、脚本B相对应。为了便于对比，以下是脚本A和B的内容：
  <br>
  <br>
  <br> 脚本A：OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG。
  <br> 脚本B：&lt;你的公钥&gt; OP_CHECKSIG。
  <br> 该函数的作用是将scriptPubKey与两个模板相比较：
  <br>
  <br>
  <br> 如果输入脚本为脚本A，则将模板A中的OP_PUBKEYHASH与脚本A中的&lt;你的地址160位哈希&gt;配对，并将该对放入vSolutionRet。
  <br> 如果输入脚本为脚本B，则从模板B中提取运算符OP_PUBKEY，和从脚本B中提取运算元&lt;你的公钥&gt;，将二者配对并放入vSolutionRet。
  <br> 如果输入脚本与两个模板均不匹配，则返回false。
  <br> 回到Solver()
  <br> 我们回到有4个参数的Solver()并继续对该函数的分析。现在我们清楚了该函数的工作原理。它会在两个分支中选择一个执行，取决于从vSolutionRet得到的对来自脚本A还是脚本B。如果来自脚本A，item.first &nbsp;== OP_PUBKEYHASH；如果来自脚本B，item.first &nbsp;== OP_PUBKEY。
  <br>
  <br>
  <br> item.first &nbsp;== OP_PUBKEY（脚本B）。在该情形下，item.second包含&lt;你的公钥&gt;。全局变量mapKeys将你的全部公钥映射至与之对应的私钥。如果mapKeys当中没有该公钥，则报错（第16行）。否则，用从mapKeys中提取出的私钥签署新生成的交易wtxNew的哈希值，其中哈希值作为第2个被传入的参数（CKey::Sign(mapKeys[vchPubKey], hash, vchSig)，第23行），再将结果放入vchSig，接着将其序列化成scriptSigRet（scriptSigRet &lt;&lt; vchSig，第24行）并返回。
  <br> item.first &nbsp;== OP_PUBKEYHASH（脚本A）。在该情形下，item.second包含&lt;你的地址160位哈希&gt;。该以太坊代币开发地址将被用于从位于第23行的全局映射mapPubKeys中找到其所对应的公钥。全局映射mapPubKeys将你的地址与生成它们的公钥建立一一对应关系（查看函数AddKey()）。接着，通过该公钥从mapKeys中找到所对应的私钥，并用该私钥签署第二个参数hash。签名和公钥将一同被序列化至scriptSigRet并返回（scriptSig &lt;&lt; vchSig &lt;&lt; vchPubkey，第24行）。
  <br> EvalScript()
  <br> 该方法位于script.cpp。现在我们回到SignSignature()。在该函数的第12行之后，txin.scriptsig，即wtxNew的第nIn笔输入交易中的scriptSig部分，将插入一个签名。该签名可能是以下其中之一：
  <br>
  <br>
  <br> vchSig vchPubKey（脚本A的签名A）
  <br> vchSig（脚本B的签名B）
  <br> 在下文当中，vchSig将被引用为&lt;你的签名_vchSig&gt;，vchPubKey则为&lt;你的公钥_vchPubKey&gt;，以强调它们分别是你本人的签名和公钥。
  <br>
  <br>
  <br> 我们现在开始调查EvalScript()，该函数是SignSignature()调用的最后一个函数，位于第15行。EvalScript()带有3个参数，分别为：
  <br>
  <br>
  <br> 第一个参数为txin.scriptSig + CScript(OP_CODESEPARATOR) + txout.scriptPubKey。它有可能是：
  <br> 验证情形A：&lt;你的签名_vchSig&gt; &lt;你的公钥_vchPubKey&gt; OP_CODESEPARATOR OP_DUP OP_HASH160 &lt;你的地址160位哈希&gt; OP_EQUALVERIFY OP_CHECKSIG，即签名A + OP_CODESEPARATOR + 脚本A。
  <br> 验证情形B：&lt;你的签名_vchSig&gt; OP_CODESEPARATOR &lt;你的公钥_vchPubKey&gt; OP_CHECKSIG，即签名B + OP_CODESEPARATOR + 脚本B。
  <br> 第二个参数为新创建的交易txTo，即CreateTransaction()中的wtxNew。
  <br> 第三个参数为nIn，即将被验证的交易在txTo输入交易列表中的位置。
  <br> 验证过程我们会在后面详细讲述。简单地说，EvalScript()验证新创建交易wtxNew的第nIn笔输入交易是否包含有效的签名。至此，一笔新的以太坊代币开发交易便创建完成。 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78580207,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78580207,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
