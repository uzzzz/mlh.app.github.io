<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>动手编写一个以太坊智能合约-区块链大本营(让区块链回归技术和应用的本质，欢迎投稿：heyc@csdn.net。) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="动手编写一个以太坊智能合约-区块链大本营(让区块链回归技术和应用的本质，欢迎投稿：heyc@csdn.net。)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Blockchain_lemon/article/details/77983873 本文节选自图书《区块链开发指南》，本书由 申屠青春 主编，宋波、张鹏、汪晓明、季宙栋、左川民 联合编著。 区块链相关约稿、文章纠错、寻求报道等可邮件联系 jiawd@csdn.net 如何部署、调用智能合约 RPC 之前的章节中讲到了怎么写、部署合约以及与合约互动。现在该讲讲与以太坊网络和智能合约沟通的细节了。 一个以太坊节点提供一个RPC界面。这个界面给Ðapp（去中心化应用）访问以太坊区块链的权限和节点提供的功能，比如编译智能合约代码，它用JSON-RPC 2.0规范(不支持提醒和命名的参数) 的子集作为序列化协议，在HTTP和IPC (linux/OSX上的unix域接口，在Windows上叫pipe’s)上可用。 惯例 RPC界面会使用一些惯例，但它们不是JSON-RPC 2.0规范的一部分，这些惯例如下： 数字是十六进制编码。做这个决定是因为有些语言对运行极大的数字没有或有很少的限制。为了防止这些错误数字类型是十六进制编码，由开发者来分析这些数字并正确处理它们。在维基页百科查看十六进制编码章节查看案例。 默认区块数字。几个RPC 方法接受区块数字。在一些情况下，给出区块数字是不可能的或者不太方便。在那样的情况下，默认区块数字可以是以下字符串中的一个[”earliest”, “latest”, “pending”]。在维基页面可查看使用默认区块参数的RPC方法列表。 部署合约 我们会通过不同的步骤来部署下面的合约，但只用到RPC界面。 contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } } 要做的第一件事是确保HTTP RPC界面可用。这意味着我们在开始为geth供应—rpc标志，为eth提供-j标志。在这个例子中，用的是私有开发链上的geth节点。通过这种方法，我们就不需要真实网络上的以太币了。 \&gt; geth --rpc --dev --mine --minerthreads 1 --unlock 0 console 2&gt;&gt;geth.log 这会在http://localhost:8545上启动HTTP RPC界面。 注意：geth支持CORS查看—rpccorsdomain标志了解更多。 我们可以通过用curl检索coinbase地址和余额来证明界面正在运行。请注意这些例子中的数据在你本地的节点上会有所不同。如果你想要试试这些参数，视情况替换需要的参数。 \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_coinbase&quot;, &quot;id&quot;:1}&#39; localhost:8545 {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;]} &gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBalance&quot;, &quot;params&quot;: [&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;], &quot;id&quot;:2}&#39; localhost:8545 {&quot;id&quot;:2,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x1639e49bba16280000&quot;} 记不记得前面说过数字是十六进制编码？在这个情况下，余额作为十六进制字符串以Wei的形式返还。如果希望余额作为数字以太币为单位，可以从控制台用web3，示例如下： \&gt; web3.fromWei(&quot;0x1639e49bba16280000&quot;, &quot;ether&quot;) &quot;410&quot; 现在我们在私有开发链上有一些以太币，就可以部署合约了。第一步是验证solidity编译器可用，可以用eth_getCompilers RPC method方法来检索可用的编译器，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getCompilers&quot;, &quot;id&quot;: 3}&#39; localhost:8545 {&quot;id&quot;:3,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;Solidity&quot;]} 我们可以看到solidity编译器可用。 下一步是把Multiply7合约编译到可以发送给以太坊虚拟机的字节代码中，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_compileSolidity&quot;, &quot;params&quot;: [&quot;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input {&quot;id&quot;:4,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;Multiply7&quot;:{&quot;code&quot;:&quot;0x6060604052605f8060106000396000f360606040 现在我们有了编译代码，需要决定花多少gas去部署它。RPC界面有eth_estimateGas方法，会给我们一个预估数量，如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_estimateGas&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 5}&#39; localhost:8545 {&quot;id&quot;:5,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0xb8a9&quot;} 最后部署合约。 \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;gas&quot;: &quot;0xb8a9&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 6}&#39; localhost:8545 {&quot;id&quot;:6,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08 交易由节点接受，交易散表被返还。我们可以用这个散表来跟踪交易。 下一步是决定部署合约的地址。每个执行的交易都会创建一个接收。这个接收包含交易的各种信息，比如交易被包含在哪个区块，以太坊虚拟机用掉多少gas。如果交易创建了一个合约，它也会包含合约地址。我们可以用eth_getTransactionReceipt RPC方法检索接收，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getTransactionReceipt&quot;, &quot;params&quot;: [&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08a7c&quot;], &quot;id&quot;: 7}&#39; localhost:8545 {&quot;id&quot;:7,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;transactionHash&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c682 可以看到，合约在0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d上被创建。如果你得到了零而不是接收，说明还没有被纳入区块。这时，要检查看看你的矿工是否在运行，然后重新试一遍。 和智能合约互动 现在已经部署了合约，我们可以和它互动了。有两种方法进行互动，即发送交易或调用。在本节的例子中，将会发送交易到合约的multiply方法里。 在我们的实例中，需要具体说明from、to 和data参数。From是我们账户的公共地址，to是合约地址，Data参数有一点复杂，它包括了规定调用哪个方法和哪个参数的负载量。这就需要ABI发挥作用了，ABI规定了如何为以太坊虚拟机规定和编码数据。 负载量的字节是功能选择符，规定了调用哪个方法。它取Keccak散表的头4个字节，涵盖功能名称参数类型，并进行十六进制编码。multiply功能接受一个参数。示例如下： \&gt; web3.sha3(&quot;multiply(uint256)&quot;).substring(0, 8) &quot;c6888fa1&quot; 下一步是编码参数。我们只有一个unit256，假定提供了值6。ABI有一个章节规定了编码uint字节的方法，如下： int&lt;M&gt;: enc(X) is the big-endian two’s complement encoding of X, padded on the higher-oder (left) side with 0xff for negative X and with zero 字节s for positive X such that the length is a multiple of 32 bytes. 它会编码到 0000000000000000000000000000000000000000000000000000000000000006。 将功能选择符和编码参数结合起来，数据就会变成0xc6888fa10000000000000000000000000000000000000000000000000000000000000006。 我们来试一下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;to&quot;: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, &quot;data&quot;: &quot;0xc6888fa10000000000000000000000000000000000000000000000000000000000000006&quot;}], &quot;id&quot;: 8}&#39; localhost:8545 {&quot;id&quot;:8,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869 由于我们发送了交易，于是有交易散表返回。如果检索接收，可以看到一些新内容，如下： { blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, contractAddress: null, cumulativeGasUsed: 22631, gasUsed: 22631, logs: [{ address: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, data: &quot;0x000000000000000000000000000000000000000000000000000000000000002a&quot;, logIndex: 0, topics: [&quot;0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot;], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 }], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 } 接收包含一个日志。日志由以太坊虚拟机在交易执行时生成，包含接收。如果我们看Multiply功能，可以看到打印事件和输入次数7一起被提出。由于打印事件的参数是uint256，因此可以根据ABI规则对它进行编码，这样就会得到预期的十进制42。 \&gt; web3.sha3(&quot;Print(uint256)&quot;) &quot;24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot; 这只是对一些最常见任务的简单介绍。在RPC维基页面查看可用RPC方法的完整列表。 Web3.js 正如在之前的案例所见，使用JSON-RPC界面相当单调乏味且容易出错，尤其是在处理ABI的时候。Web3.js是Javascript库，它的目标是提供更友好的界面，减少出错机会。 用web3部署Multiply7合约看起来是这样： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var code = compiled.Multiply7.code; var abi = compiled.Multiply7.info.abiDefinition; web3.eth.contract(abi).new({from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, data: code}, function (err, contract) { if (!err &amp;&amp; contract.address) console.log(&quot;deployed on:&quot;, contract.address); } ); deployed on: 0x0ab60714033847ad7f0677cc7514db48313976e2 装载一个部署的合约，发送交易： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition); var multi = Multiply7.at(&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;) multi.multiply.sendTransaction(6, {from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;}) 注册一个回调，打印事件创建日志的时候会被调用。 multi.Print(function(err, data) { console.log(JSON.stringify(data)) }) {&quot;address&quot;:&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;,&quot;args&quot;: {&quot;&quot;:&quot;21&quot;},&quot;blockHash&quot;:&quot;0x259c7dc0 在web3.js维基页面可查看更多信息。 控制台 geth控制台提供命令行界面和Javascript执行时间。它可以连接到本地或远程的geth或eth节点。它会装载用户能使用的web3.js库，从而方便用户从控制台通过web3.js部署智能合约，并和智能合约互动。实际上Web3.js章节的例子可以被复制进控制台并且调用。 查看合约与交易 有几个可用的在线区块链浏览器，能让你查询以太坊区块链，它们分别是： EtherChain EtherCamp EtherScan 其他可查看节点或交易的资源 EtherNodes ：节点的地理分配，由客户端区分。 EtherListen：实时以太坊交易可视器和可听器。 智能合约案例实战 以太坊是区块链开发领域最好的编程平台，而truffle是以太坊（Ethereum）最受欢迎的一个开发框架，这也是介绍truffle的原因。实战是最重要的事情，这篇文章不讲原理，只搭建环境，运行第一个区块链程序（Dapp）。 1. 安装truffle 安装truffle的命令如下： $ npm install -g truffle 2. 依赖环境 可用的系统包括：Windows、Linux和Mac OS X，推荐Mac OS X，不建议使用Windows，会碰到各种各样的问题，很可能导致放弃。首先，访问https://nodejs.org 官方网站下载安装NodeJS。 此外，需要安装Ethereum客户端，来支持JSON RPC API调用。 至于开发环境，推荐使用EthereumJS TestRPC，地址为： https://github.com/ethereumjs/testrpc。 安装命令如下： $ npm install -g ethereumjs-testrpc 3. 新建第一个项目 通过以下命令新建一个项目： $ mkdir zhaoxi $ cd zhaoxi $ truffle init 默认会生成一个MetaCoin的demo，可以从这个demo中学习truffle的架构。 项目的目录结构如图5-3所示。 图5-3 项目的目录结构 项目所有文件的目录如图5-4所示。 图5-4 项目文件目录目录结构 现在，通过以下命令编译项目。 $ truffle compile 图5-5是运行以上命令后的结果。 图5-5 Truffle compile执行结果图 下面介绍部署项目的方式。 部署之前先启动TestRPC，命令如下： $ testrpc $ truffle deploy（在Truffle 2.0以上版本中，命令变成了：truffle migrate） 图5-6是运行truffle deploy后的结果。 图5-6 truffle deploy执行结果图 $ truffle migrate migrate的执行结果见图5-7。 图5-7 truffle migrate migrate执行结果图 现在，可以启动服务了，命令如下： $ truffle serve 图5-8是truffle serve执行结果图 图5-8 truffle serve执行结果图 启动服务后，可以在浏览器访问项目了，地址是：http://localhost:8080/ ，网页界面如图5-9所示。 图5-9智能合约运行界面 好了，第一个区块链程序跑起来了，后面可以不断地实践深入学习了。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Blockchain_lemon/article/details/77983873 本文节选自图书《区块链开发指南》，本书由 申屠青春 主编，宋波、张鹏、汪晓明、季宙栋、左川民 联合编著。 区块链相关约稿、文章纠错、寻求报道等可邮件联系 jiawd@csdn.net 如何部署、调用智能合约 RPC 之前的章节中讲到了怎么写、部署合约以及与合约互动。现在该讲讲与以太坊网络和智能合约沟通的细节了。 一个以太坊节点提供一个RPC界面。这个界面给Ðapp（去中心化应用）访问以太坊区块链的权限和节点提供的功能，比如编译智能合约代码，它用JSON-RPC 2.0规范(不支持提醒和命名的参数) 的子集作为序列化协议，在HTTP和IPC (linux/OSX上的unix域接口，在Windows上叫pipe’s)上可用。 惯例 RPC界面会使用一些惯例，但它们不是JSON-RPC 2.0规范的一部分，这些惯例如下： 数字是十六进制编码。做这个决定是因为有些语言对运行极大的数字没有或有很少的限制。为了防止这些错误数字类型是十六进制编码，由开发者来分析这些数字并正确处理它们。在维基页百科查看十六进制编码章节查看案例。 默认区块数字。几个RPC 方法接受区块数字。在一些情况下，给出区块数字是不可能的或者不太方便。在那样的情况下，默认区块数字可以是以下字符串中的一个[”earliest”, “latest”, “pending”]。在维基页面可查看使用默认区块参数的RPC方法列表。 部署合约 我们会通过不同的步骤来部署下面的合约，但只用到RPC界面。 contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } } 要做的第一件事是确保HTTP RPC界面可用。这意味着我们在开始为geth供应—rpc标志，为eth提供-j标志。在这个例子中，用的是私有开发链上的geth节点。通过这种方法，我们就不需要真实网络上的以太币了。 \&gt; geth --rpc --dev --mine --minerthreads 1 --unlock 0 console 2&gt;&gt;geth.log 这会在http://localhost:8545上启动HTTP RPC界面。 注意：geth支持CORS查看—rpccorsdomain标志了解更多。 我们可以通过用curl检索coinbase地址和余额来证明界面正在运行。请注意这些例子中的数据在你本地的节点上会有所不同。如果你想要试试这些参数，视情况替换需要的参数。 \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_coinbase&quot;, &quot;id&quot;:1}&#39; localhost:8545 {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;]} &gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBalance&quot;, &quot;params&quot;: [&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;], &quot;id&quot;:2}&#39; localhost:8545 {&quot;id&quot;:2,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x1639e49bba16280000&quot;} 记不记得前面说过数字是十六进制编码？在这个情况下，余额作为十六进制字符串以Wei的形式返还。如果希望余额作为数字以太币为单位，可以从控制台用web3，示例如下： \&gt; web3.fromWei(&quot;0x1639e49bba16280000&quot;, &quot;ether&quot;) &quot;410&quot; 现在我们在私有开发链上有一些以太币，就可以部署合约了。第一步是验证solidity编译器可用，可以用eth_getCompilers RPC method方法来检索可用的编译器，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getCompilers&quot;, &quot;id&quot;: 3}&#39; localhost:8545 {&quot;id&quot;:3,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;Solidity&quot;]} 我们可以看到solidity编译器可用。 下一步是把Multiply7合约编译到可以发送给以太坊虚拟机的字节代码中，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_compileSolidity&quot;, &quot;params&quot;: [&quot;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input {&quot;id&quot;:4,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;Multiply7&quot;:{&quot;code&quot;:&quot;0x6060604052605f8060106000396000f360606040 现在我们有了编译代码，需要决定花多少gas去部署它。RPC界面有eth_estimateGas方法，会给我们一个预估数量，如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_estimateGas&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 5}&#39; localhost:8545 {&quot;id&quot;:5,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0xb8a9&quot;} 最后部署合约。 \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;gas&quot;: &quot;0xb8a9&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 6}&#39; localhost:8545 {&quot;id&quot;:6,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08 交易由节点接受，交易散表被返还。我们可以用这个散表来跟踪交易。 下一步是决定部署合约的地址。每个执行的交易都会创建一个接收。这个接收包含交易的各种信息，比如交易被包含在哪个区块，以太坊虚拟机用掉多少gas。如果交易创建了一个合约，它也会包含合约地址。我们可以用eth_getTransactionReceipt RPC方法检索接收，示例如下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getTransactionReceipt&quot;, &quot;params&quot;: [&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08a7c&quot;], &quot;id&quot;: 7}&#39; localhost:8545 {&quot;id&quot;:7,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;transactionHash&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c682 可以看到，合约在0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d上被创建。如果你得到了零而不是接收，说明还没有被纳入区块。这时，要检查看看你的矿工是否在运行，然后重新试一遍。 和智能合约互动 现在已经部署了合约，我们可以和它互动了。有两种方法进行互动，即发送交易或调用。在本节的例子中，将会发送交易到合约的multiply方法里。 在我们的实例中，需要具体说明from、to 和data参数。From是我们账户的公共地址，to是合约地址，Data参数有一点复杂，它包括了规定调用哪个方法和哪个参数的负载量。这就需要ABI发挥作用了，ABI规定了如何为以太坊虚拟机规定和编码数据。 负载量的字节是功能选择符，规定了调用哪个方法。它取Keccak散表的头4个字节，涵盖功能名称参数类型，并进行十六进制编码。multiply功能接受一个参数。示例如下： \&gt; web3.sha3(&quot;multiply(uint256)&quot;).substring(0, 8) &quot;c6888fa1&quot; 下一步是编码参数。我们只有一个unit256，假定提供了值6。ABI有一个章节规定了编码uint字节的方法，如下： int&lt;M&gt;: enc(X) is the big-endian two’s complement encoding of X, padded on the higher-oder (left) side with 0xff for negative X and with zero 字节s for positive X such that the length is a multiple of 32 bytes. 它会编码到 0000000000000000000000000000000000000000000000000000000000000006。 将功能选择符和编码参数结合起来，数据就会变成0xc6888fa10000000000000000000000000000000000000000000000000000000000000006。 我们来试一下： \&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;to&quot;: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, &quot;data&quot;: &quot;0xc6888fa10000000000000000000000000000000000000000000000000000000000000006&quot;}], &quot;id&quot;: 8}&#39; localhost:8545 {&quot;id&quot;:8,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869 由于我们发送了交易，于是有交易散表返回。如果检索接收，可以看到一些新内容，如下： { blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, contractAddress: null, cumulativeGasUsed: 22631, gasUsed: 22631, logs: [{ address: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, data: &quot;0x000000000000000000000000000000000000000000000000000000000000002a&quot;, logIndex: 0, topics: [&quot;0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot;], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 }], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 } 接收包含一个日志。日志由以太坊虚拟机在交易执行时生成，包含接收。如果我们看Multiply功能，可以看到打印事件和输入次数7一起被提出。由于打印事件的参数是uint256，因此可以根据ABI规则对它进行编码，这样就会得到预期的十进制42。 \&gt; web3.sha3(&quot;Print(uint256)&quot;) &quot;24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot; 这只是对一些最常见任务的简单介绍。在RPC维基页面查看可用RPC方法的完整列表。 Web3.js 正如在之前的案例所见，使用JSON-RPC界面相当单调乏味且容易出错，尤其是在处理ABI的时候。Web3.js是Javascript库，它的目标是提供更友好的界面，减少出错机会。 用web3部署Multiply7合约看起来是这样： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var code = compiled.Multiply7.code; var abi = compiled.Multiply7.info.abiDefinition; web3.eth.contract(abi).new({from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, data: code}, function (err, contract) { if (!err &amp;&amp; contract.address) console.log(&quot;deployed on:&quot;, contract.address); } ); deployed on: 0x0ab60714033847ad7f0677cc7514db48313976e2 装载一个部署的合约，发送交易： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition); var multi = Multiply7.at(&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;) multi.multiply.sendTransaction(6, {from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;}) 注册一个回调，打印事件创建日志的时候会被调用。 multi.Print(function(err, data) { console.log(JSON.stringify(data)) }) {&quot;address&quot;:&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;,&quot;args&quot;: {&quot;&quot;:&quot;21&quot;},&quot;blockHash&quot;:&quot;0x259c7dc0 在web3.js维基页面可查看更多信息。 控制台 geth控制台提供命令行界面和Javascript执行时间。它可以连接到本地或远程的geth或eth节点。它会装载用户能使用的web3.js库，从而方便用户从控制台通过web3.js部署智能合约，并和智能合约互动。实际上Web3.js章节的例子可以被复制进控制台并且调用。 查看合约与交易 有几个可用的在线区块链浏览器，能让你查询以太坊区块链，它们分别是： EtherChain EtherCamp EtherScan 其他可查看节点或交易的资源 EtherNodes ：节点的地理分配，由客户端区分。 EtherListen：实时以太坊交易可视器和可听器。 智能合约案例实战 以太坊是区块链开发领域最好的编程平台，而truffle是以太坊（Ethereum）最受欢迎的一个开发框架，这也是介绍truffle的原因。实战是最重要的事情，这篇文章不讲原理，只搭建环境，运行第一个区块链程序（Dapp）。 1. 安装truffle 安装truffle的命令如下： $ npm install -g truffle 2. 依赖环境 可用的系统包括：Windows、Linux和Mac OS X，推荐Mac OS X，不建议使用Windows，会碰到各种各样的问题，很可能导致放弃。首先，访问https://nodejs.org 官方网站下载安装NodeJS。 此外，需要安装Ethereum客户端，来支持JSON RPC API调用。 至于开发环境，推荐使用EthereumJS TestRPC，地址为： https://github.com/ethereumjs/testrpc。 安装命令如下： $ npm install -g ethereumjs-testrpc 3. 新建第一个项目 通过以下命令新建一个项目： $ mkdir zhaoxi $ cd zhaoxi $ truffle init 默认会生成一个MetaCoin的demo，可以从这个demo中学习truffle的架构。 项目的目录结构如图5-3所示。 图5-3 项目的目录结构 项目所有文件的目录如图5-4所示。 图5-4 项目文件目录目录结构 现在，通过以下命令编译项目。 $ truffle compile 图5-5是运行以上命令后的结果。 图5-5 Truffle compile执行结果图 下面介绍部署项目的方式。 部署之前先启动TestRPC，命令如下： $ testrpc $ truffle deploy（在Truffle 2.0以上版本中，命令变成了：truffle migrate） 图5-6是运行truffle deploy后的结果。 图5-6 truffle deploy执行结果图 $ truffle migrate migrate的执行结果见图5-7。 图5-7 truffle migrate migrate执行结果图 现在，可以启动服务了，命令如下： $ truffle serve 图5-8是truffle serve执行结果图 图5-8 truffle serve执行结果图 启动服务后，可以在浏览器访问项目了，地址是：http://localhost:8080/ ，网页界面如图5-9所示。 图5-9智能合约运行界面 好了，第一个区块链程序跑起来了，后面可以不断地实践深入学习了。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/14/84d624da1ceffcc6acfd49c478c2accb.html" />
<meta property="og:url" content="https://mlh.app/2017/09/14/84d624da1ceffcc6acfd49c478c2accb.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Blockchain_lemon/article/details/77983873 本文节选自图书《区块链开发指南》，本书由 申屠青春 主编，宋波、张鹏、汪晓明、季宙栋、左川民 联合编著。 区块链相关约稿、文章纠错、寻求报道等可邮件联系 jiawd@csdn.net 如何部署、调用智能合约 RPC 之前的章节中讲到了怎么写、部署合约以及与合约互动。现在该讲讲与以太坊网络和智能合约沟通的细节了。 一个以太坊节点提供一个RPC界面。这个界面给Ðapp（去中心化应用）访问以太坊区块链的权限和节点提供的功能，比如编译智能合约代码，它用JSON-RPC 2.0规范(不支持提醒和命名的参数) 的子集作为序列化协议，在HTTP和IPC (linux/OSX上的unix域接口，在Windows上叫pipe’s)上可用。 惯例 RPC界面会使用一些惯例，但它们不是JSON-RPC 2.0规范的一部分，这些惯例如下： 数字是十六进制编码。做这个决定是因为有些语言对运行极大的数字没有或有很少的限制。为了防止这些错误数字类型是十六进制编码，由开发者来分析这些数字并正确处理它们。在维基页百科查看十六进制编码章节查看案例。 默认区块数字。几个RPC 方法接受区块数字。在一些情况下，给出区块数字是不可能的或者不太方便。在那样的情况下，默认区块数字可以是以下字符串中的一个[”earliest”, “latest”, “pending”]。在维基页面可查看使用默认区块参数的RPC方法列表。 部署合约 我们会通过不同的步骤来部署下面的合约，但只用到RPC界面。 contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } } 要做的第一件事是确保HTTP RPC界面可用。这意味着我们在开始为geth供应—rpc标志，为eth提供-j标志。在这个例子中，用的是私有开发链上的geth节点。通过这种方法，我们就不需要真实网络上的以太币了。 \\&gt; geth --rpc --dev --mine --minerthreads 1 --unlock 0 console 2&gt;&gt;geth.log 这会在http://localhost:8545上启动HTTP RPC界面。 注意：geth支持CORS查看—rpccorsdomain标志了解更多。 我们可以通过用curl检索coinbase地址和余额来证明界面正在运行。请注意这些例子中的数据在你本地的节点上会有所不同。如果你想要试试这些参数，视情况替换需要的参数。 \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_coinbase&quot;, &quot;id&quot;:1}&#39; localhost:8545 {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;]} &gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBalance&quot;, &quot;params&quot;: [&quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;], &quot;id&quot;:2}&#39; localhost:8545 {&quot;id&quot;:2,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x1639e49bba16280000&quot;} 记不记得前面说过数字是十六进制编码？在这个情况下，余额作为十六进制字符串以Wei的形式返还。如果希望余额作为数字以太币为单位，可以从控制台用web3，示例如下： \\&gt; web3.fromWei(&quot;0x1639e49bba16280000&quot;, &quot;ether&quot;) &quot;410&quot; 现在我们在私有开发链上有一些以太币，就可以部署合约了。第一步是验证solidity编译器可用，可以用eth_getCompilers RPC method方法来检索可用的编译器，示例如下： \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getCompilers&quot;, &quot;id&quot;: 3}&#39; localhost:8545 {&quot;id&quot;:3,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:[&quot;Solidity&quot;]} 我们可以看到solidity编译器可用。 下一步是把Multiply7合约编译到可以发送给以太坊虚拟机的字节代码中，示例如下： \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_compileSolidity&quot;, &quot;params&quot;: [&quot;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input {&quot;id&quot;:4,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;Multiply7&quot;:{&quot;code&quot;:&quot;0x6060604052605f8060106000396000f360606040 现在我们有了编译代码，需要决定花多少gas去部署它。RPC界面有eth_estimateGas方法，会给我们一个预估数量，如下： \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_estimateGas&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 5}&#39; localhost:8545 {&quot;id&quot;:5,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0xb8a9&quot;} 最后部署合约。 \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;gas&quot;: &quot;0xb8a9&quot;, &quot;data&quot;: &quot;0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3&quot;}], &quot;id&quot;: 6}&#39; localhost:8545 {&quot;id&quot;:6,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08 交易由节点接受，交易散表被返还。我们可以用这个散表来跟踪交易。 下一步是决定部署合约的地址。每个执行的交易都会创建一个接收。这个接收包含交易的各种信息，比如交易被包含在哪个区块，以太坊虚拟机用掉多少gas。如果交易创建了一个合约，它也会包含合约地址。我们可以用eth_getTransactionReceipt RPC方法检索接收，示例如下： \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_getTransactionReceipt&quot;, &quot;params&quot;: [&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08a7c&quot;], &quot;id&quot;: 7}&#39; localhost:8545 {&quot;id&quot;:7,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;transactionHash&quot;:&quot;0x3a90b5face52c4c5f30d507ccf51b0209ca628c682 可以看到，合约在0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d上被创建。如果你得到了零而不是接收，说明还没有被纳入区块。这时，要检查看看你的矿工是否在运行，然后重新试一遍。 和智能合约互动 现在已经部署了合约，我们可以和它互动了。有两种方法进行互动，即发送交易或调用。在本节的例子中，将会发送交易到合约的multiply方法里。 在我们的实例中，需要具体说明from、to 和data参数。From是我们账户的公共地址，to是合约地址，Data参数有一点复杂，它包括了规定调用哪个方法和哪个参数的负载量。这就需要ABI发挥作用了，ABI规定了如何为以太坊虚拟机规定和编码数据。 负载量的字节是功能选择符，规定了调用哪个方法。它取Keccak散表的头4个字节，涵盖功能名称参数类型，并进行十六进制编码。multiply功能接受一个参数。示例如下： \\&gt; web3.sha3(&quot;multiply(uint256)&quot;).substring(0, 8) &quot;c6888fa1&quot; 下一步是编码参数。我们只有一个unit256，假定提供了值6。ABI有一个章节规定了编码uint字节的方法，如下： int&lt;M&gt;: enc(X) is the big-endian two’s complement encoding of X, padded on the higher-oder (left) side with 0xff for negative X and with zero 字节s for positive X such that the length is a multiple of 32 bytes. 它会编码到 0000000000000000000000000000000000000000000000000000000000000006。 将功能选择符和编码参数结合起来，数据就会变成0xc6888fa10000000000000000000000000000000000000000000000000000000000000006。 我们来试一下： \\&gt; curl --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;: &quot;eth_sendTransaction&quot;, &quot;params&quot;: [{&quot;from&quot;: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, &quot;to&quot;: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, &quot;data&quot;: &quot;0xc6888fa10000000000000000000000000000000000000000000000000000000000000006&quot;}], &quot;id&quot;: 8}&#39; localhost:8545 {&quot;id&quot;:8,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869 由于我们发送了交易，于是有交易散表返回。如果检索接收，可以看到一些新内容，如下： { blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, contractAddress: null, cumulativeGasUsed: 22631, gasUsed: 22631, logs: [{ address: &quot;0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d&quot;, blockHash: &quot;0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55&quot;, blockNumber: 268, data: &quot;0x000000000000000000000000000000000000000000000000000000000000002a&quot;, logIndex: 0, topics: [&quot;0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot;], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 }], transactionHash: &quot;0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74&quot;, transactionIndex: 0 } 接收包含一个日志。日志由以太坊虚拟机在交易执行时生成，包含接收。如果我们看Multiply功能，可以看到打印事件和输入次数7一起被提出。由于打印事件的参数是uint256，因此可以根据ABI规则对它进行编码，这样就会得到预期的十进制42。 \\&gt; web3.sha3(&quot;Print(uint256)&quot;) &quot;24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da&quot; 这只是对一些最常见任务的简单介绍。在RPC维基页面查看可用RPC方法的完整列表。 Web3.js 正如在之前的案例所见，使用JSON-RPC界面相当单调乏味且容易出错，尤其是在处理ABI的时候。Web3.js是Javascript库，它的目标是提供更友好的界面，减少出错机会。 用web3部署Multiply7合约看起来是这样： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var code = compiled.Multiply7.code; var abi = compiled.Multiply7.info.abiDefinition; web3.eth.contract(abi).new({from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;, data: code}, function (err, contract) { if (!err &amp;&amp; contract.address) console.log(&quot;deployed on:&quot;, contract.address); } ); deployed on: 0x0ab60714033847ad7f0677cc7514db48313976e2 装载一个部署的合约，发送交易： var source = &#39;contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input var compiled = web3.eth.compile.solidity(source); var Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition); var multi = Multiply7.at(&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;) multi.multiply.sendTransaction(6, {from: &quot;0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a&quot;}) 注册一个回调，打印事件创建日志的时候会被调用。 multi.Print(function(err, data) { console.log(JSON.stringify(data)) }) {&quot;address&quot;:&quot;0x0ab60714033847ad7f0677cc7514db48313976e2&quot;,&quot;args&quot;: {&quot;&quot;:&quot;21&quot;},&quot;blockHash&quot;:&quot;0x259c7dc0 在web3.js维基页面可查看更多信息。 控制台 geth控制台提供命令行界面和Javascript执行时间。它可以连接到本地或远程的geth或eth节点。它会装载用户能使用的web3.js库，从而方便用户从控制台通过web3.js部署智能合约，并和智能合约互动。实际上Web3.js章节的例子可以被复制进控制台并且调用。 查看合约与交易 有几个可用的在线区块链浏览器，能让你查询以太坊区块链，它们分别是： EtherChain EtherCamp EtherScan 其他可查看节点或交易的资源 EtherNodes ：节点的地理分配，由客户端区分。 EtherListen：实时以太坊交易可视器和可听器。 智能合约案例实战 以太坊是区块链开发领域最好的编程平台，而truffle是以太坊（Ethereum）最受欢迎的一个开发框架，这也是介绍truffle的原因。实战是最重要的事情，这篇文章不讲原理，只搭建环境，运行第一个区块链程序（Dapp）。 1. 安装truffle 安装truffle的命令如下： $ npm install -g truffle 2. 依赖环境 可用的系统包括：Windows、Linux和Mac OS X，推荐Mac OS X，不建议使用Windows，会碰到各种各样的问题，很可能导致放弃。首先，访问https://nodejs.org 官方网站下载安装NodeJS。 此外，需要安装Ethereum客户端，来支持JSON RPC API调用。 至于开发环境，推荐使用EthereumJS TestRPC，地址为： https://github.com/ethereumjs/testrpc。 安装命令如下： $ npm install -g ethereumjs-testrpc 3. 新建第一个项目 通过以下命令新建一个项目： $ mkdir zhaoxi $ cd zhaoxi $ truffle init 默认会生成一个MetaCoin的demo，可以从这个demo中学习truffle的架构。 项目的目录结构如图5-3所示。 图5-3 项目的目录结构 项目所有文件的目录如图5-4所示。 图5-4 项目文件目录目录结构 现在，通过以下命令编译项目。 $ truffle compile 图5-5是运行以上命令后的结果。 图5-5 Truffle compile执行结果图 下面介绍部署项目的方式。 部署之前先启动TestRPC，命令如下： $ testrpc $ truffle deploy（在Truffle 2.0以上版本中，命令变成了：truffle migrate） 图5-6是运行truffle deploy后的结果。 图5-6 truffle deploy执行结果图 $ truffle migrate migrate的执行结果见图5-7。 图5-7 truffle migrate migrate执行结果图 现在，可以启动服务了，命令如下： $ truffle serve 图5-8是truffle serve执行结果图 图5-8 truffle serve执行结果图 启动服务后，可以在浏览器访问项目了，地址是：http://localhost:8080/ ，网页界面如图5-9所示。 图5-9智能合约运行界面 好了，第一个区块链程序跑起来了，后面可以不断地实践深入学习了。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/14/84d624da1ceffcc6acfd49c478c2accb.html","headline":"动手编写一个以太坊智能合约-区块链大本营(让区块链回归技术和应用的本质，欢迎投稿：heyc@csdn.net。)","dateModified":"2017-09-14T00:00:00+08:00","datePublished":"2017-09-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/14/84d624da1ceffcc6acfd49c478c2accb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>动手编写一个以太坊智能合约-区块链大本营(让区块链回归技术和应用的本质，欢迎投稿：heyc@csdn.net。)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Blockchain_lemon/article/details/77983873 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <blockquote> 
   <p>本文节选自图书《区块链开发指南》，本书由 申屠青春 主编，宋波、张鹏、汪晓明、季宙栋、左川民 联合编著。 <br> 区块链相关约稿、文章纠错、寻求报道等可邮件联系 jiawd@csdn.net</p> 
  </blockquote> 
  <h2 id="如何部署调用智能合约">如何部署、调用智能合约</h2> 
  <h3 id="rpc">RPC</h3> 
  <p>之前的章节中讲到了怎么写、部署合约以及与合约互动。现在该讲讲与以太坊网络和智能合约沟通的细节了。</p> 
  <p>一个以太坊节点提供一个RPC界面。这个界面给Ðapp（去中心化应用）访问以太坊区块链的权限和节点提供的功能，比如编译智能合约代码，它用JSON-RPC 2.0规范(不支持提醒和命名的参数) 的子集作为序列化协议，在HTTP和IPC (linux/OSX上的unix域接口，在Windows上叫pipe’s)上可用。</p> 
  <h3 id="惯例">惯例</h3> 
  <p>RPC界面会使用一些惯例，但它们不是JSON-RPC 2.0规范的一部分，这些惯例如下：</p> 
  <ul> 
   <li><p>数字是十六进制编码。做这个决定是因为有些语言对运行极大的数字没有或有很少的限制。为了防止这些错误数字类型是十六进制编码，由开发者来分析这些数字并正确处理它们。在维基页百科查看十六进制编码章节查看案例。</p></li> 
   <li><p>默认区块数字。几个RPC 方法接受区块数字。在一些情况下，给出区块数字是不可能的或者不太方便。在那样的情况下，默认区块数字可以是以下字符串中的一个[”earliest”, “latest”, “pending”]。在维基页面可查看使用默认区块参数的RPC方法列表。</p></li> 
  </ul> 
  <h3 id="部署合约">部署合约</h3> 
  <p>我们会通过不同的步骤来部署下面的合约，但只用到RPC界面。</p> 
  <pre class="prettyprint"><code class=" hljs php">contract Multiply7 {
event <span class="hljs-keyword">Print</span>(uint);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(uint input)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>
<span class="hljs-keyword">Print</span>(input
*
<span class="hljs-number">7</span>);
<span class="hljs-keyword">return</span> input
*
<span class="hljs-number">7</span>;
}
}</code></pre> 
  <p>要做的第一件事是确保HTTP RPC界面可用。这意味着我们在开始为geth供应—rpc标志，为eth提供-j标志。在这个例子中，用的是私有开发链上的geth节点。通过这种方法，我们就不需要真实网络上的以太币了。</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">\</span>&gt; <span class="hljs-comment">geth</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpc</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">dev</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">mine</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">minerthreads</span> <span class="hljs-comment">1</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">unlock</span> <span class="hljs-comment">0</span> <span class="hljs-comment">console</span> <span class="hljs-comment">2</span>&gt;&gt;<span class="hljs-comment">geth</span><span class="hljs-string">.</span><span class="hljs-comment">log</span></code></pre> 
  <p>这会在<a href="http://localhost:8545" rel="nofollow">http://localhost:8545</a>上启动HTTP RPC界面。</p> 
  <p>注意：geth支持CORS查看—rpccorsdomain标志了解更多。 <br> 我们可以通过用curl检索coinbase地址和余额来证明界面正在运行。请注意这些例子中的数据在你本地的节点上会有所不同。如果你想要试试这些参数，视情况替换需要的参数。</p> 
  <pre class="prettyprint"><code class=" hljs scilab">\&gt; curl --data <span class="hljs-string">'{"</span>jsonrpc<span class="hljs-string">":"</span><span class="hljs-number">2.0</span><span class="hljs-string">","</span>method<span class="hljs-string">":"</span>eth_coinbase<span class="hljs-string">", "</span>id<span class="hljs-string">":1}'</span> localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-matrix">[<span class="hljs-string">"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a"</span>]</span>}
&gt; curl --data <span class="hljs-string">'{"</span>jsonrpc<span class="hljs-string">":"</span><span class="hljs-number">2.0</span><span class="hljs-string">","</span>method<span class="hljs-string">":"</span>eth_getBalance<span class="hljs-string">", "</span>params<span class="hljs-string">": ["</span><span class="hljs-number">0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a</span><span class="hljs-string">"], "</span>id<span class="hljs-string">":2}'</span> localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-string">"0x1639e49bba16280000"</span>}</code></pre> 
  <p>记不记得前面说过数字是十六进制编码？在这个情况下，余额作为十六进制字符串以Wei的形式返还。如果希望余额作为数字以太币为单位，可以从控制台用web3，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">\&gt; web3<span class="hljs-preprocessor">.fromWei</span>(<span class="hljs-string">"0x1639e49bba16280000"</span>, <span class="hljs-string">"ether"</span>)
<span class="hljs-string">"410"</span></code></pre> 
  <p>现在我们在私有开发链上有一些以太币，就可以部署合约了。第一步是验证solidity编译器可用，可以用eth_getCompilers RPC method方法来检索可用的编译器，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs scilab">\&gt; curl --data <span class="hljs-string">'{"</span>jsonrpc<span class="hljs-string">":"</span><span class="hljs-number">2.0</span><span class="hljs-string">","</span>method<span class="hljs-string">": "</span>eth_getCompilers<span class="hljs-string">", "</span>id<span class="hljs-string">": 3}'</span> localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-matrix">[<span class="hljs-string">"Solidity"</span>]</span>}</code></pre> 
  <p>我们可以看到solidity编译器可用。</p> 
  <p>下一步是把Multiply7合约编译到可以发送给以太坊虚拟机的字节代码中，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs 1c">\&gt; curl --data '{<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"method"</span>: <span class="hljs-string">"eth_compileSolidity"</span>, <span class="hljs-string">"params"</span>: [<span class="hljs-string">"contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:{<span class="hljs-string">"Multiply7"</span>:{<span class="hljs-string">"code"</span>:<span class="hljs-string">"0x6060604052605f8060106000396000f360606040</span></code></pre> 
  <p>现在我们有了编译代码，需要决定花多少gas去部署它。RPC界面有eth_estimateGas方法，会给我们一个预估数量，如下：</p> 
  <pre class="prettyprint"><code class=" hljs scilab">\&gt; curl --data <span class="hljs-string">'{"</span>jsonrpc<span class="hljs-string">":"</span><span class="hljs-number">2.0</span><span class="hljs-string">","</span>method<span class="hljs-string">": "</span>eth_estimateGas<span class="hljs-string">", "</span>params<span class="hljs-string">": [{"</span>from<span class="hljs-string">": "</span><span class="hljs-number">0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a</span><span class="hljs-string">", "</span>data<span class="hljs-string">": "</span><span class="hljs-number">0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3</span><span class="hljs-string">"}], "</span>id<span class="hljs-string">": 5}'</span> localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-string">"0xb8a9"</span>}</code></pre> 
  <p>最后部署合约。</p> 
  <pre class="prettyprint"><code class=" hljs 1c">\&gt; curl --data '{<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"method"</span>: <span class="hljs-string">"eth_sendTransaction"</span>, <span class="hljs-string">"params"</span>: [{<span class="hljs-string">"from"</span>: <span class="hljs-string">"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a"</span>, <span class="hljs-string">"gas"</span>: <span class="hljs-string">"0xb8a9"</span>, <span class="hljs-string">"data"</span>: <span class="hljs-string">"0x6060604052605f8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b60586004356007810260609081526000907f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da90602090a15060070290565b5060206060f3"</span>}], <span class="hljs-string">"id"</span>: <span class="hljs-number">6</span>}' localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-string">"0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08</span></code></pre> 
  <p>交易由节点接受，交易散表被返还。我们可以用这个散表来跟踪交易。</p> 
  <p>下一步是决定部署合约的地址。每个执行的交易都会创建一个接收。这个接收包含交易的各种信息，比如交易被包含在哪个区块，以太坊虚拟机用掉多少gas。如果交易创建了一个合约，它也会包含合约地址。我们可以用eth_getTransactionReceipt RPC方法检索接收，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs 1c">\&gt; curl --data '{<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"method"</span>: <span class="hljs-string">"eth_getTransactionReceipt"</span>, <span class="hljs-string">"params"</span>: [<span class="hljs-string">"0x3a90b5face52c4c5f30d507ccf51b0209ca628c6824d0532bcd6283df7c08a7c"</span>], <span class="hljs-string">"id"</span>: <span class="hljs-number">7</span>}' localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:{<span class="hljs-string">"transactionHash"</span>:<span class="hljs-string">"0x3a90b5face52c4c5f30d507ccf51b0209ca628c682</span></code></pre> 
  <p>可以看到，合约在0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d上被创建。如果你得到了零而不是接收，说明还没有被纳入区块。这时，要检查看看你的矿工是否在运行，然后重新试一遍。</p> 
  <h3 id="和智能合约互动">和智能合约互动</h3> 
  <p>现在已经部署了合约，我们可以和它互动了。有两种方法进行互动，即发送交易或调用。在本节的例子中，将会发送交易到合约的multiply方法里。</p> 
  <p>在我们的实例中，需要具体说明from、to 和data参数。From是我们账户的公共地址，to是合约地址，Data参数有一点复杂，它包括了规定调用哪个方法和哪个参数的负载量。这就需要ABI发挥作用了，ABI规定了如何为以太坊虚拟机规定和编码数据。</p> 
  <p>负载量的字节是功能选择符，规定了调用哪个方法。它取Keccak散表的头4个字节，涵盖功能名称参数类型，并进行十六进制编码。multiply功能接受一个参数。示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">\&gt; web3<span class="hljs-preprocessor">.sha</span>3(<span class="hljs-string">"multiply(uint256)"</span>)<span class="hljs-preprocessor">.substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>)
<span class="hljs-string">"c6888fa1"</span></code></pre> 
  <p>下一步是编码参数。我们只有一个unit256，假定提供了值6。ABI有一个章节规定了编码uint字节的方法，如下：</p> 
  <pre class="prettyprint"><code class=" hljs applescript">int&lt;M&gt;: enc(X) <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> big-endian two’s complement encoding <span class="hljs-keyword">of</span> X, padded <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword">the</span> higher-oder (left) side <span class="hljs-keyword">with</span> <span class="hljs-number">0xff</span> <span class="hljs-keyword">for</span> negative X <span class="hljs-keyword">and</span> <span class="hljs-keyword">with</span> zero 字节s <span class="hljs-keyword">for</span> positive X such <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> <span class="hljs-property">length</span> <span class="hljs-keyword">is</span> a multiple <span class="hljs-keyword">of</span> <span class="hljs-number">32</span> bytes.</code></pre> 
  <p>它会编码到 <br> 0000000000000000000000000000000000000000000000000000000000000006。 <br> 将功能选择符和编码参数结合起来，数据就会变成0xc6888fa10000000000000000000000000000000000000000000000000000000000000006。</p> 
  <p>我们来试一下：</p> 
  <pre class="prettyprint"><code class=" hljs 1c">\&gt; curl --data '{<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"method"</span>: <span class="hljs-string">"eth_sendTransaction"</span>, <span class="hljs-string">"params"</span>: [{<span class="hljs-string">"from"</span>: <span class="hljs-string">"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a"</span>, <span class="hljs-string">"to"</span>: <span class="hljs-string">"0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d"</span>, <span class="hljs-string">"data"</span>: <span class="hljs-string">"0xc6888fa10000000000000000000000000000000000000000000000000000000000000006"</span>}], <span class="hljs-string">"id"</span>: <span class="hljs-number">8</span>}' localhost:<span class="hljs-number">8545</span>
{<span class="hljs-string">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-string">"jsonrpc"</span>:<span class="hljs-string">"2.0"</span>,<span class="hljs-string">"result"</span>:<span class="hljs-string">"0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869</span></code></pre> 
  <p>由于我们发送了交易，于是有交易散表返回。如果检索接收，可以看到一些新内容，如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">{
<span class="hljs-label">blockHash:</span> <span class="hljs-string">"0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55"</span>,
<span class="hljs-label">blockNumber:</span> <span class="hljs-number">268</span>,
<span class="hljs-label">contractAddress:</span> null,
<span class="hljs-label">cumulativeGasUsed:</span> <span class="hljs-number">22631</span>,
<span class="hljs-label">gasUsed:</span> <span class="hljs-number">22631</span>,
<span class="hljs-label">logs:</span> [{
<span class="hljs-label">address:</span> <span class="hljs-string">"0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d"</span>,
<span class="hljs-label">blockHash:</span> <span class="hljs-string">"0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55"</span>,
<span class="hljs-label">blockNumber:</span> <span class="hljs-number">268</span>,
<span class="hljs-label">data:</span> <span class="hljs-string">"0x000000000000000000000000000000000000000000000000000000000000002a"</span>,
<span class="hljs-label">logIndex:</span> <span class="hljs-number">0</span>,
<span class="hljs-label">topics:</span> [<span class="hljs-string">"0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da"</span>],
<span class="hljs-label">transactionHash:</span> <span class="hljs-string">"0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74"</span>,
<span class="hljs-label">transactionIndex:</span> <span class="hljs-number">0</span>
}],
<span class="hljs-label">transactionHash:</span> <span class="hljs-string">"0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74"</span>,
<span class="hljs-label">transactionIndex:</span> <span class="hljs-number">0</span>
}</code></pre> 
  <p>接收包含一个日志。日志由以太坊虚拟机在交易执行时生成，包含接收。如果我们看Multiply功能，可以看到打印事件和输入次数7一起被提出。由于打印事件的参数是uint256，因此可以根据ABI规则对它进行编码，这样就会得到预期的十进制42。</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">\&gt; web3<span class="hljs-preprocessor">.sha</span>3(<span class="hljs-string">"Print(uint256)"</span>)
<span class="hljs-string">"24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da"</span></code></pre> 
  <p>这只是对一些最常见任务的简单介绍。在RPC维基页面查看可用RPC方法的完整列表。</p> 
  <h3 id="web3js">Web3.js</h3> 
  <p>正如在之前的案例所见，使用JSON-RPC界面相当单调乏味且容易出错，尤其是在处理ABI的时候。Web3.js是Javascript库，它的目标是提供更友好的界面，减少出错机会。</p> 
  <p>用web3部署Multiply7合约看起来是这样：</p> 
  <pre class="prettyprint"><code class=" hljs vbscript">var source = <span class="hljs-comment">'contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input</span>
var compiled = web3.eth.compile.solidity(source);
var code = compiled.Multiply7.code;
var abi = compiled.Multiply7.info.abiDefinition;
web3.eth.contract(abi).<span class="hljs-keyword">new</span>({from: <span class="hljs-string">"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a"</span>, data: code}, <span class="hljs-keyword">function</span> (<span class="hljs-built_in">err</span>, contract) {
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">err</span> &amp;&amp; contract.address)
console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"deployed on:"</span>, contract.address);
}
);
deployed <span class="hljs-keyword">on</span>: <span class="hljs-number">0x0ab60714033847ad7f0677cc7514db48313976e2</span></code></pre> 
  <p>装载一个部署的合约，发送交易：</p> 
  <pre class="prettyprint"><code class=" hljs applescript">var source = 'contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input
var compiled = web3.eth.compile.solidity(source);
var Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition);
var multi = Multiply7.<span class="hljs-keyword">at</span>(<span class="hljs-string">"0x0ab60714033847ad7f0677cc7514db48313976e2"</span>)
multi.multiply.sendTransaction(<span class="hljs-number">6</span>, {<span class="hljs-keyword">from</span>: <span class="hljs-string">"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a"</span>})</code></pre> 
  <p>注册一个回调，打印事件创建日志的时候会被调用。</p> 
  <pre class="prettyprint"><code class=" hljs javascript">multi.Print(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span> {</span> console.log(<span class="hljs-built_in">JSON</span>.stringify(data)) })
{<span class="hljs-string">"address"</span>:<span class="hljs-string">"0x0ab60714033847ad7f0677cc7514db48313976e2"</span>,<span class="hljs-string">"args"</span>: {<span class="hljs-string">""</span>:<span class="hljs-string">"21"</span>},<span class="hljs-string">"blockHash"</span>:<span class="hljs-string">"0x259c7dc0</span></code></pre> 
  <p>在web3.js维基页面可查看更多信息。</p> 
  <h3 id="控制台">控制台</h3> 
  <p>geth控制台提供命令行界面和Javascript执行时间。它可以连接到本地或远程的geth或eth节点。它会装载用户能使用的web3.js库，从而方便用户从控制台通过web3.js部署智能合约，并和智能合约互动。实际上Web3.js章节的例子可以被复制进控制台并且调用。</p> 
  <h3 id="查看合约与交易">查看合约与交易</h3> 
  <p>有几个可用的在线区块链浏览器，能让你查询以太坊区块链，它们分别是：</p> 
  <ul> 
   <li>EtherChain</li> 
   <li>EtherCamp</li> 
   <li>EtherScan </li> 
  </ul> 
  <p>其他可查看节点或交易的资源</p> 
  <ul> 
   <li>EtherNodes ：节点的地理分配，由客户端区分。</li> 
   <li>EtherListen：实时以太坊交易可视器和可听器。</li> 
  </ul> 
  <h3 id="智能合约案例实战">智能合约案例实战</h3> 
  <p>以太坊是区块链开发领域最好的编程平台，而truffle是以太坊（Ethereum）最受欢迎的一个开发框架，这也是介绍truffle的原因。实战是最重要的事情，这篇文章不讲原理，只搭建环境，运行第一个区块链程序（Dapp）。 </p> 
  <p><strong>1. 安装truffle</strong></p> 
  <p>安装truffle的命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>npm install -g truffle</code></pre> 
  <p><strong>2. 依赖环境</strong></p> 
  <p>可用的系统包括：Windows、Linux和Mac OS X，推荐Mac OS X，不建议使用Windows，会碰到各种各样的问题，很可能导致放弃。首先，访问<a href="https://nodejs.org" rel="nofollow">https://nodejs.org</a> 官方网站下载安装NodeJS。</p> 
  <p>此外，需要安装Ethereum客户端，来支持JSON RPC API调用。</p> 
  <p>至于开发环境，推荐使用EthereumJS TestRPC，地址为： <a href="https://github.com/ethereumjs/testrpc" rel="nofollow">https://github.com/ethereumjs/testrpc</a>。</p> 
  <p>安装命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ npm install <span class="hljs-attribute">-g</span> ethereumjs<span class="hljs-attribute">-testrpc</span></code></pre> 
  <p><strong>3. 新建第一个项目</strong></p> 
  <p>通过以下命令新建一个项目：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>mkdir zhaoxi
<span class="hljs-variable">$ </span>cd zhaoxi
<span class="hljs-variable">$ </span>truffle init</code></pre> 
  <p>默认会生成一个MetaCoin的demo，可以从这个demo中学习truffle的架构。</p> 
  <p>项目的目录结构如图5-3所示。</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914182847846" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-3 项目的目录结构
   </center>
  </center>
  <p></p> 
  <p>项目所有文件的目录如图5-4所示。</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183107119" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-4 项目文件目录目录结构
   </center>
  </center>
  <p></p> 
  <p>现在，通过以下命令编译项目。</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>truffle compile</code></pre> 
  <p>图5-5是运行以上命令后的结果。 <br> </p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183153564" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-5 Truffle compile执行结果图
   </center>
  </center>
  <p></p> 
  <p>下面介绍部署项目的方式。</p> 
  <p>部署之前先启动TestRPC，命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>testrpc 
<span class="hljs-variable">$ </span>truffle deploy（在<span class="hljs-constant">Truffle</span> <span class="hljs-number">2.0</span>以上版本中，命令变成了：truffle migrate）</code></pre> 
  <p>图5-6是运行truffle deploy后的结果。</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183241791" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-6 truffle deploy执行结果图
   </center>
  </center>
  <p></p> 
  <p>$ truffle migrate migrate的执行结果见图5-7。</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183342146" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-7 truffle migrate migrate执行结果图
   </center>
  </center>
  <p></p> 
  <p>现在，可以启动服务了，命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>truffle serve</code></pre> 
  <p>图5-8是truffle serve执行结果图</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183435355" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-8 truffle serve执行结果图
   </center>
  </center>
  <p></p> 
  <p>启动服务后，可以在浏览器访问项目了，地址是：<a href="http://localhost:8080/" rel="nofollow">http://localhost:8080/</a> ，网页界面如图5-9所示。</p> 
  <p></p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914183458609" alt="这里写图片描述" title=""> 
   <br> 
   <center>
    图5-9智能合约运行界面
   </center>
  </center>
  <p></p> 
  <p>好了，第一个区块链程序跑起来了，后面可以不断地实践深入学习了。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170914180220098" alt="这里写图片描述" title=""></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/77983873,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/77983873,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
