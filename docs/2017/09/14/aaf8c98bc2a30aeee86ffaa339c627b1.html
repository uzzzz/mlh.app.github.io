<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码解析(14) - 可执行程序 - Bitcoind-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码解析(14) - 可执行程序 - Bitcoind-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77982837 0x00 AppInitParameterInteraction 这个函数包括源码中的Step 2和Step 3两个，主要实现的功能是设置区块链运行时的一些参数。 0x01 Step 2 - parameter interactions // if using block pruning, then disallow txindex if (gArgs.GetArg(&quot;-prune&quot;, 0)) { if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); } -prune参数表示启用区块修剪(block pruning)，根据bitcoin release note中的描述， Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 我们知道在比特币运行的本地环境中，有四种类型的数据（在Linux环境下查看~/.bitcoin/目录）， raw block，从网络中接收的原始区块信息，对应文件为blk***.dat undo data，在进行chain reorganization时使用的数据，对应文件为rev***.dat。Chain reorganization是指某一个节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行Chain reorganization，所以这个操作只是针对某一个节点而言的。 block index，区块索引，每一个区块都有一个唯一的索引，对应文件为~/.bitcoin/blocks/index下的.ldblevel db数据库文件。 UTXO，Unspent transaction output，表示所有未花费的交易，对应文件为~/.bitcoin/chainstate/中的.ldb文件。 而block pruing删除的就是raw block和undo data两种数据，通过-prune=N参数N来指定raw block + undo data数据的大小，单位为MB。 N的最小值为550，代表288个区块的大小，按照每个block 10 Min的速率，代表2天的时间。 因为block pruning需要删除一些区块的信息，而-txindex是对所有交易建立索引，所以这两者不兼容，如果同时设置了，那么则提示错误。 // -bind and -whitebind can&#39;t be set when not listening size_t nUserBind = gArgs.GetArgs(&quot;-bind&quot;).size() + gArgs.GetArgs(&quot;-whitebind&quot;).size(); if (nUserBind != 0 &amp;&amp; !gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN)) { return InitError(&quot;Cannot set -bind or -whitebind together with -listen=0&quot;); } 接下来这段代码检测-listen和bind之间的冲突问题，也就是如果设置了bind的地址而没有设置listen那么就会报错并退出程序。 // Make sure enough file descriptors are available int nBind = std::max(nUserBind, size_t(1)); nUserMaxConnections = gArgs.GetArg(&quot;-maxconnections&quot;, DEFAULT_MAX_PEER_CONNECTIONS); nMaxConnections = std::max(nUserMaxConnections, 0); // Trim requested connection counts, to fit into system limitations nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), 0); nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS); if (nFD &lt; MIN_CORE_FILEDESCRIPTORS) return InitError(_(&quot;Not enough file descriptors available.&quot;)); nMaxConnections = std::min(nFD - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS, nMaxConnections); if (nMaxConnections &lt; nUserMaxConnections) InitWarning(strprintf(_(&quot;Reducing -maxconnections from %d to %d, because of system limitations.&quot;), nUserMaxConnections, nMaxConnections)); 这段代码中注释的意思是确保有足够的文件描述符，文件描述符又是什么呢？ 转载： http://blog.csdn.net/cywosp/article/details/38965239 在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中*最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话*。 内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一。 从上述文章中我们知道文件描述符就是一个打开文件的索引，首先代码计算了用户设置的bind的地址数量nBind，然后或者命令行中的-maxconnections，这个参数的默认值为125。 // src/net.h line 75 /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 然后开始计算最大连接数，公式中涉及到几个变量，分别位于如下位置， // src/compat.h line 27 #define FD_SETSIZE 1024 // max number of fds in fd_set // src/init.cpp line 89 #define MIN_CORE_FILEDESCRIPTORS 150 // src/net.h line 61 /** Maximum number of addnode outgoing nodes */ static const int MAX_ADDNODE_CONNECTIONS = 8; FD_SETSIZ：如上述参考的文章中所说，代表系统对单个进程的用户级限制，值为1024。 MIN_CORE_FILEDESCRIPTORS：直译为最小核心文件描述符数量，但并不懂含义= = MAX_ADDNODE_CONNECTIONS：最大addnode连接数，不懂含义= = 虽然还没有明白这个公式的原理，但是功能大概明白了，首先判断文件描述符的数量是否够用，如果不够用那么直接报错并退出程序；然后判断命令行设置的-maxconnections是否超过了系统支持的最大连接数，如果超过了，那么就提示强制设置为系统的最大连接数。 0x02 Step 3: parameter-to-internal-flags if (gArgs.IsArgSet(&quot;-debug&quot;)) { // Special-case: if -debug=0/-nodebug is set, turn off debugging messages const std::vector&lt;std::string&gt; categories = gArgs.GetArgs(&quot;-debug&quot;); if (find(categories.begin(), categories.end(), std::string(&quot;0&quot;)) == categories.end()) { for (const auto&amp; cat : categories) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debug&quot;, cat)); continue; } logCategories |= flag; } } } // Now remove the logging categories which were explicitly excluded for (const std::string&amp; cat : gArgs.GetArgs(&quot;-debugexclude&quot;)) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debugexclude&quot;, cat)); continue; } logCategories &amp;= ~flag; } 首先的一段代码是判断应该对哪些目录写入调试日志，所有的目录包括以下类型(src/util.cpp line 220)， const CLogCategoryDesc LogCategories[] = { {BCLog::NONE, &quot;0&quot;}, {BCLog::NET, &quot;net&quot;}, {BCLog::TOR, &quot;tor&quot;}, {BCLog::MEMPOOL, &quot;mempool&quot;}, {BCLog::HTTP, &quot;http&quot;}, {BCLog::BENCH, &quot;bench&quot;}, {BCLog::ZMQ, &quot;zmq&quot;}, {BCLog::DB, &quot;db&quot;}, {BCLog::RPC, &quot;rpc&quot;}, {BCLog::ESTIMATEFEE, &quot;estimatefee&quot;}, {BCLog::ADDRMAN, &quot;addrman&quot;}, {BCLog::SELECTCOINS, &quot;selectcoins&quot;}, {BCLog::REINDEX, &quot;reindex&quot;}, {BCLog::CMPCTBLOCK, &quot;cmpctblock&quot;}, {BCLog::RAND, &quot;rand&quot;}, {BCLog::PRUNE, &quot;prune&quot;}, {BCLog::PROXY, &quot;proxy&quot;}, {BCLog::MEMPOOLREJ, &quot;mempoolrej&quot;}, {BCLog::LIBEVENT, &quot;libevent&quot;}, {BCLog::COINDB, &quot;coindb&quot;}, {BCLog::QT, &quot;qt&quot;}, {BCLog::LEVELDB, &quot;leveldb&quot;}, {BCLog::ALL, &quot;1&quot;}, {BCLog::ALL, &quot;all&quot;}, }; 每个目录都对应了一个编号，代码中的logCategories变量就是记录所有的日志目录的集合，类型是uint32_t，而目录对应的编号每一个都对应32位中的一位，所以每做一次|操作，就表示将当前的目录编号加进集合。而后面的-debugexclude参数就是从集合中删除掉不想记录日志的目录，这时使用的是&amp;= ~flag操作，~表示每一位取反，与上反码就表示将当前的目录编号从集合中去掉。 再接下来一段代码中的几个if语句就是检查一下不支持的参数，或者有变更的参数命令，比较容易理解。 // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(gArgs.GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } fCheckBlockIndex = gArgs.GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = gArgs.GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); 根据帮助信息中的解释， -checkmempool：表示每隔多少个交易进行一次sanity check。 -checkblockindex：每隔一段时间检查mapBlockIndex、setBlockIndexCandidates、chainActive和mapBlockUnlinked变量的一致性。 -checkpoints：该变量默认为1，表示不验证当前已经存在的链；如果为0，表示要检查一些校验点的区块信息是否正确，所有校验点的信息也都保存在chainparams中的checkpointdata中。 代码首先判断chainparams中的DefaultConsistencyChecks是否为true，如果这个变量为false，那么ratio=0，也就是不进行sanity check。Sanity check之前在http://blog.csdn.net/pure_lady/article/details/77776716#t2中CTxMemPool类中介绍过，表示检查mempool中所有交易的一致性（没有双花，所有的输入都是合法的）。对于chainparams这个变量的也在http://blog.csdn.net/pure_lady/article/details/77895680中的SelectParams函数中介绍过，首先根据设置的网络MAIN、TESTNET或者REGTEST选择相应的参数，三个网络根据src/chainparams.cpp中给参数定义不同的值，对于DefaultConsistencyChecks这个参数，MAIN和TESTNET都为false，而REGTEST中此变量为true。 hashAssumeValid = uint256S(gArgs.GetArg(&quot;-assumevalid&quot;, chainparams.GetConsensus().defaultAssumeValid.GetHex())); if (!hashAssumeValid.IsNull()) LogPrintf(&quot;Assuming ancestors of block %s have valid signatures.\n&quot;, hashAssumeValid.GetHex()); else LogPrintf(&quot;Validating signatures for all blocks.\n&quot;); -assumevalid=blockid：表示在blockid之前的所有区块都假设正确的，也就是不用再去验证。如果没有设置，那么就要验证之前所有区块的签名信息。 // mempool limits int64_t nMempoolSizeMax = gArgs.GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = gArgs.GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting. if (gArgs.IsArgSet(&quot;-incrementalrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;incrementalrelayfee&quot;, gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;))); incrementalRelayFee = CFeeRate(n); } 接下来这段代码首先计算mempool的最大值，后面乘以1000000是将单位从MB转换成B，然后计算最小的限制，其中，-limitdescendantsize的含义如下，后面乘以1000将单位从KB转化成B，再乘以40表示最小可以容纳40个这个的交易族。 -limitdescendantsize：如果某个交易在mempool中所有的祖先size之和超过该限制值，那么则拒绝接受该交易。单位为KB。 在每个节点内部都可以设置以下几种费用来避免接收过多的交易， minrelaytxfee：最小的转发费用，如果交易费小于这个值，节点就直接忽略该交易。默认值为0.00001 BTC/KB。 dustrelayfee：用来判定一笔交易时候是否是dust tx，如果是的话则忽略该交易。默认值为0.00001BTC/KB。 incrementalrelayfee：用来改变mempool最低交易费用的变量，当mempool中的交易数量超过阈值时，交易费用阈值便会增加，增加的程度就由incrementalrelayfee决定。默认值为0.00001BTC/KB。 节点交易处理流程 所以一个full-node对交易的处理流程如下：（1）首先判断交易的费用之和是否大于minrelayfee；（2）然后判断是否是dustrelayfee，如果是的话就转发给其他节点，自己忽略该交易；（3）最后判断费用是否满足当前的费用条件，当前的费用会根据交易数量动态的变化，当交易数量过多时，增加，交易减少时，也减小。 源码中这地方就是判断命令行中是否设置了-incrementalrelayfee，如果设置了就设置变量incrementalRelayFee。 设置脚本验证线程数量 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = gArgs.GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; -par=N ：设置脚本验证线程数量，取值范围为[-2,16]，小于0表示令N个保持空闲，0表示自动检测，1表示不允许并行，大于等于2表示同一时刻最大线程数量，默认值为0。 其中MAX_SCRIPTCHECK_THREADS定义的值为16。 设置prune保留的文件大小 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nPruneArg = gArgs.GetArg(&quot;-prune&quot;, 0); if (nPruneArg &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024; if (nPruneArg == 1) { // manual pruning: -prune=1 LogPrintf(&quot;Block pruning enabled. Use RPC call pruneblockchain(height) to manually prune block and undo files.\n&quot;); nPruneTarget = std::numeric_limits&lt;uint64_t&gt;::max(); fPruneMode = true; } else if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } -prune参数在Step 2中已经介绍过，用来删除已经验证过的区块，取值有以下几种： 0：默认值，表示禁止该功能。 1：表示允许手动使用RPC命令删除旧的区块。 大于等于550：表示允许保存的raw block + undo data文件总大小，其中550MB = MIN_DISK_SPACE_FOR_BLOCK_FILES。 注册RPC命令 RegisterAllCoreRPCCommands(tableRPC); #ifdef ENABLE_WALLET RegisterWalletRPCCommands(tableRPC); #endif 所谓注册RPC命令，其实解释将信号和处理函数connect起来，方式就是使用boost的signal/slot模式，但是这里做的只是将一些指令添加到一个类型为CRPCTable的tableRPC变量中，这个tableRPC维护了所有的命令和对应的处理函数，收到相应的RPC命令是再调用CRPCTable类中execute函数执行请求。 再看看All core RPC commands包括了哪些命令， static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) { RegisterBlockchainRPCCommands(t); RegisterNetRPCCommands(t); RegisterMiscRPCCommands(t); RegisterMiningRPCCommands(t); RegisterRawTransactionRPCCommands(t); } 可见这句代码注册了几乎所有核心的命令。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77982837 0x00 AppInitParameterInteraction 这个函数包括源码中的Step 2和Step 3两个，主要实现的功能是设置区块链运行时的一些参数。 0x01 Step 2 - parameter interactions // if using block pruning, then disallow txindex if (gArgs.GetArg(&quot;-prune&quot;, 0)) { if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); } -prune参数表示启用区块修剪(block pruning)，根据bitcoin release note中的描述， Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 我们知道在比特币运行的本地环境中，有四种类型的数据（在Linux环境下查看~/.bitcoin/目录）， raw block，从网络中接收的原始区块信息，对应文件为blk***.dat undo data，在进行chain reorganization时使用的数据，对应文件为rev***.dat。Chain reorganization是指某一个节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行Chain reorganization，所以这个操作只是针对某一个节点而言的。 block index，区块索引，每一个区块都有一个唯一的索引，对应文件为~/.bitcoin/blocks/index下的.ldblevel db数据库文件。 UTXO，Unspent transaction output，表示所有未花费的交易，对应文件为~/.bitcoin/chainstate/中的.ldb文件。 而block pruing删除的就是raw block和undo data两种数据，通过-prune=N参数N来指定raw block + undo data数据的大小，单位为MB。 N的最小值为550，代表288个区块的大小，按照每个block 10 Min的速率，代表2天的时间。 因为block pruning需要删除一些区块的信息，而-txindex是对所有交易建立索引，所以这两者不兼容，如果同时设置了，那么则提示错误。 // -bind and -whitebind can&#39;t be set when not listening size_t nUserBind = gArgs.GetArgs(&quot;-bind&quot;).size() + gArgs.GetArgs(&quot;-whitebind&quot;).size(); if (nUserBind != 0 &amp;&amp; !gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN)) { return InitError(&quot;Cannot set -bind or -whitebind together with -listen=0&quot;); } 接下来这段代码检测-listen和bind之间的冲突问题，也就是如果设置了bind的地址而没有设置listen那么就会报错并退出程序。 // Make sure enough file descriptors are available int nBind = std::max(nUserBind, size_t(1)); nUserMaxConnections = gArgs.GetArg(&quot;-maxconnections&quot;, DEFAULT_MAX_PEER_CONNECTIONS); nMaxConnections = std::max(nUserMaxConnections, 0); // Trim requested connection counts, to fit into system limitations nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), 0); nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS); if (nFD &lt; MIN_CORE_FILEDESCRIPTORS) return InitError(_(&quot;Not enough file descriptors available.&quot;)); nMaxConnections = std::min(nFD - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS, nMaxConnections); if (nMaxConnections &lt; nUserMaxConnections) InitWarning(strprintf(_(&quot;Reducing -maxconnections from %d to %d, because of system limitations.&quot;), nUserMaxConnections, nMaxConnections)); 这段代码中注释的意思是确保有足够的文件描述符，文件描述符又是什么呢？ 转载： http://blog.csdn.net/cywosp/article/details/38965239 在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中*最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话*。 内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一。 从上述文章中我们知道文件描述符就是一个打开文件的索引，首先代码计算了用户设置的bind的地址数量nBind，然后或者命令行中的-maxconnections，这个参数的默认值为125。 // src/net.h line 75 /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 然后开始计算最大连接数，公式中涉及到几个变量，分别位于如下位置， // src/compat.h line 27 #define FD_SETSIZE 1024 // max number of fds in fd_set // src/init.cpp line 89 #define MIN_CORE_FILEDESCRIPTORS 150 // src/net.h line 61 /** Maximum number of addnode outgoing nodes */ static const int MAX_ADDNODE_CONNECTIONS = 8; FD_SETSIZ：如上述参考的文章中所说，代表系统对单个进程的用户级限制，值为1024。 MIN_CORE_FILEDESCRIPTORS：直译为最小核心文件描述符数量，但并不懂含义= = MAX_ADDNODE_CONNECTIONS：最大addnode连接数，不懂含义= = 虽然还没有明白这个公式的原理，但是功能大概明白了，首先判断文件描述符的数量是否够用，如果不够用那么直接报错并退出程序；然后判断命令行设置的-maxconnections是否超过了系统支持的最大连接数，如果超过了，那么就提示强制设置为系统的最大连接数。 0x02 Step 3: parameter-to-internal-flags if (gArgs.IsArgSet(&quot;-debug&quot;)) { // Special-case: if -debug=0/-nodebug is set, turn off debugging messages const std::vector&lt;std::string&gt; categories = gArgs.GetArgs(&quot;-debug&quot;); if (find(categories.begin(), categories.end(), std::string(&quot;0&quot;)) == categories.end()) { for (const auto&amp; cat : categories) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debug&quot;, cat)); continue; } logCategories |= flag; } } } // Now remove the logging categories which were explicitly excluded for (const std::string&amp; cat : gArgs.GetArgs(&quot;-debugexclude&quot;)) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debugexclude&quot;, cat)); continue; } logCategories &amp;= ~flag; } 首先的一段代码是判断应该对哪些目录写入调试日志，所有的目录包括以下类型(src/util.cpp line 220)， const CLogCategoryDesc LogCategories[] = { {BCLog::NONE, &quot;0&quot;}, {BCLog::NET, &quot;net&quot;}, {BCLog::TOR, &quot;tor&quot;}, {BCLog::MEMPOOL, &quot;mempool&quot;}, {BCLog::HTTP, &quot;http&quot;}, {BCLog::BENCH, &quot;bench&quot;}, {BCLog::ZMQ, &quot;zmq&quot;}, {BCLog::DB, &quot;db&quot;}, {BCLog::RPC, &quot;rpc&quot;}, {BCLog::ESTIMATEFEE, &quot;estimatefee&quot;}, {BCLog::ADDRMAN, &quot;addrman&quot;}, {BCLog::SELECTCOINS, &quot;selectcoins&quot;}, {BCLog::REINDEX, &quot;reindex&quot;}, {BCLog::CMPCTBLOCK, &quot;cmpctblock&quot;}, {BCLog::RAND, &quot;rand&quot;}, {BCLog::PRUNE, &quot;prune&quot;}, {BCLog::PROXY, &quot;proxy&quot;}, {BCLog::MEMPOOLREJ, &quot;mempoolrej&quot;}, {BCLog::LIBEVENT, &quot;libevent&quot;}, {BCLog::COINDB, &quot;coindb&quot;}, {BCLog::QT, &quot;qt&quot;}, {BCLog::LEVELDB, &quot;leveldb&quot;}, {BCLog::ALL, &quot;1&quot;}, {BCLog::ALL, &quot;all&quot;}, }; 每个目录都对应了一个编号，代码中的logCategories变量就是记录所有的日志目录的集合，类型是uint32_t，而目录对应的编号每一个都对应32位中的一位，所以每做一次|操作，就表示将当前的目录编号加进集合。而后面的-debugexclude参数就是从集合中删除掉不想记录日志的目录，这时使用的是&amp;= ~flag操作，~表示每一位取反，与上反码就表示将当前的目录编号从集合中去掉。 再接下来一段代码中的几个if语句就是检查一下不支持的参数，或者有变更的参数命令，比较容易理解。 // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(gArgs.GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } fCheckBlockIndex = gArgs.GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = gArgs.GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); 根据帮助信息中的解释， -checkmempool：表示每隔多少个交易进行一次sanity check。 -checkblockindex：每隔一段时间检查mapBlockIndex、setBlockIndexCandidates、chainActive和mapBlockUnlinked变量的一致性。 -checkpoints：该变量默认为1，表示不验证当前已经存在的链；如果为0，表示要检查一些校验点的区块信息是否正确，所有校验点的信息也都保存在chainparams中的checkpointdata中。 代码首先判断chainparams中的DefaultConsistencyChecks是否为true，如果这个变量为false，那么ratio=0，也就是不进行sanity check。Sanity check之前在http://blog.csdn.net/pure_lady/article/details/77776716#t2中CTxMemPool类中介绍过，表示检查mempool中所有交易的一致性（没有双花，所有的输入都是合法的）。对于chainparams这个变量的也在http://blog.csdn.net/pure_lady/article/details/77895680中的SelectParams函数中介绍过，首先根据设置的网络MAIN、TESTNET或者REGTEST选择相应的参数，三个网络根据src/chainparams.cpp中给参数定义不同的值，对于DefaultConsistencyChecks这个参数，MAIN和TESTNET都为false，而REGTEST中此变量为true。 hashAssumeValid = uint256S(gArgs.GetArg(&quot;-assumevalid&quot;, chainparams.GetConsensus().defaultAssumeValid.GetHex())); if (!hashAssumeValid.IsNull()) LogPrintf(&quot;Assuming ancestors of block %s have valid signatures.\n&quot;, hashAssumeValid.GetHex()); else LogPrintf(&quot;Validating signatures for all blocks.\n&quot;); -assumevalid=blockid：表示在blockid之前的所有区块都假设正确的，也就是不用再去验证。如果没有设置，那么就要验证之前所有区块的签名信息。 // mempool limits int64_t nMempoolSizeMax = gArgs.GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = gArgs.GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting. if (gArgs.IsArgSet(&quot;-incrementalrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;incrementalrelayfee&quot;, gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;))); incrementalRelayFee = CFeeRate(n); } 接下来这段代码首先计算mempool的最大值，后面乘以1000000是将单位从MB转换成B，然后计算最小的限制，其中，-limitdescendantsize的含义如下，后面乘以1000将单位从KB转化成B，再乘以40表示最小可以容纳40个这个的交易族。 -limitdescendantsize：如果某个交易在mempool中所有的祖先size之和超过该限制值，那么则拒绝接受该交易。单位为KB。 在每个节点内部都可以设置以下几种费用来避免接收过多的交易， minrelaytxfee：最小的转发费用，如果交易费小于这个值，节点就直接忽略该交易。默认值为0.00001 BTC/KB。 dustrelayfee：用来判定一笔交易时候是否是dust tx，如果是的话则忽略该交易。默认值为0.00001BTC/KB。 incrementalrelayfee：用来改变mempool最低交易费用的变量，当mempool中的交易数量超过阈值时，交易费用阈值便会增加，增加的程度就由incrementalrelayfee决定。默认值为0.00001BTC/KB。 节点交易处理流程 所以一个full-node对交易的处理流程如下：（1）首先判断交易的费用之和是否大于minrelayfee；（2）然后判断是否是dustrelayfee，如果是的话就转发给其他节点，自己忽略该交易；（3）最后判断费用是否满足当前的费用条件，当前的费用会根据交易数量动态的变化，当交易数量过多时，增加，交易减少时，也减小。 源码中这地方就是判断命令行中是否设置了-incrementalrelayfee，如果设置了就设置变量incrementalRelayFee。 设置脚本验证线程数量 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = gArgs.GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; -par=N ：设置脚本验证线程数量，取值范围为[-2,16]，小于0表示令N个保持空闲，0表示自动检测，1表示不允许并行，大于等于2表示同一时刻最大线程数量，默认值为0。 其中MAX_SCRIPTCHECK_THREADS定义的值为16。 设置prune保留的文件大小 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nPruneArg = gArgs.GetArg(&quot;-prune&quot;, 0); if (nPruneArg &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024; if (nPruneArg == 1) { // manual pruning: -prune=1 LogPrintf(&quot;Block pruning enabled. Use RPC call pruneblockchain(height) to manually prune block and undo files.\n&quot;); nPruneTarget = std::numeric_limits&lt;uint64_t&gt;::max(); fPruneMode = true; } else if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } -prune参数在Step 2中已经介绍过，用来删除已经验证过的区块，取值有以下几种： 0：默认值，表示禁止该功能。 1：表示允许手动使用RPC命令删除旧的区块。 大于等于550：表示允许保存的raw block + undo data文件总大小，其中550MB = MIN_DISK_SPACE_FOR_BLOCK_FILES。 注册RPC命令 RegisterAllCoreRPCCommands(tableRPC); #ifdef ENABLE_WALLET RegisterWalletRPCCommands(tableRPC); #endif 所谓注册RPC命令，其实解释将信号和处理函数connect起来，方式就是使用boost的signal/slot模式，但是这里做的只是将一些指令添加到一个类型为CRPCTable的tableRPC变量中，这个tableRPC维护了所有的命令和对应的处理函数，收到相应的RPC命令是再调用CRPCTable类中execute函数执行请求。 再看看All core RPC commands包括了哪些命令， static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) { RegisterBlockchainRPCCommands(t); RegisterNetRPCCommands(t); RegisterMiscRPCCommands(t); RegisterMiningRPCCommands(t); RegisterRawTransactionRPCCommands(t); } 可见这句代码注册了几乎所有核心的命令。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/14/aaf8c98bc2a30aeee86ffaa339c627b1.html" />
<meta property="og:url" content="https://mlh.app/2017/09/14/aaf8c98bc2a30aeee86ffaa339c627b1.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77982837 0x00 AppInitParameterInteraction 这个函数包括源码中的Step 2和Step 3两个，主要实现的功能是设置区块链运行时的一些参数。 0x01 Step 2 - parameter interactions // if using block pruning, then disallow txindex if (gArgs.GetArg(&quot;-prune&quot;, 0)) { if (gArgs.GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); } -prune参数表示启用区块修剪(block pruning)，根据bitcoin release note中的描述， Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 我们知道在比特币运行的本地环境中，有四种类型的数据（在Linux环境下查看~/.bitcoin/目录）， raw block，从网络中接收的原始区块信息，对应文件为blk***.dat undo data，在进行chain reorganization时使用的数据，对应文件为rev***.dat。Chain reorganization是指某一个节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行Chain reorganization，所以这个操作只是针对某一个节点而言的。 block index，区块索引，每一个区块都有一个唯一的索引，对应文件为~/.bitcoin/blocks/index下的.ldblevel db数据库文件。 UTXO，Unspent transaction output，表示所有未花费的交易，对应文件为~/.bitcoin/chainstate/中的.ldb文件。 而block pruing删除的就是raw block和undo data两种数据，通过-prune=N参数N来指定raw block + undo data数据的大小，单位为MB。 N的最小值为550，代表288个区块的大小，按照每个block 10 Min的速率，代表2天的时间。 因为block pruning需要删除一些区块的信息，而-txindex是对所有交易建立索引，所以这两者不兼容，如果同时设置了，那么则提示错误。 // -bind and -whitebind can&#39;t be set when not listening size_t nUserBind = gArgs.GetArgs(&quot;-bind&quot;).size() + gArgs.GetArgs(&quot;-whitebind&quot;).size(); if (nUserBind != 0 &amp;&amp; !gArgs.GetBoolArg(&quot;-listen&quot;, DEFAULT_LISTEN)) { return InitError(&quot;Cannot set -bind or -whitebind together with -listen=0&quot;); } 接下来这段代码检测-listen和bind之间的冲突问题，也就是如果设置了bind的地址而没有设置listen那么就会报错并退出程序。 // Make sure enough file descriptors are available int nBind = std::max(nUserBind, size_t(1)); nUserMaxConnections = gArgs.GetArg(&quot;-maxconnections&quot;, DEFAULT_MAX_PEER_CONNECTIONS); nMaxConnections = std::max(nUserMaxConnections, 0); // Trim requested connection counts, to fit into system limitations nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), 0); nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS); if (nFD &lt; MIN_CORE_FILEDESCRIPTORS) return InitError(_(&quot;Not enough file descriptors available.&quot;)); nMaxConnections = std::min(nFD - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS, nMaxConnections); if (nMaxConnections &lt; nUserMaxConnections) InitWarning(strprintf(_(&quot;Reducing -maxconnections from %d to %d, because of system limitations.&quot;), nUserMaxConnections, nMaxConnections)); 这段代码中注释的意思是确保有足够的文件描述符，文件描述符又是什么呢？ 转载： http://blog.csdn.net/cywosp/article/details/38965239 在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中*最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话*。 内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一。 从上述文章中我们知道文件描述符就是一个打开文件的索引，首先代码计算了用户设置的bind的地址数量nBind，然后或者命令行中的-maxconnections，这个参数的默认值为125。 // src/net.h line 75 /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 然后开始计算最大连接数，公式中涉及到几个变量，分别位于如下位置， // src/compat.h line 27 #define FD_SETSIZE 1024 // max number of fds in fd_set // src/init.cpp line 89 #define MIN_CORE_FILEDESCRIPTORS 150 // src/net.h line 61 /** Maximum number of addnode outgoing nodes */ static const int MAX_ADDNODE_CONNECTIONS = 8; FD_SETSIZ：如上述参考的文章中所说，代表系统对单个进程的用户级限制，值为1024。 MIN_CORE_FILEDESCRIPTORS：直译为最小核心文件描述符数量，但并不懂含义= = MAX_ADDNODE_CONNECTIONS：最大addnode连接数，不懂含义= = 虽然还没有明白这个公式的原理，但是功能大概明白了，首先判断文件描述符的数量是否够用，如果不够用那么直接报错并退出程序；然后判断命令行设置的-maxconnections是否超过了系统支持的最大连接数，如果超过了，那么就提示强制设置为系统的最大连接数。 0x02 Step 3: parameter-to-internal-flags if (gArgs.IsArgSet(&quot;-debug&quot;)) { // Special-case: if -debug=0/-nodebug is set, turn off debugging messages const std::vector&lt;std::string&gt; categories = gArgs.GetArgs(&quot;-debug&quot;); if (find(categories.begin(), categories.end(), std::string(&quot;0&quot;)) == categories.end()) { for (const auto&amp; cat : categories) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debug&quot;, cat)); continue; } logCategories |= flag; } } } // Now remove the logging categories which were explicitly excluded for (const std::string&amp; cat : gArgs.GetArgs(&quot;-debugexclude&quot;)) { uint32_t flag = 0; if (!GetLogCategory(&amp;flag, &amp;cat)) { InitWarning(strprintf(_(&quot;Unsupported logging category %s=%s.&quot;), &quot;-debugexclude&quot;, cat)); continue; } logCategories &amp;= ~flag; } 首先的一段代码是判断应该对哪些目录写入调试日志，所有的目录包括以下类型(src/util.cpp line 220)， const CLogCategoryDesc LogCategories[] = { {BCLog::NONE, &quot;0&quot;}, {BCLog::NET, &quot;net&quot;}, {BCLog::TOR, &quot;tor&quot;}, {BCLog::MEMPOOL, &quot;mempool&quot;}, {BCLog::HTTP, &quot;http&quot;}, {BCLog::BENCH, &quot;bench&quot;}, {BCLog::ZMQ, &quot;zmq&quot;}, {BCLog::DB, &quot;db&quot;}, {BCLog::RPC, &quot;rpc&quot;}, {BCLog::ESTIMATEFEE, &quot;estimatefee&quot;}, {BCLog::ADDRMAN, &quot;addrman&quot;}, {BCLog::SELECTCOINS, &quot;selectcoins&quot;}, {BCLog::REINDEX, &quot;reindex&quot;}, {BCLog::CMPCTBLOCK, &quot;cmpctblock&quot;}, {BCLog::RAND, &quot;rand&quot;}, {BCLog::PRUNE, &quot;prune&quot;}, {BCLog::PROXY, &quot;proxy&quot;}, {BCLog::MEMPOOLREJ, &quot;mempoolrej&quot;}, {BCLog::LIBEVENT, &quot;libevent&quot;}, {BCLog::COINDB, &quot;coindb&quot;}, {BCLog::QT, &quot;qt&quot;}, {BCLog::LEVELDB, &quot;leveldb&quot;}, {BCLog::ALL, &quot;1&quot;}, {BCLog::ALL, &quot;all&quot;}, }; 每个目录都对应了一个编号，代码中的logCategories变量就是记录所有的日志目录的集合，类型是uint32_t，而目录对应的编号每一个都对应32位中的一位，所以每做一次|操作，就表示将当前的目录编号加进集合。而后面的-debugexclude参数就是从集合中删除掉不想记录日志的目录，这时使用的是&amp;= ~flag操作，~表示每一位取反，与上反码就表示将当前的目录编号从集合中去掉。 再接下来一段代码中的几个if语句就是检查一下不支持的参数，或者有变更的参数命令，比较容易理解。 // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(gArgs.GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } fCheckBlockIndex = gArgs.GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = gArgs.GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); 根据帮助信息中的解释， -checkmempool：表示每隔多少个交易进行一次sanity check。 -checkblockindex：每隔一段时间检查mapBlockIndex、setBlockIndexCandidates、chainActive和mapBlockUnlinked变量的一致性。 -checkpoints：该变量默认为1，表示不验证当前已经存在的链；如果为0，表示要检查一些校验点的区块信息是否正确，所有校验点的信息也都保存在chainparams中的checkpointdata中。 代码首先判断chainparams中的DefaultConsistencyChecks是否为true，如果这个变量为false，那么ratio=0，也就是不进行sanity check。Sanity check之前在http://blog.csdn.net/pure_lady/article/details/77776716#t2中CTxMemPool类中介绍过，表示检查mempool中所有交易的一致性（没有双花，所有的输入都是合法的）。对于chainparams这个变量的也在http://blog.csdn.net/pure_lady/article/details/77895680中的SelectParams函数中介绍过，首先根据设置的网络MAIN、TESTNET或者REGTEST选择相应的参数，三个网络根据src/chainparams.cpp中给参数定义不同的值，对于DefaultConsistencyChecks这个参数，MAIN和TESTNET都为false，而REGTEST中此变量为true。 hashAssumeValid = uint256S(gArgs.GetArg(&quot;-assumevalid&quot;, chainparams.GetConsensus().defaultAssumeValid.GetHex())); if (!hashAssumeValid.IsNull()) LogPrintf(&quot;Assuming ancestors of block %s have valid signatures.\\n&quot;, hashAssumeValid.GetHex()); else LogPrintf(&quot;Validating signatures for all blocks.\\n&quot;); -assumevalid=blockid：表示在blockid之前的所有区块都假设正确的，也就是不用再去验证。如果没有设置，那么就要验证之前所有区块的签名信息。 // mempool limits int64_t nMempoolSizeMax = gArgs.GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = gArgs.GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting. if (gArgs.IsArgSet(&quot;-incrementalrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;incrementalrelayfee&quot;, gArgs.GetArg(&quot;-incrementalrelayfee&quot;, &quot;&quot;))); incrementalRelayFee = CFeeRate(n); } 接下来这段代码首先计算mempool的最大值，后面乘以1000000是将单位从MB转换成B，然后计算最小的限制，其中，-limitdescendantsize的含义如下，后面乘以1000将单位从KB转化成B，再乘以40表示最小可以容纳40个这个的交易族。 -limitdescendantsize：如果某个交易在mempool中所有的祖先size之和超过该限制值，那么则拒绝接受该交易。单位为KB。 在每个节点内部都可以设置以下几种费用来避免接收过多的交易， minrelaytxfee：最小的转发费用，如果交易费小于这个值，节点就直接忽略该交易。默认值为0.00001 BTC/KB。 dustrelayfee：用来判定一笔交易时候是否是dust tx，如果是的话则忽略该交易。默认值为0.00001BTC/KB。 incrementalrelayfee：用来改变mempool最低交易费用的变量，当mempool中的交易数量超过阈值时，交易费用阈值便会增加，增加的程度就由incrementalrelayfee决定。默认值为0.00001BTC/KB。 节点交易处理流程 所以一个full-node对交易的处理流程如下：（1）首先判断交易的费用之和是否大于minrelayfee；（2）然后判断是否是dustrelayfee，如果是的话就转发给其他节点，自己忽略该交易；（3）最后判断费用是否满足当前的费用条件，当前的费用会根据交易数量动态的变化，当交易数量过多时，增加，交易减少时，也减小。 源码中这地方就是判断命令行中是否设置了-incrementalrelayfee，如果设置了就设置变量incrementalRelayFee。 设置脚本验证线程数量 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = gArgs.GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; -par=N ：设置脚本验证线程数量，取值范围为[-2,16]，小于0表示令N个保持空闲，0表示自动检测，1表示不允许并行，大于等于2表示同一时刻最大线程数量，默认值为0。 其中MAX_SCRIPTCHECK_THREADS定义的值为16。 设置prune保留的文件大小 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nPruneArg = gArgs.GetArg(&quot;-prune&quot;, 0); if (nPruneArg &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024; if (nPruneArg == 1) { // manual pruning: -prune=1 LogPrintf(&quot;Block pruning enabled. Use RPC call pruneblockchain(height) to manually prune block and undo files.\\n&quot;); nPruneTarget = std::numeric_limits&lt;uint64_t&gt;::max(); fPruneMode = true; } else if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } -prune参数在Step 2中已经介绍过，用来删除已经验证过的区块，取值有以下几种： 0：默认值，表示禁止该功能。 1：表示允许手动使用RPC命令删除旧的区块。 大于等于550：表示允许保存的raw block + undo data文件总大小，其中550MB = MIN_DISK_SPACE_FOR_BLOCK_FILES。 注册RPC命令 RegisterAllCoreRPCCommands(tableRPC); #ifdef ENABLE_WALLET RegisterWalletRPCCommands(tableRPC); #endif 所谓注册RPC命令，其实解释将信号和处理函数connect起来，方式就是使用boost的signal/slot模式，但是这里做的只是将一些指令添加到一个类型为CRPCTable的tableRPC变量中，这个tableRPC维护了所有的命令和对应的处理函数，收到相应的RPC命令是再调用CRPCTable类中execute函数执行请求。 再看看All core RPC commands包括了哪些命令， static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) { RegisterBlockchainRPCCommands(t); RegisterNetRPCCommands(t); RegisterMiscRPCCommands(t); RegisterMiningRPCCommands(t); RegisterRawTransactionRPCCommands(t); } 可见这句代码注册了几乎所有核心的命令。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/14/aaf8c98bc2a30aeee86ffaa339c627b1.html","headline":"比特币源码解析(14) - 可执行程序 - Bitcoind-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)","dateModified":"2017-09-14T00:00:00+08:00","datePublished":"2017-09-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/14/aaf8c98bc2a30aeee86ffaa339c627b1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码解析(14) - 可执行程序 - Bitcoind-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77982837 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2 id="0x00-appinitparameterinteraction">0x00 AppInitParameterInteraction</h2> 
  <p>这个函数包括源码中的Step 2和Step 3两个，主要实现的功能是设置区块链运行时的一些参数。</p> 
  <h2 id="0x01-step-2-parameter-interactions">0x01 Step 2 - parameter interactions</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs bash">    // <span class="hljs-keyword">if</span> using block pruning, <span class="hljs-keyword">then</span> disallow txindex
    <span class="hljs-keyword">if</span> (gArgs.GetArg(<span class="hljs-string">"-prune"</span>, <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">if</span> (gArgs.GetBoolArg(<span class="hljs-string">"-txindex"</span>, DEFAULT_TXINDEX))
            <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Prune mode is incompatible with -txindex."</span>));
    }</code></pre> 
  <p><code>-prune</code>参数表示启用区块修剪(block pruning)，根据<a href="https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#block-file-pruning" rel="nofollow" target="_blank">bitcoin release note</a>中的描述，</p> 
  <blockquote> 
   <p>Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain.</p> 
   <p>区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。</p> 
  </blockquote> 
  <p>我们知道在比特币运行的本地环境中，有四种类型的数据（在Linux环境下查看<code>~/.bitcoin/</code>目录），</p> 
  <ul> 
   <li>raw block，从网络中接收的原始区块信息，对应文件为<code>blk***.dat</code></li> 
   <li>undo data，在进行chain reorganization时使用的数据，对应文件为<code>rev***.dat</code>。Chain reorganization是指某一个节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行Chain reorganization，所以这个操作只是针对某一个节点而言的。</li> 
   <li>block index，区块索引，每一个区块都有一个唯一的索引，对应文件为<code>~/.bitcoin/blocks/index</code>下的<code>.ldb</code>level db数据库文件。</li> 
   <li>UTXO，Unspent transaction output，表示所有未花费的交易，对应文件为<code>~/.bitcoin/chainstate/</code>中的<code>.ldb</code>文件。</li> 
  </ul> 
  <p>而block pruing删除的就是raw block和undo data两种数据，通过<code>-prune=N</code>参数<code>N</code>来指定raw block + undo data数据的大小，单位为<code>MB</code>。 <code>N</code>的最小值为<code>550</code>，代表288个区块的大小，按照每个block 10 Min的速率，代表2天的时间。</p> 
  <p>因为block pruning需要删除一些区块的信息，而<code>-txindex</code>是对所有交易建立索引，所以这两者不兼容，如果同时设置了，那么则提示错误。</p> 
  <pre class="prettyprint"><code class="language-c++ hljs sql">// -bind and -whitebind can't be <span class="hljs-operator"><span class="hljs-keyword">set</span> <span class="hljs-keyword">when</span> <span class="hljs-keyword">not</span> listening size_t nUserBind = gArgs.GetArgs(<span class="hljs-string">"-bind"</span>).<span class="hljs-keyword">size</span>() + gArgs.GetArgs(<span class="hljs-string">"-whitebind"</span>).<span class="hljs-keyword">size</span>();</span>
if (nUserBind != 0 &amp;&amp; !gArgs.GetBoolArg("-listen", DEFAULT_LISTEN)) {
    return InitError("Cannot <span class="hljs-operator"><span class="hljs-keyword">set</span> -bind <span class="hljs-keyword">or</span> -whitebind together <span class="hljs-keyword">with</span> -listen=<span class="hljs-number">0</span><span class="hljs-string">"); }</span></span></code></pre> 
  <p>接下来这段代码检测<code>-listen</code>和<code>bind</code>之间的冲突问题，也就是如果设置了<code>bind</code>的地址而没有设置<code>listen</code>那么就会报错并退出程序。</p> 
  <pre class="prettyprint"><code class="language-c++ hljs mel">    <span class="hljs-comment">// Make sure enough file descriptors are available</span>
    <span class="hljs-keyword">int</span> nBind = std::<span class="hljs-keyword">max</span>(nUserBind, size_t(<span class="hljs-number">1</span>));
    nUserMaxConnections = gArgs.GetArg(<span class="hljs-string">"-maxconnections"</span>, DEFAULT_MAX_PEER_CONNECTIONS);
    nMaxConnections = std::<span class="hljs-keyword">max</span>(nUserMaxConnections, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// Trim requested connection counts, to fit into system limitations</span>
    nMaxConnections = std::<span class="hljs-keyword">max</span>(std::<span class="hljs-keyword">min</span>(nMaxConnections, (<span class="hljs-keyword">int</span>)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), <span class="hljs-number">0</span>);
    nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS);
    <span class="hljs-keyword">if</span> (nFD &lt; MIN_CORE_FILEDESCRIPTORS)
        <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Not enough file descriptors available."</span>));
    nMaxConnections = std::<span class="hljs-keyword">min</span>(nFD - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS, nMaxConnections);

    <span class="hljs-keyword">if</span> (nMaxConnections &lt; nUserMaxConnections)
        InitWarning(strprintf(_(<span class="hljs-string">"Reducing -maxconnections from %d to %d, because of system limitations."</span>), nUserMaxConnections, nMaxConnections));
</code></pre> 
  <p>这段代码中注释的意思是确保有足够的文件描述符，文件描述符又是什么呢？</p> 
  <blockquote> 
   <p>转载： <a href="http://blog.csdn.net/cywosp/article/details/38965239" rel="nofollow" target="_blank">http://blog.csdn.net/cywosp/article/details/38965239</a></p> 
   <p>在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。<strong>POSIX标准要求每次打开文件时（含socket）必须使用当前进程中<em>*</em></strong>最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话*。</p> 
   <p>内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一。</p> 
  </blockquote> 
  <p>从上述文章中我们知道文件描述符就是一个打开文件的索引，首先代码计算了用户设置的bind的地址数量<code>nBind</code>，然后或者命令行中的<code>-maxconnections</code>，这个参数的默认值为125。</p> 
  <pre class="prettyprint"><code class="language-c++ hljs java"><span class="hljs-comment">// src/net.h line 75</span>
<span class="hljs-javadoc">/** The maximum number of peer connections to maintain. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_MAX_PEER_CONNECTIONS = <span class="hljs-number">125</span>;</code></pre> 
  <p>然后开始计算最大连接数，公式中涉及到几个变量，分别位于如下位置，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs java"><span class="hljs-comment">// src/compat.h line 27</span>
#define FD_SETSIZE <span class="hljs-number">1024</span> <span class="hljs-comment">// max number of fds in fd_set</span>

<span class="hljs-comment">// src/init.cpp line 89</span>
#define MIN_CORE_FILEDESCRIPTORS <span class="hljs-number">150</span>

<span class="hljs-comment">// src/net.h line 61</span>
<span class="hljs-javadoc">/** Maximum number of addnode outgoing nodes */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_ADDNODE_CONNECTIONS = <span class="hljs-number">8</span>;</code></pre> 
  <ul> 
   <li>FD_SETSIZ：如上述参考的文章中所说，代表系统对单个进程的用户级限制，值为1024。</li> 
   <li>MIN_CORE_FILEDESCRIPTORS：直译为最小核心文件描述符数量，但并不懂含义= =</li> 
   <li>MAX_ADDNODE_CONNECTIONS：最大addnode连接数，不懂含义= =</li> 
  </ul> 
  <p>虽然还没有明白这个公式的原理，但是功能大概明白了，首先判断文件描述符的数量是否够用，如果不够用那么直接报错并退出程序；然后判断命令行设置的<code>-maxconnections</code>是否超过了系统支持的最大连接数，如果超过了，那么就提示强制设置为系统的最大连接数。</p> 
  <h2 id="0x02-step-3-parameter-to-internal-flags">0x02 Step 3: parameter-to-internal-flags</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    <span class="hljs-keyword">if</span> (gArgs.IsArgSet(<span class="hljs-string">"-debug"</span>)) {
        <span class="hljs-comment">// Special-case: if -debug=0/-nodebug is set, turn off debugging messages</span>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> categories = gArgs.GetArgs(<span class="hljs-string">"-debug"</span>);

        <span class="hljs-keyword">if</span> (find(categories.begin(), categories.end(), <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"0"</span>)) == categories.end()) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; cat : categories) {
                uint32_t flag = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (!GetLogCategory(&amp;flag, &amp;cat)) {
                    InitWarning(strprintf(_(<span class="hljs-string">"Unsupported logging category %s=%s."</span>), <span class="hljs-string">"-debug"</span>, cat));
                    <span class="hljs-keyword">continue</span>;
                }
                logCategories |= flag;
            }
        }
    }

    <span class="hljs-comment">// Now remove the logging categories which were explicitly excluded</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; cat : gArgs.GetArgs(<span class="hljs-string">"-debugexclude"</span>)) {
        uint32_t flag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (!GetLogCategory(&amp;flag, &amp;cat)) {
            InitWarning(strprintf(_(<span class="hljs-string">"Unsupported logging category %s=%s."</span>), <span class="hljs-string">"-debugexclude"</span>, cat));
            <span class="hljs-keyword">continue</span>;
        }
        logCategories &amp;= ~flag;
    }</code></pre> 
  <p>首先的一段代码是判断应该对哪些目录写入调试日志，所有的目录包括以下类型(<code>src/util.cpp line 220</code>)，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs autohotkey">const CLogCategoryDesc LogCategories[] =
{
<span class="hljs-label"> {BCLog::</span>NONE, <span class="hljs-string">"0"</span>},
<span class="hljs-label"> {BCLog::</span>NET, <span class="hljs-string">"net"</span>},
<span class="hljs-label"> {BCLog::</span>TOR, <span class="hljs-string">"tor"</span>},
<span class="hljs-label"> {BCLog::</span>MEMPOOL, <span class="hljs-string">"mempool"</span>},
<span class="hljs-label"> {BCLog::</span>HTTP, <span class="hljs-string">"http"</span>},
<span class="hljs-label"> {BCLog::</span>BENCH, <span class="hljs-string">"bench"</span>},
<span class="hljs-label"> {BCLog::</span>ZMQ, <span class="hljs-string">"zmq"</span>},
<span class="hljs-label"> {BCLog::</span>DB, <span class="hljs-string">"db"</span>},
<span class="hljs-label"> {BCLog::</span>RPC, <span class="hljs-string">"rpc"</span>},
<span class="hljs-label"> {BCLog::</span>ESTIMATEFEE, <span class="hljs-string">"estimatefee"</span>},
<span class="hljs-label"> {BCLog::</span>ADDRMAN, <span class="hljs-string">"addrman"</span>},
<span class="hljs-label"> {BCLog::</span>SELECTCOINS, <span class="hljs-string">"selectcoins"</span>},
<span class="hljs-label"> {BCLog::</span>REINDEX, <span class="hljs-string">"reindex"</span>},
<span class="hljs-label"> {BCLog::</span>CMPCTBLOCK, <span class="hljs-string">"cmpctblock"</span>},
<span class="hljs-label"> {BCLog::</span>RAND, <span class="hljs-string">"rand"</span>},
<span class="hljs-label"> {BCLog::</span>PRUNE, <span class="hljs-string">"prune"</span>},
<span class="hljs-label"> {BCLog::</span>PROXY, <span class="hljs-string">"proxy"</span>},
<span class="hljs-label"> {BCLog::</span>MEMPOOLREJ, <span class="hljs-string">"mempoolrej"</span>},
<span class="hljs-label"> {BCLog::</span>LIBEVENT, <span class="hljs-string">"libevent"</span>},
<span class="hljs-label"> {BCLog::</span>COINDB, <span class="hljs-string">"coindb"</span>},
<span class="hljs-label"> {BCLog::</span>QT, <span class="hljs-string">"qt"</span>},
<span class="hljs-label"> {BCLog::</span>LEVELDB, <span class="hljs-string">"leveldb"</span>},
<span class="hljs-label"> {BCLog::</span>ALL, <span class="hljs-string">"1"</span>},
<span class="hljs-label"> {BCLog::</span>ALL, <span class="hljs-string">"all"</span>},
}<span class="hljs-comment">;</span></code></pre> 
  <p>每个目录都对应了一个编号，代码中的<code>logCategories</code>变量就是记录所有的日志目录的集合，类型是<code>uint32_t</code>，而目录对应的编号每一个都对应32位中的一位，所以每做一次<code>|</code>操作，就表示将当前的目录编号加进集合。而后面的<code>-debugexclude</code>参数就是从集合中删除掉不想记录日志的目录，这时使用的是<code>&amp;= ~flag</code>操作，<code>~</code>表示每一位取反，与上反码就表示将当前的目录编号从集合中去掉。</p> 
  <p>再接下来一段代码中的几个<code>if</code>语句就是检查一下不支持的参数，或者有变更的参数命令，比较容易理解。</p> 
  <pre class="prettyprint"><code class="language-c++ hljs avrasm">    // Checkmempool <span class="hljs-keyword">and</span> checkblockindex default to true <span class="hljs-keyword">in</span> regtest mode
    int ratio = <span class="hljs-keyword">std</span>::min&lt;int&gt;(<span class="hljs-keyword">std</span>::max&lt;int&gt;(gArgs<span class="hljs-preprocessor">.GetArg</span>(<span class="hljs-string">"-checkmempool"</span>, chainparams<span class="hljs-preprocessor">.DefaultConsistencyChecks</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">0</span>), <span class="hljs-number">1000000</span>)<span class="hljs-comment">;</span>
    if (ratio != <span class="hljs-number">0</span>) {
        mempool<span class="hljs-preprocessor">.setSanityCheck</span>(<span class="hljs-number">1.0</span> / ratio)<span class="hljs-comment">;</span>
    }
    fCheckBlockIndex = gArgs<span class="hljs-preprocessor">.GetBoolArg</span>(<span class="hljs-string">"-checkblockindex"</span>, chainparams<span class="hljs-preprocessor">.DefaultConsistencyChecks</span>())<span class="hljs-comment">;</span>
    fCheckpointsEnabled = gArgs<span class="hljs-preprocessor">.GetBoolArg</span>(<span class="hljs-string">"-checkpoints"</span>, DEFAULT_CHECKPOINTS_ENABLED)<span class="hljs-comment">;</span></code></pre> 
  <p>根据帮助信息中的解释，</p> 
  <blockquote> 
   <p><code>-checkmempool</code>：表示每隔多少个交易进行一次sanity check。</p> 
   <p><code>-checkblockindex</code>：每隔一段时间检查<code>mapBlockIndex</code>、<code>setBlockIndexCandidates</code>、<code>chainActive</code>和<code>mapBlockUnlinked</code>变量的一致性。</p> 
   <p><code>-checkpoints</code>：该变量默认为1，表示不验证当前已经存在的链；如果为0，表示要检查一些校验点的区块信息是否正确，所有校验点的信息也都保存在chainparams中的checkpointdata中。</p> 
  </blockquote> 
  <p>代码首先判断<code>chainparams</code>中的<code>DefaultConsistencyChecks</code>是否为<code>true</code>，如果这个变量为<code>false</code>，那么<code>ratio=0</code>，也就是不进行sanity check。Sanity check之前在<a href="http://blog.csdn.net/pure_lady/article/details/77776716#t2" rel="nofollow" target="_blank">http://blog.csdn.net/pure_lady/article/details/77776716#t2</a>中CTxMemPool类中介绍过，表示检查mempool中所有交易的一致性（没有双花，所有的输入都是合法的）。对于<code>chainparams</code>这个变量的也在<a href="http://blog.csdn.net/pure_lady/article/details/77895680" rel="nofollow" target="_blank">http://blog.csdn.net/pure_lady/article/details/77895680</a>中的<code>SelectParams</code>函数中介绍过，首先根据设置的网络<code>MAIN</code>、<code>TESTNET</code>或者<code>REGTEST</code>选择相应的参数，三个网络根据<code>src/chainparams.cpp</code>中给参数定义不同的值，对于<code>DefaultConsistencyChecks</code>这个参数，<code>MAIN</code>和<code>TESTNET</code>都为<code>false</code>，而<code>REGTEST</code>中此变量为<code>true</code>。 </p> 
  <pre class="prettyprint"><code class="language-c++ hljs avrasm">    hashAssumeValid = uint256S(gArgs<span class="hljs-preprocessor">.GetArg</span>(<span class="hljs-string">"-assumevalid"</span>, chainparams<span class="hljs-preprocessor">.GetConsensus</span>()<span class="hljs-preprocessor">.defaultAssumeValid</span><span class="hljs-preprocessor">.GetHex</span>()))<span class="hljs-comment">;</span>
    if (!hashAssumeValid<span class="hljs-preprocessor">.IsNull</span>())
        LogPrintf(<span class="hljs-string">"Assuming ancestors of block %s have valid signatures.\n"</span>, hashAssumeValid<span class="hljs-preprocessor">.GetHex</span>())<span class="hljs-comment">;</span>
    else
        LogPrintf(<span class="hljs-string">"Validating signatures for all blocks.\n"</span>)<span class="hljs-comment">;</span></code></pre> 
  <blockquote> 
   <p><code>-assumevalid=blockid</code>：表示在<code>blockid</code>之前的所有区块都假设正确的，也就是不用再去验证。如果没有设置，那么就要验证之前所有区块的签名信息。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class="language-c++ hljs bash">    // mempool limits
    int64_t nMempoolSizeMax = gArgs.GetArg(<span class="hljs-string">"-maxmempool"</span>, DEFAULT_MAX_MEMPOOL_SIZE) * <span class="hljs-number">1000000</span>;
    int64_t nMempoolSizeM<span class="hljs-keyword">in</span> = gArgs.GetArg(<span class="hljs-string">"-limitdescendantsize"</span>, DEFAULT_DESCENDANT_SIZE_LIMIT) * <span class="hljs-number">1000</span> * <span class="hljs-number">40</span>;
    <span class="hljs-keyword">if</span> (nMempoolSizeMax &lt; <span class="hljs-number">0</span> || nMempoolSizeMax &lt; nMempoolSizeM<span class="hljs-keyword">in</span>)
        <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"-maxmempool must be at least %d MB"</span>), std::ceil(nMempoolSizeM<span class="hljs-keyword">in</span> / <span class="hljs-number">1000000.0</span>)));
    // incremental relay fee sets the minimum feerate increase necessary <span class="hljs-keyword">for</span> BIP <span class="hljs-number">125</span> replacement <span class="hljs-keyword">in</span> the mempool
    // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.
    <span class="hljs-keyword">if</span> (gArgs.IsArgSet(<span class="hljs-string">"-incrementalrelayfee"</span>))
    {
        CAmount n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (!ParseMoney(gArgs.GetArg(<span class="hljs-string">"-incrementalrelayfee"</span>, <span class="hljs-string">""</span>), n))
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"incrementalrelayfee"</span>, gArgs.GetArg(<span class="hljs-string">"-incrementalrelayfee"</span>, <span class="hljs-string">""</span>)));
        incrementalRelayFee = CFeeRate(n);
    }</code></pre> 
  <p>接下来这段代码首先计算mempool的最大值，后面乘以1000000是将单位从MB转换成B，然后计算最小的限制，其中，<code>-limitdescendantsize</code>的含义如下，后面乘以1000将单位从KB转化成B，再乘以40表示最小可以容纳40个这个的交易族。</p> 
  <blockquote> 
   <p><code>-limitdescendantsize</code>：如果某个交易在mempool中所有的祖先size之和超过该限制值，那么则拒绝接受该交易。单位为KB。</p> 
  </blockquote> 
  <p>在每个节点内部都可以设置以下几种费用来避免接收过多的交易，</p> 
  <ul> 
   <li>minrelaytxfee：最小的转发费用，如果交易费小于这个值，节点就直接忽略该交易。默认值为0.00001 BTC/KB。</li> 
   <li>dustrelayfee：用来判定一笔交易时候是否是dust tx，如果是的话则忽略该交易。默认值为0.00001BTC/KB。</li> 
   <li>incrementalrelayfee：用来改变mempool最低交易费用的变量，当mempool中的交易数量超过阈值时，交易费用阈值便会增加，增加的程度就由incrementalrelayfee决定。默认值为0.00001BTC/KB。</li> 
  </ul> 
  <h3 id="节点交易处理流程">节点交易处理流程</h3> 
  <p>所以一个full-node对交易的处理流程如下：（1）首先判断交易的费用之和是否大于minrelayfee；（2）然后判断是否是dustrelayfee，如果是的话就转发给其他节点，自己忽略该交易；（3）最后判断费用是否满足当前的费用条件，当前的费用会根据交易数量动态的变化，当交易数量过多时，增加，交易减少时，也减小。</p> 
  <p>源码中这地方就是判断命令行中是否设置了<code>-incrementalrelayfee</code>，如果设置了就设置变量<code>incrementalRelayFee</code>。</p> 
  <h3 id="设置脚本验证线程数量">设置脚本验证线程数量</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cs">    <span class="hljs-comment">// -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency</span>
    nScriptCheckThreads = gArgs.GetArg(<span class="hljs-string">"-par"</span>, DEFAULT_SCRIPTCHECK_THREADS);
    <span class="hljs-keyword">if</span> (nScriptCheckThreads &lt;= <span class="hljs-number">0</span>)
        nScriptCheckThreads += GetNumCores();
    <span class="hljs-keyword">if</span> (nScriptCheckThreads &lt;= <span class="hljs-number">1</span>)
        nScriptCheckThreads = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS)
        nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;</code></pre> 
  <blockquote> 
   <p><code>-par=N</code> ：设置脚本验证线程数量，取值范围为[-2,16]，小于0表示令N个保持空闲，0表示自动检测，1表示不允许并行，大于等于2表示同一时刻最大线程数量，默认值为0。</p> 
  </blockquote> 
  <p>其中<code>MAX_SCRIPTCHECK_THREADS</code>定义的值为16。</p> 
  <h3 id="设置prune保留的文件大小">设置prune保留的文件大小</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs lasso">    <span class="hljs-comment">// block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files</span>
    int64_t nPruneArg <span class="hljs-subst">=</span> gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-prune"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (nPruneArg <span class="hljs-subst">&lt;</span> <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Prune cannot be configured with a negative value."</span>));
    }
    nPruneTarget <span class="hljs-subst">=</span> (uint64_t) nPruneArg <span class="hljs-subst">*</span> <span class="hljs-number">1024</span> <span class="hljs-subst">*</span> <span class="hljs-number">1024</span>;
    <span class="hljs-keyword">if</span> (nPruneArg <span class="hljs-subst">==</span> <span class="hljs-number">1</span>) {  <span class="hljs-comment">// manual pruning: -prune=1</span>
        LogPrintf(<span class="hljs-string">"Block pruning enabled. Use RPC call pruneblockchain(height) to manually prune block and undo files.\n"</span>);
        nPruneTarget <span class="hljs-subst">=</span> std<span class="hljs-tag">::numeric_limits</span><span class="hljs-subst">&lt;</span>uint64_t<span class="hljs-subst">&gt;</span><span class="hljs-tag">::max</span>();
        fPruneMode <span class="hljs-subst">=</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nPruneTarget) {
        <span class="hljs-keyword">if</span> (nPruneTarget <span class="hljs-subst">&lt;</span> MIN_DISK_SPACE_FOR_BLOCK_FILES) {
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Prune configured below the minimum of %d MiB. Please use a higher number."</span>), MIN_DISK_SPACE_FOR_BLOCK_FILES <span class="hljs-subst">/</span> <span class="hljs-number">1024</span> <span class="hljs-subst">/</span> <span class="hljs-number">1024</span>));
        }
        LogPrintf(<span class="hljs-string">"Prune configured to target %uMiB on disk for block and undo files.\n"</span>, nPruneTarget <span class="hljs-subst">/</span> <span class="hljs-number">1024</span> <span class="hljs-subst">/</span> <span class="hljs-number">1024</span>);
        fPruneMode <span class="hljs-subst">=</span> <span class="hljs-literal">true</span>;
    }</code></pre> 
  <p><code>-prune</code>参数在Step 2中已经介绍过，用来删除已经验证过的区块，取值有以下几种：</p> 
  <ul> 
   <li>0：默认值，表示禁止该功能。</li> 
   <li>1：表示允许手动使用RPC命令删除旧的区块。</li> 
   <li>大于等于550：表示允许保存的raw block + undo data文件总大小，其中550MB = MIN_DISK_SPACE_FOR_BLOCK_FILES。</li> 
  </ul> 
  <h3 id="注册rpc命令">注册RPC命令</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs vala">    RegisterAllCoreRPCCommands(tableRPC);
<span class="hljs-preprocessor">#ifdef ENABLE_WALLET</span>
    RegisterWalletRPCCommands(tableRPC);
<span class="hljs-preprocessor">#endif</span></code></pre> 
  <p>所谓注册RPC命令，其实解释将信号和处理函数connect起来，方式就是使用boost的signal/slot模式，但是这里做的只是将一些指令添加到一个类型为CRPCTable的tableRPC变量中，这个tableRPC维护了所有的命令和对应的处理函数，收到相应的RPC命令是再调用CRPCTable类中execute函数执行请求。</p> 
  <p>再看看All core RPC commands包括了哪些命令，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs scss"><span class="hljs-value">static</span> <span class="hljs-value">inline</span> void <span class="hljs-function">RegisterAllCoreRPCCommands(CRPCTable &amp;t)</span>
{
    <span class="hljs-function">RegisterBlockchainRPCCommands(t)</span>;
    <span class="hljs-function">RegisterNetRPCCommands(t)</span>;
    <span class="hljs-function">RegisterMiscRPCCommands(t)</span>;
    <span class="hljs-function">RegisterMiningRPCCommands(t)</span>;
    <span class="hljs-function">RegisterRawTransactionRPCCommands(t)</span>;
}</code></pre> 
  <p>可见这句代码注册了几乎所有核心的命令。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77982837,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77982837,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
