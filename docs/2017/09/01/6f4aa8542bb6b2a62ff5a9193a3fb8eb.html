<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码解析(5) - 数据结构 - 交易-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码解析(5) - 数据结构 - 交易-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77771392 0x00 摘要 交易(transaction)是比特币甚至所有区块链中最核心的数据结构之一，可以说其他所有的模块都是为交易服务的，包括交易的产生、广播、共识、存储等等，所以我们首先从交易出发，然后逐步延伸到其他的部分。 0x01 COutPoint /** An outpoint - a combination of a transaction hash and an index n into its vout. * COutPoint主要用在交易的输入CTxIn中，用来确定当前输出的来源， * 包括前一笔交易的hash，以及对应前一笔交易中的第几个输出的序列号。 */ class COutPoint { public: uint256 hash; // 交易的哈希 uint32_t n; // 对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } ADD_SERIALIZE_METHODS; // 用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载小于号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; 0x02 CTxIn /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. * 交易的输入，包括当前输入对应前一笔交易的输出的位置，以及花费前一笔输出需要的签名脚本 * CScriptWitness是用来支持隔离见证时使用的。 */ class CTxIn { public: COutPoint prevout; // 前一笔交易输出的位置 CScript scriptSig; // 解锁脚本 uint32_t nSequence; // 序列号 CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. * 规则1：如果一笔交易中所有的SEQUENCE_FINAL都被赋值了相应的nSequence，那么nLockTime就会被禁用*/ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. * 规则2：如果设置了这个变量，那么规则1就失效了*/ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. * 规则3：如果规则1有效并且设置了此变量，那么相对锁定时间就为512秒，否则锁定时间就为1个区块*/ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. * 规则4：如果规则1有效，那么这个变量就用来从nSequence计算对应的锁定时间*/ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } // 禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 0x03 CTxOut /** An output of a transaction. It contains the public key that the next input must be able to sign with to claim it. * 交易的输出，包含金额和锁定脚本 */ class CTxOut { public: CAmount nValue; // 输出金额 CScript scriptPubKey; // 锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } // 获取dust阈值，一笔交易如果交易费小于dust阈值，就会被认为是dust tx， // 此函数在最新版本中已转移到src/policy/policy.h中 CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /** &quot;Dust&quot;是根据CTransaction中的minRelayTxFee来定义的，单位是satoshis/千字节， * 如果在一笔交易中交易费占了1/3以上，那么我们就认为该交易是&quot;Dust&quot;交易。 * 因此dust交易的金额小于 546*minRelayTxFee/1000; * 而在支持隔离见证的交易中，txout通常大小为31字节，CTxIn大小至少为67字节， * 此时dust交易的金额则一般小于 294*minRelayTxFee/1000. */ if (scriptPubKey.IsUnspendable()) // 判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(*this, SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; // 判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 0x04 CTransaction /** The basic transaction that is broadcasted on the network and contained in blocks. * A transaction can contain multiple inputs and outputs. * 下面就是在网络中广播然后被打包进区块的最基本的交易的结构，一个交易可能包含多个交易输入和输出。 */ class CTransaction { public: // Default transaction version. 默认交易版本 static const int32_t CURRENT_VERSION=2; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /** 下面这些变量都被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值； * 但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容 */ const int32_t nVersion; // 版本 const std::vector&lt;CTxIn&gt; vin; // 交易输入 const std::vector&lt;CTxOut&gt; vout; // 交易输出 const uint32_t nLockTime; // 锁定时间 private: /** Memory only. */ const uint256 hash; uint256 ComputeHash() const; public: /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction(CMutableTransaction &amp;&amp;tx); template &lt;typename Stream&gt; inline void Serialize(Stream&amp; s) const { SerializeTransaction(*this, s); } /** This deserializing constructor is provided instead of an Unserialize method. * Unserialize is not possible, since it would require overwriting const fields. */ template &lt;typename Stream&gt; CTransaction(deserialize_type, Stream&amp; s) : CTransaction(CMutableTransaction(deserialize, s)) {} bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts. CAmount GetValueOut() const; // 返回交易输出金额之和 // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. /** * Get the total transaction size in bytes, including witness data. * &quot;Total Size&quot; defined in BIP141 and BIP144. * @return Total transaction size in bytes */ unsigned int GetTotalSize() const; // 返回交易大小 bool IsCoinBase() const // 判断是否是coinbase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; bool HasWitness() const { for (size_t i = 0; i &lt; vin.size(); i++) { if (!vin[i].scriptWitness.IsNull()) { return true; } } return false; } }; 除了这个结构以外，还定义了一个CMutableTransaction其中的变量内容和CTransaction相同，但是都是可以直接修改的，但是最后广播和网络中传输的类型都是CTransaction。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77771392 0x00 摘要 交易(transaction)是比特币甚至所有区块链中最核心的数据结构之一，可以说其他所有的模块都是为交易服务的，包括交易的产生、广播、共识、存储等等，所以我们首先从交易出发，然后逐步延伸到其他的部分。 0x01 COutPoint /** An outpoint - a combination of a transaction hash and an index n into its vout. * COutPoint主要用在交易的输入CTxIn中，用来确定当前输出的来源， * 包括前一笔交易的hash，以及对应前一笔交易中的第几个输出的序列号。 */ class COutPoint { public: uint256 hash; // 交易的哈希 uint32_t n; // 对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } ADD_SERIALIZE_METHODS; // 用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载小于号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; 0x02 CTxIn /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. * 交易的输入，包括当前输入对应前一笔交易的输出的位置，以及花费前一笔输出需要的签名脚本 * CScriptWitness是用来支持隔离见证时使用的。 */ class CTxIn { public: COutPoint prevout; // 前一笔交易输出的位置 CScript scriptSig; // 解锁脚本 uint32_t nSequence; // 序列号 CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. * 规则1：如果一笔交易中所有的SEQUENCE_FINAL都被赋值了相应的nSequence，那么nLockTime就会被禁用*/ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. * 规则2：如果设置了这个变量，那么规则1就失效了*/ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. * 规则3：如果规则1有效并且设置了此变量，那么相对锁定时间就为512秒，否则锁定时间就为1个区块*/ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. * 规则4：如果规则1有效，那么这个变量就用来从nSequence计算对应的锁定时间*/ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } // 禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 0x03 CTxOut /** An output of a transaction. It contains the public key that the next input must be able to sign with to claim it. * 交易的输出，包含金额和锁定脚本 */ class CTxOut { public: CAmount nValue; // 输出金额 CScript scriptPubKey; // 锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } // 获取dust阈值，一笔交易如果交易费小于dust阈值，就会被认为是dust tx， // 此函数在最新版本中已转移到src/policy/policy.h中 CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /** &quot;Dust&quot;是根据CTransaction中的minRelayTxFee来定义的，单位是satoshis/千字节， * 如果在一笔交易中交易费占了1/3以上，那么我们就认为该交易是&quot;Dust&quot;交易。 * 因此dust交易的金额小于 546*minRelayTxFee/1000; * 而在支持隔离见证的交易中，txout通常大小为31字节，CTxIn大小至少为67字节， * 此时dust交易的金额则一般小于 294*minRelayTxFee/1000. */ if (scriptPubKey.IsUnspendable()) // 判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(*this, SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; // 判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 0x04 CTransaction /** The basic transaction that is broadcasted on the network and contained in blocks. * A transaction can contain multiple inputs and outputs. * 下面就是在网络中广播然后被打包进区块的最基本的交易的结构，一个交易可能包含多个交易输入和输出。 */ class CTransaction { public: // Default transaction version. 默认交易版本 static const int32_t CURRENT_VERSION=2; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /** 下面这些变量都被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值； * 但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容 */ const int32_t nVersion; // 版本 const std::vector&lt;CTxIn&gt; vin; // 交易输入 const std::vector&lt;CTxOut&gt; vout; // 交易输出 const uint32_t nLockTime; // 锁定时间 private: /** Memory only. */ const uint256 hash; uint256 ComputeHash() const; public: /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction(CMutableTransaction &amp;&amp;tx); template &lt;typename Stream&gt; inline void Serialize(Stream&amp; s) const { SerializeTransaction(*this, s); } /** This deserializing constructor is provided instead of an Unserialize method. * Unserialize is not possible, since it would require overwriting const fields. */ template &lt;typename Stream&gt; CTransaction(deserialize_type, Stream&amp; s) : CTransaction(CMutableTransaction(deserialize, s)) {} bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts. CAmount GetValueOut() const; // 返回交易输出金额之和 // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. /** * Get the total transaction size in bytes, including witness data. * &quot;Total Size&quot; defined in BIP141 and BIP144. * @return Total transaction size in bytes */ unsigned int GetTotalSize() const; // 返回交易大小 bool IsCoinBase() const // 判断是否是coinbase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; bool HasWitness() const { for (size_t i = 0; i &lt; vin.size(); i++) { if (!vin[i].scriptWitness.IsNull()) { return true; } } return false; } }; 除了这个结构以外，还定义了一个CMutableTransaction其中的变量内容和CTransaction相同，但是都是可以直接修改的，但是最后广播和网络中传输的类型都是CTransaction。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/01/6f4aa8542bb6b2a62ff5a9193a3fb8eb.html" />
<meta property="og:url" content="https://mlh.app/2017/09/01/6f4aa8542bb6b2a62ff5a9193a3fb8eb.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77771392 0x00 摘要 交易(transaction)是比特币甚至所有区块链中最核心的数据结构之一，可以说其他所有的模块都是为交易服务的，包括交易的产生、广播、共识、存储等等，所以我们首先从交易出发，然后逐步延伸到其他的部分。 0x01 COutPoint /** An outpoint - a combination of a transaction hash and an index n into its vout. * COutPoint主要用在交易的输入CTxIn中，用来确定当前输出的来源， * 包括前一笔交易的hash，以及对应前一笔交易中的第几个输出的序列号。 */ class COutPoint { public: uint256 hash; // 交易的哈希 uint32_t n; // 对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } ADD_SERIALIZE_METHODS; // 用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载小于号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; 0x02 CTxIn /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. * 交易的输入，包括当前输入对应前一笔交易的输出的位置，以及花费前一笔输出需要的签名脚本 * CScriptWitness是用来支持隔离见证时使用的。 */ class CTxIn { public: COutPoint prevout; // 前一笔交易输出的位置 CScript scriptSig; // 解锁脚本 uint32_t nSequence; // 序列号 CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. * 规则1：如果一笔交易中所有的SEQUENCE_FINAL都被赋值了相应的nSequence，那么nLockTime就会被禁用*/ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. * 规则2：如果设置了这个变量，那么规则1就失效了*/ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. * 规则3：如果规则1有效并且设置了此变量，那么相对锁定时间就为512秒，否则锁定时间就为1个区块*/ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. * 规则4：如果规则1有效，那么这个变量就用来从nSequence计算对应的锁定时间*/ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } // 禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 0x03 CTxOut /** An output of a transaction. It contains the public key that the next input must be able to sign with to claim it. * 交易的输出，包含金额和锁定脚本 */ class CTxOut { public: CAmount nValue; // 输出金额 CScript scriptPubKey; // 锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } // 获取dust阈值，一笔交易如果交易费小于dust阈值，就会被认为是dust tx， // 此函数在最新版本中已转移到src/policy/policy.h中 CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /** &quot;Dust&quot;是根据CTransaction中的minRelayTxFee来定义的，单位是satoshis/千字节， * 如果在一笔交易中交易费占了1/3以上，那么我们就认为该交易是&quot;Dust&quot;交易。 * 因此dust交易的金额小于 546*minRelayTxFee/1000; * 而在支持隔离见证的交易中，txout通常大小为31字节，CTxIn大小至少为67字节， * 此时dust交易的金额则一般小于 294*minRelayTxFee/1000. */ if (scriptPubKey.IsUnspendable()) // 判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(*this, SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; // 判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 0x04 CTransaction /** The basic transaction that is broadcasted on the network and contained in blocks. * A transaction can contain multiple inputs and outputs. * 下面就是在网络中广播然后被打包进区块的最基本的交易的结构，一个交易可能包含多个交易输入和输出。 */ class CTransaction { public: // Default transaction version. 默认交易版本 static const int32_t CURRENT_VERSION=2; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /** 下面这些变量都被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值； * 但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容 */ const int32_t nVersion; // 版本 const std::vector&lt;CTxIn&gt; vin; // 交易输入 const std::vector&lt;CTxOut&gt; vout; // 交易输出 const uint32_t nLockTime; // 锁定时间 private: /** Memory only. */ const uint256 hash; uint256 ComputeHash() const; public: /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction(CMutableTransaction &amp;&amp;tx); template &lt;typename Stream&gt; inline void Serialize(Stream&amp; s) const { SerializeTransaction(*this, s); } /** This deserializing constructor is provided instead of an Unserialize method. * Unserialize is not possible, since it would require overwriting const fields. */ template &lt;typename Stream&gt; CTransaction(deserialize_type, Stream&amp; s) : CTransaction(CMutableTransaction(deserialize, s)) {} bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts. CAmount GetValueOut() const; // 返回交易输出金额之和 // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. /** * Get the total transaction size in bytes, including witness data. * &quot;Total Size&quot; defined in BIP141 and BIP144. * @return Total transaction size in bytes */ unsigned int GetTotalSize() const; // 返回交易大小 bool IsCoinBase() const // 判断是否是coinbase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; bool HasWitness() const { for (size_t i = 0; i &lt; vin.size(); i++) { if (!vin[i].scriptWitness.IsNull()) { return true; } } return false; } }; 除了这个结构以外，还定义了一个CMutableTransaction其中的变量内容和CTransaction相同，但是都是可以直接修改的，但是最后广播和网络中传输的类型都是CTransaction。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/01/6f4aa8542bb6b2a62ff5a9193a3fb8eb.html","headline":"比特币源码解析(5) - 数据结构 - 交易-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)","dateModified":"2017-09-01T00:00:00+08:00","datePublished":"2017-09-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/01/6f4aa8542bb6b2a62ff5a9193a3fb8eb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码解析(5) - 数据结构 - 交易-呼，是出一口气；吸，是争一口气!(生活不止眼前的苟且，还有读不懂的诗和到不了的远方。)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77771392 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2 id="0x00-摘要">0x00 摘要</h2> 
  <p>交易(transaction)是比特币甚至所有区块链中最核心的数据结构之一，可以说其他所有的模块都是为交易服务的，包括交易的产生、广播、共识、存储等等，所以我们首先从交易出发，然后逐步延伸到其他的部分。</p> 
  <h2 id="0x01-coutpoint">0x01 COutPoint</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">/** An outpoint - a combination of a transaction hash and an index n into its vout. * COutPoint主要用在交易的输入CTxIn中，用来确定当前输出的来源， * 包括前一笔交易的hash，以及对应前一笔交易中的第几个输出的序列号。 */</span>
<span class="hljs-keyword">class</span> COutPoint
{
<span class="hljs-keyword">public</span>:
    uint256 hash; <span class="hljs-comment">// 交易的哈希</span>
    uint32_t n;  <span class="hljs-comment">// 对应的序列号</span>

    COutPoint() { SetNull(); }
    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }

    ADD_SERIALIZE_METHODS;  <span class="hljs-comment">// 用来序列化数据结构，方便存储和传输</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action) {
        READWRITE(hash);
        READWRITE(n);
    }

    <span class="hljs-keyword">void</span> SetNull() { hash.SetNull(); n = (uint32_t) -<span class="hljs-number">1</span>; }
    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> (hash.IsNull() &amp;&amp; n == (uint32_t) -<span class="hljs-number">1</span>); }

    <span class="hljs-comment">//重载小于号</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">int</span> cmp = a.hash.Compare(b.hash);
        <span class="hljs-keyword">return</span> cmp &lt; <span class="hljs-number">0</span> || (cmp == <span class="hljs-number">0</span> &amp;&amp; a.n &lt; b.n);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.hash == b.hash &amp;&amp; a.n == b.n);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <h2 id="0x02-ctxin">0x02 CTxIn</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">/** An input of a transaction. It contains the location of the previous * transaction's output that it claims and a signature that matches the * output's public key. * 交易的输入，包括当前输入对应前一笔交易的输出的位置，以及花费前一笔输出需要的签名脚本 * CScriptWitness是用来支持隔离见证时使用的。 */</span>
<span class="hljs-keyword">class</span> CTxIn
{
<span class="hljs-keyword">public</span>:
    COutPoint prevout;  <span class="hljs-comment">// 前一笔交易输出的位置</span>
    CScript scriptSig;  <span class="hljs-comment">// 解锁脚本</span>
    uint32_t nSequence;  <span class="hljs-comment">// 序列号</span>
    CScriptWitness scriptWitness; <span class="hljs-comment">//! Only serialized through CTransaction</span>

    <span class="hljs-comment">/* Setting nSequence to this value for every input in a transaction * disables nLockTime. * 规则1：如果一笔交易中所有的SEQUENCE_FINAL都被赋值了相应的nSequence，那么nLockTime就会被禁用*/</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_FINAL = <span class="hljs-number">0xffffffff</span>;

    <span class="hljs-comment">/* Below flags apply in the context of BIP 68*/</span>
    <span class="hljs-comment">/* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. * 规则2：如果设置了这个变量，那么规则1就失效了*/</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);

    <span class="hljs-comment">/* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. * 规则3：如果规则1有效并且设置了此变量，那么相对锁定时间就为512秒，否则锁定时间就为1个区块*/</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">22</span>);

    <span class="hljs-comment">/* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. * 规则4：如果规则1有效，那么这个变量就用来从nSequence计算对应的锁定时间*/</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_MASK = <span class="hljs-number">0x0000ffff</span>;

    <span class="hljs-comment">/* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SEQUENCE_LOCKTIME_GRANULARITY = <span class="hljs-number">9</span>;

    CTxIn()
    {
        nSequence = SEQUENCE_FINAL;
    }

    <span class="hljs-comment">// 禁用隐式转换，构造函数必须明确使用当前形式</span>
    <span class="hljs-keyword">explicit</span> CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);
    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);

    ADD_SERIALIZE_METHODS;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action) {
        READWRITE(prevout);
        READWRITE(*(CScriptBase*)(&amp;scriptSig));
        READWRITE(nSequence);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTxIn&amp; a, <span class="hljs-keyword">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.prevout   == b.prevout &amp;&amp;
                a.scriptSig == b.scriptSig &amp;&amp;
                a.nSequence == b.nSequence);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTxIn&amp; a, <span class="hljs-keyword">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <h2 id="0x03-ctxout">0x03 CTxOut</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">/** An output of a transaction. It contains the public key that the next input must be able to sign with to claim it. * 交易的输出，包含金额和锁定脚本 */</span>
<span class="hljs-keyword">class</span> CTxOut
{
<span class="hljs-keyword">public</span>:
    CAmount nValue;  <span class="hljs-comment">// 输出金额</span>
    CScript scriptPubKey;  <span class="hljs-comment">// 锁定脚本</span>

    CTxOut()
    {
        SetNull();
    }

    CTxOut(<span class="hljs-keyword">const</span> CAmount&amp; nValueIn, CScript scriptPubKeyIn);

    ADD_SERIALIZE_METHODS;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action) {
        READWRITE(nValue);
        READWRITE(*(CScriptBase*)(&amp;scriptPubKey));
    }

    <span class="hljs-keyword">void</span> SetNull()
    {
        nValue = -<span class="hljs-number">1</span>;
        scriptPubKey.clear();
    }

    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (nValue == -<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// 获取dust阈值，一笔交易如果交易费小于dust阈值，就会被认为是dust tx， </span>
    <span class="hljs-comment">// 此函数在最新版本中已转移到src/policy/policy.h中</span>
    CAmount GetDustThreshold(<span class="hljs-keyword">const</span> CFeeRate &amp;minRelayTxFee) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-comment">// "Dust" is defined in terms of CTransaction::minRelayTxFee,</span>
        <span class="hljs-comment">// which has units satoshis-per-kilobyte.</span>
        <span class="hljs-comment">// If you'd pay more than 1/3 in fees</span>
        <span class="hljs-comment">// to spend something, then we consider it dust.</span>
        <span class="hljs-comment">// A typical spendable non-segwit txout is 34 bytes big, and will</span>
        <span class="hljs-comment">// need a CTxIn of at least 148 bytes to spend:</span>
        <span class="hljs-comment">// so dust is a spendable txout less than</span>
        <span class="hljs-comment">// 546*minRelayTxFee/1000 (in satoshis).</span>
        <span class="hljs-comment">// A typical spendable segwit txout is 31 bytes big, and will</span>
        <span class="hljs-comment">// need a CTxIn of at least 67 bytes to spend:</span>
        <span class="hljs-comment">// so dust is a spendable txout less than</span>
        <span class="hljs-comment">// 294*minRelayTxFee/1000 (in satoshis).</span>
        <span class="hljs-comment">/** "Dust"是根据CTransaction中的minRelayTxFee来定义的，单位是satoshis/千字节， * 如果在一笔交易中交易费占了1/3以上，那么我们就认为该交易是"Dust"交易。 * 因此dust交易的金额小于 546*minRelayTxFee/1000; * 而在支持隔离见证的交易中，txout通常大小为31字节，CTxIn大小至少为67字节， * 此时dust交易的金额则一般小于 294*minRelayTxFee/1000. */</span>
        <span class="hljs-keyword">if</span> (scriptPubKey.IsUnspendable())  <span class="hljs-comment">// 判断脚本格式是否正确</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        size_t nSize = GetSerializeSize(*<span class="hljs-keyword">this</span>, SER_DISK, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> witnessversion = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> witnessprogram;

        <span class="hljs-comment">// 判断是否支持隔离见证</span>
        <span class="hljs-keyword">if</span> (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {
            <span class="hljs-comment">// sum the sizes of the parts of a transaction input</span>
            <span class="hljs-comment">// with 75% segwit discount applied to the script size.</span>
            nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + (<span class="hljs-number">107</span> / WITNESS_SCALE_FACTOR) + <span class="hljs-number">4</span>);
        } <span class="hljs-keyword">else</span> {
            nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + <span class="hljs-number">107</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// the 148 mentioned above</span>
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * minRelayTxFee.GetFee(nSize);
    }

    <span class="hljs-keyword">bool</span> IsDust(<span class="hljs-keyword">const</span> CFeeRate &amp;minRelayTxFee) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (nValue &lt; GetDustThreshold(minRelayTxFee));
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.nValue       == b.nValue &amp;&amp;
                a.scriptPubKey == b.scriptPubKey);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <h2 id="0x04-ctransaction">0x04 CTransaction</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs java"><span class="hljs-javadoc">/** The basic transaction that is broadcasted on the network and contained in blocks. * A transaction can contain multiple inputs and outputs. * 下面就是在网络中广播然后被打包进区块的最基本的交易的结构，一个交易可能包含多个交易输入和输出。 */</span>
class CTransaction
{
<span class="hljs-keyword">public</span>:
    // Default transaction version. 默认交易版本
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> int32_t CURRENT_VERSION=<span class="hljs-number">2</span>;

    <span class="hljs-comment">// Changing the default transaction version requires a two step process: first</span>
    <span class="hljs-comment">// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date</span>
    <span class="hljs-comment">// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and</span>
    <span class="hljs-comment">// MAX_STANDARD_VERSION will be equal.</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> int32_t MAX_STANDARD_VERSION=<span class="hljs-number">2</span>;

    <span class="hljs-comment">// The local variables are made const to prevent unintended modification</span>
    <span class="hljs-comment">// without updating the cached hash value. However, CTransaction is not</span>
    <span class="hljs-comment">// actually immutable; deserialization and assignment are implemented,</span>
    <span class="hljs-comment">// and bypass the constness. This is safe, as they update the entire</span>
    <span class="hljs-comment">// structure, including the hash.</span>
    <span class="hljs-javadoc">/** 下面这些变量都被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值； * 但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容 */</span>
    <span class="hljs-keyword">const</span> int32_t nVersion;  <span class="hljs-comment">// 版本</span>
    <span class="hljs-keyword">const</span> std::vector&lt;CTxIn&gt; vin; <span class="hljs-comment">// 交易输入</span>
    <span class="hljs-keyword">const</span> std::vector&lt;CTxOut&gt; vout; <span class="hljs-comment">// 交易输出</span>
    <span class="hljs-keyword">const</span> uint32_t nLockTime; <span class="hljs-comment">// 锁定时间</span>

<span class="hljs-keyword">private</span>:
    /** Memory only. */
    <span class="hljs-keyword">const</span> uint256 hash;

    uint256 ComputeHash() <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">public</span>:
    /** Construct a CTransaction that qualifies as <span class="hljs-title">IsNull</span>() */
    <span class="hljs-title">CTransaction</span>();

    <span class="hljs-javadoc">/** Convert a CMutableTransaction into a CTransaction. */</span>
    CTransaction(<span class="hljs-keyword">const</span> CMutableTransaction &amp;tx);
    CTransaction(CMutableTransaction &amp;&amp;tx);

    template &lt;typename Stream&gt;
    inline <span class="hljs-keyword">void</span> Serialize(Stream&amp; s) <span class="hljs-keyword">const</span> {
        SerializeTransaction(*<span class="hljs-keyword">this</span>, s);
    }

    <span class="hljs-javadoc">/** This deserializing constructor is provided instead of an Unserialize method. * Unserialize is not possible, since it would require overwriting const fields. */</span>
    template &lt;typename Stream&gt;
    CTransaction(deserialize_type, Stream&amp; s) : CTransaction(CMutableTransaction(deserialize, s)) {}

    bool IsNull() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> vin.empty() &amp;&amp; vout.empty();
    }

    <span class="hljs-keyword">const</span> uint256&amp; GetHash() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> hash;
    }

    <span class="hljs-comment">// Compute a hash that includes both transaction and witness data</span>
    uint256 GetWitnessHash() <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// Return sum of txouts.</span>
    CAmount GetValueOut() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 返回交易输出金额之和</span>
    <span class="hljs-comment">// GetValueIn() is a method on CCoinsViewCache, because</span>
    <span class="hljs-comment">// inputs must be known to compute value in.</span>

    <span class="hljs-javadoc">/** * Get the total transaction size in bytes, including witness data. * "Total Size" defined in BIP141 and BIP144. *<span class="hljs-javadoctag"> @return</span> Total transaction size in bytes */</span>
    unsigned <span class="hljs-keyword">int</span> GetTotalSize() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 返回交易大小</span>

    bool IsCoinBase() <span class="hljs-keyword">const</span>  <span class="hljs-comment">// 判断是否是coinbase交易</span>
    {
        <span class="hljs-keyword">return</span> (vin.size() == <span class="hljs-number">1</span> &amp;&amp; vin[<span class="hljs-number">0</span>].prevout.IsNull());
    }

    friend bool operator==(<span class="hljs-keyword">const</span> CTransaction&amp; a, <span class="hljs-keyword">const</span> CTransaction&amp; b)
    {
        <span class="hljs-keyword">return</span> a.hash == b.hash;
    }

    friend bool operator!=(<span class="hljs-keyword">const</span> CTransaction&amp; a, <span class="hljs-keyword">const</span> CTransaction&amp; b)
    {
        <span class="hljs-keyword">return</span> a.hash != b.hash;
    }

    std::string ToString() <span class="hljs-keyword">const</span>;

    bool HasWitness() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; vin.size(); i++) {
            <span class="hljs-keyword">if</span> (!vin[i].scriptWitness.IsNull()) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
};</code></pre> 
  <p>除了这个结构以外，还定义了一个<code>CMutableTransaction</code>其中的变量内容和<code>CTransaction</code>相同，但是都是可以直接修改的，但是最后广播和网络中传输的类型都是<code>CTransaction</code>。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77771392,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77771392,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
