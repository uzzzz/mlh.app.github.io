<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币白皮书(阅读总结) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币白皮书(阅读总结)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="比特币白皮书 比特币钱包的使用 比特币钱包(Electrum) 1 Electrum 钱包入门使用教程 http://www.8btc.com/bitcoin-electrum-intro 2 你好 简化的支付确认SPV (Simplified Payment Verification): 比特币单位换算关系如下： 1比特币（Bitcoins，BTC） 0.01比特分（Bitcent，cBTC） 0.001毫比特（Milli-Bitcoins，mBTC） 0.000001微比特（Micro-Bitcoins，μBTC或uBTC） 0.00000001聪（satoshi）（基本单位） 交易（transactions), 一枚电子货币的实质： 1 是一串数字签名 每一位所有者通过对前一次交易和下一位拥有者的公钥签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾； 电子货币发送给下一位拥有者后， 收款人通过对签名进行校验，就能够验证该链条的所有者。 该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。 从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。 如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced)，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现. 时间戳服务器(Timestamp server) 时间戳服务器通过对以区块存形式存在的一组数据实施随机散列而加上时间戳，并将该时间戳进行广播。 该时间戳能够证实特定数据于某特定时间是确定存在的。 因为只有在此时刻存在了，才能获取相应的随机散列值。 每个时间戳应该将前一个时间戳纳入其随机散列值中， 每一个随后的时间戳都对前一个时间戳进行增强，这样就形成了一个链条。 工作量证明： 为了在点对点的基础上构建一组分散化的时间戳服务器，所以在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作。 例如： SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。 在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。 由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。 比特币网络的运转： 新的交易向全网进行广播； 每一个节点都将收到的交易信息纳入一个区块中； 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明； 当一个节点找到了一个工作量证明，它就向全网进行广播； 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性； 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。 激励 每个区块的第一笔交易进行特殊化处理(奖励交易)，该交易产生一枚由该区块创造者拥有的新的电子货币。 1 增加了节点支持该网络的激励； 2 并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。 另外一个激励的来源则是交易费（transaction fees）。 激励系统也有助于鼓励节点保持诚实。 当攻击节点的算力高于诚实节点的算力时: 要么将其用于诚实工作产生新的电子货币; 或者将其用于进行二次支付攻击。 会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。 回收硬盘空间 不含交易信息的区块头（Block header）大小仅有80字节。 回收硬盘空间的时机: 最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。 为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[7] 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。 简化的支付确认 SPV: 描述 : 在不运行完整网络节点的情况下，也能够对支付进行检验。 实现方式 : 一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支, 通向它被加上时间戳并纳入区块的那次交易。 节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。 价值的分割与组合: 为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。 一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。 隐私; 传统隐私保护方式：因为试图向可信任的第三方索取交易信息是严格受限的。 比特币的保护方式： 比特币将交易信息向全网进行广播，就意味着这样的方法失效。 但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起。 风险（暴露隐私）：作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。 此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。 计算 攻击节点算力高于诚实节点，快速的制造替代性区块链。 产生的后果：最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 不能办到的事情： 1 凭空创造价值； 2 掠夺本不属于攻击者的货币。 原因： 这是因为节点将不会接受无效的交易，诚实的节点永远不会接受一个包含了无效信息的区块。 提前预防方案：收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。 可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。 结论 预设出：一种不需要信用中介的电子支付系统。 实现方案： 1 通用的电子货币的电子签名原理，为所有权提供了强有力的控制。 缺憾：但是不足以防止双重支付。 2 一种采用工作量证明机制的点对点网络来记录交易的公开信息。 阅读更多" />
<meta property="og:description" content="比特币白皮书 比特币钱包的使用 比特币钱包(Electrum) 1 Electrum 钱包入门使用教程 http://www.8btc.com/bitcoin-electrum-intro 2 你好 简化的支付确认SPV (Simplified Payment Verification): 比特币单位换算关系如下： 1比特币（Bitcoins，BTC） 0.01比特分（Bitcent，cBTC） 0.001毫比特（Milli-Bitcoins，mBTC） 0.000001微比特（Micro-Bitcoins，μBTC或uBTC） 0.00000001聪（satoshi）（基本单位） 交易（transactions), 一枚电子货币的实质： 1 是一串数字签名 每一位所有者通过对前一次交易和下一位拥有者的公钥签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾； 电子货币发送给下一位拥有者后， 收款人通过对签名进行校验，就能够验证该链条的所有者。 该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。 从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。 如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced)，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现. 时间戳服务器(Timestamp server) 时间戳服务器通过对以区块存形式存在的一组数据实施随机散列而加上时间戳，并将该时间戳进行广播。 该时间戳能够证实特定数据于某特定时间是确定存在的。 因为只有在此时刻存在了，才能获取相应的随机散列值。 每个时间戳应该将前一个时间戳纳入其随机散列值中， 每一个随后的时间戳都对前一个时间戳进行增强，这样就形成了一个链条。 工作量证明： 为了在点对点的基础上构建一组分散化的时间戳服务器，所以在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作。 例如： SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。 在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。 由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。 比特币网络的运转： 新的交易向全网进行广播； 每一个节点都将收到的交易信息纳入一个区块中； 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明； 当一个节点找到了一个工作量证明，它就向全网进行广播； 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性； 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。 激励 每个区块的第一笔交易进行特殊化处理(奖励交易)，该交易产生一枚由该区块创造者拥有的新的电子货币。 1 增加了节点支持该网络的激励； 2 并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。 另外一个激励的来源则是交易费（transaction fees）。 激励系统也有助于鼓励节点保持诚实。 当攻击节点的算力高于诚实节点的算力时: 要么将其用于诚实工作产生新的电子货币; 或者将其用于进行二次支付攻击。 会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。 回收硬盘空间 不含交易信息的区块头（Block header）大小仅有80字节。 回收硬盘空间的时机: 最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。 为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[7] 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。 简化的支付确认 SPV: 描述 : 在不运行完整网络节点的情况下，也能够对支付进行检验。 实现方式 : 一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支, 通向它被加上时间戳并纳入区块的那次交易。 节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。 价值的分割与组合: 为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。 一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。 隐私; 传统隐私保护方式：因为试图向可信任的第三方索取交易信息是严格受限的。 比特币的保护方式： 比特币将交易信息向全网进行广播，就意味着这样的方法失效。 但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起。 风险（暴露隐私）：作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。 此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。 计算 攻击节点算力高于诚实节点，快速的制造替代性区块链。 产生的后果：最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 不能办到的事情： 1 凭空创造价值； 2 掠夺本不属于攻击者的货币。 原因： 这是因为节点将不会接受无效的交易，诚实的节点永远不会接受一个包含了无效信息的区块。 提前预防方案：收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。 可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。 结论 预设出：一种不需要信用中介的电子支付系统。 实现方案： 1 通用的电子货币的电子签名原理，为所有权提供了强有力的控制。 缺憾：但是不足以防止双重支付。 2 一种采用工作量证明机制的点对点网络来记录交易的公开信息。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/01/5d3d57958e5e2902e1a1f3b95fb3360b.html" />
<meta property="og:url" content="https://mlh.app/2017/09/01/5d3d57958e5e2902e1a1f3b95fb3360b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"比特币白皮书 比特币钱包的使用 比特币钱包(Electrum) 1 Electrum 钱包入门使用教程 http://www.8btc.com/bitcoin-electrum-intro 2 你好 简化的支付确认SPV (Simplified Payment Verification): 比特币单位换算关系如下： 1比特币（Bitcoins，BTC） 0.01比特分（Bitcent，cBTC） 0.001毫比特（Milli-Bitcoins，mBTC） 0.000001微比特（Micro-Bitcoins，μBTC或uBTC） 0.00000001聪（satoshi）（基本单位） 交易（transactions), 一枚电子货币的实质： 1 是一串数字签名 每一位所有者通过对前一次交易和下一位拥有者的公钥签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾； 电子货币发送给下一位拥有者后， 收款人通过对签名进行校验，就能够验证该链条的所有者。 该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。 从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。 如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced)，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现. 时间戳服务器(Timestamp server) 时间戳服务器通过对以区块存形式存在的一组数据实施随机散列而加上时间戳，并将该时间戳进行广播。 该时间戳能够证实特定数据于某特定时间是确定存在的。 因为只有在此时刻存在了，才能获取相应的随机散列值。 每个时间戳应该将前一个时间戳纳入其随机散列值中， 每一个随后的时间戳都对前一个时间戳进行增强，这样就形成了一个链条。 工作量证明： 为了在点对点的基础上构建一组分散化的时间戳服务器，所以在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作。 例如： SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。 在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。 由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。 比特币网络的运转： 新的交易向全网进行广播； 每一个节点都将收到的交易信息纳入一个区块中； 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明； 当一个节点找到了一个工作量证明，它就向全网进行广播； 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性； 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。 激励 每个区块的第一笔交易进行特殊化处理(奖励交易)，该交易产生一枚由该区块创造者拥有的新的电子货币。 1 增加了节点支持该网络的激励； 2 并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。 另外一个激励的来源则是交易费（transaction fees）。 激励系统也有助于鼓励节点保持诚实。 当攻击节点的算力高于诚实节点的算力时: 要么将其用于诚实工作产生新的电子货币; 或者将其用于进行二次支付攻击。 会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。 回收硬盘空间 不含交易信息的区块头（Block header）大小仅有80字节。 回收硬盘空间的时机: 最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。 为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[7] 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。 简化的支付确认 SPV: 描述 : 在不运行完整网络节点的情况下，也能够对支付进行检验。 实现方式 : 一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支, 通向它被加上时间戳并纳入区块的那次交易。 节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。 价值的分割与组合: 为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。 一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。 隐私; 传统隐私保护方式：因为试图向可信任的第三方索取交易信息是严格受限的。 比特币的保护方式： 比特币将交易信息向全网进行广播，就意味着这样的方法失效。 但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起。 风险（暴露隐私）：作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。 此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。 计算 攻击节点算力高于诚实节点，快速的制造替代性区块链。 产生的后果：最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 不能办到的事情： 1 凭空创造价值； 2 掠夺本不属于攻击者的货币。 原因： 这是因为节点将不会接受无效的交易，诚实的节点永远不会接受一个包含了无效信息的区块。 提前预防方案：收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。 可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。 结论 预设出：一种不需要信用中介的电子支付系统。 实现方案： 1 通用的电子货币的电子签名原理，为所有权提供了强有力的控制。 缺憾：但是不足以防止双重支付。 2 一种采用工作量证明机制的点对点网络来记录交易的公开信息。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/01/5d3d57958e5e2902e1a1f3b95fb3360b.html","headline":"比特币白皮书(阅读总结)","dateModified":"2017-09-01T00:00:00+08:00","datePublished":"2017-09-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/01/5d3d57958e5e2902e1a1f3b95fb3360b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币白皮书(阅读总结)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="比特币白皮书">比特币白皮书</h1> 
  <h3 id="比特币钱包的使用">比特币钱包的使用</h3> 
  <ol> 
   <li>比特币钱包(Electrum) <br> 
    <ul>
     <li>1 Electrum 钱包入门使用教程 <a href="http://www.8btc.com/bitcoin-electrum-intro" rel="nofollow">http://www.8btc.com/bitcoin-electrum-intro</a></li> 
     <li>2 你好</li>
    </ul></li> 
   <li><p>简化的支付确认SPV (Simplified Payment Verification):</p></li> 
   <li><p>比特币单位换算关系如下：</p> 
    <ul>
     <li>1比特币（Bitcoins，BTC） </li> 
     <li>0.01比特分（Bitcent，cBTC）</li> 
     <li>0.001毫比特（Milli-Bitcoins，mBTC）</li> 
     <li>0.000001微比特（Micro-Bitcoins，μBTC或uBTC）</li> 
     <li>0.00000001聪（satoshi）（基本单位）</li>
    </ul></li> 
   <li><p>交易（transactions), 一枚电子货币的实质：</p> 
    <ul>
     <li>1 是一串数字签名 <br> 
      <ul>
       <li>每一位<strong>所有者</strong>通过对<strong>前一次交易</strong>和<strong>下一位拥有者的公钥</strong>签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾；</li> 
       <li>电子货币发送给下一位拥有者后， 收款人通过对签名进行校验，就能够验证该链条的所有者。</li> 
       <li>该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。</li> 
       <li>我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。</li> 
       <li>从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。</li> 
       <li>如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced)，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现.</li>
      </ul></li>
    </ul></li> 
   <li><p>时间戳服务器(Timestamp server)</p> 
    <ul>
     <li>时间戳服务器通过对以<strong>区块</strong>存形式存在的一组数据<strong>实施随机散列</strong>而加上时间戳，并将该时间戳进行广播。</li> 
     <li><strong>该时间戳</strong>能够证实<strong>特定数据</strong>于<strong>某特定时间</strong>是确定<strong>存在</strong>的。 <br> 
      <ul>
       <li>因为只有在此时刻存在了，才能获取相应的随机散列值。</li>
      </ul></li> 
     <li>每个时间戳应该将<strong>前一个</strong>时间戳纳入其随机散列值中， 每一个随后的时间戳都对前<strong>一个时间戳进行增强</strong>，这样就形成了一个链条。</li>
    </ul></li> 
   <li><p>工作量证明：</p> 
    <ul>
     <li>为了在点对点的基础上构建一组分散化的时间戳服务器，所以在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作。 <br> 
      <ul>
       <li>例如： SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。</li>
      </ul></li> 
     <li>在区块中补增<strong>一个随机数</strong>(Nonce)，这个随机数要使得该给定区块的<strong>随机散列值</strong>出现了<strong>所需的那么多个0</strong>。</li> 
     <li>由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</li> 
     <li>另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用<strong>移动平均目标的方法</strong>来确定，即令<strong>难度指向令每小时生成区块的速度为某一个预定的平均数</strong>。如果区块生成的速度过快，那么难度就会提高。</li>
    </ul></li> 
   <li><p>比特币网络的运转：</p> 
    <ul>
     <li>新的交易向全网进行广播；</li> 
     <li>每一个节点都将收到的交易信息纳入一个区块中；</li> 
     <li>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</li> 
     <li>当一个节点找到了一个工作量证明，它就向全网进行广播；</li> 
     <li>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</li> 
     <li>其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。</li> 
     <li>所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。</li>
    </ul></li> 
   <li><p>激励</p> 
    <ul>
     <li>每个区块的<strong>第一笔交易</strong>进行特殊化处理(奖励交易)，该交易产生一枚由该区块创造者拥有的新的电子货币。 <br> 
      <ul>
       <li>1 增加了节点支持该网络的激励；</li> 
       <li>2 并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。</li>
      </ul></li> 
     <li>另外一个激励的来源则是交易费（transaction fees）。</li> 
     <li>激励系统也有助于鼓励节点保持诚实。 <br> 
      <ul>
       <li>当攻击节点的算力高于诚实节点的算力时: <br> 
        <ul>
         <li>要么将其用于诚实工作产生新的电子货币;</li> 
         <li>或者将其用于进行二次支付攻击。 </li> 
         <li>会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。</li>
        </ul></li>
      </ul></li>
    </ul></li> 
   <li><p>回收硬盘空间</p> 
    <ul>
     <li><strong>不含交易信息的区块头（Block header）大小仅有80字节</strong>。</li> 
     <li>回收硬盘空间的时机: <br> 
      <ul>
       <li>最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。</li> 
       <li>为了同时确保<strong>不损害区块的随机散列值</strong>，交易信息被随机散列时，被构建成一种<strong>Merkle树</strong>（Merkle tree）[7] 的形态，使得<strong>只有根(root)</strong>被纳入了<strong>区块的随机散列值</strong>。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。</li>
      </ul></li>
    </ul></li> 
   <li><p>简化的支付确认 SPV:</p> 
    <ul>
     <li>描述 : 在不运行完整网络节点的情况下，也能够对支付进行检验。 <br> 
      <ul>
       <li>实现方式 : 一个用户<strong>需要保留最长</strong>的工作量证明链条的<strong>区块头的拷贝</strong>，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支, 通向它被加上时间戳并纳入区块的那次交易。</li> 
       <li>节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。</li>
      </ul></li>
    </ul></li> 
   <li>价值的分割与组合: <br> 
    <ul>
     <li>为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。</li> 
     <li>一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。</li> 
     <li>需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。</li>
    </ul></li> 
   <li>隐私; <br> 
    <ul>
     <li>传统隐私保护方式：因为试图向可信任的第三方索取交易信息是严格受限的。</li> 
     <li>比特币的保护方式： <br> 
      <ul>
       <li>比特币将交易信息向全网进行广播，就意味着这样的方法失效。</li> 
       <li>但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起。</li> 
       <li>风险（暴露隐私）：作为额外的预防措施，使用者可以让每次交易都生成<strong>一个新的地址</strong>，以确保这些交易不被追溯到<strong>一个共同的所有者</strong>。但是由于<strong>并行输入</strong>的存在，一定程度上的追溯还是<strong>不可避免的</strong>，因为<strong>并行输入表明这些货币都属于同一个所有者</strong>。 <br> 
        <ul>
         <li>此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。</li>
        </ul></li>
      </ul></li>
    </ul></li> 
   <li><p>计算</p> 
    <ul>
     <li>攻击节点算力高于诚实节点，快速的制造替代性区块链。 <br> 
      <ul>
       <li>产生的后果：最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。</li> 
       <li>不能办到的事情： <br> 
        <ul>
         <li>1 凭空创造价值；</li> 
         <li>2 掠夺本不属于攻击者的货币。</li> 
         <li>原因： 这是因为节点将不会接受无效的交易，诚实的节点永远不会接受一个包含了无效信息的区块。</li>
        </ul></li>
      </ul></li> 
     <li>提前预防方案：收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。 <br> 
      <ul>
       <li>可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。</li>
      </ul></li>
    </ul></li> 
   <li><p>结论</p> 
    <ul>
     <li>预设出：一种不需要信用中介的电子支付系统。</li> 
     <li>实现方案： <br> 
      <ul>
       <li>1 通用的电子货币的电子签名原理，为所有权提供了强有力的控制。 <br> 
        <ul>
         <li>缺憾：但是不足以防止双重支付。</li>
        </ul></li> 
       <li>2 一种采用工作量证明机制的点对点网络来记录交易的公开信息。</li>
      </ul></li>
    </ul></li> 
  </ol> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yyxyong/article/details/77771155,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yyxyong/article/details/77771155,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
