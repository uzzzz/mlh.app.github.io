<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码解析(6) - 数据结构 - 交易池 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码解析(6) - 数据结构 - 交易池" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77776716 0x00 摘要 我们知道当交易被广播并且被矿工接收到时，矿工就会把交易加入到本地的交易池当中，每个矿工又会对自己的交易池设置相应的限制，来保证交易数量不会过多，矿工在打包交易到区块中时，也会根据一定的优先顺序来选择交易，从而让自己能获得尽量多的交易费。 对于交易池主要介绍两个结构CTxMemPoolEntry和CTxMemPool，第一个是交易池中每一个元素的基本结构，第二个是整个交易池包含的所有信息。 0x01 CTxMemPoolEntry /** * CTxMemPoolEntry存储交易和该交易的所有子孙交易， * 当一个新的entry添加到mempool中时，我们更新它的所有子孙状态 * 和祖先状态 */ class CTxMemPoolEntry { private: CTransactionRef tx; // 交易引用 CAmount nFee; //交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight; //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nUsageSize; //大小 //!&lt; ... and total memory usage int64_t nTime; //时间戳 //!&lt; Local time when entering the mempool unsigned int entryHeight; //区块高度 //!&lt; Chain height when entering the mempool bool spendsCoinbase; //前一个交易是否是CoinBase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; // 调整交易的优先级 LockPoints lockPoints; //交易最后的所在区块高度和打包的时间 // 子孙交易信息，如果我们移除一个交易，必须同时移除它的所有子孙交易 uint64_t nCountWithDescendants; // 子孙交易的数量 uint64_t nSizeWithDescendants; // 大小 CAmount nModFeesWithDescendants; // 费用和，包括当前交易 // 祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransactionRef&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, unsigned int _entryHeight, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } CTransactionRef GetSharedTx() const { return this-&gt;tx; } const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // 更新子孙状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // 更新祖先状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // 更新feeDelta，并且修改子孙交易费用 void UpdateFeeDelta(int64_t feeDelta); // 更新LockPoint void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; 0x02 CTxMemPool /** * 交易内存池，保存所有在当前主链上有效的交易。 * 当交易在网络上广播之后，就会被加进交易池。 * 但并不是所有的交易都会被加入， * 例如交易费太小的，或者“双花”的交易或者非标准交易。 * 内存池中通过一个boost::multi_index类型的变量mapTx来排序所有交易， * 按照下面四个标准： * -交易hash * -交易费（包括所有子孙交易） * -在mempool中的时间 * -挖矿分数 * 为了保证交易费的正确性，当新交易被加进mempool时，我们必须更新 * 该交易的所有祖先交易信息，而这个操作可能会导致处理速度变慢， * 所以必须对更需祖先的数量进行限制。 */ class CTxMemPool { private: uint32_t nCheckFrequency; //表示在2^32时间内检查的次数 unsigned int nTransactionsUpdated; //!&lt; Used by getblocktemplate to trigger CreateNewBlock() invocation CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有mempool中交易的虚拟大小，不包括见证数据 uint64_t cachedInnerUsage; //map中元素使用的动态内存大小之和 mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool需要的最小费用 void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid， 首先根据交易hash排 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate，然后是费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore &gt;, // sorted by entry time，然后时间 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization)， 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors， 祖先交易费 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //所有交易见证数据的哈希 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, CAmount&gt; mapDeltas; /** 创建新的mempool */ explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr); /** * 如果开启了sanity-check，那么check函数将会保证pool的一致性， * 即不包含双花交易，所有的输入都在mapNextTx数组中。 * 如果关闭了sanity-check,那么check函数什么都不做 */ void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } /** * addUnchecked函数必须首先更新交易的祖先交易状态， * 第一个addUnchecked函数可以用来调用CalculateMemPoolAncestors(), * 然后调用第二个addUnchecked */ bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool validFeeEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool validFeeEstimate = true); void removeRecursive(const CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx); void removeForBlock(const std::vector&lt;CTransactionRef&gt;&amp; vtx, unsigned int nBlockHeight); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); bool isSpent(const COutPoint&amp; outpoint); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); /** * 检查交易的输入是否在当前的mempool中 */ bool HasNoInputsOf(const CTransaction&amp; tx) const; /** 调整 CreateNewBlock 时交易的优先级 */ void PrioritiseTransaction(const uint256&amp; hash, const CAmount&amp; nFeeDelta); void ApplyDelta(const uint256 hash, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); /** * 从竞争失败的Block中更新交易信息到mempool */ void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;vHashesToUpdate); /** 计算mempool中所有entry的祖先 * limitAncestorCount = 最大祖先数量 * limitAncestorSize = 最大祖先交易大小 * limitDescendantCount = 任意祖先的最大子孙数量 * limitDescendantSize = 任意祖先的最大子孙大小 * errString = 超过了任何limit限制的错误提示 * fSearchForParents = 是否在mempool中搜索交易的输入， * 或者从mapLinks中查找，对于不在mempool中的entry必须设为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** * 返回进入mempool需要的最小交易费， * incrementalRelayFee变量用来限制feerate降到0所需的时间。 */ CFeeRate GetMinFee(size_t sizelimit) const; /** * 移除所有动态大小超过sizelimit的交易， * 如果传入了pvNoSpendsRemaining，那么将返回不在mempool中并且也没有 * 任何输出在mempool的交易列表 */ void TrimToSize(size_t sizelimit, std::vector&lt;COutPoint&gt;* pvNoSpendsRemaining=nullptr); /** * 移除所有在time之前的交易和它的子孙交易， * 返回移除的数量 */ int Expire(int64_t time); /** 如果交易不满足chain limit，返回false*/ bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() const { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } CTransactionRef get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; size_t DynamicMemoryUsage() const; boost::signals2::signal&lt;void (CTransactionRef)&gt; NotifyEntryAdded; boost::signals2::signal&lt;void (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved; private: /** UpdateForDescendants 是被 UpdateTransactionsFromBlock 调用， * 用来更新被加入pool中的单个交易的子孙节节点； * setExclude 是内存池中不用更新的子孙交易集合 (because any descendants in * setExclude were added to the mempool after the transaction being * updated and hence their state is already reflected in the parent * state). * * 当子孙交易被更新时，cachedDescendants也同时更新 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** 设置一个entry的祖先 */ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** 对于每一个要移除的交易，更新它的祖先和直接的儿子。 * 如果updateDescendants 设为 true, 那么还同时更新mempool中子孙的祖先状态 */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个特定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); }; 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77776716 0x00 摘要 我们知道当交易被广播并且被矿工接收到时，矿工就会把交易加入到本地的交易池当中，每个矿工又会对自己的交易池设置相应的限制，来保证交易数量不会过多，矿工在打包交易到区块中时，也会根据一定的优先顺序来选择交易，从而让自己能获得尽量多的交易费。 对于交易池主要介绍两个结构CTxMemPoolEntry和CTxMemPool，第一个是交易池中每一个元素的基本结构，第二个是整个交易池包含的所有信息。 0x01 CTxMemPoolEntry /** * CTxMemPoolEntry存储交易和该交易的所有子孙交易， * 当一个新的entry添加到mempool中时，我们更新它的所有子孙状态 * 和祖先状态 */ class CTxMemPoolEntry { private: CTransactionRef tx; // 交易引用 CAmount nFee; //交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight; //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nUsageSize; //大小 //!&lt; ... and total memory usage int64_t nTime; //时间戳 //!&lt; Local time when entering the mempool unsigned int entryHeight; //区块高度 //!&lt; Chain height when entering the mempool bool spendsCoinbase; //前一个交易是否是CoinBase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; // 调整交易的优先级 LockPoints lockPoints; //交易最后的所在区块高度和打包的时间 // 子孙交易信息，如果我们移除一个交易，必须同时移除它的所有子孙交易 uint64_t nCountWithDescendants; // 子孙交易的数量 uint64_t nSizeWithDescendants; // 大小 CAmount nModFeesWithDescendants; // 费用和，包括当前交易 // 祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransactionRef&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, unsigned int _entryHeight, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } CTransactionRef GetSharedTx() const { return this-&gt;tx; } const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // 更新子孙状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // 更新祖先状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // 更新feeDelta，并且修改子孙交易费用 void UpdateFeeDelta(int64_t feeDelta); // 更新LockPoint void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; 0x02 CTxMemPool /** * 交易内存池，保存所有在当前主链上有效的交易。 * 当交易在网络上广播之后，就会被加进交易池。 * 但并不是所有的交易都会被加入， * 例如交易费太小的，或者“双花”的交易或者非标准交易。 * 内存池中通过一个boost::multi_index类型的变量mapTx来排序所有交易， * 按照下面四个标准： * -交易hash * -交易费（包括所有子孙交易） * -在mempool中的时间 * -挖矿分数 * 为了保证交易费的正确性，当新交易被加进mempool时，我们必须更新 * 该交易的所有祖先交易信息，而这个操作可能会导致处理速度变慢， * 所以必须对更需祖先的数量进行限制。 */ class CTxMemPool { private: uint32_t nCheckFrequency; //表示在2^32时间内检查的次数 unsigned int nTransactionsUpdated; //!&lt; Used by getblocktemplate to trigger CreateNewBlock() invocation CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有mempool中交易的虚拟大小，不包括见证数据 uint64_t cachedInnerUsage; //map中元素使用的动态内存大小之和 mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool需要的最小费用 void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid， 首先根据交易hash排 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate，然后是费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore &gt;, // sorted by entry time，然后时间 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization)， 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors， 祖先交易费 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //所有交易见证数据的哈希 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, CAmount&gt; mapDeltas; /** 创建新的mempool */ explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr); /** * 如果开启了sanity-check，那么check函数将会保证pool的一致性， * 即不包含双花交易，所有的输入都在mapNextTx数组中。 * 如果关闭了sanity-check,那么check函数什么都不做 */ void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } /** * addUnchecked函数必须首先更新交易的祖先交易状态， * 第一个addUnchecked函数可以用来调用CalculateMemPoolAncestors(), * 然后调用第二个addUnchecked */ bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool validFeeEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool validFeeEstimate = true); void removeRecursive(const CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx); void removeForBlock(const std::vector&lt;CTransactionRef&gt;&amp; vtx, unsigned int nBlockHeight); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); bool isSpent(const COutPoint&amp; outpoint); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); /** * 检查交易的输入是否在当前的mempool中 */ bool HasNoInputsOf(const CTransaction&amp; tx) const; /** 调整 CreateNewBlock 时交易的优先级 */ void PrioritiseTransaction(const uint256&amp; hash, const CAmount&amp; nFeeDelta); void ApplyDelta(const uint256 hash, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); /** * 从竞争失败的Block中更新交易信息到mempool */ void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;vHashesToUpdate); /** 计算mempool中所有entry的祖先 * limitAncestorCount = 最大祖先数量 * limitAncestorSize = 最大祖先交易大小 * limitDescendantCount = 任意祖先的最大子孙数量 * limitDescendantSize = 任意祖先的最大子孙大小 * errString = 超过了任何limit限制的错误提示 * fSearchForParents = 是否在mempool中搜索交易的输入， * 或者从mapLinks中查找，对于不在mempool中的entry必须设为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** * 返回进入mempool需要的最小交易费， * incrementalRelayFee变量用来限制feerate降到0所需的时间。 */ CFeeRate GetMinFee(size_t sizelimit) const; /** * 移除所有动态大小超过sizelimit的交易， * 如果传入了pvNoSpendsRemaining，那么将返回不在mempool中并且也没有 * 任何输出在mempool的交易列表 */ void TrimToSize(size_t sizelimit, std::vector&lt;COutPoint&gt;* pvNoSpendsRemaining=nullptr); /** * 移除所有在time之前的交易和它的子孙交易， * 返回移除的数量 */ int Expire(int64_t time); /** 如果交易不满足chain limit，返回false*/ bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() const { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } CTransactionRef get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; size_t DynamicMemoryUsage() const; boost::signals2::signal&lt;void (CTransactionRef)&gt; NotifyEntryAdded; boost::signals2::signal&lt;void (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved; private: /** UpdateForDescendants 是被 UpdateTransactionsFromBlock 调用， * 用来更新被加入pool中的单个交易的子孙节节点； * setExclude 是内存池中不用更新的子孙交易集合 (because any descendants in * setExclude were added to the mempool after the transaction being * updated and hence their state is already reflected in the parent * state). * * 当子孙交易被更新时，cachedDescendants也同时更新 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** 设置一个entry的祖先 */ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** 对于每一个要移除的交易，更新它的祖先和直接的儿子。 * 如果updateDescendants 设为 true, 那么还同时更新mempool中子孙的祖先状态 */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个特定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); }; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77776716 0x00 摘要 我们知道当交易被广播并且被矿工接收到时，矿工就会把交易加入到本地的交易池当中，每个矿工又会对自己的交易池设置相应的限制，来保证交易数量不会过多，矿工在打包交易到区块中时，也会根据一定的优先顺序来选择交易，从而让自己能获得尽量多的交易费。 对于交易池主要介绍两个结构CTxMemPoolEntry和CTxMemPool，第一个是交易池中每一个元素的基本结构，第二个是整个交易池包含的所有信息。 0x01 CTxMemPoolEntry /** * CTxMemPoolEntry存储交易和该交易的所有子孙交易， * 当一个新的entry添加到mempool中时，我们更新它的所有子孙状态 * 和祖先状态 */ class CTxMemPoolEntry { private: CTransactionRef tx; // 交易引用 CAmount nFee; //交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight; //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nUsageSize; //大小 //!&lt; ... and total memory usage int64_t nTime; //时间戳 //!&lt; Local time when entering the mempool unsigned int entryHeight; //区块高度 //!&lt; Chain height when entering the mempool bool spendsCoinbase; //前一个交易是否是CoinBase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; // 调整交易的优先级 LockPoints lockPoints; //交易最后的所在区块高度和打包的时间 // 子孙交易信息，如果我们移除一个交易，必须同时移除它的所有子孙交易 uint64_t nCountWithDescendants; // 子孙交易的数量 uint64_t nSizeWithDescendants; // 大小 CAmount nModFeesWithDescendants; // 费用和，包括当前交易 // 祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransactionRef&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, unsigned int _entryHeight, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } CTransactionRef GetSharedTx() const { return this-&gt;tx; } const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // 更新子孙状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // 更新祖先状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // 更新feeDelta，并且修改子孙交易费用 void UpdateFeeDelta(int64_t feeDelta); // 更新LockPoint void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; 0x02 CTxMemPool /** * 交易内存池，保存所有在当前主链上有效的交易。 * 当交易在网络上广播之后，就会被加进交易池。 * 但并不是所有的交易都会被加入， * 例如交易费太小的，或者“双花”的交易或者非标准交易。 * 内存池中通过一个boost::multi_index类型的变量mapTx来排序所有交易， * 按照下面四个标准： * -交易hash * -交易费（包括所有子孙交易） * -在mempool中的时间 * -挖矿分数 * 为了保证交易费的正确性，当新交易被加进mempool时，我们必须更新 * 该交易的所有祖先交易信息，而这个操作可能会导致处理速度变慢， * 所以必须对更需祖先的数量进行限制。 */ class CTxMemPool { private: uint32_t nCheckFrequency; //表示在2^32时间内检查的次数 unsigned int nTransactionsUpdated; //!&lt; Used by getblocktemplate to trigger CreateNewBlock() invocation CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有mempool中交易的虚拟大小，不包括见证数据 uint64_t cachedInnerUsage; //map中元素使用的动态内存大小之和 mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool需要的最小费用 void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid， 首先根据交易hash排 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate，然后是费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore &gt;, // sorted by entry time，然后时间 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization)， 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors， 祖先交易费 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //所有交易见证数据的哈希 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, CAmount&gt; mapDeltas; /** 创建新的mempool */ explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr); /** * 如果开启了sanity-check，那么check函数将会保证pool的一致性， * 即不包含双花交易，所有的输入都在mapNextTx数组中。 * 如果关闭了sanity-check,那么check函数什么都不做 */ void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } /** * addUnchecked函数必须首先更新交易的祖先交易状态， * 第一个addUnchecked函数可以用来调用CalculateMemPoolAncestors(), * 然后调用第二个addUnchecked */ bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool validFeeEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool validFeeEstimate = true); void removeRecursive(const CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx); void removeForBlock(const std::vector&lt;CTransactionRef&gt;&amp; vtx, unsigned int nBlockHeight); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); bool isSpent(const COutPoint&amp; outpoint); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); /** * 检查交易的输入是否在当前的mempool中 */ bool HasNoInputsOf(const CTransaction&amp; tx) const; /** 调整 CreateNewBlock 时交易的优先级 */ void PrioritiseTransaction(const uint256&amp; hash, const CAmount&amp; nFeeDelta); void ApplyDelta(const uint256 hash, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); /** * 从竞争失败的Block中更新交易信息到mempool */ void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;vHashesToUpdate); /** 计算mempool中所有entry的祖先 * limitAncestorCount = 最大祖先数量 * limitAncestorSize = 最大祖先交易大小 * limitDescendantCount = 任意祖先的最大子孙数量 * limitDescendantSize = 任意祖先的最大子孙大小 * errString = 超过了任何limit限制的错误提示 * fSearchForParents = 是否在mempool中搜索交易的输入， * 或者从mapLinks中查找，对于不在mempool中的entry必须设为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** * 返回进入mempool需要的最小交易费， * incrementalRelayFee变量用来限制feerate降到0所需的时间。 */ CFeeRate GetMinFee(size_t sizelimit) const; /** * 移除所有动态大小超过sizelimit的交易， * 如果传入了pvNoSpendsRemaining，那么将返回不在mempool中并且也没有 * 任何输出在mempool的交易列表 */ void TrimToSize(size_t sizelimit, std::vector&lt;COutPoint&gt;* pvNoSpendsRemaining=nullptr); /** * 移除所有在time之前的交易和它的子孙交易， * 返回移除的数量 */ int Expire(int64_t time); /** 如果交易不满足chain limit，返回false*/ bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() const { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } CTransactionRef get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; size_t DynamicMemoryUsage() const; boost::signals2::signal&lt;void (CTransactionRef)&gt; NotifyEntryAdded; boost::signals2::signal&lt;void (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved; private: /** UpdateForDescendants 是被 UpdateTransactionsFromBlock 调用， * 用来更新被加入pool中的单个交易的子孙节节点； * setExclude 是内存池中不用更新的子孙交易集合 (because any descendants in * setExclude were added to the mempool after the transaction being * updated and hence their state is already reflected in the parent * state). * * 当子孙交易被更新时，cachedDescendants也同时更新 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** 设置一个entry的祖先 */ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** 对于每一个要移除的交易，更新它的祖先和直接的儿子。 * 如果updateDescendants 设为 true, 那么还同时更新mempool中子孙的祖先状态 */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个特定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN); }; 阅读更多","@type":"BlogPosting","url":"/2017/09/01/2c5a57f737fea7092bd62ebf797a910f.html","headline":"比特币源码解析(6) - 数据结构 - 交易池","dateModified":"2017-09-01T00:00:00+08:00","datePublished":"2017-09-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/09/01/2c5a57f737fea7092bd62ebf797a910f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码解析(6) - 数据结构 - 交易池</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012183589/article/details/77776716 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2 id="0x00-摘要">0x00 摘要</h2> 
  <p>我们知道当交易被广播并且被矿工接收到时，矿工就会把交易加入到本地的交易池当中，每个矿工又会对自己的交易池设置相应的限制，来保证交易数量不会过多，矿工在打包交易到区块中时，也会根据一定的优先顺序来选择交易，从而让自己能获得尽量多的交易费。 <br> 对于交易池主要介绍两个结构<code>CTxMemPoolEntry</code>和<code>CTxMemPool</code>，第一个是交易池中每一个元素的基本结构，第二个是整个交易池包含的所有信息。</p> 
  <h2 id="0x01-ctxmempoolentry">0x01 CTxMemPoolEntry</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs java"><span class="hljs-javadoc">/** * CTxMemPoolEntry存储交易和该交易的所有子孙交易， * 当一个新的entry添加到mempool中时，我们更新它的所有子孙状态 * 和祖先状态 */</span>

class CTxMemPoolEntry
{
<span class="hljs-keyword">private</span>:
    CTransactionRef tx;  <span class="hljs-comment">// 交易引用</span>
    CAmount nFee;  <span class="hljs-comment">//交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups</span>
    size_t nTxWeight;          <span class="hljs-comment">//!&lt; ... and avoid recomputing tx weight (also used for GetTxSize())</span>
    size_t nUsageSize;  <span class="hljs-comment">//大小 //!&lt; ... and total memory usage</span>
    int64_t nTime;   <span class="hljs-comment">//时间戳 //!&lt; Local time when entering the mempool</span>
    unsigned <span class="hljs-keyword">int</span> entryHeight; <span class="hljs-comment">//区块高度 //!&lt; Chain height when entering the mempool</span>
    bool spendsCoinbase;       <span class="hljs-comment">//前一个交易是否是CoinBase</span>
    int64_t sigOpCost;         <span class="hljs-comment">//!&lt; Total sigop cost</span>
    int64_t feeDelta;          <span class="hljs-comment">// 调整交易的优先级</span>
    LockPoints lockPoints;     <span class="hljs-comment">//交易最后的所在区块高度和打包的时间</span>

    <span class="hljs-comment">// 子孙交易信息，如果我们移除一个交易，必须同时移除它的所有子孙交易</span>
    uint64_t nCountWithDescendants;  <span class="hljs-comment">// 子孙交易的数量</span>
    uint64_t nSizeWithDescendants;   <span class="hljs-comment">// 大小</span>
    CAmount nModFeesWithDescendants; <span class="hljs-comment">// 费用和，包括当前交易</span>

    <span class="hljs-comment">// 祖先交易信息</span>
    uint64_t nCountWithAncestors;
    uint64_t nSizeWithAncestors;
    CAmount nModFeesWithAncestors;
    int64_t nSigOpCostWithAncestors;

<span class="hljs-keyword">public</span>:
    <span class="hljs-title">CTxMemPoolEntry</span>(<span class="hljs-keyword">const</span> CTransactionRef&amp; _tx, <span class="hljs-keyword">const</span> CAmount&amp; _nFee,
                    int64_t _nTime, unsigned <span class="hljs-keyword">int</span> _entryHeight,
                    bool spendsCoinbase,
                    int64_t nSigOpsCost, LockPoints lp);

    <span class="hljs-keyword">const</span> CTransaction&amp; GetTx() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;tx; }
    CTransactionRef GetSharedTx() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;tx; }
    <span class="hljs-keyword">const</span> CAmount&amp; GetFee() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nFee; }
    size_t GetTxSize() <span class="hljs-keyword">const</span>;
    size_t GetTxWeight() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nTxWeight; }
    int64_t GetTime() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nTime; }
    unsigned <span class="hljs-keyword">int</span> GetHeight() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> entryHeight; }
    int64_t GetSigOpCost() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> sigOpCost; }
    int64_t GetModifiedFee() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nFee + feeDelta; }
    size_t DynamicMemoryUsage() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nUsageSize; }
    <span class="hljs-keyword">const</span> LockPoints&amp; GetLockPoints() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> lockPoints; }

    <span class="hljs-comment">// 更新子孙状态</span>
    <span class="hljs-keyword">void</span> UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount);

    <span class="hljs-comment">// 更新祖先状态</span>
    <span class="hljs-keyword">void</span> UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, <span class="hljs-keyword">int</span> modifySigOps);

    <span class="hljs-comment">// 更新feeDelta，并且修改子孙交易费用</span>
    <span class="hljs-keyword">void</span> UpdateFeeDelta(int64_t feeDelta);
    <span class="hljs-comment">// 更新LockPoint</span>
    <span class="hljs-keyword">void</span> UpdateLockPoints(<span class="hljs-keyword">const</span> LockPoints&amp; lp);

    uint64_t GetCountWithDescendants() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nCountWithDescendants; }
    uint64_t GetSizeWithDescendants() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nSizeWithDescendants; }
    CAmount GetModFeesWithDescendants() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nModFeesWithDescendants; }

    bool GetSpendsCoinbase() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> spendsCoinbase; }

    uint64_t GetCountWithAncestors() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nCountWithAncestors; }
    uint64_t GetSizeWithAncestors() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nSizeWithAncestors; }
    CAmount GetModFeesWithAncestors() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nModFeesWithAncestors; }
    int64_t GetSigOpCostWithAncestors() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> nSigOpCostWithAncestors; }

    mutable size_t vTxHashesIdx; <span class="hljs-comment">//!&lt; Index in mempool's vTxHashes</span>
};</code></pre> 
  <h2 id="0x02-ctxmempool">0x02 CTxMemPool</h2> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">/** * 交易内存池，保存所有在当前主链上有效的交易。 * 当交易在网络上广播之后，就会被加进交易池。 * 但并不是所有的交易都会被加入， * 例如交易费太小的，或者“双花”的交易或者非标准交易。 * 内存池中通过一个boost::multi_index类型的变量mapTx来排序所有交易， * 按照下面四个标准： * -交易hash * -交易费（包括所有子孙交易） * -在mempool中的时间 * -挖矿分数 * 为了保证交易费的正确性，当新交易被加进mempool时，我们必须更新 * 该交易的所有祖先交易信息，而这个操作可能会导致处理速度变慢， * 所以必须对更需祖先的数量进行限制。 */</span>
<span class="hljs-keyword">class</span> CTxMemPool
{
<span class="hljs-keyword">private</span>:
    uint32_t nCheckFrequency; <span class="hljs-comment">//表示在2^32时间内检查的次数</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nTransactionsUpdated; <span class="hljs-comment">//!&lt; Used by getblocktemplate to trigger CreateNewBlock() invocation</span>
    CBlockPolicyEstimator* minerPolicyEstimator;

    uint64_t totalTxSize;      <span class="hljs-comment">//所有mempool中交易的虚拟大小，不包括见证数据</span>
    uint64_t cachedInnerUsage; <span class="hljs-comment">//map中元素使用的动态内存大小之和</span>

    <span class="hljs-keyword">mutable</span> int64_t lastRollingFeeUpdate;
    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> blockSinceLastRollingFeeBump;
    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">double</span> rollingMinimumFeeRate; <span class="hljs-comment">//进入pool需要的最小费用</span>

    <span class="hljs-keyword">void</span> trackPackageRemoved(<span class="hljs-keyword">const</span> CFeeRate&amp; rate);

<span class="hljs-keyword">public</span>:

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ROLLING_FEE_HALFLIFE = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">12</span>; <span class="hljs-comment">// public only for testing</span>

    <span class="hljs-keyword">typedef</span> boost::multi_index_container&lt;
        CTxMemPoolEntry,
        boost::multi_index::indexed_by&lt;
            <span class="hljs-comment">// sorted by txid， 首先根据交易hash排</span>
            boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;,
            <span class="hljs-comment">// sorted by fee rate，然后是费用</span>
            boost::multi_index::ordered_non_unique&lt;
                boost::multi_index::tag&lt;descendant_score&gt;,
                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,
                CompareTxMemPoolEntryByDescendantScore
            &gt;,
            <span class="hljs-comment">// sorted by entry time，然后时间</span>
            boost::multi_index::ordered_non_unique&lt;
                boost::multi_index::tag&lt;entry_time&gt;,
                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,
                CompareTxMemPoolEntryByEntryTime
            &gt;,
            <span class="hljs-comment">// sorted by score (for mining prioritization)， 分数</span>
            boost::multi_index::ordered_unique&lt;
                boost::multi_index::tag&lt;mining_score&gt;,
                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,
                CompareTxMemPoolEntryByScore
            &gt;,
            <span class="hljs-comment">// sorted by fee rate with ancestors， 祖先交易费</span>
            boost::multi_index::ordered_non_unique&lt;
                boost::multi_index::tag&lt;ancestor_score&gt;,
                boost::multi_index::identity&lt;CTxMemPoolEntry&gt;,
                CompareTxMemPoolEntryByAncestorFee
            &gt;
        &gt;
    &gt; indexed_transaction_set;

    <span class="hljs-keyword">mutable</span> CCriticalSection cs;
    indexed_transaction_set mapTx;

    <span class="hljs-keyword">typedef</span> indexed_transaction_set::nth_index&lt;<span class="hljs-number">0</span>&gt;::type::iterator txiter;
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;uint256, txiter&gt;</span> &gt; vTxHashes; <span class="hljs-comment">//所有交易见证数据的哈希</span>

    <span class="hljs-keyword">struct</span> CompareIteratorByHash {
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> txiter &amp;a, <span class="hljs-keyword">const</span> txiter &amp;b) <span class="hljs-keyword">const</span> {
            <span class="hljs-keyword">return</span> a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash();
        }
    };
    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;txiter, CompareIteratorByHash&gt;</span> setEntries;

    <span class="hljs-keyword">const</span> setEntries &amp; GetMemPoolParents(txiter entry) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">const</span> setEntries &amp; GetMemPoolChildren(txiter entry) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;txiter, setEntries, CompareIteratorByHash&gt;</span> cacheMap;

    <span class="hljs-keyword">struct</span> TxLinks {
        setEntries parents;
        setEntries children;
    };

    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;txiter, TxLinks, CompareIteratorByHash&gt;</span> txlinksMap;
    txlinksMap mapLinks;

    <span class="hljs-keyword">void</span> UpdateParent(txiter entry, txiter parent, <span class="hljs-keyword">bool</span> add);
    <span class="hljs-keyword">void</span> UpdateChild(txiter entry, txiter child, <span class="hljs-keyword">bool</span> add);

    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;indexed_transaction_set::const_iterator&gt;</span> GetSortedDepthAndScore() <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">public</span>:
    indirectmap&lt;COutPoint, <span class="hljs-keyword">const</span> CTransaction*&gt; mapNextTx;
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;uint256, CAmount&gt;</span> mapDeltas;

    <span class="hljs-comment">/** 创建新的mempool */</span>
    <span class="hljs-keyword">explicit</span> CTxMemPool(CBlockPolicyEstimator* estimator = <span class="hljs-keyword">nullptr</span>);

    <span class="hljs-comment">/** * 如果开启了sanity-check，那么check函数将会保证pool的一致性， * 即不包含双花交易，所有的输入都在mapNextTx数组中。 * 如果关闭了sanity-check,那么check函数什么都不做 */</span>
    <span class="hljs-keyword">void</span> check(<span class="hljs-keyword">const</span> CCoinsViewCache *pcoins) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> setSanityCheck(<span class="hljs-keyword">double</span> dFrequency = <span class="hljs-number">1.0</span>) { nCheckFrequency = dFrequency * <span class="hljs-number">4294967295.0</span>; }

     <span class="hljs-comment">/** * addUnchecked函数必须首先更新交易的祖先交易状态， * 第一个addUnchecked函数可以用来调用CalculateMemPoolAncestors(), * 然后调用第二个addUnchecked */</span>
    <span class="hljs-keyword">bool</span> addUnchecked(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-keyword">const</span> CTxMemPoolEntry &amp;entry, <span class="hljs-keyword">bool</span> validFeeEstimate = <span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">bool</span> addUnchecked(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-keyword">const</span> CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, <span class="hljs-keyword">bool</span> validFeeEstimate = <span class="hljs-keyword">true</span>);

    <span class="hljs-keyword">void</span> removeRecursive(<span class="hljs-keyword">const</span> CTransaction &amp;tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);
    <span class="hljs-keyword">void</span> removeForReorg(<span class="hljs-keyword">const</span> CCoinsViewCache *pcoins, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nMemPoolHeight, <span class="hljs-keyword">int</span> flags);
    <span class="hljs-keyword">void</span> removeConflicts(<span class="hljs-keyword">const</span> CTransaction &amp;tx);
    <span class="hljs-keyword">void</span> removeForBlock(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CTransactionRef&gt;</span>&amp; vtx, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nBlockHeight);

    <span class="hljs-keyword">void</span> clear();
    <span class="hljs-keyword">void</span> _clear(); <span class="hljs-comment">//lock free</span>
    <span class="hljs-keyword">bool</span> CompareDepthAndScore(<span class="hljs-keyword">const</span> uint256&amp; hasha, <span class="hljs-keyword">const</span> uint256&amp; hashb);
    <span class="hljs-keyword">void</span> queryHashes(<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint256&gt;</span>&amp; vtxid);
    <span class="hljs-keyword">bool</span> isSpent(<span class="hljs-keyword">const</span> COutPoint&amp; outpoint);
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> GetTransactionsUpdated() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> AddTransactionsUpdated(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n);
    <span class="hljs-comment">/** * 检查交易的输入是否在当前的mempool中 */</span>
    <span class="hljs-keyword">bool</span> HasNoInputsOf(<span class="hljs-keyword">const</span> CTransaction&amp; tx) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">/** 调整 CreateNewBlock 时交易的优先级 */</span>
    <span class="hljs-keyword">void</span> PrioritiseTransaction(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-keyword">const</span> CAmount&amp; nFeeDelta);
    <span class="hljs-keyword">void</span> ApplyDelta(<span class="hljs-keyword">const</span> uint256 hash, CAmount &amp;nFeeDelta) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> ClearPrioritisation(<span class="hljs-keyword">const</span> uint256 hash);

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */</span>
    <span class="hljs-keyword">void</span> RemoveStaged(setEntries &amp;stage, <span class="hljs-keyword">bool</span> updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);

    <span class="hljs-comment">/** * 从竞争失败的Block中更新交易信息到mempool */</span>
    <span class="hljs-keyword">void</span> UpdateTransactionsFromBlock(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint256&gt;</span> &amp;vHashesToUpdate);

    <span class="hljs-comment">/** 计算mempool中所有entry的祖先 * limitAncestorCount = 最大祖先数量 * limitAncestorSize = 最大祖先交易大小 * limitDescendantCount = 任意祖先的最大子孙数量 * limitDescendantSize = 任意祖先的最大子孙大小 * errString = 超过了任何limit限制的错误提示 * fSearchForParents = 是否在mempool中搜索交易的输入， * 或者从mapLinks中查找，对于不在mempool中的entry必须设为true */</span>
    <span class="hljs-keyword">bool</span> CalculateMemPoolAncestors(<span class="hljs-keyword">const</span> CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;errString, <span class="hljs-keyword">bool</span> fSearchForParents = <span class="hljs-keyword">true</span>) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">/** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */</span>
    <span class="hljs-keyword">void</span> CalculateDescendants(txiter it, setEntries &amp;setDescendants);

    <span class="hljs-comment">/** * 返回进入mempool需要的最小交易费， * incrementalRelayFee变量用来限制feerate降到0所需的时间。 */</span>
    CFeeRate GetMinFee(size_t sizelimit) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">/** * 移除所有动态大小超过sizelimit的交易， * 如果传入了pvNoSpendsRemaining，那么将返回不在mempool中并且也没有 * 任何输出在mempool的交易列表 */</span>
    <span class="hljs-keyword">void</span> TrimToSize(size_t sizelimit, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;COutPoint&gt;</span>* pvNoSpendsRemaining=<span class="hljs-keyword">nullptr</span>);

    <span class="hljs-comment">/** * 移除所有在time之前的交易和它的子孙交易， * 返回移除的数量 */</span>
    <span class="hljs-keyword">int</span> Expire(int64_t time);

    <span class="hljs-comment">/** 如果交易不满足chain limit，返回false*/</span>
    <span class="hljs-keyword">bool</span> TransactionWithinChainLimit(<span class="hljs-keyword">const</span> uint256&amp; txid, size_t chainLimit) <span class="hljs-keyword">const</span>;

    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size()
    {
        LOCK(cs);
        <span class="hljs-keyword">return</span> mapTx.size();
    }

    uint64_t GetTotalTxSize() <span class="hljs-keyword">const</span>
    {
        LOCK(cs);
        <span class="hljs-keyword">return</span> totalTxSize;
    }

    <span class="hljs-keyword">bool</span> exists(uint256 hash) <span class="hljs-keyword">const</span>
    {
        LOCK(cs);
        <span class="hljs-keyword">return</span> (mapTx.count(hash) != <span class="hljs-number">0</span>);
    }

    CTransactionRef get(<span class="hljs-keyword">const</span> uint256&amp; hash) <span class="hljs-keyword">const</span>;
    TxMempoolInfo info(<span class="hljs-keyword">const</span> uint256&amp; hash) <span class="hljs-keyword">const</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;TxMempoolInfo&gt;</span> infoAll() <span class="hljs-keyword">const</span>;

    size_t DynamicMemoryUsage() <span class="hljs-keyword">const</span>;

    boost::signals2::signal&lt;<span class="hljs-keyword">void</span> (CTransactionRef)&gt; NotifyEntryAdded;
    boost::signals2::signal&lt;<span class="hljs-keyword">void</span> (CTransactionRef, MemPoolRemovalReason)&gt; NotifyEntryRemoved;

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">/** UpdateForDescendants 是被 UpdateTransactionsFromBlock 调用， * 用来更新被加入pool中的单个交易的子孙节节点； * setExclude 是内存池中不用更新的子孙交易集合 (because any descendants in * setExclude were added to the mempool after the transaction being * updated and hence their state is already reflected in the parent * state). * * 当子孙交易被更新时，cachedDescendants也同时更新 */</span>
    <span class="hljs-keyword">void</span> UpdateForDescendants(txiter updateIt,
            cacheMap &amp;cachedDescendants,
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;uint256&gt;</span> &amp;setExclude);

    <span class="hljs-comment">/** Update ancestors of hash to add/remove it as a descendant transaction. */</span>
    <span class="hljs-keyword">void</span> UpdateAncestorsOf(<span class="hljs-keyword">bool</span> add, txiter hash, setEntries &amp;setAncestors);

    <span class="hljs-comment">/** 设置一个entry的祖先 */</span>
    <span class="hljs-keyword">void</span> UpdateEntryForAncestors(txiter it, <span class="hljs-keyword">const</span> setEntries &amp;setAncestors);

    <span class="hljs-comment">/** 对于每一个要移除的交易，更新它的祖先和直接的儿子。 * 如果updateDescendants 设为 true, 那么还同时更新mempool中子孙的祖先状态 */</span>
    <span class="hljs-keyword">void</span> UpdateForRemoveFromMempool(<span class="hljs-keyword">const</span> setEntries &amp;entriesToRemove, <span class="hljs-keyword">bool</span> updateDescendants);

    <span class="hljs-comment">/** Sever link between specified transaction and direct children. */</span>
    <span class="hljs-keyword">void</span> UpdateChildrenForRemoval(txiter entry);

    <span class="hljs-comment">/** 对于一个特定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */</span>
    <span class="hljs-keyword">void</span> removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);
};</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77776716,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/77776716,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
