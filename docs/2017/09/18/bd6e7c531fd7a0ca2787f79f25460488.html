<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链中常用共识算法总结-远去的少年(让我思考一下) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链中常用共识算法总结-远去的少年(让我思考一下)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，转载注明出处。 https://blog.csdn.net/s_lisheng/article/details/78022645 本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。 建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。 实用拜占庭容错系统PBFT（联盟链中常用） 拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。 拜占庭将军问题 拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。 拜占庭容错系统 拜占庭容错系统是指：在一个拥有 n n 台节点的系统，整个系统，对每个请求满足如下条件： 所有非拜占庭节点使用相同的输入信息，产生同样的结果； 如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。 与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过 m m 台，并且对每个请求满足2个指标： 安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到； 活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。 拜占庭系统目前普遍采用的假设条件包括: 1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋； 2) 节点之间的错误是不相关的； 3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达； 4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性； （发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。） 状态机拜占庭系统 状态机拜占庭系统的特点 状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。 状态机拜占庭系统的核心协议 一、一致性协议 一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。 一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。 一致性协议解决一致性的方法主要有： 1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器； 2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含 3m+1 3 m + 1 台服务器的拜占庭系统，需要收集到 2m+1 2 m + 1 台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。 引申思考： 1. 部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ 2. PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？ 二、检查点协议 拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。 处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被 m+1 m + 1 台非拜占庭服务器执行，并且某一服务器 i i 能够向其他的服务器证明这一点，那么 i i 就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到 2m+1 2 m + 1 台服务器的状态，那么其中一致的部分就是至少有 m+1 m + 1 非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。 三、视图更换 在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。 视图更换协议一般有两种触发方式： 1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息； 2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。 视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有 m+1 m + 1 台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少 2m+1 2 m + 1 台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。 实用拜占庭容错系统PBFT详解 实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。 PBFT的一致性协议如下：PBFT系统通常假设故障节点数为 m m 个，而整个服务节点数为 3m+1 3 m + 1 个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 上图显示了一个简化的PBFT的协议通信模式，其中 C C 为客户端， N0 N 0 ~ N3 N 3 表示服务节点，特别的， N0 N 0 为主节点， N3 N 3 为故障节点。整个协议的基本过程如下： 1）客户端发送请求，激活主节点的服务操作； 2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求； 序号分配阶段，主节点给请求赋值一个序号 n n ，广播序号分配消息和客户端的请求消息 m m ，并将构造pre-prepare消息给各从节点； 交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息； 序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。 3）客户端等待来自不同节点的响应，若有 m+1 m + 1 个响应相同，则该响应即为运算的结果； Raft协议 Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。 Raft基础 一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。 Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。 leader选举 当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。 一般而言，在Raft系统中： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到 N/2+1 N / 2 + 1 的大多数票，候选人还是可以成为leader。 3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。 4）以后可以通过心跳进行记账的通知。 5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程 Raft的记账过程按以下步骤完成： 1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； 2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； 3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息； 4）在下一个心跳中，leader会通知所有follower更新确认的项目。 对于每个新的交易记录，重复上述过程。 如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。 如果想更直观的理解Raft协议，可以看动画演示。 论文原文：In Search of an Understandable Consensus Algorithm 学习参考：The Raft Consensus Algorithm PoW PoW的原理可参看这篇博文中哈希函数难题友好性这一节：http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下： 1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希； 2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入； 3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。 PoS PoW存在以下弊端： 矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。 PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。 PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。 点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。 DPoS PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。 比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前 N N 个（ N N 通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信 N N 已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。 可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程） 参考资料： 拜占庭共识算法之PBFT Raft动画演示 The Raft Consensus Algorithm 2-hop Blockchain: Combining Proof-of-Work and Proof-of-Stake Securely 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，转载注明出处。 https://blog.csdn.net/s_lisheng/article/details/78022645 本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。 建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。 实用拜占庭容错系统PBFT（联盟链中常用） 拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。 拜占庭将军问题 拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。 拜占庭容错系统 拜占庭容错系统是指：在一个拥有 n n 台节点的系统，整个系统，对每个请求满足如下条件： 所有非拜占庭节点使用相同的输入信息，产生同样的结果； 如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。 与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过 m m 台，并且对每个请求满足2个指标： 安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到； 活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。 拜占庭系统目前普遍采用的假设条件包括: 1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋； 2) 节点之间的错误是不相关的； 3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达； 4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性； （发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。） 状态机拜占庭系统 状态机拜占庭系统的特点 状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。 状态机拜占庭系统的核心协议 一、一致性协议 一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。 一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。 一致性协议解决一致性的方法主要有： 1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器； 2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含 3m+1 3 m + 1 台服务器的拜占庭系统，需要收集到 2m+1 2 m + 1 台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。 引申思考： 1. 部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ 2. PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？ 二、检查点协议 拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。 处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被 m+1 m + 1 台非拜占庭服务器执行，并且某一服务器 i i 能够向其他的服务器证明这一点，那么 i i 就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到 2m+1 2 m + 1 台服务器的状态，那么其中一致的部分就是至少有 m+1 m + 1 非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。 三、视图更换 在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。 视图更换协议一般有两种触发方式： 1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息； 2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。 视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有 m+1 m + 1 台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少 2m+1 2 m + 1 台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。 实用拜占庭容错系统PBFT详解 实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。 PBFT的一致性协议如下：PBFT系统通常假设故障节点数为 m m 个，而整个服务节点数为 3m+1 3 m + 1 个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 上图显示了一个简化的PBFT的协议通信模式，其中 C C 为客户端， N0 N 0 ~ N3 N 3 表示服务节点，特别的， N0 N 0 为主节点， N3 N 3 为故障节点。整个协议的基本过程如下： 1）客户端发送请求，激活主节点的服务操作； 2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求； 序号分配阶段，主节点给请求赋值一个序号 n n ，广播序号分配消息和客户端的请求消息 m m ，并将构造pre-prepare消息给各从节点； 交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息； 序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。 3）客户端等待来自不同节点的响应，若有 m+1 m + 1 个响应相同，则该响应即为运算的结果； Raft协议 Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。 Raft基础 一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。 Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。 leader选举 当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。 一般而言，在Raft系统中： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到 N/2+1 N / 2 + 1 的大多数票，候选人还是可以成为leader。 3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。 4）以后可以通过心跳进行记账的通知。 5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程 Raft的记账过程按以下步骤完成： 1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； 2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； 3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息； 4）在下一个心跳中，leader会通知所有follower更新确认的项目。 对于每个新的交易记录，重复上述过程。 如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。 如果想更直观的理解Raft协议，可以看动画演示。 论文原文：In Search of an Understandable Consensus Algorithm 学习参考：The Raft Consensus Algorithm PoW PoW的原理可参看这篇博文中哈希函数难题友好性这一节：http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下： 1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希； 2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入； 3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。 PoS PoW存在以下弊端： 矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。 PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。 PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。 点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。 DPoS PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。 比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前 N N 个（ N N 通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信 N N 已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。 可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程） 参考资料： 拜占庭共识算法之PBFT Raft动画演示 The Raft Consensus Algorithm 2-hop Blockchain: Combining Proof-of-Work and Proof-of-Stake Securely 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/18/bd6e7c531fd7a0ca2787f79f25460488.html" />
<meta property="og:url" content="https://mlh.app/2017/09/18/bd6e7c531fd7a0ca2787f79f25460488.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，转载注明出处。 https://blog.csdn.net/s_lisheng/article/details/78022645 本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。 建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。 实用拜占庭容错系统PBFT（联盟链中常用） 拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。 拜占庭将军问题 拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。 拜占庭容错系统 拜占庭容错系统是指：在一个拥有 n n 台节点的系统，整个系统，对每个请求满足如下条件： 所有非拜占庭节点使用相同的输入信息，产生同样的结果； 如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。 与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过 m m 台，并且对每个请求满足2个指标： 安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到； 活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。 拜占庭系统目前普遍采用的假设条件包括: 1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋； 2) 节点之间的错误是不相关的； 3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达； 4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性； （发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。） 状态机拜占庭系统 状态机拜占庭系统的特点 状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：一致性协议、 检查点协议和视图更换协议。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。 状态机拜占庭系统的核心协议 一、一致性协议 一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。 一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。 一致性协议解决一致性的方法主要有： 1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器； 2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含 3m+1 3 m + 1 台服务器的拜占庭系统，需要收集到 2m+1 2 m + 1 台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。 引申思考： 1. 部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？ 2. PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？ 二、检查点协议 拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。 处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被 m+1 m + 1 台非拜占庭服务器执行，并且某一服务器 i i 能够向其他的服务器证明这一点，那么 i i 就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到 2m+1 2 m + 1 台服务器的状态，那么其中一致的部分就是至少有 m+1 m + 1 非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。 三、视图更换 在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。 视图更换协议一般有两种触发方式： 1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息； 2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。 视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有 m+1 m + 1 台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少 2m+1 2 m + 1 台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。 实用拜占庭容错系统PBFT详解 实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。 PBFT的一致性协议如下：PBFT系统通常假设故障节点数为 m m 个，而整个服务节点数为 3m+1 3 m + 1 个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 上图显示了一个简化的PBFT的协议通信模式，其中 C C 为客户端， N0 N 0 ~ N3 N 3 表示服务节点，特别的， N0 N 0 为主节点， N3 N 3 为故障节点。整个协议的基本过程如下： 1）客户端发送请求，激活主节点的服务操作； 2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求； 序号分配阶段，主节点给请求赋值一个序号 n n ，广播序号分配消息和客户端的请求消息 m m ，并将构造pre-prepare消息给各从节点； 交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息； 序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。 3）客户端等待来自不同节点的响应，若有 m+1 m + 1 个响应相同，则该响应即为运算的结果； Raft协议 Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。 Raft基础 一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。 Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。 leader选举 当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。 一般而言，在Raft系统中： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到 N/2+1 N / 2 + 1 的大多数票，候选人还是可以成为leader。 3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。 4）以后可以通过心跳进行记账的通知。 5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程 Raft的记账过程按以下步骤完成： 1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； 2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； 3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息； 4）在下一个心跳中，leader会通知所有follower更新确认的项目。 对于每个新的交易记录，重复上述过程。 如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。 如果想更直观的理解Raft协议，可以看动画演示。 论文原文：In Search of an Understandable Consensus Algorithm 学习参考：The Raft Consensus Algorithm PoW PoW的原理可参看这篇博文中哈希函数难题友好性这一节：http://blog.csdn.net/s_lisheng/article/details/77937202，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下： 1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希； 2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入； 3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。 PoS PoW存在以下弊端： 矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。 PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。 PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。 点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。 DPoS PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。 比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前 N N 个（ N N 通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信 N N 已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。 可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程） 参考资料： 拜占庭共识算法之PBFT Raft动画演示 The Raft Consensus Algorithm 2-hop Blockchain: Combining Proof-of-Work and Proof-of-Stake Securely 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/18/bd6e7c531fd7a0ca2787f79f25460488.html","headline":"区块链中常用共识算法总结-远去的少年(让我思考一下)","dateModified":"2017-09-18T00:00:00+08:00","datePublished":"2017-09-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/18/bd6e7c531fd7a0ca2787f79f25460488.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链中常用共识算法总结-远去的少年(让我思考一下)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，转载注明出处。 https://blog.csdn.net/s_lisheng/article/details/78022645 
 </div> 
 <div class="markdown_views prism-dracula"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>本文是对区块链技术中涉及的共识算法的学习总结整理。 其中PBFT和Raft是联盟链和私有链常用的共识算法，而PoW（比特币采用）和PoS是公有链常用的共识算法。</p> 
  <blockquote> 
   <p>建议对区块链的学习，要分成是公有链还是联盟链，这两种链中一般采用的共识算法是有较大不同的，P2P网络等也有较大的不同。传统的共识算法一般不适用于公有链，而一定程度上适用于联盟链。</p> 
  </blockquote> 
  <hr> 
  <h2 id="实用拜占庭容错系统pbft联盟链中常用"><font color="CornflowerBlue">实用拜占庭容错系统PBFT（联盟链中常用）</font></h2> 
  <p>拜占庭容错技术（Byzantine Fault Tolerance,BFT）是一类分布式计算领域的容错技术，是一种解决分布式系统容错问题的通用方案。实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）使拜占庭协议的运行复杂度从指数级别降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。</p> 
  <h3 id="拜占庭将军问题">拜占庭将军问题</h3> 
  <p>拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p> 
  <h3 id="拜占庭容错系统">拜占庭容错系统</h3> 
  <p>拜占庭容错系统是指：在一个拥有<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-1" style="width: 0.669em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.515em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.949em, 1000.46em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: STIXGeneral; font-style: italic;">n</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       n
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-1">n</script>台节点的系统，整个系统，对每个请求满足如下条件：</p> 
  <ul> 
   <li>所有非拜占庭节点使用相同的输入信息，产生同样的结果；</li> 
   <li>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。</li> 
  </ul> 
  <p>与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-4" style="width: 0.873em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.949em, 1000.72em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-5"><span class="mi" id="MathJax-Span-6" style="font-family: STIXGeneral; font-style: italic;">m</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-2">m</script>台，并且对每个请求满足2个指标：</p> 
  <ul> 
   <li>安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；</li> 
   <li>活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。</li> 
  </ul> 
  <p>拜占庭系统目前普遍采用的假设条件包括: <br> 1) 拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋； <br> 2) 节点之间的错误是不相关的； <br> 3) 节点之间通过异步网络连接，网络中的消息可能丢失、乱序、延时到达； <br> 4) 服务器之间传递的信息,第三方可以知晓 ,但是不能窜改、伪造信息的内容和验证信息的完整性；</p> 
  <p><font color="CornflowerBlue" size="3">（<em>发生故障的节点称为拜占庭节点；正常的节点为非拜占庭节点。</em>）</font></p> 
  <h3 id="状态机拜占庭系统">状态机拜占庭系统</h3> 
  <h4 id="状态机拜占庭系统的特点">状态机拜占庭系统的特点</h4> 
  <p>状态机拜占庭系统的特点是整个系统共同维护一个状态,所有节点采取一致的行动,一般包括 3 种协议：<font color="CornflowerBlue" size="3">一致性协议</font>、 <font color="CornflowerBlue" size="3">检查点协议</font>和<font color="CornflowerBlue" size="3">视图更换协议</font>。系统正常运行在一致性协议和检查点协议下，视图更换协议则是只有在主节点出错或者运行缓慢的情况下才会启动，负责维系系统继续执行客户端请求的能力。</p> 
  <h4 id="状态机拜占庭系统的核心协议">状态机拜占庭系统的核心协议</h4> 
  <p><strong>一、一致性协议</strong> <br> 一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。</p> 
  <p>一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。</p> 
  <p>一致性协议解决一致性的方法主要有： <br> 1）服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器； <br> 2）由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-7" style="width: 3.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.82em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-8"><span class="mn" id="MathJax-Span-9" style="font-family: STIXGeneral;">3</span><span class="mi" id="MathJax-Span-10" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-11" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-12" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mn>
       3
      </mn>
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-3">3m+1</script>台服务器的拜占庭系统，需要收集到<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-13" style="width: 3.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.82em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-14"><span class="mn" id="MathJax-Span-15" style="font-family: STIXGeneral;">2</span><span class="mi" id="MathJax-Span-16" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-17" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-18" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mn>
       2
      </mn>
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-4">2m+1</script>台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。</p> 
  <p><font color="CadetBlue"><em>引申思考：</em> <br> <em>1. 部署一个采用PBFT共识算法的区块链，至少需要几个节点呢？</em> <br> <em>2. PBFT共识算法的区块链，最佳节点数量问题，采用PBFT共识算法的区块链系统节点数量的下限和上限？</em></font></p> 
  <p><strong>二、检查点协议</strong> <br> 拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。</p> 
  <p>处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-19" style="width: 2.974em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.41em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.31em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-20"><span class="mi" id="MathJax-Span-21" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-22" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-23" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-5">m+1</script>台非拜占庭服务器执行，并且某一服务器<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-24" style="width: 0.31em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.259em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.26em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-25"><span class="mi" id="MathJax-Span-26" style="font-family: STIXGeneral; font-style: italic;">i</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       i
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-6">i  
</script>能够向其他的服务器证明这一点，那么<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-27" style="width: 0.31em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.259em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.26em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-28"><span class="mi" id="MathJax-Span-29" style="font-family: STIXGeneral; font-style: italic;">i</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       i
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-7">i</script>就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-30" style="width: 3.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.82em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-31"><span class="mn" id="MathJax-Span-32" style="font-family: STIXGeneral;">2</span><span class="mi" id="MathJax-Span-33" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-34" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-35" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mn>
       2
      </mn>
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-8">2m+1</script>台服务器的状态，那么其中一致的部分就是至少有<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-36" style="width: 2.974em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.41em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.31em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-37"><span class="mi" id="MathJax-Span-38" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-39" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-40" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-9">m+1</script>非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。</p> 
  <p><strong>三、视图更换</strong> <br> 在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。</p> 
  <p>视图更换协议一般有两种触发方式： <br> 1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息； <br> 2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。</p> 
  <p>视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-41" style="width: 2.974em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.41em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.31em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-42"><span class="mi" id="MathJax-Span-43" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-44" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-45" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-10">m+1</script>台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-11-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-46" style="width: 3.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.82em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-47"><span class="mn" id="MathJax-Span-48" style="font-family: STIXGeneral;">2</span><span class="mi" id="MathJax-Span-49" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-50" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-51" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mn>
       2
      </mn>
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-11">2m+1</script>台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。</p> 
  <h3 id="实用拜占庭容错系统pbft详解">实用拜占庭容错系统PBFT详解</h3> 
  <p>实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT），是一类状态机拜占庭系统。</p> 
  <p>PBFT的一致性协议如下：PBFT系统通常假设故障节点数为<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-52" style="width: 0.873em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.949em, 1000.72em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-53"><span class="mi" id="MathJax-Span-54" style="font-family: STIXGeneral; font-style: italic;">m</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-12">m</script>个，而整个服务节点数为<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-55" style="width: 3.589em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.82em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-56"><span class="mn" id="MathJax-Span-57" style="font-family: STIXGeneral;">3</span><span class="mi" id="MathJax-Span-58" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-59" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-60" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mn>
       3
      </mn>
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-13">3m+1</script>个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器监测。<font color="CadetBlue">如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170924212044418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p> 
  <p>上图显示了一个简化的PBFT的协议通信模式，其中<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-14-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-61" style="width: 0.822em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.669em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.67em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-family: STIXGeneral; font-style: italic;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       C
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-14">C</script>为客户端，<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>N</mi><mn>0</mn></msub></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-64" style="width: 1.335em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.08em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-65"><span class="msubsup" id="MathJax-Span-66"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.72em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-67" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mn" id="MathJax-Span-68" style="font-size: 70.7%; font-family: STIXGeneral;">0</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msub>
       <mi>
        N
       </mi>
       <mn>
        0
       </mn>
      </msub>
     </math></span></span><script type="math/tex" id="MathJax-Element-15">N_0</script>~<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>N</mi><mn>3</mn></msub></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-69" style="width: 1.335em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.08em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-70"><span class="msubsup" id="MathJax-Span-71"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.72em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-72" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mn" id="MathJax-Span-73" style="font-size: 70.7%; font-family: STIXGeneral;">3</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msub>
       <mi>
        N
       </mi>
       <mn>
        3
       </mn>
      </msub>
     </math></span></span><script type="math/tex" id="MathJax-Element-16">N_3</script>表示服务节点，特别的，<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>N</mi><mn>0</mn></msub></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-74" style="width: 1.335em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.08em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-75"><span class="msubsup" id="MathJax-Span-76"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.72em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-77" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mn" id="MathJax-Span-78" style="font-size: 70.7%; font-family: STIXGeneral;">0</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msub>
       <mi>
        N
       </mi>
       <mn>
        0
       </mn>
      </msub>
     </math></span></span><script type="math/tex" id="MathJax-Element-17">N_0</script>为主节点，<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>N</mi><mn>3</mn></msub></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-79" style="width: 1.335em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.08em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-80"><span class="msubsup" id="MathJax-Span-81"><span style="display: inline-block; position: relative; width: 1.078em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.72em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-82" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mn" id="MathJax-Span-83" style="font-size: 70.7%; font-family: STIXGeneral;">3</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msub>
       <mi>
        N
       </mi>
       <mn>
        3
       </mn>
      </msub>
     </math></span></span><script type="math/tex" id="MathJax-Element-18">N_3</script>为故障节点。整个协议的基本过程如下： <br> 1）客户端发送请求，激活主节点的服务操作； <br> 2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求；</p> 
  <ol> 
   <li>序号分配阶段，主节点给请求赋值一个序号<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation" style="position: relative;">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-84" style="width: 0.604em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.495em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.861em, 1000.5em, 2.626em, -999.997em); top: -2.456em; left: 0em;"><span class="mrow" id="MathJax-Span-85"><span class="mi" id="MathJax-Span-86" style="font-family: STIXGeneral; font-style: italic;">n</span></span><span style="display: inline-block; width: 0px; height: 2.462em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 0.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        n
       </mi>
      </math></span></span><script type="math/tex" id="MathJax-Element-19">n</script>，广播序号分配消息和客户端的请求消息<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi></math>" role="presentation" style="position: relative;">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-87" style="width: 0.877em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.713em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.861em, 1000.71em, 2.626em, -999.997em); top: -2.456em; left: 0em;"><span class="mrow" id="MathJax-Span-88"><span class="mi" id="MathJax-Span-89" style="font-family: STIXGeneral; font-style: italic;">m</span></span><span style="display: inline-block; width: 0px; height: 2.462em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 0.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        m
       </mi>
      </math></span></span><script type="math/tex" id="MathJax-Element-20">m</script>，并将构造pre-prepare消息给各从节点；</li> 
   <li>交互阶段，从节点接收pre-prepare消息，向其他服务节点广播prepare消息；</li> 
   <li>序号确认阶段，各节点对视图内的请求和次序进行验证后，广播commit消息，执行收到的客户端的请求并给客户端响应。</li> 
  </ol> 
  <p>3）客户端等待来自不同节点的响应，若有<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-90" style="width: 2.974em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.41em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1002.31em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-91"><span class="mi" id="MathJax-Span-92" style="font-family: STIXGeneral; font-style: italic;">m</span><span class="mo" id="MathJax-Span-93" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-94" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       m
      </mi>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-21">m+1</script>个响应相同，则该响应即为运算的结果；</p> 
  <hr> 
  <h2 id="raft协议">Raft协议</h2> 
  <p><font color="red">Raft是在<strong>非拜占庭故障</strong>下达成共识的<strong>强一致协议</strong>。</font>在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。</p> 
  <h5 id="raft基础">Raft基础</h5> 
  <p>一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。</p> 
  <p>Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。</p> 
  <h5 id="leader选举">leader选举</h5> 
  <p>当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</p> 
  <p>一般而言，在Raft系统中： <br> 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 <br> 2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-22-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo>+</mo><mn>1</mn></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-95" style="width: 3.896em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.179em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1003.08em, 2.769em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-96"><span class="mi" id="MathJax-Span-97" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="texatom" id="MathJax-Span-98"><span class="mrow" id="MathJax-Span-99"><span class="mo" id="MathJax-Span-100" style="font-family: STIXGeneral;">/</span></span></span><span class="mn" id="MathJax-Span-101" style="font-family: STIXGeneral;">2</span><span class="mo" id="MathJax-Span-102" style="font-family: STIXGeneral; padding-left: 0.259em;">+</span><span class="mn" id="MathJax-Span-103" style="font-family: STIXGeneral; padding-left: 0.259em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       N
      </mi>
      <mrow class="MJX-TeXAtom-ORD">
       <mo>
        /
       </mo>
      </mrow>
      <mn>
       2
      </mn>
      <mo>
       +
      </mo>
      <mn>
       1
      </mn>
     </math></span></span><script type="math/tex" id="MathJax-Element-22">N/2+1</script>的大多数票，候选人还是可以成为leader。 <br> 3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。 <br> 4）以后可以通过心跳进行记账的通知。 <br> 5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 <br> 6）follower同意后，其成为leader，继续承担记账等指导工作。</p> 
  <h5 id="记账过程">记账过程</h5> 
  <p>Raft的记账过程按以下步骤完成： <br> 1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； <br> 2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； <br> 3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息； <br> 4）在下一个心跳中，leader会通知所有follower更新确认的项目。 <br> 对于每个新的交易记录，重复上述过程。</p> 
  <p>如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新更新。</p> 
  <p>如果想更直观的理解Raft协议，可以看<a href="http://thesecretlivesofdata.com/raft/" rel="nofollow">动画演示</a>。 <br> 论文原文：<a href="https://raft.github.io/raft.pdf" rel="nofollow">In Search of an Understandable Consensus Algorithm</a> <br> 学习参考：<a href="https://raft.github.io/" rel="nofollow">The Raft Consensus Algorithm</a></p> 
  <hr> 
  <h2 id="pow">PoW</h2> 
  <p>PoW的原理可参看这篇博文中哈希函数难题友好性这一节：<a href="http://blog.csdn.net/s_lisheng/article/details/77937202" rel="nofollow">http://blog.csdn.net/s_lisheng/article/details/77937202</a>，理解了难题友好性，就基本理解了PoW机制的原理。结合比特币去理解PoW。比特币PoW的过程，就是将不同的nonce值作为输入，尝试进行SHA256哈希运算，找出满足给定数量前导0的哈希值的过程。要求的前导0的个数越多，代表难度越大。比特币节点求解工作量证明问题的步骤归纳如下：</p> 
  <p>1）生成铸币交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle跟哈希； <br> 2）把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入； <br> 3）不停地变更区块头中的随机数nonce，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标难度做比对，如果满足难度条件，则解题成功，工作量证明完成。</p> 
  <hr> 
  <h2 id="pos">PoS</h2> 
  <p>PoW存在以下弊端：</p> 
  <ul> 
   <li>矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。</li> 
   <li>PoW存在巨大的算力浪费，看看矿池用掉多少电就知道了。</li> 
  </ul> 
  <p>PoS（权益证明，Proof of Stake）的出现很大程度上是因为PoW的缺陷而提出的。采用PoS的币中不同币的PoS不完全相同，权益证明要求用户证明拥有某些数量的货币（即对货币的权益），下面以点点币为例，理解PoS的思想。</p> 
  <p>点点币在SHA-256的哈希运算的难度方便引入了币龄的概念，使得难度与交易输入的币龄成反比。在点点币中，币龄被定义为币的数量与币所拥有的天数的乘积。点点币的权益证明机制结合了随机化与币龄的概念，未使用至少30天的币可以参与竞争下一区块，越久和越大的币集有更大的可能去签名下一区块。而一旦币的权益被用于签名一个区块，则币龄将清为零，这样必须等待至少30日才能签署另一个区块。同时，为防止非常老或非常大的权益控制区块链，寻找下一区块的最大概率在90天后达到最大值，这一过程保护了网络，并随着时间逐渐成为新的币而无需消耗大量的计算能力。</p> 
  <hr> 
  <h2 id="dpos">DPoS</h2> 
  <p>PoS机制虽然考虑了PoW的不足，但也有缺点：依据权益结余来选择，会导致首富账户的权力更大，有可能支配记账权。股份授权证明机制（Delegated Proof of Stake，DPoS），是对PoW、PoS不足的提出的。下面以比特股为例，理解DPoS的思想。</p> 
  <p>比特股引入了见证人这个概念，见证人可以生成区块，每一个持有比特股的人都可以投票选举见证人。得到总同意票数中的前<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-23-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-104" style="width: 0.873em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.72em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-105"><span class="mi" id="MathJax-Span-106" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       N
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-23">N</script>个（<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-24-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-107" style="width: 0.873em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.72em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-108"><span class="mi" id="MathJax-Span-109" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       N
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-24">N</script>通常定义为101）候选者可以当选为见证人，当选见证人的个数需满足：至少一半的参与投票者相信<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-25-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-110" style="width: 0.873em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.744em, 1000.72em, 2.718em, -999.997em); top: -2.559em; left: 0em;"><span class="mrow" id="MathJax-Span-111"><span class="mi" id="MathJax-Span-112" style="font-family: STIXGeneral; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.564em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       N
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-25">N</script>已经充分地去中心化。见证人的候选名单每个维护周期（1天）更新一次。见证人然后随机排列，每个见证人按序有2秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机等，持股人可以随时通过投票更换这些见证人。</p> 
  <p>可以看到，其核心思想是通过缩小参与核心共识过程的节点数量，以提高共识效率。（<em>这里可以认为选举见证人的过程为非核心共识过程，而见证人按序生成区块可以认为是核心共识过程</em>）</p> 
  <hr> 
  <p>参考资料： <br> <a href="http://www.jianshu.com/p/fb5edf031afd" rel="nofollow">拜占庭共识算法之PBFT</a> <br> <a href="http://thesecretlivesofdata.com/raft/" rel="nofollow">Raft动画演示</a> <br> <a href="https://raft.github.io/" rel="nofollow">The Raft Consensus Algorithm</a> <br> <a href="https://eprint.iacr.org/2016/716" rel="nofollow">2-hop Blockchain: Combining Proof-of-Work and Proof-of-Stake Securely</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/s_lisheng/article/details/78022645,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/s_lisheng/article/details/78022645,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
