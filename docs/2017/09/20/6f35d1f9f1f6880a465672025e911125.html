<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【Solidity】使用编译器 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【Solidity】使用编译器" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="使用编译器 使用命令行编译器 Solidity库的构建目标之一是solc，即solidity命令行编译器。 使用solc --help可以为您提供所有选项的解释。 编译器可以生成各种输出，从简单的二进制文件和通过抽象语法树（解析树）的汇编到气体使用的估计。 如果你只想编译一个文件，你可以运行它作为solc -bin sourceFile.sol，它将打印二进制文件。 在部署合同之前，请先使用solc --optimize --bin sourceFile.sol进行编译时激活优化器。 如果要获取一些更高级的solc的输出变量，最好使用solc -o outputDirectory --bin --ast --asm sourceFile.sol将其输出到单独的文件中。 命令行编译器将自动从文件系统读取导入的文件，但也可以通过以下方式使用prefix = path提供路径重定向： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这本质上指示编译器搜索任何从/usr/local/lib/dapp-bin下的github.com/ethereum/dapp-bin/开始的任何东西，如果没有找到该文件，它将会看/usr/local/lib/fallback（空前缀总是匹配）。 solc将不会从位于重映射目标之外的文件系统读取文件，而是在显式指定的源文件所在目录之外，因此import &quot;/etc/passwd&quot;; 只有在添加=/作为重映射时才可以工作。 如果重新映射有多个匹配项，则选择具有最长公用前缀的匹配项。 为了安全起见，编译器可以限制可以访问哪些目录。 允许在命令行上指定的源文件的路径（及其子目录）和重新映射定义的路径用于导入语句，但其他所有内容都被拒绝。 额外的路径（及其子目录）可以通--allow-paths /sample/path,/another/sample/path来实现。 如果您的合约使用库，您会注意到字节码中包含__LibraryName ___形式的子字符串。 您可以使用solc作为链接器，这意味着它会在这些点插入库地址： 添加--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;命令为每个库提供一个地址或将该字符串存储在一个文件（每行一个库）中，并使用--libraries fileName运行solc。 如果使用选项--link调用solc，所有输入文件将被解释为上面给出的__LibraryName ____格式中的未链接二进制文件（十六进制编码），并且是原位置的（如果输入是从stdin读取的，则写入 到stdout）。 在这种情况下，除了--libraries之外的所有选项都将被忽略（包括-o）。 如果使用--standard-json选项调用solc，则会在标准输入上输入JSON输入（如下所述），并在标准输出上返回一个JSON输出。 编译器输入和输出JSON描述 这些JSON格式由编译器API使用，也可以通过solc获得。 这些都可以更改，一些字段是可选的（如所指出），但其目的仅在于向后兼容的更改。 编译器API期望使用JSON格式的输入，并以JSON格式输出输出编译结果。 输入说明 { // 必须: 源代码用的语言, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // 必须 sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings (enabled defaults to false) optimizer: { enabled: true, runs: 500 }, // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出描述 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 阅读更多" />
<meta property="og:description" content="使用编译器 使用命令行编译器 Solidity库的构建目标之一是solc，即solidity命令行编译器。 使用solc --help可以为您提供所有选项的解释。 编译器可以生成各种输出，从简单的二进制文件和通过抽象语法树（解析树）的汇编到气体使用的估计。 如果你只想编译一个文件，你可以运行它作为solc -bin sourceFile.sol，它将打印二进制文件。 在部署合同之前，请先使用solc --optimize --bin sourceFile.sol进行编译时激活优化器。 如果要获取一些更高级的solc的输出变量，最好使用solc -o outputDirectory --bin --ast --asm sourceFile.sol将其输出到单独的文件中。 命令行编译器将自动从文件系统读取导入的文件，但也可以通过以下方式使用prefix = path提供路径重定向： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这本质上指示编译器搜索任何从/usr/local/lib/dapp-bin下的github.com/ethereum/dapp-bin/开始的任何东西，如果没有找到该文件，它将会看/usr/local/lib/fallback（空前缀总是匹配）。 solc将不会从位于重映射目标之外的文件系统读取文件，而是在显式指定的源文件所在目录之外，因此import &quot;/etc/passwd&quot;; 只有在添加=/作为重映射时才可以工作。 如果重新映射有多个匹配项，则选择具有最长公用前缀的匹配项。 为了安全起见，编译器可以限制可以访问哪些目录。 允许在命令行上指定的源文件的路径（及其子目录）和重新映射定义的路径用于导入语句，但其他所有内容都被拒绝。 额外的路径（及其子目录）可以通--allow-paths /sample/path,/another/sample/path来实现。 如果您的合约使用库，您会注意到字节码中包含__LibraryName ___形式的子字符串。 您可以使用solc作为链接器，这意味着它会在这些点插入库地址： 添加--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;命令为每个库提供一个地址或将该字符串存储在一个文件（每行一个库）中，并使用--libraries fileName运行solc。 如果使用选项--link调用solc，所有输入文件将被解释为上面给出的__LibraryName ____格式中的未链接二进制文件（十六进制编码），并且是原位置的（如果输入是从stdin读取的，则写入 到stdout）。 在这种情况下，除了--libraries之外的所有选项都将被忽略（包括-o）。 如果使用--standard-json选项调用solc，则会在标准输入上输入JSON输入（如下所述），并在标准输出上返回一个JSON输出。 编译器输入和输出JSON描述 这些JSON格式由编译器API使用，也可以通过solc获得。 这些都可以更改，一些字段是可选的（如所指出），但其目的仅在于向后兼容的更改。 编译器API期望使用JSON格式的输入，并以JSON格式输出输出编译结果。 输入说明 { // 必须: 源代码用的语言, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // 必须 sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings (enabled defaults to false) optimizer: { enabled: true, runs: 500 }, // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出描述 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"使用编译器 使用命令行编译器 Solidity库的构建目标之一是solc，即solidity命令行编译器。 使用solc --help可以为您提供所有选项的解释。 编译器可以生成各种输出，从简单的二进制文件和通过抽象语法树（解析树）的汇编到气体使用的估计。 如果你只想编译一个文件，你可以运行它作为solc -bin sourceFile.sol，它将打印二进制文件。 在部署合同之前，请先使用solc --optimize --bin sourceFile.sol进行编译时激活优化器。 如果要获取一些更高级的solc的输出变量，最好使用solc -o outputDirectory --bin --ast --asm sourceFile.sol将其输出到单独的文件中。 命令行编译器将自动从文件系统读取导入的文件，但也可以通过以下方式使用prefix = path提供路径重定向： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这本质上指示编译器搜索任何从/usr/local/lib/dapp-bin下的github.com/ethereum/dapp-bin/开始的任何东西，如果没有找到该文件，它将会看/usr/local/lib/fallback（空前缀总是匹配）。 solc将不会从位于重映射目标之外的文件系统读取文件，而是在显式指定的源文件所在目录之外，因此import &quot;/etc/passwd&quot;; 只有在添加=/作为重映射时才可以工作。 如果重新映射有多个匹配项，则选择具有最长公用前缀的匹配项。 为了安全起见，编译器可以限制可以访问哪些目录。 允许在命令行上指定的源文件的路径（及其子目录）和重新映射定义的路径用于导入语句，但其他所有内容都被拒绝。 额外的路径（及其子目录）可以通--allow-paths /sample/path,/another/sample/path来实现。 如果您的合约使用库，您会注意到字节码中包含__LibraryName ___形式的子字符串。 您可以使用solc作为链接器，这意味着它会在这些点插入库地址： 添加--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;命令为每个库提供一个地址或将该字符串存储在一个文件（每行一个库）中，并使用--libraries fileName运行solc。 如果使用选项--link调用solc，所有输入文件将被解释为上面给出的__LibraryName ____格式中的未链接二进制文件（十六进制编码），并且是原位置的（如果输入是从stdin读取的，则写入 到stdout）。 在这种情况下，除了--libraries之外的所有选项都将被忽略（包括-o）。 如果使用--standard-json选项调用solc，则会在标准输入上输入JSON输入（如下所述），并在标准输出上返回一个JSON输出。 编译器输入和输出JSON描述 这些JSON格式由编译器API使用，也可以通过solc获得。 这些都可以更改，一些字段是可选的（如所指出），但其目的仅在于向后兼容的更改。 编译器API期望使用JSON格式的输入，并以JSON格式输出输出编译结果。 输入说明 { // 必须: 源代码用的语言, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // 必须 sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings (enabled defaults to false) optimizer: { enabled: true, runs: 500 }, // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出描述 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 阅读更多","@type":"BlogPosting","url":"/2017/09/20/6f35d1f9f1f6880a465672025e911125.html","headline":"【Solidity】使用编译器","dateModified":"2017-09-20T00:00:00+08:00","datePublished":"2017-09-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/09/20/6f35d1f9f1f6880a465672025e911125.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【Solidity】使用编译器</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="使用编译器">使用编译器</h1> 
  <h2 id="使用命令行编译器">使用命令行编译器</h2> 
  <p>Solidity库的构建目标之一是solc，即solidity命令行编译器。 使用<code>solc --help</code>可以为您提供所有选项的解释。 编译器可以生成各种输出，从简单的二进制文件和通过抽象语法树（解析树）的汇编到气体使用的估计。 如果你只想编译一个文件，你可以运行它作为<code>solc -bin sourceFile.sol</code>，它将打印二进制文件。 在部署合同之前，请先使用<code>solc --optimize --bin sourceFile.sol</code>进行编译时激活优化器。 如果要获取一些更高级的solc的输出变量，最好使用<code>solc -o outputDirectory --bin --ast --asm sourceFile.sol</code>将其输出到单独的文件中。</p> 
  <p>命令行编译器将自动从文件系统读取导入的文件，但也可以通过以下方式使用<code>prefix = path</code>提供路径重定向：</p> 
  <pre class="prettyprint"><code class=" hljs ruby">solc github.com/ethereum/dapp-bin/=<span class="hljs-regexp">/usr/local</span><span class="hljs-regexp">/lib/dapp</span>-bin/ =<span class="hljs-regexp">/usr/local</span><span class="hljs-regexp">/lib/fallback</span> file.sol
</code></pre> 
  <p>这本质上指示编译器搜索任何从<code>/usr/local/lib/dapp-bin</code>下的<code>github.com/ethereum/dapp-bin/</code>开始的任何东西，如果没有找到该文件，它将会看<code>/usr/local/lib/fallback</code>（空前缀总是匹配）。 solc将不会从位于重映射目标之外的文件系统读取文件，而是在显式指定的源文件所在目录之外，因此<code>import "/etc/passwd";</code> 只有在添加<code>=/</code>作为重映射时才可以工作。</p> 
  <p>如果重新映射有多个匹配项，则选择具有最长公用前缀的匹配项。</p> 
  <p>为了安全起见，编译器可以限制可以访问哪些目录。 允许在命令行上指定的源文件的路径（及其子目录）和重新映射定义的路径用于导入语句，但其他所有内容都被拒绝。 额外的路径（及其子目录）可以通<code>--allow-paths /sample/path,/another/sample/path</code>来实现。</p> 
  <p>如果您的合约使用<a href="https://solidity.readthedocs.io/en/develop/contracts.html#libraries" rel="nofollow" target="_blank">库</a>，您会注意到字节码中包含<code>__LibraryName ___</code>形式的子字符串。 您可以使用<code>solc</code>作为链接器，这意味着它会在这些点插入库地址：</p> 
  <p>添加<code>--libraries "Math:0x12345678901234567890 Heap:0xabcdef0123456"</code>命令为每个库提供一个地址或将该字符串存储在一个文件（每行一个库）中，并使用<code>--libraries fileName</code>运行<code>solc</code>。</p> 
  <p>如果使用选项<code>--link</code>调用<code>solc</code>，所有输入文件将被解释为上面给出的<code>__LibraryName ____</code>格式中的未链接二进制文件（十六进制编码），并且是原位置的（如果输入是从stdin读取的，则写入 到stdout）。 在这种情况下，除了<code>--libraries</code>之外的所有选项都将被忽略（包括-o）。</p> 
  <p>如果使用<code>--standard-json</code>选项调用<code>solc</code>，则会在标准输入上输入JSON输入（如下所述），并在标准输出上返回一个JSON输出。</p> 
  <h2 id="编译器输入和输出json描述">编译器输入和输出JSON描述</h2> 
  <p>这些JSON格式由编译器API使用，也可以通过solc获得。 这些都可以更改，一些字段是可选的（如所指出），但其目的仅在于向后兼容的更改。</p> 
  <p>编译器API期望使用JSON格式的输入，并以JSON格式输出输出编译结果。</p> 
  <h3 id="输入说明">输入说明</h3> 
  <pre class="prettyprint"><code class=" hljs cs">{
  <span class="hljs-comment">// 必须: 源代码用的语言, such as "Solidity", "serpent", "lll", "assembly", etc.</span>
  language: <span class="hljs-string">"Solidity"</span>,
  <span class="hljs-comment">// 必须</span>
  sources:
  {
    <span class="hljs-comment">// The keys here are the "global" names of the source files,</span>
    <span class="hljs-comment">// imports can use other files via remappings (see below).</span>
    <span class="hljs-string">"myFile.sol"</span>:
    {
      <span class="hljs-comment">// Optional: keccak256 hash of the source file</span>
      <span class="hljs-comment">// It is used to verify the retrieved content if imported via URLs.</span>
      <span class="hljs-string">"keccak256"</span>: <span class="hljs-string">"0x123..."</span>,
      <span class="hljs-comment">// Required (unless "content" is used, see below): URL(s) to the source file.</span>
      <span class="hljs-comment">// URL(s) should be imported in this order and the result checked against the</span>
      <span class="hljs-comment">// keccak256 hash (if available). If the hash doesn't match or none of the</span>
      <span class="hljs-comment">// URL(s) result in success, an error should be raised.</span>
      <span class="hljs-string">"urls"</span>:
      [
        <span class="hljs-string">"bzzr://56ab..."</span>,
        <span class="hljs-string">"ipfs://Qma..."</span>,
        <span class="hljs-string">"file:///tmp/path/to/file.sol"</span>
      ]
    },
    <span class="hljs-string">"mortal"</span>:
    {
      <span class="hljs-comment">// Optional: keccak256 hash of the source file</span>
      <span class="hljs-string">"keccak256"</span>: <span class="hljs-string">"0x234..."</span>,
      <span class="hljs-comment">// Required (unless "urls" is used): literal contents of the source file</span>
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }"</span>
    }
  },
  <span class="hljs-comment">// Optional</span>
  settings:
  {
    <span class="hljs-comment">// Optional: Sorted list of remappings</span>
    remappings: [ <span class="hljs-string">":g/dir"</span> ],
    <span class="hljs-comment">// Optional: Optimizer settings (enabled defaults to false)</span>
    optimizer: {
      enabled: <span class="hljs-keyword">true</span>,
      runs: <span class="hljs-number">500</span>
    },
    <span class="hljs-comment">// Metadata settings (optional)</span>
    metadata: {
      <span class="hljs-comment">// Use only literal content and not URLs (false by default)</span>
      useLiteralContent: <span class="hljs-keyword">true</span>
    },
    <span class="hljs-comment">// Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.</span>
    libraries: {
      <span class="hljs-comment">// The top level key is the the name of the source file where the library is used.</span>
      <span class="hljs-comment">// If remappings are used, this source file should match the global path after remappings were applied.</span>
      <span class="hljs-comment">// If this key is an empty string, that refers to a global level.</span>
      <span class="hljs-string">"myFile.sol"</span>: {
        <span class="hljs-string">"MyLib"</span>: <span class="hljs-string">"0x123123..."</span>
      }
    }
    <span class="hljs-comment">// The following can be used to select desired outputs.</span>
    <span class="hljs-comment">// If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.</span>
    <span class="hljs-comment">// The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,</span>
    <span class="hljs-comment">// while the star refers to all of the contracts.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The available output types are as follows:</span>
    <span class="hljs-comment">// abi - ABI</span>
    <span class="hljs-comment">// ast - AST of all source files</span>
    <span class="hljs-comment">// legacyAST - legacy AST of all source files</span>
    <span class="hljs-comment">// devdoc - Developer documentation (natspec)</span>
    <span class="hljs-comment">// userdoc - User documentation (natspec)</span>
    <span class="hljs-comment">// metadata - Metadata</span>
    <span class="hljs-comment">// ir - New assembly format before desugaring</span>
    <span class="hljs-comment">// evm.assembly - New assembly format after desugaring</span>
    <span class="hljs-comment">// evm.legacyAssembly - Old-style assembly format in JSON</span>
    <span class="hljs-comment">// evm.bytecode.object - Bytecode object</span>
    <span class="hljs-comment">// evm.bytecode.opcodes - Opcodes list</span>
    <span class="hljs-comment">// evm.bytecode.sourceMap - Source mapping (useful for debugging)</span>
    <span class="hljs-comment">// evm.bytecode.linkReferences - Link references (if unlinked object)</span>
    <span class="hljs-comment">// evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)</span>
    <span class="hljs-comment">// evm.methodIdentifiers - The list of function hashes</span>
    <span class="hljs-comment">// evm.gasEstimates - Function gas estimates</span>
    <span class="hljs-comment">// ewasm.wast - eWASM S-expressions format (not supported atm)</span>
    <span class="hljs-comment">// ewasm.wasm - eWASM binary format (not supported atm)</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every</span>
    <span class="hljs-comment">// target part of that output.</span>
    <span class="hljs-comment">//</span>
    outputSelection: {
      <span class="hljs-comment">// Enable the metadata and bytecode outputs of every single contract.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">"*"</span>: [ <span class="hljs-string">"metadata"</span>, <span class="hljs-string">"evm.bytecode"</span> ]
      },
      <span class="hljs-comment">// Enable the abi and opcodes output of MyContract defined in file def.</span>
      <span class="hljs-string">"def"</span>: {
        <span class="hljs-string">"MyContract"</span>: [ <span class="hljs-string">"abi"</span>, <span class="hljs-string">"evm.opcodes"</span> ]
      },
      <span class="hljs-comment">// Enable the source map output of every single contract.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">"*"</span>: [ <span class="hljs-string">"evm.sourceMap"</span> ]
      },
      <span class="hljs-comment">// Enable the legacy AST output of every single file.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">""</span>: [ <span class="hljs-string">"legacyAST"</span> ]
      }
    }
  }
}</code></pre> 
  <h3 id="输出描述">输出描述</h3> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">{
 <span class="hljs-comment"> // Optional: not present if no errors/warnings were encountered</span>
  errors: [
    {
     <span class="hljs-comment"> // Optional: Location within the source file.</span>
      sourceLocation: {
        <span class="hljs-built_in">file</span>: <span class="hljs-string">"sourceFile.sol"</span>,
        start: <span class="hljs-number">0</span>,
        <span class="hljs-function"><span class="hljs-keyword">end</span>: <span class="hljs-title">100</span></span>
      ],
     <span class="hljs-comment"> // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc</span>
      type: <span class="hljs-string">"TypeError"</span>,
     <span class="hljs-comment"> // Mandatory: Component where the error originated, such as "general", "ewasm", etc.</span>
      component: <span class="hljs-string">"general"</span>,
     <span class="hljs-comment"> // Mandatory ("error" or "warning")</span>
      severity: <span class="hljs-string">"error"</span>,
     <span class="hljs-comment"> // Mandatory</span>
      message: <span class="hljs-string">"Invalid keyword"</span>
     <span class="hljs-comment"> // Optional: the message formatted with source location</span>
      formattedMessage: <span class="hljs-string">"sourceFile.sol:100: Invalid keyword"</span>
    }
  ],
 <span class="hljs-comment"> // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.</span>
  sources: {
    <span class="hljs-string">"sourceFile.sol"</span>: {
     <span class="hljs-comment"> // Identifier (used in source maps)</span>
      id: <span class="hljs-number">1</span>,
     <span class="hljs-comment"> // The AST object</span>
      ast: {},
     <span class="hljs-comment"> // The legacy AST object</span>
      legacyAST: {}
    }
  },
 <span class="hljs-comment"> // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.</span>
  contracts: {
    <span class="hljs-string">"sourceFile.sol"</span>: {
     <span class="hljs-comment"> // If the language used has no contract names, this field should equal to an empty string.</span>
      <span class="hljs-string">"ContractName"</span>: {
       <span class="hljs-comment"> // The Ethereum Contract ABI. If empty, it is represented as an empty array.</span>
       <span class="hljs-comment"> // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</span>
        abi: [],
       <span class="hljs-comment"> // See the Metadata Output documentation (serialised JSON string)</span>
        metadata: <span class="hljs-string">"{...}"</span>,
       <span class="hljs-comment"> // User documentation (natspec)</span>
        userdoc: {},
       <span class="hljs-comment"> // Developer documentation (natspec)</span>
        devdoc: {},
       <span class="hljs-comment"> // Intermediate representation (string)</span>
        ir: <span class="hljs-string">""</span>,
       <span class="hljs-comment"> // EVM-related outputs</span>
        evm: {
         <span class="hljs-comment"> // Assembly (string)</span>
          assembly: <span class="hljs-string">""</span>,
         <span class="hljs-comment"> // Old-style assembly (object)</span>
          legacyAssembly: {},
         <span class="hljs-comment"> // Bytecode and related details.</span>
          bytecode: {
           <span class="hljs-comment"> // The bytecode as a hex string.</span>
            object: <span class="hljs-string">"00fe"</span>,
           <span class="hljs-comment"> // Opcodes list (string)</span>
            opcodes: <span class="hljs-string">""</span>,
           <span class="hljs-comment"> // The source mapping as a string. See the source mapping definition.</span>
            sourceMap: <span class="hljs-string">""</span>,
           <span class="hljs-comment"> // If given, this is an unlinked object.</span>
            linkReferences: {
              <span class="hljs-string">"libraryFile.sol"</span>: {
               <span class="hljs-comment"> // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.</span>
                <span class="hljs-string">"Library1"</span>: [
                  { start: <span class="hljs-number">0</span>, <span class="hljs-built_in">length</span>: <span class="hljs-number">20</span> },
                  { start: <span class="hljs-number">200</span>, <span class="hljs-built_in">length</span>: <span class="hljs-number">20</span> }
                ]
              }
            }
          },
         <span class="hljs-comment"> // The same layout as above.</span>
          deployedBytecode: { },
         <span class="hljs-comment"> // The list of function hashes</span>
          methodIdentifiers: {
            <span class="hljs-string">"delegate(address)"</span>: <span class="hljs-string">"5c19a95c"</span>
          },
         <span class="hljs-comment"> // Function gas estimates</span>
          gasEstimates: {
            creation: {
              codeDepositCost: <span class="hljs-string">"420000"</span>,
              executionCost: <span class="hljs-string">"infinite"</span>,
              totalCost: <span class="hljs-string">"infinite"</span>
            },
            external: {
              <span class="hljs-string">"delegate(address)"</span>: <span class="hljs-string">"25000"</span>
            },
            internal: {
              <span class="hljs-string">"heavyLifting()"</span>: <span class="hljs-string">"infinite"</span>
            }
          }
        },
       <span class="hljs-comment"> // eWASM related outputs</span>
        ewasm: {
         <span class="hljs-comment"> // S-expressions format</span>
          wast: <span class="hljs-string">""</span>,
         <span class="hljs-comment"> // Binary format (hex string)</span>
          wasm: <span class="hljs-string">""</span>
        }
      }
    }
  }
}</code></pre> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78037969,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78037969,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
