<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码解析(15) - 可执行程序 - Bitcoind | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码解析(15) - 可执行程序 - Bitcoind" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0x01 Step 3: parameter-to-internal-flags - continue 由于Step 3中的内容太多，所以上一章未能完成，这一章继续分析Step 3中剩下的内容。 连接超时时间 nConnectTimeout = gArgs.GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; -timeout：表示在发起TCP连接时的等待时间，单位是毫秒，默认值为5000。 节点费用设置 if (gArgs.IsArgSet(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;), n)) { return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;))); } // High fee check is done afterward in WalletParameterInteraction() ::minRelayTxFee = CFeeRate(n); } else if (incrementalRelayFee &gt; ::minRelayTxFee) { // Allow only setting incrementalRelayFee to control both ::minRelayTxFee = incrementalRelayFee; LogPrintf(&quot;Increasing minrelaytxfee to %s to match incrementalrelayfee\n&quot;,::minRelayTxFee.ToString()); } // Sanity check argument for min fee for including tx in block // TODO: Harmonize which arguments need sanity checking and where that happens if (gArgs.IsArgSet(&quot;-blockmintxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;blockmintxfee&quot;, gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;))); } // Feerate used to define dust. Shouldn&#39;t be changed lightly as old // implementations may inadvertently create non-standard transactions if (gArgs.IsArgSet(&quot;-dustrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;), n) || 0 == n) return InitError(AmountErrMsg(&quot;dustrelayfee&quot;, gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;))); dustRelayFee = CFeeRate(n); } 在上一章http://blog.csdn.net/pure_lady/article/details/77982837#t3部分我们介绍了几种不同的费用，以及节点在收到交易时的处理流程。现在这里就到了设置这些变量的值的时候，首先是minrelayfee，最小转发费用，从代码中可以发现如果incrementalRelayFee大于minRelayFee ，那么minRelayFee=incrementalRelayFee。 -blockmintxfee：设置交易被打包进区块的最小费用率，单位为BTC/KB，默认值为0.00001。 接下来的blockmintxfee是针对矿工而言的，矿工在将交易打包进区块之前先判断交易费是否满足条件，避免出现入不敷出的情况，因为矿工在挖矿时也有一定的成本，而交易费也是收益的一部分来源，所以矿工也要尽量让自己利益最大化。最后的dustrelayfee在上一章也介绍过，这里只是读取命令行中设置的值并传给destRelayFee变量。 判断非标准交易 fRequireStandard = !gArgs.GetBoolArg(&quot;-acceptnonstdtxn&quot;, !chainparams.RequireStandard()); if (chainparams.RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); nBytesPerSigOp = gArgs.GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); -acceptnonstdtxn：是否接受或者转发非标准交易，只适用于testnet和regtest，默认值为1. -bytespersigop：设置交易中每个sigop的大小，单位为字节，默认值为20. 接下来就是判断chainparams中的参数和-acceptnonstdtxn参数的值是否相互冲突。-bytespersigop是用来计算交易大小的参数，配合nSigOpsCost，表示交易中操作符的数量，两者的乘积就是交易的大小，像下面的函数中实现的。 int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost) { return (std::max(nWeight, nSigOpCost * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR; } 初始化钱包参数&amp;设定交易中数据大小 #ifdef ENABLE_WALLET if (!WalletParameterInteraction()) return false; #endif fIsBareMultisigStd = gArgs.GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = gArgs.GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = gArgs.GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); 接下来这段代码首先判断是否启用了钱包，如果启用了，那么就进行钱包参数的初始化，点开WalletParameterInteraction()函数可以发现，该函数还是比较简单，就是把命令行中相应的参数赋值给CWallet中的变量，钱包部分暂且跳过，分析完主要功能部分之后可以再来单独分析钱包的实现。接下来分别设定三个参数， permitbaremultisig：是否允许转发non-P2SH多签名，默认值为1。 datacarrier：表示是否允许在交易中写入数据，默认为1. datacarriersize：表示交易中写入数据的最大大小，默认值为83. 系统中总共定义了6种交易类型，类型包含在CTxOut中的scriptPubKey中，交易主要分为两种：标准和非标准，除了非标准的，其他5种都是标准的交易，6种类型分别如下， 交易类型 描述 TX_NONSTANDARD 非标准的交易 TX_PUBKEY 公钥 TX_PUBKEYHASH 公钥哈希 TX_SCRIPTHASH 脚本哈希 TX_MULTISIG 多重签名 TX_NULL_DATA 空数据 datacarrier对应的类型就是最后一种TX_NULL_DATA，并由datacarriersize指定写入数据的最大长度，具体实现函数位于src/policy/policy.cpp中： bool IsStandard(const CScript&amp; scriptPubKey, txnouttype&amp; whichType, const bool witnessEnabled) { std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (!Solver(scriptPubKey, whichType, vSolutions)) // Solver函数解析scriptPubKey中的信息 return false; if (whichType == TX_MULTISIG) { unsigned char m = vSolutions.front()[0]; unsigned char n = vSolutions.back()[0]; // Support up to x-of-3 multisig txns as standard if (n &lt; 1 || n &gt; 3) return false; if (m &lt; 1 || m &gt; n) return false; } else if (whichType == TX_NULL_DATA &amp;&amp; (!fAcceptDatacarrier || scriptPubKey.size() &gt; nMaxDatacarrierBytes)) return false; // 这里判断 else if (!witnessEnabled &amp;&amp; (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH)) return false; return whichType != TX_NONSTANDARD; } Initial Block Download // Option to startup with mocktime set (used for regression testing): SetMockTime(gArgs.GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op if (gArgs.GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); nMaxTipAge = gArgs.GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 上面这段代码主要涉及下面几个参数： -mocktime=&lt;n&gt;：设定系统模拟时间，只适用于regression test，模拟时间表示将时间设置为创世后n秒，即时间从0年0月0日0时0分n秒开始。 -peerbloomfilters：是否支持使用bloom filter来过滤区块和交易，默认为1. -rpcserialversion：设置原始交易或者区块在non-verbose模式下的返回值，取值只有两种，0表示non-segwit，1表示segwit，默认值为1. -maxtipage：执行IBD(Initial block download)的最大时间间隔，单位为秒，默认值为86400，也就是24小时。 首先模拟时间比较容易理解，就是将当前时间设为0+n秒；接着peerbloomfilters参数决定是否开启bloom filter服务，该服务的主要功能是按照一定条件过滤某些特定的交易给自己或者其他节点；然后rpcserialversion设定序列化版本，具体在何处使用到还的看接下来的分析；最后maxtipage表示如果当前时间和本地区块链最后一个区块生成的时间差大于maxtipage那么将执行IBD函数，IBD函数表示要一次性下载大量的区块，具体介绍请参考https://bitcoin.org/en/developer-guide#initial-block-download，默认值为24小时，也就是说如果节点一天没有更新本地的区块链信息，那么就会执行IBD来从网络同步区块。 mempoolreplacement fEnableReplacement = gArgs.GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; gArgs.IsArgSet(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = gArgs.GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } -mempoolreplacement：启用内存池中的交易替换。 所谓交易替换就是指全节点的mempool中如果有多个交易花费了相同的inputs，那么他们之间允许替换。不过代码的if语句没有看懂，从第一句GetBoolArg()来看，mempoolreplacement应该是数值类型，但是后面又要在数值型中查找字符串，那结果肯定是false，所以还是不明白为什么这么写。 Regtest测试新deployments if (gArgs.IsArgSet(&quot;-vbparams&quot;)) { // Allow overriding version bits parameters for testing if (!chainparams.MineBlocksOnDemand()) { return InitError(&quot;Version bits parameters may only be overridden on regtest.&quot;); } for (const std::string&amp; strDeployment : gArgs.GetArgs(&quot;-vbparams&quot;)) { std::vector&lt;std::string&gt; vDeploymentParams; boost::split(vDeploymentParams, strDeployment, boost::is_any_of(&quot;:&quot;)); if (vDeploymentParams.size() != 3) { return InitError(&quot;Version bits parameters malformed, expecting deployment:start:end&quot;); } int64_t nStartTime, nTimeout; if (!ParseInt64(vDeploymentParams[1], &amp;nStartTime)) { return InitError(strprintf(&quot;Invalid nStartTime (%s)&quot;, vDeploymentParams[1])); } if (!ParseInt64(vDeploymentParams[2], &amp;nTimeout)) { return InitError(strprintf(&quot;Invalid nTimeout (%s)&quot;, vDeploymentParams[2])); } bool found = false; for (int j=0; j&lt;(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) { if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) { UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout); found = true; LogPrintf(&quot;Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n&quot;, vDeploymentParams[0], nStartTime, nTimeout); break; } } if (!found) { return InitError(strprintf(&quot;Invalid deployment (%s)&quot;, vDeploymentParams[0])); } } } -vbparams=deploytment:start:end：设置新的机制启用时间和终止时间，只用于regtest。 这个参数是用于测试新的功能，所以只用于regtest，首先检测chainparams中的fMineBlocksOnDemand参数是否为true，这个参数的含义是让miner在挖到新的block后停止挖矿，直到接到新的命令，而fMineBlocksOnDemand参数在main和testnet中都为false，只有在regtest中才为true，chainparams.MineBlocksOnDemand()函数就是直接返回fMineBlocksOnDemand变量的值。在命令行中可以指定多个-vbparams从而同时启用多个新的机制，代码中接下来的for循环就是枚举每一个机制进行处理，输入的形式是deployment:start:end，然后分别解析三个参数的值，其中第一个是string类型，后面两个是int64_t类型，解析完之后在系统的deployments表中查找对应名字的机制，系统的deployments表在src/versionbits.cpp中，如下， const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = { { /*.name =*/ &quot;testdummy&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;csv&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;segwit&quot;, /*.gbt_force =*/ true, } }; 可见目前只包含三个机制，每个机制又包含以下几个参数，该文件位于src/consensus/params.h中， /** * Struct for each individual consensus rule change using BIP9. */ struct BIP9Deployment { /** Bit position to select the particular bit in nVersion. */ int bit; /** Start MedianTime for version bits miner confirmation. Can be a date in the past */ int64_t nStartTime; /** Timeout/expiry MedianTime for the deployment attempt. */ int64_t nTimeout; }; 找到对应的名字之后就通过UpdateVersionBitsParameters()更新其中的nstartTime和nTimeout变量值。 到此，整个AppInitParameterInteraction()函数就分析完了，虽然很长，但基本上也都是一些参数的设置，所以还是很容易看懂，其中主要的还是需要查阅大量的资料，有些参数网上很少有相关的介绍，需要自己去在整个代码中搜索相关信息，然后理解它的含义。 阅读更多" />
<meta property="og:description" content="0x01 Step 3: parameter-to-internal-flags - continue 由于Step 3中的内容太多，所以上一章未能完成，这一章继续分析Step 3中剩下的内容。 连接超时时间 nConnectTimeout = gArgs.GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; -timeout：表示在发起TCP连接时的等待时间，单位是毫秒，默认值为5000。 节点费用设置 if (gArgs.IsArgSet(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;), n)) { return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;))); } // High fee check is done afterward in WalletParameterInteraction() ::minRelayTxFee = CFeeRate(n); } else if (incrementalRelayFee &gt; ::minRelayTxFee) { // Allow only setting incrementalRelayFee to control both ::minRelayTxFee = incrementalRelayFee; LogPrintf(&quot;Increasing minrelaytxfee to %s to match incrementalrelayfee\n&quot;,::minRelayTxFee.ToString()); } // Sanity check argument for min fee for including tx in block // TODO: Harmonize which arguments need sanity checking and where that happens if (gArgs.IsArgSet(&quot;-blockmintxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;blockmintxfee&quot;, gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;))); } // Feerate used to define dust. Shouldn&#39;t be changed lightly as old // implementations may inadvertently create non-standard transactions if (gArgs.IsArgSet(&quot;-dustrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;), n) || 0 == n) return InitError(AmountErrMsg(&quot;dustrelayfee&quot;, gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;))); dustRelayFee = CFeeRate(n); } 在上一章http://blog.csdn.net/pure_lady/article/details/77982837#t3部分我们介绍了几种不同的费用，以及节点在收到交易时的处理流程。现在这里就到了设置这些变量的值的时候，首先是minrelayfee，最小转发费用，从代码中可以发现如果incrementalRelayFee大于minRelayFee ，那么minRelayFee=incrementalRelayFee。 -blockmintxfee：设置交易被打包进区块的最小费用率，单位为BTC/KB，默认值为0.00001。 接下来的blockmintxfee是针对矿工而言的，矿工在将交易打包进区块之前先判断交易费是否满足条件，避免出现入不敷出的情况，因为矿工在挖矿时也有一定的成本，而交易费也是收益的一部分来源，所以矿工也要尽量让自己利益最大化。最后的dustrelayfee在上一章也介绍过，这里只是读取命令行中设置的值并传给destRelayFee变量。 判断非标准交易 fRequireStandard = !gArgs.GetBoolArg(&quot;-acceptnonstdtxn&quot;, !chainparams.RequireStandard()); if (chainparams.RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); nBytesPerSigOp = gArgs.GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); -acceptnonstdtxn：是否接受或者转发非标准交易，只适用于testnet和regtest，默认值为1. -bytespersigop：设置交易中每个sigop的大小，单位为字节，默认值为20. 接下来就是判断chainparams中的参数和-acceptnonstdtxn参数的值是否相互冲突。-bytespersigop是用来计算交易大小的参数，配合nSigOpsCost，表示交易中操作符的数量，两者的乘积就是交易的大小，像下面的函数中实现的。 int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost) { return (std::max(nWeight, nSigOpCost * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR; } 初始化钱包参数&amp;设定交易中数据大小 #ifdef ENABLE_WALLET if (!WalletParameterInteraction()) return false; #endif fIsBareMultisigStd = gArgs.GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = gArgs.GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = gArgs.GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); 接下来这段代码首先判断是否启用了钱包，如果启用了，那么就进行钱包参数的初始化，点开WalletParameterInteraction()函数可以发现，该函数还是比较简单，就是把命令行中相应的参数赋值给CWallet中的变量，钱包部分暂且跳过，分析完主要功能部分之后可以再来单独分析钱包的实现。接下来分别设定三个参数， permitbaremultisig：是否允许转发non-P2SH多签名，默认值为1。 datacarrier：表示是否允许在交易中写入数据，默认为1. datacarriersize：表示交易中写入数据的最大大小，默认值为83. 系统中总共定义了6种交易类型，类型包含在CTxOut中的scriptPubKey中，交易主要分为两种：标准和非标准，除了非标准的，其他5种都是标准的交易，6种类型分别如下， 交易类型 描述 TX_NONSTANDARD 非标准的交易 TX_PUBKEY 公钥 TX_PUBKEYHASH 公钥哈希 TX_SCRIPTHASH 脚本哈希 TX_MULTISIG 多重签名 TX_NULL_DATA 空数据 datacarrier对应的类型就是最后一种TX_NULL_DATA，并由datacarriersize指定写入数据的最大长度，具体实现函数位于src/policy/policy.cpp中： bool IsStandard(const CScript&amp; scriptPubKey, txnouttype&amp; whichType, const bool witnessEnabled) { std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (!Solver(scriptPubKey, whichType, vSolutions)) // Solver函数解析scriptPubKey中的信息 return false; if (whichType == TX_MULTISIG) { unsigned char m = vSolutions.front()[0]; unsigned char n = vSolutions.back()[0]; // Support up to x-of-3 multisig txns as standard if (n &lt; 1 || n &gt; 3) return false; if (m &lt; 1 || m &gt; n) return false; } else if (whichType == TX_NULL_DATA &amp;&amp; (!fAcceptDatacarrier || scriptPubKey.size() &gt; nMaxDatacarrierBytes)) return false; // 这里判断 else if (!witnessEnabled &amp;&amp; (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH)) return false; return whichType != TX_NONSTANDARD; } Initial Block Download // Option to startup with mocktime set (used for regression testing): SetMockTime(gArgs.GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op if (gArgs.GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); nMaxTipAge = gArgs.GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 上面这段代码主要涉及下面几个参数： -mocktime=&lt;n&gt;：设定系统模拟时间，只适用于regression test，模拟时间表示将时间设置为创世后n秒，即时间从0年0月0日0时0分n秒开始。 -peerbloomfilters：是否支持使用bloom filter来过滤区块和交易，默认为1. -rpcserialversion：设置原始交易或者区块在non-verbose模式下的返回值，取值只有两种，0表示non-segwit，1表示segwit，默认值为1. -maxtipage：执行IBD(Initial block download)的最大时间间隔，单位为秒，默认值为86400，也就是24小时。 首先模拟时间比较容易理解，就是将当前时间设为0+n秒；接着peerbloomfilters参数决定是否开启bloom filter服务，该服务的主要功能是按照一定条件过滤某些特定的交易给自己或者其他节点；然后rpcserialversion设定序列化版本，具体在何处使用到还的看接下来的分析；最后maxtipage表示如果当前时间和本地区块链最后一个区块生成的时间差大于maxtipage那么将执行IBD函数，IBD函数表示要一次性下载大量的区块，具体介绍请参考https://bitcoin.org/en/developer-guide#initial-block-download，默认值为24小时，也就是说如果节点一天没有更新本地的区块链信息，那么就会执行IBD来从网络同步区块。 mempoolreplacement fEnableReplacement = gArgs.GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; gArgs.IsArgSet(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = gArgs.GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } -mempoolreplacement：启用内存池中的交易替换。 所谓交易替换就是指全节点的mempool中如果有多个交易花费了相同的inputs，那么他们之间允许替换。不过代码的if语句没有看懂，从第一句GetBoolArg()来看，mempoolreplacement应该是数值类型，但是后面又要在数值型中查找字符串，那结果肯定是false，所以还是不明白为什么这么写。 Regtest测试新deployments if (gArgs.IsArgSet(&quot;-vbparams&quot;)) { // Allow overriding version bits parameters for testing if (!chainparams.MineBlocksOnDemand()) { return InitError(&quot;Version bits parameters may only be overridden on regtest.&quot;); } for (const std::string&amp; strDeployment : gArgs.GetArgs(&quot;-vbparams&quot;)) { std::vector&lt;std::string&gt; vDeploymentParams; boost::split(vDeploymentParams, strDeployment, boost::is_any_of(&quot;:&quot;)); if (vDeploymentParams.size() != 3) { return InitError(&quot;Version bits parameters malformed, expecting deployment:start:end&quot;); } int64_t nStartTime, nTimeout; if (!ParseInt64(vDeploymentParams[1], &amp;nStartTime)) { return InitError(strprintf(&quot;Invalid nStartTime (%s)&quot;, vDeploymentParams[1])); } if (!ParseInt64(vDeploymentParams[2], &amp;nTimeout)) { return InitError(strprintf(&quot;Invalid nTimeout (%s)&quot;, vDeploymentParams[2])); } bool found = false; for (int j=0; j&lt;(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) { if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) { UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout); found = true; LogPrintf(&quot;Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n&quot;, vDeploymentParams[0], nStartTime, nTimeout); break; } } if (!found) { return InitError(strprintf(&quot;Invalid deployment (%s)&quot;, vDeploymentParams[0])); } } } -vbparams=deploytment:start:end：设置新的机制启用时间和终止时间，只用于regtest。 这个参数是用于测试新的功能，所以只用于regtest，首先检测chainparams中的fMineBlocksOnDemand参数是否为true，这个参数的含义是让miner在挖到新的block后停止挖矿，直到接到新的命令，而fMineBlocksOnDemand参数在main和testnet中都为false，只有在regtest中才为true，chainparams.MineBlocksOnDemand()函数就是直接返回fMineBlocksOnDemand变量的值。在命令行中可以指定多个-vbparams从而同时启用多个新的机制，代码中接下来的for循环就是枚举每一个机制进行处理，输入的形式是deployment:start:end，然后分别解析三个参数的值，其中第一个是string类型，后面两个是int64_t类型，解析完之后在系统的deployments表中查找对应名字的机制，系统的deployments表在src/versionbits.cpp中，如下， const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = { { /*.name =*/ &quot;testdummy&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;csv&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;segwit&quot;, /*.gbt_force =*/ true, } }; 可见目前只包含三个机制，每个机制又包含以下几个参数，该文件位于src/consensus/params.h中， /** * Struct for each individual consensus rule change using BIP9. */ struct BIP9Deployment { /** Bit position to select the particular bit in nVersion. */ int bit; /** Start MedianTime for version bits miner confirmation. Can be a date in the past */ int64_t nStartTime; /** Timeout/expiry MedianTime for the deployment attempt. */ int64_t nTimeout; }; 找到对应的名字之后就通过UpdateVersionBitsParameters()更新其中的nstartTime和nTimeout变量值。 到此，整个AppInitParameterInteraction()函数就分析完了，虽然很长，但基本上也都是一些参数的设置，所以还是很容易看懂，其中主要的还是需要查阅大量的资料，有些参数网上很少有相关的介绍，需要自己去在整个代码中搜索相关信息，然后理解它的含义。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/20/018a1a2c07c644a7ba08c0de8b0a7963.html" />
<meta property="og:url" content="https://mlh.app/2017/09/20/018a1a2c07c644a7ba08c0de8b0a7963.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"0x01 Step 3: parameter-to-internal-flags - continue 由于Step 3中的内容太多，所以上一章未能完成，这一章继续分析Step 3中剩下的内容。 连接超时时间 nConnectTimeout = gArgs.GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; -timeout：表示在发起TCP连接时的等待时间，单位是毫秒，默认值为5000。 节点费用设置 if (gArgs.IsArgSet(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;), n)) { return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, gArgs.GetArg(&quot;-minrelaytxfee&quot;, &quot;&quot;))); } // High fee check is done afterward in WalletParameterInteraction() ::minRelayTxFee = CFeeRate(n); } else if (incrementalRelayFee &gt; ::minRelayTxFee) { // Allow only setting incrementalRelayFee to control both ::minRelayTxFee = incrementalRelayFee; LogPrintf(&quot;Increasing minrelaytxfee to %s to match incrementalrelayfee\\n&quot;,::minRelayTxFee.ToString()); } // Sanity check argument for min fee for including tx in block // TODO: Harmonize which arguments need sanity checking and where that happens if (gArgs.IsArgSet(&quot;-blockmintxfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;), n)) return InitError(AmountErrMsg(&quot;blockmintxfee&quot;, gArgs.GetArg(&quot;-blockmintxfee&quot;, &quot;&quot;))); } // Feerate used to define dust. Shouldn&#39;t be changed lightly as old // implementations may inadvertently create non-standard transactions if (gArgs.IsArgSet(&quot;-dustrelayfee&quot;)) { CAmount n = 0; if (!ParseMoney(gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;), n) || 0 == n) return InitError(AmountErrMsg(&quot;dustrelayfee&quot;, gArgs.GetArg(&quot;-dustrelayfee&quot;, &quot;&quot;))); dustRelayFee = CFeeRate(n); } 在上一章http://blog.csdn.net/pure_lady/article/details/77982837#t3部分我们介绍了几种不同的费用，以及节点在收到交易时的处理流程。现在这里就到了设置这些变量的值的时候，首先是minrelayfee，最小转发费用，从代码中可以发现如果incrementalRelayFee大于minRelayFee ，那么minRelayFee=incrementalRelayFee。 -blockmintxfee：设置交易被打包进区块的最小费用率，单位为BTC/KB，默认值为0.00001。 接下来的blockmintxfee是针对矿工而言的，矿工在将交易打包进区块之前先判断交易费是否满足条件，避免出现入不敷出的情况，因为矿工在挖矿时也有一定的成本，而交易费也是收益的一部分来源，所以矿工也要尽量让自己利益最大化。最后的dustrelayfee在上一章也介绍过，这里只是读取命令行中设置的值并传给destRelayFee变量。 判断非标准交易 fRequireStandard = !gArgs.GetBoolArg(&quot;-acceptnonstdtxn&quot;, !chainparams.RequireStandard()); if (chainparams.RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); nBytesPerSigOp = gArgs.GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); -acceptnonstdtxn：是否接受或者转发非标准交易，只适用于testnet和regtest，默认值为1. -bytespersigop：设置交易中每个sigop的大小，单位为字节，默认值为20. 接下来就是判断chainparams中的参数和-acceptnonstdtxn参数的值是否相互冲突。-bytespersigop是用来计算交易大小的参数，配合nSigOpsCost，表示交易中操作符的数量，两者的乘积就是交易的大小，像下面的函数中实现的。 int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost) { return (std::max(nWeight, nSigOpCost * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR; } 初始化钱包参数&amp;设定交易中数据大小 #ifdef ENABLE_WALLET if (!WalletParameterInteraction()) return false; #endif fIsBareMultisigStd = gArgs.GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = gArgs.GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = gArgs.GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); 接下来这段代码首先判断是否启用了钱包，如果启用了，那么就进行钱包参数的初始化，点开WalletParameterInteraction()函数可以发现，该函数还是比较简单，就是把命令行中相应的参数赋值给CWallet中的变量，钱包部分暂且跳过，分析完主要功能部分之后可以再来单独分析钱包的实现。接下来分别设定三个参数， permitbaremultisig：是否允许转发non-P2SH多签名，默认值为1。 datacarrier：表示是否允许在交易中写入数据，默认为1. datacarriersize：表示交易中写入数据的最大大小，默认值为83. 系统中总共定义了6种交易类型，类型包含在CTxOut中的scriptPubKey中，交易主要分为两种：标准和非标准，除了非标准的，其他5种都是标准的交易，6种类型分别如下， 交易类型 描述 TX_NONSTANDARD 非标准的交易 TX_PUBKEY 公钥 TX_PUBKEYHASH 公钥哈希 TX_SCRIPTHASH 脚本哈希 TX_MULTISIG 多重签名 TX_NULL_DATA 空数据 datacarrier对应的类型就是最后一种TX_NULL_DATA，并由datacarriersize指定写入数据的最大长度，具体实现函数位于src/policy/policy.cpp中： bool IsStandard(const CScript&amp; scriptPubKey, txnouttype&amp; whichType, const bool witnessEnabled) { std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (!Solver(scriptPubKey, whichType, vSolutions)) // Solver函数解析scriptPubKey中的信息 return false; if (whichType == TX_MULTISIG) { unsigned char m = vSolutions.front()[0]; unsigned char n = vSolutions.back()[0]; // Support up to x-of-3 multisig txns as standard if (n &lt; 1 || n &gt; 3) return false; if (m &lt; 1 || m &gt; n) return false; } else if (whichType == TX_NULL_DATA &amp;&amp; (!fAcceptDatacarrier || scriptPubKey.size() &gt; nMaxDatacarrierBytes)) return false; // 这里判断 else if (!witnessEnabled &amp;&amp; (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH)) return false; return whichType != TX_NONSTANDARD; } Initial Block Download // Option to startup with mocktime set (used for regression testing): SetMockTime(gArgs.GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op if (gArgs.GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (gArgs.GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); nMaxTipAge = gArgs.GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 上面这段代码主要涉及下面几个参数： -mocktime=&lt;n&gt;：设定系统模拟时间，只适用于regression test，模拟时间表示将时间设置为创世后n秒，即时间从0年0月0日0时0分n秒开始。 -peerbloomfilters：是否支持使用bloom filter来过滤区块和交易，默认为1. -rpcserialversion：设置原始交易或者区块在non-verbose模式下的返回值，取值只有两种，0表示non-segwit，1表示segwit，默认值为1. -maxtipage：执行IBD(Initial block download)的最大时间间隔，单位为秒，默认值为86400，也就是24小时。 首先模拟时间比较容易理解，就是将当前时间设为0+n秒；接着peerbloomfilters参数决定是否开启bloom filter服务，该服务的主要功能是按照一定条件过滤某些特定的交易给自己或者其他节点；然后rpcserialversion设定序列化版本，具体在何处使用到还的看接下来的分析；最后maxtipage表示如果当前时间和本地区块链最后一个区块生成的时间差大于maxtipage那么将执行IBD函数，IBD函数表示要一次性下载大量的区块，具体介绍请参考https://bitcoin.org/en/developer-guide#initial-block-download，默认值为24小时，也就是说如果节点一天没有更新本地的区块链信息，那么就会执行IBD来从网络同步区块。 mempoolreplacement fEnableReplacement = gArgs.GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; gArgs.IsArgSet(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = gArgs.GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } -mempoolreplacement：启用内存池中的交易替换。 所谓交易替换就是指全节点的mempool中如果有多个交易花费了相同的inputs，那么他们之间允许替换。不过代码的if语句没有看懂，从第一句GetBoolArg()来看，mempoolreplacement应该是数值类型，但是后面又要在数值型中查找字符串，那结果肯定是false，所以还是不明白为什么这么写。 Regtest测试新deployments if (gArgs.IsArgSet(&quot;-vbparams&quot;)) { // Allow overriding version bits parameters for testing if (!chainparams.MineBlocksOnDemand()) { return InitError(&quot;Version bits parameters may only be overridden on regtest.&quot;); } for (const std::string&amp; strDeployment : gArgs.GetArgs(&quot;-vbparams&quot;)) { std::vector&lt;std::string&gt; vDeploymentParams; boost::split(vDeploymentParams, strDeployment, boost::is_any_of(&quot;:&quot;)); if (vDeploymentParams.size() != 3) { return InitError(&quot;Version bits parameters malformed, expecting deployment:start:end&quot;); } int64_t nStartTime, nTimeout; if (!ParseInt64(vDeploymentParams[1], &amp;nStartTime)) { return InitError(strprintf(&quot;Invalid nStartTime (%s)&quot;, vDeploymentParams[1])); } if (!ParseInt64(vDeploymentParams[2], &amp;nTimeout)) { return InitError(strprintf(&quot;Invalid nTimeout (%s)&quot;, vDeploymentParams[2])); } bool found = false; for (int j=0; j&lt;(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) { if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) { UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout); found = true; LogPrintf(&quot;Setting version bits activation parameters for %s to start=%ld, timeout=%ld\\n&quot;, vDeploymentParams[0], nStartTime, nTimeout); break; } } if (!found) { return InitError(strprintf(&quot;Invalid deployment (%s)&quot;, vDeploymentParams[0])); } } } -vbparams=deploytment:start:end：设置新的机制启用时间和终止时间，只用于regtest。 这个参数是用于测试新的功能，所以只用于regtest，首先检测chainparams中的fMineBlocksOnDemand参数是否为true，这个参数的含义是让miner在挖到新的block后停止挖矿，直到接到新的命令，而fMineBlocksOnDemand参数在main和testnet中都为false，只有在regtest中才为true，chainparams.MineBlocksOnDemand()函数就是直接返回fMineBlocksOnDemand变量的值。在命令行中可以指定多个-vbparams从而同时启用多个新的机制，代码中接下来的for循环就是枚举每一个机制进行处理，输入的形式是deployment:start:end，然后分别解析三个参数的值，其中第一个是string类型，后面两个是int64_t类型，解析完之后在系统的deployments表中查找对应名字的机制，系统的deployments表在src/versionbits.cpp中，如下， const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = { { /*.name =*/ &quot;testdummy&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;csv&quot;, /*.gbt_force =*/ true, }, { /*.name =*/ &quot;segwit&quot;, /*.gbt_force =*/ true, } }; 可见目前只包含三个机制，每个机制又包含以下几个参数，该文件位于src/consensus/params.h中， /** * Struct for each individual consensus rule change using BIP9. */ struct BIP9Deployment { /** Bit position to select the particular bit in nVersion. */ int bit; /** Start MedianTime for version bits miner confirmation. Can be a date in the past */ int64_t nStartTime; /** Timeout/expiry MedianTime for the deployment attempt. */ int64_t nTimeout; }; 找到对应的名字之后就通过UpdateVersionBitsParameters()更新其中的nstartTime和nTimeout变量值。 到此，整个AppInitParameterInteraction()函数就分析完了，虽然很长，但基本上也都是一些参数的设置，所以还是很容易看懂，其中主要的还是需要查阅大量的资料，有些参数网上很少有相关的介绍，需要自己去在整个代码中搜索相关信息，然后理解它的含义。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/20/018a1a2c07c644a7ba08c0de8b0a7963.html","headline":"比特币源码解析(15) - 可执行程序 - Bitcoind","dateModified":"2017-09-20T00:00:00+08:00","datePublished":"2017-09-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/20/018a1a2c07c644a7ba08c0de8b0a7963.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码解析(15) - 可执行程序 - Bitcoind</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h2 id="0x01-step-3-parameter-to-internal-flags-continue">0x01 Step 3: parameter-to-internal-flags - continue</h2> 
  <p>由于Step 3中的内容太多，所以上一章未能完成，这一章继续分析Step 3中剩下的内容。</p> 
  <h3 id="连接超时时间">连接超时时间</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs bash">    nConnectTimeout = gArgs.GetArg(<span class="hljs-string">"-timeout"</span>, DEFAULT_CONNECT_TIMEOUT);
    <span class="hljs-keyword">if</span> (nConnectTimeout &lt;= <span class="hljs-number">0</span>)
        nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;</code></pre> 
  <blockquote> 
   <p><code>-timeout</code>：表示在发起TCP连接时的等待时间，单位是毫秒，默认值为5000。</p> 
  </blockquote> 
  <h3 id="节点费用设置">节点费用设置</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs lasso">   <span class="hljs-keyword">if</span> (gArgs<span class="hljs-built_in">.</span>IsArgSet(<span class="hljs-string">"-minrelaytxfee"</span>)) {
        CAmount n <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>ParseMoney(gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-minrelaytxfee"</span>, <span class="hljs-string">""</span>), n)) {
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"minrelaytxfee"</span>, gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-minrelaytxfee"</span>, <span class="hljs-string">""</span>)));
        }
        <span class="hljs-comment">// High fee check is done afterward in WalletParameterInteraction()</span>
        <span class="hljs-tag">::minRelayTxFee</span> <span class="hljs-subst">=</span> CFeeRate(n);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (incrementalRelayFee <span class="hljs-subst">&gt;</span> <span class="hljs-tag">::minRelayTxFee</span>) {
        <span class="hljs-comment">// Allow only setting incrementalRelayFee to control both</span>
        <span class="hljs-tag">::minRelayTxFee</span> <span class="hljs-subst">=</span> incrementalRelayFee;
        LogPrintf(<span class="hljs-string">"Increasing minrelaytxfee to %s to match incrementalrelayfee\n"</span>,<span class="hljs-tag">::minRelayTxFee.ToString</span>());
    }

    <span class="hljs-comment">// Sanity check argument for min fee for including tx in block</span>
    <span class="hljs-comment">// TODO: Harmonize which arguments need sanity checking and where that happens</span>
    <span class="hljs-keyword">if</span> (gArgs<span class="hljs-built_in">.</span>IsArgSet(<span class="hljs-string">"-blockmintxfee"</span>))
    {
        CAmount n <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>ParseMoney(gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-blockmintxfee"</span>, <span class="hljs-string">""</span>), n))
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"blockmintxfee"</span>, gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-blockmintxfee"</span>, <span class="hljs-string">""</span>)));
    }

    <span class="hljs-comment">// Feerate used to define dust. Shouldn't be changed lightly as old</span>
    <span class="hljs-comment">// implementations may inadvertently create non-standard transactions</span>
    <span class="hljs-keyword">if</span> (gArgs<span class="hljs-built_in">.</span>IsArgSet(<span class="hljs-string">"-dustrelayfee"</span>))
    {
        CAmount n <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>ParseMoney(gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-dustrelayfee"</span>, <span class="hljs-string">""</span>), n) <span class="hljs-subst">||</span> <span class="hljs-number">0</span> <span class="hljs-subst">==</span> n)
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"dustrelayfee"</span>, gArgs<span class="hljs-built_in">.</span>GetArg(<span class="hljs-string">"-dustrelayfee"</span>, <span class="hljs-string">""</span>)));
        dustRelayFee <span class="hljs-subst">=</span> CFeeRate(n);
    }</code></pre> 
  <p>在上一章<a href="http://blog.csdn.net/pure_lady/article/details/77982837#t3" rel="nofollow" target="_blank">http://blog.csdn.net/pure_lady/article/details/77982837#t3</a>部分我们介绍了几种不同的费用，以及节点在收到交易时的处理流程。现在这里就到了设置这些变量的值的时候，首先是<code>minrelayfee</code>，最小转发费用，从代码中可以发现如果<code>incrementalRelayFee</code>大于<code>minRelayFee</code> ，那么<code>minRelayFee=incrementalRelayFee</code>。</p> 
  <blockquote> 
   <p><code>-blockmintxfee</code>：设置交易被打包进区块的最小费用率，单位为BTC/KB，默认值为0.00001。</p> 
  </blockquote> 
  <p>接下来的<code>blockmintxfee</code>是针对矿工而言的，矿工在将交易打包进区块之前先判断交易费是否满足条件，避免出现入不敷出的情况，因为矿工在挖矿时也有一定的成本，而交易费也是收益的一部分来源，所以矿工也要尽量让自己利益最大化。最后的<code>dustrelayfee</code>在上一章也介绍过，这里只是读取命令行中设置的值并传给<code>destRelayFee</code>变量。</p> 
  <h3 id="判断非标准交易">判断非标准交易</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs avrasm">    fRequireStandard = !gArgs<span class="hljs-preprocessor">.GetBoolArg</span>(<span class="hljs-string">"-acceptnonstdtxn"</span>, !chainparams<span class="hljs-preprocessor">.RequireStandard</span>())<span class="hljs-comment">;</span>
    if (chainparams<span class="hljs-preprocessor">.RequireStandard</span>() &amp;&amp; !fRequireStandard)
        return InitError(strprintf(<span class="hljs-string">"acceptnonstdtxn is not currently supported for %s chain"</span>, chainparams<span class="hljs-preprocessor">.NetworkIDString</span>()))<span class="hljs-comment">;</span>
    nBytesPerSigOp = gArgs<span class="hljs-preprocessor">.GetArg</span>(<span class="hljs-string">"-bytespersigop"</span>, nBytesPerSigOp)<span class="hljs-comment">;</span></code></pre> 
  <blockquote> 
   <p><code>-acceptnonstdtxn</code>：是否接受或者转发非标准交易，只适用于testnet和regtest，默认值为1.</p> 
   <p><code>-bytespersigop</code>：设置交易中每个sigop的大小，单位为字节，默认值为20.</p> 
  </blockquote> 
  <p>接下来就是判断chainparams中的参数和<code>-acceptnonstdtxn</code>参数的值是否相互冲突。<code>-bytespersigop</code>是用来计算交易大小的参数，配合<code>nSigOpsCost</code>，表示交易中操作符的数量，两者的乘积就是交易的大小，像下面的函数中实现的。</p> 
  <pre class="prettyprint"><code class="language-c++ hljs ruby">int64_t <span class="hljs-constant">GetVirtualTransactionSize</span>(int64_t nWeight, int64_t nSigOpCost)
{
    <span class="hljs-keyword">return</span> (<span class="hljs-symbol">std:</span><span class="hljs-symbol">:max</span>(nWeight, nSigOpCost * nBytesPerSigOp) + <span class="hljs-constant">WITNESS_SCALE_FACTOR</span> - <span class="hljs-number">1</span>) / <span class="hljs-constant">WITNESS_SCALE_FACTOR</span>;
}</code></pre> 
  <h3 id="初始化钱包参数设定交易中数据大小">初始化钱包参数&amp;设定交易中数据大小</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cs"><span class="hljs-preprocessor">#ifdef ENABLE_WALLET</span>
    <span class="hljs-keyword">if</span> (!WalletParameterInteraction())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

    fIsBareMultisigStd = gArgs.GetBoolArg(<span class="hljs-string">"-permitbaremultisig"</span>, DEFAULT_PERMIT_BAREMULTISIG);
    fAcceptDatacarrier = gArgs.GetBoolArg(<span class="hljs-string">"-datacarrier"</span>, DEFAULT_ACCEPT_DATACARRIER);
    nMaxDatacarrierBytes = gArgs.GetArg(<span class="hljs-string">"-datacarriersize"</span>, nMaxDatacarrierBytes);</code></pre> 
  <p>接下来这段代码首先判断是否启用了钱包，如果启用了，那么就进行钱包参数的初始化，点开<code>WalletParameterInteraction()</code>函数可以发现，该函数还是比较简单，就是把命令行中相应的参数赋值给<code>CWallet</code>中的变量，钱包部分暂且跳过，分析完主要功能部分之后可以再来单独分析钱包的实现。接下来分别设定三个参数，</p> 
  <blockquote> 
   <p><code>permitbaremultisig</code>：是否允许转发<code>non-P2SH</code>多签名，默认值为1。</p> 
   <p><code>datacarrier</code>：表示是否允许在交易中写入数据，默认为1.</p> 
   <p><code>datacarriersize</code>：表示交易中写入数据的最大大小，默认值为83.</p> 
  </blockquote> 
  <p>系统中总共定义了6种交易类型，类型包含在<code>CTxOut</code>中的<code>scriptPubKey</code>中，交易主要分为两种：标准和非标准，除了非标准的，其他5种都是标准的交易，6种类型分别如下，</p> 
  <table> 
   <thead> 
    <tr> 
     <th>交易类型</th> 
     <th>描述</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td><code>TX_NONSTANDARD</code></td> 
     <td>非标准的交易</td> 
    </tr> 
    <tr> 
     <td><code>TX_PUBKEY</code></td> 
     <td>公钥</td> 
    </tr> 
    <tr> 
     <td><code>TX_PUBKEYHASH</code></td> 
     <td>公钥哈希</td> 
    </tr> 
    <tr> 
     <td><code>TX_SCRIPTHASH</code></td> 
     <td>脚本哈希</td> 
    </tr> 
    <tr> 
     <td><code>TX_MULTISIG</code></td> 
     <td>多重签名</td> 
    </tr> 
    <tr> 
     <td><code>TX_NULL_DATA</code></td> 
     <td>空数据</td> 
    </tr> 
   </tbody>
  </table> 
  <p><code>datacarrier</code>对应的类型就是最后一种<code>TX_NULL_DATA</code>，并由<code>datacarriersize</code>指定写入数据的最大长度，具体实现函数位于<code>src/policy/policy.cpp</code>中：</p> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-keyword">bool</span> IsStandard(<span class="hljs-keyword">const</span> CScript&amp; scriptPubKey, txnouttype&amp; whichType, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> witnessEnabled)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> &gt;</span> vSolutions;
    <span class="hljs-keyword">if</span> (!Solver(scriptPubKey, whichType, vSolutions))  <span class="hljs-comment">// Solver函数解析scriptPubKey中的信息</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">if</span> (whichType == TX_MULTISIG)
    {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> m = vSolutions.front()[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> n = vSolutions.back()[<span class="hljs-number">0</span>];
        <span class="hljs-comment">// Support up to x-of-3 multisig txns as standard</span>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || n &gt; <span class="hljs-number">3</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1</span> || m &gt; n)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (whichType == TX_NULL_DATA &amp;&amp;
               (!fAcceptDatacarrier || scriptPubKey.size() &gt; nMaxDatacarrierBytes))
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 这里判断</span>

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!witnessEnabled &amp;&amp; (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">return</span> whichType != TX_NONSTANDARD;
}</code></pre> 
  <h3 id="initial-block-download">Initial Block Download</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs vhdl">    // Option <span class="hljs-keyword">to</span> startup <span class="hljs-keyword">with</span> mocktime set (used <span class="hljs-keyword">for</span> regression testing):
    SetMockTime(gArgs.GetArg(<span class="hljs-string">"-mocktime"</span>, <span class="hljs-number">0</span>)); // SetMockTime(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> a no-op

    <span class="hljs-keyword">if</span> (gArgs.GetBoolArg(<span class="hljs-string">"-peerbloomfilters"</span>, DEFAULT_PEERBLOOMFILTERS))
        nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM);

    <span class="hljs-keyword">if</span> (gArgs.GetArg(<span class="hljs-string">"-rpcserialversion"</span>, DEFAULT_RPC_SERIALIZE_VERSION) &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"rpcserialversion must be non-negative."</span>);

    <span class="hljs-keyword">if</span> (gArgs.GetArg(<span class="hljs-string">"-rpcserialversion"</span>, DEFAULT_RPC_SERIALIZE_VERSION) &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"unknown rpcserialversion requested."</span>);

    nMaxTipAge = gArgs.GetArg(<span class="hljs-string">"-maxtipage"</span>, DEFAULT_MAX_TIP_AGE);</code></pre> 
  <p>上面这段代码主要涉及下面几个参数：</p> 
  <blockquote> 
   <p><code>-mocktime=&lt;n&gt;</code>：设定系统模拟时间，只适用于regression test，模拟时间表示将时间设置为创世后n秒，即时间从0年0月0日0时0分n秒开始。</p> 
   <p><code>-peerbloomfilters</code>：是否支持使用bloom filter来过滤区块和交易，默认为1.</p> 
   <p><code>-rpcserialversion</code>：设置原始交易或者区块在non-verbose模式下的返回值，取值只有两种，0表示non-segwit，1表示segwit，默认值为1.</p> 
   <p><code>-maxtipage</code>：执行IBD(Initial block download)的最大时间间隔，单位为秒，默认值为86400，也就是24小时。</p> 
  </blockquote> 
  <p>首先模拟时间比较容易理解，就是将当前时间设为0+n秒；接着<code>peerbloomfilters</code>参数决定是否开启bloom filter服务，该服务的主要功能是按照一定条件过滤某些特定的交易给自己或者其他节点；然后<code>rpcserialversion</code>设定序列化版本，具体在何处使用到还的看接下来的分析；最后<code>maxtipage</code>表示如果当前时间和本地区块链最后一个区块生成的时间差大于<code>maxtipage</code>那么将执行<code>IBD</code>函数，IBD函数表示要一次性下载大量的区块，具体介绍请参考<a href="https://bitcoin.org/en/developer-guide#initial-block-download" rel="nofollow" target="_blank">https://bitcoin.org/en/developer-guide#initial-block-download</a>，默认值为24小时，也就是说如果节点一天没有更新本地的区块链信息，那么就会执行IBD来从网络同步区块。</p> 
  <h3 id="mempoolreplacement">mempoolreplacement</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    fEnableReplacement = gArgs.GetBoolArg(<span class="hljs-string">"-mempoolreplacement"</span>, DEFAULT_ENABLE_REPLACEMENT);
    <span class="hljs-keyword">if</span> ((!fEnableReplacement) &amp;&amp; gArgs.IsArgSet(<span class="hljs-string">"-mempoolreplacement"</span>)) {
        <span class="hljs-comment">// Minimal effort at forwards compatibility</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strReplacementModeList = gArgs.GetArg(<span class="hljs-string">"-mempoolreplacement"</span>, <span class="hljs-string">""</span>);  <span class="hljs-comment">// default is impossible</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> vstrReplacementModes;
        boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(<span class="hljs-string">","</span>));
        fEnableReplacement = (<span class="hljs-built_in">std</span>::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), <span class="hljs-string">"fee"</span>) != vstrReplacementModes.end());
    }</code></pre> 
  <blockquote> 
   <p><code>-mempoolreplacement</code>：启用内存池中的交易替换。</p> 
  </blockquote> 
  <p>所谓交易替换就是指全节点的mempool中如果有多个交易花费了相同的inputs，那么他们之间允许替换。不过代码的<code>if</code>语句没有看懂，从第一句<code>GetBoolArg()</code>来看，<code>mempoolreplacement</code>应该是数值类型，但是后面又要在数值型中查找字符串，那结果肯定是<code>false</code>，所以还是不明白为什么这么写。</p> 
  <h3 id="regtest测试新deployments">Regtest测试新deployments</h3> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp">    <span class="hljs-keyword">if</span> (gArgs.IsArgSet(<span class="hljs-string">"-vbparams"</span>)) {
        <span class="hljs-comment">// Allow overriding version bits parameters for testing</span>
        <span class="hljs-keyword">if</span> (!chainparams.MineBlocksOnDemand()) {
            <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"Version bits parameters may only be overridden on regtest."</span>);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strDeployment : gArgs.GetArgs(<span class="hljs-string">"-vbparams"</span>)) {
            <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(<span class="hljs-string">":"</span>));
            <span class="hljs-keyword">if</span> (vDeploymentParams.size() != <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"Version bits parameters malformed, expecting deployment:start:end"</span>);
            }
            int64_t nStartTime, nTimeout;
            <span class="hljs-keyword">if</span> (!ParseInt64(vDeploymentParams[<span class="hljs-number">1</span>], &amp;nStartTime)) {
                <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-string">"Invalid nStartTime (%s)"</span>, vDeploymentParams[<span class="hljs-number">1</span>]));
            }
            <span class="hljs-keyword">if</span> (!ParseInt64(vDeploymentParams[<span class="hljs-number">2</span>], &amp;nTimeout)) {
                <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-string">"Invalid nTimeout (%s)"</span>, vDeploymentParams[<span class="hljs-number">2</span>]));
            }
            <span class="hljs-keyword">bool</span> found = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;(<span class="hljs-keyword">int</span>)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                <span class="hljs-keyword">if</span> (vDeploymentParams[<span class="hljs-number">0</span>].compare(VersionBitsDeploymentInfo[j].name) == <span class="hljs-number">0</span>) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = <span class="hljs-keyword">true</span>;
                    LogPrintf(<span class="hljs-string">"Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n"</span>, vDeploymentParams[<span class="hljs-number">0</span>], nStartTime, nTimeout);
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (!found) {
                <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-string">"Invalid deployment (%s)"</span>, vDeploymentParams[<span class="hljs-number">0</span>]));
            }
        }
    }</code></pre> 
  <blockquote> 
   <p><code>-vbparams=deploytment:start:end</code>：设置新的机制启用时间和终止时间，只用于regtest。</p> 
  </blockquote> 
  <p>这个参数是用于测试新的功能，所以只用于regtest，首先检测<code>chainparams</code>中的<code>fMineBlocksOnDemand</code>参数是否为<code>true</code>，这个参数的含义是让miner在挖到新的block后停止挖矿，直到接到新的命令，而<code>fMineBlocksOnDemand</code>参数在<code>main</code>和<code>testnet</code>中都为<code>false</code>，只有在<code>regtest</code>中才为<code>true</code>，<code>chainparams.MineBlocksOnDemand()</code>函数就是直接返回<code>fMineBlocksOnDemand</code>变量的值。在命令行中可以指定多个<code>-vbparams</code>从而同时启用多个新的机制，代码中接下来的for循环就是枚举每一个机制进行处理，输入的形式是<code>deployment:start:end</code>，然后分别解析三个参数的值，其中第一个是<code>string</code>类型，后面两个是<code>int64_t</code>类型，解析完之后在系统的deployments表中查找对应名字的机制，系统的deployments表在<code>src/versionbits.cpp</code>中，如下，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs cs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        <span class="hljs-comment">/*.name =*/</span> <span class="hljs-string">"testdummy"</span>,
        <span class="hljs-comment">/*.gbt_force =*/</span> <span class="hljs-keyword">true</span>,
    },
    {
        <span class="hljs-comment">/*.name =*/</span> <span class="hljs-string">"csv"</span>,
        <span class="hljs-comment">/*.gbt_force =*/</span> <span class="hljs-keyword">true</span>,
    },
    {
        <span class="hljs-comment">/*.name =*/</span> <span class="hljs-string">"segwit"</span>,
        <span class="hljs-comment">/*.gbt_force =*/</span> <span class="hljs-keyword">true</span>,
    }
};</code></pre> 
  <p>可见目前只包含三个机制，每个机制又包含以下几个参数，该文件位于<code>src/consensus/params.h</code>中，</p> 
  <pre class="prettyprint"><code class="language-c++ hljs java"><span class="hljs-javadoc">/** * Struct for each individual consensus rule change using BIP9. */</span>
struct BIP9Deployment {
    <span class="hljs-javadoc">/** Bit position to select the particular bit in nVersion. */</span>
    <span class="hljs-keyword">int</span> bit;
    <span class="hljs-javadoc">/** Start MedianTime for version bits miner confirmation. Can be a date in the past */</span>
    int64_t nStartTime;
    <span class="hljs-javadoc">/** Timeout/expiry MedianTime for the deployment attempt. */</span>
    int64_t nTimeout;
};</code></pre> 
  <p>找到对应的名字之后就通过<code>UpdateVersionBitsParameters()</code>更新其中的<code>nstartTime</code>和<code>nTimeout</code>变量值。</p> 
  <p>到此，整个<code>AppInitParameterInteraction()</code>函数就分析完了，虽然很长，但基本上也都是一些参数的设置，所以还是很容易看懂，其中主要的还是需要查阅大量的资料，有些参数网上很少有相关的介绍，需要自己去在整个代码中搜索相关信息，然后理解它的含义。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78037699,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/pure_lady/article/details/78037699,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
