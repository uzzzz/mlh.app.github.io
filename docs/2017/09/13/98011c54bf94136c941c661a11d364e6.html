<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>深入浅出谈以太坊智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="深入浅出谈以太坊智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文节选自图书《区块链开发指南》 区块链方向投稿，文章纠错，寻求报道可邮件联系 jiawd@csdn.net 什么是合约? 合约是代码（它的功能）和数据（它的状态）的集合，存在于以太坊区块链的特定地址。 合约账户能够在彼此之间传递信息，进行图灵完备的运算。合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。 合约很典型地用诸如Solidity等高级语言写成，然后编译成字节代码上传到区块链上。 也有其他语言可以用于编写智能合约如Serpent和LLL，在下一节会进一步阐述。去中心化应用开发资源列出了综合的开发环境，帮助你用这些语言开发的开发者工具，提供测试和部署支持等功能。 以太坊高级语言 合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。然而，合约是很典型地用诸如Solidity等高级语言写成的，它会用以太坊虚拟机编译器编译成字节代码上传到区块链。 下面是开发者可以用来为以太坊写智能合约的高级语言。 Solidity Solidity是和JavaScript相似的语言，你可以用它来开发合约并编译成以太坊虚拟机字节代码。它目前是以太坊最受欢迎的语言。 Serpent Serpent是和Python类似的语言，可以用于开发合约编译成以太坊虚拟机字节代码。它力求简洁， 将低级语言在效率方面的优点和编程风格的操作简易相结合，同时合约编程增加了独特的领域特定功能。Serpent用LLL编译。 LLL Lisp Like Language (LLL)是和Assembly类似的低级语言。它追求极简；本质上只是直接对以太坊虚拟机的一点包装。 Mutan (弃用) Mutan是个静态类型，由Jeffrey Wilcke 开发设计的C类语言。它已经不再受到维护。 写合约 没有Hello World程序，语言就不完整。Solidity在以太坊环境内操作，没有明显的“输出”字符串的方式。我们能做的最接近的事就是用日志记录事件来把字符串放进区块链，示例如下： contract HelloWorld { event Print(string out); function() { Print(&quot;Hello, World!&quot;); } } 每次执行时，这个合约都会在区块链创建一个日志入口，印着“Hello,World!”参数。 另请参阅：Solidity docs里有更多写Solidity代码的示例和指导。 编译合约 solidity合约的编译可以通过很多机制完成。 通过命令行使用solc编译器实现。 在geth或eth提供的javascript控制台使用web3.eth.compile.solidity (这仍然需要安装solc 编译器)实现。 通过在线Solidity实时编译器实现。 通过建立solidity合约的Meteor dapp Cosmo实现。 通过Mix IDE实现。 通过以太坊钱包实现。 注意：关于solc和编译Solidity合约代码的更多信息可在此查看。 1. 在geth设置solidity编译器 如果你启动了geth节点，就可以查看哪个编译器可用。示例如下： \&gt; web3.eth.getCompilers(); [&quot;lll&quot;, &quot;solidity&quot;, &quot;serpent&quot;] 这一指令会返回到显示当前哪个编译器可用的字符串。 注意：solc编译器和cpp- ethereum一起安装。或者，你可以自己创建。 如果你的solc可执行文件不在标准位置，可以用—solc标志为solc可执行文件指定一个定制路线。示例如下： $ geth --solc /usr/local/bin/solc 或者你可以通过控制台在执行期间设置这个选项： \&gt; admin.setSolc(&quot;/usr/local/bin/solc&quot;) solc, the solidity compiler commandline interface Version: 0.2.2-02bb315d/.-Darwin/appleclang/JIT linked to libethereum-1.2.0-8007cef0/.-Darwin/appleclang/JIT path: /usr/local/bin/solc 2. 编译一个简单合约 让我们来编译一个简单的合约源，示例如下： source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; 这个合约提供了一个单一方法multiply，它和一个正整数a调用并返回到a*7。 下面准备在geth JS控制台用eth.compile.solidity()编译solidity代码： \&gt; contract = eth.compile.solidity(source).test { code: &#39;605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056&#39;, info: { language: &#39;Solidity&#39;, languageVersion: &#39;0&#39;, compilerVersion: &#39;0.9.13&#39;, abiDefinition: [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ], name: &#39;multiply&#39;, outputs: [{ name: &#39;d&#39;, type: &#39;uint256&#39; } ], type: &#39;function&#39; } ], userDoc: { methods: { } }, developerDoc: { methods: { } }, source: &#39;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&#39; } } 注意：编译器通过RPC因此也能通过web3.js，对浏览器内任何通过RPC/IPC连接到geth的Ðapp可用。 下面的例子会向你展示如何通过JSON-RPC接合geth来使用编译器。 \$ geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain &#39; * &#39; --mine console 2&gt;&gt; ~/eth/eth.log $ curl -X POST --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_compileSolidity&quot;,&quot;params&quot;:[&quot;contract test { 单源编译器输出会给出你合约对象，每个都代表一个单独的合约。eth.compile.solidity 的实际返还值是合约名字到合约对象的映射。由于合约名字是test，eth.compile.solidity(source).test会给出包含下列领域的测试合约对： Code：编译的以太坊虚拟机字节代码。 Info：从编译器输出的额外元数据。 Source：源代码。 Language：合约语言 (Solidity，Serpent，LLL)。 LanguageVersion：合约语言版本。 compilerVersion：用于编译这个合约的solidity编译器版本。 abiDefinition：应用的二进制界面定义。 userDoc：用户的NatSpec Doc。 developerDoc：开发者的NatSpec Doc。 编译器输出的直接结构化(到code和info)反映了两种非常不同的部署路径。编译的以太坊虚拟机代码和一个合约创建交易被发送到区块，剩下的(info)在理想状态下会存活在去中心化云上，公开验证的元数据则执行区块链上的代码。 如果你的源包含多个合约，输出会包括每个合约一个入口，对应的合约信息对象可以用作为属性名称的合约名字检索到。你可以通过检测当前的GlobalRegistrar代码来试一下： contracts = eth.compile.solidity(globalRegistrarSrc) 创建和部署合约 开始阅读这一节之前，确保你有解锁的账户和一些资金。 现在在区块链上创建一个合约，方法是用上一章节的以太坊虚拟机代码作为数据给空地址发送交易。示例如下： 注意：用在线Solidity实时编译器或Mix IDE程序会更容易完成。 var primaryAddress = eth.accounts[0] var abi = [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ] var MyContract = eth.contract(abi) var contract = MyContract.new(arg1, arg2, ..., {from: primaryAddress, data: evmByteCodeFromPrevio 所有的二进制数据都以十六进制的格式序列化。十六进制字符串总会有一个十六进制前缀0x。 注意：注意arg1, arg2, …是合约构造函数参数，以备它要接受参数。如果合约不需要构造函数参数，就可以忽略这些参数。 值得指出的是，这一步骤需要你支付执行。一旦交易成功进入到区块，你的账户余额(你作为发送方放在from领域)会根据以太坊虚拟机的gas规则被扣减。一段时间以后，你的交易会在一个区块中出现，确认它带来的状态是共识。你的合约现在存在于区块链上。 以不同步的方式做同样的事看起来是这样： MyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) { if (!err &amp;&amp; contract.address) console.log(contract.address); }); 与合约互动 与合约互动典型的做法是用诸如eth.contract()功能的抽象层，它会返回到javascript对象，和所有可用的合约功能一起，作为可调用的javascript功能。 描述合约可用功能的标准方式是ABI定义。这个对象是一个字符串，它描述了调用签名和每个可用合约功能的返回值。示例如下： var Multiply7 = eth.contract(contract.info.abiDefinition); var myMultiply7 = Multiply7.at(address); 现在ABI中具体说明的所有功能调用都在合约实例中可用。你可以用两种方法中的一种来调用这些合约实例上的方法。 \&gt; myMultiply7.multiply.sendTransaction(3, {from: address}) &quot;0x12345&quot; &gt; myMultiply7.multiply.call(3) 21 当用sendTransaction被调用的时候，功能调用通过发送交易来执行。需要花费以太币来发送，调用会永久记录在区块链上。用这种方式进行的调用返回值是交易散表。 当用call被调用的时候，功能在以太坊虚拟机被本地执行，功能返回值和功能一起返回。用这种方式进行的调用不会记录在区块链上，因此也不会改变合约内部状态。这种调用方式被称为恒定功能调用。以这种方式进行的调用不花费以太币。 如果你只对返回值感兴趣，那么你应该用call。如果你只关心合约状态的副作用，就应该用sendTransaction。 在上面的例子中，不会产生副作用，因此sendTransaction只会烧gas，增加宇宙的熵。 合约元数据 在之前的章节中，揭示了怎样在区块链上创建合约。现在来处理剩下的编译器输出，合约元数据或者说合约信息。 在与不是你创建的合约互动时，你可能会想要文档或者查看源代码。合约作者被鼓励提供这样的可见信息，他们可以在区块链上登记或者借助第三方服务，比如说EtherChain。管理员API为所有选择登记的合约提供便利的方法来获取这个捆绑。示例如下： // get the contract info for contract address to do manual verification var info = admin.getContractInfo(address) // lookup, fetch, decode var source = info.source; var abiDef = info.abiDefinition 这项工作的潜在机制是： 合约信息被可以公开访问的URI上传到可辨认的地方。 任何人都可以只知道合约地址就找到是什么URI。 仅通过2个步骤的区块链注册就可以实现这些要求。第一步是在被称作HashReg的合约中用内容散表注册合约代码（散表）。第二步是在UrlHint合约用内容散表注册一个url。这些注册合约是Frontier版本的一部分，已经参与到Homestead中。 要知道合约地址来查询url，获取实际合约元数据信息包，使用这一机制就足够了。 如果你是个尽职的合约创建者，请遵循以下步骤： 将合约本身部署到区块链 获取合约信息json文件 将合约信息json文件部署到你选择的任意url 注册代码散表 -&gt;内容散表 -&gt; url JS API通过提供助手把这个过程变得非常容易。 调用admin.register从合约中提取信息，在指定文件中写出json序列，运算文件的内容散表，最终将这个内容散表注册到合约代码散表。一旦将那个文件部署到任意url，你就能用admin.registerUrl来注册url 和你区块链上的内容散表(注意，一旦固定的内容选址模式被用作文件商店，url-hint不再必要了) 。 source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; // compile with solc contract = eth.compile.solidity(source).test // create contract object var MyContract = eth.contract(contract.info.abiDefinition) // extracts info from contract, save the json serialisation in the given file, contenthash = admin.saveInfo(contract.info, &quot;~/dapps/shared/contracts/test/info.json&quot;)// send off the contract to the blockchain MyContract.new({from: primaryAccount, data: contract.code}, function(error, contract){ if(!error &amp;&amp; contract.address) { // calculates the content hash and registers it with the code hash in `HashReg` // it uses address to send the transaction. // returns the content hash that we use to register a url admin.register(primaryAccount, contract.address, contenthash) // here you deploy ~/dapps/shared/contracts/test/info.json to a url admin.registerUrl(primaryAccount, hash, url) } }); 测试合约和交易 在为交易和合约排除故障时，你通常会需要一些低级的测试策略。这一章节将介绍一些你可以用到的排错工作和做法。为了测试合约和交易而不产生实际的后果，最好在私有区块链上测试。这可以通过配置一个替代网络ID (选择一个特别的数字)和/或不能用的端点来实现。推荐做法是，为了测试你用一个替代数据目录和端口，这样就不会意外地和实时运行的节点冲突(假定用默认运行。在虚拟机排错模式开启geth，推荐性能分析和最高的日志冗余级别)： geth --datadir ~/dapps/testing/00/ --port 30310 --rpcport 8110 --networkid 4567890 --nodiscover - 提交交易之前，你需要创建私有测试链（参阅测试网络相关章节），示例如下： // create account. will prompt for password personal.newAccount(); // name your primary account, will often use it primary = eth.accounts[0]; // check your balance (denominated in ether) balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); // assume an existing unlocked primary account primary = eth.accounts[0]; // mine 10 blocks to generate ether // starting miner miner.start(4); // sleep for 10 blocks (this can take quite some time). admin.sleepBlocks(10); // then stop mining (just not to burn heat in vain) miner.stop(); balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); 创建交易之后，你可以用下面的命令来强制运行： miner.start(1); admin.sleepBlocks(1); miner.stop(); 你也可以用以下命令查看即将发生的交易： // shows transaction pool txpool.status // number of pending txs eth.getBlockTransactionCount(“pending”); // print all pending txs eth.getBlock(“pending”, true).transactions 如果你提交合约创建交易，可以检查想要的代码是否实际上嵌入到当前的区块链： txhash = eth.sendTansaction({from:primary, data: code}) //... mining contractaddress = eth.getTransactionReceipt(txhash); eth.getCode(contractaddress) 《区块链开发指南》由 申屠青春 主编，由 宋波、张鹏、汪晓明、季宙栋、左川民 联合编著，中国三大区块链联盟的大伽联袂推荐。 阅读更多" />
<meta property="og:description" content="本文节选自图书《区块链开发指南》 区块链方向投稿，文章纠错，寻求报道可邮件联系 jiawd@csdn.net 什么是合约? 合约是代码（它的功能）和数据（它的状态）的集合，存在于以太坊区块链的特定地址。 合约账户能够在彼此之间传递信息，进行图灵完备的运算。合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。 合约很典型地用诸如Solidity等高级语言写成，然后编译成字节代码上传到区块链上。 也有其他语言可以用于编写智能合约如Serpent和LLL，在下一节会进一步阐述。去中心化应用开发资源列出了综合的开发环境，帮助你用这些语言开发的开发者工具，提供测试和部署支持等功能。 以太坊高级语言 合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。然而，合约是很典型地用诸如Solidity等高级语言写成的，它会用以太坊虚拟机编译器编译成字节代码上传到区块链。 下面是开发者可以用来为以太坊写智能合约的高级语言。 Solidity Solidity是和JavaScript相似的语言，你可以用它来开发合约并编译成以太坊虚拟机字节代码。它目前是以太坊最受欢迎的语言。 Serpent Serpent是和Python类似的语言，可以用于开发合约编译成以太坊虚拟机字节代码。它力求简洁， 将低级语言在效率方面的优点和编程风格的操作简易相结合，同时合约编程增加了独特的领域特定功能。Serpent用LLL编译。 LLL Lisp Like Language (LLL)是和Assembly类似的低级语言。它追求极简；本质上只是直接对以太坊虚拟机的一点包装。 Mutan (弃用) Mutan是个静态类型，由Jeffrey Wilcke 开发设计的C类语言。它已经不再受到维护。 写合约 没有Hello World程序，语言就不完整。Solidity在以太坊环境内操作，没有明显的“输出”字符串的方式。我们能做的最接近的事就是用日志记录事件来把字符串放进区块链，示例如下： contract HelloWorld { event Print(string out); function() { Print(&quot;Hello, World!&quot;); } } 每次执行时，这个合约都会在区块链创建一个日志入口，印着“Hello,World!”参数。 另请参阅：Solidity docs里有更多写Solidity代码的示例和指导。 编译合约 solidity合约的编译可以通过很多机制完成。 通过命令行使用solc编译器实现。 在geth或eth提供的javascript控制台使用web3.eth.compile.solidity (这仍然需要安装solc 编译器)实现。 通过在线Solidity实时编译器实现。 通过建立solidity合约的Meteor dapp Cosmo实现。 通过Mix IDE实现。 通过以太坊钱包实现。 注意：关于solc和编译Solidity合约代码的更多信息可在此查看。 1. 在geth设置solidity编译器 如果你启动了geth节点，就可以查看哪个编译器可用。示例如下： \&gt; web3.eth.getCompilers(); [&quot;lll&quot;, &quot;solidity&quot;, &quot;serpent&quot;] 这一指令会返回到显示当前哪个编译器可用的字符串。 注意：solc编译器和cpp- ethereum一起安装。或者，你可以自己创建。 如果你的solc可执行文件不在标准位置，可以用—solc标志为solc可执行文件指定一个定制路线。示例如下： $ geth --solc /usr/local/bin/solc 或者你可以通过控制台在执行期间设置这个选项： \&gt; admin.setSolc(&quot;/usr/local/bin/solc&quot;) solc, the solidity compiler commandline interface Version: 0.2.2-02bb315d/.-Darwin/appleclang/JIT linked to libethereum-1.2.0-8007cef0/.-Darwin/appleclang/JIT path: /usr/local/bin/solc 2. 编译一个简单合约 让我们来编译一个简单的合约源，示例如下： source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; 这个合约提供了一个单一方法multiply，它和一个正整数a调用并返回到a*7。 下面准备在geth JS控制台用eth.compile.solidity()编译solidity代码： \&gt; contract = eth.compile.solidity(source).test { code: &#39;605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056&#39;, info: { language: &#39;Solidity&#39;, languageVersion: &#39;0&#39;, compilerVersion: &#39;0.9.13&#39;, abiDefinition: [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ], name: &#39;multiply&#39;, outputs: [{ name: &#39;d&#39;, type: &#39;uint256&#39; } ], type: &#39;function&#39; } ], userDoc: { methods: { } }, developerDoc: { methods: { } }, source: &#39;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&#39; } } 注意：编译器通过RPC因此也能通过web3.js，对浏览器内任何通过RPC/IPC连接到geth的Ðapp可用。 下面的例子会向你展示如何通过JSON-RPC接合geth来使用编译器。 \$ geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain &#39; * &#39; --mine console 2&gt;&gt; ~/eth/eth.log $ curl -X POST --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_compileSolidity&quot;,&quot;params&quot;:[&quot;contract test { 单源编译器输出会给出你合约对象，每个都代表一个单独的合约。eth.compile.solidity 的实际返还值是合约名字到合约对象的映射。由于合约名字是test，eth.compile.solidity(source).test会给出包含下列领域的测试合约对： Code：编译的以太坊虚拟机字节代码。 Info：从编译器输出的额外元数据。 Source：源代码。 Language：合约语言 (Solidity，Serpent，LLL)。 LanguageVersion：合约语言版本。 compilerVersion：用于编译这个合约的solidity编译器版本。 abiDefinition：应用的二进制界面定义。 userDoc：用户的NatSpec Doc。 developerDoc：开发者的NatSpec Doc。 编译器输出的直接结构化(到code和info)反映了两种非常不同的部署路径。编译的以太坊虚拟机代码和一个合约创建交易被发送到区块，剩下的(info)在理想状态下会存活在去中心化云上，公开验证的元数据则执行区块链上的代码。 如果你的源包含多个合约，输出会包括每个合约一个入口，对应的合约信息对象可以用作为属性名称的合约名字检索到。你可以通过检测当前的GlobalRegistrar代码来试一下： contracts = eth.compile.solidity(globalRegistrarSrc) 创建和部署合约 开始阅读这一节之前，确保你有解锁的账户和一些资金。 现在在区块链上创建一个合约，方法是用上一章节的以太坊虚拟机代码作为数据给空地址发送交易。示例如下： 注意：用在线Solidity实时编译器或Mix IDE程序会更容易完成。 var primaryAddress = eth.accounts[0] var abi = [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ] var MyContract = eth.contract(abi) var contract = MyContract.new(arg1, arg2, ..., {from: primaryAddress, data: evmByteCodeFromPrevio 所有的二进制数据都以十六进制的格式序列化。十六进制字符串总会有一个十六进制前缀0x。 注意：注意arg1, arg2, …是合约构造函数参数，以备它要接受参数。如果合约不需要构造函数参数，就可以忽略这些参数。 值得指出的是，这一步骤需要你支付执行。一旦交易成功进入到区块，你的账户余额(你作为发送方放在from领域)会根据以太坊虚拟机的gas规则被扣减。一段时间以后，你的交易会在一个区块中出现，确认它带来的状态是共识。你的合约现在存在于区块链上。 以不同步的方式做同样的事看起来是这样： MyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) { if (!err &amp;&amp; contract.address) console.log(contract.address); }); 与合约互动 与合约互动典型的做法是用诸如eth.contract()功能的抽象层，它会返回到javascript对象，和所有可用的合约功能一起，作为可调用的javascript功能。 描述合约可用功能的标准方式是ABI定义。这个对象是一个字符串，它描述了调用签名和每个可用合约功能的返回值。示例如下： var Multiply7 = eth.contract(contract.info.abiDefinition); var myMultiply7 = Multiply7.at(address); 现在ABI中具体说明的所有功能调用都在合约实例中可用。你可以用两种方法中的一种来调用这些合约实例上的方法。 \&gt; myMultiply7.multiply.sendTransaction(3, {from: address}) &quot;0x12345&quot; &gt; myMultiply7.multiply.call(3) 21 当用sendTransaction被调用的时候，功能调用通过发送交易来执行。需要花费以太币来发送，调用会永久记录在区块链上。用这种方式进行的调用返回值是交易散表。 当用call被调用的时候，功能在以太坊虚拟机被本地执行，功能返回值和功能一起返回。用这种方式进行的调用不会记录在区块链上，因此也不会改变合约内部状态。这种调用方式被称为恒定功能调用。以这种方式进行的调用不花费以太币。 如果你只对返回值感兴趣，那么你应该用call。如果你只关心合约状态的副作用，就应该用sendTransaction。 在上面的例子中，不会产生副作用，因此sendTransaction只会烧gas，增加宇宙的熵。 合约元数据 在之前的章节中，揭示了怎样在区块链上创建合约。现在来处理剩下的编译器输出，合约元数据或者说合约信息。 在与不是你创建的合约互动时，你可能会想要文档或者查看源代码。合约作者被鼓励提供这样的可见信息，他们可以在区块链上登记或者借助第三方服务，比如说EtherChain。管理员API为所有选择登记的合约提供便利的方法来获取这个捆绑。示例如下： // get the contract info for contract address to do manual verification var info = admin.getContractInfo(address) // lookup, fetch, decode var source = info.source; var abiDef = info.abiDefinition 这项工作的潜在机制是： 合约信息被可以公开访问的URI上传到可辨认的地方。 任何人都可以只知道合约地址就找到是什么URI。 仅通过2个步骤的区块链注册就可以实现这些要求。第一步是在被称作HashReg的合约中用内容散表注册合约代码（散表）。第二步是在UrlHint合约用内容散表注册一个url。这些注册合约是Frontier版本的一部分，已经参与到Homestead中。 要知道合约地址来查询url，获取实际合约元数据信息包，使用这一机制就足够了。 如果你是个尽职的合约创建者，请遵循以下步骤： 将合约本身部署到区块链 获取合约信息json文件 将合约信息json文件部署到你选择的任意url 注册代码散表 -&gt;内容散表 -&gt; url JS API通过提供助手把这个过程变得非常容易。 调用admin.register从合约中提取信息，在指定文件中写出json序列，运算文件的内容散表，最终将这个内容散表注册到合约代码散表。一旦将那个文件部署到任意url，你就能用admin.registerUrl来注册url 和你区块链上的内容散表(注意，一旦固定的内容选址模式被用作文件商店，url-hint不再必要了) 。 source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; // compile with solc contract = eth.compile.solidity(source).test // create contract object var MyContract = eth.contract(contract.info.abiDefinition) // extracts info from contract, save the json serialisation in the given file, contenthash = admin.saveInfo(contract.info, &quot;~/dapps/shared/contracts/test/info.json&quot;)// send off the contract to the blockchain MyContract.new({from: primaryAccount, data: contract.code}, function(error, contract){ if(!error &amp;&amp; contract.address) { // calculates the content hash and registers it with the code hash in `HashReg` // it uses address to send the transaction. // returns the content hash that we use to register a url admin.register(primaryAccount, contract.address, contenthash) // here you deploy ~/dapps/shared/contracts/test/info.json to a url admin.registerUrl(primaryAccount, hash, url) } }); 测试合约和交易 在为交易和合约排除故障时，你通常会需要一些低级的测试策略。这一章节将介绍一些你可以用到的排错工作和做法。为了测试合约和交易而不产生实际的后果，最好在私有区块链上测试。这可以通过配置一个替代网络ID (选择一个特别的数字)和/或不能用的端点来实现。推荐做法是，为了测试你用一个替代数据目录和端口，这样就不会意外地和实时运行的节点冲突(假定用默认运行。在虚拟机排错模式开启geth，推荐性能分析和最高的日志冗余级别)： geth --datadir ~/dapps/testing/00/ --port 30310 --rpcport 8110 --networkid 4567890 --nodiscover - 提交交易之前，你需要创建私有测试链（参阅测试网络相关章节），示例如下： // create account. will prompt for password personal.newAccount(); // name your primary account, will often use it primary = eth.accounts[0]; // check your balance (denominated in ether) balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); // assume an existing unlocked primary account primary = eth.accounts[0]; // mine 10 blocks to generate ether // starting miner miner.start(4); // sleep for 10 blocks (this can take quite some time). admin.sleepBlocks(10); // then stop mining (just not to burn heat in vain) miner.stop(); balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); 创建交易之后，你可以用下面的命令来强制运行： miner.start(1); admin.sleepBlocks(1); miner.stop(); 你也可以用以下命令查看即将发生的交易： // shows transaction pool txpool.status // number of pending txs eth.getBlockTransactionCount(“pending”); // print all pending txs eth.getBlock(“pending”, true).transactions 如果你提交合约创建交易，可以检查想要的代码是否实际上嵌入到当前的区块链： txhash = eth.sendTansaction({from:primary, data: code}) //... mining contractaddress = eth.getTransactionReceipt(txhash); eth.getCode(contractaddress) 《区块链开发指南》由 申屠青春 主编，由 宋波、张鹏、汪晓明、季宙栋、左川民 联合编著，中国三大区块链联盟的大伽联袂推荐。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/09/13/98011c54bf94136c941c661a11d364e6.html" />
<meta property="og:url" content="https://mlh.app/2017/09/13/98011c54bf94136c941c661a11d364e6.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文节选自图书《区块链开发指南》 区块链方向投稿，文章纠错，寻求报道可邮件联系 jiawd@csdn.net 什么是合约? 合约是代码（它的功能）和数据（它的状态）的集合，存在于以太坊区块链的特定地址。 合约账户能够在彼此之间传递信息，进行图灵完备的运算。合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。 合约很典型地用诸如Solidity等高级语言写成，然后编译成字节代码上传到区块链上。 也有其他语言可以用于编写智能合约如Serpent和LLL，在下一节会进一步阐述。去中心化应用开发资源列出了综合的开发环境，帮助你用这些语言开发的开发者工具，提供测试和部署支持等功能。 以太坊高级语言 合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。然而，合约是很典型地用诸如Solidity等高级语言写成的，它会用以太坊虚拟机编译器编译成字节代码上传到区块链。 下面是开发者可以用来为以太坊写智能合约的高级语言。 Solidity Solidity是和JavaScript相似的语言，你可以用它来开发合约并编译成以太坊虚拟机字节代码。它目前是以太坊最受欢迎的语言。 Serpent Serpent是和Python类似的语言，可以用于开发合约编译成以太坊虚拟机字节代码。它力求简洁， 将低级语言在效率方面的优点和编程风格的操作简易相结合，同时合约编程增加了独特的领域特定功能。Serpent用LLL编译。 LLL Lisp Like Language (LLL)是和Assembly类似的低级语言。它追求极简；本质上只是直接对以太坊虚拟机的一点包装。 Mutan (弃用) Mutan是个静态类型，由Jeffrey Wilcke 开发设计的C类语言。它已经不再受到维护。 写合约 没有Hello World程序，语言就不完整。Solidity在以太坊环境内操作，没有明显的“输出”字符串的方式。我们能做的最接近的事就是用日志记录事件来把字符串放进区块链，示例如下： contract HelloWorld { event Print(string out); function() { Print(&quot;Hello, World!&quot;); } } 每次执行时，这个合约都会在区块链创建一个日志入口，印着“Hello,World!”参数。 另请参阅：Solidity docs里有更多写Solidity代码的示例和指导。 编译合约 solidity合约的编译可以通过很多机制完成。 通过命令行使用solc编译器实现。 在geth或eth提供的javascript控制台使用web3.eth.compile.solidity (这仍然需要安装solc 编译器)实现。 通过在线Solidity实时编译器实现。 通过建立solidity合约的Meteor dapp Cosmo实现。 通过Mix IDE实现。 通过以太坊钱包实现。 注意：关于solc和编译Solidity合约代码的更多信息可在此查看。 1. 在geth设置solidity编译器 如果你启动了geth节点，就可以查看哪个编译器可用。示例如下： \\&gt; web3.eth.getCompilers(); [&quot;lll&quot;, &quot;solidity&quot;, &quot;serpent&quot;] 这一指令会返回到显示当前哪个编译器可用的字符串。 注意：solc编译器和cpp- ethereum一起安装。或者，你可以自己创建。 如果你的solc可执行文件不在标准位置，可以用—solc标志为solc可执行文件指定一个定制路线。示例如下： $ geth --solc /usr/local/bin/solc 或者你可以通过控制台在执行期间设置这个选项： \\&gt; admin.setSolc(&quot;/usr/local/bin/solc&quot;) solc, the solidity compiler commandline interface Version: 0.2.2-02bb315d/.-Darwin/appleclang/JIT linked to libethereum-1.2.0-8007cef0/.-Darwin/appleclang/JIT path: /usr/local/bin/solc 2. 编译一个简单合约 让我们来编译一个简单的合约源，示例如下： source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; 这个合约提供了一个单一方法multiply，它和一个正整数a调用并返回到a*7。 下面准备在geth JS控制台用eth.compile.solidity()编译solidity代码： \\&gt; contract = eth.compile.solidity(source).test { code: &#39;605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056&#39;, info: { language: &#39;Solidity&#39;, languageVersion: &#39;0&#39;, compilerVersion: &#39;0.9.13&#39;, abiDefinition: [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ], name: &#39;multiply&#39;, outputs: [{ name: &#39;d&#39;, type: &#39;uint256&#39; } ], type: &#39;function&#39; } ], userDoc: { methods: { } }, developerDoc: { methods: { } }, source: &#39;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&#39; } } 注意：编译器通过RPC因此也能通过web3.js，对浏览器内任何通过RPC/IPC连接到geth的Ðapp可用。 下面的例子会向你展示如何通过JSON-RPC接合geth来使用编译器。 \\$ geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain &#39; * &#39; --mine console 2&gt;&gt; ~/eth/eth.log $ curl -X POST --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_compileSolidity&quot;,&quot;params&quot;:[&quot;contract test { 单源编译器输出会给出你合约对象，每个都代表一个单独的合约。eth.compile.solidity 的实际返还值是合约名字到合约对象的映射。由于合约名字是test，eth.compile.solidity(source).test会给出包含下列领域的测试合约对： Code：编译的以太坊虚拟机字节代码。 Info：从编译器输出的额外元数据。 Source：源代码。 Language：合约语言 (Solidity，Serpent，LLL)。 LanguageVersion：合约语言版本。 compilerVersion：用于编译这个合约的solidity编译器版本。 abiDefinition：应用的二进制界面定义。 userDoc：用户的NatSpec Doc。 developerDoc：开发者的NatSpec Doc。 编译器输出的直接结构化(到code和info)反映了两种非常不同的部署路径。编译的以太坊虚拟机代码和一个合约创建交易被发送到区块，剩下的(info)在理想状态下会存活在去中心化云上，公开验证的元数据则执行区块链上的代码。 如果你的源包含多个合约，输出会包括每个合约一个入口，对应的合约信息对象可以用作为属性名称的合约名字检索到。你可以通过检测当前的GlobalRegistrar代码来试一下： contracts = eth.compile.solidity(globalRegistrarSrc) 创建和部署合约 开始阅读这一节之前，确保你有解锁的账户和一些资金。 现在在区块链上创建一个合约，方法是用上一章节的以太坊虚拟机代码作为数据给空地址发送交易。示例如下： 注意：用在线Solidity实时编译器或Mix IDE程序会更容易完成。 var primaryAddress = eth.accounts[0] var abi = [{ constant: false, inputs: [{ name: &#39;a&#39;, type: &#39;uint256&#39; } ] var MyContract = eth.contract(abi) var contract = MyContract.new(arg1, arg2, ..., {from: primaryAddress, data: evmByteCodeFromPrevio 所有的二进制数据都以十六进制的格式序列化。十六进制字符串总会有一个十六进制前缀0x。 注意：注意arg1, arg2, …是合约构造函数参数，以备它要接受参数。如果合约不需要构造函数参数，就可以忽略这些参数。 值得指出的是，这一步骤需要你支付执行。一旦交易成功进入到区块，你的账户余额(你作为发送方放在from领域)会根据以太坊虚拟机的gas规则被扣减。一段时间以后，你的交易会在一个区块中出现，确认它带来的状态是共识。你的合约现在存在于区块链上。 以不同步的方式做同样的事看起来是这样： MyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) { if (!err &amp;&amp; contract.address) console.log(contract.address); }); 与合约互动 与合约互动典型的做法是用诸如eth.contract()功能的抽象层，它会返回到javascript对象，和所有可用的合约功能一起，作为可调用的javascript功能。 描述合约可用功能的标准方式是ABI定义。这个对象是一个字符串，它描述了调用签名和每个可用合约功能的返回值。示例如下： var Multiply7 = eth.contract(contract.info.abiDefinition); var myMultiply7 = Multiply7.at(address); 现在ABI中具体说明的所有功能调用都在合约实例中可用。你可以用两种方法中的一种来调用这些合约实例上的方法。 \\&gt; myMultiply7.multiply.sendTransaction(3, {from: address}) &quot;0x12345&quot; &gt; myMultiply7.multiply.call(3) 21 当用sendTransaction被调用的时候，功能调用通过发送交易来执行。需要花费以太币来发送，调用会永久记录在区块链上。用这种方式进行的调用返回值是交易散表。 当用call被调用的时候，功能在以太坊虚拟机被本地执行，功能返回值和功能一起返回。用这种方式进行的调用不会记录在区块链上，因此也不会改变合约内部状态。这种调用方式被称为恒定功能调用。以这种方式进行的调用不花费以太币。 如果你只对返回值感兴趣，那么你应该用call。如果你只关心合约状态的副作用，就应该用sendTransaction。 在上面的例子中，不会产生副作用，因此sendTransaction只会烧gas，增加宇宙的熵。 合约元数据 在之前的章节中，揭示了怎样在区块链上创建合约。现在来处理剩下的编译器输出，合约元数据或者说合约信息。 在与不是你创建的合约互动时，你可能会想要文档或者查看源代码。合约作者被鼓励提供这样的可见信息，他们可以在区块链上登记或者借助第三方服务，比如说EtherChain。管理员API为所有选择登记的合约提供便利的方法来获取这个捆绑。示例如下： // get the contract info for contract address to do manual verification var info = admin.getContractInfo(address) // lookup, fetch, decode var source = info.source; var abiDef = info.abiDefinition 这项工作的潜在机制是： 合约信息被可以公开访问的URI上传到可辨认的地方。 任何人都可以只知道合约地址就找到是什么URI。 仅通过2个步骤的区块链注册就可以实现这些要求。第一步是在被称作HashReg的合约中用内容散表注册合约代码（散表）。第二步是在UrlHint合约用内容散表注册一个url。这些注册合约是Frontier版本的一部分，已经参与到Homestead中。 要知道合约地址来查询url，获取实际合约元数据信息包，使用这一机制就足够了。 如果你是个尽职的合约创建者，请遵循以下步骤： 将合约本身部署到区块链 获取合约信息json文件 将合约信息json文件部署到你选择的任意url 注册代码散表 -&gt;内容散表 -&gt; url JS API通过提供助手把这个过程变得非常容易。 调用admin.register从合约中提取信息，在指定文件中写出json序列，运算文件的内容散表，最终将这个内容散表注册到合约代码散表。一旦将那个文件部署到任意url，你就能用admin.registerUrl来注册url 和你区块链上的内容散表(注意，一旦固定的内容选址模式被用作文件商店，url-hint不再必要了) 。 source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; // compile with solc contract = eth.compile.solidity(source).test // create contract object var MyContract = eth.contract(contract.info.abiDefinition) // extracts info from contract, save the json serialisation in the given file, contenthash = admin.saveInfo(contract.info, &quot;~/dapps/shared/contracts/test/info.json&quot;)// send off the contract to the blockchain MyContract.new({from: primaryAccount, data: contract.code}, function(error, contract){ if(!error &amp;&amp; contract.address) { // calculates the content hash and registers it with the code hash in `HashReg` // it uses address to send the transaction. // returns the content hash that we use to register a url admin.register(primaryAccount, contract.address, contenthash) // here you deploy ~/dapps/shared/contracts/test/info.json to a url admin.registerUrl(primaryAccount, hash, url) } }); 测试合约和交易 在为交易和合约排除故障时，你通常会需要一些低级的测试策略。这一章节将介绍一些你可以用到的排错工作和做法。为了测试合约和交易而不产生实际的后果，最好在私有区块链上测试。这可以通过配置一个替代网络ID (选择一个特别的数字)和/或不能用的端点来实现。推荐做法是，为了测试你用一个替代数据目录和端口，这样就不会意外地和实时运行的节点冲突(假定用默认运行。在虚拟机排错模式开启geth，推荐性能分析和最高的日志冗余级别)： geth --datadir ~/dapps/testing/00/ --port 30310 --rpcport 8110 --networkid 4567890 --nodiscover - 提交交易之前，你需要创建私有测试链（参阅测试网络相关章节），示例如下： // create account. will prompt for password personal.newAccount(); // name your primary account, will often use it primary = eth.accounts[0]; // check your balance (denominated in ether) balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); // assume an existing unlocked primary account primary = eth.accounts[0]; // mine 10 blocks to generate ether // starting miner miner.start(4); // sleep for 10 blocks (this can take quite some time). admin.sleepBlocks(10); // then stop mining (just not to burn heat in vain) miner.stop(); balance = web3.fromWei(eth.getBalance(primary), &quot;ether&quot;); 创建交易之后，你可以用下面的命令来强制运行： miner.start(1); admin.sleepBlocks(1); miner.stop(); 你也可以用以下命令查看即将发生的交易： // shows transaction pool txpool.status // number of pending txs eth.getBlockTransactionCount(“pending”); // print all pending txs eth.getBlock(“pending”, true).transactions 如果你提交合约创建交易，可以检查想要的代码是否实际上嵌入到当前的区块链： txhash = eth.sendTansaction({from:primary, data: code}) //... mining contractaddress = eth.getTransactionReceipt(txhash); eth.getCode(contractaddress) 《区块链开发指南》由 申屠青春 主编，由 宋波、张鹏、汪晓明、季宙栋、左川民 联合编著，中国三大区块链联盟的大伽联袂推荐。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/09/13/98011c54bf94136c941c661a11d364e6.html","headline":"深入浅出谈以太坊智能合约","dateModified":"2017-09-13T00:00:00+08:00","datePublished":"2017-09-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/09/13/98011c54bf94136c941c661a11d364e6.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>深入浅出谈以太坊智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p>本文节选自图书《区块链开发指南》 <br> 区块链方向投稿，文章纠错，寻求报道可邮件联系 jiawd@csdn.net</p> 
  </blockquote> 
  <h3 id="什么是合约">什么是合约?</h3> 
  <p>合约是代码（它的功能）和数据（它的状态）的集合，存在于以太坊区块链的特定地址。 合约账户能够在彼此之间传递信息，进行图灵完备的运算。合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。</p> 
  <p>合约很典型地用诸如Solidity等高级语言写成，然后编译成字节代码上传到区块链上。</p> 
  <p>也有其他语言可以用于编写智能合约如Serpent和LLL，在下一节会进一步阐述。去中心化应用开发资源列出了综合的开发环境，帮助你用这些语言开发的开发者工具，提供测试和部署支持等功能。</p> 
  <h3 id="以太坊高级语言">以太坊高级语言</h3> 
  <p>合约依靠被称作以太坊虚拟机(EVM) 字节代码（以太坊特有的二进制格式）上的区块链运行。然而，合约是很典型地用诸如Solidity等高级语言写成的，它会用以太坊虚拟机编译器编译成字节代码上传到区块链。</p> 
  <p>下面是开发者可以用来为以太坊写智能合约的高级语言。</p> 
  <ol> 
   <li>Solidity <br> Solidity是和JavaScript相似的语言，你可以用它来开发合约并编译成以太坊虚拟机字节代码。它目前是以太坊最受欢迎的语言。</li> 
   <li>Serpent <br> Serpent是和Python类似的语言，可以用于开发合约编译成以太坊虚拟机字节代码。它力求简洁， 将低级语言在效率方面的优点和编程风格的操作简易相结合，同时合约编程增加了独特的领域特定功能。Serpent用LLL编译。</li> 
   <li>LLL <br> Lisp Like Language (LLL)是和Assembly类似的低级语言。它追求极简；本质上只是直接对以太坊虚拟机的一点包装。</li> 
   <li>Mutan (弃用) <br> Mutan是个静态类型，由Jeffrey Wilcke 开发设计的C类语言。它已经不再受到维护。</li> 
  </ol> 
  <h3 id="写合约">写合约</h3> 
  <p>没有Hello World程序，语言就不完整。Solidity在以太坊环境内操作，没有明显的“输出”字符串的方式。我们能做的最接近的事就是用日志记录事件来把字符串放进区块链，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs php">contract HelloWorld {
event <span class="hljs-keyword">Print</span>(string out);
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">Print</span>(<span class="hljs-string">"Hello, World!"</span>); }
}</code></pre> 
  <p>每次执行时，这个合约都会在区块链创建一个日志入口，印着“Hello,World!”参数。 <br> 另请参阅：Solidity docs里有更多写Solidity代码的示例和指导。</p> 
  <h3 id="编译合约">编译合约</h3> 
  <p>solidity合约的编译可以通过很多机制完成。</p> 
  <ul> 
   <li>通过命令行使用solc编译器实现。</li> 
   <li>在geth或eth提供的javascript控制台使用web3.eth.compile.solidity (这仍然需要安装solc 编译器)实现。</li> 
   <li>通过在线Solidity实时编译器实现。</li> 
   <li>通过建立solidity合约的Meteor dapp Cosmo实现。</li> 
   <li>通过Mix IDE实现。</li> 
   <li>通过以太坊钱包实现。</li> 
  </ul> 
  <p>注意：关于solc和编译Solidity合约代码的更多信息可在此查看。</p> 
  <p><strong>1. 在geth设置solidity编译器</strong></p> 
  <p>如果你启动了geth节点，就可以查看哪个编译器可用。示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">\&gt; web3<span class="hljs-preprocessor">.eth</span><span class="hljs-preprocessor">.getCompilers</span>()<span class="hljs-comment">;</span>
[<span class="hljs-string">"lll"</span>, <span class="hljs-string">"solidity"</span>, <span class="hljs-string">"serpent"</span>]</code></pre> 
  <p>这一指令会返回到显示当前哪个编译器可用的字符串。 <br> 注意：solc编译器和cpp- ethereum一起安装。或者，你可以自己创建。 <br> 如果你的solc可执行文件不在标准位置，可以用—solc标志为solc可执行文件指定一个定制路线。示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">geth</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">solc</span> <span class="hljs-comment">/usr/local/bin/solc</span></code></pre> 
  <p>或者你可以通过控制台在执行期间设置这个选项：</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-subst">\&gt;</span> admin<span class="hljs-built_in">.</span>setSolc(<span class="hljs-string">"/usr/local/bin/solc"</span>)
solc, the solidity compiler commandline interface
Version: <span class="hljs-number">0.2</span><span class="hljs-number">.2</span><span class="hljs-subst">-</span><span class="hljs-number">02</span>bb315d<span class="hljs-subst">/</span><span class="hljs-built_in">.</span><span class="hljs-attribute">-Darwin</span>/appleclang/JIT linked <span class="hljs-keyword">to</span> libethereum<span class="hljs-subst">-</span><span class="hljs-number">1.2</span><span class="hljs-number">.0</span><span class="hljs-subst">-</span><span class="hljs-number">8007</span>cef0<span class="hljs-subst">/</span><span class="hljs-built_in">.</span><span class="hljs-attribute">-Darwin</span>/appleclang/JIT
path: /usr/<span class="hljs-built_in">local</span>/bin/solc</code></pre> 
  <p><strong>2. 编译一个简单合约</strong></p> 
  <p>让我们来编译一个简单的合约源，示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">source</span> = <span class="hljs-string">"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }"</span></code></pre> 
  <p>这个合约提供了一个单一方法multiply，它和一个正整数a调用并返回到a*7。</p> 
  <p>下面准备在geth JS控制台用eth.compile.solidity()编译solidity代码：</p> 
  <pre class="prettyprint"><code class=" hljs bash">\&gt; contract = eth.compile.solidity(<span class="hljs-built_in">source</span>).test
{
code: <span class="hljs-string">'605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056'</span>,
info: {
language: <span class="hljs-string">'Solidity'</span>,
languageVersion: <span class="hljs-string">'0'</span>,
compilerVersion: <span class="hljs-string">'0.9.13'</span>,
abiDefinition: [{
constant: <span class="hljs-literal">false</span>,
inputs: [{
name: <span class="hljs-string">'a'</span>,
<span class="hljs-built_in">type</span>: <span class="hljs-string">'uint256'</span>
} ],
name: <span class="hljs-string">'multiply'</span>,
outputs: [{
name: <span class="hljs-string">'d'</span>,
<span class="hljs-built_in">type</span>: <span class="hljs-string">'uint256'</span>
} ],
<span class="hljs-built_in">type</span>: <span class="hljs-string">'function'</span>
} ],
userDoc: {
methods: {
}
},
developerDoc: {
methods: {
}
},
<span class="hljs-built_in">source</span>: <span class="hljs-string">'contract test { function multiply(uint a) returns(uint d) { return a * 7; } }'</span>
}
}</code></pre> 
  <p>注意：编译器通过RPC因此也能通过web3.js，对浏览器内任何通过RPC/IPC连接到geth的Ðapp可用。</p> 
  <p>下面的例子会向你展示如何通过JSON-RPC接合geth来使用编译器。</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">\$</span> <span class="hljs-comment">geth</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">datadir</span> <span class="hljs-comment">~/eth/</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">loglevel</span> <span class="hljs-comment">6</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">logtostderr=true</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpc</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpcport</span> <span class="hljs-comment">8100</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpccorsdomain</span> <span class="hljs-comment">'</span> <span class="hljs-comment">*</span> <span class="hljs-comment">'</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">mine</span> <span class="hljs-comment">console</span> <span class="hljs-comment">2</span>&gt;&gt; <span class="hljs-comment">~/eth/eth</span><span class="hljs-string">.</span><span class="hljs-comment">log</span>
<span class="hljs-comment">$</span> <span class="hljs-comment">curl</span> <span class="hljs-literal">-</span><span class="hljs-comment">X</span> <span class="hljs-comment">POST</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">data</span> <span class="hljs-comment">'{"jsonrpc":"2</span><span class="hljs-string">.</span><span class="hljs-comment">0"</span><span class="hljs-string">,</span><span class="hljs-comment">"method":"eth_compileSolidity"</span><span class="hljs-string">,</span><span class="hljs-comment">"params":</span><span class="hljs-title">[</span><span class="hljs-comment">"contract</span> <span class="hljs-comment">test</span> <span class="hljs-comment">{</span></code></pre> 
  <p>单源编译器输出会给出你合约对象，每个都代表一个单独的合约。eth.compile.solidity 的实际返还值是合约名字到合约对象的映射。由于合约名字是test，eth.compile.solidity(source).test会给出包含下列领域的测试合约对：</p> 
  <ul> 
   <li>Code：编译的以太坊虚拟机字节代码。</li> 
   <li>Info：从编译器输出的额外元数据。</li> 
   <li>Source：源代码。</li> 
   <li>Language：合约语言 (Solidity，Serpent，LLL)。</li> 
   <li>LanguageVersion：合约语言版本。</li> 
   <li>compilerVersion：用于编译这个合约的solidity编译器版本。</li> 
   <li>abiDefinition：应用的二进制界面定义。</li> 
   <li>userDoc：用户的NatSpec Doc。</li> 
   <li>developerDoc：开发者的NatSpec Doc。</li> 
  </ul> 
  <p>编译器输出的直接结构化(到code和info)反映了两种非常不同的部署路径。编译的以太坊虚拟机代码和一个合约创建交易被发送到区块，剩下的(info)在理想状态下会存活在去中心化云上，公开验证的元数据则执行区块链上的代码。</p> 
  <p>如果你的源包含多个合约，输出会包括每个合约一个入口，对应的合约信息对象可以用作为属性名称的合约名字检索到。你可以通过检测当前的GlobalRegistrar代码来试一下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">contracts = eth<span class="hljs-preprocessor">.compile</span><span class="hljs-preprocessor">.solidity</span>(globalRegistrarSrc)</code></pre> 
  <h3 id="创建和部署合约">创建和部署合约</h3> 
  <p>开始阅读这一节之前，确保你有解锁的账户和一些资金。</p> 
  <p>现在在区块链上创建一个合约，方法是用上一章节的以太坊虚拟机代码作为数据给空地址发送交易。示例如下：</p> 
  <p>注意：用在线Solidity实时编译器或Mix IDE程序会更容易完成。</p> 
  <pre class="prettyprint"><code class=" hljs r">var primaryAddress = eth.accounts[<span class="hljs-number">0</span>]
var abi = [{ constant: false, inputs: [{ name: <span class="hljs-string">'a'</span>, type: <span class="hljs-string">'uint256'</span> } ]
var MyContract = eth.contract(abi)
var contract = MyContract.new(arg1, arg2, <span class="hljs-keyword">...</span>, {from: primaryAddress, data: evmByteCodeFromPrevio</code></pre> 
  <p>所有的二进制数据都以十六进制的格式序列化。十六进制字符串总会有一个十六进制前缀0x。</p> 
  <p>注意：注意arg1, arg2, …是合约构造函数参数，以备它要接受参数。如果合约不需要构造函数参数，就可以忽略这些参数。</p> 
  <p>值得指出的是，这一步骤需要你支付执行。一旦交易成功进入到区块，你的账户余额(你作为发送方放在from领域)会根据以太坊虚拟机的gas规则被扣减。一段时间以后，你的交易会在一个区块中出现，确认它带来的状态是共识。你的合约现在存在于区块链上。</p> 
  <p>以不同步的方式做同样的事看起来是这样：</p> 
  <pre class="prettyprint"><code class=" hljs r">MyContract.new([arg1, arg2, <span class="hljs-keyword">...</span>,]{from: primaryAccount, data: evmCode}, <span class="hljs-keyword">function</span>(err, contract) {
<span class="hljs-keyword">if</span> (!err &amp;&amp; contract.address)
console.log(contract.address);
});</code></pre> 
  <h3 id="与合约互动">与合约互动</h3> 
  <p>与合约互动典型的做法是用诸如eth.contract()功能的抽象层，它会返回到javascript对象，和所有可用的合约功能一起，作为可调用的javascript功能。</p> 
  <p>描述合约可用功能的标准方式是ABI定义。这个对象是一个字符串，它描述了调用签名和每个可用合约功能的返回值。示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">var Multiply7 = eth<span class="hljs-preprocessor">.contract</span>(contract<span class="hljs-preprocessor">.info</span><span class="hljs-preprocessor">.abiDefinition</span>)<span class="hljs-comment">;</span>
var myMultiply7 = Multiply7<span class="hljs-preprocessor">.at</span>(address)<span class="hljs-comment">;</span></code></pre> 
  <p>现在ABI中具体说明的所有功能调用都在合约实例中可用。你可以用两种方法中的一种来调用这些合约实例上的方法。</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">\&gt; myMultiply7<span class="hljs-preprocessor">.multiply</span><span class="hljs-preprocessor">.sendTransaction</span>(<span class="hljs-number">3</span>, {from: address})
<span class="hljs-string">"0x12345"</span>
&gt; myMultiply7<span class="hljs-preprocessor">.multiply</span><span class="hljs-preprocessor">.call</span>(<span class="hljs-number">3</span>)
<span class="hljs-number">21</span></code></pre> 
  <p>当用sendTransaction被调用的时候，功能调用通过发送交易来执行。需要花费以太币来发送，调用会永久记录在区块链上。用这种方式进行的调用返回值是交易散表。</p> 
  <p>当用call被调用的时候，功能在以太坊虚拟机被本地执行，功能返回值和功能一起返回。用这种方式进行的调用不会记录在区块链上，因此也不会改变合约内部状态。这种调用方式被称为恒定功能调用。以这种方式进行的调用不花费以太币。</p> 
  <p>如果你只对返回值感兴趣，那么你应该用call。如果你只关心合约状态的副作用，就应该用sendTransaction。</p> 
  <p>在上面的例子中，不会产生副作用，因此sendTransaction只会烧gas，增加宇宙的熵。</p> 
  <h3 id="合约元数据">合约元数据</h3> 
  <p>在之前的章节中，揭示了怎样在区块链上创建合约。现在来处理剩下的编译器输出，合约元数据或者说合约信息。</p> 
  <p>在与不是你创建的合约互动时，你可能会想要文档或者查看源代码。合约作者被鼓励提供这样的可见信息，他们可以在区块链上登记或者借助第三方服务，比如说EtherChain。管理员API为所有选择登记的合约提供便利的方法来获取这个捆绑。示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// get the contract info for contract address to do manual verification</span>
<span class="hljs-keyword">var</span> info = admin.getContractInfo(address) <span class="hljs-comment">// lookup, fetch, decode</span>
<span class="hljs-keyword">var</span> source = info.source;
<span class="hljs-keyword">var</span> abiDef = info.abiDefinition</code></pre> 
  <p>这项工作的潜在机制是：</p> 
  <ul> 
   <li>合约信息被可以公开访问的URI上传到可辨认的地方。</li> 
   <li>任何人都可以只知道合约地址就找到是什么URI。</li> 
  </ul> 
  <p>仅通过2个步骤的区块链注册就可以实现这些要求。第一步是在被称作HashReg的合约中用内容散表注册合约代码（散表）。第二步是在UrlHint合约用内容散表注册一个url。这些注册合约是Frontier版本的一部分，已经参与到Homestead中。</p> 
  <p>要知道合约地址来查询url，获取实际合约元数据信息包，使用这一机制就足够了。</p> 
  <p>如果你是个尽职的合约创建者，请遵循以下步骤：</p> 
  <ol> 
   <li>将合约本身部署到区块链</li> 
   <li>获取合约信息json文件</li> 
   <li>将合约信息json文件部署到你选择的任意url</li> 
   <li>注册代码散表 -&gt;内容散表 -&gt; url</li> 
  </ol> 
  <p>JS API通过提供助手把这个过程变得非常容易。 调用admin.register从合约中提取信息，在指定文件中写出json序列，运算文件的内容散表，最终将这个内容散表注册到合约代码散表。一旦将那个文件部署到任意url，你就能用admin.registerUrl来注册url 和你区块链上的内容散表(注意，一旦固定的内容选址模式被用作文件商店，url-hint不再必要了) 。</p> 
  <pre class="prettyprint"><code class=" hljs php">source = <span class="hljs-string">"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }"</span>
<span class="hljs-comment">// compile with solc</span>
contract = eth.compile.solidity(source).test
<span class="hljs-comment">// create contract object</span>
<span class="hljs-keyword">var</span> MyContract = eth.contract(contract.info.abiDefinition)
<span class="hljs-comment">// extracts info from contract, save the json serialisation in the given file,</span>
contenthash = admin.saveInfo(contract.info, <span class="hljs-string">"~/dapps/shared/contracts/test/info.json"</span>)<span class="hljs-comment">// send off the contract to the blockchain</span>
MyContract.<span class="hljs-keyword">new</span>({from: primaryAccount, data: contract.code}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, contract)</span>{</span>
<span class="hljs-keyword">if</span>(!error &amp;&amp; contract.address) {
<span class="hljs-comment">// calculates the content hash and registers it with the code hash in `HashReg`</span>
<span class="hljs-comment">// it uses address to send the transaction.</span>
<span class="hljs-comment">// returns the content hash that we use to register a url</span>
admin.register(primaryAccount, contract.address, contenthash)
<span class="hljs-comment">// here you deploy ~/dapps/shared/contracts/test/info.json to a url</span>
admin.registerUrl(primaryAccount, hash, url)
}
});</code></pre> 
  <h3 id="测试合约和交易">测试合约和交易</h3> 
  <p>在为交易和合约排除故障时，你通常会需要一些低级的测试策略。这一章节将介绍一些你可以用到的排错工作和做法。为了测试合约和交易而不产生实际的后果，最好在私有区块链上测试。这可以通过配置一个替代网络ID (选择一个特别的数字)和/或不能用的端点来实现。推荐做法是，为了测试你用一个替代数据目录和端口，这样就不会意外地和实时运行的节点冲突(假定用默认运行。在虚拟机排错模式开启geth，推荐性能分析和最高的日志冗余级别)：</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">geth</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">datadir</span> <span class="hljs-comment">~/dapps/testing/00/</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port</span> <span class="hljs-comment">30310</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpcport</span> <span class="hljs-comment">8110</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">networkid</span> <span class="hljs-comment">4567890</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">nodiscover</span> <span class="hljs-literal">-</span></code></pre> 
  <p>提交交易之前，你需要创建私有测试链（参阅测试网络相关章节），示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">// create account. will prompt for password
personal<span class="hljs-preprocessor">.newAccount</span>()<span class="hljs-comment">;</span>
// name your primary account, will often use it
primary = eth<span class="hljs-preprocessor">.accounts</span>[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
// check your balance (denominated <span class="hljs-keyword">in</span> ether)
balance = web3<span class="hljs-preprocessor">.fromWei</span>(eth<span class="hljs-preprocessor">.getBalance</span>(primary), <span class="hljs-string">"ether"</span>)<span class="hljs-comment">;</span></code></pre> 
  <pre class="prettyprint"><code class=" hljs avrasm"> // assume an existing unlocked primary account
primary = eth<span class="hljs-preprocessor">.accounts</span>[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
// mine <span class="hljs-number">10</span> blocks to generate ether
// starting miner
miner<span class="hljs-preprocessor">.start</span>(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span>
// <span class="hljs-keyword">sleep</span> for <span class="hljs-number">10</span> blocks (this can take quite some time).
admin<span class="hljs-preprocessor">.sleepBlocks</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span>
// then stop mining (just not to burn heat <span class="hljs-keyword">in</span> vain)
miner<span class="hljs-preprocessor">.stop</span>()<span class="hljs-comment">;</span>
balance = web3<span class="hljs-preprocessor">.fromWei</span>(eth<span class="hljs-preprocessor">.getBalance</span>(primary), <span class="hljs-string">"ether"</span>)<span class="hljs-comment">;</span></code></pre> 
  <p>创建交易之后，你可以用下面的命令来强制运行：</p> 
  <blockquote> 
   <p>miner.start(1); <br> admin.sleepBlocks(1); <br> miner.stop();</p> 
  </blockquote> 
  <p>你也可以用以下命令查看即将发生的交易：</p> 
  <blockquote> 
   <p>// shows transaction pool <br> txpool.status <br> // number of pending txs <br> eth.getBlockTransactionCount(“pending”); <br> // print all pending txs <br> eth.getBlock(“pending”, true).transactions</p> 
  </blockquote> 
  <p>如果你提交合约创建交易，可以检查想要的代码是否实际上嵌入到当前的区块链：</p> 
  <pre class="prettyprint"><code class=" hljs r">txhash = eth.sendTansaction({from:primary, data: code})
//<span class="hljs-keyword">...</span> mining
contractaddress = eth.getTransactionReceipt(txhash);
eth.getCode(contractaddress)</code></pre> 
  <blockquote> 
   <p>《区块链开发指南》由 申屠青春 主编，由 宋波、张鹏、汪晓明、季宙栋、左川民 联合编著，中国三大区块链联盟的大伽联袂推荐。</p> 
  </blockquote> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170913160249461" alt="这里写图片描述" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/77967546,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/77967546,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
