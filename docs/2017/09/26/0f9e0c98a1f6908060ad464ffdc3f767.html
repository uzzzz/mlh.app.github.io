<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【Ethereum】以太坊ERC20与ERC233的区别 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【Ethereum】以太坊ERC20与ERC233的区别" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/diandianxiyu/article/details/78093229 什么是ERC223 ERC223是继ERC20后推出的新标准，解决了ERC20中的一些问题 相关说明 ERC223开发的主要目标 1.合约中意外丢失token: 有两种不同的方式来转移ERC20 token: 1) 合约地址 2) 钱包地址 ，你需要调用transfer发送给钱包地址 或者 调用approve在token合约然后调用transferFrom在接收的合约来发送到合约。意外地，对合同地址调用 transfer函数的调用将导致接收方合同内的token丢失，令牌将永远不会被访问。 2.无法处理进入的令牌交易: ERC20 token交易是合约内的transfer函数的调用。当交易发生时，ERC20令牌合同不会通知接收方。此外，没有办法通过合同处理传入的令牌交易，也没有办法拒绝任何不支持的令牌。 3.实际上，钱包地址和合同之间的ERC20令牌交易是两个不同的交易：你应该在合约上调用approve，然后再调用transferFrom在另一份合约上，当你想你的token委托过去。 4.Ether交易和token交易行为不同： 开发ERC223的目标之一是进行与Ether交易相似token牌交易，以避免用户在转移token时出错，并为契约开发人员更容易地与token交易进行交互。 ERC223的有利形势 1.提供避免不符合发送令牌的合同内的意外丢失令牌的可能性。 2.允许用户通过一个函数调用发送到任何地方他们的令牌。 收件人是否是合同是没有区别的。 没有必要了解令牌合约如何为常规用户发送令牌。 3.允许合同开发人员处理传入令牌中的交易。 4.ERC223转移到合同消耗比ERC20批准少2倍gas和transferFrom在接收机的合同。 5.允许将令牌存入单一交易的合约。 防止额外blockchain肿胀。 6.token交易类似于Ether交易。 ERC223令牌应通过以令牌合约的方式transfer函数发送，但请注意，如果接收方是合同或电子钱包地址，则不会有差异。如果接收者是钱包，则ERC223令牌传输将与ERC20传输相同。如果接收方是合约，ERC223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将bytes _data附加到类似于连接到Ether 事务的_data的令牌事务。它将通过令牌合约，并将通过接收方合同的tokenFallback函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC20 ABI。 在这种情况下_data将为空字节数组。 概述 ERC: 223 Title: Token standard Author: Dexaran, dexaran820@gmail.com Status: Draft Type: ERC Created: 5-03.2017 Resolution: https://github.com/Dexaran/ERC223-token-standard Recommended implementation: https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 以下描述标准功能，令牌合同和使用指定令牌的合同可以实施，以防止意外发送令牌到合同，并使令牌交易的行为像ether交易。 动机 ERC223解决了ERC20的一些问题: 1.无法处理接收合同中的进账交易。 2.令牌可以发送到合同中没有设计不处理与标记工作，并可能会丢失。目前至少有四十万美元的损失。 3.令牌交易应与Ethereum意识形态一致。当一个用户转账的时候，必须自己执行transfer.用户存入合同或发送到外部拥有的账户无关紧要。 这些将允许合同处理传入令牌交易并防止意外发送的令牌被合同接受。 例如，分散式交换将不再需要强制用户通过令牌合约来呼叫批准，然后通过从允许的令牌获取正在调用transfer的呼叫存款。 令牌交易将在交易所合约内自动处理。 这里最重要的是在执行合同交易时调用tokenFallback。 规格 Token 使用token的合约 方法 注意: 一个重要的一点是，如果合同开发人员希望他们的合同使用指定的令牌，那么合同开发人员必须实现tokenFallback。 如果接收方未实现tokenFallback函数，则认为合同不是设计为使用令牌，那么事务必须失败，并且不会传输令牌。 在尝试将Ether发送到没有实现function（））的合同时，与Ether事务的类比是失败的。 totalSupply function totalSupply() constant returns (uint256 totalSupply) 获取总量 name function name() constant returns (string _name) 得到token的名字 symbol function symbol() constant returns (bytes32 _symbol) 得到token的符号 decimals function decimals() constant returns (uint8 _decimals) 得到token的小数点后几位 balanceOf function balanceOf(address _owner) constant returns (uint256 balance) 得到地址是_owner的账户的余额 transfer(address, uint) function transfer(address _to, uint _value) returns (bool) 由于向后兼容性原因，因为ERC20传输函数没有字节参数。如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 重要:将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。 transfer(address, uint, bytes) function transfer(address _to, uint _value, bytes _data) returns (bool) 当某人想要转移令牌时总是调用这个函数。 如果_to是合约，则此函数必须传输令牌并调用_to中的函数tokenFallback (address, uint256, bytes)。 如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。 _data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。 注意: 检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。 重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address, uint256,bytes。 此函数必须具有0xc0ee0b8a签名。 事件 Transfer event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data) 当token转移的时候触发。 合约和token一起工作 function tokenFallback(address _from, uint _value, bytes _data) 令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能。 _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。 注意: msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）将_from thetokenFallback函数内。 重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。 示例代码 ERC223_Interface.sol pragma solidity ^0.4.9; /* 新的 ERC23 contract 接口文件 */ contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } Receiver_Interface.sol pragma solidity ^0.4.9; /* * Contract that is working with ERC223 tokens */ contract ContractReceiver { struct TKN { address sender; //调用合约的人 uint value; bytes data; bytes4 sig; //签名 } function tokenFallback(address _from, uint _value, bytes _data){ TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) &lt;&lt; 8) + (uint32(_data[1]) &lt;&lt; 16) + (uint32(_data[0]) &lt;&lt; 24); tkn.sig = bytes4(u); /* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */ } } ERC223_Token.sol pragma solidity ^0.4.9; import &quot;./Receiver_Interface.sol&quot;; import &quot;./ERC223_Interface.sol&quot;; /** * ERC23 token by Dexaran * * https://github.com/Dexaran/ERC23-tokens */ /* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */ contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &gt; MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &lt; y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x &gt; MAX_UINT256 / y) throw; return x * y; } } //示例的智能合约代码 contract ERC223Token is ERC223, SafeMath { mapping(address =&gt; uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // 获取token的名称 function name() constant returns (string _name) { return name; } // 获取token的符号 function symbol() constant returns (string _symbol) { return symbol; } // 获取token精确到小数点后的位数 function decimals() constant returns (uint8 _decimals) { return decimals; } // 获取token的发布总量 function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) { //如果to是合约 if(isContract(_to)) { if (balanceOf(msg.sender) &lt; _value) throw; //如果当前的余额不够就抛出 balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);//发送者的余额做减法 balances[_to] = safeAdd(balanceOf(_to), _value); //接收者的余额做加法 ContractReceiver receiver = ContractReceiver(_to); //初始化接收合约，构造函数参数为接收者的合约地址 receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } // 类似于ERC20传输的标准功能传输，没有_data。 // 由于向后兼容性原因而增加。 function transfer(address _to, uint _value) returns (bool success) { //类似于没有_data的ERC20传输的标准功能传输 //由于向后兼容性原因而增加 bytes memory empty; if(isContract(_to)) {//如果是合约 return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } //组装定地址字节码。 如果存在字节码，那么_addr是一个合约。 function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { //检索目标地址上的代码大小，这需要汇编 length := extcodesize(_addr) } return (length&gt;0); } //当传递目标是一个地址时调用函数 function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } //当传递目标是一个合约时调用函数 function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); //必须要调用这个回调 Transfer(msg.sender, _to, _value, _data); return true; } //得到_owner的余额 function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } 参考资料 https://github.com/ethereum/EIPs/issues/223 https://github.com/Dexaran/ERC223-token-standard/tree/Recommended https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/ http://www.jinse.com/news/ethereum/43264.html https://www.reddit.com/r/ethereum/comments/6m9rnu/erc20_vs_erc223_eli5/ 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/diandianxiyu/article/details/78093229 什么是ERC223 ERC223是继ERC20后推出的新标准，解决了ERC20中的一些问题 相关说明 ERC223开发的主要目标 1.合约中意外丢失token: 有两种不同的方式来转移ERC20 token: 1) 合约地址 2) 钱包地址 ，你需要调用transfer发送给钱包地址 或者 调用approve在token合约然后调用transferFrom在接收的合约来发送到合约。意外地，对合同地址调用 transfer函数的调用将导致接收方合同内的token丢失，令牌将永远不会被访问。 2.无法处理进入的令牌交易: ERC20 token交易是合约内的transfer函数的调用。当交易发生时，ERC20令牌合同不会通知接收方。此外，没有办法通过合同处理传入的令牌交易，也没有办法拒绝任何不支持的令牌。 3.实际上，钱包地址和合同之间的ERC20令牌交易是两个不同的交易：你应该在合约上调用approve，然后再调用transferFrom在另一份合约上，当你想你的token委托过去。 4.Ether交易和token交易行为不同： 开发ERC223的目标之一是进行与Ether交易相似token牌交易，以避免用户在转移token时出错，并为契约开发人员更容易地与token交易进行交互。 ERC223的有利形势 1.提供避免不符合发送令牌的合同内的意外丢失令牌的可能性。 2.允许用户通过一个函数调用发送到任何地方他们的令牌。 收件人是否是合同是没有区别的。 没有必要了解令牌合约如何为常规用户发送令牌。 3.允许合同开发人员处理传入令牌中的交易。 4.ERC223转移到合同消耗比ERC20批准少2倍gas和transferFrom在接收机的合同。 5.允许将令牌存入单一交易的合约。 防止额外blockchain肿胀。 6.token交易类似于Ether交易。 ERC223令牌应通过以令牌合约的方式transfer函数发送，但请注意，如果接收方是合同或电子钱包地址，则不会有差异。如果接收者是钱包，则ERC223令牌传输将与ERC20传输相同。如果接收方是合约，ERC223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将bytes _data附加到类似于连接到Ether 事务的_data的令牌事务。它将通过令牌合约，并将通过接收方合同的tokenFallback函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC20 ABI。 在这种情况下_data将为空字节数组。 概述 ERC: 223 Title: Token standard Author: Dexaran, dexaran820@gmail.com Status: Draft Type: ERC Created: 5-03.2017 Resolution: https://github.com/Dexaran/ERC223-token-standard Recommended implementation: https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 以下描述标准功能，令牌合同和使用指定令牌的合同可以实施，以防止意外发送令牌到合同，并使令牌交易的行为像ether交易。 动机 ERC223解决了ERC20的一些问题: 1.无法处理接收合同中的进账交易。 2.令牌可以发送到合同中没有设计不处理与标记工作，并可能会丢失。目前至少有四十万美元的损失。 3.令牌交易应与Ethereum意识形态一致。当一个用户转账的时候，必须自己执行transfer.用户存入合同或发送到外部拥有的账户无关紧要。 这些将允许合同处理传入令牌交易并防止意外发送的令牌被合同接受。 例如，分散式交换将不再需要强制用户通过令牌合约来呼叫批准，然后通过从允许的令牌获取正在调用transfer的呼叫存款。 令牌交易将在交易所合约内自动处理。 这里最重要的是在执行合同交易时调用tokenFallback。 规格 Token 使用token的合约 方法 注意: 一个重要的一点是，如果合同开发人员希望他们的合同使用指定的令牌，那么合同开发人员必须实现tokenFallback。 如果接收方未实现tokenFallback函数，则认为合同不是设计为使用令牌，那么事务必须失败，并且不会传输令牌。 在尝试将Ether发送到没有实现function（））的合同时，与Ether事务的类比是失败的。 totalSupply function totalSupply() constant returns (uint256 totalSupply) 获取总量 name function name() constant returns (string _name) 得到token的名字 symbol function symbol() constant returns (bytes32 _symbol) 得到token的符号 decimals function decimals() constant returns (uint8 _decimals) 得到token的小数点后几位 balanceOf function balanceOf(address _owner) constant returns (uint256 balance) 得到地址是_owner的账户的余额 transfer(address, uint) function transfer(address _to, uint _value) returns (bool) 由于向后兼容性原因，因为ERC20传输函数没有字节参数。如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 重要:将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。 transfer(address, uint, bytes) function transfer(address _to, uint _value, bytes _data) returns (bool) 当某人想要转移令牌时总是调用这个函数。 如果_to是合约，则此函数必须传输令牌并调用_to中的函数tokenFallback (address, uint256, bytes)。 如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。 _data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。 注意: 检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。 重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address, uint256,bytes。 此函数必须具有0xc0ee0b8a签名。 事件 Transfer event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data) 当token转移的时候触发。 合约和token一起工作 function tokenFallback(address _from, uint _value, bytes _data) 令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能。 _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。 注意: msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）将_from thetokenFallback函数内。 重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。 示例代码 ERC223_Interface.sol pragma solidity ^0.4.9; /* 新的 ERC23 contract 接口文件 */ contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } Receiver_Interface.sol pragma solidity ^0.4.9; /* * Contract that is working with ERC223 tokens */ contract ContractReceiver { struct TKN { address sender; //调用合约的人 uint value; bytes data; bytes4 sig; //签名 } function tokenFallback(address _from, uint _value, bytes _data){ TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) &lt;&lt; 8) + (uint32(_data[1]) &lt;&lt; 16) + (uint32(_data[0]) &lt;&lt; 24); tkn.sig = bytes4(u); /* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */ } } ERC223_Token.sol pragma solidity ^0.4.9; import &quot;./Receiver_Interface.sol&quot;; import &quot;./ERC223_Interface.sol&quot;; /** * ERC23 token by Dexaran * * https://github.com/Dexaran/ERC23-tokens */ /* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */ contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &gt; MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &lt; y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x &gt; MAX_UINT256 / y) throw; return x * y; } } //示例的智能合约代码 contract ERC223Token is ERC223, SafeMath { mapping(address =&gt; uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // 获取token的名称 function name() constant returns (string _name) { return name; } // 获取token的符号 function symbol() constant returns (string _symbol) { return symbol; } // 获取token精确到小数点后的位数 function decimals() constant returns (uint8 _decimals) { return decimals; } // 获取token的发布总量 function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) { //如果to是合约 if(isContract(_to)) { if (balanceOf(msg.sender) &lt; _value) throw; //如果当前的余额不够就抛出 balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);//发送者的余额做减法 balances[_to] = safeAdd(balanceOf(_to), _value); //接收者的余额做加法 ContractReceiver receiver = ContractReceiver(_to); //初始化接收合约，构造函数参数为接收者的合约地址 receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } // 类似于ERC20传输的标准功能传输，没有_data。 // 由于向后兼容性原因而增加。 function transfer(address _to, uint _value) returns (bool success) { //类似于没有_data的ERC20传输的标准功能传输 //由于向后兼容性原因而增加 bytes memory empty; if(isContract(_to)) {//如果是合约 return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } //组装定地址字节码。 如果存在字节码，那么_addr是一个合约。 function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { //检索目标地址上的代码大小，这需要汇编 length := extcodesize(_addr) } return (length&gt;0); } //当传递目标是一个地址时调用函数 function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } //当传递目标是一个合约时调用函数 function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); //必须要调用这个回调 Transfer(msg.sender, _to, _value, _data); return true; } //得到_owner的余额 function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } 参考资料 https://github.com/ethereum/EIPs/issues/223 https://github.com/Dexaran/ERC223-token-standard/tree/Recommended https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/ http://www.jinse.com/news/ethereum/43264.html https://www.reddit.com/r/ethereum/comments/6m9rnu/erc20_vs_erc223_eli5/ 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/diandianxiyu/article/details/78093229 什么是ERC223 ERC223是继ERC20后推出的新标准，解决了ERC20中的一些问题 相关说明 ERC223开发的主要目标 1.合约中意外丢失token: 有两种不同的方式来转移ERC20 token: 1) 合约地址 2) 钱包地址 ，你需要调用transfer发送给钱包地址 或者 调用approve在token合约然后调用transferFrom在接收的合约来发送到合约。意外地，对合同地址调用 transfer函数的调用将导致接收方合同内的token丢失，令牌将永远不会被访问。 2.无法处理进入的令牌交易: ERC20 token交易是合约内的transfer函数的调用。当交易发生时，ERC20令牌合同不会通知接收方。此外，没有办法通过合同处理传入的令牌交易，也没有办法拒绝任何不支持的令牌。 3.实际上，钱包地址和合同之间的ERC20令牌交易是两个不同的交易：你应该在合约上调用approve，然后再调用transferFrom在另一份合约上，当你想你的token委托过去。 4.Ether交易和token交易行为不同： 开发ERC223的目标之一是进行与Ether交易相似token牌交易，以避免用户在转移token时出错，并为契约开发人员更容易地与token交易进行交互。 ERC223的有利形势 1.提供避免不符合发送令牌的合同内的意外丢失令牌的可能性。 2.允许用户通过一个函数调用发送到任何地方他们的令牌。 收件人是否是合同是没有区别的。 没有必要了解令牌合约如何为常规用户发送令牌。 3.允许合同开发人员处理传入令牌中的交易。 4.ERC223转移到合同消耗比ERC20批准少2倍gas和transferFrom在接收机的合同。 5.允许将令牌存入单一交易的合约。 防止额外blockchain肿胀。 6.token交易类似于Ether交易。 ERC223令牌应通过以令牌合约的方式transfer函数发送，但请注意，如果接收方是合同或电子钱包地址，则不会有差异。如果接收者是钱包，则ERC223令牌传输将与ERC20传输相同。如果接收方是合约，ERC223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将bytes _data附加到类似于连接到Ether 事务的_data的令牌事务。它将通过令牌合约，并将通过接收方合同的tokenFallback函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC20 ABI。 在这种情况下_data将为空字节数组。 概述 ERC: 223 Title: Token standard Author: Dexaran, dexaran820@gmail.com Status: Draft Type: ERC Created: 5-03.2017 Resolution: https://github.com/Dexaran/ERC223-token-standard Recommended implementation: https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 以下描述标准功能，令牌合同和使用指定令牌的合同可以实施，以防止意外发送令牌到合同，并使令牌交易的行为像ether交易。 动机 ERC223解决了ERC20的一些问题: 1.无法处理接收合同中的进账交易。 2.令牌可以发送到合同中没有设计不处理与标记工作，并可能会丢失。目前至少有四十万美元的损失。 3.令牌交易应与Ethereum意识形态一致。当一个用户转账的时候，必须自己执行transfer.用户存入合同或发送到外部拥有的账户无关紧要。 这些将允许合同处理传入令牌交易并防止意外发送的令牌被合同接受。 例如，分散式交换将不再需要强制用户通过令牌合约来呼叫批准，然后通过从允许的令牌获取正在调用transfer的呼叫存款。 令牌交易将在交易所合约内自动处理。 这里最重要的是在执行合同交易时调用tokenFallback。 规格 Token 使用token的合约 方法 注意: 一个重要的一点是，如果合同开发人员希望他们的合同使用指定的令牌，那么合同开发人员必须实现tokenFallback。 如果接收方未实现tokenFallback函数，则认为合同不是设计为使用令牌，那么事务必须失败，并且不会传输令牌。 在尝试将Ether发送到没有实现function（））的合同时，与Ether事务的类比是失败的。 totalSupply function totalSupply() constant returns (uint256 totalSupply) 获取总量 name function name() constant returns (string _name) 得到token的名字 symbol function symbol() constant returns (bytes32 _symbol) 得到token的符号 decimals function decimals() constant returns (uint8 _decimals) 得到token的小数点后几位 balanceOf function balanceOf(address _owner) constant returns (uint256 balance) 得到地址是_owner的账户的余额 transfer(address, uint) function transfer(address _to, uint _value) returns (bool) 由于向后兼容性原因，因为ERC20传输函数没有字节参数。如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 重要:将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。 transfer(address, uint, bytes) function transfer(address _to, uint _value, bytes _data) returns (bool) 当某人想要转移令牌时总是调用这个函数。 如果_to是合约，则此函数必须传输令牌并调用_to中的函数tokenFallback (address, uint256, bytes)。 如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。 如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。 _data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。 注意: 检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。 重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address, uint256,bytes。 此函数必须具有0xc0ee0b8a签名。 事件 Transfer event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data) 当token转移的时候触发。 合约和token一起工作 function tokenFallback(address _from, uint _value, bytes _data) 令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能。 _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。 注意: msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）将_from thetokenFallback函数内。 重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。 示例代码 ERC223_Interface.sol pragma solidity ^0.4.9; /* 新的 ERC23 contract 接口文件 */ contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } Receiver_Interface.sol pragma solidity ^0.4.9; /* * Contract that is working with ERC223 tokens */ contract ContractReceiver { struct TKN { address sender; //调用合约的人 uint value; bytes data; bytes4 sig; //签名 } function tokenFallback(address _from, uint _value, bytes _data){ TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) &lt;&lt; 8) + (uint32(_data[1]) &lt;&lt; 16) + (uint32(_data[0]) &lt;&lt; 24); tkn.sig = bytes4(u); /* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */ } } ERC223_Token.sol pragma solidity ^0.4.9; import &quot;./Receiver_Interface.sol&quot;; import &quot;./ERC223_Interface.sol&quot;; /** * ERC23 token by Dexaran * * https://github.com/Dexaran/ERC23-tokens */ /* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */ contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &gt; MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x &lt; y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x &gt; MAX_UINT256 / y) throw; return x * y; } } //示例的智能合约代码 contract ERC223Token is ERC223, SafeMath { mapping(address =&gt; uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // 获取token的名称 function name() constant returns (string _name) { return name; } // 获取token的符号 function symbol() constant returns (string _symbol) { return symbol; } // 获取token精确到小数点后的位数 function decimals() constant returns (uint8 _decimals) { return decimals; } // 获取token的发布总量 function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) { //如果to是合约 if(isContract(_to)) { if (balanceOf(msg.sender) &lt; _value) throw; //如果当前的余额不够就抛出 balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);//发送者的余额做减法 balances[_to] = safeAdd(balanceOf(_to), _value); //接收者的余额做加法 ContractReceiver receiver = ContractReceiver(_to); //初始化接收合约，构造函数参数为接收者的合约地址 receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } // 当用户或其他合同想要转移资金时调用的功能。 function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } // 类似于ERC20传输的标准功能传输，没有_data。 // 由于向后兼容性原因而增加。 function transfer(address _to, uint _value) returns (bool success) { //类似于没有_data的ERC20传输的标准功能传输 //由于向后兼容性原因而增加 bytes memory empty; if(isContract(_to)) {//如果是合约 return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } //组装定地址字节码。 如果存在字节码，那么_addr是一个合约。 function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { //检索目标地址上的代码大小，这需要汇编 length := extcodesize(_addr) } return (length&gt;0); } //当传递目标是一个地址时调用函数 function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } //当传递目标是一个合约时调用函数 function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) &lt; _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); //必须要调用这个回调 Transfer(msg.sender, _to, _value, _data); return true; } //得到_owner的余额 function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } 参考资料 https://github.com/ethereum/EIPs/issues/223 https://github.com/Dexaran/ERC223-token-standard/tree/Recommended https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/ http://www.jinse.com/news/ethereum/43264.html https://www.reddit.com/r/ethereum/comments/6m9rnu/erc20_vs_erc223_eli5/ 阅读更多","@type":"BlogPosting","url":"/2017/09/26/0f9e0c98a1f6908060ad464ffdc3f767.html","headline":"【Ethereum】以太坊ERC20与ERC233的区别","dateModified":"2017-09-26T00:00:00+08:00","datePublished":"2017-09-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/09/26/0f9e0c98a1f6908060ad464ffdc3f767.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【Ethereum】以太坊ERC20与ERC233的区别</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/diandianxiyu/article/details/78093229 
 </div> 
 <div class="markdown_views prism-dracula"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1 id="什么是erc223">什么是ERC223</h1> 
  <p>ERC223是继ERC20后推出的新标准，解决了ERC20中的一些问题</p> 
  <h1 id="相关说明">相关说明</h1> 
  <h2 id="erc223开发的主要目标">ERC223开发的主要目标</h2> 
  <p>1.合约中意外丢失token: 有两种不同的方式来转移ERC20 token: 1) 合约地址 2) 钱包地址 ，你需要调用<code>transfer</code>发送给钱包地址 或者 调用<code>approve</code>在token合约然后调用<code>transferFrom</code>在接收的合约来发送到合约。意外地，对合同地址调用 <code>transfer</code>函数的调用将导致接收方合同内的token丢失，令牌将永远不会被访问。</p> 
  <p>2.无法处理进入的令牌交易: ERC20 token交易是合约内的<code>transfer</code>函数的调用。当交易发生时，ERC20令牌合同不会通知接收方。此外，没有办法通过合同处理传入的令牌交易，也没有办法拒绝任何不支持的令牌。</p> 
  <p>3.实际上，钱包地址和合同之间的ERC20令牌交易是两个不同的交易：你应该在合约上调用<code>approve</code>，然后再调用<code>transferFrom</code>在另一份合约上，当你想你的token委托过去。</p> 
  <p>4.Ether交易和token交易行为不同： 开发ERC223的目标之一是进行与Ether交易相似token牌交易，以避免用户在转移token时出错，并为契约开发人员更容易地与token交易进行交互。</p> 
  <h2 id="erc223的有利形势">ERC223的有利形势</h2> 
  <p>1.提供避免不符合发送令牌的合同内的意外丢失令牌的可能性。</p> 
  <p>2.允许用户通过一个函数调用发送到任何地方他们的令牌。 收件人是否是合同是没有区别的。 没有必要了解令牌合约如何为常规用户发送令牌。</p> 
  <p>3.允许合同开发人员处理传入令牌中的交易。</p> 
  <p>4.ERC223转移到合同消耗比ERC20批准少2倍gas和transferFrom在接收机的合同。</p> 
  <p>5.允许将令牌存入单一交易的合约。 防止额外blockchain肿胀。</p> 
  <p>6.token交易类似于Ether交易。</p> 
  <p>ERC223令牌应通过以令牌合约的方式<code>transfer</code>函数发送，但请注意，如果接收方是合同或电子钱包地址，则不会有差异。如果接收者是钱包，则ERC223令牌传输将与ERC20传输相同。如果接收方是合约，ERC223令牌合约将尝试在接收方合约中调用tokenFallback函数。如果接收方没有tokenFallback函数，合约事务将失败。tokenFallback函数是Ether事务的后备功能模拟，可用于处理传入事务。有一种方法可以将<code>bytes _data</code>附加到类似于连接到Ether 事务的<code>_data</code>的令牌事务。它将通过令牌合约，并将通过接收方合同的<code>tokenFallback</code>函数处理。还有一种方法可以在没有数据参数的情况下使用ERC223令牌合约传输函数，或者使用没有传输函数数据的ERC20 ABI。 在这种情况下_data将为空字节数组。</p> 
  <h1 id="概述">概述</h1> 
  <p>ERC: 223 <br> Title: Token standard <br> Author: Dexaran, dexaran820@gmail.com <br> Status: Draft <br> Type: ERC <br> Created: 5-03.2017 <br> Resolution: <a href="https://github.com/Dexaran/ERC223-token-standard" rel="nofollow" target="_blank">https://github.com/Dexaran/ERC223-token-standard</a> <br> Recommended implementation: <a href="https://github.com/Dexaran/ERC223-token-standard/tree/Recommended" rel="nofollow" target="_blank">https://github.com/Dexaran/ERC223-token-standard/tree/Recommended</a></p> 
  <p>以下描述标准功能，令牌合同和使用指定令牌的合同可以实施，以防止意外发送令牌到合同，并使令牌交易的行为像ether交易。</p> 
  <h1 id="动机">动机</h1> 
  <p>ERC223解决了ERC20的一些问题:</p> 
  <p>1.无法处理接收合同中的进账交易。 <br> 2.令牌可以发送到合同中没有设计不处理与标记工作，并可能会丢失。目前至少有四十万美元的损失。 <br> 3.令牌交易应与Ethereum意识形态一致。当一个用户转账的时候，必须自己执行<code>transfer</code>.用户存入合同或发送到外部拥有的账户无关紧要。</p> 
  <p>这些将允许合同处理传入令牌交易并防止意外发送的令牌被合同接受。 <br> 例如，分散式交换将不再需要强制用户通过令牌合约来呼叫批准，然后通过从允许的令牌获取正在调用transfer的呼叫存款。 令牌交易将在交易所合约内自动处理。</p> 
  <p>这里最重要的是在执行合同交易时调用tokenFallback。</p> 
  <h1 id="规格">规格</h1> 
  <p>Token <br> 使用token的合约</p> 
  <h1 id="方法">方法</h1> 
  <p>注意: 一个重要的一点是，如果合同开发人员希望他们的合同使用指定的令牌，那么合同开发人员必须实现tokenFallback。</p> 
  <p>如果接收方未实现tokenFallback函数，则认为合同不是设计为使用令牌，那么事务必须失败，并且不会传输令牌。 在尝试将Ether发送到没有实现function（））的合同时，与Ether事务的类比是失败的。</p> 
  <h2 id="totalsupply">totalSupply</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 totalSupply)</span></span></code></pre> 
  <p>获取总量</p> 
  <h2 id="name">name</h2> 
  <pre class="prettyprint"><code class=" hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span> constant returns (<span class="hljs-built_in">string</span> _name)</code></pre> 
  <p>得到token的名字</p> 
  <h2 id="symbol">symbol</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">symbol</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bytes32 _symbol)</span></span></code></pre> 
  <p>得到token的符号</p> 
  <h2 id="decimals">decimals</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decimals</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint8 _decimals)</span></span></code></pre> 
  <p>得到token的小数点后几位</p> 
  <h2 id="balanceof">balanceOf</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 balance)</span></span>
</code></pre> 
  <p>得到地址是<code>_owner</code>的账户的余额</p> 
  <h2 id="transferaddress-uint">transfer(address, uint)</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span></span></code></pre> 
  <p>由于向后兼容性原因，因为ERC20传输函数没有字节参数。如果<code>_to</code>是合约，则此函数必须传输令牌并调<code>_to中</code>的函数<code>tokenFallback(address,uint256,bytes)</code>。如果<code>_to</code>（接收方合同）中没有实现<code>tokenFallback</code>函数，则事务必须失败，并且不会发生令牌的传输。</p> 
  <p>重要:将在接收方合约中调用的令牌备用功能必须命名为<code>tokenFallback</code>，并使用参数<code>address</code>,<code>uint256</code>，<code>bytes</code>。 此函数必须具有<code>0xc0ee0b8a</code>签名。</p> 
  <h2 id="transferaddress-uint-bytes">transfer(address, uint, bytes)</h2> 
  <pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value, bytes _data)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span></span></code></pre> 
  <p>当某人想要转移令牌时总是调用这个函数。 <br> 如果<code>_to</code>是合约，则此函数必须传输令牌并调用<code>_to</code>中的函数<code>tokenFallback (address, uint256, bytes)</code>。 如果<code>_to</code>（接收方合同）中没有实现<code>tokenFallback</code>函数，则事务必须失败，并且不会发生令牌的传输。 <br> 如果<code>_to</code>是外部拥有的地址，则必须发送事务，而不尝试在<code>_to</code>中执行<code>tokenFallback</code>。</p> 
  <p><code>_data</code>可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 <code>_data</code>可以是空的。</p> 
  <p>注意: 检查<code>_to</code>是合约还是地址的推荐方法是组装<code>_to</code>的代码。 如果<code>_to</code>中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。</p> 
  <p>重要: 将在接收方合约中调用的令牌备用功能必须命名为<code>tokenFallback</code>，并使用参数<code>address</code>, <code>uint256</code>,<code>bytes</code>。 此函数必须具有<code>0xc0ee0b8a</code>签名。</p> 
  <h1 id="事件">事件</h1> 
  <h2 id="transfer">Transfer</h2> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">event</span> Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data)</code></pre> 
  <p>当token转移的时候触发。</p> 
  <h2 id="合约和token一起工作">合约和token一起工作</h2> 
  <pre class="prettyprint"><code class=" hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenFallback</span><span class="hljs-params">(address _from, uint _value, bytes _data)</span></span></code></pre> 
  <p>令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能。 <code>_from</code>是令牌发送者，<code>_value</code>是传入令牌的数量，<code>_data</code>是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。</p> 
  <p>注意: msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）将_from thetokenFallback函数内。</p> 
  <p>重要: 这个函数必须命名为<code>tokenFallback</code>，并使用参数地址<code>uint256</code>，字节来匹配函数签名<code>0xc0ee0b8a</code>。</p> 
  <h1 id="示例代码">示例代码</h1> 
  <h2 id="erc223interfacesol">ERC223_Interface.sol</h2> 
  <pre class="prettyprint"><code class=" hljs php">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.9</span>;

 <span class="hljs-comment">/* 新的 ERC23 contract 接口文件 */</span>

contract ERC223 {
  uint <span class="hljs-keyword">public</span> totalSupply;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address who)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>;</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string _name)</span>;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">symbol</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string _symbol)</span>;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decimals</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint8 _decimals)</span>;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 _supply)</span>;</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address to, uint value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool ok)</span>;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address to, uint value, bytes data)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool ok)</span>;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address to, uint value, bytes data, string custom_fallback)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool ok)</span>;</span>
  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}</code></pre> 
  <h2 id="receiverinterfacesol">Receiver_Interface.sol</h2> 
  <pre class="prettyprint"><code class=" hljs vala">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.9</span>;

 <span class="hljs-comment">/* * Contract that is working with ERC223 tokens */</span>

 contract ContractReceiver {

    <span class="hljs-keyword">struct</span><span class="hljs-constant"> TKN </span>{
        address sender; <span class="hljs-comment">//调用合约的人</span>
        <span class="hljs-keyword">uint</span> value;
        bytes data;
        bytes4 sig; <span class="hljs-comment">//签名</span>
    }


    function tokenFallback(address _from, <span class="hljs-keyword">uint</span> _value, bytes _data){
     <span class="hljs-constant"> TKN </span>memory tkn;
      tkn.sender = _from;
      tkn.value = _value;
      tkn.data = _data;
      <span class="hljs-keyword">uint32</span> u = <span class="hljs-keyword">uint32</span>(_data[<span class="hljs-number">3</span>]) + (<span class="hljs-keyword">uint32</span>(_data[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">8</span>) + (<span class="hljs-keyword">uint32</span>(_data[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">16</span>) + (<span class="hljs-keyword">uint32</span>(_data[<span class="hljs-number">0</span>]) &lt;&lt; <span class="hljs-number">24</span>);
      tkn.sig = bytes4(u);

      <span class="hljs-comment">/* tkn变量是Ether交易的msg变量的模拟 * tkn.sender是发起这个令牌交易的人（类似于msg.sender） * tkn.value发送的令牌数（msg.value的类比） * tkn.data是令牌交易的数据（类似于msg.data） * tkn.sig是4字节的功能签名 * 如果令牌事务的数据是一个函数执行 */</span>
    }
}</code></pre> 
  <h2 id="erc223tokensol">ERC223_Token.sol</h2> 
  <pre class="prettyprint"><code class=" hljs php">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.9</span>;

import <span class="hljs-string">"./Receiver_Interface.sol"</span>;
import <span class="hljs-string">"./ERC223_Interface.sol"</span>;

 <span class="hljs-comment">/** * ERC23 token by Dexaran * * https://github.com/Dexaran/ERC23-tokens */</span>


 <span class="hljs-comment">/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */</span>
contract SafeMath {
    uint256 constant <span class="hljs-keyword">public</span> MAX_UINT256 =
    <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeAdd</span><span class="hljs-params">(uint256 x, uint256 y)</span> <span class="hljs-title">constant</span> <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 z)</span> {</span>
        <span class="hljs-keyword">if</span> (x &gt; MAX_UINT256 - y) <span class="hljs-keyword">throw</span>;
        <span class="hljs-keyword">return</span> x + y;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeSub</span><span class="hljs-params">(uint256 x, uint256 y)</span> <span class="hljs-title">constant</span> <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 z)</span> {</span>
        <span class="hljs-keyword">if</span> (x &lt; y) <span class="hljs-keyword">throw</span>;
        <span class="hljs-keyword">return</span> x - y;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeMul</span><span class="hljs-params">(uint256 x, uint256 y)</span> <span class="hljs-title">constant</span> <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 z)</span> {</span>
        <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (x &gt; MAX_UINT256 / y) <span class="hljs-keyword">throw</span>;
        <span class="hljs-keyword">return</span> x * y;
    }
}

<span class="hljs-comment">//示例的智能合约代码</span>
contract ERC223Token is ERC223, SafeMath {

  mapping(address =&gt; uint) balances;

  string <span class="hljs-keyword">public</span> name;
  string <span class="hljs-keyword">public</span> symbol;
  uint8 <span class="hljs-keyword">public</span> decimals;
  uint256 <span class="hljs-keyword">public</span> totalSupply;


  <span class="hljs-comment">// 获取token的名称</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string _name)</span> {</span>
      <span class="hljs-keyword">return</span> name;
  }
  <span class="hljs-comment">// 获取token的符号</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">symbol</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string _symbol)</span> {</span>
      <span class="hljs-keyword">return</span> symbol;
  }
  <span class="hljs-comment">// 获取token精确到小数点后的位数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decimals</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint8 _decimals)</span> {</span>
      <span class="hljs-keyword">return</span> decimals;
  }
  <span class="hljs-comment">// 获取token的发布总量</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 _totalSupply)</span> {</span>
      <span class="hljs-keyword">return</span> totalSupply;
  }


  <span class="hljs-comment">// 当用户或其他合同想要转移资金时调用的功能。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value, bytes _data, string _custom_fallback)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span> {</span>
    <span class="hljs-comment">//如果to是合约 </span>
    <span class="hljs-keyword">if</span>(isContract(_to)) {
        <span class="hljs-keyword">if</span> (balanceOf(msg.sender) &lt; _value) <span class="hljs-keyword">throw</span>; <span class="hljs-comment">//如果当前的余额不够就抛出</span>
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);<span class="hljs-comment">//发送者的余额做减法</span>
        balances[_to] = safeAdd(balanceOf(_to), _value); <span class="hljs-comment">//接收者的余额做加法</span>
        ContractReceiver receiver = ContractReceiver(_to);   <span class="hljs-comment">//初始化接收合约，构造函数参数为接收者的合约地址</span>
        receiver.call.value(<span class="hljs-number">0</span>)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> transferToAddress(_to, _value, _data);
    }
}


  <span class="hljs-comment">// 当用户或其他合同想要转移资金时调用的功能。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value, bytes _data)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span> {</span>

    <span class="hljs-keyword">if</span>(isContract(_to)) {
        <span class="hljs-keyword">return</span> transferToContract(_to, _value, _data);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> transferToAddress(_to, _value, _data);
    }
}

  <span class="hljs-comment">// 类似于ERC20传输的标准功能传输，没有_data。</span>
  <span class="hljs-comment">// 由于向后兼容性原因而增加。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span> {</span>

    <span class="hljs-comment">//类似于没有_data的ERC20传输的标准功能传输</span>
    <span class="hljs-comment">//由于向后兼容性原因而增加</span>
    bytes memory <span class="hljs-keyword">empty</span>;
    <span class="hljs-keyword">if</span>(isContract(_to)) {<span class="hljs-comment">//如果是合约</span>
        <span class="hljs-keyword">return</span> transferToContract(_to, _value, <span class="hljs-keyword">empty</span>);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> transferToAddress(_to, _value, <span class="hljs-keyword">empty</span>);
    }
}

  <span class="hljs-comment">//组装定地址字节码。 如果存在字节码，那么_addr是一个合约。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isContract</span><span class="hljs-params">(address _addr)</span> <span class="hljs-title">private</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool is_contract)</span> {</span>
      uint length;
      assembly {
            <span class="hljs-comment">//检索目标地址上的代码大小，这需要汇编</span>
            length := extcodesize(_addr)
      }
      <span class="hljs-keyword">return</span> (length&gt;<span class="hljs-number">0</span>);
    }

  <span class="hljs-comment">//当传递目标是一个地址时调用函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferToAddress</span><span class="hljs-params">(address _to, uint _value, bytes _data)</span> <span class="hljs-title">private</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span> {</span>
    <span class="hljs-keyword">if</span> (balanceOf(msg.sender) &lt; _value) <span class="hljs-keyword">throw</span>;
    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
    balances[_to] = safeAdd(balanceOf(_to), _value);
    Transfer(msg.sender, _to, _value, _data);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-comment">//当传递目标是一个合约时调用函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferToContract</span><span class="hljs-params">(address _to, uint _value, bytes _data)</span> <span class="hljs-title">private</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span> {</span>
    <span class="hljs-keyword">if</span> (balanceOf(msg.sender) &lt; _value) <span class="hljs-keyword">throw</span>;
    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
    balances[_to] = safeAdd(balanceOf(_to), _value);
    ContractReceiver receiver = ContractReceiver(_to);
    receiver.tokenFallback(msg.sender, _value, _data); <span class="hljs-comment">//必须要调用这个回调</span>
    Transfer(msg.sender, _to, _value, _data);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}


  <span class="hljs-comment">//得到_owner的余额</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint balance)</span> {</span>
    <span class="hljs-keyword">return</span> balances[_owner];
  }
}</code></pre> 
  <h1 id="参考资料">参考资料</h1> 
  <ul> 
   <li><a href="https://github.com/ethereum/EIPs/issues/223" rel="nofollow" target="_blank">https://github.com/ethereum/EIPs/issues/223</a></li> 
   <li><a href="https://github.com/Dexaran/ERC223-token-standard/tree/Recommended" rel="nofollow" target="_blank">https://github.com/Dexaran/ERC223-token-standard/tree/Recommended</a></li> 
   <li><a href="https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/" rel="nofollow" target="_blank">https://www.reddit.com/r/ethereum/comments/60ql37/attention_be_careful_using_ethereum_tokens/</a></li> 
   <li><a href="http://www.jinse.com/news/ethereum/43264.html" rel="nofollow" target="_blank">http://www.jinse.com/news/ethereum/43264.html</a></li> 
   <li><a href="https://www.reddit.com/r/ethereum/comments/6m9rnu/erc20_vs_erc223_eli5/" rel="nofollow" target="_blank">https://www.reddit.com/r/ethereum/comments/6m9rnu/erc20_vs_erc223_eli5/</a></li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78093229,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/diandianxiyu_geek/article/details/78093229,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
