<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于FreeRTOS与MQTT的物联网技术应用系列——步进电机控制（四）FreeRTOS系统下LwIP-1.4.1的移植 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于FreeRTOS与MQTT的物联网技术应用系列——步进电机控制（四）FreeRTOS系统下LwIP-1.4.1的移植" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文在前一篇的基础上，进行基于FreeRTOS的LwIP-1.4.1版本移植、 本文使用的网卡PHY芯片型号是DP83848，工作在MII接口模式，时钟频率是25MHz。 现在的LwIP版本已经发展到了lwIP 2.0.3 版。 但是看了具体的代码后发现一些跟1.4.1对比之下不同之处，其中包含但不全部： 1、IPv4和IPv6的实现代码混合起来，而1.4.1是分开的，通过预处理宏可以分开编译。 2、增加了一些常用的网络组件或应用程序，其中包括了基于tcp接口实现的MQTT协议。 本人也曾试图移植lwIP 2.0.2，发现IPv6实现会被编译进去，并且由此产生一些函数调用问题，在我们的固件库中以及mdk的库中不支持相关函数，另外，本项目用的芯片并不支持IPv6，而相关代码会增加ROM空间的占用，没有必要，而LwIP2.0.2以上的版本所带的MQTT协议实现也可以移植过来到LwIP-1.4.1上使用。 因此还是选用LwIP的1.4.1这个经典版本。但后面的MQTT协议实现没有用LwIP2.0.2版的实现代码，而是比较接近paho.mqtt.embedded-c版的一个实现。 以下是具体移植过程： LwIP的官方网站：http://savannah.nongnu.org/projects/lwip/ LwIP-1.4.1下载地址：http://download.savannah.nongnu.org/releases/lwip/lwip-1.4.1.zip 或：http://ftp.yzu.edu.tw/nongnu/lwip/lwip-1.4.1.zip 或：https://gitee.com/null_926_6734/CongXiangYingGuanFangHuoQiJingXiangXiaZaiDeMouXieYuanDaiMa/raw/master/lwip-1.4.1.zip contrib-1.4.1.zip contrib-1.4.1里面含有官方的移植示例，有windows和unix操作系统下的移植，和某些非操作系统的移植。 在本项目的移植中需要用到一些头文件，可以在contrib-1.4.1中找到。 本文参考了网络上的源代码： STM32_FreeRTOS_LwIP 这份代码的说明是这样的： 说明： 在神州五号STM32F107VC开发板上移植了最新的FreeRTOS-V8.1.2操作系统，并在该系统上移植了最新的LwIP-1.4.1协议栈，能够ping通，但是系统的稳定性没有测试，仅供使用者参考。 本人提供的备用下载地址： STM32_FreeRTOS_LwIP.rar 移植之前，我们要确认一下网卡芯片的工作模式MII接口模式。根据金牛开发板官方驱动代码提供的代码 看到该开发板的PHY芯片DP83848跟STM32F107VC引脚的对应关系如下： lwip-1.4.1.zip代码包解压之后放到third_party目录下。 在IDE上增加一个组，命名为：third_party/LwIP。 1、把third_party\lwip-1.4.1\src\core下的c文件加入工程中； 2、把third_party\lwip-1.4.1\src\core\ipv4下的c文件加入到工程中； 3、把third_party\lwip-1.4.1\src\netif下的c文件加入到工程中； 4、把third_party\lwip-1.4.1\src\api下的c文件加入到工程中； 5、把一下路径加入包含路径中： ..\third_party\lwip-1.4.1\src\include;..\third_party\lwip-1.4.1\src\include\lwip;..\third_party\lwip-1.4.1\src\include\arch;..\third_party\lwip-1.4.1\src\include\ipv4;..\third_party\lwip-1.4.1\src\include\netif; 此时编译，会出现错误，提示找不到lwipopts.h文件。 我们直接在STM32_FreeRTOS_LwIP这份源代码中直接复制过来，它位置在 STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\App下面，顺便把netconf.h和netconf.c复制过来，放到BSP目录下： 关于lwipopts.h的配置说明请参考： http://blog.csdn.net/slj_win/article/details/16959055 我们拷贝过来的这份lwipopts.h中的配置，是实际使用的时候，会占用大部分的RAM，以至于FreeRTOS的任务经常出现栈溢出或直接跑飞，因此需要稍微减少内存的使用，做一些修改。 还有就是需要添加对DNS的支持： #define LWIP_DNS 1 和对接收数据定时窗口的支持： #define LWIP_SO_RCVTIMEO 1 修改后如下： /** ****************************************************************************** * @file lwipopts.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief lwIP Options Configuration. * This file is based on Utilities\lwip_v1.3.2\src\include\lwip\opt.h * and contains the lwIP configuration for the STM32F2x7 demonstration. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ #ifndef __LWIPOPTS_H__ #define __LWIPOPTS_H__ /** * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain * critical regions during buffer allocation, deallocation and memory * allocation and deallocation. */ #define SYS_LIGHTWEIGHT_PROT 0 #define ETHARP_TRUST_IP_MAC 0 #define IP_REASSEMBLY 0 #define IP_FRAG 0 //#define ARP_QUEUEING 0 /* ---------- ARP options ---------- */ #define LWIP_ARP 1 #define ARP_TABLE_SIZE 10 #define ARP_QUEUEING 1 /** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use lwIP facilities. */ #define NO_SYS 0 /* ---------- Memory options ---------- */ /* MEM_ALIGNMENT: should be set to the alignment of the CPU for which lwIP is compiled. 4 byte alignment -&gt; define MEM_ALIGNMENT to 4, 2 byte alignment -&gt; define MEM_ALIGNMENT to 2. */ #define MEM_ALIGNMENT 4 /* MEM_SIZE: the size of the heap memory. If the application will send a lot of data that needs to be copied, this should be set high. */ #define MEM_SIZE (4*1024) // (5*1024) @2017.08.26 /* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application sends a lot of data out of ROM (or other static memory), this should be set high. */ #define MEMP_NUM_PBUF 100 /* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One per active UDP &quot;connection&quot;. */ #define MEMP_NUM_UDP_PCB 6 /* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections. */ #define MEMP_NUM_TCP_PCB 10 /* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */ #define MEMP_NUM_TCP_PCB_LISTEN 5 /* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */ #define MEMP_NUM_TCP_SEG 20 /* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */ #define MEMP_NUM_SYS_TIMEOUT 10 /* ---------- Pbuf options ---------- */ /* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */ #define PBUF_POOL_SIZE 10 // 20 @2017.08.26 /* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */ #define PBUF_POOL_BUFSIZE 500 /* ---------- TCP options ---------- */ #define LWIP_TCP 1 #define TCP_TTL 255 /* Controls if TCP should queue segments that arrive out of order. Define to 0 if your device is low on memory. */ #define TCP_QUEUE_OOSEQ 1 /* TCP Maximum segment size. */ #define TCP_MSS (1500 - 40) /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */ /* TCP sender buffer space (bytes). */ #define TCP_SND_BUF (5*TCP_MSS) /* TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */ #define TCP_SND_QUEUELEN (4* TCP_SND_BUF/TCP_MSS) /* TCP receive window. */ #define TCP_WND (2*TCP_MSS) /* ---------- ICMP options ---------- */ #define LWIP_ICMP 1 /* ---------- DHCP options ---------- */ /* Define LWIP_DHCP to 1 if you want DHCP configuration of interfaces. DHCP is not implemented in lwIP 0.5.1, however, so turning this on does currently not work. */ #define LWIP_DHCP 1 #define LWIP_DNS 1 //added @2017.08.17 /* Enable SO_RCVTIMEO processing. */ #define LWIP_SO_RCVTIMEO 1 //added @2017.08.18 #define DHCP_DOES_ARP_CHECK (LWIP_DHCP) /* ---------- UDP options ---------- */ #define LWIP_UDP 1 #define UDP_TTL 255 /* ---------- Statistics options ---------- */ #define LWIP_STATS 0 #define LWIP_PROVIDE_ERRNO 1 /* -------------------------------------- ---------- Checksum options ---------- -------------------------------------- */ /* The STM32F2x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware: - To use this feature let the following define uncommented. - To disable it and process by CPU comment the the checksum. */ #define CHECKSUM_BY_HARDWARE 1 #ifdef CHECKSUM_BY_HARDWARE /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 0 /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 0 /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 0 #define CHECKSUM_GEN_ICMP 0 /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 0 /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 0 /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 0 #else /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 1 /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 1 /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 1 #define CHECKSUM_GEN_ICMP 1 /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 1 /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 1 /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 1 #endif /* ---------------------------------------------- ---------- Sequential layer options ---------- ---------------------------------------------- */ /** * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c) */ #define LWIP_NETCONN 1 /* ------------------------------------ ---------- Socket options ---------- ------------------------------------ */ /** * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c) */ #define LWIP_SOCKET 1 /* ----------------------------------- ---------- DEBUG options ---------- ----------------------------------- */ #define LWIP_DEBUG 0 /* --------------------------------- ---------- OS options ---------- --------------------------------- */ #define TCPIP_THREAD_STACKSIZE 1000 #define TCPIP_MBOX_SIZE 5 #define DEFAULT_UDP_RECVMBOX_SIZE 2000 #define DEFAULT_TCP_RECVMBOX_SIZE 2000 #define DEFAULT_ACCEPTMBOX_SIZE 2000 #define DEFAULT_THREAD_STACKSIZE 500 #define TCPIP_THREAD_PRIO (configMAX_PRIORITIES - 2) #endif /* __LWIPOPTS_H__ */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 还有跟移植相关的部分代码在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\lwip-1.4.1\src\include\arch目录下，把整个文件夹都复制过来： 放在我们的相应目录下，并把其中的sys_arch.c加入到IDE的third_party/LwIP组中。 此时编译一下，会出现一堆警告，其中一个是： ..\third_party\lwip-1.4.1\src\core\dns.c(241): warning: #223-D: function &quot;LWIP_PLATFORM_DIAG&quot; declared implicitly 这是LWIP_PLATFORM_DIAG这个宏没有定义的原因。 可以在third_party\lwip-1.4.1\src\include\lwip\debug.h这个文件中定义。 找到： #define LWIP_DEBUGF(debug, message) do { \ 这一行，在它前面加上： #include &lt;stdio.h&gt; #define LWIP_PLATFORM_DIAG printf 并找到： LWIP_PLATFORM_DIAG(message); \ 修改为： LWIP_PLATFORM_DIAG message ; \ 再编译，出现错误： ..\third_party\lwip-1.4.1\src\include\lwip/sys.h(113): error: #20: identifier &quot;sys_mutex_t&quot; is undefined 解决方法是在 #if LWIP_COMPAT_MUTEX 前面定义这个宏： #define LWIP_COMPAT_MUTEX 1 编译，通过。 这是LwIP协议栈的主体部分OK了，但是还没有跟FreeRTOS对接好，另外没有把网卡驱动搞定。下面一步步完成吧。 接下来，首先把网卡驱动搞定。这部分在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\STM32_ETH_Driver下的源码基础上做修改。 把整个STM32_ETH_Driver文件夹复制到我们的项目根目录下，在IDE上添加一个组，命名为STM32_ETH_Driver，把项目中的STM32_ETH_Driver\src\stm32_eth.c加入到组中。 把..\STM32_ETH_Driver\inc加入包含路径中位置如图所示： 接下来要修改stm32_eth.h和stm32_eth.c。 stm32_eth.c主要是对网卡控制器进行操作，以对网卡芯片初始化。 stm32_eth.h： /** ****************************************************************************** * @file stm32_eth.h * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file contains all the functions prototypes for the Ethernet * firmware library. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __STM32_ETH_H #define __STM32_ETH_H #ifdef __cplusplus extern &quot;C&quot; { #endif /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x.h&quot; /** @addtogroup STM32_ETH_Driver * @{ */ /** @defgroup ETH_Exported_Types * @{ */ /** * @brief ETH MAC Init structure definition * @note The user should not configure all the ETH_InitTypeDef structure&#39;s fields. * By calling the ETH_StructInit function the structure¡¯s fields are set to their default values. * Only the parameters that will be set to a non-default value should be configured. */ typedef struct { /** * @brief / * MAC */ uint32_t ETH_AutoNegotiation; /*!&lt; Selects or not the AutoNegotiation mode for the external PHY The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps) and the mode (half/full-duplex). This parameter can be a value of @ref ETH_AutoNegotiation */ uint32_t ETH_Watchdog; /*!&lt; Selects or not the Watchdog timer When enabled, the MAC allows no more then 2048 bytes to be received. When disabled, the MAC can receive up to 16384 bytes. This parameter can be a value of @ref ETH_watchdog */ uint32_t ETH_Jabber; /*!&lt; Selects or not Jabber timer When enabled, the MAC allows no more then 2048 bytes to be sent. When disabled, the MAC can send up to 16384 bytes. This parameter can be a value of @ref ETH_Jabber */ uint32_t ETH_InterFrameGap; /*!&lt; Selects the minimum IFG between frames during transmission This parameter can be a value of @ref ETH_Inter_Frame_Gap */ uint32_t ETH_CarrierSense; /*!&lt; Selects or not the Carrier Sense This parameter can be a value of @ref ETH_Carrier_Sense */ uint32_t ETH_Speed; /*!&lt; Sets the Ethernet speed: 10/100 Mbps This parameter can be a value of @ref ETH_Speed */ uint32_t ETH_ReceiveOwn; /*!&lt; Selects or not the ReceiveOwn ReceiveOwn allows the reception of frames when the TX_EN signal is asserted in Half-Duplex mode This parameter can be a value of @ref ETH_Receive_Own */ uint32_t ETH_LoopbackMode; /*!&lt; Selects or not the internal MAC MII Loopback mode This parameter can be a value of @ref ETH_Loop_Back_Mode */ uint32_t ETH_Mode; /*!&lt; Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode This parameter can be a value of @ref ETH_Duplex_Mode */ uint32_t ETH_ChecksumOffload; /*!&lt; Selects or not the IPv4 checksum checking for received frame payloads&#39; TCP/UDP/ICMP headers. This parameter can be a value of @ref ETH_Checksum_Offload */ uint32_t ETH_RetryTransmission; /*!&lt; Selects or not the MAC attempt retries transmission, based on the settings of BL, when a colision occurs (Half-Duplex mode) This parameter can be a value of @ref ETH_Retry_Transmission */ uint32_t ETH_AutomaticPadCRCStrip; /*!&lt; Selects or not the Automatic MAC Pad/CRC Stripping This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ uint32_t ETH_BackOffLimit; /*!&lt; Selects the BackOff limit value This parameter can be a value of @ref ETH_Back_Off_Limit */ uint32_t ETH_DeferralCheck; /*!&lt; Selects or not the deferral check function (Half-Duplex mode) This parameter can be a value of @ref ETH_Deferral_Check */ uint32_t ETH_ReceiveAll; /*!&lt; Selects or not all frames reception by the MAC (No fitering) This parameter can be a value of @ref ETH_Receive_All */ uint32_t ETH_SourceAddrFilter; /*!&lt; Selects the Source Address Filter mode This parameter can be a value of @ref ETH_Source_Addr_Filter */ uint32_t ETH_PassControlFrames; /*!&lt; Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames) This parameter can be a value of @ref ETH_Pass_Control_Frames */ uint32_t ETH_BroadcastFramesReception; /*!&lt; Selects or not the reception of Broadcast Frames This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */ uint32_t ETH_DestinationAddrFilter; /*!&lt; Sets the destination filter mode for both unicast and multicast frames This parameter can be a value of @ref ETH_Destination_Addr_Filter */ uint32_t ETH_PromiscuousMode; /*!&lt; Selects or not the Promiscuous Mode This parameter can be a value of @ref ETH_Promiscuous_Mode */ uint32_t ETH_MulticastFramesFilter; /*!&lt; Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ uint32_t ETH_UnicastFramesFilter; /*!&lt; Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ uint32_t ETH_HashTableHigh; /*!&lt; This field holds the higher 32 bits of Hash table. */ uint32_t ETH_HashTableLow; /*!&lt; This field holds the lower 32 bits of Hash table. */ uint32_t ETH_PauseTime; /*!&lt; This field holds the value to be used in the Pause Time field in the transmit control frame */ uint32_t ETH_ZeroQuantaPause; /*!&lt; Selects or not the automatic generation of Zero-Quanta Pause Control frames This parameter can be a value of @ref ETH_Zero_Quanta_Pause */ uint32_t ETH_PauseLowThreshold; /*!&lt; This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Frame This parameter can be a value of @ref ETH_Pause_Low_Threshold */ uint32_t ETH_UnicastPauseFrameDetect; /*!&lt; Selects or not the MAC detection of the Pause frames (with MAC Address0 unicast address and unique multicast address) This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */ uint32_t ETH_ReceiveFlowControl; /*!&lt; Enables or disables the MAC to decode the received Pause frame and disable its transmitter for a specified time (Pause Time) This parameter can be a value of @ref ETH_Receive_Flow_Control */ uint32_t ETH_TransmitFlowControl; /*!&lt; Enables or disables the MAC to transmit Pause frames (Full-Duplex mode) or the MAC back-pressure operation (Half-Duplex mode) This parameter can be a value of @ref ETH_Transmit_Flow_Control */ uint32_t ETH_VLANTagComparison; /*!&lt; Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for comparison and filtering This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ uint32_t ETH_VLANTagIdentifier; /*!&lt; Holds the VLAN tag identifier for receive frames */ /** * @brief / * DMA */ uint32_t ETH_DropTCPIPChecksumErrorFrame; /*!&lt; Selects or not the Dropping of TCP/IP Checksum Error Frames This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ uint32_t ETH_ReceiveStoreForward; /*!&lt; Enables or disables the Receive store and forward mode This parameter can be a value of @ref ETH_Receive_Store_Forward */ uint32_t ETH_FlushReceivedFrame; /*!&lt; Enables or disables the flushing of received frames This parameter can be a value of @ref ETH_Flush_Received_Frame */ uint32_t ETH_TransmitStoreForward; /*!&lt; Enables or disables Transmit store and forward mode This parameter can be a value of @ref ETH_Transmit_Store_Forward */ uint32_t ETH_TransmitThresholdControl; /*!&lt; Selects or not the Transmit Threshold Control This parameter can be a value of @ref ETH_Transmit_Threshold_Control */ uint32_t ETH_ForwardErrorFrames; /*!&lt; Selects or not the forward to the DMA of erroneous frames This parameter can be a value of @ref ETH_Forward_Error_Frames */ uint32_t ETH_ForwardUndersizedGoodFrames; /*!&lt; Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error and length less than 64 bytes) including pad-bytes and CRC) This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */ uint32_t ETH_ReceiveThresholdControl; /*!&lt; Selects the threshold level of the Receive FIFO This parameter can be a value of @ref ETH_Receive_Threshold_Control */ uint32_t ETH_SecondFrameOperate; /*!&lt; Selects or not the Operate on second frame mode, which allows the DMA to process a second frame of Transmit data even before obtaining the status for the first frame. This parameter can be a value of @ref ETH_Second_Frame_Operate */ uint32_t ETH_AddressAlignedBeats; /*!&lt; Enables or disables the Address Aligned Beats This parameter can be a value of @ref ETH_Address_Aligned_Beats */ uint32_t ETH_FixedBurst; /*!&lt; Enables or disables the AHB Master interface fixed burst transfers This parameter can be a value of @ref ETH_Fixed_Burst */ uint32_t ETH_RxDMABurstLength; /*!&lt; Indicates the maximum number of beats to be transferred in one Rx DMA transaction This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ uint32_t ETH_TxDMABurstLength; /*!&lt; Indicates sthe maximum number of beats to be transferred in one Tx DMA transaction This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */ uint32_t ETH_DescriptorSkipLength; /*!&lt; Specifies the number of word to skip between two unchained descriptors (Ring mode) */ uint32_t ETH_DMAArbitration; /*!&lt; Selects the DMA Tx/Rx arbitration This parameter can be a value of @ref ETH_DMA_Arbitration */ }ETH_InitTypeDef; /**--------------------------------------------------------------------------**/ /** * @brief DMA descriptors types */ /**--------------------------------------------------------------------------**/ /** * @brief ETH DMA Desciptors data structure definition */ typedef struct { uint32_t Status; /*!&lt; Status */ uint32_t ControlBufferSize; /*!&lt; Control and Buffer1, Buffer2 lengths */ uint32_t Buffer1Addr; /*!&lt; Buffer1 address pointer */ uint32_t Buffer2NextDescAddr; /*!&lt; Buffer2 or next descriptor address pointer */ } ETH_DMADESCTypeDef; /** * @} */ /** @defgroup ETH_Exported_Constants * @{ */ /**--------------------------------------------------------------------------**/ /** * @brief ETH Frames defines */ /**--------------------------------------------------------------------------**/ /** @defgroup ENET_Buffers_setting * @{ */ #define ETH_MAX_PACKET_SIZE 1520 /*!&lt; ETH_HEADER + ETH_EXTRA + MAX_ETH_PAYLOAD + ETH_CRC */ #define ETH_HEADER 14 /*!&lt; 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */ #define ETH_CRC 4 /*!&lt; Ethernet CRC */ #define ETH_EXTRA 2 /*!&lt; Extra bytes in some cases */ #define VLAN_TAG 4 /*!&lt; optional 802.1q VLAN Tag */ #define MIN_ETH_PAYLOAD 46 /*!&lt; Minimum Ethernet payload size */ #define MAX_ETH_PAYLOAD 1500 /*!&lt; Maximum Ethernet payload size */ #define JUMBO_FRAME_PAYLOAD 9000 /*!&lt; Jumbo frame payload size */ /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA descriptors registers bits definition */ /**--------------------------------------------------------------------------**/ /** @code DMA Tx Desciptor ----------------------------------------------------------------------------------------------- TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] | ----------------------------------------------------------------------------------------------- TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] | ----------------------------------------------------------------------------------------------- TDES2 | Buffer1 Address [31:0] | ----------------------------------------------------------------------------------------------- TDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | ----------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of TDES0 register: DMA Tx descriptor status register */ #define ETH_DMATxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMATxDesc_IC ((uint32_t)0x40000000) /*!&lt; Interrupt on Completion */ #define ETH_DMATxDesc_LS ((uint32_t)0x20000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FS ((uint32_t)0x10000000) /*!&lt; First Segment */ #define ETH_DMATxDesc_DC ((uint32_t)0x08000000) /*!&lt; Disable CRC */ #define ETH_DMATxDesc_DP ((uint32_t)0x04000000) /*!&lt; Disable Padding */ #define ETH_DMATxDesc_TTSE ((uint32_t)0x02000000) /*!&lt; Transmit Time Stamp Enable */ #define ETH_DMATxDesc_CIC ((uint32_t)0x00C00000) /*!&lt; Checksum Insertion Control: 4 cases */ #define ETH_DMATxDesc_CIC_ByPass ((uint32_t)0x00000000) /*!&lt; Do Nothing: Checksum Engine is bypassed */ #define ETH_DMATxDesc_CIC_IPV4Header ((uint32_t)0x00400000) /*!&lt; IPV4 header Checksum Insertion */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP Checksum Insertion calculated over segment only */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Full ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP Checksum Insertion fully calculated */ #define ETH_DMATxDesc_TER ((uint32_t)0x00200000) /*!&lt; Transmit End of Ring */ #define ETH_DMATxDesc_TCH ((uint32_t)0x00100000) /*!&lt; Second Address Chained */ #define ETH_DMATxDesc_TTSS ((uint32_t)0x00020000) /*!&lt; Tx Time Stamp Status */ #define ETH_DMATxDesc_IHE ((uint32_t)0x00010000) /*!&lt; IP Header Error */ #define ETH_DMATxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */ #define ETH_DMATxDesc_JT ((uint32_t)0x00004000) /*!&lt; Jabber Timeout */ #define ETH_DMATxDesc_FF ((uint32_t)0x00002000) /*!&lt; Frame Flushed: DMA/MTL flushed the frame due to SW flush */ #define ETH_DMATxDesc_PCE ((uint32_t)0x00001000) /*!&lt; Payload Checksum Error */ #define ETH_DMATxDesc_LCA ((uint32_t)0x00000800) /*!&lt; Loss of Carrier: carrier lost during tramsmission */ #define ETH_DMATxDesc_NC ((uint32_t)0x00000400) /*!&lt; No Carrier: no carrier signal from the tranceiver */ #define ETH_DMATxDesc_LCO ((uint32_t)0x00000200) /*!&lt; Late Collision: transmission aborted due to collision */ #define ETH_DMATxDesc_EC ((uint32_t)0x00000100) /*!&lt; Excessive Collision: transmission aborted after 16 collisions */ #define ETH_DMATxDesc_VF ((uint32_t)0x00000080) /*!&lt; VLAN Frame */ #define ETH_DMATxDesc_CC ((uint32_t)0x00000078) /*!&lt; Collision Count */ #define ETH_DMATxDesc_ED ((uint32_t)0x00000004) /*!&lt; Excessive Deferral */ #define ETH_DMATxDesc_UF ((uint32_t)0x00000002) /*!&lt; Underflow Error: late data arrival from the memory */ #define ETH_DMATxDesc_DB ((uint32_t)0x00000001) /*!&lt; Deferred Bit */ /** * @brief Bit definition of TDES1 register */ #define ETH_DMATxDesc_TBS2 ((uint32_t)0x1FFF0000) /*!&lt; Transmit Buffer2 Size */ #define ETH_DMATxDesc_TBS1 ((uint32_t)0x00001FFF) /*!&lt; Transmit Buffer1 Size */ /** * @brief Bit definition of TDES2 register */ #define ETH_DMATxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of TDES3 register */ #define ETH_DMATxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /** * @} */ /** @defgroup DMA_Rx_descriptor * @{ */ /** @code DMA Rx Desciptor -------------------------------------------------------------------------------------------------------------------- RDES0 | OWN(31) | Status [30:0] | --------------------------------------------------------------------------------------------------------------------- RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] | --------------------------------------------------------------------------------------------------------------------- RDES2 | Buffer1 Address [31:0] | --------------------------------------------------------------------------------------------------------------------- RDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | --------------------------------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of RDES0 register: DMA Rx descriptor status register */ #define ETH_DMARxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMARxDesc_AFM ((uint32_t)0x40000000) /*!&lt; DA Filter Fail for the rx frame */ #define ETH_DMARxDesc_FL ((uint32_t)0x3FFF0000) /*!&lt; Receive descriptor frame length */ #define ETH_DMARxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */ #define ETH_DMARxDesc_DE ((uint32_t)0x00004000) /*!&lt; Desciptor error: no more descriptors for receive frame */ #define ETH_DMARxDesc_SAF ((uint32_t)0x00002000) /*!&lt; SA Filter Fail for the received frame */ #define ETH_DMARxDesc_LE ((uint32_t)0x00001000) /*!&lt; Frame size not matching with length field */ #define ETH_DMARxDesc_OE ((uint32_t)0x00000800) /*!&lt; Overflow Error: Frame was damaged due to buffer overflow */ #define ETH_DMARxDesc_VLAN ((uint32_t)0x00000400) /*!&lt; VLAN Tag: received frame is a VLAN frame */ #define ETH_DMARxDesc_FS ((uint32_t)0x00000200) /*!&lt; First descriptor of the frame */ #define ETH_DMARxDesc_LS ((uint32_t)0x00000100) /*!&lt; Last descriptor of the frame */ #define ETH_DMARxDesc_IPV4HCE ((uint32_t)0x00000080) /*!&lt; IPC Checksum Error: Rx Ipv4 header checksum error */ #define ETH_DMARxDesc_LC ((uint32_t)0x00000040) /*!&lt; Late collision occurred during reception */ #define ETH_DMARxDesc_FT ((uint32_t)0x00000020) /*!&lt; Frame type - Ethernet, otherwise 802.3 */ #define ETH_DMARxDesc_RWT ((uint32_t)0x00000010) /*!&lt; Receive Watchdog Timeout: watchdog timer expired during reception */ #define ETH_DMARxDesc_RE ((uint32_t)0x00000008) /*!&lt; Receive error: error reported by MII interface */ #define ETH_DMARxDesc_DBE ((uint32_t)0x00000004) /*!&lt; Dribble bit error: frame contains non int multiple of 8 bits */ #define ETH_DMARxDesc_CE ((uint32_t)0x00000002) /*!&lt; CRC error */ #define ETH_DMARxDesc_MAMPCE ((uint32_t)0x00000001) /*!&lt; Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */ /** * @brief Bit definition of RDES1 register */ #define ETH_DMARxDesc_DIC ((uint32_t)0x80000000) /*!&lt; Disable Interrupt on Completion */ #define ETH_DMARxDesc_RBS2 ((uint32_t)0x1FFF0000) /*!&lt; Receive Buffer2 Size */ #define ETH_DMARxDesc_RER ((uint32_t)0x00008000) /*!&lt; Receive End of Ring */ #define ETH_DMARxDesc_RCH ((uint32_t)0x00004000) /*!&lt; Second Address Chained */ #define ETH_DMARxDesc_RBS1 ((uint32_t)0x00001FFF) /*!&lt; Receive Buffer1 Size */ /** * @brief Bit definition of RDES2 register */ #define ETH_DMARxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of RDES3 register */ #define ETH_DMARxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /**--------------------------------------------------------------------------**/ /** * @brief Desciption of common PHY registers */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup PHY_Read_write_Timeouts * @{ */ #define PHY_READ_TO ((uint32_t)0x0004FFFF) #define PHY_WRITE_TO ((uint32_t)0x0004FFFF) /** * @} */ /** @defgroup PHY_Reset_Delay * @{ */ #define PHY_ResetDelay ((uint32_t)0x000FFFFF) /** * @} */ /** @defgroup PHY_Config_Delay * @{ */ #define PHY_ConfigDelay ((uint32_t)0x00FFFFFF) /** * @} */ /** @defgroup PHY_Register_address * @{ */ #define PHY_BCR 0 /*!&lt; Tranceiver Basic Control Register */ #define PHY_BSR 1 /*!&lt; Tranceiver Basic Status Register */ /** * @} */ /** @defgroup PHY_basic_Control_register * @{ */ #define PHY_Reset ((u16)0x8000) /*!&lt; PHY Reset */ #define PHY_Loopback ((u16)0x4000) /*!&lt; Select loop-back mode */ #define PHY_FULLDUPLEX_100M ((u16)0x2100) /*!&lt; Set the full-duplex mode at 100 Mb/s */ #define PHY_HALFDUPLEX_100M ((u16)0x2000) /*!&lt; Set the half-duplex mode at 100 Mb/s */ #define PHY_FULLDUPLEX_10M ((u16)0x0100) /*!&lt; Set the full-duplex mode at 10 Mb/s */ #define PHY_HALFDUPLEX_10M ((u16)0x0000) /*!&lt; Set the half-duplex mode at 10 Mb/s */ #define PHY_AutoNegotiation ((u16)0x1000) /*!&lt; Enable auto-negotiation function */ #define PHY_Restart_AutoNegotiation ((u16)0x0200) /*!&lt; Restart auto-negotiation function */ #define PHY_Powerdown ((u16)0x0800) /*!&lt; Select the power down mode */ #define PHY_Isolate ((u16)0x0400) /*!&lt; Isolate PHY from MII */ /** * @} */ /** @defgroup PHY_basic_status_register * @{ */ #define PHY_AutoNego_Complete ((u16)0x0020) /*!&lt; Auto-Negotioation process completed */ #define PHY_Linked_Status ((u16)0x0004) /*!&lt; Valid link established */ #define PHY_Jabber_detection ((u16)0x0002) /*!&lt; Jabber condition detected */ /** * @} */ /** @defgroup PHY_status_register * @{ */ /* The PHY status register value change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_SR 31 /*!&lt; Tranceiver Status Register */ /** * @brief For DP83848 */ #define PHY_SR 16 /*!&lt; Tranceiver Status Register */ /* The Speed and Duplex mask values change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_Speed_Status ((u16)0x0004) /*!&lt; Configured information of Speed: 10Mbps */ //#define PHY_Duplex_Status ((u16)0x0010) /*!&lt; Configured information of Duplex: Full-duplex */ /** * @brief For DP83848 */ #define PHY_Speed_Status ((u16)0x0002) /*!&lt; Configured information of Speed: 10Mbps */ #define PHY_Duplex_Status ((u16)0x0004) /*!&lt; Configured information of Duplex: Full-duplex */ #define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) &lt;= 0x1F) #define IS_ETH_PHY_REG(REG) (REG &lt;= 0x1F) /**--------------------------------------------------------------------------**/ /** * @brief MAC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_AutoNegotiation * @{ */ #define ETH_AutoNegotiation_Enable ((uint32_t)0x00000001) #define ETH_AutoNegotiation_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \ ((CMD) == ETH_AutoNegotiation_Disable)) /** * @} */ /** @defgroup ETH_watchdog * @{ */ #define ETH_Watchdog_Enable ((uint32_t)0x00000000) #define ETH_Watchdog_Disable ((uint32_t)0x00800000) #define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \ ((CMD) == ETH_Watchdog_Disable)) /** * @} */ /** @defgroup ETH_Jabber * @{ */ #define ETH_Jabber_Enable ((uint32_t)0x00000000) #define ETH_Jabber_Disable ((uint32_t)0x00400000) #define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \ ((CMD) == ETH_Jabber_Disable)) /** * @} */ /** @defgroup ETH_Inter_Frame_Gap * @{ */ #define ETH_InterFrameGap_96Bit ((uint32_t)0x00000000) /*!&lt; minimum IFG between frames during transmission is 96Bit */ #define ETH_InterFrameGap_88Bit ((uint32_t)0x00020000) /*!&lt; minimum IFG between frames during transmission is 88Bit */ #define ETH_InterFrameGap_80Bit ((uint32_t)0x00040000) /*!&lt; minimum IFG between frames during transmission is 80Bit */ #define ETH_InterFrameGap_72Bit ((uint32_t)0x00060000) /*!&lt; minimum IFG between frames during transmission is 72Bit */ #define ETH_InterFrameGap_64Bit ((uint32_t)0x00080000) /*!&lt; minimum IFG between frames during transmission is 64Bit */ #define ETH_InterFrameGap_56Bit ((uint32_t)0x000A0000) /*!&lt; minimum IFG between frames during transmission is 56Bit */ #define ETH_InterFrameGap_48Bit ((uint32_t)0x000C0000) /*!&lt; minimum IFG between frames during transmission is 48Bit */ #define ETH_InterFrameGap_40Bit ((uint32_t)0x000E0000) /*!&lt; minimum IFG between frames during transmission is 40Bit */ #define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \ ((GAP) == ETH_InterFrameGap_88Bit) || \ ((GAP) == ETH_InterFrameGap_80Bit) || \ ((GAP) == ETH_InterFrameGap_72Bit) || \ ((GAP) == ETH_InterFrameGap_64Bit) || \ ((GAP) == ETH_InterFrameGap_56Bit) || \ ((GAP) == ETH_InterFrameGap_48Bit) || \ ((GAP) == ETH_InterFrameGap_40Bit)) /** * @} */ /** @defgroup ETH_Carrier_Sense * @{ */ #define ETH_CarrierSense_Enable ((uint32_t)0x00000000) #define ETH_CarrierSense_Disable ((uint32_t)0x00010000) #define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \ ((CMD) == ETH_CarrierSense_Disable)) /** * @} */ /** @defgroup ETH_Speed * @{ */ #define ETH_Speed_10M ((uint32_t)0x00000000) #define ETH_Speed_100M ((uint32_t)0x00004000) #define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \ ((SPEED) == ETH_Speed_100M)) /** * @} */ /** @defgroup ETH_Receive_Own * @{ */ #define ETH_ReceiveOwn_Enable ((uint32_t)0x00000000) #define ETH_ReceiveOwn_Disable ((uint32_t)0x00002000) #define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \ ((CMD) == ETH_ReceiveOwn_Disable)) /** * @} */ /** @defgroup ETH_Loop_Back_Mode * @{ */ #define ETH_LoopbackMode_Enable ((uint32_t)0x00001000) #define ETH_LoopbackMode_Disable ((uint32_t)0x00000000) #define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \ ((CMD) == ETH_LoopbackMode_Disable)) /** * @} */ /** @defgroup ETH_Duplex_Mode * @{ */ #define ETH_Mode_FullDuplex ((uint32_t)0x00000800) #define ETH_Mode_HalfDuplex ((uint32_t)0x00000000) #define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \ ((MODE) == ETH_Mode_HalfDuplex)) /** * @} */ /** @defgroup ETH_Checksum_Offload * @{ */ #define ETH_ChecksumOffload_Enable ((uint32_t)0x00000400) #define ETH_ChecksumOffload_Disable ((uint32_t)0x00000000) #define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \ ((CMD) == ETH_ChecksumOffload_Disable)) /** * @} */ /** @defgroup ETH_Retry_Transmission * @{ */ #define ETH_RetryTransmission_Enable ((uint32_t)0x00000000) #define ETH_RetryTransmission_Disable ((uint32_t)0x00000200) #define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \ ((CMD) == ETH_RetryTransmission_Disable)) /** * @} */ /** @defgroup ETH_Automatic_Pad_CRC_Strip * @{ */ #define ETH_AutomaticPadCRCStrip_Enable ((uint32_t)0x00000080) #define ETH_AutomaticPadCRCStrip_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \ ((CMD) == ETH_AutomaticPadCRCStrip_Disable)) /** * @} */ /** @defgroup ETH_Back_Off_Limit * @{ */ #define ETH_BackOffLimit_10 ((uint32_t)0x00000000) #define ETH_BackOffLimit_8 ((uint32_t)0x00000020) #define ETH_BackOffLimit_4 ((uint32_t)0x00000040) #define ETH_BackOffLimit_1 ((uint32_t)0x00000060) #define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \ ((LIMIT) == ETH_BackOffLimit_8) || \ ((LIMIT) == ETH_BackOffLimit_4) || \ ((LIMIT) == ETH_BackOffLimit_1)) /** * @} */ /** @defgroup ETH_Deferral_Check * @{ */ #define ETH_DeferralCheck_Enable ((uint32_t)0x00000010) #define ETH_DeferralCheck_Disable ((uint32_t)0x00000000) #define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \ ((CMD) == ETH_DeferralCheck_Disable)) /** * @} */ /** @defgroup ETH_Receive_All * @{ */ #define ETH_ReceiveAll_Enable ((uint32_t)0x80000000) #define ETH_ReceiveAll_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \ ((CMD) == ETH_ReceiveAll_Disable)) /** * @} */ /** @defgroup ETH_Source_Addr_Filter * @{ */ #define ETH_SourceAddrFilter_Normal_Enable ((uint32_t)0x00000200) #define ETH_SourceAddrFilter_Inverse_Enable ((uint32_t)0x00000300) #define ETH_SourceAddrFilter_Disable ((uint32_t)0x00000000) #define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \ ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \ ((CMD) == ETH_SourceAddrFilter_Disable)) /** * @} */ /** @defgroup ETH_Pass_Control_Frames * @{ */ #define ETH_PassControlFrames_BlockAll ((uint32_t)0x00000040) /*!&lt; MAC filters all control frames from reaching the application */ #define ETH_PassControlFrames_ForwardAll ((uint32_t)0x00000080) /*!&lt; MAC forwards all control frames to application even if they fail the Address Filter */ #define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)0x000000C0) /*!&lt; MAC forwards control frames that pass the Address Filter. */ #define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \ ((PASS) == ETH_PassControlFrames_ForwardAll) || \ ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter)) /** * @} */ /** @defgroup ETH_Broadcast_Frames_Reception * @{ */ #define ETH_BroadcastFramesReception_Enable ((uint32_t)0x00000000) #define ETH_BroadcastFramesReception_Disable ((uint32_t)0x00000020) #define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \ ((CMD) == ETH_BroadcastFramesReception_Disable)) /** * @} */ /** @defgroup ETH_Destination_Addr_Filter * @{ */ #define ETH_DestinationAddrFilter_Normal ((uint32_t)0x00000000) #define ETH_DestinationAddrFilter_Inverse ((uint32_t)0x00000008) #define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \ ((FILTER) == ETH_DestinationAddrFilter_Inverse)) /** * @} */ /** @defgroup ETH_Promiscuous_Mode * @{ */ #define ETH_PromiscuousMode_Enable ((uint32_t)0x00000001) #define ETH_PromiscuousMode_Disable ((uint32_t)0x00000000) #define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \ ((CMD) == ETH_PromiscuousMode_Disable)) /** * @} */ /** @defgroup ETH_Multicast_Frames_Filter * @{ */ #define ETH_MulticastFramesFilter_PerfectHashTable ((uint32_t)0x00000404) #define ETH_MulticastFramesFilter_HashTable ((uint32_t)0x00000004) #define ETH_MulticastFramesFilter_Perfect ((uint32_t)0x00000000) #define ETH_MulticastFramesFilter_None ((uint32_t)0x00000010) #define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \ ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \ ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \ ((FILTER) == ETH_MulticastFramesFilter_None)) /** * @} */ /** @defgroup ETH_Unicast_Frames_Filter * @{ */ #define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)0x00000402) #define ETH_UnicastFramesFilter_HashTable ((uint32_t)0x00000002) #define ETH_UnicastFramesFilter_Perfect ((uint32_t)0x00000000) #define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \ ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \ ((FILTER) == ETH_UnicastFramesFilter_Perfect)) /** * @} */ /** @defgroup ETH_Pause_Time * @{ */ #define IS_ETH_PAUSE_TIME(TIME) ((TIME) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_Zero_Quanta_Pause * @{ */ #define ETH_ZeroQuantaPause_Enable ((uint32_t)0x00000000) #define ETH_ZeroQuantaPause_Disable ((uint32_t)0x00000080) #define IS_ETH_ZEROQUANTA_PAUSE(CMD) (((CMD) == ETH_ZeroQuantaPause_Enable) || \ ((CMD) == ETH_ZeroQuantaPause_Disable)) /** * @} */ /** @defgroup ETH_Pause_Low_Threshold * @{ */ #define ETH_PauseLowThreshold_Minus4 ((uint32_t)0x00000000) /*!&lt; Pause time minus 4 slot times */ #define ETH_PauseLowThreshold_Minus28 ((uint32_t)0x00000010) /*!&lt; Pause time minus 28 slot times */ #define ETH_PauseLowThreshold_Minus144 ((uint32_t)0x00000020) /*!&lt; Pause time minus 144 slot times */ #define ETH_PauseLowThreshold_Minus256 ((uint32_t)0x00000030) /*!&lt; Pause time minus 256 slot times */ #define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus256)) /** * @} */ /** @defgroup ETH_Unicast_Pause_Frame_Detect * @{ */ #define ETH_UnicastPauseFrameDetect_Enable ((uint32_t)0x00000008) #define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)0x00000000) #define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \ ((CMD) == ETH_UnicastPauseFrameDetect_Disable)) /** * @} */ /** @defgroup ETH_Receive_Flow_Control * @{ */ #define ETH_ReceiveFlowControl_Enable ((uint32_t)0x00000004) #define ETH_ReceiveFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \ ((CMD) == ETH_ReceiveFlowControl_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Flow_Control * @{ */ #define ETH_TransmitFlowControl_Enable ((uint32_t)0x00000002) #define ETH_TransmitFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \ ((CMD) == ETH_TransmitFlowControl_Disable)) /** * @} */ /** @defgroup ETH_VLAN_Tag_Comparison * @{ */ #define ETH_VLANTagComparison_12Bit ((uint32_t)0x00010000) #define ETH_VLANTagComparison_16Bit ((uint32_t)0x00000000) #define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \ ((COMPARISON) == ETH_VLANTagComparison_16Bit)) #define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_MAC_Flags * @{ */ #define ETH_MAC_FLAG_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger flag (on MAC) */ #define ETH_MAC_FLAG_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit flag */ #define ETH_MAC_FLAG_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive flag */ #define ETH_MAC_FLAG_MMC ((uint32_t)0x00000010) /*!&lt; MMC flag (on MAC) */ #define ETH_MAC_FLAG_PMT ((uint32_t)0x00000008) /*!&lt; PMT flag (on MAC) */ #define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \ ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \ ((FLAG) == ETH_MAC_FLAG_PMT)) /** * @} */ /** @defgroup ETH_MAC_Interrupts * @{ */ #define ETH_MAC_IT_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger interrupt (on MAC) */ #define ETH_MAC_IT_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit interrupt */ #define ETH_MAC_IT_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive interrupt */ #define ETH_MAC_IT_MMC ((uint32_t)0x00000010) /*!&lt; MMC interrupt (on MAC) */ #define ETH_MAC_IT_PMT ((uint32_t)0x00000008) /*!&lt; PMT interrupt (on MAC) */ #define IS_ETH_MAC_IT(IT) ((((IT) &amp; (uint32_t)0xFFFFFDF7) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \ ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \ ((IT) == ETH_MAC_IT_PMT)) /** * @} */ /** @defgroup ETH_MAC_addresses * @{ */ #define ETH_MAC_Address0 ((uint32_t)0x00000000) #define ETH_MAC_Address1 ((uint32_t)0x00000008) #define ETH_MAC_Address2 ((uint32_t)0x00000010) #define ETH_MAC_Address3 ((uint32_t)0x00000018) #define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \ ((ADDRESS) == ETH_MAC_Address1) || \ ((ADDRESS) == ETH_MAC_Address2) || \ ((ADDRESS) == ETH_MAC_Address3)) #define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \ ((ADDRESS) == ETH_MAC_Address2) || \ ((ADDRESS) == ETH_MAC_Address3)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames * @{ */ #define ETH_MAC_AddressFilter_SA ((uint32_t)0x00000000) #define ETH_MAC_AddressFilter_DA ((uint32_t)0x00000008) #define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \ ((FILTER) == ETH_MAC_AddressFilter_DA)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_Mask_bytes * @{ */ #define ETH_MAC_AddressMask_Byte6 ((uint32_t)0x20000000) /*!&lt; Mask MAC Address high reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte5 ((uint32_t)0x10000000) /*!&lt; Mask MAC Address high reg bits [7:0] */ #define ETH_MAC_AddressMask_Byte4 ((uint32_t)0x08000000) /*!&lt; Mask MAC Address low reg bits [31:24] */ #define ETH_MAC_AddressMask_Byte3 ((uint32_t)0x04000000) /*!&lt; Mask MAC Address low reg bits [23:16] */ #define ETH_MAC_AddressMask_Byte2 ((uint32_t)0x02000000) /*!&lt; Mask MAC Address low reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte1 ((uint32_t)0x01000000) /*!&lt; Mask MAC Address low reg bits [70] */ #define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \ ((MASK) == ETH_MAC_AddressMask_Byte5) || \ ((MASK) == ETH_MAC_AddressMask_Byte4) || \ ((MASK) == ETH_MAC_AddressMask_Byte3) || \ ((MASK) == ETH_MAC_AddressMask_Byte2) || \ ((MASK) == ETH_MAC_AddressMask_Byte1)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA Desciptors defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_flags * @{ */ #define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \ ((FLAG) == ETH_DMATxDesc_IC) || \ ((FLAG) == ETH_DMATxDesc_LS) || \ ((FLAG) == ETH_DMATxDesc_FS) || \ ((FLAG) == ETH_DMATxDesc_DC) || \ ((FLAG) == ETH_DMATxDesc_DP) || \ ((FLAG) == ETH_DMATxDesc_TTSE) || \ ((FLAG) == ETH_DMATxDesc_TER) || \ ((FLAG) == ETH_DMATxDesc_TCH) || \ ((FLAG) == ETH_DMATxDesc_TTSS) || \ ((FLAG) == ETH_DMATxDesc_IHE) || \ ((FLAG) == ETH_DMATxDesc_ES) || \ ((FLAG) == ETH_DMATxDesc_JT) || \ ((FLAG) == ETH_DMATxDesc_FF) || \ ((FLAG) == ETH_DMATxDesc_PCE) || \ ((FLAG) == ETH_DMATxDesc_LCA) || \ ((FLAG) == ETH_DMATxDesc_NC) || \ ((FLAG) == ETH_DMATxDesc_LCO) || \ ((FLAG) == ETH_DMATxDesc_EC) || \ ((FLAG) == ETH_DMATxDesc_VF) || \ ((FLAG) == ETH_DMATxDesc_CC) || \ ((FLAG) == ETH_DMATxDesc_ED) || \ ((FLAG) == ETH_DMATxDesc_UF) || \ ((FLAG) == ETH_DMATxDesc_DB)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_segment * @{ */ #define ETH_DMATxDesc_LastSegment ((uint32_t)0x40000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FirstSegment ((uint32_t)0x20000000) /*!&lt; First Segment */ #define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \ ((SEGMENT) == ETH_DMATxDesc_FirstSegment)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control * @{ */ #define ETH_DMATxDesc_ChecksumByPass ((uint32_t)0x00000000) /*!&lt; Checksum engine bypass */ #define ETH_DMATxDesc_ChecksumIPV4Header ((uint32_t)0x00400000) /*!&lt; IPv4 header checksum insertion */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPFull ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP checksum fully in hardware including pseudo header */ #define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull)) /** * @brief ETH DMA Tx Desciptor buffer size */ #define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) &lt;= 0x1FFF) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_flags * @{ */ #define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \ ((FLAG) == ETH_DMARxDesc_AFM) || \ ((FLAG) == ETH_DMARxDesc_ES) || \ ((FLAG) == ETH_DMARxDesc_DE) || \ ((FLAG) == ETH_DMARxDesc_SAF) || \ ((FLAG) == ETH_DMARxDesc_LE) || \ ((FLAG) == ETH_DMARxDesc_OE) || \ ((FLAG) == ETH_DMARxDesc_VLAN) || \ ((FLAG) == ETH_DMARxDesc_FS) || \ ((FLAG) == ETH_DMARxDesc_LS) || \ ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \ ((FLAG) == ETH_DMARxDesc_LC) || \ ((FLAG) == ETH_DMARxDesc_FT) || \ ((FLAG) == ETH_DMARxDesc_RWT) || \ ((FLAG) == ETH_DMARxDesc_RE) || \ ((FLAG) == ETH_DMARxDesc_DBE) || \ ((FLAG) == ETH_DMARxDesc_CE) || \ ((FLAG) == ETH_DMARxDesc_MAMPCE)) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_buffers_ * @{ */ #define ETH_DMARxDesc_Buffer1 ((uint32_t)0x00000000) /*!&lt; DMA Rx Desc Buffer1 */ #define ETH_DMARxDesc_Buffer2 ((uint32_t)0x00000001) /*!&lt; DMA Rx Desc Buffer2 */ #define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \ ((BUFFER) == ETH_DMARxDesc_Buffer2)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame * @{ */ #define ETH_DropTCPIPChecksumErrorFrame_Enable ((uint32_t)0x00000000) #define ETH_DropTCPIPChecksumErrorFrame_Disable ((uint32_t)0x04000000) #define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \ ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable)) /** * @} */ /** @defgroup ETH_Receive_Store_Forward * @{ */ #define ETH_ReceiveStoreForward_Enable ((uint32_t)0x02000000) #define ETH_ReceiveStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \ ((CMD) == ETH_ReceiveStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Flush_Received_Frame * @{ */ #define ETH_FlushReceivedFrame_Enable ((uint32_t)0x00000000) #define ETH_FlushReceivedFrame_Disable ((uint32_t)0x01000000) #define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \ ((CMD) == ETH_FlushReceivedFrame_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Store_Forward * @{ */ #define ETH_TransmitStoreForward_Enable ((uint32_t)0x00200000) #define ETH_TransmitStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \ ((CMD) == ETH_TransmitStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Threshold_Control * @{ */ #define ETH_TransmitThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Transmit FIFO is 64 Bytes */ #define ETH_TransmitThresholdControl_128Bytes ((uint32_t)0x00004000) /*!&lt; threshold level of the MTL Transmit FIFO is 128 Bytes */ #define ETH_TransmitThresholdControl_192Bytes ((uint32_t)0x00008000) /*!&lt; threshold level of the MTL Transmit FIFO is 192 Bytes */ #define ETH_TransmitThresholdControl_256Bytes ((uint32_t)0x0000C000) /*!&lt; threshold level of the MTL Transmit FIFO is 256 Bytes */ #define ETH_TransmitThresholdControl_40Bytes ((uint32_t)0x00010000) /*!&lt; threshold level of the MTL Transmit FIFO is 40 Bytes */ #define ETH_TransmitThresholdControl_32Bytes ((uint32_t)0x00014000) /*!&lt; threshold level of the MTL Transmit FIFO is 32 Bytes */ #define ETH_TransmitThresholdControl_24Bytes ((uint32_t)0x00018000) /*!&lt; threshold level of the MTL Transmit FIFO is 24 Bytes */ #define ETH_TransmitThresholdControl_16Bytes ((uint32_t)0x0001C000) /*!&lt; threshold level of the MTL Transmit FIFO is 16 Bytes */ #define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes)) /** * @} */ /** @defgroup ETH_Forward_Error_Frames * @{ */ #define ETH_ForwardErrorFrames_Enable ((uint32_t)0x00000080) #define ETH_ForwardErrorFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \ ((CMD) == ETH_ForwardErrorFrames_Disable)) /** * @} */ /** @defgroup ETH_Forward_Undersized_Good_Frames * @{ */ #define ETH_ForwardUndersizedGoodFrames_Enable ((uint32_t)0x00000040) #define ETH_ForwardUndersizedGoodFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \ ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable)) /** * @} */ /** @defgroup ETH_Receive_Threshold_Control * @{ */ #define ETH_ReceiveThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Receive FIFO is 64 Bytes */ #define ETH_ReceiveThresholdControl_32Bytes ((uint32_t)0x00000008) /*!&lt; threshold level of the MTL Receive FIFO is 32 Bytes */ #define ETH_ReceiveThresholdControl_96Bytes ((uint32_t)0x00000010) /*!&lt; threshold level of the MTL Receive FIFO is 96 Bytes */ #define ETH_ReceiveThresholdControl_128Bytes ((uint32_t)0x00000018) /*!&lt; threshold level of the MTL Receive FIFO is 128 Bytes */ #define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes)) /** * @} */ /** @defgroup ETH_Second_Frame_Operate * @{ */ #define ETH_SecondFrameOperate_Enable ((uint32_t)0x00000004) #define ETH_SecondFrameOperate_Disable ((uint32_t)0x00000000) #define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \ ((CMD) == ETH_SecondFrameOperate_Disable)) /** * @} */ /** @defgroup ETH_Address_Aligned_Beats * @{ */ #define ETH_AddressAlignedBeats_Enable ((uint32_t)0x02000000) #define ETH_AddressAlignedBeats_Disable ((uint32_t)0x00000000) #define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \ ((CMD) == ETH_AddressAlignedBeats_Disable)) /** * @} */ /** @defgroup ETH_Fixed_Burst * @{ */ #define ETH_FixedBurst_Enable ((uint32_t)0x00010000) #define ETH_FixedBurst_Disable ((uint32_t)0x00000000) #define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \ ((CMD) == ETH_FixedBurst_Disable)) /** * @} */ /** @defgroup ETH_Rx_DMA_Burst_Length * @{ */ #define ETH_RxDMABurstLength_1Beat ((uint32_t)0x00020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 1 */ #define ETH_RxDMABurstLength_2Beat ((uint32_t)0x00040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 2 */ #define ETH_RxDMABurstLength_4Beat ((uint32_t)0x00080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_8Beat ((uint32_t)0x00100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_16Beat ((uint32_t)0x00200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_32Beat ((uint32_t)0x00400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 64 */ #define ETH_RxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 128 */ #define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat)) /** * @} */ /** @defgroup ETH_Tx_DMA_Burst_Length * @{ */ #define ETH_TxDMABurstLength_1Beat ((uint32_t)0x00000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */ #define ETH_TxDMABurstLength_2Beat ((uint32_t)0x00000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */ #define ETH_TxDMABurstLength_4Beat ((uint32_t)0x00000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_8Beat ((uint32_t)0x00000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_16Beat ((uint32_t)0x00001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_32Beat ((uint32_t)0x00002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */ #define ETH_TxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */ #define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat)) /** * @brief ETH DMA Desciptor SkipLength */ #define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) &lt;= 0x1F) /** * @} */ /** @defgroup ETH_DMA_Arbitration * @{ */ #define ETH_DMAArbitration_RoundRobin_RxTx_1_1 ((uint32_t)0x00000000) #define ETH_DMAArbitration_RoundRobin_RxTx_2_1 ((uint32_t)0x00004000) #define ETH_DMAArbitration_RoundRobin_RxTx_3_1 ((uint32_t)0x00008000) #define ETH_DMAArbitration_RoundRobin_RxTx_4_1 ((uint32_t)0x0000C000) #define ETH_DMAArbitration_RxPriorTx ((uint32_t)0x00000002) #define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \ ((RATIO) == ETH_DMAArbitration_RxPriorTx)) /** * @} */ /** @defgroup ETH_DMA_Flags * @{ */ #define ETH_DMA_FLAG_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_FLAG_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_FLAG_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_FLAG_DataTransferError ((uint32_t)0x00800000) /*!&lt; Error bits 0-Rx DMA, 1-Tx DMA */ #define ETH_DMA_FLAG_ReadWriteError ((uint32_t)0x01000000) /*!&lt; Error bits 0-write trnsf, 1-read transfr */ #define ETH_DMA_FLAG_AccessError ((uint32_t)0x02000000) /*!&lt; Error bits 0-data buffer, 1-desc. access */ #define ETH_DMA_FLAG_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary flag */ #define ETH_DMA_FLAG_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary flag */ #define ETH_DMA_FLAG_ER ((uint32_t)0x00004000) /*!&lt; Early receive flag */ #define ETH_DMA_FLAG_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error flag */ #define ETH_DMA_FLAG_ET ((uint32_t)0x00000400) /*!&lt; Early transmit flag */ #define ETH_DMA_FLAG_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout flag */ #define ETH_DMA_FLAG_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped flag */ #define ETH_DMA_FLAG_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable flag */ #define ETH_DMA_FLAG_R ((uint32_t)0x00000040) /*!&lt; Receive flag */ #define ETH_DMA_FLAG_TU ((uint32_t)0x00000020) /*!&lt; Underflow flag */ #define ETH_DMA_FLAG_RO ((uint32_t)0x00000010) /*!&lt; Overflow flag */ #define ETH_DMA_FLAG_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout flag */ #define ETH_DMA_FLAG_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable flag */ #define ETH_DMA_FLAG_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped flag */ #define ETH_DMA_FLAG_T ((uint32_t)0x00000001) /*!&lt; Transmit flag */ #define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((FLAG) != 0x00)) #define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \ ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \ ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \ ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \ ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \ ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \ ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \ ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \ ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \ ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \ ((FLAG) == ETH_DMA_FLAG_T)) /** * @} */ /** @defgroup ETH_DMA_Interrupts * @{ */ #define ETH_DMA_IT_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_IT_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_IT_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_IT_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary */ #define ETH_DMA_IT_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary */ #define ETH_DMA_IT_ER ((uint32_t)0x00004000) /*!&lt; Early receive interrupt */ #define ETH_DMA_IT_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error interrupt */ #define ETH_DMA_IT_ET ((uint32_t)0x00000400) /*!&lt; Early transmit interrupt */ #define ETH_DMA_IT_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout interrupt */ #define ETH_DMA_IT_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped interrupt */ #define ETH_DMA_IT_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable interrupt */ #define ETH_DMA_IT_R ((uint32_t)0x00000040) /*!&lt; Receive interrupt */ #define ETH_DMA_IT_TU ((uint32_t)0x00000020) /*!&lt; Underflow interrupt */ #define ETH_DMA_IT_RO ((uint32_t)0x00000010) /*!&lt; Overflow interrupt */ #define ETH_DMA_IT_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout interrupt */ #define ETH_DMA_IT_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable interrupt */ #define ETH_DMA_IT_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped interrupt */ #define ETH_DMA_IT_T ((uint32_t)0x00000001) /*!&lt; Transmit interrupt */ #define IS_ETH_DMA_IT(IT) ((((IT) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \ ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \ ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \ ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \ ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \ ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \ ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \ ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \ ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T)) /** * @} */ /** @defgroup ETH_DMA_transmit_process_state_ * @{ */ #define ETH_DMA_TransmitProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Tx Command issued */ #define ETH_DMA_TransmitProcess_Fetching ((uint32_t)0x00100000) /*!&lt; Running - fetching the Tx descriptor */ #define ETH_DMA_TransmitProcess_Waiting ((uint32_t)0x00200000) /*!&lt; Running - waiting for status */ #define ETH_DMA_TransmitProcess_Reading ((uint32_t)0x00300000) /*!&lt; Running - reading the data from host memory */ #define ETH_DMA_TransmitProcess_Suspended ((uint32_t)0x00600000) /*!&lt; Suspended - Tx Desciptor unavailabe */ #define ETH_DMA_TransmitProcess_Closing ((uint32_t)0x00700000) /*!&lt; Running - closing Rx descriptor */ /** * @} */ /** @defgroup ETH_DMA_receive_process_state_ * @{ */ #define ETH_DMA_ReceiveProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Rx Command issued */ #define ETH_DMA_ReceiveProcess_Fetching ((uint32_t)0x00020000) /*!&lt; Running - fetching the Rx descriptor */ #define ETH_DMA_ReceiveProcess_Waiting ((uint32_t)0x00060000) /*!&lt; Running - waiting for packet */ #define ETH_DMA_ReceiveProcess_Suspended ((uint32_t)0x00080000) /*!&lt; Suspended - Rx Desciptor unavailable */ #define ETH_DMA_ReceiveProcess_Closing ((uint32_t)0x000A0000) /*!&lt; Running - closing descriptor */ #define ETH_DMA_ReceiveProcess_Queuing ((uint32_t)0x000E0000) /*!&lt; Running - queuing the recieve frame into host memory */ /** * @} */ /** @defgroup ETH_DMA_overflow_ * @{ */ #define ETH_DMA_Overflow_RxFIFOCounter ((uint32_t)0x10000000) /*!&lt; Overflow bit for FIFO overflow counter */ #define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)0x00010000) /*!&lt; Overflow bit for missed frame counter */ #define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \ ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PMT defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PMT_Flags * @{ */ #define ETH_PMT_FLAG_WUFFRPR ((uint32_t)0x80000000) /*!&lt; Wake-Up Frame Filter Register Poniter Reset */ #define ETH_PMT_FLAG_WUFR ((uint32_t)0x00000040) /*!&lt; Wake-Up Frame Received */ #define ETH_PMT_FLAG_MPR ((uint32_t)0x00000020) /*!&lt; Magic Packet Received */ #define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \ ((FLAG) == ETH_PMT_FLAG_MPR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet MMC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_MMC_Tx_Interrupts * @{ */ #define ETH_MMC_IT_TGF ((uint32_t)0x00200000) /*!&lt; When Tx good frame counter reaches half the maximum value */ #define ETH_MMC_IT_TGFMSC ((uint32_t)0x00008000) /*!&lt; When Tx good multi col counter reaches half the maximum value */ #define ETH_MMC_IT_TGFSC ((uint32_t)0x00004000) /*!&lt; When Tx good single col counter reaches half the maximum value */ /** * @} */ /** @defgroup ETH_MMC_Rx_Interrupts * @{ */ #define ETH_MMC_IT_RGUF ((uint32_t)0x10020000) /*!&lt; When Rx good unicast frames counter reaches half the maximum value */ #define ETH_MMC_IT_RFAE ((uint32_t)0x10000040) /*!&lt; When Rx alignment error counter reaches half the maximum value */ #define ETH_MMC_IT_RFCE ((uint32_t)0x10000020) /*!&lt; When Rx crc error counter reaches half the maximum value */ #define IS_ETH_MMC_IT(IT) (((((IT) &amp; (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) &amp; (uint32_t)0xEFFDFF9F) == 0x00)) &amp;&amp; \ ((IT) != 0x00)) #define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \ ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \ ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE)) /** * @} */ /** @defgroup ETH_MMC_Registers * @{ */ #define ETH_MMCCR ((uint32_t)0x00000100) /*!&lt; MMC CR register */ #define ETH_MMCRIR ((uint32_t)0x00000104) /*!&lt; MMC RIR register */ #define ETH_MMCTIR ((uint32_t)0x00000108) /*!&lt; MMC TIR register */ #define ETH_MMCRIMR ((uint32_t)0x0000010C) /*!&lt; MMC RIMR register */ #define ETH_MMCTIMR ((uint32_t)0x00000110) /*!&lt; MMC TIMR register */ #define ETH_MMCTGFSCCR ((uint32_t)0x0000014C) /*!&lt; MMC TGFSCCR register */ #define ETH_MMCTGFMSCCR ((uint32_t)0x00000150) /*!&lt; MMC TGFMSCCR register */ #define ETH_MMCTGFCR ((uint32_t)0x00000168) /*!&lt; MMC TGFCR register */ #define ETH_MMCRFCECR ((uint32_t)0x00000194) /*!&lt; MMC RFCECR register */ #define ETH_MMCRFAECR ((uint32_t)0x00000198) /*!&lt; MMC RFAECR register */ #define ETH_MMCRGUFCR ((uint32_t)0x000001C4) /*!&lt; MMC RGUFCR register */ /** * @brief ETH MMC registers */ #define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR) || ((REG) == ETH_MMCRIR) || \ ((REG) == ETH_MMCTIR) || ((REG) == ETH_MMCRIMR) || \ ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \ ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \ ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \ ((REG) == ETH_MMCRGUFCR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PTP defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PTP_time_update_method * @{ */ #define ETH_PTP_FineUpdate ((uint32_t)0x00000001) /*!&lt; Fine Update method */ #define ETH_PTP_CoarseUpdate ((uint32_t)0x00000000) /*!&lt; Coarse Update method */ #define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \ ((UPDATE) == ETH_PTP_CoarseUpdate)) /** * @} */ /** @defgroup ETH_PTP_Flags * @{ */ #define ETH_PTP_FLAG_TSARU ((uint32_t)0x00000020) /*!&lt; Addend Register Update */ #define ETH_PTP_FLAG_TSITE ((uint32_t)0x00000010) /*!&lt; Time Stamp Interrupt Trigger */ #define ETH_PTP_FLAG_TSSTU ((uint32_t)0x00000008) /*!&lt; Time Stamp Update */ #define ETH_PTP_FLAG_TSSTI ((uint32_t)0x00000004) /*!&lt; Time Stamp Initialize */ #define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \ ((FLAG) == ETH_PTP_FLAG_TSITE) || \ ((FLAG) == ETH_PTP_FLAG_TSSTU) || \ ((FLAG) == ETH_PTP_FLAG_TSSTI)) /** * @brief ETH PTP subsecond increment */ #define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) &lt;= 0xFF) /** * @} */ /** @defgroup ETH_PTP_time_sign * @{ */ #define ETH_PTP_PositiveTime ((uint32_t)0x00000000) /*!&lt; Positive time value */ #define ETH_PTP_NegativeTime ((uint32_t)0x80000000) /*!&lt; Negative time value */ #define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \ ((SIGN) == ETH_PTP_NegativeTime)) /** * @brief ETH PTP time stamp low update */ #define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) &lt;= 0x7FFFFFFF) /** * @brief ETH PTP registers */ #define ETH_PTPTSCR ((uint32_t)0x00000700) /*!&lt; PTP TSCR register */ #define ETH_PTPSSIR ((uint32_t)0x00000704) /*!&lt; PTP SSIR register */ #define ETH_PTPTSHR ((uint32_t)0x00000708) /*!&lt; PTP TSHR register */ #define ETH_PTPTSLR ((uint32_t)0x0000070C) /*!&lt; PTP TSLR register */ #define ETH_PTPTSHUR ((uint32_t)0x00000710) /*!&lt; PTP TSHUR register */ #define ETH_PTPTSLUR ((uint32_t)0x00000714) /*!&lt; PTP TSLUR register */ #define ETH_PTPTSAR ((uint32_t)0x00000718) /*!&lt; PTP TSAR register */ #define ETH_PTPTTHR ((uint32_t)0x0000071C) /*!&lt; PTP TTHR register */ #define ETH_PTPTTLR ((uint32_t)0x00000720) /* PTP TTLR register */ #define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \ ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \ ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \ ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \ ((REG) == ETH_PTPTTLR)) /** * @} */ /** * @} */ /** @defgroup ETH_Exported_Macros * @{ */ /** * @} */ /** @defgroup ETH_Exported_Functions * @{ */ void ETH_DeInit(void); uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct); void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct); void ETH_SoftwareReset(void); FlagStatus ETH_GetSoftwareResetStatus(void); void ETH_Start(void); uint32_t ETH_HandleTxPkt(u8 *ppkt, u16 FrameLength); uint32_t ETH_HandleRxPkt(u8 *ppkt); uint32_t ETH_GetRxPktSize(void); void ETH_DropRxPkt(void); /** * @brief PHY */ u16 ETH_ReadPHYRegister(u16 PHYAddress, u16 PHYReg); uint32_t ETH_WritePHYRegister(u16 PHYAddress, u16 PHYReg, u16 PHYValue); uint32_t ETH_PHYLoopBackCmd(u16 PHYAddress, FunctionalState NewState); /** * @brief MAC */ void ETH_MACTransmissionCmd(FunctionalState NewState); void ETH_MACReceptionCmd(FunctionalState NewState); FlagStatus ETH_GetFlowControlBusyStatus(void); void ETH_InitiatePauseControlFrame(void); void ETH_BackPressureActivationCmd(FunctionalState NewState); FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG); ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT); void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState); void ETH_MACAddressConfig(uint32_t MacAddr, u8 *Addr); void ETH_GetMACAddress(uint32_t MacAddr, u8 *Addr); void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState); void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter); void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte); /** * @brief DMA Tx/Rx descriptors */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff, uint32_t TxBuffCount); void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff1, u8 *TxBuff2, uint32_t TxBuffCount); FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag); uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc); void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc); void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment); void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum); void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2); void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff1, u8 *RxBuff2, uint32_t RxBuffCount); FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag); void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc); uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc); void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer); /** * @brief DMA */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG); void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG); ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT); void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT); uint32_t ETH_GetTransmitProcessState(void); uint32_t ETH_GetReceiveProcessState(void); void ETH_FlushTransmitFIFO(void); FlagStatus ETH_GetFlushTransmitFIFOStatus(void); void ETH_DMATransmissionCmd(FunctionalState NewState); void ETH_DMAReceptionCmd(FunctionalState NewState); void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState); FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow); uint32_t ETH_GetRxOverflowMissedFrameCounter(void); uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void); uint32_t ETH_GetCurrentTxDescStartAddress(void); uint32_t ETH_GetCurrentRxDescStartAddress(void); uint32_t ETH_GetCurrentTxBufferAddress(void); uint32_t ETH_GetCurrentRxBufferAddress(void); void ETH_ResumeDMATransmission(void); void ETH_ResumeDMAReception(void); /** * @brief PMT */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void); void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer); void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState); FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG); void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState); void ETH_MagicPacketDetectionCmd(FunctionalState NewState); void ETH_PowerDownCmd(FunctionalState NewState); /** * @brief MMC */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState); void ETH_MMCResetOnReadCmd(FunctionalState NewState); void ETH_MMCCounterRolloverCmd(FunctionalState NewState); void ETH_MMCCountersReset(void); void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState); ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT); uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg); /** * @brief PTP */ uint32_t ETH_HandlePTPTxPkt(u8 *ppkt, u16 FrameLength, uint32_t *PTPTxTab); uint32_t ETH_HandlePTPRxPkt(u8 *ppkt, uint32_t *PTPRxTab); void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, u8* TxBuff, uint32_t TxBuffCount); void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_EnablePTPTimeStampAddend(void); void ETH_EnablePTPTimeStampInterruptTrigger(void); void ETH_EnablePTPTimeStampUpdate(void); void ETH_InitializePTPTimeStamp(void); void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod); void ETH_PTPTimeStampCmd(FunctionalState NewState); FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG); void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue); void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue); void ETH_SetPTPTimeStampAddend(uint32_t Value); void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue); uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg); #ifdef __cplusplus } #endif void FreeRTOS_Hardware_STMS32_ETH_Init(void); #endif /* __STM32_ETH_H */ /** * @} */ /** * @} */ /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/ stm32_eth.c /** ****************************************************************************** * @file stm32_eth.c * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file provides all the ETH firmware functions. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32_eth.h&quot; #include &quot;stm32f10x_rcc.h&quot; #define DP83848_PHY_ADDRESS 0x01 /* Relative to STM322xG-EVAL Board */ /* STM32F107 ETH dirver options */ #define CHECKSUM_BY_HARDWARE 1 /* 0: disable. 1: use hardware checksum. */ #define RMII_MODE 0 /* 0: MII MODE, 1: RMII MODE. */ #define STM32_ETH_IO_REMAP 1 /* 0: default, 1: remap RXD to PDx. */ #define USE_MCO 1 /* 0: disable, 1: PA8(MCO) out 25Mhz(MII) or 50Mhz(RMII). */ /** @addtogroup STM32_ETH_Driver * @brief ETH driver modules * @{ */ /** @defgroup ETH_Private_TypesDefinitions * @{ */ /** * @} */ /** @defgroup ETH_Private_Defines * @{ */ /* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */ ETH_DMADESCTypeDef *DMATxDescToSet; ETH_DMADESCTypeDef *DMARxDescToGet; ETH_DMADESCTypeDef *DMAPTPTxDescToSet; ETH_DMADESCTypeDef *DMAPTPRxDescToGet; /* ETHERNET MAC address offsets */ #define ETH_MAC_ADDR_HBASE (ETH_MAC_BASE + 0x40) /* ETHERNET MAC address high offset */ #define ETH_MAC_ADDR_LBASE (ETH_MAC_BASE + 0x44) /* ETHERNET MAC address low offset */ /* ETHERNET MACMIIAR register Mask */ #define MACMIIAR_CR_MASK ((uint32_t)0xFFFFFFE3) /* ETHERNET MACCR register Mask */ #define MACCR_CLEAR_MASK ((uint32_t)0xFF20810F) /* ETHERNET MACFCR register Mask */ #define MACFCR_CLEAR_MASK ((uint32_t)0x0000FF41) /* ETHERNET DMAOMR register Mask */ #define DMAOMR_CLEAR_MASK ((uint32_t)0xF8DE3F23) /* ETHERNET Remote Wake-up frame register length */ #define ETH_WAKEUP_REGISTER_LENGTH 8 /* ETHERNET Missed frames counter Shift */ #define ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT 17 /* ETHERNET DMA Tx descriptors Collision Count Shift */ #define ETH_DMATXDESC_COLLISION_COUNTSHIFT 3 /* ETHERNET DMA Tx descriptors Buffer2 Size Shift */ #define ETH_DMATXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET DMA Rx descriptors Frame Length Shift */ #define ETH_DMARXDESC_FRAME_LENGTHSHIFT 16 /* ETHERNET DMA Rx descriptors Buffer2 Size Shift */ #define ETH_DMARXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET errors */ #define ETH_ERROR ((uint32_t)0) #define ETH_SUCCESS ((uint32_t)1) /** * @} */ /** @defgroup ETH_Private_Macros * @{ */ /** * @} */ /** @defgroup ETH_Private_Variables * @{ */ /** * @} */ /** @defgroup ETH_Private_FunctionPrototypes * @{ */ /** * @} */ /** @defgroup ETH_Private_Functions * @{ */ /** * @brief Deinitializes the ETHERNET peripheral registers to their default reset values. * @param None * @retval None */ void ETH_DeInit(void) { RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE); RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE); } /** * @brief Initializes the ETHERNET peripheral according to the specified * parameters in the ETH_InitStruct . * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains * the configuration information for the specified ETHERNET peripheral. * @retval ETH_ERROR: Ethernet initialization failed * ETH_SUCCESS: Ethernet successfully initialized */ uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct) { uint32_t tmpreg = 0; __IO uint32_t i = 0; RCC_ClocksTypeDef rcc_clocks; uint32_t hclk = 60000000; __IO uint32_t timeout = 0; /* Check the parameters */ /* MAC --------------------------*/ assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct-&gt;ETH_AutoNegotiation)); assert_param(IS_ETH_WATCHDOG(ETH_InitStruct-&gt;ETH_Watchdog)); assert_param(IS_ETH_JABBER(ETH_InitStruct-&gt;ETH_Jabber)); assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct-&gt;ETH_InterFrameGap)); assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct-&gt;ETH_CarrierSense)); assert_param(IS_ETH_SPEED(ETH_InitStruct-&gt;ETH_Speed)); assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct-&gt;ETH_ReceiveOwn)); assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct-&gt;ETH_LoopbackMode)); assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct-&gt;ETH_Mode)); assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct-&gt;ETH_ChecksumOffload)); assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct-&gt;ETH_RetryTransmission)); assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip)); assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct-&gt;ETH_BackOffLimit)); assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct-&gt;ETH_DeferralCheck)); assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct-&gt;ETH_ReceiveAll)); assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct-&gt;ETH_SourceAddrFilter)); assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct-&gt;ETH_PassControlFrames)); assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct-&gt;ETH_BroadcastFramesReception)); assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct-&gt;ETH_DestinationAddrFilter)); assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct-&gt;ETH_PromiscuousMode)); assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_MulticastFramesFilter)); assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_UnicastFramesFilter)); assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct-&gt;ETH_PauseTime)); assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct-&gt;ETH_ZeroQuantaPause)); assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct-&gt;ETH_PauseLowThreshold)); assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect)); assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct-&gt;ETH_ReceiveFlowControl)); assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct-&gt;ETH_TransmitFlowControl)); assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct-&gt;ETH_VLANTagComparison)); assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct-&gt;ETH_VLANTagIdentifier)); /* DMA --------------------------*/ assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame)); assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct-&gt;ETH_ReceiveStoreForward)); assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct-&gt;ETH_FlushReceivedFrame)); assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct-&gt;ETH_TransmitStoreForward)); assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_TransmitThresholdControl)); assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct-&gt;ETH_ForwardErrorFrames)); assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames)); assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_ReceiveThresholdControl)); assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct-&gt;ETH_SecondFrameOperate)); assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct-&gt;ETH_AddressAlignedBeats)); assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct-&gt;ETH_FixedBurst)); assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_RxDMABurstLength)); assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_TxDMABurstLength)); assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct-&gt;ETH_DescriptorSkipLength)); assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct-&gt;ETH_DMAArbitration)); /*-------------------------------- MAC Config ------------------------------*/ /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/ /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Clear CSR Clock Range CR[2:0] bits */ tmpreg &amp;= MACMIIAR_CR_MASK; /* Get hclk frequency value */ RCC_GetClocksFreq(&amp;rcc_clocks); hclk = rcc_clocks.HCLK_Frequency; /* Set CR bits depending on hclk value */ if((hclk &gt;= 20000000)&amp;&amp;(hclk &lt; 35000000)) { /* CSR Clock Range between 20-35 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16; } else if((hclk &gt;= 35000000)&amp;&amp;(hclk &lt; 60000000)) { /* CSR Clock Range between 35-60 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26; } else /* ((hclk &gt;= 60000000)&amp;&amp;(hclk &lt;= 72000000)) */ { /* CSR Clock Range between 60-72 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42; } /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */ ETH-&gt;MACMIIAR = (uint32_t)tmpreg; /*------------------------ ETHERNET MACCR Configuration --------------------*/ /* Get the ETHERNET MACCR value */ tmpreg = ETH-&gt;MACCR; /* Clear WD, PCE, PS, TE and RE bits */ tmpreg &amp;= MACCR_CLEAR_MASK; /* Set the WD bit according to ETH_Watchdog value */ /* Set the JD: bit according to ETH_Jabber value */ /* Set the IFG bit according to ETH_InterFrameGap value */ /* Set the DCRS bit according to ETH_CarrierSense value */ /* Set the FES bit according to ETH_Speed value */ /* Set the DO bit according to ETH_ReceiveOwn value */ /* Set the LM bit according to ETH_LoopbackMode value */ /* Set the DM bit according to ETH_Mode value */ /* Set the IPC bit according to ETH_ChecksumOffload value */ /* Set the DR bit according to ETH_RetryTransmission value */ /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ /* Set the BL bit according to ETH_BackOffLimit value */ /* Set the DC bit according to ETH_DeferralCheck value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_Watchdog | ETH_InitStruct-&gt;ETH_Jabber | ETH_InitStruct-&gt;ETH_InterFrameGap | ETH_InitStruct-&gt;ETH_CarrierSense | ETH_InitStruct-&gt;ETH_Speed | ETH_InitStruct-&gt;ETH_ReceiveOwn | ETH_InitStruct-&gt;ETH_LoopbackMode | ETH_InitStruct-&gt;ETH_Mode | ETH_InitStruct-&gt;ETH_ChecksumOffload | ETH_InitStruct-&gt;ETH_RetryTransmission | ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip | ETH_InitStruct-&gt;ETH_BackOffLimit | ETH_InitStruct-&gt;ETH_DeferralCheck); /* Write to ETHERNET MACCR */ ETH-&gt;MACCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACFFR Configuration --------------------*/ /* Set the RA bit according to ETH_ReceiveAll value */ /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */ /* Set the PCF bit according to ETH_PassControlFrames value */ /* Set the DBF bit according to ETH_BroadcastFramesReception value */ /* Set the DAIF bit according to ETH_DestinationAddrFilter value */ /* Set the PR bit according to ETH_PromiscuousMode value */ /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */ /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */ /* Write to ETHERNET MACFFR */ ETH-&gt;MACFFR = (uint32_t)(ETH_InitStruct-&gt;ETH_ReceiveAll | ETH_InitStruct-&gt;ETH_SourceAddrFilter | ETH_InitStruct-&gt;ETH_PassControlFrames | ETH_InitStruct-&gt;ETH_BroadcastFramesReception | ETH_InitStruct-&gt;ETH_DestinationAddrFilter | ETH_InitStruct-&gt;ETH_PromiscuousMode | ETH_InitStruct-&gt;ETH_MulticastFramesFilter | ETH_InitStruct-&gt;ETH_UnicastFramesFilter); /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/ /* Write to ETHERNET MACHTHR */ ETH-&gt;MACHTHR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableHigh; /* Write to ETHERNET MACHTLR */ ETH-&gt;MACHTLR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableLow; /*----------------------- ETHERNET MACFCR Configuration --------------------*/ /* Get the ETHERNET MACFCR value */ tmpreg = ETH-&gt;MACFCR; /* Clear xx bits */ tmpreg &amp;= MACFCR_CLEAR_MASK; /* Set the PT bit according to ETH_PauseTime value */ /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */ /* Set the PLT bit according to ETH_PauseLowThreshold value */ /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */ /* Set the RFE bit according to ETH_ReceiveFlowControl value */ /* Set the TFE bit according to ETH_TransmitFlowControl value */ tmpreg |= (uint32_t)((ETH_InitStruct-&gt;ETH_PauseTime &lt;&lt; 16) | ETH_InitStruct-&gt;ETH_ZeroQuantaPause | ETH_InitStruct-&gt;ETH_PauseLowThreshold | ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect | ETH_InitStruct-&gt;ETH_ReceiveFlowControl | ETH_InitStruct-&gt;ETH_TransmitFlowControl); /* Write to ETHERNET MACFCR */ ETH-&gt;MACFCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/ /* Set the ETV bit according to ETH_VLANTagComparison value */ /* Set the VL bit according to ETH_VLANTagIdentifier value */ ETH-&gt;MACVLANTR = (uint32_t)(ETH_InitStruct-&gt;ETH_VLANTagComparison | ETH_InitStruct-&gt;ETH_VLANTagIdentifier); /*-------------------------------- DMA Config ------------------------------*/ /*----------------------- ETHERNET DMAOMR Configuration --------------------*/ /* Get the ETHERNET DMAOMR value */ tmpreg = ETH-&gt;DMAOMR; /* Clear xx bits */ tmpreg &amp;= DMAOMR_CLEAR_MASK; /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */ /* Set the RSF bit according to ETH_ReceiveStoreForward value */ /* Set the DFF bit according to ETH_FlushReceivedFrame value */ /* Set the TSF bit according to ETH_TransmitStoreForward value */ /* Set the TTC bit according to ETH_TransmitThresholdControl value */ /* Set the FEF bit according to ETH_ForwardErrorFrames value */ /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */ /* Set the RTC bit according to ETH_ReceiveThresholdControl value */ /* Set the OSF bit according to ETH_SecondFrameOperate value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame | ETH_InitStruct-&gt;ETH_ReceiveStoreForward | ETH_InitStruct-&gt;ETH_FlushReceivedFrame | ETH_InitStruct-&gt;ETH_TransmitStoreForward | ETH_InitStruct-&gt;ETH_TransmitThresholdControl | ETH_InitStruct-&gt;ETH_ForwardErrorFrames | ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames | ETH_InitStruct-&gt;ETH_ReceiveThresholdControl | ETH_InitStruct-&gt;ETH_SecondFrameOperate); /* Write to ETHERNET DMAOMR */ ETH-&gt;DMAOMR = (uint32_t)tmpreg; /*----------------------- ETHERNET DMABMR Configuration --------------------*/ /* Set the AAL bit according to ETH_AddressAlignedBeats value */ /* Set the FB bit according to ETH_FixedBurst value */ /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */ /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */ /* Set the DSL bit according to ETH_DesciptorSkipLength value */ /* Set the PR and DA bits according to ETH_DMAArbitration value */ ETH-&gt;DMABMR = (uint32_t)(ETH_InitStruct-&gt;ETH_AddressAlignedBeats | ETH_InitStruct-&gt;ETH_FixedBurst | ETH_InitStruct-&gt;ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */ ETH_InitStruct-&gt;ETH_TxDMABurstLength | (ETH_InitStruct-&gt;ETH_DescriptorSkipLength &lt;&lt; 2) | ETH_InitStruct-&gt;ETH_DMAArbitration | ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */ /* Return Ethernet configuration success */ return ETH_SUCCESS; } /** * @brief Fills each ETH_InitStruct member with its default value. * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized. * @retval None */ void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct) { /* ETH_InitStruct members default value */ /*------------------------ MAC -----------------------------------*/ ETH_InitStruct-&gt;ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; ETH_InitStruct-&gt;ETH_Watchdog = ETH_Watchdog_Enable; ETH_InitStruct-&gt;ETH_Jabber = ETH_Jabber_Enable; ETH_InitStruct-&gt;ETH_InterFrameGap = ETH_InterFrameGap_96Bit; ETH_InitStruct-&gt;ETH_CarrierSense = ETH_CarrierSense_Enable; ETH_InitStruct-&gt;ETH_Speed = ETH_Speed_10M; ETH_InitStruct-&gt;ETH_ReceiveOwn = ETH_ReceiveOwn_Enable; ETH_InitStruct-&gt;ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStruct-&gt;ETH_Mode = ETH_Mode_HalfDuplex; ETH_InitStruct-&gt;ETH_ChecksumOffload = ETH_ChecksumOffload_Disable; ETH_InitStruct-&gt;ETH_RetryTransmission = ETH_RetryTransmission_Enable; ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStruct-&gt;ETH_BackOffLimit = ETH_BackOffLimit_10; ETH_InitStruct-&gt;ETH_DeferralCheck = ETH_DeferralCheck_Disable; ETH_InitStruct-&gt;ETH_ReceiveAll = ETH_ReceiveAll_Disable; ETH_InitStruct-&gt;ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable; ETH_InitStruct-&gt;ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; ETH_InitStruct-&gt;ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStruct-&gt;ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal; ETH_InitStruct-&gt;ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStruct-&gt;ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_HashTableHigh = 0x0; ETH_InitStruct-&gt;ETH_HashTableLow = 0x0; ETH_InitStruct-&gt;ETH_PauseTime = 0x0; ETH_InitStruct-&gt;ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable; ETH_InitStruct-&gt;ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4; ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable; ETH_InitStruct-&gt;ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable; ETH_InitStruct-&gt;ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable; ETH_InitStruct-&gt;ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit; ETH_InitStruct-&gt;ETH_VLANTagIdentifier = 0x0; /*------------------------ DMA -----------------------------------*/ ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; ETH_InitStruct-&gt;ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStruct-&gt;ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable; ETH_InitStruct-&gt;ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStruct-&gt;ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStruct-&gt;ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable; ETH_InitStruct-&gt;ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStruct-&gt;ETH_FixedBurst = ETH_FixedBurst_Disable; ETH_InitStruct-&gt;ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_DescriptorSkipLength = 0x0; ETH_InitStruct-&gt;ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1; } /** * @brief Enables ENET MAC and DMA reception/transmission * @param None * @retval None */ void ETH_Start(void) { /* Enable transmit state machine of the MAC for transmission on the MII */ ETH_MACTransmissionCmd(ENABLE); /* Flush Transmit FIFO */ ETH_FlushTransmitFIFO(); /* Enable receive state machine of the MAC for reception from the MII */ ETH_MACReceptionCmd(ENABLE); /* Start DMA transmission */ ETH_DMATransmissionCmd(ENABLE); /* Start DMA reception */ ETH_DMAReceptionCmd(ENABLE); } /** * @brief Transmits a packet, from application buffer, pointed by ppkt. * @param ppkt: pointer to the application&#39;s packet buffer to transmit. * @param FrameLength: Tx Packet size. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength) { uint32_t offset = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMATxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt. * @param ppkt: pointer to the application packet receive buffer. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandleRxPkt(uint8_t *ppkt) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @brief Get the size of received the received packet. * @param None * @retval framelength: received packet size */ uint32_t ETH_GetRxPktSize(void) { uint32_t frameLength = 0; if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the size of the packet: including 4 bytes of the CRC */ frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet); } /* Return Frame Length */ return frameLength; } /** * @brief Drop a Received packet (too small packet, etc...) * @param None * @retval None */ void ETH_DropRxPkt(void) { /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read: this will be the first Rx descriptor in this case */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } } /*--------------------------------- PHY ------------------------------------*/ /** * @brief Read a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR: Tranceiver Basic Control Register * @arg PHY_BSR: Tranceiver Basic Status Register * @arg PHY_SR : Tranceiver Status Register * @arg More PHY register could be read depending on the used PHY * @retval ETH_ERROR: in case of timeout * MAC MIIDR register value: Data read from the selected PHY register (correct read ) */ uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII address register value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg &amp;= ~ETH_MACMIIAR_MW; /* Set the read mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_READ_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return (uint16_t)ETH_ERROR; } /* Return data register value */ return (uint16_t)(ETH-&gt;MACMIIDR); } /** * @brief Write to a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR : Tranceiver Control Register * @arg More PHY register could be written depending on the used PHY * @param PHYValue: the value to write * @retval ETH_ERROR: in case of timeout * ETH_SUCCESS: for correct write */ uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII register address value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg |= ETH_MACMIIAR_MW; /* Set the write mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Give the value to the MII data register */ ETH-&gt;MACMIIDR = PHYValue; /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_WRITE_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_WRITE_TO) { return ETH_ERROR; } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Enables or disables the PHY loopBack mode. * @Note: Don&#39;t be confused with ETH_MACLoopBackCmd function which enables internal * loopback at MII level * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: * @param NewState: new state of the PHY loopBack mode. * This parameter can be: ENABLE or DISABLE. * @retval ETH_ERROR: in case of bad PHY configuration * ETH_SUCCESS: for correct PHY configuration */ uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState) { uint16_t tmpreg = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_FUNCTIONAL_STATE(NewState)); /* Get the PHY configuration to update it */ tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); if (NewState != DISABLE) { /* Enable the PHY loopback mode */ tmpreg |= PHY_Loopback; } else { /* Disable the PHY loopback mode: normal mode */ tmpreg &amp;= (uint16_t)(~(uint16_t)PHY_Loopback); } /* Update the PHY control register with the new configuration */ if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET) { return ETH_SUCCESS; } else { /* Return SUCCESS */ return ETH_ERROR; } } /*--------------------------------- MAC ------------------------------------*/ /** * @brief Enables or disables the MAC transmission. * @param NewState: new state of the MAC transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACTransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC transmission */ ETH-&gt;MACCR |= ETH_MACCR_TE; } else { /* Disable the MAC transmission */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_TE; } } /** * @brief Enables or disables the MAC reception. * @param NewState: new state of the MAC reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC reception */ ETH-&gt;MACCR |= ETH_MACCR_RE; } else { /* Disable the MAC reception */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_RE; } } /** * @brief Checks whether the ETHERNET flow control busy bit is set or not. * @param None * @retval The new state of flow control busy status bit (SET or RESET). */ FlagStatus ETH_GetFlowControlBusyStatus(void) { FlagStatus bitstatus = RESET; /* The Flow Control register should not be written to until this bit is cleared */ if ((ETH-&gt;MACFCR &amp; ETH_MACFCR_FCBBPA) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Initiate a Pause Control Frame (Full-duplex only). * @param None * @retval None */ void ETH_InitiatePauseControlFrame(void) { /* When Set In full duplex MAC initiates pause control frame */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } /** * @brief Enables or disables the MAC BackPressure operation activation (Half-duplex only). * @param NewState: new state of the MAC BackPressure operation activation. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_BackPressureActivationCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Activate the MAC BackPressure operation */ /* In Half duplex: during backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } else { /* Desactivate the MAC BackPressure operation */ ETH-&gt;MACFCR &amp;= ~ETH_MACFCR_FCBBPA; } } /** * @brief Checks whether the specified ETHERNET MAC flag is set or not. * @param ETH_MAC_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_MAC_FLAG_TST : Time stamp trigger flag * @arg ETH_MAC_FLAG_MMCT : MMC transmit flag * @arg ETH_MAC_FLAG_MMCR : MMC receive flag * @arg ETH_MAC_FLAG_MMC : MMC flag * @arg ETH_MAC_FLAG_PMT : PMT flag * @retval The new state of ETHERNET MAC flag (SET or RESET). */ FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); if ((ETH-&gt;MACSR &amp; ETH_MAC_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET MAC interrupt has occurred or not. * @param ETH_MAC_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_MMCT : MMC transmit interrupt * @arg ETH_MAC_IT_MMCR : MMC receive interrupt * @arg ETH_MAC_IT_MMC : MMC interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @retval The new state of ETHERNET MAC interrupt (SET or RESET). */ ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); if ((ETH-&gt;MACSR &amp; ETH_MAC_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the specified ETHERNET MAC interrupts. * @param ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @param NewState: new state of the specified ETHERNET MAC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_IT(ETH_MAC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR &amp;= (~(uint32_t)ETH_MAC_IT); } else { /* Disable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR |= ETH_MAC_IT; } } /** * @brief Configures the selected MAC address. * @param MacAddr: The MAC addres to configure. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Calculate the selectecd MAC address high register */ tmpreg = ((uint32_t)Addr[5] &lt;&lt; 8) | (uint32_t)Addr[4]; /* Load the selectecd MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg; /* Calculate the selectecd MAC address low register */ tmpreg = ((uint32_t)Addr[3] &lt;&lt; 24) | ((uint32_t)Addr[2] &lt;&lt; 16) | ((uint32_t)Addr[1] &lt;&lt; 8) | Addr[0]; /* Load the selectecd MAC address low register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg; } /** * @brief Get the selected MAC address. * @param MacAddr: The MAC addres to return. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Get the selectecd MAC address high register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[5] = ((tmpreg &gt;&gt; 8) &amp; (uint8_t)0xFF); Addr[4] = (tmpreg &amp; (uint8_t)0xFF); /* Load the selectecd MAC address low register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[3] = ((tmpreg &gt;&gt; 24) &amp; (uint8_t)0xFF); Addr[2] = ((tmpreg &gt;&gt; 16) &amp; (uint8_t)0xFF); Addr[1] = ((tmpreg &gt;&gt; 8 ) &amp; (uint8_t)0xFF); Addr[0] = (tmpreg &amp; (uint8_t)0xFF); } /** * @brief Enables or disables the Address filter module uses the specified * ETHERNET MAC address for perfect filtering * @param MacAddr: specifies the ETHERNET MAC address to be used for prfect filtering. * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param NewState: new state of the specified ETHERNET MAC address use. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE; } else { /* Disable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_AE); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Filter: specifies the used frame received field for comparaison * This parameter can be one of the following values: * @arg ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the * SA fields of the received frame. * @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the * DA fields of the received frame. * @retval None */ void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter)); if (Filter != ETH_MAC_AddressFilter_DA) { /* The selected ETHERNET MAC address is used to compare with the SA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA; } else { /* The selected ETHERNET MAC address is used to compare with the DA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_SA); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param MaskByte: specifies the used address bytes for comparaison * This parameter can be any combination of the following values: * @arg ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0]. * @arg ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24]. * @arg ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16]. * @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0]. * @retval None */ void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte)); /* Clear MBC bits in the selected MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_MBC); /* Set the selected Filetr mask bytes */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte; } /*------------------------ DMA Tx/Rx Desciptors -----------------------------*/ /** * @brief Initializes the DMA Tx descriptors in chain mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Second Address Chained bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Tx descriptors in ring mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff1: Pointer on the first TxBuffer1 list * @param TxBuff2: Pointer on the first TxBuffer2 list * @param TxBuffCount: Number of the used Tx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;TxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (TxBuffCount-1)) { /* Set Transmit End of Ring bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TER; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Checks whether the specified ETHERNET DMA Tx Desc flag is set or not. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param ETH_DMATxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine * @arg ETH_DMATxDesc_IC : Interrupt on completetion * @arg ETH_DMATxDesc_LS : Last Segment * @arg ETH_DMATxDesc_FS : First Segment * @arg ETH_DMATxDesc_DC : Disable CRC * @arg ETH_DMATxDesc_DP : Disable Pad * @arg ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable * @arg ETH_DMATxDesc_TER : Transmit End of Ring * @arg ETH_DMATxDesc_TCH : Second Address Chained * @arg ETH_DMATxDesc_TTSS: Tx Time Stamp Status * @arg ETH_DMATxDesc_IHE : IP Header Error * @arg ETH_DMATxDesc_ES : Error summary * @arg ETH_DMATxDesc_JT : Jabber Timeout * @arg ETH_DMATxDesc_FF : Frame Flushed: DMA/MTL flushed the frame due to SW flush * @arg ETH_DMATxDesc_PCE : Payload Checksum Error * @arg ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during tramsmission * @arg ETH_DMATxDesc_NC : No Carrier: no carrier signal from the tranceiver * @arg ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision * @arg ETH_DMATxDesc_EC : Excessive Collision: transmission aborted after 16 collisions * @arg ETH_DMATxDesc_VF : VLAN Frame * @arg ETH_DMATxDesc_CC : Collision Count * @arg ETH_DMATxDesc_ED : Excessive Deferral * @arg ETH_DMATxDesc_UF : Underflow Error: late data arrival from the memory * @arg ETH_DMATxDesc_DB : Deferred Bit * @retval The new state of ETH_DMATxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag)); if ((DMATxDesc-&gt;Status &amp; ETH_DMATxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Returns the specified ETHERNET DMA Tx Desc collision count. * @param DMATxDesc: pointer on a DMA Tx descriptor * @retval The Transmit descriptor collision counter value. */ uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc) { /* Return the Receive descriptor frame length */ return ((DMATxDesc-&gt;Status &amp; ETH_DMATxDesc_CC) &gt;&gt; ETH_DMATXDESC_COLLISION_COUNTSHIFT); } /** * @brief Set the specified DMA Tx Desc Own bit. * @param DMATxDesc: Pointer on a Tx desc * @retval None */ void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc) { /* Set the DMA Tx Desc Own bit */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_OWN; } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param NewState: new state of the DMA Tx Desc transmit interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_IC; } else { /* Disable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_IC); } } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_LastSegment : actual Tx desc contain last segment * @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment * @retval None */ void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment)); /* Selects the DMA Tx Desc Frame segment */ DMATxDesc-&gt;Status |= DMATxDesc_FrameSegment; } /** * @brief Selects the specified ETHERNET DMA Tx Desc Checksum Insertion. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_ChecksumByPass : Checksum bypass * @arg ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header * @retval None */ void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum)); /* Set the selected DMA Tx desc checksum insertion control */ DMATxDesc-&gt;Status |= DMATxDesc_Checksum; } /** * @brief Enables or disables the DMA Tx Desc CRC. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc CRC. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DC); } else { /* Disable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DC; } } /** * @brief Enables or disables the DMA Tx Desc end of ring. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TER; } else { /* Disable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_TER); } } /** * @brief Enables or disables the DMA Tx Desc second address chained. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TCH; } else { /* Disable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TCH); } } /** * @brief Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DP); } else { /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DP; } } /** * @brief Enables or disables the DMA Tx Desc time stamp. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc time stamp. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TTSE; } else { /* Disable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TTSE); } } /** * @brief Configures the specified DMA Tx Desc buffer1 and buffer2 sizes. * @param DMATxDesc: Pointer on a Tx desc * @param BufferSize1: specifies the Tx desc buffer1 size. * @param BufferSize2: specifies the Tx desc buffer2 size (put &quot;0&quot; if not used). * @retval None */ void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2) { /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1)); assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2)); /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */ DMATxDesc-&gt;ControlBufferSize |= (BufferSize1 | (BufferSize2 &lt;&lt; ETH_DMATXDESC_BUFFER2_SIZESHIFT)); } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Initializes the DMA Rx descriptors in ring mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff1: Pointer on the first RxBuffer1 list * @param RxBuff2: Pointer on the first RxBuffer2 list * @param RxBuffCount: Number of the used Rx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size */ DMARxDesc-&gt;ControlBufferSize = ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;RxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (RxBuffCount-1)) { /* Set Receive End of Ring bit */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Checks whether the specified ETHERNET Rx Desc flag is set or not. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param ETH_DMARxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMARxDesc_OWN: OWN bit: descriptor is owned by DMA engine * @arg ETH_DMARxDesc_AFM: DA Filter Fail for the rx frame * @arg ETH_DMARxDesc_ES: Error summary * @arg ETH_DMARxDesc_DE: Desciptor error: no more descriptors for receive frame * @arg ETH_DMARxDesc_SAF: SA Filter Fail for the received frame * @arg ETH_DMARxDesc_LE: Frame size not matching with length field * @arg ETH_DMARxDesc_OE: Overflow Error: Frame was damaged due to buffer overflow * @arg ETH_DMARxDesc_VLAN: VLAN Tag: received frame is a VLAN frame * @arg ETH_DMARxDesc_FS: First descriptor of the frame * @arg ETH_DMARxDesc_LS: Last descriptor of the frame * @arg ETH_DMARxDesc_IPV4HCE: IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error * @arg ETH_DMARxDesc_LC: Late collision occurred during reception * @arg ETH_DMARxDesc_FT: Frame type - Ethernet, otherwise 802.3 * @arg ETH_DMARxDesc_RWT: Receive Watchdog Timeout: watchdog timer expired during reception * @arg ETH_DMARxDesc_RE: Receive error: error reported by MII interface * @arg ETH_DMARxDesc_DE: Dribble bit error: frame contains non int multiple of 8 bits * @arg ETH_DMARxDesc_CE: CRC error * @arg ETH_DMARxDesc_MAMPCE: Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error * @retval The new state of ETH_DMARxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag)); if ((DMARxDesc-&gt;Status &amp; ETH_DMARxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Set the specified DMA Rx Desc Own bit. * @param DMARxDesc: Pointer on a Rx desc * @retval None */ void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc) { /* Set the DMA Rx Desc Own bit */ DMARxDesc-&gt;Status |= ETH_DMARxDesc_OWN; } /** * @brief Returns the specified DMA Rx Desc frame length. * @param DMARxDesc: pointer on a DMA Rx descriptor * @retval The Rx descriptor received frame length. */ uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc) { /* Return the Receive descriptor frame length */ return ((DMARxDesc-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT); } /** * @brief Enables or disables the specified DMA Rx Desc receive interrupt. * @param DMARxDesc: Pointer on a Rx desc * @param NewState: new state of the specified DMA Rx Desc interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_DIC); } else { /* Disable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_DIC; } } /** * @brief Enables or disables the DMA Rx Desc end of ring. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } else { /* Disable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RER); } } /** * @brief Enables or disables the DMA Rx Desc second address chained. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RCH; } else { /* Disable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RCH); } } /** * @brief Returns the specified ETHERNET DMA Rx Desc buffer size. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param DMARxDesc_Buffer: specifies the DMA Rx Desc buffer. * This parameter can be any one of the following values: * @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1 * @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2 * @retval The Receive descriptor frame length. */ uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer) { /* Check the parameters */ assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer)); if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1) { /* Return the DMA Rx Desc buffer2 size */ return ((DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS2) &gt;&gt; ETH_DMARXDESC_BUFFER2_SIZESHIFT); } else { /* Return the DMA Rx Desc buffer1 size */ return (DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS1); } } /*--------------------------------- DMA ------------------------------------*/ /** * @brief Resets all MAC subsystem internal registers and logic. * @param None * @retval None */ void ETH_SoftwareReset(void) { /* Set the SWR bit: resets all MAC subsystem internal registers and logic */ /* After reset all the registers holds their respective reset values */ ETH-&gt;DMABMR |= ETH_DMABMR_SR; } /** * @brief Checks whether the ETHERNET software reset bit is set or not. * @param None * @retval The new state of DMA Bus Mode register SR bit (SET or RESET). */ FlagStatus ETH_GetSoftwareResetStatus(void) { FlagStatus bitstatus = RESET; if((ETH-&gt;DMABMR &amp; ETH_DMABMR_SR) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET DMA flag is set or not. * @param ETH_DMA_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_FLAG_TST : Time-stamp trigger flag * @arg ETH_DMA_FLAG_PMT : PMT flag * @arg ETH_DMA_FLAG_MMC : MMC flag * @arg ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access * @arg ETH_DMA_FLAG_ReadWriteError : Error bits 0-write trnsf, 1-read transfr * @arg ETH_DMA_FLAG_AccessError : Error bits 0-Rx DMA, 1-Tx DMA * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ET : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Underflow flag * @arg ETH_DMA_FLAG_RO : Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval The new state of ETH_DMA_FLAG (SET or RESET). */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG)); if ((ETH-&gt;DMASR &amp; ETH_DMA_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA pending flag. * @param ETH_DMA_FLAG: specifies the flag to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ETI : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Transmit Underflow flag * @arg ETH_DMA_FLAG_RO : Receive Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval None */ void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG) { /* Check the parameters */ assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG)); /* Clear the selected ETHERNET DMA FLAG */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_FLAG; } /** * @brief Checks whether the specified ETHERNET DMA interrupt has occured or not. * @param ETH_DMA_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_DMA_IT_TST : Time-stamp trigger interrupt * @arg ETH_DMA_IT_PMT : PMT interrupt * @arg ETH_DMA_IT_MMC : MMC interrupt * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval The new state of ETH_DMA_IT (SET or RESET). */ ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT)); if ((ETH-&gt;DMASR &amp; ETH_DMA_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA IT pending bit. * @param ETH_DMA_IT: specifies the interrupt pending bit to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ETI : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Transmit Underflow interrupt * @arg ETH_DMA_IT_RO : Receive Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval None */ void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); /* Clear the selected ETHERNET DMA IT */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_IT; } /** * @brief Returns the ETHERNET DMA Transmit Process State. * @param None * @retval The new ETHERNET DMA Transmit Process State: * This can be one of the following values: * - ETH_DMA_TransmitProcess_Stopped : Stopped - Reset or Stop Tx Command issued * - ETH_DMA_TransmitProcess_Fetching : Running - fetching the Tx descriptor * - ETH_DMA_TransmitProcess_Waiting : Running - waiting for status * - ETH_DMA_TransmitProcess_Reading : unning - reading the data from host memory * - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe * - ETH_DMA_TransmitProcess_Closing : Running - closing Rx descriptor */ uint32_t ETH_GetTransmitProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_TS)); } /** * @brief Returns the ETHERNET DMA Receive Process State. * @param None * @retval The new ETHERNET DMA Receive Process State: * This can be one of the following values: * - ETH_DMA_ReceiveProcess_Stopped : Stopped - Reset or Stop Rx Command issued * - ETH_DMA_ReceiveProcess_Fetching : Running - fetching the Rx descriptor * - ETH_DMA_ReceiveProcess_Waiting : Running - waiting for packet * - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable * - ETH_DMA_ReceiveProcess_Closing : Running - closing descriptor * - ETH_DMA_ReceiveProcess_Queuing : Running - queuing the recieve frame into host memory */ uint32_t ETH_GetReceiveProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_RS)); } /** * @brief Clears the ETHERNET transmit FIFO. * @param None * @retval None */ void ETH_FlushTransmitFIFO(void) { /* Set the Flush Transmit FIFO bit */ ETH-&gt;DMAOMR |= ETH_DMAOMR_FTF; } /** * @brief Checks whether the ETHERNET transmit FIFO bit is cleared or not. * @param None * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET). */ FlagStatus ETH_GetFlushTransmitFIFOStatus(void) { FlagStatus bitstatus = RESET; if ((ETH-&gt;DMAOMR &amp; ETH_DMAOMR_FTF) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the DMA transmission. * @param NewState: new state of the DMA transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA transmission */ ETH-&gt;DMAOMR |= ETH_DMAOMR_ST; } else { /* Disable the DMA transmission */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_ST; } } /** * @brief Enables or disables the DMA reception. * @param NewState: new state of the DMA reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA reception */ ETH-&gt;DMAOMR |= ETH_DMAOMR_SR; } else { /* Disable the DMA reception */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_SR; } } /** * @brief Enables or disables the specified ETHERNET DMA interrupts. * @param ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @param NewState: new state of the specified ETHERNET DMA interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER |= ETH_DMA_IT; } else { /* Disable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER &amp;=(~(uint32_t)ETH_DMA_IT); } } /** * @brief Checks whether the specified ETHERNET DMA overflow flag is set or not. * @param ETH_DMA_Overflow: specifies the DMA overflow flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter * @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET). */ FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow)); if ((ETH-&gt;DMAMFBOCR &amp; ETH_DMA_Overflow) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Get the ETHERNET DMA Rx Overflow Missed Frame Counter value. * @param None * @retval The value of Rx overflow Missed Frame Counter. */ uint32_t ETH_GetRxOverflowMissedFrameCounter(void) { return ((uint32_t)((ETH-&gt;DMAMFBOCR &amp; ETH_DMAMFBOCR_MFA)&gt;&gt;ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT)); } /** * @brief Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value. * @param None * @retval The value of Buffer unavailable Missed Frame Counter. */ uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void) { return ((uint32_t)(ETH-&gt;DMAMFBOCR) &amp; ETH_DMAMFBOCR_MFC); } /** * @brief Get the ETHERNET DMA DMACHTDR register value. * @param None * @retval The value of the current Tx desc start address. */ uint32_t ETH_GetCurrentTxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTDR)); } /** * @brief Get the ETHERNET DMA DMACHRDR register value. * @param None * @retval The value of the current Rx desc start address. */ uint32_t ETH_GetCurrentRxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRDR)); } /** * @brief Get the ETHERNET DMA DMACHTBAR register value. * @param None * @retval The value of the current Tx buffer address. */ uint32_t ETH_GetCurrentTxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTBAR)); } /** * @brief Get the ETHERNET DMA DMACHRBAR register value. * @param None * @retval The value of the current Rx buffer address. */ uint32_t ETH_GetCurrentRxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRBAR)); } /** * @brief Resumes the DMA Transmission by writing to the DmaTxPollDemand register * (the data written could be anything). This forces the DMA to resume transmission. * @param None * @retval None. */ void ETH_ResumeDMATransmission(void) { ETH-&gt;DMATPDR = 0; } /** * @brief Resumes the DMA Transmission by writing to the DmaRxPollDemand register * (the data written could be anything). This forces the DMA to resume reception. * @param None * @retval None. */ void ETH_ResumeDMAReception(void) { ETH-&gt;DMARPDR = 0; } /*--------------------------------- PMT ------------------------------------*/ /** * @brief Reset Wakeup frame filter register pointer. * @param None * @retval None */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void) { /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFFRPR; } /** * @brief Populates the remote wakeup frame registers. * @param Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words). * @retval None */ void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer) { uint32_t i = 0; /* Fill Remote Wake-up Frame Filter register with Buffer data */ for(i =0; i&lt;ETH_WAKEUP_REGISTER_LENGTH; i++) { /* Write each time to the same register */ ETH-&gt;MACRWUFFR = Buffer[i]; } } /** * @brief Enables or disables any unicast packet filtered by the MAC address * recognition to be a wake-up frame. * @param NewState: new state of the MAC Global Unicast Wake-Up. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_GU; } else { /* Disable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_GU; } } /** * @brief Checks whether the specified ETHERNET PMT flag is set or not. * @param ETH_PMT_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Poniter Reset * @arg ETH_PMT_FLAG_WUFR : Wake-Up Frame Received * @arg ETH_PMT_FLAG_MPR : Magic Packet Received * @retval The new state of ETHERNET PMT Flag (SET or RESET). */ FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG)); if ((ETH-&gt;MACPMTCSR &amp; ETH_PMT_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the MAC Wake-Up Frame Detection. * @param NewState: new state of the MAC Wake-Up Frame Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFE; } else { /* Disable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_WFE; } } /** * @brief Enables or disables the MAC Magic Packet Detection. * @param NewState: new state of the MAC Magic Packet Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MagicPacketDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_MPE; } else { /* Disable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_MPE; } } /** * @brief Enables or disables the MAC Power Down. * @param NewState: new state of the MAC Power Down. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PowerDownCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Power Down */ /* This puts the MAC in power down mode */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_PD; } else { /* Disable the MAC Power Down */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_PD; } } /*--------------------------------- MMC ------------------------------------*/ /** * @brief Enables or disables the MMC Counter Freeze. * @param NewState: new state of the MMC Counter Freeze. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter Freeze */ ETH-&gt;MMCCR |= ETH_MMCCR_MCF; } else { /* Disable the MMC Counter Freeze */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_MCF; } } /** * @brief Enables or disables the MMC Reset On Read. * @param NewState: new state of the MMC Reset On Read. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCResetOnReadCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter reset on read */ ETH-&gt;MMCCR |= ETH_MMCCR_ROR; } else { /* Disable the MMC Counter reset on read */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_ROR; } } /** * @brief Enables or disables the MMC Counter Stop Rollover. * @param NewState: new state of the MMC Counter Stop Rollover. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterRolloverCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Disable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_CSR; } else { /* Enable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR |= ETH_MMCCR_CSR; } } /** * @brief Resets the MMC Counters. * @param None * @retval None */ void ETH_MMCCountersReset(void) { /* Resets the MMC Counters */ ETH-&gt;MMCCR |= ETH_MMCCR_CR; } /** * @brief Enables or disables the specified ETHERNET MMC interrupts. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. * This parameter can be any combination of Tx interrupt or * any combination of Rx interrupt (but not both)of the following values: * @arg ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value * @param NewState: new state of the specified ETHERNET MMC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MMC_IT(ETH_MMC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* Remove egister mak from IT */ ETH_MMC_IT &amp;= 0xEFFFFFFF; /* ETHERNET MMC Rx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR |= ETH_MMC_IT; } } else { /* ETHERNET MMC Tx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR |= ETH_MMC_IT; } } } /** * @brief Checks whether the specified ETHERNET MMC IT is set or not. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt. * This parameter can be one of the following values: * @arg ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value * @retval The value of ETHERNET MMC IT (SET or RESET). */ ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* ETHERNET MMC Rx interrupts selected */ /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCRIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } else { /* ETHERNET MMC Tx interrupts selected */ /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCTIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } return bitstatus; } /** * @brief Get the specified ETHERNET MMC register value. * @param ETH_MMCReg: specifies the ETHERNET MMC register. * This parameter can be one of the following values: * @arg ETH_MMCCR : MMC CR register * @arg ETH_MMCRIR : MMC RIR register * @arg ETH_MMCTIR : MMC TIR register * @arg ETH_MMCRIMR : MMC RIMR register * @arg ETH_MMCTIMR : MMC TIMR register * @arg ETH_MMCTGFSCCR : MMC TGFSCCR register * @arg ETH_MMCTGFMSCCR: MMC TGFMSCCR register * @arg ETH_MMCTGFCR : MMC TGFCR register * @arg ETH_MMCRFCECR : MMC RFCECR register * @arg ETH_MMCRFAECR : MMC RFAECR register * @arg ETH_MMCRGUFCR : MMC RGUFCRregister * @retval The value of ETHERNET MMC Register value. */ uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg) { /* Check the parameters */ assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg)); } /*--------------------------------- PTP ------------------------------------*/ /** * @brief Updated the PTP block for fine correction with the Time Stamp Addend register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampAddend(void) { /* Enable the PTP block update with the Time Stamp Addend register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSARU; } /** * @brief Enable the PTP Time Stamp interrupt trigger * @param None * @retval None */ void ETH_EnablePTPTimeStampInterruptTrigger(void) { /* Enable the PTP target time interrupt */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSITE; } /** * @brief Updated the PTP system time with the Time Stamp Update register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampUpdate(void) { /* Enable the PTP system time update with the Time Stamp Update register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTU; } /** * @brief Initialize the PTP Time Stamp * @param None * @retval None */ void ETH_InitializePTPTimeStamp(void) { /* Initialize the PTP Time Stamp */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTI; } /** * @brief Selects the PTP Update method * @param UpdateMethod: the PTP Update method * This parameter can be one of the following values: * @arg ETH_PTP_FineUpdate : Fine Update method * @arg ETH_PTP_CoarseUpdate : Coarse Update method * @retval None */ void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod) { /* Check the parameters */ assert_param(IS_ETH_PTP_UPDATE(UpdateMethod)); if (UpdateMethod != ETH_PTP_CoarseUpdate) { /* Enable the PTP Fine Update method */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSFCU; } else { /* Disable the PTP Coarse Update method */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSFCU); } } /** * @brief Enables or disables the PTP time stamp for transmit and receive frames. * @param NewState: new state of the PTP time stamp for transmit and receive frames * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PTPTimeStampCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSE; } else { /* Disable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSE); } } /** * @brief Checks whether the specified ETHERNET PTP flag is set or not. * @param ETH_PTP_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PTP_FLAG_TSARU : Addend Register Update * @arg ETH_PTP_FLAG_TSITE : Time Stamp Interrupt Trigger Enable * @arg ETH_PTP_FLAG_TSSTU : Time Stamp Update * @arg ETH_PTP_FLAG_TSSTI : Time Stamp Initialize * @retval The new state of ETHERNET PTP Flag (SET or RESET). */ FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG)); if ((ETH-&gt;PTPTSCR &amp; ETH_PTP_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Sets the system time Sub-Second Increment value. * @param SubSecondValue: specifies the PTP Sub-Second Increment Register value. * @retval None */ void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue)); /* Set the PTP Sub-Second Increment Register */ ETH-&gt;PTPSSIR = SubSecondValue; } /** * @brief Sets the Time Stamp update sign and values. * @param Sign: specifies the PTP Time update value sign. * This parameter can be one of the following values: * @arg ETH_PTP_PositiveTime : positive time value. * @arg ETH_PTP_NegativeTime : negative time value. * @param SecondValue: specifies the PTP Time update second value. * @param SubSecondValue: specifies the PTP Time update sub-second value. * This parameter is a 31 bit value, bit32 correspond to the sign. * @retval None */ void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_TIME_SIGN(Sign)); assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); /* Set the PTP Time Update High Register */ ETH-&gt;PTPTSHUR = SecondValue; /* Set the PTP Time Update Low Register with sign */ ETH-&gt;PTPTSLUR = Sign | SubSecondValue; } /** * @brief Sets the Time Stamp Addend value. * @param Value: specifies the PTP Time Stamp Addend Register value. * @retval None */ void ETH_SetPTPTimeStampAddend(uint32_t Value) { /* Set the PTP Time Stamp Addend Register */ ETH-&gt;PTPTSAR = Value; } /** * @brief Sets the Target Time registers values. * @param HighValue: specifies the PTP Target Time High Register value. * @param LowValue: specifies the PTP Target Time Low Register value. * @retval None */ void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue) { /* Set the PTP Target Time High Register */ ETH-&gt;PTPTTHR = HighValue; /* Set the PTP Target Time Low Register */ ETH-&gt;PTPTTLR = LowValue; } /** * @brief Get the specified ETHERNET PTP register value. * @param ETH_PTPReg: specifies the ETHERNET PTP register. * This parameter can be one of the following values: * @arg ETH_PTPTSCR : Sub-Second Increment Register * @arg ETH_PTPSSIR : Sub-Second Increment Register * @arg ETH_PTPTSHR : Time Stamp High Register * @arg ETH_PTPTSLR : Time Stamp Low Register * @arg ETH_PTPTSHUR : Time Stamp High Update Register * @arg ETH_PTPTSLUR : Time Stamp Low Update Register * @arg ETH_PTPTSAR : Time Stamp Addend Register * @arg ETH_PTPTTHR : Target Time High Register * @arg ETH_PTPTTLR : Target Time Low Register * @retval The value of ETHERNET PTP Register value. */ uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg) { /* Check the parameters */ assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg)); } /** * @brief Initializes the DMA Tx descriptors in chain mode with PTP. * @param DMATxDescTab: Pointer on the first Tx desc list * @param DMAPTPTxDescTab: Pointer on the first PTP Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; DMAPTPTxDescToSet = DMAPTPTxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab+i; /* Set Second Address Chained bit and enable PTP */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr =(uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */ (&amp;DMAPTPTxDescTab[i])-&gt;Buffer1Addr = DMATxDesc-&gt;Buffer1Addr; (&amp;DMAPTPTxDescTab[i])-&gt;Buffer2NextDescAddr = DMATxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPTxDescTab desc status record the first list address */ (&amp;DMAPTPTxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPTxDescTab; /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param DMAPTPRxDescTab: Pointer on the first PTP Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; DMAPTPRxDescToGet = DMAPTPRxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */ (&amp;DMAPTPRxDescTab[i])-&gt;Buffer1Addr = DMARxDesc-&gt;Buffer1Addr; (&amp;DMAPTPRxDescTab[i])-&gt;Buffer2NextDescAddr = DMARxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPRxDescTab desc status record the first list address */ (&amp;DMAPTPRxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPRxDescTab; /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Transmits a packet, from application buffer, pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet buffer to transmit. * @param FrameLength: Tx Packet size. * @param PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab) { uint32_t offset = 0, timeout = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMAPTPTxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; (uint32_t)0x1FFF); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Wait for ETH_DMATxDesc_TTSS flag to be set */ do { timeout++; } while (!(DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TTSS) &amp;&amp; (timeout &lt; 0xFFFF)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return ETH_ERROR; } /* Clear the DMATxDescToSet status register TTSS flag */ DMATxDescToSet-&gt;Status &amp;= ~ETH_DMATxDesc_TTSS; *PTPTxTab++ = DMATxDescToSet-&gt;Buffer1Addr; *PTPTxTab = DMATxDescToSet-&gt;Buffer2NextDescAddr; /* Update the ENET DMA current descriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Buffer2NextDescAddr); if(DMAPTPTxDescToSet-&gt;Status != 0) { DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Status); } else { DMAPTPTxDescToSet++; } } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read: this will be the first Tx descriptor in this case */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet receive buffer. * @param PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ENET or CPU */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } *PTPRxTab++ = DMARxDescToGet-&gt;Buffer1Addr; *PTPRxTab = DMARxDescToGet-&gt;Buffer2NextDescAddr; /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status |= ETH_DMARxDesc_OWN; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Buffer2NextDescAddr); if(DMAPTPRxDescToGet-&gt;Status != 0) { DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Status); } else { DMAPTPRxDescToGet++; } } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @} */ /* * STM32 Eth Driver * Change Logs: * Date Author Notes * 2009-10-05 Bernard eth interface driver for STM32F107 CL */ #include &lt;netif/ethernetif.h&gt; #include &lt;netif/etharp.h&gt; #include &lt;lwip/icmp.h&gt; #include &quot;lwipopts.h&quot; #define ETH_DEBUG //#define ETH_RX_DUMP //#define ETH_TX_DUMP #ifdef ETH_DEBUG #define STM32_ETH_TRACE FreeRTOS_printf #else #define STM32_ETH_TRACE(...) #endif /* ETH_DEBUG */ #if defined(ETH_RX_DUMP) || defined(ETH_TX_DUMP) static void packet_dump(const char * msg, const struct pbuf* p) { rt_uint32_t i; u8 *ptr = p-&gt;payload; STM32_ETH_TRACE(&quot;%s %d byte\n&quot;, msg, p-&gt;tot_len); for(i=0; i&lt;p-&gt;tot_len; i++) { if( (i%8) == 0 ) { STM32_ETH_TRACE(&quot; &quot;); } if( (i%16) == 0 ) { STM32_ETH_TRACE(&quot;\r\n&quot;); } STM32_ETH_TRACE(&quot;%02x &quot;,*ptr); ptr++; } STM32_ETH_TRACE(&quot;\n\n&quot;); } #endif /* dump */ static ETH_InitTypeDef ETH_InitStructure; /* initialize the interface */ /** * @brief Configures the Ethernet Interface * @param None * @retval None */ void Ethernet_Configuration(void) { vu32 Value = 0; /* Reset ETHERNET on AHB Bus */ ETH_DeInit(); /* Software reset */ ETH_SoftwareReset(); /* Wait for software reset */ while(ETH_GetSoftwareResetStatus()==SET); /* ETHERNET Configuration ------------------------------------------------------*/ /* Call ETH_StructInit if you don&#39;t like to configure all ETH_InitStructure parameter */ ETH_StructInit(&amp;ETH_InitStructure); /* Fill ETH_InitStructure parametrs */ /*------------------------ MAC -----------------------------------*/ ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable ; ETH_InitStructure.ETH_Speed = ETH_Speed_100M; ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex; ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable; ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable; ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; #if CHECKSUM_BY_HARDWARE ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable; #endif /* CHECKSUM_BY_HARDWARE */ /*------------------------ DMA -----------------------------------*/ /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */ ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable; ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable; ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat; ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat; ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1; /* Configure ETHERNET */ Value = ETH_Init(&amp;ETH_InitStructure); /* Enable DMA Receive interrupt (need to enable in this case Normal interrupt) */ ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R | ETH_DMA_IT_T, ENABLE); } static void RCC_Configuration(void) { /* Enable ETHERNET clock */ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx | RCC_AHBPeriph_ETH_MAC_Rx, ENABLE); /* Enable GPIOs clocks */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_AFIO, ENABLE); } static void NVIC_Configuration(void) { NVIC_InitTypeDef NVIC_InitStructure; /* 2 bit for pre-emption priority, 2 bits for subpriority */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //by sunq /* Enable the EXTI0 Interrupt */ NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); } /* * GPIO Configuration for ETH AF Output Push Pull: - ETH_MDC : PC1 - ETH_MDIO : PA2 - ETH_TX_EN : PB11 - ETH_TXD0 : PB12 - ETH_TXD1 : PB13 - ETH_TXD2 : PC2 - ETH_TXD3 : PB8 - ETH_PPS_OUT / ETH_RMII_PPS_OUT: PB5 Input (Reset Value): - ETH_MII_TX_CLK: PC3 - ETH_MII_RX_CLK / ETH_RMII_REF_CLK: PA1 - ETH_MII_CRS: PA0 - ETH_MII_COL: PA3 - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PA7 - ETH_MII_RXD0: PC4 - ETH_MII_RXD1: PC5 - ETH_MII_RXD2: PB0 - ETH_MII_RXD3: PB1 - ETH_MII_RX_ER: PB10 *************************************** For Remapped Ethernet pins ******************************************* Input (Reset Value): - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PD8 - ETH_MII_RXD0 / ETH_RMII_RXD0: PD9 - ETH_MII_RXD1 / ETH_RMII_RXD1: PD10 - ETH_MII_RXD2: PD11 - ETH_MII_RXD3: PD12 */ static void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; #if STM32_ETH_IO_REMAP /* ETHERNET pins remapp in STM3210C-EVAL board: RX_DV and RxD[3:0] */ GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE); #endif /* STM32_ETH_IO_REMAP */ /* MII/RMII Media interface selection */ #if (RMII_MODE == 0) /* Mode MII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_MII); #elif (RMII_MODE == 1) /* Mode RMII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII); #endif /* RMII_MODE */ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* MDIO */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* MDC */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* MDIO */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); } /* MDIO */ /* TXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* TX_EN */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* TXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* TXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TX_CLK */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* TXD */ /* RXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; #if (STM32_ETH_IO_REMAP == 0) /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #else /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #endif /* STM32_ETH_IO_REMAP */ #if (RMII_MODE == 0) /* CRS */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* COL */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_CLK */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_ER */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* RXD */ #if (USE_MCO == 1) #if (RMII_MODE == 0) /* Mode MII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ RCC_MCOConfig(RCC_MCO_HSE); #elif (RMII_MODE == 1) /* Mode RMII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ /* set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */ RCC_PLL3Config(RCC_PLL3Mul_10); /* Enable PLL3 */ RCC_PLL3Cmd(ENABLE); /* Wait till PLL3 is ready */ while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {} /* Get clock PLL3 clock on PA8 pin */ RCC_MCOConfig(RCC_MCO_PLL3CLK); #endif /* RMII_MODE */ /* MCO pin configuration------------------------------------------------- */ /* Configure MCO (PA8) as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); #endif /* USE_MCO */ } void FreeRTOS_Hardware_STMS32_ETH_Init() { RCC_Configuration(); GPIO_Configuration(); NVIC_Configuration(); Ethernet_Configuration(); } 另外我们写一个ethernetif.h头文件： #ifndef __ETHERNETIF_H__ #define __ETHERNETIF_H__ #include &quot;lwip/err.h&quot; #include &quot;lwip/netif.h&quot; err_t ethernetif_init(struct netif *netif); #endif 把它放在third_party\lwip-1.4.1\src\include\netif目录下。 到此，驱动部分完成了。 然后，就要修改third_party\lwip-1.4.1\src\netif\ethernetif.c。 ethernetif.c内容主要是针对物理层操作的一个结构体变量进行回调函数指针赋值，并实现链路层发送和接收数据包， 代码如下： /** * @file * Ethernet Interface Skeleton * */ /* * Copyright (c) 2001-2004 Swedish Institute of Computer Science. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * 1. Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation * and/or other materials provided with the distribution. * 3. The name of the author may not be used to endorse or promote products * derived from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY * OF SUCH DAMAGE. * * This file is part of the lwIP TCP/IP stack. * * Author: Adam Dunkels &lt;adam@sics.se&gt; * */ /* * This file is a skeleton for developing Ethernet network interface * drivers for lwIP. Add code to the low_level functions and do a * search-and-replace for the word &quot;ethernetif&quot; to replace it with * something that better describes your network interface. */ #include &quot;lwip/opt.h&quot; #include &quot;lwip/def.h&quot; #include &quot;lwip/mem.h&quot; #include &quot;lwip/pbuf.h&quot; #include &quot;lwip/sys.h&quot; #include &quot;netif/etharp.h&quot; #include &quot;err.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;stm32_eth.h&quot; #include &lt;string.h&gt; #include &quot;lwip/timers.h&quot; #define netifMTU (1500) #define netifINTERFACE_TASK_STACK_SIZE ( 350 ) #define netifINTERFACE_TASK_PRIORITY ( configMAX_PRIORITIES - 1 ) #define netifGUARD_BLOCK_TIME ( 250 ) /* The time to block waiting for input. */ #define emacBLOCK_TIME_WAITING_FOR_INPUT ( ( portTickType ) 100 ) /* Define those to better describe your network interface. */ #define IFNAME0 &#39;s&#39; #define IFNAME1 &#39;t&#39; #define ETH_DMARxDesc_FrameLengthShift 16 #define ETH_ERROR ((u32)0) #define ETH_SUCCESS ((u32)1) static struct netif *s_pxNetIf = NULL; xSemaphoreHandle s_xSemaphore = NULL; #define ETH_RXBUFNB 4 #define ETH_TXBUFNB 2 /* Ethernet Rx &amp; Tx DMA Descriptors */ ETH_DMADESCTypeDef DMARxDscrTab[ETH_RXBUFNB], DMATxDscrTab[ETH_TXBUFNB]; /* Ethernet Receive buffers */ uint8_t Rx_Buff[ETH_RXBUFNB][ETH_MAX_PACKET_SIZE]; /* Ethernet Transmit buffers */ uint8_t Tx_Buff[ETH_TXBUFNB][ETH_MAX_PACKET_SIZE]; /* Global pointers to track current transmit and receive descriptors */ extern ETH_DMADESCTypeDef *DMATxDescToSet; extern ETH_DMADESCTypeDef *DMARxDescToGet; typedef struct { u32 length; u32 buffer; ETH_DMADESCTypeDef *descriptor; }FrameTypeDef; FrameTypeDef ETH_RxPkt_ChainMode(void); u32 ETH_GetCurrentTxBuffer(void); u32 ETH_TxPkt_ChainMode(u16 FrameLength); static void ethernetif_input( void * pvParameters ); static void arp_timer(void *arg); /** * In this function, the hardware should be initialized. * Called from ethernetif_init(). * * @param netif the already initialized lwip network interface structure * for this ethernetif */ static void low_level_init(struct netif *netif) { uint32_t i; struct ethernetif *ethernetif = netif-&gt;state; /* set netif MAC hardware address length */ netif-&gt;hwaddr_len = ETHARP_HWADDR_LEN; /* set netif MAC hardware address */ netif-&gt;hwaddr[0] = MAC_ADDR0; netif-&gt;hwaddr[1] = MAC_ADDR1; netif-&gt;hwaddr[2] = MAC_ADDR2; netif-&gt;hwaddr[3] = MAC_ADDR3; netif-&gt;hwaddr[4] = MAC_ADDR4; netif-&gt;hwaddr[5] = MAC_ADDR5; /* set netif maximum transfer unit */ netif-&gt;mtu = 1500; /* Accept broadcast address and ARP traffic */ netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP; s_pxNetIf =netif; /* create binary semaphore used for informing ethernetif of frame reception */ if (s_xSemaphore == NULL) { s_xSemaphore= xSemaphoreCreateCounting(20,0); } /* initialize MAC address in ethernet MAC */ ETH_MACAddressConfig(ETH_MAC_Address0, netif-&gt;hwaddr); /* Initialize Tx Descriptors list: Chain Mode */ ETH_DMATxDescChainInit(DMATxDscrTab, &amp;Tx_Buff[0][0], ETH_TXBUFNB); /* Initialize Rx Descriptors list: Chain Mode */ ETH_DMARxDescChainInit(DMARxDscrTab, &amp;Rx_Buff[0][0], ETH_RXBUFNB); /* Enable Ethernet Rx interrrupt */ { for(i=0; i&lt;ETH_RXBUFNB; i++) { ETH_DMARxDescReceiveITConfig(&amp;DMARxDscrTab[i], ENABLE); } } #ifdef CHECKSUM_BY_HARDWARE /* Enable the checksum insertion for the Tx frames */ { for(i=0; i&lt;ETH_TXBUFNB; i++) { ETH_DMATxDescChecksumInsertionConfig(&amp;DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull); } } #endif /* create the task that handles the ETH_MAC */ xTaskCreate(ethernetif_input, (const char*) &quot;Eth_if&quot;, netifINTERFACE_TASK_STACK_SIZE, NULL, netifINTERFACE_TASK_PRIORITY,NULL); /* Enable MAC and DMA transmission and reception */ ETH_Start(); } /** * This function should do the actual transmission of the packet. The packet is * contained in the pbuf that is passed to the function. This pbuf * might be chained. * * @param netif the lwip network interface structure for this ethernetif * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type) * @return ERR_OK if the packet could be sent * an err_t value if the packet couldn&#39;t be sent * * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to * strange results. You might consider waiting for space in the DMA queue * to become availale since the stack doesn&#39;t retry to send a packet * dropped because of memory failure (except for the TCP timers). */ static err_t low_level_output(struct netif *netif, struct pbuf *p) { static xSemaphoreHandle xTxSemaphore = NULL; struct pbuf *q; uint32_t l = 0; u8 *buffer ; if (xTxSemaphore == NULL) { vSemaphoreCreateBinary (xTxSemaphore); } if (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME)) { buffer = (u8 *)(ETH_GetCurrentTxBuffer()); for(q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)&amp;buffer[l], q-&gt;payload, q-&gt;len); l = l + q-&gt;len; } ETH_TxPkt_ChainMode(l); xSemaphoreGive(xTxSemaphore); } return ERR_OK; } /** * Should allocate a pbuf and transfer the bytes of the incoming * packet from the interface into the pbuf. * * @param netif the lwip network interface structure for this ethernetif * @return a pbuf filled with the received packet (including MAC header) * NULL on memory error */ static struct pbuf * low_level_input(struct netif *netif) { struct pbuf *p, *q; u16_t len; int l =0; FrameTypeDef frame; u8 *buffer; p = NULL; frame = ETH_RxPkt_ChainMode(); /* Check if the descriptor is exist */ if(!frame.descriptor) return p; /* Obtain the size of the packet and put it into the &quot;len&quot; variable. */ len = frame.length; buffer = (u8 *)frame.buffer; /* We allocate a pbuf chain of pbufs from the pool. */ p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL); if (p != NULL) { for (q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)q-&gt;payload, (u8_t*)&amp;buffer[l], q-&gt;len); l = l + q-&gt;len; } } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } return p; } /** * This function is the ethernetif_input task, it is processed when a packet * is ready to be read from the interface. It uses the function low_level_input() * that should handle the actual reception of bytes from the network * interface. Then the type of the received packet is determined and * the appropriate input function is called. * * @param netif the lwip network interface structure for this ethernetif */ void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } /** * Should be called at the beginning of the program to set up the * network interface. It calls the function low_level_init() to do the * actual setup of the hardware. * * This function should be passed as a parameter to netif_add(). * * @param netif the lwip network interface structure for this ethernetif * @return ERR_OK if the loopif is initialized * ERR_MEM if private data couldn&#39;t be allocated * any other err_t on error */ err_t ethernetif_init(struct netif *netif) { LWIP_ASSERT(&quot;netif != NULL&quot;, (netif != NULL)); #if LWIP_NETIF_HOSTNAME /* Initialize interface hostname */ netif-&gt;hostname = &quot;lwip&quot;; #endif /* LWIP_NETIF_HOSTNAME */ netif-&gt;name[0] = IFNAME0; netif-&gt;name[1] = IFNAME1; netif-&gt;output = etharp_output; netif-&gt;linkoutput = low_level_output; /* initialize the hardware */ low_level_init(netif); etharp_init(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); return ERR_OK; } static void arp_timer(void *arg) { etharp_tmr(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); } /******************************************************************************* * Function Name : ETH_RxPkt_ChainMode * Description : Receives a packet. * Input : None * Output : None * Return : frame: farme size and location *******************************************************************************/ FrameTypeDef ETH_RxPkt_ChainMode(void) { u32 framelength = 0; FrameTypeDef frame = {0,0}; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (u32)RESET) { frame.length = ETH_ERROR; if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Return error: OWN bit set */ return frame; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (u32)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARxDesc_FrameLengthShift) - 4; /* Get the addrees of the actual buffer */ frame.buffer = DMARxDescToGet-&gt;Buffer1Addr; } else { /* Return ERROR */ framelength = ETH_ERROR; } frame.length = framelength; frame.descriptor = DMARxDescToGet; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); /* Return Frame */ return (frame); } /******************************************************************************* * Function Name : ETH_TxPkt_ChainMode * Description : Transmits a packet, from application buffer, pointed by ppkt. * Input : - FrameLength: Tx Packet size. * Output : None * Return : ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission *******************************************************************************/ u32 ETH_TxPkt_ChainMode(u16 FrameLength) { /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (u32)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (u32)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); /* Return SUCCESS */ return ETH_SUCCESS; } /******************************************************************************* * Function Name : ETH_GetCurrentTxBuffer * Description : Return the address of the buffer pointed by the current descritor. * Input : None * Output : None * Return : Buffer address *******************************************************************************/ u32 ETH_GetCurrentTxBuffer(void) { /* Return Buffer address */ return (DMATxDescToSet-&gt;Buffer1Addr); } 这里我们加了一个FreeRTOS_net_config.h头文件，里面定义了MAC地址和默认的IP地址定义： /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __FREERTOS_NET_CONFIG_H__ #define __FREERTOS_NET_CONFIG_H__ #ifdef __cplusplus extern &quot;C&quot; { #endif /* MAC ADDRESS*/ #define MAC_ADDR0 0x00 #define MAC_ADDR1 0x80 #define MAC_ADDR2 0xe1 #define MAC_ADDR3 0x31 #define MAC_ADDR4 0x45 #define MAC_ADDR5 0x57 /*Static IP ADDRESS*/ #define IP_ADDR0 192 #define IP_ADDR1 168 #define IP_ADDR2 1 #define IP_ADDR3 30 /*NETMASK*/ #define NETMASK_ADDR0 255 #define NETMASK_ADDR1 255 #define NETMASK_ADDR2 255 #define NETMASK_ADDR3 0 /*Gateway Address*/ #define GW_ADDR0 192 #define GW_ADDR1 168 #define GW_ADDR2 1 #define GW_ADDR3 1 #ifdef __cplusplus } #endif #endif /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 把FreeRTOS_net_config.h放在BSP目录下。 对于ethernetif.c的代码要说明一下ethernetif_input这个函数： void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } 网上有很多版本没有while循环，这会导致数据接收的时候缓冲区很快被填满，但不能清空，从而导致速度突然下降乃至断断续续，大量丢包，即使ping本机也会陡然降速，不断超时。加上while就可以解决问题了，但是出现了bug，导致系统崩溃，问题出现在low_level_input函数中的 frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; 因为frame.descriptor这个指针使用完之后就被释放了，程序再次跑到这里的时候frame.descriptor成了野指针。 为了解决这个问题，在使用前判断一下： /* Check if the descriptor is exist */ if(!frame.descriptor) return p; 详细位置请参考上面的有关代码。 另外，我们代码中使用了信号量，所以需要在FreeRTOS的配置文件中打开相关的宏，以支持信号量： 把FreeRTOSConfig.h中的： #define configUSE_COUNTING_SEMAPHORES 0 改为： #define configUSE_COUNTING_SEMAPHORES 1 接下来需要改的地方就是网卡接口中断服务程序了。 需要修改两个文件，第一个就是启动文件STM32F10x.s，把以太网中断向量的屏蔽解除。 第二个就是中断服务函数文件stm32f10x_it.c，定义以太网中断服务函数。 STM32F10x.s如下： ;/*****************************************************************************/ ;/* STM32F10x.s: Startup file for ST STM32F10x device series */ ;/*****************************************************************************/ ;/* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; */ ;/*****************************************************************************/ ;/* This file is part of the uVision/ARM development tools. */ ;/* Copyright (c) 2005-2007 Keil Software. All rights reserved. */ ;/* This software may only be used under the terms of a valid, current, */ ;/* end user licence from KEIL for a compatible version of KEIL software */ ;/* development tools. Nothing else gives you the right to use this software. */ ;/*****************************************************************************/ ;// &lt;h&gt; Stack Configuration ;// &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp ;// &lt;h&gt; Heap Configuration ;// &lt;o&gt; Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit IMPORT xPortPendSVHandler IMPORT xPortSysTickHandler IMPORT vPortSVCHandler IMPORT vUARTInterruptHandler ;IMPORT vTimer2IntHandler PRESERVE8 THUMB ; Vector Table Mapped to Address 0 at Reset AREA RESET, DATA, READONLY EXPORT __Vectors EXPORT __Vectors_End EXPORT __Vectors_Size __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD vPortSVCHandler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD xPortPendSVHandler ; PendSV Handler DCD xPortSysTickHandler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD TAMPER_IRQHandler ; Tamper DCD RTC_IRQHandler ; RTC DCD FLASH_IRQHandler ; Flash DCD RCC_IRQHandler ; RCC DCD EXTI0_IRQHandler ; EXTI Line 0 DCD EXTI1_IRQHandler ; EXTI Line 1 DCD EXTI2_IRQHandler ; EXTI Line 2 DCD EXTI3_IRQHandler ; EXTI Line 3 DCD EXTI4_IRQHandler ; EXTI Line 4 DCD DMAChannel1_IRQHandler ; DMA Channel 1 DCD DMAChannel2_IRQHandler ; DMA Channel 2 DCD DMAChannel3_IRQHandler ; DMA Channel 3 DCD DMAChannel4_IRQHandler ; DMA Channel 4 DCD DMAChannel5_IRQHandler ; DMA Channel 5 DCD DMAChannel6_IRQHandler ; DMA Channel 6 DCD DMAChannel7_IRQHandler ; DMA Channel 7 DCD ADC_IRQHandler ; ADC DCD USB_HP_CAN_TX_IRQHandler ; USB High Priority or CAN TX DCD USB_LP_CAN_RX0_IRQHandler ; USB Low Priority or CAN RX0 DCD CAN_RX1_IRQHandler ; CAN RX1 DCD CAN_SCE_IRQHandler ; CAN SCE DCD EXTI9_5_IRQHandler ; EXTI Line 9..5 DCD TIM1_BRK_IRQHandler ; TIM1 Break DCD TIM1_UP_IRQHandler ; TIM1 Update DCD TIM1_TRG_COM_IRQHandler ; TIM1 Trigger and Commutation DCD TIM1_CC_IRQHandler ; TIM1 Capture Compare ; DCD 0 ;vTimer2IntHandler ; TIM2 DCD TIM3_IRQHandler ; TIM3 DCD TIM4_IRQHandler ; TIM4 DCD I2C1_EV_IRQHandler ; I2C1 Event DCD I2C1_ER_IRQHandler ; I2C1 Error DCD I2C2_EV_IRQHandler ; I2C2 Event DCD I2C2_ER_IRQHandler ; I2C2 Error DCD SPI1_IRQHandler ; SPI1 DCD SPI2_IRQHandler ; SPI2 DCD vUARTInterruptHandler ; USART1 DCD USART2_IRQHandler ; USART2 DCD USART3_IRQHandler ; USART3 DCD EXTI15_10_IRQHandler ; EXTI Line 15..10 DCD RTCAlarm_IRQHandler ; RTC Alarm through EXTI Line DCD USBWakeUp_IRQHandler ; USB Wakeup from suspend ;-------------------added by sunq@2017.08.1 DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD TIM5_IRQHandler ; TIM5 DCD SPI3_IRQHandler ; SPI3 DCD UART4_IRQHandler ; UART4 DCD UART5_IRQHandler ; UART5 DCD TIM6_IRQHandler ; TIM6 DCD TIM7_IRQHandler ; TIM7 DCD DMA2_Channel1_IRQHandler ; DMA2 Channel1 DCD DMA2_Channel2_IRQHandler ; DMA2 Channel2 DCD DMA2_Channel3_IRQHandler ; DMA2 Channel3 DCD DMA2_Channel4_IRQHandler ; DMA2 Channel4 DCD DMA2_Channel5_IRQHandler ; DMA2 Channel5 DCD ETH_IRQHandler ; Ethernet DCD ETH_WKUP_IRQHandler ; Ethernet Wakeup through EXTI line DCD CAN2_TX_IRQHandler ; CAN2 TX DCD CAN2_RX0_IRQHandler ; CAN2 RX0 DCD CAN2_RX1_IRQHandler ; CAN2 RX1 DCD CAN2_SCE_IRQHandler ; CAN2 SCE DCD OTG_FS_IRQHandler ; USB OTG FS __Vectors_End __Vectors_Size EQU __Vectors_End - __Vectors AREA |.text|, CODE, READONLY ; Reset handler Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP ; Dummy Exception Handlers (infinite loops which can be modified) NMI_Handler PROC EXPORT NMI_Handler [WEAK] B . ENDP HardFault_Handler\ PROC EXPORT HardFault_Handler [WEAK] B . ENDP MemManage_Handler\ PROC EXPORT MemManage_Handler [WEAK] B . ENDP BusFault_Handler\ PROC EXPORT BusFault_Handler [WEAK] B . ENDP UsageFault_Handler\ PROC EXPORT UsageFault_Handler [WEAK] B . ENDP SVC_Handler PROC EXPORT SVC_Handler [WEAK] B . ENDP DebugMon_Handler\ PROC EXPORT DebugMon_Handler [WEAK] B . ENDP PendSV_Handler PROC EXPORT PendSV_Handler [WEAK] B . ENDP SysTick_Handler PROC EXPORT SysTick_Handler [WEAK] B . ENDP Default_Handler PROC EXPORT WWDG_IRQHandler [WEAK] EXPORT PVD_IRQHandler [WEAK] EXPORT TAMPER_IRQHandler [WEAK] EXPORT RTC_IRQHandler [WEAK] EXPORT FLASH_IRQHandler [WEAK] EXPORT RCC_IRQHandler [WEAK] EXPORT EXTI0_IRQHandler [WEAK] EXPORT EXTI1_IRQHandler [WEAK] EXPORT EXTI2_IRQHandler [WEAK] EXPORT EXTI3_IRQHandler [WEAK] EXPORT EXTI4_IRQHandler [WEAK] EXPORT DMAChannel1_IRQHandler [WEAK] EXPORT DMAChannel2_IRQHandler [WEAK] EXPORT DMAChannel3_IRQHandler [WEAK] EXPORT DMAChannel4_IRQHandler [WEAK] EXPORT DMAChannel5_IRQHandler [WEAK] EXPORT DMAChannel6_IRQHandler [WEAK] EXPORT DMAChannel7_IRQHandler [WEAK] EXPORT ADC_IRQHandler [WEAK] EXPORT USB_HP_CAN_TX_IRQHandler [WEAK] EXPORT USB_LP_CAN_RX0_IRQHandler [WEAK] EXPORT CAN_RX1_IRQHandler [WEAK] EXPORT CAN_SCE_IRQHandler [WEAK] EXPORT EXTI9_5_IRQHandler [WEAK] EXPORT TIM1_BRK_IRQHandler [WEAK] EXPORT TIM1_UP_IRQHandler [WEAK] EXPORT TIM1_TRG_COM_IRQHandler [WEAK] EXPORT TIM1_CC_IRQHandler [WEAK] EXPORT TIM2_IRQHandler [WEAK] EXPORT TIM3_IRQHandler [WEAK] EXPORT TIM4_IRQHandler [WEAK] EXPORT I2C1_EV_IRQHandler [WEAK] EXPORT I2C1_ER_IRQHandler [WEAK] EXPORT I2C2_EV_IRQHandler [WEAK] EXPORT I2C2_ER_IRQHandler [WEAK] EXPORT SPI1_IRQHandler [WEAK] EXPORT SPI2_IRQHandler [WEAK] EXPORT USART1_IRQHandler [WEAK] EXPORT USART2_IRQHandler [WEAK] EXPORT USART3_IRQHandler [WEAK] EXPORT EXTI15_10_IRQHandler [WEAK] EXPORT RTCAlarm_IRQHandler [WEAK] EXPORT USBWakeUp_IRQHandler [WEAK] ;-------------added @2017.09.27----------------------------- EXPORT TIM5_IRQHandler [WEAK] EXPORT SPI3_IRQHandler [WEAK] EXPORT UART4_IRQHandler [WEAK] EXPORT UART5_IRQHandler [WEAK] EXPORT TIM6_IRQHandler [WEAK] EXPORT TIM7_IRQHandler [WEAK] EXPORT DMA2_Channel1_IRQHandler [WEAK] EXPORT DMA2_Channel2_IRQHandler [WEAK] EXPORT DMA2_Channel3_IRQHandler [WEAK] EXPORT DMA2_Channel4_IRQHandler [WEAK] EXPORT DMA2_Channel5_IRQHandler [WEAK] EXPORT ETH_IRQHandler [WEAK] EXPORT ETH_WKUP_IRQHandler [WEAK] EXPORT CAN2_TX_IRQHandler [WEAK] EXPORT CAN2_RX0_IRQHandler [WEAK] EXPORT CAN2_RX1_IRQHandler [WEAK] EXPORT CAN2_SCE_IRQHandler [WEAK] EXPORT OTG_FS_IRQHandler [WEAK] WWDG_IRQHandler PVD_IRQHandler TAMPER_IRQHandler RTC_IRQHandler FLASH_IRQHandler RCC_IRQHandler EXTI0_IRQHandler EXTI1_IRQHandler EXTI2_IRQHandler EXTI3_IRQHandler EXTI4_IRQHandler DMAChannel1_IRQHandler DMAChannel2_IRQHandler DMAChannel3_IRQHandler DMAChannel4_IRQHandler DMAChannel5_IRQHandler DMAChannel6_IRQHandler DMAChannel7_IRQHandler ADC_IRQHandler USB_HP_CAN_TX_IRQHandler USB_LP_CAN_RX0_IRQHandler CAN_RX1_IRQHandler CAN_SCE_IRQHandler EXTI9_5_IRQHandler TIM1_BRK_IRQHandler TIM1_UP_IRQHandler TIM1_TRG_COM_IRQHandler TIM1_CC_IRQHandler TIM2_IRQHandler TIM3_IRQHandler TIM4_IRQHandler I2C1_EV_IRQHandler I2C1_ER_IRQHandler I2C2_EV_IRQHandler I2C2_ER_IRQHandler SPI1_IRQHandler SPI2_IRQHandler USART1_IRQHandler USART2_IRQHandler USART3_IRQHandler EXTI15_10_IRQHandler RTCAlarm_IRQHandler USBWakeUp_IRQHandler ;---------added @2017.09.27-------------------------- TIM5_IRQHandler SPI3_IRQHandler UART4_IRQHandler UART5_IRQHandler TIM6_IRQHandler TIM7_IRQHandler DMA2_Channel1_IRQHandler DMA2_Channel2_IRQHandler DMA2_Channel3_IRQHandler DMA2_Channel4_IRQHandler DMA2_Channel5_IRQHandler ETH_IRQHandler ETH_WKUP_IRQHandler CAN2_TX_IRQHandler CAN2_RX0_IRQHandler CAN2_RX1_IRQHandler CAN2_SCE_IRQHandler OTG_FS_IRQHandler B . ENDP ALIGN ; User Initial Stack &amp; Heap IF :DEF:__MICROLIB EXPORT __initial_sp EXPORT __heap_base EXPORT __heap_limit ELSE IMPORT __use_two_region_memory EXPORT __user_initial_stackheap __user_initial_stackheap LDR R0, = Heap_Mem LDR R1, =(Stack_Mem + Stack_Size) LDR R2, = (Heap_Mem + Heap_Size) LDR R3, = Stack_Mem BX LR ALIGN ENDIF END stm32F10x_it.c如下： /** ****************************************************************************** * @file Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c * @author MCD Application Team * @version V3.5.0 * @date 08-April-2011 * @brief Main Interrupt Service Routines. * This file provides template for all exceptions handler and * peripherals interrupt service routine. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x_it.h&quot; #include &quot;stm32_eth.h&quot; /* Scheduler includes */ #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; /* lwip includes */ #include &quot;lwip/sys.h&quot; /** @addtogroup STM32F10x_StdPeriph_Template * @{ */ /* Private typedef -----------------------------------------------------------*/ /* Private define ------------------------------------------------------------*/ /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ extern xSemaphoreHandle s_xSemaphore; /* Private function prototypes -----------------------------------------------*/ extern void xPortSysTickHandler(void); /* Private functions ---------------------------------------------------------*/ /******************************************************************************/ /* Cortex-M3 Processor Exceptions Handlers */ /******************************************************************************/ /** * @brief This function handles NMI exception. * @param None * @retval None */ void NMI_Handler(void) { } /** * @brief This function handles Hard Fault exception. * @param None * @retval None */ void HardFault_Handler(void) { /* Go to infinite loop when Hard Fault exception occurs */ while (1) { } } /** * @brief This function handles Memory Manage exception. * @param None * @retval None */ void MemManage_Handler(void) { /* Go to infinite loop when Memory Manage exception occurs */ while (1) { } } /** * @brief This function handles Bus Fault exception. * @param None * @retval None */ void BusFault_Handler(void) { /* Go to infinite loop when Bus Fault exception occurs */ while (1) { } } /** * @brief This function handles Usage Fault exception. * @param None * @retval None */ void UsageFault_Handler(void) { /* Go to infinite loop when Usage Fault exception occurs */ while (1) { } } /** * @brief This function handles SVCall exception. * @param None * @retval None */ void SVC_Handler(void) { } /** * @brief This function handles Debug Monitor exception. * @param None * @retval None */ void DebugMon_Handler(void) { } /** * @brief This function handles PendSVC exception. * @param None * @retval None */ void PendSV_Handler(void) { } /** * @brief This function handles SysTick Handler. * @param None * @retval None */ void SysTick_Handler(void) { } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles ETH interrupt request. * @param None * @retval None */ void ETH_IRQHandler(void) { portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; /* Frame received */ if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET) { /* Give the semaphore to wakeup LwIP task */ xSemaphoreGiveFromISR( s_xSemaphore, &amp;xHigherPriorityTaskWoken ); } /* Clear the interrupt flags. */ /* Clear the Eth DMA Rx IT pending bits */ ETH_DMAClearITPendingBit(ETH_DMA_IT_R); ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS); /* Switch tasks if necessary. */ if( xHigherPriorityTaskWoken != pdFALSE ) { portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); } } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles PPP interrupt request. * @param None * @retval None */ /*void PPP_IRQHandler(void) { }*/ /** * @} */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 移植到此基本完成。 下面验证一下移植结果。 把拷贝过来的BSP目录下的netcon.c加入到IDE的BSP组中，并修改内容如下： /** ****************************************************************************** * @file netconf.c * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief Network connection configuration ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;lwip/mem.h&quot; #include &quot;lwip/memp.h&quot; #include &quot;lwip/dhcp.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;netconf.h&quot; #include &quot;tcpip.h&quot; #include &lt;stdio.h&gt; #define _DEBUG #include &quot;dprintf.h&quot; /* Private typedef -----------------------------------------------------------*/ typedef enum { DHCP_START=0, DHCP_WAIT_ADDRESS, DHCP_ADDRESS_ASSIGNED, DHCP_TIMEOUT } DHCP_State_TypeDef; /* Private define ------------------------------------------------------------*/ #define MAX_DHCP_TRIES 5 /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ struct netif xnetif; /* network interface structure */ /* Private functions ---------------------------------------------------------*/ /** * @brief Initializes the lwIP stack * @param None * @retval None */ void LwIP_Init(void) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; /* Create tcp_ip stack thread */ tcpip_init( NULL, NULL ); /* IP address setting &amp; display on STM32_evalboard LCD*/ #ifdef USE_DHCP ipaddr.addr = 0; netmask.addr = 0; gw.addr = 0; #else IP4_ADDR(&amp;ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); #endif /* - netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask, struct ip_addr *gw, void *state, err_t (* init)(struct netif *netif), err_t (* input)(struct pbuf *p, struct netif *netif)) Adds your network interface to the netif_list. Allocate a struct netif and pass a pointer to this structure as the first argument. Give pointers to cleared ip_addr structures when using DHCP, or fill them with sane numbers otherwise. The state pointer may be NULL. The init function pointer must point to a initialization function for your ethernet netif interface. The following code illustrates it&#39;s use.*/ netif_add(&amp;xnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, &amp;ethernetif_init, &amp;tcpip_input); /* Registers the default network interface. */ netif_set_default(&amp;xnetif); /* When the netif is fully configured this function must be called.*/ netif_set_up(&amp;xnetif); } #ifdef USE_DHCP /** * @brief LwIP_DHCP_Process_Handle * @param None * @retval None */ int g_DHCP_OK_flag = 0; void LwIP_DHCP_task(void * pvParameters) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; uint32_t IPaddress; uint8_t iptab[4]; uint8_t iptxt[20]; uint8_t DHCP_state; DHCP_state = DHCP_START; for (;;) { switch (DHCP_state) { case DHCP_START: { dhcp_start(&amp;xnetif); IPaddress = 0; DHCP_state = DHCP_WAIT_ADDRESS; printf(&quot;Looking for DHCP server,please wait... \r\n&quot;); } break; case DHCP_WAIT_ADDRESS: { /* Read the new IP address */ IPaddress = xnetif.ip_addr.addr; if (IPaddress!=0) { DHCP_state = DHCP_ADDRESS_ASSIGNED; /* Stop DHCP */ dhcp_stop(&amp;xnetif); iptab[0] = (uint8_t)(IPaddress &gt;&gt; 24); iptab[1] = (uint8_t)(IPaddress &gt;&gt; 16); iptab[2] = (uint8_t)(IPaddress &gt;&gt; 8); iptab[3] = (uint8_t)(IPaddress); sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\r\nIP address[%s ]assigned by a DHCP server !\r\n&quot;,iptxt); vTaskDelete(NULL); } else { /* DHCP timeout */ if (xnetif.dhcp-&gt;tries &gt; MAX_DHCP_TRIES) { DHCP_state = DHCP_TIMEOUT; /* Stop DHCP */ dhcp_stop(&amp;xnetif); /* Static address used */ IP4_ADDR(&amp;ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 ); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); netif_set_addr(&amp;xnetif, &amp;ipaddr , &amp;netmask, &amp;gw); iptab[0] = IP_ADDR3; iptab[1] = IP_ADDR2; iptab[2] = IP_ADDR1; iptab[3] = IP_ADDR0; sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\r\nDHCP timeout \r\nStatic IP address :%s\r\n&quot;,iptxt); vTaskDelete(NULL); } { static int s=0; const char tokens[4]={&#39;-&#39;,&#39;\\&#39;,&#39;|&#39;,&#39;/&#39;}; printf(&quot;\b\b\b\b%c%c%c%c&quot;,tokens[s++%4],tokens[s%4],tokens[s%4],tokens[s%4]); } } } break; default: printf(&quot;\r\nerr: DHCP_state=%d\r\n&quot;,DHCP_state); break; } /* Toggle LED1 */ //STM_EVAL_LEDToggle(LED1);//... /* wait 250 ms */ vTaskDelay(250); } } #endif /* USE_DHCP */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 修改netconf.h，加入对DHCP的支持。 如下： /** ****************************************************************************** * @file netconf.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief This file contains all the functions prototypes for the netconf.c * file. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __NETCONF_H #define __NETCONF_H #ifdef __cplusplus extern &quot;C&quot; { #endif #define USE_DHCP // @2017.09.27 /* Includes ------------------------------------------------------------------*/ /* Exported types ------------------------------------------------------------*/ extern struct netif xnetif; /* Exported constants --------------------------------------------------------*/ /* Exported macro ------------------------------------------------------------*/ /* Exported functions ------------------------------------------------------- */ void LwIP_Init(void); void LwIP_DHCP_task(void * pvParameters); #ifdef __cplusplus } #endif #endif /* __NETCONF_H */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ main.c文件修改如下： #include &quot;stm32f10x.h&quot; #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; #include &quot;semphr.h&quot; #include &quot;utils.h&quot; #define _DEBUG #include &quot;dprintf.h&quot; void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; /* Configure IO connected to LD1, LD2, LD3 and LD4 leds *********************/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); } //?????? void NVIC_Configuration(void) { /* Configure the NVIC Preemption Priority Bits */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0); #ifdef VECT_TAB_RAM /* Set the Vector Table base location at 0x20000000 */ NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); #else /* VECT_TAB_FLASH */ /* Set the Vector Table base location at 0x08000000 */ NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); #endif } void RCC_Configuration(void) { SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |RCC_APB2Periph_ADC1 | RCC_APB2Periph_AFIO |RCC_APB2Periph_SPI1, ENABLE ); // RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALL ,ENABLE ); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4 |RCC_APB1Periph_USART3|RCC_APB1Periph_TIM2 , ENABLE ); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); } void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { /* This function will get called if a task overflows its stack. If the parameters are corrupt then inspect pxCurrentTCB to find which was the offending task. */ ( void ) pxTask; printf(&quot;ÈÎÎñ£º%s ·¢ÏÖÕ»Òç³ö\n&quot;, pcTaskName); for( ;; ); } /*-----------------------------------------------------------*/ void vApplicationTickHook( void ) { } static void prvSetupHardware( void ) { /* Start with the clocks in their expected state. */ RCC_DeInit(); /* Enable HSE (high speed external clock). */ RCC_HSEConfig( RCC_HSE_ON ); /* Wait till HSE is ready. */ while( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET ) { } /* 2 wait states required on the flash. */ *( ( unsigned long * ) 0x40022000 ) = 0x02; /* HCLK = SYSCLK */ RCC_HCLKConfig( RCC_SYSCLK_Div1 ); /* PCLK2 = HCLK */ RCC_PCLK2Config( RCC_HCLK_Div1 ); /* PCLK1 = HCLK/2 */ RCC_PCLK1Config( RCC_HCLK_Div2 ); /* Enable PLL. */ RCC_PLLCmd( ENABLE ); /* Wait till PLL is ready. */ while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) { } /* Select PLL as system clock source. */ RCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK ); /* Wait till PLL is used as system clock source. */ while( RCC_GetSYSCLKSource() != 0x08 ) { } /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */ RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE ); /* Set the Vector Table base address at 0x08000000 */ NVIC_SetVectorTable( NVIC_VectTab_FLASH, 0x0 ); NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 ); /* Configure HCLK clock as SysTick clock source. */ SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK ); GPIO_Configuration(); } #define ledSTACK_SIZE configMINIMAL_STACK_SIZE #define ledFLASH_RATE_BASE ( ( TickType_t ) 333 ) static TaskHandle_t xHandleTaskLED=NULL; static void vTaskLED(void* pvParameters) { TickType_t xFlashRate, xLastFlashTime; xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) 2 ); xFlashRate /= portTICK_PERIOD_MS; xFlashRate /= ( TickType_t ) 2; xLastFlashTime = xTaskGetTickCount(); while(1) { /* Turn on LD1 */ GPIO_SetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); /* Turn off LD1 */ GPIO_ResetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); } } #include &quot;serial.h&quot; #include &quot;integer.h&quot; #include &quot;diskio.h&quot; #include &quot;ff.h&quot; #include &quot;sdcard.h&quot; #include &quot;common.h&quot; #include &lt;stdio.h&gt; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) /* Handle to the com port used by both tasks. */ static xComPortHandle xPort = NULL; /* The Rx task will block on the Rx queue for a long period. */ #define comRX_BLOCK_TIME ( ( TickType_t ) 0xffff ) static void sd_card_task(void* pvParameters) { signed char key = 0; GPIO_ResetBits(GPIOF, GPIO_Pin_6); //LED1 on while(1) { printf(&quot;\r\n============ ÇëÑ¡Ôñ...===============\r\n\n&quot;); printf(&quot;¸ñ Ê½ »¯------------------------------- 1\r\n\n&quot;); printf(&quot;´´½¨ÎÄ¼þ------------------------------- 2\r\n\n&quot;); printf(&quot;É¾³ýÎÄ¼þ ------------------------------ 3\r\n\n&quot;); printf(&quot;ÁÐ±íÎÄ¼þ------------------------------- 4\r\n\n&quot;); printf(&quot;ÖØÆôÏµÍ³ ------------------------------ 5\r\n\n&quot;); printf(&quot;´ÅÅÌÐÅÏ¢------------------------------- 6\r\n\n&quot;); printf(&quot;´´½¨Ä¿Â¼------------------------------- 7\r\n\n&quot;); printf(&quot;±à¼­ÎÄ¼þ------------------------------- 8\r\n\n&quot;); printf(&quot;¶ÁÈ¡ÎÄ¼þ------------------------------- 9\r\n\n&quot;); printf(&quot;========================================\r\n\n&quot;); xSerialGetChar( xPort, &amp;key, comRX_BLOCK_TIME ); if (key == 0x31) //Format FS { printf(&quot;\r\n----1----&quot;); format_disk(); } else if (key == 0x32) //Creat File { printf(&quot;\r\n----2----&quot;); creat_file(); } else if (key == 0x33) //Delete File { printf(&quot;\r\n----3----&quot;); delete_file(); } else if (key == 0x34) //List File { printf(&quot;\r\n----4----&quot;); list_file(); } else if (key == 0x35) //Reset FS { printf(&quot;\r\n----5----&quot;); Sys_Soft_Reset(); } else if (key == 0x36) //Disk info { printf(&quot;\r\n----6----&quot;); get_disk_info(); } else if (key == 0x37) //Creat Dir { printf(&quot;\r\n----7----&quot;); creat_dir(); } else if (key == 0x38) //Edit File { printf(&quot;\r\n----8----&quot;); edit_file(); } else if (key == 0x39) //Read File { printf(&quot;\r\n----9----&quot;); read_file(); } else { printf(&quot;\r\n----%c----&quot;,key); printf(&quot;\r\nÖ»½ÓÊÜ1-9ÃüÁî£¬ÇëÖØÐÂÊäÈë&quot;); } } } #include &quot;netconf.h&quot; #include &quot;stm32_eth.h&quot; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) #define DHCP_TASK_PRIO ( tskIDLE_PRIORITY + 2 ) static TaskHandle_t xHandleTaskSystemInit=NULL; static void System_Init_task(void* pvParameters) { xTaskCreate(vTaskLED,&quot;vTaskLED&quot;,ledSTACK_SIZE,NULL,3,&amp;xHandleTaskLED); printf(&quot;2 led demos tasks are created !\r\n&quot;); //xTaskCreate(sd_card_task,&quot;vTaskSDCard&quot;,1024,NULL,SYSTEM_INIT_TASK_PRIO,NULL); //printf(&quot;The task of SDCard is created!\r\n&quot;); printf(&quot;eth hardware initialzing...\r\n&quot;); FreeRTOS_Hardware_STMS32_ETH_Init(); printf(&quot;eth hardware ok\r\nstarting LwIP stack...\r\n&quot;); /* Initilaize the LwIP stack */ LwIP_Init(); printf(&quot;LwIP stack started !\r\n&quot;); /* Initialize tcp echo server */ //tcpecho_init(); #ifdef USE_DHCP /* Start DHCPClient */ xTaskCreate(LwIP_DHCP_task, &quot;DHCPClient&quot;, configMINIMAL_STACK_SIZE * 2, NULL,DHCP_TASK_PRIO, NULL); #endif printf(&quot;LwIP_DHCP_task is created !\r\n&quot;); vTaskDelete(xHandleTaskSystemInit); } int main(void) { __set_PRIMASK(1);//½ûÖ¹È«¾ÖÖÐ¶Ï prvSetupHardware(); FreeRTOS_printf_service_init(); printf(&quot;###############################################\r\n&quot;); printf(&quot;## hello! welcome to FreeRTOS v9.0.0 ##\r\n&quot;); printf(&quot;###############################################\r\n&quot;); printf(&quot;\r\n\r\n&quot;); SD_Init(); InitMQTTServerInfo(); xTaskCreate(System_Init_task,&quot;vTaskSystemInit&quot;,100,NULL,SYSTEM_INIT_TASK_PRIO,&amp;xHandleTaskSystemInit); vTaskStartScheduler();//Æô¶¯ÈÎÎñµ÷¶ÈÆ÷ } /******************* (C) COPYRIGHT 2012 WildFire Team *****END OF FILE************/ 编译完成后，把hex档烧到开发板上，上电运行。看到： LwIP已经运行起来了。路由分配了ip：10.0.0.109 打开一个cmd窗口，ping一下开发板： 可以看到ping的结果还是很稳定的。 本文完整的源代码下载地址： STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1.rar 下一篇将移植MQTT，并对步进电机控制器进行控制。 阅读更多" />
<meta property="og:description" content="本文在前一篇的基础上，进行基于FreeRTOS的LwIP-1.4.1版本移植、 本文使用的网卡PHY芯片型号是DP83848，工作在MII接口模式，时钟频率是25MHz。 现在的LwIP版本已经发展到了lwIP 2.0.3 版。 但是看了具体的代码后发现一些跟1.4.1对比之下不同之处，其中包含但不全部： 1、IPv4和IPv6的实现代码混合起来，而1.4.1是分开的，通过预处理宏可以分开编译。 2、增加了一些常用的网络组件或应用程序，其中包括了基于tcp接口实现的MQTT协议。 本人也曾试图移植lwIP 2.0.2，发现IPv6实现会被编译进去，并且由此产生一些函数调用问题，在我们的固件库中以及mdk的库中不支持相关函数，另外，本项目用的芯片并不支持IPv6，而相关代码会增加ROM空间的占用，没有必要，而LwIP2.0.2以上的版本所带的MQTT协议实现也可以移植过来到LwIP-1.4.1上使用。 因此还是选用LwIP的1.4.1这个经典版本。但后面的MQTT协议实现没有用LwIP2.0.2版的实现代码，而是比较接近paho.mqtt.embedded-c版的一个实现。 以下是具体移植过程： LwIP的官方网站：http://savannah.nongnu.org/projects/lwip/ LwIP-1.4.1下载地址：http://download.savannah.nongnu.org/releases/lwip/lwip-1.4.1.zip 或：http://ftp.yzu.edu.tw/nongnu/lwip/lwip-1.4.1.zip 或：https://gitee.com/null_926_6734/CongXiangYingGuanFangHuoQiJingXiangXiaZaiDeMouXieYuanDaiMa/raw/master/lwip-1.4.1.zip contrib-1.4.1.zip contrib-1.4.1里面含有官方的移植示例，有windows和unix操作系统下的移植，和某些非操作系统的移植。 在本项目的移植中需要用到一些头文件，可以在contrib-1.4.1中找到。 本文参考了网络上的源代码： STM32_FreeRTOS_LwIP 这份代码的说明是这样的： 说明： 在神州五号STM32F107VC开发板上移植了最新的FreeRTOS-V8.1.2操作系统，并在该系统上移植了最新的LwIP-1.4.1协议栈，能够ping通，但是系统的稳定性没有测试，仅供使用者参考。 本人提供的备用下载地址： STM32_FreeRTOS_LwIP.rar 移植之前，我们要确认一下网卡芯片的工作模式MII接口模式。根据金牛开发板官方驱动代码提供的代码 看到该开发板的PHY芯片DP83848跟STM32F107VC引脚的对应关系如下： lwip-1.4.1.zip代码包解压之后放到third_party目录下。 在IDE上增加一个组，命名为：third_party/LwIP。 1、把third_party\lwip-1.4.1\src\core下的c文件加入工程中； 2、把third_party\lwip-1.4.1\src\core\ipv4下的c文件加入到工程中； 3、把third_party\lwip-1.4.1\src\netif下的c文件加入到工程中； 4、把third_party\lwip-1.4.1\src\api下的c文件加入到工程中； 5、把一下路径加入包含路径中： ..\third_party\lwip-1.4.1\src\include;..\third_party\lwip-1.4.1\src\include\lwip;..\third_party\lwip-1.4.1\src\include\arch;..\third_party\lwip-1.4.1\src\include\ipv4;..\third_party\lwip-1.4.1\src\include\netif; 此时编译，会出现错误，提示找不到lwipopts.h文件。 我们直接在STM32_FreeRTOS_LwIP这份源代码中直接复制过来，它位置在 STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\App下面，顺便把netconf.h和netconf.c复制过来，放到BSP目录下： 关于lwipopts.h的配置说明请参考： http://blog.csdn.net/slj_win/article/details/16959055 我们拷贝过来的这份lwipopts.h中的配置，是实际使用的时候，会占用大部分的RAM，以至于FreeRTOS的任务经常出现栈溢出或直接跑飞，因此需要稍微减少内存的使用，做一些修改。 还有就是需要添加对DNS的支持： #define LWIP_DNS 1 和对接收数据定时窗口的支持： #define LWIP_SO_RCVTIMEO 1 修改后如下： /** ****************************************************************************** * @file lwipopts.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief lwIP Options Configuration. * This file is based on Utilities\lwip_v1.3.2\src\include\lwip\opt.h * and contains the lwIP configuration for the STM32F2x7 demonstration. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ #ifndef __LWIPOPTS_H__ #define __LWIPOPTS_H__ /** * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain * critical regions during buffer allocation, deallocation and memory * allocation and deallocation. */ #define SYS_LIGHTWEIGHT_PROT 0 #define ETHARP_TRUST_IP_MAC 0 #define IP_REASSEMBLY 0 #define IP_FRAG 0 //#define ARP_QUEUEING 0 /* ---------- ARP options ---------- */ #define LWIP_ARP 1 #define ARP_TABLE_SIZE 10 #define ARP_QUEUEING 1 /** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use lwIP facilities. */ #define NO_SYS 0 /* ---------- Memory options ---------- */ /* MEM_ALIGNMENT: should be set to the alignment of the CPU for which lwIP is compiled. 4 byte alignment -&gt; define MEM_ALIGNMENT to 4, 2 byte alignment -&gt; define MEM_ALIGNMENT to 2. */ #define MEM_ALIGNMENT 4 /* MEM_SIZE: the size of the heap memory. If the application will send a lot of data that needs to be copied, this should be set high. */ #define MEM_SIZE (4*1024) // (5*1024) @2017.08.26 /* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application sends a lot of data out of ROM (or other static memory), this should be set high. */ #define MEMP_NUM_PBUF 100 /* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One per active UDP &quot;connection&quot;. */ #define MEMP_NUM_UDP_PCB 6 /* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections. */ #define MEMP_NUM_TCP_PCB 10 /* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */ #define MEMP_NUM_TCP_PCB_LISTEN 5 /* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */ #define MEMP_NUM_TCP_SEG 20 /* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */ #define MEMP_NUM_SYS_TIMEOUT 10 /* ---------- Pbuf options ---------- */ /* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */ #define PBUF_POOL_SIZE 10 // 20 @2017.08.26 /* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */ #define PBUF_POOL_BUFSIZE 500 /* ---------- TCP options ---------- */ #define LWIP_TCP 1 #define TCP_TTL 255 /* Controls if TCP should queue segments that arrive out of order. Define to 0 if your device is low on memory. */ #define TCP_QUEUE_OOSEQ 1 /* TCP Maximum segment size. */ #define TCP_MSS (1500 - 40) /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */ /* TCP sender buffer space (bytes). */ #define TCP_SND_BUF (5*TCP_MSS) /* TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */ #define TCP_SND_QUEUELEN (4* TCP_SND_BUF/TCP_MSS) /* TCP receive window. */ #define TCP_WND (2*TCP_MSS) /* ---------- ICMP options ---------- */ #define LWIP_ICMP 1 /* ---------- DHCP options ---------- */ /* Define LWIP_DHCP to 1 if you want DHCP configuration of interfaces. DHCP is not implemented in lwIP 0.5.1, however, so turning this on does currently not work. */ #define LWIP_DHCP 1 #define LWIP_DNS 1 //added @2017.08.17 /* Enable SO_RCVTIMEO processing. */ #define LWIP_SO_RCVTIMEO 1 //added @2017.08.18 #define DHCP_DOES_ARP_CHECK (LWIP_DHCP) /* ---------- UDP options ---------- */ #define LWIP_UDP 1 #define UDP_TTL 255 /* ---------- Statistics options ---------- */ #define LWIP_STATS 0 #define LWIP_PROVIDE_ERRNO 1 /* -------------------------------------- ---------- Checksum options ---------- -------------------------------------- */ /* The STM32F2x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware: - To use this feature let the following define uncommented. - To disable it and process by CPU comment the the checksum. */ #define CHECKSUM_BY_HARDWARE 1 #ifdef CHECKSUM_BY_HARDWARE /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 0 /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 0 /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 0 #define CHECKSUM_GEN_ICMP 0 /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 0 /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 0 /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 0 #else /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 1 /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 1 /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 1 #define CHECKSUM_GEN_ICMP 1 /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 1 /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 1 /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 1 #endif /* ---------------------------------------------- ---------- Sequential layer options ---------- ---------------------------------------------- */ /** * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c) */ #define LWIP_NETCONN 1 /* ------------------------------------ ---------- Socket options ---------- ------------------------------------ */ /** * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c) */ #define LWIP_SOCKET 1 /* ----------------------------------- ---------- DEBUG options ---------- ----------------------------------- */ #define LWIP_DEBUG 0 /* --------------------------------- ---------- OS options ---------- --------------------------------- */ #define TCPIP_THREAD_STACKSIZE 1000 #define TCPIP_MBOX_SIZE 5 #define DEFAULT_UDP_RECVMBOX_SIZE 2000 #define DEFAULT_TCP_RECVMBOX_SIZE 2000 #define DEFAULT_ACCEPTMBOX_SIZE 2000 #define DEFAULT_THREAD_STACKSIZE 500 #define TCPIP_THREAD_PRIO (configMAX_PRIORITIES - 2) #endif /* __LWIPOPTS_H__ */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 还有跟移植相关的部分代码在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\lwip-1.4.1\src\include\arch目录下，把整个文件夹都复制过来： 放在我们的相应目录下，并把其中的sys_arch.c加入到IDE的third_party/LwIP组中。 此时编译一下，会出现一堆警告，其中一个是： ..\third_party\lwip-1.4.1\src\core\dns.c(241): warning: #223-D: function &quot;LWIP_PLATFORM_DIAG&quot; declared implicitly 这是LWIP_PLATFORM_DIAG这个宏没有定义的原因。 可以在third_party\lwip-1.4.1\src\include\lwip\debug.h这个文件中定义。 找到： #define LWIP_DEBUGF(debug, message) do { \ 这一行，在它前面加上： #include &lt;stdio.h&gt; #define LWIP_PLATFORM_DIAG printf 并找到： LWIP_PLATFORM_DIAG(message); \ 修改为： LWIP_PLATFORM_DIAG message ; \ 再编译，出现错误： ..\third_party\lwip-1.4.1\src\include\lwip/sys.h(113): error: #20: identifier &quot;sys_mutex_t&quot; is undefined 解决方法是在 #if LWIP_COMPAT_MUTEX 前面定义这个宏： #define LWIP_COMPAT_MUTEX 1 编译，通过。 这是LwIP协议栈的主体部分OK了，但是还没有跟FreeRTOS对接好，另外没有把网卡驱动搞定。下面一步步完成吧。 接下来，首先把网卡驱动搞定。这部分在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\STM32_ETH_Driver下的源码基础上做修改。 把整个STM32_ETH_Driver文件夹复制到我们的项目根目录下，在IDE上添加一个组，命名为STM32_ETH_Driver，把项目中的STM32_ETH_Driver\src\stm32_eth.c加入到组中。 把..\STM32_ETH_Driver\inc加入包含路径中位置如图所示： 接下来要修改stm32_eth.h和stm32_eth.c。 stm32_eth.c主要是对网卡控制器进行操作，以对网卡芯片初始化。 stm32_eth.h： /** ****************************************************************************** * @file stm32_eth.h * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file contains all the functions prototypes for the Ethernet * firmware library. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __STM32_ETH_H #define __STM32_ETH_H #ifdef __cplusplus extern &quot;C&quot; { #endif /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x.h&quot; /** @addtogroup STM32_ETH_Driver * @{ */ /** @defgroup ETH_Exported_Types * @{ */ /** * @brief ETH MAC Init structure definition * @note The user should not configure all the ETH_InitTypeDef structure&#39;s fields. * By calling the ETH_StructInit function the structure¡¯s fields are set to their default values. * Only the parameters that will be set to a non-default value should be configured. */ typedef struct { /** * @brief / * MAC */ uint32_t ETH_AutoNegotiation; /*!&lt; Selects or not the AutoNegotiation mode for the external PHY The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps) and the mode (half/full-duplex). This parameter can be a value of @ref ETH_AutoNegotiation */ uint32_t ETH_Watchdog; /*!&lt; Selects or not the Watchdog timer When enabled, the MAC allows no more then 2048 bytes to be received. When disabled, the MAC can receive up to 16384 bytes. This parameter can be a value of @ref ETH_watchdog */ uint32_t ETH_Jabber; /*!&lt; Selects or not Jabber timer When enabled, the MAC allows no more then 2048 bytes to be sent. When disabled, the MAC can send up to 16384 bytes. This parameter can be a value of @ref ETH_Jabber */ uint32_t ETH_InterFrameGap; /*!&lt; Selects the minimum IFG between frames during transmission This parameter can be a value of @ref ETH_Inter_Frame_Gap */ uint32_t ETH_CarrierSense; /*!&lt; Selects or not the Carrier Sense This parameter can be a value of @ref ETH_Carrier_Sense */ uint32_t ETH_Speed; /*!&lt; Sets the Ethernet speed: 10/100 Mbps This parameter can be a value of @ref ETH_Speed */ uint32_t ETH_ReceiveOwn; /*!&lt; Selects or not the ReceiveOwn ReceiveOwn allows the reception of frames when the TX_EN signal is asserted in Half-Duplex mode This parameter can be a value of @ref ETH_Receive_Own */ uint32_t ETH_LoopbackMode; /*!&lt; Selects or not the internal MAC MII Loopback mode This parameter can be a value of @ref ETH_Loop_Back_Mode */ uint32_t ETH_Mode; /*!&lt; Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode This parameter can be a value of @ref ETH_Duplex_Mode */ uint32_t ETH_ChecksumOffload; /*!&lt; Selects or not the IPv4 checksum checking for received frame payloads&#39; TCP/UDP/ICMP headers. This parameter can be a value of @ref ETH_Checksum_Offload */ uint32_t ETH_RetryTransmission; /*!&lt; Selects or not the MAC attempt retries transmission, based on the settings of BL, when a colision occurs (Half-Duplex mode) This parameter can be a value of @ref ETH_Retry_Transmission */ uint32_t ETH_AutomaticPadCRCStrip; /*!&lt; Selects or not the Automatic MAC Pad/CRC Stripping This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ uint32_t ETH_BackOffLimit; /*!&lt; Selects the BackOff limit value This parameter can be a value of @ref ETH_Back_Off_Limit */ uint32_t ETH_DeferralCheck; /*!&lt; Selects or not the deferral check function (Half-Duplex mode) This parameter can be a value of @ref ETH_Deferral_Check */ uint32_t ETH_ReceiveAll; /*!&lt; Selects or not all frames reception by the MAC (No fitering) This parameter can be a value of @ref ETH_Receive_All */ uint32_t ETH_SourceAddrFilter; /*!&lt; Selects the Source Address Filter mode This parameter can be a value of @ref ETH_Source_Addr_Filter */ uint32_t ETH_PassControlFrames; /*!&lt; Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames) This parameter can be a value of @ref ETH_Pass_Control_Frames */ uint32_t ETH_BroadcastFramesReception; /*!&lt; Selects or not the reception of Broadcast Frames This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */ uint32_t ETH_DestinationAddrFilter; /*!&lt; Sets the destination filter mode for both unicast and multicast frames This parameter can be a value of @ref ETH_Destination_Addr_Filter */ uint32_t ETH_PromiscuousMode; /*!&lt; Selects or not the Promiscuous Mode This parameter can be a value of @ref ETH_Promiscuous_Mode */ uint32_t ETH_MulticastFramesFilter; /*!&lt; Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ uint32_t ETH_UnicastFramesFilter; /*!&lt; Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ uint32_t ETH_HashTableHigh; /*!&lt; This field holds the higher 32 bits of Hash table. */ uint32_t ETH_HashTableLow; /*!&lt; This field holds the lower 32 bits of Hash table. */ uint32_t ETH_PauseTime; /*!&lt; This field holds the value to be used in the Pause Time field in the transmit control frame */ uint32_t ETH_ZeroQuantaPause; /*!&lt; Selects or not the automatic generation of Zero-Quanta Pause Control frames This parameter can be a value of @ref ETH_Zero_Quanta_Pause */ uint32_t ETH_PauseLowThreshold; /*!&lt; This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Frame This parameter can be a value of @ref ETH_Pause_Low_Threshold */ uint32_t ETH_UnicastPauseFrameDetect; /*!&lt; Selects or not the MAC detection of the Pause frames (with MAC Address0 unicast address and unique multicast address) This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */ uint32_t ETH_ReceiveFlowControl; /*!&lt; Enables or disables the MAC to decode the received Pause frame and disable its transmitter for a specified time (Pause Time) This parameter can be a value of @ref ETH_Receive_Flow_Control */ uint32_t ETH_TransmitFlowControl; /*!&lt; Enables or disables the MAC to transmit Pause frames (Full-Duplex mode) or the MAC back-pressure operation (Half-Duplex mode) This parameter can be a value of @ref ETH_Transmit_Flow_Control */ uint32_t ETH_VLANTagComparison; /*!&lt; Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for comparison and filtering This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ uint32_t ETH_VLANTagIdentifier; /*!&lt; Holds the VLAN tag identifier for receive frames */ /** * @brief / * DMA */ uint32_t ETH_DropTCPIPChecksumErrorFrame; /*!&lt; Selects or not the Dropping of TCP/IP Checksum Error Frames This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ uint32_t ETH_ReceiveStoreForward; /*!&lt; Enables or disables the Receive store and forward mode This parameter can be a value of @ref ETH_Receive_Store_Forward */ uint32_t ETH_FlushReceivedFrame; /*!&lt; Enables or disables the flushing of received frames This parameter can be a value of @ref ETH_Flush_Received_Frame */ uint32_t ETH_TransmitStoreForward; /*!&lt; Enables or disables Transmit store and forward mode This parameter can be a value of @ref ETH_Transmit_Store_Forward */ uint32_t ETH_TransmitThresholdControl; /*!&lt; Selects or not the Transmit Threshold Control This parameter can be a value of @ref ETH_Transmit_Threshold_Control */ uint32_t ETH_ForwardErrorFrames; /*!&lt; Selects or not the forward to the DMA of erroneous frames This parameter can be a value of @ref ETH_Forward_Error_Frames */ uint32_t ETH_ForwardUndersizedGoodFrames; /*!&lt; Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error and length less than 64 bytes) including pad-bytes and CRC) This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */ uint32_t ETH_ReceiveThresholdControl; /*!&lt; Selects the threshold level of the Receive FIFO This parameter can be a value of @ref ETH_Receive_Threshold_Control */ uint32_t ETH_SecondFrameOperate; /*!&lt; Selects or not the Operate on second frame mode, which allows the DMA to process a second frame of Transmit data even before obtaining the status for the first frame. This parameter can be a value of @ref ETH_Second_Frame_Operate */ uint32_t ETH_AddressAlignedBeats; /*!&lt; Enables or disables the Address Aligned Beats This parameter can be a value of @ref ETH_Address_Aligned_Beats */ uint32_t ETH_FixedBurst; /*!&lt; Enables or disables the AHB Master interface fixed burst transfers This parameter can be a value of @ref ETH_Fixed_Burst */ uint32_t ETH_RxDMABurstLength; /*!&lt; Indicates the maximum number of beats to be transferred in one Rx DMA transaction This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ uint32_t ETH_TxDMABurstLength; /*!&lt; Indicates sthe maximum number of beats to be transferred in one Tx DMA transaction This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */ uint32_t ETH_DescriptorSkipLength; /*!&lt; Specifies the number of word to skip between two unchained descriptors (Ring mode) */ uint32_t ETH_DMAArbitration; /*!&lt; Selects the DMA Tx/Rx arbitration This parameter can be a value of @ref ETH_DMA_Arbitration */ }ETH_InitTypeDef; /**--------------------------------------------------------------------------**/ /** * @brief DMA descriptors types */ /**--------------------------------------------------------------------------**/ /** * @brief ETH DMA Desciptors data structure definition */ typedef struct { uint32_t Status; /*!&lt; Status */ uint32_t ControlBufferSize; /*!&lt; Control and Buffer1, Buffer2 lengths */ uint32_t Buffer1Addr; /*!&lt; Buffer1 address pointer */ uint32_t Buffer2NextDescAddr; /*!&lt; Buffer2 or next descriptor address pointer */ } ETH_DMADESCTypeDef; /** * @} */ /** @defgroup ETH_Exported_Constants * @{ */ /**--------------------------------------------------------------------------**/ /** * @brief ETH Frames defines */ /**--------------------------------------------------------------------------**/ /** @defgroup ENET_Buffers_setting * @{ */ #define ETH_MAX_PACKET_SIZE 1520 /*!&lt; ETH_HEADER + ETH_EXTRA + MAX_ETH_PAYLOAD + ETH_CRC */ #define ETH_HEADER 14 /*!&lt; 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */ #define ETH_CRC 4 /*!&lt; Ethernet CRC */ #define ETH_EXTRA 2 /*!&lt; Extra bytes in some cases */ #define VLAN_TAG 4 /*!&lt; optional 802.1q VLAN Tag */ #define MIN_ETH_PAYLOAD 46 /*!&lt; Minimum Ethernet payload size */ #define MAX_ETH_PAYLOAD 1500 /*!&lt; Maximum Ethernet payload size */ #define JUMBO_FRAME_PAYLOAD 9000 /*!&lt; Jumbo frame payload size */ /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA descriptors registers bits definition */ /**--------------------------------------------------------------------------**/ /** @code DMA Tx Desciptor ----------------------------------------------------------------------------------------------- TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] | ----------------------------------------------------------------------------------------------- TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] | ----------------------------------------------------------------------------------------------- TDES2 | Buffer1 Address [31:0] | ----------------------------------------------------------------------------------------------- TDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | ----------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of TDES0 register: DMA Tx descriptor status register */ #define ETH_DMATxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMATxDesc_IC ((uint32_t)0x40000000) /*!&lt; Interrupt on Completion */ #define ETH_DMATxDesc_LS ((uint32_t)0x20000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FS ((uint32_t)0x10000000) /*!&lt; First Segment */ #define ETH_DMATxDesc_DC ((uint32_t)0x08000000) /*!&lt; Disable CRC */ #define ETH_DMATxDesc_DP ((uint32_t)0x04000000) /*!&lt; Disable Padding */ #define ETH_DMATxDesc_TTSE ((uint32_t)0x02000000) /*!&lt; Transmit Time Stamp Enable */ #define ETH_DMATxDesc_CIC ((uint32_t)0x00C00000) /*!&lt; Checksum Insertion Control: 4 cases */ #define ETH_DMATxDesc_CIC_ByPass ((uint32_t)0x00000000) /*!&lt; Do Nothing: Checksum Engine is bypassed */ #define ETH_DMATxDesc_CIC_IPV4Header ((uint32_t)0x00400000) /*!&lt; IPV4 header Checksum Insertion */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP Checksum Insertion calculated over segment only */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Full ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP Checksum Insertion fully calculated */ #define ETH_DMATxDesc_TER ((uint32_t)0x00200000) /*!&lt; Transmit End of Ring */ #define ETH_DMATxDesc_TCH ((uint32_t)0x00100000) /*!&lt; Second Address Chained */ #define ETH_DMATxDesc_TTSS ((uint32_t)0x00020000) /*!&lt; Tx Time Stamp Status */ #define ETH_DMATxDesc_IHE ((uint32_t)0x00010000) /*!&lt; IP Header Error */ #define ETH_DMATxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */ #define ETH_DMATxDesc_JT ((uint32_t)0x00004000) /*!&lt; Jabber Timeout */ #define ETH_DMATxDesc_FF ((uint32_t)0x00002000) /*!&lt; Frame Flushed: DMA/MTL flushed the frame due to SW flush */ #define ETH_DMATxDesc_PCE ((uint32_t)0x00001000) /*!&lt; Payload Checksum Error */ #define ETH_DMATxDesc_LCA ((uint32_t)0x00000800) /*!&lt; Loss of Carrier: carrier lost during tramsmission */ #define ETH_DMATxDesc_NC ((uint32_t)0x00000400) /*!&lt; No Carrier: no carrier signal from the tranceiver */ #define ETH_DMATxDesc_LCO ((uint32_t)0x00000200) /*!&lt; Late Collision: transmission aborted due to collision */ #define ETH_DMATxDesc_EC ((uint32_t)0x00000100) /*!&lt; Excessive Collision: transmission aborted after 16 collisions */ #define ETH_DMATxDesc_VF ((uint32_t)0x00000080) /*!&lt; VLAN Frame */ #define ETH_DMATxDesc_CC ((uint32_t)0x00000078) /*!&lt; Collision Count */ #define ETH_DMATxDesc_ED ((uint32_t)0x00000004) /*!&lt; Excessive Deferral */ #define ETH_DMATxDesc_UF ((uint32_t)0x00000002) /*!&lt; Underflow Error: late data arrival from the memory */ #define ETH_DMATxDesc_DB ((uint32_t)0x00000001) /*!&lt; Deferred Bit */ /** * @brief Bit definition of TDES1 register */ #define ETH_DMATxDesc_TBS2 ((uint32_t)0x1FFF0000) /*!&lt; Transmit Buffer2 Size */ #define ETH_DMATxDesc_TBS1 ((uint32_t)0x00001FFF) /*!&lt; Transmit Buffer1 Size */ /** * @brief Bit definition of TDES2 register */ #define ETH_DMATxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of TDES3 register */ #define ETH_DMATxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /** * @} */ /** @defgroup DMA_Rx_descriptor * @{ */ /** @code DMA Rx Desciptor -------------------------------------------------------------------------------------------------------------------- RDES0 | OWN(31) | Status [30:0] | --------------------------------------------------------------------------------------------------------------------- RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] | --------------------------------------------------------------------------------------------------------------------- RDES2 | Buffer1 Address [31:0] | --------------------------------------------------------------------------------------------------------------------- RDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | --------------------------------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of RDES0 register: DMA Rx descriptor status register */ #define ETH_DMARxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMARxDesc_AFM ((uint32_t)0x40000000) /*!&lt; DA Filter Fail for the rx frame */ #define ETH_DMARxDesc_FL ((uint32_t)0x3FFF0000) /*!&lt; Receive descriptor frame length */ #define ETH_DMARxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */ #define ETH_DMARxDesc_DE ((uint32_t)0x00004000) /*!&lt; Desciptor error: no more descriptors for receive frame */ #define ETH_DMARxDesc_SAF ((uint32_t)0x00002000) /*!&lt; SA Filter Fail for the received frame */ #define ETH_DMARxDesc_LE ((uint32_t)0x00001000) /*!&lt; Frame size not matching with length field */ #define ETH_DMARxDesc_OE ((uint32_t)0x00000800) /*!&lt; Overflow Error: Frame was damaged due to buffer overflow */ #define ETH_DMARxDesc_VLAN ((uint32_t)0x00000400) /*!&lt; VLAN Tag: received frame is a VLAN frame */ #define ETH_DMARxDesc_FS ((uint32_t)0x00000200) /*!&lt; First descriptor of the frame */ #define ETH_DMARxDesc_LS ((uint32_t)0x00000100) /*!&lt; Last descriptor of the frame */ #define ETH_DMARxDesc_IPV4HCE ((uint32_t)0x00000080) /*!&lt; IPC Checksum Error: Rx Ipv4 header checksum error */ #define ETH_DMARxDesc_LC ((uint32_t)0x00000040) /*!&lt; Late collision occurred during reception */ #define ETH_DMARxDesc_FT ((uint32_t)0x00000020) /*!&lt; Frame type - Ethernet, otherwise 802.3 */ #define ETH_DMARxDesc_RWT ((uint32_t)0x00000010) /*!&lt; Receive Watchdog Timeout: watchdog timer expired during reception */ #define ETH_DMARxDesc_RE ((uint32_t)0x00000008) /*!&lt; Receive error: error reported by MII interface */ #define ETH_DMARxDesc_DBE ((uint32_t)0x00000004) /*!&lt; Dribble bit error: frame contains non int multiple of 8 bits */ #define ETH_DMARxDesc_CE ((uint32_t)0x00000002) /*!&lt; CRC error */ #define ETH_DMARxDesc_MAMPCE ((uint32_t)0x00000001) /*!&lt; Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */ /** * @brief Bit definition of RDES1 register */ #define ETH_DMARxDesc_DIC ((uint32_t)0x80000000) /*!&lt; Disable Interrupt on Completion */ #define ETH_DMARxDesc_RBS2 ((uint32_t)0x1FFF0000) /*!&lt; Receive Buffer2 Size */ #define ETH_DMARxDesc_RER ((uint32_t)0x00008000) /*!&lt; Receive End of Ring */ #define ETH_DMARxDesc_RCH ((uint32_t)0x00004000) /*!&lt; Second Address Chained */ #define ETH_DMARxDesc_RBS1 ((uint32_t)0x00001FFF) /*!&lt; Receive Buffer1 Size */ /** * @brief Bit definition of RDES2 register */ #define ETH_DMARxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of RDES3 register */ #define ETH_DMARxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /**--------------------------------------------------------------------------**/ /** * @brief Desciption of common PHY registers */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup PHY_Read_write_Timeouts * @{ */ #define PHY_READ_TO ((uint32_t)0x0004FFFF) #define PHY_WRITE_TO ((uint32_t)0x0004FFFF) /** * @} */ /** @defgroup PHY_Reset_Delay * @{ */ #define PHY_ResetDelay ((uint32_t)0x000FFFFF) /** * @} */ /** @defgroup PHY_Config_Delay * @{ */ #define PHY_ConfigDelay ((uint32_t)0x00FFFFFF) /** * @} */ /** @defgroup PHY_Register_address * @{ */ #define PHY_BCR 0 /*!&lt; Tranceiver Basic Control Register */ #define PHY_BSR 1 /*!&lt; Tranceiver Basic Status Register */ /** * @} */ /** @defgroup PHY_basic_Control_register * @{ */ #define PHY_Reset ((u16)0x8000) /*!&lt; PHY Reset */ #define PHY_Loopback ((u16)0x4000) /*!&lt; Select loop-back mode */ #define PHY_FULLDUPLEX_100M ((u16)0x2100) /*!&lt; Set the full-duplex mode at 100 Mb/s */ #define PHY_HALFDUPLEX_100M ((u16)0x2000) /*!&lt; Set the half-duplex mode at 100 Mb/s */ #define PHY_FULLDUPLEX_10M ((u16)0x0100) /*!&lt; Set the full-duplex mode at 10 Mb/s */ #define PHY_HALFDUPLEX_10M ((u16)0x0000) /*!&lt; Set the half-duplex mode at 10 Mb/s */ #define PHY_AutoNegotiation ((u16)0x1000) /*!&lt; Enable auto-negotiation function */ #define PHY_Restart_AutoNegotiation ((u16)0x0200) /*!&lt; Restart auto-negotiation function */ #define PHY_Powerdown ((u16)0x0800) /*!&lt; Select the power down mode */ #define PHY_Isolate ((u16)0x0400) /*!&lt; Isolate PHY from MII */ /** * @} */ /** @defgroup PHY_basic_status_register * @{ */ #define PHY_AutoNego_Complete ((u16)0x0020) /*!&lt; Auto-Negotioation process completed */ #define PHY_Linked_Status ((u16)0x0004) /*!&lt; Valid link established */ #define PHY_Jabber_detection ((u16)0x0002) /*!&lt; Jabber condition detected */ /** * @} */ /** @defgroup PHY_status_register * @{ */ /* The PHY status register value change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_SR 31 /*!&lt; Tranceiver Status Register */ /** * @brief For DP83848 */ #define PHY_SR 16 /*!&lt; Tranceiver Status Register */ /* The Speed and Duplex mask values change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_Speed_Status ((u16)0x0004) /*!&lt; Configured information of Speed: 10Mbps */ //#define PHY_Duplex_Status ((u16)0x0010) /*!&lt; Configured information of Duplex: Full-duplex */ /** * @brief For DP83848 */ #define PHY_Speed_Status ((u16)0x0002) /*!&lt; Configured information of Speed: 10Mbps */ #define PHY_Duplex_Status ((u16)0x0004) /*!&lt; Configured information of Duplex: Full-duplex */ #define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) &lt;= 0x1F) #define IS_ETH_PHY_REG(REG) (REG &lt;= 0x1F) /**--------------------------------------------------------------------------**/ /** * @brief MAC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_AutoNegotiation * @{ */ #define ETH_AutoNegotiation_Enable ((uint32_t)0x00000001) #define ETH_AutoNegotiation_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \ ((CMD) == ETH_AutoNegotiation_Disable)) /** * @} */ /** @defgroup ETH_watchdog * @{ */ #define ETH_Watchdog_Enable ((uint32_t)0x00000000) #define ETH_Watchdog_Disable ((uint32_t)0x00800000) #define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \ ((CMD) == ETH_Watchdog_Disable)) /** * @} */ /** @defgroup ETH_Jabber * @{ */ #define ETH_Jabber_Enable ((uint32_t)0x00000000) #define ETH_Jabber_Disable ((uint32_t)0x00400000) #define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \ ((CMD) == ETH_Jabber_Disable)) /** * @} */ /** @defgroup ETH_Inter_Frame_Gap * @{ */ #define ETH_InterFrameGap_96Bit ((uint32_t)0x00000000) /*!&lt; minimum IFG between frames during transmission is 96Bit */ #define ETH_InterFrameGap_88Bit ((uint32_t)0x00020000) /*!&lt; minimum IFG between frames during transmission is 88Bit */ #define ETH_InterFrameGap_80Bit ((uint32_t)0x00040000) /*!&lt; minimum IFG between frames during transmission is 80Bit */ #define ETH_InterFrameGap_72Bit ((uint32_t)0x00060000) /*!&lt; minimum IFG between frames during transmission is 72Bit */ #define ETH_InterFrameGap_64Bit ((uint32_t)0x00080000) /*!&lt; minimum IFG between frames during transmission is 64Bit */ #define ETH_InterFrameGap_56Bit ((uint32_t)0x000A0000) /*!&lt; minimum IFG between frames during transmission is 56Bit */ #define ETH_InterFrameGap_48Bit ((uint32_t)0x000C0000) /*!&lt; minimum IFG between frames during transmission is 48Bit */ #define ETH_InterFrameGap_40Bit ((uint32_t)0x000E0000) /*!&lt; minimum IFG between frames during transmission is 40Bit */ #define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \ ((GAP) == ETH_InterFrameGap_88Bit) || \ ((GAP) == ETH_InterFrameGap_80Bit) || \ ((GAP) == ETH_InterFrameGap_72Bit) || \ ((GAP) == ETH_InterFrameGap_64Bit) || \ ((GAP) == ETH_InterFrameGap_56Bit) || \ ((GAP) == ETH_InterFrameGap_48Bit) || \ ((GAP) == ETH_InterFrameGap_40Bit)) /** * @} */ /** @defgroup ETH_Carrier_Sense * @{ */ #define ETH_CarrierSense_Enable ((uint32_t)0x00000000) #define ETH_CarrierSense_Disable ((uint32_t)0x00010000) #define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \ ((CMD) == ETH_CarrierSense_Disable)) /** * @} */ /** @defgroup ETH_Speed * @{ */ #define ETH_Speed_10M ((uint32_t)0x00000000) #define ETH_Speed_100M ((uint32_t)0x00004000) #define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \ ((SPEED) == ETH_Speed_100M)) /** * @} */ /** @defgroup ETH_Receive_Own * @{ */ #define ETH_ReceiveOwn_Enable ((uint32_t)0x00000000) #define ETH_ReceiveOwn_Disable ((uint32_t)0x00002000) #define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \ ((CMD) == ETH_ReceiveOwn_Disable)) /** * @} */ /** @defgroup ETH_Loop_Back_Mode * @{ */ #define ETH_LoopbackMode_Enable ((uint32_t)0x00001000) #define ETH_LoopbackMode_Disable ((uint32_t)0x00000000) #define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \ ((CMD) == ETH_LoopbackMode_Disable)) /** * @} */ /** @defgroup ETH_Duplex_Mode * @{ */ #define ETH_Mode_FullDuplex ((uint32_t)0x00000800) #define ETH_Mode_HalfDuplex ((uint32_t)0x00000000) #define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \ ((MODE) == ETH_Mode_HalfDuplex)) /** * @} */ /** @defgroup ETH_Checksum_Offload * @{ */ #define ETH_ChecksumOffload_Enable ((uint32_t)0x00000400) #define ETH_ChecksumOffload_Disable ((uint32_t)0x00000000) #define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \ ((CMD) == ETH_ChecksumOffload_Disable)) /** * @} */ /** @defgroup ETH_Retry_Transmission * @{ */ #define ETH_RetryTransmission_Enable ((uint32_t)0x00000000) #define ETH_RetryTransmission_Disable ((uint32_t)0x00000200) #define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \ ((CMD) == ETH_RetryTransmission_Disable)) /** * @} */ /** @defgroup ETH_Automatic_Pad_CRC_Strip * @{ */ #define ETH_AutomaticPadCRCStrip_Enable ((uint32_t)0x00000080) #define ETH_AutomaticPadCRCStrip_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \ ((CMD) == ETH_AutomaticPadCRCStrip_Disable)) /** * @} */ /** @defgroup ETH_Back_Off_Limit * @{ */ #define ETH_BackOffLimit_10 ((uint32_t)0x00000000) #define ETH_BackOffLimit_8 ((uint32_t)0x00000020) #define ETH_BackOffLimit_4 ((uint32_t)0x00000040) #define ETH_BackOffLimit_1 ((uint32_t)0x00000060) #define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \ ((LIMIT) == ETH_BackOffLimit_8) || \ ((LIMIT) == ETH_BackOffLimit_4) || \ ((LIMIT) == ETH_BackOffLimit_1)) /** * @} */ /** @defgroup ETH_Deferral_Check * @{ */ #define ETH_DeferralCheck_Enable ((uint32_t)0x00000010) #define ETH_DeferralCheck_Disable ((uint32_t)0x00000000) #define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \ ((CMD) == ETH_DeferralCheck_Disable)) /** * @} */ /** @defgroup ETH_Receive_All * @{ */ #define ETH_ReceiveAll_Enable ((uint32_t)0x80000000) #define ETH_ReceiveAll_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \ ((CMD) == ETH_ReceiveAll_Disable)) /** * @} */ /** @defgroup ETH_Source_Addr_Filter * @{ */ #define ETH_SourceAddrFilter_Normal_Enable ((uint32_t)0x00000200) #define ETH_SourceAddrFilter_Inverse_Enable ((uint32_t)0x00000300) #define ETH_SourceAddrFilter_Disable ((uint32_t)0x00000000) #define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \ ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \ ((CMD) == ETH_SourceAddrFilter_Disable)) /** * @} */ /** @defgroup ETH_Pass_Control_Frames * @{ */ #define ETH_PassControlFrames_BlockAll ((uint32_t)0x00000040) /*!&lt; MAC filters all control frames from reaching the application */ #define ETH_PassControlFrames_ForwardAll ((uint32_t)0x00000080) /*!&lt; MAC forwards all control frames to application even if they fail the Address Filter */ #define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)0x000000C0) /*!&lt; MAC forwards control frames that pass the Address Filter. */ #define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \ ((PASS) == ETH_PassControlFrames_ForwardAll) || \ ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter)) /** * @} */ /** @defgroup ETH_Broadcast_Frames_Reception * @{ */ #define ETH_BroadcastFramesReception_Enable ((uint32_t)0x00000000) #define ETH_BroadcastFramesReception_Disable ((uint32_t)0x00000020) #define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \ ((CMD) == ETH_BroadcastFramesReception_Disable)) /** * @} */ /** @defgroup ETH_Destination_Addr_Filter * @{ */ #define ETH_DestinationAddrFilter_Normal ((uint32_t)0x00000000) #define ETH_DestinationAddrFilter_Inverse ((uint32_t)0x00000008) #define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \ ((FILTER) == ETH_DestinationAddrFilter_Inverse)) /** * @} */ /** @defgroup ETH_Promiscuous_Mode * @{ */ #define ETH_PromiscuousMode_Enable ((uint32_t)0x00000001) #define ETH_PromiscuousMode_Disable ((uint32_t)0x00000000) #define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \ ((CMD) == ETH_PromiscuousMode_Disable)) /** * @} */ /** @defgroup ETH_Multicast_Frames_Filter * @{ */ #define ETH_MulticastFramesFilter_PerfectHashTable ((uint32_t)0x00000404) #define ETH_MulticastFramesFilter_HashTable ((uint32_t)0x00000004) #define ETH_MulticastFramesFilter_Perfect ((uint32_t)0x00000000) #define ETH_MulticastFramesFilter_None ((uint32_t)0x00000010) #define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \ ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \ ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \ ((FILTER) == ETH_MulticastFramesFilter_None)) /** * @} */ /** @defgroup ETH_Unicast_Frames_Filter * @{ */ #define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)0x00000402) #define ETH_UnicastFramesFilter_HashTable ((uint32_t)0x00000002) #define ETH_UnicastFramesFilter_Perfect ((uint32_t)0x00000000) #define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \ ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \ ((FILTER) == ETH_UnicastFramesFilter_Perfect)) /** * @} */ /** @defgroup ETH_Pause_Time * @{ */ #define IS_ETH_PAUSE_TIME(TIME) ((TIME) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_Zero_Quanta_Pause * @{ */ #define ETH_ZeroQuantaPause_Enable ((uint32_t)0x00000000) #define ETH_ZeroQuantaPause_Disable ((uint32_t)0x00000080) #define IS_ETH_ZEROQUANTA_PAUSE(CMD) (((CMD) == ETH_ZeroQuantaPause_Enable) || \ ((CMD) == ETH_ZeroQuantaPause_Disable)) /** * @} */ /** @defgroup ETH_Pause_Low_Threshold * @{ */ #define ETH_PauseLowThreshold_Minus4 ((uint32_t)0x00000000) /*!&lt; Pause time minus 4 slot times */ #define ETH_PauseLowThreshold_Minus28 ((uint32_t)0x00000010) /*!&lt; Pause time minus 28 slot times */ #define ETH_PauseLowThreshold_Minus144 ((uint32_t)0x00000020) /*!&lt; Pause time minus 144 slot times */ #define ETH_PauseLowThreshold_Minus256 ((uint32_t)0x00000030) /*!&lt; Pause time minus 256 slot times */ #define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \ ((THRESHOLD) == ETH_PauseLowThreshold_Minus256)) /** * @} */ /** @defgroup ETH_Unicast_Pause_Frame_Detect * @{ */ #define ETH_UnicastPauseFrameDetect_Enable ((uint32_t)0x00000008) #define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)0x00000000) #define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \ ((CMD) == ETH_UnicastPauseFrameDetect_Disable)) /** * @} */ /** @defgroup ETH_Receive_Flow_Control * @{ */ #define ETH_ReceiveFlowControl_Enable ((uint32_t)0x00000004) #define ETH_ReceiveFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \ ((CMD) == ETH_ReceiveFlowControl_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Flow_Control * @{ */ #define ETH_TransmitFlowControl_Enable ((uint32_t)0x00000002) #define ETH_TransmitFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \ ((CMD) == ETH_TransmitFlowControl_Disable)) /** * @} */ /** @defgroup ETH_VLAN_Tag_Comparison * @{ */ #define ETH_VLANTagComparison_12Bit ((uint32_t)0x00010000) #define ETH_VLANTagComparison_16Bit ((uint32_t)0x00000000) #define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \ ((COMPARISON) == ETH_VLANTagComparison_16Bit)) #define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_MAC_Flags * @{ */ #define ETH_MAC_FLAG_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger flag (on MAC) */ #define ETH_MAC_FLAG_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit flag */ #define ETH_MAC_FLAG_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive flag */ #define ETH_MAC_FLAG_MMC ((uint32_t)0x00000010) /*!&lt; MMC flag (on MAC) */ #define ETH_MAC_FLAG_PMT ((uint32_t)0x00000008) /*!&lt; PMT flag (on MAC) */ #define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \ ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \ ((FLAG) == ETH_MAC_FLAG_PMT)) /** * @} */ /** @defgroup ETH_MAC_Interrupts * @{ */ #define ETH_MAC_IT_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger interrupt (on MAC) */ #define ETH_MAC_IT_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit interrupt */ #define ETH_MAC_IT_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive interrupt */ #define ETH_MAC_IT_MMC ((uint32_t)0x00000010) /*!&lt; MMC interrupt (on MAC) */ #define ETH_MAC_IT_PMT ((uint32_t)0x00000008) /*!&lt; PMT interrupt (on MAC) */ #define IS_ETH_MAC_IT(IT) ((((IT) &amp; (uint32_t)0xFFFFFDF7) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \ ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \ ((IT) == ETH_MAC_IT_PMT)) /** * @} */ /** @defgroup ETH_MAC_addresses * @{ */ #define ETH_MAC_Address0 ((uint32_t)0x00000000) #define ETH_MAC_Address1 ((uint32_t)0x00000008) #define ETH_MAC_Address2 ((uint32_t)0x00000010) #define ETH_MAC_Address3 ((uint32_t)0x00000018) #define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \ ((ADDRESS) == ETH_MAC_Address1) || \ ((ADDRESS) == ETH_MAC_Address2) || \ ((ADDRESS) == ETH_MAC_Address3)) #define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \ ((ADDRESS) == ETH_MAC_Address2) || \ ((ADDRESS) == ETH_MAC_Address3)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames * @{ */ #define ETH_MAC_AddressFilter_SA ((uint32_t)0x00000000) #define ETH_MAC_AddressFilter_DA ((uint32_t)0x00000008) #define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \ ((FILTER) == ETH_MAC_AddressFilter_DA)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_Mask_bytes * @{ */ #define ETH_MAC_AddressMask_Byte6 ((uint32_t)0x20000000) /*!&lt; Mask MAC Address high reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte5 ((uint32_t)0x10000000) /*!&lt; Mask MAC Address high reg bits [7:0] */ #define ETH_MAC_AddressMask_Byte4 ((uint32_t)0x08000000) /*!&lt; Mask MAC Address low reg bits [31:24] */ #define ETH_MAC_AddressMask_Byte3 ((uint32_t)0x04000000) /*!&lt; Mask MAC Address low reg bits [23:16] */ #define ETH_MAC_AddressMask_Byte2 ((uint32_t)0x02000000) /*!&lt; Mask MAC Address low reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte1 ((uint32_t)0x01000000) /*!&lt; Mask MAC Address low reg bits [70] */ #define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \ ((MASK) == ETH_MAC_AddressMask_Byte5) || \ ((MASK) == ETH_MAC_AddressMask_Byte4) || \ ((MASK) == ETH_MAC_AddressMask_Byte3) || \ ((MASK) == ETH_MAC_AddressMask_Byte2) || \ ((MASK) == ETH_MAC_AddressMask_Byte1)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA Desciptors defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_flags * @{ */ #define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \ ((FLAG) == ETH_DMATxDesc_IC) || \ ((FLAG) == ETH_DMATxDesc_LS) || \ ((FLAG) == ETH_DMATxDesc_FS) || \ ((FLAG) == ETH_DMATxDesc_DC) || \ ((FLAG) == ETH_DMATxDesc_DP) || \ ((FLAG) == ETH_DMATxDesc_TTSE) || \ ((FLAG) == ETH_DMATxDesc_TER) || \ ((FLAG) == ETH_DMATxDesc_TCH) || \ ((FLAG) == ETH_DMATxDesc_TTSS) || \ ((FLAG) == ETH_DMATxDesc_IHE) || \ ((FLAG) == ETH_DMATxDesc_ES) || \ ((FLAG) == ETH_DMATxDesc_JT) || \ ((FLAG) == ETH_DMATxDesc_FF) || \ ((FLAG) == ETH_DMATxDesc_PCE) || \ ((FLAG) == ETH_DMATxDesc_LCA) || \ ((FLAG) == ETH_DMATxDesc_NC) || \ ((FLAG) == ETH_DMATxDesc_LCO) || \ ((FLAG) == ETH_DMATxDesc_EC) || \ ((FLAG) == ETH_DMATxDesc_VF) || \ ((FLAG) == ETH_DMATxDesc_CC) || \ ((FLAG) == ETH_DMATxDesc_ED) || \ ((FLAG) == ETH_DMATxDesc_UF) || \ ((FLAG) == ETH_DMATxDesc_DB)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_segment * @{ */ #define ETH_DMATxDesc_LastSegment ((uint32_t)0x40000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FirstSegment ((uint32_t)0x20000000) /*!&lt; First Segment */ #define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \ ((SEGMENT) == ETH_DMATxDesc_FirstSegment)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control * @{ */ #define ETH_DMATxDesc_ChecksumByPass ((uint32_t)0x00000000) /*!&lt; Checksum engine bypass */ #define ETH_DMATxDesc_ChecksumIPV4Header ((uint32_t)0x00400000) /*!&lt; IPv4 header checksum insertion */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPFull ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP checksum fully in hardware including pseudo header */ #define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull)) /** * @brief ETH DMA Tx Desciptor buffer size */ #define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) &lt;= 0x1FFF) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_flags * @{ */ #define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \ ((FLAG) == ETH_DMARxDesc_AFM) || \ ((FLAG) == ETH_DMARxDesc_ES) || \ ((FLAG) == ETH_DMARxDesc_DE) || \ ((FLAG) == ETH_DMARxDesc_SAF) || \ ((FLAG) == ETH_DMARxDesc_LE) || \ ((FLAG) == ETH_DMARxDesc_OE) || \ ((FLAG) == ETH_DMARxDesc_VLAN) || \ ((FLAG) == ETH_DMARxDesc_FS) || \ ((FLAG) == ETH_DMARxDesc_LS) || \ ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \ ((FLAG) == ETH_DMARxDesc_LC) || \ ((FLAG) == ETH_DMARxDesc_FT) || \ ((FLAG) == ETH_DMARxDesc_RWT) || \ ((FLAG) == ETH_DMARxDesc_RE) || \ ((FLAG) == ETH_DMARxDesc_DBE) || \ ((FLAG) == ETH_DMARxDesc_CE) || \ ((FLAG) == ETH_DMARxDesc_MAMPCE)) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_buffers_ * @{ */ #define ETH_DMARxDesc_Buffer1 ((uint32_t)0x00000000) /*!&lt; DMA Rx Desc Buffer1 */ #define ETH_DMARxDesc_Buffer2 ((uint32_t)0x00000001) /*!&lt; DMA Rx Desc Buffer2 */ #define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \ ((BUFFER) == ETH_DMARxDesc_Buffer2)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame * @{ */ #define ETH_DropTCPIPChecksumErrorFrame_Enable ((uint32_t)0x00000000) #define ETH_DropTCPIPChecksumErrorFrame_Disable ((uint32_t)0x04000000) #define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \ ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable)) /** * @} */ /** @defgroup ETH_Receive_Store_Forward * @{ */ #define ETH_ReceiveStoreForward_Enable ((uint32_t)0x02000000) #define ETH_ReceiveStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \ ((CMD) == ETH_ReceiveStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Flush_Received_Frame * @{ */ #define ETH_FlushReceivedFrame_Enable ((uint32_t)0x00000000) #define ETH_FlushReceivedFrame_Disable ((uint32_t)0x01000000) #define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \ ((CMD) == ETH_FlushReceivedFrame_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Store_Forward * @{ */ #define ETH_TransmitStoreForward_Enable ((uint32_t)0x00200000) #define ETH_TransmitStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \ ((CMD) == ETH_TransmitStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Threshold_Control * @{ */ #define ETH_TransmitThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Transmit FIFO is 64 Bytes */ #define ETH_TransmitThresholdControl_128Bytes ((uint32_t)0x00004000) /*!&lt; threshold level of the MTL Transmit FIFO is 128 Bytes */ #define ETH_TransmitThresholdControl_192Bytes ((uint32_t)0x00008000) /*!&lt; threshold level of the MTL Transmit FIFO is 192 Bytes */ #define ETH_TransmitThresholdControl_256Bytes ((uint32_t)0x0000C000) /*!&lt; threshold level of the MTL Transmit FIFO is 256 Bytes */ #define ETH_TransmitThresholdControl_40Bytes ((uint32_t)0x00010000) /*!&lt; threshold level of the MTL Transmit FIFO is 40 Bytes */ #define ETH_TransmitThresholdControl_32Bytes ((uint32_t)0x00014000) /*!&lt; threshold level of the MTL Transmit FIFO is 32 Bytes */ #define ETH_TransmitThresholdControl_24Bytes ((uint32_t)0x00018000) /*!&lt; threshold level of the MTL Transmit FIFO is 24 Bytes */ #define ETH_TransmitThresholdControl_16Bytes ((uint32_t)0x0001C000) /*!&lt; threshold level of the MTL Transmit FIFO is 16 Bytes */ #define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \ ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes)) /** * @} */ /** @defgroup ETH_Forward_Error_Frames * @{ */ #define ETH_ForwardErrorFrames_Enable ((uint32_t)0x00000080) #define ETH_ForwardErrorFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \ ((CMD) == ETH_ForwardErrorFrames_Disable)) /** * @} */ /** @defgroup ETH_Forward_Undersized_Good_Frames * @{ */ #define ETH_ForwardUndersizedGoodFrames_Enable ((uint32_t)0x00000040) #define ETH_ForwardUndersizedGoodFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \ ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable)) /** * @} */ /** @defgroup ETH_Receive_Threshold_Control * @{ */ #define ETH_ReceiveThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Receive FIFO is 64 Bytes */ #define ETH_ReceiveThresholdControl_32Bytes ((uint32_t)0x00000008) /*!&lt; threshold level of the MTL Receive FIFO is 32 Bytes */ #define ETH_ReceiveThresholdControl_96Bytes ((uint32_t)0x00000010) /*!&lt; threshold level of the MTL Receive FIFO is 96 Bytes */ #define ETH_ReceiveThresholdControl_128Bytes ((uint32_t)0x00000018) /*!&lt; threshold level of the MTL Receive FIFO is 128 Bytes */ #define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \ ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes)) /** * @} */ /** @defgroup ETH_Second_Frame_Operate * @{ */ #define ETH_SecondFrameOperate_Enable ((uint32_t)0x00000004) #define ETH_SecondFrameOperate_Disable ((uint32_t)0x00000000) #define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \ ((CMD) == ETH_SecondFrameOperate_Disable)) /** * @} */ /** @defgroup ETH_Address_Aligned_Beats * @{ */ #define ETH_AddressAlignedBeats_Enable ((uint32_t)0x02000000) #define ETH_AddressAlignedBeats_Disable ((uint32_t)0x00000000) #define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \ ((CMD) == ETH_AddressAlignedBeats_Disable)) /** * @} */ /** @defgroup ETH_Fixed_Burst * @{ */ #define ETH_FixedBurst_Enable ((uint32_t)0x00010000) #define ETH_FixedBurst_Disable ((uint32_t)0x00000000) #define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \ ((CMD) == ETH_FixedBurst_Disable)) /** * @} */ /** @defgroup ETH_Rx_DMA_Burst_Length * @{ */ #define ETH_RxDMABurstLength_1Beat ((uint32_t)0x00020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 1 */ #define ETH_RxDMABurstLength_2Beat ((uint32_t)0x00040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 2 */ #define ETH_RxDMABurstLength_4Beat ((uint32_t)0x00080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_8Beat ((uint32_t)0x00100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_16Beat ((uint32_t)0x00200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_32Beat ((uint32_t)0x00400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 64 */ #define ETH_RxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 128 */ #define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat)) /** * @} */ /** @defgroup ETH_Tx_DMA_Burst_Length * @{ */ #define ETH_TxDMABurstLength_1Beat ((uint32_t)0x00000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */ #define ETH_TxDMABurstLength_2Beat ((uint32_t)0x00000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */ #define ETH_TxDMABurstLength_4Beat ((uint32_t)0x00000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_8Beat ((uint32_t)0x00000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_16Beat ((uint32_t)0x00001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_32Beat ((uint32_t)0x00002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */ #define ETH_TxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */ #define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat)) /** * @brief ETH DMA Desciptor SkipLength */ #define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) &lt;= 0x1F) /** * @} */ /** @defgroup ETH_DMA_Arbitration * @{ */ #define ETH_DMAArbitration_RoundRobin_RxTx_1_1 ((uint32_t)0x00000000) #define ETH_DMAArbitration_RoundRobin_RxTx_2_1 ((uint32_t)0x00004000) #define ETH_DMAArbitration_RoundRobin_RxTx_3_1 ((uint32_t)0x00008000) #define ETH_DMAArbitration_RoundRobin_RxTx_4_1 ((uint32_t)0x0000C000) #define ETH_DMAArbitration_RxPriorTx ((uint32_t)0x00000002) #define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \ ((RATIO) == ETH_DMAArbitration_RxPriorTx)) /** * @} */ /** @defgroup ETH_DMA_Flags * @{ */ #define ETH_DMA_FLAG_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_FLAG_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_FLAG_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_FLAG_DataTransferError ((uint32_t)0x00800000) /*!&lt; Error bits 0-Rx DMA, 1-Tx DMA */ #define ETH_DMA_FLAG_ReadWriteError ((uint32_t)0x01000000) /*!&lt; Error bits 0-write trnsf, 1-read transfr */ #define ETH_DMA_FLAG_AccessError ((uint32_t)0x02000000) /*!&lt; Error bits 0-data buffer, 1-desc. access */ #define ETH_DMA_FLAG_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary flag */ #define ETH_DMA_FLAG_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary flag */ #define ETH_DMA_FLAG_ER ((uint32_t)0x00004000) /*!&lt; Early receive flag */ #define ETH_DMA_FLAG_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error flag */ #define ETH_DMA_FLAG_ET ((uint32_t)0x00000400) /*!&lt; Early transmit flag */ #define ETH_DMA_FLAG_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout flag */ #define ETH_DMA_FLAG_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped flag */ #define ETH_DMA_FLAG_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable flag */ #define ETH_DMA_FLAG_R ((uint32_t)0x00000040) /*!&lt; Receive flag */ #define ETH_DMA_FLAG_TU ((uint32_t)0x00000020) /*!&lt; Underflow flag */ #define ETH_DMA_FLAG_RO ((uint32_t)0x00000010) /*!&lt; Overflow flag */ #define ETH_DMA_FLAG_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout flag */ #define ETH_DMA_FLAG_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable flag */ #define ETH_DMA_FLAG_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped flag */ #define ETH_DMA_FLAG_T ((uint32_t)0x00000001) /*!&lt; Transmit flag */ #define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((FLAG) != 0x00)) #define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \ ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \ ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \ ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \ ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \ ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \ ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \ ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \ ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \ ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \ ((FLAG) == ETH_DMA_FLAG_T)) /** * @} */ /** @defgroup ETH_DMA_Interrupts * @{ */ #define ETH_DMA_IT_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_IT_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_IT_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_IT_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary */ #define ETH_DMA_IT_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary */ #define ETH_DMA_IT_ER ((uint32_t)0x00004000) /*!&lt; Early receive interrupt */ #define ETH_DMA_IT_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error interrupt */ #define ETH_DMA_IT_ET ((uint32_t)0x00000400) /*!&lt; Early transmit interrupt */ #define ETH_DMA_IT_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout interrupt */ #define ETH_DMA_IT_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped interrupt */ #define ETH_DMA_IT_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable interrupt */ #define ETH_DMA_IT_R ((uint32_t)0x00000040) /*!&lt; Receive interrupt */ #define ETH_DMA_IT_TU ((uint32_t)0x00000020) /*!&lt; Underflow interrupt */ #define ETH_DMA_IT_RO ((uint32_t)0x00000010) /*!&lt; Overflow interrupt */ #define ETH_DMA_IT_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout interrupt */ #define ETH_DMA_IT_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable interrupt */ #define ETH_DMA_IT_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped interrupt */ #define ETH_DMA_IT_T ((uint32_t)0x00000001) /*!&lt; Transmit interrupt */ #define IS_ETH_DMA_IT(IT) ((((IT) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \ ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \ ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \ ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \ ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \ ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \ ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \ ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \ ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T)) /** * @} */ /** @defgroup ETH_DMA_transmit_process_state_ * @{ */ #define ETH_DMA_TransmitProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Tx Command issued */ #define ETH_DMA_TransmitProcess_Fetching ((uint32_t)0x00100000) /*!&lt; Running - fetching the Tx descriptor */ #define ETH_DMA_TransmitProcess_Waiting ((uint32_t)0x00200000) /*!&lt; Running - waiting for status */ #define ETH_DMA_TransmitProcess_Reading ((uint32_t)0x00300000) /*!&lt; Running - reading the data from host memory */ #define ETH_DMA_TransmitProcess_Suspended ((uint32_t)0x00600000) /*!&lt; Suspended - Tx Desciptor unavailabe */ #define ETH_DMA_TransmitProcess_Closing ((uint32_t)0x00700000) /*!&lt; Running - closing Rx descriptor */ /** * @} */ /** @defgroup ETH_DMA_receive_process_state_ * @{ */ #define ETH_DMA_ReceiveProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Rx Command issued */ #define ETH_DMA_ReceiveProcess_Fetching ((uint32_t)0x00020000) /*!&lt; Running - fetching the Rx descriptor */ #define ETH_DMA_ReceiveProcess_Waiting ((uint32_t)0x00060000) /*!&lt; Running - waiting for packet */ #define ETH_DMA_ReceiveProcess_Suspended ((uint32_t)0x00080000) /*!&lt; Suspended - Rx Desciptor unavailable */ #define ETH_DMA_ReceiveProcess_Closing ((uint32_t)0x000A0000) /*!&lt; Running - closing descriptor */ #define ETH_DMA_ReceiveProcess_Queuing ((uint32_t)0x000E0000) /*!&lt; Running - queuing the recieve frame into host memory */ /** * @} */ /** @defgroup ETH_DMA_overflow_ * @{ */ #define ETH_DMA_Overflow_RxFIFOCounter ((uint32_t)0x10000000) /*!&lt; Overflow bit for FIFO overflow counter */ #define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)0x00010000) /*!&lt; Overflow bit for missed frame counter */ #define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \ ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PMT defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PMT_Flags * @{ */ #define ETH_PMT_FLAG_WUFFRPR ((uint32_t)0x80000000) /*!&lt; Wake-Up Frame Filter Register Poniter Reset */ #define ETH_PMT_FLAG_WUFR ((uint32_t)0x00000040) /*!&lt; Wake-Up Frame Received */ #define ETH_PMT_FLAG_MPR ((uint32_t)0x00000020) /*!&lt; Magic Packet Received */ #define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \ ((FLAG) == ETH_PMT_FLAG_MPR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet MMC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_MMC_Tx_Interrupts * @{ */ #define ETH_MMC_IT_TGF ((uint32_t)0x00200000) /*!&lt; When Tx good frame counter reaches half the maximum value */ #define ETH_MMC_IT_TGFMSC ((uint32_t)0x00008000) /*!&lt; When Tx good multi col counter reaches half the maximum value */ #define ETH_MMC_IT_TGFSC ((uint32_t)0x00004000) /*!&lt; When Tx good single col counter reaches half the maximum value */ /** * @} */ /** @defgroup ETH_MMC_Rx_Interrupts * @{ */ #define ETH_MMC_IT_RGUF ((uint32_t)0x10020000) /*!&lt; When Rx good unicast frames counter reaches half the maximum value */ #define ETH_MMC_IT_RFAE ((uint32_t)0x10000040) /*!&lt; When Rx alignment error counter reaches half the maximum value */ #define ETH_MMC_IT_RFCE ((uint32_t)0x10000020) /*!&lt; When Rx crc error counter reaches half the maximum value */ #define IS_ETH_MMC_IT(IT) (((((IT) &amp; (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) &amp; (uint32_t)0xEFFDFF9F) == 0x00)) &amp;&amp; \ ((IT) != 0x00)) #define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \ ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \ ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE)) /** * @} */ /** @defgroup ETH_MMC_Registers * @{ */ #define ETH_MMCCR ((uint32_t)0x00000100) /*!&lt; MMC CR register */ #define ETH_MMCRIR ((uint32_t)0x00000104) /*!&lt; MMC RIR register */ #define ETH_MMCTIR ((uint32_t)0x00000108) /*!&lt; MMC TIR register */ #define ETH_MMCRIMR ((uint32_t)0x0000010C) /*!&lt; MMC RIMR register */ #define ETH_MMCTIMR ((uint32_t)0x00000110) /*!&lt; MMC TIMR register */ #define ETH_MMCTGFSCCR ((uint32_t)0x0000014C) /*!&lt; MMC TGFSCCR register */ #define ETH_MMCTGFMSCCR ((uint32_t)0x00000150) /*!&lt; MMC TGFMSCCR register */ #define ETH_MMCTGFCR ((uint32_t)0x00000168) /*!&lt; MMC TGFCR register */ #define ETH_MMCRFCECR ((uint32_t)0x00000194) /*!&lt; MMC RFCECR register */ #define ETH_MMCRFAECR ((uint32_t)0x00000198) /*!&lt; MMC RFAECR register */ #define ETH_MMCRGUFCR ((uint32_t)0x000001C4) /*!&lt; MMC RGUFCR register */ /** * @brief ETH MMC registers */ #define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR) || ((REG) == ETH_MMCRIR) || \ ((REG) == ETH_MMCTIR) || ((REG) == ETH_MMCRIMR) || \ ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \ ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \ ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \ ((REG) == ETH_MMCRGUFCR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PTP defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PTP_time_update_method * @{ */ #define ETH_PTP_FineUpdate ((uint32_t)0x00000001) /*!&lt; Fine Update method */ #define ETH_PTP_CoarseUpdate ((uint32_t)0x00000000) /*!&lt; Coarse Update method */ #define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \ ((UPDATE) == ETH_PTP_CoarseUpdate)) /** * @} */ /** @defgroup ETH_PTP_Flags * @{ */ #define ETH_PTP_FLAG_TSARU ((uint32_t)0x00000020) /*!&lt; Addend Register Update */ #define ETH_PTP_FLAG_TSITE ((uint32_t)0x00000010) /*!&lt; Time Stamp Interrupt Trigger */ #define ETH_PTP_FLAG_TSSTU ((uint32_t)0x00000008) /*!&lt; Time Stamp Update */ #define ETH_PTP_FLAG_TSSTI ((uint32_t)0x00000004) /*!&lt; Time Stamp Initialize */ #define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \ ((FLAG) == ETH_PTP_FLAG_TSITE) || \ ((FLAG) == ETH_PTP_FLAG_TSSTU) || \ ((FLAG) == ETH_PTP_FLAG_TSSTI)) /** * @brief ETH PTP subsecond increment */ #define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) &lt;= 0xFF) /** * @} */ /** @defgroup ETH_PTP_time_sign * @{ */ #define ETH_PTP_PositiveTime ((uint32_t)0x00000000) /*!&lt; Positive time value */ #define ETH_PTP_NegativeTime ((uint32_t)0x80000000) /*!&lt; Negative time value */ #define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \ ((SIGN) == ETH_PTP_NegativeTime)) /** * @brief ETH PTP time stamp low update */ #define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) &lt;= 0x7FFFFFFF) /** * @brief ETH PTP registers */ #define ETH_PTPTSCR ((uint32_t)0x00000700) /*!&lt; PTP TSCR register */ #define ETH_PTPSSIR ((uint32_t)0x00000704) /*!&lt; PTP SSIR register */ #define ETH_PTPTSHR ((uint32_t)0x00000708) /*!&lt; PTP TSHR register */ #define ETH_PTPTSLR ((uint32_t)0x0000070C) /*!&lt; PTP TSLR register */ #define ETH_PTPTSHUR ((uint32_t)0x00000710) /*!&lt; PTP TSHUR register */ #define ETH_PTPTSLUR ((uint32_t)0x00000714) /*!&lt; PTP TSLUR register */ #define ETH_PTPTSAR ((uint32_t)0x00000718) /*!&lt; PTP TSAR register */ #define ETH_PTPTTHR ((uint32_t)0x0000071C) /*!&lt; PTP TTHR register */ #define ETH_PTPTTLR ((uint32_t)0x00000720) /* PTP TTLR register */ #define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \ ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \ ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \ ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \ ((REG) == ETH_PTPTTLR)) /** * @} */ /** * @} */ /** @defgroup ETH_Exported_Macros * @{ */ /** * @} */ /** @defgroup ETH_Exported_Functions * @{ */ void ETH_DeInit(void); uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct); void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct); void ETH_SoftwareReset(void); FlagStatus ETH_GetSoftwareResetStatus(void); void ETH_Start(void); uint32_t ETH_HandleTxPkt(u8 *ppkt, u16 FrameLength); uint32_t ETH_HandleRxPkt(u8 *ppkt); uint32_t ETH_GetRxPktSize(void); void ETH_DropRxPkt(void); /** * @brief PHY */ u16 ETH_ReadPHYRegister(u16 PHYAddress, u16 PHYReg); uint32_t ETH_WritePHYRegister(u16 PHYAddress, u16 PHYReg, u16 PHYValue); uint32_t ETH_PHYLoopBackCmd(u16 PHYAddress, FunctionalState NewState); /** * @brief MAC */ void ETH_MACTransmissionCmd(FunctionalState NewState); void ETH_MACReceptionCmd(FunctionalState NewState); FlagStatus ETH_GetFlowControlBusyStatus(void); void ETH_InitiatePauseControlFrame(void); void ETH_BackPressureActivationCmd(FunctionalState NewState); FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG); ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT); void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState); void ETH_MACAddressConfig(uint32_t MacAddr, u8 *Addr); void ETH_GetMACAddress(uint32_t MacAddr, u8 *Addr); void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState); void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter); void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte); /** * @brief DMA Tx/Rx descriptors */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff, uint32_t TxBuffCount); void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff1, u8 *TxBuff2, uint32_t TxBuffCount); FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag); uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc); void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc); void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment); void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum); void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2); void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff1, u8 *RxBuff2, uint32_t RxBuffCount); FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag); void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc); uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc); void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer); /** * @brief DMA */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG); void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG); ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT); void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT); uint32_t ETH_GetTransmitProcessState(void); uint32_t ETH_GetReceiveProcessState(void); void ETH_FlushTransmitFIFO(void); FlagStatus ETH_GetFlushTransmitFIFOStatus(void); void ETH_DMATransmissionCmd(FunctionalState NewState); void ETH_DMAReceptionCmd(FunctionalState NewState); void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState); FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow); uint32_t ETH_GetRxOverflowMissedFrameCounter(void); uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void); uint32_t ETH_GetCurrentTxDescStartAddress(void); uint32_t ETH_GetCurrentRxDescStartAddress(void); uint32_t ETH_GetCurrentTxBufferAddress(void); uint32_t ETH_GetCurrentRxBufferAddress(void); void ETH_ResumeDMATransmission(void); void ETH_ResumeDMAReception(void); /** * @brief PMT */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void); void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer); void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState); FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG); void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState); void ETH_MagicPacketDetectionCmd(FunctionalState NewState); void ETH_PowerDownCmd(FunctionalState NewState); /** * @brief MMC */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState); void ETH_MMCResetOnReadCmd(FunctionalState NewState); void ETH_MMCCounterRolloverCmd(FunctionalState NewState); void ETH_MMCCountersReset(void); void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState); ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT); uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg); /** * @brief PTP */ uint32_t ETH_HandlePTPTxPkt(u8 *ppkt, u16 FrameLength, uint32_t *PTPTxTab); uint32_t ETH_HandlePTPRxPkt(u8 *ppkt, uint32_t *PTPRxTab); void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, u8* TxBuff, uint32_t TxBuffCount); void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_EnablePTPTimeStampAddend(void); void ETH_EnablePTPTimeStampInterruptTrigger(void); void ETH_EnablePTPTimeStampUpdate(void); void ETH_InitializePTPTimeStamp(void); void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod); void ETH_PTPTimeStampCmd(FunctionalState NewState); FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG); void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue); void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue); void ETH_SetPTPTimeStampAddend(uint32_t Value); void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue); uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg); #ifdef __cplusplus } #endif void FreeRTOS_Hardware_STMS32_ETH_Init(void); #endif /* __STM32_ETH_H */ /** * @} */ /** * @} */ /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/ stm32_eth.c /** ****************************************************************************** * @file stm32_eth.c * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file provides all the ETH firmware functions. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32_eth.h&quot; #include &quot;stm32f10x_rcc.h&quot; #define DP83848_PHY_ADDRESS 0x01 /* Relative to STM322xG-EVAL Board */ /* STM32F107 ETH dirver options */ #define CHECKSUM_BY_HARDWARE 1 /* 0: disable. 1: use hardware checksum. */ #define RMII_MODE 0 /* 0: MII MODE, 1: RMII MODE. */ #define STM32_ETH_IO_REMAP 1 /* 0: default, 1: remap RXD to PDx. */ #define USE_MCO 1 /* 0: disable, 1: PA8(MCO) out 25Mhz(MII) or 50Mhz(RMII). */ /** @addtogroup STM32_ETH_Driver * @brief ETH driver modules * @{ */ /** @defgroup ETH_Private_TypesDefinitions * @{ */ /** * @} */ /** @defgroup ETH_Private_Defines * @{ */ /* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */ ETH_DMADESCTypeDef *DMATxDescToSet; ETH_DMADESCTypeDef *DMARxDescToGet; ETH_DMADESCTypeDef *DMAPTPTxDescToSet; ETH_DMADESCTypeDef *DMAPTPRxDescToGet; /* ETHERNET MAC address offsets */ #define ETH_MAC_ADDR_HBASE (ETH_MAC_BASE + 0x40) /* ETHERNET MAC address high offset */ #define ETH_MAC_ADDR_LBASE (ETH_MAC_BASE + 0x44) /* ETHERNET MAC address low offset */ /* ETHERNET MACMIIAR register Mask */ #define MACMIIAR_CR_MASK ((uint32_t)0xFFFFFFE3) /* ETHERNET MACCR register Mask */ #define MACCR_CLEAR_MASK ((uint32_t)0xFF20810F) /* ETHERNET MACFCR register Mask */ #define MACFCR_CLEAR_MASK ((uint32_t)0x0000FF41) /* ETHERNET DMAOMR register Mask */ #define DMAOMR_CLEAR_MASK ((uint32_t)0xF8DE3F23) /* ETHERNET Remote Wake-up frame register length */ #define ETH_WAKEUP_REGISTER_LENGTH 8 /* ETHERNET Missed frames counter Shift */ #define ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT 17 /* ETHERNET DMA Tx descriptors Collision Count Shift */ #define ETH_DMATXDESC_COLLISION_COUNTSHIFT 3 /* ETHERNET DMA Tx descriptors Buffer2 Size Shift */ #define ETH_DMATXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET DMA Rx descriptors Frame Length Shift */ #define ETH_DMARXDESC_FRAME_LENGTHSHIFT 16 /* ETHERNET DMA Rx descriptors Buffer2 Size Shift */ #define ETH_DMARXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET errors */ #define ETH_ERROR ((uint32_t)0) #define ETH_SUCCESS ((uint32_t)1) /** * @} */ /** @defgroup ETH_Private_Macros * @{ */ /** * @} */ /** @defgroup ETH_Private_Variables * @{ */ /** * @} */ /** @defgroup ETH_Private_FunctionPrototypes * @{ */ /** * @} */ /** @defgroup ETH_Private_Functions * @{ */ /** * @brief Deinitializes the ETHERNET peripheral registers to their default reset values. * @param None * @retval None */ void ETH_DeInit(void) { RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE); RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE); } /** * @brief Initializes the ETHERNET peripheral according to the specified * parameters in the ETH_InitStruct . * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains * the configuration information for the specified ETHERNET peripheral. * @retval ETH_ERROR: Ethernet initialization failed * ETH_SUCCESS: Ethernet successfully initialized */ uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct) { uint32_t tmpreg = 0; __IO uint32_t i = 0; RCC_ClocksTypeDef rcc_clocks; uint32_t hclk = 60000000; __IO uint32_t timeout = 0; /* Check the parameters */ /* MAC --------------------------*/ assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct-&gt;ETH_AutoNegotiation)); assert_param(IS_ETH_WATCHDOG(ETH_InitStruct-&gt;ETH_Watchdog)); assert_param(IS_ETH_JABBER(ETH_InitStruct-&gt;ETH_Jabber)); assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct-&gt;ETH_InterFrameGap)); assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct-&gt;ETH_CarrierSense)); assert_param(IS_ETH_SPEED(ETH_InitStruct-&gt;ETH_Speed)); assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct-&gt;ETH_ReceiveOwn)); assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct-&gt;ETH_LoopbackMode)); assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct-&gt;ETH_Mode)); assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct-&gt;ETH_ChecksumOffload)); assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct-&gt;ETH_RetryTransmission)); assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip)); assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct-&gt;ETH_BackOffLimit)); assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct-&gt;ETH_DeferralCheck)); assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct-&gt;ETH_ReceiveAll)); assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct-&gt;ETH_SourceAddrFilter)); assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct-&gt;ETH_PassControlFrames)); assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct-&gt;ETH_BroadcastFramesReception)); assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct-&gt;ETH_DestinationAddrFilter)); assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct-&gt;ETH_PromiscuousMode)); assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_MulticastFramesFilter)); assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_UnicastFramesFilter)); assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct-&gt;ETH_PauseTime)); assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct-&gt;ETH_ZeroQuantaPause)); assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct-&gt;ETH_PauseLowThreshold)); assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect)); assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct-&gt;ETH_ReceiveFlowControl)); assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct-&gt;ETH_TransmitFlowControl)); assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct-&gt;ETH_VLANTagComparison)); assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct-&gt;ETH_VLANTagIdentifier)); /* DMA --------------------------*/ assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame)); assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct-&gt;ETH_ReceiveStoreForward)); assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct-&gt;ETH_FlushReceivedFrame)); assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct-&gt;ETH_TransmitStoreForward)); assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_TransmitThresholdControl)); assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct-&gt;ETH_ForwardErrorFrames)); assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames)); assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_ReceiveThresholdControl)); assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct-&gt;ETH_SecondFrameOperate)); assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct-&gt;ETH_AddressAlignedBeats)); assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct-&gt;ETH_FixedBurst)); assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_RxDMABurstLength)); assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_TxDMABurstLength)); assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct-&gt;ETH_DescriptorSkipLength)); assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct-&gt;ETH_DMAArbitration)); /*-------------------------------- MAC Config ------------------------------*/ /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/ /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Clear CSR Clock Range CR[2:0] bits */ tmpreg &amp;= MACMIIAR_CR_MASK; /* Get hclk frequency value */ RCC_GetClocksFreq(&amp;rcc_clocks); hclk = rcc_clocks.HCLK_Frequency; /* Set CR bits depending on hclk value */ if((hclk &gt;= 20000000)&amp;&amp;(hclk &lt; 35000000)) { /* CSR Clock Range between 20-35 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16; } else if((hclk &gt;= 35000000)&amp;&amp;(hclk &lt; 60000000)) { /* CSR Clock Range between 35-60 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26; } else /* ((hclk &gt;= 60000000)&amp;&amp;(hclk &lt;= 72000000)) */ { /* CSR Clock Range between 60-72 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42; } /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */ ETH-&gt;MACMIIAR = (uint32_t)tmpreg; /*------------------------ ETHERNET MACCR Configuration --------------------*/ /* Get the ETHERNET MACCR value */ tmpreg = ETH-&gt;MACCR; /* Clear WD, PCE, PS, TE and RE bits */ tmpreg &amp;= MACCR_CLEAR_MASK; /* Set the WD bit according to ETH_Watchdog value */ /* Set the JD: bit according to ETH_Jabber value */ /* Set the IFG bit according to ETH_InterFrameGap value */ /* Set the DCRS bit according to ETH_CarrierSense value */ /* Set the FES bit according to ETH_Speed value */ /* Set the DO bit according to ETH_ReceiveOwn value */ /* Set the LM bit according to ETH_LoopbackMode value */ /* Set the DM bit according to ETH_Mode value */ /* Set the IPC bit according to ETH_ChecksumOffload value */ /* Set the DR bit according to ETH_RetryTransmission value */ /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ /* Set the BL bit according to ETH_BackOffLimit value */ /* Set the DC bit according to ETH_DeferralCheck value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_Watchdog | ETH_InitStruct-&gt;ETH_Jabber | ETH_InitStruct-&gt;ETH_InterFrameGap | ETH_InitStruct-&gt;ETH_CarrierSense | ETH_InitStruct-&gt;ETH_Speed | ETH_InitStruct-&gt;ETH_ReceiveOwn | ETH_InitStruct-&gt;ETH_LoopbackMode | ETH_InitStruct-&gt;ETH_Mode | ETH_InitStruct-&gt;ETH_ChecksumOffload | ETH_InitStruct-&gt;ETH_RetryTransmission | ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip | ETH_InitStruct-&gt;ETH_BackOffLimit | ETH_InitStruct-&gt;ETH_DeferralCheck); /* Write to ETHERNET MACCR */ ETH-&gt;MACCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACFFR Configuration --------------------*/ /* Set the RA bit according to ETH_ReceiveAll value */ /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */ /* Set the PCF bit according to ETH_PassControlFrames value */ /* Set the DBF bit according to ETH_BroadcastFramesReception value */ /* Set the DAIF bit according to ETH_DestinationAddrFilter value */ /* Set the PR bit according to ETH_PromiscuousMode value */ /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */ /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */ /* Write to ETHERNET MACFFR */ ETH-&gt;MACFFR = (uint32_t)(ETH_InitStruct-&gt;ETH_ReceiveAll | ETH_InitStruct-&gt;ETH_SourceAddrFilter | ETH_InitStruct-&gt;ETH_PassControlFrames | ETH_InitStruct-&gt;ETH_BroadcastFramesReception | ETH_InitStruct-&gt;ETH_DestinationAddrFilter | ETH_InitStruct-&gt;ETH_PromiscuousMode | ETH_InitStruct-&gt;ETH_MulticastFramesFilter | ETH_InitStruct-&gt;ETH_UnicastFramesFilter); /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/ /* Write to ETHERNET MACHTHR */ ETH-&gt;MACHTHR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableHigh; /* Write to ETHERNET MACHTLR */ ETH-&gt;MACHTLR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableLow; /*----------------------- ETHERNET MACFCR Configuration --------------------*/ /* Get the ETHERNET MACFCR value */ tmpreg = ETH-&gt;MACFCR; /* Clear xx bits */ tmpreg &amp;= MACFCR_CLEAR_MASK; /* Set the PT bit according to ETH_PauseTime value */ /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */ /* Set the PLT bit according to ETH_PauseLowThreshold value */ /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */ /* Set the RFE bit according to ETH_ReceiveFlowControl value */ /* Set the TFE bit according to ETH_TransmitFlowControl value */ tmpreg |= (uint32_t)((ETH_InitStruct-&gt;ETH_PauseTime &lt;&lt; 16) | ETH_InitStruct-&gt;ETH_ZeroQuantaPause | ETH_InitStruct-&gt;ETH_PauseLowThreshold | ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect | ETH_InitStruct-&gt;ETH_ReceiveFlowControl | ETH_InitStruct-&gt;ETH_TransmitFlowControl); /* Write to ETHERNET MACFCR */ ETH-&gt;MACFCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/ /* Set the ETV bit according to ETH_VLANTagComparison value */ /* Set the VL bit according to ETH_VLANTagIdentifier value */ ETH-&gt;MACVLANTR = (uint32_t)(ETH_InitStruct-&gt;ETH_VLANTagComparison | ETH_InitStruct-&gt;ETH_VLANTagIdentifier); /*-------------------------------- DMA Config ------------------------------*/ /*----------------------- ETHERNET DMAOMR Configuration --------------------*/ /* Get the ETHERNET DMAOMR value */ tmpreg = ETH-&gt;DMAOMR; /* Clear xx bits */ tmpreg &amp;= DMAOMR_CLEAR_MASK; /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */ /* Set the RSF bit according to ETH_ReceiveStoreForward value */ /* Set the DFF bit according to ETH_FlushReceivedFrame value */ /* Set the TSF bit according to ETH_TransmitStoreForward value */ /* Set the TTC bit according to ETH_TransmitThresholdControl value */ /* Set the FEF bit according to ETH_ForwardErrorFrames value */ /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */ /* Set the RTC bit according to ETH_ReceiveThresholdControl value */ /* Set the OSF bit according to ETH_SecondFrameOperate value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame | ETH_InitStruct-&gt;ETH_ReceiveStoreForward | ETH_InitStruct-&gt;ETH_FlushReceivedFrame | ETH_InitStruct-&gt;ETH_TransmitStoreForward | ETH_InitStruct-&gt;ETH_TransmitThresholdControl | ETH_InitStruct-&gt;ETH_ForwardErrorFrames | ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames | ETH_InitStruct-&gt;ETH_ReceiveThresholdControl | ETH_InitStruct-&gt;ETH_SecondFrameOperate); /* Write to ETHERNET DMAOMR */ ETH-&gt;DMAOMR = (uint32_t)tmpreg; /*----------------------- ETHERNET DMABMR Configuration --------------------*/ /* Set the AAL bit according to ETH_AddressAlignedBeats value */ /* Set the FB bit according to ETH_FixedBurst value */ /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */ /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */ /* Set the DSL bit according to ETH_DesciptorSkipLength value */ /* Set the PR and DA bits according to ETH_DMAArbitration value */ ETH-&gt;DMABMR = (uint32_t)(ETH_InitStruct-&gt;ETH_AddressAlignedBeats | ETH_InitStruct-&gt;ETH_FixedBurst | ETH_InitStruct-&gt;ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */ ETH_InitStruct-&gt;ETH_TxDMABurstLength | (ETH_InitStruct-&gt;ETH_DescriptorSkipLength &lt;&lt; 2) | ETH_InitStruct-&gt;ETH_DMAArbitration | ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */ /* Return Ethernet configuration success */ return ETH_SUCCESS; } /** * @brief Fills each ETH_InitStruct member with its default value. * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized. * @retval None */ void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct) { /* ETH_InitStruct members default value */ /*------------------------ MAC -----------------------------------*/ ETH_InitStruct-&gt;ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; ETH_InitStruct-&gt;ETH_Watchdog = ETH_Watchdog_Enable; ETH_InitStruct-&gt;ETH_Jabber = ETH_Jabber_Enable; ETH_InitStruct-&gt;ETH_InterFrameGap = ETH_InterFrameGap_96Bit; ETH_InitStruct-&gt;ETH_CarrierSense = ETH_CarrierSense_Enable; ETH_InitStruct-&gt;ETH_Speed = ETH_Speed_10M; ETH_InitStruct-&gt;ETH_ReceiveOwn = ETH_ReceiveOwn_Enable; ETH_InitStruct-&gt;ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStruct-&gt;ETH_Mode = ETH_Mode_HalfDuplex; ETH_InitStruct-&gt;ETH_ChecksumOffload = ETH_ChecksumOffload_Disable; ETH_InitStruct-&gt;ETH_RetryTransmission = ETH_RetryTransmission_Enable; ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStruct-&gt;ETH_BackOffLimit = ETH_BackOffLimit_10; ETH_InitStruct-&gt;ETH_DeferralCheck = ETH_DeferralCheck_Disable; ETH_InitStruct-&gt;ETH_ReceiveAll = ETH_ReceiveAll_Disable; ETH_InitStruct-&gt;ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable; ETH_InitStruct-&gt;ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; ETH_InitStruct-&gt;ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStruct-&gt;ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal; ETH_InitStruct-&gt;ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStruct-&gt;ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_HashTableHigh = 0x0; ETH_InitStruct-&gt;ETH_HashTableLow = 0x0; ETH_InitStruct-&gt;ETH_PauseTime = 0x0; ETH_InitStruct-&gt;ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable; ETH_InitStruct-&gt;ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4; ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable; ETH_InitStruct-&gt;ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable; ETH_InitStruct-&gt;ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable; ETH_InitStruct-&gt;ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit; ETH_InitStruct-&gt;ETH_VLANTagIdentifier = 0x0; /*------------------------ DMA -----------------------------------*/ ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; ETH_InitStruct-&gt;ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStruct-&gt;ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable; ETH_InitStruct-&gt;ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStruct-&gt;ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStruct-&gt;ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable; ETH_InitStruct-&gt;ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStruct-&gt;ETH_FixedBurst = ETH_FixedBurst_Disable; ETH_InitStruct-&gt;ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_DescriptorSkipLength = 0x0; ETH_InitStruct-&gt;ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1; } /** * @brief Enables ENET MAC and DMA reception/transmission * @param None * @retval None */ void ETH_Start(void) { /* Enable transmit state machine of the MAC for transmission on the MII */ ETH_MACTransmissionCmd(ENABLE); /* Flush Transmit FIFO */ ETH_FlushTransmitFIFO(); /* Enable receive state machine of the MAC for reception from the MII */ ETH_MACReceptionCmd(ENABLE); /* Start DMA transmission */ ETH_DMATransmissionCmd(ENABLE); /* Start DMA reception */ ETH_DMAReceptionCmd(ENABLE); } /** * @brief Transmits a packet, from application buffer, pointed by ppkt. * @param ppkt: pointer to the application&#39;s packet buffer to transmit. * @param FrameLength: Tx Packet size. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength) { uint32_t offset = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMATxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt. * @param ppkt: pointer to the application packet receive buffer. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandleRxPkt(uint8_t *ppkt) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @brief Get the size of received the received packet. * @param None * @retval framelength: received packet size */ uint32_t ETH_GetRxPktSize(void) { uint32_t frameLength = 0; if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the size of the packet: including 4 bytes of the CRC */ frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet); } /* Return Frame Length */ return frameLength; } /** * @brief Drop a Received packet (too small packet, etc...) * @param None * @retval None */ void ETH_DropRxPkt(void) { /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read: this will be the first Rx descriptor in this case */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } } /*--------------------------------- PHY ------------------------------------*/ /** * @brief Read a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR: Tranceiver Basic Control Register * @arg PHY_BSR: Tranceiver Basic Status Register * @arg PHY_SR : Tranceiver Status Register * @arg More PHY register could be read depending on the used PHY * @retval ETH_ERROR: in case of timeout * MAC MIIDR register value: Data read from the selected PHY register (correct read ) */ uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII address register value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg &amp;= ~ETH_MACMIIAR_MW; /* Set the read mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_READ_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return (uint16_t)ETH_ERROR; } /* Return data register value */ return (uint16_t)(ETH-&gt;MACMIIDR); } /** * @brief Write to a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR : Tranceiver Control Register * @arg More PHY register could be written depending on the used PHY * @param PHYValue: the value to write * @retval ETH_ERROR: in case of timeout * ETH_SUCCESS: for correct write */ uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII register address value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg |= ETH_MACMIIAR_MW; /* Set the write mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Give the value to the MII data register */ ETH-&gt;MACMIIDR = PHYValue; /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_WRITE_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_WRITE_TO) { return ETH_ERROR; } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Enables or disables the PHY loopBack mode. * @Note: Don&#39;t be confused with ETH_MACLoopBackCmd function which enables internal * loopback at MII level * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: * @param NewState: new state of the PHY loopBack mode. * This parameter can be: ENABLE or DISABLE. * @retval ETH_ERROR: in case of bad PHY configuration * ETH_SUCCESS: for correct PHY configuration */ uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState) { uint16_t tmpreg = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_FUNCTIONAL_STATE(NewState)); /* Get the PHY configuration to update it */ tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); if (NewState != DISABLE) { /* Enable the PHY loopback mode */ tmpreg |= PHY_Loopback; } else { /* Disable the PHY loopback mode: normal mode */ tmpreg &amp;= (uint16_t)(~(uint16_t)PHY_Loopback); } /* Update the PHY control register with the new configuration */ if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET) { return ETH_SUCCESS; } else { /* Return SUCCESS */ return ETH_ERROR; } } /*--------------------------------- MAC ------------------------------------*/ /** * @brief Enables or disables the MAC transmission. * @param NewState: new state of the MAC transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACTransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC transmission */ ETH-&gt;MACCR |= ETH_MACCR_TE; } else { /* Disable the MAC transmission */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_TE; } } /** * @brief Enables or disables the MAC reception. * @param NewState: new state of the MAC reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC reception */ ETH-&gt;MACCR |= ETH_MACCR_RE; } else { /* Disable the MAC reception */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_RE; } } /** * @brief Checks whether the ETHERNET flow control busy bit is set or not. * @param None * @retval The new state of flow control busy status bit (SET or RESET). */ FlagStatus ETH_GetFlowControlBusyStatus(void) { FlagStatus bitstatus = RESET; /* The Flow Control register should not be written to until this bit is cleared */ if ((ETH-&gt;MACFCR &amp; ETH_MACFCR_FCBBPA) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Initiate a Pause Control Frame (Full-duplex only). * @param None * @retval None */ void ETH_InitiatePauseControlFrame(void) { /* When Set In full duplex MAC initiates pause control frame */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } /** * @brief Enables or disables the MAC BackPressure operation activation (Half-duplex only). * @param NewState: new state of the MAC BackPressure operation activation. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_BackPressureActivationCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Activate the MAC BackPressure operation */ /* In Half duplex: during backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } else { /* Desactivate the MAC BackPressure operation */ ETH-&gt;MACFCR &amp;= ~ETH_MACFCR_FCBBPA; } } /** * @brief Checks whether the specified ETHERNET MAC flag is set or not. * @param ETH_MAC_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_MAC_FLAG_TST : Time stamp trigger flag * @arg ETH_MAC_FLAG_MMCT : MMC transmit flag * @arg ETH_MAC_FLAG_MMCR : MMC receive flag * @arg ETH_MAC_FLAG_MMC : MMC flag * @arg ETH_MAC_FLAG_PMT : PMT flag * @retval The new state of ETHERNET MAC flag (SET or RESET). */ FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); if ((ETH-&gt;MACSR &amp; ETH_MAC_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET MAC interrupt has occurred or not. * @param ETH_MAC_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_MMCT : MMC transmit interrupt * @arg ETH_MAC_IT_MMCR : MMC receive interrupt * @arg ETH_MAC_IT_MMC : MMC interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @retval The new state of ETHERNET MAC interrupt (SET or RESET). */ ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); if ((ETH-&gt;MACSR &amp; ETH_MAC_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the specified ETHERNET MAC interrupts. * @param ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @param NewState: new state of the specified ETHERNET MAC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_IT(ETH_MAC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR &amp;= (~(uint32_t)ETH_MAC_IT); } else { /* Disable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR |= ETH_MAC_IT; } } /** * @brief Configures the selected MAC address. * @param MacAddr: The MAC addres to configure. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Calculate the selectecd MAC address high register */ tmpreg = ((uint32_t)Addr[5] &lt;&lt; 8) | (uint32_t)Addr[4]; /* Load the selectecd MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg; /* Calculate the selectecd MAC address low register */ tmpreg = ((uint32_t)Addr[3] &lt;&lt; 24) | ((uint32_t)Addr[2] &lt;&lt; 16) | ((uint32_t)Addr[1] &lt;&lt; 8) | Addr[0]; /* Load the selectecd MAC address low register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg; } /** * @brief Get the selected MAC address. * @param MacAddr: The MAC addres to return. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Get the selectecd MAC address high register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[5] = ((tmpreg &gt;&gt; 8) &amp; (uint8_t)0xFF); Addr[4] = (tmpreg &amp; (uint8_t)0xFF); /* Load the selectecd MAC address low register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[3] = ((tmpreg &gt;&gt; 24) &amp; (uint8_t)0xFF); Addr[2] = ((tmpreg &gt;&gt; 16) &amp; (uint8_t)0xFF); Addr[1] = ((tmpreg &gt;&gt; 8 ) &amp; (uint8_t)0xFF); Addr[0] = (tmpreg &amp; (uint8_t)0xFF); } /** * @brief Enables or disables the Address filter module uses the specified * ETHERNET MAC address for perfect filtering * @param MacAddr: specifies the ETHERNET MAC address to be used for prfect filtering. * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param NewState: new state of the specified ETHERNET MAC address use. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE; } else { /* Disable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_AE); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Filter: specifies the used frame received field for comparaison * This parameter can be one of the following values: * @arg ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the * SA fields of the received frame. * @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the * DA fields of the received frame. * @retval None */ void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter)); if (Filter != ETH_MAC_AddressFilter_DA) { /* The selected ETHERNET MAC address is used to compare with the SA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA; } else { /* The selected ETHERNET MAC address is used to compare with the DA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_SA); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param MaskByte: specifies the used address bytes for comparaison * This parameter can be any combination of the following values: * @arg ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0]. * @arg ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24]. * @arg ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16]. * @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0]. * @retval None */ void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte)); /* Clear MBC bits in the selected MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_MBC); /* Set the selected Filetr mask bytes */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte; } /*------------------------ DMA Tx/Rx Desciptors -----------------------------*/ /** * @brief Initializes the DMA Tx descriptors in chain mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Second Address Chained bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Tx descriptors in ring mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff1: Pointer on the first TxBuffer1 list * @param TxBuff2: Pointer on the first TxBuffer2 list * @param TxBuffCount: Number of the used Tx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;TxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (TxBuffCount-1)) { /* Set Transmit End of Ring bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TER; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Checks whether the specified ETHERNET DMA Tx Desc flag is set or not. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param ETH_DMATxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine * @arg ETH_DMATxDesc_IC : Interrupt on completetion * @arg ETH_DMATxDesc_LS : Last Segment * @arg ETH_DMATxDesc_FS : First Segment * @arg ETH_DMATxDesc_DC : Disable CRC * @arg ETH_DMATxDesc_DP : Disable Pad * @arg ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable * @arg ETH_DMATxDesc_TER : Transmit End of Ring * @arg ETH_DMATxDesc_TCH : Second Address Chained * @arg ETH_DMATxDesc_TTSS: Tx Time Stamp Status * @arg ETH_DMATxDesc_IHE : IP Header Error * @arg ETH_DMATxDesc_ES : Error summary * @arg ETH_DMATxDesc_JT : Jabber Timeout * @arg ETH_DMATxDesc_FF : Frame Flushed: DMA/MTL flushed the frame due to SW flush * @arg ETH_DMATxDesc_PCE : Payload Checksum Error * @arg ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during tramsmission * @arg ETH_DMATxDesc_NC : No Carrier: no carrier signal from the tranceiver * @arg ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision * @arg ETH_DMATxDesc_EC : Excessive Collision: transmission aborted after 16 collisions * @arg ETH_DMATxDesc_VF : VLAN Frame * @arg ETH_DMATxDesc_CC : Collision Count * @arg ETH_DMATxDesc_ED : Excessive Deferral * @arg ETH_DMATxDesc_UF : Underflow Error: late data arrival from the memory * @arg ETH_DMATxDesc_DB : Deferred Bit * @retval The new state of ETH_DMATxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag)); if ((DMATxDesc-&gt;Status &amp; ETH_DMATxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Returns the specified ETHERNET DMA Tx Desc collision count. * @param DMATxDesc: pointer on a DMA Tx descriptor * @retval The Transmit descriptor collision counter value. */ uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc) { /* Return the Receive descriptor frame length */ return ((DMATxDesc-&gt;Status &amp; ETH_DMATxDesc_CC) &gt;&gt; ETH_DMATXDESC_COLLISION_COUNTSHIFT); } /** * @brief Set the specified DMA Tx Desc Own bit. * @param DMATxDesc: Pointer on a Tx desc * @retval None */ void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc) { /* Set the DMA Tx Desc Own bit */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_OWN; } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param NewState: new state of the DMA Tx Desc transmit interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_IC; } else { /* Disable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_IC); } } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_LastSegment : actual Tx desc contain last segment * @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment * @retval None */ void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment)); /* Selects the DMA Tx Desc Frame segment */ DMATxDesc-&gt;Status |= DMATxDesc_FrameSegment; } /** * @brief Selects the specified ETHERNET DMA Tx Desc Checksum Insertion. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_ChecksumByPass : Checksum bypass * @arg ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header * @retval None */ void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum)); /* Set the selected DMA Tx desc checksum insertion control */ DMATxDesc-&gt;Status |= DMATxDesc_Checksum; } /** * @brief Enables or disables the DMA Tx Desc CRC. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc CRC. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DC); } else { /* Disable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DC; } } /** * @brief Enables or disables the DMA Tx Desc end of ring. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TER; } else { /* Disable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_TER); } } /** * @brief Enables or disables the DMA Tx Desc second address chained. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TCH; } else { /* Disable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TCH); } } /** * @brief Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DP); } else { /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DP; } } /** * @brief Enables or disables the DMA Tx Desc time stamp. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc time stamp. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TTSE; } else { /* Disable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TTSE); } } /** * @brief Configures the specified DMA Tx Desc buffer1 and buffer2 sizes. * @param DMATxDesc: Pointer on a Tx desc * @param BufferSize1: specifies the Tx desc buffer1 size. * @param BufferSize2: specifies the Tx desc buffer2 size (put &quot;0&quot; if not used). * @retval None */ void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2) { /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1)); assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2)); /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */ DMATxDesc-&gt;ControlBufferSize |= (BufferSize1 | (BufferSize2 &lt;&lt; ETH_DMATXDESC_BUFFER2_SIZESHIFT)); } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Initializes the DMA Rx descriptors in ring mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff1: Pointer on the first RxBuffer1 list * @param RxBuff2: Pointer on the first RxBuffer2 list * @param RxBuffCount: Number of the used Rx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size */ DMARxDesc-&gt;ControlBufferSize = ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;RxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (RxBuffCount-1)) { /* Set Receive End of Ring bit */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Checks whether the specified ETHERNET Rx Desc flag is set or not. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param ETH_DMARxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMARxDesc_OWN: OWN bit: descriptor is owned by DMA engine * @arg ETH_DMARxDesc_AFM: DA Filter Fail for the rx frame * @arg ETH_DMARxDesc_ES: Error summary * @arg ETH_DMARxDesc_DE: Desciptor error: no more descriptors for receive frame * @arg ETH_DMARxDesc_SAF: SA Filter Fail for the received frame * @arg ETH_DMARxDesc_LE: Frame size not matching with length field * @arg ETH_DMARxDesc_OE: Overflow Error: Frame was damaged due to buffer overflow * @arg ETH_DMARxDesc_VLAN: VLAN Tag: received frame is a VLAN frame * @arg ETH_DMARxDesc_FS: First descriptor of the frame * @arg ETH_DMARxDesc_LS: Last descriptor of the frame * @arg ETH_DMARxDesc_IPV4HCE: IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error * @arg ETH_DMARxDesc_LC: Late collision occurred during reception * @arg ETH_DMARxDesc_FT: Frame type - Ethernet, otherwise 802.3 * @arg ETH_DMARxDesc_RWT: Receive Watchdog Timeout: watchdog timer expired during reception * @arg ETH_DMARxDesc_RE: Receive error: error reported by MII interface * @arg ETH_DMARxDesc_DE: Dribble bit error: frame contains non int multiple of 8 bits * @arg ETH_DMARxDesc_CE: CRC error * @arg ETH_DMARxDesc_MAMPCE: Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error * @retval The new state of ETH_DMARxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag)); if ((DMARxDesc-&gt;Status &amp; ETH_DMARxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Set the specified DMA Rx Desc Own bit. * @param DMARxDesc: Pointer on a Rx desc * @retval None */ void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc) { /* Set the DMA Rx Desc Own bit */ DMARxDesc-&gt;Status |= ETH_DMARxDesc_OWN; } /** * @brief Returns the specified DMA Rx Desc frame length. * @param DMARxDesc: pointer on a DMA Rx descriptor * @retval The Rx descriptor received frame length. */ uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc) { /* Return the Receive descriptor frame length */ return ((DMARxDesc-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT); } /** * @brief Enables or disables the specified DMA Rx Desc receive interrupt. * @param DMARxDesc: Pointer on a Rx desc * @param NewState: new state of the specified DMA Rx Desc interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_DIC); } else { /* Disable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_DIC; } } /** * @brief Enables or disables the DMA Rx Desc end of ring. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } else { /* Disable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RER); } } /** * @brief Enables or disables the DMA Rx Desc second address chained. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RCH; } else { /* Disable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RCH); } } /** * @brief Returns the specified ETHERNET DMA Rx Desc buffer size. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param DMARxDesc_Buffer: specifies the DMA Rx Desc buffer. * This parameter can be any one of the following values: * @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1 * @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2 * @retval The Receive descriptor frame length. */ uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer) { /* Check the parameters */ assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer)); if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1) { /* Return the DMA Rx Desc buffer2 size */ return ((DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS2) &gt;&gt; ETH_DMARXDESC_BUFFER2_SIZESHIFT); } else { /* Return the DMA Rx Desc buffer1 size */ return (DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS1); } } /*--------------------------------- DMA ------------------------------------*/ /** * @brief Resets all MAC subsystem internal registers and logic. * @param None * @retval None */ void ETH_SoftwareReset(void) { /* Set the SWR bit: resets all MAC subsystem internal registers and logic */ /* After reset all the registers holds their respective reset values */ ETH-&gt;DMABMR |= ETH_DMABMR_SR; } /** * @brief Checks whether the ETHERNET software reset bit is set or not. * @param None * @retval The new state of DMA Bus Mode register SR bit (SET or RESET). */ FlagStatus ETH_GetSoftwareResetStatus(void) { FlagStatus bitstatus = RESET; if((ETH-&gt;DMABMR &amp; ETH_DMABMR_SR) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET DMA flag is set or not. * @param ETH_DMA_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_FLAG_TST : Time-stamp trigger flag * @arg ETH_DMA_FLAG_PMT : PMT flag * @arg ETH_DMA_FLAG_MMC : MMC flag * @arg ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access * @arg ETH_DMA_FLAG_ReadWriteError : Error bits 0-write trnsf, 1-read transfr * @arg ETH_DMA_FLAG_AccessError : Error bits 0-Rx DMA, 1-Tx DMA * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ET : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Underflow flag * @arg ETH_DMA_FLAG_RO : Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval The new state of ETH_DMA_FLAG (SET or RESET). */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG)); if ((ETH-&gt;DMASR &amp; ETH_DMA_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA pending flag. * @param ETH_DMA_FLAG: specifies the flag to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ETI : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Transmit Underflow flag * @arg ETH_DMA_FLAG_RO : Receive Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval None */ void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG) { /* Check the parameters */ assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG)); /* Clear the selected ETHERNET DMA FLAG */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_FLAG; } /** * @brief Checks whether the specified ETHERNET DMA interrupt has occured or not. * @param ETH_DMA_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_DMA_IT_TST : Time-stamp trigger interrupt * @arg ETH_DMA_IT_PMT : PMT interrupt * @arg ETH_DMA_IT_MMC : MMC interrupt * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval The new state of ETH_DMA_IT (SET or RESET). */ ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT)); if ((ETH-&gt;DMASR &amp; ETH_DMA_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA IT pending bit. * @param ETH_DMA_IT: specifies the interrupt pending bit to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ETI : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Transmit Underflow interrupt * @arg ETH_DMA_IT_RO : Receive Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval None */ void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); /* Clear the selected ETHERNET DMA IT */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_IT; } /** * @brief Returns the ETHERNET DMA Transmit Process State. * @param None * @retval The new ETHERNET DMA Transmit Process State: * This can be one of the following values: * - ETH_DMA_TransmitProcess_Stopped : Stopped - Reset or Stop Tx Command issued * - ETH_DMA_TransmitProcess_Fetching : Running - fetching the Tx descriptor * - ETH_DMA_TransmitProcess_Waiting : Running - waiting for status * - ETH_DMA_TransmitProcess_Reading : unning - reading the data from host memory * - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe * - ETH_DMA_TransmitProcess_Closing : Running - closing Rx descriptor */ uint32_t ETH_GetTransmitProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_TS)); } /** * @brief Returns the ETHERNET DMA Receive Process State. * @param None * @retval The new ETHERNET DMA Receive Process State: * This can be one of the following values: * - ETH_DMA_ReceiveProcess_Stopped : Stopped - Reset or Stop Rx Command issued * - ETH_DMA_ReceiveProcess_Fetching : Running - fetching the Rx descriptor * - ETH_DMA_ReceiveProcess_Waiting : Running - waiting for packet * - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable * - ETH_DMA_ReceiveProcess_Closing : Running - closing descriptor * - ETH_DMA_ReceiveProcess_Queuing : Running - queuing the recieve frame into host memory */ uint32_t ETH_GetReceiveProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_RS)); } /** * @brief Clears the ETHERNET transmit FIFO. * @param None * @retval None */ void ETH_FlushTransmitFIFO(void) { /* Set the Flush Transmit FIFO bit */ ETH-&gt;DMAOMR |= ETH_DMAOMR_FTF; } /** * @brief Checks whether the ETHERNET transmit FIFO bit is cleared or not. * @param None * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET). */ FlagStatus ETH_GetFlushTransmitFIFOStatus(void) { FlagStatus bitstatus = RESET; if ((ETH-&gt;DMAOMR &amp; ETH_DMAOMR_FTF) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the DMA transmission. * @param NewState: new state of the DMA transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA transmission */ ETH-&gt;DMAOMR |= ETH_DMAOMR_ST; } else { /* Disable the DMA transmission */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_ST; } } /** * @brief Enables or disables the DMA reception. * @param NewState: new state of the DMA reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA reception */ ETH-&gt;DMAOMR |= ETH_DMAOMR_SR; } else { /* Disable the DMA reception */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_SR; } } /** * @brief Enables or disables the specified ETHERNET DMA interrupts. * @param ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @param NewState: new state of the specified ETHERNET DMA interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER |= ETH_DMA_IT; } else { /* Disable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER &amp;=(~(uint32_t)ETH_DMA_IT); } } /** * @brief Checks whether the specified ETHERNET DMA overflow flag is set or not. * @param ETH_DMA_Overflow: specifies the DMA overflow flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter * @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET). */ FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow)); if ((ETH-&gt;DMAMFBOCR &amp; ETH_DMA_Overflow) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Get the ETHERNET DMA Rx Overflow Missed Frame Counter value. * @param None * @retval The value of Rx overflow Missed Frame Counter. */ uint32_t ETH_GetRxOverflowMissedFrameCounter(void) { return ((uint32_t)((ETH-&gt;DMAMFBOCR &amp; ETH_DMAMFBOCR_MFA)&gt;&gt;ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT)); } /** * @brief Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value. * @param None * @retval The value of Buffer unavailable Missed Frame Counter. */ uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void) { return ((uint32_t)(ETH-&gt;DMAMFBOCR) &amp; ETH_DMAMFBOCR_MFC); } /** * @brief Get the ETHERNET DMA DMACHTDR register value. * @param None * @retval The value of the current Tx desc start address. */ uint32_t ETH_GetCurrentTxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTDR)); } /** * @brief Get the ETHERNET DMA DMACHRDR register value. * @param None * @retval The value of the current Rx desc start address. */ uint32_t ETH_GetCurrentRxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRDR)); } /** * @brief Get the ETHERNET DMA DMACHTBAR register value. * @param None * @retval The value of the current Tx buffer address. */ uint32_t ETH_GetCurrentTxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTBAR)); } /** * @brief Get the ETHERNET DMA DMACHRBAR register value. * @param None * @retval The value of the current Rx buffer address. */ uint32_t ETH_GetCurrentRxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRBAR)); } /** * @brief Resumes the DMA Transmission by writing to the DmaTxPollDemand register * (the data written could be anything). This forces the DMA to resume transmission. * @param None * @retval None. */ void ETH_ResumeDMATransmission(void) { ETH-&gt;DMATPDR = 0; } /** * @brief Resumes the DMA Transmission by writing to the DmaRxPollDemand register * (the data written could be anything). This forces the DMA to resume reception. * @param None * @retval None. */ void ETH_ResumeDMAReception(void) { ETH-&gt;DMARPDR = 0; } /*--------------------------------- PMT ------------------------------------*/ /** * @brief Reset Wakeup frame filter register pointer. * @param None * @retval None */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void) { /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFFRPR; } /** * @brief Populates the remote wakeup frame registers. * @param Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words). * @retval None */ void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer) { uint32_t i = 0; /* Fill Remote Wake-up Frame Filter register with Buffer data */ for(i =0; i&lt;ETH_WAKEUP_REGISTER_LENGTH; i++) { /* Write each time to the same register */ ETH-&gt;MACRWUFFR = Buffer[i]; } } /** * @brief Enables or disables any unicast packet filtered by the MAC address * recognition to be a wake-up frame. * @param NewState: new state of the MAC Global Unicast Wake-Up. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_GU; } else { /* Disable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_GU; } } /** * @brief Checks whether the specified ETHERNET PMT flag is set or not. * @param ETH_PMT_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Poniter Reset * @arg ETH_PMT_FLAG_WUFR : Wake-Up Frame Received * @arg ETH_PMT_FLAG_MPR : Magic Packet Received * @retval The new state of ETHERNET PMT Flag (SET or RESET). */ FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG)); if ((ETH-&gt;MACPMTCSR &amp; ETH_PMT_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the MAC Wake-Up Frame Detection. * @param NewState: new state of the MAC Wake-Up Frame Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFE; } else { /* Disable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_WFE; } } /** * @brief Enables or disables the MAC Magic Packet Detection. * @param NewState: new state of the MAC Magic Packet Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MagicPacketDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_MPE; } else { /* Disable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_MPE; } } /** * @brief Enables or disables the MAC Power Down. * @param NewState: new state of the MAC Power Down. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PowerDownCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Power Down */ /* This puts the MAC in power down mode */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_PD; } else { /* Disable the MAC Power Down */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_PD; } } /*--------------------------------- MMC ------------------------------------*/ /** * @brief Enables or disables the MMC Counter Freeze. * @param NewState: new state of the MMC Counter Freeze. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter Freeze */ ETH-&gt;MMCCR |= ETH_MMCCR_MCF; } else { /* Disable the MMC Counter Freeze */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_MCF; } } /** * @brief Enables or disables the MMC Reset On Read. * @param NewState: new state of the MMC Reset On Read. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCResetOnReadCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter reset on read */ ETH-&gt;MMCCR |= ETH_MMCCR_ROR; } else { /* Disable the MMC Counter reset on read */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_ROR; } } /** * @brief Enables or disables the MMC Counter Stop Rollover. * @param NewState: new state of the MMC Counter Stop Rollover. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterRolloverCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Disable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_CSR; } else { /* Enable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR |= ETH_MMCCR_CSR; } } /** * @brief Resets the MMC Counters. * @param None * @retval None */ void ETH_MMCCountersReset(void) { /* Resets the MMC Counters */ ETH-&gt;MMCCR |= ETH_MMCCR_CR; } /** * @brief Enables or disables the specified ETHERNET MMC interrupts. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. * This parameter can be any combination of Tx interrupt or * any combination of Rx interrupt (but not both)of the following values: * @arg ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value * @param NewState: new state of the specified ETHERNET MMC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MMC_IT(ETH_MMC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* Remove egister mak from IT */ ETH_MMC_IT &amp;= 0xEFFFFFFF; /* ETHERNET MMC Rx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR |= ETH_MMC_IT; } } else { /* ETHERNET MMC Tx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR |= ETH_MMC_IT; } } } /** * @brief Checks whether the specified ETHERNET MMC IT is set or not. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt. * This parameter can be one of the following values: * @arg ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value * @retval The value of ETHERNET MMC IT (SET or RESET). */ ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* ETHERNET MMC Rx interrupts selected */ /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCRIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } else { /* ETHERNET MMC Tx interrupts selected */ /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCTIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } return bitstatus; } /** * @brief Get the specified ETHERNET MMC register value. * @param ETH_MMCReg: specifies the ETHERNET MMC register. * This parameter can be one of the following values: * @arg ETH_MMCCR : MMC CR register * @arg ETH_MMCRIR : MMC RIR register * @arg ETH_MMCTIR : MMC TIR register * @arg ETH_MMCRIMR : MMC RIMR register * @arg ETH_MMCTIMR : MMC TIMR register * @arg ETH_MMCTGFSCCR : MMC TGFSCCR register * @arg ETH_MMCTGFMSCCR: MMC TGFMSCCR register * @arg ETH_MMCTGFCR : MMC TGFCR register * @arg ETH_MMCRFCECR : MMC RFCECR register * @arg ETH_MMCRFAECR : MMC RFAECR register * @arg ETH_MMCRGUFCR : MMC RGUFCRregister * @retval The value of ETHERNET MMC Register value. */ uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg) { /* Check the parameters */ assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg)); } /*--------------------------------- PTP ------------------------------------*/ /** * @brief Updated the PTP block for fine correction with the Time Stamp Addend register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampAddend(void) { /* Enable the PTP block update with the Time Stamp Addend register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSARU; } /** * @brief Enable the PTP Time Stamp interrupt trigger * @param None * @retval None */ void ETH_EnablePTPTimeStampInterruptTrigger(void) { /* Enable the PTP target time interrupt */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSITE; } /** * @brief Updated the PTP system time with the Time Stamp Update register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampUpdate(void) { /* Enable the PTP system time update with the Time Stamp Update register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTU; } /** * @brief Initialize the PTP Time Stamp * @param None * @retval None */ void ETH_InitializePTPTimeStamp(void) { /* Initialize the PTP Time Stamp */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTI; } /** * @brief Selects the PTP Update method * @param UpdateMethod: the PTP Update method * This parameter can be one of the following values: * @arg ETH_PTP_FineUpdate : Fine Update method * @arg ETH_PTP_CoarseUpdate : Coarse Update method * @retval None */ void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod) { /* Check the parameters */ assert_param(IS_ETH_PTP_UPDATE(UpdateMethod)); if (UpdateMethod != ETH_PTP_CoarseUpdate) { /* Enable the PTP Fine Update method */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSFCU; } else { /* Disable the PTP Coarse Update method */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSFCU); } } /** * @brief Enables or disables the PTP time stamp for transmit and receive frames. * @param NewState: new state of the PTP time stamp for transmit and receive frames * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PTPTimeStampCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSE; } else { /* Disable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSE); } } /** * @brief Checks whether the specified ETHERNET PTP flag is set or not. * @param ETH_PTP_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PTP_FLAG_TSARU : Addend Register Update * @arg ETH_PTP_FLAG_TSITE : Time Stamp Interrupt Trigger Enable * @arg ETH_PTP_FLAG_TSSTU : Time Stamp Update * @arg ETH_PTP_FLAG_TSSTI : Time Stamp Initialize * @retval The new state of ETHERNET PTP Flag (SET or RESET). */ FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG)); if ((ETH-&gt;PTPTSCR &amp; ETH_PTP_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Sets the system time Sub-Second Increment value. * @param SubSecondValue: specifies the PTP Sub-Second Increment Register value. * @retval None */ void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue)); /* Set the PTP Sub-Second Increment Register */ ETH-&gt;PTPSSIR = SubSecondValue; } /** * @brief Sets the Time Stamp update sign and values. * @param Sign: specifies the PTP Time update value sign. * This parameter can be one of the following values: * @arg ETH_PTP_PositiveTime : positive time value. * @arg ETH_PTP_NegativeTime : negative time value. * @param SecondValue: specifies the PTP Time update second value. * @param SubSecondValue: specifies the PTP Time update sub-second value. * This parameter is a 31 bit value, bit32 correspond to the sign. * @retval None */ void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_TIME_SIGN(Sign)); assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); /* Set the PTP Time Update High Register */ ETH-&gt;PTPTSHUR = SecondValue; /* Set the PTP Time Update Low Register with sign */ ETH-&gt;PTPTSLUR = Sign | SubSecondValue; } /** * @brief Sets the Time Stamp Addend value. * @param Value: specifies the PTP Time Stamp Addend Register value. * @retval None */ void ETH_SetPTPTimeStampAddend(uint32_t Value) { /* Set the PTP Time Stamp Addend Register */ ETH-&gt;PTPTSAR = Value; } /** * @brief Sets the Target Time registers values. * @param HighValue: specifies the PTP Target Time High Register value. * @param LowValue: specifies the PTP Target Time Low Register value. * @retval None */ void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue) { /* Set the PTP Target Time High Register */ ETH-&gt;PTPTTHR = HighValue; /* Set the PTP Target Time Low Register */ ETH-&gt;PTPTTLR = LowValue; } /** * @brief Get the specified ETHERNET PTP register value. * @param ETH_PTPReg: specifies the ETHERNET PTP register. * This parameter can be one of the following values: * @arg ETH_PTPTSCR : Sub-Second Increment Register * @arg ETH_PTPSSIR : Sub-Second Increment Register * @arg ETH_PTPTSHR : Time Stamp High Register * @arg ETH_PTPTSLR : Time Stamp Low Register * @arg ETH_PTPTSHUR : Time Stamp High Update Register * @arg ETH_PTPTSLUR : Time Stamp Low Update Register * @arg ETH_PTPTSAR : Time Stamp Addend Register * @arg ETH_PTPTTHR : Target Time High Register * @arg ETH_PTPTTLR : Target Time Low Register * @retval The value of ETHERNET PTP Register value. */ uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg) { /* Check the parameters */ assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg)); } /** * @brief Initializes the DMA Tx descriptors in chain mode with PTP. * @param DMATxDescTab: Pointer on the first Tx desc list * @param DMAPTPTxDescTab: Pointer on the first PTP Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; DMAPTPTxDescToSet = DMAPTPTxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab+i; /* Set Second Address Chained bit and enable PTP */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr =(uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */ (&amp;DMAPTPTxDescTab[i])-&gt;Buffer1Addr = DMATxDesc-&gt;Buffer1Addr; (&amp;DMAPTPTxDescTab[i])-&gt;Buffer2NextDescAddr = DMATxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPTxDescTab desc status record the first list address */ (&amp;DMAPTPTxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPTxDescTab; /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param DMAPTPRxDescTab: Pointer on the first PTP Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; DMAPTPRxDescToGet = DMAPTPRxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */ (&amp;DMAPTPRxDescTab[i])-&gt;Buffer1Addr = DMARxDesc-&gt;Buffer1Addr; (&amp;DMAPTPRxDescTab[i])-&gt;Buffer2NextDescAddr = DMARxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPRxDescTab desc status record the first list address */ (&amp;DMAPTPRxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPRxDescTab; /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Transmits a packet, from application buffer, pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet buffer to transmit. * @param FrameLength: Tx Packet size. * @param PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab) { uint32_t offset = 0, timeout = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMAPTPTxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; (uint32_t)0x1FFF); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Wait for ETH_DMATxDesc_TTSS flag to be set */ do { timeout++; } while (!(DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TTSS) &amp;&amp; (timeout &lt; 0xFFFF)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return ETH_ERROR; } /* Clear the DMATxDescToSet status register TTSS flag */ DMATxDescToSet-&gt;Status &amp;= ~ETH_DMATxDesc_TTSS; *PTPTxTab++ = DMATxDescToSet-&gt;Buffer1Addr; *PTPTxTab = DMATxDescToSet-&gt;Buffer2NextDescAddr; /* Update the ENET DMA current descriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Buffer2NextDescAddr); if(DMAPTPTxDescToSet-&gt;Status != 0) { DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Status); } else { DMAPTPTxDescToSet++; } } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read: this will be the first Tx descriptor in this case */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet receive buffer. * @param PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ENET or CPU */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } *PTPRxTab++ = DMARxDescToGet-&gt;Buffer1Addr; *PTPRxTab = DMARxDescToGet-&gt;Buffer2NextDescAddr; /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status |= ETH_DMARxDesc_OWN; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Buffer2NextDescAddr); if(DMAPTPRxDescToGet-&gt;Status != 0) { DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Status); } else { DMAPTPRxDescToGet++; } } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @} */ /* * STM32 Eth Driver * Change Logs: * Date Author Notes * 2009-10-05 Bernard eth interface driver for STM32F107 CL */ #include &lt;netif/ethernetif.h&gt; #include &lt;netif/etharp.h&gt; #include &lt;lwip/icmp.h&gt; #include &quot;lwipopts.h&quot; #define ETH_DEBUG //#define ETH_RX_DUMP //#define ETH_TX_DUMP #ifdef ETH_DEBUG #define STM32_ETH_TRACE FreeRTOS_printf #else #define STM32_ETH_TRACE(...) #endif /* ETH_DEBUG */ #if defined(ETH_RX_DUMP) || defined(ETH_TX_DUMP) static void packet_dump(const char * msg, const struct pbuf* p) { rt_uint32_t i; u8 *ptr = p-&gt;payload; STM32_ETH_TRACE(&quot;%s %d byte\n&quot;, msg, p-&gt;tot_len); for(i=0; i&lt;p-&gt;tot_len; i++) { if( (i%8) == 0 ) { STM32_ETH_TRACE(&quot; &quot;); } if( (i%16) == 0 ) { STM32_ETH_TRACE(&quot;\r\n&quot;); } STM32_ETH_TRACE(&quot;%02x &quot;,*ptr); ptr++; } STM32_ETH_TRACE(&quot;\n\n&quot;); } #endif /* dump */ static ETH_InitTypeDef ETH_InitStructure; /* initialize the interface */ /** * @brief Configures the Ethernet Interface * @param None * @retval None */ void Ethernet_Configuration(void) { vu32 Value = 0; /* Reset ETHERNET on AHB Bus */ ETH_DeInit(); /* Software reset */ ETH_SoftwareReset(); /* Wait for software reset */ while(ETH_GetSoftwareResetStatus()==SET); /* ETHERNET Configuration ------------------------------------------------------*/ /* Call ETH_StructInit if you don&#39;t like to configure all ETH_InitStructure parameter */ ETH_StructInit(&amp;ETH_InitStructure); /* Fill ETH_InitStructure parametrs */ /*------------------------ MAC -----------------------------------*/ ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable ; ETH_InitStructure.ETH_Speed = ETH_Speed_100M; ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex; ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable; ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable; ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; #if CHECKSUM_BY_HARDWARE ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable; #endif /* CHECKSUM_BY_HARDWARE */ /*------------------------ DMA -----------------------------------*/ /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */ ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable; ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable; ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat; ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat; ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1; /* Configure ETHERNET */ Value = ETH_Init(&amp;ETH_InitStructure); /* Enable DMA Receive interrupt (need to enable in this case Normal interrupt) */ ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R | ETH_DMA_IT_T, ENABLE); } static void RCC_Configuration(void) { /* Enable ETHERNET clock */ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx | RCC_AHBPeriph_ETH_MAC_Rx, ENABLE); /* Enable GPIOs clocks */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_AFIO, ENABLE); } static void NVIC_Configuration(void) { NVIC_InitTypeDef NVIC_InitStructure; /* 2 bit for pre-emption priority, 2 bits for subpriority */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //by sunq /* Enable the EXTI0 Interrupt */ NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); } /* * GPIO Configuration for ETH AF Output Push Pull: - ETH_MDC : PC1 - ETH_MDIO : PA2 - ETH_TX_EN : PB11 - ETH_TXD0 : PB12 - ETH_TXD1 : PB13 - ETH_TXD2 : PC2 - ETH_TXD3 : PB8 - ETH_PPS_OUT / ETH_RMII_PPS_OUT: PB5 Input (Reset Value): - ETH_MII_TX_CLK: PC3 - ETH_MII_RX_CLK / ETH_RMII_REF_CLK: PA1 - ETH_MII_CRS: PA0 - ETH_MII_COL: PA3 - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PA7 - ETH_MII_RXD0: PC4 - ETH_MII_RXD1: PC5 - ETH_MII_RXD2: PB0 - ETH_MII_RXD3: PB1 - ETH_MII_RX_ER: PB10 *************************************** For Remapped Ethernet pins ******************************************* Input (Reset Value): - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PD8 - ETH_MII_RXD0 / ETH_RMII_RXD0: PD9 - ETH_MII_RXD1 / ETH_RMII_RXD1: PD10 - ETH_MII_RXD2: PD11 - ETH_MII_RXD3: PD12 */ static void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; #if STM32_ETH_IO_REMAP /* ETHERNET pins remapp in STM3210C-EVAL board: RX_DV and RxD[3:0] */ GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE); #endif /* STM32_ETH_IO_REMAP */ /* MII/RMII Media interface selection */ #if (RMII_MODE == 0) /* Mode MII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_MII); #elif (RMII_MODE == 1) /* Mode RMII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII); #endif /* RMII_MODE */ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* MDIO */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* MDC */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* MDIO */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); } /* MDIO */ /* TXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* TX_EN */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* TXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* TXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TX_CLK */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* TXD */ /* RXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; #if (STM32_ETH_IO_REMAP == 0) /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #else /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #endif /* STM32_ETH_IO_REMAP */ #if (RMII_MODE == 0) /* CRS */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* COL */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_CLK */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_ER */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* RXD */ #if (USE_MCO == 1) #if (RMII_MODE == 0) /* Mode MII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ RCC_MCOConfig(RCC_MCO_HSE); #elif (RMII_MODE == 1) /* Mode RMII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ /* set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */ RCC_PLL3Config(RCC_PLL3Mul_10); /* Enable PLL3 */ RCC_PLL3Cmd(ENABLE); /* Wait till PLL3 is ready */ while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {} /* Get clock PLL3 clock on PA8 pin */ RCC_MCOConfig(RCC_MCO_PLL3CLK); #endif /* RMII_MODE */ /* MCO pin configuration------------------------------------------------- */ /* Configure MCO (PA8) as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); #endif /* USE_MCO */ } void FreeRTOS_Hardware_STMS32_ETH_Init() { RCC_Configuration(); GPIO_Configuration(); NVIC_Configuration(); Ethernet_Configuration(); } 另外我们写一个ethernetif.h头文件： #ifndef __ETHERNETIF_H__ #define __ETHERNETIF_H__ #include &quot;lwip/err.h&quot; #include &quot;lwip/netif.h&quot; err_t ethernetif_init(struct netif *netif); #endif 把它放在third_party\lwip-1.4.1\src\include\netif目录下。 到此，驱动部分完成了。 然后，就要修改third_party\lwip-1.4.1\src\netif\ethernetif.c。 ethernetif.c内容主要是针对物理层操作的一个结构体变量进行回调函数指针赋值，并实现链路层发送和接收数据包， 代码如下： /** * @file * Ethernet Interface Skeleton * */ /* * Copyright (c) 2001-2004 Swedish Institute of Computer Science. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * 1. Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation * and/or other materials provided with the distribution. * 3. The name of the author may not be used to endorse or promote products * derived from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY * OF SUCH DAMAGE. * * This file is part of the lwIP TCP/IP stack. * * Author: Adam Dunkels &lt;adam@sics.se&gt; * */ /* * This file is a skeleton for developing Ethernet network interface * drivers for lwIP. Add code to the low_level functions and do a * search-and-replace for the word &quot;ethernetif&quot; to replace it with * something that better describes your network interface. */ #include &quot;lwip/opt.h&quot; #include &quot;lwip/def.h&quot; #include &quot;lwip/mem.h&quot; #include &quot;lwip/pbuf.h&quot; #include &quot;lwip/sys.h&quot; #include &quot;netif/etharp.h&quot; #include &quot;err.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;stm32_eth.h&quot; #include &lt;string.h&gt; #include &quot;lwip/timers.h&quot; #define netifMTU (1500) #define netifINTERFACE_TASK_STACK_SIZE ( 350 ) #define netifINTERFACE_TASK_PRIORITY ( configMAX_PRIORITIES - 1 ) #define netifGUARD_BLOCK_TIME ( 250 ) /* The time to block waiting for input. */ #define emacBLOCK_TIME_WAITING_FOR_INPUT ( ( portTickType ) 100 ) /* Define those to better describe your network interface. */ #define IFNAME0 &#39;s&#39; #define IFNAME1 &#39;t&#39; #define ETH_DMARxDesc_FrameLengthShift 16 #define ETH_ERROR ((u32)0) #define ETH_SUCCESS ((u32)1) static struct netif *s_pxNetIf = NULL; xSemaphoreHandle s_xSemaphore = NULL; #define ETH_RXBUFNB 4 #define ETH_TXBUFNB 2 /* Ethernet Rx &amp; Tx DMA Descriptors */ ETH_DMADESCTypeDef DMARxDscrTab[ETH_RXBUFNB], DMATxDscrTab[ETH_TXBUFNB]; /* Ethernet Receive buffers */ uint8_t Rx_Buff[ETH_RXBUFNB][ETH_MAX_PACKET_SIZE]; /* Ethernet Transmit buffers */ uint8_t Tx_Buff[ETH_TXBUFNB][ETH_MAX_PACKET_SIZE]; /* Global pointers to track current transmit and receive descriptors */ extern ETH_DMADESCTypeDef *DMATxDescToSet; extern ETH_DMADESCTypeDef *DMARxDescToGet; typedef struct { u32 length; u32 buffer; ETH_DMADESCTypeDef *descriptor; }FrameTypeDef; FrameTypeDef ETH_RxPkt_ChainMode(void); u32 ETH_GetCurrentTxBuffer(void); u32 ETH_TxPkt_ChainMode(u16 FrameLength); static void ethernetif_input( void * pvParameters ); static void arp_timer(void *arg); /** * In this function, the hardware should be initialized. * Called from ethernetif_init(). * * @param netif the already initialized lwip network interface structure * for this ethernetif */ static void low_level_init(struct netif *netif) { uint32_t i; struct ethernetif *ethernetif = netif-&gt;state; /* set netif MAC hardware address length */ netif-&gt;hwaddr_len = ETHARP_HWADDR_LEN; /* set netif MAC hardware address */ netif-&gt;hwaddr[0] = MAC_ADDR0; netif-&gt;hwaddr[1] = MAC_ADDR1; netif-&gt;hwaddr[2] = MAC_ADDR2; netif-&gt;hwaddr[3] = MAC_ADDR3; netif-&gt;hwaddr[4] = MAC_ADDR4; netif-&gt;hwaddr[5] = MAC_ADDR5; /* set netif maximum transfer unit */ netif-&gt;mtu = 1500; /* Accept broadcast address and ARP traffic */ netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP; s_pxNetIf =netif; /* create binary semaphore used for informing ethernetif of frame reception */ if (s_xSemaphore == NULL) { s_xSemaphore= xSemaphoreCreateCounting(20,0); } /* initialize MAC address in ethernet MAC */ ETH_MACAddressConfig(ETH_MAC_Address0, netif-&gt;hwaddr); /* Initialize Tx Descriptors list: Chain Mode */ ETH_DMATxDescChainInit(DMATxDscrTab, &amp;Tx_Buff[0][0], ETH_TXBUFNB); /* Initialize Rx Descriptors list: Chain Mode */ ETH_DMARxDescChainInit(DMARxDscrTab, &amp;Rx_Buff[0][0], ETH_RXBUFNB); /* Enable Ethernet Rx interrrupt */ { for(i=0; i&lt;ETH_RXBUFNB; i++) { ETH_DMARxDescReceiveITConfig(&amp;DMARxDscrTab[i], ENABLE); } } #ifdef CHECKSUM_BY_HARDWARE /* Enable the checksum insertion for the Tx frames */ { for(i=0; i&lt;ETH_TXBUFNB; i++) { ETH_DMATxDescChecksumInsertionConfig(&amp;DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull); } } #endif /* create the task that handles the ETH_MAC */ xTaskCreate(ethernetif_input, (const char*) &quot;Eth_if&quot;, netifINTERFACE_TASK_STACK_SIZE, NULL, netifINTERFACE_TASK_PRIORITY,NULL); /* Enable MAC and DMA transmission and reception */ ETH_Start(); } /** * This function should do the actual transmission of the packet. The packet is * contained in the pbuf that is passed to the function. This pbuf * might be chained. * * @param netif the lwip network interface structure for this ethernetif * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type) * @return ERR_OK if the packet could be sent * an err_t value if the packet couldn&#39;t be sent * * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to * strange results. You might consider waiting for space in the DMA queue * to become availale since the stack doesn&#39;t retry to send a packet * dropped because of memory failure (except for the TCP timers). */ static err_t low_level_output(struct netif *netif, struct pbuf *p) { static xSemaphoreHandle xTxSemaphore = NULL; struct pbuf *q; uint32_t l = 0; u8 *buffer ; if (xTxSemaphore == NULL) { vSemaphoreCreateBinary (xTxSemaphore); } if (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME)) { buffer = (u8 *)(ETH_GetCurrentTxBuffer()); for(q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)&amp;buffer[l], q-&gt;payload, q-&gt;len); l = l + q-&gt;len; } ETH_TxPkt_ChainMode(l); xSemaphoreGive(xTxSemaphore); } return ERR_OK; } /** * Should allocate a pbuf and transfer the bytes of the incoming * packet from the interface into the pbuf. * * @param netif the lwip network interface structure for this ethernetif * @return a pbuf filled with the received packet (including MAC header) * NULL on memory error */ static struct pbuf * low_level_input(struct netif *netif) { struct pbuf *p, *q; u16_t len; int l =0; FrameTypeDef frame; u8 *buffer; p = NULL; frame = ETH_RxPkt_ChainMode(); /* Check if the descriptor is exist */ if(!frame.descriptor) return p; /* Obtain the size of the packet and put it into the &quot;len&quot; variable. */ len = frame.length; buffer = (u8 *)frame.buffer; /* We allocate a pbuf chain of pbufs from the pool. */ p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL); if (p != NULL) { for (q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)q-&gt;payload, (u8_t*)&amp;buffer[l], q-&gt;len); l = l + q-&gt;len; } } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } return p; } /** * This function is the ethernetif_input task, it is processed when a packet * is ready to be read from the interface. It uses the function low_level_input() * that should handle the actual reception of bytes from the network * interface. Then the type of the received packet is determined and * the appropriate input function is called. * * @param netif the lwip network interface structure for this ethernetif */ void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } /** * Should be called at the beginning of the program to set up the * network interface. It calls the function low_level_init() to do the * actual setup of the hardware. * * This function should be passed as a parameter to netif_add(). * * @param netif the lwip network interface structure for this ethernetif * @return ERR_OK if the loopif is initialized * ERR_MEM if private data couldn&#39;t be allocated * any other err_t on error */ err_t ethernetif_init(struct netif *netif) { LWIP_ASSERT(&quot;netif != NULL&quot;, (netif != NULL)); #if LWIP_NETIF_HOSTNAME /* Initialize interface hostname */ netif-&gt;hostname = &quot;lwip&quot;; #endif /* LWIP_NETIF_HOSTNAME */ netif-&gt;name[0] = IFNAME0; netif-&gt;name[1] = IFNAME1; netif-&gt;output = etharp_output; netif-&gt;linkoutput = low_level_output; /* initialize the hardware */ low_level_init(netif); etharp_init(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); return ERR_OK; } static void arp_timer(void *arg) { etharp_tmr(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); } /******************************************************************************* * Function Name : ETH_RxPkt_ChainMode * Description : Receives a packet. * Input : None * Output : None * Return : frame: farme size and location *******************************************************************************/ FrameTypeDef ETH_RxPkt_ChainMode(void) { u32 framelength = 0; FrameTypeDef frame = {0,0}; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (u32)RESET) { frame.length = ETH_ERROR; if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Return error: OWN bit set */ return frame; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (u32)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARxDesc_FrameLengthShift) - 4; /* Get the addrees of the actual buffer */ frame.buffer = DMARxDescToGet-&gt;Buffer1Addr; } else { /* Return ERROR */ framelength = ETH_ERROR; } frame.length = framelength; frame.descriptor = DMARxDescToGet; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); /* Return Frame */ return (frame); } /******************************************************************************* * Function Name : ETH_TxPkt_ChainMode * Description : Transmits a packet, from application buffer, pointed by ppkt. * Input : - FrameLength: Tx Packet size. * Output : None * Return : ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission *******************************************************************************/ u32 ETH_TxPkt_ChainMode(u16 FrameLength) { /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (u32)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (u32)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); /* Return SUCCESS */ return ETH_SUCCESS; } /******************************************************************************* * Function Name : ETH_GetCurrentTxBuffer * Description : Return the address of the buffer pointed by the current descritor. * Input : None * Output : None * Return : Buffer address *******************************************************************************/ u32 ETH_GetCurrentTxBuffer(void) { /* Return Buffer address */ return (DMATxDescToSet-&gt;Buffer1Addr); } 这里我们加了一个FreeRTOS_net_config.h头文件，里面定义了MAC地址和默认的IP地址定义： /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __FREERTOS_NET_CONFIG_H__ #define __FREERTOS_NET_CONFIG_H__ #ifdef __cplusplus extern &quot;C&quot; { #endif /* MAC ADDRESS*/ #define MAC_ADDR0 0x00 #define MAC_ADDR1 0x80 #define MAC_ADDR2 0xe1 #define MAC_ADDR3 0x31 #define MAC_ADDR4 0x45 #define MAC_ADDR5 0x57 /*Static IP ADDRESS*/ #define IP_ADDR0 192 #define IP_ADDR1 168 #define IP_ADDR2 1 #define IP_ADDR3 30 /*NETMASK*/ #define NETMASK_ADDR0 255 #define NETMASK_ADDR1 255 #define NETMASK_ADDR2 255 #define NETMASK_ADDR3 0 /*Gateway Address*/ #define GW_ADDR0 192 #define GW_ADDR1 168 #define GW_ADDR2 1 #define GW_ADDR3 1 #ifdef __cplusplus } #endif #endif /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 把FreeRTOS_net_config.h放在BSP目录下。 对于ethernetif.c的代码要说明一下ethernetif_input这个函数： void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } 网上有很多版本没有while循环，这会导致数据接收的时候缓冲区很快被填满，但不能清空，从而导致速度突然下降乃至断断续续，大量丢包，即使ping本机也会陡然降速，不断超时。加上while就可以解决问题了，但是出现了bug，导致系统崩溃，问题出现在low_level_input函数中的 frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; 因为frame.descriptor这个指针使用完之后就被释放了，程序再次跑到这里的时候frame.descriptor成了野指针。 为了解决这个问题，在使用前判断一下： /* Check if the descriptor is exist */ if(!frame.descriptor) return p; 详细位置请参考上面的有关代码。 另外，我们代码中使用了信号量，所以需要在FreeRTOS的配置文件中打开相关的宏，以支持信号量： 把FreeRTOSConfig.h中的： #define configUSE_COUNTING_SEMAPHORES 0 改为： #define configUSE_COUNTING_SEMAPHORES 1 接下来需要改的地方就是网卡接口中断服务程序了。 需要修改两个文件，第一个就是启动文件STM32F10x.s，把以太网中断向量的屏蔽解除。 第二个就是中断服务函数文件stm32f10x_it.c，定义以太网中断服务函数。 STM32F10x.s如下： ;/*****************************************************************************/ ;/* STM32F10x.s: Startup file for ST STM32F10x device series */ ;/*****************************************************************************/ ;/* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; */ ;/*****************************************************************************/ ;/* This file is part of the uVision/ARM development tools. */ ;/* Copyright (c) 2005-2007 Keil Software. All rights reserved. */ ;/* This software may only be used under the terms of a valid, current, */ ;/* end user licence from KEIL for a compatible version of KEIL software */ ;/* development tools. Nothing else gives you the right to use this software. */ ;/*****************************************************************************/ ;// &lt;h&gt; Stack Configuration ;// &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp ;// &lt;h&gt; Heap Configuration ;// &lt;o&gt; Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit IMPORT xPortPendSVHandler IMPORT xPortSysTickHandler IMPORT vPortSVCHandler IMPORT vUARTInterruptHandler ;IMPORT vTimer2IntHandler PRESERVE8 THUMB ; Vector Table Mapped to Address 0 at Reset AREA RESET, DATA, READONLY EXPORT __Vectors EXPORT __Vectors_End EXPORT __Vectors_Size __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD vPortSVCHandler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD xPortPendSVHandler ; PendSV Handler DCD xPortSysTickHandler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD TAMPER_IRQHandler ; Tamper DCD RTC_IRQHandler ; RTC DCD FLASH_IRQHandler ; Flash DCD RCC_IRQHandler ; RCC DCD EXTI0_IRQHandler ; EXTI Line 0 DCD EXTI1_IRQHandler ; EXTI Line 1 DCD EXTI2_IRQHandler ; EXTI Line 2 DCD EXTI3_IRQHandler ; EXTI Line 3 DCD EXTI4_IRQHandler ; EXTI Line 4 DCD DMAChannel1_IRQHandler ; DMA Channel 1 DCD DMAChannel2_IRQHandler ; DMA Channel 2 DCD DMAChannel3_IRQHandler ; DMA Channel 3 DCD DMAChannel4_IRQHandler ; DMA Channel 4 DCD DMAChannel5_IRQHandler ; DMA Channel 5 DCD DMAChannel6_IRQHandler ; DMA Channel 6 DCD DMAChannel7_IRQHandler ; DMA Channel 7 DCD ADC_IRQHandler ; ADC DCD USB_HP_CAN_TX_IRQHandler ; USB High Priority or CAN TX DCD USB_LP_CAN_RX0_IRQHandler ; USB Low Priority or CAN RX0 DCD CAN_RX1_IRQHandler ; CAN RX1 DCD CAN_SCE_IRQHandler ; CAN SCE DCD EXTI9_5_IRQHandler ; EXTI Line 9..5 DCD TIM1_BRK_IRQHandler ; TIM1 Break DCD TIM1_UP_IRQHandler ; TIM1 Update DCD TIM1_TRG_COM_IRQHandler ; TIM1 Trigger and Commutation DCD TIM1_CC_IRQHandler ; TIM1 Capture Compare ; DCD 0 ;vTimer2IntHandler ; TIM2 DCD TIM3_IRQHandler ; TIM3 DCD TIM4_IRQHandler ; TIM4 DCD I2C1_EV_IRQHandler ; I2C1 Event DCD I2C1_ER_IRQHandler ; I2C1 Error DCD I2C2_EV_IRQHandler ; I2C2 Event DCD I2C2_ER_IRQHandler ; I2C2 Error DCD SPI1_IRQHandler ; SPI1 DCD SPI2_IRQHandler ; SPI2 DCD vUARTInterruptHandler ; USART1 DCD USART2_IRQHandler ; USART2 DCD USART3_IRQHandler ; USART3 DCD EXTI15_10_IRQHandler ; EXTI Line 15..10 DCD RTCAlarm_IRQHandler ; RTC Alarm through EXTI Line DCD USBWakeUp_IRQHandler ; USB Wakeup from suspend ;-------------------added by sunq@2017.08.1 DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD TIM5_IRQHandler ; TIM5 DCD SPI3_IRQHandler ; SPI3 DCD UART4_IRQHandler ; UART4 DCD UART5_IRQHandler ; UART5 DCD TIM6_IRQHandler ; TIM6 DCD TIM7_IRQHandler ; TIM7 DCD DMA2_Channel1_IRQHandler ; DMA2 Channel1 DCD DMA2_Channel2_IRQHandler ; DMA2 Channel2 DCD DMA2_Channel3_IRQHandler ; DMA2 Channel3 DCD DMA2_Channel4_IRQHandler ; DMA2 Channel4 DCD DMA2_Channel5_IRQHandler ; DMA2 Channel5 DCD ETH_IRQHandler ; Ethernet DCD ETH_WKUP_IRQHandler ; Ethernet Wakeup through EXTI line DCD CAN2_TX_IRQHandler ; CAN2 TX DCD CAN2_RX0_IRQHandler ; CAN2 RX0 DCD CAN2_RX1_IRQHandler ; CAN2 RX1 DCD CAN2_SCE_IRQHandler ; CAN2 SCE DCD OTG_FS_IRQHandler ; USB OTG FS __Vectors_End __Vectors_Size EQU __Vectors_End - __Vectors AREA |.text|, CODE, READONLY ; Reset handler Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP ; Dummy Exception Handlers (infinite loops which can be modified) NMI_Handler PROC EXPORT NMI_Handler [WEAK] B . ENDP HardFault_Handler\ PROC EXPORT HardFault_Handler [WEAK] B . ENDP MemManage_Handler\ PROC EXPORT MemManage_Handler [WEAK] B . ENDP BusFault_Handler\ PROC EXPORT BusFault_Handler [WEAK] B . ENDP UsageFault_Handler\ PROC EXPORT UsageFault_Handler [WEAK] B . ENDP SVC_Handler PROC EXPORT SVC_Handler [WEAK] B . ENDP DebugMon_Handler\ PROC EXPORT DebugMon_Handler [WEAK] B . ENDP PendSV_Handler PROC EXPORT PendSV_Handler [WEAK] B . ENDP SysTick_Handler PROC EXPORT SysTick_Handler [WEAK] B . ENDP Default_Handler PROC EXPORT WWDG_IRQHandler [WEAK] EXPORT PVD_IRQHandler [WEAK] EXPORT TAMPER_IRQHandler [WEAK] EXPORT RTC_IRQHandler [WEAK] EXPORT FLASH_IRQHandler [WEAK] EXPORT RCC_IRQHandler [WEAK] EXPORT EXTI0_IRQHandler [WEAK] EXPORT EXTI1_IRQHandler [WEAK] EXPORT EXTI2_IRQHandler [WEAK] EXPORT EXTI3_IRQHandler [WEAK] EXPORT EXTI4_IRQHandler [WEAK] EXPORT DMAChannel1_IRQHandler [WEAK] EXPORT DMAChannel2_IRQHandler [WEAK] EXPORT DMAChannel3_IRQHandler [WEAK] EXPORT DMAChannel4_IRQHandler [WEAK] EXPORT DMAChannel5_IRQHandler [WEAK] EXPORT DMAChannel6_IRQHandler [WEAK] EXPORT DMAChannel7_IRQHandler [WEAK] EXPORT ADC_IRQHandler [WEAK] EXPORT USB_HP_CAN_TX_IRQHandler [WEAK] EXPORT USB_LP_CAN_RX0_IRQHandler [WEAK] EXPORT CAN_RX1_IRQHandler [WEAK] EXPORT CAN_SCE_IRQHandler [WEAK] EXPORT EXTI9_5_IRQHandler [WEAK] EXPORT TIM1_BRK_IRQHandler [WEAK] EXPORT TIM1_UP_IRQHandler [WEAK] EXPORT TIM1_TRG_COM_IRQHandler [WEAK] EXPORT TIM1_CC_IRQHandler [WEAK] EXPORT TIM2_IRQHandler [WEAK] EXPORT TIM3_IRQHandler [WEAK] EXPORT TIM4_IRQHandler [WEAK] EXPORT I2C1_EV_IRQHandler [WEAK] EXPORT I2C1_ER_IRQHandler [WEAK] EXPORT I2C2_EV_IRQHandler [WEAK] EXPORT I2C2_ER_IRQHandler [WEAK] EXPORT SPI1_IRQHandler [WEAK] EXPORT SPI2_IRQHandler [WEAK] EXPORT USART1_IRQHandler [WEAK] EXPORT USART2_IRQHandler [WEAK] EXPORT USART3_IRQHandler [WEAK] EXPORT EXTI15_10_IRQHandler [WEAK] EXPORT RTCAlarm_IRQHandler [WEAK] EXPORT USBWakeUp_IRQHandler [WEAK] ;-------------added @2017.09.27----------------------------- EXPORT TIM5_IRQHandler [WEAK] EXPORT SPI3_IRQHandler [WEAK] EXPORT UART4_IRQHandler [WEAK] EXPORT UART5_IRQHandler [WEAK] EXPORT TIM6_IRQHandler [WEAK] EXPORT TIM7_IRQHandler [WEAK] EXPORT DMA2_Channel1_IRQHandler [WEAK] EXPORT DMA2_Channel2_IRQHandler [WEAK] EXPORT DMA2_Channel3_IRQHandler [WEAK] EXPORT DMA2_Channel4_IRQHandler [WEAK] EXPORT DMA2_Channel5_IRQHandler [WEAK] EXPORT ETH_IRQHandler [WEAK] EXPORT ETH_WKUP_IRQHandler [WEAK] EXPORT CAN2_TX_IRQHandler [WEAK] EXPORT CAN2_RX0_IRQHandler [WEAK] EXPORT CAN2_RX1_IRQHandler [WEAK] EXPORT CAN2_SCE_IRQHandler [WEAK] EXPORT OTG_FS_IRQHandler [WEAK] WWDG_IRQHandler PVD_IRQHandler TAMPER_IRQHandler RTC_IRQHandler FLASH_IRQHandler RCC_IRQHandler EXTI0_IRQHandler EXTI1_IRQHandler EXTI2_IRQHandler EXTI3_IRQHandler EXTI4_IRQHandler DMAChannel1_IRQHandler DMAChannel2_IRQHandler DMAChannel3_IRQHandler DMAChannel4_IRQHandler DMAChannel5_IRQHandler DMAChannel6_IRQHandler DMAChannel7_IRQHandler ADC_IRQHandler USB_HP_CAN_TX_IRQHandler USB_LP_CAN_RX0_IRQHandler CAN_RX1_IRQHandler CAN_SCE_IRQHandler EXTI9_5_IRQHandler TIM1_BRK_IRQHandler TIM1_UP_IRQHandler TIM1_TRG_COM_IRQHandler TIM1_CC_IRQHandler TIM2_IRQHandler TIM3_IRQHandler TIM4_IRQHandler I2C1_EV_IRQHandler I2C1_ER_IRQHandler I2C2_EV_IRQHandler I2C2_ER_IRQHandler SPI1_IRQHandler SPI2_IRQHandler USART1_IRQHandler USART2_IRQHandler USART3_IRQHandler EXTI15_10_IRQHandler RTCAlarm_IRQHandler USBWakeUp_IRQHandler ;---------added @2017.09.27-------------------------- TIM5_IRQHandler SPI3_IRQHandler UART4_IRQHandler UART5_IRQHandler TIM6_IRQHandler TIM7_IRQHandler DMA2_Channel1_IRQHandler DMA2_Channel2_IRQHandler DMA2_Channel3_IRQHandler DMA2_Channel4_IRQHandler DMA2_Channel5_IRQHandler ETH_IRQHandler ETH_WKUP_IRQHandler CAN2_TX_IRQHandler CAN2_RX0_IRQHandler CAN2_RX1_IRQHandler CAN2_SCE_IRQHandler OTG_FS_IRQHandler B . ENDP ALIGN ; User Initial Stack &amp; Heap IF :DEF:__MICROLIB EXPORT __initial_sp EXPORT __heap_base EXPORT __heap_limit ELSE IMPORT __use_two_region_memory EXPORT __user_initial_stackheap __user_initial_stackheap LDR R0, = Heap_Mem LDR R1, =(Stack_Mem + Stack_Size) LDR R2, = (Heap_Mem + Heap_Size) LDR R3, = Stack_Mem BX LR ALIGN ENDIF END stm32F10x_it.c如下： /** ****************************************************************************** * @file Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c * @author MCD Application Team * @version V3.5.0 * @date 08-April-2011 * @brief Main Interrupt Service Routines. * This file provides template for all exceptions handler and * peripherals interrupt service routine. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x_it.h&quot; #include &quot;stm32_eth.h&quot; /* Scheduler includes */ #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; /* lwip includes */ #include &quot;lwip/sys.h&quot; /** @addtogroup STM32F10x_StdPeriph_Template * @{ */ /* Private typedef -----------------------------------------------------------*/ /* Private define ------------------------------------------------------------*/ /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ extern xSemaphoreHandle s_xSemaphore; /* Private function prototypes -----------------------------------------------*/ extern void xPortSysTickHandler(void); /* Private functions ---------------------------------------------------------*/ /******************************************************************************/ /* Cortex-M3 Processor Exceptions Handlers */ /******************************************************************************/ /** * @brief This function handles NMI exception. * @param None * @retval None */ void NMI_Handler(void) { } /** * @brief This function handles Hard Fault exception. * @param None * @retval None */ void HardFault_Handler(void) { /* Go to infinite loop when Hard Fault exception occurs */ while (1) { } } /** * @brief This function handles Memory Manage exception. * @param None * @retval None */ void MemManage_Handler(void) { /* Go to infinite loop when Memory Manage exception occurs */ while (1) { } } /** * @brief This function handles Bus Fault exception. * @param None * @retval None */ void BusFault_Handler(void) { /* Go to infinite loop when Bus Fault exception occurs */ while (1) { } } /** * @brief This function handles Usage Fault exception. * @param None * @retval None */ void UsageFault_Handler(void) { /* Go to infinite loop when Usage Fault exception occurs */ while (1) { } } /** * @brief This function handles SVCall exception. * @param None * @retval None */ void SVC_Handler(void) { } /** * @brief This function handles Debug Monitor exception. * @param None * @retval None */ void DebugMon_Handler(void) { } /** * @brief This function handles PendSVC exception. * @param None * @retval None */ void PendSV_Handler(void) { } /** * @brief This function handles SysTick Handler. * @param None * @retval None */ void SysTick_Handler(void) { } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles ETH interrupt request. * @param None * @retval None */ void ETH_IRQHandler(void) { portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; /* Frame received */ if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET) { /* Give the semaphore to wakeup LwIP task */ xSemaphoreGiveFromISR( s_xSemaphore, &amp;xHigherPriorityTaskWoken ); } /* Clear the interrupt flags. */ /* Clear the Eth DMA Rx IT pending bits */ ETH_DMAClearITPendingBit(ETH_DMA_IT_R); ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS); /* Switch tasks if necessary. */ if( xHigherPriorityTaskWoken != pdFALSE ) { portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); } } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles PPP interrupt request. * @param None * @retval None */ /*void PPP_IRQHandler(void) { }*/ /** * @} */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 移植到此基本完成。 下面验证一下移植结果。 把拷贝过来的BSP目录下的netcon.c加入到IDE的BSP组中，并修改内容如下： /** ****************************************************************************** * @file netconf.c * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief Network connection configuration ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;lwip/mem.h&quot; #include &quot;lwip/memp.h&quot; #include &quot;lwip/dhcp.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;netconf.h&quot; #include &quot;tcpip.h&quot; #include &lt;stdio.h&gt; #define _DEBUG #include &quot;dprintf.h&quot; /* Private typedef -----------------------------------------------------------*/ typedef enum { DHCP_START=0, DHCP_WAIT_ADDRESS, DHCP_ADDRESS_ASSIGNED, DHCP_TIMEOUT } DHCP_State_TypeDef; /* Private define ------------------------------------------------------------*/ #define MAX_DHCP_TRIES 5 /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ struct netif xnetif; /* network interface structure */ /* Private functions ---------------------------------------------------------*/ /** * @brief Initializes the lwIP stack * @param None * @retval None */ void LwIP_Init(void) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; /* Create tcp_ip stack thread */ tcpip_init( NULL, NULL ); /* IP address setting &amp; display on STM32_evalboard LCD*/ #ifdef USE_DHCP ipaddr.addr = 0; netmask.addr = 0; gw.addr = 0; #else IP4_ADDR(&amp;ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); #endif /* - netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask, struct ip_addr *gw, void *state, err_t (* init)(struct netif *netif), err_t (* input)(struct pbuf *p, struct netif *netif)) Adds your network interface to the netif_list. Allocate a struct netif and pass a pointer to this structure as the first argument. Give pointers to cleared ip_addr structures when using DHCP, or fill them with sane numbers otherwise. The state pointer may be NULL. The init function pointer must point to a initialization function for your ethernet netif interface. The following code illustrates it&#39;s use.*/ netif_add(&amp;xnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, &amp;ethernetif_init, &amp;tcpip_input); /* Registers the default network interface. */ netif_set_default(&amp;xnetif); /* When the netif is fully configured this function must be called.*/ netif_set_up(&amp;xnetif); } #ifdef USE_DHCP /** * @brief LwIP_DHCP_Process_Handle * @param None * @retval None */ int g_DHCP_OK_flag = 0; void LwIP_DHCP_task(void * pvParameters) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; uint32_t IPaddress; uint8_t iptab[4]; uint8_t iptxt[20]; uint8_t DHCP_state; DHCP_state = DHCP_START; for (;;) { switch (DHCP_state) { case DHCP_START: { dhcp_start(&amp;xnetif); IPaddress = 0; DHCP_state = DHCP_WAIT_ADDRESS; printf(&quot;Looking for DHCP server,please wait... \r\n&quot;); } break; case DHCP_WAIT_ADDRESS: { /* Read the new IP address */ IPaddress = xnetif.ip_addr.addr; if (IPaddress!=0) { DHCP_state = DHCP_ADDRESS_ASSIGNED; /* Stop DHCP */ dhcp_stop(&amp;xnetif); iptab[0] = (uint8_t)(IPaddress &gt;&gt; 24); iptab[1] = (uint8_t)(IPaddress &gt;&gt; 16); iptab[2] = (uint8_t)(IPaddress &gt;&gt; 8); iptab[3] = (uint8_t)(IPaddress); sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\r\nIP address[%s ]assigned by a DHCP server !\r\n&quot;,iptxt); vTaskDelete(NULL); } else { /* DHCP timeout */ if (xnetif.dhcp-&gt;tries &gt; MAX_DHCP_TRIES) { DHCP_state = DHCP_TIMEOUT; /* Stop DHCP */ dhcp_stop(&amp;xnetif); /* Static address used */ IP4_ADDR(&amp;ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 ); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); netif_set_addr(&amp;xnetif, &amp;ipaddr , &amp;netmask, &amp;gw); iptab[0] = IP_ADDR3; iptab[1] = IP_ADDR2; iptab[2] = IP_ADDR1; iptab[3] = IP_ADDR0; sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\r\nDHCP timeout \r\nStatic IP address :%s\r\n&quot;,iptxt); vTaskDelete(NULL); } { static int s=0; const char tokens[4]={&#39;-&#39;,&#39;\\&#39;,&#39;|&#39;,&#39;/&#39;}; printf(&quot;\b\b\b\b%c%c%c%c&quot;,tokens[s++%4],tokens[s%4],tokens[s%4],tokens[s%4]); } } } break; default: printf(&quot;\r\nerr: DHCP_state=%d\r\n&quot;,DHCP_state); break; } /* Toggle LED1 */ //STM_EVAL_LEDToggle(LED1);//... /* wait 250 ms */ vTaskDelay(250); } } #endif /* USE_DHCP */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 修改netconf.h，加入对DHCP的支持。 如下： /** ****************************************************************************** * @file netconf.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief This file contains all the functions prototypes for the netconf.c * file. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __NETCONF_H #define __NETCONF_H #ifdef __cplusplus extern &quot;C&quot; { #endif #define USE_DHCP // @2017.09.27 /* Includes ------------------------------------------------------------------*/ /* Exported types ------------------------------------------------------------*/ extern struct netif xnetif; /* Exported constants --------------------------------------------------------*/ /* Exported macro ------------------------------------------------------------*/ /* Exported functions ------------------------------------------------------- */ void LwIP_Init(void); void LwIP_DHCP_task(void * pvParameters); #ifdef __cplusplus } #endif #endif /* __NETCONF_H */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ main.c文件修改如下： #include &quot;stm32f10x.h&quot; #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; #include &quot;semphr.h&quot; #include &quot;utils.h&quot; #define _DEBUG #include &quot;dprintf.h&quot; void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; /* Configure IO connected to LD1, LD2, LD3 and LD4 leds *********************/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); } //?????? void NVIC_Configuration(void) { /* Configure the NVIC Preemption Priority Bits */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0); #ifdef VECT_TAB_RAM /* Set the Vector Table base location at 0x20000000 */ NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); #else /* VECT_TAB_FLASH */ /* Set the Vector Table base location at 0x08000000 */ NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); #endif } void RCC_Configuration(void) { SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |RCC_APB2Periph_ADC1 | RCC_APB2Periph_AFIO |RCC_APB2Periph_SPI1, ENABLE ); // RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALL ,ENABLE ); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4 |RCC_APB1Periph_USART3|RCC_APB1Periph_TIM2 , ENABLE ); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); } void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { /* This function will get called if a task overflows its stack. If the parameters are corrupt then inspect pxCurrentTCB to find which was the offending task. */ ( void ) pxTask; printf(&quot;ÈÎÎñ£º%s ·¢ÏÖÕ»Òç³ö\n&quot;, pcTaskName); for( ;; ); } /*-----------------------------------------------------------*/ void vApplicationTickHook( void ) { } static void prvSetupHardware( void ) { /* Start with the clocks in their expected state. */ RCC_DeInit(); /* Enable HSE (high speed external clock). */ RCC_HSEConfig( RCC_HSE_ON ); /* Wait till HSE is ready. */ while( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET ) { } /* 2 wait states required on the flash. */ *( ( unsigned long * ) 0x40022000 ) = 0x02; /* HCLK = SYSCLK */ RCC_HCLKConfig( RCC_SYSCLK_Div1 ); /* PCLK2 = HCLK */ RCC_PCLK2Config( RCC_HCLK_Div1 ); /* PCLK1 = HCLK/2 */ RCC_PCLK1Config( RCC_HCLK_Div2 ); /* Enable PLL. */ RCC_PLLCmd( ENABLE ); /* Wait till PLL is ready. */ while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) { } /* Select PLL as system clock source. */ RCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK ); /* Wait till PLL is used as system clock source. */ while( RCC_GetSYSCLKSource() != 0x08 ) { } /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */ RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE ); /* Set the Vector Table base address at 0x08000000 */ NVIC_SetVectorTable( NVIC_VectTab_FLASH, 0x0 ); NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 ); /* Configure HCLK clock as SysTick clock source. */ SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK ); GPIO_Configuration(); } #define ledSTACK_SIZE configMINIMAL_STACK_SIZE #define ledFLASH_RATE_BASE ( ( TickType_t ) 333 ) static TaskHandle_t xHandleTaskLED=NULL; static void vTaskLED(void* pvParameters) { TickType_t xFlashRate, xLastFlashTime; xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) 2 ); xFlashRate /= portTICK_PERIOD_MS; xFlashRate /= ( TickType_t ) 2; xLastFlashTime = xTaskGetTickCount(); while(1) { /* Turn on LD1 */ GPIO_SetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); /* Turn off LD1 */ GPIO_ResetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); } } #include &quot;serial.h&quot; #include &quot;integer.h&quot; #include &quot;diskio.h&quot; #include &quot;ff.h&quot; #include &quot;sdcard.h&quot; #include &quot;common.h&quot; #include &lt;stdio.h&gt; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) /* Handle to the com port used by both tasks. */ static xComPortHandle xPort = NULL; /* The Rx task will block on the Rx queue for a long period. */ #define comRX_BLOCK_TIME ( ( TickType_t ) 0xffff ) static void sd_card_task(void* pvParameters) { signed char key = 0; GPIO_ResetBits(GPIOF, GPIO_Pin_6); //LED1 on while(1) { printf(&quot;\r\n============ ÇëÑ¡Ôñ...===============\r\n\n&quot;); printf(&quot;¸ñ Ê½ »¯------------------------------- 1\r\n\n&quot;); printf(&quot;´´½¨ÎÄ¼þ------------------------------- 2\r\n\n&quot;); printf(&quot;É¾³ýÎÄ¼þ ------------------------------ 3\r\n\n&quot;); printf(&quot;ÁÐ±íÎÄ¼þ------------------------------- 4\r\n\n&quot;); printf(&quot;ÖØÆôÏµÍ³ ------------------------------ 5\r\n\n&quot;); printf(&quot;´ÅÅÌÐÅÏ¢------------------------------- 6\r\n\n&quot;); printf(&quot;´´½¨Ä¿Â¼------------------------------- 7\r\n\n&quot;); printf(&quot;±à¼­ÎÄ¼þ------------------------------- 8\r\n\n&quot;); printf(&quot;¶ÁÈ¡ÎÄ¼þ------------------------------- 9\r\n\n&quot;); printf(&quot;========================================\r\n\n&quot;); xSerialGetChar( xPort, &amp;key, comRX_BLOCK_TIME ); if (key == 0x31) //Format FS { printf(&quot;\r\n----1----&quot;); format_disk(); } else if (key == 0x32) //Creat File { printf(&quot;\r\n----2----&quot;); creat_file(); } else if (key == 0x33) //Delete File { printf(&quot;\r\n----3----&quot;); delete_file(); } else if (key == 0x34) //List File { printf(&quot;\r\n----4----&quot;); list_file(); } else if (key == 0x35) //Reset FS { printf(&quot;\r\n----5----&quot;); Sys_Soft_Reset(); } else if (key == 0x36) //Disk info { printf(&quot;\r\n----6----&quot;); get_disk_info(); } else if (key == 0x37) //Creat Dir { printf(&quot;\r\n----7----&quot;); creat_dir(); } else if (key == 0x38) //Edit File { printf(&quot;\r\n----8----&quot;); edit_file(); } else if (key == 0x39) //Read File { printf(&quot;\r\n----9----&quot;); read_file(); } else { printf(&quot;\r\n----%c----&quot;,key); printf(&quot;\r\nÖ»½ÓÊÜ1-9ÃüÁî£¬ÇëÖØÐÂÊäÈë&quot;); } } } #include &quot;netconf.h&quot; #include &quot;stm32_eth.h&quot; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) #define DHCP_TASK_PRIO ( tskIDLE_PRIORITY + 2 ) static TaskHandle_t xHandleTaskSystemInit=NULL; static void System_Init_task(void* pvParameters) { xTaskCreate(vTaskLED,&quot;vTaskLED&quot;,ledSTACK_SIZE,NULL,3,&amp;xHandleTaskLED); printf(&quot;2 led demos tasks are created !\r\n&quot;); //xTaskCreate(sd_card_task,&quot;vTaskSDCard&quot;,1024,NULL,SYSTEM_INIT_TASK_PRIO,NULL); //printf(&quot;The task of SDCard is created!\r\n&quot;); printf(&quot;eth hardware initialzing...\r\n&quot;); FreeRTOS_Hardware_STMS32_ETH_Init(); printf(&quot;eth hardware ok\r\nstarting LwIP stack...\r\n&quot;); /* Initilaize the LwIP stack */ LwIP_Init(); printf(&quot;LwIP stack started !\r\n&quot;); /* Initialize tcp echo server */ //tcpecho_init(); #ifdef USE_DHCP /* Start DHCPClient */ xTaskCreate(LwIP_DHCP_task, &quot;DHCPClient&quot;, configMINIMAL_STACK_SIZE * 2, NULL,DHCP_TASK_PRIO, NULL); #endif printf(&quot;LwIP_DHCP_task is created !\r\n&quot;); vTaskDelete(xHandleTaskSystemInit); } int main(void) { __set_PRIMASK(1);//½ûÖ¹È«¾ÖÖÐ¶Ï prvSetupHardware(); FreeRTOS_printf_service_init(); printf(&quot;###############################################\r\n&quot;); printf(&quot;## hello! welcome to FreeRTOS v9.0.0 ##\r\n&quot;); printf(&quot;###############################################\r\n&quot;); printf(&quot;\r\n\r\n&quot;); SD_Init(); InitMQTTServerInfo(); xTaskCreate(System_Init_task,&quot;vTaskSystemInit&quot;,100,NULL,SYSTEM_INIT_TASK_PRIO,&amp;xHandleTaskSystemInit); vTaskStartScheduler();//Æô¶¯ÈÎÎñµ÷¶ÈÆ÷ } /******************* (C) COPYRIGHT 2012 WildFire Team *****END OF FILE************/ 编译完成后，把hex档烧到开发板上，上电运行。看到： LwIP已经运行起来了。路由分配了ip：10.0.0.109 打开一个cmd窗口，ping一下开发板： 可以看到ping的结果还是很稳定的。 本文完整的源代码下载地址： STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1.rar 下一篇将移植MQTT，并对步进电机控制器进行控制。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文在前一篇的基础上，进行基于FreeRTOS的LwIP-1.4.1版本移植、 本文使用的网卡PHY芯片型号是DP83848，工作在MII接口模式，时钟频率是25MHz。 现在的LwIP版本已经发展到了lwIP 2.0.3 版。 但是看了具体的代码后发现一些跟1.4.1对比之下不同之处，其中包含但不全部： 1、IPv4和IPv6的实现代码混合起来，而1.4.1是分开的，通过预处理宏可以分开编译。 2、增加了一些常用的网络组件或应用程序，其中包括了基于tcp接口实现的MQTT协议。 本人也曾试图移植lwIP 2.0.2，发现IPv6实现会被编译进去，并且由此产生一些函数调用问题，在我们的固件库中以及mdk的库中不支持相关函数，另外，本项目用的芯片并不支持IPv6，而相关代码会增加ROM空间的占用，没有必要，而LwIP2.0.2以上的版本所带的MQTT协议实现也可以移植过来到LwIP-1.4.1上使用。 因此还是选用LwIP的1.4.1这个经典版本。但后面的MQTT协议实现没有用LwIP2.0.2版的实现代码，而是比较接近paho.mqtt.embedded-c版的一个实现。 以下是具体移植过程： LwIP的官方网站：http://savannah.nongnu.org/projects/lwip/ LwIP-1.4.1下载地址：http://download.savannah.nongnu.org/releases/lwip/lwip-1.4.1.zip 或：http://ftp.yzu.edu.tw/nongnu/lwip/lwip-1.4.1.zip 或：https://gitee.com/null_926_6734/CongXiangYingGuanFangHuoQiJingXiangXiaZaiDeMouXieYuanDaiMa/raw/master/lwip-1.4.1.zip contrib-1.4.1.zip contrib-1.4.1里面含有官方的移植示例，有windows和unix操作系统下的移植，和某些非操作系统的移植。 在本项目的移植中需要用到一些头文件，可以在contrib-1.4.1中找到。 本文参考了网络上的源代码： STM32_FreeRTOS_LwIP 这份代码的说明是这样的： 说明： 在神州五号STM32F107VC开发板上移植了最新的FreeRTOS-V8.1.2操作系统，并在该系统上移植了最新的LwIP-1.4.1协议栈，能够ping通，但是系统的稳定性没有测试，仅供使用者参考。 本人提供的备用下载地址： STM32_FreeRTOS_LwIP.rar 移植之前，我们要确认一下网卡芯片的工作模式MII接口模式。根据金牛开发板官方驱动代码提供的代码 看到该开发板的PHY芯片DP83848跟STM32F107VC引脚的对应关系如下： lwip-1.4.1.zip代码包解压之后放到third_party目录下。 在IDE上增加一个组，命名为：third_party/LwIP。 1、把third_party\\lwip-1.4.1\\src\\core下的c文件加入工程中； 2、把third_party\\lwip-1.4.1\\src\\core\\ipv4下的c文件加入到工程中； 3、把third_party\\lwip-1.4.1\\src\\netif下的c文件加入到工程中； 4、把third_party\\lwip-1.4.1\\src\\api下的c文件加入到工程中； 5、把一下路径加入包含路径中： ..\\third_party\\lwip-1.4.1\\src\\include;..\\third_party\\lwip-1.4.1\\src\\include\\lwip;..\\third_party\\lwip-1.4.1\\src\\include\\arch;..\\third_party\\lwip-1.4.1\\src\\include\\ipv4;..\\third_party\\lwip-1.4.1\\src\\include\\netif; 此时编译，会出现错误，提示找不到lwipopts.h文件。 我们直接在STM32_FreeRTOS_LwIP这份源代码中直接复制过来，它位置在 STM32_FreeRTOS_LwIP.rar\\STM32_FreeRTOS_LwIP\\App下面，顺便把netconf.h和netconf.c复制过来，放到BSP目录下： 关于lwipopts.h的配置说明请参考： http://blog.csdn.net/slj_win/article/details/16959055 我们拷贝过来的这份lwipopts.h中的配置，是实际使用的时候，会占用大部分的RAM，以至于FreeRTOS的任务经常出现栈溢出或直接跑飞，因此需要稍微减少内存的使用，做一些修改。 还有就是需要添加对DNS的支持： #define LWIP_DNS 1 和对接收数据定时窗口的支持： #define LWIP_SO_RCVTIMEO 1 修改后如下： /** ****************************************************************************** * @file lwipopts.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief lwIP Options Configuration. * This file is based on Utilities\\lwip_v1.3.2\\src\\include\\lwip\\opt.h * and contains the lwIP configuration for the STM32F2x7 demonstration. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ #ifndef __LWIPOPTS_H__ #define __LWIPOPTS_H__ /** * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain * critical regions during buffer allocation, deallocation and memory * allocation and deallocation. */ #define SYS_LIGHTWEIGHT_PROT 0 #define ETHARP_TRUST_IP_MAC 0 #define IP_REASSEMBLY 0 #define IP_FRAG 0 //#define ARP_QUEUEING 0 /* ---------- ARP options ---------- */ #define LWIP_ARP 1 #define ARP_TABLE_SIZE 10 #define ARP_QUEUEING 1 /** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use lwIP facilities. */ #define NO_SYS 0 /* ---------- Memory options ---------- */ /* MEM_ALIGNMENT: should be set to the alignment of the CPU for which lwIP is compiled. 4 byte alignment -&gt; define MEM_ALIGNMENT to 4, 2 byte alignment -&gt; define MEM_ALIGNMENT to 2. */ #define MEM_ALIGNMENT 4 /* MEM_SIZE: the size of the heap memory. If the application will send a lot of data that needs to be copied, this should be set high. */ #define MEM_SIZE (4*1024) // (5*1024) @2017.08.26 /* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application sends a lot of data out of ROM (or other static memory), this should be set high. */ #define MEMP_NUM_PBUF 100 /* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One per active UDP &quot;connection&quot;. */ #define MEMP_NUM_UDP_PCB 6 /* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections. */ #define MEMP_NUM_TCP_PCB 10 /* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */ #define MEMP_NUM_TCP_PCB_LISTEN 5 /* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */ #define MEMP_NUM_TCP_SEG 20 /* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */ #define MEMP_NUM_SYS_TIMEOUT 10 /* ---------- Pbuf options ---------- */ /* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */ #define PBUF_POOL_SIZE 10 // 20 @2017.08.26 /* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */ #define PBUF_POOL_BUFSIZE 500 /* ---------- TCP options ---------- */ #define LWIP_TCP 1 #define TCP_TTL 255 /* Controls if TCP should queue segments that arrive out of order. Define to 0 if your device is low on memory. */ #define TCP_QUEUE_OOSEQ 1 /* TCP Maximum segment size. */ #define TCP_MSS (1500 - 40) /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */ /* TCP sender buffer space (bytes). */ #define TCP_SND_BUF (5*TCP_MSS) /* TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */ #define TCP_SND_QUEUELEN (4* TCP_SND_BUF/TCP_MSS) /* TCP receive window. */ #define TCP_WND (2*TCP_MSS) /* ---------- ICMP options ---------- */ #define LWIP_ICMP 1 /* ---------- DHCP options ---------- */ /* Define LWIP_DHCP to 1 if you want DHCP configuration of interfaces. DHCP is not implemented in lwIP 0.5.1, however, so turning this on does currently not work. */ #define LWIP_DHCP 1 #define LWIP_DNS 1 //added @2017.08.17 /* Enable SO_RCVTIMEO processing. */ #define LWIP_SO_RCVTIMEO 1 //added @2017.08.18 #define DHCP_DOES_ARP_CHECK (LWIP_DHCP) /* ---------- UDP options ---------- */ #define LWIP_UDP 1 #define UDP_TTL 255 /* ---------- Statistics options ---------- */ #define LWIP_STATS 0 #define LWIP_PROVIDE_ERRNO 1 /* -------------------------------------- ---------- Checksum options ---------- -------------------------------------- */ /* The STM32F2x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware: - To use this feature let the following define uncommented. - To disable it and process by CPU comment the the checksum. */ #define CHECKSUM_BY_HARDWARE 1 #ifdef CHECKSUM_BY_HARDWARE /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 0 /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 0 /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 0 #define CHECKSUM_GEN_ICMP 0 /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 0 /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 0 /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 0 #else /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/ #define CHECKSUM_GEN_IP 1 /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/ #define CHECKSUM_GEN_UDP 1 /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/ #define CHECKSUM_GEN_TCP 1 #define CHECKSUM_GEN_ICMP 1 /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/ #define CHECKSUM_CHECK_IP 1 /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/ #define CHECKSUM_CHECK_UDP 1 /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/ #define CHECKSUM_CHECK_TCP 1 #endif /* ---------------------------------------------- ---------- Sequential layer options ---------- ---------------------------------------------- */ /** * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c) */ #define LWIP_NETCONN 1 /* ------------------------------------ ---------- Socket options ---------- ------------------------------------ */ /** * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c) */ #define LWIP_SOCKET 1 /* ----------------------------------- ---------- DEBUG options ---------- ----------------------------------- */ #define LWIP_DEBUG 0 /* --------------------------------- ---------- OS options ---------- --------------------------------- */ #define TCPIP_THREAD_STACKSIZE 1000 #define TCPIP_MBOX_SIZE 5 #define DEFAULT_UDP_RECVMBOX_SIZE 2000 #define DEFAULT_TCP_RECVMBOX_SIZE 2000 #define DEFAULT_ACCEPTMBOX_SIZE 2000 #define DEFAULT_THREAD_STACKSIZE 500 #define TCPIP_THREAD_PRIO (configMAX_PRIORITIES - 2) #endif /* __LWIPOPTS_H__ */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 还有跟移植相关的部分代码在STM32_FreeRTOS_LwIP.rar\\STM32_FreeRTOS_LwIP\\lwip-1.4.1\\src\\include\\arch目录下，把整个文件夹都复制过来： 放在我们的相应目录下，并把其中的sys_arch.c加入到IDE的third_party/LwIP组中。 此时编译一下，会出现一堆警告，其中一个是： ..\\third_party\\lwip-1.4.1\\src\\core\\dns.c(241): warning: #223-D: function &quot;LWIP_PLATFORM_DIAG&quot; declared implicitly 这是LWIP_PLATFORM_DIAG这个宏没有定义的原因。 可以在third_party\\lwip-1.4.1\\src\\include\\lwip\\debug.h这个文件中定义。 找到： #define LWIP_DEBUGF(debug, message) do { \\ 这一行，在它前面加上： #include &lt;stdio.h&gt; #define LWIP_PLATFORM_DIAG printf 并找到： LWIP_PLATFORM_DIAG(message); \\ 修改为： LWIP_PLATFORM_DIAG message ; \\ 再编译，出现错误： ..\\third_party\\lwip-1.4.1\\src\\include\\lwip/sys.h(113): error: #20: identifier &quot;sys_mutex_t&quot; is undefined 解决方法是在 #if LWIP_COMPAT_MUTEX 前面定义这个宏： #define LWIP_COMPAT_MUTEX 1 编译，通过。 这是LwIP协议栈的主体部分OK了，但是还没有跟FreeRTOS对接好，另外没有把网卡驱动搞定。下面一步步完成吧。 接下来，首先把网卡驱动搞定。这部分在STM32_FreeRTOS_LwIP.rar\\STM32_FreeRTOS_LwIP\\STM32_ETH_Driver下的源码基础上做修改。 把整个STM32_ETH_Driver文件夹复制到我们的项目根目录下，在IDE上添加一个组，命名为STM32_ETH_Driver，把项目中的STM32_ETH_Driver\\src\\stm32_eth.c加入到组中。 把..\\STM32_ETH_Driver\\inc加入包含路径中位置如图所示： 接下来要修改stm32_eth.h和stm32_eth.c。 stm32_eth.c主要是对网卡控制器进行操作，以对网卡芯片初始化。 stm32_eth.h： /** ****************************************************************************** * @file stm32_eth.h * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file contains all the functions prototypes for the Ethernet * firmware library. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __STM32_ETH_H #define __STM32_ETH_H #ifdef __cplusplus extern &quot;C&quot; { #endif /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x.h&quot; /** @addtogroup STM32_ETH_Driver * @{ */ /** @defgroup ETH_Exported_Types * @{ */ /** * @brief ETH MAC Init structure definition * @note The user should not configure all the ETH_InitTypeDef structure&#39;s fields. * By calling the ETH_StructInit function the structure¡¯s fields are set to their default values. * Only the parameters that will be set to a non-default value should be configured. */ typedef struct { /** * @brief / * MAC */ uint32_t ETH_AutoNegotiation; /*!&lt; Selects or not the AutoNegotiation mode for the external PHY The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps) and the mode (half/full-duplex). This parameter can be a value of @ref ETH_AutoNegotiation */ uint32_t ETH_Watchdog; /*!&lt; Selects or not the Watchdog timer When enabled, the MAC allows no more then 2048 bytes to be received. When disabled, the MAC can receive up to 16384 bytes. This parameter can be a value of @ref ETH_watchdog */ uint32_t ETH_Jabber; /*!&lt; Selects or not Jabber timer When enabled, the MAC allows no more then 2048 bytes to be sent. When disabled, the MAC can send up to 16384 bytes. This parameter can be a value of @ref ETH_Jabber */ uint32_t ETH_InterFrameGap; /*!&lt; Selects the minimum IFG between frames during transmission This parameter can be a value of @ref ETH_Inter_Frame_Gap */ uint32_t ETH_CarrierSense; /*!&lt; Selects or not the Carrier Sense This parameter can be a value of @ref ETH_Carrier_Sense */ uint32_t ETH_Speed; /*!&lt; Sets the Ethernet speed: 10/100 Mbps This parameter can be a value of @ref ETH_Speed */ uint32_t ETH_ReceiveOwn; /*!&lt; Selects or not the ReceiveOwn ReceiveOwn allows the reception of frames when the TX_EN signal is asserted in Half-Duplex mode This parameter can be a value of @ref ETH_Receive_Own */ uint32_t ETH_LoopbackMode; /*!&lt; Selects or not the internal MAC MII Loopback mode This parameter can be a value of @ref ETH_Loop_Back_Mode */ uint32_t ETH_Mode; /*!&lt; Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode This parameter can be a value of @ref ETH_Duplex_Mode */ uint32_t ETH_ChecksumOffload; /*!&lt; Selects or not the IPv4 checksum checking for received frame payloads&#39; TCP/UDP/ICMP headers. This parameter can be a value of @ref ETH_Checksum_Offload */ uint32_t ETH_RetryTransmission; /*!&lt; Selects or not the MAC attempt retries transmission, based on the settings of BL, when a colision occurs (Half-Duplex mode) This parameter can be a value of @ref ETH_Retry_Transmission */ uint32_t ETH_AutomaticPadCRCStrip; /*!&lt; Selects or not the Automatic MAC Pad/CRC Stripping This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ uint32_t ETH_BackOffLimit; /*!&lt; Selects the BackOff limit value This parameter can be a value of @ref ETH_Back_Off_Limit */ uint32_t ETH_DeferralCheck; /*!&lt; Selects or not the deferral check function (Half-Duplex mode) This parameter can be a value of @ref ETH_Deferral_Check */ uint32_t ETH_ReceiveAll; /*!&lt; Selects or not all frames reception by the MAC (No fitering) This parameter can be a value of @ref ETH_Receive_All */ uint32_t ETH_SourceAddrFilter; /*!&lt; Selects the Source Address Filter mode This parameter can be a value of @ref ETH_Source_Addr_Filter */ uint32_t ETH_PassControlFrames; /*!&lt; Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames) This parameter can be a value of @ref ETH_Pass_Control_Frames */ uint32_t ETH_BroadcastFramesReception; /*!&lt; Selects or not the reception of Broadcast Frames This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */ uint32_t ETH_DestinationAddrFilter; /*!&lt; Sets the destination filter mode for both unicast and multicast frames This parameter can be a value of @ref ETH_Destination_Addr_Filter */ uint32_t ETH_PromiscuousMode; /*!&lt; Selects or not the Promiscuous Mode This parameter can be a value of @ref ETH_Promiscuous_Mode */ uint32_t ETH_MulticastFramesFilter; /*!&lt; Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ uint32_t ETH_UnicastFramesFilter; /*!&lt; Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ uint32_t ETH_HashTableHigh; /*!&lt; This field holds the higher 32 bits of Hash table. */ uint32_t ETH_HashTableLow; /*!&lt; This field holds the lower 32 bits of Hash table. */ uint32_t ETH_PauseTime; /*!&lt; This field holds the value to be used in the Pause Time field in the transmit control frame */ uint32_t ETH_ZeroQuantaPause; /*!&lt; Selects or not the automatic generation of Zero-Quanta Pause Control frames This parameter can be a value of @ref ETH_Zero_Quanta_Pause */ uint32_t ETH_PauseLowThreshold; /*!&lt; This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Frame This parameter can be a value of @ref ETH_Pause_Low_Threshold */ uint32_t ETH_UnicastPauseFrameDetect; /*!&lt; Selects or not the MAC detection of the Pause frames (with MAC Address0 unicast address and unique multicast address) This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */ uint32_t ETH_ReceiveFlowControl; /*!&lt; Enables or disables the MAC to decode the received Pause frame and disable its transmitter for a specified time (Pause Time) This parameter can be a value of @ref ETH_Receive_Flow_Control */ uint32_t ETH_TransmitFlowControl; /*!&lt; Enables or disables the MAC to transmit Pause frames (Full-Duplex mode) or the MAC back-pressure operation (Half-Duplex mode) This parameter can be a value of @ref ETH_Transmit_Flow_Control */ uint32_t ETH_VLANTagComparison; /*!&lt; Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for comparison and filtering This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ uint32_t ETH_VLANTagIdentifier; /*!&lt; Holds the VLAN tag identifier for receive frames */ /** * @brief / * DMA */ uint32_t ETH_DropTCPIPChecksumErrorFrame; /*!&lt; Selects or not the Dropping of TCP/IP Checksum Error Frames This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ uint32_t ETH_ReceiveStoreForward; /*!&lt; Enables or disables the Receive store and forward mode This parameter can be a value of @ref ETH_Receive_Store_Forward */ uint32_t ETH_FlushReceivedFrame; /*!&lt; Enables or disables the flushing of received frames This parameter can be a value of @ref ETH_Flush_Received_Frame */ uint32_t ETH_TransmitStoreForward; /*!&lt; Enables or disables Transmit store and forward mode This parameter can be a value of @ref ETH_Transmit_Store_Forward */ uint32_t ETH_TransmitThresholdControl; /*!&lt; Selects or not the Transmit Threshold Control This parameter can be a value of @ref ETH_Transmit_Threshold_Control */ uint32_t ETH_ForwardErrorFrames; /*!&lt; Selects or not the forward to the DMA of erroneous frames This parameter can be a value of @ref ETH_Forward_Error_Frames */ uint32_t ETH_ForwardUndersizedGoodFrames; /*!&lt; Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error and length less than 64 bytes) including pad-bytes and CRC) This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */ uint32_t ETH_ReceiveThresholdControl; /*!&lt; Selects the threshold level of the Receive FIFO This parameter can be a value of @ref ETH_Receive_Threshold_Control */ uint32_t ETH_SecondFrameOperate; /*!&lt; Selects or not the Operate on second frame mode, which allows the DMA to process a second frame of Transmit data even before obtaining the status for the first frame. This parameter can be a value of @ref ETH_Second_Frame_Operate */ uint32_t ETH_AddressAlignedBeats; /*!&lt; Enables or disables the Address Aligned Beats This parameter can be a value of @ref ETH_Address_Aligned_Beats */ uint32_t ETH_FixedBurst; /*!&lt; Enables or disables the AHB Master interface fixed burst transfers This parameter can be a value of @ref ETH_Fixed_Burst */ uint32_t ETH_RxDMABurstLength; /*!&lt; Indicates the maximum number of beats to be transferred in one Rx DMA transaction This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ uint32_t ETH_TxDMABurstLength; /*!&lt; Indicates sthe maximum number of beats to be transferred in one Tx DMA transaction This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */ uint32_t ETH_DescriptorSkipLength; /*!&lt; Specifies the number of word to skip between two unchained descriptors (Ring mode) */ uint32_t ETH_DMAArbitration; /*!&lt; Selects the DMA Tx/Rx arbitration This parameter can be a value of @ref ETH_DMA_Arbitration */ }ETH_InitTypeDef; /**--------------------------------------------------------------------------**/ /** * @brief DMA descriptors types */ /**--------------------------------------------------------------------------**/ /** * @brief ETH DMA Desciptors data structure definition */ typedef struct { uint32_t Status; /*!&lt; Status */ uint32_t ControlBufferSize; /*!&lt; Control and Buffer1, Buffer2 lengths */ uint32_t Buffer1Addr; /*!&lt; Buffer1 address pointer */ uint32_t Buffer2NextDescAddr; /*!&lt; Buffer2 or next descriptor address pointer */ } ETH_DMADESCTypeDef; /** * @} */ /** @defgroup ETH_Exported_Constants * @{ */ /**--------------------------------------------------------------------------**/ /** * @brief ETH Frames defines */ /**--------------------------------------------------------------------------**/ /** @defgroup ENET_Buffers_setting * @{ */ #define ETH_MAX_PACKET_SIZE 1520 /*!&lt; ETH_HEADER + ETH_EXTRA + MAX_ETH_PAYLOAD + ETH_CRC */ #define ETH_HEADER 14 /*!&lt; 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */ #define ETH_CRC 4 /*!&lt; Ethernet CRC */ #define ETH_EXTRA 2 /*!&lt; Extra bytes in some cases */ #define VLAN_TAG 4 /*!&lt; optional 802.1q VLAN Tag */ #define MIN_ETH_PAYLOAD 46 /*!&lt; Minimum Ethernet payload size */ #define MAX_ETH_PAYLOAD 1500 /*!&lt; Maximum Ethernet payload size */ #define JUMBO_FRAME_PAYLOAD 9000 /*!&lt; Jumbo frame payload size */ /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA descriptors registers bits definition */ /**--------------------------------------------------------------------------**/ /** @code DMA Tx Desciptor ----------------------------------------------------------------------------------------------- TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] | ----------------------------------------------------------------------------------------------- TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] | ----------------------------------------------------------------------------------------------- TDES2 | Buffer1 Address [31:0] | ----------------------------------------------------------------------------------------------- TDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | ----------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of TDES0 register: DMA Tx descriptor status register */ #define ETH_DMATxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMATxDesc_IC ((uint32_t)0x40000000) /*!&lt; Interrupt on Completion */ #define ETH_DMATxDesc_LS ((uint32_t)0x20000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FS ((uint32_t)0x10000000) /*!&lt; First Segment */ #define ETH_DMATxDesc_DC ((uint32_t)0x08000000) /*!&lt; Disable CRC */ #define ETH_DMATxDesc_DP ((uint32_t)0x04000000) /*!&lt; Disable Padding */ #define ETH_DMATxDesc_TTSE ((uint32_t)0x02000000) /*!&lt; Transmit Time Stamp Enable */ #define ETH_DMATxDesc_CIC ((uint32_t)0x00C00000) /*!&lt; Checksum Insertion Control: 4 cases */ #define ETH_DMATxDesc_CIC_ByPass ((uint32_t)0x00000000) /*!&lt; Do Nothing: Checksum Engine is bypassed */ #define ETH_DMATxDesc_CIC_IPV4Header ((uint32_t)0x00400000) /*!&lt; IPV4 header Checksum Insertion */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP Checksum Insertion calculated over segment only */ #define ETH_DMATxDesc_CIC_TCPUDPICMP_Full ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP Checksum Insertion fully calculated */ #define ETH_DMATxDesc_TER ((uint32_t)0x00200000) /*!&lt; Transmit End of Ring */ #define ETH_DMATxDesc_TCH ((uint32_t)0x00100000) /*!&lt; Second Address Chained */ #define ETH_DMATxDesc_TTSS ((uint32_t)0x00020000) /*!&lt; Tx Time Stamp Status */ #define ETH_DMATxDesc_IHE ((uint32_t)0x00010000) /*!&lt; IP Header Error */ #define ETH_DMATxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */ #define ETH_DMATxDesc_JT ((uint32_t)0x00004000) /*!&lt; Jabber Timeout */ #define ETH_DMATxDesc_FF ((uint32_t)0x00002000) /*!&lt; Frame Flushed: DMA/MTL flushed the frame due to SW flush */ #define ETH_DMATxDesc_PCE ((uint32_t)0x00001000) /*!&lt; Payload Checksum Error */ #define ETH_DMATxDesc_LCA ((uint32_t)0x00000800) /*!&lt; Loss of Carrier: carrier lost during tramsmission */ #define ETH_DMATxDesc_NC ((uint32_t)0x00000400) /*!&lt; No Carrier: no carrier signal from the tranceiver */ #define ETH_DMATxDesc_LCO ((uint32_t)0x00000200) /*!&lt; Late Collision: transmission aborted due to collision */ #define ETH_DMATxDesc_EC ((uint32_t)0x00000100) /*!&lt; Excessive Collision: transmission aborted after 16 collisions */ #define ETH_DMATxDesc_VF ((uint32_t)0x00000080) /*!&lt; VLAN Frame */ #define ETH_DMATxDesc_CC ((uint32_t)0x00000078) /*!&lt; Collision Count */ #define ETH_DMATxDesc_ED ((uint32_t)0x00000004) /*!&lt; Excessive Deferral */ #define ETH_DMATxDesc_UF ((uint32_t)0x00000002) /*!&lt; Underflow Error: late data arrival from the memory */ #define ETH_DMATxDesc_DB ((uint32_t)0x00000001) /*!&lt; Deferred Bit */ /** * @brief Bit definition of TDES1 register */ #define ETH_DMATxDesc_TBS2 ((uint32_t)0x1FFF0000) /*!&lt; Transmit Buffer2 Size */ #define ETH_DMATxDesc_TBS1 ((uint32_t)0x00001FFF) /*!&lt; Transmit Buffer1 Size */ /** * @brief Bit definition of TDES2 register */ #define ETH_DMATxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of TDES3 register */ #define ETH_DMATxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /** * @} */ /** @defgroup DMA_Rx_descriptor * @{ */ /** @code DMA Rx Desciptor -------------------------------------------------------------------------------------------------------------------- RDES0 | OWN(31) | Status [30:0] | --------------------------------------------------------------------------------------------------------------------- RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] | --------------------------------------------------------------------------------------------------------------------- RDES2 | Buffer1 Address [31:0] | --------------------------------------------------------------------------------------------------------------------- RDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | --------------------------------------------------------------------------------------------------------------------- @endcode */ /** * @brief Bit definition of RDES0 register: DMA Rx descriptor status register */ #define ETH_DMARxDesc_OWN ((uint32_t)0x80000000) /*!&lt; OWN bit: descriptor is owned by DMA engine */ #define ETH_DMARxDesc_AFM ((uint32_t)0x40000000) /*!&lt; DA Filter Fail for the rx frame */ #define ETH_DMARxDesc_FL ((uint32_t)0x3FFF0000) /*!&lt; Receive descriptor frame length */ #define ETH_DMARxDesc_ES ((uint32_t)0x00008000) /*!&lt; Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */ #define ETH_DMARxDesc_DE ((uint32_t)0x00004000) /*!&lt; Desciptor error: no more descriptors for receive frame */ #define ETH_DMARxDesc_SAF ((uint32_t)0x00002000) /*!&lt; SA Filter Fail for the received frame */ #define ETH_DMARxDesc_LE ((uint32_t)0x00001000) /*!&lt; Frame size not matching with length field */ #define ETH_DMARxDesc_OE ((uint32_t)0x00000800) /*!&lt; Overflow Error: Frame was damaged due to buffer overflow */ #define ETH_DMARxDesc_VLAN ((uint32_t)0x00000400) /*!&lt; VLAN Tag: received frame is a VLAN frame */ #define ETH_DMARxDesc_FS ((uint32_t)0x00000200) /*!&lt; First descriptor of the frame */ #define ETH_DMARxDesc_LS ((uint32_t)0x00000100) /*!&lt; Last descriptor of the frame */ #define ETH_DMARxDesc_IPV4HCE ((uint32_t)0x00000080) /*!&lt; IPC Checksum Error: Rx Ipv4 header checksum error */ #define ETH_DMARxDesc_LC ((uint32_t)0x00000040) /*!&lt; Late collision occurred during reception */ #define ETH_DMARxDesc_FT ((uint32_t)0x00000020) /*!&lt; Frame type - Ethernet, otherwise 802.3 */ #define ETH_DMARxDesc_RWT ((uint32_t)0x00000010) /*!&lt; Receive Watchdog Timeout: watchdog timer expired during reception */ #define ETH_DMARxDesc_RE ((uint32_t)0x00000008) /*!&lt; Receive error: error reported by MII interface */ #define ETH_DMARxDesc_DBE ((uint32_t)0x00000004) /*!&lt; Dribble bit error: frame contains non int multiple of 8 bits */ #define ETH_DMARxDesc_CE ((uint32_t)0x00000002) /*!&lt; CRC error */ #define ETH_DMARxDesc_MAMPCE ((uint32_t)0x00000001) /*!&lt; Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */ /** * @brief Bit definition of RDES1 register */ #define ETH_DMARxDesc_DIC ((uint32_t)0x80000000) /*!&lt; Disable Interrupt on Completion */ #define ETH_DMARxDesc_RBS2 ((uint32_t)0x1FFF0000) /*!&lt; Receive Buffer2 Size */ #define ETH_DMARxDesc_RER ((uint32_t)0x00008000) /*!&lt; Receive End of Ring */ #define ETH_DMARxDesc_RCH ((uint32_t)0x00004000) /*!&lt; Second Address Chained */ #define ETH_DMARxDesc_RBS1 ((uint32_t)0x00001FFF) /*!&lt; Receive Buffer1 Size */ /** * @brief Bit definition of RDES2 register */ #define ETH_DMARxDesc_B1AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer1 Address Pointer */ /** * @brief Bit definition of RDES3 register */ #define ETH_DMARxDesc_B2AP ((uint32_t)0xFFFFFFFF) /*!&lt; Buffer2 Address Pointer */ /**--------------------------------------------------------------------------**/ /** * @brief Desciption of common PHY registers */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup PHY_Read_write_Timeouts * @{ */ #define PHY_READ_TO ((uint32_t)0x0004FFFF) #define PHY_WRITE_TO ((uint32_t)0x0004FFFF) /** * @} */ /** @defgroup PHY_Reset_Delay * @{ */ #define PHY_ResetDelay ((uint32_t)0x000FFFFF) /** * @} */ /** @defgroup PHY_Config_Delay * @{ */ #define PHY_ConfigDelay ((uint32_t)0x00FFFFFF) /** * @} */ /** @defgroup PHY_Register_address * @{ */ #define PHY_BCR 0 /*!&lt; Tranceiver Basic Control Register */ #define PHY_BSR 1 /*!&lt; Tranceiver Basic Status Register */ /** * @} */ /** @defgroup PHY_basic_Control_register * @{ */ #define PHY_Reset ((u16)0x8000) /*!&lt; PHY Reset */ #define PHY_Loopback ((u16)0x4000) /*!&lt; Select loop-back mode */ #define PHY_FULLDUPLEX_100M ((u16)0x2100) /*!&lt; Set the full-duplex mode at 100 Mb/s */ #define PHY_HALFDUPLEX_100M ((u16)0x2000) /*!&lt; Set the half-duplex mode at 100 Mb/s */ #define PHY_FULLDUPLEX_10M ((u16)0x0100) /*!&lt; Set the full-duplex mode at 10 Mb/s */ #define PHY_HALFDUPLEX_10M ((u16)0x0000) /*!&lt; Set the half-duplex mode at 10 Mb/s */ #define PHY_AutoNegotiation ((u16)0x1000) /*!&lt; Enable auto-negotiation function */ #define PHY_Restart_AutoNegotiation ((u16)0x0200) /*!&lt; Restart auto-negotiation function */ #define PHY_Powerdown ((u16)0x0800) /*!&lt; Select the power down mode */ #define PHY_Isolate ((u16)0x0400) /*!&lt; Isolate PHY from MII */ /** * @} */ /** @defgroup PHY_basic_status_register * @{ */ #define PHY_AutoNego_Complete ((u16)0x0020) /*!&lt; Auto-Negotioation process completed */ #define PHY_Linked_Status ((u16)0x0004) /*!&lt; Valid link established */ #define PHY_Jabber_detection ((u16)0x0002) /*!&lt; Jabber condition detected */ /** * @} */ /** @defgroup PHY_status_register * @{ */ /* The PHY status register value change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_SR 31 /*!&lt; Tranceiver Status Register */ /** * @brief For DP83848 */ #define PHY_SR 16 /*!&lt; Tranceiver Status Register */ /* The Speed and Duplex mask values change from a PHY to another so the user have to update this value depending on the used external PHY */ /** * @brief For LAN8700 */ //#define PHY_Speed_Status ((u16)0x0004) /*!&lt; Configured information of Speed: 10Mbps */ //#define PHY_Duplex_Status ((u16)0x0010) /*!&lt; Configured information of Duplex: Full-duplex */ /** * @brief For DP83848 */ #define PHY_Speed_Status ((u16)0x0002) /*!&lt; Configured information of Speed: 10Mbps */ #define PHY_Duplex_Status ((u16)0x0004) /*!&lt; Configured information of Duplex: Full-duplex */ #define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) &lt;= 0x1F) #define IS_ETH_PHY_REG(REG) (REG &lt;= 0x1F) /**--------------------------------------------------------------------------**/ /** * @brief MAC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_AutoNegotiation * @{ */ #define ETH_AutoNegotiation_Enable ((uint32_t)0x00000001) #define ETH_AutoNegotiation_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \\ ((CMD) == ETH_AutoNegotiation_Disable)) /** * @} */ /** @defgroup ETH_watchdog * @{ */ #define ETH_Watchdog_Enable ((uint32_t)0x00000000) #define ETH_Watchdog_Disable ((uint32_t)0x00800000) #define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \\ ((CMD) == ETH_Watchdog_Disable)) /** * @} */ /** @defgroup ETH_Jabber * @{ */ #define ETH_Jabber_Enable ((uint32_t)0x00000000) #define ETH_Jabber_Disable ((uint32_t)0x00400000) #define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \\ ((CMD) == ETH_Jabber_Disable)) /** * @} */ /** @defgroup ETH_Inter_Frame_Gap * @{ */ #define ETH_InterFrameGap_96Bit ((uint32_t)0x00000000) /*!&lt; minimum IFG between frames during transmission is 96Bit */ #define ETH_InterFrameGap_88Bit ((uint32_t)0x00020000) /*!&lt; minimum IFG between frames during transmission is 88Bit */ #define ETH_InterFrameGap_80Bit ((uint32_t)0x00040000) /*!&lt; minimum IFG between frames during transmission is 80Bit */ #define ETH_InterFrameGap_72Bit ((uint32_t)0x00060000) /*!&lt; minimum IFG between frames during transmission is 72Bit */ #define ETH_InterFrameGap_64Bit ((uint32_t)0x00080000) /*!&lt; minimum IFG between frames during transmission is 64Bit */ #define ETH_InterFrameGap_56Bit ((uint32_t)0x000A0000) /*!&lt; minimum IFG between frames during transmission is 56Bit */ #define ETH_InterFrameGap_48Bit ((uint32_t)0x000C0000) /*!&lt; minimum IFG between frames during transmission is 48Bit */ #define ETH_InterFrameGap_40Bit ((uint32_t)0x000E0000) /*!&lt; minimum IFG between frames during transmission is 40Bit */ #define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \\ ((GAP) == ETH_InterFrameGap_88Bit) || \\ ((GAP) == ETH_InterFrameGap_80Bit) || \\ ((GAP) == ETH_InterFrameGap_72Bit) || \\ ((GAP) == ETH_InterFrameGap_64Bit) || \\ ((GAP) == ETH_InterFrameGap_56Bit) || \\ ((GAP) == ETH_InterFrameGap_48Bit) || \\ ((GAP) == ETH_InterFrameGap_40Bit)) /** * @} */ /** @defgroup ETH_Carrier_Sense * @{ */ #define ETH_CarrierSense_Enable ((uint32_t)0x00000000) #define ETH_CarrierSense_Disable ((uint32_t)0x00010000) #define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \\ ((CMD) == ETH_CarrierSense_Disable)) /** * @} */ /** @defgroup ETH_Speed * @{ */ #define ETH_Speed_10M ((uint32_t)0x00000000) #define ETH_Speed_100M ((uint32_t)0x00004000) #define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \\ ((SPEED) == ETH_Speed_100M)) /** * @} */ /** @defgroup ETH_Receive_Own * @{ */ #define ETH_ReceiveOwn_Enable ((uint32_t)0x00000000) #define ETH_ReceiveOwn_Disable ((uint32_t)0x00002000) #define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \\ ((CMD) == ETH_ReceiveOwn_Disable)) /** * @} */ /** @defgroup ETH_Loop_Back_Mode * @{ */ #define ETH_LoopbackMode_Enable ((uint32_t)0x00001000) #define ETH_LoopbackMode_Disable ((uint32_t)0x00000000) #define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \\ ((CMD) == ETH_LoopbackMode_Disable)) /** * @} */ /** @defgroup ETH_Duplex_Mode * @{ */ #define ETH_Mode_FullDuplex ((uint32_t)0x00000800) #define ETH_Mode_HalfDuplex ((uint32_t)0x00000000) #define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \\ ((MODE) == ETH_Mode_HalfDuplex)) /** * @} */ /** @defgroup ETH_Checksum_Offload * @{ */ #define ETH_ChecksumOffload_Enable ((uint32_t)0x00000400) #define ETH_ChecksumOffload_Disable ((uint32_t)0x00000000) #define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \\ ((CMD) == ETH_ChecksumOffload_Disable)) /** * @} */ /** @defgroup ETH_Retry_Transmission * @{ */ #define ETH_RetryTransmission_Enable ((uint32_t)0x00000000) #define ETH_RetryTransmission_Disable ((uint32_t)0x00000200) #define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \\ ((CMD) == ETH_RetryTransmission_Disable)) /** * @} */ /** @defgroup ETH_Automatic_Pad_CRC_Strip * @{ */ #define ETH_AutomaticPadCRCStrip_Enable ((uint32_t)0x00000080) #define ETH_AutomaticPadCRCStrip_Disable ((uint32_t)0x00000000) #define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \\ ((CMD) == ETH_AutomaticPadCRCStrip_Disable)) /** * @} */ /** @defgroup ETH_Back_Off_Limit * @{ */ #define ETH_BackOffLimit_10 ((uint32_t)0x00000000) #define ETH_BackOffLimit_8 ((uint32_t)0x00000020) #define ETH_BackOffLimit_4 ((uint32_t)0x00000040) #define ETH_BackOffLimit_1 ((uint32_t)0x00000060) #define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \\ ((LIMIT) == ETH_BackOffLimit_8) || \\ ((LIMIT) == ETH_BackOffLimit_4) || \\ ((LIMIT) == ETH_BackOffLimit_1)) /** * @} */ /** @defgroup ETH_Deferral_Check * @{ */ #define ETH_DeferralCheck_Enable ((uint32_t)0x00000010) #define ETH_DeferralCheck_Disable ((uint32_t)0x00000000) #define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \\ ((CMD) == ETH_DeferralCheck_Disable)) /** * @} */ /** @defgroup ETH_Receive_All * @{ */ #define ETH_ReceiveAll_Enable ((uint32_t)0x80000000) #define ETH_ReceiveAll_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \\ ((CMD) == ETH_ReceiveAll_Disable)) /** * @} */ /** @defgroup ETH_Source_Addr_Filter * @{ */ #define ETH_SourceAddrFilter_Normal_Enable ((uint32_t)0x00000200) #define ETH_SourceAddrFilter_Inverse_Enable ((uint32_t)0x00000300) #define ETH_SourceAddrFilter_Disable ((uint32_t)0x00000000) #define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \\ ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \\ ((CMD) == ETH_SourceAddrFilter_Disable)) /** * @} */ /** @defgroup ETH_Pass_Control_Frames * @{ */ #define ETH_PassControlFrames_BlockAll ((uint32_t)0x00000040) /*!&lt; MAC filters all control frames from reaching the application */ #define ETH_PassControlFrames_ForwardAll ((uint32_t)0x00000080) /*!&lt; MAC forwards all control frames to application even if they fail the Address Filter */ #define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)0x000000C0) /*!&lt; MAC forwards control frames that pass the Address Filter. */ #define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \\ ((PASS) == ETH_PassControlFrames_ForwardAll) || \\ ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter)) /** * @} */ /** @defgroup ETH_Broadcast_Frames_Reception * @{ */ #define ETH_BroadcastFramesReception_Enable ((uint32_t)0x00000000) #define ETH_BroadcastFramesReception_Disable ((uint32_t)0x00000020) #define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \\ ((CMD) == ETH_BroadcastFramesReception_Disable)) /** * @} */ /** @defgroup ETH_Destination_Addr_Filter * @{ */ #define ETH_DestinationAddrFilter_Normal ((uint32_t)0x00000000) #define ETH_DestinationAddrFilter_Inverse ((uint32_t)0x00000008) #define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \\ ((FILTER) == ETH_DestinationAddrFilter_Inverse)) /** * @} */ /** @defgroup ETH_Promiscuous_Mode * @{ */ #define ETH_PromiscuousMode_Enable ((uint32_t)0x00000001) #define ETH_PromiscuousMode_Disable ((uint32_t)0x00000000) #define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \\ ((CMD) == ETH_PromiscuousMode_Disable)) /** * @} */ /** @defgroup ETH_Multicast_Frames_Filter * @{ */ #define ETH_MulticastFramesFilter_PerfectHashTable ((uint32_t)0x00000404) #define ETH_MulticastFramesFilter_HashTable ((uint32_t)0x00000004) #define ETH_MulticastFramesFilter_Perfect ((uint32_t)0x00000000) #define ETH_MulticastFramesFilter_None ((uint32_t)0x00000010) #define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \\ ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \\ ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \\ ((FILTER) == ETH_MulticastFramesFilter_None)) /** * @} */ /** @defgroup ETH_Unicast_Frames_Filter * @{ */ #define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)0x00000402) #define ETH_UnicastFramesFilter_HashTable ((uint32_t)0x00000002) #define ETH_UnicastFramesFilter_Perfect ((uint32_t)0x00000000) #define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \\ ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \\ ((FILTER) == ETH_UnicastFramesFilter_Perfect)) /** * @} */ /** @defgroup ETH_Pause_Time * @{ */ #define IS_ETH_PAUSE_TIME(TIME) ((TIME) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_Zero_Quanta_Pause * @{ */ #define ETH_ZeroQuantaPause_Enable ((uint32_t)0x00000000) #define ETH_ZeroQuantaPause_Disable ((uint32_t)0x00000080) #define IS_ETH_ZEROQUANTA_PAUSE(CMD) (((CMD) == ETH_ZeroQuantaPause_Enable) || \\ ((CMD) == ETH_ZeroQuantaPause_Disable)) /** * @} */ /** @defgroup ETH_Pause_Low_Threshold * @{ */ #define ETH_PauseLowThreshold_Minus4 ((uint32_t)0x00000000) /*!&lt; Pause time minus 4 slot times */ #define ETH_PauseLowThreshold_Minus28 ((uint32_t)0x00000010) /*!&lt; Pause time minus 28 slot times */ #define ETH_PauseLowThreshold_Minus144 ((uint32_t)0x00000020) /*!&lt; Pause time minus 144 slot times */ #define ETH_PauseLowThreshold_Minus256 ((uint32_t)0x00000030) /*!&lt; Pause time minus 256 slot times */ #define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \\ ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \\ ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \\ ((THRESHOLD) == ETH_PauseLowThreshold_Minus256)) /** * @} */ /** @defgroup ETH_Unicast_Pause_Frame_Detect * @{ */ #define ETH_UnicastPauseFrameDetect_Enable ((uint32_t)0x00000008) #define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)0x00000000) #define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \\ ((CMD) == ETH_UnicastPauseFrameDetect_Disable)) /** * @} */ /** @defgroup ETH_Receive_Flow_Control * @{ */ #define ETH_ReceiveFlowControl_Enable ((uint32_t)0x00000004) #define ETH_ReceiveFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \\ ((CMD) == ETH_ReceiveFlowControl_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Flow_Control * @{ */ #define ETH_TransmitFlowControl_Enable ((uint32_t)0x00000002) #define ETH_TransmitFlowControl_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \\ ((CMD) == ETH_TransmitFlowControl_Disable)) /** * @} */ /** @defgroup ETH_VLAN_Tag_Comparison * @{ */ #define ETH_VLANTagComparison_12Bit ((uint32_t)0x00010000) #define ETH_VLANTagComparison_16Bit ((uint32_t)0x00000000) #define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \\ ((COMPARISON) == ETH_VLANTagComparison_16Bit)) #define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) &lt;= 0xFFFF) /** * @} */ /** @defgroup ETH_MAC_Flags * @{ */ #define ETH_MAC_FLAG_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger flag (on MAC) */ #define ETH_MAC_FLAG_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit flag */ #define ETH_MAC_FLAG_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive flag */ #define ETH_MAC_FLAG_MMC ((uint32_t)0x00000010) /*!&lt; MMC flag (on MAC) */ #define ETH_MAC_FLAG_PMT ((uint32_t)0x00000008) /*!&lt; PMT flag (on MAC) */ #define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \\ ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \\ ((FLAG) == ETH_MAC_FLAG_PMT)) /** * @} */ /** @defgroup ETH_MAC_Interrupts * @{ */ #define ETH_MAC_IT_TST ((uint32_t)0x00000200) /*!&lt; Time stamp trigger interrupt (on MAC) */ #define ETH_MAC_IT_MMCT ((uint32_t)0x00000040) /*!&lt; MMC transmit interrupt */ #define ETH_MAC_IT_MMCR ((uint32_t)0x00000020) /*!&lt; MMC receive interrupt */ #define ETH_MAC_IT_MMC ((uint32_t)0x00000010) /*!&lt; MMC interrupt (on MAC) */ #define ETH_MAC_IT_PMT ((uint32_t)0x00000008) /*!&lt; PMT interrupt (on MAC) */ #define IS_ETH_MAC_IT(IT) ((((IT) &amp; (uint32_t)0xFFFFFDF7) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \\ ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \\ ((IT) == ETH_MAC_IT_PMT)) /** * @} */ /** @defgroup ETH_MAC_addresses * @{ */ #define ETH_MAC_Address0 ((uint32_t)0x00000000) #define ETH_MAC_Address1 ((uint32_t)0x00000008) #define ETH_MAC_Address2 ((uint32_t)0x00000010) #define ETH_MAC_Address3 ((uint32_t)0x00000018) #define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \\ ((ADDRESS) == ETH_MAC_Address1) || \\ ((ADDRESS) == ETH_MAC_Address2) || \\ ((ADDRESS) == ETH_MAC_Address3)) #define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \\ ((ADDRESS) == ETH_MAC_Address2) || \\ ((ADDRESS) == ETH_MAC_Address3)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames * @{ */ #define ETH_MAC_AddressFilter_SA ((uint32_t)0x00000000) #define ETH_MAC_AddressFilter_DA ((uint32_t)0x00000008) #define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \\ ((FILTER) == ETH_MAC_AddressFilter_DA)) /** * @} */ /** @defgroup ETH_MAC_addresses_filter_Mask_bytes * @{ */ #define ETH_MAC_AddressMask_Byte6 ((uint32_t)0x20000000) /*!&lt; Mask MAC Address high reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte5 ((uint32_t)0x10000000) /*!&lt; Mask MAC Address high reg bits [7:0] */ #define ETH_MAC_AddressMask_Byte4 ((uint32_t)0x08000000) /*!&lt; Mask MAC Address low reg bits [31:24] */ #define ETH_MAC_AddressMask_Byte3 ((uint32_t)0x04000000) /*!&lt; Mask MAC Address low reg bits [23:16] */ #define ETH_MAC_AddressMask_Byte2 ((uint32_t)0x02000000) /*!&lt; Mask MAC Address low reg bits [15:8] */ #define ETH_MAC_AddressMask_Byte1 ((uint32_t)0x01000000) /*!&lt; Mask MAC Address low reg bits [70] */ #define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \\ ((MASK) == ETH_MAC_AddressMask_Byte5) || \\ ((MASK) == ETH_MAC_AddressMask_Byte4) || \\ ((MASK) == ETH_MAC_AddressMask_Byte3) || \\ ((MASK) == ETH_MAC_AddressMask_Byte2) || \\ ((MASK) == ETH_MAC_AddressMask_Byte1)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA Desciptors defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_flags * @{ */ #define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \\ ((FLAG) == ETH_DMATxDesc_IC) || \\ ((FLAG) == ETH_DMATxDesc_LS) || \\ ((FLAG) == ETH_DMATxDesc_FS) || \\ ((FLAG) == ETH_DMATxDesc_DC) || \\ ((FLAG) == ETH_DMATxDesc_DP) || \\ ((FLAG) == ETH_DMATxDesc_TTSE) || \\ ((FLAG) == ETH_DMATxDesc_TER) || \\ ((FLAG) == ETH_DMATxDesc_TCH) || \\ ((FLAG) == ETH_DMATxDesc_TTSS) || \\ ((FLAG) == ETH_DMATxDesc_IHE) || \\ ((FLAG) == ETH_DMATxDesc_ES) || \\ ((FLAG) == ETH_DMATxDesc_JT) || \\ ((FLAG) == ETH_DMATxDesc_FF) || \\ ((FLAG) == ETH_DMATxDesc_PCE) || \\ ((FLAG) == ETH_DMATxDesc_LCA) || \\ ((FLAG) == ETH_DMATxDesc_NC) || \\ ((FLAG) == ETH_DMATxDesc_LCO) || \\ ((FLAG) == ETH_DMATxDesc_EC) || \\ ((FLAG) == ETH_DMATxDesc_VF) || \\ ((FLAG) == ETH_DMATxDesc_CC) || \\ ((FLAG) == ETH_DMATxDesc_ED) || \\ ((FLAG) == ETH_DMATxDesc_UF) || \\ ((FLAG) == ETH_DMATxDesc_DB)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_segment * @{ */ #define ETH_DMATxDesc_LastSegment ((uint32_t)0x40000000) /*!&lt; Last Segment */ #define ETH_DMATxDesc_FirstSegment ((uint32_t)0x20000000) /*!&lt; First Segment */ #define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \\ ((SEGMENT) == ETH_DMATxDesc_FirstSegment)) /** * @} */ /** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control * @{ */ #define ETH_DMATxDesc_ChecksumByPass ((uint32_t)0x00000000) /*!&lt; Checksum engine bypass */ #define ETH_DMATxDesc_ChecksumIPV4Header ((uint32_t)0x00400000) /*!&lt; IPv4 header checksum insertion */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment ((uint32_t)0x00800000) /*!&lt; TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */ #define ETH_DMATxDesc_ChecksumTCPUDPICMPFull ((uint32_t)0x00C00000) /*!&lt; TCP/UDP/ICMP checksum fully in hardware including pseudo header */ #define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \\ ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \\ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \\ ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull)) /** * @brief ETH DMA Tx Desciptor buffer size */ #define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) &lt;= 0x1FFF) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_flags * @{ */ #define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \\ ((FLAG) == ETH_DMARxDesc_AFM) || \\ ((FLAG) == ETH_DMARxDesc_ES) || \\ ((FLAG) == ETH_DMARxDesc_DE) || \\ ((FLAG) == ETH_DMARxDesc_SAF) || \\ ((FLAG) == ETH_DMARxDesc_LE) || \\ ((FLAG) == ETH_DMARxDesc_OE) || \\ ((FLAG) == ETH_DMARxDesc_VLAN) || \\ ((FLAG) == ETH_DMARxDesc_FS) || \\ ((FLAG) == ETH_DMARxDesc_LS) || \\ ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \\ ((FLAG) == ETH_DMARxDesc_LC) || \\ ((FLAG) == ETH_DMARxDesc_FT) || \\ ((FLAG) == ETH_DMARxDesc_RWT) || \\ ((FLAG) == ETH_DMARxDesc_RE) || \\ ((FLAG) == ETH_DMARxDesc_DBE) || \\ ((FLAG) == ETH_DMARxDesc_CE) || \\ ((FLAG) == ETH_DMARxDesc_MAMPCE)) /** * @} */ /** @defgroup ETH_DMA_Rx_descriptor_buffers_ * @{ */ #define ETH_DMARxDesc_Buffer1 ((uint32_t)0x00000000) /*!&lt; DMA Rx Desc Buffer1 */ #define ETH_DMARxDesc_Buffer2 ((uint32_t)0x00000001) /*!&lt; DMA Rx Desc Buffer2 */ #define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \\ ((BUFFER) == ETH_DMARxDesc_Buffer2)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet DMA defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame * @{ */ #define ETH_DropTCPIPChecksumErrorFrame_Enable ((uint32_t)0x00000000) #define ETH_DropTCPIPChecksumErrorFrame_Disable ((uint32_t)0x04000000) #define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \\ ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable)) /** * @} */ /** @defgroup ETH_Receive_Store_Forward * @{ */ #define ETH_ReceiveStoreForward_Enable ((uint32_t)0x02000000) #define ETH_ReceiveStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \\ ((CMD) == ETH_ReceiveStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Flush_Received_Frame * @{ */ #define ETH_FlushReceivedFrame_Enable ((uint32_t)0x00000000) #define ETH_FlushReceivedFrame_Disable ((uint32_t)0x01000000) #define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \\ ((CMD) == ETH_FlushReceivedFrame_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Store_Forward * @{ */ #define ETH_TransmitStoreForward_Enable ((uint32_t)0x00200000) #define ETH_TransmitStoreForward_Disable ((uint32_t)0x00000000) #define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \\ ((CMD) == ETH_TransmitStoreForward_Disable)) /** * @} */ /** @defgroup ETH_Transmit_Threshold_Control * @{ */ #define ETH_TransmitThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Transmit FIFO is 64 Bytes */ #define ETH_TransmitThresholdControl_128Bytes ((uint32_t)0x00004000) /*!&lt; threshold level of the MTL Transmit FIFO is 128 Bytes */ #define ETH_TransmitThresholdControl_192Bytes ((uint32_t)0x00008000) /*!&lt; threshold level of the MTL Transmit FIFO is 192 Bytes */ #define ETH_TransmitThresholdControl_256Bytes ((uint32_t)0x0000C000) /*!&lt; threshold level of the MTL Transmit FIFO is 256 Bytes */ #define ETH_TransmitThresholdControl_40Bytes ((uint32_t)0x00010000) /*!&lt; threshold level of the MTL Transmit FIFO is 40 Bytes */ #define ETH_TransmitThresholdControl_32Bytes ((uint32_t)0x00014000) /*!&lt; threshold level of the MTL Transmit FIFO is 32 Bytes */ #define ETH_TransmitThresholdControl_24Bytes ((uint32_t)0x00018000) /*!&lt; threshold level of the MTL Transmit FIFO is 24 Bytes */ #define ETH_TransmitThresholdControl_16Bytes ((uint32_t)0x0001C000) /*!&lt; threshold level of the MTL Transmit FIFO is 16 Bytes */ #define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \\ ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes)) /** * @} */ /** @defgroup ETH_Forward_Error_Frames * @{ */ #define ETH_ForwardErrorFrames_Enable ((uint32_t)0x00000080) #define ETH_ForwardErrorFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \\ ((CMD) == ETH_ForwardErrorFrames_Disable)) /** * @} */ /** @defgroup ETH_Forward_Undersized_Good_Frames * @{ */ #define ETH_ForwardUndersizedGoodFrames_Enable ((uint32_t)0x00000040) #define ETH_ForwardUndersizedGoodFrames_Disable ((uint32_t)0x00000000) #define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \\ ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable)) /** * @} */ /** @defgroup ETH_Receive_Threshold_Control * @{ */ #define ETH_ReceiveThresholdControl_64Bytes ((uint32_t)0x00000000) /*!&lt; threshold level of the MTL Receive FIFO is 64 Bytes */ #define ETH_ReceiveThresholdControl_32Bytes ((uint32_t)0x00000008) /*!&lt; threshold level of the MTL Receive FIFO is 32 Bytes */ #define ETH_ReceiveThresholdControl_96Bytes ((uint32_t)0x00000010) /*!&lt; threshold level of the MTL Receive FIFO is 96 Bytes */ #define ETH_ReceiveThresholdControl_128Bytes ((uint32_t)0x00000018) /*!&lt; threshold level of the MTL Receive FIFO is 128 Bytes */ #define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \\ ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \\ ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \\ ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes)) /** * @} */ /** @defgroup ETH_Second_Frame_Operate * @{ */ #define ETH_SecondFrameOperate_Enable ((uint32_t)0x00000004) #define ETH_SecondFrameOperate_Disable ((uint32_t)0x00000000) #define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \\ ((CMD) == ETH_SecondFrameOperate_Disable)) /** * @} */ /** @defgroup ETH_Address_Aligned_Beats * @{ */ #define ETH_AddressAlignedBeats_Enable ((uint32_t)0x02000000) #define ETH_AddressAlignedBeats_Disable ((uint32_t)0x00000000) #define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \\ ((CMD) == ETH_AddressAlignedBeats_Disable)) /** * @} */ /** @defgroup ETH_Fixed_Burst * @{ */ #define ETH_FixedBurst_Enable ((uint32_t)0x00010000) #define ETH_FixedBurst_Disable ((uint32_t)0x00000000) #define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \\ ((CMD) == ETH_FixedBurst_Disable)) /** * @} */ /** @defgroup ETH_Rx_DMA_Burst_Length * @{ */ #define ETH_RxDMABurstLength_1Beat ((uint32_t)0x00020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 1 */ #define ETH_RxDMABurstLength_2Beat ((uint32_t)0x00040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 2 */ #define ETH_RxDMABurstLength_4Beat ((uint32_t)0x00080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_8Beat ((uint32_t)0x00100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_16Beat ((uint32_t)0x00200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_32Beat ((uint32_t)0x00400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01020000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */ #define ETH_RxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01040000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */ #define ETH_RxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01080000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */ #define ETH_RxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01100000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */ #define ETH_RxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01200000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 64 */ #define ETH_RxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01400000) /*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 128 */ #define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \\ ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat)) /** * @} */ /** @defgroup ETH_Tx_DMA_Burst_Length * @{ */ #define ETH_TxDMABurstLength_1Beat ((uint32_t)0x00000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */ #define ETH_TxDMABurstLength_2Beat ((uint32_t)0x00000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */ #define ETH_TxDMABurstLength_4Beat ((uint32_t)0x00000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_8Beat ((uint32_t)0x00000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_16Beat ((uint32_t)0x00001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_32Beat ((uint32_t)0x00002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_4Beat ((uint32_t)0x01000100) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */ #define ETH_TxDMABurstLength_4xPBL_8Beat ((uint32_t)0x01000200) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */ #define ETH_TxDMABurstLength_4xPBL_16Beat ((uint32_t)0x01000400) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */ #define ETH_TxDMABurstLength_4xPBL_32Beat ((uint32_t)0x01000800) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */ #define ETH_TxDMABurstLength_4xPBL_64Beat ((uint32_t)0x01001000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */ #define ETH_TxDMABurstLength_4xPBL_128Beat ((uint32_t)0x01002000) /*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */ #define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \\ ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat)) /** * @brief ETH DMA Desciptor SkipLength */ #define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) &lt;= 0x1F) /** * @} */ /** @defgroup ETH_DMA_Arbitration * @{ */ #define ETH_DMAArbitration_RoundRobin_RxTx_1_1 ((uint32_t)0x00000000) #define ETH_DMAArbitration_RoundRobin_RxTx_2_1 ((uint32_t)0x00004000) #define ETH_DMAArbitration_RoundRobin_RxTx_3_1 ((uint32_t)0x00008000) #define ETH_DMAArbitration_RoundRobin_RxTx_4_1 ((uint32_t)0x0000C000) #define ETH_DMAArbitration_RxPriorTx ((uint32_t)0x00000002) #define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \\ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \\ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \\ ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \\ ((RATIO) == ETH_DMAArbitration_RxPriorTx)) /** * @} */ /** @defgroup ETH_DMA_Flags * @{ */ #define ETH_DMA_FLAG_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_FLAG_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_FLAG_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_FLAG_DataTransferError ((uint32_t)0x00800000) /*!&lt; Error bits 0-Rx DMA, 1-Tx DMA */ #define ETH_DMA_FLAG_ReadWriteError ((uint32_t)0x01000000) /*!&lt; Error bits 0-write trnsf, 1-read transfr */ #define ETH_DMA_FLAG_AccessError ((uint32_t)0x02000000) /*!&lt; Error bits 0-data buffer, 1-desc. access */ #define ETH_DMA_FLAG_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary flag */ #define ETH_DMA_FLAG_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary flag */ #define ETH_DMA_FLAG_ER ((uint32_t)0x00004000) /*!&lt; Early receive flag */ #define ETH_DMA_FLAG_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error flag */ #define ETH_DMA_FLAG_ET ((uint32_t)0x00000400) /*!&lt; Early transmit flag */ #define ETH_DMA_FLAG_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout flag */ #define ETH_DMA_FLAG_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped flag */ #define ETH_DMA_FLAG_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable flag */ #define ETH_DMA_FLAG_R ((uint32_t)0x00000040) /*!&lt; Receive flag */ #define ETH_DMA_FLAG_TU ((uint32_t)0x00000020) /*!&lt; Underflow flag */ #define ETH_DMA_FLAG_RO ((uint32_t)0x00000010) /*!&lt; Overflow flag */ #define ETH_DMA_FLAG_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout flag */ #define ETH_DMA_FLAG_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable flag */ #define ETH_DMA_FLAG_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped flag */ #define ETH_DMA_FLAG_T ((uint32_t)0x00000001) /*!&lt; Transmit flag */ #define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((FLAG) != 0x00)) #define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \\ ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \\ ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \\ ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \\ ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \\ ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \\ ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \\ ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \\ ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \\ ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \\ ((FLAG) == ETH_DMA_FLAG_T)) /** * @} */ /** @defgroup ETH_DMA_Interrupts * @{ */ #define ETH_DMA_IT_TST ((uint32_t)0x20000000) /*!&lt; Time-stamp trigger interrupt (on DMA) */ #define ETH_DMA_IT_PMT ((uint32_t)0x10000000) /*!&lt; PMT interrupt (on DMA) */ #define ETH_DMA_IT_MMC ((uint32_t)0x08000000) /*!&lt; MMC interrupt (on DMA) */ #define ETH_DMA_IT_NIS ((uint32_t)0x00010000) /*!&lt; Normal interrupt summary */ #define ETH_DMA_IT_AIS ((uint32_t)0x00008000) /*!&lt; Abnormal interrupt summary */ #define ETH_DMA_IT_ER ((uint32_t)0x00004000) /*!&lt; Early receive interrupt */ #define ETH_DMA_IT_FBE ((uint32_t)0x00002000) /*!&lt; Fatal bus error interrupt */ #define ETH_DMA_IT_ET ((uint32_t)0x00000400) /*!&lt; Early transmit interrupt */ #define ETH_DMA_IT_RWT ((uint32_t)0x00000200) /*!&lt; Receive watchdog timeout interrupt */ #define ETH_DMA_IT_RPS ((uint32_t)0x00000100) /*!&lt; Receive process stopped interrupt */ #define ETH_DMA_IT_RBU ((uint32_t)0x00000080) /*!&lt; Receive buffer unavailable interrupt */ #define ETH_DMA_IT_R ((uint32_t)0x00000040) /*!&lt; Receive interrupt */ #define ETH_DMA_IT_TU ((uint32_t)0x00000020) /*!&lt; Underflow interrupt */ #define ETH_DMA_IT_RO ((uint32_t)0x00000010) /*!&lt; Overflow interrupt */ #define ETH_DMA_IT_TJT ((uint32_t)0x00000008) /*!&lt; Transmit jabber timeout interrupt */ #define ETH_DMA_IT_TBU ((uint32_t)0x00000004) /*!&lt; Transmit buffer unavailable interrupt */ #define ETH_DMA_IT_TPS ((uint32_t)0x00000002) /*!&lt; Transmit process stopped interrupt */ #define ETH_DMA_IT_T ((uint32_t)0x00000001) /*!&lt; Transmit interrupt */ #define IS_ETH_DMA_IT(IT) ((((IT) &amp; (uint32_t)0xFFFE1800) == 0x00) &amp;&amp; ((IT) != 0x00)) #define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \\ ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \\ ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \\ ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \\ ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \\ ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \\ ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \\ ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \\ ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T)) /** * @} */ /** @defgroup ETH_DMA_transmit_process_state_ * @{ */ #define ETH_DMA_TransmitProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Tx Command issued */ #define ETH_DMA_TransmitProcess_Fetching ((uint32_t)0x00100000) /*!&lt; Running - fetching the Tx descriptor */ #define ETH_DMA_TransmitProcess_Waiting ((uint32_t)0x00200000) /*!&lt; Running - waiting for status */ #define ETH_DMA_TransmitProcess_Reading ((uint32_t)0x00300000) /*!&lt; Running - reading the data from host memory */ #define ETH_DMA_TransmitProcess_Suspended ((uint32_t)0x00600000) /*!&lt; Suspended - Tx Desciptor unavailabe */ #define ETH_DMA_TransmitProcess_Closing ((uint32_t)0x00700000) /*!&lt; Running - closing Rx descriptor */ /** * @} */ /** @defgroup ETH_DMA_receive_process_state_ * @{ */ #define ETH_DMA_ReceiveProcess_Stopped ((uint32_t)0x00000000) /*!&lt; Stopped - Reset or Stop Rx Command issued */ #define ETH_DMA_ReceiveProcess_Fetching ((uint32_t)0x00020000) /*!&lt; Running - fetching the Rx descriptor */ #define ETH_DMA_ReceiveProcess_Waiting ((uint32_t)0x00060000) /*!&lt; Running - waiting for packet */ #define ETH_DMA_ReceiveProcess_Suspended ((uint32_t)0x00080000) /*!&lt; Suspended - Rx Desciptor unavailable */ #define ETH_DMA_ReceiveProcess_Closing ((uint32_t)0x000A0000) /*!&lt; Running - closing descriptor */ #define ETH_DMA_ReceiveProcess_Queuing ((uint32_t)0x000E0000) /*!&lt; Running - queuing the recieve frame into host memory */ /** * @} */ /** @defgroup ETH_DMA_overflow_ * @{ */ #define ETH_DMA_Overflow_RxFIFOCounter ((uint32_t)0x10000000) /*!&lt; Overflow bit for FIFO overflow counter */ #define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)0x00010000) /*!&lt; Overflow bit for missed frame counter */ #define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \\ ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PMT defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PMT_Flags * @{ */ #define ETH_PMT_FLAG_WUFFRPR ((uint32_t)0x80000000) /*!&lt; Wake-Up Frame Filter Register Poniter Reset */ #define ETH_PMT_FLAG_WUFR ((uint32_t)0x00000040) /*!&lt; Wake-Up Frame Received */ #define ETH_PMT_FLAG_MPR ((uint32_t)0x00000020) /*!&lt; Magic Packet Received */ #define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \\ ((FLAG) == ETH_PMT_FLAG_MPR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet MMC defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_MMC_Tx_Interrupts * @{ */ #define ETH_MMC_IT_TGF ((uint32_t)0x00200000) /*!&lt; When Tx good frame counter reaches half the maximum value */ #define ETH_MMC_IT_TGFMSC ((uint32_t)0x00008000) /*!&lt; When Tx good multi col counter reaches half the maximum value */ #define ETH_MMC_IT_TGFSC ((uint32_t)0x00004000) /*!&lt; When Tx good single col counter reaches half the maximum value */ /** * @} */ /** @defgroup ETH_MMC_Rx_Interrupts * @{ */ #define ETH_MMC_IT_RGUF ((uint32_t)0x10020000) /*!&lt; When Rx good unicast frames counter reaches half the maximum value */ #define ETH_MMC_IT_RFAE ((uint32_t)0x10000040) /*!&lt; When Rx alignment error counter reaches half the maximum value */ #define ETH_MMC_IT_RFCE ((uint32_t)0x10000020) /*!&lt; When Rx crc error counter reaches half the maximum value */ #define IS_ETH_MMC_IT(IT) (((((IT) &amp; (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) &amp; (uint32_t)0xEFFDFF9F) == 0x00)) &amp;&amp; \\ ((IT) != 0x00)) #define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \\ ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \\ ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE)) /** * @} */ /** @defgroup ETH_MMC_Registers * @{ */ #define ETH_MMCCR ((uint32_t)0x00000100) /*!&lt; MMC CR register */ #define ETH_MMCRIR ((uint32_t)0x00000104) /*!&lt; MMC RIR register */ #define ETH_MMCTIR ((uint32_t)0x00000108) /*!&lt; MMC TIR register */ #define ETH_MMCRIMR ((uint32_t)0x0000010C) /*!&lt; MMC RIMR register */ #define ETH_MMCTIMR ((uint32_t)0x00000110) /*!&lt; MMC TIMR register */ #define ETH_MMCTGFSCCR ((uint32_t)0x0000014C) /*!&lt; MMC TGFSCCR register */ #define ETH_MMCTGFMSCCR ((uint32_t)0x00000150) /*!&lt; MMC TGFMSCCR register */ #define ETH_MMCTGFCR ((uint32_t)0x00000168) /*!&lt; MMC TGFCR register */ #define ETH_MMCRFCECR ((uint32_t)0x00000194) /*!&lt; MMC RFCECR register */ #define ETH_MMCRFAECR ((uint32_t)0x00000198) /*!&lt; MMC RFAECR register */ #define ETH_MMCRGUFCR ((uint32_t)0x000001C4) /*!&lt; MMC RGUFCR register */ /** * @brief ETH MMC registers */ #define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR) || ((REG) == ETH_MMCRIR) || \\ ((REG) == ETH_MMCTIR) || ((REG) == ETH_MMCRIMR) || \\ ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \\ ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \\ ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \\ ((REG) == ETH_MMCRGUFCR)) /**--------------------------------------------------------------------------**/ /** * @brief Ethernet PTP defines */ /**--------------------------------------------------------------------------**/ /** * @} */ /** @defgroup ETH_PTP_time_update_method * @{ */ #define ETH_PTP_FineUpdate ((uint32_t)0x00000001) /*!&lt; Fine Update method */ #define ETH_PTP_CoarseUpdate ((uint32_t)0x00000000) /*!&lt; Coarse Update method */ #define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \\ ((UPDATE) == ETH_PTP_CoarseUpdate)) /** * @} */ /** @defgroup ETH_PTP_Flags * @{ */ #define ETH_PTP_FLAG_TSARU ((uint32_t)0x00000020) /*!&lt; Addend Register Update */ #define ETH_PTP_FLAG_TSITE ((uint32_t)0x00000010) /*!&lt; Time Stamp Interrupt Trigger */ #define ETH_PTP_FLAG_TSSTU ((uint32_t)0x00000008) /*!&lt; Time Stamp Update */ #define ETH_PTP_FLAG_TSSTI ((uint32_t)0x00000004) /*!&lt; Time Stamp Initialize */ #define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \\ ((FLAG) == ETH_PTP_FLAG_TSITE) || \\ ((FLAG) == ETH_PTP_FLAG_TSSTU) || \\ ((FLAG) == ETH_PTP_FLAG_TSSTI)) /** * @brief ETH PTP subsecond increment */ #define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) &lt;= 0xFF) /** * @} */ /** @defgroup ETH_PTP_time_sign * @{ */ #define ETH_PTP_PositiveTime ((uint32_t)0x00000000) /*!&lt; Positive time value */ #define ETH_PTP_NegativeTime ((uint32_t)0x80000000) /*!&lt; Negative time value */ #define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \\ ((SIGN) == ETH_PTP_NegativeTime)) /** * @brief ETH PTP time stamp low update */ #define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) &lt;= 0x7FFFFFFF) /** * @brief ETH PTP registers */ #define ETH_PTPTSCR ((uint32_t)0x00000700) /*!&lt; PTP TSCR register */ #define ETH_PTPSSIR ((uint32_t)0x00000704) /*!&lt; PTP SSIR register */ #define ETH_PTPTSHR ((uint32_t)0x00000708) /*!&lt; PTP TSHR register */ #define ETH_PTPTSLR ((uint32_t)0x0000070C) /*!&lt; PTP TSLR register */ #define ETH_PTPTSHUR ((uint32_t)0x00000710) /*!&lt; PTP TSHUR register */ #define ETH_PTPTSLUR ((uint32_t)0x00000714) /*!&lt; PTP TSLUR register */ #define ETH_PTPTSAR ((uint32_t)0x00000718) /*!&lt; PTP TSAR register */ #define ETH_PTPTTHR ((uint32_t)0x0000071C) /*!&lt; PTP TTHR register */ #define ETH_PTPTTLR ((uint32_t)0x00000720) /* PTP TTLR register */ #define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \\ ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \\ ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \\ ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \\ ((REG) == ETH_PTPTTLR)) /** * @} */ /** * @} */ /** @defgroup ETH_Exported_Macros * @{ */ /** * @} */ /** @defgroup ETH_Exported_Functions * @{ */ void ETH_DeInit(void); uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct); void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct); void ETH_SoftwareReset(void); FlagStatus ETH_GetSoftwareResetStatus(void); void ETH_Start(void); uint32_t ETH_HandleTxPkt(u8 *ppkt, u16 FrameLength); uint32_t ETH_HandleRxPkt(u8 *ppkt); uint32_t ETH_GetRxPktSize(void); void ETH_DropRxPkt(void); /** * @brief PHY */ u16 ETH_ReadPHYRegister(u16 PHYAddress, u16 PHYReg); uint32_t ETH_WritePHYRegister(u16 PHYAddress, u16 PHYReg, u16 PHYValue); uint32_t ETH_PHYLoopBackCmd(u16 PHYAddress, FunctionalState NewState); /** * @brief MAC */ void ETH_MACTransmissionCmd(FunctionalState NewState); void ETH_MACReceptionCmd(FunctionalState NewState); FlagStatus ETH_GetFlowControlBusyStatus(void); void ETH_InitiatePauseControlFrame(void); void ETH_BackPressureActivationCmd(FunctionalState NewState); FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG); ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT); void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState); void ETH_MACAddressConfig(uint32_t MacAddr, u8 *Addr); void ETH_GetMACAddress(uint32_t MacAddr, u8 *Addr); void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState); void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter); void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte); /** * @brief DMA Tx/Rx descriptors */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff, uint32_t TxBuffCount); void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff1, u8 *TxBuff2, uint32_t TxBuffCount); FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag); uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc); void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc); void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment); void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum); void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState); void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2); void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff1, u8 *RxBuff2, uint32_t RxBuffCount); FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag); void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc); uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc); void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState); uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer); /** * @brief DMA */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG); void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG); ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT); void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT); uint32_t ETH_GetTransmitProcessState(void); uint32_t ETH_GetReceiveProcessState(void); void ETH_FlushTransmitFIFO(void); FlagStatus ETH_GetFlushTransmitFIFOStatus(void); void ETH_DMATransmissionCmd(FunctionalState NewState); void ETH_DMAReceptionCmd(FunctionalState NewState); void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState); FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow); uint32_t ETH_GetRxOverflowMissedFrameCounter(void); uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void); uint32_t ETH_GetCurrentTxDescStartAddress(void); uint32_t ETH_GetCurrentRxDescStartAddress(void); uint32_t ETH_GetCurrentTxBufferAddress(void); uint32_t ETH_GetCurrentRxBufferAddress(void); void ETH_ResumeDMATransmission(void); void ETH_ResumeDMAReception(void); /** * @brief PMT */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void); void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer); void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState); FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG); void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState); void ETH_MagicPacketDetectionCmd(FunctionalState NewState); void ETH_PowerDownCmd(FunctionalState NewState); /** * @brief MMC */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState); void ETH_MMCResetOnReadCmd(FunctionalState NewState); void ETH_MMCCounterRolloverCmd(FunctionalState NewState); void ETH_MMCCountersReset(void); void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState); ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT); uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg); /** * @brief PTP */ uint32_t ETH_HandlePTPTxPkt(u8 *ppkt, u16 FrameLength, uint32_t *PTPTxTab); uint32_t ETH_HandlePTPRxPkt(u8 *ppkt, uint32_t *PTPRxTab); void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, u8* TxBuff, uint32_t TxBuffCount); void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, u8 *RxBuff, uint32_t RxBuffCount); void ETH_EnablePTPTimeStampAddend(void); void ETH_EnablePTPTimeStampInterruptTrigger(void); void ETH_EnablePTPTimeStampUpdate(void); void ETH_InitializePTPTimeStamp(void); void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod); void ETH_PTPTimeStampCmd(FunctionalState NewState); FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG); void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue); void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue); void ETH_SetPTPTimeStampAddend(uint32_t Value); void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue); uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg); #ifdef __cplusplus } #endif void FreeRTOS_Hardware_STMS32_ETH_Init(void); #endif /* __STM32_ETH_H */ /** * @} */ /** * @} */ /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/ stm32_eth.c /** ****************************************************************************** * @file stm32_eth.c * @author MCD Application Team * @version V1.1.0 * @date 11/20/2009 * @brief This file provides all the ETH firmware functions. ****************************************************************************** * @copy * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32_eth.h&quot; #include &quot;stm32f10x_rcc.h&quot; #define DP83848_PHY_ADDRESS 0x01 /* Relative to STM322xG-EVAL Board */ /* STM32F107 ETH dirver options */ #define CHECKSUM_BY_HARDWARE 1 /* 0: disable. 1: use hardware checksum. */ #define RMII_MODE 0 /* 0: MII MODE, 1: RMII MODE. */ #define STM32_ETH_IO_REMAP 1 /* 0: default, 1: remap RXD to PDx. */ #define USE_MCO 1 /* 0: disable, 1: PA8(MCO) out 25Mhz(MII) or 50Mhz(RMII). */ /** @addtogroup STM32_ETH_Driver * @brief ETH driver modules * @{ */ /** @defgroup ETH_Private_TypesDefinitions * @{ */ /** * @} */ /** @defgroup ETH_Private_Defines * @{ */ /* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */ ETH_DMADESCTypeDef *DMATxDescToSet; ETH_DMADESCTypeDef *DMARxDescToGet; ETH_DMADESCTypeDef *DMAPTPTxDescToSet; ETH_DMADESCTypeDef *DMAPTPRxDescToGet; /* ETHERNET MAC address offsets */ #define ETH_MAC_ADDR_HBASE (ETH_MAC_BASE + 0x40) /* ETHERNET MAC address high offset */ #define ETH_MAC_ADDR_LBASE (ETH_MAC_BASE + 0x44) /* ETHERNET MAC address low offset */ /* ETHERNET MACMIIAR register Mask */ #define MACMIIAR_CR_MASK ((uint32_t)0xFFFFFFE3) /* ETHERNET MACCR register Mask */ #define MACCR_CLEAR_MASK ((uint32_t)0xFF20810F) /* ETHERNET MACFCR register Mask */ #define MACFCR_CLEAR_MASK ((uint32_t)0x0000FF41) /* ETHERNET DMAOMR register Mask */ #define DMAOMR_CLEAR_MASK ((uint32_t)0xF8DE3F23) /* ETHERNET Remote Wake-up frame register length */ #define ETH_WAKEUP_REGISTER_LENGTH 8 /* ETHERNET Missed frames counter Shift */ #define ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT 17 /* ETHERNET DMA Tx descriptors Collision Count Shift */ #define ETH_DMATXDESC_COLLISION_COUNTSHIFT 3 /* ETHERNET DMA Tx descriptors Buffer2 Size Shift */ #define ETH_DMATXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET DMA Rx descriptors Frame Length Shift */ #define ETH_DMARXDESC_FRAME_LENGTHSHIFT 16 /* ETHERNET DMA Rx descriptors Buffer2 Size Shift */ #define ETH_DMARXDESC_BUFFER2_SIZESHIFT 16 /* ETHERNET errors */ #define ETH_ERROR ((uint32_t)0) #define ETH_SUCCESS ((uint32_t)1) /** * @} */ /** @defgroup ETH_Private_Macros * @{ */ /** * @} */ /** @defgroup ETH_Private_Variables * @{ */ /** * @} */ /** @defgroup ETH_Private_FunctionPrototypes * @{ */ /** * @} */ /** @defgroup ETH_Private_Functions * @{ */ /** * @brief Deinitializes the ETHERNET peripheral registers to their default reset values. * @param None * @retval None */ void ETH_DeInit(void) { RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE); RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE); } /** * @brief Initializes the ETHERNET peripheral according to the specified * parameters in the ETH_InitStruct . * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains * the configuration information for the specified ETHERNET peripheral. * @retval ETH_ERROR: Ethernet initialization failed * ETH_SUCCESS: Ethernet successfully initialized */ uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct) { uint32_t tmpreg = 0; __IO uint32_t i = 0; RCC_ClocksTypeDef rcc_clocks; uint32_t hclk = 60000000; __IO uint32_t timeout = 0; /* Check the parameters */ /* MAC --------------------------*/ assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct-&gt;ETH_AutoNegotiation)); assert_param(IS_ETH_WATCHDOG(ETH_InitStruct-&gt;ETH_Watchdog)); assert_param(IS_ETH_JABBER(ETH_InitStruct-&gt;ETH_Jabber)); assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct-&gt;ETH_InterFrameGap)); assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct-&gt;ETH_CarrierSense)); assert_param(IS_ETH_SPEED(ETH_InitStruct-&gt;ETH_Speed)); assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct-&gt;ETH_ReceiveOwn)); assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct-&gt;ETH_LoopbackMode)); assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct-&gt;ETH_Mode)); assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct-&gt;ETH_ChecksumOffload)); assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct-&gt;ETH_RetryTransmission)); assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip)); assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct-&gt;ETH_BackOffLimit)); assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct-&gt;ETH_DeferralCheck)); assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct-&gt;ETH_ReceiveAll)); assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct-&gt;ETH_SourceAddrFilter)); assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct-&gt;ETH_PassControlFrames)); assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct-&gt;ETH_BroadcastFramesReception)); assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct-&gt;ETH_DestinationAddrFilter)); assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct-&gt;ETH_PromiscuousMode)); assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_MulticastFramesFilter)); assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_UnicastFramesFilter)); assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct-&gt;ETH_PauseTime)); assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct-&gt;ETH_ZeroQuantaPause)); assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct-&gt;ETH_PauseLowThreshold)); assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect)); assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct-&gt;ETH_ReceiveFlowControl)); assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct-&gt;ETH_TransmitFlowControl)); assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct-&gt;ETH_VLANTagComparison)); assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct-&gt;ETH_VLANTagIdentifier)); /* DMA --------------------------*/ assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame)); assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct-&gt;ETH_ReceiveStoreForward)); assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct-&gt;ETH_FlushReceivedFrame)); assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct-&gt;ETH_TransmitStoreForward)); assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_TransmitThresholdControl)); assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct-&gt;ETH_ForwardErrorFrames)); assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames)); assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_ReceiveThresholdControl)); assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct-&gt;ETH_SecondFrameOperate)); assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct-&gt;ETH_AddressAlignedBeats)); assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct-&gt;ETH_FixedBurst)); assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_RxDMABurstLength)); assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_TxDMABurstLength)); assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct-&gt;ETH_DescriptorSkipLength)); assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct-&gt;ETH_DMAArbitration)); /*-------------------------------- MAC Config ------------------------------*/ /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/ /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Clear CSR Clock Range CR[2:0] bits */ tmpreg &amp;= MACMIIAR_CR_MASK; /* Get hclk frequency value */ RCC_GetClocksFreq(&amp;rcc_clocks); hclk = rcc_clocks.HCLK_Frequency; /* Set CR bits depending on hclk value */ if((hclk &gt;= 20000000)&amp;&amp;(hclk &lt; 35000000)) { /* CSR Clock Range between 20-35 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16; } else if((hclk &gt;= 35000000)&amp;&amp;(hclk &lt; 60000000)) { /* CSR Clock Range between 35-60 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26; } else /* ((hclk &gt;= 60000000)&amp;&amp;(hclk &lt;= 72000000)) */ { /* CSR Clock Range between 60-72 MHz */ tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42; } /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */ ETH-&gt;MACMIIAR = (uint32_t)tmpreg; /*------------------------ ETHERNET MACCR Configuration --------------------*/ /* Get the ETHERNET MACCR value */ tmpreg = ETH-&gt;MACCR; /* Clear WD, PCE, PS, TE and RE bits */ tmpreg &amp;= MACCR_CLEAR_MASK; /* Set the WD bit according to ETH_Watchdog value */ /* Set the JD: bit according to ETH_Jabber value */ /* Set the IFG bit according to ETH_InterFrameGap value */ /* Set the DCRS bit according to ETH_CarrierSense value */ /* Set the FES bit according to ETH_Speed value */ /* Set the DO bit according to ETH_ReceiveOwn value */ /* Set the LM bit according to ETH_LoopbackMode value */ /* Set the DM bit according to ETH_Mode value */ /* Set the IPC bit according to ETH_ChecksumOffload value */ /* Set the DR bit according to ETH_RetryTransmission value */ /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ /* Set the BL bit according to ETH_BackOffLimit value */ /* Set the DC bit according to ETH_DeferralCheck value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_Watchdog | ETH_InitStruct-&gt;ETH_Jabber | ETH_InitStruct-&gt;ETH_InterFrameGap | ETH_InitStruct-&gt;ETH_CarrierSense | ETH_InitStruct-&gt;ETH_Speed | ETH_InitStruct-&gt;ETH_ReceiveOwn | ETH_InitStruct-&gt;ETH_LoopbackMode | ETH_InitStruct-&gt;ETH_Mode | ETH_InitStruct-&gt;ETH_ChecksumOffload | ETH_InitStruct-&gt;ETH_RetryTransmission | ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip | ETH_InitStruct-&gt;ETH_BackOffLimit | ETH_InitStruct-&gt;ETH_DeferralCheck); /* Write to ETHERNET MACCR */ ETH-&gt;MACCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACFFR Configuration --------------------*/ /* Set the RA bit according to ETH_ReceiveAll value */ /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */ /* Set the PCF bit according to ETH_PassControlFrames value */ /* Set the DBF bit according to ETH_BroadcastFramesReception value */ /* Set the DAIF bit according to ETH_DestinationAddrFilter value */ /* Set the PR bit according to ETH_PromiscuousMode value */ /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */ /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */ /* Write to ETHERNET MACFFR */ ETH-&gt;MACFFR = (uint32_t)(ETH_InitStruct-&gt;ETH_ReceiveAll | ETH_InitStruct-&gt;ETH_SourceAddrFilter | ETH_InitStruct-&gt;ETH_PassControlFrames | ETH_InitStruct-&gt;ETH_BroadcastFramesReception | ETH_InitStruct-&gt;ETH_DestinationAddrFilter | ETH_InitStruct-&gt;ETH_PromiscuousMode | ETH_InitStruct-&gt;ETH_MulticastFramesFilter | ETH_InitStruct-&gt;ETH_UnicastFramesFilter); /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/ /* Write to ETHERNET MACHTHR */ ETH-&gt;MACHTHR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableHigh; /* Write to ETHERNET MACHTLR */ ETH-&gt;MACHTLR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableLow; /*----------------------- ETHERNET MACFCR Configuration --------------------*/ /* Get the ETHERNET MACFCR value */ tmpreg = ETH-&gt;MACFCR; /* Clear xx bits */ tmpreg &amp;= MACFCR_CLEAR_MASK; /* Set the PT bit according to ETH_PauseTime value */ /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */ /* Set the PLT bit according to ETH_PauseLowThreshold value */ /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */ /* Set the RFE bit according to ETH_ReceiveFlowControl value */ /* Set the TFE bit according to ETH_TransmitFlowControl value */ tmpreg |= (uint32_t)((ETH_InitStruct-&gt;ETH_PauseTime &lt;&lt; 16) | ETH_InitStruct-&gt;ETH_ZeroQuantaPause | ETH_InitStruct-&gt;ETH_PauseLowThreshold | ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect | ETH_InitStruct-&gt;ETH_ReceiveFlowControl | ETH_InitStruct-&gt;ETH_TransmitFlowControl); /* Write to ETHERNET MACFCR */ ETH-&gt;MACFCR = (uint32_t)tmpreg; /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/ /* Set the ETV bit according to ETH_VLANTagComparison value */ /* Set the VL bit according to ETH_VLANTagIdentifier value */ ETH-&gt;MACVLANTR = (uint32_t)(ETH_InitStruct-&gt;ETH_VLANTagComparison | ETH_InitStruct-&gt;ETH_VLANTagIdentifier); /*-------------------------------- DMA Config ------------------------------*/ /*----------------------- ETHERNET DMAOMR Configuration --------------------*/ /* Get the ETHERNET DMAOMR value */ tmpreg = ETH-&gt;DMAOMR; /* Clear xx bits */ tmpreg &amp;= DMAOMR_CLEAR_MASK; /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */ /* Set the RSF bit according to ETH_ReceiveStoreForward value */ /* Set the DFF bit according to ETH_FlushReceivedFrame value */ /* Set the TSF bit according to ETH_TransmitStoreForward value */ /* Set the TTC bit according to ETH_TransmitThresholdControl value */ /* Set the FEF bit according to ETH_ForwardErrorFrames value */ /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */ /* Set the RTC bit according to ETH_ReceiveThresholdControl value */ /* Set the OSF bit according to ETH_SecondFrameOperate value */ tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame | ETH_InitStruct-&gt;ETH_ReceiveStoreForward | ETH_InitStruct-&gt;ETH_FlushReceivedFrame | ETH_InitStruct-&gt;ETH_TransmitStoreForward | ETH_InitStruct-&gt;ETH_TransmitThresholdControl | ETH_InitStruct-&gt;ETH_ForwardErrorFrames | ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames | ETH_InitStruct-&gt;ETH_ReceiveThresholdControl | ETH_InitStruct-&gt;ETH_SecondFrameOperate); /* Write to ETHERNET DMAOMR */ ETH-&gt;DMAOMR = (uint32_t)tmpreg; /*----------------------- ETHERNET DMABMR Configuration --------------------*/ /* Set the AAL bit according to ETH_AddressAlignedBeats value */ /* Set the FB bit according to ETH_FixedBurst value */ /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */ /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */ /* Set the DSL bit according to ETH_DesciptorSkipLength value */ /* Set the PR and DA bits according to ETH_DMAArbitration value */ ETH-&gt;DMABMR = (uint32_t)(ETH_InitStruct-&gt;ETH_AddressAlignedBeats | ETH_InitStruct-&gt;ETH_FixedBurst | ETH_InitStruct-&gt;ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */ ETH_InitStruct-&gt;ETH_TxDMABurstLength | (ETH_InitStruct-&gt;ETH_DescriptorSkipLength &lt;&lt; 2) | ETH_InitStruct-&gt;ETH_DMAArbitration | ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */ /* Return Ethernet configuration success */ return ETH_SUCCESS; } /** * @brief Fills each ETH_InitStruct member with its default value. * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized. * @retval None */ void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct) { /* ETH_InitStruct members default value */ /*------------------------ MAC -----------------------------------*/ ETH_InitStruct-&gt;ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; ETH_InitStruct-&gt;ETH_Watchdog = ETH_Watchdog_Enable; ETH_InitStruct-&gt;ETH_Jabber = ETH_Jabber_Enable; ETH_InitStruct-&gt;ETH_InterFrameGap = ETH_InterFrameGap_96Bit; ETH_InitStruct-&gt;ETH_CarrierSense = ETH_CarrierSense_Enable; ETH_InitStruct-&gt;ETH_Speed = ETH_Speed_10M; ETH_InitStruct-&gt;ETH_ReceiveOwn = ETH_ReceiveOwn_Enable; ETH_InitStruct-&gt;ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStruct-&gt;ETH_Mode = ETH_Mode_HalfDuplex; ETH_InitStruct-&gt;ETH_ChecksumOffload = ETH_ChecksumOffload_Disable; ETH_InitStruct-&gt;ETH_RetryTransmission = ETH_RetryTransmission_Enable; ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStruct-&gt;ETH_BackOffLimit = ETH_BackOffLimit_10; ETH_InitStruct-&gt;ETH_DeferralCheck = ETH_DeferralCheck_Disable; ETH_InitStruct-&gt;ETH_ReceiveAll = ETH_ReceiveAll_Disable; ETH_InitStruct-&gt;ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable; ETH_InitStruct-&gt;ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; ETH_InitStruct-&gt;ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStruct-&gt;ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal; ETH_InitStruct-&gt;ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStruct-&gt;ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; ETH_InitStruct-&gt;ETH_HashTableHigh = 0x0; ETH_InitStruct-&gt;ETH_HashTableLow = 0x0; ETH_InitStruct-&gt;ETH_PauseTime = 0x0; ETH_InitStruct-&gt;ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable; ETH_InitStruct-&gt;ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4; ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable; ETH_InitStruct-&gt;ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable; ETH_InitStruct-&gt;ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable; ETH_InitStruct-&gt;ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit; ETH_InitStruct-&gt;ETH_VLANTagIdentifier = 0x0; /*------------------------ DMA -----------------------------------*/ ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; ETH_InitStruct-&gt;ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStruct-&gt;ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable; ETH_InitStruct-&gt;ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStruct-&gt;ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStruct-&gt;ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes; ETH_InitStruct-&gt;ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable; ETH_InitStruct-&gt;ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStruct-&gt;ETH_FixedBurst = ETH_FixedBurst_Disable; ETH_InitStruct-&gt;ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat; ETH_InitStruct-&gt;ETH_DescriptorSkipLength = 0x0; ETH_InitStruct-&gt;ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1; } /** * @brief Enables ENET MAC and DMA reception/transmission * @param None * @retval None */ void ETH_Start(void) { /* Enable transmit state machine of the MAC for transmission on the MII */ ETH_MACTransmissionCmd(ENABLE); /* Flush Transmit FIFO */ ETH_FlushTransmitFIFO(); /* Enable receive state machine of the MAC for reception from the MII */ ETH_MACReceptionCmd(ENABLE); /* Start DMA transmission */ ETH_DMATransmissionCmd(ENABLE); /* Start DMA reception */ ETH_DMAReceptionCmd(ENABLE); } /** * @brief Transmits a packet, from application buffer, pointed by ppkt. * @param ppkt: pointer to the application&#39;s packet buffer to transmit. * @param FrameLength: Tx Packet size. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength) { uint32_t offset = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMATxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt. * @param ppkt: pointer to the application packet receive buffer. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandleRxPkt(uint8_t *ppkt) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @brief Get the size of received the received packet. * @param None * @retval framelength: received packet size */ uint32_t ETH_GetRxPktSize(void) { uint32_t frameLength = 0; if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the size of the packet: including 4 bytes of the CRC */ frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet); } /* Return Frame Length */ return frameLength; } /** * @brief Drop a Received packet (too small packet, etc...) * @param None * @retval None */ void ETH_DropRxPkt(void) { /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN; /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read: this will be the first Rx descriptor in this case */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } } /*--------------------------------- PHY ------------------------------------*/ /** * @brief Read a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR: Tranceiver Basic Control Register * @arg PHY_BSR: Tranceiver Basic Status Register * @arg PHY_SR : Tranceiver Status Register * @arg More PHY register could be read depending on the used PHY * @retval ETH_ERROR: in case of timeout * MAC MIIDR register value: Data read from the selected PHY register (correct read ) */ uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII address register value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg &amp;= ~ETH_MACMIIAR_MW; /* Set the read mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_READ_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return (uint16_t)ETH_ERROR; } /* Return data register value */ return (uint16_t)(ETH-&gt;MACMIIDR); } /** * @brief Write to a PHY register * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * @arg PHY_BCR : Tranceiver Control Register * @arg More PHY register could be written depending on the used PHY * @param PHYValue: the value to write * @retval ETH_ERROR: in case of timeout * ETH_SUCCESS: for correct write */ uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue) { uint32_t tmpreg = 0; __IO uint32_t timeout = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_ETH_PHY_REG(PHYReg)); /* Get the ETHERNET MACMIIAR value */ tmpreg = ETH-&gt;MACMIIAR; /* Keep only the CSR Clock Range CR[2:0] bits value */ tmpreg &amp;= ~MACMIIAR_CR_MASK; /* Prepare the MII register address value */ tmpreg |=(((uint32_t)PHYAddress&lt;&lt;11) &amp; ETH_MACMIIAR_PA); /* Set the PHY device address */ tmpreg |=(((uint32_t)PHYReg&lt;&lt;6) &amp; ETH_MACMIIAR_MR); /* Set the PHY register address */ tmpreg |= ETH_MACMIIAR_MW; /* Set the write mode */ tmpreg |= ETH_MACMIIAR_MB; /* Set the MII Busy bit */ /* Give the value to the MII data register */ ETH-&gt;MACMIIDR = PHYValue; /* Write the result value into the MII Address register */ ETH-&gt;MACMIIAR = tmpreg; /* Check for the Busy flag */ do { timeout++; tmpreg = ETH-&gt;MACMIIAR; } while ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_WRITE_TO)); /* Return ERROR in case of timeout */ if(timeout == PHY_WRITE_TO) { return ETH_ERROR; } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Enables or disables the PHY loopBack mode. * @Note: Don&#39;t be confused with ETH_MACLoopBackCmd function which enables internal * loopback at MII level * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: * @param NewState: new state of the PHY loopBack mode. * This parameter can be: ENABLE or DISABLE. * @retval ETH_ERROR: in case of bad PHY configuration * ETH_SUCCESS: for correct PHY configuration */ uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState) { uint16_t tmpreg = 0; /* Check the parameters */ assert_param(IS_ETH_PHY_ADDRESS(PHYAddress)); assert_param(IS_FUNCTIONAL_STATE(NewState)); /* Get the PHY configuration to update it */ tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); if (NewState != DISABLE) { /* Enable the PHY loopback mode */ tmpreg |= PHY_Loopback; } else { /* Disable the PHY loopback mode: normal mode */ tmpreg &amp;= (uint16_t)(~(uint16_t)PHY_Loopback); } /* Update the PHY control register with the new configuration */ if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET) { return ETH_SUCCESS; } else { /* Return SUCCESS */ return ETH_ERROR; } } /*--------------------------------- MAC ------------------------------------*/ /** * @brief Enables or disables the MAC transmission. * @param NewState: new state of the MAC transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACTransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC transmission */ ETH-&gt;MACCR |= ETH_MACCR_TE; } else { /* Disable the MAC transmission */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_TE; } } /** * @brief Enables or disables the MAC reception. * @param NewState: new state of the MAC reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC reception */ ETH-&gt;MACCR |= ETH_MACCR_RE; } else { /* Disable the MAC reception */ ETH-&gt;MACCR &amp;= ~ETH_MACCR_RE; } } /** * @brief Checks whether the ETHERNET flow control busy bit is set or not. * @param None * @retval The new state of flow control busy status bit (SET or RESET). */ FlagStatus ETH_GetFlowControlBusyStatus(void) { FlagStatus bitstatus = RESET; /* The Flow Control register should not be written to until this bit is cleared */ if ((ETH-&gt;MACFCR &amp; ETH_MACFCR_FCBBPA) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Initiate a Pause Control Frame (Full-duplex only). * @param None * @retval None */ void ETH_InitiatePauseControlFrame(void) { /* When Set In full duplex MAC initiates pause control frame */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } /** * @brief Enables or disables the MAC BackPressure operation activation (Half-duplex only). * @param NewState: new state of the MAC BackPressure operation activation. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_BackPressureActivationCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Activate the MAC BackPressure operation */ /* In Half duplex: during backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision */ ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA; } else { /* Desactivate the MAC BackPressure operation */ ETH-&gt;MACFCR &amp;= ~ETH_MACFCR_FCBBPA; } } /** * @brief Checks whether the specified ETHERNET MAC flag is set or not. * @param ETH_MAC_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_MAC_FLAG_TST : Time stamp trigger flag * @arg ETH_MAC_FLAG_MMCT : MMC transmit flag * @arg ETH_MAC_FLAG_MMCR : MMC receive flag * @arg ETH_MAC_FLAG_MMC : MMC flag * @arg ETH_MAC_FLAG_PMT : PMT flag * @retval The new state of ETHERNET MAC flag (SET or RESET). */ FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); if ((ETH-&gt;MACSR &amp; ETH_MAC_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET MAC interrupt has occurred or not. * @param ETH_MAC_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_MMCT : MMC transmit interrupt * @arg ETH_MAC_IT_MMCR : MMC receive interrupt * @arg ETH_MAC_IT_MMC : MMC interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @retval The new state of ETHERNET MAC interrupt (SET or RESET). */ ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); if ((ETH-&gt;MACSR &amp; ETH_MAC_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the specified ETHERNET MAC interrupts. * @param ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_MAC_IT_TST : Time stamp trigger interrupt * @arg ETH_MAC_IT_PMT : PMT interrupt * @param NewState: new state of the specified ETHERNET MAC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_IT(ETH_MAC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR &amp;= (~(uint32_t)ETH_MAC_IT); } else { /* Disable the selected ETHERNET MAC interrupts */ ETH-&gt;MACIMR |= ETH_MAC_IT; } } /** * @brief Configures the selected MAC address. * @param MacAddr: The MAC addres to configure. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Calculate the selectecd MAC address high register */ tmpreg = ((uint32_t)Addr[5] &lt;&lt; 8) | (uint32_t)Addr[4]; /* Load the selectecd MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg; /* Calculate the selectecd MAC address low register */ tmpreg = ((uint32_t)Addr[3] &lt;&lt; 24) | ((uint32_t)Addr[2] &lt;&lt; 16) | ((uint32_t)Addr[1] &lt;&lt; 8) | Addr[0]; /* Load the selectecd MAC address low register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg; } /** * @brief Get the selected MAC address. * @param MacAddr: The MAC addres to return. * This parameter can be one of the following values: * @arg ETH_MAC_Address0 : MAC Address0 * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Addr: Pointer on MAC address buffer data (6 bytes). * @retval None */ void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr) { uint32_t tmpreg; /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr)); /* Get the selectecd MAC address high register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[5] = ((tmpreg &gt;&gt; 8) &amp; (uint8_t)0xFF); Addr[4] = (tmpreg &amp; (uint8_t)0xFF); /* Load the selectecd MAC address low register */ tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)); /* Calculate the selectecd MAC address buffer */ Addr[3] = ((tmpreg &gt;&gt; 24) &amp; (uint8_t)0xFF); Addr[2] = ((tmpreg &gt;&gt; 16) &amp; (uint8_t)0xFF); Addr[1] = ((tmpreg &gt;&gt; 8 ) &amp; (uint8_t)0xFF); Addr[0] = (tmpreg &amp; (uint8_t)0xFF); } /** * @brief Enables or disables the Address filter module uses the specified * ETHERNET MAC address for perfect filtering * @param MacAddr: specifies the ETHERNET MAC address to be used for prfect filtering. * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param NewState: new state of the specified ETHERNET MAC address use. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE; } else { /* Disable the selected ETHERNET MAC address for perfect filtering */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_AE); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param Filter: specifies the used frame received field for comparaison * This parameter can be one of the following values: * @arg ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the * SA fields of the received frame. * @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the * DA fields of the received frame. * @retval None */ void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter)); if (Filter != ETH_MAC_AddressFilter_DA) { /* The selected ETHERNET MAC address is used to compare with the SA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA; } else { /* The selected ETHERNET MAC address is used to compare with the DA fields of the received frame. */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_SA); } } /** * @brief Set the filter type for the specified ETHERNET MAC address * @param MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * @arg ETH_MAC_Address1 : MAC Address1 * @arg ETH_MAC_Address2 : MAC Address2 * @arg ETH_MAC_Address3 : MAC Address3 * @param MaskByte: specifies the used address bytes for comparaison * This parameter can be any combination of the following values: * @arg ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0]. * @arg ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24]. * @arg ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16]. * @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8]. * @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0]. * @retval None */ void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte) { /* Check the parameters */ assert_param(IS_ETH_MAC_ADDRESS123(MacAddr)); assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte)); /* Clear MBC bits in the selected MAC address high register */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_MBC); /* Set the selected Filetr mask bytes */ (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte; } /*------------------------ DMA Tx/Rx Desciptors -----------------------------*/ /** * @brief Initializes the DMA Tx descriptors in chain mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Second Address Chained bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Tx descriptors in ring mode. * @param DMATxDescTab: Pointer on the first Tx desc list * @param TxBuff1: Pointer on the first TxBuffer1 list * @param TxBuff2: Pointer on the first TxBuffer2 list * @param TxBuffCount: Number of the used Tx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab + i; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;TxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (TxBuffCount-1)) { /* Set Transmit End of Ring bit */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TER; } } /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Checks whether the specified ETHERNET DMA Tx Desc flag is set or not. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param ETH_DMATxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine * @arg ETH_DMATxDesc_IC : Interrupt on completetion * @arg ETH_DMATxDesc_LS : Last Segment * @arg ETH_DMATxDesc_FS : First Segment * @arg ETH_DMATxDesc_DC : Disable CRC * @arg ETH_DMATxDesc_DP : Disable Pad * @arg ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable * @arg ETH_DMATxDesc_TER : Transmit End of Ring * @arg ETH_DMATxDesc_TCH : Second Address Chained * @arg ETH_DMATxDesc_TTSS: Tx Time Stamp Status * @arg ETH_DMATxDesc_IHE : IP Header Error * @arg ETH_DMATxDesc_ES : Error summary * @arg ETH_DMATxDesc_JT : Jabber Timeout * @arg ETH_DMATxDesc_FF : Frame Flushed: DMA/MTL flushed the frame due to SW flush * @arg ETH_DMATxDesc_PCE : Payload Checksum Error * @arg ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during tramsmission * @arg ETH_DMATxDesc_NC : No Carrier: no carrier signal from the tranceiver * @arg ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision * @arg ETH_DMATxDesc_EC : Excessive Collision: transmission aborted after 16 collisions * @arg ETH_DMATxDesc_VF : VLAN Frame * @arg ETH_DMATxDesc_CC : Collision Count * @arg ETH_DMATxDesc_ED : Excessive Deferral * @arg ETH_DMATxDesc_UF : Underflow Error: late data arrival from the memory * @arg ETH_DMATxDesc_DB : Deferred Bit * @retval The new state of ETH_DMATxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag)); if ((DMATxDesc-&gt;Status &amp; ETH_DMATxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Returns the specified ETHERNET DMA Tx Desc collision count. * @param DMATxDesc: pointer on a DMA Tx descriptor * @retval The Transmit descriptor collision counter value. */ uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc) { /* Return the Receive descriptor frame length */ return ((DMATxDesc-&gt;Status &amp; ETH_DMATxDesc_CC) &gt;&gt; ETH_DMATXDESC_COLLISION_COUNTSHIFT); } /** * @brief Set the specified DMA Tx Desc Own bit. * @param DMATxDesc: Pointer on a Tx desc * @retval None */ void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc) { /* Set the DMA Tx Desc Own bit */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_OWN; } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param NewState: new state of the DMA Tx Desc transmit interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_IC; } else { /* Disable the DMA Tx Desc Transmit interrupt */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_IC); } } /** * @brief Enables or disables the specified DMA Tx Desc Transmit interrupt. * @param DMATxDesc: Pointer on a Tx desc * @param DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_LastSegment : actual Tx desc contain last segment * @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment * @retval None */ void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment)); /* Selects the DMA Tx Desc Frame segment */ DMATxDesc-&gt;Status |= DMATxDesc_FrameSegment; } /** * @brief Selects the specified ETHERNET DMA Tx Desc Checksum Insertion. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion. * This parameter can be one of the following values: * @arg ETH_DMATxDesc_ChecksumByPass : Checksum bypass * @arg ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present * @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header * @retval None */ void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum) { /* Check the parameters */ assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum)); /* Set the selected DMA Tx desc checksum insertion control */ DMATxDesc-&gt;Status |= DMATxDesc_Checksum; } /** * @brief Enables or disables the DMA Tx Desc CRC. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc CRC. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DC); } else { /* Disable the selected DMA Tx Desc CRC */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DC; } } /** * @brief Enables or disables the DMA Tx Desc end of ring. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TER; } else { /* Disable the selected DMA Tx Desc end of ring */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_TER); } } /** * @brief Enables or disables the DMA Tx Desc second address chained. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TCH; } else { /* Disable the selected DMA Tx Desc second address chained */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TCH); } } /** * @brief Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */ DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DP); } else { /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/ DMATxDesc-&gt;Status |= ETH_DMATxDesc_DP; } } /** * @brief Enables or disables the DMA Tx Desc time stamp. * @param DMATxDesc: pointer on a DMA Tx descriptor * @param NewState: new state of the specified DMA Tx Desc time stamp. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status |= ETH_DMATxDesc_TTSE; } else { /* Disable the selected DMA Tx Desc time stamp */ DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TTSE); } } /** * @brief Configures the specified DMA Tx Desc buffer1 and buffer2 sizes. * @param DMATxDesc: Pointer on a Tx desc * @param BufferSize1: specifies the Tx desc buffer1 size. * @param BufferSize2: specifies the Tx desc buffer2 size (put &quot;0&quot; if not used). * @retval None */ void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2) { /* Check the parameters */ assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1)); assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2)); /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */ DMATxDesc-&gt;ControlBufferSize |= (BufferSize1 | (BufferSize2 &lt;&lt; ETH_DMATXDESC_BUFFER2_SIZESHIFT)); } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Initializes the DMA Rx descriptors in ring mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param RxBuff1: Pointer on the first RxBuffer1 list * @param RxBuff2: Pointer on the first RxBuffer2 list * @param RxBuffCount: Number of the used Rx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. * @retval None */ void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size */ DMARxDesc-&gt;ControlBufferSize = ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff1[i*ETH_MAX_PACKET_SIZE]); /* Set Buffer2 address pointer */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;RxBuff2[i*ETH_MAX_PACKET_SIZE]); /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */ if(i == (RxBuffCount-1)) { /* Set Receive End of Ring bit */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } } /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Checks whether the specified ETHERNET Rx Desc flag is set or not. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param ETH_DMARxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMARxDesc_OWN: OWN bit: descriptor is owned by DMA engine * @arg ETH_DMARxDesc_AFM: DA Filter Fail for the rx frame * @arg ETH_DMARxDesc_ES: Error summary * @arg ETH_DMARxDesc_DE: Desciptor error: no more descriptors for receive frame * @arg ETH_DMARxDesc_SAF: SA Filter Fail for the received frame * @arg ETH_DMARxDesc_LE: Frame size not matching with length field * @arg ETH_DMARxDesc_OE: Overflow Error: Frame was damaged due to buffer overflow * @arg ETH_DMARxDesc_VLAN: VLAN Tag: received frame is a VLAN frame * @arg ETH_DMARxDesc_FS: First descriptor of the frame * @arg ETH_DMARxDesc_LS: Last descriptor of the frame * @arg ETH_DMARxDesc_IPV4HCE: IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error * @arg ETH_DMARxDesc_LC: Late collision occurred during reception * @arg ETH_DMARxDesc_FT: Frame type - Ethernet, otherwise 802.3 * @arg ETH_DMARxDesc_RWT: Receive Watchdog Timeout: watchdog timer expired during reception * @arg ETH_DMARxDesc_RE: Receive error: error reported by MII interface * @arg ETH_DMARxDesc_DE: Dribble bit error: frame contains non int multiple of 8 bits * @arg ETH_DMARxDesc_CE: CRC error * @arg ETH_DMARxDesc_MAMPCE: Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error * @retval The new state of ETH_DMARxDescFlag (SET or RESET). */ FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag)); if ((DMARxDesc-&gt;Status &amp; ETH_DMARxDescFlag) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Set the specified DMA Rx Desc Own bit. * @param DMARxDesc: Pointer on a Rx desc * @retval None */ void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc) { /* Set the DMA Rx Desc Own bit */ DMARxDesc-&gt;Status |= ETH_DMARxDesc_OWN; } /** * @brief Returns the specified DMA Rx Desc frame length. * @param DMARxDesc: pointer on a DMA Rx descriptor * @retval The Rx descriptor received frame length. */ uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc) { /* Return the Receive descriptor frame length */ return ((DMARxDesc-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT); } /** * @brief Enables or disables the specified DMA Rx Desc receive interrupt. * @param DMARxDesc: Pointer on a Rx desc * @param NewState: new state of the specified DMA Rx Desc interrupt. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_DIC); } else { /* Disable the DMA Rx Desc receive interrupt */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_DIC; } } /** * @brief Enables or disables the DMA Rx Desc end of ring. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc end of ring. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER; } else { /* Disable the selected DMA Rx Desc end of ring */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RER); } } /** * @brief Enables or disables the DMA Rx Desc second address chained. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param NewState: new state of the specified DMA Rx Desc second address chained. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RCH; } else { /* Disable the selected DMA Rx Desc second address chained */ DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RCH); } } /** * @brief Returns the specified ETHERNET DMA Rx Desc buffer size. * @param DMARxDesc: pointer on a DMA Rx descriptor * @param DMARxDesc_Buffer: specifies the DMA Rx Desc buffer. * This parameter can be any one of the following values: * @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1 * @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2 * @retval The Receive descriptor frame length. */ uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer) { /* Check the parameters */ assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer)); if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1) { /* Return the DMA Rx Desc buffer2 size */ return ((DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS2) &gt;&gt; ETH_DMARXDESC_BUFFER2_SIZESHIFT); } else { /* Return the DMA Rx Desc buffer1 size */ return (DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS1); } } /*--------------------------------- DMA ------------------------------------*/ /** * @brief Resets all MAC subsystem internal registers and logic. * @param None * @retval None */ void ETH_SoftwareReset(void) { /* Set the SWR bit: resets all MAC subsystem internal registers and logic */ /* After reset all the registers holds their respective reset values */ ETH-&gt;DMABMR |= ETH_DMABMR_SR; } /** * @brief Checks whether the ETHERNET software reset bit is set or not. * @param None * @retval The new state of DMA Bus Mode register SR bit (SET or RESET). */ FlagStatus ETH_GetSoftwareResetStatus(void) { FlagStatus bitstatus = RESET; if((ETH-&gt;DMABMR &amp; ETH_DMABMR_SR) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Checks whether the specified ETHERNET DMA flag is set or not. * @param ETH_DMA_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_FLAG_TST : Time-stamp trigger flag * @arg ETH_DMA_FLAG_PMT : PMT flag * @arg ETH_DMA_FLAG_MMC : MMC flag * @arg ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access * @arg ETH_DMA_FLAG_ReadWriteError : Error bits 0-write trnsf, 1-read transfr * @arg ETH_DMA_FLAG_AccessError : Error bits 0-Rx DMA, 1-Tx DMA * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ET : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Underflow flag * @arg ETH_DMA_FLAG_RO : Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval The new state of ETH_DMA_FLAG (SET or RESET). */ FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG)); if ((ETH-&gt;DMASR &amp; ETH_DMA_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA pending flag. * @param ETH_DMA_FLAG: specifies the flag to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag * @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * @arg ETH_DMA_FLAG_ER : Early receive flag * @arg ETH_DMA_FLAG_FBE : Fatal bus error flag * @arg ETH_DMA_FLAG_ETI : Early transmit flag * @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * @arg ETH_DMA_FLAG_RPS : Receive process stopped flag * @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * @arg ETH_DMA_FLAG_R : Receive flag * @arg ETH_DMA_FLAG_TU : Transmit Underflow flag * @arg ETH_DMA_FLAG_RO : Receive Overflow flag * @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag * @arg ETH_DMA_FLAG_T : Transmit flag * @retval None */ void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG) { /* Check the parameters */ assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG)); /* Clear the selected ETHERNET DMA FLAG */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_FLAG; } /** * @brief Checks whether the specified ETHERNET DMA interrupt has occured or not. * @param ETH_DMA_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * @arg ETH_DMA_IT_TST : Time-stamp trigger interrupt * @arg ETH_DMA_IT_PMT : PMT interrupt * @arg ETH_DMA_IT_MMC : MMC interrupt * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval The new state of ETH_DMA_IT (SET or RESET). */ ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT)); if ((ETH-&gt;DMASR &amp; ETH_DMA_IT) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Clears the ETHERNET&#39;s DMA IT pending bit. * @param ETH_DMA_IT: specifies the interrupt pending bit to clear. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ETI : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Transmit Underflow interrupt * @arg ETH_DMA_IT_RO : Receive Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @retval None */ void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); /* Clear the selected ETHERNET DMA IT */ ETH-&gt;DMASR = (uint32_t) ETH_DMA_IT; } /** * @brief Returns the ETHERNET DMA Transmit Process State. * @param None * @retval The new ETHERNET DMA Transmit Process State: * This can be one of the following values: * - ETH_DMA_TransmitProcess_Stopped : Stopped - Reset or Stop Tx Command issued * - ETH_DMA_TransmitProcess_Fetching : Running - fetching the Tx descriptor * - ETH_DMA_TransmitProcess_Waiting : Running - waiting for status * - ETH_DMA_TransmitProcess_Reading : unning - reading the data from host memory * - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe * - ETH_DMA_TransmitProcess_Closing : Running - closing Rx descriptor */ uint32_t ETH_GetTransmitProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_TS)); } /** * @brief Returns the ETHERNET DMA Receive Process State. * @param None * @retval The new ETHERNET DMA Receive Process State: * This can be one of the following values: * - ETH_DMA_ReceiveProcess_Stopped : Stopped - Reset or Stop Rx Command issued * - ETH_DMA_ReceiveProcess_Fetching : Running - fetching the Rx descriptor * - ETH_DMA_ReceiveProcess_Waiting : Running - waiting for packet * - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable * - ETH_DMA_ReceiveProcess_Closing : Running - closing descriptor * - ETH_DMA_ReceiveProcess_Queuing : Running - queuing the recieve frame into host memory */ uint32_t ETH_GetReceiveProcessState(void) { return ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_RS)); } /** * @brief Clears the ETHERNET transmit FIFO. * @param None * @retval None */ void ETH_FlushTransmitFIFO(void) { /* Set the Flush Transmit FIFO bit */ ETH-&gt;DMAOMR |= ETH_DMAOMR_FTF; } /** * @brief Checks whether the ETHERNET transmit FIFO bit is cleared or not. * @param None * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET). */ FlagStatus ETH_GetFlushTransmitFIFOStatus(void) { FlagStatus bitstatus = RESET; if ((ETH-&gt;DMAOMR &amp; ETH_DMAOMR_FTF) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the DMA transmission. * @param NewState: new state of the DMA transmission. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMATransmissionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA transmission */ ETH-&gt;DMAOMR |= ETH_DMAOMR_ST; } else { /* Disable the DMA transmission */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_ST; } } /** * @brief Enables or disables the DMA reception. * @param NewState: new state of the DMA reception. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAReceptionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the DMA reception */ ETH-&gt;DMAOMR |= ETH_DMAOMR_SR; } else { /* Disable the DMA reception */ ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_SR; } } /** * @brief Enables or disables the specified ETHERNET DMA interrupts. * @param ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * @arg ETH_DMA_IT_NIS : Normal interrupt summary * @arg ETH_DMA_IT_AIS : Abnormal interrupt summary * @arg ETH_DMA_IT_ER : Early receive interrupt * @arg ETH_DMA_IT_FBE : Fatal bus error interrupt * @arg ETH_DMA_IT_ET : Early transmit interrupt * @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * @arg ETH_DMA_IT_RPS : Receive process stopped interrupt * @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * @arg ETH_DMA_IT_R : Receive interrupt * @arg ETH_DMA_IT_TU : Underflow interrupt * @arg ETH_DMA_IT_RO : Overflow interrupt * @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt * @arg ETH_DMA_IT_T : Transmit interrupt * @param NewState: new state of the specified ETHERNET DMA interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_DMA_IT(ETH_DMA_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER |= ETH_DMA_IT; } else { /* Disable the selected ETHERNET DMA interrupts */ ETH-&gt;DMAIER &amp;=(~(uint32_t)ETH_DMA_IT); } } /** * @brief Checks whether the specified ETHERNET DMA overflow flag is set or not. * @param ETH_DMA_Overflow: specifies the DMA overflow flag to check. * This parameter can be one of the following values: * @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter * @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET). */ FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow)); if ((ETH-&gt;DMAMFBOCR &amp; ETH_DMA_Overflow) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Get the ETHERNET DMA Rx Overflow Missed Frame Counter value. * @param None * @retval The value of Rx overflow Missed Frame Counter. */ uint32_t ETH_GetRxOverflowMissedFrameCounter(void) { return ((uint32_t)((ETH-&gt;DMAMFBOCR &amp; ETH_DMAMFBOCR_MFA)&gt;&gt;ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT)); } /** * @brief Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value. * @param None * @retval The value of Buffer unavailable Missed Frame Counter. */ uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void) { return ((uint32_t)(ETH-&gt;DMAMFBOCR) &amp; ETH_DMAMFBOCR_MFC); } /** * @brief Get the ETHERNET DMA DMACHTDR register value. * @param None * @retval The value of the current Tx desc start address. */ uint32_t ETH_GetCurrentTxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTDR)); } /** * @brief Get the ETHERNET DMA DMACHRDR register value. * @param None * @retval The value of the current Rx desc start address. */ uint32_t ETH_GetCurrentRxDescStartAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRDR)); } /** * @brief Get the ETHERNET DMA DMACHTBAR register value. * @param None * @retval The value of the current Tx buffer address. */ uint32_t ETH_GetCurrentTxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHTBAR)); } /** * @brief Get the ETHERNET DMA DMACHRBAR register value. * @param None * @retval The value of the current Rx buffer address. */ uint32_t ETH_GetCurrentRxBufferAddress(void) { return ((uint32_t)(ETH-&gt;DMACHRBAR)); } /** * @brief Resumes the DMA Transmission by writing to the DmaTxPollDemand register * (the data written could be anything). This forces the DMA to resume transmission. * @param None * @retval None. */ void ETH_ResumeDMATransmission(void) { ETH-&gt;DMATPDR = 0; } /** * @brief Resumes the DMA Transmission by writing to the DmaRxPollDemand register * (the data written could be anything). This forces the DMA to resume reception. * @param None * @retval None. */ void ETH_ResumeDMAReception(void) { ETH-&gt;DMARPDR = 0; } /*--------------------------------- PMT ------------------------------------*/ /** * @brief Reset Wakeup frame filter register pointer. * @param None * @retval None */ void ETH_ResetWakeUpFrameFilterRegisterPointer(void) { /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFFRPR; } /** * @brief Populates the remote wakeup frame registers. * @param Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words). * @retval None */ void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer) { uint32_t i = 0; /* Fill Remote Wake-up Frame Filter register with Buffer data */ for(i =0; i&lt;ETH_WAKEUP_REGISTER_LENGTH; i++) { /* Write each time to the same register */ ETH-&gt;MACRWUFFR = Buffer[i]; } } /** * @brief Enables or disables any unicast packet filtered by the MAC address * recognition to be a wake-up frame. * @param NewState: new state of the MAC Global Unicast Wake-Up. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_GU; } else { /* Disable the MAC Global Unicast Wake-Up */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_GU; } } /** * @brief Checks whether the specified ETHERNET PMT flag is set or not. * @param ETH_PMT_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Poniter Reset * @arg ETH_PMT_FLAG_WUFR : Wake-Up Frame Received * @arg ETH_PMT_FLAG_MPR : Magic Packet Received * @retval The new state of ETHERNET PMT Flag (SET or RESET). */ FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG)); if ((ETH-&gt;MACPMTCSR &amp; ETH_PMT_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Enables or disables the MAC Wake-Up Frame Detection. * @param NewState: new state of the MAC Wake-Up Frame Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFE; } else { /* Disable the MAC Wake-Up Frame Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_WFE; } } /** * @brief Enables or disables the MAC Magic Packet Detection. * @param NewState: new state of the MAC Magic Packet Detection. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MagicPacketDetectionCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_MPE; } else { /* Disable the MAC Magic Packet Detection */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_MPE; } } /** * @brief Enables or disables the MAC Power Down. * @param NewState: new state of the MAC Power Down. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PowerDownCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MAC Power Down */ /* This puts the MAC in power down mode */ ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_PD; } else { /* Disable the MAC Power Down */ ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_PD; } } /*--------------------------------- MMC ------------------------------------*/ /** * @brief Enables or disables the MMC Counter Freeze. * @param NewState: new state of the MMC Counter Freeze. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterFreezeCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter Freeze */ ETH-&gt;MMCCR |= ETH_MMCCR_MCF; } else { /* Disable the MMC Counter Freeze */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_MCF; } } /** * @brief Enables or disables the MMC Reset On Read. * @param NewState: new state of the MMC Reset On Read. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCResetOnReadCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the MMC Counter reset on read */ ETH-&gt;MMCCR |= ETH_MMCCR_ROR; } else { /* Disable the MMC Counter reset on read */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_ROR; } } /** * @brief Enables or disables the MMC Counter Stop Rollover. * @param NewState: new state of the MMC Counter Stop Rollover. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCCounterRolloverCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Disable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_CSR; } else { /* Enable the MMC Counter Stop Rollover */ ETH-&gt;MMCCR |= ETH_MMCCR_CSR; } } /** * @brief Resets the MMC Counters. * @param None * @retval None */ void ETH_MMCCountersReset(void) { /* Resets the MMC Counters */ ETH-&gt;MMCCR |= ETH_MMCCR_CR; } /** * @brief Enables or disables the specified ETHERNET MMC interrupts. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. * This parameter can be any combination of Tx interrupt or * any combination of Rx interrupt (but not both)of the following values: * @arg ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value * @param NewState: new state of the specified ETHERNET MMC interrupts. * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ETH_MMC_IT(ETH_MMC_IT)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* Remove egister mak from IT */ ETH_MMC_IT &amp;= 0xEFFFFFFF; /* ETHERNET MMC Rx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCRIMR |= ETH_MMC_IT; } } else { /* ETHERNET MMC Tx interrupts selected */ if (NewState != DISABLE) { /* Enable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR &amp;=(~(uint32_t)ETH_MMC_IT); } else { /* Disable the selected ETHERNET MMC interrupts */ ETH-&gt;MMCTIMR |= ETH_MMC_IT; } } } /** * @brief Checks whether the specified ETHERNET MMC IT is set or not. * @param ETH_MMC_IT: specifies the ETHERNET MMC interrupt. * This parameter can be one of the following values: * @arg ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value * @arg ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value * @arg ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value * @arg ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value * @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value * @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value * @retval The value of ETHERNET MMC IT (SET or RESET). */ ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT) { ITStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); if ((ETH_MMC_IT &amp; (uint32_t)0x10000000) != (uint32_t)RESET) { /* ETHERNET MMC Rx interrupts selected */ /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCRIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } else { /* ETHERNET MMC Tx interrupts selected */ /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */ if ((((ETH-&gt;MMCTIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET)) { bitstatus = SET; } else { bitstatus = RESET; } } return bitstatus; } /** * @brief Get the specified ETHERNET MMC register value. * @param ETH_MMCReg: specifies the ETHERNET MMC register. * This parameter can be one of the following values: * @arg ETH_MMCCR : MMC CR register * @arg ETH_MMCRIR : MMC RIR register * @arg ETH_MMCTIR : MMC TIR register * @arg ETH_MMCRIMR : MMC RIMR register * @arg ETH_MMCTIMR : MMC TIMR register * @arg ETH_MMCTGFSCCR : MMC TGFSCCR register * @arg ETH_MMCTGFMSCCR: MMC TGFMSCCR register * @arg ETH_MMCTGFCR : MMC TGFCR register * @arg ETH_MMCRFCECR : MMC RFCECR register * @arg ETH_MMCRFAECR : MMC RFAECR register * @arg ETH_MMCRGUFCR : MMC RGUFCRregister * @retval The value of ETHERNET MMC Register value. */ uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg) { /* Check the parameters */ assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg)); } /*--------------------------------- PTP ------------------------------------*/ /** * @brief Updated the PTP block for fine correction with the Time Stamp Addend register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampAddend(void) { /* Enable the PTP block update with the Time Stamp Addend register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSARU; } /** * @brief Enable the PTP Time Stamp interrupt trigger * @param None * @retval None */ void ETH_EnablePTPTimeStampInterruptTrigger(void) { /* Enable the PTP target time interrupt */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSITE; } /** * @brief Updated the PTP system time with the Time Stamp Update register value. * @param None * @retval None */ void ETH_EnablePTPTimeStampUpdate(void) { /* Enable the PTP system time update with the Time Stamp Update register value */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTU; } /** * @brief Initialize the PTP Time Stamp * @param None * @retval None */ void ETH_InitializePTPTimeStamp(void) { /* Initialize the PTP Time Stamp */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTI; } /** * @brief Selects the PTP Update method * @param UpdateMethod: the PTP Update method * This parameter can be one of the following values: * @arg ETH_PTP_FineUpdate : Fine Update method * @arg ETH_PTP_CoarseUpdate : Coarse Update method * @retval None */ void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod) { /* Check the parameters */ assert_param(IS_ETH_PTP_UPDATE(UpdateMethod)); if (UpdateMethod != ETH_PTP_CoarseUpdate) { /* Enable the PTP Fine Update method */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSFCU; } else { /* Disable the PTP Coarse Update method */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSFCU); } } /** * @brief Enables or disables the PTP time stamp for transmit and receive frames. * @param NewState: new state of the PTP time stamp for transmit and receive frames * This parameter can be: ENABLE or DISABLE. * @retval None */ void ETH_PTPTimeStampCmd(FunctionalState NewState) { /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { /* Enable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSE; } else { /* Disable the PTP time stamp for transmit and receive frames */ ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSE); } } /** * @brief Checks whether the specified ETHERNET PTP flag is set or not. * @param ETH_PTP_FLAG: specifies the flag to check. * This parameter can be one of the following values: * @arg ETH_PTP_FLAG_TSARU : Addend Register Update * @arg ETH_PTP_FLAG_TSITE : Time Stamp Interrupt Trigger Enable * @arg ETH_PTP_FLAG_TSSTU : Time Stamp Update * @arg ETH_PTP_FLAG_TSSTI : Time Stamp Initialize * @retval The new state of ETHERNET PTP Flag (SET or RESET). */ FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG) { FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG)); if ((ETH-&gt;PTPTSCR &amp; ETH_PTP_FLAG) != (uint32_t)RESET) { bitstatus = SET; } else { bitstatus = RESET; } return bitstatus; } /** * @brief Sets the system time Sub-Second Increment value. * @param SubSecondValue: specifies the PTP Sub-Second Increment Register value. * @retval None */ void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue)); /* Set the PTP Sub-Second Increment Register */ ETH-&gt;PTPSSIR = SubSecondValue; } /** * @brief Sets the Time Stamp update sign and values. * @param Sign: specifies the PTP Time update value sign. * This parameter can be one of the following values: * @arg ETH_PTP_PositiveTime : positive time value. * @arg ETH_PTP_NegativeTime : negative time value. * @param SecondValue: specifies the PTP Time update second value. * @param SubSecondValue: specifies the PTP Time update sub-second value. * This parameter is a 31 bit value, bit32 correspond to the sign. * @retval None */ void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue) { /* Check the parameters */ assert_param(IS_ETH_PTP_TIME_SIGN(Sign)); assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); /* Set the PTP Time Update High Register */ ETH-&gt;PTPTSHUR = SecondValue; /* Set the PTP Time Update Low Register with sign */ ETH-&gt;PTPTSLUR = Sign | SubSecondValue; } /** * @brief Sets the Time Stamp Addend value. * @param Value: specifies the PTP Time Stamp Addend Register value. * @retval None */ void ETH_SetPTPTimeStampAddend(uint32_t Value) { /* Set the PTP Time Stamp Addend Register */ ETH-&gt;PTPTSAR = Value; } /** * @brief Sets the Target Time registers values. * @param HighValue: specifies the PTP Target Time High Register value. * @param LowValue: specifies the PTP Target Time Low Register value. * @retval None */ void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue) { /* Set the PTP Target Time High Register */ ETH-&gt;PTPTTHR = HighValue; /* Set the PTP Target Time Low Register */ ETH-&gt;PTPTTLR = LowValue; } /** * @brief Get the specified ETHERNET PTP register value. * @param ETH_PTPReg: specifies the ETHERNET PTP register. * This parameter can be one of the following values: * @arg ETH_PTPTSCR : Sub-Second Increment Register * @arg ETH_PTPSSIR : Sub-Second Increment Register * @arg ETH_PTPTSHR : Time Stamp High Register * @arg ETH_PTPTSLR : Time Stamp Low Register * @arg ETH_PTPTSHUR : Time Stamp High Update Register * @arg ETH_PTPTSLUR : Time Stamp Low Update Register * @arg ETH_PTPTSAR : Time Stamp Addend Register * @arg ETH_PTPTTHR : Target Time High Register * @arg ETH_PTPTTLR : Target Time Low Register * @retval The value of ETHERNET PTP Register value. */ uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg) { /* Check the parameters */ assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg)); /* Return the selected register value */ return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg)); } /** * @brief Initializes the DMA Tx descriptors in chain mode with PTP. * @param DMATxDescTab: Pointer on the first Tx desc list * @param DMAPTPTxDescTab: Pointer on the first PTP Tx desc list * @param TxBuff: Pointer on the first TxBuffer list * @param TxBuffCount: Number of the used Tx desc in the list * @retval None */ void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMATxDesc; /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */ DMATxDescToSet = DMATxDescTab; DMAPTPTxDescToSet = DMAPTPTxDescTab; /* Fill each DMATxDesc descriptor with the right values */ for(i=0; i &lt; TxBuffCount; i++) { /* Get the pointer on the ith member of the Tx Desc list */ DMATxDesc = DMATxDescTab+i; /* Set Second Address Chained bit and enable PTP */ DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE; /* Set Buffer1 address pointer */ DMATxDesc-&gt;Buffer1Addr =(uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (TxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab; } /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */ (&amp;DMAPTPTxDescTab[i])-&gt;Buffer1Addr = DMATxDesc-&gt;Buffer1Addr; (&amp;DMAPTPTxDescTab[i])-&gt;Buffer2NextDescAddr = DMATxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPTxDescTab desc status record the first list address */ (&amp;DMAPTPTxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPTxDescTab; /* Set Transmit Desciptor List Address Register */ ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab; } /** * @brief Initializes the DMA Rx descriptors in chain mode. * @param DMARxDescTab: Pointer on the first Rx desc list * @param DMAPTPRxDescTab: Pointer on the first PTP Rx desc list * @param RxBuff: Pointer on the first RxBuffer list * @param RxBuffCount: Number of the used Rx desc in the list * @retval None */ void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount) { uint32_t i = 0; ETH_DMADESCTypeDef *DMARxDesc; /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */ DMARxDescToGet = DMARxDescTab; DMAPTPRxDescToGet = DMAPTPRxDescTab; /* Fill each DMARxDesc descriptor with the right values */ for(i=0; i &lt; RxBuffCount; i++) { /* Get the pointer on the ith member of the Rx Desc list */ DMARxDesc = DMARxDescTab+i; /* Set Own bit of the Rx descriptor Status */ DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN; /* Set Buffer1 size and Second Address Chained bit */ DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE; /* Set Buffer1 address pointer */ DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]); /* Initialize the next descriptor with the Next Desciptor Polling Enable */ if(i &lt; (RxBuffCount-1)) { /* Set next descriptor address register with next descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); } else { /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); } /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */ (&amp;DMAPTPRxDescTab[i])-&gt;Buffer1Addr = DMARxDesc-&gt;Buffer1Addr; (&amp;DMAPTPRxDescTab[i])-&gt;Buffer2NextDescAddr = DMARxDesc-&gt;Buffer2NextDescAddr; } /* Store on the last DMAPTPRxDescTab desc status record the first list address */ (&amp;DMAPTPRxDescTab[i-1])-&gt;Status = (uint32_t) DMAPTPRxDescTab; /* Set Receive Desciptor List Address Register */ ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab; } /** * @brief Transmits a packet, from application buffer, pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet buffer to transmit. * @param FrameLength: Tx Packet size. * @param PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values. * @retval ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */ uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab) { uint32_t offset = 0, timeout = 0; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */ for(offset=0; offset&lt;FrameLength; offset++) { (*(__IO uint8_t *)((DMAPTPTxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset)); } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; (uint32_t)0x1FFF); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Wait for ETH_DMATxDesc_TTSS flag to be set */ do { timeout++; } while (!(DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TTSS) &amp;&amp; (timeout &lt; 0xFFFF)); /* Return ERROR in case of timeout */ if(timeout == PHY_READ_TO) { return ETH_ERROR; } /* Clear the DMATxDescToSet status register TTSS flag */ DMATxDescToSet-&gt;Status &amp;= ~ETH_DMATxDesc_TTSS; *PTPTxTab++ = DMATxDescToSet-&gt;Buffer1Addr; *PTPTxTab = DMATxDescToSet-&gt;Buffer2NextDescAddr; /* Update the ENET DMA current descriptor */ /* Chained Mode */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Buffer2NextDescAddr); if(DMAPTPTxDescToSet-&gt;Status != 0) { DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Status); } else { DMAPTPTxDescToSet++; } } else /* Ring Mode */ { if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET) { /* Selects the next DMA Tx descriptor list for next buffer read: this will be the first Tx descriptor in this case */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR); } else { /* Selects the next DMA Tx descriptor list for next buffer read */ DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return SUCCESS */ return ETH_SUCCESS; } /** * @brief Receives a packet and copies it to memory pointed by ppkt with Time Stamp values. * @param ppkt: pointer to application packet receive buffer. * @param PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values. * @retval ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */ uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab) { uint32_t offset = 0, framelength = 0; /* Check if the descriptor is owned by the ENET or CPU */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET) { /* Return error: OWN bit set */ return ETH_ERROR; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4; /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ for(offset=0; offset&lt;framelength; offset++) { (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet-&gt;Buffer1Addr) + offset)); } } else { /* Return ERROR */ framelength = ETH_ERROR; } /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } *PTPRxTab++ = DMARxDescToGet-&gt;Buffer1Addr; *PTPRxTab = DMARxDescToGet-&gt;Buffer2NextDescAddr; /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ DMARxDescToGet-&gt;Status |= ETH_DMARxDesc_OWN; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET) { /* Selects the next DMA Rx descriptor list for next buffer read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Buffer2NextDescAddr); if(DMAPTPRxDescToGet-&gt;Status != 0) { DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Status); } else { DMAPTPRxDescToGet++; } } else /* Ring Mode */ { if((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET) { /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR); } else { /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; 2)); } } /* Return Frame Length/ERROR */ return (framelength); } /** * @} */ /* * STM32 Eth Driver * Change Logs: * Date Author Notes * 2009-10-05 Bernard eth interface driver for STM32F107 CL */ #include &lt;netif/ethernetif.h&gt; #include &lt;netif/etharp.h&gt; #include &lt;lwip/icmp.h&gt; #include &quot;lwipopts.h&quot; #define ETH_DEBUG //#define ETH_RX_DUMP //#define ETH_TX_DUMP #ifdef ETH_DEBUG #define STM32_ETH_TRACE FreeRTOS_printf #else #define STM32_ETH_TRACE(...) #endif /* ETH_DEBUG */ #if defined(ETH_RX_DUMP) || defined(ETH_TX_DUMP) static void packet_dump(const char * msg, const struct pbuf* p) { rt_uint32_t i; u8 *ptr = p-&gt;payload; STM32_ETH_TRACE(&quot;%s %d byte\\n&quot;, msg, p-&gt;tot_len); for(i=0; i&lt;p-&gt;tot_len; i++) { if( (i%8) == 0 ) { STM32_ETH_TRACE(&quot; &quot;); } if( (i%16) == 0 ) { STM32_ETH_TRACE(&quot;\\r\\n&quot;); } STM32_ETH_TRACE(&quot;%02x &quot;,*ptr); ptr++; } STM32_ETH_TRACE(&quot;\\n\\n&quot;); } #endif /* dump */ static ETH_InitTypeDef ETH_InitStructure; /* initialize the interface */ /** * @brief Configures the Ethernet Interface * @param None * @retval None */ void Ethernet_Configuration(void) { vu32 Value = 0; /* Reset ETHERNET on AHB Bus */ ETH_DeInit(); /* Software reset */ ETH_SoftwareReset(); /* Wait for software reset */ while(ETH_GetSoftwareResetStatus()==SET); /* ETHERNET Configuration ------------------------------------------------------*/ /* Call ETH_StructInit if you don&#39;t like to configure all ETH_InitStructure parameter */ ETH_StructInit(&amp;ETH_InitStructure); /* Fill ETH_InitStructure parametrs */ /*------------------------ MAC -----------------------------------*/ ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable ; ETH_InitStructure.ETH_Speed = ETH_Speed_100M; ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex; ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable; ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable; ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable; ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable; ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable; ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; #if CHECKSUM_BY_HARDWARE ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable; #endif /* CHECKSUM_BY_HARDWARE */ /*------------------------ DMA -----------------------------------*/ /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */ ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable; ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable; ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable; ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable; ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable; ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat; ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat; ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1; /* Configure ETHERNET */ Value = ETH_Init(&amp;ETH_InitStructure); /* Enable DMA Receive interrupt (need to enable in this case Normal interrupt) */ ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R | ETH_DMA_IT_T, ENABLE); } static void RCC_Configuration(void) { /* Enable ETHERNET clock */ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx | RCC_AHBPeriph_ETH_MAC_Rx, ENABLE); /* Enable GPIOs clocks */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_AFIO, ENABLE); } static void NVIC_Configuration(void) { NVIC_InitTypeDef NVIC_InitStructure; /* 2 bit for pre-emption priority, 2 bits for subpriority */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //by sunq /* Enable the EXTI0 Interrupt */ NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); } /* * GPIO Configuration for ETH AF Output Push Pull: - ETH_MDC : PC1 - ETH_MDIO : PA2 - ETH_TX_EN : PB11 - ETH_TXD0 : PB12 - ETH_TXD1 : PB13 - ETH_TXD2 : PC2 - ETH_TXD3 : PB8 - ETH_PPS_OUT / ETH_RMII_PPS_OUT: PB5 Input (Reset Value): - ETH_MII_TX_CLK: PC3 - ETH_MII_RX_CLK / ETH_RMII_REF_CLK: PA1 - ETH_MII_CRS: PA0 - ETH_MII_COL: PA3 - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PA7 - ETH_MII_RXD0: PC4 - ETH_MII_RXD1: PC5 - ETH_MII_RXD2: PB0 - ETH_MII_RXD3: PB1 - ETH_MII_RX_ER: PB10 *************************************** For Remapped Ethernet pins ******************************************* Input (Reset Value): - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PD8 - ETH_MII_RXD0 / ETH_RMII_RXD0: PD9 - ETH_MII_RXD1 / ETH_RMII_RXD1: PD10 - ETH_MII_RXD2: PD11 - ETH_MII_RXD3: PD12 */ static void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; #if STM32_ETH_IO_REMAP /* ETHERNET pins remapp in STM3210C-EVAL board: RX_DV and RxD[3:0] */ GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE); #endif /* STM32_ETH_IO_REMAP */ /* MII/RMII Media interface selection */ #if (RMII_MODE == 0) /* Mode MII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_MII); #elif (RMII_MODE == 1) /* Mode RMII. */ GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII); #endif /* RMII_MODE */ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* MDIO */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* MDC */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* MDIO */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); } /* MDIO */ /* TXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; /* TX_EN */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* TXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* TXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* TX_CLK */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* TXD */ /* RXD */ { GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; #if (STM32_ETH_IO_REMAP == 0) /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #else /* RX_DV/CRS_DV */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD0 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD1 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #if (RMII_MODE == 0) /* RXD2 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* RXD3 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ #endif /* STM32_ETH_IO_REMAP */ #if (RMII_MODE == 0) /* CRS */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* COL */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_CLK */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* RX_ER */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); #endif /* RMII_MODE */ } /* RXD */ #if (USE_MCO == 1) #if (RMII_MODE == 0) /* Mode MII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ RCC_MCOConfig(RCC_MCO_HSE); #elif (RMII_MODE == 1) /* Mode RMII. */ /* Get HSE clock = 25MHz on PA8 pin(MCO) */ /* set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */ RCC_PLL3Config(RCC_PLL3Mul_10); /* Enable PLL3 */ RCC_PLL3Cmd(ENABLE); /* Wait till PLL3 is ready */ while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {} /* Get clock PLL3 clock on PA8 pin */ RCC_MCOConfig(RCC_MCO_PLL3CLK); #endif /* RMII_MODE */ /* MCO pin configuration------------------------------------------------- */ /* Configure MCO (PA8) as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); #endif /* USE_MCO */ } void FreeRTOS_Hardware_STMS32_ETH_Init() { RCC_Configuration(); GPIO_Configuration(); NVIC_Configuration(); Ethernet_Configuration(); } 另外我们写一个ethernetif.h头文件： #ifndef __ETHERNETIF_H__ #define __ETHERNETIF_H__ #include &quot;lwip/err.h&quot; #include &quot;lwip/netif.h&quot; err_t ethernetif_init(struct netif *netif); #endif 把它放在third_party\\lwip-1.4.1\\src\\include\\netif目录下。 到此，驱动部分完成了。 然后，就要修改third_party\\lwip-1.4.1\\src\\netif\\ethernetif.c。 ethernetif.c内容主要是针对物理层操作的一个结构体变量进行回调函数指针赋值，并实现链路层发送和接收数据包， 代码如下： /** * @file * Ethernet Interface Skeleton * */ /* * Copyright (c) 2001-2004 Swedish Institute of Computer Science. * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * 1. Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation * and/or other materials provided with the distribution. * 3. The name of the author may not be used to endorse or promote products * derived from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY * OF SUCH DAMAGE. * * This file is part of the lwIP TCP/IP stack. * * Author: Adam Dunkels &lt;adam@sics.se&gt; * */ /* * This file is a skeleton for developing Ethernet network interface * drivers for lwIP. Add code to the low_level functions and do a * search-and-replace for the word &quot;ethernetif&quot; to replace it with * something that better describes your network interface. */ #include &quot;lwip/opt.h&quot; #include &quot;lwip/def.h&quot; #include &quot;lwip/mem.h&quot; #include &quot;lwip/pbuf.h&quot; #include &quot;lwip/sys.h&quot; #include &quot;netif/etharp.h&quot; #include &quot;err.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;stm32_eth.h&quot; #include &lt;string.h&gt; #include &quot;lwip/timers.h&quot; #define netifMTU (1500) #define netifINTERFACE_TASK_STACK_SIZE ( 350 ) #define netifINTERFACE_TASK_PRIORITY ( configMAX_PRIORITIES - 1 ) #define netifGUARD_BLOCK_TIME ( 250 ) /* The time to block waiting for input. */ #define emacBLOCK_TIME_WAITING_FOR_INPUT ( ( portTickType ) 100 ) /* Define those to better describe your network interface. */ #define IFNAME0 &#39;s&#39; #define IFNAME1 &#39;t&#39; #define ETH_DMARxDesc_FrameLengthShift 16 #define ETH_ERROR ((u32)0) #define ETH_SUCCESS ((u32)1) static struct netif *s_pxNetIf = NULL; xSemaphoreHandle s_xSemaphore = NULL; #define ETH_RXBUFNB 4 #define ETH_TXBUFNB 2 /* Ethernet Rx &amp; Tx DMA Descriptors */ ETH_DMADESCTypeDef DMARxDscrTab[ETH_RXBUFNB], DMATxDscrTab[ETH_TXBUFNB]; /* Ethernet Receive buffers */ uint8_t Rx_Buff[ETH_RXBUFNB][ETH_MAX_PACKET_SIZE]; /* Ethernet Transmit buffers */ uint8_t Tx_Buff[ETH_TXBUFNB][ETH_MAX_PACKET_SIZE]; /* Global pointers to track current transmit and receive descriptors */ extern ETH_DMADESCTypeDef *DMATxDescToSet; extern ETH_DMADESCTypeDef *DMARxDescToGet; typedef struct { u32 length; u32 buffer; ETH_DMADESCTypeDef *descriptor; }FrameTypeDef; FrameTypeDef ETH_RxPkt_ChainMode(void); u32 ETH_GetCurrentTxBuffer(void); u32 ETH_TxPkt_ChainMode(u16 FrameLength); static void ethernetif_input( void * pvParameters ); static void arp_timer(void *arg); /** * In this function, the hardware should be initialized. * Called from ethernetif_init(). * * @param netif the already initialized lwip network interface structure * for this ethernetif */ static void low_level_init(struct netif *netif) { uint32_t i; struct ethernetif *ethernetif = netif-&gt;state; /* set netif MAC hardware address length */ netif-&gt;hwaddr_len = ETHARP_HWADDR_LEN; /* set netif MAC hardware address */ netif-&gt;hwaddr[0] = MAC_ADDR0; netif-&gt;hwaddr[1] = MAC_ADDR1; netif-&gt;hwaddr[2] = MAC_ADDR2; netif-&gt;hwaddr[3] = MAC_ADDR3; netif-&gt;hwaddr[4] = MAC_ADDR4; netif-&gt;hwaddr[5] = MAC_ADDR5; /* set netif maximum transfer unit */ netif-&gt;mtu = 1500; /* Accept broadcast address and ARP traffic */ netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP; s_pxNetIf =netif; /* create binary semaphore used for informing ethernetif of frame reception */ if (s_xSemaphore == NULL) { s_xSemaphore= xSemaphoreCreateCounting(20,0); } /* initialize MAC address in ethernet MAC */ ETH_MACAddressConfig(ETH_MAC_Address0, netif-&gt;hwaddr); /* Initialize Tx Descriptors list: Chain Mode */ ETH_DMATxDescChainInit(DMATxDscrTab, &amp;Tx_Buff[0][0], ETH_TXBUFNB); /* Initialize Rx Descriptors list: Chain Mode */ ETH_DMARxDescChainInit(DMARxDscrTab, &amp;Rx_Buff[0][0], ETH_RXBUFNB); /* Enable Ethernet Rx interrrupt */ { for(i=0; i&lt;ETH_RXBUFNB; i++) { ETH_DMARxDescReceiveITConfig(&amp;DMARxDscrTab[i], ENABLE); } } #ifdef CHECKSUM_BY_HARDWARE /* Enable the checksum insertion for the Tx frames */ { for(i=0; i&lt;ETH_TXBUFNB; i++) { ETH_DMATxDescChecksumInsertionConfig(&amp;DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull); } } #endif /* create the task that handles the ETH_MAC */ xTaskCreate(ethernetif_input, (const char*) &quot;Eth_if&quot;, netifINTERFACE_TASK_STACK_SIZE, NULL, netifINTERFACE_TASK_PRIORITY,NULL); /* Enable MAC and DMA transmission and reception */ ETH_Start(); } /** * This function should do the actual transmission of the packet. The packet is * contained in the pbuf that is passed to the function. This pbuf * might be chained. * * @param netif the lwip network interface structure for this ethernetif * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type) * @return ERR_OK if the packet could be sent * an err_t value if the packet couldn&#39;t be sent * * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to * strange results. You might consider waiting for space in the DMA queue * to become availale since the stack doesn&#39;t retry to send a packet * dropped because of memory failure (except for the TCP timers). */ static err_t low_level_output(struct netif *netif, struct pbuf *p) { static xSemaphoreHandle xTxSemaphore = NULL; struct pbuf *q; uint32_t l = 0; u8 *buffer ; if (xTxSemaphore == NULL) { vSemaphoreCreateBinary (xTxSemaphore); } if (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME)) { buffer = (u8 *)(ETH_GetCurrentTxBuffer()); for(q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)&amp;buffer[l], q-&gt;payload, q-&gt;len); l = l + q-&gt;len; } ETH_TxPkt_ChainMode(l); xSemaphoreGive(xTxSemaphore); } return ERR_OK; } /** * Should allocate a pbuf and transfer the bytes of the incoming * packet from the interface into the pbuf. * * @param netif the lwip network interface structure for this ethernetif * @return a pbuf filled with the received packet (including MAC header) * NULL on memory error */ static struct pbuf * low_level_input(struct netif *netif) { struct pbuf *p, *q; u16_t len; int l =0; FrameTypeDef frame; u8 *buffer; p = NULL; frame = ETH_RxPkt_ChainMode(); /* Check if the descriptor is exist */ if(!frame.descriptor) return p; /* Obtain the size of the packet and put it into the &quot;len&quot; variable. */ len = frame.length; buffer = (u8 *)frame.buffer; /* We allocate a pbuf chain of pbufs from the pool. */ p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL); if (p != NULL) { for (q = p; q != NULL; q = q-&gt;next) { memcpy((u8_t*)q-&gt;payload, (u8_t*)&amp;buffer[l], q-&gt;len); l = l + q-&gt;len; } } /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */ frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; /* When Rx Buffer unavailable flag is set: clear it and resume reception */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } return p; } /** * This function is the ethernetif_input task, it is processed when a packet * is ready to be read from the interface. It uses the function low_level_input() * that should handle the actual reception of bytes from the network * interface. Then the type of the received packet is determined and * the appropriate input function is called. * * @param netif the lwip network interface structure for this ethernetif */ void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } /** * Should be called at the beginning of the program to set up the * network interface. It calls the function low_level_init() to do the * actual setup of the hardware. * * This function should be passed as a parameter to netif_add(). * * @param netif the lwip network interface structure for this ethernetif * @return ERR_OK if the loopif is initialized * ERR_MEM if private data couldn&#39;t be allocated * any other err_t on error */ err_t ethernetif_init(struct netif *netif) { LWIP_ASSERT(&quot;netif != NULL&quot;, (netif != NULL)); #if LWIP_NETIF_HOSTNAME /* Initialize interface hostname */ netif-&gt;hostname = &quot;lwip&quot;; #endif /* LWIP_NETIF_HOSTNAME */ netif-&gt;name[0] = IFNAME0; netif-&gt;name[1] = IFNAME1; netif-&gt;output = etharp_output; netif-&gt;linkoutput = low_level_output; /* initialize the hardware */ low_level_init(netif); etharp_init(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); return ERR_OK; } static void arp_timer(void *arg) { etharp_tmr(); sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL); } /******************************************************************************* * Function Name : ETH_RxPkt_ChainMode * Description : Receives a packet. * Input : None * Output : None * Return : frame: farme size and location *******************************************************************************/ FrameTypeDef ETH_RxPkt_ChainMode(void) { u32 framelength = 0; FrameTypeDef frame = {0,0}; /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (u32)RESET) { frame.length = ETH_ERROR; if ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET) { /* Clear RBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_RBUS; /* Resume DMA reception */ ETH-&gt;DMARPDR = 0; } /* Return error: OWN bit set */ return frame; } if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (u32)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (u32)RESET)) { /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */ framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARxDesc_FrameLengthShift) - 4; /* Get the addrees of the actual buffer */ frame.buffer = DMARxDescToGet-&gt;Buffer1Addr; } else { /* Return ERROR */ framelength = ETH_ERROR; } frame.length = framelength; frame.descriptor = DMARxDescToGet; /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */ /* Chained Mode */ /* Selects the next DMA Rx descriptor list for next buffer to read */ DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); /* Return Frame */ return (frame); } /******************************************************************************* * Function Name : ETH_TxPkt_ChainMode * Description : Transmits a packet, from application buffer, pointed by ppkt. * Input : - FrameLength: Tx Packet size. * Output : None * Return : ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission *******************************************************************************/ u32 ETH_TxPkt_ChainMode(u16 FrameLength) { /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */ if((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (u32)RESET) { /* Return ERROR: OWN bit set */ return ETH_ERROR; } /* Setting the Frame Length: bits[12:0] */ DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1); /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS; /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */ DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN; /* When Tx Buffer unavailable flag is set: clear it and resume transmission */ if ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (u32)RESET) { /* Clear TBUS ETHERNET DMA flag */ ETH-&gt;DMASR = ETH_DMASR_TBUS; /* Resume DMA transmission*/ ETH-&gt;DMATPDR = 0; } /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */ /* Chained Mode */ /* Selects the next DMA Tx descriptor list for next buffer to send */ DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr); /* Return SUCCESS */ return ETH_SUCCESS; } /******************************************************************************* * Function Name : ETH_GetCurrentTxBuffer * Description : Return the address of the buffer pointed by the current descritor. * Input : None * Output : None * Return : Buffer address *******************************************************************************/ u32 ETH_GetCurrentTxBuffer(void) { /* Return Buffer address */ return (DMATxDescToSet-&gt;Buffer1Addr); } 这里我们加了一个FreeRTOS_net_config.h头文件，里面定义了MAC地址和默认的IP地址定义： /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __FREERTOS_NET_CONFIG_H__ #define __FREERTOS_NET_CONFIG_H__ #ifdef __cplusplus extern &quot;C&quot; { #endif /* MAC ADDRESS*/ #define MAC_ADDR0 0x00 #define MAC_ADDR1 0x80 #define MAC_ADDR2 0xe1 #define MAC_ADDR3 0x31 #define MAC_ADDR4 0x45 #define MAC_ADDR5 0x57 /*Static IP ADDRESS*/ #define IP_ADDR0 192 #define IP_ADDR1 168 #define IP_ADDR2 1 #define IP_ADDR3 30 /*NETMASK*/ #define NETMASK_ADDR0 255 #define NETMASK_ADDR1 255 #define NETMASK_ADDR2 255 #define NETMASK_ADDR3 0 /*Gateway Address*/ #define GW_ADDR0 192 #define GW_ADDR1 168 #define GW_ADDR2 1 #define GW_ADDR3 1 #ifdef __cplusplus } #endif #endif /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 把FreeRTOS_net_config.h放在BSP目录下。 对于ethernetif.c的代码要说明一下ethernetif_input这个函数： void ethernetif_input( void * pvParameters ) { struct pbuf *p; for( ;; ) { if (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE) { while(1) { p = low_level_input( s_pxNetIf ); if(p!=NULL) { if (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf)) { pbuf_free(p); p=NULL; } } else break; } } } } 网上有很多版本没有while循环，这会导致数据接收的时候缓冲区很快被填满，但不能清空，从而导致速度突然下降乃至断断续续，大量丢包，即使ping本机也会陡然降速，不断超时。加上while就可以解决问题了，但是出现了bug，导致系统崩溃，问题出现在low_level_input函数中的 frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; 因为frame.descriptor这个指针使用完之后就被释放了，程序再次跑到这里的时候frame.descriptor成了野指针。 为了解决这个问题，在使用前判断一下： /* Check if the descriptor is exist */ if(!frame.descriptor) return p; 详细位置请参考上面的有关代码。 另外，我们代码中使用了信号量，所以需要在FreeRTOS的配置文件中打开相关的宏，以支持信号量： 把FreeRTOSConfig.h中的： #define configUSE_COUNTING_SEMAPHORES 0 改为： #define configUSE_COUNTING_SEMAPHORES 1 接下来需要改的地方就是网卡接口中断服务程序了。 需要修改两个文件，第一个就是启动文件STM32F10x.s，把以太网中断向量的屏蔽解除。 第二个就是中断服务函数文件stm32f10x_it.c，定义以太网中断服务函数。 STM32F10x.s如下： ;/*****************************************************************************/ ;/* STM32F10x.s: Startup file for ST STM32F10x device series */ ;/*****************************************************************************/ ;/* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; */ ;/*****************************************************************************/ ;/* This file is part of the uVision/ARM development tools. */ ;/* Copyright (c) 2005-2007 Keil Software. All rights reserved. */ ;/* This software may only be used under the terms of a valid, current, */ ;/* end user licence from KEIL for a compatible version of KEIL software */ ;/* development tools. Nothing else gives you the right to use this software. */ ;/*****************************************************************************/ ;// &lt;h&gt; Stack Configuration ;// &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp ;// &lt;h&gt; Heap Configuration ;// &lt;o&gt; Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ;// &lt;/h&gt; Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit IMPORT xPortPendSVHandler IMPORT xPortSysTickHandler IMPORT vPortSVCHandler IMPORT vUARTInterruptHandler ;IMPORT vTimer2IntHandler PRESERVE8 THUMB ; Vector Table Mapped to Address 0 at Reset AREA RESET, DATA, READONLY EXPORT __Vectors EXPORT __Vectors_End EXPORT __Vectors_Size __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD vPortSVCHandler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD xPortPendSVHandler ; PendSV Handler DCD xPortSysTickHandler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD TAMPER_IRQHandler ; Tamper DCD RTC_IRQHandler ; RTC DCD FLASH_IRQHandler ; Flash DCD RCC_IRQHandler ; RCC DCD EXTI0_IRQHandler ; EXTI Line 0 DCD EXTI1_IRQHandler ; EXTI Line 1 DCD EXTI2_IRQHandler ; EXTI Line 2 DCD EXTI3_IRQHandler ; EXTI Line 3 DCD EXTI4_IRQHandler ; EXTI Line 4 DCD DMAChannel1_IRQHandler ; DMA Channel 1 DCD DMAChannel2_IRQHandler ; DMA Channel 2 DCD DMAChannel3_IRQHandler ; DMA Channel 3 DCD DMAChannel4_IRQHandler ; DMA Channel 4 DCD DMAChannel5_IRQHandler ; DMA Channel 5 DCD DMAChannel6_IRQHandler ; DMA Channel 6 DCD DMAChannel7_IRQHandler ; DMA Channel 7 DCD ADC_IRQHandler ; ADC DCD USB_HP_CAN_TX_IRQHandler ; USB High Priority or CAN TX DCD USB_LP_CAN_RX0_IRQHandler ; USB Low Priority or CAN RX0 DCD CAN_RX1_IRQHandler ; CAN RX1 DCD CAN_SCE_IRQHandler ; CAN SCE DCD EXTI9_5_IRQHandler ; EXTI Line 9..5 DCD TIM1_BRK_IRQHandler ; TIM1 Break DCD TIM1_UP_IRQHandler ; TIM1 Update DCD TIM1_TRG_COM_IRQHandler ; TIM1 Trigger and Commutation DCD TIM1_CC_IRQHandler ; TIM1 Capture Compare ; DCD 0 ;vTimer2IntHandler ; TIM2 DCD TIM3_IRQHandler ; TIM3 DCD TIM4_IRQHandler ; TIM4 DCD I2C1_EV_IRQHandler ; I2C1 Event DCD I2C1_ER_IRQHandler ; I2C1 Error DCD I2C2_EV_IRQHandler ; I2C2 Event DCD I2C2_ER_IRQHandler ; I2C2 Error DCD SPI1_IRQHandler ; SPI1 DCD SPI2_IRQHandler ; SPI2 DCD vUARTInterruptHandler ; USART1 DCD USART2_IRQHandler ; USART2 DCD USART3_IRQHandler ; USART3 DCD EXTI15_10_IRQHandler ; EXTI Line 15..10 DCD RTCAlarm_IRQHandler ; RTC Alarm through EXTI Line DCD USBWakeUp_IRQHandler ; USB Wakeup from suspend ;-------------------added by sunq@2017.08.1 DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD TIM5_IRQHandler ; TIM5 DCD SPI3_IRQHandler ; SPI3 DCD UART4_IRQHandler ; UART4 DCD UART5_IRQHandler ; UART5 DCD TIM6_IRQHandler ; TIM6 DCD TIM7_IRQHandler ; TIM7 DCD DMA2_Channel1_IRQHandler ; DMA2 Channel1 DCD DMA2_Channel2_IRQHandler ; DMA2 Channel2 DCD DMA2_Channel3_IRQHandler ; DMA2 Channel3 DCD DMA2_Channel4_IRQHandler ; DMA2 Channel4 DCD DMA2_Channel5_IRQHandler ; DMA2 Channel5 DCD ETH_IRQHandler ; Ethernet DCD ETH_WKUP_IRQHandler ; Ethernet Wakeup through EXTI line DCD CAN2_TX_IRQHandler ; CAN2 TX DCD CAN2_RX0_IRQHandler ; CAN2 RX0 DCD CAN2_RX1_IRQHandler ; CAN2 RX1 DCD CAN2_SCE_IRQHandler ; CAN2 SCE DCD OTG_FS_IRQHandler ; USB OTG FS __Vectors_End __Vectors_Size EQU __Vectors_End - __Vectors AREA |.text|, CODE, READONLY ; Reset handler Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP ; Dummy Exception Handlers (infinite loops which can be modified) NMI_Handler PROC EXPORT NMI_Handler [WEAK] B . ENDP HardFault_Handler\\ PROC EXPORT HardFault_Handler [WEAK] B . ENDP MemManage_Handler\\ PROC EXPORT MemManage_Handler [WEAK] B . ENDP BusFault_Handler\\ PROC EXPORT BusFault_Handler [WEAK] B . ENDP UsageFault_Handler\\ PROC EXPORT UsageFault_Handler [WEAK] B . ENDP SVC_Handler PROC EXPORT SVC_Handler [WEAK] B . ENDP DebugMon_Handler\\ PROC EXPORT DebugMon_Handler [WEAK] B . ENDP PendSV_Handler PROC EXPORT PendSV_Handler [WEAK] B . ENDP SysTick_Handler PROC EXPORT SysTick_Handler [WEAK] B . ENDP Default_Handler PROC EXPORT WWDG_IRQHandler [WEAK] EXPORT PVD_IRQHandler [WEAK] EXPORT TAMPER_IRQHandler [WEAK] EXPORT RTC_IRQHandler [WEAK] EXPORT FLASH_IRQHandler [WEAK] EXPORT RCC_IRQHandler [WEAK] EXPORT EXTI0_IRQHandler [WEAK] EXPORT EXTI1_IRQHandler [WEAK] EXPORT EXTI2_IRQHandler [WEAK] EXPORT EXTI3_IRQHandler [WEAK] EXPORT EXTI4_IRQHandler [WEAK] EXPORT DMAChannel1_IRQHandler [WEAK] EXPORT DMAChannel2_IRQHandler [WEAK] EXPORT DMAChannel3_IRQHandler [WEAK] EXPORT DMAChannel4_IRQHandler [WEAK] EXPORT DMAChannel5_IRQHandler [WEAK] EXPORT DMAChannel6_IRQHandler [WEAK] EXPORT DMAChannel7_IRQHandler [WEAK] EXPORT ADC_IRQHandler [WEAK] EXPORT USB_HP_CAN_TX_IRQHandler [WEAK] EXPORT USB_LP_CAN_RX0_IRQHandler [WEAK] EXPORT CAN_RX1_IRQHandler [WEAK] EXPORT CAN_SCE_IRQHandler [WEAK] EXPORT EXTI9_5_IRQHandler [WEAK] EXPORT TIM1_BRK_IRQHandler [WEAK] EXPORT TIM1_UP_IRQHandler [WEAK] EXPORT TIM1_TRG_COM_IRQHandler [WEAK] EXPORT TIM1_CC_IRQHandler [WEAK] EXPORT TIM2_IRQHandler [WEAK] EXPORT TIM3_IRQHandler [WEAK] EXPORT TIM4_IRQHandler [WEAK] EXPORT I2C1_EV_IRQHandler [WEAK] EXPORT I2C1_ER_IRQHandler [WEAK] EXPORT I2C2_EV_IRQHandler [WEAK] EXPORT I2C2_ER_IRQHandler [WEAK] EXPORT SPI1_IRQHandler [WEAK] EXPORT SPI2_IRQHandler [WEAK] EXPORT USART1_IRQHandler [WEAK] EXPORT USART2_IRQHandler [WEAK] EXPORT USART3_IRQHandler [WEAK] EXPORT EXTI15_10_IRQHandler [WEAK] EXPORT RTCAlarm_IRQHandler [WEAK] EXPORT USBWakeUp_IRQHandler [WEAK] ;-------------added @2017.09.27----------------------------- EXPORT TIM5_IRQHandler [WEAK] EXPORT SPI3_IRQHandler [WEAK] EXPORT UART4_IRQHandler [WEAK] EXPORT UART5_IRQHandler [WEAK] EXPORT TIM6_IRQHandler [WEAK] EXPORT TIM7_IRQHandler [WEAK] EXPORT DMA2_Channel1_IRQHandler [WEAK] EXPORT DMA2_Channel2_IRQHandler [WEAK] EXPORT DMA2_Channel3_IRQHandler [WEAK] EXPORT DMA2_Channel4_IRQHandler [WEAK] EXPORT DMA2_Channel5_IRQHandler [WEAK] EXPORT ETH_IRQHandler [WEAK] EXPORT ETH_WKUP_IRQHandler [WEAK] EXPORT CAN2_TX_IRQHandler [WEAK] EXPORT CAN2_RX0_IRQHandler [WEAK] EXPORT CAN2_RX1_IRQHandler [WEAK] EXPORT CAN2_SCE_IRQHandler [WEAK] EXPORT OTG_FS_IRQHandler [WEAK] WWDG_IRQHandler PVD_IRQHandler TAMPER_IRQHandler RTC_IRQHandler FLASH_IRQHandler RCC_IRQHandler EXTI0_IRQHandler EXTI1_IRQHandler EXTI2_IRQHandler EXTI3_IRQHandler EXTI4_IRQHandler DMAChannel1_IRQHandler DMAChannel2_IRQHandler DMAChannel3_IRQHandler DMAChannel4_IRQHandler DMAChannel5_IRQHandler DMAChannel6_IRQHandler DMAChannel7_IRQHandler ADC_IRQHandler USB_HP_CAN_TX_IRQHandler USB_LP_CAN_RX0_IRQHandler CAN_RX1_IRQHandler CAN_SCE_IRQHandler EXTI9_5_IRQHandler TIM1_BRK_IRQHandler TIM1_UP_IRQHandler TIM1_TRG_COM_IRQHandler TIM1_CC_IRQHandler TIM2_IRQHandler TIM3_IRQHandler TIM4_IRQHandler I2C1_EV_IRQHandler I2C1_ER_IRQHandler I2C2_EV_IRQHandler I2C2_ER_IRQHandler SPI1_IRQHandler SPI2_IRQHandler USART1_IRQHandler USART2_IRQHandler USART3_IRQHandler EXTI15_10_IRQHandler RTCAlarm_IRQHandler USBWakeUp_IRQHandler ;---------added @2017.09.27-------------------------- TIM5_IRQHandler SPI3_IRQHandler UART4_IRQHandler UART5_IRQHandler TIM6_IRQHandler TIM7_IRQHandler DMA2_Channel1_IRQHandler DMA2_Channel2_IRQHandler DMA2_Channel3_IRQHandler DMA2_Channel4_IRQHandler DMA2_Channel5_IRQHandler ETH_IRQHandler ETH_WKUP_IRQHandler CAN2_TX_IRQHandler CAN2_RX0_IRQHandler CAN2_RX1_IRQHandler CAN2_SCE_IRQHandler OTG_FS_IRQHandler B . ENDP ALIGN ; User Initial Stack &amp; Heap IF :DEF:__MICROLIB EXPORT __initial_sp EXPORT __heap_base EXPORT __heap_limit ELSE IMPORT __use_two_region_memory EXPORT __user_initial_stackheap __user_initial_stackheap LDR R0, = Heap_Mem LDR R1, =(Stack_Mem + Stack_Size) LDR R2, = (Heap_Mem + Heap_Size) LDR R3, = Stack_Mem BX LR ALIGN ENDIF END stm32F10x_it.c如下： /** ****************************************************************************** * @file Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c * @author MCD Application Team * @version V3.5.0 * @date 08-April-2011 * @brief Main Interrupt Service Routines. * This file provides template for all exceptions handler and * peripherals interrupt service routine. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;stm32f10x_it.h&quot; #include &quot;stm32_eth.h&quot; /* Scheduler includes */ #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; /* lwip includes */ #include &quot;lwip/sys.h&quot; /** @addtogroup STM32F10x_StdPeriph_Template * @{ */ /* Private typedef -----------------------------------------------------------*/ /* Private define ------------------------------------------------------------*/ /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ extern xSemaphoreHandle s_xSemaphore; /* Private function prototypes -----------------------------------------------*/ extern void xPortSysTickHandler(void); /* Private functions ---------------------------------------------------------*/ /******************************************************************************/ /* Cortex-M3 Processor Exceptions Handlers */ /******************************************************************************/ /** * @brief This function handles NMI exception. * @param None * @retval None */ void NMI_Handler(void) { } /** * @brief This function handles Hard Fault exception. * @param None * @retval None */ void HardFault_Handler(void) { /* Go to infinite loop when Hard Fault exception occurs */ while (1) { } } /** * @brief This function handles Memory Manage exception. * @param None * @retval None */ void MemManage_Handler(void) { /* Go to infinite loop when Memory Manage exception occurs */ while (1) { } } /** * @brief This function handles Bus Fault exception. * @param None * @retval None */ void BusFault_Handler(void) { /* Go to infinite loop when Bus Fault exception occurs */ while (1) { } } /** * @brief This function handles Usage Fault exception. * @param None * @retval None */ void UsageFault_Handler(void) { /* Go to infinite loop when Usage Fault exception occurs */ while (1) { } } /** * @brief This function handles SVCall exception. * @param None * @retval None */ void SVC_Handler(void) { } /** * @brief This function handles Debug Monitor exception. * @param None * @retval None */ void DebugMon_Handler(void) { } /** * @brief This function handles PendSVC exception. * @param None * @retval None */ void PendSV_Handler(void) { } /** * @brief This function handles SysTick Handler. * @param None * @retval None */ void SysTick_Handler(void) { } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles ETH interrupt request. * @param None * @retval None */ void ETH_IRQHandler(void) { portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; /* Frame received */ if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET) { /* Give the semaphore to wakeup LwIP task */ xSemaphoreGiveFromISR( s_xSemaphore, &amp;xHigherPriorityTaskWoken ); } /* Clear the interrupt flags. */ /* Clear the Eth DMA Rx IT pending bits */ ETH_DMAClearITPendingBit(ETH_DMA_IT_R); ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS); /* Switch tasks if necessary. */ if( xHigherPriorityTaskWoken != pdFALSE ) { portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); } } /******************************************************************************/ /* STM32F10x Peripherals Interrupt Handlers */ /* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */ /* available peripheral interrupt handler&#39;s name please refer to the startup */ /* file (startup_stm32f10x_xx.s). */ /******************************************************************************/ /** * @brief This function handles PPP interrupt request. * @param None * @retval None */ /*void PPP_IRQHandler(void) { }*/ /** * @} */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 移植到此基本完成。 下面验证一下移植结果。 把拷贝过来的BSP目录下的netcon.c加入到IDE的BSP组中，并修改内容如下： /** ****************************************************************************** * @file netconf.c * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief Network connection configuration ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Includes ------------------------------------------------------------------*/ #include &quot;lwip/mem.h&quot; #include &quot;lwip/memp.h&quot; #include &quot;lwip/dhcp.h&quot; #include &quot;ethernetif.h&quot; #include &quot;FreeRTOS_net_config.h&quot; #include &quot;netconf.h&quot; #include &quot;tcpip.h&quot; #include &lt;stdio.h&gt; #define _DEBUG #include &quot;dprintf.h&quot; /* Private typedef -----------------------------------------------------------*/ typedef enum { DHCP_START=0, DHCP_WAIT_ADDRESS, DHCP_ADDRESS_ASSIGNED, DHCP_TIMEOUT } DHCP_State_TypeDef; /* Private define ------------------------------------------------------------*/ #define MAX_DHCP_TRIES 5 /* Private macro -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ struct netif xnetif; /* network interface structure */ /* Private functions ---------------------------------------------------------*/ /** * @brief Initializes the lwIP stack * @param None * @retval None */ void LwIP_Init(void) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; /* Create tcp_ip stack thread */ tcpip_init( NULL, NULL ); /* IP address setting &amp; display on STM32_evalboard LCD*/ #ifdef USE_DHCP ipaddr.addr = 0; netmask.addr = 0; gw.addr = 0; #else IP4_ADDR(&amp;ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); #endif /* - netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask, struct ip_addr *gw, void *state, err_t (* init)(struct netif *netif), err_t (* input)(struct pbuf *p, struct netif *netif)) Adds your network interface to the netif_list. Allocate a struct netif and pass a pointer to this structure as the first argument. Give pointers to cleared ip_addr structures when using DHCP, or fill them with sane numbers otherwise. The state pointer may be NULL. The init function pointer must point to a initialization function for your ethernet netif interface. The following code illustrates it&#39;s use.*/ netif_add(&amp;xnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, &amp;ethernetif_init, &amp;tcpip_input); /* Registers the default network interface. */ netif_set_default(&amp;xnetif); /* When the netif is fully configured this function must be called.*/ netif_set_up(&amp;xnetif); } #ifdef USE_DHCP /** * @brief LwIP_DHCP_Process_Handle * @param None * @retval None */ int g_DHCP_OK_flag = 0; void LwIP_DHCP_task(void * pvParameters) { struct ip_addr ipaddr; struct ip_addr netmask; struct ip_addr gw; uint32_t IPaddress; uint8_t iptab[4]; uint8_t iptxt[20]; uint8_t DHCP_state; DHCP_state = DHCP_START; for (;;) { switch (DHCP_state) { case DHCP_START: { dhcp_start(&amp;xnetif); IPaddress = 0; DHCP_state = DHCP_WAIT_ADDRESS; printf(&quot;Looking for DHCP server,please wait... \\r\\n&quot;); } break; case DHCP_WAIT_ADDRESS: { /* Read the new IP address */ IPaddress = xnetif.ip_addr.addr; if (IPaddress!=0) { DHCP_state = DHCP_ADDRESS_ASSIGNED; /* Stop DHCP */ dhcp_stop(&amp;xnetif); iptab[0] = (uint8_t)(IPaddress &gt;&gt; 24); iptab[1] = (uint8_t)(IPaddress &gt;&gt; 16); iptab[2] = (uint8_t)(IPaddress &gt;&gt; 8); iptab[3] = (uint8_t)(IPaddress); sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\\r\\nIP address[%s ]assigned by a DHCP server !\\r\\n&quot;,iptxt); vTaskDelete(NULL); } else { /* DHCP timeout */ if (xnetif.dhcp-&gt;tries &gt; MAX_DHCP_TRIES) { DHCP_state = DHCP_TIMEOUT; /* Stop DHCP */ dhcp_stop(&amp;xnetif); /* Static address used */ IP4_ADDR(&amp;ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 ); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3); netif_set_addr(&amp;xnetif, &amp;ipaddr , &amp;netmask, &amp;gw); iptab[0] = IP_ADDR3; iptab[1] = IP_ADDR2; iptab[2] = IP_ADDR1; iptab[3] = IP_ADDR0; sprintf((char*)iptxt, &quot; %d.%d.%d.%d&quot;, iptab[3], iptab[2], iptab[1], iptab[0]); /* end of DHCP process: LED1 stays ON*/ //STM_EVAL_LEDOn(LED1);//.... printf(&quot;\\r\\nDHCP timeout \\r\\nStatic IP address :%s\\r\\n&quot;,iptxt); vTaskDelete(NULL); } { static int s=0; const char tokens[4]={&#39;-&#39;,&#39;\\\\&#39;,&#39;|&#39;,&#39;/&#39;}; printf(&quot;\\b\\b\\b\\b%c%c%c%c&quot;,tokens[s++%4],tokens[s%4],tokens[s%4],tokens[s%4]); } } } break; default: printf(&quot;\\r\\nerr: DHCP_state=%d\\r\\n&quot;,DHCP_state); break; } /* Toggle LED1 */ //STM_EVAL_LEDToggle(LED1);//... /* wait 250 ms */ vTaskDelay(250); } } #endif /* USE_DHCP */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ 修改netconf.h，加入对DHCP的支持。 如下： /** ****************************************************************************** * @file netconf.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief This file contains all the functions prototypes for the netconf.c * file. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef __NETCONF_H #define __NETCONF_H #ifdef __cplusplus extern &quot;C&quot; { #endif #define USE_DHCP // @2017.09.27 /* Includes ------------------------------------------------------------------*/ /* Exported types ------------------------------------------------------------*/ extern struct netif xnetif; /* Exported constants --------------------------------------------------------*/ /* Exported macro ------------------------------------------------------------*/ /* Exported functions ------------------------------------------------------- */ void LwIP_Init(void); void LwIP_DHCP_task(void * pvParameters); #ifdef __cplusplus } #endif #endif /* __NETCONF_H */ /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/ main.c文件修改如下： #include &quot;stm32f10x.h&quot; #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;queue.h&quot; #include &quot;semphr.h&quot; #include &quot;utils.h&quot; #define _DEBUG #include &quot;dprintf.h&quot; void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; /* Configure IO connected to LD1, LD2, LD3 and LD4 leds *********************/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); } //?????? void NVIC_Configuration(void) { /* Configure the NVIC Preemption Priority Bits */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0); #ifdef VECT_TAB_RAM /* Set the Vector Table base location at 0x20000000 */ NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); #else /* VECT_TAB_FLASH */ /* Set the Vector Table base location at 0x08000000 */ NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); #endif } void RCC_Configuration(void) { SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |RCC_APB2Periph_ADC1 | RCC_APB2Periph_AFIO |RCC_APB2Periph_SPI1, ENABLE ); // RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALL ,ENABLE ); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4 |RCC_APB1Periph_USART3|RCC_APB1Periph_TIM2 , ENABLE ); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); } void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { /* This function will get called if a task overflows its stack. If the parameters are corrupt then inspect pxCurrentTCB to find which was the offending task. */ ( void ) pxTask; printf(&quot;ÈÎÎñ£º%s ·¢ÏÖÕ»Òç³ö\\n&quot;, pcTaskName); for( ;; ); } /*-----------------------------------------------------------*/ void vApplicationTickHook( void ) { } static void prvSetupHardware( void ) { /* Start with the clocks in their expected state. */ RCC_DeInit(); /* Enable HSE (high speed external clock). */ RCC_HSEConfig( RCC_HSE_ON ); /* Wait till HSE is ready. */ while( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET ) { } /* 2 wait states required on the flash. */ *( ( unsigned long * ) 0x40022000 ) = 0x02; /* HCLK = SYSCLK */ RCC_HCLKConfig( RCC_SYSCLK_Div1 ); /* PCLK2 = HCLK */ RCC_PCLK2Config( RCC_HCLK_Div1 ); /* PCLK1 = HCLK/2 */ RCC_PCLK1Config( RCC_HCLK_Div2 ); /* Enable PLL. */ RCC_PLLCmd( ENABLE ); /* Wait till PLL is ready. */ while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) { } /* Select PLL as system clock source. */ RCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK ); /* Wait till PLL is used as system clock source. */ while( RCC_GetSYSCLKSource() != 0x08 ) { } /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */ RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE ); /* Set the Vector Table base address at 0x08000000 */ NVIC_SetVectorTable( NVIC_VectTab_FLASH, 0x0 ); NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 ); /* Configure HCLK clock as SysTick clock source. */ SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK ); GPIO_Configuration(); } #define ledSTACK_SIZE configMINIMAL_STACK_SIZE #define ledFLASH_RATE_BASE ( ( TickType_t ) 333 ) static TaskHandle_t xHandleTaskLED=NULL; static void vTaskLED(void* pvParameters) { TickType_t xFlashRate, xLastFlashTime; xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) 2 ); xFlashRate /= portTICK_PERIOD_MS; xFlashRate /= ( TickType_t ) 2; xLastFlashTime = xTaskGetTickCount(); while(1) { /* Turn on LD1 */ GPIO_SetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); /* Turn off LD1 */ GPIO_ResetBits(GPIOD, GPIO_Pin_2); /* Insert delay */ //vTaskDelay(300); vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate ); } } #include &quot;serial.h&quot; #include &quot;integer.h&quot; #include &quot;diskio.h&quot; #include &quot;ff.h&quot; #include &quot;sdcard.h&quot; #include &quot;common.h&quot; #include &lt;stdio.h&gt; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) /* Handle to the com port used by both tasks. */ static xComPortHandle xPort = NULL; /* The Rx task will block on the Rx queue for a long period. */ #define comRX_BLOCK_TIME ( ( TickType_t ) 0xffff ) static void sd_card_task(void* pvParameters) { signed char key = 0; GPIO_ResetBits(GPIOF, GPIO_Pin_6); //LED1 on while(1) { printf(&quot;\\r\\n============ ÇëÑ¡Ôñ...===============\\r\\n\\n&quot;); printf(&quot;¸ñ Ê½ »¯------------------------------- 1\\r\\n\\n&quot;); printf(&quot;´´½¨ÎÄ¼þ------------------------------- 2\\r\\n\\n&quot;); printf(&quot;É¾³ýÎÄ¼þ ------------------------------ 3\\r\\n\\n&quot;); printf(&quot;ÁÐ±íÎÄ¼þ------------------------------- 4\\r\\n\\n&quot;); printf(&quot;ÖØÆôÏµÍ³ ------------------------------ 5\\r\\n\\n&quot;); printf(&quot;´ÅÅÌÐÅÏ¢------------------------------- 6\\r\\n\\n&quot;); printf(&quot;´´½¨Ä¿Â¼------------------------------- 7\\r\\n\\n&quot;); printf(&quot;±à¼­ÎÄ¼þ------------------------------- 8\\r\\n\\n&quot;); printf(&quot;¶ÁÈ¡ÎÄ¼þ------------------------------- 9\\r\\n\\n&quot;); printf(&quot;========================================\\r\\n\\n&quot;); xSerialGetChar( xPort, &amp;key, comRX_BLOCK_TIME ); if (key == 0x31) //Format FS { printf(&quot;\\r\\n----1----&quot;); format_disk(); } else if (key == 0x32) //Creat File { printf(&quot;\\r\\n----2----&quot;); creat_file(); } else if (key == 0x33) //Delete File { printf(&quot;\\r\\n----3----&quot;); delete_file(); } else if (key == 0x34) //List File { printf(&quot;\\r\\n----4----&quot;); list_file(); } else if (key == 0x35) //Reset FS { printf(&quot;\\r\\n----5----&quot;); Sys_Soft_Reset(); } else if (key == 0x36) //Disk info { printf(&quot;\\r\\n----6----&quot;); get_disk_info(); } else if (key == 0x37) //Creat Dir { printf(&quot;\\r\\n----7----&quot;); creat_dir(); } else if (key == 0x38) //Edit File { printf(&quot;\\r\\n----8----&quot;); edit_file(); } else if (key == 0x39) //Read File { printf(&quot;\\r\\n----9----&quot;); read_file(); } else { printf(&quot;\\r\\n----%c----&quot;,key); printf(&quot;\\r\\nÖ»½ÓÊÜ1-9ÃüÁî£¬ÇëÖØÐÂÊäÈë&quot;); } } } #include &quot;netconf.h&quot; #include &quot;stm32_eth.h&quot; #define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY ) #define DHCP_TASK_PRIO ( tskIDLE_PRIORITY + 2 ) static TaskHandle_t xHandleTaskSystemInit=NULL; static void System_Init_task(void* pvParameters) { xTaskCreate(vTaskLED,&quot;vTaskLED&quot;,ledSTACK_SIZE,NULL,3,&amp;xHandleTaskLED); printf(&quot;2 led demos tasks are created !\\r\\n&quot;); //xTaskCreate(sd_card_task,&quot;vTaskSDCard&quot;,1024,NULL,SYSTEM_INIT_TASK_PRIO,NULL); //printf(&quot;The task of SDCard is created!\\r\\n&quot;); printf(&quot;eth hardware initialzing...\\r\\n&quot;); FreeRTOS_Hardware_STMS32_ETH_Init(); printf(&quot;eth hardware ok\\r\\nstarting LwIP stack...\\r\\n&quot;); /* Initilaize the LwIP stack */ LwIP_Init(); printf(&quot;LwIP stack started !\\r\\n&quot;); /* Initialize tcp echo server */ //tcpecho_init(); #ifdef USE_DHCP /* Start DHCPClient */ xTaskCreate(LwIP_DHCP_task, &quot;DHCPClient&quot;, configMINIMAL_STACK_SIZE * 2, NULL,DHCP_TASK_PRIO, NULL); #endif printf(&quot;LwIP_DHCP_task is created !\\r\\n&quot;); vTaskDelete(xHandleTaskSystemInit); } int main(void) { __set_PRIMASK(1);//½ûÖ¹È«¾ÖÖÐ¶Ï prvSetupHardware(); FreeRTOS_printf_service_init(); printf(&quot;###############################################\\r\\n&quot;); printf(&quot;## hello! welcome to FreeRTOS v9.0.0 ##\\r\\n&quot;); printf(&quot;###############################################\\r\\n&quot;); printf(&quot;\\r\\n\\r\\n&quot;); SD_Init(); InitMQTTServerInfo(); xTaskCreate(System_Init_task,&quot;vTaskSystemInit&quot;,100,NULL,SYSTEM_INIT_TASK_PRIO,&amp;xHandleTaskSystemInit); vTaskStartScheduler();//Æô¶¯ÈÎÎñµ÷¶ÈÆ÷ } /******************* (C) COPYRIGHT 2012 WildFire Team *****END OF FILE************/ 编译完成后，把hex档烧到开发板上，上电运行。看到： LwIP已经运行起来了。路由分配了ip：10.0.0.109 打开一个cmd窗口，ping一下开发板： 可以看到ping的结果还是很稳定的。 本文完整的源代码下载地址： STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1.rar 下一篇将移植MQTT，并对步进电机控制器进行控制。 阅读更多","@type":"BlogPosting","url":"/2017/09/26/da020891f7dcd8dc4de56bfe7c74a9d3.html","headline":"基于FreeRTOS与MQTT的物联网技术应用系列——步进电机控制（四）FreeRTOS系统下LwIP-1.4.1的移植","dateModified":"2017-09-26T00:00:00+08:00","datePublished":"2017-09-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/09/26/da020891f7dcd8dc4de56bfe7c74a9d3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于FreeRTOS与MQTT的物联网技术应用系列——步进电机控制（四）FreeRTOS系统下LwIP-1.4.1的移植</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>本文在前一篇的基础上，进行基于FreeRTOS的LwIP-1.4.1版本移植、 <br> 本文使用的网卡PHY芯片型号是DP83848，工作在MII接口模式，时钟频率是25MHz。</p> 
  <p>现在的LwIP版本已经发展到了lwIP 2.0.3 版。 <br> 但是看了具体的代码后发现一些跟1.4.1对比之下不同之处，其中包含但不全部： <br> 1、IPv4和IPv6的实现代码混合起来，而1.4.1是分开的，通过预处理宏可以分开编译。 <br> 2、增加了一些常用的网络组件或应用程序，其中包括了基于tcp接口实现的MQTT协议。</p> 
  <p>本人也曾试图移植lwIP 2.0.2，发现IPv6实现会被编译进去，并且由此产生一些函数调用问题，在我们的固件库中以及mdk的库中不支持相关函数，另外，本项目用的芯片并不支持IPv6，而相关代码会增加ROM空间的占用，没有必要，而LwIP2.0.2以上的版本所带的MQTT协议实现也可以移植过来到LwIP-1.4.1上使用。</p> 
  <p>因此还是选用LwIP的1.4.1这个经典版本。但后面的MQTT协议实现没有用LwIP2.0.2版的实现代码，而是比较接近paho.mqtt.embedded-c版的一个实现。</p> 
  <p>以下是具体移植过程：</p> 
  <p>LwIP的官方网站：<a href="http://savannah.nongnu.org/projects/lwip/" rel="nofollow">http://savannah.nongnu.org/projects/lwip/</a></p> 
  <p>LwIP-1.4.1下载地址：<a href="http://download.savannah.nongnu.org/releases/lwip/lwip-1.4.1.zip" rel="nofollow">http://download.savannah.nongnu.org/releases/lwip/lwip-1.4.1.zip</a> <br> 或：<a href="http://ftp.yzu.edu.tw/nongnu/lwip/lwip-1.4.1.zip" rel="nofollow">http://ftp.yzu.edu.tw/nongnu/lwip/lwip-1.4.1.zip</a> <br> 或：<a href="https://gitee.com/null_926_6734/CongXiangYingGuanFangHuoQiJingXiangXiaZaiDeMouXieYuanDaiMa/raw/master/lwip-1.4.1.zip" rel="nofollow">https://gitee.com/null_926_6734/CongXiangYingGuanFangHuoQiJingXiangXiaZaiDeMouXieYuanDaiMa/raw/master/lwip-1.4.1.zip</a></p> 
  <p><a href="http://download.savannah.nongnu.org/releases/lwip/contrib-1.4.1.zip" rel="nofollow">contrib-1.4.1.zip</a></p> 
  <p>contrib-1.4.1里面含有官方的移植示例，有windows和unix操作系统下的移植，和某些非操作系统的移植。 <br> 在本项目的移植中需要用到一些头文件，可以在contrib-1.4.1中找到。</p> 
  <p>本文参考了网络上的源代码： <br> <a href="http://www.pudn.com/Download/item/id/2835116.html" rel="nofollow">STM32_FreeRTOS_LwIP</a> <br> 这份代码的说明是这样的： <br> <em>说明： 在神州五号STM32F107VC开发板上移植了最新的FreeRTOS-V8.1.2操作系统，并在该系统上移植了最新的LwIP-1.4.1协议栈，能够ping通，但是系统的稳定性没有测试，仅供使用者参考。</em></p> 
  <p>本人提供的备用下载地址： <br> <a href="https://gitee.com/null_926_6734/STM32F107_FreeRTOS_v9.0.0/raw/STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1/STM32_FreeRTOS_LwIP.rar" rel="nofollow">STM32_FreeRTOS_LwIP.rar</a></p> 
  <p>移植之前，我们要确认一下网卡芯片的工作模式MII接口模式。根据金牛开发板官方驱动代码提供的代码 <br> 看到该开发板的PHY芯片DP83848跟STM32F107VC引脚的对应关系如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170927000136908?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>lwip-1.4.1.zip代码包解压之后放到third_party目录下。 <br> 在IDE上增加一个组，命名为：third_party/LwIP。 <br> 1、把third_party\lwip-1.4.1\src\core下的c文件加入工程中； <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926155652033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 2、把third_party\lwip-1.4.1\src\core\ipv4下的c文件加入到工程中； <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926155708129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 3、把third_party\lwip-1.4.1\src\netif下的c文件加入到工程中； <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926155723223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 4、把third_party\lwip-1.4.1\src\api下的c文件加入到工程中； <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926173729839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 5、把一下路径加入包含路径中：</p> 
  <pre class="prettyprint"><code class=" hljs tex">..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span>;..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span><span class="hljs-command">\lwip</span>;..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span><span class="hljs-command">\arch</span>;..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span><span class="hljs-command">\ipv</span>4;..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span><span class="hljs-command">\netif</span>;</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926155746231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>此时编译，会出现错误，提示找不到lwipopts.h文件。 <br> 我们直接在STM32_FreeRTOS_LwIP这份源代码中直接复制过来，它位置在 <br> STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\App下面，顺便把netconf.h和netconf.c复制过来，放到BSP目录下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926161101264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>关于lwipopts.h的配置说明请参考： <br> <a href="http://blog.csdn.net/slj_win/article/details/16959055" rel="nofollow" target="_blank">http://blog.csdn.net/slj_win/article/details/16959055</a></p> 
  <p>我们拷贝过来的这份lwipopts.h中的配置，是实际使用的时候，会占用大部分的RAM，以至于FreeRTOS的任务经常出现栈溢出或直接跑飞，因此需要稍微减少内存的使用，做一些修改。 <br> 还有就是需要添加对DNS的支持：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_DNS 1 </span></code></pre> 
  <p>和对接收数据定时窗口的支持：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_SO_RCVTIMEO 1</span></code></pre> 
  <p>修改后如下：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">/** ****************************************************************************** * @file lwipopts.h * @author MCD Application Team * @version V1.1.0 * @date 07-October-2011 * @brief lwIP Options Configuration. * This file is based on Utilities\lwip_v1.3.2\src\include\lwip\opt.h * and contains the lwIP configuration for the STM32F2x7 demonstration. ****************************************************************************** * @attention * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */</span>

<span class="hljs-preprocessor">#ifndef __LWIPOPTS_H__</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __LWIPOPTS_H__</span>

<span class="hljs-comment">/** * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain * critical regions during buffer allocation, deallocation and memory * allocation and deallocation. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SYS_LIGHTWEIGHT_PROT 0</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ETHARP_TRUST_IP_MAC 0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IP_REASSEMBLY 0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IP_FRAG 0</span>
<span class="hljs-comment">//#define ARP_QUEUEING 0</span>

<span class="hljs-comment">/* ---------- ARP options ---------- */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_ARP 1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ARP_TABLE_SIZE 10</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ARP_QUEUEING 1</span>

<span class="hljs-comment">/** * NO_SYS==1: Provides VERY minimal functionality. Otherwise, * use lwIP facilities. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> NO_SYS 0</span>

<span class="hljs-comment">/* ---------- Memory options ---------- */</span>
<span class="hljs-comment">/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which lwIP is compiled. 4 byte alignment -&gt; define MEM_ALIGNMENT to 4, 2 byte alignment -&gt; define MEM_ALIGNMENT to 2. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_ALIGNMENT 4</span>

<span class="hljs-comment">/* MEM_SIZE: the size of the heap memory. If the application will send a lot of data that needs to be copied, this should be set high. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_SIZE (4*1024) // (5*1024) @2017.08.26</span>

<span class="hljs-comment">/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application sends a lot of data out of ROM (or other static memory), this should be set high. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_PBUF 100</span>
<span class="hljs-comment">/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One per active UDP "connection". */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_UDP_PCB 6</span>
<span class="hljs-comment">/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_TCP_PCB 10</span>
<span class="hljs-comment">/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_TCP_PCB_LISTEN 5</span>
<span class="hljs-comment">/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_TCP_SEG 20</span>
<span class="hljs-comment">/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMP_NUM_SYS_TIMEOUT 10</span>


<span class="hljs-comment">/* ---------- Pbuf options ---------- */</span>
<span class="hljs-comment">/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PBUF_POOL_SIZE 10 // 20 @2017.08.26</span>

<span class="hljs-comment">/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PBUF_POOL_BUFSIZE 500</span>


<span class="hljs-comment">/* ---------- TCP options ---------- */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_TCP 1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_TTL 255</span>

<span class="hljs-comment">/* Controls if TCP should queue segments that arrive out of order. Define to 0 if your device is low on memory. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_QUEUE_OOSEQ 1</span>

<span class="hljs-comment">/* TCP Maximum segment size. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_MSS (1500 - 40) /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */</span>

<span class="hljs-comment">/* TCP sender buffer space (bytes). */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_SND_BUF (5*TCP_MSS)</span>

<span class="hljs-comment">/* TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_SND_QUEUELEN (4* TCP_SND_BUF/TCP_MSS)</span>

<span class="hljs-comment">/* TCP receive window. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCP_WND (2*TCP_MSS)</span>


<span class="hljs-comment">/* ---------- ICMP options ---------- */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_ICMP 1</span>


<span class="hljs-comment">/* ---------- DHCP options ---------- */</span>
<span class="hljs-comment">/* Define LWIP_DHCP to 1 if you want DHCP configuration of interfaces. DHCP is not implemented in lwIP 0.5.1, however, so turning this on does currently not work. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_DHCP 1</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_DNS 1 //added @2017.08.17</span>
<span class="hljs-comment">/* Enable SO_RCVTIMEO processing. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_SO_RCVTIMEO 1 //added @2017.08.18 </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DHCP_DOES_ARP_CHECK (LWIP_DHCP)</span>

<span class="hljs-comment">/* ---------- UDP options ---------- */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_UDP 1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> UDP_TTL 255</span>


<span class="hljs-comment">/* ---------- Statistics options ---------- */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_STATS 0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_PROVIDE_ERRNO 1</span>


<span class="hljs-comment">/* -------------------------------------- ---------- Checksum options ---------- -------------------------------------- */</span>

<span class="hljs-comment">/* The STM32F2x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware: - To use this feature let the following define uncommented. - To disable it and process by CPU comment the the checksum. */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_BY_HARDWARE 1</span>


<span class="hljs-preprocessor">#ifdef CHECKSUM_BY_HARDWARE</span>
  <span class="hljs-comment">/* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_IP 0</span>
  <span class="hljs-comment">/* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_UDP 0</span>
  <span class="hljs-comment">/* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_TCP 0</span>

  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_ICMP 0 </span>

  <span class="hljs-comment">/* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_IP 0</span>
  <span class="hljs-comment">/* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_UDP 0</span>
  <span class="hljs-comment">/* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_TCP 0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-comment">/* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_IP 1</span>
  <span class="hljs-comment">/* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_UDP 1</span>
  <span class="hljs-comment">/* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_TCP 1</span>

    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_GEN_ICMP 1</span>

  <span class="hljs-comment">/* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_IP 1</span>
  <span class="hljs-comment">/* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_UDP 1</span>
  <span class="hljs-comment">/* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CHECKSUM_CHECK_TCP 1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>


<span class="hljs-comment">/* ---------------------------------------------- ---------- Sequential layer options ---------- ---------------------------------------------- */</span>
<span class="hljs-comment">/** * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c) */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_NETCONN 1</span>

<span class="hljs-comment">/* ------------------------------------ ---------- Socket options ---------- ------------------------------------ */</span>
<span class="hljs-comment">/** * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c) */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_SOCKET 1</span>

<span class="hljs-comment">/* ----------------------------------- ---------- DEBUG options ---------- ----------------------------------- */</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_DEBUG 0</span>


<span class="hljs-comment">/* --------------------------------- ---------- OS options ---------- --------------------------------- */</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCPIP_THREAD_STACKSIZE 1000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCPIP_MBOX_SIZE 5</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEFAULT_UDP_RECVMBOX_SIZE 2000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEFAULT_TCP_RECVMBOX_SIZE 2000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEFAULT_ACCEPTMBOX_SIZE 2000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEFAULT_THREAD_STACKSIZE 500</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TCPIP_THREAD_PRIO (configMAX_PRIORITIES - 2)</span>



<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> /* __LWIPOPTS_H__ */</span>

<span class="hljs-comment">/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/</span>
</code></pre> 
  <p>还有跟移植相关的部分代码在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\lwip-1.4.1\src\include\arch目录下，把整个文件夹都复制过来： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926162914255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 放在我们的相应目录下，并把其中的sys_arch.c加入到IDE的third_party/LwIP组中。</p> 
  <p>此时编译一下，会出现一堆警告，其中一个是：</p> 
  <pre class="prettyprint"><code class=" hljs tex">..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\core</span><span class="hljs-command">\dns</span>.c(241): warning:  <span class="hljs-special">#</span>223-D: function "LWIP_PLATFORM_DIAG" declared implicitly</code></pre> 
  <p>这是LWIP_PLATFORM_DIAG这个宏没有定义的原因。 <br> 可以在third_party\lwip-1.4.1\src\include\lwip\debug.h这个文件中定义。 <br> 找到：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_DEBUGF(debug, message) do { \</span></code></pre> 
  <p>这一行，在它前面加上：</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#define LWIP_PLATFORM_DIAG printf </span></code></pre> 
  <p>并找到：</p> 
  <pre class="prettyprint"><code class=" hljs cmake">LWIP_PLATFORM_DIAG(<span class="hljs-keyword">message</span>); \</code></pre> 
  <p>修改为：</p> 
  <pre class="prettyprint"><code class=" hljs cmake">LWIP_PLATFORM_DIAG <span class="hljs-keyword">message</span> ; \</code></pre> 
  <p>再编译，出现错误：</p> 
  <pre class="prettyprint"><code class=" hljs tex">..<span class="hljs-command">\third</span>_party<span class="hljs-command">\lwip</span>-1.4.1<span class="hljs-command">\src</span><span class="hljs-command">\include</span><span class="hljs-command">\lwip</span>/sys.h(113): error:  <span class="hljs-special">#</span>20: identifier "sys_mutex_t" is undefined</code></pre> 
  <p>解决方法是在</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> LWIP_COMPAT_MUTEX</span></code></pre> 
  <p>前面定义这个宏：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LWIP_COMPAT_MUTEX 1</span></code></pre> 
  <p>编译，通过。 <br> 这是LwIP协议栈的主体部分OK了，但是还没有跟FreeRTOS对接好，另外没有把网卡驱动搞定。下面一步步完成吧。</p> 
  <p>接下来，首先把网卡驱动搞定。这部分在STM32_FreeRTOS_LwIP.rar\STM32_FreeRTOS_LwIP\STM32_ETH_Driver下的源码基础上做修改。 <br> 把整个STM32_ETH_Driver文件夹复制到我们的项目根目录下，在IDE上添加一个组，命名为STM32_ETH_Driver，把项目中的STM32_ETH_Driver\src\stm32_eth.c加入到组中。 <br> 把..\STM32_ETH_Driver\inc加入包含路径中位置如图所示： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170926221857298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>接下来要修改stm32_eth.h和stm32_eth.c。 <br> stm32_eth.c主要是对网卡控制器进行操作，以对网卡芯片初始化。</p> 
  <p>stm32_eth.h：</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** ****************************************************************************** *<span class="hljs-javadoctag"> @file</span> stm32_eth.h *<span class="hljs-javadoctag"> @author</span> MCD Application Team *<span class="hljs-javadoctag"> @version</span> V1.1.0 *<span class="hljs-javadoctag"> @date</span> 11/20/2009 *<span class="hljs-javadoctag"> @brief</span> This file contains all the functions prototypes for the Ethernet * firmware library. ****************************************************************************** *<span class="hljs-javadoctag"> @copy</span> * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */</span>

<span class="hljs-comment">/* Define to prevent recursive inclusion -------------------------------------*/</span>
#ifndef __STM32_ETH_H
#define __STM32_ETH_H

#ifdef __cplusplus
 extern <span class="hljs-string">"C"</span> {
#endif

<span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span>
#include <span class="hljs-string">"stm32f10x.h"</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @addtogroup</span> STM32_ETH_Driver * @{ */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Exported_Types * @{ */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH MAC Init structure definition *<span class="hljs-javadoctag"> @note</span> The user should not configure all the ETH_InitTypeDef structure's fields. * By calling the ETH_StructInit function the structure¡¯s fields are set to their default values. * Only the parameters that will be set to a non-default value should be configured. */</span>
typedef struct {
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> / * MAC */</span>
  uint32_t             ETH_AutoNegotiation;           <span class="hljs-comment">/*!&lt; Selects or not the AutoNegotiation mode for the external PHY The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps) and the mode (half/full-duplex). This parameter can be a value of @ref ETH_AutoNegotiation */</span>

  uint32_t             ETH_Watchdog;                  <span class="hljs-comment">/*!&lt; Selects or not the Watchdog timer When enabled, the MAC allows no more then 2048 bytes to be received. When disabled, the MAC can receive up to 16384 bytes. This parameter can be a value of @ref ETH_watchdog */</span>

  uint32_t             ETH_Jabber;                    <span class="hljs-comment">/*!&lt; Selects or not Jabber timer When enabled, the MAC allows no more then 2048 bytes to be sent. When disabled, the MAC can send up to 16384 bytes. This parameter can be a value of @ref ETH_Jabber */</span>

  uint32_t             ETH_InterFrameGap;             <span class="hljs-comment">/*!&lt; Selects the minimum IFG between frames during transmission This parameter can be a value of @ref ETH_Inter_Frame_Gap */</span>

  uint32_t             ETH_CarrierSense;              <span class="hljs-comment">/*!&lt; Selects or not the Carrier Sense This parameter can be a value of @ref ETH_Carrier_Sense */</span>

  uint32_t             ETH_Speed;                     <span class="hljs-comment">/*!&lt; Sets the Ethernet speed: 10/100 Mbps This parameter can be a value of @ref ETH_Speed */</span>

  uint32_t             ETH_ReceiveOwn;                <span class="hljs-comment">/*!&lt; Selects or not the ReceiveOwn ReceiveOwn allows the reception of frames when the TX_EN signal is asserted in Half-Duplex mode This parameter can be a value of @ref ETH_Receive_Own */</span>

  uint32_t             ETH_LoopbackMode;              <span class="hljs-comment">/*!&lt; Selects or not the internal MAC MII Loopback mode This parameter can be a value of @ref ETH_Loop_Back_Mode */</span>

  uint32_t             ETH_Mode;                      <span class="hljs-comment">/*!&lt; Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode This parameter can be a value of @ref ETH_Duplex_Mode */</span>

  uint32_t             ETH_ChecksumOffload;           <span class="hljs-comment">/*!&lt; Selects or not the IPv4 checksum checking for received frame payloads' TCP/UDP/ICMP headers. This parameter can be a value of @ref ETH_Checksum_Offload */</span>

  uint32_t             ETH_RetryTransmission;         <span class="hljs-comment">/*!&lt; Selects or not the MAC attempt retries transmission, based on the settings of BL, when a colision occurs (Half-Duplex mode) This parameter can be a value of @ref ETH_Retry_Transmission */</span>

  uint32_t             ETH_AutomaticPadCRCStrip;      <span class="hljs-comment">/*!&lt; Selects or not the Automatic MAC Pad/CRC Stripping This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */</span>

  uint32_t             ETH_BackOffLimit;              <span class="hljs-comment">/*!&lt; Selects the BackOff limit value This parameter can be a value of @ref ETH_Back_Off_Limit */</span>

  uint32_t             ETH_DeferralCheck;             <span class="hljs-comment">/*!&lt; Selects or not the deferral check function (Half-Duplex mode) This parameter can be a value of @ref ETH_Deferral_Check */</span>

  uint32_t             ETH_ReceiveAll;                <span class="hljs-comment">/*!&lt; Selects or not all frames reception by the MAC (No fitering) This parameter can be a value of @ref ETH_Receive_All */</span>

  uint32_t             ETH_SourceAddrFilter;          <span class="hljs-comment">/*!&lt; Selects the Source Address Filter mode This parameter can be a value of @ref ETH_Source_Addr_Filter */</span>

  uint32_t             ETH_PassControlFrames;         <span class="hljs-comment">/*!&lt; Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames) This parameter can be a value of @ref ETH_Pass_Control_Frames */</span>

  uint32_t             ETH_BroadcastFramesReception;  <span class="hljs-comment">/*!&lt; Selects or not the reception of Broadcast Frames This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */</span>

  uint32_t             ETH_DestinationAddrFilter;     <span class="hljs-comment">/*!&lt; Sets the destination filter mode for both unicast and multicast frames This parameter can be a value of @ref ETH_Destination_Addr_Filter */</span>

  uint32_t             ETH_PromiscuousMode;           <span class="hljs-comment">/*!&lt; Selects or not the Promiscuous Mode This parameter can be a value of @ref ETH_Promiscuous_Mode */</span>

  uint32_t             ETH_MulticastFramesFilter;     <span class="hljs-comment">/*!&lt; Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Multicast_Frames_Filter */</span>

  uint32_t             ETH_UnicastFramesFilter;       <span class="hljs-comment">/*!&lt; Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter This parameter can be a value of @ref ETH_Unicast_Frames_Filter */</span>

  uint32_t             ETH_HashTableHigh;             <span class="hljs-comment">/*!&lt; This field holds the higher 32 bits of Hash table. */</span>

  uint32_t             ETH_HashTableLow;              <span class="hljs-comment">/*!&lt; This field holds the lower 32 bits of Hash table. */</span>

  uint32_t             ETH_PauseTime;                 <span class="hljs-comment">/*!&lt; This field holds the value to be used in the Pause Time field in the transmit control frame */</span>

  uint32_t             ETH_ZeroQuantaPause;           <span class="hljs-comment">/*!&lt; Selects or not the automatic generation of Zero-Quanta Pause Control frames This parameter can be a value of @ref ETH_Zero_Quanta_Pause */</span>

  uint32_t             ETH_PauseLowThreshold;         <span class="hljs-comment">/*!&lt; This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Frame This parameter can be a value of @ref ETH_Pause_Low_Threshold */</span>

  uint32_t             ETH_UnicastPauseFrameDetect;   <span class="hljs-comment">/*!&lt; Selects or not the MAC detection of the Pause frames (with MAC Address0 unicast address and unique multicast address) This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */</span>

  uint32_t             ETH_ReceiveFlowControl;        <span class="hljs-comment">/*!&lt; Enables or disables the MAC to decode the received Pause frame and disable its transmitter for a specified time (Pause Time) This parameter can be a value of @ref ETH_Receive_Flow_Control */</span>

  uint32_t             ETH_TransmitFlowControl;       <span class="hljs-comment">/*!&lt; Enables or disables the MAC to transmit Pause frames (Full-Duplex mode) or the MAC back-pressure operation (Half-Duplex mode) This parameter can be a value of @ref ETH_Transmit_Flow_Control */</span>

  uint32_t             ETH_VLANTagComparison;         <span class="hljs-comment">/*!&lt; Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for comparison and filtering This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */</span>

  uint32_t             ETH_VLANTagIdentifier;         <span class="hljs-comment">/*!&lt; Holds the VLAN tag identifier for receive frames */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> / * DMA */</span>

  uint32_t             ETH_DropTCPIPChecksumErrorFrame; <span class="hljs-comment">/*!&lt; Selects or not the Dropping of TCP/IP Checksum Error Frames This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */</span>

  uint32_t             ETH_ReceiveStoreForward;         <span class="hljs-comment">/*!&lt; Enables or disables the Receive store and forward mode This parameter can be a value of @ref ETH_Receive_Store_Forward */</span>

  uint32_t             ETH_FlushReceivedFrame;          <span class="hljs-comment">/*!&lt; Enables or disables the flushing of received frames This parameter can be a value of @ref ETH_Flush_Received_Frame */</span>

  uint32_t             ETH_TransmitStoreForward;        <span class="hljs-comment">/*!&lt; Enables or disables Transmit store and forward mode This parameter can be a value of @ref ETH_Transmit_Store_Forward */</span>

  uint32_t             ETH_TransmitThresholdControl;    <span class="hljs-comment">/*!&lt; Selects or not the Transmit Threshold Control This parameter can be a value of @ref ETH_Transmit_Threshold_Control */</span>

  uint32_t             ETH_ForwardErrorFrames;          <span class="hljs-comment">/*!&lt; Selects or not the forward to the DMA of erroneous frames This parameter can be a value of @ref ETH_Forward_Error_Frames */</span>

  uint32_t             ETH_ForwardUndersizedGoodFrames; <span class="hljs-comment">/*!&lt; Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error and length less than 64 bytes) including pad-bytes and CRC) This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */</span>

  uint32_t             ETH_ReceiveThresholdControl;     <span class="hljs-comment">/*!&lt; Selects the threshold level of the Receive FIFO This parameter can be a value of @ref ETH_Receive_Threshold_Control */</span>

  uint32_t             ETH_SecondFrameOperate;          <span class="hljs-comment">/*!&lt; Selects or not the Operate on second frame mode, which allows the DMA to process a second frame of Transmit data even before obtaining the status for the first frame. This parameter can be a value of @ref ETH_Second_Frame_Operate */</span>

  uint32_t             ETH_AddressAlignedBeats;         <span class="hljs-comment">/*!&lt; Enables or disables the Address Aligned Beats This parameter can be a value of @ref ETH_Address_Aligned_Beats */</span>

  uint32_t             ETH_FixedBurst;                  <span class="hljs-comment">/*!&lt; Enables or disables the AHB Master interface fixed burst transfers This parameter can be a value of @ref ETH_Fixed_Burst */</span>

  uint32_t             ETH_RxDMABurstLength;            <span class="hljs-comment">/*!&lt; Indicates the maximum number of beats to be transferred in one Rx DMA transaction This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */</span>

  uint32_t             ETH_TxDMABurstLength;            <span class="hljs-comment">/*!&lt; Indicates sthe maximum number of beats to be transferred in one Tx DMA transaction This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */</span>

  uint32_t             ETH_DescriptorSkipLength;        <span class="hljs-comment">/*!&lt; Specifies the number of word to skip between two unchained descriptors (Ring mode) */</span>

  uint32_t             ETH_DMAArbitration;              <span class="hljs-comment">/*!&lt; Selects the DMA Tx/Rx arbitration This parameter can be a value of @ref ETH_DMA_Arbitration */</span>
}ETH_InitTypeDef;

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> DMA descriptors types */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH DMA Desciptors data structure definition */</span>
typedef struct  {
  uint32_t   Status;                <span class="hljs-comment">/*!&lt; Status */</span>
  uint32_t   ControlBufferSize;     <span class="hljs-comment">/*!&lt; Control and Buffer1, Buffer2 lengths */</span>
  uint32_t   Buffer1Addr;           <span class="hljs-comment">/*!&lt; Buffer1 address pointer */</span>
  uint32_t   Buffer2NextDescAddr;   <span class="hljs-comment">/*!&lt; Buffer2 or next descriptor address pointer */</span>
} ETH_DMADESCTypeDef;

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Exported_Constants * @{ */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH Frames defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ENET_Buffers_setting * @{ */</span>
#define ETH_MAX_PACKET_SIZE    <span class="hljs-number">1520</span>    <span class="hljs-comment">/*!&lt; ETH_HEADER + ETH_EXTRA + MAX_ETH_PAYLOAD + ETH_CRC */</span>
#define ETH_HEADER               <span class="hljs-number">14</span>    <span class="hljs-comment">/*!&lt; 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */</span>
#define ETH_CRC                   <span class="hljs-number">4</span>    <span class="hljs-comment">/*!&lt; Ethernet CRC */</span>
#define ETH_EXTRA                 <span class="hljs-number">2</span>    <span class="hljs-comment">/*!&lt; Extra bytes in some cases */</span>
#define VLAN_TAG                  <span class="hljs-number">4</span>    <span class="hljs-comment">/*!&lt; optional 802.1q VLAN Tag */</span>
#define MIN_ETH_PAYLOAD          <span class="hljs-number">46</span>    <span class="hljs-comment">/*!&lt; Minimum Ethernet payload size */</span>
#define MAX_ETH_PAYLOAD        <span class="hljs-number">1500</span>    <span class="hljs-comment">/*!&lt; Maximum Ethernet payload size */</span>
#define JUMBO_FRAME_PAYLOAD    <span class="hljs-number">9000</span>    <span class="hljs-comment">/*!&lt; Jumbo frame payload size */</span>

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet DMA descriptors registers bits definition */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @code</span> DMA Tx Desciptor ----------------------------------------------------------------------------------------------- TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] | ----------------------------------------------------------------------------------------------- TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] | ----------------------------------------------------------------------------------------------- TDES2 | Buffer1 Address [31:0] | ----------------------------------------------------------------------------------------------- TDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | -----------------------------------------------------------------------------------------------<span class="hljs-javadoctag"> @endcode</span> */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of TDES0 register: DMA Tx descriptor status register */</span>
#define ETH_DMATxDesc_OWN                     ((uint32_t)<span class="hljs-number">0x80000000</span>)  <span class="hljs-comment">/*!&lt; OWN bit: descriptor is owned by DMA engine */</span>
#define ETH_DMATxDesc_IC                      ((uint32_t)<span class="hljs-number">0x40000000</span>)  <span class="hljs-comment">/*!&lt; Interrupt on Completion */</span>
#define ETH_DMATxDesc_LS                      ((uint32_t)<span class="hljs-number">0x20000000</span>)  <span class="hljs-comment">/*!&lt; Last Segment */</span>
#define ETH_DMATxDesc_FS                      ((uint32_t)<span class="hljs-number">0x10000000</span>)  <span class="hljs-comment">/*!&lt; First Segment */</span>
#define ETH_DMATxDesc_DC                      ((uint32_t)<span class="hljs-number">0x08000000</span>)  <span class="hljs-comment">/*!&lt; Disable CRC */</span>
#define ETH_DMATxDesc_DP                      ((uint32_t)<span class="hljs-number">0x04000000</span>)  <span class="hljs-comment">/*!&lt; Disable Padding */</span>
#define ETH_DMATxDesc_TTSE                    ((uint32_t)<span class="hljs-number">0x02000000</span>)  <span class="hljs-comment">/*!&lt; Transmit Time Stamp Enable */</span>
#define ETH_DMATxDesc_CIC                     ((uint32_t)<span class="hljs-number">0x00C00000</span>)  <span class="hljs-comment">/*!&lt; Checksum Insertion Control: 4 cases */</span>
#define ETH_DMATxDesc_CIC_ByPass              ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Do Nothing: Checksum Engine is bypassed */</span>
#define ETH_DMATxDesc_CIC_IPV4Header          ((uint32_t)<span class="hljs-number">0x00400000</span>)  <span class="hljs-comment">/*!&lt; IPV4 header Checksum Insertion */</span>
#define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment  ((uint32_t)<span class="hljs-number">0x00800000</span>)  <span class="hljs-comment">/*!&lt; TCP/UDP/ICMP Checksum Insertion calculated over segment only */</span>
#define ETH_DMATxDesc_CIC_TCPUDPICMP_Full     ((uint32_t)<span class="hljs-number">0x00C00000</span>)  <span class="hljs-comment">/*!&lt; TCP/UDP/ICMP Checksum Insertion fully calculated */</span>
#define ETH_DMATxDesc_TER                     ((uint32_t)<span class="hljs-number">0x00200000</span>)  <span class="hljs-comment">/*!&lt; Transmit End of Ring */</span>
#define ETH_DMATxDesc_TCH                     ((uint32_t)<span class="hljs-number">0x00100000</span>)  <span class="hljs-comment">/*!&lt; Second Address Chained */</span>
#define ETH_DMATxDesc_TTSS                    ((uint32_t)<span class="hljs-number">0x00020000</span>)  <span class="hljs-comment">/*!&lt; Tx Time Stamp Status */</span>
#define ETH_DMATxDesc_IHE                     ((uint32_t)<span class="hljs-number">0x00010000</span>)  <span class="hljs-comment">/*!&lt; IP Header Error */</span>
#define ETH_DMATxDesc_ES                      ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */</span>
#define ETH_DMATxDesc_JT                      ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; Jabber Timeout */</span>
#define ETH_DMATxDesc_FF                      ((uint32_t)<span class="hljs-number">0x00002000</span>)  <span class="hljs-comment">/*!&lt; Frame Flushed: DMA/MTL flushed the frame due to SW flush */</span>
#define ETH_DMATxDesc_PCE                     ((uint32_t)<span class="hljs-number">0x00001000</span>)  <span class="hljs-comment">/*!&lt; Payload Checksum Error */</span>
#define ETH_DMATxDesc_LCA                     ((uint32_t)<span class="hljs-number">0x00000800</span>)  <span class="hljs-comment">/*!&lt; Loss of Carrier: carrier lost during tramsmission */</span>
#define ETH_DMATxDesc_NC                      ((uint32_t)<span class="hljs-number">0x00000400</span>)  <span class="hljs-comment">/*!&lt; No Carrier: no carrier signal from the tranceiver */</span>
#define ETH_DMATxDesc_LCO                     ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; Late Collision: transmission aborted due to collision */</span>
#define ETH_DMATxDesc_EC                      ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; Excessive Collision: transmission aborted after 16 collisions */</span>
#define ETH_DMATxDesc_VF                      ((uint32_t)<span class="hljs-number">0x00000080</span>)  <span class="hljs-comment">/*!&lt; VLAN Frame */</span>
#define ETH_DMATxDesc_CC                      ((uint32_t)<span class="hljs-number">0x00000078</span>)  <span class="hljs-comment">/*!&lt; Collision Count */</span>
#define ETH_DMATxDesc_ED                      ((uint32_t)<span class="hljs-number">0x00000004</span>)  <span class="hljs-comment">/*!&lt; Excessive Deferral */</span>
#define ETH_DMATxDesc_UF                      ((uint32_t)<span class="hljs-number">0x00000002</span>)  <span class="hljs-comment">/*!&lt; Underflow Error: late data arrival from the memory */</span>
#define ETH_DMATxDesc_DB                      ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; Deferred Bit */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of TDES1 register */</span>
#define ETH_DMATxDesc_TBS2  ((uint32_t)<span class="hljs-number">0x1FFF0000</span>)  <span class="hljs-comment">/*!&lt; Transmit Buffer2 Size */</span>
#define ETH_DMATxDesc_TBS1  ((uint32_t)<span class="hljs-number">0x00001FFF</span>)  <span class="hljs-comment">/*!&lt; Transmit Buffer1 Size */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of TDES2 register */</span>
#define ETH_DMATxDesc_B1AP  ((uint32_t)<span class="hljs-number">0xFFFFFFFF</span>)  <span class="hljs-comment">/*!&lt; Buffer1 Address Pointer */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of TDES3 register */</span>
#define ETH_DMATxDesc_B2AP  ((uint32_t)<span class="hljs-number">0xFFFFFFFF</span>)  <span class="hljs-comment">/*!&lt; Buffer2 Address Pointer */</span>

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> DMA_Rx_descriptor * @{ */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @code</span> DMA Rx Desciptor -------------------------------------------------------------------------------------------------------------------- RDES0 | OWN(31) | Status [30:0] | --------------------------------------------------------------------------------------------------------------------- RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] | --------------------------------------------------------------------------------------------------------------------- RDES2 | Buffer1 Address [31:0] | --------------------------------------------------------------------------------------------------------------------- RDES3 | Buffer2 Address [31:0] / Next Desciptor Address [31:0] | ---------------------------------------------------------------------------------------------------------------------<span class="hljs-javadoctag"> @endcode</span> */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of RDES0 register: DMA Rx descriptor status register */</span>
#define ETH_DMARxDesc_OWN         ((uint32_t)<span class="hljs-number">0x80000000</span>)  <span class="hljs-comment">/*!&lt; OWN bit: descriptor is owned by DMA engine */</span>
#define ETH_DMARxDesc_AFM         ((uint32_t)<span class="hljs-number">0x40000000</span>)  <span class="hljs-comment">/*!&lt; DA Filter Fail for the rx frame */</span>
#define ETH_DMARxDesc_FL          ((uint32_t)<span class="hljs-number">0x3FFF0000</span>)  <span class="hljs-comment">/*!&lt; Receive descriptor frame length */</span>
#define ETH_DMARxDesc_ES          ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */</span>
#define ETH_DMARxDesc_DE          ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; Desciptor error: no more descriptors for receive frame */</span>
#define ETH_DMARxDesc_SAF         ((uint32_t)<span class="hljs-number">0x00002000</span>)  <span class="hljs-comment">/*!&lt; SA Filter Fail for the received frame */</span>
#define ETH_DMARxDesc_LE          ((uint32_t)<span class="hljs-number">0x00001000</span>)  <span class="hljs-comment">/*!&lt; Frame size not matching with length field */</span>
#define ETH_DMARxDesc_OE          ((uint32_t)<span class="hljs-number">0x00000800</span>)  <span class="hljs-comment">/*!&lt; Overflow Error: Frame was damaged due to buffer overflow */</span>
#define ETH_DMARxDesc_VLAN        ((uint32_t)<span class="hljs-number">0x00000400</span>)  <span class="hljs-comment">/*!&lt; VLAN Tag: received frame is a VLAN frame */</span>
#define ETH_DMARxDesc_FS          ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; First descriptor of the frame */</span>
#define ETH_DMARxDesc_LS          ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; Last descriptor of the frame */</span>
#define ETH_DMARxDesc_IPV4HCE     ((uint32_t)<span class="hljs-number">0x00000080</span>)  <span class="hljs-comment">/*!&lt; IPC Checksum Error: Rx Ipv4 header checksum error */</span>
#define ETH_DMARxDesc_LC          ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; Late collision occurred during reception */</span>
#define ETH_DMARxDesc_FT          ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Frame type - Ethernet, otherwise 802.3 */</span>
#define ETH_DMARxDesc_RWT         ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; Receive Watchdog Timeout: watchdog timer expired during reception */</span>
#define ETH_DMARxDesc_RE          ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; Receive error: error reported by MII interface */</span>
#define ETH_DMARxDesc_DBE         ((uint32_t)<span class="hljs-number">0x00000004</span>)  <span class="hljs-comment">/*!&lt; Dribble bit error: frame contains non int multiple of 8 bits */</span>
#define ETH_DMARxDesc_CE          ((uint32_t)<span class="hljs-number">0x00000002</span>)  <span class="hljs-comment">/*!&lt; CRC error */</span>
#define ETH_DMARxDesc_MAMPCE      ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of RDES1 register */</span>
#define ETH_DMARxDesc_DIC   ((uint32_t)<span class="hljs-number">0x80000000</span>)  <span class="hljs-comment">/*!&lt; Disable Interrupt on Completion */</span>
#define ETH_DMARxDesc_RBS2  ((uint32_t)<span class="hljs-number">0x1FFF0000</span>)  <span class="hljs-comment">/*!&lt; Receive Buffer2 Size */</span>
#define ETH_DMARxDesc_RER   ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; Receive End of Ring */</span>
#define ETH_DMARxDesc_RCH   ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; Second Address Chained */</span>
#define ETH_DMARxDesc_RBS1  ((uint32_t)<span class="hljs-number">0x00001FFF</span>)  <span class="hljs-comment">/*!&lt; Receive Buffer1 Size */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of RDES2 register */</span>
#define ETH_DMARxDesc_B1AP  ((uint32_t)<span class="hljs-number">0xFFFFFFFF</span>)  <span class="hljs-comment">/*!&lt; Buffer1 Address Pointer */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Bit definition of RDES3 register */</span>
#define ETH_DMARxDesc_B2AP  ((uint32_t)<span class="hljs-number">0xFFFFFFFF</span>)  <span class="hljs-comment">/*!&lt; Buffer2 Address Pointer */</span>

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Desciption of common PHY registers */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_Read_write_Timeouts * @{ */</span>
#define PHY_READ_TO                     ((uint32_t)<span class="hljs-number">0x0004FFFF</span>)
#define PHY_WRITE_TO                    ((uint32_t)<span class="hljs-number">0x0004FFFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_Reset_Delay * @{ */</span>
#define PHY_ResetDelay                  ((uint32_t)<span class="hljs-number">0x000FFFFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_Config_Delay * @{ */</span>
#define PHY_ConfigDelay                 ((uint32_t)<span class="hljs-number">0x00FFFFFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_Register_address * @{ */</span>
#define PHY_BCR                          <span class="hljs-number">0</span>          <span class="hljs-comment">/*!&lt; Tranceiver Basic Control Register */</span>
#define PHY_BSR                          <span class="hljs-number">1</span>          <span class="hljs-comment">/*!&lt; Tranceiver Basic Status Register */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_basic_Control_register * @{ */</span>
#define PHY_Reset                       ((u16)<span class="hljs-number">0x8000</span>)      <span class="hljs-comment">/*!&lt; PHY Reset */</span>
#define PHY_Loopback                    ((u16)<span class="hljs-number">0x4000</span>)      <span class="hljs-comment">/*!&lt; Select loop-back mode */</span>
#define PHY_FULLDUPLEX_100M             ((u16)<span class="hljs-number">0x2100</span>)      <span class="hljs-comment">/*!&lt; Set the full-duplex mode at 100 Mb/s */</span>
#define PHY_HALFDUPLEX_100M             ((u16)<span class="hljs-number">0x2000</span>)      <span class="hljs-comment">/*!&lt; Set the half-duplex mode at 100 Mb/s */</span>
#define PHY_FULLDUPLEX_10M              ((u16)<span class="hljs-number">0x0100</span>)      <span class="hljs-comment">/*!&lt; Set the full-duplex mode at 10 Mb/s */</span>
#define PHY_HALFDUPLEX_10M              ((u16)<span class="hljs-number">0x0000</span>)      <span class="hljs-comment">/*!&lt; Set the half-duplex mode at 10 Mb/s */</span>
#define PHY_AutoNegotiation             ((u16)<span class="hljs-number">0x1000</span>)      <span class="hljs-comment">/*!&lt; Enable auto-negotiation function */</span>
#define PHY_Restart_AutoNegotiation     ((u16)<span class="hljs-number">0x0200</span>)      <span class="hljs-comment">/*!&lt; Restart auto-negotiation function */</span>
#define PHY_Powerdown                   ((u16)<span class="hljs-number">0x0800</span>)      <span class="hljs-comment">/*!&lt; Select the power down mode */</span>
#define PHY_Isolate                     ((u16)<span class="hljs-number">0x0400</span>)      <span class="hljs-comment">/*!&lt; Isolate PHY from MII */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_basic_status_register * @{ */</span>
#define PHY_AutoNego_Complete           ((u16)<span class="hljs-number">0x0020</span>)      <span class="hljs-comment">/*!&lt; Auto-Negotioation process completed */</span>
#define PHY_Linked_Status               ((u16)<span class="hljs-number">0x0004</span>)      <span class="hljs-comment">/*!&lt; Valid link established */</span>
#define PHY_Jabber_detection            ((u16)<span class="hljs-number">0x0002</span>)      <span class="hljs-comment">/*!&lt; Jabber condition detected */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> PHY_status_register * @{ */</span>
<span class="hljs-comment">/* The PHY status register value change from a PHY to another so the user have to update this value depending on the used external PHY */</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> For LAN8700 */</span>
<span class="hljs-comment">//#define PHY_SR 31 /*!&lt; Tranceiver Status Register */</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> For DP83848 */</span>
#define PHY_SR                           <span class="hljs-number">16</span>     <span class="hljs-comment">/*!&lt; Tranceiver Status Register */</span>

<span class="hljs-comment">/* The Speed and Duplex mask values change from a PHY to another so the user have to update this value depending on the used external PHY */</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> For LAN8700 */</span>
<span class="hljs-comment">//#define PHY_Speed_Status ((u16)0x0004) /*!&lt; Configured information of Speed: 10Mbps */</span>
<span class="hljs-comment">//#define PHY_Duplex_Status ((u16)0x0010) /*!&lt; Configured information of Duplex: Full-duplex */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> For DP83848 */</span>
#define PHY_Speed_Status            ((u16)<span class="hljs-number">0x0002</span>)    <span class="hljs-comment">/*!&lt; Configured information of Speed: 10Mbps */</span>
#define PHY_Duplex_Status           ((u16)<span class="hljs-number">0x0004</span>)    <span class="hljs-comment">/*!&lt; Configured information of Duplex: Full-duplex */</span>
#define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) &lt;= <span class="hljs-number">0x1F</span>)
#define IS_ETH_PHY_REG(REG)         (REG &lt;= <span class="hljs-number">0x1F</span>)

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> MAC defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_AutoNegotiation * @{ */</span>
#define ETH_AutoNegotiation_Enable     ((uint32_t)<span class="hljs-number">0x00000001</span>)
#define ETH_AutoNegotiation_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \
                                     ((CMD) == ETH_AutoNegotiation_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_watchdog * @{ */</span>
#define ETH_Watchdog_Enable       ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_Watchdog_Disable      ((uint32_t)<span class="hljs-number">0x00800000</span>)
#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \
                              ((CMD) == ETH_Watchdog_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Jabber * @{ */</span>
#define ETH_Jabber_Enable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_Jabber_Disable   ((uint32_t)<span class="hljs-number">0x00400000</span>)
#define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \
                            ((CMD) == ETH_Jabber_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Inter_Frame_Gap * @{ */</span>
#define ETH_InterFrameGap_96Bit   ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 96Bit */</span>
#define ETH_InterFrameGap_88Bit   ((uint32_t)<span class="hljs-number">0x00020000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 88Bit */</span>
#define ETH_InterFrameGap_80Bit   ((uint32_t)<span class="hljs-number">0x00040000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 80Bit */</span>
#define ETH_InterFrameGap_72Bit   ((uint32_t)<span class="hljs-number">0x00060000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 72Bit */</span>
#define ETH_InterFrameGap_64Bit   ((uint32_t)<span class="hljs-number">0x00080000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 64Bit */</span>
#define ETH_InterFrameGap_56Bit   ((uint32_t)<span class="hljs-number">0x000A0000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 56Bit */</span>
#define ETH_InterFrameGap_48Bit   ((uint32_t)<span class="hljs-number">0x000C0000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 48Bit */</span>
#define ETH_InterFrameGap_40Bit   ((uint32_t)<span class="hljs-number">0x000E0000</span>)  <span class="hljs-comment">/*!&lt; minimum IFG between frames during transmission is 40Bit */</span>
#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \
                                     ((GAP) == ETH_InterFrameGap_88Bit) || \
                                     ((GAP) == ETH_InterFrameGap_80Bit) || \
                                     ((GAP) == ETH_InterFrameGap_72Bit) || \
                                     ((GAP) == ETH_InterFrameGap_64Bit) || \
                                     ((GAP) == ETH_InterFrameGap_56Bit) || \
                                     ((GAP) == ETH_InterFrameGap_48Bit) || \
                                     ((GAP) == ETH_InterFrameGap_40Bit))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Carrier_Sense * @{ */</span>
#define ETH_CarrierSense_Enable   ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_CarrierSense_Disable  ((uint32_t)<span class="hljs-number">0x00010000</span>)
#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \
                                   ((CMD) == ETH_CarrierSense_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Speed * @{ */</span>
#define ETH_Speed_10M        ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_Speed_100M       ((uint32_t)<span class="hljs-number">0x00004000</span>)
#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \
                             ((SPEED) == ETH_Speed_100M))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Receive_Own * @{ */</span>
#define ETH_ReceiveOwn_Enable     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_ReceiveOwn_Disable    ((uint32_t)<span class="hljs-number">0x00002000</span>)
#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \
                                 ((CMD) == ETH_ReceiveOwn_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Loop_Back_Mode * @{ */</span>
#define ETH_LoopbackMode_Enable        ((uint32_t)<span class="hljs-number">0x00001000</span>)
#define ETH_LoopbackMode_Disable       ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \
                                   ((CMD) == ETH_LoopbackMode_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Duplex_Mode * @{ */</span>
#define ETH_Mode_FullDuplex       ((uint32_t)<span class="hljs-number">0x00000800</span>)
#define ETH_Mode_HalfDuplex       ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \
                                  ((MODE) == ETH_Mode_HalfDuplex))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Checksum_Offload * @{ */</span>
#define ETH_ChecksumOffload_Enable     ((uint32_t)<span class="hljs-number">0x00000400</span>)
#define ETH_ChecksumOffload_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \
                                      ((CMD) == ETH_ChecksumOffload_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Retry_Transmission * @{ */</span>
#define ETH_RetryTransmission_Enable   ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_RetryTransmission_Disable  ((uint32_t)<span class="hljs-number">0x00000200</span>)
#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \
                                        ((CMD) == ETH_RetryTransmission_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Automatic_Pad_CRC_Strip * @{ */</span>
#define ETH_AutomaticPadCRCStrip_Enable     ((uint32_t)<span class="hljs-number">0x00000080</span>)
#define ETH_AutomaticPadCRCStrip_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \
                                            ((CMD) == ETH_AutomaticPadCRCStrip_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Back_Off_Limit * @{ */</span>
#define ETH_BackOffLimit_10  ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_BackOffLimit_8   ((uint32_t)<span class="hljs-number">0x00000020</span>)
#define ETH_BackOffLimit_4   ((uint32_t)<span class="hljs-number">0x00000040</span>)
#define ETH_BackOffLimit_1   ((uint32_t)<span class="hljs-number">0x00000060</span>)
#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \
                                     ((LIMIT) == ETH_BackOffLimit_8) || \
                                     ((LIMIT) == ETH_BackOffLimit_4) || \
                                     ((LIMIT) == ETH_BackOffLimit_1))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Deferral_Check * @{ */</span>
#define ETH_DeferralCheck_Enable       ((uint32_t)<span class="hljs-number">0x00000010</span>)
#define ETH_DeferralCheck_Disable      ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \
                                    ((CMD) == ETH_DeferralCheck_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Receive_All * @{ */</span>
#define ETH_ReceiveAll_Enable     ((uint32_t)<span class="hljs-number">0x80000000</span>)
#define ETH_ReceiveAll_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \
                                 ((CMD) == ETH_ReceiveAll_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Source_Addr_Filter * @{ */</span>
#define ETH_SourceAddrFilter_Normal_Enable       ((uint32_t)<span class="hljs-number">0x00000200</span>)
#define ETH_SourceAddrFilter_Inverse_Enable      ((uint32_t)<span class="hljs-number">0x00000300</span>)
#define ETH_SourceAddrFilter_Disable             ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \
                                        ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \
                                        ((CMD) == ETH_SourceAddrFilter_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Pass_Control_Frames * @{ */</span>
#define ETH_PassControlFrames_BlockAll                ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; MAC filters all control frames from reaching the application */</span>
#define ETH_PassControlFrames_ForwardAll              ((uint32_t)<span class="hljs-number">0x00000080</span>)  <span class="hljs-comment">/*!&lt; MAC forwards all control frames to application even if they fail the Address Filter */</span>
#define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)<span class="hljs-number">0x000000C0</span>)  <span class="hljs-comment">/*!&lt; MAC forwards control frames that pass the Address Filter. */</span>
#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \
                                     ((PASS) == ETH_PassControlFrames_ForwardAll) || \
                                     ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Broadcast_Frames_Reception * @{ */</span>
#define ETH_BroadcastFramesReception_Enable      ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_BroadcastFramesReception_Disable     ((uint32_t)<span class="hljs-number">0x00000020</span>)
#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \
                                                ((CMD) == ETH_BroadcastFramesReception_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Destination_Addr_Filter * @{ */</span>
#define ETH_DestinationAddrFilter_Normal    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_DestinationAddrFilter_Inverse   ((uint32_t)<span class="hljs-number">0x00000008</span>)
#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \
                                                ((FILTER) == ETH_DestinationAddrFilter_Inverse))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Promiscuous_Mode * @{ */</span>
#define ETH_PromiscuousMode_Enable     ((uint32_t)<span class="hljs-number">0x00000001</span>)
#define ETH_PromiscuousMode_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \
                                      ((CMD) == ETH_PromiscuousMode_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Multicast_Frames_Filter * @{ */</span>
#define ETH_MulticastFramesFilter_PerfectHashTable    ((uint32_t)<span class="hljs-number">0x00000404</span>)
#define ETH_MulticastFramesFilter_HashTable           ((uint32_t)<span class="hljs-number">0x00000004</span>)
#define ETH_MulticastFramesFilter_Perfect             ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_MulticastFramesFilter_None                ((uint32_t)<span class="hljs-number">0x00000010</span>)
#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \
                                                ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \
                                                ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \
                                                ((FILTER) == ETH_MulticastFramesFilter_None))


<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Unicast_Frames_Filter * @{ */</span>
#define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)<span class="hljs-number">0x00000402</span>)
#define ETH_UnicastFramesFilter_HashTable        ((uint32_t)<span class="hljs-number">0x00000002</span>)
#define ETH_UnicastFramesFilter_Perfect          ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \
                                              ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \
                                              ((FILTER) == ETH_UnicastFramesFilter_Perfect))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Pause_Time * @{ */</span>
#define IS_ETH_PAUSE_TIME(TIME) ((TIME) &lt;= <span class="hljs-number">0xFFFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Zero_Quanta_Pause * @{ */</span>
#define ETH_ZeroQuantaPause_Enable     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_ZeroQuantaPause_Disable    ((uint32_t)<span class="hljs-number">0x00000080</span>)
#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZeroQuantaPause_Enable) || \
                                        ((CMD) == ETH_ZeroQuantaPause_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Pause_Low_Threshold * @{ */</span>
#define ETH_PauseLowThreshold_Minus4        ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Pause time minus 4 slot times */</span>
#define ETH_PauseLowThreshold_Minus28       ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; Pause time minus 28 slot times */</span>
#define ETH_PauseLowThreshold_Minus144      ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Pause time minus 144 slot times */</span>
#define ETH_PauseLowThreshold_Minus256      ((uint32_t)<span class="hljs-number">0x00000030</span>)  <span class="hljs-comment">/*!&lt; Pause time minus 256 slot times */</span>
#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \
                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \
                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \
                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus256))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Unicast_Pause_Frame_Detect * @{ */</span>
#define ETH_UnicastPauseFrameDetect_Enable  ((uint32_t)<span class="hljs-number">0x00000008</span>)
#define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \
                                                ((CMD) == ETH_UnicastPauseFrameDetect_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Receive_Flow_Control * @{ */</span>
#define ETH_ReceiveFlowControl_Enable       ((uint32_t)<span class="hljs-number">0x00000004</span>)
#define ETH_ReceiveFlowControl_Disable      ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \
                                         ((CMD) == ETH_ReceiveFlowControl_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Transmit_Flow_Control * @{ */</span>
#define ETH_TransmitFlowControl_Enable      ((uint32_t)<span class="hljs-number">0x00000002</span>)
#define ETH_TransmitFlowControl_Disable     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \
                                          ((CMD) == ETH_TransmitFlowControl_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_VLAN_Tag_Comparison * @{ */</span>
#define ETH_VLANTagComparison_12Bit    ((uint32_t)<span class="hljs-number">0x00010000</span>)
#define ETH_VLANTagComparison_16Bit    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \
                                                ((COMPARISON) == ETH_VLANTagComparison_16Bit))
#define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) &lt;= <span class="hljs-number">0xFFFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MAC_Flags * @{ */</span>
#define ETH_MAC_FLAG_TST     ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; Time stamp trigger flag (on MAC) */</span>
#define ETH_MAC_FLAG_MMCT    ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; MMC transmit flag */</span>
#define ETH_MAC_FLAG_MMCR    ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; MMC receive flag */</span>
#define ETH_MAC_FLAG_MMC     ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; MMC flag (on MAC) */</span>
#define ETH_MAC_FLAG_PMT     ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; PMT flag (on MAC) */</span>
#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \
                                   ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \
                                   ((FLAG) == ETH_MAC_FLAG_PMT))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MAC_Interrupts * @{ */</span>
#define ETH_MAC_IT_TST       ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; Time stamp trigger interrupt (on MAC) */</span>
#define ETH_MAC_IT_MMCT      ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; MMC transmit interrupt */</span>
#define ETH_MAC_IT_MMCR      ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; MMC receive interrupt */</span>
#define ETH_MAC_IT_MMC       ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; MMC interrupt (on MAC) */</span>
#define ETH_MAC_IT_PMT       ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; PMT interrupt (on MAC) */</span>
#define IS_ETH_MAC_IT(IT) ((((IT) &amp; (uint32_t)<span class="hljs-number">0xFFFFFDF7</span>) == <span class="hljs-number">0x00</span>) &amp;&amp; ((IT) != <span class="hljs-number">0x00</span>))
#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \
                               ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \
                               ((IT) == ETH_MAC_IT_PMT))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MAC_addresses * @{ */</span>
#define ETH_MAC_Address0     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_MAC_Address1     ((uint32_t)<span class="hljs-number">0x00000008</span>)
#define ETH_MAC_Address2     ((uint32_t)<span class="hljs-number">0x00000010</span>)
#define ETH_MAC_Address3     ((uint32_t)<span class="hljs-number">0x00000018</span>)
#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \
                                         ((ADDRESS) == ETH_MAC_Address1) || \
                                         ((ADDRESS) == ETH_MAC_Address2) || \
                                         ((ADDRESS) == ETH_MAC_Address3))
#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \
                                        ((ADDRESS) == ETH_MAC_Address2) || \
                                        ((ADDRESS) == ETH_MAC_Address3))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames * @{ */</span>
#define ETH_MAC_AddressFilter_SA       ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_MAC_AddressFilter_DA       ((uint32_t)<span class="hljs-number">0x00000008</span>)
#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \
                                           ((FILTER) == ETH_MAC_AddressFilter_DA))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MAC_addresses_filter_Mask_bytes * @{ */</span>
#define ETH_MAC_AddressMask_Byte6      ((uint32_t)<span class="hljs-number">0x20000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address high reg bits [15:8] */</span>
#define ETH_MAC_AddressMask_Byte5      ((uint32_t)<span class="hljs-number">0x10000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address high reg bits [7:0] */</span>
#define ETH_MAC_AddressMask_Byte4      ((uint32_t)<span class="hljs-number">0x08000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address low reg bits [31:24] */</span>
#define ETH_MAC_AddressMask_Byte3      ((uint32_t)<span class="hljs-number">0x04000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address low reg bits [23:16] */</span>
#define ETH_MAC_AddressMask_Byte2      ((uint32_t)<span class="hljs-number">0x02000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address low reg bits [15:8] */</span>
#define ETH_MAC_AddressMask_Byte1      ((uint32_t)<span class="hljs-number">0x01000000</span>)  <span class="hljs-comment">/*!&lt; Mask MAC Address low reg bits [70] */</span>
#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \
                                       ((MASK) == ETH_MAC_AddressMask_Byte5) || \
                                       ((MASK) == ETH_MAC_AddressMask_Byte4) || \
                                       ((MASK) == ETH_MAC_AddressMask_Byte3) || \
                                       ((MASK) == ETH_MAC_AddressMask_Byte2) || \
                                       ((MASK) == ETH_MAC_AddressMask_Byte1))

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet DMA Desciptors defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Tx_descriptor_flags * @{ */</span>
#define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \
                                         ((FLAG) == ETH_DMATxDesc_IC) || \
                                         ((FLAG) == ETH_DMATxDesc_LS) || \
                                         ((FLAG) == ETH_DMATxDesc_FS) || \
                                         ((FLAG) == ETH_DMATxDesc_DC) || \
                                         ((FLAG) == ETH_DMATxDesc_DP) || \
                                         ((FLAG) == ETH_DMATxDesc_TTSE) || \
                                         ((FLAG) == ETH_DMATxDesc_TER) || \
                                         ((FLAG) == ETH_DMATxDesc_TCH) || \
                                         ((FLAG) == ETH_DMATxDesc_TTSS) || \
                                         ((FLAG) == ETH_DMATxDesc_IHE) || \
                                         ((FLAG) == ETH_DMATxDesc_ES) || \
                                         ((FLAG) == ETH_DMATxDesc_JT) || \
                                         ((FLAG) == ETH_DMATxDesc_FF) || \
                                         ((FLAG) == ETH_DMATxDesc_PCE) || \
                                         ((FLAG) == ETH_DMATxDesc_LCA) || \
                                         ((FLAG) == ETH_DMATxDesc_NC) || \
                                         ((FLAG) == ETH_DMATxDesc_LCO) || \
                                         ((FLAG) == ETH_DMATxDesc_EC) || \
                                         ((FLAG) == ETH_DMATxDesc_VF) || \
                                         ((FLAG) == ETH_DMATxDesc_CC) || \
                                         ((FLAG) == ETH_DMATxDesc_ED) || \
                                         ((FLAG) == ETH_DMATxDesc_UF) || \
                                         ((FLAG) == ETH_DMATxDesc_DB))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Tx_descriptor_segment * @{ */</span>
#define ETH_DMATxDesc_LastSegment      ((uint32_t)<span class="hljs-number">0x40000000</span>)  <span class="hljs-comment">/*!&lt; Last Segment */</span>
#define ETH_DMATxDesc_FirstSegment     ((uint32_t)<span class="hljs-number">0x20000000</span>)  <span class="hljs-comment">/*!&lt; First Segment */</span>
#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \
                                            ((SEGMENT) == ETH_DMATxDesc_FirstSegment))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Tx_descriptor_Checksum_Insertion_Control * @{ */</span>
#define ETH_DMATxDesc_ChecksumByPass             ((uint32_t)<span class="hljs-number">0x00000000</span>)   <span class="hljs-comment">/*!&lt; Checksum engine bypass */</span>
#define ETH_DMATxDesc_ChecksumIPV4Header         ((uint32_t)<span class="hljs-number">0x00400000</span>)   <span class="hljs-comment">/*!&lt; IPv4 header checksum insertion */</span>
#define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment  ((uint32_t)<span class="hljs-number">0x00800000</span>)   <span class="hljs-comment">/*!&lt; TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */</span>
#define ETH_DMATxDesc_ChecksumTCPUDPICMPFull     ((uint32_t)<span class="hljs-number">0x00C00000</span>)   <span class="hljs-comment">/*!&lt; TCP/UDP/ICMP checksum fully in hardware including pseudo header */</span>
#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \
                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \
                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \
                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull))
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH DMA Tx Desciptor buffer size */</span>
#define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) &lt;= <span class="hljs-number">0x1FFF</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Rx_descriptor_flags * @{ */</span>
#define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \
                                         ((FLAG) == ETH_DMARxDesc_AFM) || \
                                         ((FLAG) == ETH_DMARxDesc_ES) || \
                                         ((FLAG) == ETH_DMARxDesc_DE) || \
                                         ((FLAG) == ETH_DMARxDesc_SAF) || \
                                         ((FLAG) == ETH_DMARxDesc_LE) || \
                                         ((FLAG) == ETH_DMARxDesc_OE) || \
                                         ((FLAG) == ETH_DMARxDesc_VLAN) || \
                                         ((FLAG) == ETH_DMARxDesc_FS) || \
                                         ((FLAG) == ETH_DMARxDesc_LS) || \
                                         ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \
                                         ((FLAG) == ETH_DMARxDesc_LC) || \
                                         ((FLAG) == ETH_DMARxDesc_FT) || \
                                         ((FLAG) == ETH_DMARxDesc_RWT) || \
                                         ((FLAG) == ETH_DMARxDesc_RE) || \
                                         ((FLAG) == ETH_DMARxDesc_DBE) || \
                                         ((FLAG) == ETH_DMARxDesc_CE) || \
                                         ((FLAG) == ETH_DMARxDesc_MAMPCE))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Rx_descriptor_buffers_ * @{ */</span>
#define ETH_DMARxDesc_Buffer1     ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; DMA Rx Desc Buffer1 */</span>
#define ETH_DMARxDesc_Buffer2     ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; DMA Rx Desc Buffer2 */</span>
#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \
                                          ((BUFFER) == ETH_DMARxDesc_Buffer2))

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet DMA defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Drop_TCP_IP_Checksum_Error_Frame * @{ */</span>
#define ETH_DropTCPIPChecksumErrorFrame_Enable   ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_DropTCPIPChecksumErrorFrame_Disable  ((uint32_t)<span class="hljs-number">0x04000000</span>)
#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \
                                               ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Receive_Store_Forward * @{ */</span>
#define ETH_ReceiveStoreForward_Enable      ((uint32_t)<span class="hljs-number">0x02000000</span>)
#define ETH_ReceiveStoreForward_Disable     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \
                                           ((CMD) == ETH_ReceiveStoreForward_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Flush_Received_Frame * @{ */</span>
#define ETH_FlushReceivedFrame_Enable       ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_FlushReceivedFrame_Disable      ((uint32_t)<span class="hljs-number">0x01000000</span>)
#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \
                                         ((CMD) == ETH_FlushReceivedFrame_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Transmit_Store_Forward * @{ */</span>
#define ETH_TransmitStoreForward_Enable     ((uint32_t)<span class="hljs-number">0x00200000</span>)
#define ETH_TransmitStoreForward_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \
                                            ((CMD) == ETH_TransmitStoreForward_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Transmit_Threshold_Control * @{ */</span>
#define ETH_TransmitThresholdControl_64Bytes     ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 64 Bytes */</span>
#define ETH_TransmitThresholdControl_128Bytes    ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 128 Bytes */</span>
#define ETH_TransmitThresholdControl_192Bytes    ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 192 Bytes */</span>
#define ETH_TransmitThresholdControl_256Bytes    ((uint32_t)<span class="hljs-number">0x0000C000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 256 Bytes */</span>
#define ETH_TransmitThresholdControl_40Bytes     ((uint32_t)<span class="hljs-number">0x00010000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 40 Bytes */</span>
#define ETH_TransmitThresholdControl_32Bytes     ((uint32_t)<span class="hljs-number">0x00014000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 32 Bytes */</span>
#define ETH_TransmitThresholdControl_24Bytes     ((uint32_t)<span class="hljs-number">0x00018000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 24 Bytes */</span>
#define ETH_TransmitThresholdControl_16Bytes     ((uint32_t)<span class="hljs-number">0x0001C000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Transmit FIFO is 16 Bytes */</span>
#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \
                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Forward_Error_Frames * @{ */</span>
#define ETH_ForwardErrorFrames_Enable       ((uint32_t)<span class="hljs-number">0x00000080</span>)
#define ETH_ForwardErrorFrames_Disable      ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \
                                          ((CMD) == ETH_ForwardErrorFrames_Disable))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Forward_Undersized_Good_Frames * @{ */</span>
#define ETH_ForwardUndersizedGoodFrames_Enable   ((uint32_t)<span class="hljs-number">0x00000040</span>)
#define ETH_ForwardUndersizedGoodFrames_Disable  ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \
                                                    ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Receive_Threshold_Control * @{ */</span>
#define ETH_ReceiveThresholdControl_64Bytes      ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Receive FIFO is 64 Bytes */</span>
#define ETH_ReceiveThresholdControl_32Bytes      ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Receive FIFO is 32 Bytes */</span>
#define ETH_ReceiveThresholdControl_96Bytes      ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Receive FIFO is 96 Bytes */</span>
#define ETH_ReceiveThresholdControl_128Bytes     ((uint32_t)<span class="hljs-number">0x00000018</span>)  <span class="hljs-comment">/*!&lt; threshold level of the MTL Receive FIFO is 128 Bytes */</span>
#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \
                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \
                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \
                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Second_Frame_Operate * @{ */</span>
#define ETH_SecondFrameOperate_Enable       ((uint32_t)<span class="hljs-number">0x00000004</span>)
#define ETH_SecondFrameOperate_Disable      ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \
                                          ((CMD) == ETH_SecondFrameOperate_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Address_Aligned_Beats * @{ */</span>
#define ETH_AddressAlignedBeats_Enable      ((uint32_t)<span class="hljs-number">0x02000000</span>)
#define ETH_AddressAlignedBeats_Disable     ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \
                                           ((CMD) == ETH_AddressAlignedBeats_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Fixed_Burst * @{ */</span>
#define ETH_FixedBurst_Enable     ((uint32_t)<span class="hljs-number">0x00010000</span>)
#define ETH_FixedBurst_Disable    ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \
                                 ((CMD) == ETH_FixedBurst_Disable))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Rx_DMA_Burst_Length * @{ */</span>
#define ETH_RxDMABurstLength_1Beat          ((uint32_t)<span class="hljs-number">0x00020000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 1 */</span>
#define ETH_RxDMABurstLength_2Beat          ((uint32_t)<span class="hljs-number">0x00040000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 2 */</span>
#define ETH_RxDMABurstLength_4Beat          ((uint32_t)<span class="hljs-number">0x00080000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */</span>
#define ETH_RxDMABurstLength_8Beat          ((uint32_t)<span class="hljs-number">0x00100000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */</span>
#define ETH_RxDMABurstLength_16Beat         ((uint32_t)<span class="hljs-number">0x00200000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */</span>
#define ETH_RxDMABurstLength_32Beat         ((uint32_t)<span class="hljs-number">0x00400000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */</span>
#define ETH_RxDMABurstLength_4xPBL_4Beat    ((uint32_t)<span class="hljs-number">0x01020000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 4 */</span>
#define ETH_RxDMABurstLength_4xPBL_8Beat    ((uint32_t)<span class="hljs-number">0x01040000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 8 */</span>
#define ETH_RxDMABurstLength_4xPBL_16Beat   ((uint32_t)<span class="hljs-number">0x01080000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 16 */</span>
#define ETH_RxDMABurstLength_4xPBL_32Beat   ((uint32_t)<span class="hljs-number">0x01100000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 32 */</span>
#define ETH_RxDMABurstLength_4xPBL_64Beat   ((uint32_t)<span class="hljs-number">0x01200000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 64 */</span>
#define ETH_RxDMABurstLength_4xPBL_128Beat  ((uint32_t)<span class="hljs-number">0x01400000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one RxDMA transaction is 128 */</span>
#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \
                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Tx_DMA_Burst_Length * @{ */</span>
#define ETH_TxDMABurstLength_1Beat          ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */</span>
#define ETH_TxDMABurstLength_2Beat          ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */</span>
#define ETH_TxDMABurstLength_4Beat          ((uint32_t)<span class="hljs-number">0x00000400</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */</span>
#define ETH_TxDMABurstLength_8Beat          ((uint32_t)<span class="hljs-number">0x00000800</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */</span>
#define ETH_TxDMABurstLength_16Beat         ((uint32_t)<span class="hljs-number">0x00001000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */</span>
#define ETH_TxDMABurstLength_32Beat         ((uint32_t)<span class="hljs-number">0x00002000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */</span>
#define ETH_TxDMABurstLength_4xPBL_4Beat    ((uint32_t)<span class="hljs-number">0x01000100</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */</span>
#define ETH_TxDMABurstLength_4xPBL_8Beat    ((uint32_t)<span class="hljs-number">0x01000200</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */</span>
#define ETH_TxDMABurstLength_4xPBL_16Beat   ((uint32_t)<span class="hljs-number">0x01000400</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */</span>
#define ETH_TxDMABurstLength_4xPBL_32Beat   ((uint32_t)<span class="hljs-number">0x01000800</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */</span>
#define ETH_TxDMABurstLength_4xPBL_64Beat   ((uint32_t)<span class="hljs-number">0x01001000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */</span>
#define ETH_TxDMABurstLength_4xPBL_128Beat  ((uint32_t)<span class="hljs-number">0x01002000</span>)  <span class="hljs-comment">/*!&lt; maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */</span>
#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \
                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat))
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH DMA Desciptor SkipLength */</span>
#define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) &lt;= <span class="hljs-number">0x1F</span>)

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Arbitration * @{ */</span>
#define ETH_DMAArbitration_RoundRobin_RxTx_1_1   ((uint32_t)<span class="hljs-number">0x00000000</span>)
#define ETH_DMAArbitration_RoundRobin_RxTx_2_1   ((uint32_t)<span class="hljs-number">0x00004000</span>)
#define ETH_DMAArbitration_RoundRobin_RxTx_3_1   ((uint32_t)<span class="hljs-number">0x00008000</span>)
#define ETH_DMAArbitration_RoundRobin_RxTx_4_1   ((uint32_t)<span class="hljs-number">0x0000C000</span>)
#define ETH_DMAArbitration_RxPriorTx             ((uint32_t)<span class="hljs-number">0x00000002</span>)
#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \
                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \
                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \
                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \
                                                       ((RATIO) == ETH_DMAArbitration_RxPriorTx))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Flags * @{ */</span>
#define ETH_DMA_FLAG_TST               ((uint32_t)<span class="hljs-number">0x20000000</span>)  <span class="hljs-comment">/*!&lt; Time-stamp trigger interrupt (on DMA) */</span>
#define ETH_DMA_FLAG_PMT               ((uint32_t)<span class="hljs-number">0x10000000</span>)  <span class="hljs-comment">/*!&lt; PMT interrupt (on DMA) */</span>
#define ETH_DMA_FLAG_MMC               ((uint32_t)<span class="hljs-number">0x08000000</span>)  <span class="hljs-comment">/*!&lt; MMC interrupt (on DMA) */</span>
#define ETH_DMA_FLAG_DataTransferError ((uint32_t)<span class="hljs-number">0x00800000</span>)  <span class="hljs-comment">/*!&lt; Error bits 0-Rx DMA, 1-Tx DMA */</span>
#define ETH_DMA_FLAG_ReadWriteError    ((uint32_t)<span class="hljs-number">0x01000000</span>)  <span class="hljs-comment">/*!&lt; Error bits 0-write trnsf, 1-read transfr */</span>
#define ETH_DMA_FLAG_AccessError       ((uint32_t)<span class="hljs-number">0x02000000</span>)  <span class="hljs-comment">/*!&lt; Error bits 0-data buffer, 1-desc. access */</span>
#define ETH_DMA_FLAG_NIS               ((uint32_t)<span class="hljs-number">0x00010000</span>)  <span class="hljs-comment">/*!&lt; Normal interrupt summary flag */</span>
#define ETH_DMA_FLAG_AIS               ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; Abnormal interrupt summary flag */</span>
#define ETH_DMA_FLAG_ER                ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; Early receive flag */</span>
#define ETH_DMA_FLAG_FBE               ((uint32_t)<span class="hljs-number">0x00002000</span>)  <span class="hljs-comment">/*!&lt; Fatal bus error flag */</span>
#define ETH_DMA_FLAG_ET                ((uint32_t)<span class="hljs-number">0x00000400</span>)  <span class="hljs-comment">/*!&lt; Early transmit flag */</span>
#define ETH_DMA_FLAG_RWT               ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; Receive watchdog timeout flag */</span>
#define ETH_DMA_FLAG_RPS               ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; Receive process stopped flag */</span>
#define ETH_DMA_FLAG_RBU               ((uint32_t)<span class="hljs-number">0x00000080</span>)  <span class="hljs-comment">/*!&lt; Receive buffer unavailable flag */</span>
#define ETH_DMA_FLAG_R                 ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; Receive flag */</span>
#define ETH_DMA_FLAG_TU                ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Underflow flag */</span>
#define ETH_DMA_FLAG_RO                ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; Overflow flag */</span>
#define ETH_DMA_FLAG_TJT               ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; Transmit jabber timeout flag */</span>
#define ETH_DMA_FLAG_TBU               ((uint32_t)<span class="hljs-number">0x00000004</span>)  <span class="hljs-comment">/*!&lt; Transmit buffer unavailable flag */</span>
#define ETH_DMA_FLAG_TPS               ((uint32_t)<span class="hljs-number">0x00000002</span>)  <span class="hljs-comment">/*!&lt; Transmit process stopped flag */</span>
#define ETH_DMA_FLAG_T                 ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; Transmit flag */</span>

#define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) &amp; (uint32_t)<span class="hljs-number">0xFFFE1800</span>) == <span class="hljs-number">0x00</span>) &amp;&amp; ((FLAG) != <span class="hljs-number">0x00</span>))
#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \
                                   ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \
                                   ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \
                                   ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \
                                   ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \
                                   ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \
                                   ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \
                                   ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \
                                   ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \
                                   ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \
                                   ((FLAG) == ETH_DMA_FLAG_T))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_Interrupts * @{ */</span>
#define ETH_DMA_IT_TST       ((uint32_t)<span class="hljs-number">0x20000000</span>)  <span class="hljs-comment">/*!&lt; Time-stamp trigger interrupt (on DMA) */</span>
#define ETH_DMA_IT_PMT       ((uint32_t)<span class="hljs-number">0x10000000</span>)  <span class="hljs-comment">/*!&lt; PMT interrupt (on DMA) */</span>
#define ETH_DMA_IT_MMC       ((uint32_t)<span class="hljs-number">0x08000000</span>)  <span class="hljs-comment">/*!&lt; MMC interrupt (on DMA) */</span>
#define ETH_DMA_IT_NIS       ((uint32_t)<span class="hljs-number">0x00010000</span>)  <span class="hljs-comment">/*!&lt; Normal interrupt summary */</span>
#define ETH_DMA_IT_AIS       ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; Abnormal interrupt summary */</span>
#define ETH_DMA_IT_ER        ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; Early receive interrupt */</span>
#define ETH_DMA_IT_FBE       ((uint32_t)<span class="hljs-number">0x00002000</span>)  <span class="hljs-comment">/*!&lt; Fatal bus error interrupt */</span>
#define ETH_DMA_IT_ET        ((uint32_t)<span class="hljs-number">0x00000400</span>)  <span class="hljs-comment">/*!&lt; Early transmit interrupt */</span>
#define ETH_DMA_IT_RWT       ((uint32_t)<span class="hljs-number">0x00000200</span>)  <span class="hljs-comment">/*!&lt; Receive watchdog timeout interrupt */</span>
#define ETH_DMA_IT_RPS       ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; Receive process stopped interrupt */</span>
#define ETH_DMA_IT_RBU       ((uint32_t)<span class="hljs-number">0x00000080</span>)  <span class="hljs-comment">/*!&lt; Receive buffer unavailable interrupt */</span>
#define ETH_DMA_IT_R         ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; Receive interrupt */</span>
#define ETH_DMA_IT_TU        ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Underflow interrupt */</span>
#define ETH_DMA_IT_RO        ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; Overflow interrupt */</span>
#define ETH_DMA_IT_TJT       ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; Transmit jabber timeout interrupt */</span>
#define ETH_DMA_IT_TBU       ((uint32_t)<span class="hljs-number">0x00000004</span>)  <span class="hljs-comment">/*!&lt; Transmit buffer unavailable interrupt */</span>
#define ETH_DMA_IT_TPS       ((uint32_t)<span class="hljs-number">0x00000002</span>)  <span class="hljs-comment">/*!&lt; Transmit process stopped interrupt */</span>
#define ETH_DMA_IT_T         ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; Transmit interrupt */</span>

#define IS_ETH_DMA_IT(IT) ((((IT) &amp; (uint32_t)<span class="hljs-number">0xFFFE1800</span>) == <span class="hljs-number">0x00</span>) &amp;&amp; ((IT) != <span class="hljs-number">0x00</span>))
#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \
                               ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \
                               ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \
                               ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \
                               ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \
                               ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \
                               ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \
                               ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \
                               ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_transmit_process_state_ * @{ */</span>
#define ETH_DMA_TransmitProcess_Stopped     ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Stopped - Reset or Stop Tx Command issued */</span>
#define ETH_DMA_TransmitProcess_Fetching    ((uint32_t)<span class="hljs-number">0x00100000</span>)  <span class="hljs-comment">/*!&lt; Running - fetching the Tx descriptor */</span>
#define ETH_DMA_TransmitProcess_Waiting     ((uint32_t)<span class="hljs-number">0x00200000</span>)  <span class="hljs-comment">/*!&lt; Running - waiting for status */</span>
#define ETH_DMA_TransmitProcess_Reading     ((uint32_t)<span class="hljs-number">0x00300000</span>)  <span class="hljs-comment">/*!&lt; Running - reading the data from host memory */</span>
#define ETH_DMA_TransmitProcess_Suspended   ((uint32_t)<span class="hljs-number">0x00600000</span>)  <span class="hljs-comment">/*!&lt; Suspended - Tx Desciptor unavailabe */</span>
#define ETH_DMA_TransmitProcess_Closing     ((uint32_t)<span class="hljs-number">0x00700000</span>)  <span class="hljs-comment">/*!&lt; Running - closing Rx descriptor */</span>

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_receive_process_state_ * @{ */</span>
#define ETH_DMA_ReceiveProcess_Stopped      ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Stopped - Reset or Stop Rx Command issued */</span>
#define ETH_DMA_ReceiveProcess_Fetching     ((uint32_t)<span class="hljs-number">0x00020000</span>)  <span class="hljs-comment">/*!&lt; Running - fetching the Rx descriptor */</span>
#define ETH_DMA_ReceiveProcess_Waiting      ((uint32_t)<span class="hljs-number">0x00060000</span>)  <span class="hljs-comment">/*!&lt; Running - waiting for packet */</span>
#define ETH_DMA_ReceiveProcess_Suspended    ((uint32_t)<span class="hljs-number">0x00080000</span>)  <span class="hljs-comment">/*!&lt; Suspended - Rx Desciptor unavailable */</span>
#define ETH_DMA_ReceiveProcess_Closing      ((uint32_t)<span class="hljs-number">0x000A0000</span>)  <span class="hljs-comment">/*!&lt; Running - closing descriptor */</span>
#define ETH_DMA_ReceiveProcess_Queuing      ((uint32_t)<span class="hljs-number">0x000E0000</span>)  <span class="hljs-comment">/*!&lt; Running - queuing the recieve frame into host memory */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_DMA_overflow_ * @{ */</span>
#define ETH_DMA_Overflow_RxFIFOCounter      ((uint32_t)<span class="hljs-number">0x10000000</span>)  <span class="hljs-comment">/*!&lt; Overflow bit for FIFO overflow counter */</span>
#define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)<span class="hljs-number">0x00010000</span>)  <span class="hljs-comment">/*!&lt; Overflow bit for missed frame counter */</span>
#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \
                                           ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter))

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet PMT defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_PMT_Flags * @{ */</span>
#define ETH_PMT_FLAG_WUFFRPR      ((uint32_t)<span class="hljs-number">0x80000000</span>)  <span class="hljs-comment">/*!&lt; Wake-Up Frame Filter Register Poniter Reset */</span>
#define ETH_PMT_FLAG_WUFR         ((uint32_t)<span class="hljs-number">0x00000040</span>)  <span class="hljs-comment">/*!&lt; Wake-Up Frame Received */</span>
#define ETH_PMT_FLAG_MPR          ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Magic Packet Received */</span>
#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \
                                   ((FLAG) == ETH_PMT_FLAG_MPR))

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet MMC defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MMC_Tx_Interrupts * @{ */</span>
#define ETH_MMC_IT_TGF       ((uint32_t)<span class="hljs-number">0x00200000</span>)  <span class="hljs-comment">/*!&lt; When Tx good frame counter reaches half the maximum value */</span>
#define ETH_MMC_IT_TGFMSC    ((uint32_t)<span class="hljs-number">0x00008000</span>)  <span class="hljs-comment">/*!&lt; When Tx good multi col counter reaches half the maximum value */</span>
#define ETH_MMC_IT_TGFSC     ((uint32_t)<span class="hljs-number">0x00004000</span>)  <span class="hljs-comment">/*!&lt; When Tx good single col counter reaches half the maximum value */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MMC_Rx_Interrupts * @{ */</span>
#define ETH_MMC_IT_RGUF      ((uint32_t)<span class="hljs-number">0x10020000</span>)  <span class="hljs-comment">/*!&lt; When Rx good unicast frames counter reaches half the maximum value */</span>
#define ETH_MMC_IT_RFAE      ((uint32_t)<span class="hljs-number">0x10000040</span>)  <span class="hljs-comment">/*!&lt; When Rx alignment error counter reaches half the maximum value */</span>
#define ETH_MMC_IT_RFCE      ((uint32_t)<span class="hljs-number">0x10000020</span>)  <span class="hljs-comment">/*!&lt; When Rx crc error counter reaches half the maximum value */</span>
#define IS_ETH_MMC_IT(IT) (((((IT) &amp; (uint32_t)<span class="hljs-number">0xFFDF3FFF</span>) == <span class="hljs-number">0x00</span>) || (((IT) &amp; (uint32_t)<span class="hljs-number">0xEFFDFF9F</span>) == <span class="hljs-number">0x00</span>)) &amp;&amp; \
                           ((IT) != <span class="hljs-number">0x00</span>))
#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \
                               ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \
                               ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_MMC_Registers * @{ */</span>
#define ETH_MMCCR            ((uint32_t)<span class="hljs-number">0x00000100</span>)  <span class="hljs-comment">/*!&lt; MMC CR register */</span>
#define ETH_MMCRIR           ((uint32_t)<span class="hljs-number">0x00000104</span>)  <span class="hljs-comment">/*!&lt; MMC RIR register */</span>
#define ETH_MMCTIR           ((uint32_t)<span class="hljs-number">0x00000108</span>)  <span class="hljs-comment">/*!&lt; MMC TIR register */</span>
#define ETH_MMCRIMR          ((uint32_t)<span class="hljs-number">0x0000010C</span>)  <span class="hljs-comment">/*!&lt; MMC RIMR register */</span>
#define ETH_MMCTIMR          ((uint32_t)<span class="hljs-number">0x00000110</span>)  <span class="hljs-comment">/*!&lt; MMC TIMR register */</span>
#define ETH_MMCTGFSCCR       ((uint32_t)<span class="hljs-number">0x0000014C</span>)  <span class="hljs-comment">/*!&lt; MMC TGFSCCR register */</span>
#define ETH_MMCTGFMSCCR      ((uint32_t)<span class="hljs-number">0x00000150</span>)  <span class="hljs-comment">/*!&lt; MMC TGFMSCCR register */</span>
#define ETH_MMCTGFCR         ((uint32_t)<span class="hljs-number">0x00000168</span>)  <span class="hljs-comment">/*!&lt; MMC TGFCR register */</span>
#define ETH_MMCRFCECR        ((uint32_t)<span class="hljs-number">0x00000194</span>)  <span class="hljs-comment">/*!&lt; MMC RFCECR register */</span>
#define ETH_MMCRFAECR        ((uint32_t)<span class="hljs-number">0x00000198</span>)  <span class="hljs-comment">/*!&lt; MMC RFAECR register */</span>
#define ETH_MMCRGUFCR        ((uint32_t)<span class="hljs-number">0x000001C4</span>)  <span class="hljs-comment">/*!&lt; MMC RGUFCR register */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH MMC registers */</span>
#define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR)  || ((REG) == ETH_MMCRIR) || \
                                  ((REG) == ETH_MMCTIR)  || ((REG) == ETH_MMCRIMR) || \
                                  ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \
                                  ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \
                                  ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \
                                  ((REG) == ETH_MMCRGUFCR))

<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Ethernet PTP defines */</span>
<span class="hljs-javadoc">/**--------------------------------------------------------------------------**/</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_PTP_time_update_method * @{ */</span>
#define ETH_PTP_FineUpdate        ((uint32_t)<span class="hljs-number">0x00000001</span>)  <span class="hljs-comment">/*!&lt; Fine Update method */</span>
#define ETH_PTP_CoarseUpdate      ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Coarse Update method */</span>
#define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \
                                   ((UPDATE) == ETH_PTP_CoarseUpdate))

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_PTP_Flags * @{ */</span>
#define ETH_PTP_FLAG_TSARU        ((uint32_t)<span class="hljs-number">0x00000020</span>)  <span class="hljs-comment">/*!&lt; Addend Register Update */</span>
#define ETH_PTP_FLAG_TSITE        ((uint32_t)<span class="hljs-number">0x00000010</span>)  <span class="hljs-comment">/*!&lt; Time Stamp Interrupt Trigger */</span>
#define ETH_PTP_FLAG_TSSTU        ((uint32_t)<span class="hljs-number">0x00000008</span>)  <span class="hljs-comment">/*!&lt; Time Stamp Update */</span>
#define ETH_PTP_FLAG_TSSTI        ((uint32_t)<span class="hljs-number">0x00000004</span>)  <span class="hljs-comment">/*!&lt; Time Stamp Initialize */</span>
#define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \
                                   ((FLAG) == ETH_PTP_FLAG_TSITE) || \
                                   ((FLAG) == ETH_PTP_FLAG_TSSTU) || \
                                   ((FLAG) == ETH_PTP_FLAG_TSSTI))
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH PTP subsecond increment */</span>
#define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) &lt;= <span class="hljs-number">0xFF</span>)

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_PTP_time_sign * @{ */</span>
#define ETH_PTP_PositiveTime      ((uint32_t)<span class="hljs-number">0x00000000</span>)  <span class="hljs-comment">/*!&lt; Positive time value */</span>
#define ETH_PTP_NegativeTime      ((uint32_t)<span class="hljs-number">0x80000000</span>)  <span class="hljs-comment">/*!&lt; Negative time value */</span>
#define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \
                                    ((SIGN) == ETH_PTP_NegativeTime))

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH PTP time stamp low update */</span>
#define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) &lt;= <span class="hljs-number">0x7FFFFFFF</span>)

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> ETH PTP registers */</span>
#define ETH_PTPTSCR     ((uint32_t)<span class="hljs-number">0x00000700</span>)  <span class="hljs-comment">/*!&lt; PTP TSCR register */</span>
#define ETH_PTPSSIR     ((uint32_t)<span class="hljs-number">0x00000704</span>)  <span class="hljs-comment">/*!&lt; PTP SSIR register */</span>
#define ETH_PTPTSHR     ((uint32_t)<span class="hljs-number">0x00000708</span>)  <span class="hljs-comment">/*!&lt; PTP TSHR register */</span>
#define ETH_PTPTSLR     ((uint32_t)<span class="hljs-number">0x0000070C</span>)  <span class="hljs-comment">/*!&lt; PTP TSLR register */</span>
#define ETH_PTPTSHUR    ((uint32_t)<span class="hljs-number">0x00000710</span>)  <span class="hljs-comment">/*!&lt; PTP TSHUR register */</span>
#define ETH_PTPTSLUR    ((uint32_t)<span class="hljs-number">0x00000714</span>)  <span class="hljs-comment">/*!&lt; PTP TSLUR register */</span>
#define ETH_PTPTSAR     ((uint32_t)<span class="hljs-number">0x00000718</span>)  <span class="hljs-comment">/*!&lt; PTP TSAR register */</span>
#define ETH_PTPTTHR     ((uint32_t)<span class="hljs-number">0x0000071C</span>)  <span class="hljs-comment">/*!&lt; PTP TTHR register */</span>
#define ETH_PTPTTLR     ((uint32_t)<span class="hljs-number">0x00000720</span>)  <span class="hljs-comment">/* PTP TTLR register */</span>
#define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \
                                  ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \
                                  ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \
                                  ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \
                                  ((REG) == ETH_PTPTTLR))

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Exported_Macros * @{ */</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Exported_Functions * @{ */</span>
<span class="hljs-keyword">void</span> ETH_DeInit(<span class="hljs-keyword">void</span>);
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct);
<span class="hljs-keyword">void</span> ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct);
<span class="hljs-keyword">void</span> ETH_SoftwareReset(<span class="hljs-keyword">void</span>);
FlagStatus ETH_GetSoftwareResetStatus(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span>  ETH_Start(<span class="hljs-keyword">void</span>);
uint32_t ETH_HandleTxPkt(u8 *ppkt, u16 FrameLength);
uint32_t ETH_HandleRxPkt(u8 *ppkt);
uint32_t ETH_GetRxPktSize(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_DropRxPkt(<span class="hljs-keyword">void</span>);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> PHY */</span>
u16 ETH_ReadPHYRegister(u16 PHYAddress, u16 PHYReg);
uint32_t ETH_WritePHYRegister(u16 PHYAddress, u16 PHYReg, u16 PHYValue);
uint32_t ETH_PHYLoopBackCmd(u16 PHYAddress, FunctionalState NewState);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> MAC */</span>
<span class="hljs-keyword">void</span> ETH_MACTransmissionCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MACReceptionCmd(FunctionalState NewState);
FlagStatus ETH_GetFlowControlBusyStatus(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_InitiatePauseControlFrame(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_BackPressureActivationCmd(FunctionalState NewState);
FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG);
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT);
<span class="hljs-keyword">void</span> ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MACAddressConfig(uint32_t MacAddr, u8 *Addr);
<span class="hljs-keyword">void</span> ETH_GetMACAddress(uint32_t MacAddr, u8 *Addr);
<span class="hljs-keyword">void</span> ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter);
<span class="hljs-keyword">void</span> ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> DMA Tx/Rx descriptors */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff, uint32_t TxBuffCount);
<span class="hljs-keyword">void</span> ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, u8 *TxBuff1, u8 *TxBuff2, uint32_t TxBuffCount);
FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag);
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc);
<span class="hljs-keyword">void</span> ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc);
<span class="hljs-keyword">void</span> ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment);
<span class="hljs-keyword">void</span> ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum);
<span class="hljs-keyword">void</span> ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2);
<span class="hljs-keyword">void</span> ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff, uint32_t RxBuffCount);
<span class="hljs-keyword">void</span> ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, u8 *RxBuff1, u8 *RxBuff2, uint32_t RxBuffCount);
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag);
<span class="hljs-keyword">void</span> ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc);
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc);
<span class="hljs-keyword">void</span> ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> DMA */</span>
FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG);
<span class="hljs-keyword">void</span> ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG);
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT);
<span class="hljs-keyword">void</span> ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT);
uint32_t ETH_GetTransmitProcessState(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetReceiveProcessState(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_FlushTransmitFIFO(<span class="hljs-keyword">void</span>);
FlagStatus ETH_GetFlushTransmitFIFOStatus(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_DMATransmissionCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMAReceptionCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState);
FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow);
uint32_t ETH_GetRxOverflowMissedFrameCounter(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetCurrentTxDescStartAddress(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetCurrentRxDescStartAddress(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetCurrentTxBufferAddress(<span class="hljs-keyword">void</span>);
uint32_t ETH_GetCurrentRxBufferAddress(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_ResumeDMATransmission(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_ResumeDMAReception(<span class="hljs-keyword">void</span>);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> PMT */</span>
<span class="hljs-keyword">void</span> ETH_ResetWakeUpFrameFilterRegisterPointer(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer);
<span class="hljs-keyword">void</span> ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState);
FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG);
<span class="hljs-keyword">void</span> ETH_WakeUpFrameDetectionCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MagicPacketDetectionCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_PowerDownCmd(FunctionalState NewState);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> MMC */</span>
<span class="hljs-keyword">void</span> ETH_MMCCounterFreezeCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MMCResetOnReadCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MMCCounterRolloverCmd(FunctionalState NewState);
<span class="hljs-keyword">void</span> ETH_MMCCountersReset(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState);
ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT);
uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg);

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> PTP */</span>
uint32_t ETH_HandlePTPTxPkt(u8 *ppkt, u16 FrameLength, uint32_t *PTPTxTab);
uint32_t ETH_HandlePTPRxPkt(u8 *ppkt, uint32_t *PTPRxTab);
<span class="hljs-keyword">void</span> ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab, u8* TxBuff, uint32_t TxBuffCount);
<span class="hljs-keyword">void</span> ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab, u8 *RxBuff, uint32_t RxBuffCount);
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampAddend(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampInterruptTrigger(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampUpdate(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_InitializePTPTimeStamp(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">void</span> ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod);
<span class="hljs-keyword">void</span> ETH_PTPTimeStampCmd(FunctionalState NewState);
FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG);
<span class="hljs-keyword">void</span> ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue);
<span class="hljs-keyword">void</span> ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue);
<span class="hljs-keyword">void</span> ETH_SetPTPTimeStampAddend(uint32_t Value);
<span class="hljs-keyword">void</span> ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue);
uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg);

#ifdef __cplusplus
}
#endif

<span class="hljs-keyword">void</span> FreeRTOS_Hardware_STMS32_ETH_Init(<span class="hljs-keyword">void</span>);

#endif <span class="hljs-comment">/* __STM32_ETH_H */</span>
<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/</span>
</code></pre> 
  <p>stm32_eth.c</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** ****************************************************************************** *<span class="hljs-javadoctag"> @file</span> stm32_eth.c *<span class="hljs-javadoctag"> @author</span> MCD Application Team *<span class="hljs-javadoctag"> @version</span> V1.1.0 *<span class="hljs-javadoctag"> @date</span> 11/20/2009 *<span class="hljs-javadoctag"> @brief</span> This file provides all the ETH firmware functions. ****************************************************************************** *<span class="hljs-javadoctag"> @copy</span> * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2009 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; */</span>

<span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span>
#include <span class="hljs-string">"stm32_eth.h"</span>
#include <span class="hljs-string">"stm32f10x_rcc.h"</span>

#define DP83848_PHY_ADDRESS       <span class="hljs-number">0x01</span> <span class="hljs-comment">/* Relative to STM322xG-EVAL Board */</span>

<span class="hljs-comment">/* STM32F107 ETH dirver options */</span>
#define CHECKSUM_BY_HARDWARE    <span class="hljs-number">1</span>       <span class="hljs-comment">/* 0: disable. 1: use hardware checksum. */</span>
#define RMII_MODE               <span class="hljs-number">0</span>       <span class="hljs-comment">/* 0: MII MODE, 1: RMII MODE. */</span>
#define STM32_ETH_IO_REMAP      <span class="hljs-number">1</span>       <span class="hljs-comment">/* 0: default, 1: remap RXD to PDx. */</span>
#define USE_MCO                 <span class="hljs-number">1</span>       <span class="hljs-comment">/* 0: disable, 1: PA8(MCO) out 25Mhz(MII) or 50Mhz(RMII). */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @addtogroup</span> STM32_ETH_Driver *<span class="hljs-javadoctag"> @brief</span> ETH driver modules * @{ */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_TypesDefinitions * @{ */</span>
<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_Defines * @{ */</span>
<span class="hljs-comment">/* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */</span>
ETH_DMADESCTypeDef  *DMATxDescToSet;
ETH_DMADESCTypeDef  *DMARxDescToGet;
ETH_DMADESCTypeDef  *DMAPTPTxDescToSet;
ETH_DMADESCTypeDef  *DMAPTPRxDescToGet;

<span class="hljs-comment">/* ETHERNET MAC address offsets */</span>
#define ETH_MAC_ADDR_HBASE   (ETH_MAC_BASE + <span class="hljs-number">0x40</span>)  <span class="hljs-comment">/* ETHERNET MAC address high offset */</span>
#define ETH_MAC_ADDR_LBASE    (ETH_MAC_BASE + <span class="hljs-number">0x44</span>)  <span class="hljs-comment">/* ETHERNET MAC address low offset */</span>

<span class="hljs-comment">/* ETHERNET MACMIIAR register Mask */</span>
#define MACMIIAR_CR_MASK    ((uint32_t)<span class="hljs-number">0xFFFFFFE3</span>)

<span class="hljs-comment">/* ETHERNET MACCR register Mask */</span>
#define MACCR_CLEAR_MASK    ((uint32_t)<span class="hljs-number">0xFF20810F</span>)

<span class="hljs-comment">/* ETHERNET MACFCR register Mask */</span>
#define MACFCR_CLEAR_MASK   ((uint32_t)<span class="hljs-number">0x0000FF41</span>)

<span class="hljs-comment">/* ETHERNET DMAOMR register Mask */</span>
#define DMAOMR_CLEAR_MASK   ((uint32_t)<span class="hljs-number">0xF8DE3F23</span>)

<span class="hljs-comment">/* ETHERNET Remote Wake-up frame register length */</span>
#define ETH_WAKEUP_REGISTER_LENGTH      <span class="hljs-number">8</span>

<span class="hljs-comment">/* ETHERNET Missed frames counter Shift */</span>
#define  ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT     <span class="hljs-number">17</span>

<span class="hljs-comment">/* ETHERNET DMA Tx descriptors Collision Count Shift */</span>
#define  ETH_DMATXDESC_COLLISION_COUNTSHIFT        <span class="hljs-number">3</span>

<span class="hljs-comment">/* ETHERNET DMA Tx descriptors Buffer2 Size Shift */</span>
#define  ETH_DMATXDESC_BUFFER2_SIZESHIFT           <span class="hljs-number">16</span>

<span class="hljs-comment">/* ETHERNET DMA Rx descriptors Frame Length Shift */</span>
#define  ETH_DMARXDESC_FRAME_LENGTHSHIFT           <span class="hljs-number">16</span>

<span class="hljs-comment">/* ETHERNET DMA Rx descriptors Buffer2 Size Shift */</span>
#define  ETH_DMARXDESC_BUFFER2_SIZESHIFT           <span class="hljs-number">16</span>

<span class="hljs-comment">/* ETHERNET errors */</span>
#define  ETH_ERROR              ((uint32_t)<span class="hljs-number">0</span>)
#define  ETH_SUCCESS            ((uint32_t)<span class="hljs-number">1</span>)
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_Macros * @{ */</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_Variables * @{ */</span>
<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_FunctionPrototypes * @{ */</span>

<span class="hljs-javadoc">/** * @} */</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @defgroup</span> ETH_Private_Functions * @{ */</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Deinitializes the ETHERNET peripheral registers to their default reset values. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DeInit(<span class="hljs-keyword">void</span>)
{
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the ETHERNET peripheral according to the specified * parameters in the ETH_InitStruct . *<span class="hljs-javadoctag"> @param</span> ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains * the configuration information for the specified ETHERNET peripheral. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: Ethernet initialization failed * ETH_SUCCESS: Ethernet successfully initialized */</span>
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct)
{
    uint32_t tmpreg = <span class="hljs-number">0</span>;
    __IO uint32_t i = <span class="hljs-number">0</span>;
    RCC_ClocksTypeDef  rcc_clocks;
    uint32_t hclk = <span class="hljs-number">60000000</span>;
    __IO uint32_t timeout = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Check the parameters */</span>
    <span class="hljs-comment">/* MAC --------------------------*/</span>
    assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct-&gt;ETH_AutoNegotiation));
    assert_param(IS_ETH_WATCHDOG(ETH_InitStruct-&gt;ETH_Watchdog));
    assert_param(IS_ETH_JABBER(ETH_InitStruct-&gt;ETH_Jabber));
    assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct-&gt;ETH_InterFrameGap));
    assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct-&gt;ETH_CarrierSense));
    assert_param(IS_ETH_SPEED(ETH_InitStruct-&gt;ETH_Speed));
    assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct-&gt;ETH_ReceiveOwn));
    assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct-&gt;ETH_LoopbackMode));
    assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct-&gt;ETH_Mode));
    assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct-&gt;ETH_ChecksumOffload));
    assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct-&gt;ETH_RetryTransmission));
    assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip));
    assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct-&gt;ETH_BackOffLimit));
    assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct-&gt;ETH_DeferralCheck));
    assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct-&gt;ETH_ReceiveAll));
    assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct-&gt;ETH_SourceAddrFilter));
    assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct-&gt;ETH_PassControlFrames));
    assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct-&gt;ETH_BroadcastFramesReception));
    assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct-&gt;ETH_DestinationAddrFilter));
    assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct-&gt;ETH_PromiscuousMode));
    assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_MulticastFramesFilter));
    assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct-&gt;ETH_UnicastFramesFilter));
    assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct-&gt;ETH_PauseTime));
    assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct-&gt;ETH_ZeroQuantaPause));
    assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct-&gt;ETH_PauseLowThreshold));
    assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect));
    assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct-&gt;ETH_ReceiveFlowControl));
    assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct-&gt;ETH_TransmitFlowControl));
    assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct-&gt;ETH_VLANTagComparison));
    assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct-&gt;ETH_VLANTagIdentifier));
    <span class="hljs-comment">/* DMA --------------------------*/</span>
    assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame));
    assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct-&gt;ETH_ReceiveStoreForward));
    assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct-&gt;ETH_FlushReceivedFrame));
    assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct-&gt;ETH_TransmitStoreForward));
    assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_TransmitThresholdControl));
    assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct-&gt;ETH_ForwardErrorFrames));
    assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames));
    assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct-&gt;ETH_ReceiveThresholdControl));
    assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct-&gt;ETH_SecondFrameOperate));
    assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct-&gt;ETH_AddressAlignedBeats));
    assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct-&gt;ETH_FixedBurst));
    assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_RxDMABurstLength));
    assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct-&gt;ETH_TxDMABurstLength));
    assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct-&gt;ETH_DescriptorSkipLength));
    assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct-&gt;ETH_DMAArbitration));

    <span class="hljs-comment">/*-------------------------------- MAC Config ------------------------------*/</span>
    <span class="hljs-comment">/*---------------------- ETHERNET MACMIIAR Configuration -------------------*/</span>
    <span class="hljs-comment">/* Get the ETHERNET MACMIIAR value */</span>
    tmpreg = ETH-&gt;MACMIIAR;
    <span class="hljs-comment">/* Clear CSR Clock Range CR[2:0] bits */</span>
    tmpreg &amp;= MACMIIAR_CR_MASK;
    <span class="hljs-comment">/* Get hclk frequency value */</span>
    RCC_GetClocksFreq(&amp;rcc_clocks);
    hclk = rcc_clocks.HCLK_Frequency;
    <span class="hljs-comment">/* Set CR bits depending on hclk value */</span>
    <span class="hljs-keyword">if</span>((hclk &gt;= <span class="hljs-number">20000000</span>)&amp;&amp;(hclk &lt; <span class="hljs-number">35000000</span>))
    {
        <span class="hljs-comment">/* CSR Clock Range between 20-35 MHz */</span>
        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((hclk &gt;= <span class="hljs-number">35000000</span>)&amp;&amp;(hclk &lt; <span class="hljs-number">60000000</span>))
    {
        <span class="hljs-comment">/* CSR Clock Range between 35-60 MHz */</span>
        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* ((hclk &gt;= 60000000)&amp;&amp;(hclk &lt;= 72000000)) */</span>
    {
        <span class="hljs-comment">/* CSR Clock Range between 60-72 MHz */</span>
        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;
    }
    <span class="hljs-comment">/* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */</span>
    ETH-&gt;MACMIIAR = (uint32_t)tmpreg;

    <span class="hljs-comment">/*------------------------ ETHERNET MACCR Configuration --------------------*/</span>
    <span class="hljs-comment">/* Get the ETHERNET MACCR value */</span>
    tmpreg = ETH-&gt;MACCR;
    <span class="hljs-comment">/* Clear WD, PCE, PS, TE and RE bits */</span>
    tmpreg &amp;= MACCR_CLEAR_MASK;
    <span class="hljs-comment">/* Set the WD bit according to ETH_Watchdog value */</span>
    <span class="hljs-comment">/* Set the JD: bit according to ETH_Jabber value */</span>
    <span class="hljs-comment">/* Set the IFG bit according to ETH_InterFrameGap value */</span>
    <span class="hljs-comment">/* Set the DCRS bit according to ETH_CarrierSense value */</span>
    <span class="hljs-comment">/* Set the FES bit according to ETH_Speed value */</span>
    <span class="hljs-comment">/* Set the DO bit according to ETH_ReceiveOwn value */</span>
    <span class="hljs-comment">/* Set the LM bit according to ETH_LoopbackMode value */</span>
    <span class="hljs-comment">/* Set the DM bit according to ETH_Mode value */</span>
    <span class="hljs-comment">/* Set the IPC bit according to ETH_ChecksumOffload value */</span>
    <span class="hljs-comment">/* Set the DR bit according to ETH_RetryTransmission value */</span>
    <span class="hljs-comment">/* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */</span>
    <span class="hljs-comment">/* Set the BL bit according to ETH_BackOffLimit value */</span>
    <span class="hljs-comment">/* Set the DC bit according to ETH_DeferralCheck value */</span>
    tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_Watchdog |
                         ETH_InitStruct-&gt;ETH_Jabber |
                         ETH_InitStruct-&gt;ETH_InterFrameGap |
                         ETH_InitStruct-&gt;ETH_CarrierSense |
                         ETH_InitStruct-&gt;ETH_Speed |
                         ETH_InitStruct-&gt;ETH_ReceiveOwn |
                         ETH_InitStruct-&gt;ETH_LoopbackMode |
                         ETH_InitStruct-&gt;ETH_Mode |
                         ETH_InitStruct-&gt;ETH_ChecksumOffload |
                         ETH_InitStruct-&gt;ETH_RetryTransmission |
                         ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip |
                         ETH_InitStruct-&gt;ETH_BackOffLimit |
                         ETH_InitStruct-&gt;ETH_DeferralCheck);
    <span class="hljs-comment">/* Write to ETHERNET MACCR */</span>
    ETH-&gt;MACCR = (uint32_t)tmpreg;

    <span class="hljs-comment">/*----------------------- ETHERNET MACFFR Configuration --------------------*/</span>
    <span class="hljs-comment">/* Set the RA bit according to ETH_ReceiveAll value */</span>
    <span class="hljs-comment">/* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */</span>
    <span class="hljs-comment">/* Set the PCF bit according to ETH_PassControlFrames value */</span>
    <span class="hljs-comment">/* Set the DBF bit according to ETH_BroadcastFramesReception value */</span>
    <span class="hljs-comment">/* Set the DAIF bit according to ETH_DestinationAddrFilter value */</span>
    <span class="hljs-comment">/* Set the PR bit according to ETH_PromiscuousMode value */</span>
    <span class="hljs-comment">/* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */</span>
    <span class="hljs-comment">/* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */</span>
    <span class="hljs-comment">/* Write to ETHERNET MACFFR */</span>
    ETH-&gt;MACFFR = (uint32_t)(ETH_InitStruct-&gt;ETH_ReceiveAll |
                             ETH_InitStruct-&gt;ETH_SourceAddrFilter |
                             ETH_InitStruct-&gt;ETH_PassControlFrames |
                             ETH_InitStruct-&gt;ETH_BroadcastFramesReception |
                             ETH_InitStruct-&gt;ETH_DestinationAddrFilter |
                             ETH_InitStruct-&gt;ETH_PromiscuousMode |
                             ETH_InitStruct-&gt;ETH_MulticastFramesFilter |
                             ETH_InitStruct-&gt;ETH_UnicastFramesFilter);
    <span class="hljs-comment">/*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/</span>
    <span class="hljs-comment">/* Write to ETHERNET MACHTHR */</span>
    ETH-&gt;MACHTHR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableHigh;
    <span class="hljs-comment">/* Write to ETHERNET MACHTLR */</span>
    ETH-&gt;MACHTLR = (uint32_t)ETH_InitStruct-&gt;ETH_HashTableLow;
    <span class="hljs-comment">/*----------------------- ETHERNET MACFCR Configuration --------------------*/</span>
    <span class="hljs-comment">/* Get the ETHERNET MACFCR value */</span>
    tmpreg = ETH-&gt;MACFCR;
    <span class="hljs-comment">/* Clear xx bits */</span>
    tmpreg &amp;= MACFCR_CLEAR_MASK;

    <span class="hljs-comment">/* Set the PT bit according to ETH_PauseTime value */</span>
    <span class="hljs-comment">/* Set the DZPQ bit according to ETH_ZeroQuantaPause value */</span>
    <span class="hljs-comment">/* Set the PLT bit according to ETH_PauseLowThreshold value */</span>
    <span class="hljs-comment">/* Set the UP bit according to ETH_UnicastPauseFrameDetect value */</span>
    <span class="hljs-comment">/* Set the RFE bit according to ETH_ReceiveFlowControl value */</span>
    <span class="hljs-comment">/* Set the TFE bit according to ETH_TransmitFlowControl value */</span>
    tmpreg |= (uint32_t)((ETH_InitStruct-&gt;ETH_PauseTime &lt;&lt; <span class="hljs-number">16</span>) |
                         ETH_InitStruct-&gt;ETH_ZeroQuantaPause |
                         ETH_InitStruct-&gt;ETH_PauseLowThreshold |
                         ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect |
                         ETH_InitStruct-&gt;ETH_ReceiveFlowControl |
                         ETH_InitStruct-&gt;ETH_TransmitFlowControl);
    <span class="hljs-comment">/* Write to ETHERNET MACFCR */</span>
    ETH-&gt;MACFCR = (uint32_t)tmpreg;
    <span class="hljs-comment">/*----------------------- ETHERNET MACVLANTR Configuration -----------------*/</span>
    <span class="hljs-comment">/* Set the ETV bit according to ETH_VLANTagComparison value */</span>
    <span class="hljs-comment">/* Set the VL bit according to ETH_VLANTagIdentifier value */</span>
    ETH-&gt;MACVLANTR = (uint32_t)(ETH_InitStruct-&gt;ETH_VLANTagComparison |
                                ETH_InitStruct-&gt;ETH_VLANTagIdentifier);

    <span class="hljs-comment">/*-------------------------------- DMA Config ------------------------------*/</span>
    <span class="hljs-comment">/*----------------------- ETHERNET DMAOMR Configuration --------------------*/</span>
    <span class="hljs-comment">/* Get the ETHERNET DMAOMR value */</span>
    tmpreg = ETH-&gt;DMAOMR;
    <span class="hljs-comment">/* Clear xx bits */</span>
    tmpreg &amp;= DMAOMR_CLEAR_MASK;

    <span class="hljs-comment">/* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */</span>
    <span class="hljs-comment">/* Set the RSF bit according to ETH_ReceiveStoreForward value */</span>
    <span class="hljs-comment">/* Set the DFF bit according to ETH_FlushReceivedFrame value */</span>
    <span class="hljs-comment">/* Set the TSF bit according to ETH_TransmitStoreForward value */</span>
    <span class="hljs-comment">/* Set the TTC bit according to ETH_TransmitThresholdControl value */</span>
    <span class="hljs-comment">/* Set the FEF bit according to ETH_ForwardErrorFrames value */</span>
    <span class="hljs-comment">/* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */</span>
    <span class="hljs-comment">/* Set the RTC bit according to ETH_ReceiveThresholdControl value */</span>
    <span class="hljs-comment">/* Set the OSF bit according to ETH_SecondFrameOperate value */</span>
    tmpreg |= (uint32_t)(ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame |
                         ETH_InitStruct-&gt;ETH_ReceiveStoreForward |
                         ETH_InitStruct-&gt;ETH_FlushReceivedFrame |
                         ETH_InitStruct-&gt;ETH_TransmitStoreForward |
                         ETH_InitStruct-&gt;ETH_TransmitThresholdControl |
                         ETH_InitStruct-&gt;ETH_ForwardErrorFrames |
                         ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames |
                         ETH_InitStruct-&gt;ETH_ReceiveThresholdControl |
                         ETH_InitStruct-&gt;ETH_SecondFrameOperate);
    <span class="hljs-comment">/* Write to ETHERNET DMAOMR */</span>
    ETH-&gt;DMAOMR = (uint32_t)tmpreg;

    <span class="hljs-comment">/*----------------------- ETHERNET DMABMR Configuration --------------------*/</span>
    <span class="hljs-comment">/* Set the AAL bit according to ETH_AddressAlignedBeats value */</span>
    <span class="hljs-comment">/* Set the FB bit according to ETH_FixedBurst value */</span>
    <span class="hljs-comment">/* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */</span>
    <span class="hljs-comment">/* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */</span>
    <span class="hljs-comment">/* Set the DSL bit according to ETH_DesciptorSkipLength value */</span>
    <span class="hljs-comment">/* Set the PR and DA bits according to ETH_DMAArbitration value */</span>
    ETH-&gt;DMABMR = (uint32_t)(ETH_InitStruct-&gt;ETH_AddressAlignedBeats |
                             ETH_InitStruct-&gt;ETH_FixedBurst |
                             ETH_InitStruct-&gt;ETH_RxDMABurstLength | <span class="hljs-comment">/* !! if 4xPBL is selected for Tx or Rx it is applied for the other */</span>
                             ETH_InitStruct-&gt;ETH_TxDMABurstLength |
                             (ETH_InitStruct-&gt;ETH_DescriptorSkipLength &lt;&lt; <span class="hljs-number">2</span>) |
                             ETH_InitStruct-&gt;ETH_DMAArbitration |
                             ETH_DMABMR_USP); <span class="hljs-comment">/* Enable use of separate PBL for Rx and Tx */</span>
    <span class="hljs-comment">/* Return Ethernet configuration success */</span>
    <span class="hljs-keyword">return</span> ETH_SUCCESS;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Fills each ETH_InitStruct member with its default value. *<span class="hljs-javadoctag"> @param</span> ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
    <span class="hljs-comment">/* ETH_InitStruct members default value */</span>
    <span class="hljs-comment">/*------------------------ MAC -----------------------------------*/</span>
    ETH_InitStruct-&gt;ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;
    ETH_InitStruct-&gt;ETH_Watchdog = ETH_Watchdog_Enable;
    ETH_InitStruct-&gt;ETH_Jabber = ETH_Jabber_Enable;
    ETH_InitStruct-&gt;ETH_InterFrameGap = ETH_InterFrameGap_96Bit;
    ETH_InitStruct-&gt;ETH_CarrierSense = ETH_CarrierSense_Enable;
    ETH_InitStruct-&gt;ETH_Speed = ETH_Speed_10M;
    ETH_InitStruct-&gt;ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
    ETH_InitStruct-&gt;ETH_LoopbackMode = ETH_LoopbackMode_Disable;
    ETH_InitStruct-&gt;ETH_Mode = ETH_Mode_HalfDuplex;
    ETH_InitStruct-&gt;ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;
    ETH_InitStruct-&gt;ETH_RetryTransmission = ETH_RetryTransmission_Enable;
    ETH_InitStruct-&gt;ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
    ETH_InitStruct-&gt;ETH_BackOffLimit = ETH_BackOffLimit_10;
    ETH_InitStruct-&gt;ETH_DeferralCheck = ETH_DeferralCheck_Disable;
    ETH_InitStruct-&gt;ETH_ReceiveAll = ETH_ReceiveAll_Disable;
    ETH_InitStruct-&gt;ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
    ETH_InitStruct-&gt;ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
    ETH_InitStruct-&gt;ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
    ETH_InitStruct-&gt;ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
    ETH_InitStruct-&gt;ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
    ETH_InitStruct-&gt;ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
    ETH_InitStruct-&gt;ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
    ETH_InitStruct-&gt;ETH_HashTableHigh = <span class="hljs-number">0x0</span>;
    ETH_InitStruct-&gt;ETH_HashTableLow = <span class="hljs-number">0x0</span>;
    ETH_InitStruct-&gt;ETH_PauseTime = <span class="hljs-number">0x0</span>;
    ETH_InitStruct-&gt;ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
    ETH_InitStruct-&gt;ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;
    ETH_InitStruct-&gt;ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;
    ETH_InitStruct-&gt;ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;
    ETH_InitStruct-&gt;ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
    ETH_InitStruct-&gt;ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;
    ETH_InitStruct-&gt;ETH_VLANTagIdentifier = <span class="hljs-number">0x0</span>;
    <span class="hljs-comment">/*------------------------ DMA -----------------------------------*/</span>
    ETH_InitStruct-&gt;ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable;
    ETH_InitStruct-&gt;ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
    ETH_InitStruct-&gt;ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;
    ETH_InitStruct-&gt;ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;
    ETH_InitStruct-&gt;ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;
    ETH_InitStruct-&gt;ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
    ETH_InitStruct-&gt;ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
    ETH_InitStruct-&gt;ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;
    ETH_InitStruct-&gt;ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
    ETH_InitStruct-&gt;ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
    ETH_InitStruct-&gt;ETH_FixedBurst = ETH_FixedBurst_Disable;
    ETH_InitStruct-&gt;ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
    ETH_InitStruct-&gt;ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
    ETH_InitStruct-&gt;ETH_DescriptorSkipLength = <span class="hljs-number">0x0</span>;
    ETH_InitStruct-&gt;ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables ENET MAC and DMA reception/transmission *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_Start(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Enable transmit state machine of the MAC for transmission on the MII */</span>
    ETH_MACTransmissionCmd(ENABLE);
    <span class="hljs-comment">/* Flush Transmit FIFO */</span>
    ETH_FlushTransmitFIFO();
    <span class="hljs-comment">/* Enable receive state machine of the MAC for reception from the MII */</span>
    ETH_MACReceptionCmd(ENABLE);

    <span class="hljs-comment">/* Start DMA transmission */</span>
    ETH_DMATransmissionCmd(ENABLE);
    <span class="hljs-comment">/* Start DMA reception */</span>
    ETH_DMAReceptionCmd(ENABLE);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Transmits a packet, from application buffer, pointed by ppkt. *<span class="hljs-javadoctag"> @param</span> ppkt: pointer to the application's packet buffer to transmit. *<span class="hljs-javadoctag"> @param</span> FrameLength: Tx Packet size. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */</span>
uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength)
{
    uint32_t offset = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */</span>
    <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Return ERROR: OWN bit set */</span>
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }

    <span class="hljs-comment">/* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */</span>
    <span class="hljs-keyword">for</span>(offset=<span class="hljs-number">0</span>; offset&lt;FrameLength; offset++)
    {
        (*(__IO uint8_t *)((DMATxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset));
    }

    <span class="hljs-comment">/* Setting the Frame Length: bits[12:0] */</span>
    DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1);
    <span class="hljs-comment">/* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */</span>
    DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
    <span class="hljs-comment">/* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */</span>
    DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN;
    <span class="hljs-comment">/* When Tx Buffer unavailable flag is set: clear it and resume transmission */</span>
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Clear TBUS ETHERNET DMA flag */</span>
        ETH-&gt;DMASR = ETH_DMASR_TBUS;
        <span class="hljs-comment">/* Resume DMA transmission*/</span>
        ETH-&gt;DMATPDR = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */</span>
    <span class="hljs-comment">/* Chained Mode */</span>
    <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Selects the next DMA Tx descriptor list for next buffer to send */</span>
        DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* Ring Mode */</span>
    {
        <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET)
        {
            <span class="hljs-comment">/* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */</span>
            DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Selects the next DMA Tx descriptor list for next buffer to send */</span>
            DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
        }
    }
    <span class="hljs-comment">/* Return SUCCESS */</span>
    <span class="hljs-keyword">return</span> ETH_SUCCESS;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Receives a packet and copies it to memory pointed by ppkt. *<span class="hljs-javadoctag"> @param</span> ppkt: pointer to the application packet receive buffer. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */</span>
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{
    uint32_t offset = <span class="hljs-number">0</span>, framelength = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */</span>
    <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Return error: OWN bit set */</span>
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }

    <span class="hljs-keyword">if</span>(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET))
    {
        <span class="hljs-comment">/* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */</span>
        framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - <span class="hljs-number">4</span>;
        <span class="hljs-comment">/* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */</span>
        <span class="hljs-keyword">for</span>(offset=<span class="hljs-number">0</span>; offset&lt;framelength; offset++)
        {
            (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet-&gt;Buffer1Addr) + offset));
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Return ERROR */</span>
        framelength = ETH_ERROR;
    }
    <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */</span>
    DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN;

    <span class="hljs-comment">/* When Rx Buffer unavailable flag is set: clear it and resume reception */</span>
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Clear RBUS ETHERNET DMA flag */</span>
        ETH-&gt;DMASR = ETH_DMASR_RBUS;
        <span class="hljs-comment">/* Resume DMA reception */</span>
        ETH-&gt;DMARPDR = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */</span>
    <span class="hljs-comment">/* Chained Mode */</span>
    <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer to read */</span>
        DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* Ring Mode */</span>
    {
        <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET)
        {
            <span class="hljs-comment">/* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer to read */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
        }
    }

    <span class="hljs-comment">/* Return Frame Length/ERROR */</span>
    <span class="hljs-keyword">return</span> (framelength);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the size of received the received packet. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> framelength: received packet size */</span>
uint32_t ETH_GetRxPktSize(<span class="hljs-keyword">void</span>)
{
    uint32_t frameLength = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET))
    {
        <span class="hljs-comment">/* Get the size of the packet: including 4 bytes of the CRC */</span>
        frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet);
    }

    <span class="hljs-comment">/* Return Frame Length */</span>
    <span class="hljs-keyword">return</span> frameLength;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Drop a Received packet (too small packet, etc...) *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DropRxPkt(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */</span>
    DMARxDescToGet-&gt;Status = ETH_DMARxDesc_OWN;
    <span class="hljs-comment">/* Chained Mode */</span>
    <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer read */</span>
        DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* Ring Mode */</span>
    {
        <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET)
        {
            <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer read: this will be the first Rx descriptor in this case */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer read */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
        }
    }
}

<span class="hljs-comment">/*--------------------------------- PHY ------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Read a PHY register *<span class="hljs-javadoctag"> @param</span> PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 *<span class="hljs-javadoctag"> @param</span> PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> PHY_BCR: Tranceiver Basic Control Register * <span class="hljs-javadoctag"> @arg</span> PHY_BSR: Tranceiver Basic Status Register * <span class="hljs-javadoctag"> @arg</span> PHY_SR : Tranceiver Status Register * <span class="hljs-javadoctag"> @arg</span> More PHY register could be read depending on the used PHY *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: in case of timeout * MAC MIIDR register value: Data read from the selected PHY register (correct read ) */</span>
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
    uint32_t tmpreg = <span class="hljs-number">0</span>;
    __IO uint32_t timeout = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
    assert_param(IS_ETH_PHY_REG(PHYReg));

    <span class="hljs-comment">/* Get the ETHERNET MACMIIAR value */</span>
    tmpreg = ETH-&gt;MACMIIAR;
    <span class="hljs-comment">/* Keep only the CSR Clock Range CR[2:0] bits value */</span>
    tmpreg &amp;= ~MACMIIAR_CR_MASK;
    <span class="hljs-comment">/* Prepare the MII address register value */</span>
    tmpreg |=(((uint32_t)PHYAddress&lt;&lt;<span class="hljs-number">11</span>) &amp; ETH_MACMIIAR_PA); <span class="hljs-comment">/* Set the PHY device address */</span>
    tmpreg |=(((uint32_t)PHYReg&lt;&lt;<span class="hljs-number">6</span>) &amp; ETH_MACMIIAR_MR);      <span class="hljs-comment">/* Set the PHY register address */</span>
    tmpreg &amp;= ~ETH_MACMIIAR_MW;                              <span class="hljs-comment">/* Set the read mode */</span>
    tmpreg |= ETH_MACMIIAR_MB;                               <span class="hljs-comment">/* Set the MII Busy bit */</span>
    <span class="hljs-comment">/* Write the result value into the MII Address register */</span>
    ETH-&gt;MACMIIAR = tmpreg;
    <span class="hljs-comment">/* Check for the Busy flag */</span>
    do
    {
        timeout++;
        tmpreg = ETH-&gt;MACMIIAR;
    }
    <span class="hljs-keyword">while</span> ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_READ_TO));
    <span class="hljs-comment">/* Return ERROR in case of timeout */</span>
    <span class="hljs-keyword">if</span>(timeout == PHY_READ_TO)
    {
        <span class="hljs-keyword">return</span> (uint16_t)ETH_ERROR;
    }

    <span class="hljs-comment">/* Return data register value */</span>
    <span class="hljs-keyword">return</span> (uint16_t)(ETH-&gt;MACMIIDR);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Write to a PHY register *<span class="hljs-javadoctag"> @param</span> PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: 0,..,31 *<span class="hljs-javadoctag"> @param</span> PHYReg: PHY register address, is the index of one of the 32 PHY register. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> PHY_BCR : Tranceiver Control Register * <span class="hljs-javadoctag"> @arg</span> More PHY register could be written depending on the used PHY *<span class="hljs-javadoctag"> @param</span> PHYValue: the value to write *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: in case of timeout * ETH_SUCCESS: for correct write */</span>
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
    uint32_t tmpreg = <span class="hljs-number">0</span>;
    __IO uint32_t timeout = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
    assert_param(IS_ETH_PHY_REG(PHYReg));

    <span class="hljs-comment">/* Get the ETHERNET MACMIIAR value */</span>
    tmpreg = ETH-&gt;MACMIIAR;
    <span class="hljs-comment">/* Keep only the CSR Clock Range CR[2:0] bits value */</span>
    tmpreg &amp;= ~MACMIIAR_CR_MASK;
    <span class="hljs-comment">/* Prepare the MII register address value */</span>
    tmpreg |=(((uint32_t)PHYAddress&lt;&lt;<span class="hljs-number">11</span>) &amp; ETH_MACMIIAR_PA); <span class="hljs-comment">/* Set the PHY device address */</span>
    tmpreg |=(((uint32_t)PHYReg&lt;&lt;<span class="hljs-number">6</span>) &amp; ETH_MACMIIAR_MR);      <span class="hljs-comment">/* Set the PHY register address */</span>
    tmpreg |= ETH_MACMIIAR_MW;                               <span class="hljs-comment">/* Set the write mode */</span>
    tmpreg |= ETH_MACMIIAR_MB;                               <span class="hljs-comment">/* Set the MII Busy bit */</span>
    <span class="hljs-comment">/* Give the value to the MII data register */</span>
    ETH-&gt;MACMIIDR = PHYValue;
    <span class="hljs-comment">/* Write the result value into the MII Address register */</span>
    ETH-&gt;MACMIIAR = tmpreg;
    <span class="hljs-comment">/* Check for the Busy flag */</span>
    do
    {
        timeout++;
        tmpreg = ETH-&gt;MACMIIAR;
    }
    <span class="hljs-keyword">while</span> ((tmpreg &amp; ETH_MACMIIAR_MB) &amp;&amp; (timeout &lt; (uint32_t)PHY_WRITE_TO));
    <span class="hljs-comment">/* Return ERROR in case of timeout */</span>
    <span class="hljs-keyword">if</span>(timeout == PHY_WRITE_TO)
    {
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }

    <span class="hljs-comment">/* Return SUCCESS */</span>
    <span class="hljs-keyword">return</span> ETH_SUCCESS;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the PHY loopBack mode. *<span class="hljs-javadoctag"> @Note</span>: Don't be confused with ETH_MACLoopBackCmd function which enables internal * loopback at MII level *<span class="hljs-javadoctag"> @param</span> PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. * This parameter can be one of the following values: *<span class="hljs-javadoctag"> @param</span> NewState: new state of the PHY loopBack mode. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: in case of bad PHY configuration * ETH_SUCCESS: for correct PHY configuration */</span>
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
    uint16_t tmpreg = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-comment">/* Get the PHY configuration to update it */</span>
    tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR);

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the PHY loopback mode */</span>
        tmpreg |= PHY_Loopback;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the PHY loopback mode: normal mode */</span>
        tmpreg &amp;= (uint16_t)(~(uint16_t)PHY_Loopback);
    }
    <span class="hljs-comment">/* Update the PHY control register with the new configuration */</span>
    <span class="hljs-keyword">if</span>(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
    {
        <span class="hljs-keyword">return</span> ETH_SUCCESS;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Return SUCCESS */</span>
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }
}

<span class="hljs-comment">/*--------------------------------- MAC ------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC transmission. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC transmission. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACTransmissionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC transmission */</span>
        ETH-&gt;MACCR |= ETH_MACCR_TE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC transmission */</span>
        ETH-&gt;MACCR &amp;= ~ETH_MACCR_TE;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC reception. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC reception. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACReceptionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC reception */</span>
        ETH-&gt;MACCR |= ETH_MACCR_RE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC reception */</span>
        ETH-&gt;MACCR &amp;= ~ETH_MACCR_RE;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the ETHERNET flow control busy bit is set or not. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The new state of flow control busy status bit (SET or RESET). */</span>
FlagStatus ETH_GetFlowControlBusyStatus(<span class="hljs-keyword">void</span>)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* The Flow Control register should not be written to until this bit is cleared */</span>
    <span class="hljs-keyword">if</span> ((ETH-&gt;MACFCR &amp; ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initiate a Pause Control Frame (Full-duplex only). *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_InitiatePauseControlFrame(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* When Set In full duplex MAC initiates pause control frame */</span>
    ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC BackPressure operation activation (Half-duplex only). *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC BackPressure operation activation. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_BackPressureActivationCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Activate the MAC BackPressure operation */</span>
        <span class="hljs-comment">/* In Half duplex: during backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision */</span>
        ETH-&gt;MACFCR |= ETH_MACFCR_FCBBPA;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Desactivate the MAC BackPressure operation */</span>
        ETH-&gt;MACFCR &amp;= ~ETH_MACFCR_FCBBPA;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET MAC flag is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_MAC_FLAG: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_FLAG_TST : Time stamp trigger flag * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_FLAG_MMCT : MMC transmit flag * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_FLAG_MMCR : MMC receive flag * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_FLAG_MMC : MMC flag * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_FLAG_PMT : PMT flag *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET MAC flag (SET or RESET). */</span>
FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG));
    <span class="hljs-keyword">if</span> ((ETH-&gt;MACSR &amp; ETH_MAC_FLAG) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET MAC interrupt has occurred or not. *<span class="hljs-javadoctag"> @param</span> ETH_MAC_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_TST : Time stamp trigger interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_MMCT : MMC transmit interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_MMCR : MMC receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_MMC : MMC interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_PMT : PMT interrupt *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET MAC interrupt (SET or RESET). */</span>
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
{
    ITStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT));
    <span class="hljs-keyword">if</span> ((ETH-&gt;MACSR &amp; ETH_MAC_IT) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified ETHERNET MAC interrupts. *<span class="hljs-javadoctag"> @param</span> ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_TST : Time stamp trigger interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_IT_PMT : PMT interrupt *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified ETHERNET MAC interrupts. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected ETHERNET MAC interrupts */</span>
        ETH-&gt;MACIMR &amp;= (~(uint32_t)ETH_MAC_IT);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected ETHERNET MAC interrupts */</span>
        ETH-&gt;MACIMR |= ETH_MAC_IT;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Configures the selected MAC address. *<span class="hljs-javadoctag"> @param</span> MacAddr: The MAC addres to configure. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address0 : MAC Address0 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address1 : MAC Address1 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address2 : MAC Address2 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address3 : MAC Address3 *<span class="hljs-javadoctag"> @param</span> Addr: Pointer on MAC address buffer data (6 bytes). *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
{
    uint32_t tmpreg;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));

    <span class="hljs-comment">/* Calculate the selectecd MAC address high register */</span>
    tmpreg = ((uint32_t)Addr[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">8</span>) | (uint32_t)Addr[<span class="hljs-number">4</span>];
    <span class="hljs-comment">/* Load the selectecd MAC address high register */</span>
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
    <span class="hljs-comment">/* Calculate the selectecd MAC address low register */</span>
    tmpreg = ((uint32_t)Addr[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) | ((uint32_t)Addr[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) | ((uint32_t)Addr[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) | Addr[<span class="hljs-number">0</span>];

    <span class="hljs-comment">/* Load the selectecd MAC address low register */</span>
    (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the selected MAC address. *<span class="hljs-javadoctag"> @param</span> MacAddr: The MAC addres to return. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address0 : MAC Address0 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address1 : MAC Address1 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address2 : MAC Address2 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address3 : MAC Address3 *<span class="hljs-javadoctag"> @param</span> Addr: Pointer on MAC address buffer data (6 bytes). *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
{
    uint32_t tmpreg;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));

    <span class="hljs-comment">/* Get the selectecd MAC address high register */</span>
    tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));

    <span class="hljs-comment">/* Calculate the selectecd MAC address buffer */</span>
    Addr[<span class="hljs-number">5</span>] = ((tmpreg &gt;&gt; <span class="hljs-number">8</span>) &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
    Addr[<span class="hljs-number">4</span>] = (tmpreg &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
    <span class="hljs-comment">/* Load the selectecd MAC address low register */</span>
    tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
    <span class="hljs-comment">/* Calculate the selectecd MAC address buffer */</span>
    Addr[<span class="hljs-number">3</span>] = ((tmpreg &gt;&gt; <span class="hljs-number">24</span>) &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
    Addr[<span class="hljs-number">2</span>] = ((tmpreg &gt;&gt; <span class="hljs-number">16</span>) &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
    Addr[<span class="hljs-number">1</span>] = ((tmpreg &gt;&gt; <span class="hljs-number">8</span> ) &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
    Addr[<span class="hljs-number">0</span>] = (tmpreg &amp; (uint8_t)<span class="hljs-number">0xFF</span>);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the Address filter module uses the specified * ETHERNET MAC address for perfect filtering *<span class="hljs-javadoctag"> @param</span> MacAddr: specifies the ETHERNET MAC address to be used for prfect filtering. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address1 : MAC Address1 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address2 : MAC Address2 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address3 : MAC Address3 *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified ETHERNET MAC address use. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected ETHERNET MAC address for perfect filtering */</span>
        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected ETHERNET MAC address for perfect filtering */</span>
        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_AE);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Set the filter type for the specified ETHERNET MAC address *<span class="hljs-javadoctag"> @param</span> MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address1 : MAC Address1 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address2 : MAC Address2 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address3 : MAC Address3 *<span class="hljs-javadoctag"> @param</span> Filter: specifies the used frame received field for comparaison * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the * SA fields of the received frame. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the * DA fields of the received frame. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));

    <span class="hljs-keyword">if</span> (Filter != ETH_MAC_AddressFilter_DA)
    {
        <span class="hljs-comment">/* The selected ETHERNET MAC address is used to compare with the SA fields of the received frame. */</span>
        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* The selected ETHERNET MAC address is used to compare with the DA fields of the received frame. */</span>
        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_SA);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Set the filter type for the specified ETHERNET MAC address *<span class="hljs-javadoctag"> @param</span> MacAddr: specifies the ETHERNET MAC address * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address1 : MAC Address1 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address2 : MAC Address2 * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_Address3 : MAC Address3 *<span class="hljs-javadoctag"> @param</span> MaskByte: specifies the used address bytes for comparaison * This parameter can be any combination of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8]. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0]. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24]. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16]. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8]. * <span class="hljs-javadoctag"> @arg</span> ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0]. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
    assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));

    <span class="hljs-comment">/* Clear MBC bits in the selected MAC address high register */</span>
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &amp;=(~(uint32_t)ETH_MACA1HR_MBC);
    <span class="hljs-comment">/* Set the selected Filetr mask bytes */</span>
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
}
<span class="hljs-comment">/*------------------------ DMA Tx/Rx Desciptors -----------------------------*/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Tx descriptors in chain mode. *<span class="hljs-javadoctag"> @param</span> DMATxDescTab: Pointer on the first Tx desc list *<span class="hljs-javadoctag"> @param</span> TxBuff: Pointer on the first TxBuffer list *<span class="hljs-javadoctag"> @param</span> TxBuffCount: Number of the used Tx desc in the list *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMATxDesc;

    <span class="hljs-comment">/* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */</span>
    DMATxDescToSet = DMATxDescTab;
    <span class="hljs-comment">/* Fill each DMATxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; TxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Tx Desc list */</span>
        DMATxDesc = DMATxDescTab + i;
        <span class="hljs-comment">/* Set Second Address Chained bit */</span>
        DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH;

        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Initialize the next descriptor with the Next Desciptor Polling Enable */</span>
        <span class="hljs-keyword">if</span>(i &lt; (TxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set next descriptor address register with next descriptor base address */</span>
            DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</span>
            DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab;
        }
    }

    <span class="hljs-comment">/* Set Transmit Desciptor List Address Register */</span>
    ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Tx descriptors in ring mode. *<span class="hljs-javadoctag"> @param</span> DMATxDescTab: Pointer on the first Tx desc list *<span class="hljs-javadoctag"> @param</span> TxBuff1: Pointer on the first TxBuffer1 list *<span class="hljs-javadoctag"> @param</span> TxBuff2: Pointer on the first TxBuffer2 list *<span class="hljs-javadoctag"> @param</span> TxBuffCount: Number of the used Tx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMATxDesc;

    <span class="hljs-comment">/* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */</span>
    DMATxDescToSet = DMATxDescTab;
    <span class="hljs-comment">/* Fill each DMATxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; TxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Tx Desc list */</span>
        DMATxDesc = DMATxDescTab + i;
        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMATxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;TxBuff1[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Set Buffer2 address pointer */</span>
        DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;TxBuff2[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */</span>
        <span class="hljs-keyword">if</span>(i == (TxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set Transmit End of Ring bit */</span>
            DMATxDesc-&gt;Status = ETH_DMATxDesc_TER;
        }
    }

    <span class="hljs-comment">/* Set Transmit Desciptor List Address Register */</span>
    ETH-&gt;DMATDLAR =  (uint32_t) DMATxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET DMA Tx Desc flag is set or not. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> ETH_DMATxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_IC : Interrupt on completetion * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_LS : Last Segment * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_FS : First Segment * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_DC : Disable CRC * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_DP : Disable Pad * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_TER : Transmit End of Ring * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_TCH : Second Address Chained * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_TTSS: Tx Time Stamp Status * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_IHE : IP Header Error * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ES : Error summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_JT : Jabber Timeout * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_FF : Frame Flushed: DMA/MTL flushed the frame due to SW flush * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_PCE : Payload Checksum Error * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during tramsmission * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_NC : No Carrier: no carrier signal from the tranceiver * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_EC : Excessive Collision: transmission aborted after 16 collisions * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_VF : VLAN Frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_CC : Collision Count * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ED : Excessive Deferral * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_UF : Underflow Error: late data arrival from the memory * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_DB : Deferred Bit *<span class="hljs-javadoctag"> @retval</span> The new state of ETH_DMATxDescFlag (SET or RESET). */</span>
FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));

    <span class="hljs-keyword">if</span> ((DMATxDesc-&gt;Status &amp; ETH_DMATxDescFlag) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Returns the specified ETHERNET DMA Tx Desc collision count. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @retval</span> The Transmit descriptor collision counter value. */</span>
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
{
    <span class="hljs-comment">/* Return the Receive descriptor frame length */</span>
    <span class="hljs-keyword">return</span> ((DMATxDesc-&gt;Status &amp; ETH_DMATxDesc_CC) &gt;&gt; ETH_DMATXDESC_COLLISION_COUNTSHIFT);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Set the specified DMA Tx Desc Own bit. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: Pointer on a Tx desc *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
{
    <span class="hljs-comment">/* Set the DMA Tx Desc Own bit */</span>
    DMATxDesc-&gt;Status |= ETH_DMATxDesc_OWN;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified DMA Tx Desc Transmit interrupt. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: Pointer on a Tx desc *<span class="hljs-javadoctag"> @param</span> NewState: new state of the DMA Tx Desc transmit interrupt. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the DMA Tx Desc Transmit interrupt */</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_IC;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the DMA Tx Desc Transmit interrupt */</span>
        DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_IC);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified DMA Tx Desc Transmit interrupt. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: Pointer on a Tx desc *<span class="hljs-javadoctag"> @param</span> DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_LastSegment : actual Tx desc contain last segment * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));

    <span class="hljs-comment">/* Selects the DMA Tx Desc Frame segment */</span>
    DMATxDesc-&gt;Status |= DMATxDesc_FrameSegment;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Selects the specified ETHERNET DMA Tx Desc Checksum Insertion. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ChecksumByPass : Checksum bypass * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present * <span class="hljs-javadoctag"> @arg</span> ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));

    <span class="hljs-comment">/* Set the selected DMA Tx desc checksum insertion control */</span>
    DMATxDesc-&gt;Status |= DMATxDesc_Checksum;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Tx Desc CRC. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Tx Desc CRC. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Tx Desc CRC */</span>
        DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DC);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Tx Desc CRC */</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_DC;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Tx Desc end of ring. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Tx Desc end of ring. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Tx Desc end of ring */</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_TER;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Tx Desc end of ring */</span>
        DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_TER);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Tx Desc second address chained. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Tx Desc second address chained. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Tx Desc second address chained */</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_TCH;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Tx Desc second address chained */</span>
        DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TCH);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */</span>
        DMATxDesc-&gt;Status &amp;= (~(uint32_t)ETH_DMATxDesc_DP);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_DP;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Tx Desc time stamp. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: pointer on a DMA Tx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Tx Desc time stamp. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Tx Desc time stamp */</span>
        DMATxDesc-&gt;Status |= ETH_DMATxDesc_TTSE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Tx Desc time stamp */</span>
        DMATxDesc-&gt;Status &amp;=(~(uint32_t)ETH_DMATxDesc_TTSE);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Configures the specified DMA Tx Desc buffer1 and buffer2 sizes. *<span class="hljs-javadoctag"> @param</span> DMATxDesc: Pointer on a Tx desc *<span class="hljs-javadoctag"> @param</span> BufferSize1: specifies the Tx desc buffer1 size. *<span class="hljs-javadoctag"> @param</span> BufferSize2: specifies the Tx desc buffer2 size (put "0" if not used). *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
    assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));

    <span class="hljs-comment">/* Set the DMA Tx Desc buffer1 and buffer2 sizes values */</span>
    DMATxDesc-&gt;ControlBufferSize |= (BufferSize1 | (BufferSize2 &lt;&lt; ETH_DMATXDESC_BUFFER2_SIZESHIFT));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Rx descriptors in chain mode. *<span class="hljs-javadoctag"> @param</span> DMARxDescTab: Pointer on the first Rx desc list *<span class="hljs-javadoctag"> @param</span> RxBuff: Pointer on the first RxBuffer list *<span class="hljs-javadoctag"> @param</span> RxBuffCount: Number of the used Rx desc in the list *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMARxDesc;

    <span class="hljs-comment">/* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */</span>
    DMARxDescToGet = DMARxDescTab;
    <span class="hljs-comment">/* Fill each DMARxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; RxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Rx Desc list */</span>
        DMARxDesc = DMARxDescTab+i;
        <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status */</span>
        DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN;

        <span class="hljs-comment">/* Set Buffer1 size and Second Address Chained bit */</span>
        DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;
        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Initialize the next descriptor with the Next Desciptor Polling Enable */</span>
        <span class="hljs-keyword">if</span>(i &lt; (RxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set next descriptor address register with next descriptor base address */</span>
            DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</span>
            DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab);
        }
    }

    <span class="hljs-comment">/* Set Receive Desciptor List Address Register */</span>
    ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Rx descriptors in ring mode. *<span class="hljs-javadoctag"> @param</span> DMARxDescTab: Pointer on the first Rx desc list *<span class="hljs-javadoctag"> @param</span> RxBuff1: Pointer on the first RxBuffer1 list *<span class="hljs-javadoctag"> @param</span> RxBuff2: Pointer on the first RxBuffer2 list *<span class="hljs-javadoctag"> @param</span> RxBuffCount: Number of the used Rx desc in the list * Note: see decriptor skip length defined in ETH_DMA_InitStruct * for the number of Words to skip between two unchained descriptors. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMARxDesc;
    <span class="hljs-comment">/* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */</span>
    DMARxDescToGet = DMARxDescTab;
    <span class="hljs-comment">/* Fill each DMARxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; RxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Rx Desc list */</span>
        DMARxDesc = DMARxDescTab+i;
        <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status */</span>
        DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN;
        <span class="hljs-comment">/* Set Buffer1 size */</span>
        DMARxDesc-&gt;ControlBufferSize = ETH_MAX_PACKET_SIZE;
        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff1[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Set Buffer2 address pointer */</span>
        DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(&amp;RxBuff2[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Set Receive End of Ring bit for last descriptor: The DMA returns to the base address of the list, creating a Desciptor Ring */</span>
        <span class="hljs-keyword">if</span>(i == (RxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set Receive End of Ring bit */</span>
            DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER;
        }
    }

    <span class="hljs-comment">/* Set Receive Desciptor List Address Register */</span>
    ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET Rx Desc flag is set or not. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: pointer on a DMA Rx descriptor *<span class="hljs-javadoctag"> @param</span> ETH_DMARxDescFlag: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_OWN: OWN bit: descriptor is owned by DMA engine * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_AFM: DA Filter Fail for the rx frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_ES: Error summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_DE: Desciptor error: no more descriptors for receive frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_SAF: SA Filter Fail for the received frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_LE: Frame size not matching with length field * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_OE: Overflow Error: Frame was damaged due to buffer overflow * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_VLAN: VLAN Tag: received frame is a VLAN frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_FS: First descriptor of the frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_LS: Last descriptor of the frame * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_IPV4HCE: IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_LC: Late collision occurred during reception * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_FT: Frame type - Ethernet, otherwise 802.3 * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_RWT: Receive Watchdog Timeout: watchdog timer expired during reception * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_RE: Receive error: error reported by MII interface * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_DE: Dribble bit error: frame contains non int multiple of 8 bits * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_CE: CRC error * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_MAMPCE: Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error *<span class="hljs-javadoctag"> @retval</span> The new state of ETH_DMARxDescFlag (SET or RESET). */</span>
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
    <span class="hljs-keyword">if</span> ((DMARxDesc-&gt;Status &amp; ETH_DMARxDescFlag) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Set the specified DMA Rx Desc Own bit. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: Pointer on a Rx desc *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
{
    <span class="hljs-comment">/* Set the DMA Rx Desc Own bit */</span>
    DMARxDesc-&gt;Status |= ETH_DMARxDesc_OWN;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Returns the specified DMA Rx Desc frame length. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: pointer on a DMA Rx descriptor *<span class="hljs-javadoctag"> @retval</span> The Rx descriptor received frame length. */</span>
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
    <span class="hljs-comment">/* Return the Receive descriptor frame length */</span>
    <span class="hljs-keyword">return</span> ((DMARxDesc-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified DMA Rx Desc receive interrupt. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: Pointer on a Rx desc *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Rx Desc interrupt. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the DMA Rx Desc receive interrupt */</span>
        DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_DIC);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the DMA Rx Desc receive interrupt */</span>
        DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_DIC;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Rx Desc end of ring. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: pointer on a DMA Rx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Rx Desc end of ring. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Rx Desc end of ring */</span>
        DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RER;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Rx Desc end of ring */</span>
        DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RER);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA Rx Desc second address chained. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: pointer on a DMA Rx descriptor *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified DMA Rx Desc second address chained. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected DMA Rx Desc second address chained */</span>
        DMARxDesc-&gt;ControlBufferSize |= ETH_DMARxDesc_RCH;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected DMA Rx Desc second address chained */</span>
        DMARxDesc-&gt;ControlBufferSize &amp;=(~(uint32_t)ETH_DMARxDesc_RCH);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Returns the specified ETHERNET DMA Rx Desc buffer size. *<span class="hljs-javadoctag"> @param</span> DMARxDesc: pointer on a DMA Rx descriptor *<span class="hljs-javadoctag"> @param</span> DMARxDesc_Buffer: specifies the DMA Rx Desc buffer. * This parameter can be any one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1 * <span class="hljs-javadoctag"> @arg</span> ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2 *<span class="hljs-javadoctag"> @retval</span> The Receive descriptor frame length. */</span>
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));

    <span class="hljs-keyword">if</span>(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
    {
        <span class="hljs-comment">/* Return the DMA Rx Desc buffer2 size */</span>
        <span class="hljs-keyword">return</span> ((DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS2) &gt;&gt; ETH_DMARXDESC_BUFFER2_SIZESHIFT);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Return the DMA Rx Desc buffer1 size */</span>
        <span class="hljs-keyword">return</span> (DMARxDesc-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RBS1);
    }
}

<span class="hljs-comment">/*--------------------------------- DMA ------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Resets all MAC subsystem internal registers and logic. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SoftwareReset(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Set the SWR bit: resets all MAC subsystem internal registers and logic */</span>
    <span class="hljs-comment">/* After reset all the registers holds their respective reset values */</span>
    ETH-&gt;DMABMR |= ETH_DMABMR_SR;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the ETHERNET software reset bit is set or not. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The new state of DMA Bus Mode register SR bit (SET or RESET). */</span>
FlagStatus ETH_GetSoftwareResetStatus(<span class="hljs-keyword">void</span>)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-keyword">if</span>((ETH-&gt;DMABMR &amp; ETH_DMABMR_SR) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET DMA flag is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_FLAG: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TST : Time-stamp trigger flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_PMT : PMT flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_MMC : MMC flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_ReadWriteError : Error bits 0-write trnsf, 1-read transfr * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_AccessError : Error bits 0-Rx DMA, 1-Tx DMA * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_NIS : Normal interrupt summary flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_ER : Early receive flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_FBE : Fatal bus error flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_ET : Early transmit flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RPS : Receive process stopped flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_R : Receive flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TU : Underflow flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RO : Overflow flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TPS : Transmit process stopped flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_T : Transmit flag *<span class="hljs-javadoctag"> @retval</span> The new state of ETH_DMA_FLAG (SET or RESET). */</span>
FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMA_FLAG) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Clears the ETHERNET's DMA pending flag. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_FLAG: specifies the flag to clear. * This parameter can be any combination of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_NIS : Normal interrupt summary flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_ER : Early receive flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_FBE : Fatal bus error flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_ETI : Early transmit flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RWT : Receive watchdog timeout flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RPS : Receive process stopped flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RBU : Receive buffer unavailable flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_R : Receive flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TU : Transmit Underflow flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_RO : Receive Overflow flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TJT : Transmit jabber timeout flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_TPS : Transmit process stopped flag * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_FLAG_T : Transmit flag *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));

    <span class="hljs-comment">/* Clear the selected ETHERNET DMA FLAG */</span>
    ETH-&gt;DMASR = (uint32_t) ETH_DMA_FLAG;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET DMA interrupt has occured or not. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_IT: specifies the interrupt source to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TST : Time-stamp trigger interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_PMT : PMT interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_MMC : MMC interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_NIS : Normal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_AIS : Abnormal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ER : Early receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_FBE : Fatal bus error interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ET : Early transmit interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RPS : Receive process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_R : Receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TU : Underflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RO : Overflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TPS : Transmit process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_T : Transmit interrupt *<span class="hljs-javadoctag"> @retval</span> The new state of ETH_DMA_IT (SET or RESET). */</span>
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
{
    ITStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMA_IT) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Clears the ETHERNET's DMA IT pending bit. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_IT: specifies the interrupt pending bit to clear. * This parameter can be any combination of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_NIS : Normal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_AIS : Abnormal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ER : Early receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_FBE : Fatal bus error interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ETI : Early transmit interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RPS : Receive process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_R : Receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TU : Transmit Underflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RO : Receive Overflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TPS : Transmit process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_T : Transmit interrupt *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));

    <span class="hljs-comment">/* Clear the selected ETHERNET DMA IT */</span>
    ETH-&gt;DMASR = (uint32_t) ETH_DMA_IT;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Returns the ETHERNET DMA Transmit Process State. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The new ETHERNET DMA Transmit Process State: * This can be one of the following values: * - ETH_DMA_TransmitProcess_Stopped : Stopped - Reset or Stop Tx Command issued * - ETH_DMA_TransmitProcess_Fetching : Running - fetching the Tx descriptor * - ETH_DMA_TransmitProcess_Waiting : Running - waiting for status * - ETH_DMA_TransmitProcess_Reading : unning - reading the data from host memory * - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe * - ETH_DMA_TransmitProcess_Closing : Running - closing Rx descriptor */</span>
uint32_t ETH_GetTransmitProcessState(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_TS));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Returns the ETHERNET DMA Receive Process State. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The new ETHERNET DMA Receive Process State: * This can be one of the following values: * - ETH_DMA_ReceiveProcess_Stopped : Stopped - Reset or Stop Rx Command issued * - ETH_DMA_ReceiveProcess_Fetching : Running - fetching the Rx descriptor * - ETH_DMA_ReceiveProcess_Waiting : Running - waiting for packet * - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable * - ETH_DMA_ReceiveProcess_Closing : Running - closing descriptor * - ETH_DMA_ReceiveProcess_Queuing : Running - queuing the recieve frame into host memory */</span>
uint32_t ETH_GetReceiveProcessState(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMASR &amp; ETH_DMASR_RS));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Clears the ETHERNET transmit FIFO. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_FlushTransmitFIFO(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Set the Flush Transmit FIFO bit */</span>
    ETH-&gt;DMAOMR |= ETH_DMAOMR_FTF;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the ETHERNET transmit FIFO bit is cleared or not. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET flush transmit FIFO bit (SET or RESET). */</span>
FlagStatus ETH_GetFlushTransmitFIFOStatus(<span class="hljs-keyword">void</span>)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMAOMR &amp; ETH_DMAOMR_FTF) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA transmission. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the DMA transmission. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMATransmissionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the DMA transmission */</span>
        ETH-&gt;DMAOMR |= ETH_DMAOMR_ST;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the DMA transmission */</span>
        ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_ST;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the DMA reception. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the DMA reception. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAReceptionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the DMA reception */</span>
        ETH-&gt;DMAOMR |= ETH_DMAOMR_SR;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the DMA reception */</span>
        ETH-&gt;DMAOMR &amp;= ~ETH_DMAOMR_SR;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified ETHERNET DMA interrupts. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be * enabled or disabled. * This parameter can be any combination of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_NIS : Normal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_AIS : Abnormal interrupt summary * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ER : Early receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_FBE : Fatal bus error interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_ET : Early transmit interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RWT : Receive watchdog timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RPS : Receive process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RBU : Receive buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_R : Receive interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TU : Underflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_RO : Overflow interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TJT : Transmit jabber timeout interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_TPS : Transmit process stopped interrupt * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_IT_T : Transmit interrupt *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified ETHERNET DMA interrupts. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the selected ETHERNET DMA interrupts */</span>
        ETH-&gt;DMAIER |= ETH_DMA_IT;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the selected ETHERNET DMA interrupts */</span>
        ETH-&gt;DMAIER &amp;=(~(uint32_t)ETH_DMA_IT);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET DMA overflow flag is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_DMA_Overflow: specifies the DMA overflow flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter * <span class="hljs-javadoctag"> @arg</span> ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET DMA overflow Flag (SET or RESET). */</span>
FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));

    <span class="hljs-keyword">if</span> ((ETH-&gt;DMAMFBOCR &amp; ETH_DMA_Overflow) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA Rx Overflow Missed Frame Counter value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of Rx overflow Missed Frame Counter. */</span>
uint32_t ETH_GetRxOverflowMissedFrameCounter(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)((ETH-&gt;DMAMFBOCR &amp; ETH_DMAMFBOCR_MFA)&gt;&gt;ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of Buffer unavailable Missed Frame Counter. */</span>
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMAMFBOCR) &amp; ETH_DMAMFBOCR_MFC);
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA DMACHTDR register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of the current Tx desc start address. */</span>
uint32_t ETH_GetCurrentTxDescStartAddress(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMACHTDR));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA DMACHRDR register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of the current Rx desc start address. */</span>
uint32_t ETH_GetCurrentRxDescStartAddress(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMACHRDR));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA DMACHTBAR register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of the current Tx buffer address. */</span>
uint32_t ETH_GetCurrentTxBufferAddress(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMACHTBAR));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the ETHERNET DMA DMACHRBAR register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> The value of the current Rx buffer address. */</span>
uint32_t ETH_GetCurrentRxBufferAddress(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> ((uint32_t)(ETH-&gt;DMACHRBAR));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Resumes the DMA Transmission by writing to the DmaTxPollDemand register * (the data written could be anything). This forces the DMA to resume transmission. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None. */</span>
<span class="hljs-keyword">void</span> ETH_ResumeDMATransmission(<span class="hljs-keyword">void</span>)
{
    ETH-&gt;DMATPDR = <span class="hljs-number">0</span>;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Resumes the DMA Transmission by writing to the DmaRxPollDemand register * (the data written could be anything). This forces the DMA to resume reception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None. */</span>
<span class="hljs-keyword">void</span> ETH_ResumeDMAReception(<span class="hljs-keyword">void</span>)
{
    ETH-&gt;DMARPDR = <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/*--------------------------------- PMT ------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Reset Wakeup frame filter register pointer. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_ResetWakeUpFrameFilterRegisterPointer(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */</span>
    ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Populates the remote wakeup frame registers. *<span class="hljs-javadoctag"> @param</span> Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words). *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
    uint32_t i = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Fill Remote Wake-up Frame Filter register with Buffer data */</span>
    <span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; i&lt;ETH_WAKEUP_REGISTER_LENGTH; i++)
    {
        <span class="hljs-comment">/* Write each time to the same register */</span>
        ETH-&gt;MACRWUFFR = Buffer[i];
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables any unicast packet filtered by the MAC address * recognition to be a wake-up frame. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC Global Unicast Wake-Up. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC Global Unicast Wake-Up */</span>
        ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_GU;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC Global Unicast Wake-Up */</span>
        ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_GU;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET PMT flag is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_PMT_FLAG: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Poniter Reset * <span class="hljs-javadoctag"> @arg</span> ETH_PMT_FLAG_WUFR : Wake-Up Frame Received * <span class="hljs-javadoctag"> @arg</span> ETH_PMT_FLAG_MPR : Magic Packet Received *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET PMT Flag (SET or RESET). */</span>
FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));

    <span class="hljs-keyword">if</span> ((ETH-&gt;MACPMTCSR &amp; ETH_PMT_FLAG) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC Wake-Up Frame Detection. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC Wake-Up Frame Detection. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC Wake-Up Frame Detection */</span>
        ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_WFE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC Wake-Up Frame Detection */</span>
        ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_WFE;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC Magic Packet Detection. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC Magic Packet Detection. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MagicPacketDetectionCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC Magic Packet Detection */</span>
        ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_MPE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC Magic Packet Detection */</span>
        ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_MPE;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MAC Power Down. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MAC Power Down. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_PowerDownCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MAC Power Down */</span>
        <span class="hljs-comment">/* This puts the MAC in power down mode */</span>
        ETH-&gt;MACPMTCSR |= ETH_MACPMTCSR_PD;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MAC Power Down */</span>
        ETH-&gt;MACPMTCSR &amp;= ~ETH_MACPMTCSR_PD;
    }
}

<span class="hljs-comment">/*--------------------------------- MMC ------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MMC Counter Freeze. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MMC Counter Freeze. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MMCCounterFreezeCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MMC Counter Freeze */</span>
        ETH-&gt;MMCCR |= ETH_MMCCR_MCF;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MMC Counter Freeze */</span>
        ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_MCF;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MMC Reset On Read. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MMC Reset On Read. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MMCResetOnReadCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the MMC Counter reset on read */</span>
        ETH-&gt;MMCCR |= ETH_MMCCR_ROR;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the MMC Counter reset on read */</span>
        ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_ROR;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the MMC Counter Stop Rollover. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the MMC Counter Stop Rollover. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MMCCounterRolloverCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Disable the MMC Counter Stop Rollover */</span>
        ETH-&gt;MMCCR &amp;= ~ETH_MMCCR_CSR;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Enable the MMC Counter Stop Rollover */</span>
        ETH-&gt;MMCCR |= ETH_MMCCR_CSR;
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Resets the MMC Counters. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MMCCountersReset(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Resets the MMC Counters */</span>
    ETH-&gt;MMCCR |= ETH_MMCCR_CR;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the specified ETHERNET MMC interrupts. *<span class="hljs-javadoctag"> @param</span> ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. * This parameter can be any combination of Tx interrupt or * any combination of Rx interrupt (but not both)of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value *<span class="hljs-javadoctag"> @param</span> NewState: new state of the specified ETHERNET MMC interrupts. * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> ((ETH_MMC_IT &amp; (uint32_t)<span class="hljs-number">0x10000000</span>) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Remove egister mak from IT */</span>
        ETH_MMC_IT &amp;= <span class="hljs-number">0xEFFFFFFF</span>;

        <span class="hljs-comment">/* ETHERNET MMC Rx interrupts selected */</span>
        <span class="hljs-keyword">if</span> (NewState != DISABLE)
        {
            <span class="hljs-comment">/* Enable the selected ETHERNET MMC interrupts */</span>
            ETH-&gt;MMCRIMR &amp;=(~(uint32_t)ETH_MMC_IT);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Disable the selected ETHERNET MMC interrupts */</span>
            ETH-&gt;MMCRIMR |= ETH_MMC_IT;
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* ETHERNET MMC Tx interrupts selected */</span>
        <span class="hljs-keyword">if</span> (NewState != DISABLE)
        {
            <span class="hljs-comment">/* Enable the selected ETHERNET MMC interrupts */</span>
            ETH-&gt;MMCTIMR &amp;=(~(uint32_t)ETH_MMC_IT);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Disable the selected ETHERNET MMC interrupts */</span>
            ETH-&gt;MMCTIMR |= ETH_MMC_IT;
        }
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET MMC IT is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_MMC_IT: specifies the ETHERNET MMC interrupt. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value * <span class="hljs-javadoctag"> @arg</span> ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value *<span class="hljs-javadoctag"> @retval</span> The value of ETHERNET MMC IT (SET or RESET). */</span>
ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
{
    ITStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT));

    <span class="hljs-keyword">if</span> ((ETH_MMC_IT &amp; (uint32_t)<span class="hljs-number">0x10000000</span>) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* ETHERNET MMC Rx interrupts selected */</span>
        <span class="hljs-comment">/* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */</span>
        <span class="hljs-keyword">if</span> ((((ETH-&gt;MMCRIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET))
        {
            bitstatus = SET;
        }
        <span class="hljs-keyword">else</span>
        {
            bitstatus = RESET;
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* ETHERNET MMC Tx interrupts selected */</span>
        <span class="hljs-comment">/* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */</span>
        <span class="hljs-keyword">if</span> ((((ETH-&gt;MMCTIR &amp; ETH_MMC_IT) != (uint32_t)RESET)) &amp;&amp; ((ETH-&gt;MMCRIMR &amp; ETH_MMC_IT) != (uint32_t)RESET))
        {
            bitstatus = SET;
        }
        <span class="hljs-keyword">else</span>
        {
            bitstatus = RESET;
        }
    }

    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the specified ETHERNET MMC register value. *<span class="hljs-javadoctag"> @param</span> ETH_MMCReg: specifies the ETHERNET MMC register. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_MMCCR : MMC CR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCRIR : MMC RIR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCTIR : MMC TIR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCRIMR : MMC RIMR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCTIMR : MMC TIMR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCTGFSCCR : MMC TGFSCCR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCTGFMSCCR: MMC TGFMSCCR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCTGFCR : MMC TGFCR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCRFCECR : MMC RFCECR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCRFAECR : MMC RFAECR register * <span class="hljs-javadoctag"> @arg</span> ETH_MMCRGUFCR : MMC RGUFCRregister *<span class="hljs-javadoctag"> @retval</span> The value of ETHERNET MMC Register value. */</span>
uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));

    <span class="hljs-comment">/* Return the selected register value */</span>
    <span class="hljs-keyword">return</span> (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
}
<span class="hljs-comment">/*--------------------------------- PTP ------------------------------------*/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Updated the PTP block for fine correction with the Time Stamp Addend register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampAddend(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Enable the PTP block update with the Time Stamp Addend register value */</span>
    ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSARU;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enable the PTP Time Stamp interrupt trigger *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampInterruptTrigger(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Enable the PTP target time interrupt */</span>
    ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSITE;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Updated the PTP system time with the Time Stamp Update register value. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_EnablePTPTimeStampUpdate(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Enable the PTP system time update with the Time Stamp Update register value */</span>
    ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTU;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initialize the PTP Time Stamp *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_InitializePTPTimeStamp(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Initialize the PTP Time Stamp */</span>
    ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSSTI;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Selects the PTP Update method *<span class="hljs-javadoctag"> @param</span> UpdateMethod: the PTP Update method * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_FineUpdate : Fine Update method * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_CoarseUpdate : Coarse Update method *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));

    <span class="hljs-keyword">if</span> (UpdateMethod != ETH_PTP_CoarseUpdate)
    {
        <span class="hljs-comment">/* Enable the PTP Fine Update method */</span>
        ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSFCU;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the PTP Coarse Update method */</span>
        ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSFCU);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Enables or disables the PTP time stamp for transmit and receive frames. *<span class="hljs-javadoctag"> @param</span> NewState: new state of the PTP time stamp for transmit and receive frames * This parameter can be: ENABLE or DISABLE. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_PTPTimeStampCmd(FunctionalState NewState)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_FUNCTIONAL_STATE(NewState));

    <span class="hljs-keyword">if</span> (NewState != DISABLE)
    {
        <span class="hljs-comment">/* Enable the PTP time stamp for transmit and receive frames */</span>
        ETH-&gt;PTPTSCR |= ETH_PTPTSCR_TSE;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Disable the PTP time stamp for transmit and receive frames */</span>
        ETH-&gt;PTPTSCR &amp;= (~(uint32_t)ETH_PTPTSCR_TSE);
    }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Checks whether the specified ETHERNET PTP flag is set or not. *<span class="hljs-javadoctag"> @param</span> ETH_PTP_FLAG: specifies the flag to check. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_FLAG_TSARU : Addend Register Update * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_FLAG_TSITE : Time Stamp Interrupt Trigger Enable * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_FLAG_TSSTU : Time Stamp Update * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_FLAG_TSSTI : Time Stamp Initialize *<span class="hljs-javadoctag"> @retval</span> The new state of ETHERNET PTP Flag (SET or RESET). */</span>
FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG)
{
    FlagStatus bitstatus = RESET;
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG));

    <span class="hljs-keyword">if</span> ((ETH-&gt;PTPTSCR &amp; ETH_PTP_FLAG) != (uint32_t)RESET)
    {
        bitstatus = SET;
    }
    <span class="hljs-keyword">else</span>
    {
        bitstatus = RESET;
    }
    <span class="hljs-keyword">return</span> bitstatus;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Sets the system time Sub-Second Increment value. *<span class="hljs-javadoctag"> @param</span> SubSecondValue: specifies the PTP Sub-Second Increment Register value. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue));
    <span class="hljs-comment">/* Set the PTP Sub-Second Increment Register */</span>
    ETH-&gt;PTPSSIR = SubSecondValue;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Sets the Time Stamp update sign and values. *<span class="hljs-javadoctag"> @param</span> Sign: specifies the PTP Time update value sign. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_PositiveTime : positive time value. * <span class="hljs-javadoctag"> @arg</span> ETH_PTP_NegativeTime : negative time value. *<span class="hljs-javadoctag"> @param</span> SecondValue: specifies the PTP Time update second value. *<span class="hljs-javadoctag"> @param</span> SubSecondValue: specifies the PTP Time update sub-second value. * This parameter is a 31 bit value, bit32 correspond to the sign. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PTP_TIME_SIGN(Sign));
    assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue));
    <span class="hljs-comment">/* Set the PTP Time Update High Register */</span>
    ETH-&gt;PTPTSHUR = SecondValue;

    <span class="hljs-comment">/* Set the PTP Time Update Low Register with sign */</span>
    ETH-&gt;PTPTSLUR = Sign | SubSecondValue;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Sets the Time Stamp Addend value. *<span class="hljs-javadoctag"> @param</span> Value: specifies the PTP Time Stamp Addend Register value. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetPTPTimeStampAddend(uint32_t Value)
{
    <span class="hljs-comment">/* Set the PTP Time Stamp Addend Register */</span>
    ETH-&gt;PTPTSAR = Value;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Sets the Target Time registers values. *<span class="hljs-javadoctag"> @param</span> HighValue: specifies the PTP Target Time High Register value. *<span class="hljs-javadoctag"> @param</span> LowValue: specifies the PTP Target Time Low Register value. *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue)
{
    <span class="hljs-comment">/* Set the PTP Target Time High Register */</span>
    ETH-&gt;PTPTTHR = HighValue;
    <span class="hljs-comment">/* Set the PTP Target Time Low Register */</span>
    ETH-&gt;PTPTTLR = LowValue;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Get the specified ETHERNET PTP register value. *<span class="hljs-javadoctag"> @param</span> ETH_PTPReg: specifies the ETHERNET PTP register. * This parameter can be one of the following values: * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSCR : Sub-Second Increment Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPSSIR : Sub-Second Increment Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSHR : Time Stamp High Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSLR : Time Stamp Low Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSHUR : Time Stamp High Update Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSLUR : Time Stamp Low Update Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTSAR : Time Stamp Addend Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTTHR : Target Time High Register * <span class="hljs-javadoctag"> @arg</span> ETH_PTPTTLR : Target Time Low Register *<span class="hljs-javadoctag"> @retval</span> The value of ETHERNET PTP Register value. */</span>
uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg)
{
    <span class="hljs-comment">/* Check the parameters */</span>
    assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg));

    <span class="hljs-comment">/* Return the selected register value */</span>
    <span class="hljs-keyword">return</span> (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg));
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Tx descriptors in chain mode with PTP. *<span class="hljs-javadoctag"> @param</span> DMATxDescTab: Pointer on the first Tx desc list *<span class="hljs-javadoctag"> @param</span> DMAPTPTxDescTab: Pointer on the first PTP Tx desc list *<span class="hljs-javadoctag"> @param</span> TxBuff: Pointer on the first TxBuffer list *<span class="hljs-javadoctag"> @param</span> TxBuffCount: Number of the used Tx desc in the list *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMATxDesc;

    <span class="hljs-comment">/* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */</span>
    DMATxDescToSet = DMATxDescTab;
    DMAPTPTxDescToSet = DMAPTPTxDescTab;
    <span class="hljs-comment">/* Fill each DMATxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; TxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Tx Desc list */</span>
        DMATxDesc = DMATxDescTab+i;
        <span class="hljs-comment">/* Set Second Address Chained bit and enable PTP */</span>
        DMATxDesc-&gt;Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;

        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMATxDesc-&gt;Buffer1Addr =(uint32_t)(&amp;TxBuff[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Initialize the next descriptor with the Next Desciptor Polling Enable */</span>
        <span class="hljs-keyword">if</span>(i &lt; (TxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set next descriptor address register with next descriptor base address */</span>
            DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</span>
            DMATxDesc-&gt;Buffer2NextDescAddr = (uint32_t) DMATxDescTab;
        }
        <span class="hljs-comment">/* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */</span>
        (&amp;DMAPTPTxDescTab[i])-&gt;Buffer1Addr = DMATxDesc-&gt;Buffer1Addr;
        (&amp;DMAPTPTxDescTab[i])-&gt;Buffer2NextDescAddr = DMATxDesc-&gt;Buffer2NextDescAddr;
    }
    <span class="hljs-comment">/* Store on the last DMAPTPTxDescTab desc status record the first list address */</span>
    (&amp;DMAPTPTxDescTab[i-<span class="hljs-number">1</span>])-&gt;Status = (uint32_t) DMAPTPTxDescTab;

    <span class="hljs-comment">/* Set Transmit Desciptor List Address Register */</span>
    ETH-&gt;DMATDLAR = (uint32_t) DMATxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the DMA Rx descriptors in chain mode. *<span class="hljs-javadoctag"> @param</span> DMARxDescTab: Pointer on the first Rx desc list *<span class="hljs-javadoctag"> @param</span> DMAPTPRxDescTab: Pointer on the first PTP Rx desc list *<span class="hljs-javadoctag"> @param</span> RxBuff: Pointer on the first RxBuffer list *<span class="hljs-javadoctag"> @param</span> RxBuffCount: Number of the used Rx desc in the list *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
    uint32_t i = <span class="hljs-number">0</span>;
    ETH_DMADESCTypeDef *DMARxDesc;

    <span class="hljs-comment">/* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */</span>
    DMARxDescToGet = DMARxDescTab;
    DMAPTPRxDescToGet = DMAPTPRxDescTab;
    <span class="hljs-comment">/* Fill each DMARxDesc descriptor with the right values */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; RxBuffCount; i++)
    {
        <span class="hljs-comment">/* Get the pointer on the ith member of the Rx Desc list */</span>
        DMARxDesc = DMARxDescTab+i;
        <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status */</span>
        DMARxDesc-&gt;Status = ETH_DMARxDesc_OWN;

        <span class="hljs-comment">/* Set Buffer1 size and Second Address Chained bit */</span>
        DMARxDesc-&gt;ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;
        <span class="hljs-comment">/* Set Buffer1 address pointer */</span>
        DMARxDesc-&gt;Buffer1Addr = (uint32_t)(&amp;RxBuff[i*ETH_MAX_PACKET_SIZE]);

        <span class="hljs-comment">/* Initialize the next descriptor with the Next Desciptor Polling Enable */</span>
        <span class="hljs-keyword">if</span>(i &lt; (RxBuffCount-<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">/* Set next descriptor address register with next descriptor base address */</span>
            DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* For last descriptor, set next descriptor address register equal to the first descriptor base address */</span>
            DMARxDesc-&gt;Buffer2NextDescAddr = (uint32_t)(DMARxDescTab);
        }
        <span class="hljs-comment">/* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */</span>
        (&amp;DMAPTPRxDescTab[i])-&gt;Buffer1Addr = DMARxDesc-&gt;Buffer1Addr;
        (&amp;DMAPTPRxDescTab[i])-&gt;Buffer2NextDescAddr = DMARxDesc-&gt;Buffer2NextDescAddr;
    }
    <span class="hljs-comment">/* Store on the last DMAPTPRxDescTab desc status record the first list address */</span>
    (&amp;DMAPTPRxDescTab[i-<span class="hljs-number">1</span>])-&gt;Status = (uint32_t) DMAPTPRxDescTab;

    <span class="hljs-comment">/* Set Receive Desciptor List Address Register */</span>
    ETH-&gt;DMARDLAR = (uint32_t) DMARxDescTab;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Transmits a packet, from application buffer, pointed by ppkt with Time Stamp values. *<span class="hljs-javadoctag"> @param</span> ppkt: pointer to application packet buffer to transmit. *<span class="hljs-javadoctag"> @param</span> FrameLength: Tx Packet size. *<span class="hljs-javadoctag"> @param</span> PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: in case of Tx desc owned by DMA * ETH_SUCCESS: for correct transmission */</span>
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
    uint32_t offset = <span class="hljs-number">0</span>, timeout = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */</span>
    <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Return ERROR: OWN bit set */</span>
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }
    <span class="hljs-comment">/* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */</span>
    <span class="hljs-keyword">for</span>(offset=<span class="hljs-number">0</span>; offset&lt;FrameLength; offset++)
    {
        (*(__IO uint8_t *)((DMAPTPTxDescToSet-&gt;Buffer1Addr) + offset)) = (*(ppkt + offset));
    }
    <span class="hljs-comment">/* Setting the Frame Length: bits[12:0] */</span>
    DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; (uint32_t)<span class="hljs-number">0x1FFF</span>);
    <span class="hljs-comment">/* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */</span>
    DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
    <span class="hljs-comment">/* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */</span>
    DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN;
    <span class="hljs-comment">/* When Tx Buffer unavailable flag is set: clear it and resume transmission */</span>
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Clear TBUS ETHERNET DMA flag */</span>
        ETH-&gt;DMASR = ETH_DMASR_TBUS;
        <span class="hljs-comment">/* Resume DMA transmission*/</span>
        ETH-&gt;DMATPDR = <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">/* Wait for ETH_DMATxDesc_TTSS flag to be set */</span>
    do
    {
        timeout++;
    }
    <span class="hljs-keyword">while</span> (!(DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TTSS) &amp;&amp; (timeout &lt; <span class="hljs-number">0xFFFF</span>));
    <span class="hljs-comment">/* Return ERROR in case of timeout */</span>
    <span class="hljs-keyword">if</span>(timeout == PHY_READ_TO)
    {
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }
    <span class="hljs-comment">/* Clear the DMATxDescToSet status register TTSS flag */</span>
    DMATxDescToSet-&gt;Status &amp;= ~ETH_DMATxDesc_TTSS;
    *PTPTxTab++ = DMATxDescToSet-&gt;Buffer1Addr;
    *PTPTxTab = DMATxDescToSet-&gt;Buffer2NextDescAddr;
    <span class="hljs-comment">/* Update the ENET DMA current descriptor */</span>
    <span class="hljs-comment">/* Chained Mode */</span>
    <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TCH) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Selects the next DMA Tx descriptor list for next buffer read */</span>
        DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Buffer2NextDescAddr);
        <span class="hljs-keyword">if</span>(DMAPTPTxDescToSet-&gt;Status != <span class="hljs-number">0</span>)
        {
            DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet-&gt;Status);
        }
        <span class="hljs-keyword">else</span>
        {
            DMAPTPTxDescToSet++;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* Ring Mode */</span>
    {
        <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_TER) != (uint32_t)RESET)
        {
            <span class="hljs-comment">/* Selects the next DMA Tx descriptor list for next buffer read: this will be the first Tx descriptor in this case */</span>
            DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR);
            DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMATDLAR);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Selects the next DMA Tx descriptor list for next buffer read */</span>
            DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
            DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
        }
    }
    <span class="hljs-comment">/* Return SUCCESS */</span>
    <span class="hljs-keyword">return</span> ETH_SUCCESS;
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Receives a packet and copies it to memory pointed by ppkt with Time Stamp values. *<span class="hljs-javadoctag"> @param</span> ppkt: pointer to application packet receive buffer. *<span class="hljs-javadoctag"> @param</span> PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values. *<span class="hljs-javadoctag"> @retval</span> ETH_ERROR: if there is error in reception * framelength: received packet size if packet reception is correct */</span>
uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab)
{
    uint32_t offset = <span class="hljs-number">0</span>, framelength = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* Check if the descriptor is owned by the ENET or CPU */</span>
    <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Return error: OWN bit set */</span>
        <span class="hljs-keyword">return</span> ETH_ERROR;
    }
    <span class="hljs-keyword">if</span>(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET) &amp;&amp;
            ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET))
    {
        <span class="hljs-comment">/* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */</span>
        framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARXDESC_FRAME_LENGTHSHIFT) - <span class="hljs-number">4</span>;
        <span class="hljs-comment">/* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */</span>
        <span class="hljs-keyword">for</span>(offset=<span class="hljs-number">0</span>; offset&lt;framelength; offset++)
        {
            (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet-&gt;Buffer1Addr) + offset));
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">/* Return ERROR */</span>
        framelength = ETH_ERROR;
    }
    <span class="hljs-comment">/* When Rx Buffer unavailable flag is set: clear it and resume reception */</span>
    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Clear RBUS ETHERNET DMA flag */</span>
        ETH-&gt;DMASR = ETH_DMASR_RBUS;
        <span class="hljs-comment">/* Resume DMA reception */</span>
        ETH-&gt;DMARPDR = <span class="hljs-number">0</span>;
    }
    *PTPRxTab++ = DMARxDescToGet-&gt;Buffer1Addr;
    *PTPRxTab = DMARxDescToGet-&gt;Buffer2NextDescAddr;
    <span class="hljs-comment">/* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */</span>
    DMARxDescToGet-&gt;Status |= ETH_DMARxDesc_OWN;
    <span class="hljs-comment">/* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */</span>
    <span class="hljs-comment">/* Chained Mode */</span>
    <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RCH) != (uint32_t)RESET)
    {
        <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer read */</span>
        DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Buffer2NextDescAddr);
        <span class="hljs-keyword">if</span>(DMAPTPRxDescToGet-&gt;Status != <span class="hljs-number">0</span>)
        {
            DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet-&gt;Status);
        }
        <span class="hljs-keyword">else</span>
        {
            DMAPTPRxDescToGet++;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* Ring Mode */</span>
    {
        <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;ControlBufferSize &amp; ETH_DMARxDesc_RER) != (uint32_t)RESET)
        {
            <span class="hljs-comment">/* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH-&gt;DMARDLAR);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">/* Selects the next DMA Rx descriptor list for next buffer to read */</span>
            DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + <span class="hljs-number">0x10</span> + ((ETH-&gt;DMABMR &amp; ETH_DMABMR_DSL) &gt;&gt; <span class="hljs-number">2</span>));
        }
    }
    <span class="hljs-comment">/* Return Frame Length/ERROR */</span>
    <span class="hljs-keyword">return</span> (framelength);
}

<span class="hljs-javadoc">/** * @} */</span>


<span class="hljs-comment">/* * STM32 Eth Driver * Change Logs: * Date Author Notes * 2009-10-05 Bernard eth interface driver for STM32F107 CL */</span>

#include &lt;netif/ethernetif.h&gt;
#include &lt;netif/etharp.h&gt;
#include &lt;lwip/icmp.h&gt;
#include <span class="hljs-string">"lwipopts.h"</span>

#define ETH_DEBUG
<span class="hljs-comment">//#define ETH_RX_DUMP</span>
<span class="hljs-comment">//#define ETH_TX_DUMP</span>

#ifdef ETH_DEBUG
#define STM32_ETH_TRACE         FreeRTOS_printf
#<span class="hljs-keyword">else</span>
#define STM32_ETH_TRACE(...)
#endif <span class="hljs-comment">/* ETH_DEBUG */</span>

#<span class="hljs-keyword">if</span> defined(ETH_RX_DUMP) ||  defined(ETH_TX_DUMP)
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> packet_dump(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * msg, <span class="hljs-keyword">const</span> struct pbuf* p)
{
    rt_uint32_t i;
    u8 *ptr = p-&gt;payload;

    STM32_ETH_TRACE(<span class="hljs-string">"%s %d byte\n"</span>, msg, p-&gt;tot_len);

    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;p-&gt;tot_len; i++)
    {
        <span class="hljs-keyword">if</span>( (i%<span class="hljs-number">8</span>) == <span class="hljs-number">0</span> )
        {
            STM32_ETH_TRACE(<span class="hljs-string">" "</span>);
        }
        <span class="hljs-keyword">if</span>( (i%<span class="hljs-number">16</span>) == <span class="hljs-number">0</span> )
        {
            STM32_ETH_TRACE(<span class="hljs-string">"\r\n"</span>);
        }
        STM32_ETH_TRACE(<span class="hljs-string">"%02x "</span>,*ptr);
        ptr++;
    }
    STM32_ETH_TRACE(<span class="hljs-string">"\n\n"</span>);
}
#endif <span class="hljs-comment">/* dump */</span>

<span class="hljs-keyword">static</span> ETH_InitTypeDef ETH_InitStructure;



<span class="hljs-comment">/* initialize the interface */</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Configures the Ethernet Interface *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> Ethernet_Configuration(<span class="hljs-keyword">void</span>)
{
    vu32 Value = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Reset ETHERNET on AHB Bus */</span>
    ETH_DeInit();

    <span class="hljs-comment">/* Software reset */</span>
    ETH_SoftwareReset();

    <span class="hljs-comment">/* Wait for software reset */</span>
    <span class="hljs-keyword">while</span>(ETH_GetSoftwareResetStatus()==SET);

    <span class="hljs-comment">/* ETHERNET Configuration ------------------------------------------------------*/</span>
    <span class="hljs-comment">/* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */</span>
    ETH_StructInit(&amp;ETH_InitStructure);

    <span class="hljs-comment">/* Fill ETH_InitStructure parametrs */</span>
    <span class="hljs-comment">/*------------------------ MAC -----------------------------------*/</span>
    ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable  ;
    ETH_InitStructure.ETH_Speed = ETH_Speed_100M;
    ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;

    ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
    ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
    ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
    ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable;
    ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
    ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
    ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
    ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
#<span class="hljs-keyword">if</span> CHECKSUM_BY_HARDWARE
    ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
#endif <span class="hljs-comment">/* CHECKSUM_BY_HARDWARE */</span>

    <span class="hljs-comment">/*------------------------ DMA -----------------------------------*/</span>

    <span class="hljs-comment">/* When we use the Checksum offload feature, we need to enable the Store and Forward mode: the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */</span>
    ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable;
    ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
    ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;

    ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
    ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
    ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
    ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
    ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
    ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
    ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
    ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

    <span class="hljs-comment">/* Configure ETHERNET */</span>
    Value = ETH_Init(&amp;ETH_InitStructure);

    <span class="hljs-comment">/* Enable DMA Receive interrupt (need to enable in this case Normal interrupt) */</span>
    ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R | ETH_DMA_IT_T, ENABLE);

}


<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> RCC_Configuration(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* Enable ETHERNET clock */</span>
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx |
                          RCC_AHBPeriph_ETH_MAC_Rx, ENABLE);

    <span class="hljs-comment">/* Enable GPIOs clocks */</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |   RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |
                           RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE| RCC_APB2Periph_AFIO, ENABLE);
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> NVIC_Configuration(<span class="hljs-keyword">void</span>)
{
    NVIC_InitTypeDef NVIC_InitStructure;

  <span class="hljs-comment">/* 2 bit for pre-emption priority, 2 bits for subpriority */</span>
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="hljs-comment">//by sunq</span>

    <span class="hljs-comment">/* Enable the EXTI0 Interrupt */</span>
    NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">2</span>;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">0</span>;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&amp;NVIC_InitStructure);
}

<span class="hljs-comment">/* * GPIO Configuration for ETH AF Output Push Pull: - ETH_MDC : PC1 - ETH_MDIO : PA2 - ETH_TX_EN : PB11 - ETH_TXD0 : PB12 - ETH_TXD1 : PB13 - ETH_TXD2 : PC2 - ETH_TXD3 : PB8 - ETH_PPS_OUT / ETH_RMII_PPS_OUT: PB5 Input (Reset Value): - ETH_MII_TX_CLK: PC3 - ETH_MII_RX_CLK / ETH_RMII_REF_CLK: PA1 - ETH_MII_CRS: PA0 - ETH_MII_COL: PA3 - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PA7 - ETH_MII_RXD0: PC4 - ETH_MII_RXD1: PC5 - ETH_MII_RXD2: PB0 - ETH_MII_RXD3: PB1 - ETH_MII_RX_ER: PB10 *************************************** For Remapped Ethernet pins ******************************************* Input (Reset Value): - ETH_MII_RX_DV / ETH_RMII_CRS_DV: PD8 - ETH_MII_RXD0 / ETH_RMII_RXD0: PD9 - ETH_MII_RXD1 / ETH_RMII_RXD1: PD10 - ETH_MII_RXD2: PD11 - ETH_MII_RXD3: PD12 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> GPIO_Configuration(<span class="hljs-keyword">void</span>)
{
    GPIO_InitTypeDef GPIO_InitStructure;

#<span class="hljs-keyword">if</span> STM32_ETH_IO_REMAP
    <span class="hljs-comment">/* ETHERNET pins remapp in STM3210C-EVAL board: RX_DV and RxD[3:0] */</span>
    GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE);
#endif <span class="hljs-comment">/* STM32_ETH_IO_REMAP */</span>

    <span class="hljs-comment">/* MII/RMII Media interface selection */</span>
#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>) <span class="hljs-comment">/* Mode MII. */</span>
    GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_MII);
#elif (RMII_MODE == <span class="hljs-number">1</span>)  <span class="hljs-comment">/* Mode RMII. */</span>
    GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII);
#endif <span class="hljs-comment">/* RMII_MODE */</span>

    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    <span class="hljs-comment">/* MDIO */</span>
    {
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

        <span class="hljs-comment">/* MDC */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
        GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* MDIO */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
        GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    } <span class="hljs-comment">/* MDIO */</span>

    <span class="hljs-comment">/* TXD */</span>
    {
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

        <span class="hljs-comment">/* TX_EN */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* TXD0 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* TXD1 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>)
        <span class="hljs-comment">/* TXD2 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
        GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* TXD3 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* TX_CLK */</span>
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
        GPIO_Init(GPIOC, &amp;GPIO_InitStructure);
#endif <span class="hljs-comment">/* RMII_MODE */</span>
    } <span class="hljs-comment">/* TXD */</span>

    <span class="hljs-comment">/* RXD */</span>
    {
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;

#<span class="hljs-keyword">if</span> (STM32_ETH_IO_REMAP == <span class="hljs-number">0</span>)
        <span class="hljs-comment">/* RX_DV/CRS_DV */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
        GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD0 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
        GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD1 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
        GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>)
        <span class="hljs-comment">/* RXD2 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD3 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
#endif <span class="hljs-comment">/* RMII_MODE */</span>
#<span class="hljs-keyword">else</span>
        <span class="hljs-comment">/* RX_DV/CRS_DV */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
        GPIO_Init(GPIOD, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD0 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
        GPIO_Init(GPIOD, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD1 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
        GPIO_Init(GPIOD, &amp;GPIO_InitStructure);

#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>)
        <span class="hljs-comment">/* RXD2 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
        GPIO_Init(GPIOD, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RXD3 */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
        GPIO_Init(GPIOD, &amp;GPIO_InitStructure);
#endif <span class="hljs-comment">/* RMII_MODE */</span>
#endif <span class="hljs-comment">/* STM32_ETH_IO_REMAP */</span>

#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>)
        <span class="hljs-comment">/* CRS */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
        GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* COL */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
        GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RX_CLK */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
        GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

        <span class="hljs-comment">/* RX_ER */</span>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
        GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
#endif <span class="hljs-comment">/* RMII_MODE */</span>
    } <span class="hljs-comment">/* RXD */</span>

#<span class="hljs-keyword">if</span> (USE_MCO == <span class="hljs-number">1</span>)
#<span class="hljs-keyword">if</span> (RMII_MODE == <span class="hljs-number">0</span>) <span class="hljs-comment">/* Mode MII. */</span>
    <span class="hljs-comment">/* Get HSE clock = 25MHz on PA8 pin(MCO) */</span>
    RCC_MCOConfig(RCC_MCO_HSE);
#elif (RMII_MODE == <span class="hljs-number">1</span>)  <span class="hljs-comment">/* Mode RMII. */</span>
    <span class="hljs-comment">/* Get HSE clock = 25MHz on PA8 pin(MCO) */</span>
    <span class="hljs-comment">/* set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */</span>
    RCC_PLL3Config(RCC_PLL3Mul_10);
    <span class="hljs-comment">/* Enable PLL3 */</span>
    RCC_PLL3Cmd(ENABLE);
    <span class="hljs-comment">/* Wait till PLL3 is ready */</span>
    <span class="hljs-keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET)
    {}

    <span class="hljs-comment">/* Get clock PLL3 clock on PA8 pin */</span>
    RCC_MCOConfig(RCC_MCO_PLL3CLK);
#endif <span class="hljs-comment">/* RMII_MODE */</span>

    <span class="hljs-comment">/* MCO pin configuration------------------------------------------------- */</span>
    <span class="hljs-comment">/* Configure MCO (PA8) as alternate function push-pull */</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
#endif <span class="hljs-comment">/* USE_MCO */</span>
}

<span class="hljs-keyword">void</span> FreeRTOS_Hardware_STMS32_ETH_Init()
{
    RCC_Configuration();
    GPIO_Configuration();
    NVIC_Configuration();


    Ethernet_Configuration();
}
</code></pre> 
  <p>另外我们写一个ethernetif.h头文件：</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef __ETHERNETIF_H__</span>
<span class="hljs-preprocessor">#define __ETHERNETIF_H__</span>


<span class="hljs-preprocessor">#include "lwip/err.h"</span>
<span class="hljs-preprocessor">#include "lwip/netif.h"</span>

err_t ethernetif_init(<span class="hljs-keyword">struct</span> netif *netif);



<span class="hljs-preprocessor">#endif </span>
</code></pre> 
  <p>把它放在third_party\lwip-1.4.1\src\include\netif目录下。</p> 
  <p>到此，驱动部分完成了。 </p> 
  <p>然后，就要修改third_party\lwip-1.4.1\src\netif\ethernetif.c。 <br> ethernetif.c内容主要是针对物理层操作的一个结构体变量进行回调函数指针赋值，并实现链路层发送和接收数据包， <br> 代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs applescript">/**
 * @<span class="hljs-type">file</span>
 * Ethernet Interface Skeleton
 *
 */

/*
 * Copyright (c) <span class="hljs-number">2001</span>-<span class="hljs-number">2004</span> Swedish Institute <span class="hljs-keyword">of</span> Computer Science.
 * All rights reserved.
 *
 * Redistribution <span class="hljs-keyword">and</span> use <span class="hljs-keyword">in</span> source <span class="hljs-keyword">and</span> binary forms, <span class="hljs-keyword">with</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">without</span> modification,
 * are permitted provided <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> following conditions are met:
 *
 * <span class="hljs-number">1.</span> Redistributions <span class="hljs-keyword">of</span> source code must retain <span class="hljs-keyword">the</span> <span class="hljs-keyword">above</span> copyright notice,
 *    this <span class="hljs-type">list</span> <span class="hljs-keyword">of</span> conditions <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> following disclaimer.
 * <span class="hljs-number">2.</span> Redistributions <span class="hljs-keyword">in</span> binary form must reproduce <span class="hljs-keyword">the</span> <span class="hljs-keyword">above</span> copyright notice,
 *    this <span class="hljs-type">list</span> <span class="hljs-keyword">of</span> conditions <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> following disclaimer <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> documentation
 *    <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> other materials provided <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> distribution.
 * <span class="hljs-number">3.</span> The <span class="hljs-property">name</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> author may <span class="hljs-keyword">not</span> be used <span class="hljs-keyword">to</span> endorse <span class="hljs-keyword">or</span> promote products
 *    derived <span class="hljs-keyword">from</span> this software <span class="hljs-keyword">without</span> specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * This <span class="hljs-type">file</span> <span class="hljs-keyword">is</span> part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> lwIP TCP/IP stack.
 *
 * Author: Adam Dunkels &lt;adam@sics.se&gt;
 *
 */

/*
 * This <span class="hljs-type">file</span> <span class="hljs-keyword">is</span> a skeleton <span class="hljs-keyword">for</span> developing Ethernet network interface
 * drivers <span class="hljs-keyword">for</span> lwIP. Add code <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> low_level functions <span class="hljs-keyword">and</span> do a
 * search-<span class="hljs-keyword">and</span>-replace <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-property">word</span> <span class="hljs-string">"ethernetif"</span> <span class="hljs-keyword">to</span> replace <span class="hljs-keyword">it</span> <span class="hljs-keyword">with</span>
 * something <span class="hljs-keyword">that</span> better describes your network interface.
 */

<span class="hljs-comment">#include "lwip/opt.h"</span>
<span class="hljs-comment">#include "lwip/def.h"</span>
<span class="hljs-comment">#include "lwip/mem.h"</span>
<span class="hljs-comment">#include "lwip/pbuf.h"</span>
<span class="hljs-comment">#include "lwip/sys.h"</span>
<span class="hljs-comment">#include "netif/etharp.h"</span>
<span class="hljs-comment">#include "err.h"</span>
<span class="hljs-comment">#include "ethernetif.h"</span>

<span class="hljs-comment">#include "FreeRTOS_net_config.h"</span>
<span class="hljs-comment">#include "stm32_eth.h"</span>
<span class="hljs-comment">#include &lt;string.h&gt;</span>
<span class="hljs-comment">#include "lwip/timers.h"</span>

<span class="hljs-comment">#define netifMTU (1500)</span>
<span class="hljs-comment">#define netifINTERFACE_TASK_STACK_SIZE ( 350 )</span>
<span class="hljs-comment">#define netifINTERFACE_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )</span>
<span class="hljs-comment">#define netifGUARD_BLOCK_TIME ( 250 )</span>
/* The <span class="hljs-property">time</span> <span class="hljs-keyword">to</span> block waiting <span class="hljs-keyword">for</span> input. */
<span class="hljs-comment">#define emacBLOCK_TIME_WAITING_FOR_INPUT ( ( portTickType ) 100 )</span>

/* Define those <span class="hljs-keyword">to</span> better describe your network interface. */
<span class="hljs-comment">#define IFNAME0 's'</span>
<span class="hljs-comment">#define IFNAME1 't'</span>

<span class="hljs-comment">#define ETH_DMARxDesc_FrameLengthShift 16</span>
<span class="hljs-comment">#define ETH_ERROR ((u32)0)</span>
<span class="hljs-comment">#define ETH_SUCCESS ((u32)1)</span>

static struct netif *s_pxNetIf = NULL;
xSemaphoreHandle s_xSemaphore = NULL;

<span class="hljs-comment">#define ETH_RXBUFNB 4</span>
<span class="hljs-comment">#define ETH_TXBUFNB 2</span>

/* Ethernet Rx &amp; Tx DMA Descriptors */
ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB], DMATxDscrTab[ETH_TXBUFNB];

/* Ethernet Receive buffers  */
uint8_t Rx_Buff[ETH_RXBUFNB][ETH_MAX_PACKET_SIZE]; 

/* Ethernet Transmit buffers */
uint8_t Tx_Buff[ETH_TXBUFNB][ETH_MAX_PACKET_SIZE]; 

/* Global pointers <span class="hljs-keyword">to</span> track current transmit <span class="hljs-keyword">and</span> receive descriptors */
extern ETH_DMADESCTypeDef  *DMATxDescToSet;
extern ETH_DMADESCTypeDef  *DMARxDescToGet;

typedef struct
{
    u32 <span class="hljs-property">length</span>;
    u32 buffer;
    ETH_DMADESCTypeDef *descriptor;
}FrameTypeDef;

FrameTypeDef ETH_RxPkt_ChainMode(void);
u32 ETH_GetCurrentTxBuffer(void);
u32 ETH_TxPkt_ChainMode(u16 FrameLength);

static void ethernetif_input( void * pvParameters );
static void arp_timer(void *arg);

/**
 * In this function, <span class="hljs-keyword">the</span> hardware should be initialized.
 * Called <span class="hljs-keyword">from</span> ethernetif_init().
 *
 * @param netif <span class="hljs-keyword">the</span> already initialized lwip network interface structure
 *        <span class="hljs-keyword">for</span> this ethernetif
 */
static void low_level_init(struct netif *netif)
{
  uint32_t i;

  struct ethernetif *ethernetif = netif-&gt;state;

  /* <span class="hljs-keyword">set</span> netif MAC hardware address <span class="hljs-property">length</span> */
  netif-&gt;hwaddr_len = ETHARP_HWADDR_LEN;

  /* <span class="hljs-keyword">set</span> netif MAC hardware address */
  netif-&gt;hwaddr[<span class="hljs-number">0</span>] =  MAC_ADDR0;
  netif-&gt;hwaddr[<span class="hljs-number">1</span>] =  MAC_ADDR1;
  netif-&gt;hwaddr[<span class="hljs-number">2</span>] =  MAC_ADDR2;
  netif-&gt;hwaddr[<span class="hljs-number">3</span>] =  MAC_ADDR3;
  netif-&gt;hwaddr[<span class="hljs-number">4</span>] =  MAC_ADDR4;
  netif-&gt;hwaddr[<span class="hljs-number">5</span>] =  MAC_ADDR5;

  /* <span class="hljs-keyword">set</span> netif maximum transfer unit */
  netif-&gt;mtu = <span class="hljs-number">1500</span>;

  /* Accept broadcast address <span class="hljs-keyword">and</span> ARP traffic */
  netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;

  s_pxNetIf =netif;

  /* create binary semaphore used <span class="hljs-keyword">for</span> informing ethernetif <span class="hljs-keyword">of</span> frame reception */
  <span class="hljs-keyword">if</span> (s_xSemaphore == NULL)
  {
    s_xSemaphore= xSemaphoreCreateCounting(<span class="hljs-number">20</span>,<span class="hljs-number">0</span>);
  }

  /* initialize MAC address <span class="hljs-keyword">in</span> ethernet MAC */ 
  ETH_MACAddressConfig(ETH_MAC_Address0, netif-&gt;hwaddr); 

  /* Initialize Tx Descriptors <span class="hljs-type">list</span>: Chain Mode */
  ETH_DMATxDescChainInit(DMATxDscrTab, &amp;Tx_Buff[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ETH_TXBUFNB);
  /* Initialize Rx Descriptors <span class="hljs-type">list</span>: Chain Mode  */
  ETH_DMARxDescChainInit(DMARxDscrTab, &amp;Rx_Buff[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], ETH_RXBUFNB);

  /* Enable Ethernet Rx interrrupt */
  { 
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ETH_RXBUFNB; i++)
    {
      ETH_DMARxDescReceiveITConfig(&amp;DMARxDscrTab[i], ENABLE);
    }
  }

<span class="hljs-comment">#ifdef CHECKSUM_BY_HARDWARE</span>
  /* Enable <span class="hljs-keyword">the</span> checksum insertion <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> Tx frames */
  {
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ETH_TXBUFNB; i++)
    {
      ETH_DMATxDescChecksumInsertionConfig(&amp;DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
    }
  } 
<span class="hljs-comment">#endif</span>

  /* create <span class="hljs-keyword">the</span> task <span class="hljs-keyword">that</span> handles <span class="hljs-keyword">the</span> ETH_MAC */
  xTaskCreate(ethernetif_input, (const char*) <span class="hljs-string">"Eth_if"</span>, netifINTERFACE_TASK_STACK_SIZE, NULL,
              netifINTERFACE_TASK_PRIORITY,NULL);

  /* Enable MAC <span class="hljs-keyword">and</span> DMA transmission <span class="hljs-keyword">and</span> reception */
  ETH_Start();   
}


/**
 * This function should do <span class="hljs-keyword">the</span> actual transmission <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> packet. The packet <span class="hljs-keyword">is</span>
 * contained <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> pbuf <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> passed <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> function. This pbuf
 * might be chained.
 *
 * @param netif <span class="hljs-keyword">the</span> lwip network interface structure <span class="hljs-keyword">for</span> this ethernetif
 * @param p <span class="hljs-keyword">the</span> MAC packet <span class="hljs-keyword">to</span> send (e.g. IP packet including MAC addresses <span class="hljs-keyword">and</span> type)
 * @<span class="hljs-constant">return</span> ERR_OK <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> packet could be sent
 *         an err_t value <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> packet couldn't be sent
 *
 * @note Returning ERR_MEM here <span class="hljs-keyword">if</span> a DMA queue <span class="hljs-keyword">of</span> your MAC <span class="hljs-keyword">is</span> full can lead <span class="hljs-keyword">to</span>
 *       strange results. You might consider waiting <span class="hljs-keyword">for</span> <span class="hljs-constant">space</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> DMA queue
 *       <span class="hljs-keyword">to</span> become availale <span class="hljs-keyword">since</span> <span class="hljs-keyword">the</span> stack doesn't retry <span class="hljs-keyword">to</span> send a packet
 *       dropped because <span class="hljs-keyword">of</span> memory failure (except <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
  static xSemaphoreHandle xTxSemaphore = NULL;
  struct pbuf *q;
  uint32_t l = <span class="hljs-number">0</span>;
  u8 *buffer ;

  <span class="hljs-keyword">if</span> (xTxSemaphore == NULL)
  {
    vSemaphoreCreateBinary (xTxSemaphore);
  } 

  <span class="hljs-keyword">if</span> (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME))
  {
    buffer =  (u8 *)(ETH_GetCurrentTxBuffer());
    <span class="hljs-keyword">for</span>(q = p; q != NULL; q = q-&gt;next) 
    {
      memcpy((u8_t*)&amp;buffer[l], q-&gt;payload, q-&gt;len);
      l = l + q-&gt;len;
    }
    ETH_TxPkt_ChainMode(l);
    xSemaphoreGive(xTxSemaphore);
  }
<span class="hljs-command"> return</span> ERR_OK;
}





/**
 * Should allocate a pbuf <span class="hljs-keyword">and</span> transfer <span class="hljs-keyword">the</span> bytes <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> incoming
 * packet <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> interface <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> pbuf.
 *
 * @param netif <span class="hljs-keyword">the</span> lwip network interface structure <span class="hljs-keyword">for</span> this ethernetif
 * @<span class="hljs-constant">return</span> a pbuf filled <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> received packet (including MAC header)
 *         NULL <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> memory <span class="hljs-keyword">error</span>
 */
static struct pbuf * low_level_input(struct netif *netif)
{
  struct pbuf *p, *q;
  u16_t len;
  int l =<span class="hljs-number">0</span>;
  FrameTypeDef frame;
  u8 *buffer;

  p = NULL;
  frame = ETH_RxPkt_ChainMode();

    /* Check <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> descriptor <span class="hljs-keyword">is</span> exist */
    <span class="hljs-keyword">if</span>(!frame.descriptor)
<span class="hljs-command"> return</span> p;

  /* Obtain <span class="hljs-keyword">the</span> size <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> packet <span class="hljs-keyword">and</span> <span class="hljs-keyword">put</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> <span class="hljs-string">"len"</span>
     variable. */
  len = frame.<span class="hljs-property">length</span>;

  buffer = (u8 *)frame.buffer;

  /* We allocate a pbuf chain <span class="hljs-keyword">of</span> pbufs <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);

  <span class="hljs-keyword">if</span> (p != NULL)
  {
    <span class="hljs-keyword">for</span> (q = p; q != NULL; q = q-&gt;next)
    {
      memcpy((u8_t*)q-&gt;payload, (u8_t*)&amp;buffer[l], q-&gt;len);
      l = l + q-&gt;len;
    }    
  }


  /* Set Own bit <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> Rx descriptor Status: gives <span class="hljs-keyword">the</span> buffer <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> ETHERNET DMA */
  frame.descriptor-&gt;Status = ETH_DMARxDesc_OWN; 

  /* When Rx Buffer unavailable flag <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>: clear <span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> resume reception */
  <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET)  
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH-&gt;DMASR = ETH_DMASR_RBUS;
    /* Resume DMA reception */
    ETH-&gt;DMARPDR = <span class="hljs-number">0</span>;
  }
<span class="hljs-command"> return</span> p;
}


/**
 * This function <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> ethernetif_input task, <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> processed when a packet 
 * <span class="hljs-keyword">is</span> ready <span class="hljs-keyword">to</span> be <span class="hljs-command">read</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> interface. It uses <span class="hljs-keyword">the</span> function low_level_input() 
 * <span class="hljs-keyword">that</span> should handle <span class="hljs-keyword">the</span> actual reception <span class="hljs-keyword">of</span> bytes <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> network
 * interface. Then <span class="hljs-keyword">the</span> type <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> received packet <span class="hljs-keyword">is</span> determined <span class="hljs-keyword">and</span>
 * <span class="hljs-keyword">the</span> appropriate input function <span class="hljs-keyword">is</span> called.
 *
 * @param netif <span class="hljs-keyword">the</span> lwip network interface structure <span class="hljs-keyword">for</span> this ethernetif
 */
void ethernetif_input( void * pvParameters )
{
  struct pbuf *p;

  <span class="hljs-keyword">for</span>( ;; )
  {
    <span class="hljs-keyword">if</span> (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE)
    {
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
              p = low_level_input( s_pxNetIf );
              <span class="hljs-keyword">if</span>(p!=NULL)
              {   
                  <span class="hljs-keyword">if</span> (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf))
                  {
                    pbuf_free(p);
                    p=NULL;
                  }               
              }
              <span class="hljs-keyword">else</span>
                break;  
        }
    }
  }
}  

/**
 * Should be called <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">beginning</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> program <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> up <span class="hljs-keyword">the</span>
 * network interface. It calls <span class="hljs-keyword">the</span> function low_level_init() <span class="hljs-keyword">to</span> do <span class="hljs-keyword">the</span>
 * actual setup <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> hardware.
 *
 * This function should be passed <span class="hljs-keyword">as</span> a parameter <span class="hljs-keyword">to</span> netif_add().
 *
 * @param netif <span class="hljs-keyword">the</span> lwip network interface structure <span class="hljs-keyword">for</span> this ethernetif
 * @<span class="hljs-constant">return</span> ERR_OK <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> loopif <span class="hljs-keyword">is</span> initialized
 *         ERR_MEM <span class="hljs-keyword">if</span> private data couldn't be allocated
 *         any other err_t <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword">error</span>
 */
err_t ethernetif_init(struct netif *netif)
{
  LWIP_ASSERT(<span class="hljs-string">"netif != NULL"</span>, (netif != NULL));

<span class="hljs-comment">#if LWIP_NETIF_HOSTNAME</span>
  /* Initialize interface hostname */
  netif-&gt;hostname = <span class="hljs-string">"lwip"</span>;
<span class="hljs-comment">#endif /* LWIP_NETIF_HOSTNAME */</span>

  netif-&gt;<span class="hljs-property">name</span>[<span class="hljs-number">0</span>] = IFNAME0;
  netif-&gt;<span class="hljs-property">name</span>[<span class="hljs-number">1</span>] = IFNAME1;

  netif-&gt;output = etharp_output;
  netif-&gt;linkoutput = low_level_output;

  /* initialize <span class="hljs-keyword">the</span> hardware */
  low_level_init(netif);

  etharp_init();
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
<span class="hljs-command"> return</span> ERR_OK;
}


static void arp_timer(void *arg)
{
  etharp_tmr();
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
}



/*******************************************************************************
* Function Name  : ETH_RxPkt_ChainMode
* Description    : Receives a packet.
* Input          : None
* Output         : None
* Return         : frame: farme size <span class="hljs-keyword">and</span> location
*******************************************************************************/
FrameTypeDef ETH_RxPkt_ChainMode(void)
{ 
  u32 framelength = <span class="hljs-number">0</span>;
  FrameTypeDef frame = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}; 

  /* Check <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> descriptor <span class="hljs-keyword">is</span> owned <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> ETHERNET DMA (when <span class="hljs-keyword">set</span>) <span class="hljs-keyword">or</span> CPU (when reset) */
  <span class="hljs-keyword">if</span>((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) != (u32)RESET)
  { 
    frame.<span class="hljs-property">length</span> = ETH_ERROR;

    <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_RBUS) != (u32)RESET)  
    {
      /* Clear RBUS ETHERNET DMA flag */
      ETH-&gt;DMASR = ETH_DMASR_RBUS;
      /* Resume DMA reception */
      ETH-&gt;DMARPDR = <span class="hljs-number">0</span>;
    }

    /* Return <span class="hljs-keyword">error</span>: OWN bit <span class="hljs-keyword">set</span> */
<span class="hljs-command"> return</span> frame; 
  }

  <span class="hljs-keyword">if</span>(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_ES) == (u32)RESET) &amp;&amp; 
     ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (u32)RESET) &amp;&amp;  
     ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (u32)RESET))  
  {      
    /* Get <span class="hljs-keyword">the</span> Frame Length <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> received packet: substruct <span class="hljs-number">4</span> bytes <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> CRC */
    framelength = ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FL) &gt;&gt; ETH_DMARxDesc_FrameLengthShift) - <span class="hljs-number">4</span>;

    /* Get <span class="hljs-keyword">the</span> addrees <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> actual buffer */
    frame.buffer = DMARxDescToGet-&gt;Buffer1Addr; 
  }
  <span class="hljs-keyword">else</span>
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  }

  frame.<span class="hljs-property">length</span> = framelength;


  frame.descriptor = DMARxDescToGet;

  /* Update <span class="hljs-keyword">the</span> ETHERNET DMA <span class="hljs-keyword">global</span> Rx descriptor <span class="hljs-keyword">with</span> next Rx decriptor */      
  /* Chained Mode */    
  /* Selects <span class="hljs-keyword">the</span> next DMA Rx descriptor <span class="hljs-type">list</span> <span class="hljs-keyword">for</span> next buffer <span class="hljs-keyword">to</span> <span class="hljs-command">read</span> */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr);    

  /* Return Frame */
<span class="hljs-command"> return</span> (frame);  
}

/*******************************************************************************
* Function Name  : ETH_TxPkt_ChainMode
* Description    : Transmits a packet, <span class="hljs-keyword">from</span> <span class="hljs-type">application</span> buffer, pointed <span class="hljs-keyword">by</span> ppkt.
* Input          : - FrameLength: Tx Packet size.
* Output         : None
* Return         : ETH_ERROR: <span class="hljs-keyword">in</span> case <span class="hljs-keyword">of</span> Tx desc owned <span class="hljs-keyword">by</span> DMA
*                  ETH_SUCCESS: <span class="hljs-keyword">for</span> correct transmission
*******************************************************************************/
u32 ETH_TxPkt_ChainMode(u16 FrameLength)
{   
  /* Check <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> descriptor <span class="hljs-keyword">is</span> owned <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> ETHERNET DMA (when <span class="hljs-keyword">set</span>) <span class="hljs-keyword">or</span> CPU (when reset) */
  <span class="hljs-keyword">if</span>((DMATxDescToSet-&gt;Status &amp; ETH_DMATxDesc_OWN) != (u32)RESET)
  {  
    /* Return ERROR: OWN bit <span class="hljs-keyword">set</span> */
<span class="hljs-command"> return</span> ETH_ERROR;
  }

  /* Setting <span class="hljs-keyword">the</span> Frame Length: bits[<span class="hljs-number">12</span>:<span class="hljs-number">0</span>] */
  DMATxDescToSet-&gt;ControlBufferSize = (FrameLength &amp; ETH_DMATxDesc_TBS1);

  /* Setting <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> segment <span class="hljs-keyword">and</span> <span class="hljs-keyword">first</span> segment bits (<span class="hljs-keyword">in</span> this case a frame <span class="hljs-keyword">is</span> transmitted <span class="hljs-keyword">in</span> one descriptor) */    
  DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;

  /* Set Own bit <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> Tx descriptor Status: gives <span class="hljs-keyword">the</span> buffer <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> ETHERNET DMA */
  DMATxDescToSet-&gt;Status |= ETH_DMATxDesc_OWN;

  /* When Tx Buffer unavailable flag <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>: clear <span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> resume transmission */
  <span class="hljs-keyword">if</span> ((ETH-&gt;DMASR &amp; ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH-&gt;DMASR = ETH_DMASR_TBUS;
    /* Resume DMA transmission*/
    ETH-&gt;DMATPDR = <span class="hljs-number">0</span>;
  }

  /* Update <span class="hljs-keyword">the</span> ETHERNET DMA <span class="hljs-keyword">global</span> Tx descriptor <span class="hljs-keyword">with</span> next Tx decriptor */  
  /* Chained Mode */
  /* Selects <span class="hljs-keyword">the</span> next DMA Tx descriptor <span class="hljs-type">list</span> <span class="hljs-keyword">for</span> next buffer <span class="hljs-keyword">to</span> send */ 
  DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet-&gt;Buffer2NextDescAddr);    


  /* Return SUCCESS */
<span class="hljs-command"> return</span> ETH_SUCCESS;   
}


/*******************************************************************************
* Function Name  : ETH_GetCurrentTxBuffer
* Description    : Return <span class="hljs-keyword">the</span> address <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> buffer pointed <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> current descritor.
* Input          : None
* Output         : None
* Return         : Buffer address
*******************************************************************************/
u32 ETH_GetCurrentTxBuffer(void)
{ 
  /* Return Buffer address */
<span class="hljs-command"> return</span> (DMATxDescToSet-&gt;Buffer1Addr);   
}
</code></pre> 
  <p>这里我们加了一个FreeRTOS_net_config.h头文件，里面定义了MAC地址和默认的IP地址定义：</p> 
  <pre class="prettyprint"><code class=" hljs vala">
<span class="hljs-comment">/* Define to prevent recursive inclusion -------------------------------------*/</span>
<span class="hljs-preprocessor">#ifndef __FREERTOS_NET_CONFIG_H__</span>
<span class="hljs-preprocessor">#define __FREERTOS_NET_CONFIG_H__</span>

<span class="hljs-preprocessor">#ifdef __cplusplus</span>
 extern <span class="hljs-string">"C"</span> {
<span class="hljs-preprocessor">#endif</span>


<span class="hljs-comment">/* MAC ADDRESS*/</span>
<span class="hljs-preprocessor">#define MAC_ADDR0 0x00</span>
<span class="hljs-preprocessor">#define MAC_ADDR1 0x80</span>
<span class="hljs-preprocessor">#define MAC_ADDR2 0xe1</span>
<span class="hljs-preprocessor">#define MAC_ADDR3 0x31</span>
<span class="hljs-preprocessor">#define MAC_ADDR4 0x45</span>
<span class="hljs-preprocessor">#define MAC_ADDR5 0x57</span>

<span class="hljs-comment">/*Static IP ADDRESS*/</span>
<span class="hljs-preprocessor">#define IP_ADDR0 192</span>
<span class="hljs-preprocessor">#define IP_ADDR1 168</span>
<span class="hljs-preprocessor">#define IP_ADDR2 1</span>
<span class="hljs-preprocessor">#define IP_ADDR3 30</span>

<span class="hljs-comment">/*NETMASK*/</span>
<span class="hljs-preprocessor">#define NETMASK_ADDR0 255</span>
<span class="hljs-preprocessor">#define NETMASK_ADDR1 255</span>
<span class="hljs-preprocessor">#define NETMASK_ADDR2 255</span>
<span class="hljs-preprocessor">#define NETMASK_ADDR3 0</span>

<span class="hljs-comment">/*Gateway Address*/</span>
<span class="hljs-preprocessor">#define GW_ADDR0 192</span>
<span class="hljs-preprocessor">#define GW_ADDR1 168</span>
<span class="hljs-preprocessor">#define GW_ADDR2 1</span>
<span class="hljs-preprocessor">#define GW_ADDR3 1 </span>


<span class="hljs-preprocessor">#ifdef __cplusplus</span>
}
<span class="hljs-preprocessor">#endif</span>

<span class="hljs-preprocessor">#endif </span>


<span class="hljs-comment">/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/</span>

</code></pre> 
  <p>把FreeRTOS_net_config.h放在BSP目录下。</p> 
  <p>对于ethernetif.c的代码要说明一下ethernetif_input这个函数：</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> ethernetif_input( <span class="hljs-keyword">void</span> * pvParameters )
{
  <span class="hljs-keyword">struct</span> pbuf *p;

  <span class="hljs-keyword">for</span>( ;; )
  {
    <span class="hljs-keyword">if</span> (xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT)==pdTRUE)
    {
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
              p = low_level_input( s_pxNetIf );
              <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)
              {   
                  <span class="hljs-keyword">if</span> (ERR_OK != s_pxNetIf-&gt;input( p, s_pxNetIf))
                  {
                    pbuf_free(p);
                    p=<span class="hljs-literal">NULL</span>;
                  }               
              }
              <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">break</span>;  
        }
    }
  }
} </code></pre> 
  <p>网上有很多版本没有while循环，这会导致数据接收的时候缓冲区很快被填满，但不能清空，从而导致速度突然下降乃至断断续续，大量丢包，即使ping本机也会陡然降速，不断超时。加上while就可以解决问题了，但是出现了bug，导致系统崩溃，问题出现在low_level_input函数中的</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">frame.descriptor-&gt;Status </span>=<span class="hljs-string"> ETH_DMARxDesc_OWN; </span></code></pre> 
  <p>因为frame.descriptor这个指针使用完之后就被释放了，程序再次跑到这里的时候frame.descriptor成了野指针。 <br> 为了解决这个问题，在使用前判断一下：</p> 
  <pre class="prettyprint"><code class=" hljs applescript">    /* Check <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> descriptor <span class="hljs-keyword">is</span> exist */
    <span class="hljs-keyword">if</span>(!frame.descriptor)
<span class="hljs-command"> return</span> p;</code></pre> 
  <p>详细位置请参考上面的有关代码。</p> 
  <p>另外，我们代码中使用了信号量，所以需要在FreeRTOS的配置文件中打开相关的宏，以支持信号量： <br> 把FreeRTOSConfig.h中的：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES 0</span></code></pre> 
  <p>改为：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES 1</span></code></pre> 
  <p>接下来需要改的地方就是网卡接口中断服务程序了。</p> 
  <p>需要修改两个文件，第一个就是启动文件STM32F10x.s，把以太网中断向量的屏蔽解除。 <br> 第二个就是中断服务函数文件stm32f10x_it.c，定义以太网中断服务函数。</p> 
  <p>STM32F10x.s如下：</p> 
  <pre class="prettyprint"><code class=" hljs cmake">;/*****************************************************************************/
;/* STM32F10x.s: Startup file for ST STM32F10x device series                  */
;/*****************************************************************************/
;/* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;                          */
;/*****************************************************************************/
;/* This file is part of the uVision/ARM development tools.                   */
;/* Copyright (c) <span class="hljs-number">2005</span>-<span class="hljs-number">2007</span> Keil Software. All rights reserved.               */
;/* This software may only be used under the terms of a valid, current,       */
;/* end user licence from KEIL for a compatible version of KEIL software      */
;/* development tools. Nothing <span class="hljs-keyword">else</span> gives you the right to use this software. */
;/*****************************************************************************/


;// &lt;h&gt; Stack Configuration
;//   &lt;o&gt; Stack Size (in Bytes) &lt;<span class="hljs-number">0</span>x0-<span class="hljs-number">0</span>xFFFFFFFF:<span class="hljs-number">8</span>&gt;
;// &lt;/h&gt;

Stack_Size      EQU     <span class="hljs-number">0</span>x00000400

                AREA    STACK, NOINIT, READWRITE, ALIGN=<span class="hljs-number">3</span>
Stack_Mem       SPACE   Stack_Size
__initial_sp


;// &lt;h&gt; Heap Configuration
;//   &lt;o&gt;  Heap Size (in Bytes) &lt;<span class="hljs-number">0</span>x0-<span class="hljs-number">0</span>xFFFFFFFF:<span class="hljs-number">8</span>&gt;
;// &lt;/h&gt;

Heap_Size       EQU     <span class="hljs-number">0</span>x00000200

                AREA    HEAP, NOINIT, READWRITE, ALIGN=<span class="hljs-number">3</span>
__heap_base
Heap_Mem        SPACE   Heap_Size
__heap_limit

                IMPORT xPortPendSVHandler
                IMPORT xPortSysTickHandler
                IMPORT vPortSVCHandler
                IMPORT vUARTInterruptHandler
                ;IMPORT vTimer2IntHandler

                PRESERVE8
                THUMB


; Vector Table Mapped to Address <span class="hljs-number">0</span> at Reset

                AREA    RESET, DATA, READONLY
                <span class="hljs-keyword">EXPORT</span>  __Vectors
                <span class="hljs-keyword">EXPORT</span>  __Vectors_End
                <span class="hljs-keyword">EXPORT</span>  __Vectors_Size

__Vectors       DCD     __initial_sp              ; Top of Stack
                DCD     Reset_Handler             ; Reset Handler
                DCD     NMI_Handler               ; NMI Handler
                DCD     HardFault_Handler         ; Hard Fault Handler
                DCD     MemManage_Handler         ; MPU Fault Handler
                DCD     BusFault_Handler          ; Bus Fault Handler
                DCD     UsageFault_Handler        ; Usage Fault Handler
                DCD     <span class="hljs-number">0</span>                         ; Reserved
                DCD     <span class="hljs-number">0</span>                         ; Reserved
                DCD     <span class="hljs-number">0</span>                         ; Reserved
                DCD     <span class="hljs-number">0</span>                         ; Reserved
                DCD     vPortSVCHandler           ; SVCall Handler
                DCD     DebugMon_Handler          ; Debug Monitor Handler
                DCD     <span class="hljs-number">0</span>                         ; Reserved
                DCD     xPortPendSVHandler        ; PendSV Handler
                DCD     xPortSysTickHandler       ; SysTick Handler

                ; External Interrupts
                DCD     WWDG_IRQHandler           ; Window Watchdog
                DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
                DCD     TAMPER_IRQHandler         ; Tamper
                DCD     RTC_IRQHandler            ; RTC
                DCD     FLASH_IRQHandler          ; Flash
                DCD     RCC_IRQHandler            ; RCC
                DCD     EXTI0_IRQHandler          ; EXTI Line <span class="hljs-number">0</span>
                DCD     EXTI1_IRQHandler          ; EXTI Line <span class="hljs-number">1</span>
                DCD     EXTI2_IRQHandler          ; EXTI Line <span class="hljs-number">2</span>
                DCD     EXTI3_IRQHandler          ; EXTI Line <span class="hljs-number">3</span>
                DCD     EXTI4_IRQHandler          ; EXTI Line <span class="hljs-number">4</span>
                DCD     DMAChannel1_IRQHandler    ; DMA Channel <span class="hljs-number">1</span>
                DCD     DMAChannel2_IRQHandler    ; DMA Channel <span class="hljs-number">2</span>
                DCD     DMAChannel3_IRQHandler    ; DMA Channel <span class="hljs-number">3</span>
                DCD     DMAChannel4_IRQHandler    ; DMA Channel <span class="hljs-number">4</span>
                DCD     DMAChannel5_IRQHandler    ; DMA Channel <span class="hljs-number">5</span>
                DCD     DMAChannel6_IRQHandler    ; DMA Channel <span class="hljs-number">6</span>
                DCD     DMAChannel7_IRQHandler    ; DMA Channel <span class="hljs-number">7</span>
                DCD     ADC_IRQHandler            ; ADC
                DCD     USB_HP_CAN_TX_IRQHandler  ; USB High Priority <span class="hljs-keyword">or</span> CAN TX
                DCD     USB_LP_CAN_RX0_IRQHandler ; USB Low  Priority <span class="hljs-keyword">or</span> CAN RX0
                DCD     CAN_RX1_IRQHandler        ; CAN RX1
                DCD     CAN_SCE_IRQHandler        ; CAN SCE
                DCD     EXTI9_5_IRQHandler        ; EXTI Line <span class="hljs-number">9</span>..<span class="hljs-number">5</span>
                DCD     TIM1_BRK_IRQHandler       ; TIM1 <span class="hljs-keyword">Break</span>
                DCD     TIM1_UP_IRQHandler        ; TIM1 Update
                DCD     TIM1_TRG_COM_IRQHandler   ; TIM1 Trigger <span class="hljs-keyword">and</span> Commutation
                DCD     TIM1_CC_IRQHandler        ; TIM1 Capture Compare
                ;
                DCD     <span class="hljs-number">0</span>                         ;vTimer2IntHandler         ; TIM2
                DCD     TIM3_IRQHandler           ; TIM3
                DCD     TIM4_IRQHandler           ; TIM4
                DCD     I2C1_EV_IRQHandler        ; I2C1 Event
                DCD     I2C1_ER_IRQHandler        ; I2C1 Error
                DCD     I2C2_EV_IRQHandler        ; I2C2 Event
                DCD     I2C2_ER_IRQHandler        ; I2C2 Error
                DCD     SPI1_IRQHandler           ; SPI1
                DCD     SPI2_IRQHandler           ; SPI2
                DCD     vUARTInterruptHandler     ; USART1
                DCD     USART2_IRQHandler         ; USART2
                DCD     USART3_IRQHandler         ; USART3
                DCD     EXTI15_10_IRQHandler      ; EXTI Line <span class="hljs-number">15</span>..<span class="hljs-number">10</span>
                DCD     RTCAlarm_IRQHandler       ; RTC Alarm through EXTI Line
                DCD     USBWakeUp_IRQHandler      ; USB Wakeup from suspend

                ;-------------------added by sunq@<span class="hljs-number">2017.08</span>.<span class="hljs-number">1</span>
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     <span class="hljs-number">0</span>                          ; Reserved
                DCD     TIM5_IRQHandler            ; TIM5
                DCD     SPI3_IRQHandler            ; SPI3
                DCD     UART4_IRQHandler           ; UART4
                DCD     UART5_IRQHandler           ; UART5
                DCD     TIM6_IRQHandler            ; TIM6
                DCD     TIM7_IRQHandler            ; TIM7
                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1
                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2
                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3
                DCD     DMA2_Channel4_IRQHandler   ; DMA2 Channel4
                DCD     DMA2_Channel5_IRQHandler   ; DMA2 Channel5
                DCD     ETH_IRQHandler             ; Ethernet
                DCD     ETH_WKUP_IRQHandler        ; Ethernet Wakeup through EXTI line
                DCD     CAN2_TX_IRQHandler         ; CAN2 TX
                DCD     CAN2_RX0_IRQHandler        ; CAN2 RX0
                DCD     CAN2_RX1_IRQHandler        ; CAN2 RX1
                DCD     CAN2_SCE_IRQHandler        ; CAN2 SCE
                DCD     OTG_FS_IRQHandler          ; USB OTG FS
__Vectors_End

__Vectors_Size  EQU  __Vectors_End - __Vectors

                AREA    |.text|, CODE, READONLY

; Reset handler
Reset_Handler   PROC
                <span class="hljs-keyword">EXPORT</span>  Reset_Handler             [WEAK]
        IMPORT  SystemInit
                IMPORT  __main
                 LDR     R0, =SystemInit
                 BLX     R0
                LDR     R0, =__main
                BX      R0
                ENDP


; Dummy Exception Handlers (infinite loops which can be modified)                

NMI_Handler     PROC
                <span class="hljs-keyword">EXPORT</span>  NMI_Handler               [WEAK]
                B       .
                ENDP
HardFault_Handler\
                PROC
                <span class="hljs-keyword">EXPORT</span>  HardFault_Handler         [WEAK]
                B       .
                ENDP
MemManage_Handler\
                PROC
                <span class="hljs-keyword">EXPORT</span>  MemManage_Handler         [WEAK]
                B       .
                ENDP
BusFault_Handler\
                PROC
                <span class="hljs-keyword">EXPORT</span>  BusFault_Handler          [WEAK]
                B       .
                ENDP
UsageFault_Handler\
                PROC
                <span class="hljs-keyword">EXPORT</span>  UsageFault_Handler        [WEAK]
                B       .
                ENDP
SVC_Handler     PROC
                <span class="hljs-keyword">EXPORT</span>  SVC_Handler               [WEAK]
                B       .
                ENDP
DebugMon_Handler\
                PROC
                <span class="hljs-keyword">EXPORT</span>  DebugMon_Handler          [WEAK]
                B       .
                ENDP
PendSV_Handler  PROC
                <span class="hljs-keyword">EXPORT</span>  PendSV_Handler            [WEAK]
                B       .
                ENDP
SysTick_Handler PROC
                <span class="hljs-keyword">EXPORT</span>  SysTick_Handler           [WEAK]
                B       .
                ENDP

Default_Handler PROC

                <span class="hljs-keyword">EXPORT</span>  WWDG_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  PVD_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TAMPER_IRQHandler         [WEAK]
                <span class="hljs-keyword">EXPORT</span>  RTC_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  FLASH_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  RCC_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI0_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI1_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI2_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI3_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI4_IRQHandler          [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel1_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel2_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel3_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel4_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel5_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel6_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMAChannel7_IRQHandler    [WEAK]
                <span class="hljs-keyword">EXPORT</span>  ADC_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USB_HP_CAN_TX_IRQHandler  [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USB_LP_CAN_RX0_IRQHandler [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN_RX1_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN_SCE_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI9_5_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM1_BRK_IRQHandler       [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM1_UP_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM1_TRG_COM_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM1_CC_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM2_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM3_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM4_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  I2C1_EV_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  I2C1_ER_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  I2C2_EV_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  I2C2_ER_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  SPI1_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  SPI2_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USART1_IRQHandler         [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USART2_IRQHandler         [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USART3_IRQHandler         [WEAK]
                <span class="hljs-keyword">EXPORT</span>  EXTI15_10_IRQHandler      [WEAK]
                <span class="hljs-keyword">EXPORT</span>  RTCAlarm_IRQHandler       [WEAK]
                <span class="hljs-keyword">EXPORT</span>  USBWakeUp_IRQHandler      [WEAK]
                ;-------------added @<span class="hljs-number">2017.09</span>.<span class="hljs-number">27</span>-----------------------------
                <span class="hljs-keyword">EXPORT</span>  TIM5_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  SPI3_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  UART4_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  UART5_IRQHandler           [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM6_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  TIM7_IRQHandler            [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMA2_Channel1_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMA2_Channel2_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMA2_Channel3_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMA2_Channel4_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  DMA2_Channel5_IRQHandler   [WEAK]
                <span class="hljs-keyword">EXPORT</span>  ETH_IRQHandler             [WEAK]
                <span class="hljs-keyword">EXPORT</span>  ETH_WKUP_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN2_TX_IRQHandler         [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN2_RX0_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN2_RX1_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  CAN2_SCE_IRQHandler        [WEAK]
                <span class="hljs-keyword">EXPORT</span>  OTG_FS_IRQHandler          [WEAK]


WWDG_IRQHandler
PVD_IRQHandler
TAMPER_IRQHandler
RTC_IRQHandler
FLASH_IRQHandler
RCC_IRQHandler
EXTI0_IRQHandler
EXTI1_IRQHandler
EXTI2_IRQHandler
EXTI3_IRQHandler
EXTI4_IRQHandler
DMAChannel1_IRQHandler
DMAChannel2_IRQHandler
DMAChannel3_IRQHandler
DMAChannel4_IRQHandler
DMAChannel5_IRQHandler
DMAChannel6_IRQHandler
DMAChannel7_IRQHandler
ADC_IRQHandler
USB_HP_CAN_TX_IRQHandler
USB_LP_CAN_RX0_IRQHandler
CAN_RX1_IRQHandler
CAN_SCE_IRQHandler
EXTI9_5_IRQHandler
TIM1_BRK_IRQHandler
TIM1_UP_IRQHandler
TIM1_TRG_COM_IRQHandler
TIM1_CC_IRQHandler
TIM2_IRQHandler
TIM3_IRQHandler
TIM4_IRQHandler
I2C1_EV_IRQHandler
I2C1_ER_IRQHandler
I2C2_EV_IRQHandler
I2C2_ER_IRQHandler
SPI1_IRQHandler
SPI2_IRQHandler
USART1_IRQHandler
USART2_IRQHandler
USART3_IRQHandler
EXTI15_10_IRQHandler
RTCAlarm_IRQHandler
USBWakeUp_IRQHandler
;---------added  @<span class="hljs-number">2017.09</span>.<span class="hljs-number">27</span>--------------------------
TIM5_IRQHandler
SPI3_IRQHandler
UART4_IRQHandler
UART5_IRQHandler
TIM6_IRQHandler
TIM7_IRQHandler
DMA2_Channel1_IRQHandler
DMA2_Channel2_IRQHandler
DMA2_Channel3_IRQHandler
DMA2_Channel4_IRQHandler
DMA2_Channel5_IRQHandler
ETH_IRQHandler
ETH_WKUP_IRQHandler
CAN2_TX_IRQHandler
CAN2_RX0_IRQHandler
CAN2_RX1_IRQHandler
CAN2_SCE_IRQHandler
OTG_FS_IRQHandler
                B       .

                ENDP


                ALIGN


; User Initial Stack &amp; Heap

                <span class="hljs-keyword">IF</span>      :DEF:__MICROLIB

                <span class="hljs-keyword">EXPORT</span>  __initial_sp
                <span class="hljs-keyword">EXPORT</span>  __heap_base
                <span class="hljs-keyword">EXPORT</span>  __heap_limit

                <span class="hljs-keyword">ELSE</span>

                IMPORT  __use_two_region_memory
                <span class="hljs-keyword">EXPORT</span>  __user_initial_stackheap
__user_initial_stackheap

                LDR     R0, =  Heap_Mem
                LDR     R1, =(Stack_Mem + Stack_Size)
                LDR     R2, = (Heap_Mem +  Heap_Size)
                LDR     R3, = Stack_Mem
                BX      LR

                ALIGN

                <span class="hljs-keyword">ENDIF</span>


                END
</code></pre> 
  <p>stm32F10x_it.c如下：</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** ****************************************************************************** *<span class="hljs-javadoctag"> @file</span> Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c *<span class="hljs-javadoctag"> @author</span> MCD Application Team *<span class="hljs-javadoctag"> @version</span> V3.5.0 *<span class="hljs-javadoctag"> @date</span> 08-April-2011 *<span class="hljs-javadoctag"> @brief</span> Main Interrupt Service Routines. * This file provides template for all exceptions handler and * peripherals interrupt service routine. ****************************************************************************** *<span class="hljs-javadoctag"> @attention</span> * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */</span>

<span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span>
#include <span class="hljs-string">"stm32f10x_it.h"</span>
#include <span class="hljs-string">"stm32_eth.h"</span>


<span class="hljs-comment">/* Scheduler includes */</span>
#include <span class="hljs-string">"FreeRTOS.h"</span>
#include <span class="hljs-string">"task.h"</span>
#include <span class="hljs-string">"queue.h"</span>

<span class="hljs-comment">/* lwip includes */</span>
#include <span class="hljs-string">"lwip/sys.h"</span>

<span class="hljs-javadoc">/**<span class="hljs-javadoctag"> @addtogroup</span> STM32F10x_StdPeriph_Template * @{ */</span>

<span class="hljs-comment">/* Private typedef -----------------------------------------------------------*/</span>
<span class="hljs-comment">/* Private define ------------------------------------------------------------*/</span>
<span class="hljs-comment">/* Private macro -------------------------------------------------------------*/</span>
<span class="hljs-comment">/* Private variables ---------------------------------------------------------*/</span>
extern xSemaphoreHandle s_xSemaphore;
<span class="hljs-comment">/* Private function prototypes -----------------------------------------------*/</span>
extern <span class="hljs-keyword">void</span> xPortSysTickHandler(<span class="hljs-keyword">void</span>); 
<span class="hljs-comment">/* Private functions ---------------------------------------------------------*/</span>

<span class="hljs-javadoc">/******************************************************************************/</span>
<span class="hljs-comment">/* Cortex-M3 Processor Exceptions Handlers */</span>
<span class="hljs-javadoc">/******************************************************************************/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles NMI exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> NMI_Handler(<span class="hljs-keyword">void</span>)
{
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles Hard Fault exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> HardFault_Handler(<span class="hljs-keyword">void</span>)
{
  <span class="hljs-comment">/* Go to infinite loop when Hard Fault exception occurs */</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
  }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles Memory Manage exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> MemManage_Handler(<span class="hljs-keyword">void</span>)
{
  <span class="hljs-comment">/* Go to infinite loop when Memory Manage exception occurs */</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
  }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles Bus Fault exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> BusFault_Handler(<span class="hljs-keyword">void</span>)
{
  <span class="hljs-comment">/* Go to infinite loop when Bus Fault exception occurs */</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
  }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles Usage Fault exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> UsageFault_Handler(<span class="hljs-keyword">void</span>)
{
  <span class="hljs-comment">/* Go to infinite loop when Usage Fault exception occurs */</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
  }
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles SVCall exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> SVC_Handler(<span class="hljs-keyword">void</span>)
{
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles Debug Monitor exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> DebugMon_Handler(<span class="hljs-keyword">void</span>)
{
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles PendSVC exception. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> PendSV_Handler(<span class="hljs-keyword">void</span>)
{
}

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles SysTick Handler. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> SysTick_Handler(<span class="hljs-keyword">void</span>)
{
}

<span class="hljs-javadoc">/******************************************************************************/</span>
<span class="hljs-comment">/* STM32F10x Peripherals Interrupt Handlers */</span>
<span class="hljs-comment">/* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */</span>
<span class="hljs-comment">/* available peripheral interrupt handler's name please refer to the startup */</span>
<span class="hljs-comment">/* file (startup_stm32f10x_xx.s). */</span>
<span class="hljs-javadoc">/******************************************************************************/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles ETH interrupt request. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> ETH_IRQHandler(<span class="hljs-keyword">void</span>)
{
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

    <span class="hljs-comment">/* Frame received */</span>
    <span class="hljs-keyword">if</span> ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET) 
    {
        <span class="hljs-comment">/* Give the semaphore to wakeup LwIP task */</span>
        xSemaphoreGiveFromISR( s_xSemaphore, &amp;xHigherPriorityTaskWoken );   
    }

    <span class="hljs-comment">/* Clear the interrupt flags. */</span>
    <span class="hljs-comment">/* Clear the Eth DMA Rx IT pending bits */</span>
    ETH_DMAClearITPendingBit(ETH_DMA_IT_R);
    ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);

    <span class="hljs-comment">/* Switch tasks if necessary. */</span>    
    <span class="hljs-keyword">if</span>( xHigherPriorityTaskWoken != pdFALSE )
    {
        portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
    }
}

<span class="hljs-javadoc">/******************************************************************************/</span>
<span class="hljs-comment">/* STM32F10x Peripherals Interrupt Handlers */</span>
<span class="hljs-comment">/* Add here the Interrupt Handler for the used peripheral(s) (PPP), for the */</span>
<span class="hljs-comment">/* available peripheral interrupt handler's name please refer to the startup */</span>
<span class="hljs-comment">/* file (startup_stm32f10x_xx.s). */</span>
<span class="hljs-javadoc">/******************************************************************************/</span>

<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> This function handles PPP interrupt request. *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-comment">/*void PPP_IRQHandler(void) { }*/</span>

<span class="hljs-javadoc">/** * @} */</span> 


<span class="hljs-javadoc">/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/</span>
</code></pre> 
  <p>移植到此基本完成。 <br> 下面验证一下移植结果。 <br> 把拷贝过来的BSP目录下的netcon.c加入到IDE的BSP组中，并修改内容如下：</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** ****************************************************************************** *<span class="hljs-javadoctag"> @file</span> netconf.c *<span class="hljs-javadoctag"> @author</span> MCD Application Team *<span class="hljs-javadoctag"> @version</span> V1.1.0 *<span class="hljs-javadoctag"> @date</span> 07-October-2011 *<span class="hljs-javadoctag"> @brief</span> Network connection configuration ****************************************************************************** *<span class="hljs-javadoctag"> @attention</span> * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS. * * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt; ****************************************************************************** */</span>

<span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span>
#include <span class="hljs-string">"lwip/mem.h"</span>
#include <span class="hljs-string">"lwip/memp.h"</span>
#include <span class="hljs-string">"lwip/dhcp.h"</span>
#include <span class="hljs-string">"ethernetif.h"</span>
#include <span class="hljs-string">"FreeRTOS_net_config.h"</span>
#include <span class="hljs-string">"netconf.h"</span>
#include <span class="hljs-string">"tcpip.h"</span>
#include &lt;stdio.h&gt;

#define _DEBUG
#include <span class="hljs-string">"dprintf.h"</span>

<span class="hljs-comment">/* Private typedef -----------------------------------------------------------*/</span>
typedef <span class="hljs-keyword">enum</span> 
{ 
  DHCP_START=<span class="hljs-number">0</span>,
  DHCP_WAIT_ADDRESS,
  DHCP_ADDRESS_ASSIGNED,
  DHCP_TIMEOUT
} 
DHCP_State_TypeDef;
<span class="hljs-comment">/* Private define ------------------------------------------------------------*/</span>
#define MAX_DHCP_TRIES <span class="hljs-number">5</span>

<span class="hljs-comment">/* Private macro -------------------------------------------------------------*/</span>
<span class="hljs-comment">/* Private variables ---------------------------------------------------------*/</span>
struct netif xnetif; <span class="hljs-comment">/* network interface structure */</span>

<span class="hljs-comment">/* Private functions ---------------------------------------------------------*/</span>
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> Initializes the lwIP stack *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">void</span> LwIP_Init(<span class="hljs-keyword">void</span>)
{
  struct ip_addr ipaddr;
  struct ip_addr netmask;
  struct ip_addr gw;

  <span class="hljs-comment">/* Create tcp_ip stack thread */</span>
  tcpip_init( NULL, NULL ); 

  <span class="hljs-comment">/* IP address setting &amp; display on STM32_evalboard LCD*/</span>
#ifdef USE_DHCP
  ipaddr.addr = <span class="hljs-number">0</span>;
  netmask.addr = <span class="hljs-number">0</span>;
  gw.addr = <span class="hljs-number">0</span>;
#<span class="hljs-keyword">else</span>
  IP4_ADDR(&amp;ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
  IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3);
  IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
#endif

  <span class="hljs-comment">/* - netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask, struct ip_addr *gw, void *state, err_t (* init)(struct netif *netif), err_t (* input)(struct pbuf *p, struct netif *netif)) Adds your network interface to the netif_list. Allocate a struct netif and pass a pointer to this structure as the first argument. Give pointers to cleared ip_addr structures when using DHCP, or fill them with sane numbers otherwise. The state pointer may be NULL. The init function pointer must point to a initialization function for your ethernet netif interface. The following code illustrates it's use.*/</span>

  netif_add(&amp;xnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, &amp;ethernetif_init, &amp;tcpip_input);

 <span class="hljs-comment">/* Registers the default network interface. */</span>
  netif_set_default(&amp;xnetif);

 <span class="hljs-comment">/* When the netif is fully configured this function must be called.*/</span>
  netif_set_up(&amp;xnetif); 
}


#ifdef USE_DHCP
<span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @brief</span> LwIP_DHCP_Process_Handle *<span class="hljs-javadoctag"> @param</span> None *<span class="hljs-javadoctag"> @retval</span> None */</span>
<span class="hljs-keyword">int</span> g_DHCP_OK_flag = <span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span> LwIP_DHCP_task(<span class="hljs-keyword">void</span> * pvParameters)
{
  struct ip_addr ipaddr;
  struct ip_addr netmask;
  struct ip_addr gw;
  uint32_t IPaddress;
  uint8_t iptab[<span class="hljs-number">4</span>];
  uint8_t iptxt[<span class="hljs-number">20</span>];
  uint8_t DHCP_state;  
  DHCP_state = DHCP_START;

  <span class="hljs-keyword">for</span> (;;)
  {
    <span class="hljs-keyword">switch</span> (DHCP_state)
    {
      <span class="hljs-keyword">case</span> DHCP_START:
          {
            dhcp_start(&amp;xnetif);
            IPaddress = <span class="hljs-number">0</span>;
            DHCP_state = DHCP_WAIT_ADDRESS;
                    printf(<span class="hljs-string">"Looking for DHCP server,please wait... \r\n"</span>);
          }
          <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> DHCP_WAIT_ADDRESS:
          {
            <span class="hljs-comment">/* Read the new IP address */</span>
            IPaddress = xnetif.ip_addr.addr;

            <span class="hljs-keyword">if</span> (IPaddress!=<span class="hljs-number">0</span>) 
            {
              DHCP_state = DHCP_ADDRESS_ASSIGNED;   

              <span class="hljs-comment">/* Stop DHCP */</span>
              dhcp_stop(&amp;xnetif);


              iptab[<span class="hljs-number">0</span>] = (uint8_t)(IPaddress &gt;&gt; <span class="hljs-number">24</span>);
              iptab[<span class="hljs-number">1</span>] = (uint8_t)(IPaddress &gt;&gt; <span class="hljs-number">16</span>);
              iptab[<span class="hljs-number">2</span>] = (uint8_t)(IPaddress &gt;&gt; <span class="hljs-number">8</span>);
              iptab[<span class="hljs-number">3</span>] = (uint8_t)(IPaddress);

              sprintf((<span class="hljs-keyword">char</span>*)iptxt, <span class="hljs-string">" %d.%d.%d.%d"</span>, iptab[<span class="hljs-number">3</span>], iptab[<span class="hljs-number">2</span>], iptab[<span class="hljs-number">1</span>], iptab[<span class="hljs-number">0</span>]);  
              <span class="hljs-comment">/* end of DHCP process: LED1 stays ON*/</span>
              <span class="hljs-comment">//STM_EVAL_LEDOn(LED1);//....</span>
                        printf(<span class="hljs-string">"\r\nIP address[%s ]assigned by a DHCP server !\r\n"</span>,iptxt);

              vTaskDelete(NULL);
            }
            <span class="hljs-keyword">else</span>
            {
              <span class="hljs-comment">/* DHCP timeout */</span>
              <span class="hljs-keyword">if</span> (xnetif.dhcp-&gt;tries &gt; MAX_DHCP_TRIES)
              {
                DHCP_state = DHCP_TIMEOUT;

                <span class="hljs-comment">/* Stop DHCP */</span>
                dhcp_stop(&amp;xnetif);

                <span class="hljs-comment">/* Static address used */</span>
                IP4_ADDR(&amp;ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
                IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
                IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
                netif_set_addr(&amp;xnetif, &amp;ipaddr , &amp;netmask, &amp;gw);

                iptab[<span class="hljs-number">0</span>] = IP_ADDR3;
                iptab[<span class="hljs-number">1</span>] = IP_ADDR2;
                iptab[<span class="hljs-number">2</span>] = IP_ADDR1;
                iptab[<span class="hljs-number">3</span>] = IP_ADDR0;

                sprintf((<span class="hljs-keyword">char</span>*)iptxt, <span class="hljs-string">" %d.%d.%d.%d"</span>, iptab[<span class="hljs-number">3</span>], iptab[<span class="hljs-number">2</span>], iptab[<span class="hljs-number">1</span>], iptab[<span class="hljs-number">0</span>]); 

                <span class="hljs-comment">/* end of DHCP process: LED1 stays ON*/</span>
                <span class="hljs-comment">//STM_EVAL_LEDOn(LED1);//....</span>
                            printf(<span class="hljs-string">"\r\nDHCP timeout \r\nStatic IP address :%s\r\n"</span>,iptxt);
                vTaskDelete(NULL);
              }
                        {
                            <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>;
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> tokens[<span class="hljs-number">4</span>]={<span class="hljs-string">'-'</span>,<span class="hljs-string">'\\'</span>,<span class="hljs-string">'|'</span>,<span class="hljs-string">'/'</span>};
                            printf(<span class="hljs-string">"\b\b\b\b%c%c%c%c"</span>,tokens[s++%<span class="hljs-number">4</span>],tokens[s%<span class="hljs-number">4</span>],tokens[s%<span class="hljs-number">4</span>],tokens[s%<span class="hljs-number">4</span>]);
                        }
            }
          }
          <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">default</span>:
                printf(<span class="hljs-string">"\r\nerr: DHCP_state=%d\r\n"</span>,DHCP_state); 
                <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-comment">/* Toggle LED1 */</span>
    <span class="hljs-comment">//STM_EVAL_LEDToggle(LED1);//...</span>
    <span class="hljs-comment">/* wait 250 ms */</span>
    vTaskDelay(<span class="hljs-number">250</span>);
  }   
}
#endif  <span class="hljs-comment">/* USE_DHCP */</span>


<span class="hljs-javadoc">/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/</span>
</code></pre> 
  <p>修改netconf.h，加入对DHCP的支持。 <br> 如下：</p> 
  <pre class="prettyprint"><code class=" hljs markdown">/**
  <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-emphasis">***</span>
  * @file    netconf.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    07-October-2011 
  * @brief   This file contains all the functions prototypes for the netconf.c 
  *          file.
  <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-emphasis">***</span>
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">center</span>&gt;</span></span>&amp;copy; COPYRIGHT 2011 STMicroelectronics<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">center</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span></span>
  <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-emphasis">***</span>
  */

/<span class="hljs-bullet">* Define to prevent recursive inclusion -------------------------------------*</span>/
<span class="hljs-header">#ifndef __NETCONF_H</span>
<span class="hljs-header">#define __NETCONF_H</span>

<span class="hljs-header">#ifdef __cplusplus</span>
 extern "C" {
<span class="hljs-header">#endif</span>

<span class="hljs-header">#define USE_DHCP // @2017.09.27 </span>

/<span class="hljs-bullet">* Includes ------------------------------------------------------------------*</span>/
/<span class="hljs-bullet">* Exported types ------------------------------------------------------------*</span>/ 
extern struct netif xnetif;
/<span class="hljs-bullet">* Exported constants --------------------------------------------------------*</span>/
/<span class="hljs-bullet">* Exported macro ------------------------------------------------------------*</span>/
/<span class="hljs-bullet">* Exported functions ------------------------------------------------------- *</span>/
void LwIP_Init(void);
void LwIP<span class="hljs-emphasis">_DHCP_</span>task(void * pvParameters);


<span class="hljs-header">#ifdef __cplusplus</span>
}
<span class="hljs-header">#endif</span>

<span class="hljs-header">#endif /* __NETCONF_H */</span>


/<span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">**** (C) COPYRIGHT 2011 STMicroelectronics **</span><span class="hljs-strong">***END OF FILE**</span>**/
</code></pre> 
  <p>main.c文件修改如下：</p> 
  <pre class="prettyprint"><code class=" hljs cpp">
<span class="hljs-preprocessor">#include "stm32f10x.h"</span>
<span class="hljs-preprocessor">#include "FreeRTOS.h"</span>
<span class="hljs-preprocessor">#include "task.h"</span>
<span class="hljs-preprocessor">#include "queue.h"</span>
<span class="hljs-preprocessor">#include "semphr.h"</span>
<span class="hljs-preprocessor">#include "utils.h"</span>
<span class="hljs-preprocessor">#define _DEBUG</span>
<span class="hljs-preprocessor">#include "dprintf.h"</span>


<span class="hljs-keyword">void</span> GPIO_Configuration(<span class="hljs-keyword">void</span>)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    <span class="hljs-comment">/* Configure IO connected to LD1, LD2, LD3 and LD4 leds *********************/</span>  
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOD, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">//??????</span>
<span class="hljs-keyword">void</span> NVIC_Configuration(<span class="hljs-keyword">void</span>)
{ 
    <span class="hljs-comment">/* Configure the NVIC Preemption Priority Bits */</span>  
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

    <span class="hljs-preprocessor">#ifdef VECT_TAB_RAM </span>
      <span class="hljs-comment">/* Set the Vector Table base location at 0x20000000 */</span> 
      NVIC_SetVectorTable(NVIC_VectTab_RAM, <span class="hljs-number">0x0</span>); 
    <span class="hljs-preprocessor">#else /* VECT_TAB_FLASH */</span>
      <span class="hljs-comment">/* Set the Vector Table base location at 0x08000000 */</span> 
      NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="hljs-number">0x0</span>);   
    <span class="hljs-preprocessor">#endif</span>
}


<span class="hljs-keyword">void</span> RCC_Configuration(<span class="hljs-keyword">void</span>)
{
    SystemInit();   
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA 
                           |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
                           |RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE
                           |RCC_APB2Periph_ADC1  | RCC_APB2Periph_AFIO 
                           |RCC_APB2Periph_SPI1, ENABLE );
  <span class="hljs-comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALL ,ENABLE );</span>
     RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4 
                           |RCC_APB1Periph_USART3|RCC_APB1Periph_TIM2                              
                           , ENABLE );
     RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
}


<span class="hljs-keyword">void</span> vApplicationStackOverflowHook( TaskHandle_t pxTask, <span class="hljs-keyword">char</span> *pcTaskName )
{
    <span class="hljs-comment">/* This function will get called if a task overflows its stack. If the parameters are corrupt then inspect pxCurrentTCB to find which was the offending task. */</span>

    ( <span class="hljs-keyword">void</span> ) pxTask;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ÈÎÎñ£º%s ·¢ÏÖÕ»Òç³ö\n"</span>, pcTaskName);
    <span class="hljs-keyword">for</span>( ;; );
}
<span class="hljs-comment">/*-----------------------------------------------------------*/</span>

<span class="hljs-keyword">void</span> vApplicationTickHook( <span class="hljs-keyword">void</span> )
{
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> prvSetupHardware( <span class="hljs-keyword">void</span> )
{
    <span class="hljs-comment">/* Start with the clocks in their expected state. */</span>
    RCC_DeInit();

    <span class="hljs-comment">/* Enable HSE (high speed external clock). */</span>
    RCC_HSEConfig( RCC_HSE_ON );

    <span class="hljs-comment">/* Wait till HSE is ready. */</span>
    <span class="hljs-keyword">while</span>( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET )
    {
    }

    <span class="hljs-comment">/* 2 wait states required on the flash. */</span>
    *( ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> * ) <span class="hljs-number">0x40022000</span> ) = <span class="hljs-number">0x02</span>;

    <span class="hljs-comment">/* HCLK = SYSCLK */</span>
    RCC_HCLKConfig( RCC_SYSCLK_Div1 );

    <span class="hljs-comment">/* PCLK2 = HCLK */</span>
    RCC_PCLK2Config( RCC_HCLK_Div1 );

    <span class="hljs-comment">/* PCLK1 = HCLK/2 */</span>
    RCC_PCLK1Config( RCC_HCLK_Div2 );

    <span class="hljs-comment">/* Enable PLL. */</span>
    RCC_PLLCmd( ENABLE );

    <span class="hljs-comment">/* Wait till PLL is ready. */</span>
    <span class="hljs-keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
    {
    }

    <span class="hljs-comment">/* Select PLL as system clock source. */</span>
    RCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK );

    <span class="hljs-comment">/* Wait till PLL is used as system clock source. */</span>
    <span class="hljs-keyword">while</span>( RCC_GetSYSCLKSource() != <span class="hljs-number">0x08</span> )
    {
    }

    <span class="hljs-comment">/* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */</span>
    RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC
                            | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE );

    <span class="hljs-comment">/* Set the Vector Table base address at 0x08000000 */</span>
    NVIC_SetVectorTable( NVIC_VectTab_FLASH, <span class="hljs-number">0x0</span> );

    NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

    <span class="hljs-comment">/* Configure HCLK clock as SysTick clock source. */</span>
    SysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );

    GPIO_Configuration();
}



<span class="hljs-preprocessor">#define ledSTACK_SIZE configMINIMAL_STACK_SIZE</span>
<span class="hljs-preprocessor">#define ledFLASH_RATE_BASE ( ( TickType_t ) 333 )</span>

<span class="hljs-keyword">static</span> TaskHandle_t xHandleTaskLED=NULL;


<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> vTaskLED(<span class="hljs-keyword">void</span>* pvParameters)
{
    TickType_t xFlashRate, xLastFlashTime;
    xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) <span class="hljs-number">2</span> );
    xFlashRate /= portTICK_PERIOD_MS;
    xFlashRate /= ( TickType_t ) <span class="hljs-number">2</span>;
    xLastFlashTime = xTaskGetTickCount();

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-comment">/* Turn on LD1 */</span>
        GPIO_SetBits(GPIOD, GPIO_Pin_2);
        <span class="hljs-comment">/* Insert delay */</span>
        <span class="hljs-comment">//vTaskDelay(300);</span>
        vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate );

        <span class="hljs-comment">/* Turn off LD1 */</span>
        GPIO_ResetBits(GPIOD, GPIO_Pin_2);
        <span class="hljs-comment">/* Insert delay */</span>
        <span class="hljs-comment">//vTaskDelay(300);</span>
        vTaskDelayUntil( &amp;xLastFlashTime, xFlashRate );
    }
}


<span class="hljs-preprocessor">#include "serial.h"</span>
<span class="hljs-preprocessor">#include "integer.h"</span>
<span class="hljs-preprocessor">#include "diskio.h"</span>
<span class="hljs-preprocessor">#include "ff.h"</span>
<span class="hljs-preprocessor">#include "sdcard.h" </span>
<span class="hljs-preprocessor">#include "common.h"</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>

<span class="hljs-preprocessor">#define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY )</span>

<span class="hljs-comment">/* Handle to the com port used by both tasks. */</span>
<span class="hljs-keyword">static</span> xComPortHandle xPort = NULL;

<span class="hljs-comment">/* The Rx task will block on the Rx queue for a long period. */</span>
<span class="hljs-preprocessor">#define comRX_BLOCK_TIME ( ( TickType_t ) 0xffff )</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> sd_card_task(<span class="hljs-keyword">void</span>* pvParameters)
{ 
    <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>  key = <span class="hljs-number">0</span>;

  GPIO_ResetBits(GPIOF,  GPIO_Pin_6);                                   <span class="hljs-comment">//LED1 on</span>

  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
  {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n============ ÇëÑ¡Ôñ...===============\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"¸ñ Ê½ »¯------------------------------- 1\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"´´½¨ÎÄ¼þ------------------------------- 2\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"É¾³ýÎÄ¼þ ------------------------------ 3\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ÁÐ±íÎÄ¼þ------------------------------- 4\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ÖØÆôÏµÍ³ ------------------------------ 5\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"´ÅÅÌÐÅÏ¢------------------------------- 6\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"´´½¨Ä¿Â¼------------------------------- 7\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"±à¼­ÎÄ¼þ------------------------------- 8\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"¶ÁÈ¡ÎÄ¼þ------------------------------- 9\r\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"========================================\r\n\n"</span>);



        xSerialGetChar( xPort, &amp;key, comRX_BLOCK_TIME );

        <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x31</span>)        <span class="hljs-comment">//Format FS</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----1----"</span>);
            format_disk();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x32</span>)   <span class="hljs-comment">//Creat File</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----2----"</span>);
            creat_file();       
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x33</span>)   <span class="hljs-comment">//Delete File</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----3----"</span>);
            delete_file();      
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x34</span>)   <span class="hljs-comment">//List File</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----4----"</span>);
            list_file();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x35</span>)   <span class="hljs-comment">//Reset FS</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----5----"</span>);
            Sys_Soft_Reset();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x36</span>)   <span class="hljs-comment">//Disk info</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----6----"</span>);
            get_disk_info();    
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x37</span>)   <span class="hljs-comment">//Creat Dir</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----7----"</span>);
            creat_dir();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x38</span>)   <span class="hljs-comment">//Edit File</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----8----"</span>);
            edit_file();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0x39</span>)   <span class="hljs-comment">//Read File</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----9----"</span>);
            read_file();    
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n----%c----"</span>,key);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\nÖ»½ÓÊÜ1-9ÃüÁî£¬ÇëÖØÐÂÊäÈë"</span>);
        }           
    }       
}


<span class="hljs-preprocessor">#include "netconf.h"</span>
<span class="hljs-preprocessor">#include "stm32_eth.h"</span>


<span class="hljs-preprocessor">#define SYSTEM_INIT_TASK_PRIO ( tskIDLE_PRIORITY )</span>
<span class="hljs-preprocessor">#define DHCP_TASK_PRIO ( tskIDLE_PRIORITY + 2 ) </span>

<span class="hljs-keyword">static</span> TaskHandle_t xHandleTaskSystemInit=NULL;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> System_Init_task(<span class="hljs-keyword">void</span>* pvParameters)
{

    xTaskCreate(vTaskLED,<span class="hljs-string">"vTaskLED"</span>,ledSTACK_SIZE,NULL,<span class="hljs-number">3</span>,&amp;xHandleTaskLED);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2 led demos tasks are created !\r\n"</span>);

    <span class="hljs-comment">//xTaskCreate(sd_card_task,"vTaskSDCard",1024,NULL,SYSTEM_INIT_TASK_PRIO,NULL); </span>
    <span class="hljs-comment">//printf("The task of SDCard is created!\r\n");</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"eth hardware initialzing...\r\n"</span>);
    FreeRTOS_Hardware_STMS32_ETH_Init();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"eth hardware ok\r\nstarting LwIP stack...\r\n"</span>);

    <span class="hljs-comment">/* Initilaize the LwIP stack */</span>
    LwIP_Init();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"LwIP stack started !\r\n"</span>);


    <span class="hljs-comment">/* Initialize tcp echo server */</span>
    <span class="hljs-comment">//tcpecho_init();</span>

    <span class="hljs-preprocessor">#ifdef USE_DHCP</span>
    <span class="hljs-comment">/* Start DHCPClient */</span>
    xTaskCreate(LwIP_DHCP_task, <span class="hljs-string">"DHCPClient"</span>, configMINIMAL_STACK_SIZE * <span class="hljs-number">2</span>, NULL,DHCP_TASK_PRIO, NULL);
    <span class="hljs-preprocessor">#endif </span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"LwIP_DHCP_task is created !\r\n"</span>);

    vTaskDelete(xHandleTaskSystemInit);
}


<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{  
    __set_PRIMASK(<span class="hljs-number">1</span>);<span class="hljs-comment">//½ûÖ¹È«¾ÖÖÐ¶Ï</span>
    prvSetupHardware(); 

    FreeRTOS_printf_service_init();

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"###############################################\r\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"## hello! welcome to FreeRTOS v9.0.0 ##\r\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"###############################################\r\n"</span>);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n\r\n"</span>);

    SD_Init(); 

    InitMQTTServerInfo();

    xTaskCreate(System_Init_task,<span class="hljs-string">"vTaskSystemInit"</span>,<span class="hljs-number">100</span>,NULL,SYSTEM_INIT_TASK_PRIO,&amp;xHandleTaskSystemInit);

    vTaskStartScheduler();<span class="hljs-comment">//Æô¶¯ÈÎÎñµ÷¶ÈÆ÷</span>
}

<span class="hljs-comment">/******************* (C) COPYRIGHT 2012 WildFire Team *****END OF FILE************/</span>


</code></pre> 
  <p>编译完成后，把hex档烧到开发板上，上电运行。看到： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170927014212617?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>LwIP已经运行起来了。路由分配了ip：10.0.0.109</p> 
  <p>打开一个cmd窗口，ping一下开发板： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20170927014650149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3FzaGluaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>可以看到ping的结果还是很稳定的。</p> 
  <p>本文完整的源代码下载地址： <br> <a href="https://gitee.com/null_926_6734/STM32F107_FreeRTOS_v9.0.0/raw/STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1/STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1.rar" rel="nofollow" target="_blank">STM32F107_FreeRTOS_v9.0.0_SDCard_LwIP-1.4.1.rar</a></p> 
  <p>下一篇将移植MQTT，并对步进电机控制器进行控制。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sqshining/article/details/78091067,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sqshining/article/details/78091067,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
