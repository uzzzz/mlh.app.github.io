<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于HyperLedger 创建第一个区块链网络 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于HyperLedger 创建第一个区块链网络" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="linux系统版本：CentOS Linux release 7.2.1511 (Core) 构建您的第一个网络（BYFN）场景提供了一个由两个组织组成的示例Hyperledger Fabric网络，每个组织都有两个peer节点，以及一个“solo”ordering服务。 （1）先决条件 安装curl 安装docker &amp; docker compose,Docker 版本要求 17.06.2-ce or greater 我本机的docker 版本是Docker version 17.09.0-ce, build afdb6d4 docker-compose version 1.16.1, build 6d1ac219 安装go语言，版本1.9.x&nbsp;or greater 安装node.js和npm python 2.7 &nbsp; The Fabric Node.js SDK requires an iteration of Python 2.7 in order for&nbsp; npm&nbsp;install &nbsp;operations to complete successfully 下载官网的例子，并且下载特定于平台的二进制文件 git clone https://github.com/hyperledger/fabric-samples.git cd first - network curl - sSL https : // goo . gl / Q3YRTi | bash 如果这个命令不能成功执行的话，就先去下载好对应的脚本，然后再执行，执行好后会发现当前目录多了一个bin目录，目录里面有： cryptogen, configtxgen, configtxlator, and peer 然后把这个bin目录添加到系统的环境变量中去 （2）官网提供了两种方法创建网络： 懒人方法，一键运行脚本 cd first - network ./ byfn . sh - m generate ./ byfn . sh - m up ./ byfn . sh - m down 逐步运行命令 证书生成器 用 cryptogen来为网络中的实体生成加密材料（证书），这些证书是身份的代表，它们允许在我们的实体进行交流和交易时进行签名/验证身份验证。 证书是如何工作的： cryptogen工具读取包含网络拓扑的 crypto-config.yaml配置文件来生成相关证书，并允许我们为组织和属于这些组织的组件生成一组证书和密钥。每个组织都配置了一个唯一的根证书（ca-cert），它将特定组件（peer node和ordering node）绑定到该组织。通过为每个组织分配唯一的CA证书，我们正在模仿一个典型的网络，参与会员将使用自己的证书授权。 Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 我们运行完&nbsp; cryptogen &nbsp;这个工具后, 生成的证书和秘钥会保存在一个名为 crypto-config 的文件夹里面 配置事务生成器 configtxgen&nbsp;tool &nbsp;用来创建4个配置文件: orderer&nbsp;genesis&nbsp;block, channel&nbsp;channel&nbsp;configuration&nbsp;transaction, and two&nbsp;anchor&nbsp;peer&nbsp;transactions&nbsp;- one for each Peer Org. order block是用于ordering服务的创世纪块， &nbsp;channel transaction文件在通道创建时广播给orderer。 anchor peer transactions, 按照名称可能得出的提示， anchor peer transactions在此通道上指定每个组织的锚点peer。 configtxgen &nbsp; tool是如何工作的？ Configtxgen 工具读取 -&nbsp; configtx.yaml &nbsp;- 这个配置文件，这个配置文件包含一个简单网络的定义。有3个会员 - 一个 Orderer Org ( OrdererOrg ) 和2个 Peer Orgs ( Org1 &nbsp;&amp;&nbsp; Org2 ) ，这两个Org分别管理着两个peer，这个文件也指定了一个 组合-&nbsp; SampleConsortium &nbsp;- ，包含了两个Peer Orgs. 注意：sampleConsortium被定义在system-level profile中，接下来被channel-level profile引用。Channels存在在consortium的范围内，所有的consortium都在network的范围内。 你会看到这个文件有两个不同的头部，一个是给-&nbsp; TwoOrgsOrdererGenesis &nbsp;- 用，另一个是给通道用-&nbsp; TwoOrgsChannel . 这两个头部很重要，因为会作为创建上面4个配置文件的参数给传递出去。 这个配置文件还有两个附加的定义是值得我们注意的： Org(peer0.org1.example.com&nbsp;&amp;&nbsp;peer0.org2.example.com)的anchor节点，另外一个就是指向每个成员的MSP目录的位置，基于此，我们可以将每个Org的根证书存放在orderer Genesis block中，这是一个很重要的概念。现在任意network entity与ordering service通信时就能对其数字签名进行验证。 运行tool: 可以通过configtxgen&nbsp;and&nbsp;cryptogen手动生成证书/密钥以及各项配置文件。同样，可以参考byfn.sh脚本实现。 可以参考byfn.sh脚本中的generateCerts函数用来生成证书（这些证书被定义在crypto-config.yaml中的网络配置所使用）所需要的命令。为了方便起见，我们提供一个参考如下。 首先，先跑起来cryptogen工具，我们的二进制文件都在bin目录下，因此我们需要cd到tool所在的目录下. ../bin/cryptogen generate --config=./crypto-config.yaml 接下来，我们会告诉configtxgen工具去哪找到需要调用的configtx.yaml文件。 首先，我们需要设置一个环境变量，用于告知configtxgen根据去哪找configtx.yaml配置文件。接下来，我们调用configtxgen工具创建orderer Genesis block export FABRIC_CFG_PATH= $PWD.. /bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 接着，我们创建channel transaction artifact(channel.tx)。然后，确保替换$CHANNEL_NAME export CHANNEL_NAME= mychannel .. /bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接着，我们在我们正在创建的channel上定义Org1的anchor节点。然后，确保替换$CHANNEL_NAME ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 然后，我们在相同的channel上定义Org2的anchor节点。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 启动network 我们利用docker-compose脚本来启动我们的network。docker-compose文件引用了我们之前下载的镜像，并使用前面生成的genesis block来引导orderer。 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/ peer# command: /bin/bash -c ‘./scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT‘ volumes ---------docker-compose-cli.yaml 如果没有注释掉上面的命令的话，在network启动的时候，其将执行所有的CLI命令，然后就会导致文章末尾中的错误。 启动network，注意$CHANNEL_NAME,&lt;pick_a_value&gt;自己设定 CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=&lt;pick_a_value&gt; docker-compose -f docker-compose-cli.yaml up -d 9.环境变量 对于以下针对peer0.org1.example.com的CLI命令，我们需要使用以下给出的四个环境变量来介绍我们的命令。这些peer0.org1.example.com变量都被包含在CLI容器里，因此我们可以不用传递的操作它们。然而！，如果你想发送calls到其他peers或者orderer，你需要根据情况提供这些变量。打开docker-compose-base.yaml并查看具体的路径信息 # Environment variables for PEER0CORE_PEER_MSPCONFIGPATH =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/ mspCORE_PEER_ADDRESS =peer0.org1.example.com: 7051 CORE_PEER_LOCALMSPID = &quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 10.创建并进入Channel docker exec -it cli bash 请回忆下我们使用configtxgen工具生成channel配置artifact-channel.tx。我们将把artifact作为创建channel的请求的一部分发送给orderer。 注意到在接下来的命令中我们发送了-- cafile作为命令的一部分。这个是orderer证书的本地路径，使得我们可以验证TLS握手。 我们使用-c flag 标注出我们的channel名称，用-f flag标注出我们的channel 配置transaction。在本例中是channel.tx，然而你可以使用不同的名称用于挂载配置transaction。使用下面创建channel的语句的时候注意channel-name。 export CHANNEL_NAME= mychannel peer channel create -o orderer.example.com: 7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令返回了一个genesis block-&nbsp;&lt;channel-ID.block&gt;&nbsp;-我们可以通过这个id进入到channel。它包含channel.tx中指定的配置信息，创建成功后有如下输出： 接下来的操作都需要在CLI容器中进行，在操作peer0.org1.example.com之外的peer时，需要记得相关环境变量的命令。 接下来我们把peer0.org1.example.com加入到channel中去，channel-ID.block是之前生成的，这里我的是mychannel.block。 peer channel join -b &lt;channel-ID.block&gt; 你可把其他的peer加入到该channel上，但是需要设置上述的四个环境变量。 安装并实例化chaincode 我们这里只是使用已经存在的chaincode。 application通过chaincode与blockchain ledger进行交互。我们把chaincode安装到execute与endorse我们transaction的peer上，接下来在channel上初始化chaincode。 首先，安装sample go代码到4个peer之一的peer上。以下命令把chaincode的源代码放到了peer节点的文件系统上。 peer chaincode install - n mycc - v 1.0 - p github . com / hyperledger / fabric / examples / chaincode / go / chaincode_example02 接下来，在channel上实例化chaincode。这将在channel上初始化chaincode，同时设置chaincode的endorsement的策略，然后在目标peer上启动chaincode容器。请注意-P参数，我们通过设置这个参数，来指定transaction的endorsement的需求level，用于验证chaincode。 在下面的命令，我们定义了endorsement策略为-P&nbsp;&quot;OR&nbsp;(‘Org0MSP.member‘,‘Org1MSP.member‘)&quot;。这表示我们需要隶属于Org1或者Org2的peer进行“endorsement”（也就是说，只有一个endorsement）。如果把or改为and则说明我们需要两个endorsement peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询 首先查询a的值，确保chaincode已经正常的实例化，同时确保state DB已经被填充 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 调用 让我们从a账户转移10个到b账户，这个命令将会创建新的block同时更新state DB。 peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 上述调用过程解析 script.sh脚本在CLI容器内部执行，该脚本执行了createChannel命令，提供了channel名称，同时使用channel.tx进行channel配置 createChannel的输出是一个genesis block，使用channel名称命名的block，例如mychannel.block，该block在peers的文件系统上存储，该block包括channel.tx指定的channel配置信息。 加入channel的命令对所有4个peer进行执行，把之前生成的genesis block作为输入。这个join命令使得peers加入mychannel里面，同时创建了一个以mychannel.block作为开始的chain。 接着，我们拥有了由4个peer，两个organization组成的channel。这都在我们TwoOrgsChannel&nbsp;profile.里面。 peer0.org1.example.com&nbsp;与&nbsp;peer1.org1.example.com&nbsp;隶属于 Org1;&nbsp;peer0.org2.example.com 以及&nbsp;peer1.org2.example.com&nbsp;隶属于 Org2。这些关系在crypto-config.yaml中定义，同时在我们的docker compose中指定了MSP的路径。 Org1MSP (peer0.org1.example.com) 以及 Org2MSP (peer0.org2.example.com)的anchor节点接下来被更新了。我们基于建立的channel把Org1MSPanchors.tx&nbsp;与&nbsp;Org2MSPanchors.tx&nbsp;的artifacts，发送给orderering service，以实现上述的更新。 chaincode_example02被安装在了peer0.org1.example.com&nbsp;与&nbsp;peer0.org2.example.com 接着chaincode在peer0.org2.example.com被实例化。实例化把chaincode加到channel上，并启动目标peer的容器，接着初始化chaincode有关的键-值对（&nbsp;[“a”,”100” “b”,”200”]）。实例化的过程导致了dev-peer0.org2.example.com-zeychaincode-1.0的启动。 实例化需要有endorsement策略的参数，这里设置为-P&nbsp;&quot;OR&nbsp;&nbsp;&nbsp;&nbsp;(‘Org1MSP.member‘,‘Org2MSP.member‘)&quot;，表示任意transaction必须被Org1 或者 Org2的一个peer进行endorsed。 接下来把对“a”的查询发送给peer0.org1.example.com，即在peer0.org1.example.com查询a的值。chaincode之前已经安装在了peer0.org1.example.com上，因此这个查询将会针对Org1 peer0 启动一个容器（dev-peer0.org1.example.com-zeychaincode-1.0），然后查询结果得到返回，没有任何写的操作发生，因此返回值是100 接着调用请求发送给peer0.org1.example.com，把10个从a转移到b。 然后chaincode在peer1.org2.example.com进行安装。 然后一个查询a的余额的请求发送到peer1.org2.example.com。这个启动了第三个chaincode容器（dev-peer1.org2.example.com-mycc-1.0），90被返回。正确的反应了上述transaction，a的值被改为了10。 Error: Got unexpected status: BAD_REQUEST 原因是存在同名的channel 阅读更多" />
<meta property="og:description" content="linux系统版本：CentOS Linux release 7.2.1511 (Core) 构建您的第一个网络（BYFN）场景提供了一个由两个组织组成的示例Hyperledger Fabric网络，每个组织都有两个peer节点，以及一个“solo”ordering服务。 （1）先决条件 安装curl 安装docker &amp; docker compose,Docker 版本要求 17.06.2-ce or greater 我本机的docker 版本是Docker version 17.09.0-ce, build afdb6d4 docker-compose version 1.16.1, build 6d1ac219 安装go语言，版本1.9.x&nbsp;or greater 安装node.js和npm python 2.7 &nbsp; The Fabric Node.js SDK requires an iteration of Python 2.7 in order for&nbsp; npm&nbsp;install &nbsp;operations to complete successfully 下载官网的例子，并且下载特定于平台的二进制文件 git clone https://github.com/hyperledger/fabric-samples.git cd first - network curl - sSL https : // goo . gl / Q3YRTi | bash 如果这个命令不能成功执行的话，就先去下载好对应的脚本，然后再执行，执行好后会发现当前目录多了一个bin目录，目录里面有： cryptogen, configtxgen, configtxlator, and peer 然后把这个bin目录添加到系统的环境变量中去 （2）官网提供了两种方法创建网络： 懒人方法，一键运行脚本 cd first - network ./ byfn . sh - m generate ./ byfn . sh - m up ./ byfn . sh - m down 逐步运行命令 证书生成器 用 cryptogen来为网络中的实体生成加密材料（证书），这些证书是身份的代表，它们允许在我们的实体进行交流和交易时进行签名/验证身份验证。 证书是如何工作的： cryptogen工具读取包含网络拓扑的 crypto-config.yaml配置文件来生成相关证书，并允许我们为组织和属于这些组织的组件生成一组证书和密钥。每个组织都配置了一个唯一的根证书（ca-cert），它将特定组件（peer node和ordering node）绑定到该组织。通过为每个组织分配唯一的CA证书，我们正在模仿一个典型的网络，参与会员将使用自己的证书授权。 Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 我们运行完&nbsp; cryptogen &nbsp;这个工具后, 生成的证书和秘钥会保存在一个名为 crypto-config 的文件夹里面 配置事务生成器 configtxgen&nbsp;tool &nbsp;用来创建4个配置文件: orderer&nbsp;genesis&nbsp;block, channel&nbsp;channel&nbsp;configuration&nbsp;transaction, and two&nbsp;anchor&nbsp;peer&nbsp;transactions&nbsp;- one for each Peer Org. order block是用于ordering服务的创世纪块， &nbsp;channel transaction文件在通道创建时广播给orderer。 anchor peer transactions, 按照名称可能得出的提示， anchor peer transactions在此通道上指定每个组织的锚点peer。 configtxgen &nbsp; tool是如何工作的？ Configtxgen 工具读取 -&nbsp; configtx.yaml &nbsp;- 这个配置文件，这个配置文件包含一个简单网络的定义。有3个会员 - 一个 Orderer Org ( OrdererOrg ) 和2个 Peer Orgs ( Org1 &nbsp;&amp;&nbsp; Org2 ) ，这两个Org分别管理着两个peer，这个文件也指定了一个 组合-&nbsp; SampleConsortium &nbsp;- ，包含了两个Peer Orgs. 注意：sampleConsortium被定义在system-level profile中，接下来被channel-level profile引用。Channels存在在consortium的范围内，所有的consortium都在network的范围内。 你会看到这个文件有两个不同的头部，一个是给-&nbsp; TwoOrgsOrdererGenesis &nbsp;- 用，另一个是给通道用-&nbsp; TwoOrgsChannel . 这两个头部很重要，因为会作为创建上面4个配置文件的参数给传递出去。 这个配置文件还有两个附加的定义是值得我们注意的： Org(peer0.org1.example.com&nbsp;&amp;&nbsp;peer0.org2.example.com)的anchor节点，另外一个就是指向每个成员的MSP目录的位置，基于此，我们可以将每个Org的根证书存放在orderer Genesis block中，这是一个很重要的概念。现在任意network entity与ordering service通信时就能对其数字签名进行验证。 运行tool: 可以通过configtxgen&nbsp;and&nbsp;cryptogen手动生成证书/密钥以及各项配置文件。同样，可以参考byfn.sh脚本实现。 可以参考byfn.sh脚本中的generateCerts函数用来生成证书（这些证书被定义在crypto-config.yaml中的网络配置所使用）所需要的命令。为了方便起见，我们提供一个参考如下。 首先，先跑起来cryptogen工具，我们的二进制文件都在bin目录下，因此我们需要cd到tool所在的目录下. ../bin/cryptogen generate --config=./crypto-config.yaml 接下来，我们会告诉configtxgen工具去哪找到需要调用的configtx.yaml文件。 首先，我们需要设置一个环境变量，用于告知configtxgen根据去哪找configtx.yaml配置文件。接下来，我们调用configtxgen工具创建orderer Genesis block export FABRIC_CFG_PATH= $PWD.. /bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 接着，我们创建channel transaction artifact(channel.tx)。然后，确保替换$CHANNEL_NAME export CHANNEL_NAME= mychannel .. /bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接着，我们在我们正在创建的channel上定义Org1的anchor节点。然后，确保替换$CHANNEL_NAME ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 然后，我们在相同的channel上定义Org2的anchor节点。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 启动network 我们利用docker-compose脚本来启动我们的network。docker-compose文件引用了我们之前下载的镜像，并使用前面生成的genesis block来引导orderer。 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/ peer# command: /bin/bash -c ‘./scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT‘ volumes ---------docker-compose-cli.yaml 如果没有注释掉上面的命令的话，在network启动的时候，其将执行所有的CLI命令，然后就会导致文章末尾中的错误。 启动network，注意$CHANNEL_NAME,&lt;pick_a_value&gt;自己设定 CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=&lt;pick_a_value&gt; docker-compose -f docker-compose-cli.yaml up -d 9.环境变量 对于以下针对peer0.org1.example.com的CLI命令，我们需要使用以下给出的四个环境变量来介绍我们的命令。这些peer0.org1.example.com变量都被包含在CLI容器里，因此我们可以不用传递的操作它们。然而！，如果你想发送calls到其他peers或者orderer，你需要根据情况提供这些变量。打开docker-compose-base.yaml并查看具体的路径信息 # Environment variables for PEER0CORE_PEER_MSPCONFIGPATH =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/ mspCORE_PEER_ADDRESS =peer0.org1.example.com: 7051 CORE_PEER_LOCALMSPID = &quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 10.创建并进入Channel docker exec -it cli bash 请回忆下我们使用configtxgen工具生成channel配置artifact-channel.tx。我们将把artifact作为创建channel的请求的一部分发送给orderer。 注意到在接下来的命令中我们发送了-- cafile作为命令的一部分。这个是orderer证书的本地路径，使得我们可以验证TLS握手。 我们使用-c flag 标注出我们的channel名称，用-f flag标注出我们的channel 配置transaction。在本例中是channel.tx，然而你可以使用不同的名称用于挂载配置transaction。使用下面创建channel的语句的时候注意channel-name。 export CHANNEL_NAME= mychannel peer channel create -o orderer.example.com: 7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令返回了一个genesis block-&nbsp;&lt;channel-ID.block&gt;&nbsp;-我们可以通过这个id进入到channel。它包含channel.tx中指定的配置信息，创建成功后有如下输出： 接下来的操作都需要在CLI容器中进行，在操作peer0.org1.example.com之外的peer时，需要记得相关环境变量的命令。 接下来我们把peer0.org1.example.com加入到channel中去，channel-ID.block是之前生成的，这里我的是mychannel.block。 peer channel join -b &lt;channel-ID.block&gt; 你可把其他的peer加入到该channel上，但是需要设置上述的四个环境变量。 安装并实例化chaincode 我们这里只是使用已经存在的chaincode。 application通过chaincode与blockchain ledger进行交互。我们把chaincode安装到execute与endorse我们transaction的peer上，接下来在channel上初始化chaincode。 首先，安装sample go代码到4个peer之一的peer上。以下命令把chaincode的源代码放到了peer节点的文件系统上。 peer chaincode install - n mycc - v 1.0 - p github . com / hyperledger / fabric / examples / chaincode / go / chaincode_example02 接下来，在channel上实例化chaincode。这将在channel上初始化chaincode，同时设置chaincode的endorsement的策略，然后在目标peer上启动chaincode容器。请注意-P参数，我们通过设置这个参数，来指定transaction的endorsement的需求level，用于验证chaincode。 在下面的命令，我们定义了endorsement策略为-P&nbsp;&quot;OR&nbsp;(‘Org0MSP.member‘,‘Org1MSP.member‘)&quot;。这表示我们需要隶属于Org1或者Org2的peer进行“endorsement”（也就是说，只有一个endorsement）。如果把or改为and则说明我们需要两个endorsement peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询 首先查询a的值，确保chaincode已经正常的实例化，同时确保state DB已经被填充 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 调用 让我们从a账户转移10个到b账户，这个命令将会创建新的block同时更新state DB。 peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 上述调用过程解析 script.sh脚本在CLI容器内部执行，该脚本执行了createChannel命令，提供了channel名称，同时使用channel.tx进行channel配置 createChannel的输出是一个genesis block，使用channel名称命名的block，例如mychannel.block，该block在peers的文件系统上存储，该block包括channel.tx指定的channel配置信息。 加入channel的命令对所有4个peer进行执行，把之前生成的genesis block作为输入。这个join命令使得peers加入mychannel里面，同时创建了一个以mychannel.block作为开始的chain。 接着，我们拥有了由4个peer，两个organization组成的channel。这都在我们TwoOrgsChannel&nbsp;profile.里面。 peer0.org1.example.com&nbsp;与&nbsp;peer1.org1.example.com&nbsp;隶属于 Org1;&nbsp;peer0.org2.example.com 以及&nbsp;peer1.org2.example.com&nbsp;隶属于 Org2。这些关系在crypto-config.yaml中定义，同时在我们的docker compose中指定了MSP的路径。 Org1MSP (peer0.org1.example.com) 以及 Org2MSP (peer0.org2.example.com)的anchor节点接下来被更新了。我们基于建立的channel把Org1MSPanchors.tx&nbsp;与&nbsp;Org2MSPanchors.tx&nbsp;的artifacts，发送给orderering service，以实现上述的更新。 chaincode_example02被安装在了peer0.org1.example.com&nbsp;与&nbsp;peer0.org2.example.com 接着chaincode在peer0.org2.example.com被实例化。实例化把chaincode加到channel上，并启动目标peer的容器，接着初始化chaincode有关的键-值对（&nbsp;[“a”,”100” “b”,”200”]）。实例化的过程导致了dev-peer0.org2.example.com-zeychaincode-1.0的启动。 实例化需要有endorsement策略的参数，这里设置为-P&nbsp;&quot;OR&nbsp;&nbsp;&nbsp;&nbsp;(‘Org1MSP.member‘,‘Org2MSP.member‘)&quot;，表示任意transaction必须被Org1 或者 Org2的一个peer进行endorsed。 接下来把对“a”的查询发送给peer0.org1.example.com，即在peer0.org1.example.com查询a的值。chaincode之前已经安装在了peer0.org1.example.com上，因此这个查询将会针对Org1 peer0 启动一个容器（dev-peer0.org1.example.com-zeychaincode-1.0），然后查询结果得到返回，没有任何写的操作发生，因此返回值是100 接着调用请求发送给peer0.org1.example.com，把10个从a转移到b。 然后chaincode在peer1.org2.example.com进行安装。 然后一个查询a的余额的请求发送到peer1.org2.example.com。这个启动了第三个chaincode容器（dev-peer1.org2.example.com-mycc-1.0），90被返回。正确的反应了上述transaction，a的值被改为了10。 Error: Got unexpected status: BAD_REQUEST 原因是存在同名的channel 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"linux系统版本：CentOS Linux release 7.2.1511 (Core) 构建您的第一个网络（BYFN）场景提供了一个由两个组织组成的示例Hyperledger Fabric网络，每个组织都有两个peer节点，以及一个“solo”ordering服务。 （1）先决条件 安装curl 安装docker &amp; docker compose,Docker 版本要求 17.06.2-ce or greater 我本机的docker 版本是Docker version 17.09.0-ce, build afdb6d4 docker-compose version 1.16.1, build 6d1ac219 安装go语言，版本1.9.x&nbsp;or greater 安装node.js和npm python 2.7 &nbsp; The Fabric Node.js SDK requires an iteration of Python 2.7 in order for&nbsp; npm&nbsp;install &nbsp;operations to complete successfully 下载官网的例子，并且下载特定于平台的二进制文件 git clone https://github.com/hyperledger/fabric-samples.git cd first - network curl - sSL https : // goo . gl / Q3YRTi | bash 如果这个命令不能成功执行的话，就先去下载好对应的脚本，然后再执行，执行好后会发现当前目录多了一个bin目录，目录里面有： cryptogen, configtxgen, configtxlator, and peer 然后把这个bin目录添加到系统的环境变量中去 （2）官网提供了两种方法创建网络： 懒人方法，一键运行脚本 cd first - network ./ byfn . sh - m generate ./ byfn . sh - m up ./ byfn . sh - m down 逐步运行命令 证书生成器 用 cryptogen来为网络中的实体生成加密材料（证书），这些证书是身份的代表，它们允许在我们的实体进行交流和交易时进行签名/验证身份验证。 证书是如何工作的： cryptogen工具读取包含网络拓扑的 crypto-config.yaml配置文件来生成相关证书，并允许我们为组织和属于这些组织的组件生成一组证书和密钥。每个组织都配置了一个唯一的根证书（ca-cert），它将特定组件（peer node和ordering node）绑定到该组织。通过为每个组织分配唯一的CA证书，我们正在模仿一个典型的网络，参与会员将使用自己的证书授权。 Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 我们运行完&nbsp; cryptogen &nbsp;这个工具后, 生成的证书和秘钥会保存在一个名为 crypto-config 的文件夹里面 配置事务生成器 configtxgen&nbsp;tool &nbsp;用来创建4个配置文件: orderer&nbsp;genesis&nbsp;block, channel&nbsp;channel&nbsp;configuration&nbsp;transaction, and two&nbsp;anchor&nbsp;peer&nbsp;transactions&nbsp;- one for each Peer Org. order block是用于ordering服务的创世纪块， &nbsp;channel transaction文件在通道创建时广播给orderer。 anchor peer transactions, 按照名称可能得出的提示， anchor peer transactions在此通道上指定每个组织的锚点peer。 configtxgen &nbsp; tool是如何工作的？ Configtxgen 工具读取 -&nbsp; configtx.yaml &nbsp;- 这个配置文件，这个配置文件包含一个简单网络的定义。有3个会员 - 一个 Orderer Org ( OrdererOrg ) 和2个 Peer Orgs ( Org1 &nbsp;&amp;&nbsp; Org2 ) ，这两个Org分别管理着两个peer，这个文件也指定了一个 组合-&nbsp; SampleConsortium &nbsp;- ，包含了两个Peer Orgs. 注意：sampleConsortium被定义在system-level profile中，接下来被channel-level profile引用。Channels存在在consortium的范围内，所有的consortium都在network的范围内。 你会看到这个文件有两个不同的头部，一个是给-&nbsp; TwoOrgsOrdererGenesis &nbsp;- 用，另一个是给通道用-&nbsp; TwoOrgsChannel . 这两个头部很重要，因为会作为创建上面4个配置文件的参数给传递出去。 这个配置文件还有两个附加的定义是值得我们注意的： Org(peer0.org1.example.com&nbsp;&amp;&nbsp;peer0.org2.example.com)的anchor节点，另外一个就是指向每个成员的MSP目录的位置，基于此，我们可以将每个Org的根证书存放在orderer Genesis block中，这是一个很重要的概念。现在任意network entity与ordering service通信时就能对其数字签名进行验证。 运行tool: 可以通过configtxgen&nbsp;and&nbsp;cryptogen手动生成证书/密钥以及各项配置文件。同样，可以参考byfn.sh脚本实现。 可以参考byfn.sh脚本中的generateCerts函数用来生成证书（这些证书被定义在crypto-config.yaml中的网络配置所使用）所需要的命令。为了方便起见，我们提供一个参考如下。 首先，先跑起来cryptogen工具，我们的二进制文件都在bin目录下，因此我们需要cd到tool所在的目录下. ../bin/cryptogen generate --config=./crypto-config.yaml 接下来，我们会告诉configtxgen工具去哪找到需要调用的configtx.yaml文件。 首先，我们需要设置一个环境变量，用于告知configtxgen根据去哪找configtx.yaml配置文件。接下来，我们调用configtxgen工具创建orderer Genesis block export FABRIC_CFG_PATH= $PWD.. /bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 接着，我们创建channel transaction artifact(channel.tx)。然后，确保替换$CHANNEL_NAME export CHANNEL_NAME= mychannel .. /bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接着，我们在我们正在创建的channel上定义Org1的anchor节点。然后，确保替换$CHANNEL_NAME ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 然后，我们在相同的channel上定义Org2的anchor节点。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 启动network 我们利用docker-compose脚本来启动我们的network。docker-compose文件引用了我们之前下载的镜像，并使用前面生成的genesis block来引导orderer。 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/ peer# command: /bin/bash -c ‘./scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT‘ volumes ---------docker-compose-cli.yaml 如果没有注释掉上面的命令的话，在network启动的时候，其将执行所有的CLI命令，然后就会导致文章末尾中的错误。 启动network，注意$CHANNEL_NAME,&lt;pick_a_value&gt;自己设定 CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=&lt;pick_a_value&gt; docker-compose -f docker-compose-cli.yaml up -d 9.环境变量 对于以下针对peer0.org1.example.com的CLI命令，我们需要使用以下给出的四个环境变量来介绍我们的命令。这些peer0.org1.example.com变量都被包含在CLI容器里，因此我们可以不用传递的操作它们。然而！，如果你想发送calls到其他peers或者orderer，你需要根据情况提供这些变量。打开docker-compose-base.yaml并查看具体的路径信息 # Environment variables for PEER0CORE_PEER_MSPCONFIGPATH =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/ mspCORE_PEER_ADDRESS =peer0.org1.example.com: 7051 CORE_PEER_LOCALMSPID = &quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE =/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 10.创建并进入Channel docker exec -it cli bash 请回忆下我们使用configtxgen工具生成channel配置artifact-channel.tx。我们将把artifact作为创建channel的请求的一部分发送给orderer。 注意到在接下来的命令中我们发送了-- cafile作为命令的一部分。这个是orderer证书的本地路径，使得我们可以验证TLS握手。 我们使用-c flag 标注出我们的channel名称，用-f flag标注出我们的channel 配置transaction。在本例中是channel.tx，然而你可以使用不同的名称用于挂载配置transaction。使用下面创建channel的语句的时候注意channel-name。 export CHANNEL_NAME= mychannel peer channel create -o orderer.example.com: 7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令返回了一个genesis block-&nbsp;&lt;channel-ID.block&gt;&nbsp;-我们可以通过这个id进入到channel。它包含channel.tx中指定的配置信息，创建成功后有如下输出： 接下来的操作都需要在CLI容器中进行，在操作peer0.org1.example.com之外的peer时，需要记得相关环境变量的命令。 接下来我们把peer0.org1.example.com加入到channel中去，channel-ID.block是之前生成的，这里我的是mychannel.block。 peer channel join -b &lt;channel-ID.block&gt; 你可把其他的peer加入到该channel上，但是需要设置上述的四个环境变量。 安装并实例化chaincode 我们这里只是使用已经存在的chaincode。 application通过chaincode与blockchain ledger进行交互。我们把chaincode安装到execute与endorse我们transaction的peer上，接下来在channel上初始化chaincode。 首先，安装sample go代码到4个peer之一的peer上。以下命令把chaincode的源代码放到了peer节点的文件系统上。 peer chaincode install - n mycc - v 1.0 - p github . com / hyperledger / fabric / examples / chaincode / go / chaincode_example02 接下来，在channel上实例化chaincode。这将在channel上初始化chaincode，同时设置chaincode的endorsement的策略，然后在目标peer上启动chaincode容器。请注意-P参数，我们通过设置这个参数，来指定transaction的endorsement的需求level，用于验证chaincode。 在下面的命令，我们定义了endorsement策略为-P&nbsp;&quot;OR&nbsp;(‘Org0MSP.member‘,‘Org1MSP.member‘)&quot;。这表示我们需要隶属于Org1或者Org2的peer进行“endorsement”（也就是说，只有一个endorsement）。如果把or改为and则说明我们需要两个endorsement peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询 首先查询a的值，确保chaincode已经正常的实例化，同时确保state DB已经被填充 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 调用 让我们从a账户转移10个到b账户，这个命令将会创建新的block同时更新state DB。 peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 上述调用过程解析 script.sh脚本在CLI容器内部执行，该脚本执行了createChannel命令，提供了channel名称，同时使用channel.tx进行channel配置 createChannel的输出是一个genesis block，使用channel名称命名的block，例如mychannel.block，该block在peers的文件系统上存储，该block包括channel.tx指定的channel配置信息。 加入channel的命令对所有4个peer进行执行，把之前生成的genesis block作为输入。这个join命令使得peers加入mychannel里面，同时创建了一个以mychannel.block作为开始的chain。 接着，我们拥有了由4个peer，两个organization组成的channel。这都在我们TwoOrgsChannel&nbsp;profile.里面。 peer0.org1.example.com&nbsp;与&nbsp;peer1.org1.example.com&nbsp;隶属于 Org1;&nbsp;peer0.org2.example.com 以及&nbsp;peer1.org2.example.com&nbsp;隶属于 Org2。这些关系在crypto-config.yaml中定义，同时在我们的docker compose中指定了MSP的路径。 Org1MSP (peer0.org1.example.com) 以及 Org2MSP (peer0.org2.example.com)的anchor节点接下来被更新了。我们基于建立的channel把Org1MSPanchors.tx&nbsp;与&nbsp;Org2MSPanchors.tx&nbsp;的artifacts，发送给orderering service，以实现上述的更新。 chaincode_example02被安装在了peer0.org1.example.com&nbsp;与&nbsp;peer0.org2.example.com 接着chaincode在peer0.org2.example.com被实例化。实例化把chaincode加到channel上，并启动目标peer的容器，接着初始化chaincode有关的键-值对（&nbsp;[“a”,”100” “b”,”200”]）。实例化的过程导致了dev-peer0.org2.example.com-zeychaincode-1.0的启动。 实例化需要有endorsement策略的参数，这里设置为-P&nbsp;&quot;OR&nbsp;&nbsp;&nbsp;&nbsp;(‘Org1MSP.member‘,‘Org2MSP.member‘)&quot;，表示任意transaction必须被Org1 或者 Org2的一个peer进行endorsed。 接下来把对“a”的查询发送给peer0.org1.example.com，即在peer0.org1.example.com查询a的值。chaincode之前已经安装在了peer0.org1.example.com上，因此这个查询将会针对Org1 peer0 启动一个容器（dev-peer0.org1.example.com-zeychaincode-1.0），然后查询结果得到返回，没有任何写的操作发生，因此返回值是100 接着调用请求发送给peer0.org1.example.com，把10个从a转移到b。 然后chaincode在peer1.org2.example.com进行安装。 然后一个查询a的余额的请求发送到peer1.org2.example.com。这个启动了第三个chaincode容器（dev-peer1.org2.example.com-mycc-1.0），90被返回。正确的反应了上述transaction，a的值被改为了10。 Error: Got unexpected status: BAD_REQUEST 原因是存在同名的channel 阅读更多","@type":"BlogPosting","url":"/2017/10/20/9b83065b1a30a763fbd41aff62020825.html","headline":"基于HyperLedger 创建第一个区块链网络","dateModified":"2017-10-20T00:00:00+08:00","datePublished":"2017-10-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/10/20/9b83065b1a30a763fbd41aff62020825.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于HyperLedger 创建第一个区块链网络</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="line-height:1.75;font-size:14px;">
   linux系统版本：CentOS Linux release 7.2.1511 (Core)
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   构建您的第一个网络（BYFN）场景提供了一个由两个组织组成的示例Hyperledger Fabric网络，每个组织都有两个peer节点，以及一个“solo”ordering服务。
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="font-size:22px;"><strong>（1）先决条件</strong></span>
  </div> 
  <ul>
   <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;"> 安装curl</li>
   <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;"> 安装docker &amp; docker compose,<span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">Docker 版本要求 17.06.2-ce or greater</span></li>
  </ul>
  <div style="text-indent:56px;line-height:1.75;font-size:14px;">
    我本机的docker 版本是Docker version 17.09.0-ce, build afdb6d4
  </div> 
  <div style="text-indent:56px;line-height:1.75;font-size:14px;">
    docker-compose version 1.16.1, build 6d1ac219
  </div> 
  <ul>
   <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;"> 安装go语言，版本1.9.x<span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(217,229,239);">&nbsp;</span>or greater</li>
   <li style="text-indent:28px;text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;"> 安装node.js和npm</li>
   <li style="text-indent:28px;text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;"> python 2.7</li>
  </ul>
  <div style="text-indent:56px;line-height:1.75;font-size:14px;"> 
   <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;</span>
   <span style="font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">The Fabric Node.js SDK requires an iteration of Python 2.7 in order</span>
  </div> 
  <div style="text-indent:28px;line-height:1.75;font-size:14px;"> 
   <span style="font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">for&nbsp;</span>
   <span style="font-family:'Courier New';color:rgb(231,76,60);">npm&nbsp;install</span>
   <span style="font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;operations to complete successfully</span>
  </div> 
  <ul>
   <li style="text-indent:28px;text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(1,1,1);"> <span style="background-color:rgb(252,252,252);">下载官网的例子，并且下载特定于平台的二进制文件</span></li>
  </ul>
  <div style="text-indent:56px;line-height:1.75;font-size:14px;"> 
   <span style="font-family:'Courier New';color:rgb(51,51,51);">git</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">clone</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <a href="https://github.com/hyperledger/fabric-samples.git" rel="nofollow"><span style="font-family:'Courier New';color:rgb(0,56,132);">https:</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>//</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">github</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>.</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">com</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>/</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">hyperledger</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>/</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">fabric</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>-</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">samples</span><span style="font-family:'Courier New';color:rgb(0,56,132);"><strong>.</strong></span><span style="font-family:'Courier New';color:rgb(0,56,132);">git</span></a>
  </div> 
  <div style="text-indent:56px;line-height:1.75;font-size:14px;"> 
   <span style="font-family:'Courier New';color:rgb(51,51,51);">cd</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">first</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">network</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="font-family:'Courier New';color:rgb(51,51,51);">curl</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">sSL</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">https</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);">:</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>//</strong></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">goo</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>.</strong></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">gl</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">Q3YRTi</span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>|</strong></span>
   <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
   <span style="font-family:'Courier New';color:rgb(51,51,51);">bash 如果这个命令不能成功执行的话，就先去下载好对应的脚本，然后再执行，执行好后会发现当前目录多了一个bin目录，目录里面有：</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="color:rgb(223,64,42);">cryptogen,</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="color:rgb(223,64,42);">configtxgen,</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="color:rgb(223,64,42);">configtxlator, and</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   <span style="color:rgb(223,64,42);">peer</span>
  </div> 
  <div style="line-height:1.75;font-size:14px;">
   然后把这个bin目录添加到系统的环境变量中去
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:22px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">（2）官网提供了两种方法创建网络：</span>
   </div> 
   <ol>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:decimal;font-family:Arial;color:rgb(1,1,1);"> <span style="background-color:rgb(252,252,252);">懒人方法，一键运行脚本</span></li>
   </ol>
   <div style="text-indent:28px;line-height:1.75;font-size:14px;"> 
    <span style="font-family:'Courier New';color:rgb(51,51,51);">cd</span>
    <span style="font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-family:'Courier New';color:rgb(51,51,51);">first</span>
    <span style="font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-family:'Courier New';color:rgb(51,51,51);">network</span>
   </div> 
   <div style="text-indent:28px;line-height:1.75;font-size:14px;"> 
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>./</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">byfn</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>.</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">sh</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">m</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">generate</span>
   </div> 
   <div style="text-indent:28px;line-height:1.75;font-size:14px;"> 
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>./</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">byfn</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>.</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">sh</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">m</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">up</span>
   </div> 
   <div style="text-indent:28px;line-height:1.75;font-size:14px;"> 
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>./</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">byfn</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>.</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">sh</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">m</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">down</span>
   </div> 
   <ol start="2">
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;"> 逐步运行命令</li>
   </ol>
   <ul>
    <li style="text-indent:28px;text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(1,1,1);font-weight:bold;"> <span style="background-color:rgb(252,252,252);">证书生成器</span></li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    用
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">cryptogen</span>来为网络中的实体生成加密材料（证书），这些证书是身份的代表，它们允许在我们的实体进行交流和交易时进行签名/验证身份验证。
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    证书是如何工作的：
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">cryptogen</span>工具读取包含网络拓扑的
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">crypto-config.yaml</span>配置文件来生成相关证书，并允许我们为组织和属于这些组织的组件生成一组证书和密钥。每个组织都配置了一个唯一的根证书（ca-cert），它将特定组件（peer node和ordering node）绑定到该组织。通过为每个组织分配唯一的CA证书，我们正在模仿一个典型的网络，参与会员将使用自己的证书授权。 Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">我们运行完&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">cryptogen</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;这个工具后, 生成的证书和秘钥会保存在一个名为</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">crypto-config</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">的文件夹里面</span>
   </div> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(34,34,34);font-weight:bold;"> <span style="background-color:rgb(245,245,245);">配置事务生成器</span></li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">configtxgen&nbsp;tool</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;用来创建4个配置文件:</span>
   </div> 
   <ul>
    <li style="margin-left:28px;line-height:1.5;text-align:left;font-size:16px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(1,1,1);"> <span style="background-color:rgb(252,252,252);">orderer&nbsp;</span><span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">genesis&nbsp;block</span><span style="background-color:rgb(252,252,252);">,</span></li>
    <li style="margin-left:28px;line-height:1.5;text-align:left;font-size:16px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(1,1,1);"> <span style="background-color:rgb(252,252,252);">channel&nbsp;</span><span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">channel&nbsp;configuration&nbsp;transaction</span><span style="background-color:rgb(252,252,252);">,</span></li>
    <li style="margin-left:28px;line-height:1.5;text-align:left;font-size:16px;list-style-position:inside;list-style-type:disc;font-family:Arial;color:rgb(1,1,1);"> <span style="background-color:rgb(252,252,252);">and two&nbsp;</span><span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">anchor&nbsp;peer&nbsp;transactions</span><span style="background-color:rgb(252,252,252);">&nbsp;- one for each Peer Org.</span></li>
   </ul>
   <div style="margin-left:28px;line-height:1.5;font-size:14px;">
     order block是用于ordering服务的创世纪块，
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;channel transaction</span>文件在通道创建时广播给orderer。
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">anchor peer transactions,</span> 按照名称可能得出的提示，
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">anchor peer transactions</span>在此通道上指定每个组织的锚点peer。
   </div> 
   <div style="margin-left:28px;line-height:1.5;font-size:14px;"> 
    <br>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">configtxgen</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">tool</span>是如何工作的？
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">Configtxgen 工具读取 -&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">configtx.yaml</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;- 这个配置文件，这个配置文件包含一个简单网络的定义。有3个会员 - 一个 Orderer Org (</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">OrdererOrg</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">) 和2个 Peer Orgs (</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">Org1</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;&amp;&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">Org2</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">) ，这两个Org分别管理着两个peer，这个文件也指定了一个 组合-&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">SampleConsortium</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;- ，包含了两个Peer Orgs.</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">注意：sampleConsortium被定义在system-level profile中，接下来被channel-level profile引用。Channels存在在consortium的范围内，所有的consortium都在network的范围内。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">你会看到这个文件有两个不同的头部，一个是给-&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">TwoOrgsOrdererGenesis</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">&nbsp;- 用，另一个是给通道用-&nbsp;</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(231,76,60);">TwoOrgsChannel</span>
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">.</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">这两个头部很重要，因为会作为创建上面4个配置文件的参数给传递出去。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:16px;font-family:Arial;color:rgb(1,1,1);background-color:rgb(252,252,252);">这个配置文件还有两个附加的定义是值得我们注意的：</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">Org(peer0.org1.example.com&nbsp;&amp;&nbsp;peer0.org2.example.com)的anchor节点，另外一个就是指向每个成员的MSP目录的位置，基于此，我们可以将每个Org的根证书存放在orderer Genesis block中，这是一个很重要的概念。现在任意network entity与ordering service通信时就能对其数字签名进行验证。</span>
   </div> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 运行tool:</li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">可以通过configtxgen&nbsp;and&nbsp;cryptogen手动生成证书/密钥以及各项配置文件。同样，可以参考byfn.sh脚本实现。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">可以参考byfn.sh脚本中的generateCerts函数用来生成证书（这些证书被定义在crypto-config.yaml中的网络配置所使用）所需要的命令。为了方便起见，我们提供一个参考如下。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">首先，先跑起来cryptogen工具，我们的二进制文件都在bin目录下，因此我们需要cd到tool所在的目录下.</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">../bin/cryptogen generate --config=./crypto-config.yaml</span>
   </div> 
   <div>
    <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100217005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
    <br>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">接下来，我们会告诉configtxgen工具去哪找到需要调用的configtx.yaml文件。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">首先，我们需要设置一个环境变量，用于告知configtxgen根据去哪找configtx.yaml配置文件。接下来，我们调用configtxgen工具创建orderer Genesis block</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">export FABRIC_CFG_PATH=</span>
    <span style="background-color:rgb(246,246,246);">$PWD..</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100306550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">接着，我们创建channel transaction artifact(channel.tx)。然后，确保替换$CHANNEL_NAME</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">export CHANNEL_NAME=</span>
    <span style="background-color:rgb(246,246,246);">mychannel</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="background-color:rgb(246,246,246);">..</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100404196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">接着，我们在我们正在创建的channel上定义Org1的anchor节点。然后，确保替换$CHANNEL_NAME</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100435499?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">然后，我们在相同的channel上定义Org2的anchor节点。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100510896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:22px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 启动network</li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">我们利用docker-compose脚本来启动我们的network。docker-compose文件引用了我们之前下载的镜像，并使用前面生成的genesis block来引导orderer。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">working_dir: /opt/gopath/src/github.com/hyperledger/fabric/</span>
    <span style="background-color:rgb(246,246,246);">peer# command: </span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">/bin/bash -c</span>
    <span style="color:rgb(128,0,0);background-color:rgb(246,246,246);">‘./scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT‘</span>
    <span style="background-color:rgb(246,246,246);">volumes ---------docker-compose-cli.yaml</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">如果没有注释掉上面的命令的话，在network启动的时候，其将执行所有的CLI命令，然后就会导致文章末尾中的错误。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">启动network，注意$CHANNEL_NAME,&lt;pick_a_value&gt;自己设定</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=&lt;pick_a_value&gt; docker-compose -f docker-compose-cli.yaml up -d</span>
   </div> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 9.环境变量</li>
   </ul>
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">对于以下针对peer0.org1.example.com的CLI命令，我们需要使用以下给出的四个环境变量来介绍我们的命令。这些peer0.org1.example.com变量都被包含在CLI容器里，因此我们可以不用传递的操作它们。然而！，如果你想发送calls到其他peers或者orderer，你需要根据情况提供这些变量。打开docker-compose-base.yaml并查看具体的路径信息</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);"># Environment variables</span>
    <span style="color:rgb(0,0,255);background-color:rgb(246,246,246);">for</span>
    <span style="background-color:rgb(246,246,246);"> PEER0CORE_PEER_MSPCONFIGPATH</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/</span>
    <span style="background-color:rgb(246,246,246);">mspCORE_PEER_ADDRESS</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">=peer0.org1.example.com:</span>
    <span style="color:rgb(128,0,128);background-color:rgb(246,246,246);">7051</span>
    <span style="background-color:rgb(246,246,246);">CORE_PEER_LOCALMSPID</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">=</span>
    <span style="color:rgb(128,0,0);background-color:rgb(246,246,246);">"Org1MSP"</span>
    <span style="background-color:rgb(246,246,246);">CORE_PEER_TLS_ROOTCERT_FILE</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span>
   </div> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 10.创建并进入Channel</li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">docker exec -it cli bash</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100554603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">请回忆下我们使用configtxgen工具生成channel配置artifact-channel.tx。我们将把artifact作为创建channel的请求的一部分发送给orderer。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">注意到在接下来的命令中我们发送了-- cafile作为命令的一部分。这个是orderer证书的本地路径，使得我们可以验证TLS握手。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">我们使用-c flag 标注出我们的channel名称，用-f flag标注出我们的channel 配置transaction。在本例中是channel.tx，然而你可以使用不同的名称用于挂载配置transaction。使用下面创建channel的语句的时候注意channel-name。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">export CHANNEL_NAME=</span>
    <span style="background-color:rgb(246,246,246);">mychannel</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="background-color:rgb(246,246,246);">peer channel create</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">-o orderer.example.com:</span>
    <span style="color:rgb(128,0,128);background-color:rgb(246,246,246);">7050</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);"> -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">上述命令返回了一个genesis block-&nbsp;&lt;channel-ID.block&gt;&nbsp;-我们可以通过这个id进入到channel。它包含channel.tx中指定的配置信息，创建成功后有如下输出：</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100628058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">接下来的操作都需要在CLI容器中进行，在操作peer0.org1.example.com之外的peer时，需要记得相关环境变量的命令。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">接下来我们把peer0.org1.example.com加入到channel中去，channel-ID.block是之前生成的，这里我的是mychannel.block。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="background-color:rgb(246,246,246);">peer channel join</span>
    <span style="color:rgb(63,63,63);background-color:rgb(246,246,246);">-b &lt;channel-ID.block&gt;</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100710958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">你可把其他的peer加入到该channel上，但是需要设置上述的四个环境变量。</span>
   </div> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 安装并实例化chaincode</li>
   </ul>
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">我们这里只是使用已经存在的chaincode。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">application通过chaincode与blockchain ledger进行交互。我们把chaincode安装到execute与endorse我们transaction的peer上，接下来在channel上初始化chaincode。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">首先，安装sample go代码到4个peer之一的peer上。以下命令把chaincode的源代码放到了peer节点的文件系统上。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">peer</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">chaincode</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">install</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">n</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">mycc</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">v</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(0,153,153);">1.0</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>-</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">p</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">github</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>.</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">com</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">hyperledger</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">fabric</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">examples</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">chaincode</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">go</span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);"><strong>/</strong></span>
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);">chaincode_example02</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100743294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(51,51,51);"><br></span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">接下来，在channel上实例化chaincode。这将在channel上初始化chaincode，同时设置chaincode的endorsement的策略，然后在目标peer上启动chaincode容器。请注意-P参数，我们通过设置这个参数，来指定transaction的endorsement的需求level，用于验证chaincode。</span>
   </div> 
   <div style="line-height:2.14286;font-size:14px;">
    <span style="color:rgb(63,63,63);">在下面的命令，我们定义了endorsement策略为-P&nbsp;"OR&nbsp;(‘Org0MSP.member‘,‘Org1MSP.member‘)"。这表示我们需要隶属于Org1或者Org2的peer进行“endorsement”（也就是说，只有一个endorsement）。如果把or改为and则说明我们需要两个endorsement</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);">peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020100934930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 查询</li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">首先查询a的值，确保chaincode已经正常的实例化，同时确保state DB已经被填充</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020101022295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);font-weight:bold;"> 调用</li>
   </ul>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(63,63,63);">让我们从a账户转移10个到b账户，这个命令将会创建新的block同时更新state DB。</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="font-size:12px;font-family:'Courier New';color:rgb(64,64,64);">peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}'</span>
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020101102113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <div style="line-height:1.75;font-size:14px;">
    peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'
   </div> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171020101139341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTAxMTAyNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div style="line-height:1.75;font-size:14px;"> 
   <ul>
    <li style="text-align:left;line-height:1.75;font-size:18px;list-style-position:inside;list-style-type:disc;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 上述调用过程解析</li>
   </ul>
   <ol>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> script.sh脚本在CLI容器内部执行，该脚本执行了createChannel命令，提供了channel名称，同时使用channel.tx进行channel配置</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> createChannel的输出是一个genesis block，使用channel名称命名的block，例如mychannel.block，该block在peers的文件系统上存储，该block包括channel.tx指定的channel配置信息。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 加入channel的命令对所有4个peer进行执行，把之前生成的genesis block作为输入。这个join命令使得peers加入mychannel里面，同时创建了一个以mychannel.block作为开始的chain。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 接着，我们拥有了由4个peer，两个organization组成的channel。这都在我们TwoOrgsChannel&nbsp;profile.里面。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> peer0.org1.example.com&nbsp;与&nbsp;peer1.org1.example.com&nbsp;隶属于 Org1;&nbsp;peer0.org2.example.com 以及&nbsp;peer1.org2.example.com&nbsp;隶属于 Org2。这些关系在crypto-config.yaml中定义，同时在我们的docker compose中指定了MSP的路径。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> Org1MSP (peer0.org1.example.com) 以及 Org2MSP (peer0.org2.example.com)的anchor节点接下来被更新了。我们基于建立的channel把Org1MSPanchors.tx&nbsp;与&nbsp;Org2MSPanchors.tx&nbsp;的artifacts，发送给orderering service，以实现上述的更新。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> chaincode_example02被安装在了peer0.org1.example.com&nbsp;与&nbsp;peer0.org2.example.com</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 接着chaincode在peer0.org2.example.com被实例化。实例化把chaincode加到channel上，并启动目标peer的容器，接着初始化chaincode有关的键-值对（&nbsp;[“a”,”100” “b”,”200”]）。实例化的过程导致了dev-peer0.org2.example.com-zeychaincode-1.0的启动。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 实例化需要有endorsement策略的参数，这里设置为-P&nbsp;"OR&nbsp;&nbsp;&nbsp;&nbsp;(‘Org1MSP.member‘,‘Org2MSP.member‘)"，表示任意transaction必须被Org1 或者 Org2的一个peer进行endorsed。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 接下来把对“a”的查询发送给peer0.org1.example.com，即在peer0.org1.example.com查询a的值。chaincode之前已经安装在了peer0.org1.example.com上，因此这个查询将会针对Org1 peer0 启动一个容器（dev-peer0.org1.example.com-zeychaincode-1.0），然后查询结果得到返回，没有任何写的操作发生，因此返回值是100</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 接着调用请求发送给peer0.org1.example.com，把10个从a转移到b。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 然后chaincode在peer1.org2.example.com进行安装。</li>
    <li style="text-align:left;line-height:1.75;font-size:14px;list-style-position:inside;list-style-type:decimal;font-family:'Microsoft YaHei', STXihei;color:rgb(63,63,63);"> 然后一个查询a的余额的请求发送到peer1.org2.example.com。这个启动了第三个chaincode容器（dev-peer1.org2.example.com-mycc-1.0），90被返回。正确的反应了上述transaction，a的值被改为了10。</li>
   </ol>
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(223,64,42);">Error: Got unexpected status: BAD_REQUEST</span>
   </div> 
   <div style="line-height:1.75;font-size:14px;">
    <span style="color:rgb(223,64,42);">原因是存在同名的channel</span>
   </div> 
   <br>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011011025/article/details/78292278,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011011025/article/details/78292278,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
