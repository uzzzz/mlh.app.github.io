<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>数字货币核心内容详细详解底层技术开发教程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="数字货币核心内容详细详解底层技术开发教程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链爱好者（QQ：53016353） 1.1 数字货币介绍 数字货币是数字事件(交易)的账簿，这个账簿由多个参与者共享，每个参与者都在系统中拥有权益。账簿只有在所有参与者达成共识的情况下才能够更新，并且信息一旦记录就永远不能修改。每个记录的事件都可以基于参与者的共识证明使用密码学进行验证。 交易是安全、私有和保密的。每个参与者使用身份证明向网络成员服务（membership service）注册以获取系统的访问权限。参与者使用不可追踪的导出证书生成交易，可以在网络中完全匿名。交易的内容使用由密钥导出的复杂函数进行加密，确保只有指定的参与者才能够看到内容，以保护商业交易的机密性。 账簿的全部或者部分可以审计以满足监管要求。在参与者合作的情况下，审计人员可以获取有限时间的证书来查看账簿和交易详情，从而对运营情况进行准确的评估。 数字货币是区块链技术的实现，比特币可以作为一种简单的应用在数字货币基础上构建。数字货币采用了模块化的构架，允许不同的组件在实现协议的基础上即插即用。可以使用强大的容器技术来运行主流编程语言以进行智能合约的开发。使用熟悉的和已验证的技术是数字货币构架的宗旨。 1.2 使用Fabic的原因 早期的区块链技术能够实现一些功能，但是缺乏对特定行业需求的完整支持。为了满足现代市场的要求，数字货币面向行业需求进行设计以适应多种行业特定的应用场景，并且在诸如伸缩性设计等方面比这个领域的先驱更进一步。数字货币使用了新的方法实现了授权网络、在多个区块链网络上的私有性和保密性。 2.1 数字货币构架 数字货币的构架由成员服务（Membership）、区块链服务（Blockchain）和链码服务（Chaincode）三个主要类别构成。这些类别仅仅是数字货币的逻辑结构，并不是在物理上将组件划分成不同的进程、地址空间或者虚拟机。&nbsp; 2.1.1 成员服务 成员服务负责管理用户标识、隐私、以及网络的保密性和可审计性。在无权限的区块链中，参与者不需要授权，并且所有节点可以平等地提交交易或者将交易累积成区块，也就是说没有角色的区别。成员服务将公钥基础设施（PKI）和去中心化共识机制的基本元素进行整合，从而将无权限区块链转化为有权限区块链。在有权限区块链中，参与者需要注册以获取长期身份凭据（登记证书），并且可以根据身份类型进行区分。在用户的情况下，交易证书管理者（TCA）可以发行假名凭据。这种凭据（即交易证书）被用来进行授权提交的交易。交易证书在区块链上保存，并且允许授权的审计者对交易进行归类，否则这些交易将无法关联。 2.1.2 区块链服务 区块链服务通过使用基于HTTP2的P2P协议管理分布式账簿。区块链上的数据结构经过了高度优化以提供最有效的Hash算法来保存世界状态（world state)的副本。在部署中可以使用和配置不同的共识算法，包括PBFT, Raft, PoW, PoS等。 2.1.3 链码服务 链码服务为链码（chaincode）在验证节点上执行提供了一个安全和轻量级的沙盒。沙盒环境是一个锁定和安全容器，带有一组经过签名的基础磁盘映像，包含了安全操作系统和支持Go、Java和Node.js的链码语言、运行时和SDK，其他语言可以根据需要被启用。 2.1.4 事件 验证节点和链码可以在区块链网络上发送事件，应用程序可以监听这些事件并作出响应。已经存在一组预先定义好的事件，并且链码也可以生成自定义的事件。事件可以被一个或者多个事件适配器处理，适配器可以使用Web Hook或者Kafka进一步将事件进行传递。 2.1.5 应用程序接口（API） 数字货币的主要编程接口是REST API，以及基于Swagger2.0的变体。这些API可以让应用程序注册用户、查询区块链、以及发送交易。有一组API专门设计给链码用来与底层平台交互以执行交易和查询交易结果。 2.1.6 命令行接口（CLI） CLI包括REST API的一组子集来帮助开发者快速测试链码和查询交易状态。CLI由Go语言实现，并且支持多种操作系统。 2.2 拓扑结构 数字货币的部署可以包括成员服务、多个验证节点（peer）和非验证节点、以及一个或者多个应用。所有这些组件构成了一个区块链。可以存在多个区块链，每个区块链都可以有自己的运行参数和安全需求。 2.2.1 单个验证节点 从功能上将，非验证节点是验证节点的子集，也就是说每个非验证节点上的功能也可以在验证节点上实现，因此最简单的区块链网络可以仅有一个验证节点构成。这种配置最适合作为开发环境，单个验证节点可以在“编辑-编译-调试”周期中快速启动。 单个验证节点不需要共识机制，因此默认的共识机制插件为noops，在这种情况下交易是立即执行的，这样开发者可以在开发过程中的到立即反馈。 2.2.2 多个验证节点 用于生产环境或者测试环境的区块链网络一般由多个验证节点和非验证节点构成。非验证节点可以承担一部分从验证节点剥离的工作量，比如处理API请求和处理事件。&nbsp; 所有验证节点构成了一个全连接的网络，即每个验证节点都与其他的验证节点连接。非验证节点连接到邻近的允许连接的验证节点。非验证节点是可选的，因为应用程序可以直接与验证节点进行通讯。 2.2.3 多链 每个由验证节点和非验证节点组成的网络构成了一个区块链。多个区块链可以被创建用来满足不同的需求，好比多个Web网站可以满足不同的目的。 数字货币的点对点通讯是基于gRPC构建的，实现了基于流的双向消息通讯。gRPC使用了谷歌公司的Protocol Buffers对数据结构进行串行化来实现节点之间的数据传输。Protocol buffers是一种语言中立、平台中立、并且可扩展的数据结构串行化技术。数据结构、消息和服务都是用proto3语言描述。 3.1 消息 节点之间传输的消息是由Message这个proto结构封装的，有四种不同的类型：发现（Discovery）、交易（Transaction）、同步（Synchronization）和共识（Consensus）。每种类型都可以在其内嵌的payload字段中定义更多的子类型。 message Message { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; DISC_HELLO = 1; &nbsp; &nbsp; &nbsp; &nbsp; DISC_DISCONNECT = 2; &nbsp; &nbsp; &nbsp; &nbsp; DISC_GET_PEERS = 3; &nbsp; &nbsp; &nbsp; &nbsp; DISC_PEERS = 4; &nbsp; &nbsp; &nbsp; &nbsp; DISC_NEWMSG = 5; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_STATUS = 6; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_TRANSACTION = 7; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_GET_TRANSACTIONS = 8; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_QUERY = 9; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_GET_BLOCKS = 11; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCKS = 12; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCK_ADDED = 13; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_SNAPSHOT = 14; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_SNAPSHOT = 15; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_DELTAS = 16; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_DELTAS = 17; &nbsp; &nbsp; &nbsp; &nbsp; RESPONSE = 20; &nbsp; &nbsp; &nbsp; &nbsp; CONSENSUS = 21; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; bytes payload = 2; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 3; } payload字段是一个包含其他对象（Transaction或者Response）的不透明字节数组，例如，当type是CHAIN_TRANSACTION时，payload是Transaction对象。 3.1.1 发现消息 在节点启动之后，如果CORE_PEER_DISCOVERY_ROOTNODE字段存在则运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是另外一个网路上节点（任意节点）的IP地址，这个节点可以作为发现网络上其他所有节点的起点。协议序列从DISC_HELLO开始，其payload为HelloMessage对象： message HelloMessage { &nbsp; &nbsp; PeerEndpoint peerEndpoint = 1; &nbsp; &nbsp; uint64 blockNumber = 2; } message PeerEndpoint { &nbsp; &nbsp; PeerID ID = 1; &nbsp; &nbsp; string address = 2; &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; VALIDATOR = 1; &nbsp; &nbsp; &nbsp; &nbsp; NON_VALIDATOR = 2; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 3; &nbsp; &nbsp; bytes pkiID = 4; } message PeerID { &nbsp; &nbsp; string name = 1; } PeerId是节点启动的时候被赋予的名字，也可以在配置文件中定义。 PeerEndpoint用来描述验证节点或者非验证节点 pkiID是节点的密码学ID address是节点的IP地址和端口(ip:port) blockNumber是节点上区块链的当前高度 如果通过DISC_HELLO获取的区块高度超过了当前节点的区块链高度，则节点立即启动同步协议将节点状态更新到网络当前最新状态。 DISC_HELLO之后，节点周期性地发送DISC_GET_PEERS以发现新加入到网络的其他节点。作为对DISC_GET_PEERS消息的响应，收到消息的节点发送&#39;DISC_PEERS&#39;消息，该消息中的payload字段包含了一组PeerEndpoint。其他发现消息目前未使用。 3.1.2 交易消息 存在3种交易类型：部署（Deploy）、调用（Invoke）和查询（Query）。部署交易将指定的链码安装到区块链网络，而调用和查询交易则是调用已经部署到区块链上的链码函数。还有一种创建型（Create）交易用于将已经部署到区块链上的链码实例化并载入内存，但目前该交易类型未实现。 3.1.2.1 交易数据结构 message Transaction { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_DEPLOY = 1; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_INVOKE = 2; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_QUERY = 3; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_TERMINATE = 4; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; string uuid = 5; &nbsp; &nbsp; bytes chaincodeID = 2; &nbsp; &nbsp; bytes payloadHash = 3; &nbsp; &nbsp; ConfidentialityLevel confidentialityLevel = 7; &nbsp; &nbsp; bytes nonce = 8; &nbsp; &nbsp; bytes cert = 9; &nbsp; &nbsp; bytes signature = 10; &nbsp; &nbsp; bytes metadata = 4; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { &nbsp; &nbsp; bytes payload = 1; } enum ConfidentialityLevel { &nbsp; &nbsp; PUBLIC = 0; &nbsp; &nbsp; CONFIDENTIAL = 1; } 3.1.3 同步消息 当节点通过发现协议发现自己比区块链网络落后或者不一致，则马上开启同步协议。节点广播SYNC_GET_BLOCKS、SYNC_STATE_GET_SNAPSHOT或者SYNC_STATE_GET_DELTAS，相应地接收SYNC_BLOCKS、SYNC_STATE_SNAPSHOT或者SYNC_STATE_DELTAS。 已安装的共识机制插件决定同步协议如何执行，每种消息针对不同的情况： SYNC_GET_BLOCKS在消息的payload字段中请求一组连续范围的区块，这种范围使用SyncBlockRange表示： message SyncBlockRange { &nbsp; &nbsp; uint64 start = 1; &nbsp; &nbsp; uint64 end = 2; } 接收到SYNC_GET_BLOCKS的节点响应SYNC_BLOCKS消息，在其payload字段中包含了SyncBlocks: message SyncBlocks { &nbsp; &nbsp; SyncBlockRange range = 1; &nbsp; &nbsp; repeated Block blocks = 2; } 3.1.4 共识消息 共识机制用于处理交易，因此CONSENSUS消息由内部的共识框架在接收到CHAIN_TRANSACTION消息后发送。共识框架将CHAIN_TRANSACTION转化为CONSENSUS，然后向所有验证节点进行广播。共识插件接收到消息后，根据自身算法对消息进行处理。 3.2 账簿 账簿（ledger）由区块链（blockchain）和世界状态（world state）这两个部分组成。区块链是一组链接起来的区块，用来在账簿中记录交易。世界状态是键值数据库，在链码执行过程中用来存储状态。 3.2.1 区块链 3.2.1.1 区块 区块链被定义为一组连接在一起的区块，因为每个区块都包含链中前一个区块的Hash。区块中另外2个重要信息是交易列表，以及区块中所有交易执行完成后的世界状态的Hash值。 message Block { &nbsp; version = 1; &nbsp; google.protobuf.Timestamp timestamp = 2; &nbsp; bytes transactionsHash = 3; &nbsp; bytes stateHash = 4; &nbsp; bytes previousBlockHash = 5; &nbsp; bytes consensusMetadata = 6; &nbsp; NonHashData nonHashData = 7; } message BlockTransactions { &nbsp; repeated Transaction transactions = 1; } transactionsHash是区块内交易列表merkle根的hash值 stateHash是世界状态merkle根的hash值 previousBlockHash是前一个区块的hash值 BlockTransactions.transactions是交易消息的数组，交易列表由于大小的关系并不直接包含在区块内部。 3.2.2 世界状态 节点中的世界状态是所有已部署的链码的状态集合，实际上是键值对{chaincodeID, ckey}的集合。 阅读更多" />
<meta property="og:description" content="区块链爱好者（QQ：53016353） 1.1 数字货币介绍 数字货币是数字事件(交易)的账簿，这个账簿由多个参与者共享，每个参与者都在系统中拥有权益。账簿只有在所有参与者达成共识的情况下才能够更新，并且信息一旦记录就永远不能修改。每个记录的事件都可以基于参与者的共识证明使用密码学进行验证。 交易是安全、私有和保密的。每个参与者使用身份证明向网络成员服务（membership service）注册以获取系统的访问权限。参与者使用不可追踪的导出证书生成交易，可以在网络中完全匿名。交易的内容使用由密钥导出的复杂函数进行加密，确保只有指定的参与者才能够看到内容，以保护商业交易的机密性。 账簿的全部或者部分可以审计以满足监管要求。在参与者合作的情况下，审计人员可以获取有限时间的证书来查看账簿和交易详情，从而对运营情况进行准确的评估。 数字货币是区块链技术的实现，比特币可以作为一种简单的应用在数字货币基础上构建。数字货币采用了模块化的构架，允许不同的组件在实现协议的基础上即插即用。可以使用强大的容器技术来运行主流编程语言以进行智能合约的开发。使用熟悉的和已验证的技术是数字货币构架的宗旨。 1.2 使用Fabic的原因 早期的区块链技术能够实现一些功能，但是缺乏对特定行业需求的完整支持。为了满足现代市场的要求，数字货币面向行业需求进行设计以适应多种行业特定的应用场景，并且在诸如伸缩性设计等方面比这个领域的先驱更进一步。数字货币使用了新的方法实现了授权网络、在多个区块链网络上的私有性和保密性。 2.1 数字货币构架 数字货币的构架由成员服务（Membership）、区块链服务（Blockchain）和链码服务（Chaincode）三个主要类别构成。这些类别仅仅是数字货币的逻辑结构，并不是在物理上将组件划分成不同的进程、地址空间或者虚拟机。&nbsp; 2.1.1 成员服务 成员服务负责管理用户标识、隐私、以及网络的保密性和可审计性。在无权限的区块链中，参与者不需要授权，并且所有节点可以平等地提交交易或者将交易累积成区块，也就是说没有角色的区别。成员服务将公钥基础设施（PKI）和去中心化共识机制的基本元素进行整合，从而将无权限区块链转化为有权限区块链。在有权限区块链中，参与者需要注册以获取长期身份凭据（登记证书），并且可以根据身份类型进行区分。在用户的情况下，交易证书管理者（TCA）可以发行假名凭据。这种凭据（即交易证书）被用来进行授权提交的交易。交易证书在区块链上保存，并且允许授权的审计者对交易进行归类，否则这些交易将无法关联。 2.1.2 区块链服务 区块链服务通过使用基于HTTP2的P2P协议管理分布式账簿。区块链上的数据结构经过了高度优化以提供最有效的Hash算法来保存世界状态（world state)的副本。在部署中可以使用和配置不同的共识算法，包括PBFT, Raft, PoW, PoS等。 2.1.3 链码服务 链码服务为链码（chaincode）在验证节点上执行提供了一个安全和轻量级的沙盒。沙盒环境是一个锁定和安全容器，带有一组经过签名的基础磁盘映像，包含了安全操作系统和支持Go、Java和Node.js的链码语言、运行时和SDK，其他语言可以根据需要被启用。 2.1.4 事件 验证节点和链码可以在区块链网络上发送事件，应用程序可以监听这些事件并作出响应。已经存在一组预先定义好的事件，并且链码也可以生成自定义的事件。事件可以被一个或者多个事件适配器处理，适配器可以使用Web Hook或者Kafka进一步将事件进行传递。 2.1.5 应用程序接口（API） 数字货币的主要编程接口是REST API，以及基于Swagger2.0的变体。这些API可以让应用程序注册用户、查询区块链、以及发送交易。有一组API专门设计给链码用来与底层平台交互以执行交易和查询交易结果。 2.1.6 命令行接口（CLI） CLI包括REST API的一组子集来帮助开发者快速测试链码和查询交易状态。CLI由Go语言实现，并且支持多种操作系统。 2.2 拓扑结构 数字货币的部署可以包括成员服务、多个验证节点（peer）和非验证节点、以及一个或者多个应用。所有这些组件构成了一个区块链。可以存在多个区块链，每个区块链都可以有自己的运行参数和安全需求。 2.2.1 单个验证节点 从功能上将，非验证节点是验证节点的子集，也就是说每个非验证节点上的功能也可以在验证节点上实现，因此最简单的区块链网络可以仅有一个验证节点构成。这种配置最适合作为开发环境，单个验证节点可以在“编辑-编译-调试”周期中快速启动。 单个验证节点不需要共识机制，因此默认的共识机制插件为noops，在这种情况下交易是立即执行的，这样开发者可以在开发过程中的到立即反馈。 2.2.2 多个验证节点 用于生产环境或者测试环境的区块链网络一般由多个验证节点和非验证节点构成。非验证节点可以承担一部分从验证节点剥离的工作量，比如处理API请求和处理事件。&nbsp; 所有验证节点构成了一个全连接的网络，即每个验证节点都与其他的验证节点连接。非验证节点连接到邻近的允许连接的验证节点。非验证节点是可选的，因为应用程序可以直接与验证节点进行通讯。 2.2.3 多链 每个由验证节点和非验证节点组成的网络构成了一个区块链。多个区块链可以被创建用来满足不同的需求，好比多个Web网站可以满足不同的目的。 数字货币的点对点通讯是基于gRPC构建的，实现了基于流的双向消息通讯。gRPC使用了谷歌公司的Protocol Buffers对数据结构进行串行化来实现节点之间的数据传输。Protocol buffers是一种语言中立、平台中立、并且可扩展的数据结构串行化技术。数据结构、消息和服务都是用proto3语言描述。 3.1 消息 节点之间传输的消息是由Message这个proto结构封装的，有四种不同的类型：发现（Discovery）、交易（Transaction）、同步（Synchronization）和共识（Consensus）。每种类型都可以在其内嵌的payload字段中定义更多的子类型。 message Message { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; DISC_HELLO = 1; &nbsp; &nbsp; &nbsp; &nbsp; DISC_DISCONNECT = 2; &nbsp; &nbsp; &nbsp; &nbsp; DISC_GET_PEERS = 3; &nbsp; &nbsp; &nbsp; &nbsp; DISC_PEERS = 4; &nbsp; &nbsp; &nbsp; &nbsp; DISC_NEWMSG = 5; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_STATUS = 6; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_TRANSACTION = 7; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_GET_TRANSACTIONS = 8; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_QUERY = 9; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_GET_BLOCKS = 11; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCKS = 12; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCK_ADDED = 13; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_SNAPSHOT = 14; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_SNAPSHOT = 15; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_DELTAS = 16; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_DELTAS = 17; &nbsp; &nbsp; &nbsp; &nbsp; RESPONSE = 20; &nbsp; &nbsp; &nbsp; &nbsp; CONSENSUS = 21; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; bytes payload = 2; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 3; } payload字段是一个包含其他对象（Transaction或者Response）的不透明字节数组，例如，当type是CHAIN_TRANSACTION时，payload是Transaction对象。 3.1.1 发现消息 在节点启动之后，如果CORE_PEER_DISCOVERY_ROOTNODE字段存在则运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是另外一个网路上节点（任意节点）的IP地址，这个节点可以作为发现网络上其他所有节点的起点。协议序列从DISC_HELLO开始，其payload为HelloMessage对象： message HelloMessage { &nbsp; &nbsp; PeerEndpoint peerEndpoint = 1; &nbsp; &nbsp; uint64 blockNumber = 2; } message PeerEndpoint { &nbsp; &nbsp; PeerID ID = 1; &nbsp; &nbsp; string address = 2; &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; VALIDATOR = 1; &nbsp; &nbsp; &nbsp; &nbsp; NON_VALIDATOR = 2; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 3; &nbsp; &nbsp; bytes pkiID = 4; } message PeerID { &nbsp; &nbsp; string name = 1; } PeerId是节点启动的时候被赋予的名字，也可以在配置文件中定义。 PeerEndpoint用来描述验证节点或者非验证节点 pkiID是节点的密码学ID address是节点的IP地址和端口(ip:port) blockNumber是节点上区块链的当前高度 如果通过DISC_HELLO获取的区块高度超过了当前节点的区块链高度，则节点立即启动同步协议将节点状态更新到网络当前最新状态。 DISC_HELLO之后，节点周期性地发送DISC_GET_PEERS以发现新加入到网络的其他节点。作为对DISC_GET_PEERS消息的响应，收到消息的节点发送&#39;DISC_PEERS&#39;消息，该消息中的payload字段包含了一组PeerEndpoint。其他发现消息目前未使用。 3.1.2 交易消息 存在3种交易类型：部署（Deploy）、调用（Invoke）和查询（Query）。部署交易将指定的链码安装到区块链网络，而调用和查询交易则是调用已经部署到区块链上的链码函数。还有一种创建型（Create）交易用于将已经部署到区块链上的链码实例化并载入内存，但目前该交易类型未实现。 3.1.2.1 交易数据结构 message Transaction { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_DEPLOY = 1; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_INVOKE = 2; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_QUERY = 3; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_TERMINATE = 4; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; string uuid = 5; &nbsp; &nbsp; bytes chaincodeID = 2; &nbsp; &nbsp; bytes payloadHash = 3; &nbsp; &nbsp; ConfidentialityLevel confidentialityLevel = 7; &nbsp; &nbsp; bytes nonce = 8; &nbsp; &nbsp; bytes cert = 9; &nbsp; &nbsp; bytes signature = 10; &nbsp; &nbsp; bytes metadata = 4; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { &nbsp; &nbsp; bytes payload = 1; } enum ConfidentialityLevel { &nbsp; &nbsp; PUBLIC = 0; &nbsp; &nbsp; CONFIDENTIAL = 1; } 3.1.3 同步消息 当节点通过发现协议发现自己比区块链网络落后或者不一致，则马上开启同步协议。节点广播SYNC_GET_BLOCKS、SYNC_STATE_GET_SNAPSHOT或者SYNC_STATE_GET_DELTAS，相应地接收SYNC_BLOCKS、SYNC_STATE_SNAPSHOT或者SYNC_STATE_DELTAS。 已安装的共识机制插件决定同步协议如何执行，每种消息针对不同的情况： SYNC_GET_BLOCKS在消息的payload字段中请求一组连续范围的区块，这种范围使用SyncBlockRange表示： message SyncBlockRange { &nbsp; &nbsp; uint64 start = 1; &nbsp; &nbsp; uint64 end = 2; } 接收到SYNC_GET_BLOCKS的节点响应SYNC_BLOCKS消息，在其payload字段中包含了SyncBlocks: message SyncBlocks { &nbsp; &nbsp; SyncBlockRange range = 1; &nbsp; &nbsp; repeated Block blocks = 2; } 3.1.4 共识消息 共识机制用于处理交易，因此CONSENSUS消息由内部的共识框架在接收到CHAIN_TRANSACTION消息后发送。共识框架将CHAIN_TRANSACTION转化为CONSENSUS，然后向所有验证节点进行广播。共识插件接收到消息后，根据自身算法对消息进行处理。 3.2 账簿 账簿（ledger）由区块链（blockchain）和世界状态（world state）这两个部分组成。区块链是一组链接起来的区块，用来在账簿中记录交易。世界状态是键值数据库，在链码执行过程中用来存储状态。 3.2.1 区块链 3.2.1.1 区块 区块链被定义为一组连接在一起的区块，因为每个区块都包含链中前一个区块的Hash。区块中另外2个重要信息是交易列表，以及区块中所有交易执行完成后的世界状态的Hash值。 message Block { &nbsp; version = 1; &nbsp; google.protobuf.Timestamp timestamp = 2; &nbsp; bytes transactionsHash = 3; &nbsp; bytes stateHash = 4; &nbsp; bytes previousBlockHash = 5; &nbsp; bytes consensusMetadata = 6; &nbsp; NonHashData nonHashData = 7; } message BlockTransactions { &nbsp; repeated Transaction transactions = 1; } transactionsHash是区块内交易列表merkle根的hash值 stateHash是世界状态merkle根的hash值 previousBlockHash是前一个区块的hash值 BlockTransactions.transactions是交易消息的数组，交易列表由于大小的关系并不直接包含在区块内部。 3.2.2 世界状态 节点中的世界状态是所有已部署的链码的状态集合，实际上是键值对{chaincodeID, ckey}的集合。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链爱好者（QQ：53016353） 1.1 数字货币介绍 数字货币是数字事件(交易)的账簿，这个账簿由多个参与者共享，每个参与者都在系统中拥有权益。账簿只有在所有参与者达成共识的情况下才能够更新，并且信息一旦记录就永远不能修改。每个记录的事件都可以基于参与者的共识证明使用密码学进行验证。 交易是安全、私有和保密的。每个参与者使用身份证明向网络成员服务（membership service）注册以获取系统的访问权限。参与者使用不可追踪的导出证书生成交易，可以在网络中完全匿名。交易的内容使用由密钥导出的复杂函数进行加密，确保只有指定的参与者才能够看到内容，以保护商业交易的机密性。 账簿的全部或者部分可以审计以满足监管要求。在参与者合作的情况下，审计人员可以获取有限时间的证书来查看账簿和交易详情，从而对运营情况进行准确的评估。 数字货币是区块链技术的实现，比特币可以作为一种简单的应用在数字货币基础上构建。数字货币采用了模块化的构架，允许不同的组件在实现协议的基础上即插即用。可以使用强大的容器技术来运行主流编程语言以进行智能合约的开发。使用熟悉的和已验证的技术是数字货币构架的宗旨。 1.2 使用Fabic的原因 早期的区块链技术能够实现一些功能，但是缺乏对特定行业需求的完整支持。为了满足现代市场的要求，数字货币面向行业需求进行设计以适应多种行业特定的应用场景，并且在诸如伸缩性设计等方面比这个领域的先驱更进一步。数字货币使用了新的方法实现了授权网络、在多个区块链网络上的私有性和保密性。 2.1 数字货币构架 数字货币的构架由成员服务（Membership）、区块链服务（Blockchain）和链码服务（Chaincode）三个主要类别构成。这些类别仅仅是数字货币的逻辑结构，并不是在物理上将组件划分成不同的进程、地址空间或者虚拟机。&nbsp; 2.1.1 成员服务 成员服务负责管理用户标识、隐私、以及网络的保密性和可审计性。在无权限的区块链中，参与者不需要授权，并且所有节点可以平等地提交交易或者将交易累积成区块，也就是说没有角色的区别。成员服务将公钥基础设施（PKI）和去中心化共识机制的基本元素进行整合，从而将无权限区块链转化为有权限区块链。在有权限区块链中，参与者需要注册以获取长期身份凭据（登记证书），并且可以根据身份类型进行区分。在用户的情况下，交易证书管理者（TCA）可以发行假名凭据。这种凭据（即交易证书）被用来进行授权提交的交易。交易证书在区块链上保存，并且允许授权的审计者对交易进行归类，否则这些交易将无法关联。 2.1.2 区块链服务 区块链服务通过使用基于HTTP2的P2P协议管理分布式账簿。区块链上的数据结构经过了高度优化以提供最有效的Hash算法来保存世界状态（world state)的副本。在部署中可以使用和配置不同的共识算法，包括PBFT, Raft, PoW, PoS等。 2.1.3 链码服务 链码服务为链码（chaincode）在验证节点上执行提供了一个安全和轻量级的沙盒。沙盒环境是一个锁定和安全容器，带有一组经过签名的基础磁盘映像，包含了安全操作系统和支持Go、Java和Node.js的链码语言、运行时和SDK，其他语言可以根据需要被启用。 2.1.4 事件 验证节点和链码可以在区块链网络上发送事件，应用程序可以监听这些事件并作出响应。已经存在一组预先定义好的事件，并且链码也可以生成自定义的事件。事件可以被一个或者多个事件适配器处理，适配器可以使用Web Hook或者Kafka进一步将事件进行传递。 2.1.5 应用程序接口（API） 数字货币的主要编程接口是REST API，以及基于Swagger2.0的变体。这些API可以让应用程序注册用户、查询区块链、以及发送交易。有一组API专门设计给链码用来与底层平台交互以执行交易和查询交易结果。 2.1.6 命令行接口（CLI） CLI包括REST API的一组子集来帮助开发者快速测试链码和查询交易状态。CLI由Go语言实现，并且支持多种操作系统。 2.2 拓扑结构 数字货币的部署可以包括成员服务、多个验证节点（peer）和非验证节点、以及一个或者多个应用。所有这些组件构成了一个区块链。可以存在多个区块链，每个区块链都可以有自己的运行参数和安全需求。 2.2.1 单个验证节点 从功能上将，非验证节点是验证节点的子集，也就是说每个非验证节点上的功能也可以在验证节点上实现，因此最简单的区块链网络可以仅有一个验证节点构成。这种配置最适合作为开发环境，单个验证节点可以在“编辑-编译-调试”周期中快速启动。 单个验证节点不需要共识机制，因此默认的共识机制插件为noops，在这种情况下交易是立即执行的，这样开发者可以在开发过程中的到立即反馈。 2.2.2 多个验证节点 用于生产环境或者测试环境的区块链网络一般由多个验证节点和非验证节点构成。非验证节点可以承担一部分从验证节点剥离的工作量，比如处理API请求和处理事件。&nbsp; 所有验证节点构成了一个全连接的网络，即每个验证节点都与其他的验证节点连接。非验证节点连接到邻近的允许连接的验证节点。非验证节点是可选的，因为应用程序可以直接与验证节点进行通讯。 2.2.3 多链 每个由验证节点和非验证节点组成的网络构成了一个区块链。多个区块链可以被创建用来满足不同的需求，好比多个Web网站可以满足不同的目的。 数字货币的点对点通讯是基于gRPC构建的，实现了基于流的双向消息通讯。gRPC使用了谷歌公司的Protocol Buffers对数据结构进行串行化来实现节点之间的数据传输。Protocol buffers是一种语言中立、平台中立、并且可扩展的数据结构串行化技术。数据结构、消息和服务都是用proto3语言描述。 3.1 消息 节点之间传输的消息是由Message这个proto结构封装的，有四种不同的类型：发现（Discovery）、交易（Transaction）、同步（Synchronization）和共识（Consensus）。每种类型都可以在其内嵌的payload字段中定义更多的子类型。 message Message { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; DISC_HELLO = 1; &nbsp; &nbsp; &nbsp; &nbsp; DISC_DISCONNECT = 2; &nbsp; &nbsp; &nbsp; &nbsp; DISC_GET_PEERS = 3; &nbsp; &nbsp; &nbsp; &nbsp; DISC_PEERS = 4; &nbsp; &nbsp; &nbsp; &nbsp; DISC_NEWMSG = 5; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_STATUS = 6; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_TRANSACTION = 7; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_GET_TRANSACTIONS = 8; &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_QUERY = 9; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_GET_BLOCKS = 11; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCKS = 12; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCK_ADDED = 13; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_SNAPSHOT = 14; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_SNAPSHOT = 15; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_DELTAS = 16; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_DELTAS = 17; &nbsp; &nbsp; &nbsp; &nbsp; RESPONSE = 20; &nbsp; &nbsp; &nbsp; &nbsp; CONSENSUS = 21; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; bytes payload = 2; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 3; } payload字段是一个包含其他对象（Transaction或者Response）的不透明字节数组，例如，当type是CHAIN_TRANSACTION时，payload是Transaction对象。 3.1.1 发现消息 在节点启动之后，如果CORE_PEER_DISCOVERY_ROOTNODE字段存在则运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是另外一个网路上节点（任意节点）的IP地址，这个节点可以作为发现网络上其他所有节点的起点。协议序列从DISC_HELLO开始，其payload为HelloMessage对象： message HelloMessage { &nbsp; &nbsp; PeerEndpoint peerEndpoint = 1; &nbsp; &nbsp; uint64 blockNumber = 2; } message PeerEndpoint { &nbsp; &nbsp; PeerID ID = 1; &nbsp; &nbsp; string address = 2; &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; VALIDATOR = 1; &nbsp; &nbsp; &nbsp; &nbsp; NON_VALIDATOR = 2; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 3; &nbsp; &nbsp; bytes pkiID = 4; } message PeerID { &nbsp; &nbsp; string name = 1; } PeerId是节点启动的时候被赋予的名字，也可以在配置文件中定义。 PeerEndpoint用来描述验证节点或者非验证节点 pkiID是节点的密码学ID address是节点的IP地址和端口(ip:port) blockNumber是节点上区块链的当前高度 如果通过DISC_HELLO获取的区块高度超过了当前节点的区块链高度，则节点立即启动同步协议将节点状态更新到网络当前最新状态。 DISC_HELLO之后，节点周期性地发送DISC_GET_PEERS以发现新加入到网络的其他节点。作为对DISC_GET_PEERS消息的响应，收到消息的节点发送&#39;DISC_PEERS&#39;消息，该消息中的payload字段包含了一组PeerEndpoint。其他发现消息目前未使用。 3.1.2 交易消息 存在3种交易类型：部署（Deploy）、调用（Invoke）和查询（Query）。部署交易将指定的链码安装到区块链网络，而调用和查询交易则是调用已经部署到区块链上的链码函数。还有一种创建型（Create）交易用于将已经部署到区块链上的链码实例化并载入内存，但目前该交易类型未实现。 3.1.2.1 交易数据结构 message Transaction { &nbsp; &nbsp; enum Type { &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_DEPLOY = 1; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_INVOKE = 2; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_QUERY = 3; &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_TERMINATE = 4; &nbsp; &nbsp; } &nbsp; &nbsp; Type type = 1; &nbsp; &nbsp; string uuid = 5; &nbsp; &nbsp; bytes chaincodeID = 2; &nbsp; &nbsp; bytes payloadHash = 3; &nbsp; &nbsp; ConfidentialityLevel confidentialityLevel = 7; &nbsp; &nbsp; bytes nonce = 8; &nbsp; &nbsp; bytes cert = 9; &nbsp; &nbsp; bytes signature = 10; &nbsp; &nbsp; bytes metadata = 4; &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { &nbsp; &nbsp; bytes payload = 1; } enum ConfidentialityLevel { &nbsp; &nbsp; PUBLIC = 0; &nbsp; &nbsp; CONFIDENTIAL = 1; } 3.1.3 同步消息 当节点通过发现协议发现自己比区块链网络落后或者不一致，则马上开启同步协议。节点广播SYNC_GET_BLOCKS、SYNC_STATE_GET_SNAPSHOT或者SYNC_STATE_GET_DELTAS，相应地接收SYNC_BLOCKS、SYNC_STATE_SNAPSHOT或者SYNC_STATE_DELTAS。 已安装的共识机制插件决定同步协议如何执行，每种消息针对不同的情况： SYNC_GET_BLOCKS在消息的payload字段中请求一组连续范围的区块，这种范围使用SyncBlockRange表示： message SyncBlockRange { &nbsp; &nbsp; uint64 start = 1; &nbsp; &nbsp; uint64 end = 2; } 接收到SYNC_GET_BLOCKS的节点响应SYNC_BLOCKS消息，在其payload字段中包含了SyncBlocks: message SyncBlocks { &nbsp; &nbsp; SyncBlockRange range = 1; &nbsp; &nbsp; repeated Block blocks = 2; } 3.1.4 共识消息 共识机制用于处理交易，因此CONSENSUS消息由内部的共识框架在接收到CHAIN_TRANSACTION消息后发送。共识框架将CHAIN_TRANSACTION转化为CONSENSUS，然后向所有验证节点进行广播。共识插件接收到消息后，根据自身算法对消息进行处理。 3.2 账簿 账簿（ledger）由区块链（blockchain）和世界状态（world state）这两个部分组成。区块链是一组链接起来的区块，用来在账簿中记录交易。世界状态是键值数据库，在链码执行过程中用来存储状态。 3.2.1 区块链 3.2.1.1 区块 区块链被定义为一组连接在一起的区块，因为每个区块都包含链中前一个区块的Hash。区块中另外2个重要信息是交易列表，以及区块中所有交易执行完成后的世界状态的Hash值。 message Block { &nbsp; version = 1; &nbsp; google.protobuf.Timestamp timestamp = 2; &nbsp; bytes transactionsHash = 3; &nbsp; bytes stateHash = 4; &nbsp; bytes previousBlockHash = 5; &nbsp; bytes consensusMetadata = 6; &nbsp; NonHashData nonHashData = 7; } message BlockTransactions { &nbsp; repeated Transaction transactions = 1; } transactionsHash是区块内交易列表merkle根的hash值 stateHash是世界状态merkle根的hash值 previousBlockHash是前一个区块的hash值 BlockTransactions.transactions是交易消息的数组，交易列表由于大小的关系并不直接包含在区块内部。 3.2.2 世界状态 节点中的世界状态是所有已部署的链码的状态集合，实际上是键值对{chaincodeID, ckey}的集合。 阅读更多","@type":"BlogPosting","url":"/2017/10/29/0c1cd1bf2bdeb3f02e1a24381b55d08d.html","headline":"数字货币核心内容详细详解底层技术开发教程","dateModified":"2017-10-29T00:00:00+08:00","datePublished":"2017-10-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/10/29/0c1cd1bf2bdeb3f02e1a24381b55d08d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>数字货币核心内容详细详解底层技术开发教程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="text-align:center;"><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">区块链爱好者（QQ：53016353）</span><br></p> 
  <p>1.1 数字货币介绍</p> 数字货币是数字事件(交易)的账簿，这个账簿由多个参与者共享，每个参与者都在系统中拥有权益。账簿只有在所有参与者达成共识的情况下才能够更新，并且信息一旦记录就永远不能修改。每个记录的事件都可以基于参与者的共识证明使用密码学进行验证。
  <br>
  <br>
  <br> 交易是安全、私有和保密的。每个参与者使用身份证明向网络成员服务（membership service）注册以获取系统的访问权限。参与者使用不可追踪的导出证书生成交易，可以在网络中完全匿名。交易的内容使用由密钥导出的复杂函数进行加密，确保只有指定的参与者才能够看到内容，以保护商业交易的机密性。
  <br>
  <br>
  <br> 账簿的全部或者部分可以审计以满足监管要求。在参与者合作的情况下，审计人员可以获取有限时间的证书来查看账簿和交易详情，从而对运营情况进行准确的评估。
  <br>
  <br>
  <br> 数字货币是区块链技术的实现，比特币可以作为一种简单的应用在数字货币基础上构建。数字货币采用了模块化的构架，允许不同的组件在实现协议的基础上即插即用。可以使用强大的容器技术来运行主流编程语言以进行智能合约的开发。使用熟悉的和已验证的技术是数字货币构架的宗旨。
  <br>
  <br>
  <br> 1.2 使用Fabic的原因
  <br> 早期的区块链技术能够实现一些功能，但是缺乏对特定行业需求的完整支持。为了满足现代市场的要求，数字货币面向行业需求进行设计以适应多种行业特定的应用场景，并且在诸如伸缩性设计等方面比这个领域的先驱更进一步。数字货币使用了新的方法实现了授权网络、在多个区块链网络上的私有性和保密性。
  <br>
  <br>
  <br>
  <br>
  <br> 2.1 数字货币构架
  <br> 数字货币的构架由成员服务（Membership）、区块链服务（Blockchain）和链码服务（Chaincode）三个主要类别构成。这些类别仅仅是数字货币的逻辑结构，并不是在物理上将组件划分成不同的进程、地址空间或者虚拟机。&nbsp;
  <br>
  <br>
  <br>
  <br>
  <br> 2.1.1 成员服务
  <br> 成员服务负责管理用户标识、隐私、以及网络的保密性和可审计性。在无权限的区块链中，参与者不需要授权，并且所有节点可以平等地提交交易或者将交易累积成区块，也就是说没有角色的区别。成员服务将公钥基础设施（PKI）和去中心化共识机制的基本元素进行整合，从而将无权限区块链转化为有权限区块链。在有权限区块链中，参与者需要注册以获取长期身份凭据（登记证书），并且可以根据身份类型进行区分。在用户的情况下，交易证书管理者（TCA）可以发行假名凭据。这种凭据（即交易证书）被用来进行授权提交的交易。交易证书在区块链上保存，并且允许授权的审计者对交易进行归类，否则这些交易将无法关联。
  <br>
  <br>
  <br> 2.1.2 区块链服务
  <br> 区块链服务通过使用基于HTTP2的P2P协议管理分布式账簿。区块链上的数据结构经过了高度优化以提供最有效的Hash算法来保存世界状态（world state)的副本。在部署中可以使用和配置不同的共识算法，包括PBFT, Raft, PoW, PoS等。
  <br>
  <br>
  <br> 2.1.3 链码服务
  <br> 链码服务为链码（chaincode）在验证节点上执行提供了一个安全和轻量级的沙盒。沙盒环境是一个锁定和安全容器，带有一组经过签名的基础磁盘映像，包含了安全操作系统和支持Go、Java和Node.js的链码语言、运行时和SDK，其他语言可以根据需要被启用。
  <br>
  <br>
  <br> 2.1.4 事件
  <br> 验证节点和链码可以在区块链网络上发送事件，应用程序可以监听这些事件并作出响应。已经存在一组预先定义好的事件，并且链码也可以生成自定义的事件。事件可以被一个或者多个事件适配器处理，适配器可以使用Web Hook或者Kafka进一步将事件进行传递。
  <br>
  <br>
  <br> 2.1.5 应用程序接口（API）
  <br> 数字货币的主要编程接口是REST API，以及基于Swagger2.0的变体。这些API可以让应用程序注册用户、查询区块链、以及发送交易。有一组API专门设计给链码用来与底层平台交互以执行交易和查询交易结果。
  <br>
  <br>
  <br> 2.1.6 命令行接口（CLI）
  <br> CLI包括REST API的一组子集来帮助开发者快速测试链码和查询交易状态。CLI由Go语言实现，并且支持多种操作系统。
  <br>
  <br>
  <br> 2.2 拓扑结构
  <br> 数字货币的部署可以包括成员服务、多个验证节点（peer）和非验证节点、以及一个或者多个应用。所有这些组件构成了一个区块链。可以存在多个区块链，每个区块链都可以有自己的运行参数和安全需求。
  <br>
  <br>
  <br> 2.2.1 单个验证节点
  <br> 从功能上将，非验证节点是验证节点的子集，也就是说每个非验证节点上的功能也可以在验证节点上实现，因此最简单的区块链网络可以仅有一个验证节点构成。这种配置最适合作为开发环境，单个验证节点可以在“编辑-编译-调试”周期中快速启动。
  <br>
  <br>
  <br> 单个验证节点不需要共识机制，因此默认的共识机制插件为noops，在这种情况下交易是立即执行的，这样开发者可以在开发过程中的到立即反馈。
  <br>
  <br>
  <br> 2.2.2 多个验证节点
  <br> 用于生产环境或者测试环境的区块链网络一般由多个验证节点和非验证节点构成。非验证节点可以承担一部分从验证节点剥离的工作量，比如处理API请求和处理事件。&nbsp;
  <br>
  <br>
  <br> 所有验证节点构成了一个全连接的网络，即每个验证节点都与其他的验证节点连接。非验证节点连接到邻近的允许连接的验证节点。非验证节点是可选的，因为应用程序可以直接与验证节点进行通讯。
  <br>
  <br>
  <br> 2.2.3 多链
  <br> 每个由验证节点和非验证节点组成的网络构成了一个区块链。多个区块链可以被创建用来满足不同的需求，好比多个Web网站可以满足不同的目的。
  <br>
  <br>
  <br>
  <br>
  <br> 数字货币的点对点通讯是基于gRPC构建的，实现了基于流的双向消息通讯。gRPC使用了谷歌公司的Protocol Buffers对数据结构进行串行化来实现节点之间的数据传输。Protocol buffers是一种语言中立、平台中立、并且可扩展的数据结构串行化技术。数据结构、消息和服务都是用proto3语言描述。
  <br>
  <br>
  <br> 3.1 消息
  <br> 节点之间传输的消息是由Message这个proto结构封装的，有四种不同的类型：发现（Discovery）、交易（Transaction）、同步（Synchronization）和共识（Consensus）。每种类型都可以在其内嵌的payload字段中定义更多的子类型。
  <br>
  <br>
  <br> message Message {
  <br> &nbsp; &nbsp; enum Type {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; DISC_HELLO = 1;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; DISC_DISCONNECT = 2;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; DISC_GET_PEERS = 3;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; DISC_PEERS = 4;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; DISC_NEWMSG = 5;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_STATUS = 6;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_TRANSACTION = 7;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_GET_TRANSACTIONS = 8;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAIN_QUERY = 9;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_GET_BLOCKS = 11;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCKS = 12;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_BLOCK_ADDED = 13;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_SNAPSHOT = 14;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_SNAPSHOT = 15;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_GET_DELTAS = 16;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; SYNC_STATE_DELTAS = 17;
  <br>
  <br>
  <br> &nbsp; &nbsp; &nbsp; &nbsp; RESPONSE = 20;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CONSENSUS = 21;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; Type type = 1;
  <br> &nbsp; &nbsp; bytes payload = 2;
  <br> &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 3;
  <br> }
  <br> payload字段是一个包含其他对象（Transaction或者Response）的不透明字节数组，例如，当type是CHAIN_TRANSACTION时，payload是Transaction对象。
  <br>
  <br>
  <br> 3.1.1 发现消息
  <br> 在节点启动之后，如果CORE_PEER_DISCOVERY_ROOTNODE字段存在则运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是另外一个网路上节点（任意节点）的IP地址，这个节点可以作为发现网络上其他所有节点的起点。协议序列从DISC_HELLO开始，其payload为HelloMessage对象：
  <br>
  <br>
  <br> message HelloMessage {
  <br> &nbsp; &nbsp; PeerEndpoint peerEndpoint = 1;
  <br> &nbsp; &nbsp; uint64 blockNumber = 2;
  <br> }
  <br> message PeerEndpoint {
  <br> &nbsp; &nbsp; PeerID ID = 1;
  <br> &nbsp; &nbsp; string address = 2;
  <br> &nbsp; &nbsp; enum Type {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; VALIDATOR = 1;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; NON_VALIDATOR = 2;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; Type type = 3;
  <br> &nbsp; &nbsp; bytes pkiID = 4;
  <br> }
  <br>
  <br>
  <br> message PeerID {
  <br> &nbsp; &nbsp; string name = 1;
  <br> }
  <br>
  <br>
  <br> PeerId是节点启动的时候被赋予的名字，也可以在配置文件中定义。
  <br> PeerEndpoint用来描述验证节点或者非验证节点
  <br> pkiID是节点的密码学ID
  <br> address是节点的IP地址和端口(ip:port)
  <br> blockNumber是节点上区块链的当前高度
  <br>
  <br>
  <br> 如果通过DISC_HELLO获取的区块高度超过了当前节点的区块链高度，则节点立即启动同步协议将节点状态更新到网络当前最新状态。
  <br>
  <br>
  <br> DISC_HELLO之后，节点周期性地发送DISC_GET_PEERS以发现新加入到网络的其他节点。作为对DISC_GET_PEERS消息的响应，收到消息的节点发送'DISC_PEERS'消息，该消息中的payload字段包含了一组PeerEndpoint。其他发现消息目前未使用。
  <br>
  <br>
  <br> 3.1.2 交易消息
  <br> 存在3种交易类型：部署（Deploy）、调用（Invoke）和查询（Query）。部署交易将指定的链码安装到区块链网络，而调用和查询交易则是调用已经部署到区块链上的链码函数。还有一种创建型（Create）交易用于将已经部署到区块链上的链码实例化并载入内存，但目前该交易类型未实现。
  <br>
  <br>
  <br> 3.1.2.1 交易数据结构
  <br> message Transaction {
  <br> &nbsp; &nbsp; enum Type {
  <br> &nbsp; &nbsp; &nbsp; &nbsp; UNDEFINED = 0;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_DEPLOY = 1;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_INVOKE = 2;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_QUERY = 3;
  <br> &nbsp; &nbsp; &nbsp; &nbsp; CHAINCODE_TERMINATE = 4;
  <br> &nbsp; &nbsp; }
  <br> &nbsp; &nbsp; Type type = 1;
  <br> &nbsp; &nbsp; string uuid = 5;
  <br> &nbsp; &nbsp; bytes chaincodeID = 2;
  <br> &nbsp; &nbsp; bytes payloadHash = 3;
  <br>
  <br>
  <br> &nbsp; &nbsp; ConfidentialityLevel confidentialityLevel = 7;
  <br> &nbsp; &nbsp; bytes nonce = 8;
  <br> &nbsp; &nbsp; bytes cert = 9;
  <br> &nbsp; &nbsp; bytes signature = 10;
  <br>
  <br>
  <br> &nbsp; &nbsp; bytes metadata = 4;
  <br> &nbsp; &nbsp; google.protobuf.Timestamp timestamp = 6;
  <br> }
  <br>
  <br>
  <br> message TransactionPayload {
  <br> &nbsp; &nbsp; bytes payload = 1;
  <br> }
  <br>
  <br>
  <br> enum ConfidentialityLevel {
  <br> &nbsp; &nbsp; PUBLIC = 0;
  <br> &nbsp; &nbsp; CONFIDENTIAL = 1;
  <br> }
  <br>
  <br>
  <br> 3.1.3 同步消息
  <br> 当节点通过发现协议发现自己比区块链网络落后或者不一致，则马上开启同步协议。节点广播SYNC_GET_BLOCKS、SYNC_STATE_GET_SNAPSHOT或者SYNC_STATE_GET_DELTAS，相应地接收SYNC_BLOCKS、SYNC_STATE_SNAPSHOT或者SYNC_STATE_DELTAS。
  <br>
  <br>
  <br> 已安装的共识机制插件决定同步协议如何执行，每种消息针对不同的情况：
  <br>
  <br>
  <br> SYNC_GET_BLOCKS在消息的payload字段中请求一组连续范围的区块，这种范围使用SyncBlockRange表示：
  <br>
  <br>
  <br> message SyncBlockRange {
  <br> &nbsp; &nbsp; uint64 start = 1;
  <br> &nbsp; &nbsp; uint64 end = 2;
  <br> }
  <br>
  <br>
  <br> 接收到SYNC_GET_BLOCKS的节点响应SYNC_BLOCKS消息，在其payload字段中包含了SyncBlocks:
  <br>
  <br>
  <br> message SyncBlocks {
  <br> &nbsp; &nbsp; SyncBlockRange range = 1;
  <br> &nbsp; &nbsp; repeated Block blocks = 2;
  <br> }
  <br>
  <br>
  <br> 3.1.4 共识消息
  <br> 共识机制用于处理交易，因此CONSENSUS消息由内部的共识框架在接收到CHAIN_TRANSACTION消息后发送。共识框架将CHAIN_TRANSACTION转化为CONSENSUS，然后向所有验证节点进行广播。共识插件接收到消息后，根据自身算法对消息进行处理。
  <br>
  <br>
  <br> 3.2 账簿
  <br> 账簿（ledger）由区块链（blockchain）和世界状态（world state）这两个部分组成。区块链是一组链接起来的区块，用来在账簿中记录交易。世界状态是键值数据库，在链码执行过程中用来存储状态。
  <br>
  <br>
  <br> 3.2.1 区块链
  <br> 3.2.1.1 区块
  <br> 区块链被定义为一组连接在一起的区块，因为每个区块都包含链中前一个区块的Hash。区块中另外2个重要信息是交易列表，以及区块中所有交易执行完成后的世界状态的Hash值。
  <br>
  <br>
  <br> message Block {
  <br> &nbsp; version = 1;
  <br> &nbsp; google.protobuf.Timestamp timestamp = 2;
  <br> &nbsp; bytes transactionsHash = 3;
  <br> &nbsp; bytes stateHash = 4;
  <br> &nbsp; bytes previousBlockHash = 5;
  <br> &nbsp; bytes consensusMetadata = 6;
  <br> &nbsp; NonHashData nonHashData = 7;
  <br> }
  <br>
  <br>
  <br> message BlockTransactions {
  <br> &nbsp; repeated Transaction transactions = 1;
  <br> }
  <br>
  <br>
  <br> transactionsHash是区块内交易列表merkle根的hash值
  <br> stateHash是世界状态merkle根的hash值
  <br> previousBlockHash是前一个区块的hash值
  <br> BlockTransactions.transactions是交易消息的数组，交易列表由于大小的关系并不直接包含在区块内部。
  <br>
  <br>
  <br> 3.2.2 世界状态
  <br> 节点中的世界状态是所有已部署的链码的状态集合，实际上是键值对{chaincodeID, ckey}的集合。 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78383526,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jQQ53016353/article/details/78383526,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
