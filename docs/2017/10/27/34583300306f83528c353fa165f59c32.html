<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>编写你的第一个hyperledger fabric network程序 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="编写你的第一个hyperledger fabric network程序" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Writing Your First Application 编写你的第一个程序。 本文档的目标是使阅读本文档的人能基于HyperLedger Fabric Network编写自己的第一个程序。 在这个程序里，我们提供最基本的功能： 用户能在账本中查询一条数据或者用户更新账本中的一条数据。 我们的程序是使用JAVASCRIPT编写，运行在NODEJS平台上。 此文档将会指导你通过三步去编写你的第一个程序。 第一步： &nbsp;&nbsp;运行一个HyperLedger Fabric BlockChain Network。 &nbsp;&nbsp;我们需要一些基础组件去查询和更新账本。 一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）--作为我们的网络支撑。 &nbsp;&nbsp;我们还需要一个CLI容器来执行管理命令。 一个单独的脚本将会下载和运行这个测试网络。 第二步： &nbsp;&nbsp;学习我们的程序将要使用的智能合约的参数。 &nbsp;&nbsp;我们的智能合约允许我们使用多种不同的方法去操作账本（Ledger）。 例如： 我们可以读取数据的整体或者是一部分（we can &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read data holistically or on a more granular level.）。 第三步： &nbsp;&nbsp;部署程序去查询和更新数据。 &nbsp;&nbsp;我们提供两种简单的程序 ---- 一个查询账本，另一个更新账本。 我们的程序将会使用超级账本的SDK API 去影响 HyperLedger. &nbsp;&nbsp; &nbsp;&nbsp;在完成本教程之后，你应该对如何使用HyperLedger Fabric Network提供的NODEJS的API去编写自己的程序有一个基本的理解。 &nbsp;&nbsp; 首先，让我们运行我们的HyperLedger。 Getting a Test Network 获取一个测试网络。 &nbsp;&nbsp;确保你已经安装了所有必须的依赖软件。 &nbsp;&nbsp;首先决定你要克隆Fabric-samples到哪一个目录，然后运行克隆脚本，随后进入fabric的子目录。 &nbsp;&nbsp; &nbsp;&nbsp;git clone https://github.com/hyperledger/fabric-samples.git &nbsp;&nbsp;cd fabric-samples/fabcar &nbsp;&nbsp; &nbsp;&nbsp;这个子目录（fabcar）包含脚本和程序代码可以运行简单的fabric程序。 运行ls命令你将会看到如下内容： &nbsp;&nbsp;chaincode invoke.js network package.json query.js startFabric.sh &nbsp;&nbsp;现在我们运行startFabric.sh脚本去运行网络。 &nbsp;&nbsp; &nbsp;&nbsp;./startFabric.sh &nbsp;&nbsp; &nbsp;&nbsp;注意: 这个脚本将会下载HyperLedger Fabric Docker 镜像，所以它将会运行一会儿。 &nbsp;&nbsp; &nbsp;&nbsp;为了简洁起见， 我们不会深挖这个命令运行时发生了什么， 这里给出了一个大概内容。 &nbsp;&nbsp;&nbsp;&nbsp;启动一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）和一个CLI 容器。 &nbsp;&nbsp;&nbsp;&nbsp;创建一个通道并且将启动的节点加入通道。 &nbsp;&nbsp;&nbsp;&nbsp;在启动的节点上安装智能合约并且安装启动chainCode。 &nbsp;&nbsp;&nbsp;&nbsp;调用initLedger添加10条数据到账本中。 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;注意： 这些操作通常有管理员来完成。 本脚本使用CLI执行脚本完成操作。同时SDK也能很好的支持这些操作。 &nbsp;&nbsp; &nbsp;&nbsp;执行docker ps 命令去显示startFabric.sh脚本运行的进程。 你可以通过Building Your First Network来学习更多细节和关于这些机器的操作。 &nbsp;&nbsp;在这里我们把注意力放在程序这里。下面的图片简单展示了程序是如何访问HyperLedger Fabric Netowrk。 &nbsp;&nbsp; &nbsp;&nbsp;好吧， 现在你有了一个简单的网络环境和一些能与这个环境交互的代码，让我们将这两部分组合到一起吧。 How Applications Interact with the Network&nbsp; 如何使用程序访问Fabric &nbsp;&nbsp;程序使用APIs去访问智能合约（chaincode）。这些智能合约在网络的主机上以名字和版本作为唯一标识。例如： 我们的智能合约的标题是： dev-peer0.org.example.com-fabcar-1.0 ----名称的部分是fabcar， 版本的部分是1.0，运行的peer的名称是dev-peer0.org.example.com. &nbsp;&nbsp; &nbsp;&nbsp;API可以通过软件开发工具包（SDK）来访问。这次练习中我们将使用Hyper-ledger Fabric Node SDK来开发。当然你也可以使用JAVA SDK或者CLI来进行练习。 &nbsp;&nbsp; Querying the Ledger 查询账本 &nbsp;&nbsp;查询是从账本中读取数据。你可以查询数据的单个值或者多个值。如果账本写入的时候使用的是像JSON一样的富文本 ---- 执行复杂的搜索。 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;正如我们之前说的，我们的网络中有一个运行Chaincode容器和一个账本，其中有10条不同的数据。 我们还需要一些简单的JAVASCRIPT脚本 -- &nbsp;&nbsp;-- 在fabcar目录下可以去查询账本下的块的信息。 &nbsp;&nbsp; &nbsp;&nbsp;在我们了解程序如何运行之前，我们需要为我们的程序安装依赖的SDK模块，在你的fabcar目录下，运行如下命令：npm install。 &nbsp;&nbsp; &nbsp;&nbsp;注意： 你将从fabcar目录发出所有后续的命令。 &nbsp;&nbsp; &nbsp;&nbsp;现在我们可以运行我们的JAVASCRIPT程序了。 首先，让我们运行query.js程序列出账本中的所有区块的信息。 一个函数将会查询出所有的区块, &nbsp;&nbsp;queryAllCars, 预加载到我们的程序中， 我们可以简单的运行这个脚本： node query.js &nbsp;&nbsp; &nbsp;&nbsp;它将会返回如下内容： &nbsp;&nbsp;&nbsp;Query result count = 1 &nbsp;&nbsp;&nbsp;Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius &nbsp;&nbsp;&nbsp;˓→ &quot;,&quot;owner&quot;:&quot;Tomoko&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Brad&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Jin Soo&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner &nbsp;&nbsp;&nbsp;˓→ &quot;:&quot;Max&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Michel&quot;}},&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}}, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Valeria&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Shotaro&quot;}}] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这里有10条数据。 一辆属于adriana黑色（black）的特斯拉（Tesla）Mode S，一辆红色（red）的福特（ford）野马（mustang）是Brad 和其他的。 &nbsp;&nbsp;&nbsp;账本是基于键值（key/value）来实现,而且我们实现键（key）的CAR0 到CAR9。 这一点将会变的非常重要。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;让我们看看程序是如何实现的吧。 使用编辑器打开程序query.js。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;程序的初始化章节定义了主要的变量例如： (智能合约)chaincode ID, 通道名称（channel name）和 访问端口。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;var options = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallet_path : path.join(__dirname, &#39;./network/creds&#39;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id: &#39;PeerAdmin&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel_id: &#39;mychannel&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincode_id: &#39;fabcar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network_url: &#39;grpc://localhost:7051&#39;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这一部分使我们构造查询的语句： &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;// queryCar - requires 1 argument, ex: args: [&#39;CAR4&#39;], &nbsp;&nbsp;&nbsp;// queryAllCars - requires no arguments , ex: args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;fcn: &#39;queryAllCars&#39;, &nbsp;&nbsp;&nbsp;args: [&#39;&#39;] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们将chaincode_id定义为fabcar,允许我们到达这个智能合约。 然后调用智能合约中定义的queryAllCars函数。 &nbsp;&nbsp;&nbsp;当我们运行 node query.js命令的时候，这个函数被调用来查询账本。然而这并不是我们唯一能调用的函数。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们来看下其他的代码。进入chaincode子目录然后打开fabcar.go文件， 你将会看到被声明为 -- initLedger， &nbsp;&nbsp;&nbsp;queryAllCars， createCar 和 changeCarOwner等函数。 让我们在queryAllCars中去了解如何操作账本。 &nbsp;&nbsp;&nbsp;func (s &nbsp;&nbsp;&nbsp;&nbsp;* SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response &nbsp;&nbsp;&nbsp;&nbsp;˓→ { &nbsp;&nbsp;&nbsp;&nbsp;startKey := &quot;CAR0&quot; &nbsp;&nbsp;&nbsp;&nbsp;endKey := &quot;CAR999&quot; &nbsp;&nbsp;&nbsp;&nbsp;resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) 这个函数使用了shim的接口函数GetStateByRange通过两个区间函数startKey和endKey来返回之间的账本数据。 &nbsp;&nbsp;&nbsp;我们分别定义了CAR0到CAR999的键。因此, 如果键被正确使用的话,我们可以存储1000辆车,而且queryAllCars会列出每一辆车。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;下面的图片展示了程序如何智能合约（chaincode）的不同的函数。 在上图中我们可以看到我们的queryAllCars, 还有一个createCar。createCar函数允许我们更新账本。createCar最终将一个新的块添加到区块链中。 &nbsp;&nbsp;&nbsp;但是首先我们先做另一个查询。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;回到我们的query.js程序，编辑query.js的构造请求去查询一个特殊的车辆。&nbsp; 我们将会修改queryAllCars为queryCar,并且指定一个Key作为参数（这里我们 &nbsp;&nbsp;&nbsp;使用CAR4）。我们编辑query.js成下面这样。 &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;queryCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR4&#39;] &nbsp;&nbsp;&nbsp;保存程序并返回fabcar目录下。然后再次运行程序： &nbsp;&nbsp;&nbsp;node query.js &nbsp;&nbsp;&nbsp;你应该看到如下的数据： &nbsp;&nbsp;&nbsp;{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经从查询所有到查询指定的一条。 使用queryCar函数，我们可以查询任意Key获取其映射的数据。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;非常好， 现在你应该能使用智能合约（chaincode）的基础函数用来查询并且可以传递查询参数了。 &nbsp;&nbsp;&nbsp; Updating the Ledger 更新账本。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经做过了账本查询并且修改了一点点代码， 我们已经做好了更新账本的准本。 &nbsp;&nbsp;&nbsp;我们可以对账本做很多更新，但是前提是我们得有数据来更新。所以首先我们来创建一辆车（一条数据）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;账本更新从一个事务的生成开始。 就像查询一样， 一个请求需要一个唯一的channelID， 调用函数和智能合约才能被创建，并且需要将这些数据传递。 &nbsp;&nbsp;&nbsp;然后程序将调用channel.SendTransactionProposal API 将事务发送给peer获得建议（endorsement）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Fabric 返回一个请求响应，应用程序使用它来创建和提交一个事务请求。这个请求通过调用channel.sendTransaction API 发送到 排序服务 &nbsp;&nbsp;&nbsp;（The Ordering Service）。排序服务（The Ordering Service）将此事务绑定到一个块中， 然后将该块发送给所有对等的节点上去认证 &nbsp;&nbsp;&nbsp;（我们的例子中仅有一个节点）。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最终程序会调用eh.setPeerAddr去链接节点的事件监听端口并且调用eh.registerTxEvent去注册时间关联到事务的ID。这个API允许程序去获取 &nbsp;&nbsp;&nbsp;交易的流程（成功（successfully）, committed(已提交)或者未成功（unsuccessful））。把他想象成为一个通知机制。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;注意： 我们不会深入的了解事务的生命周期。你可以查阅事务流程（Transaction Flow）文档来了解如何提交事务给账本的底层细节。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们最初的调用是建立一项新的资产（也就是一辆车）。我们有一个单独的程序 - invoke.js -我们将使用这些事务。就像查询（query.js）一样, &nbsp;&nbsp;&nbsp;我们使用编辑工具打开invoke.js 并找到构造调用API的代码： &nbsp;&nbsp;&nbsp;// createCar - requires 5 args, ex: args: [&#39;CAR11&#39;, &#39;Honda&#39;, &#39;Accord&#39;, &#39;Black&#39;, &#39;Tom &nbsp;&nbsp;&nbsp;&nbsp;˓→ &#39;], &nbsp;&nbsp;&nbsp;&nbsp;// changeCarOwner - requires 2 args , ex: args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;// send proposal to endorser &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你将会看到我们调用两个函数 createCar和changeCarOwner. 让我们创建一辆红色的Chevy Volt，并且将他的拥有者设置为 Nick. 我们的账本的唯一标识的最顶端 &nbsp;&nbsp;&nbsp;是CAR9， 所以我们将用CAR10. 更改代码块像下面这样： &nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;createCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;保存并运行它： &nbsp;&nbsp;&nbsp;&nbsp;node invoke.js &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你的控制台终将会输出响应和事务ID。当我们看到这条信息的时候： &nbsp;&nbsp;&nbsp;&nbsp;The transaction has been committed on peer localhost:7053 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;节点会发出事件通知，我们通过eh.registerTxEvent去接受通知。所以现在如果我们重复去运行query.js的话我们是可以查询到CAR10的。 &nbsp;&nbsp;&nbsp;我们应该会看到如下结果： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Nick&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最后让我们调用我们最后一个函数： changeCarOwner。 Nick是非常慷慨大方的，它准备将他的车送个一个叫Barry的朋友。所以我们简单 &nbsp;&nbsp;&nbsp;的修改一下我们的invoke.js &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets: targets &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;changeCarOwner&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;再次运行程序 - node invoke.js - 然后再运行query.js。 我们将看到CAR10, 我们看到的是修改后的： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} Additional Resources&nbsp;&nbsp; 附加资源 &nbsp;&nbsp;&nbsp;Hyperledger Fabric Node SDK repo 中有更多的优秀的资源和实例代码。当然你也可以咨询Hyperledger FAbric的社区。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 阅读更多" />
<meta property="og:description" content="Writing Your First Application 编写你的第一个程序。 本文档的目标是使阅读本文档的人能基于HyperLedger Fabric Network编写自己的第一个程序。 在这个程序里，我们提供最基本的功能： 用户能在账本中查询一条数据或者用户更新账本中的一条数据。 我们的程序是使用JAVASCRIPT编写，运行在NODEJS平台上。 此文档将会指导你通过三步去编写你的第一个程序。 第一步： &nbsp;&nbsp;运行一个HyperLedger Fabric BlockChain Network。 &nbsp;&nbsp;我们需要一些基础组件去查询和更新账本。 一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）--作为我们的网络支撑。 &nbsp;&nbsp;我们还需要一个CLI容器来执行管理命令。 一个单独的脚本将会下载和运行这个测试网络。 第二步： &nbsp;&nbsp;学习我们的程序将要使用的智能合约的参数。 &nbsp;&nbsp;我们的智能合约允许我们使用多种不同的方法去操作账本（Ledger）。 例如： 我们可以读取数据的整体或者是一部分（we can &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read data holistically or on a more granular level.）。 第三步： &nbsp;&nbsp;部署程序去查询和更新数据。 &nbsp;&nbsp;我们提供两种简单的程序 ---- 一个查询账本，另一个更新账本。 我们的程序将会使用超级账本的SDK API 去影响 HyperLedger. &nbsp;&nbsp; &nbsp;&nbsp;在完成本教程之后，你应该对如何使用HyperLedger Fabric Network提供的NODEJS的API去编写自己的程序有一个基本的理解。 &nbsp;&nbsp; 首先，让我们运行我们的HyperLedger。 Getting a Test Network 获取一个测试网络。 &nbsp;&nbsp;确保你已经安装了所有必须的依赖软件。 &nbsp;&nbsp;首先决定你要克隆Fabric-samples到哪一个目录，然后运行克隆脚本，随后进入fabric的子目录。 &nbsp;&nbsp; &nbsp;&nbsp;git clone https://github.com/hyperledger/fabric-samples.git &nbsp;&nbsp;cd fabric-samples/fabcar &nbsp;&nbsp; &nbsp;&nbsp;这个子目录（fabcar）包含脚本和程序代码可以运行简单的fabric程序。 运行ls命令你将会看到如下内容： &nbsp;&nbsp;chaincode invoke.js network package.json query.js startFabric.sh &nbsp;&nbsp;现在我们运行startFabric.sh脚本去运行网络。 &nbsp;&nbsp; &nbsp;&nbsp;./startFabric.sh &nbsp;&nbsp; &nbsp;&nbsp;注意: 这个脚本将会下载HyperLedger Fabric Docker 镜像，所以它将会运行一会儿。 &nbsp;&nbsp; &nbsp;&nbsp;为了简洁起见， 我们不会深挖这个命令运行时发生了什么， 这里给出了一个大概内容。 &nbsp;&nbsp;&nbsp;&nbsp;启动一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）和一个CLI 容器。 &nbsp;&nbsp;&nbsp;&nbsp;创建一个通道并且将启动的节点加入通道。 &nbsp;&nbsp;&nbsp;&nbsp;在启动的节点上安装智能合约并且安装启动chainCode。 &nbsp;&nbsp;&nbsp;&nbsp;调用initLedger添加10条数据到账本中。 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;注意： 这些操作通常有管理员来完成。 本脚本使用CLI执行脚本完成操作。同时SDK也能很好的支持这些操作。 &nbsp;&nbsp; &nbsp;&nbsp;执行docker ps 命令去显示startFabric.sh脚本运行的进程。 你可以通过Building Your First Network来学习更多细节和关于这些机器的操作。 &nbsp;&nbsp;在这里我们把注意力放在程序这里。下面的图片简单展示了程序是如何访问HyperLedger Fabric Netowrk。 &nbsp;&nbsp; &nbsp;&nbsp;好吧， 现在你有了一个简单的网络环境和一些能与这个环境交互的代码，让我们将这两部分组合到一起吧。 How Applications Interact with the Network&nbsp; 如何使用程序访问Fabric &nbsp;&nbsp;程序使用APIs去访问智能合约（chaincode）。这些智能合约在网络的主机上以名字和版本作为唯一标识。例如： 我们的智能合约的标题是： dev-peer0.org.example.com-fabcar-1.0 ----名称的部分是fabcar， 版本的部分是1.0，运行的peer的名称是dev-peer0.org.example.com. &nbsp;&nbsp; &nbsp;&nbsp;API可以通过软件开发工具包（SDK）来访问。这次练习中我们将使用Hyper-ledger Fabric Node SDK来开发。当然你也可以使用JAVA SDK或者CLI来进行练习。 &nbsp;&nbsp; Querying the Ledger 查询账本 &nbsp;&nbsp;查询是从账本中读取数据。你可以查询数据的单个值或者多个值。如果账本写入的时候使用的是像JSON一样的富文本 ---- 执行复杂的搜索。 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;正如我们之前说的，我们的网络中有一个运行Chaincode容器和一个账本，其中有10条不同的数据。 我们还需要一些简单的JAVASCRIPT脚本 -- &nbsp;&nbsp;-- 在fabcar目录下可以去查询账本下的块的信息。 &nbsp;&nbsp; &nbsp;&nbsp;在我们了解程序如何运行之前，我们需要为我们的程序安装依赖的SDK模块，在你的fabcar目录下，运行如下命令：npm install。 &nbsp;&nbsp; &nbsp;&nbsp;注意： 你将从fabcar目录发出所有后续的命令。 &nbsp;&nbsp; &nbsp;&nbsp;现在我们可以运行我们的JAVASCRIPT程序了。 首先，让我们运行query.js程序列出账本中的所有区块的信息。 一个函数将会查询出所有的区块, &nbsp;&nbsp;queryAllCars, 预加载到我们的程序中， 我们可以简单的运行这个脚本： node query.js &nbsp;&nbsp; &nbsp;&nbsp;它将会返回如下内容： &nbsp;&nbsp;&nbsp;Query result count = 1 &nbsp;&nbsp;&nbsp;Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius &nbsp;&nbsp;&nbsp;˓→ &quot;,&quot;owner&quot;:&quot;Tomoko&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Brad&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Jin Soo&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner &nbsp;&nbsp;&nbsp;˓→ &quot;:&quot;Max&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Michel&quot;}},&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}}, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Valeria&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Shotaro&quot;}}] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这里有10条数据。 一辆属于adriana黑色（black）的特斯拉（Tesla）Mode S，一辆红色（red）的福特（ford）野马（mustang）是Brad 和其他的。 &nbsp;&nbsp;&nbsp;账本是基于键值（key/value）来实现,而且我们实现键（key）的CAR0 到CAR9。 这一点将会变的非常重要。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;让我们看看程序是如何实现的吧。 使用编辑器打开程序query.js。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;程序的初始化章节定义了主要的变量例如： (智能合约)chaincode ID, 通道名称（channel name）和 访问端口。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;var options = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallet_path : path.join(__dirname, &#39;./network/creds&#39;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id: &#39;PeerAdmin&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel_id: &#39;mychannel&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincode_id: &#39;fabcar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network_url: &#39;grpc://localhost:7051&#39;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这一部分使我们构造查询的语句： &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;// queryCar - requires 1 argument, ex: args: [&#39;CAR4&#39;], &nbsp;&nbsp;&nbsp;// queryAllCars - requires no arguments , ex: args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;fcn: &#39;queryAllCars&#39;, &nbsp;&nbsp;&nbsp;args: [&#39;&#39;] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们将chaincode_id定义为fabcar,允许我们到达这个智能合约。 然后调用智能合约中定义的queryAllCars函数。 &nbsp;&nbsp;&nbsp;当我们运行 node query.js命令的时候，这个函数被调用来查询账本。然而这并不是我们唯一能调用的函数。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们来看下其他的代码。进入chaincode子目录然后打开fabcar.go文件， 你将会看到被声明为 -- initLedger， &nbsp;&nbsp;&nbsp;queryAllCars， createCar 和 changeCarOwner等函数。 让我们在queryAllCars中去了解如何操作账本。 &nbsp;&nbsp;&nbsp;func (s &nbsp;&nbsp;&nbsp;&nbsp;* SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response &nbsp;&nbsp;&nbsp;&nbsp;˓→ { &nbsp;&nbsp;&nbsp;&nbsp;startKey := &quot;CAR0&quot; &nbsp;&nbsp;&nbsp;&nbsp;endKey := &quot;CAR999&quot; &nbsp;&nbsp;&nbsp;&nbsp;resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) 这个函数使用了shim的接口函数GetStateByRange通过两个区间函数startKey和endKey来返回之间的账本数据。 &nbsp;&nbsp;&nbsp;我们分别定义了CAR0到CAR999的键。因此, 如果键被正确使用的话,我们可以存储1000辆车,而且queryAllCars会列出每一辆车。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;下面的图片展示了程序如何智能合约（chaincode）的不同的函数。 在上图中我们可以看到我们的queryAllCars, 还有一个createCar。createCar函数允许我们更新账本。createCar最终将一个新的块添加到区块链中。 &nbsp;&nbsp;&nbsp;但是首先我们先做另一个查询。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;回到我们的query.js程序，编辑query.js的构造请求去查询一个特殊的车辆。&nbsp; 我们将会修改queryAllCars为queryCar,并且指定一个Key作为参数（这里我们 &nbsp;&nbsp;&nbsp;使用CAR4）。我们编辑query.js成下面这样。 &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;queryCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR4&#39;] &nbsp;&nbsp;&nbsp;保存程序并返回fabcar目录下。然后再次运行程序： &nbsp;&nbsp;&nbsp;node query.js &nbsp;&nbsp;&nbsp;你应该看到如下的数据： &nbsp;&nbsp;&nbsp;{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经从查询所有到查询指定的一条。 使用queryCar函数，我们可以查询任意Key获取其映射的数据。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;非常好， 现在你应该能使用智能合约（chaincode）的基础函数用来查询并且可以传递查询参数了。 &nbsp;&nbsp;&nbsp; Updating the Ledger 更新账本。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经做过了账本查询并且修改了一点点代码， 我们已经做好了更新账本的准本。 &nbsp;&nbsp;&nbsp;我们可以对账本做很多更新，但是前提是我们得有数据来更新。所以首先我们来创建一辆车（一条数据）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;账本更新从一个事务的生成开始。 就像查询一样， 一个请求需要一个唯一的channelID， 调用函数和智能合约才能被创建，并且需要将这些数据传递。 &nbsp;&nbsp;&nbsp;然后程序将调用channel.SendTransactionProposal API 将事务发送给peer获得建议（endorsement）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Fabric 返回一个请求响应，应用程序使用它来创建和提交一个事务请求。这个请求通过调用channel.sendTransaction API 发送到 排序服务 &nbsp;&nbsp;&nbsp;（The Ordering Service）。排序服务（The Ordering Service）将此事务绑定到一个块中， 然后将该块发送给所有对等的节点上去认证 &nbsp;&nbsp;&nbsp;（我们的例子中仅有一个节点）。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最终程序会调用eh.setPeerAddr去链接节点的事件监听端口并且调用eh.registerTxEvent去注册时间关联到事务的ID。这个API允许程序去获取 &nbsp;&nbsp;&nbsp;交易的流程（成功（successfully）, committed(已提交)或者未成功（unsuccessful））。把他想象成为一个通知机制。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;注意： 我们不会深入的了解事务的生命周期。你可以查阅事务流程（Transaction Flow）文档来了解如何提交事务给账本的底层细节。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们最初的调用是建立一项新的资产（也就是一辆车）。我们有一个单独的程序 - invoke.js -我们将使用这些事务。就像查询（query.js）一样, &nbsp;&nbsp;&nbsp;我们使用编辑工具打开invoke.js 并找到构造调用API的代码： &nbsp;&nbsp;&nbsp;// createCar - requires 5 args, ex: args: [&#39;CAR11&#39;, &#39;Honda&#39;, &#39;Accord&#39;, &#39;Black&#39;, &#39;Tom &nbsp;&nbsp;&nbsp;&nbsp;˓→ &#39;], &nbsp;&nbsp;&nbsp;&nbsp;// changeCarOwner - requires 2 args , ex: args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;// send proposal to endorser &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你将会看到我们调用两个函数 createCar和changeCarOwner. 让我们创建一辆红色的Chevy Volt，并且将他的拥有者设置为 Nick. 我们的账本的唯一标识的最顶端 &nbsp;&nbsp;&nbsp;是CAR9， 所以我们将用CAR10. 更改代码块像下面这样： &nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;createCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;保存并运行它： &nbsp;&nbsp;&nbsp;&nbsp;node invoke.js &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你的控制台终将会输出响应和事务ID。当我们看到这条信息的时候： &nbsp;&nbsp;&nbsp;&nbsp;The transaction has been committed on peer localhost:7053 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;节点会发出事件通知，我们通过eh.registerTxEvent去接受通知。所以现在如果我们重复去运行query.js的话我们是可以查询到CAR10的。 &nbsp;&nbsp;&nbsp;我们应该会看到如下结果： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Nick&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最后让我们调用我们最后一个函数： changeCarOwner。 Nick是非常慷慨大方的，它准备将他的车送个一个叫Barry的朋友。所以我们简单 &nbsp;&nbsp;&nbsp;的修改一下我们的invoke.js &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets: targets &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;changeCarOwner&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;再次运行程序 - node invoke.js - 然后再运行query.js。 我们将看到CAR10, 我们看到的是修改后的： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} Additional Resources&nbsp;&nbsp; 附加资源 &nbsp;&nbsp;&nbsp;Hyperledger Fabric Node SDK repo 中有更多的优秀的资源和实例代码。当然你也可以咨询Hyperledger FAbric的社区。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/10/27/34583300306f83528c353fa165f59c32.html" />
<meta property="og:url" content="https://mlh.app/2017/10/27/34583300306f83528c353fa165f59c32.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Writing Your First Application 编写你的第一个程序。 本文档的目标是使阅读本文档的人能基于HyperLedger Fabric Network编写自己的第一个程序。 在这个程序里，我们提供最基本的功能： 用户能在账本中查询一条数据或者用户更新账本中的一条数据。 我们的程序是使用JAVASCRIPT编写，运行在NODEJS平台上。 此文档将会指导你通过三步去编写你的第一个程序。 第一步： &nbsp;&nbsp;运行一个HyperLedger Fabric BlockChain Network。 &nbsp;&nbsp;我们需要一些基础组件去查询和更新账本。 一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）--作为我们的网络支撑。 &nbsp;&nbsp;我们还需要一个CLI容器来执行管理命令。 一个单独的脚本将会下载和运行这个测试网络。 第二步： &nbsp;&nbsp;学习我们的程序将要使用的智能合约的参数。 &nbsp;&nbsp;我们的智能合约允许我们使用多种不同的方法去操作账本（Ledger）。 例如： 我们可以读取数据的整体或者是一部分（we can &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read data holistically or on a more granular level.）。 第三步： &nbsp;&nbsp;部署程序去查询和更新数据。 &nbsp;&nbsp;我们提供两种简单的程序 ---- 一个查询账本，另一个更新账本。 我们的程序将会使用超级账本的SDK API 去影响 HyperLedger. &nbsp;&nbsp; &nbsp;&nbsp;在完成本教程之后，你应该对如何使用HyperLedger Fabric Network提供的NODEJS的API去编写自己的程序有一个基本的理解。 &nbsp;&nbsp; 首先，让我们运行我们的HyperLedger。 Getting a Test Network 获取一个测试网络。 &nbsp;&nbsp;确保你已经安装了所有必须的依赖软件。 &nbsp;&nbsp;首先决定你要克隆Fabric-samples到哪一个目录，然后运行克隆脚本，随后进入fabric的子目录。 &nbsp;&nbsp; &nbsp;&nbsp;git clone https://github.com/hyperledger/fabric-samples.git &nbsp;&nbsp;cd fabric-samples/fabcar &nbsp;&nbsp; &nbsp;&nbsp;这个子目录（fabcar）包含脚本和程序代码可以运行简单的fabric程序。 运行ls命令你将会看到如下内容： &nbsp;&nbsp;chaincode invoke.js network package.json query.js startFabric.sh &nbsp;&nbsp;现在我们运行startFabric.sh脚本去运行网络。 &nbsp;&nbsp; &nbsp;&nbsp;./startFabric.sh &nbsp;&nbsp; &nbsp;&nbsp;注意: 这个脚本将会下载HyperLedger Fabric Docker 镜像，所以它将会运行一会儿。 &nbsp;&nbsp; &nbsp;&nbsp;为了简洁起见， 我们不会深挖这个命令运行时发生了什么， 这里给出了一个大概内容。 &nbsp;&nbsp;&nbsp;&nbsp;启动一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）和一个CLI 容器。 &nbsp;&nbsp;&nbsp;&nbsp;创建一个通道并且将启动的节点加入通道。 &nbsp;&nbsp;&nbsp;&nbsp;在启动的节点上安装智能合约并且安装启动chainCode。 &nbsp;&nbsp;&nbsp;&nbsp;调用initLedger添加10条数据到账本中。 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;注意： 这些操作通常有管理员来完成。 本脚本使用CLI执行脚本完成操作。同时SDK也能很好的支持这些操作。 &nbsp;&nbsp; &nbsp;&nbsp;执行docker ps 命令去显示startFabric.sh脚本运行的进程。 你可以通过Building Your First Network来学习更多细节和关于这些机器的操作。 &nbsp;&nbsp;在这里我们把注意力放在程序这里。下面的图片简单展示了程序是如何访问HyperLedger Fabric Netowrk。 &nbsp;&nbsp; &nbsp;&nbsp;好吧， 现在你有了一个简单的网络环境和一些能与这个环境交互的代码，让我们将这两部分组合到一起吧。 How Applications Interact with the Network&nbsp; 如何使用程序访问Fabric &nbsp;&nbsp;程序使用APIs去访问智能合约（chaincode）。这些智能合约在网络的主机上以名字和版本作为唯一标识。例如： 我们的智能合约的标题是： dev-peer0.org.example.com-fabcar-1.0 ----名称的部分是fabcar， 版本的部分是1.0，运行的peer的名称是dev-peer0.org.example.com. &nbsp;&nbsp; &nbsp;&nbsp;API可以通过软件开发工具包（SDK）来访问。这次练习中我们将使用Hyper-ledger Fabric Node SDK来开发。当然你也可以使用JAVA SDK或者CLI来进行练习。 &nbsp;&nbsp; Querying the Ledger 查询账本 &nbsp;&nbsp;查询是从账本中读取数据。你可以查询数据的单个值或者多个值。如果账本写入的时候使用的是像JSON一样的富文本 ---- 执行复杂的搜索。 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;正如我们之前说的，我们的网络中有一个运行Chaincode容器和一个账本，其中有10条不同的数据。 我们还需要一些简单的JAVASCRIPT脚本 -- &nbsp;&nbsp;-- 在fabcar目录下可以去查询账本下的块的信息。 &nbsp;&nbsp; &nbsp;&nbsp;在我们了解程序如何运行之前，我们需要为我们的程序安装依赖的SDK模块，在你的fabcar目录下，运行如下命令：npm install。 &nbsp;&nbsp; &nbsp;&nbsp;注意： 你将从fabcar目录发出所有后续的命令。 &nbsp;&nbsp; &nbsp;&nbsp;现在我们可以运行我们的JAVASCRIPT程序了。 首先，让我们运行query.js程序列出账本中的所有区块的信息。 一个函数将会查询出所有的区块, &nbsp;&nbsp;queryAllCars, 预加载到我们的程序中， 我们可以简单的运行这个脚本： node query.js &nbsp;&nbsp; &nbsp;&nbsp;它将会返回如下内容： &nbsp;&nbsp;&nbsp;Query result count = 1 &nbsp;&nbsp;&nbsp;Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius &nbsp;&nbsp;&nbsp;˓→ &quot;,&quot;owner&quot;:&quot;Tomoko&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Brad&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Jin Soo&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner &nbsp;&nbsp;&nbsp;˓→ &quot;:&quot;Max&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Michel&quot;}},&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}}, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari &nbsp;&nbsp;&nbsp;˓→ &quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Valeria&quot;}}, &nbsp;&nbsp;&nbsp;{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;: &nbsp;&nbsp;&nbsp;˓→ &quot;Shotaro&quot;}}] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这里有10条数据。 一辆属于adriana黑色（black）的特斯拉（Tesla）Mode S，一辆红色（red）的福特（ford）野马（mustang）是Brad 和其他的。 &nbsp;&nbsp;&nbsp;账本是基于键值（key/value）来实现,而且我们实现键（key）的CAR0 到CAR9。 这一点将会变的非常重要。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;让我们看看程序是如何实现的吧。 使用编辑器打开程序query.js。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;程序的初始化章节定义了主要的变量例如： (智能合约)chaincode ID, 通道名称（channel name）和 访问端口。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;var options = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallet_path : path.join(__dirname, &#39;./network/creds&#39;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id: &#39;PeerAdmin&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel_id: &#39;mychannel&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincode_id: &#39;fabcar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network_url: &#39;grpc://localhost:7051&#39;, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这一部分使我们构造查询的语句： &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;// queryCar - requires 1 argument, ex: args: [&#39;CAR4&#39;], &nbsp;&nbsp;&nbsp;// queryAllCars - requires no arguments , ex: args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;fcn: &#39;queryAllCars&#39;, &nbsp;&nbsp;&nbsp;args: [&#39;&#39;] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们将chaincode_id定义为fabcar,允许我们到达这个智能合约。 然后调用智能合约中定义的queryAllCars函数。 &nbsp;&nbsp;&nbsp;当我们运行 node query.js命令的时候，这个函数被调用来查询账本。然而这并不是我们唯一能调用的函数。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们来看下其他的代码。进入chaincode子目录然后打开fabcar.go文件， 你将会看到被声明为 -- initLedger， &nbsp;&nbsp;&nbsp;queryAllCars， createCar 和 changeCarOwner等函数。 让我们在queryAllCars中去了解如何操作账本。 &nbsp;&nbsp;&nbsp;func (s &nbsp;&nbsp;&nbsp;&nbsp;* SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response &nbsp;&nbsp;&nbsp;&nbsp;˓→ { &nbsp;&nbsp;&nbsp;&nbsp;startKey := &quot;CAR0&quot; &nbsp;&nbsp;&nbsp;&nbsp;endKey := &quot;CAR999&quot; &nbsp;&nbsp;&nbsp;&nbsp;resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) 这个函数使用了shim的接口函数GetStateByRange通过两个区间函数startKey和endKey来返回之间的账本数据。 &nbsp;&nbsp;&nbsp;我们分别定义了CAR0到CAR999的键。因此, 如果键被正确使用的话,我们可以存储1000辆车,而且queryAllCars会列出每一辆车。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;下面的图片展示了程序如何智能合约（chaincode）的不同的函数。 在上图中我们可以看到我们的queryAllCars, 还有一个createCar。createCar函数允许我们更新账本。createCar最终将一个新的块添加到区块链中。 &nbsp;&nbsp;&nbsp;但是首先我们先做另一个查询。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;回到我们的query.js程序，编辑query.js的构造请求去查询一个特殊的车辆。&nbsp; 我们将会修改queryAllCars为queryCar,并且指定一个Key作为参数（这里我们 &nbsp;&nbsp;&nbsp;使用CAR4）。我们编辑query.js成下面这样。 &nbsp;&nbsp;&nbsp;const request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: transaction_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;queryCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR4&#39;] &nbsp;&nbsp;&nbsp;保存程序并返回fabcar目录下。然后再次运行程序： &nbsp;&nbsp;&nbsp;node query.js &nbsp;&nbsp;&nbsp;你应该看到如下的数据： &nbsp;&nbsp;&nbsp;{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经从查询所有到查询指定的一条。 使用queryCar函数，我们可以查询任意Key获取其映射的数据。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;非常好， 现在你应该能使用智能合约（chaincode）的基础函数用来查询并且可以传递查询参数了。 &nbsp;&nbsp;&nbsp; Updating the Ledger 更新账本。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;现在我们已经做过了账本查询并且修改了一点点代码， 我们已经做好了更新账本的准本。 &nbsp;&nbsp;&nbsp;我们可以对账本做很多更新，但是前提是我们得有数据来更新。所以首先我们来创建一辆车（一条数据）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;账本更新从一个事务的生成开始。 就像查询一样， 一个请求需要一个唯一的channelID， 调用函数和智能合约才能被创建，并且需要将这些数据传递。 &nbsp;&nbsp;&nbsp;然后程序将调用channel.SendTransactionProposal API 将事务发送给peer获得建议（endorsement）。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Fabric 返回一个请求响应，应用程序使用它来创建和提交一个事务请求。这个请求通过调用channel.sendTransaction API 发送到 排序服务 &nbsp;&nbsp;&nbsp;（The Ordering Service）。排序服务（The Ordering Service）将此事务绑定到一个块中， 然后将该块发送给所有对等的节点上去认证 &nbsp;&nbsp;&nbsp;（我们的例子中仅有一个节点）。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最终程序会调用eh.setPeerAddr去链接节点的事件监听端口并且调用eh.registerTxEvent去注册时间关联到事务的ID。这个API允许程序去获取 &nbsp;&nbsp;&nbsp;交易的流程（成功（successfully）, committed(已提交)或者未成功（unsuccessful））。把他想象成为一个通知机制。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;注意： 我们不会深入的了解事务的生命周期。你可以查阅事务流程（Transaction Flow）文档来了解如何提交事务给账本的底层细节。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们最初的调用是建立一项新的资产（也就是一辆车）。我们有一个单独的程序 - invoke.js -我们将使用这些事务。就像查询（query.js）一样, &nbsp;&nbsp;&nbsp;我们使用编辑工具打开invoke.js 并找到构造调用API的代码： &nbsp;&nbsp;&nbsp;// createCar - requires 5 args, ex: args: [&#39;CAR11&#39;, &#39;Honda&#39;, &#39;Accord&#39;, &#39;Black&#39;, &#39;Tom &nbsp;&nbsp;&nbsp;&nbsp;˓→ &#39;], &nbsp;&nbsp;&nbsp;&nbsp;// changeCarOwner - requires 2 args , ex: args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;// send proposal to endorser &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你将会看到我们调用两个函数 createCar和changeCarOwner. 让我们创建一辆红色的Chevy Volt，并且将他的拥有者设置为 Nick. 我们的账本的唯一标识的最顶端 &nbsp;&nbsp;&nbsp;是CAR9， 所以我们将用CAR10. 更改代码块像下面这样： &nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;targets: targets, &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;createCar&#39;, &nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;保存并运行它： &nbsp;&nbsp;&nbsp;&nbsp;node invoke.js &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;你的控制台终将会输出响应和事务ID。当我们看到这条信息的时候： &nbsp;&nbsp;&nbsp;&nbsp;The transaction has been committed on peer localhost:7053 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;节点会发出事件通知，我们通过eh.registerTxEvent去接受通知。所以现在如果我们重复去运行query.js的话我们是可以查询到CAR10的。 &nbsp;&nbsp;&nbsp;我们应该会看到如下结果： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Nick&quot;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;最后让我们调用我们最后一个函数： changeCarOwner。 Nick是非常慷慨大方的，它准备将他的车送个一个叫Barry的朋友。所以我们简单 &nbsp;&nbsp;&nbsp;的修改一下我们的invoke.js &nbsp;&nbsp;&nbsp;&nbsp;var request = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets: targets &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: &#39;changeCarOwner&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: [&#39;CAR10&#39;, &#39;Barry&#39;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id &nbsp;&nbsp;&nbsp;再次运行程序 - node invoke.js - 然后再运行query.js。 我们将看到CAR10, 我们看到的是修改后的： &nbsp;&nbsp;&nbsp;&nbsp;Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} Additional Resources&nbsp;&nbsp; 附加资源 &nbsp;&nbsp;&nbsp;Hyperledger Fabric Node SDK repo 中有更多的优秀的资源和实例代码。当然你也可以咨询Hyperledger FAbric的社区。 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/10/27/34583300306f83528c353fa165f59c32.html","headline":"编写你的第一个hyperledger fabric network程序","dateModified":"2017-10-27T00:00:00+08:00","datePublished":"2017-10-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/10/27/34583300306f83528c353fa165f59c32.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>编写你的第一个hyperledger fabric network程序</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div>
   Writing Your First Application
   <br> 编写你的第一个程序。
  </div> 
  <div>
   本文档的目标是使阅读本文档的人能基于HyperLedger Fabric Network编写自己的第一个程序。
  </div> 
  <div>
   在这个程序里，我们提供最基本的功能： 用户能在账本中查询一条数据或者用户更新账本中的一条数据。
  </div> 
  <div>
   <br> 我们的程序是使用JAVASCRIPT编写，运行在NODEJS平台上。 此文档将会指导你通过三步去编写你的第一个程序。
  </div> 
  <div>
   第一步：
   <br> &nbsp;&nbsp;运行一个HyperLedger Fabric BlockChain Network。
   <br> &nbsp;&nbsp;我们需要一些基础组件去查询和更新账本。 一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）--作为我们的网络支撑。
   <br> &nbsp;&nbsp;我们还需要一个CLI容器来执行管理命令。 一个单独的脚本将会下载和运行这个测试网络。
   <br> 第二步：
   <br> &nbsp;&nbsp;学习我们的程序将要使用的智能合约的参数。
   <br> &nbsp;&nbsp;我们的智能合约允许我们使用多种不同的方法去操作账本（Ledger）。 例如： 我们可以读取数据的整体或者是一部分（we can
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read data holistically or on a more granular level.）。
   <br> 第三步：
   <br> &nbsp;&nbsp;部署程序去查询和更新数据。
   <br> &nbsp;&nbsp;我们提供两种简单的程序 ---- 一个查询账本，另一个更新账本。 我们的程序将会使用超级账本的SDK API 去影响 HyperLedger.
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;在完成本教程之后，你应该对如何使用HyperLedger Fabric Network提供的NODEJS的API去编写自己的程序有一个基本的理解。
   <br> &nbsp;&nbsp;
   <br> 首先，让我们运行我们的HyperLedger。
  </div> 
  <div>
   Getting a Test Network
   <br> 获取一个测试网络。
  </div> 
  <div>
   &nbsp;&nbsp;确保你已经安装了所有必须的依赖软件。
   <br> &nbsp;&nbsp;首先决定你要克隆Fabric-samples到哪一个目录，然后运行克隆脚本，随后进入fabric的子目录。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;git clone https://github.com/hyperledger/fabric-samples.git
   <br> &nbsp;&nbsp;cd fabric-samples/fabcar
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;这个子目录（fabcar）包含脚本和程序代码可以运行简单的fabric程序。 运行ls命令你将会看到如下内容：
   <br> &nbsp;&nbsp;chaincode invoke.js network package.json query.js startFabric.sh
   <br> &nbsp;&nbsp;现在我们运行startFabric.sh脚本去运行网络。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;./startFabric.sh
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;注意: 这个脚本将会下载HyperLedger Fabric Docker 镜像，所以它将会运行一会儿。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;为了简洁起见， 我们不会深挖这个命令运行时发生了什么， 这里给出了一个大概内容。
   <br> &nbsp;&nbsp;&nbsp;&nbsp;启动一个通道节点（peer node）, 排序节点（Ordering node）和认证授权中心（Certificate Authority ）和一个CLI 容器。
   <br> &nbsp;&nbsp;&nbsp;&nbsp;创建一个通道并且将启动的节点加入通道。
   <br> &nbsp;&nbsp;&nbsp;&nbsp;在启动的节点上安装智能合约并且安装启动chainCode。
   <br> &nbsp;&nbsp;&nbsp;&nbsp;调用initLedger添加10条数据到账本中。
   <br> &nbsp; &nbsp;&nbsp;
   <br> &nbsp;&nbsp;注意： 这些操作通常有管理员来完成。 本脚本使用CLI执行脚本完成操作。同时SDK也能很好的支持这些操作。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;执行docker ps 命令去显示startFabric.sh脚本运行的进程。 你可以通过Building Your First Network来学习更多细节和关于这些机器的操作。
   <br> &nbsp;&nbsp;在这里我们把注意力放在程序这里。下面的图片简单展示了程序是如何访问HyperLedger Fabric Netowrk。
  </div> 
  <div>
   <img alt="" src="">
  </div> 
  <div>
   <img alt="" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171027174733662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejcxNDMwMzU4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;好吧， 现在你有了一个简单的网络环境和一些能与这个环境交互的代码，让我们将这两部分组合到一起吧。
  </div> 
  <div>
   How Applications Interact with the Network&nbsp;
   <br> 如何使用程序访问Fabric
  </div> 
  <div>
   &nbsp;&nbsp;程序使用APIs去访问智能合约（chaincode）。这些智能合约在网络的主机上以名字和版本作为唯一标识。例如： 我们的智能合约的标题是： dev-peer0.org.example.com-fabcar-1.0 ----名称的部分是fabcar， 版本的部分是1.0，运行的peer的名称是dev-peer0.org.example.com.
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;API可以通过软件开发工具包（SDK）来访问。这次练习中我们将使用Hyper-ledger Fabric Node SDK来开发。当然你也可以使用JAVA SDK或者CLI来进行练习。
   <br> &nbsp;&nbsp;
   <br> Querying the Ledger
   <br> 查询账本
  </div> 
  <div>
   &nbsp;&nbsp;查询是从账本中读取数据。你可以查询数据的单个值或者多个值。如果账本写入的时候使用的是像JSON一样的富文本 ---- 执行复杂的搜索。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;
   <img alt="" src="">
   <img alt="" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171027174450149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejcxNDMwMzU4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;正如我们之前说的，我们的网络中有一个运行Chaincode容器和一个账本，其中有10条不同的数据。 我们还需要一些简单的JAVASCRIPT脚本 --
   <br> &nbsp;&nbsp;-- 在fabcar目录下可以去查询账本下的块的信息。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;在我们了解程序如何运行之前，我们需要为我们的程序安装依赖的SDK模块，在你的fabcar目录下，运行如下命令：npm install。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;注意： 你将从fabcar目录发出所有后续的命令。
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;现在我们可以运行我们的JAVASCRIPT程序了。 首先，让我们运行query.js程序列出账本中的所有区块的信息。 一个函数将会查询出所有的区块,
   <br> &nbsp;&nbsp;queryAllCars, 预加载到我们的程序中， 我们可以简单的运行这个脚本： node query.js
   <br> &nbsp;&nbsp;
   <br> &nbsp;&nbsp;它将会返回如下内容：
   <br> &nbsp;&nbsp;&nbsp;Query result count = 1
   <br> &nbsp;&nbsp;&nbsp;Response is [{"Key":"CAR0", "Record":{"colour":"blue","make":"Toyota","model":"Prius
   <br> &nbsp;&nbsp;&nbsp;˓→ ","owner":"Tomoko"}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR1", "Record":{"colour":"red","make":"Ford","model":"Mustang","owner":
   <br> &nbsp;&nbsp;&nbsp;˓→ "Brad"}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR2", "Record":{"colour":"green","make":"Hyundai","model":"Tucson","owner":
   <br> &nbsp;&nbsp;&nbsp;˓→ "Jin Soo"}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR3", "Record":{"colour":"yellow","make":"Volkswagen","model":"Passat","owner
   <br> &nbsp;&nbsp;&nbsp;˓→ ":"Max"}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR4", "Record":{"colour":"black","make":"Tesla","model":"S","owner":"Adriana
   <br> &nbsp;&nbsp;&nbsp;˓→ "}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR5", "Record":{"colour":"purple","make":"Peugeot","model":"205","owner":
   <br> &nbsp;&nbsp;&nbsp;˓→ "Michel"}},&nbsp;
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR6", "Record":{"colour":"white","make":"Chery","model":"S22L","owner":"Aarav"}},
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR7", "Record":{"colour":"violet","make":"Fiat","model":"Punto","owner":"Pari
   <br> &nbsp;&nbsp;&nbsp;˓→ "}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR8", "Record":{"colour":"indigo","make":"Tata","model":"Nano","owner":
   <br> &nbsp;&nbsp;&nbsp;˓→ "Valeria"}},
   <br> &nbsp;&nbsp;&nbsp;{"Key":"CAR9", "Record":{"colour":"brown","make":"Holden","model":"Barina","owner":
   <br> &nbsp;&nbsp;&nbsp;˓→ "Shotaro"}}]
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;这里有10条数据。 一辆属于adriana黑色（black）的特斯拉（Tesla）Mode S，一辆红色（red）的福特（ford）野马（mustang）是Brad 和其他的。
   <br> &nbsp;&nbsp;&nbsp;账本是基于键值（key/value）来实现,而且我们实现键（key）的CAR0 到CAR9。 这一点将会变的非常重要。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;让我们看看程序是如何实现的吧。 使用编辑器打开程序query.js。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;程序的初始化章节定义了主要的变量例如： (智能合约)chaincode ID, 通道名称（channel name）和 访问端口。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;var options = {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallet_path : path.join(__dirname, './network/creds'),
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id: 'PeerAdmin',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel_id: 'mychannel',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincode_id: 'fabcar',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network_url: 'grpc://localhost:7051',
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;这一部分使我们构造查询的语句：
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;// queryCar - requires 1 argument, ex: args: ['CAR4'],
   <br> &nbsp;&nbsp;&nbsp;// queryAllCars - requires no arguments , ex: args: [''],
   <br> &nbsp;&nbsp;&nbsp;const request = {
   <br> &nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id,
   <br> &nbsp;&nbsp;&nbsp;txId: transaction_id,
   <br> &nbsp;&nbsp;&nbsp;fcn: 'queryAllCars',
   <br> &nbsp;&nbsp;&nbsp;args: ['']
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;我们将chaincode_id定义为fabcar,允许我们到达这个智能合约。 然后调用智能合约中定义的queryAllCars函数。
   <br> &nbsp;&nbsp;&nbsp;当我们运行 node query.js命令的时候，这个函数被调用来查询账本。然而这并不是我们唯一能调用的函数。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;我们来看下其他的代码。进入chaincode子目录然后打开fabcar.go文件， 你将会看到被声明为 -- initLedger，
   <br> &nbsp;&nbsp;&nbsp;queryAllCars， createCar 和 changeCarOwner等函数。 让我们在queryAllCars中去了解如何操作账本。
   <br> &nbsp;&nbsp;&nbsp;func (s
   <br> &nbsp;&nbsp;&nbsp;&nbsp;* SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response
   <br> &nbsp;&nbsp;&nbsp;&nbsp;˓→ {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;startKey := "CAR0"
   <br> &nbsp;&nbsp;&nbsp;&nbsp;endKey := "CAR999"
   <br> &nbsp;&nbsp;&nbsp;&nbsp;resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
  </div> 
  <div>
   这个函数使用了shim的接口函数GetStateByRange通过两个区间函数startKey和endKey来返回之间的账本数据。
   <br> &nbsp;&nbsp;&nbsp;我们分别定义了CAR0到CAR999的键。因此, 如果键被正确使用的话,我们可以存储1000辆车,而且queryAllCars会列出每一辆车。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;下面的图片展示了程序如何智能合约（chaincode）的不同的函数。
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <img alt="" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171106153359207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejcxNDMwMzU4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   在上图中我们可以看到我们的queryAllCars, 还有一个createCar。createCar函数允许我们更新账本。createCar最终将一个新的块添加到区块链中。
   <br> &nbsp;&nbsp;&nbsp;但是首先我们先做另一个查询。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;回到我们的query.js程序，编辑query.js的构造请求去查询一个特殊的车辆。&nbsp; 我们将会修改queryAllCars为queryCar,并且指定一个Key作为参数（这里我们
   <br> &nbsp;&nbsp;&nbsp;使用CAR4）。我们编辑query.js成下面这样。
   <br> &nbsp;&nbsp;&nbsp;const request = {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: transaction_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: 'queryCar',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: ['CAR4']
   <br> &nbsp;&nbsp;&nbsp;保存程序并返回fabcar目录下。然后再次运行程序：
   <br> &nbsp;&nbsp;&nbsp;node query.js
   <br> &nbsp;&nbsp;&nbsp;你应该看到如下的数据：
   <br> &nbsp;&nbsp;&nbsp;{"colour":"black","make":"Tesla","model":"S","owner":"Adriana"}
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;现在我们已经从查询所有到查询指定的一条。 使用queryCar函数，我们可以查询任意Key获取其映射的数据。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;非常好， 现在你应该能使用智能合约（chaincode）的基础函数用来查询并且可以传递查询参数了。
   <br> &nbsp;&nbsp;&nbsp;
   <br> Updating the Ledger
   <br> 更新账本。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;现在我们已经做过了账本查询并且修改了一点点代码， 我们已经做好了更新账本的准本。 
   <br> &nbsp;&nbsp;&nbsp;我们可以对账本做很多更新，但是前提是我们得有数据来更新。所以首先我们来创建一辆车（一条数据）。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;账本更新从一个事务的生成开始。 就像查询一样， 一个请求需要一个唯一的channelID， 调用函数和智能合约才能被创建，并且需要将这些数据传递。
   <br> &nbsp;&nbsp;&nbsp;然后程序将调用channel.SendTransactionProposal API 将事务发送给peer获得建议（endorsement）。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;Fabric 返回一个请求响应，应用程序使用它来创建和提交一个事务请求。这个请求通过调用channel.sendTransaction API 发送到 排序服务
   <br> &nbsp;&nbsp;&nbsp;（The Ordering Service）。排序服务（The Ordering Service）将此事务绑定到一个块中， 然后将该块发送给所有对等的节点上去认证
   <br> &nbsp;&nbsp;&nbsp;（我们的例子中仅有一个节点）。
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;最终程序会调用eh.setPeerAddr去链接节点的事件监听端口并且调用eh.registerTxEvent去注册时间关联到事务的ID。这个API允许程序去获取
   <br> &nbsp;&nbsp;&nbsp;交易的流程（成功（successfully）, committed(已提交)或者未成功（unsuccessful））。把他想象成为一个通知机制。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;注意： 我们不会深入的了解事务的生命周期。你可以查阅事务流程（Transaction Flow）文档来了解如何提交事务给账本的底层细节。
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;我们最初的调用是建立一项新的资产（也就是一辆车）。我们有一个单独的程序 - invoke.js -我们将使用这些事务。就像查询（query.js）一样,
   <br> &nbsp;&nbsp;&nbsp;我们使用编辑工具打开invoke.js 并找到构造调用API的代码：
   <br> &nbsp;&nbsp;&nbsp;// createCar - requires 5 args, ex: args: ['CAR11', 'Honda', 'Accord', 'Black', 'Tom
   <br> &nbsp;&nbsp;&nbsp;&nbsp;˓→ '],
   <br> &nbsp;&nbsp;&nbsp;&nbsp;// changeCarOwner - requires 2 args , ex: args: ['CAR10', 'Barry'],
   <br> &nbsp;&nbsp;&nbsp;&nbsp;// send proposal to endorser
   <br> &nbsp;&nbsp;&nbsp;&nbsp;var request = {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;targets: targets,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;fcn: '',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;args: [''],
   <br> &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;你将会看到我们调用两个函数 createCar和changeCarOwner. 让我们创建一辆红色的Chevy Volt，并且将他的拥有者设置为 Nick. 我们的账本的唯一标识的最顶端
   <br> &nbsp;&nbsp;&nbsp;是CAR9， 所以我们将用CAR10. 更改代码块像下面这样：
   <br> &nbsp;&nbsp;&nbsp;var request = {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;targets: targets,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;fcn: 'createCar',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
   <br> &nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;保存并运行它：
   <br> &nbsp;&nbsp;&nbsp;&nbsp;node invoke.js
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;你的控制台终将会输出响应和事务ID。当我们看到这条信息的时候：
   <br> &nbsp;&nbsp;&nbsp;&nbsp;The transaction has been committed on peer localhost:7053
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;节点会发出事件通知，我们通过eh.registerTxEvent去接受通知。所以现在如果我们重复去运行query.js的话我们是可以查询到CAR10的。
   <br> &nbsp;&nbsp;&nbsp;我们应该会看到如下结果：
   <br> &nbsp;&nbsp;&nbsp;&nbsp;Response is {"colour":"Red","make":"Chevy","model":"Volt","owner":"Nick"}
   <br> &nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;最后让我们调用我们最后一个函数： changeCarOwner。 Nick是非常慷慨大方的，它准备将他的车送个一个叫Barry的朋友。所以我们简单
   <br> &nbsp;&nbsp;&nbsp;的修改一下我们的invoke.js
   <br> &nbsp;&nbsp;&nbsp;&nbsp;var request = {
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets: targets
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeId: options.chaincode_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcn: 'changeCarOwner',
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args: ['CAR10', 'Barry'],
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainId: options.channel_id,
   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txId: tx_id
   <br> &nbsp;&nbsp;&nbsp;再次运行程序 - node invoke.js - 然后再运行query.js。 我们将看到CAR10, 我们看到的是修改后的：
   <br> &nbsp;&nbsp;&nbsp;&nbsp;Response is {"colour":"Red","make":"Chevy","model":"Volt","owner":"Barry"}
  </div> 
  <div>
   <br> Additional Resources&nbsp;&nbsp;
   <br> 附加资源
   <br> &nbsp;&nbsp;&nbsp;Hyperledger Fabric Node SDK repo 中有更多的优秀的资源和实例代码。当然你也可以咨询Hyperledger FAbric的社区。
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br> &nbsp;&nbsp;&nbsp;&nbsp;
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/z714303584/article/details/78367380,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/z714303584/article/details/78367380,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
