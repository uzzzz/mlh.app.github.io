<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>量化投资:第4节 多支股票择时回测与仓位管理 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="量化投资:第4节 多支股票择时回测与仓位管理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 之前的章节无论讲解策略优化，还是针对回测进行滑点或是手续费都是针对一支股票进行择时操作。 本节将示例讲解多支股票进行择时策略的实现，依然使用AbuFactorBuyBreak做为买入策略，其它四个卖出策略同时生效的组合。 from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1. 多支股票使用相同的因子进行择时 选择的股票如下所示： choice_symbols = [‘usTSLA’, ‘usNOAH’, ‘usSFUN’, ‘usBIDU’, ‘usAAPL’, ‘usGOOG’, ‘usWUBA’, ‘usVIPS’] 备注：本节示例都基于美股市场，针对A股市场及港股市场，比特币，期货市场后在后面的章节讲解 # 我们假定choice_symbols是我们选股模块的结果， choice_symbols = [&#39;usTSLA&#39;, &#39;usNOAH&#39;, &#39;usSFUN&#39;, &#39;usBIDU&#39;, &#39;usAAPL&#39;, &#39;usGOOG&#39;, &#39;usWUBA&#39;, &#39;usVIPS&#39;] 使用ABuPickTimeExecute.do_symbols_with_same_factors()函数对多支股票使用相同的买入因子，卖出因子 %%time capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors, sell_factors, capital, show=False) CPU times: user 18.5 s, sys: 264 ms, total: 20.1 s Wall time: 19.2 s 运行完毕，使用了ipython的magic code %%time去统计代码块运行时间，显示运行了19.2 s，本节最后会使用多进程模式运行相同的回测，会和这个时间进行比较。 备注：具体实际运行时间根据cpu的性能确定 下面代码显示orders_pd中前10个交易数据： orders_pd[:10] 通过buy_cnt列可以发现每次交易数量都不一样，由于内部有资金管理控制模块默认使用atr进行仓位控制 默认资金管理控制使用AbuAtrPosition，详情请阅读源代码，下面会有自定义仓位管理的示例。 下面代码显示action_pd中前10个行为数据： action_pd[:10] 注意deal列代表了交易是否成交，由于内部有资金管理控制模块，所以不是所有交易信号都可以最后成交。 下面我们使用abu量化系统度量模块对整体结果做个度量，如下图所示（之后章节会对度量方法及模块进行详细讲解，这里请先简单使用即可）。 from abupy import AbuMetricsBase metrics = AbuMetricsBase(orders_pd, action_pd, capital, benchmark) metrics.fit_metrics() metrics.plot_returns_cmp(only_show_returns=True) 买入后卖出的交易数量:67 买入后尚未卖出的交易数量:3 胜率:43.2836% 平均获利期望:12.2712% 平均亏损期望:-4.9050% 盈亏比:1.9327 策略收益: 29.4383% 基准收益: 15.0841% 策略年化收益: 14.7192% 基准年化收益: 7.5420% 策略买入成交比例:84.2857% 策略资金利用率比例:22.3612% 策略共执行504个交易日 2. 自定义仓位管理策略的实现 上面使用AbuMetricsBase进行度量，我们计算出： 胜率:41.79% 平均获利期望:12.01% 平均亏损期望:-4.91% 有这三个参数就可以使用kelly公式来做仓位控制，AbuKellyPosition实现如下： class AbuKellyPosition(AbuPositionBase): &quot;&quot;&quot;示例kelly仓位管理类&quot;&quot;&quot; def fit_position(self, factor_object): &quot;&quot;&quot; fit_position计算的结果是买入多少个单位（股，手，顿，合约） 需要factor_object策略因子对象通过历史回测统计胜率，期望收益，期望亏损， 并设置构造当前factor_object对象，通过kelly公司计算仓位 :param factor_object: ABuFactorBuyBases子类实例对象 :return:买入多少个单位（股，手，顿，合约） &quot;&quot;&quot; # 败率 loss_rate = 1 - self.win_rate # kelly计算出仓位比例 kelly_pos = self.win_rate - loss_rate / (self.gains_mean / self.losses_mean) # 最大仓位限制，依然受上层最大仓位控制限制，eg：如果kelly计算出全仓，依然会减少到75%，如修改需要修改最大仓位值 kelly_pos = self.pos_max if kelly_pos &gt; self.pos_max else kelly_pos # 结果是买入多少个单位（股，手，顿，合约） return self.read_cash * kelly_pos / self.bp * self.deposit_rate def _init_self(self, **kwargs): &quot;&quot;&quot;kelly仓位控制管理类初始化设置&quot;&quot;&quot; # 默认kelly仓位胜率0.50 self.win_rate = kwargs.pop(&#39;win_rate&#39;, 0.50) # 默认平均获利期望0.10 self.gains_mean = kwargs.pop(&#39;gains_mean&#39;, 0.10) # 默认平均亏损期望0.05 self.losses_mean = kwargs.pop(&#39;losses_mean&#39;, 0.05) &quot;&quot;&quot;以默认的设置kelly根据计算0.5 - 0.5 / (0.10 / 0.05) 仓位将是0.25即25%&quot;&quot;&quot; 自定义仓位管理代码如上AbuKellyPosition： 仓位管理类需要继承AbuPositionBase 仓位管理类主要需要实现函数fit_position，即根据买入价格，本金基数等融合买入策略对买入单位进行计算 仓位管理类主要需要实现函数_init_self，外部通过字典参数将胜率等参数进行关键子参数设置（详见后使用示例） 更多资金管理代码请阅读AbuPositionBase 下面编写buy_factors2，其42d突破使用position＝AbuKellyPosition 参数胜率：metrics.win_rate(41.79%) 期望收益：metrics.gains_mean(12.01%) 期望亏损：metrics.losses_mean(-4.91%)， 代码如下所示： from abupy import AbuKellyPosition # 42d使用刚刚编写的AbuKellyPosition，60d仍然使用默认仓位管理类，即abupy中内置的AbuAtrPosition类 buy_factors2 = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;position&#39;: {&#39;class&#39;: AbuKellyPosition, &#39;win_rate&#39;: metrics.win_rate, &#39;gains_mean&#39;: metrics.gains_mean, &#39;losses_mean&#39;: -metrics.losses_mean}, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors2, sell_factors, capital, show=False) 从输出生成的orders_pd中可以看到buy Pos列所有42d突破都使用了AbuKellyPosition，60d仍然使用AbuAtrPosition orders_pd[:10].filter([&#39;symbol&#39;, &#39;buy_cnt&#39;, &#39;buy_factor&#39;, &#39;buy_pos&#39;]) 3. 多支股票使用不同的因子进行择时 使用ABuPickTimeExecute.do_symbols_with_diff_factors()函数针对不同的股票使用不同的买入因子和不同的卖出因子， 具体实现请查阅源代码ABuPickTimeExecute，使用示例如下： # 选定noah和sfun target_symbols = [&#39;usSFUN&#39;, &#39;usNOAH&#39;] # 针对sfun只使用42d向上突破作为买入因子 buy_factors_sfun = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 针对sfun只使用60d向下突破作为卖出因子 sell_factors_sfun = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorSellBreak}] # 针对noah只使用21d向上突破作为买入因子 buy_factors_noah = [{&#39;xd&#39;: 21, &#39;class&#39;: AbuFactorBuyBreak}] # 针对noah只使用42d向下突破作为卖出因子 sell_factors_noah = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorSellBreak}] factor_dict = dict() # 构建SFUN独立的buy_factors，sell_factors的dict factor_dict[&#39;usSFUN&#39;] = {&#39;buy_factors&#39;: buy_factors_sfun, &#39;sell_factors&#39;: sell_factors_sfun} # 构建NOAH独立的buy_factors，sell_factors的dict factor_dict[&#39;usNOAH&#39;] = {&#39;buy_factors&#39;: buy_factors_noah, &#39;sell_factors&#39;: sell_factors_noah} # 初始化资金 capital = AbuCapital(1000000, benchmark) # 使用do_symbols_with_diff_factors执行 orders_pd, action_pd, all_fit_symbols = ABuPickTimeExecute.do_symbols_with_diff_factors(target_symbols, benchmark, factor_dict, capital) 如下代码通过pandas的交叉表来分析输出的orders_pd， 来证明: noah买入因子全部是使用21d向上突破，sfun买入因子全部是使用42d向上突破： pd.crosstab(orders_pd.buy_factor, orders_pd.symbol) 4. 使用并行来提升择时运行效率 当你选择的股票非常多的时候，比如很多时候是对全市场进行回测，那就需要多进程并行来提升运行效率，AbuPickTimeMaster.do_symbols_with_same_factors_process()函数通过定义n_process_kl（同时获取股票数据的进程数）和n_process_pick_time（同时进行择时的进程数）来完成操作. 具体实现代码请阅读AbuPickTimeMaster，使用示例如下所示： %%time from abupy import AbuPickTimeMaster capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = AbuPickTimeMaster.do_symbols_with_same_factors_process( choice_symbols, benchmark, buy_factors, sell_factors, capital, n_process_kl=4, n_process_pick_time=4) pid:12502 gen kl_pd complete:100.0% pid:12503 gen kl_pd complete:100.0% pid:12504 gen kl_pd complete:100.0% pid:12505 gen kl_pd complete:100.0% pid:12506 gen kl_pd complete:100.0% pid:12507 gen kl_pd complete:100.0% pid:12508 gen kl_pd complete:100.0% pid:12509 gen kl_pd complete:100.0% pid:12503 done! pid:12505 done! pid:12506 done! pid:12507 done! pid:12504 done! pid:12502 done! pid:12509 done! pid:12508 done! pid:12510 pick times complete:100.0% pid:12511 pick times complete:100.0% pid:12512 pick times complete:100.0% pid:12513 pick times complete:100.0% pid:12514 pick times complete:100.0% pid:12515 pick times complete:100.0% pid:12516 pick times complete:100.0% pid:12517 pick times complete:100.0% pid:12510 done! pid:12512 done! pid:12515 done! pid:12513 done! pid:12511 done! pid:12514 done! pid:12517 done! pid:12516 done! CPU times: user 2.48 s, sys: 192 ms, total: 2.67 s Wall time: 6.36s 依然使用%%time度量代码块运行时间，之前使用开始时使用ABuPickTimeExecute运行相同的回测输出运行时间19.2 s， 使用AbuPickTimeMaster使用参数n_process_pick_time=8，即启动8个择时进程后，运行时间缩短到6.36s，从输出的信息也可以看到8个pid同时进行 择时 pid:84544 pick times complete:100.0% pid:84545 pick times complete:100.0% pid:84546 pick times complete:100.0% pid:84547 pick times complete:100.0% pid:84548 pick times complete:100.0% pid:84549 pick times complete:100.0% pid:84550 pick times complete:100.0% pid:84551 pick times complete:100.0% 多进程的运行方式在进行多支股票设置全市场策略回测时是非常有用的，本节由于choice_symbols中的股票数少，n_process_kl即并行金融数据采集模块 并没有使用，还有一些需要注意的地方也还没有讲到，在后续的全市场回测章节讲继续讲解。 备注: 由于本例开辟进程数较多，但是每个进程处理的任务非常少，所以在cpu不够快的电脑上结果可能正好相反，多进程模式的运行也行会更加耗时，效率更低，属正常现象，后面的例子每个进程可能会处理几十几百个交易对象就不会出现创建销毁进程的开销大于任务执行时间的情况 特别是windows系统，mac上不会发生，由于mac上的并行使用joblib，在windows上长任务joblib存在bug，所以windows上并行只是封装为joblib的接口形式，详情阅读源代码ABuParallel abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多" />
<meta property="og:description" content="作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 之前的章节无论讲解策略优化，还是针对回测进行滑点或是手续费都是针对一支股票进行择时操作。 本节将示例讲解多支股票进行择时策略的实现，依然使用AbuFactorBuyBreak做为买入策略，其它四个卖出策略同时生效的组合。 from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1. 多支股票使用相同的因子进行择时 选择的股票如下所示： choice_symbols = [‘usTSLA’, ‘usNOAH’, ‘usSFUN’, ‘usBIDU’, ‘usAAPL’, ‘usGOOG’, ‘usWUBA’, ‘usVIPS’] 备注：本节示例都基于美股市场，针对A股市场及港股市场，比特币，期货市场后在后面的章节讲解 # 我们假定choice_symbols是我们选股模块的结果， choice_symbols = [&#39;usTSLA&#39;, &#39;usNOAH&#39;, &#39;usSFUN&#39;, &#39;usBIDU&#39;, &#39;usAAPL&#39;, &#39;usGOOG&#39;, &#39;usWUBA&#39;, &#39;usVIPS&#39;] 使用ABuPickTimeExecute.do_symbols_with_same_factors()函数对多支股票使用相同的买入因子，卖出因子 %%time capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors, sell_factors, capital, show=False) CPU times: user 18.5 s, sys: 264 ms, total: 20.1 s Wall time: 19.2 s 运行完毕，使用了ipython的magic code %%time去统计代码块运行时间，显示运行了19.2 s，本节最后会使用多进程模式运行相同的回测，会和这个时间进行比较。 备注：具体实际运行时间根据cpu的性能确定 下面代码显示orders_pd中前10个交易数据： orders_pd[:10] 通过buy_cnt列可以发现每次交易数量都不一样，由于内部有资金管理控制模块默认使用atr进行仓位控制 默认资金管理控制使用AbuAtrPosition，详情请阅读源代码，下面会有自定义仓位管理的示例。 下面代码显示action_pd中前10个行为数据： action_pd[:10] 注意deal列代表了交易是否成交，由于内部有资金管理控制模块，所以不是所有交易信号都可以最后成交。 下面我们使用abu量化系统度量模块对整体结果做个度量，如下图所示（之后章节会对度量方法及模块进行详细讲解，这里请先简单使用即可）。 from abupy import AbuMetricsBase metrics = AbuMetricsBase(orders_pd, action_pd, capital, benchmark) metrics.fit_metrics() metrics.plot_returns_cmp(only_show_returns=True) 买入后卖出的交易数量:67 买入后尚未卖出的交易数量:3 胜率:43.2836% 平均获利期望:12.2712% 平均亏损期望:-4.9050% 盈亏比:1.9327 策略收益: 29.4383% 基准收益: 15.0841% 策略年化收益: 14.7192% 基准年化收益: 7.5420% 策略买入成交比例:84.2857% 策略资金利用率比例:22.3612% 策略共执行504个交易日 2. 自定义仓位管理策略的实现 上面使用AbuMetricsBase进行度量，我们计算出： 胜率:41.79% 平均获利期望:12.01% 平均亏损期望:-4.91% 有这三个参数就可以使用kelly公式来做仓位控制，AbuKellyPosition实现如下： class AbuKellyPosition(AbuPositionBase): &quot;&quot;&quot;示例kelly仓位管理类&quot;&quot;&quot; def fit_position(self, factor_object): &quot;&quot;&quot; fit_position计算的结果是买入多少个单位（股，手，顿，合约） 需要factor_object策略因子对象通过历史回测统计胜率，期望收益，期望亏损， 并设置构造当前factor_object对象，通过kelly公司计算仓位 :param factor_object: ABuFactorBuyBases子类实例对象 :return:买入多少个单位（股，手，顿，合约） &quot;&quot;&quot; # 败率 loss_rate = 1 - self.win_rate # kelly计算出仓位比例 kelly_pos = self.win_rate - loss_rate / (self.gains_mean / self.losses_mean) # 最大仓位限制，依然受上层最大仓位控制限制，eg：如果kelly计算出全仓，依然会减少到75%，如修改需要修改最大仓位值 kelly_pos = self.pos_max if kelly_pos &gt; self.pos_max else kelly_pos # 结果是买入多少个单位（股，手，顿，合约） return self.read_cash * kelly_pos / self.bp * self.deposit_rate def _init_self(self, **kwargs): &quot;&quot;&quot;kelly仓位控制管理类初始化设置&quot;&quot;&quot; # 默认kelly仓位胜率0.50 self.win_rate = kwargs.pop(&#39;win_rate&#39;, 0.50) # 默认平均获利期望0.10 self.gains_mean = kwargs.pop(&#39;gains_mean&#39;, 0.10) # 默认平均亏损期望0.05 self.losses_mean = kwargs.pop(&#39;losses_mean&#39;, 0.05) &quot;&quot;&quot;以默认的设置kelly根据计算0.5 - 0.5 / (0.10 / 0.05) 仓位将是0.25即25%&quot;&quot;&quot; 自定义仓位管理代码如上AbuKellyPosition： 仓位管理类需要继承AbuPositionBase 仓位管理类主要需要实现函数fit_position，即根据买入价格，本金基数等融合买入策略对买入单位进行计算 仓位管理类主要需要实现函数_init_self，外部通过字典参数将胜率等参数进行关键子参数设置（详见后使用示例） 更多资金管理代码请阅读AbuPositionBase 下面编写buy_factors2，其42d突破使用position＝AbuKellyPosition 参数胜率：metrics.win_rate(41.79%) 期望收益：metrics.gains_mean(12.01%) 期望亏损：metrics.losses_mean(-4.91%)， 代码如下所示： from abupy import AbuKellyPosition # 42d使用刚刚编写的AbuKellyPosition，60d仍然使用默认仓位管理类，即abupy中内置的AbuAtrPosition类 buy_factors2 = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;position&#39;: {&#39;class&#39;: AbuKellyPosition, &#39;win_rate&#39;: metrics.win_rate, &#39;gains_mean&#39;: metrics.gains_mean, &#39;losses_mean&#39;: -metrics.losses_mean}, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors2, sell_factors, capital, show=False) 从输出生成的orders_pd中可以看到buy Pos列所有42d突破都使用了AbuKellyPosition，60d仍然使用AbuAtrPosition orders_pd[:10].filter([&#39;symbol&#39;, &#39;buy_cnt&#39;, &#39;buy_factor&#39;, &#39;buy_pos&#39;]) 3. 多支股票使用不同的因子进行择时 使用ABuPickTimeExecute.do_symbols_with_diff_factors()函数针对不同的股票使用不同的买入因子和不同的卖出因子， 具体实现请查阅源代码ABuPickTimeExecute，使用示例如下： # 选定noah和sfun target_symbols = [&#39;usSFUN&#39;, &#39;usNOAH&#39;] # 针对sfun只使用42d向上突破作为买入因子 buy_factors_sfun = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 针对sfun只使用60d向下突破作为卖出因子 sell_factors_sfun = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorSellBreak}] # 针对noah只使用21d向上突破作为买入因子 buy_factors_noah = [{&#39;xd&#39;: 21, &#39;class&#39;: AbuFactorBuyBreak}] # 针对noah只使用42d向下突破作为卖出因子 sell_factors_noah = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorSellBreak}] factor_dict = dict() # 构建SFUN独立的buy_factors，sell_factors的dict factor_dict[&#39;usSFUN&#39;] = {&#39;buy_factors&#39;: buy_factors_sfun, &#39;sell_factors&#39;: sell_factors_sfun} # 构建NOAH独立的buy_factors，sell_factors的dict factor_dict[&#39;usNOAH&#39;] = {&#39;buy_factors&#39;: buy_factors_noah, &#39;sell_factors&#39;: sell_factors_noah} # 初始化资金 capital = AbuCapital(1000000, benchmark) # 使用do_symbols_with_diff_factors执行 orders_pd, action_pd, all_fit_symbols = ABuPickTimeExecute.do_symbols_with_diff_factors(target_symbols, benchmark, factor_dict, capital) 如下代码通过pandas的交叉表来分析输出的orders_pd， 来证明: noah买入因子全部是使用21d向上突破，sfun买入因子全部是使用42d向上突破： pd.crosstab(orders_pd.buy_factor, orders_pd.symbol) 4. 使用并行来提升择时运行效率 当你选择的股票非常多的时候，比如很多时候是对全市场进行回测，那就需要多进程并行来提升运行效率，AbuPickTimeMaster.do_symbols_with_same_factors_process()函数通过定义n_process_kl（同时获取股票数据的进程数）和n_process_pick_time（同时进行择时的进程数）来完成操作. 具体实现代码请阅读AbuPickTimeMaster，使用示例如下所示： %%time from abupy import AbuPickTimeMaster capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = AbuPickTimeMaster.do_symbols_with_same_factors_process( choice_symbols, benchmark, buy_factors, sell_factors, capital, n_process_kl=4, n_process_pick_time=4) pid:12502 gen kl_pd complete:100.0% pid:12503 gen kl_pd complete:100.0% pid:12504 gen kl_pd complete:100.0% pid:12505 gen kl_pd complete:100.0% pid:12506 gen kl_pd complete:100.0% pid:12507 gen kl_pd complete:100.0% pid:12508 gen kl_pd complete:100.0% pid:12509 gen kl_pd complete:100.0% pid:12503 done! pid:12505 done! pid:12506 done! pid:12507 done! pid:12504 done! pid:12502 done! pid:12509 done! pid:12508 done! pid:12510 pick times complete:100.0% pid:12511 pick times complete:100.0% pid:12512 pick times complete:100.0% pid:12513 pick times complete:100.0% pid:12514 pick times complete:100.0% pid:12515 pick times complete:100.0% pid:12516 pick times complete:100.0% pid:12517 pick times complete:100.0% pid:12510 done! pid:12512 done! pid:12515 done! pid:12513 done! pid:12511 done! pid:12514 done! pid:12517 done! pid:12516 done! CPU times: user 2.48 s, sys: 192 ms, total: 2.67 s Wall time: 6.36s 依然使用%%time度量代码块运行时间，之前使用开始时使用ABuPickTimeExecute运行相同的回测输出运行时间19.2 s， 使用AbuPickTimeMaster使用参数n_process_pick_time=8，即启动8个择时进程后，运行时间缩短到6.36s，从输出的信息也可以看到8个pid同时进行 择时 pid:84544 pick times complete:100.0% pid:84545 pick times complete:100.0% pid:84546 pick times complete:100.0% pid:84547 pick times complete:100.0% pid:84548 pick times complete:100.0% pid:84549 pick times complete:100.0% pid:84550 pick times complete:100.0% pid:84551 pick times complete:100.0% 多进程的运行方式在进行多支股票设置全市场策略回测时是非常有用的，本节由于choice_symbols中的股票数少，n_process_kl即并行金融数据采集模块 并没有使用，还有一些需要注意的地方也还没有讲到，在后续的全市场回测章节讲继续讲解。 备注: 由于本例开辟进程数较多，但是每个进程处理的任务非常少，所以在cpu不够快的电脑上结果可能正好相反，多进程模式的运行也行会更加耗时，效率更低，属正常现象，后面的例子每个进程可能会处理几十几百个交易对象就不会出现创建销毁进程的开销大于任务执行时间的情况 特别是windows系统，mac上不会发生，由于mac上的并行使用joblib，在windows上长任务joblib存在bug，所以windows上并行只是封装为joblib的接口形式，详情阅读源代码ABuParallel abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 之前的章节无论讲解策略优化，还是针对回测进行滑点或是手续费都是针对一支股票进行择时操作。 本节将示例讲解多支股票进行择时策略的实现，依然使用AbuFactorBuyBreak做为买入策略，其它四个卖出策略同时生效的组合。 from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1. 多支股票使用相同的因子进行择时 选择的股票如下所示： choice_symbols = [‘usTSLA’, ‘usNOAH’, ‘usSFUN’, ‘usBIDU’, ‘usAAPL’, ‘usGOOG’, ‘usWUBA’, ‘usVIPS’] 备注：本节示例都基于美股市场，针对A股市场及港股市场，比特币，期货市场后在后面的章节讲解 # 我们假定choice_symbols是我们选股模块的结果， choice_symbols = [&#39;usTSLA&#39;, &#39;usNOAH&#39;, &#39;usSFUN&#39;, &#39;usBIDU&#39;, &#39;usAAPL&#39;, &#39;usGOOG&#39;, &#39;usWUBA&#39;, &#39;usVIPS&#39;] 使用ABuPickTimeExecute.do_symbols_with_same_factors()函数对多支股票使用相同的买入因子，卖出因子 %%time capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors, sell_factors, capital, show=False) CPU times: user 18.5 s, sys: 264 ms, total: 20.1 s Wall time: 19.2 s 运行完毕，使用了ipython的magic code %%time去统计代码块运行时间，显示运行了19.2 s，本节最后会使用多进程模式运行相同的回测，会和这个时间进行比较。 备注：具体实际运行时间根据cpu的性能确定 下面代码显示orders_pd中前10个交易数据： orders_pd[:10] 通过buy_cnt列可以发现每次交易数量都不一样，由于内部有资金管理控制模块默认使用atr进行仓位控制 默认资金管理控制使用AbuAtrPosition，详情请阅读源代码，下面会有自定义仓位管理的示例。 下面代码显示action_pd中前10个行为数据： action_pd[:10] 注意deal列代表了交易是否成交，由于内部有资金管理控制模块，所以不是所有交易信号都可以最后成交。 下面我们使用abu量化系统度量模块对整体结果做个度量，如下图所示（之后章节会对度量方法及模块进行详细讲解，这里请先简单使用即可）。 from abupy import AbuMetricsBase metrics = AbuMetricsBase(orders_pd, action_pd, capital, benchmark) metrics.fit_metrics() metrics.plot_returns_cmp(only_show_returns=True) 买入后卖出的交易数量:67 买入后尚未卖出的交易数量:3 胜率:43.2836% 平均获利期望:12.2712% 平均亏损期望:-4.9050% 盈亏比:1.9327 策略收益: 29.4383% 基准收益: 15.0841% 策略年化收益: 14.7192% 基准年化收益: 7.5420% 策略买入成交比例:84.2857% 策略资金利用率比例:22.3612% 策略共执行504个交易日 2. 自定义仓位管理策略的实现 上面使用AbuMetricsBase进行度量，我们计算出： 胜率:41.79% 平均获利期望:12.01% 平均亏损期望:-4.91% 有这三个参数就可以使用kelly公式来做仓位控制，AbuKellyPosition实现如下： class AbuKellyPosition(AbuPositionBase): &quot;&quot;&quot;示例kelly仓位管理类&quot;&quot;&quot; def fit_position(self, factor_object): &quot;&quot;&quot; fit_position计算的结果是买入多少个单位（股，手，顿，合约） 需要factor_object策略因子对象通过历史回测统计胜率，期望收益，期望亏损， 并设置构造当前factor_object对象，通过kelly公司计算仓位 :param factor_object: ABuFactorBuyBases子类实例对象 :return:买入多少个单位（股，手，顿，合约） &quot;&quot;&quot; # 败率 loss_rate = 1 - self.win_rate # kelly计算出仓位比例 kelly_pos = self.win_rate - loss_rate / (self.gains_mean / self.losses_mean) # 最大仓位限制，依然受上层最大仓位控制限制，eg：如果kelly计算出全仓，依然会减少到75%，如修改需要修改最大仓位值 kelly_pos = self.pos_max if kelly_pos &gt; self.pos_max else kelly_pos # 结果是买入多少个单位（股，手，顿，合约） return self.read_cash * kelly_pos / self.bp * self.deposit_rate def _init_self(self, **kwargs): &quot;&quot;&quot;kelly仓位控制管理类初始化设置&quot;&quot;&quot; # 默认kelly仓位胜率0.50 self.win_rate = kwargs.pop(&#39;win_rate&#39;, 0.50) # 默认平均获利期望0.10 self.gains_mean = kwargs.pop(&#39;gains_mean&#39;, 0.10) # 默认平均亏损期望0.05 self.losses_mean = kwargs.pop(&#39;losses_mean&#39;, 0.05) &quot;&quot;&quot;以默认的设置kelly根据计算0.5 - 0.5 / (0.10 / 0.05) 仓位将是0.25即25%&quot;&quot;&quot; 自定义仓位管理代码如上AbuKellyPosition： 仓位管理类需要继承AbuPositionBase 仓位管理类主要需要实现函数fit_position，即根据买入价格，本金基数等融合买入策略对买入单位进行计算 仓位管理类主要需要实现函数_init_self，外部通过字典参数将胜率等参数进行关键子参数设置（详见后使用示例） 更多资金管理代码请阅读AbuPositionBase 下面编写buy_factors2，其42d突破使用position＝AbuKellyPosition 参数胜率：metrics.win_rate(41.79%) 期望收益：metrics.gains_mean(12.01%) 期望亏损：metrics.losses_mean(-4.91%)， 代码如下所示： from abupy import AbuKellyPosition # 42d使用刚刚编写的AbuKellyPosition，60d仍然使用默认仓位管理类，即abupy中内置的AbuAtrPosition类 buy_factors2 = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;position&#39;: {&#39;class&#39;: AbuKellyPosition, &#39;win_rate&#39;: metrics.win_rate, &#39;gains_mean&#39;: metrics.gains_mean, &#39;losses_mean&#39;: -metrics.losses_mean}, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols, benchmark, buy_factors2, sell_factors, capital, show=False) 从输出生成的orders_pd中可以看到buy Pos列所有42d突破都使用了AbuKellyPosition，60d仍然使用AbuAtrPosition orders_pd[:10].filter([&#39;symbol&#39;, &#39;buy_cnt&#39;, &#39;buy_factor&#39;, &#39;buy_pos&#39;]) 3. 多支股票使用不同的因子进行择时 使用ABuPickTimeExecute.do_symbols_with_diff_factors()函数针对不同的股票使用不同的买入因子和不同的卖出因子， 具体实现请查阅源代码ABuPickTimeExecute，使用示例如下： # 选定noah和sfun target_symbols = [&#39;usSFUN&#39;, &#39;usNOAH&#39;] # 针对sfun只使用42d向上突破作为买入因子 buy_factors_sfun = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 针对sfun只使用60d向下突破作为卖出因子 sell_factors_sfun = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorSellBreak}] # 针对noah只使用21d向上突破作为买入因子 buy_factors_noah = [{&#39;xd&#39;: 21, &#39;class&#39;: AbuFactorBuyBreak}] # 针对noah只使用42d向下突破作为卖出因子 sell_factors_noah = [{&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorSellBreak}] factor_dict = dict() # 构建SFUN独立的buy_factors，sell_factors的dict factor_dict[&#39;usSFUN&#39;] = {&#39;buy_factors&#39;: buy_factors_sfun, &#39;sell_factors&#39;: sell_factors_sfun} # 构建NOAH独立的buy_factors，sell_factors的dict factor_dict[&#39;usNOAH&#39;] = {&#39;buy_factors&#39;: buy_factors_noah, &#39;sell_factors&#39;: sell_factors_noah} # 初始化资金 capital = AbuCapital(1000000, benchmark) # 使用do_symbols_with_diff_factors执行 orders_pd, action_pd, all_fit_symbols = ABuPickTimeExecute.do_symbols_with_diff_factors(target_symbols, benchmark, factor_dict, capital) 如下代码通过pandas的交叉表来分析输出的orders_pd， 来证明: noah买入因子全部是使用21d向上突破，sfun买入因子全部是使用42d向上突破： pd.crosstab(orders_pd.buy_factor, orders_pd.symbol) 4. 使用并行来提升择时运行效率 当你选择的股票非常多的时候，比如很多时候是对全市场进行回测，那就需要多进程并行来提升运行效率，AbuPickTimeMaster.do_symbols_with_same_factors_process()函数通过定义n_process_kl（同时获取股票数据的进程数）和n_process_pick_time（同时进行择时的进程数）来完成操作. 具体实现代码请阅读AbuPickTimeMaster，使用示例如下所示： %%time from abupy import AbuPickTimeMaster capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = AbuPickTimeMaster.do_symbols_with_same_factors_process( choice_symbols, benchmark, buy_factors, sell_factors, capital, n_process_kl=4, n_process_pick_time=4) pid:12502 gen kl_pd complete:100.0% pid:12503 gen kl_pd complete:100.0% pid:12504 gen kl_pd complete:100.0% pid:12505 gen kl_pd complete:100.0% pid:12506 gen kl_pd complete:100.0% pid:12507 gen kl_pd complete:100.0% pid:12508 gen kl_pd complete:100.0% pid:12509 gen kl_pd complete:100.0% pid:12503 done! pid:12505 done! pid:12506 done! pid:12507 done! pid:12504 done! pid:12502 done! pid:12509 done! pid:12508 done! pid:12510 pick times complete:100.0% pid:12511 pick times complete:100.0% pid:12512 pick times complete:100.0% pid:12513 pick times complete:100.0% pid:12514 pick times complete:100.0% pid:12515 pick times complete:100.0% pid:12516 pick times complete:100.0% pid:12517 pick times complete:100.0% pid:12510 done! pid:12512 done! pid:12515 done! pid:12513 done! pid:12511 done! pid:12514 done! pid:12517 done! pid:12516 done! CPU times: user 2.48 s, sys: 192 ms, total: 2.67 s Wall time: 6.36s 依然使用%%time度量代码块运行时间，之前使用开始时使用ABuPickTimeExecute运行相同的回测输出运行时间19.2 s， 使用AbuPickTimeMaster使用参数n_process_pick_time=8，即启动8个择时进程后，运行时间缩短到6.36s，从输出的信息也可以看到8个pid同时进行 择时 pid:84544 pick times complete:100.0% pid:84545 pick times complete:100.0% pid:84546 pick times complete:100.0% pid:84547 pick times complete:100.0% pid:84548 pick times complete:100.0% pid:84549 pick times complete:100.0% pid:84550 pick times complete:100.0% pid:84551 pick times complete:100.0% 多进程的运行方式在进行多支股票设置全市场策略回测时是非常有用的，本节由于choice_symbols中的股票数少，n_process_kl即并行金融数据采集模块 并没有使用，还有一些需要注意的地方也还没有讲到，在后续的全市场回测章节讲继续讲解。 备注: 由于本例开辟进程数较多，但是每个进程处理的任务非常少，所以在cpu不够快的电脑上结果可能正好相反，多进程模式的运行也行会更加耗时，效率更低，属正常现象，后面的例子每个进程可能会处理几十几百个交易对象就不会出现创建销毁进程的开销大于任务执行时间的情况 特别是windows系统，mac上不会发生，由于mac上的并行使用joblib，在windows上长任务joblib存在bug，所以windows上并行只是封装为joblib的接口形式，详情阅读源代码ABuParallel abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多","@type":"BlogPosting","url":"/2017/10/19/bb0cf656cb38fac9ed8a89b7133e1c84.html","headline":"量化投资:第4节 多支股票择时回测与仓位管理","dateModified":"2017-10-19T00:00:00+08:00","datePublished":"2017-10-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/10/19/bb0cf656cb38fac9ed8a89b7133e1c84.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>量化投资:第4节 多支股票择时回测与仓位管理</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>作者: 阿布</p> 
  <p>阿布量化版权所有 未经允许 禁止转载</p> 
  <p><a href="https://github.com/bbfamily/abu" rel="nofollow">abu量化系统github地址(欢迎+star)</a> </p> 
  <p><a href="https://github.com/bbfamily/abu/tree/master/abupy_lecture" rel="nofollow">本节ipython notebook</a></p> 
  <p>之前的章节无论讲解策略优化，还是针对回测进行滑点或是手续费都是针对一支股票进行择时操作。</p> 
  <p>本节将示例讲解多支股票进行择时策略的实现，依然使用AbuFactorBuyBreak做为买入策略，其它四个卖出策略同时生效的组合。</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuFactorBuyBreak, AbuFactorSellBreak
<span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop
<span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> ABuPickTimeExecute, AbuBenchmark, AbuCapital

<span class="hljs-comment"># buy_factors 60日向上突破，42日向上突破两个因子</span>
buy_factors = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">60</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}, 
               {<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]
<span class="hljs-comment"># 四个卖出因子同时并行生效</span>
sell_factors = [
    {
        <span class="hljs-string">'xd'</span>: <span class="hljs-number">120</span>,
        <span class="hljs-string">'class'</span>: AbuFactorSellBreak
    },
    {
        <span class="hljs-string">'stop_loss_n'</span>: <span class="hljs-number">0.5</span>,
        <span class="hljs-string">'stop_win_n'</span>: <span class="hljs-number">3.0</span>,
        <span class="hljs-string">'class'</span>: AbuFactorAtrNStop
    },
    {
        <span class="hljs-string">'class'</span>: AbuFactorPreAtrNStop,
        <span class="hljs-string">'pre_atr_n'</span>: <span class="hljs-number">1.0</span>
    },
    {
        <span class="hljs-string">'class'</span>: AbuFactorCloseAtrNStop,
        <span class="hljs-string">'close_atr_n'</span>: <span class="hljs-number">1.5</span>
    }]
benchmark = AbuBenchmark()
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)</code></pre> 
  <h3 id="1-多支股票使用相同的因子进行择时">1. 多支股票使用相同的因子进行择时</h3> 
  <p>选择的股票如下所示： <br> choice_symbols = [‘usTSLA’, ‘usNOAH’, ‘usSFUN’, ‘usBIDU’, ‘usAAPL’, <br> ‘usGOOG’, ‘usWUBA’, ‘usVIPS’]</p> 
  <p>备注：本节示例都基于美股市场，针对A股市场及港股市场，比特币，期货市场后在后面的章节讲解</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 我们假定choice_symbols是我们选股模块的结果，</span>
choice_symbols = [<span class="hljs-string">'usTSLA'</span>, <span class="hljs-string">'usNOAH'</span>, <span class="hljs-string">'usSFUN'</span>, <span class="hljs-string">'usBIDU'</span>, <span class="hljs-string">'usAAPL'</span>,
                  <span class="hljs-string">'usGOOG'</span>, <span class="hljs-string">'usWUBA'</span>, <span class="hljs-string">'usVIPS'</span>]</code></pre> 
  <p>使用ABuPickTimeExecute.do_symbols_with_same_factors()函数对多支股票使用相同的买入因子，卖出因子</p> 
  <pre class="prettyprint"><code class="language-python hljs ">%%time
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)
orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols,
                                                                                            benchmark,
                                                                                            buy_factors,
                                                                                            sell_factors,
                                                                                            capital,
                                                                                            show=<span class="hljs-keyword">False</span>)</code></pre> 
  <pre><code>CPU times: user 18.5 s, sys: 264 ms, total: 20.1 s
Wall time: 19.2 s
</code></pre> 
  <p>运行完毕，使用了ipython的magic code %%time去统计代码块运行时间，显示运行了19.2 s，本节最后会使用多进程模式运行相同的回测，会和这个时间进行比较。</p> 
  <p>备注：具体实际运行时间根据cpu的性能确定</p> 
  <p>下面代码显示orders_pd中前10个交易数据：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">orders_pd[:<span class="hljs-number">10</span>]</code></pre> 
  <p><img src="https://img-blog.csdn.net/20171019150200987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>通过buy_cnt列可以发现每次交易数量都不一样，由于内部有资金管理控制模块默认使用atr进行仓位控制</p> 
  <p>默认资金管理控制使用AbuAtrPosition，详情请阅读源代码，下面会有自定义仓位管理的示例。</p> 
  <p>下面代码显示action_pd中前10个行为数据：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">action_pd[:<span class="hljs-number">10</span>]</code></pre> 
  <p><img src="https://img-blog.csdn.net/20171019150221225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <ul> 
   <li>注意deal列代表了交易是否成交，由于内部有资金管理控制模块，所以不是所有交易信号都可以最后成交。</li> 
  </ul> 
  <p>下面我们使用abu量化系统度量模块对整体结果做个度量，如下图所示（之后章节会对度量方法及模块进行详细讲解，这里请先简单使用即可）。</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuMetricsBase 
metrics = AbuMetricsBase(orders_pd, action_pd, capital, benchmark)
metrics.fit_metrics()
metrics.plot_returns_cmp(only_show_returns=<span class="hljs-keyword">True</span>)</code></pre> 
  <pre><code>买入后卖出的交易数量:67
买入后尚未卖出的交易数量:3
胜率:43.2836%
平均获利期望:12.2712%
平均亏损期望:-4.9050%
盈亏比:1.9327
策略收益: 29.4383%
基准收益: 15.0841%
策略年化收益: 14.7192%
基准年化收益: 7.5420%
策略买入成交比例:84.2857%
策略资金利用率比例:22.3612%
策略共执行504个交易日
</code></pre> 
  <p><img src="https://img-blog.csdn.net/20171019150241137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <h3 id="2-自定义仓位管理策略的实现">2. 自定义仓位管理策略的实现</h3> 
  <p>上面使用AbuMetricsBase进行度量，我们计算出：</p> 
  <ol> 
   <li>胜率:41.79%</li> 
   <li>平均获利期望:12.01%</li> 
   <li>平均亏损期望:-4.91%</li> 
  </ol> 
  <p>有这三个参数就可以使用kelly公式来做仓位控制，AbuKellyPosition实现如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbuKellyPosition</span><span class="hljs-params">(AbuPositionBase)</span>:</span>
    <span class="hljs-string">"""示例kelly仓位管理类"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit_position</span><span class="hljs-params">(self, factor_object)</span>:</span>
        <span class="hljs-string">""" fit_position计算的结果是买入多少个单位（股，手，顿，合约） 需要factor_object策略因子对象通过历史回测统计胜率，期望收益，期望亏损， 并设置构造当前factor_object对象，通过kelly公司计算仓位 :param factor_object: ABuFactorBuyBases子类实例对象 :return:买入多少个单位（股，手，顿，合约） """</span>
        <span class="hljs-comment"># 败率</span>
        loss_rate = <span class="hljs-number">1</span> - self.win_rate
        <span class="hljs-comment"># kelly计算出仓位比例</span>
        kelly_pos = self.win_rate - loss_rate / (self.gains_mean / self.losses_mean)
        <span class="hljs-comment"># 最大仓位限制，依然受上层最大仓位控制限制，eg：如果kelly计算出全仓，依然会减少到75%，如修改需要修改最大仓位值</span>
        kelly_pos = self.pos_max <span class="hljs-keyword">if</span> kelly_pos &gt; self.pos_max <span class="hljs-keyword">else</span> kelly_pos
        <span class="hljs-comment"># 结果是买入多少个单位（股，手，顿，合约）</span>
        <span class="hljs-keyword">return</span> self.read_cash * kelly_pos / self.bp * self.deposit_rate

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_self</span><span class="hljs-params">(self, **kwargs)</span>:</span>
        <span class="hljs-string">"""kelly仓位控制管理类初始化设置"""</span>

        <span class="hljs-comment"># 默认kelly仓位胜率0.50</span>
        self.win_rate = kwargs.pop(<span class="hljs-string">'win_rate'</span>, <span class="hljs-number">0.50</span>)
        <span class="hljs-comment"># 默认平均获利期望0.10</span>
        self.gains_mean = kwargs.pop(<span class="hljs-string">'gains_mean'</span>, <span class="hljs-number">0.10</span>)
        <span class="hljs-comment"># 默认平均亏损期望0.05</span>
        self.losses_mean = kwargs.pop(<span class="hljs-string">'losses_mean'</span>, <span class="hljs-number">0.05</span>)

        <span class="hljs-string">"""以默认的设置kelly根据计算0.5 - 0.5 / (0.10 / 0.05) 仓位将是0.25即25%"""</span></code></pre> 
  <p>自定义仓位管理代码如上AbuKellyPosition：</p> 
  <ol> 
   <li>仓位管理类需要继承AbuPositionBase</li> 
   <li>仓位管理类主要需要实现函数fit_position，即根据买入价格，本金基数等融合买入策略对买入单位进行计算</li> 
   <li>仓位管理类主要需要实现函数_init_self，外部通过字典参数将胜率等参数进行关键子参数设置（详见后使用示例）</li> 
  </ol> 
  <p>更多资金管理代码请阅读AbuPositionBase</p> 
  <p>下面编写buy_factors2，其42d突破使用position＝AbuKellyPosition</p> 
  <ul> 
   <li>参数胜率：metrics.win_rate(41.79%)</li> 
   <li>期望收益：metrics.gains_mean(12.01%)</li> 
   <li>期望亏损：metrics.losses_mean(-4.91%)，</li> 
  </ul> 
  <p>代码如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuKellyPosition

<span class="hljs-comment"># 42d使用刚刚编写的AbuKellyPosition，60d仍然使用默认仓位管理类，即abupy中内置的AbuAtrPosition类</span>
buy_factors2 = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">60</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak},
                {<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'position'</span>: {<span class="hljs-string">'class'</span>: AbuKellyPosition, <span class="hljs-string">'win_rate'</span>: metrics.win_rate, 
                                        <span class="hljs-string">'gains_mean'</span>: metrics.gains_mean, <span class="hljs-string">'losses_mean'</span>: -metrics.losses_mean},
                 <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]

capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)
orders_pd, action_pd, all_fit_symbols_cnt = ABuPickTimeExecute.do_symbols_with_same_factors(choice_symbols,
                                                                                            benchmark,
                                                                                            buy_factors2,
                                                                                            sell_factors,
                                                                                            capital,
                                                                                            show=<span class="hljs-keyword">False</span>)</code></pre> 
  <p>从输出生成的orders_pd中可以看到buy Pos列所有42d突破都使用了AbuKellyPosition，60d仍然使用AbuAtrPosition</p> 
  <pre class="prettyprint"><code class="language-python hljs ">orders_pd[:<span class="hljs-number">10</span>].filter([<span class="hljs-string">'symbol'</span>, <span class="hljs-string">'buy_cnt'</span>, <span class="hljs-string">'buy_factor'</span>, <span class="hljs-string">'buy_pos'</span>])</code></pre> 
  <p><img src="https://img-blog.csdn.net/20171019150304836?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <h3 id="3-多支股票使用不同的因子进行择时">3. 多支股票使用不同的因子进行择时</h3> 
  <p>使用ABuPickTimeExecute.do_symbols_with_diff_factors()函数针对不同的股票使用不同的买入因子和不同的卖出因子，</p> 
  <p>具体实现请查阅源代码ABuPickTimeExecute，使用示例如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 选定noah和sfun</span>
target_symbols = [<span class="hljs-string">'usSFUN'</span>, <span class="hljs-string">'usNOAH'</span>]

<span class="hljs-comment"># 针对sfun只使用42d向上突破作为买入因子</span>
buy_factors_sfun = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]
<span class="hljs-comment"># 针对sfun只使用60d向下突破作为卖出因子</span>
sell_factors_sfun = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">60</span>, <span class="hljs-string">'class'</span>: AbuFactorSellBreak}]

<span class="hljs-comment"># 针对noah只使用21d向上突破作为买入因子</span>
buy_factors_noah = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">21</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]
<span class="hljs-comment"># 针对noah只使用42d向下突破作为卖出因子</span>
sell_factors_noah = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'class'</span>: AbuFactorSellBreak}]

factor_dict = dict()
<span class="hljs-comment"># 构建SFUN独立的buy_factors，sell_factors的dict</span>
factor_dict[<span class="hljs-string">'usSFUN'</span>] = {<span class="hljs-string">'buy_factors'</span>: buy_factors_sfun,
                         <span class="hljs-string">'sell_factors'</span>: sell_factors_sfun}

<span class="hljs-comment"># 构建NOAH独立的buy_factors，sell_factors的dict</span>
factor_dict[<span class="hljs-string">'usNOAH'</span>] = {<span class="hljs-string">'buy_factors'</span>: buy_factors_noah,
                         <span class="hljs-string">'sell_factors'</span>: sell_factors_noah}

<span class="hljs-comment"># 初始化资金</span>
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)
<span class="hljs-comment"># 使用do_symbols_with_diff_factors执行</span>
orders_pd, action_pd, all_fit_symbols = ABuPickTimeExecute.do_symbols_with_diff_factors(target_symbols,
                                                                                        benchmark,
                                                                                        factor_dict,
                                                                                        capital)</code></pre> 
  <p>如下代码通过pandas的交叉表来分析输出的orders_pd， 来证明: noah买入因子全部是使用21d向上突破，sfun买入因子全部是使用42d向上突破：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">pd.crosstab(orders_pd.buy_factor, orders_pd.symbol)</code></pre> 
  <p><img src="https://img-blog.csdn.net/20171019150327385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <h3 id="4-使用并行来提升择时运行效率">4. 使用并行来提升择时运行效率</h3> 
  <p>当你选择的股票非常多的时候，比如很多时候是对全市场进行回测，那就需要多进程并行来提升运行效率，AbuPickTimeMaster.do_symbols_with_same_factors_process()函数通过定义n_process_kl（同时获取股票数据的进程数）和n_process_pick_time（同时进行择时的进程数）来完成操作.</p> 
  <p>具体实现代码请阅读AbuPickTimeMaster，使用示例如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">%%time
<span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuPickTimeMaster

capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)
orders_pd, action_pd, _ = AbuPickTimeMaster.do_symbols_with_same_factors_process(
                                    choice_symbols, benchmark, buy_factors, sell_factors, capital,
                                    n_process_kl=<span class="hljs-number">4</span>, n_process_pick_time=<span class="hljs-number">4</span>)</code></pre> 
  <pre><code>pid:12502 gen kl_pd complete:100.0%
pid:12503 gen kl_pd complete:100.0%
pid:12504 gen kl_pd complete:100.0%
pid:12505 gen kl_pd complete:100.0%
pid:12506 gen kl_pd complete:100.0%
pid:12507 gen kl_pd complete:100.0%
pid:12508 gen kl_pd complete:100.0%
pid:12509 gen kl_pd complete:100.0%
pid:12503 done!
pid:12505 done!
pid:12506 done!
pid:12507 done!
pid:12504 done!
pid:12502 done!
pid:12509 done!
pid:12508 done!
pid:12510 pick times complete:100.0%
pid:12511 pick times complete:100.0%
pid:12512 pick times complete:100.0%
pid:12513 pick times complete:100.0%
pid:12514 pick times complete:100.0%
pid:12515 pick times complete:100.0%
pid:12516 pick times complete:100.0%
pid:12517 pick times complete:100.0%
pid:12510 done!
pid:12512 done!
pid:12515 done!
pid:12513 done!
pid:12511 done!
pid:12514 done!
pid:12517 done!
pid:12516 done!
CPU times: user 2.48 s, sys: 192 ms, total: 2.67 s
Wall time: 6.36s
</code></pre> 
  <p>依然使用%%time度量代码块运行时间，之前使用开始时使用ABuPickTimeExecute运行相同的回测输出运行时间19.2 s， <br> 使用AbuPickTimeMaster使用参数n_process_pick_time=8，即启动8个择时进程后，运行时间缩短到6.36s，从输出的信息也可以看到8个pid同时进行 <br> 择时</p> 
  <ul> 
   <li>pid:84544 pick times complete:100.0%</li> 
   <li>pid:84545 pick times complete:100.0%</li> 
   <li>pid:84546 pick times complete:100.0%</li> 
   <li>pid:84547 pick times complete:100.0%</li> 
   <li>pid:84548 pick times complete:100.0%</li> 
   <li>pid:84549 pick times complete:100.0%</li> 
   <li>pid:84550 pick times complete:100.0%</li> 
   <li>pid:84551 pick times complete:100.0%</li> 
  </ul> 
  <p>多进程的运行方式在进行多支股票设置全市场策略回测时是非常有用的，本节由于choice_symbols中的股票数少，n_process_kl即并行金融数据采集模块 <br> 并没有使用，还有一些需要注意的地方也还没有讲到，在后续的全市场回测章节讲继续讲解。</p> 
  <p>备注: </p> 
  <p><strong>由于本例开辟进程数较多，但是每个进程处理的任务非常少，所以在cpu不够快的电脑上结果可能正好相反，多进程模式的运行也行会更加耗时，效率更低，属正常现象，后面的例子每个进程可能会处理几十几百个交易对象就不会出现创建销毁进程的开销大于任务执行时间的情况</strong></p> 
  <ul> 
   <li>特别是windows系统，mac上不会发生，由于mac上的并行使用joblib，在windows上长任务joblib存在bug，所以windows上并行只是封装为joblib的接口形式，详情阅读源代码ABuParallel</li> 
  </ul> 
  <h4 id="abu量化文档目录章节">abu量化文档目录章节</h4> 
  <ol> 
   <li><a href="http://www.abuquant.com/lecture/lecture_1.html" rel="nofollow" target="_blank">择时策略的开发</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_2.html" rel="nofollow" target="_blank">择时策略的优化</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_3.html" rel="nofollow" target="_blank">滑点策略与交易手续费</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_4.html" rel="nofollow" target="_blank">多支股票择时回测与仓位管理</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_5.html" rel="nofollow" target="_blank">选股策略的开发</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_6.html" rel="nofollow" target="_blank">回测结果的度量</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_7.html" rel="nofollow" target="_blank">寻找策略最优参数和评分</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_8.html" rel="nofollow" target="_blank">A股市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_9.html" rel="nofollow" target="_blank">港股市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_10.html" rel="nofollow" target="_blank">比特币，莱特币的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_11.html" rel="nofollow" target="_blank">期货市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_12.html" rel="nofollow" target="_blank">机器学习与比特币示例</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_13.html" rel="nofollow" target="_blank">量化技术分析应用</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_14.html" rel="nofollow" target="_blank">量化相关性分析应用</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_15.html" rel="nofollow" target="_blank">量化交易和搜索引擎</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_16.html" rel="nofollow" target="_blank">UMP主裁交易决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_17.html" rel="nofollow" target="_blank">UMP边裁交易决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_18.html" rel="nofollow" target="_blank">自定义裁判决策交易</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_19.html" rel="nofollow" target="_blank">数据源</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_20.html" rel="nofollow" target="_blank">A股全市场回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_21.html" rel="nofollow" target="_blank">A股UMP决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_22.html" rel="nofollow" target="_blank">美股全市场回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_23.html" rel="nofollow" target="_blank">美股UMP决策</a></li> 
  </ol> 
  <p><a href="http://www.abuquant.com/article" rel="nofollow" target="_blank">更多阿布量化量化技术文章</a></p> 
  <p>更多关于abu量化系统请关注微信公众号: abu_quant</p> 
  <p><img src="https://img-blog.csdn.net/20171019150416083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bbfamily1314/article/details/78285084,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bbfamily1314/article/details/78285084,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
