<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>量化投资:第3节 滑点策略与交易手续费-bbfamily1314的博客 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="量化投资:第3节 滑点策略与交易手续费-bbfamily1314的博客" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 上一节使用AbuFactorBuyBreak和AbuFactorSellBreak且混入基本止盈止损策略AbuFactorAtrNStop， 风险控制止损策略AbuFactorPreAtrNStop，利润保护止盈策略AbuFactorCloseAtrNStop来提高交易的盈利效果。 本节将继续在上一节回测的基础上示例择时策略其它使用方法，首先完成上一节的回测准备，如下所示： from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1 滑点买入卖出价格确定及策略实现 第一节中实现的买入策略和卖出策略的编写，买入策略中确定买入只是通过make_buy_order函数，确定买单生成，卖出策略确定卖出订单 也只是通过fit_sell_order来提交卖单，那么执行订单，应该使用的什么价格买入或者卖出呢，abupy在默认的策略都是使用当天的均价买入卖出， 当然你可以实现多种复杂的当日交易策略，设置限价单、市价单，获取当日的分时数据再次进行策略分析执行操作，但是如果你的回测数量足够多的情况下，比如全市场回测，按照大数定理，这个均值执行其实是最好的模拟，而且简单、运行速度快。 滑点买入卖出价格确定具体实现代码请阅读AbuSlippageBuyMean和AbuSlippageSellMean，它们的实现都很简单 在买入滑点AbuSlippageBuyMean中有一个小策略当当天开盘价格直接下探7%时，放弃买单，看上一节回测结果中如下图这次交易，从图上就可以发现虽然是突破买入，但明显第二天执行买单时的价格是直线下跌的，且下跌不少，但还是成交了这笔交易。因为开盘下跌幅度没有达到7%的阀值，下面我们就过拟合这次交易避免买入，只为示例 下面编写一个独立的Slippage策略，只简单修改g_open_down_rate的值为0.02 from abupy import AbuSlippageBuyBase, slippage # 修改买入下跌阀值为0.02 g_open_down_rate = 0.02 class AbuSlippageBuyMean2(AbuSlippageBuyBase): &quot;&quot;&quot;示例日内滑点均价买入类&quot;&quot;&quot; @slippage.sbb.slippage_limit_up def fit_price(self): &quot;&quot;&quot; 取当天交易日的最高最低均价做为决策价格 :return: 最终决策的当前交易买入价格 &quot;&quot;&quot; # TODO 基类提取作为装饰器函数，子类根据需要选择是否装饰，并且添加上根据order的call，put明确细节逻辑 if self.kl_pd_buy.pre_close == 0 or (self.kl_pd_buy.open / self.kl_pd_buy.pre_close) &lt; (1 - g_open_down_rate): # 开盘就下跌一定比例阀值，放弃单子 return np.inf # 买入价格为当天均价，即最高，最低的平均，也可使用高开低收平均等方式计算 self.buy_price = np.mean([self.kl_pd_buy[&#39;high&#39;], self.kl_pd_buy[&#39;low&#39;]]) # 返回最终的决策价格 return self.buy_price 上面编写的AbuSlippageBuyMean2类实现即为滑点买入类的实现： 滑点买入类需要继承自AbuSlippageBuyBase 滑点买入类需要实现fit_price来确定交易单执行当日的最终买入价格 slippage_limit_up装饰器是针对a股涨停板买入价格决策的装饰器，处理买入成功概率，根据概率决定是否能买入，及涨停下的买入价格决策，涨停下买入价格模型为，越靠近涨停价格买入成交概率越大，即在涨停下预期以靠近涨停价格买入， 备注：slippage_limit_up及slippage_limit_down具体实现可阅读源代码，后面的章节有示例演示使用 但是滑点类时什么时候被实例化使用的呢，怎么使用我们自己写的这个滑点类呢？首先看买入因子基类AbuFactorBuyBase，在每个买入因子初始化的时候即把默认的滑点类以及仓位管理类（稍后讲解）赋值，如下片段代码所示： 详情请查看AbuFactorBuyBas源代码 class AbuFactorBuyBase(six.with_metaclass(ABCMeta, ABuParamBaseClass)): def __init__(self, capital, kl_pd, **kwargs): # 走势数据 self.kl_pd = kl_pd # 资金情况数据 self.capital = capital # 滑点类，默认AbuSlippageBuyMean self.slippage_class = kwargs[&#39;slippage&#39;] \ if &#39;slippage&#39; in kwargs else AbuSlippageBuyMean # 仓位管理，默认AbuAtrPosition self.position_class = kwargs[&#39;position&#39;] \ if &#39;position&#39; in kwargs else AbuAtrPosition if &#39;win_rate&#39; in kwargs: self.win_rate = kwargs[&#39;win_rate&#39;] if &#39;gains_mean&#39; in kwargs: self.gains_mean = kwargs[&#39;gains_mean&#39;] if &#39;losses_mean&#39; in kwargs: self.losses_mean = kwargs[&#39;losses_mean&#39;] self._init_self(**kwargs) 之后因子在每次生效产生买单的时候会触发AbuOrder实例对象的fit_buy_order()函数，fit_buy_order()中将滑点类，仓位管理类实例化后，执行买入价格及数量确定，代码片段如下所示，详情请查看源代码。 def fit_buy_order(self, day_ind, factor_object): kl_pd = factor_object.kl_pd # 要执行买入当天的数据 kl_pd_buy = kl_pd.iloc[day_ind + 1] # 买入因子名称 factor_name = factor_object.factor_name \ if hasattr(factor_object, &#39;factor_name&#39;) else &#39;unknown&#39; # 滑点类设置 slippage_class = factor_object.slippage_class # 仓位管理类设置 position_class = factor_object.position_class # 初始资金，也可修改策略使用剩余资金 read_cash = factor_object.capital.read_cash # 实例化滑点类 fact = slippage_class(kl_pd_buy, factor_name) # 执行fit_price(), 计算出买入价格 bp = fact.fit_price() # 如果滑点类中决定不买入，撤单子，bp就返回正无穷 if bp &lt; np.inf: # 实例化仓位管理类 position = position_class(kl_pd_buy, factor_name, bp, read_cash) # 执行fit_position()，通过仓位管理计算买入的数量 buy_stock_cnt = int(position.fit_position(factor_object)) if buy_stock_cnt &lt; 1: return 卖出因子的滑点操作及仓位管理与买入类似，读者可以自行阅读源代码。 由以上代码我们可以发现通过buy_factors的字典对象中传入slippage便可以自行设置滑点类，由于上图显示的交易是60日突破产生的买单，所以我们只修改60日突破的字典对象，执行后可以看到如下图所示，过滤了两个60日突破的买单，即过滤了上图所示的交易，代码如下所示： 备注：实际上如果只是修改g_open_down_rate的值，可以通过模块全局变量直接修改，本节只为示例使用流程 # 针对60使用AbuSlippageBuyMean2 buy_factors2 = [{&#39;slippage&#39;: AbuSlippageBuyMean2, &#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=True) 2. 交易手续费的计算以及自定义手续费 交易必然会产生手续费，手续费的计算在ABuCommission模块中，比如本例中使用的的美股交易回测，使用的手续费计算代码如下所示： def calc_commission_us(trade_cnt, price): &quot;&quot;&quot; 美股计算交易费用：每股0.01，最低消费2.99 :param trade_cnt: 交易的股数（int） :param price: 每股的价格（美元）（暂不使用，只是保持接口统一） :return: 计算结果手续费 &quot;&quot;&quot; # 每股手续费0.01 commission = trade_cnt * 0.01 if commission &lt; 2.99: # 最低消费2.99 commission = 2.99 return commission 针对不同市场美股，a股，港股，比特币，期货有不同计算手续费的方法，更多详情请阅读ABuCommission模块源代码 下面先看看之前的回测交易中产生的手续费情况，查看代码如下所示： capital.commission.commission_df 如果你想把自己的计算手续费的方法使用在回测中，只需要编写手续费函数，示例如下所示： def calc_commission_us2(trade_cnt, price): &quot;&quot;&quot; 手续费统一7美元 &quot;&quot;&quot; return 7 如上编写的手续费函数统一每次买入卖出都是7美元手续费，手续费函数有两个参数一个trade_cnt代表买入（卖出）股数， 另一个参数是price，代表买入（卖出）价格，下面使用这个自定义的手续费方法做回测，代码如下所示： # 构造一个字典key=&#39;buy_commission_func&#39;, value=自定义的手续费方法函数 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从上面回测交易手续费结果可以看到，买入的手续费都变成了7元，卖出手续费还是之前的算法，下面的回测将买入卖出手续费计算方法都变成使用自定义的方法，代码如下所示： # 卖出字典key=&#39;sell_commission_func&#39;, 指向同一个手续费方法，当然也可以定义不同的方法 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2, &#39;sell_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从回测结果即可以看到所有买入卖出的手续费都是7美元 abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 abu量化系统文档教程持续更新中，请关注公众号中的更新提醒。 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多" />
<meta property="og:description" content="作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 上一节使用AbuFactorBuyBreak和AbuFactorSellBreak且混入基本止盈止损策略AbuFactorAtrNStop， 风险控制止损策略AbuFactorPreAtrNStop，利润保护止盈策略AbuFactorCloseAtrNStop来提高交易的盈利效果。 本节将继续在上一节回测的基础上示例择时策略其它使用方法，首先完成上一节的回测准备，如下所示： from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1 滑点买入卖出价格确定及策略实现 第一节中实现的买入策略和卖出策略的编写，买入策略中确定买入只是通过make_buy_order函数，确定买单生成，卖出策略确定卖出订单 也只是通过fit_sell_order来提交卖单，那么执行订单，应该使用的什么价格买入或者卖出呢，abupy在默认的策略都是使用当天的均价买入卖出， 当然你可以实现多种复杂的当日交易策略，设置限价单、市价单，获取当日的分时数据再次进行策略分析执行操作，但是如果你的回测数量足够多的情况下，比如全市场回测，按照大数定理，这个均值执行其实是最好的模拟，而且简单、运行速度快。 滑点买入卖出价格确定具体实现代码请阅读AbuSlippageBuyMean和AbuSlippageSellMean，它们的实现都很简单 在买入滑点AbuSlippageBuyMean中有一个小策略当当天开盘价格直接下探7%时，放弃买单，看上一节回测结果中如下图这次交易，从图上就可以发现虽然是突破买入，但明显第二天执行买单时的价格是直线下跌的，且下跌不少，但还是成交了这笔交易。因为开盘下跌幅度没有达到7%的阀值，下面我们就过拟合这次交易避免买入，只为示例 下面编写一个独立的Slippage策略，只简单修改g_open_down_rate的值为0.02 from abupy import AbuSlippageBuyBase, slippage # 修改买入下跌阀值为0.02 g_open_down_rate = 0.02 class AbuSlippageBuyMean2(AbuSlippageBuyBase): &quot;&quot;&quot;示例日内滑点均价买入类&quot;&quot;&quot; @slippage.sbb.slippage_limit_up def fit_price(self): &quot;&quot;&quot; 取当天交易日的最高最低均价做为决策价格 :return: 最终决策的当前交易买入价格 &quot;&quot;&quot; # TODO 基类提取作为装饰器函数，子类根据需要选择是否装饰，并且添加上根据order的call，put明确细节逻辑 if self.kl_pd_buy.pre_close == 0 or (self.kl_pd_buy.open / self.kl_pd_buy.pre_close) &lt; (1 - g_open_down_rate): # 开盘就下跌一定比例阀值，放弃单子 return np.inf # 买入价格为当天均价，即最高，最低的平均，也可使用高开低收平均等方式计算 self.buy_price = np.mean([self.kl_pd_buy[&#39;high&#39;], self.kl_pd_buy[&#39;low&#39;]]) # 返回最终的决策价格 return self.buy_price 上面编写的AbuSlippageBuyMean2类实现即为滑点买入类的实现： 滑点买入类需要继承自AbuSlippageBuyBase 滑点买入类需要实现fit_price来确定交易单执行当日的最终买入价格 slippage_limit_up装饰器是针对a股涨停板买入价格决策的装饰器，处理买入成功概率，根据概率决定是否能买入，及涨停下的买入价格决策，涨停下买入价格模型为，越靠近涨停价格买入成交概率越大，即在涨停下预期以靠近涨停价格买入， 备注：slippage_limit_up及slippage_limit_down具体实现可阅读源代码，后面的章节有示例演示使用 但是滑点类时什么时候被实例化使用的呢，怎么使用我们自己写的这个滑点类呢？首先看买入因子基类AbuFactorBuyBase，在每个买入因子初始化的时候即把默认的滑点类以及仓位管理类（稍后讲解）赋值，如下片段代码所示： 详情请查看AbuFactorBuyBas源代码 class AbuFactorBuyBase(six.with_metaclass(ABCMeta, ABuParamBaseClass)): def __init__(self, capital, kl_pd, **kwargs): # 走势数据 self.kl_pd = kl_pd # 资金情况数据 self.capital = capital # 滑点类，默认AbuSlippageBuyMean self.slippage_class = kwargs[&#39;slippage&#39;] \ if &#39;slippage&#39; in kwargs else AbuSlippageBuyMean # 仓位管理，默认AbuAtrPosition self.position_class = kwargs[&#39;position&#39;] \ if &#39;position&#39; in kwargs else AbuAtrPosition if &#39;win_rate&#39; in kwargs: self.win_rate = kwargs[&#39;win_rate&#39;] if &#39;gains_mean&#39; in kwargs: self.gains_mean = kwargs[&#39;gains_mean&#39;] if &#39;losses_mean&#39; in kwargs: self.losses_mean = kwargs[&#39;losses_mean&#39;] self._init_self(**kwargs) 之后因子在每次生效产生买单的时候会触发AbuOrder实例对象的fit_buy_order()函数，fit_buy_order()中将滑点类，仓位管理类实例化后，执行买入价格及数量确定，代码片段如下所示，详情请查看源代码。 def fit_buy_order(self, day_ind, factor_object): kl_pd = factor_object.kl_pd # 要执行买入当天的数据 kl_pd_buy = kl_pd.iloc[day_ind + 1] # 买入因子名称 factor_name = factor_object.factor_name \ if hasattr(factor_object, &#39;factor_name&#39;) else &#39;unknown&#39; # 滑点类设置 slippage_class = factor_object.slippage_class # 仓位管理类设置 position_class = factor_object.position_class # 初始资金，也可修改策略使用剩余资金 read_cash = factor_object.capital.read_cash # 实例化滑点类 fact = slippage_class(kl_pd_buy, factor_name) # 执行fit_price(), 计算出买入价格 bp = fact.fit_price() # 如果滑点类中决定不买入，撤单子，bp就返回正无穷 if bp &lt; np.inf: # 实例化仓位管理类 position = position_class(kl_pd_buy, factor_name, bp, read_cash) # 执行fit_position()，通过仓位管理计算买入的数量 buy_stock_cnt = int(position.fit_position(factor_object)) if buy_stock_cnt &lt; 1: return 卖出因子的滑点操作及仓位管理与买入类似，读者可以自行阅读源代码。 由以上代码我们可以发现通过buy_factors的字典对象中传入slippage便可以自行设置滑点类，由于上图显示的交易是60日突破产生的买单，所以我们只修改60日突破的字典对象，执行后可以看到如下图所示，过滤了两个60日突破的买单，即过滤了上图所示的交易，代码如下所示： 备注：实际上如果只是修改g_open_down_rate的值，可以通过模块全局变量直接修改，本节只为示例使用流程 # 针对60使用AbuSlippageBuyMean2 buy_factors2 = [{&#39;slippage&#39;: AbuSlippageBuyMean2, &#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=True) 2. 交易手续费的计算以及自定义手续费 交易必然会产生手续费，手续费的计算在ABuCommission模块中，比如本例中使用的的美股交易回测，使用的手续费计算代码如下所示： def calc_commission_us(trade_cnt, price): &quot;&quot;&quot; 美股计算交易费用：每股0.01，最低消费2.99 :param trade_cnt: 交易的股数（int） :param price: 每股的价格（美元）（暂不使用，只是保持接口统一） :return: 计算结果手续费 &quot;&quot;&quot; # 每股手续费0.01 commission = trade_cnt * 0.01 if commission &lt; 2.99: # 最低消费2.99 commission = 2.99 return commission 针对不同市场美股，a股，港股，比特币，期货有不同计算手续费的方法，更多详情请阅读ABuCommission模块源代码 下面先看看之前的回测交易中产生的手续费情况，查看代码如下所示： capital.commission.commission_df 如果你想把自己的计算手续费的方法使用在回测中，只需要编写手续费函数，示例如下所示： def calc_commission_us2(trade_cnt, price): &quot;&quot;&quot; 手续费统一7美元 &quot;&quot;&quot; return 7 如上编写的手续费函数统一每次买入卖出都是7美元手续费，手续费函数有两个参数一个trade_cnt代表买入（卖出）股数， 另一个参数是price，代表买入（卖出）价格，下面使用这个自定义的手续费方法做回测，代码如下所示： # 构造一个字典key=&#39;buy_commission_func&#39;, value=自定义的手续费方法函数 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从上面回测交易手续费结果可以看到，买入的手续费都变成了7元，卖出手续费还是之前的算法，下面的回测将买入卖出手续费计算方法都变成使用自定义的方法，代码如下所示： # 卖出字典key=&#39;sell_commission_func&#39;, 指向同一个手续费方法，当然也可以定义不同的方法 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2, &#39;sell_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从回测结果即可以看到所有买入卖出的手续费都是7美元 abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 abu量化系统文档教程持续更新中，请关注公众号中的更新提醒。 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多" />
<link rel="canonical" href="https://mlh.app/2017/10/19/4ccb7cb3fe3c5aa7691fbe841608fd0b.html" />
<meta property="og:url" content="https://mlh.app/2017/10/19/4ccb7cb3fe3c5aa7691fbe841608fd0b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者: 阿布 阿布量化版权所有 未经允许 禁止转载 abu量化系统github地址(欢迎+star) 本节ipython notebook 上一节使用AbuFactorBuyBreak和AbuFactorSellBreak且混入基本止盈止损策略AbuFactorAtrNStop， 风险控制止损策略AbuFactorPreAtrNStop，利润保护止盈策略AbuFactorCloseAtrNStop来提高交易的盈利效果。 本节将继续在上一节回测的基础上示例择时策略其它使用方法，首先完成上一节的回测准备，如下所示： from abupy import AbuFactorBuyBreak, AbuFactorSellBreak from abupy import AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop from abupy import ABuPickTimeExecute, AbuBenchmark, AbuCapital # buy_factors 60日向上突破，42日向上突破两个因子 buy_factors = [{&#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] # 四个卖出因子同时并行生效 sell_factors = [ { &#39;xd&#39;: 120, &#39;class&#39;: AbuFactorSellBreak }, { &#39;stop_loss_n&#39;: 0.5, &#39;stop_win_n&#39;: 3.0, &#39;class&#39;: AbuFactorAtrNStop }, { &#39;class&#39;: AbuFactorPreAtrNStop, &#39;pre_atr_n&#39;: 1.0 }, { &#39;class&#39;: AbuFactorCloseAtrNStop, &#39;close_atr_n&#39;: 1.5 }] benchmark = AbuBenchmark() capital = AbuCapital(1000000, benchmark) 1 滑点买入卖出价格确定及策略实现 第一节中实现的买入策略和卖出策略的编写，买入策略中确定买入只是通过make_buy_order函数，确定买单生成，卖出策略确定卖出订单 也只是通过fit_sell_order来提交卖单，那么执行订单，应该使用的什么价格买入或者卖出呢，abupy在默认的策略都是使用当天的均价买入卖出， 当然你可以实现多种复杂的当日交易策略，设置限价单、市价单，获取当日的分时数据再次进行策略分析执行操作，但是如果你的回测数量足够多的情况下，比如全市场回测，按照大数定理，这个均值执行其实是最好的模拟，而且简单、运行速度快。 滑点买入卖出价格确定具体实现代码请阅读AbuSlippageBuyMean和AbuSlippageSellMean，它们的实现都很简单 在买入滑点AbuSlippageBuyMean中有一个小策略当当天开盘价格直接下探7%时，放弃买单，看上一节回测结果中如下图这次交易，从图上就可以发现虽然是突破买入，但明显第二天执行买单时的价格是直线下跌的，且下跌不少，但还是成交了这笔交易。因为开盘下跌幅度没有达到7%的阀值，下面我们就过拟合这次交易避免买入，只为示例 下面编写一个独立的Slippage策略，只简单修改g_open_down_rate的值为0.02 from abupy import AbuSlippageBuyBase, slippage # 修改买入下跌阀值为0.02 g_open_down_rate = 0.02 class AbuSlippageBuyMean2(AbuSlippageBuyBase): &quot;&quot;&quot;示例日内滑点均价买入类&quot;&quot;&quot; @slippage.sbb.slippage_limit_up def fit_price(self): &quot;&quot;&quot; 取当天交易日的最高最低均价做为决策价格 :return: 最终决策的当前交易买入价格 &quot;&quot;&quot; # TODO 基类提取作为装饰器函数，子类根据需要选择是否装饰，并且添加上根据order的call，put明确细节逻辑 if self.kl_pd_buy.pre_close == 0 or (self.kl_pd_buy.open / self.kl_pd_buy.pre_close) &lt; (1 - g_open_down_rate): # 开盘就下跌一定比例阀值，放弃单子 return np.inf # 买入价格为当天均价，即最高，最低的平均，也可使用高开低收平均等方式计算 self.buy_price = np.mean([self.kl_pd_buy[&#39;high&#39;], self.kl_pd_buy[&#39;low&#39;]]) # 返回最终的决策价格 return self.buy_price 上面编写的AbuSlippageBuyMean2类实现即为滑点买入类的实现： 滑点买入类需要继承自AbuSlippageBuyBase 滑点买入类需要实现fit_price来确定交易单执行当日的最终买入价格 slippage_limit_up装饰器是针对a股涨停板买入价格决策的装饰器，处理买入成功概率，根据概率决定是否能买入，及涨停下的买入价格决策，涨停下买入价格模型为，越靠近涨停价格买入成交概率越大，即在涨停下预期以靠近涨停价格买入， 备注：slippage_limit_up及slippage_limit_down具体实现可阅读源代码，后面的章节有示例演示使用 但是滑点类时什么时候被实例化使用的呢，怎么使用我们自己写的这个滑点类呢？首先看买入因子基类AbuFactorBuyBase，在每个买入因子初始化的时候即把默认的滑点类以及仓位管理类（稍后讲解）赋值，如下片段代码所示： 详情请查看AbuFactorBuyBas源代码 class AbuFactorBuyBase(six.with_metaclass(ABCMeta, ABuParamBaseClass)): def __init__(self, capital, kl_pd, **kwargs): # 走势数据 self.kl_pd = kl_pd # 资金情况数据 self.capital = capital # 滑点类，默认AbuSlippageBuyMean self.slippage_class = kwargs[&#39;slippage&#39;] \\ if &#39;slippage&#39; in kwargs else AbuSlippageBuyMean # 仓位管理，默认AbuAtrPosition self.position_class = kwargs[&#39;position&#39;] \\ if &#39;position&#39; in kwargs else AbuAtrPosition if &#39;win_rate&#39; in kwargs: self.win_rate = kwargs[&#39;win_rate&#39;] if &#39;gains_mean&#39; in kwargs: self.gains_mean = kwargs[&#39;gains_mean&#39;] if &#39;losses_mean&#39; in kwargs: self.losses_mean = kwargs[&#39;losses_mean&#39;] self._init_self(**kwargs) 之后因子在每次生效产生买单的时候会触发AbuOrder实例对象的fit_buy_order()函数，fit_buy_order()中将滑点类，仓位管理类实例化后，执行买入价格及数量确定，代码片段如下所示，详情请查看源代码。 def fit_buy_order(self, day_ind, factor_object): kl_pd = factor_object.kl_pd # 要执行买入当天的数据 kl_pd_buy = kl_pd.iloc[day_ind + 1] # 买入因子名称 factor_name = factor_object.factor_name \\ if hasattr(factor_object, &#39;factor_name&#39;) else &#39;unknown&#39; # 滑点类设置 slippage_class = factor_object.slippage_class # 仓位管理类设置 position_class = factor_object.position_class # 初始资金，也可修改策略使用剩余资金 read_cash = factor_object.capital.read_cash # 实例化滑点类 fact = slippage_class(kl_pd_buy, factor_name) # 执行fit_price(), 计算出买入价格 bp = fact.fit_price() # 如果滑点类中决定不买入，撤单子，bp就返回正无穷 if bp &lt; np.inf: # 实例化仓位管理类 position = position_class(kl_pd_buy, factor_name, bp, read_cash) # 执行fit_position()，通过仓位管理计算买入的数量 buy_stock_cnt = int(position.fit_position(factor_object)) if buy_stock_cnt &lt; 1: return 卖出因子的滑点操作及仓位管理与买入类似，读者可以自行阅读源代码。 由以上代码我们可以发现通过buy_factors的字典对象中传入slippage便可以自行设置滑点类，由于上图显示的交易是60日突破产生的买单，所以我们只修改60日突破的字典对象，执行后可以看到如下图所示，过滤了两个60日突破的买单，即过滤了上图所示的交易，代码如下所示： 备注：实际上如果只是修改g_open_down_rate的值，可以通过模块全局变量直接修改，本节只为示例使用流程 # 针对60使用AbuSlippageBuyMean2 buy_factors2 = [{&#39;slippage&#39;: AbuSlippageBuyMean2, &#39;xd&#39;: 60, &#39;class&#39;: AbuFactorBuyBreak}, {&#39;xd&#39;: 42, &#39;class&#39;: AbuFactorBuyBreak}] capital = AbuCapital(1000000, benchmark) orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=True) 2. 交易手续费的计算以及自定义手续费 交易必然会产生手续费，手续费的计算在ABuCommission模块中，比如本例中使用的的美股交易回测，使用的手续费计算代码如下所示： def calc_commission_us(trade_cnt, price): &quot;&quot;&quot; 美股计算交易费用：每股0.01，最低消费2.99 :param trade_cnt: 交易的股数（int） :param price: 每股的价格（美元）（暂不使用，只是保持接口统一） :return: 计算结果手续费 &quot;&quot;&quot; # 每股手续费0.01 commission = trade_cnt * 0.01 if commission &lt; 2.99: # 最低消费2.99 commission = 2.99 return commission 针对不同市场美股，a股，港股，比特币，期货有不同计算手续费的方法，更多详情请阅读ABuCommission模块源代码 下面先看看之前的回测交易中产生的手续费情况，查看代码如下所示： capital.commission.commission_df 如果你想把自己的计算手续费的方法使用在回测中，只需要编写手续费函数，示例如下所示： def calc_commission_us2(trade_cnt, price): &quot;&quot;&quot; 手续费统一7美元 &quot;&quot;&quot; return 7 如上编写的手续费函数统一每次买入卖出都是7美元手续费，手续费函数有两个参数一个trade_cnt代表买入（卖出）股数， 另一个参数是price，代表买入（卖出）价格，下面使用这个自定义的手续费方法做回测，代码如下所示： # 构造一个字典key=&#39;buy_commission_func&#39;, value=自定义的手续费方法函数 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从上面回测交易手续费结果可以看到，买入的手续费都变成了7元，卖出手续费还是之前的算法，下面的回测将买入卖出手续费计算方法都变成使用自定义的方法，代码如下所示： # 卖出字典key=&#39;sell_commission_func&#39;, 指向同一个手续费方法，当然也可以定义不同的方法 commission_dict = {&#39;buy_commission_func&#39;: calc_commission_us2, &#39;sell_commission_func&#39;: calc_commission_us2} # 将commission_dict做为参数传入AbuCapital capital = AbuCapital(1000000, benchmark, user_commission_dict=commission_dict) # 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易 orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([&#39;usTSLA&#39;], benchmark, buy_factors2, sell_factors, capital, show=False) # 回测完成后查看手续费情况 capital.commission.commission_df 从回测结果即可以看到所有买入卖出的手续费都是7美元 abu量化文档目录章节 择时策略的开发 择时策略的优化 滑点策略与交易手续费 多支股票择时回测与仓位管理 选股策略的开发 回测结果的度量 寻找策略最优参数和评分 A股市场的回测 港股市场的回测 比特币，莱特币的回测 期货市场的回测 机器学习与比特币示例 量化技术分析应用 量化相关性分析应用 量化交易和搜索引擎 UMP主裁交易决策 UMP边裁交易决策 自定义裁判决策交易 数据源 A股全市场回测 A股UMP决策 美股全市场回测 美股UMP决策 更多阿布量化量化技术文章 abu量化系统文档教程持续更新中，请关注公众号中的更新提醒。 更多关于abu量化系统请关注微信公众号: abu_quant 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2017/10/19/4ccb7cb3fe3c5aa7691fbe841608fd0b.html","headline":"量化投资:第3节 滑点策略与交易手续费-bbfamily1314的博客","dateModified":"2017-10-19T00:00:00+08:00","datePublished":"2017-10-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2017/10/19/4ccb7cb3fe3c5aa7691fbe841608fd0b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>量化投资:第3节 滑点策略与交易手续费-bbfamily1314的博客</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>作者: 阿布</p> 
  <p>阿布量化版权所有 未经允许 禁止转载</p> 
  <p><a href="https://github.com/bbfamily/abu" rel="nofollow" target="_blank">abu量化系统github地址(欢迎+star)</a> </p> 
  <p><a href="https://github.com/bbfamily/abu/tree/master/abupy_lecture" rel="nofollow" target="_blank">本节ipython notebook</a></p> 
  <p>上一节使用AbuFactorBuyBreak和AbuFactorSellBreak且混入基本止盈止损策略AbuFactorAtrNStop， <br> 风险控制止损策略AbuFactorPreAtrNStop，利润保护止盈策略AbuFactorCloseAtrNStop来提高交易的盈利效果。</p> 
  <p>本节将继续在上一节回测的基础上示例择时策略其它使用方法，首先完成上一节的回测准备，如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuFactorBuyBreak, AbuFactorSellBreak
<span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuFactorAtrNStop, AbuFactorPreAtrNStop, AbuFactorCloseAtrNStop
<span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> ABuPickTimeExecute, AbuBenchmark, AbuCapital

<span class="hljs-comment"># buy_factors 60日向上突破，42日向上突破两个因子</span>
buy_factors = [{<span class="hljs-string">'xd'</span>: <span class="hljs-number">60</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}, 
               {<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]
<span class="hljs-comment"># 四个卖出因子同时并行生效</span>
sell_factors = [
    {
        <span class="hljs-string">'xd'</span>: <span class="hljs-number">120</span>,
        <span class="hljs-string">'class'</span>: AbuFactorSellBreak
    },
    {
        <span class="hljs-string">'stop_loss_n'</span>: <span class="hljs-number">0.5</span>,
        <span class="hljs-string">'stop_win_n'</span>: <span class="hljs-number">3.0</span>,
        <span class="hljs-string">'class'</span>: AbuFactorAtrNStop
    },
    {
        <span class="hljs-string">'class'</span>: AbuFactorPreAtrNStop,
        <span class="hljs-string">'pre_atr_n'</span>: <span class="hljs-number">1.0</span>
    },
    {
        <span class="hljs-string">'class'</span>: AbuFactorCloseAtrNStop,
        <span class="hljs-string">'close_atr_n'</span>: <span class="hljs-number">1.5</span>
    }]
benchmark = AbuBenchmark()
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)</code></pre> 
  <h3 id="1-滑点买入卖出价格确定及策略实现">1 滑点买入卖出价格确定及策略实现</h3> 
  <p>第一节中实现的买入策略和卖出策略的编写，买入策略中确定买入只是通过make_buy_order函数，确定买单生成，卖出策略确定卖出订单 <br> 也只是通过fit_sell_order来提交卖单，那么执行订单，应该使用的什么价格买入或者卖出呢，abupy在默认的策略都是使用当天的均价买入卖出，</p> 
  <p>当然你可以实现多种复杂的当日交易策略，设置限价单、市价单，获取当日的分时数据再次进行策略分析执行操作，但是如果你的回测数量足够多的情况下，比如全市场回测，按照大数定理，这个均值执行其实是最好的模拟，而且简单、运行速度快。</p> 
  <p>滑点买入卖出价格确定具体实现代码请阅读AbuSlippageBuyMean和AbuSlippageSellMean，它们的实现都很简单</p> 
  <p>在买入滑点AbuSlippageBuyMean中有一个小策略当当天开盘价格直接下探7%时，放弃买单，看上一节回测结果中如下图这次交易，从图上就可以发现虽然是突破买入，但明显第二天执行买单时的价格是直线下跌的，且下跌不少，但还是成交了这笔交易。因为开盘下跌幅度没有达到7%的阀值，下面我们就过拟合这次交易避免买入，只为示例</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145517790?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>下面编写一个独立的Slippage策略，只简单修改g_open_down_rate的值为0.02</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> abupy <span class="hljs-keyword">import</span> AbuSlippageBuyBase, slippage
<span class="hljs-comment"># 修改买入下跌阀值为0.02</span>
g_open_down_rate = <span class="hljs-number">0.02</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbuSlippageBuyMean2</span><span class="hljs-params">(AbuSlippageBuyBase)</span>:</span>
    <span class="hljs-string">"""示例日内滑点均价买入类"""</span>

    <span class="hljs-decorator">@slippage.sbb.slippage_limit_up</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit_price</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">""" 取当天交易日的最高最低均价做为决策价格 :return: 最终决策的当前交易买入价格 """</span>
        <span class="hljs-comment"># TODO 基类提取作为装饰器函数，子类根据需要选择是否装饰，并且添加上根据order的call，put明确细节逻辑</span>
        <span class="hljs-keyword">if</span> self.kl_pd_buy.pre_close == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> (self.kl_pd_buy.open / self.kl_pd_buy.pre_close) &lt; (<span class="hljs-number">1</span> - g_open_down_rate):
            <span class="hljs-comment"># 开盘就下跌一定比例阀值，放弃单子</span>
            <span class="hljs-keyword">return</span> np.inf
        <span class="hljs-comment"># 买入价格为当天均价，即最高，最低的平均，也可使用高开低收平均等方式计算</span>
        self.buy_price = np.mean([self.kl_pd_buy[<span class="hljs-string">'high'</span>], self.kl_pd_buy[<span class="hljs-string">'low'</span>]])
        <span class="hljs-comment"># 返回最终的决策价格</span>
        <span class="hljs-keyword">return</span> self.buy_price</code></pre> 
  <p>上面编写的AbuSlippageBuyMean2类实现即为滑点买入类的实现：</p> 
  <ol> 
   <li>滑点买入类需要继承自AbuSlippageBuyBase</li> 
   <li>滑点买入类需要实现fit_price来确定交易单执行当日的最终买入价格</li> 
   <li>slippage_limit_up装饰器是针对a股涨停板买入价格决策的装饰器，处理买入成功概率，根据概率决定是否能买入，及涨停下的买入价格决策，涨停下买入价格模型为，越靠近涨停价格买入成交概率越大，即在涨停下预期以靠近涨停价格买入，</li> 
  </ol> 
  <p>备注：slippage_limit_up及slippage_limit_down具体实现可阅读源代码，后面的章节有示例演示使用</p> 
  <p>但是滑点类时什么时候被实例化使用的呢，怎么使用我们自己写的这个滑点类呢？首先看买入因子基类AbuFactorBuyBase，在每个买入因子初始化的时候即把默认的滑点类以及仓位管理类（稍后讲解）赋值，如下片段代码所示：</p> 
  <p>详情请查看AbuFactorBuyBas源代码</p> 
  <pre><code>class AbuFactorBuyBase(six.with_metaclass(ABCMeta, ABuParamBaseClass)):
    def __init__(self, capital, kl_pd, **kwargs):
        # 走势数据
        self.kl_pd = kl_pd
        # 资金情况数据
        self.capital = capital
        # 滑点类，默认AbuSlippageBuyMean
        self.slippage_class = kwargs['slippage'] \
            if 'slippage' in kwargs else AbuSlippageBuyMean
        # 仓位管理，默认AbuAtrPosition
        self.position_class = kwargs['position'] \
            if 'position' in kwargs else AbuAtrPosition
        if 'win_rate' in kwargs:
            self.win_rate = kwargs['win_rate']
        if 'gains_mean' in kwargs:
            self.gains_mean = kwargs['gains_mean']
        if 'losses_mean' in kwargs:
            self.losses_mean = kwargs['losses_mean']
        self._init_self(**kwargs)
</code></pre> 
  <p>之后因子在每次生效产生买单的时候会触发AbuOrder实例对象的fit_buy_order()函数，fit_buy_order()中将滑点类，仓位管理类实例化后，执行买入价格及数量确定，代码片段如下所示，详情请查看源代码。</p> 
  <pre><code>def fit_buy_order(self, day_ind, factor_object):
    kl_pd = factor_object.kl_pd
    # 要执行买入当天的数据
    kl_pd_buy = kl_pd.iloc[day_ind + 1]
    # 买入因子名称
    factor_name = factor_object.factor_name \
        if hasattr(factor_object, 'factor_name') else 'unknown'
    # 滑点类设置
    slippage_class = factor_object.slippage_class
    # 仓位管理类设置
    position_class = factor_object.position_class
    # 初始资金，也可修改策略使用剩余资金
    read_cash = factor_object.capital.read_cash
    # 实例化滑点类
    fact = slippage_class(kl_pd_buy, factor_name)
    # 执行fit_price(), 计算出买入价格
    bp = fact.fit_price()
    # 如果滑点类中决定不买入，撤单子，bp就返回正无穷
    if bp &lt; np.inf:
        # 实例化仓位管理类
        position = position_class(kl_pd_buy, factor_name, bp, 
                                  read_cash)
        # 执行fit_position()，通过仓位管理计算买入的数量
        buy_stock_cnt = int(position.fit_position(factor_object))
        if buy_stock_cnt &lt; 1:
            return
</code></pre> 
  <p>卖出因子的滑点操作及仓位管理与买入类似，读者可以自行阅读源代码。</p> 
  <p>由以上代码我们可以发现通过buy_factors的字典对象中传入slippage便可以自行设置滑点类，由于上图显示的交易是60日突破产生的买单，所以我们只修改60日突破的字典对象，执行后可以看到如下图所示，过滤了两个60日突破的买单，即过滤了上图所示的交易，代码如下所示：</p> 
  <p>备注：实际上如果只是修改g_open_down_rate的值，可以通过模块全局变量直接修改，本节只为示例使用流程</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 针对60使用AbuSlippageBuyMean2</span>
buy_factors2 = [{<span class="hljs-string">'slippage'</span>: AbuSlippageBuyMean2, <span class="hljs-string">'xd'</span>: <span class="hljs-number">60</span>,
                 <span class="hljs-string">'class'</span>: AbuFactorBuyBreak},
                {<span class="hljs-string">'xd'</span>: <span class="hljs-number">42</span>, <span class="hljs-string">'class'</span>: AbuFactorBuyBreak}]
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark)
orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([<span class="hljs-string">'usTSLA'</span>],
                                                                            benchmark,
                                                                            buy_factors2,
                                                                            sell_factors,
                                                                            capital,
                                                                            show=<span class="hljs-keyword">True</span>)</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145630555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <h3 id="2-交易手续费的计算以及自定义手续费">2. 交易手续费的计算以及自定义手续费</h3> 
  <p>交易必然会产生手续费，手续费的计算在ABuCommission模块中，比如本例中使用的的美股交易回测，使用的手续费计算代码如下所示：</p> 
  <pre><code>def calc_commission_us(trade_cnt, price):
    """
    美股计算交易费用：每股0.01，最低消费2.99
    :param trade_cnt: 交易的股数（int）
    :param price: 每股的价格（美元）（暂不使用，只是保持接口统一）
    :return: 计算结果手续费
    """
    # 每股手续费0.01
    commission = trade_cnt * 0.01
    if commission &lt; 2.99:
        # 最低消费2.99
        commission = 2.99
    return commission
</code></pre> 
  <p>针对不同市场美股，a股，港股，比特币，期货有不同计算手续费的方法，更多详情请阅读ABuCommission模块源代码</p> 
  <p>下面先看看之前的回测交易中产生的手续费情况，查看代码如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs ">capital.commission.commission_df</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145712404?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>如果你想把自己的计算手续费的方法使用在回测中，只需要编写手续费函数，示例如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_commission_us2</span><span class="hljs-params">(trade_cnt, price)</span>:</span>
    <span class="hljs-string">""" 手续费统一7美元 """</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span></code></pre> 
  <p>如上编写的手续费函数统一每次买入卖出都是7美元手续费，手续费函数有两个参数一个trade_cnt代表买入（卖出）股数， <br> 另一个参数是price，代表买入（卖出）价格，下面使用这个自定义的手续费方法做回测，代码如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 构造一个字典key='buy_commission_func', value=自定义的手续费方法函数</span>
commission_dict = {<span class="hljs-string">'buy_commission_func'</span>: calc_commission_us2}
<span class="hljs-comment"># 将commission_dict做为参数传入AbuCapital</span>
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark, user_commission_dict=commission_dict)
<span class="hljs-comment"># 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易</span>
orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([<span class="hljs-string">'usTSLA'</span>],
                                                                            benchmark,
                                                                            buy_factors2,
                                                                            sell_factors,
                                                                            capital,
                                                                            show=<span class="hljs-keyword">False</span>)
<span class="hljs-comment"># 回测完成后查看手续费情况</span>
capital.commission.commission_df</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145742959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>从上面回测交易手续费结果可以看到，买入的手续费都变成了7元，卖出手续费还是之前的算法，下面的回测将买入卖出手续费计算方法都变成使用自定义的方法，代码如下所示：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 卖出字典key='sell_commission_func', 指向同一个手续费方法，当然也可以定义不同的方法</span>
commission_dict = {<span class="hljs-string">'buy_commission_func'</span>: calc_commission_us2, <span class="hljs-string">'sell_commission_func'</span>: calc_commission_us2}
<span class="hljs-comment"># 将commission_dict做为参数传入AbuCapital</span>
capital = AbuCapital(<span class="hljs-number">1000000</span>, benchmark, user_commission_dict=commission_dict)
<span class="hljs-comment"># 除了手续费自定义外，回测其它设置不变，show=False不可视化回测交易</span>
orders_pd, action_pd, _ = ABuPickTimeExecute.do_symbols_with_same_factors([<span class="hljs-string">'usTSLA'</span>],
                                                                            benchmark,
                                                                            buy_factors2,
                                                                            sell_factors,
                                                                            capital,
                                                                            show=<span class="hljs-keyword">False</span>)
<span class="hljs-comment"># 回测完成后查看手续费情况</span>
capital.commission.commission_df</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145810250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>从回测结果即可以看到所有买入卖出的手续费都是7美元</p> 
  <h4 id="abu量化文档目录章节">abu量化文档目录章节</h4> 
  <ol> 
   <li><a href="http://www.abuquant.com/lecture/lecture_1.html" rel="nofollow">择时策略的开发</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_2.html" rel="nofollow">择时策略的优化</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_3.html" rel="nofollow">滑点策略与交易手续费</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_4.html" rel="nofollow">多支股票择时回测与仓位管理</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_5.html" rel="nofollow">选股策略的开发</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_6.html" rel="nofollow">回测结果的度量</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_7.html" rel="nofollow">寻找策略最优参数和评分</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_8.html" rel="nofollow">A股市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_9.html" rel="nofollow">港股市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_10.html" rel="nofollow">比特币，莱特币的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_11.html" rel="nofollow">期货市场的回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_12.html" rel="nofollow">机器学习与比特币示例</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_13.html" rel="nofollow">量化技术分析应用</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_14.html" rel="nofollow">量化相关性分析应用</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_15.html" rel="nofollow">量化交易和搜索引擎</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_16.html" rel="nofollow">UMP主裁交易决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_17.html" rel="nofollow">UMP边裁交易决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_18.html" rel="nofollow">自定义裁判决策交易</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_19.html" rel="nofollow">数据源</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_20.html" rel="nofollow">A股全市场回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_21.html" rel="nofollow">A股UMP决策</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_22.html" rel="nofollow">美股全市场回测</a></li> 
   <li><a href="http://www.abuquant.com/lecture/lecture_23.html" rel="nofollow">美股UMP决策</a></li> 
  </ol> 
  <p><a href="http://www.abuquant.com/article" rel="nofollow">更多阿布量化量化技术文章</a></p> 
  <p>abu量化系统文档教程持续更新中，请关注公众号中的更新提醒。</p> 
  <p>更多关于abu量化系统请关注微信公众号: abu_quant</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20171019145857896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJmYW1pbHkxMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bbfamily1314/article/details/78284986,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bbfamily1314/article/details/78284986,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
