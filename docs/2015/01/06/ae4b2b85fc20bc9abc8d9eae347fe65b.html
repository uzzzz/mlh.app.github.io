<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【比特币】Namecoin原理 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【比特币】Namecoin原理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="NOTE: This standard is used by&nbsp;Namecoin, but new merged mining data should likely propose a new BIP to supercede it with something based on p2pool&#39;s merged mining. Contents &nbsp;[hide]&nbsp; 1&nbsp;Terminology 2&nbsp;Aux proof-of-work block 3&nbsp;Merkle Branch 4&nbsp;Merged mining coinbase 5&nbsp;Aux work merkle tree 6&nbsp;Example 7&nbsp;Notes Terminology Auxiliary Proof-of-Work (POW) a.k.a &quot;AuxPOW&quot;. This is the way that merged mining can exist; it is the relationship between two blockchains for one to trust the other&#39;s work as their own and accept AuxPOW blocks. Merged Mining The act of using work done on one blockchain on more than one chain, using Auxiliary POW. Auxiliary Blockchain The altcoin that is accepting work done on alternate chains as valid on its own chain. Client applications have to be modified to accept Auxiliary POW. Parent Blockchain The blockchain where the actual mining work is taking place. This chain does not need to be aware of the Auxiliary POW logic, as AuxPOW blocks submitted to this chain are still valid blocks. Parent Block Not to be confused with the &quot;previous block&quot;. This is a block that is structured for the parent blockchain (i.e. the&nbsp; prev_block&nbsp;hash points to the prior block on the parent blockchain). The header of this block is part of the AuxPOW Block in the auxiliary blockchain. AuxPOW Block This is a new type of block that is similar to a standard blockchain block, with two important differences. Firstly, the hash of the block header does NOT meet the difficulty level of the blockchain (so, if interpreted by a naive client, will be thrown out as not meeting the difficulty level). Secondly, it has additional data elements that show that the miner who created this block actually did mining activity (hashing) on the parent blockchain, and that work meets the difficulty level of the auxiliary blockchain, which is why this block should be accepted. Aux proof-of-work block This is used to prove work on the auxiliary blockchain. In vinced&#39;s original implementation it&#39;s generated by calling the&nbsp;getworkaux&nbsp;RPC method on the parent blockchain client (bitcoind) and then the work is then submitted by passing it to the auxiliary chain client (namecoind) as the second parameter to&nbsp;getauxblock. When receiving an Aux proof-of-work block in a&nbsp;&quot;block&quot; network message, the data received is similar to a standard block, but extra data is inserted between the&nbsp;nonce&nbsp;andtxn_count&nbsp;elements. In the below table, the shaded rows are the same as the standard block definition: Field Size Description Data type Comments 4 version uint32_t &nbsp; 32 prev_block char[32] &nbsp; 32 merkle_root char[32] &nbsp; 4 timestamp uint32_t &nbsp; 4 bits uint32_t &nbsp; 4 nonce uint32_t &nbsp; &nbsp;? coinbase_txn txn Coinbase transaction that is in the parent block,&nbsp;linking&nbsp;the AuxPOW block to its parent block 32 block_hash char[32] Hash of the&nbsp;parent_block&nbsp;header &nbsp;? coinbase_branch Merkle branch The merkle branch linking the&nbsp;coinbase_txn&nbsp;to the parent block&#39;s&nbsp;merkle_root &nbsp;? blockchain_branch Merkle branch The merkle branch linking this auxiliary blockchain to the others, when used in a merged mining setup with multiple auxiliary chains 80 parent_block Block header Parent block header &nbsp;? txn_count var_int &nbsp; &nbsp;? txns tx[] &nbsp; For the&nbsp;coinbase_branch&nbsp;merkle branch, because the coinbase transaction is the first transaction in the block (if using Bitcoin as a parent chain, i.e. hash #7 in the example given&nbsp;below), the&nbsp;branch_side_mask&nbsp;is always going to be all zeroes, because the branch hashes will always be &quot;on the right&quot; of the working hash. When only working on one auxiliary blockchain, the&nbsp;blockchain_branch&nbsp;link is not needed, and is nulled-out by being presented as 5 bytes of zeros (interpreted as a one-byte&nbsp;var_int&nbsp;indicating a&nbsp;branch_length&nbsp;of zero, and a 32-bit (4 byte)&nbsp;branch_side_mask&nbsp;of all zeroes). Note that the&nbsp;block_hash&nbsp;element is not needed as you have the full&nbsp;parent_block&nbsp;header element and can calculate the hash from that. The current Namecoin client doesn&#39;t check this field for validity, and as such some AuxPOW blocks have it little-endian, and some have it big-endian. Merkle Branch Say Alice created a Merkle tree, and it&#39;s root element is publicly available. For example: merkleRoot (0) / \ / \ 1 2 / \ / \ / \ / \ 3 4 5 6 / \ / \ / \ / \ 7 8 9 10 11 12 13 14 Now she wants to prove to Bob that a given hash (#10) was part of that tree, but Bob doesn&#39;t have the full tree (only the public root; hash #0). Alice can send Bob all the hashes she used to make the tree in the first place (hashes #7-#14, total of 7 extra hashes), so Bob can build the whole tree to verify the root is the same, but that&#39;s rather data-intensive. Instead, she could give Bob hashes #9, #3, and #2 (one from each level of the tree, working #10 back to the root). Without Bob knowing the structure of the tree, Alice also has to tell Bob what order to apply the hashes in (since&nbsp;hash(#9, #10) == #4, but&nbsp;hash(#10, #9)&nbsp;!= #4). So Alice tells Bob &quot;left, left, right&quot; to indicate which operand #9, #3, and #2 are, respectively. That can be encoded as a bitmask and take up very little data to transmit. So, instead of transmitting 7 hashes to Bob, Alice transmits 3 hashes and a bitmask. The data savings get even more pronounced if the merkle tree gets even bigger. That is the overall premise, and specifically for the AuxPOW protocol, it&#39;s been termed a &quot;merkle branch&quot; (since it&#39;s one pathway of a merkle tree), and is transmitted thus: Field Size Description Data type Comments &nbsp;? branch_length var_int The number of hashes making up the branch &nbsp;? branch_hash[] char[32] Individual hash in the branch; repeated&nbsp;branch_length&nbsp;number of times 4 branch_side_mask int32_t Bitmask of which side of the merkle hash function the&nbsp;branch_hash&nbsp;element should go on. Zero means it goes on the right, One means on the left. The first&nbsp;branch_hash&nbsp;is used first, and the least-significant bit of the&nbsp;branch_side_mask&nbsp;determines its hash position. Then the second&nbsp;branch_hash&nbsp;is applied with the second-least-significant bit of the&nbsp;branch_side_mask, etc. So for Alice&#39;s example,&nbsp;branch_length&nbsp;would be 3, the hashes would be given in the order #9, #3, then #2, and the&nbsp;branch_side_mask&nbsp;would be&nbsp;0b011&nbsp;= 3. Merged mining coinbase Insert exactly one of these headers into the&nbsp;scriptSig&nbsp;of the coinbase transaction in the parent block. Field Size Description Data type Comments 4 magic char[4] 0xfa,&nbsp;0xbe, &#39;m&#39;, &#39;m&#39;&nbsp;(only required if over 20 bytes past the start of the script; optional otherwise) 32 block_hash char[32] Hash of the AuxPOW block header 4 merkle_size int32_t Number of entries in aux work merkle tree.&nbsp;(Must be a power of 2) 4 merkle_nonce int32_t Nonce used to calculate indexes into aux work merkle tree; you may as well leave this at zero That string of 44 bytes being part of the coinbase script means that the miner constructed the AuxPOW Block before creating the coinbase. Aux work merkle tree If you&#39;re just mining a single auxiliary chain and using getauxblock, you don&#39;t have to worry about this - just set the merkle tree hash in the coinbase to the aux chain block&#39;s hash as given by getauxblock, the merkle size to 1, and the merkle nonce to 0. If you&#39;re mining more than one, this is a bit broken. It uses the following algorithm to convert the chain ID to a slot at the base of the merkle tree in which that chain&#39;s block hash must slot: unsigned int rand = merkle_nonce; rand = rand * 1103515245 + 12345; rand += chain_id; rand = rand * 1103515245 + 12345; slot_num = rand&nbsp;% merkle_size The idea is that you can increment merkle_nonce until the chains you&#39;re mining don&#39;t clash for the same slot. The trouble is that this doesn&#39;t work; because it just adds a number derived from the merkle_nonce to the chain_id, if two chains clash for one nonce they&#39;ll still clash for all possible nonces.[1]&nbsp;New implementers: please pick your chain_id so that not clashing with existing chains requires as small a value of merkle_size as possible, or use a better algorithm to calculate the slot id for your chain. Once you know where in the merkle tree the different chains go,&nbsp;reverse the bytes of each chain&#39;s block hash as given you by getauxblock&nbsp;(so the byte at the start moves to the end, etc) and insert into the appropriate slot, filling the unused ones with arbitrary data. Now build up the merkle tree as usual by taking each pair of values in the initial row and double SHA-256 hashing them to give a new row of hashes, repeating this until you only have a single hash. This last hash is the merkle root. You need toreverse the bytes of this again&nbsp;before inserting it into the coinbase. If you&#39;re not using getauxblock to get the block hash, you can skip the first reversal but still need to reverse the final merkle root when adding it to the coinbase. The aux proof-of-work also needs a merkle branch, which is built as follows: find the location of the block&#39;s hash in the merkle tree, and add the other value that you hashed it with in building the merkle tree. Now add the value you hashed that result with. Keep doing this until you reach the root. The merkle root itself is&nbsp;neverincluded in the merkle branch. If you just have a single aux chain, this can be left entirely empty. (It also appears you&nbsp;don&#39;t&nbsp;need to reverse these hashes.) Example This is the AuxPOW block at&nbsp;height 19200&nbsp;in the Namecoin chain (the first block that allowed AuxPOW authentication). It has a hash ofd8a7c3e01e1e95bcee015e6fcc7583a2ca60b79e5a3aa0a171eddd344ada903d, and only has one Namecoin transaction (coinbase sending 50 NMC to the miner&#39;s address). The parent block that was used as Proof of Work has a hash less than the difficulty target of Namecoin at the time, but not the Bitcoin target: 0000000000003d47277359fb969c43e3c7e7c0306a17f6444b8e91e19def03a9 -- parent block hash 000000000000b269000000000000000000000000000000000000000000000000 -- Namecoin difficulty target 00000000000009ee5d0000000000000000000000000000000000000000000000 -- Bitcoin difficulty target Hence, this AuxPOW block was valid in the Namecoin blockchain, but not in the Bitcoin blockchain (you will find no Bitcoin block with the hash starting&nbsp;3d47277359fb969c. If it were, it would be right after&nbsp;4a59b7deb5c4e01b, since that&#39;s the&nbsp;previous_block&nbsp;hash used) Block Header: 01 01 01 00 // Version 36 90 9a c0 7a 16 73 da f6 5f a7 d8 28 88 2e 66 c9 e8 9f 85 46 cd d5 0a 9f b1 00 00 00 00 00 00 // Previous block hash 0f 5c 65 49 bc d6 08 ab 7c 4e ac 59 3e 5b d5 a7 3b 2d 43 2e b6 35 18 70 8f 77 8f c7 dc df af 88 // Merkle root 8d 1a 90 4e // Timestamp 69 b2 00 1b // Bits 00 00 00 00 // Nonce Parent Block Coinbase Transaction: 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 35 // Script size 04 5d ee 09 1a 01 4d 52 2c fa be 6d 6d d8 a7 c3 e0 1e 1e 95 bc ee 01 5e 6f cc 75 83 a2 ca 60 b7 // Script 9e 5a 3a a0 a1 71 ed dd 34 4a da 90 3d 01 00 00 00 00 00 00 00 ff ff ff ff // Sequence Number 01 // TxOut Count 60 a0 10 2a 01 00 00 00 // Amount 43 // Script Size 41 04 f8 bb e9 7e d2 ac bc 5b ba 11 c6 8f 6f 1a 03 13 f9 18 f3 d3 c0 e8 47 50 55 e3 51 e3 bf 44 // Script 2f 8c 8d ce e6 82 d2 45 7b dc 53 51 b7 0d d9 e3 40 26 76 6e ba 18 b0 6e ae e2 e1 02 ef d1 ab 63 46 67 ac 00 00 00 00 // Lock Time Coinbase Link: a9 03 ef 9d e1 91 8e 4b 44 f6 17 6a 30 c0 e7 c7 e3 43 9c 96 fb 59 73 27 47 3d 00 00 00 00 00 00 // Hash of parent block header 05 // Number of links in branch 05 0a c4 a1 a1 e1 bc e0 c4 8e 55 5b 1a 9f 93 52 81 96 8c 72 d6 37 9b 24 72 9c a0 42 5a 3f c3 cb // Hash #1 43 3c d3 48 b3 5e a2 28 06 cf 21 c7 b1 46 48 9a ef 69 89 55 1e b5 ad 23 73 ab 61 21 06 0f 30 34 // Hash #2 1d 64 87 57 c0 21 7d 43 e6 6c 57 ea ed 64 fc 18 20 ec 65 d1 57 f3 3b 74 19 65 18 3a 5e 0c 85 06 // Hash #3 ac 26 02 df e2 f5 47 01 2d 1c c7 50 04 d4 8f 97 ab a4 6b d9 93 0f f2 85 c9 f2 76 f5 bd 09 f3 56 // Hash #4 df 19 72 45 79 d6 5e c7 cb 62 bf 97 94 6d fc 6f b0 e3 b2 83 9b 7f da b3 7c db 60 e5 51 22 d3 5b // Hash #5 00 00 00 00 // Branch sides bitmask Aux Blockchain Link: 00 // Number of links in branch 00 00 00 00 // Branch sides bitmask Parent Block Header: 01 00 00 00 // Version 08 be 13 29 5c 03 e6 7c b7 0d 00 da e8 1e a0 6e 78 b9 01 4e 5c eb 7d 9b a5 04 00 00 00 00 00 00 // Previous block hash e0 fd 42 db 8e f6 d7 83 f0 79 d1 26 be a1 2e 2d 10 c1 04 c0 92 7c d6 8f 95 4d 85 6f 9e 81 11 e5 // Merkle root 9a 23 90 4e // Timestamp 5d ee 09 1a // Bits 1c 65 50 86 // Nonce Transactions: 01 // Tx Count 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 08 // Script size 04 69 b2 00 1b 01 01 52 // Script ff ff ff ff // Sequence number 01 // TxOut Count 00 f2 05 2a 01 00 00 00 // Amount 43 // Script size 41 04 89 fe 91 e6 28 47 57 5c 98 de ea b0 20 f6 5f df f1 7a 3a 87 0e bb 05 82 0b 41 4f 3d 80 97 // Script 21 8e c9 a6 5f 1e 0a e0 ac 35 af 72 47 bd 79 ed 1f 2a 24 67 5f ff b5 aa 6f 96 20 e1 92 0a d4 bf 5a a6 ac 00 00 00 00 // Lock Time http://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work 非合并挖矿得到的namecoin block 合并挖矿的block，没有显示插入的AuxPow部分 bool CheckWork(CBlock* pblock, CWallet&amp; wallet, CReserveKey&amp; reservekey) { uint256 hash = pblock-&gt;GetHash(); uint256 hashTarget = CBigNum().SetCompact(pblock-&gt;nBits).getuint256(); CAuxPow *auxpow = pblock-&gt;auxpow.get(); if (auxpow != NULL) { if (!auxpow-&gt;Check(hash, pblock-&gt;GetChainID())) return error(&quot;AUX POW is not valid&quot;); if (auxpow-&gt;GetParentBlockHash() &gt; hashTarget) return error(&quot;AUX POW parent hash %s is not under target %s&quot;, auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); //// debug print printf(&quot;BitcoinMiner:\n&quot;); printf(&quot;AUX proof-of-work found \n our hash: %s \n parent hash: %s \n target: %s\n&quot;, hash.GetHex().c_str(), auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); } else { if (hash &gt; hashTarget) return false; //// debug print printf(&quot;BitcoinMiner:\n&quot;); printf(&quot;proof-of-work found \n hash: %s \ntarget: %s\n&quot;, hash.GetHex().c_str(), hashTarget.GetHex().c_str()); } pblock-&gt;print(); printf(&quot;%s &quot;, DateTimeStrFormat(&quot;%x %H:%M&quot;, GetTime()).c_str()); printf(&quot;generated %s\n&quot;, FormatMoney(pblock-&gt;vtx[0].vout[0].nValue).c_str()); // Found a solution CRITICAL_BLOCK(cs_main) { if (pblock-&gt;hashPrevBlock != hashBestChain) return error(&quot;BitcoinMiner : generated block is stale&quot;); // Remove key from key pool reservekey.KeepKey(); // Track how many getdata requests this block gets CRITICAL_BLOCK(wallet.cs_mapRequestCount) wallet.mapRequestCount[pblock-&gt;GetHash()] = 0; // Process this block the same as if we had received it from another node if (!ProcessBlock(NULL, pblock)) return error(&quot;BitcoinMiner : ProcessBlock, block not accepted&quot;); } Sleep(2000); return true; } bool CAuxPow::Check(uint256 hashAuxBlock, int nChainID) { if (nIndex != 0) return error(&quot;AuxPow is not a generate&quot;); if (!fTestNet &amp;&amp; parentBlock.GetChainID() == nChainID) return error(&quot;Aux POW parent has our chain ID&quot;); if (vChainMerkleBranch.size() &gt; 30) return error(&quot;Aux POW chain merkle branch too long&quot;); // Check that the chain merkle root is in the coinbase uint256 nRootHash = CBlock::CheckMerkleBranch(hashAuxBlock, vChainMerkleBranch, nChainIndex); vector&lt;unsigned char&gt; vchRootHash(nRootHash.begin(), nRootHash.end()); std::reverse(vchRootHash.begin(), vchRootHash.end()); // correct endian // Check that we are in the parent block merkle tree if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != parentBlock.hashMerkleRoot) return error(&quot;Aux POW merkle root incorrect&quot;); const CScript script = vin[0].scriptSig; // Check that the same work is not submitted twice to our chain. // CScript::const_iterator pcHead = std::search(script.begin(), script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader)); CScript::const_iterator pc = std::search(script.begin(), script.end(), vchRootHash.begin(), vchRootHash.end()); if (pc == script.end()) return error(&quot;Aux POW missing chain merkle root in parent coinbase&quot;); if (pcHead != script.end()) { // Enforce only one chain merkle root by checking that a single instance of the merged // mining header exists just before. if (script.end() != std::search(pcHead + 1, script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader))) return error(&quot;Multiple merged mining headers in coinbase&quot;); if (pcHead + sizeof(pchMergedMiningHeader) != pc) return error(&quot;Merged mining header is not just before chain merkle root&quot;); } else { // For backward compatibility. // Enforce only one chain merkle root by checking that it starts early in the coinbase. // 8-12 bytes are enough to encode extraNonce and nBits. if (pc - script.begin() &gt; 20) return error(&quot;Aux POW chain merkle root must start in the first 20 bytes of the parent coinbase&quot;); } // Ensure we are at a deterministic point in the merkle leaves by hashing // a nonce and our chain ID and comparing to the index. pc += vchRootHash.size(); if (script.end() - pc &lt; 8) return error(&quot;Aux POW missing chain merkle tree size and nonce in parent coinbase&quot;); int nSize; memcpy(&amp;nSize, &amp;pc[0], 4); if (nSize != (1 &lt;&lt; vChainMerkleBranch.size())) return error(&quot;Aux POW merkle branch size does not match parent coinbase&quot;); int nNonce; memcpy(&amp;nNonce, &amp;pc[4], 4); // Choose a pseudo-random slot in the chain merkle tree // but have it be fixed for a size/nonce/chain combination. // // This prevents the same work from being used twice for the // same chain while reducing the chance that two chains clash // for the same slot. unsigned int rand = nNonce; rand = rand * 1103515245 + 12345; rand += nChainID; rand = rand * 1103515245 + 12345; if (nChainIndex != (rand % nSize)) return error(&quot;Aux POW wrong index&quot;); return true; } 阅读更多" />
<meta property="og:description" content="NOTE: This standard is used by&nbsp;Namecoin, but new merged mining data should likely propose a new BIP to supercede it with something based on p2pool&#39;s merged mining. Contents &nbsp;[hide]&nbsp; 1&nbsp;Terminology 2&nbsp;Aux proof-of-work block 3&nbsp;Merkle Branch 4&nbsp;Merged mining coinbase 5&nbsp;Aux work merkle tree 6&nbsp;Example 7&nbsp;Notes Terminology Auxiliary Proof-of-Work (POW) a.k.a &quot;AuxPOW&quot;. This is the way that merged mining can exist; it is the relationship between two blockchains for one to trust the other&#39;s work as their own and accept AuxPOW blocks. Merged Mining The act of using work done on one blockchain on more than one chain, using Auxiliary POW. Auxiliary Blockchain The altcoin that is accepting work done on alternate chains as valid on its own chain. Client applications have to be modified to accept Auxiliary POW. Parent Blockchain The blockchain where the actual mining work is taking place. This chain does not need to be aware of the Auxiliary POW logic, as AuxPOW blocks submitted to this chain are still valid blocks. Parent Block Not to be confused with the &quot;previous block&quot;. This is a block that is structured for the parent blockchain (i.e. the&nbsp; prev_block&nbsp;hash points to the prior block on the parent blockchain). The header of this block is part of the AuxPOW Block in the auxiliary blockchain. AuxPOW Block This is a new type of block that is similar to a standard blockchain block, with two important differences. Firstly, the hash of the block header does NOT meet the difficulty level of the blockchain (so, if interpreted by a naive client, will be thrown out as not meeting the difficulty level). Secondly, it has additional data elements that show that the miner who created this block actually did mining activity (hashing) on the parent blockchain, and that work meets the difficulty level of the auxiliary blockchain, which is why this block should be accepted. Aux proof-of-work block This is used to prove work on the auxiliary blockchain. In vinced&#39;s original implementation it&#39;s generated by calling the&nbsp;getworkaux&nbsp;RPC method on the parent blockchain client (bitcoind) and then the work is then submitted by passing it to the auxiliary chain client (namecoind) as the second parameter to&nbsp;getauxblock. When receiving an Aux proof-of-work block in a&nbsp;&quot;block&quot; network message, the data received is similar to a standard block, but extra data is inserted between the&nbsp;nonce&nbsp;andtxn_count&nbsp;elements. In the below table, the shaded rows are the same as the standard block definition: Field Size Description Data type Comments 4 version uint32_t &nbsp; 32 prev_block char[32] &nbsp; 32 merkle_root char[32] &nbsp; 4 timestamp uint32_t &nbsp; 4 bits uint32_t &nbsp; 4 nonce uint32_t &nbsp; &nbsp;? coinbase_txn txn Coinbase transaction that is in the parent block,&nbsp;linking&nbsp;the AuxPOW block to its parent block 32 block_hash char[32] Hash of the&nbsp;parent_block&nbsp;header &nbsp;? coinbase_branch Merkle branch The merkle branch linking the&nbsp;coinbase_txn&nbsp;to the parent block&#39;s&nbsp;merkle_root &nbsp;? blockchain_branch Merkle branch The merkle branch linking this auxiliary blockchain to the others, when used in a merged mining setup with multiple auxiliary chains 80 parent_block Block header Parent block header &nbsp;? txn_count var_int &nbsp; &nbsp;? txns tx[] &nbsp; For the&nbsp;coinbase_branch&nbsp;merkle branch, because the coinbase transaction is the first transaction in the block (if using Bitcoin as a parent chain, i.e. hash #7 in the example given&nbsp;below), the&nbsp;branch_side_mask&nbsp;is always going to be all zeroes, because the branch hashes will always be &quot;on the right&quot; of the working hash. When only working on one auxiliary blockchain, the&nbsp;blockchain_branch&nbsp;link is not needed, and is nulled-out by being presented as 5 bytes of zeros (interpreted as a one-byte&nbsp;var_int&nbsp;indicating a&nbsp;branch_length&nbsp;of zero, and a 32-bit (4 byte)&nbsp;branch_side_mask&nbsp;of all zeroes). Note that the&nbsp;block_hash&nbsp;element is not needed as you have the full&nbsp;parent_block&nbsp;header element and can calculate the hash from that. The current Namecoin client doesn&#39;t check this field for validity, and as such some AuxPOW blocks have it little-endian, and some have it big-endian. Merkle Branch Say Alice created a Merkle tree, and it&#39;s root element is publicly available. For example: merkleRoot (0) / \ / \ 1 2 / \ / \ / \ / \ 3 4 5 6 / \ / \ / \ / \ 7 8 9 10 11 12 13 14 Now she wants to prove to Bob that a given hash (#10) was part of that tree, but Bob doesn&#39;t have the full tree (only the public root; hash #0). Alice can send Bob all the hashes she used to make the tree in the first place (hashes #7-#14, total of 7 extra hashes), so Bob can build the whole tree to verify the root is the same, but that&#39;s rather data-intensive. Instead, she could give Bob hashes #9, #3, and #2 (one from each level of the tree, working #10 back to the root). Without Bob knowing the structure of the tree, Alice also has to tell Bob what order to apply the hashes in (since&nbsp;hash(#9, #10) == #4, but&nbsp;hash(#10, #9)&nbsp;!= #4). So Alice tells Bob &quot;left, left, right&quot; to indicate which operand #9, #3, and #2 are, respectively. That can be encoded as a bitmask and take up very little data to transmit. So, instead of transmitting 7 hashes to Bob, Alice transmits 3 hashes and a bitmask. The data savings get even more pronounced if the merkle tree gets even bigger. That is the overall premise, and specifically for the AuxPOW protocol, it&#39;s been termed a &quot;merkle branch&quot; (since it&#39;s one pathway of a merkle tree), and is transmitted thus: Field Size Description Data type Comments &nbsp;? branch_length var_int The number of hashes making up the branch &nbsp;? branch_hash[] char[32] Individual hash in the branch; repeated&nbsp;branch_length&nbsp;number of times 4 branch_side_mask int32_t Bitmask of which side of the merkle hash function the&nbsp;branch_hash&nbsp;element should go on. Zero means it goes on the right, One means on the left. The first&nbsp;branch_hash&nbsp;is used first, and the least-significant bit of the&nbsp;branch_side_mask&nbsp;determines its hash position. Then the second&nbsp;branch_hash&nbsp;is applied with the second-least-significant bit of the&nbsp;branch_side_mask, etc. So for Alice&#39;s example,&nbsp;branch_length&nbsp;would be 3, the hashes would be given in the order #9, #3, then #2, and the&nbsp;branch_side_mask&nbsp;would be&nbsp;0b011&nbsp;= 3. Merged mining coinbase Insert exactly one of these headers into the&nbsp;scriptSig&nbsp;of the coinbase transaction in the parent block. Field Size Description Data type Comments 4 magic char[4] 0xfa,&nbsp;0xbe, &#39;m&#39;, &#39;m&#39;&nbsp;(only required if over 20 bytes past the start of the script; optional otherwise) 32 block_hash char[32] Hash of the AuxPOW block header 4 merkle_size int32_t Number of entries in aux work merkle tree.&nbsp;(Must be a power of 2) 4 merkle_nonce int32_t Nonce used to calculate indexes into aux work merkle tree; you may as well leave this at zero That string of 44 bytes being part of the coinbase script means that the miner constructed the AuxPOW Block before creating the coinbase. Aux work merkle tree If you&#39;re just mining a single auxiliary chain and using getauxblock, you don&#39;t have to worry about this - just set the merkle tree hash in the coinbase to the aux chain block&#39;s hash as given by getauxblock, the merkle size to 1, and the merkle nonce to 0. If you&#39;re mining more than one, this is a bit broken. It uses the following algorithm to convert the chain ID to a slot at the base of the merkle tree in which that chain&#39;s block hash must slot: unsigned int rand = merkle_nonce; rand = rand * 1103515245 + 12345; rand += chain_id; rand = rand * 1103515245 + 12345; slot_num = rand&nbsp;% merkle_size The idea is that you can increment merkle_nonce until the chains you&#39;re mining don&#39;t clash for the same slot. The trouble is that this doesn&#39;t work; because it just adds a number derived from the merkle_nonce to the chain_id, if two chains clash for one nonce they&#39;ll still clash for all possible nonces.[1]&nbsp;New implementers: please pick your chain_id so that not clashing with existing chains requires as small a value of merkle_size as possible, or use a better algorithm to calculate the slot id for your chain. Once you know where in the merkle tree the different chains go,&nbsp;reverse the bytes of each chain&#39;s block hash as given you by getauxblock&nbsp;(so the byte at the start moves to the end, etc) and insert into the appropriate slot, filling the unused ones with arbitrary data. Now build up the merkle tree as usual by taking each pair of values in the initial row and double SHA-256 hashing them to give a new row of hashes, repeating this until you only have a single hash. This last hash is the merkle root. You need toreverse the bytes of this again&nbsp;before inserting it into the coinbase. If you&#39;re not using getauxblock to get the block hash, you can skip the first reversal but still need to reverse the final merkle root when adding it to the coinbase. The aux proof-of-work also needs a merkle branch, which is built as follows: find the location of the block&#39;s hash in the merkle tree, and add the other value that you hashed it with in building the merkle tree. Now add the value you hashed that result with. Keep doing this until you reach the root. The merkle root itself is&nbsp;neverincluded in the merkle branch. If you just have a single aux chain, this can be left entirely empty. (It also appears you&nbsp;don&#39;t&nbsp;need to reverse these hashes.) Example This is the AuxPOW block at&nbsp;height 19200&nbsp;in the Namecoin chain (the first block that allowed AuxPOW authentication). It has a hash ofd8a7c3e01e1e95bcee015e6fcc7583a2ca60b79e5a3aa0a171eddd344ada903d, and only has one Namecoin transaction (coinbase sending 50 NMC to the miner&#39;s address). The parent block that was used as Proof of Work has a hash less than the difficulty target of Namecoin at the time, but not the Bitcoin target: 0000000000003d47277359fb969c43e3c7e7c0306a17f6444b8e91e19def03a9 -- parent block hash 000000000000b269000000000000000000000000000000000000000000000000 -- Namecoin difficulty target 00000000000009ee5d0000000000000000000000000000000000000000000000 -- Bitcoin difficulty target Hence, this AuxPOW block was valid in the Namecoin blockchain, but not in the Bitcoin blockchain (you will find no Bitcoin block with the hash starting&nbsp;3d47277359fb969c. If it were, it would be right after&nbsp;4a59b7deb5c4e01b, since that&#39;s the&nbsp;previous_block&nbsp;hash used) Block Header: 01 01 01 00 // Version 36 90 9a c0 7a 16 73 da f6 5f a7 d8 28 88 2e 66 c9 e8 9f 85 46 cd d5 0a 9f b1 00 00 00 00 00 00 // Previous block hash 0f 5c 65 49 bc d6 08 ab 7c 4e ac 59 3e 5b d5 a7 3b 2d 43 2e b6 35 18 70 8f 77 8f c7 dc df af 88 // Merkle root 8d 1a 90 4e // Timestamp 69 b2 00 1b // Bits 00 00 00 00 // Nonce Parent Block Coinbase Transaction: 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 35 // Script size 04 5d ee 09 1a 01 4d 52 2c fa be 6d 6d d8 a7 c3 e0 1e 1e 95 bc ee 01 5e 6f cc 75 83 a2 ca 60 b7 // Script 9e 5a 3a a0 a1 71 ed dd 34 4a da 90 3d 01 00 00 00 00 00 00 00 ff ff ff ff // Sequence Number 01 // TxOut Count 60 a0 10 2a 01 00 00 00 // Amount 43 // Script Size 41 04 f8 bb e9 7e d2 ac bc 5b ba 11 c6 8f 6f 1a 03 13 f9 18 f3 d3 c0 e8 47 50 55 e3 51 e3 bf 44 // Script 2f 8c 8d ce e6 82 d2 45 7b dc 53 51 b7 0d d9 e3 40 26 76 6e ba 18 b0 6e ae e2 e1 02 ef d1 ab 63 46 67 ac 00 00 00 00 // Lock Time Coinbase Link: a9 03 ef 9d e1 91 8e 4b 44 f6 17 6a 30 c0 e7 c7 e3 43 9c 96 fb 59 73 27 47 3d 00 00 00 00 00 00 // Hash of parent block header 05 // Number of links in branch 05 0a c4 a1 a1 e1 bc e0 c4 8e 55 5b 1a 9f 93 52 81 96 8c 72 d6 37 9b 24 72 9c a0 42 5a 3f c3 cb // Hash #1 43 3c d3 48 b3 5e a2 28 06 cf 21 c7 b1 46 48 9a ef 69 89 55 1e b5 ad 23 73 ab 61 21 06 0f 30 34 // Hash #2 1d 64 87 57 c0 21 7d 43 e6 6c 57 ea ed 64 fc 18 20 ec 65 d1 57 f3 3b 74 19 65 18 3a 5e 0c 85 06 // Hash #3 ac 26 02 df e2 f5 47 01 2d 1c c7 50 04 d4 8f 97 ab a4 6b d9 93 0f f2 85 c9 f2 76 f5 bd 09 f3 56 // Hash #4 df 19 72 45 79 d6 5e c7 cb 62 bf 97 94 6d fc 6f b0 e3 b2 83 9b 7f da b3 7c db 60 e5 51 22 d3 5b // Hash #5 00 00 00 00 // Branch sides bitmask Aux Blockchain Link: 00 // Number of links in branch 00 00 00 00 // Branch sides bitmask Parent Block Header: 01 00 00 00 // Version 08 be 13 29 5c 03 e6 7c b7 0d 00 da e8 1e a0 6e 78 b9 01 4e 5c eb 7d 9b a5 04 00 00 00 00 00 00 // Previous block hash e0 fd 42 db 8e f6 d7 83 f0 79 d1 26 be a1 2e 2d 10 c1 04 c0 92 7c d6 8f 95 4d 85 6f 9e 81 11 e5 // Merkle root 9a 23 90 4e // Timestamp 5d ee 09 1a // Bits 1c 65 50 86 // Nonce Transactions: 01 // Tx Count 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 08 // Script size 04 69 b2 00 1b 01 01 52 // Script ff ff ff ff // Sequence number 01 // TxOut Count 00 f2 05 2a 01 00 00 00 // Amount 43 // Script size 41 04 89 fe 91 e6 28 47 57 5c 98 de ea b0 20 f6 5f df f1 7a 3a 87 0e bb 05 82 0b 41 4f 3d 80 97 // Script 21 8e c9 a6 5f 1e 0a e0 ac 35 af 72 47 bd 79 ed 1f 2a 24 67 5f ff b5 aa 6f 96 20 e1 92 0a d4 bf 5a a6 ac 00 00 00 00 // Lock Time http://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work 非合并挖矿得到的namecoin block 合并挖矿的block，没有显示插入的AuxPow部分 bool CheckWork(CBlock* pblock, CWallet&amp; wallet, CReserveKey&amp; reservekey) { uint256 hash = pblock-&gt;GetHash(); uint256 hashTarget = CBigNum().SetCompact(pblock-&gt;nBits).getuint256(); CAuxPow *auxpow = pblock-&gt;auxpow.get(); if (auxpow != NULL) { if (!auxpow-&gt;Check(hash, pblock-&gt;GetChainID())) return error(&quot;AUX POW is not valid&quot;); if (auxpow-&gt;GetParentBlockHash() &gt; hashTarget) return error(&quot;AUX POW parent hash %s is not under target %s&quot;, auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); //// debug print printf(&quot;BitcoinMiner:\n&quot;); printf(&quot;AUX proof-of-work found \n our hash: %s \n parent hash: %s \n target: %s\n&quot;, hash.GetHex().c_str(), auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); } else { if (hash &gt; hashTarget) return false; //// debug print printf(&quot;BitcoinMiner:\n&quot;); printf(&quot;proof-of-work found \n hash: %s \ntarget: %s\n&quot;, hash.GetHex().c_str(), hashTarget.GetHex().c_str()); } pblock-&gt;print(); printf(&quot;%s &quot;, DateTimeStrFormat(&quot;%x %H:%M&quot;, GetTime()).c_str()); printf(&quot;generated %s\n&quot;, FormatMoney(pblock-&gt;vtx[0].vout[0].nValue).c_str()); // Found a solution CRITICAL_BLOCK(cs_main) { if (pblock-&gt;hashPrevBlock != hashBestChain) return error(&quot;BitcoinMiner : generated block is stale&quot;); // Remove key from key pool reservekey.KeepKey(); // Track how many getdata requests this block gets CRITICAL_BLOCK(wallet.cs_mapRequestCount) wallet.mapRequestCount[pblock-&gt;GetHash()] = 0; // Process this block the same as if we had received it from another node if (!ProcessBlock(NULL, pblock)) return error(&quot;BitcoinMiner : ProcessBlock, block not accepted&quot;); } Sleep(2000); return true; } bool CAuxPow::Check(uint256 hashAuxBlock, int nChainID) { if (nIndex != 0) return error(&quot;AuxPow is not a generate&quot;); if (!fTestNet &amp;&amp; parentBlock.GetChainID() == nChainID) return error(&quot;Aux POW parent has our chain ID&quot;); if (vChainMerkleBranch.size() &gt; 30) return error(&quot;Aux POW chain merkle branch too long&quot;); // Check that the chain merkle root is in the coinbase uint256 nRootHash = CBlock::CheckMerkleBranch(hashAuxBlock, vChainMerkleBranch, nChainIndex); vector&lt;unsigned char&gt; vchRootHash(nRootHash.begin(), nRootHash.end()); std::reverse(vchRootHash.begin(), vchRootHash.end()); // correct endian // Check that we are in the parent block merkle tree if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != parentBlock.hashMerkleRoot) return error(&quot;Aux POW merkle root incorrect&quot;); const CScript script = vin[0].scriptSig; // Check that the same work is not submitted twice to our chain. // CScript::const_iterator pcHead = std::search(script.begin(), script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader)); CScript::const_iterator pc = std::search(script.begin(), script.end(), vchRootHash.begin(), vchRootHash.end()); if (pc == script.end()) return error(&quot;Aux POW missing chain merkle root in parent coinbase&quot;); if (pcHead != script.end()) { // Enforce only one chain merkle root by checking that a single instance of the merged // mining header exists just before. if (script.end() != std::search(pcHead + 1, script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader))) return error(&quot;Multiple merged mining headers in coinbase&quot;); if (pcHead + sizeof(pchMergedMiningHeader) != pc) return error(&quot;Merged mining header is not just before chain merkle root&quot;); } else { // For backward compatibility. // Enforce only one chain merkle root by checking that it starts early in the coinbase. // 8-12 bytes are enough to encode extraNonce and nBits. if (pc - script.begin() &gt; 20) return error(&quot;Aux POW chain merkle root must start in the first 20 bytes of the parent coinbase&quot;); } // Ensure we are at a deterministic point in the merkle leaves by hashing // a nonce and our chain ID and comparing to the index. pc += vchRootHash.size(); if (script.end() - pc &lt; 8) return error(&quot;Aux POW missing chain merkle tree size and nonce in parent coinbase&quot;); int nSize; memcpy(&amp;nSize, &amp;pc[0], 4); if (nSize != (1 &lt;&lt; vChainMerkleBranch.size())) return error(&quot;Aux POW merkle branch size does not match parent coinbase&quot;); int nNonce; memcpy(&amp;nNonce, &amp;pc[4], 4); // Choose a pseudo-random slot in the chain merkle tree // but have it be fixed for a size/nonce/chain combination. // // This prevents the same work from being used twice for the // same chain while reducing the chance that two chains clash // for the same slot. unsigned int rand = nNonce; rand = rand * 1103515245 + 12345; rand += nChainID; rand = rand * 1103515245 + 12345; if (nChainIndex != (rand % nSize)) return error(&quot;Aux POW wrong index&quot;); return true; } 阅读更多" />
<link rel="canonical" href="https://mlh.app/2015/01/06/ae4b2b85fc20bc9abc8d9eae347fe65b.html" />
<meta property="og:url" content="https://mlh.app/2015/01/06/ae4b2b85fc20bc9abc8d9eae347fe65b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-01-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"NOTE: This standard is used by&nbsp;Namecoin, but new merged mining data should likely propose a new BIP to supercede it with something based on p2pool&#39;s merged mining. Contents &nbsp;[hide]&nbsp; 1&nbsp;Terminology 2&nbsp;Aux proof-of-work block 3&nbsp;Merkle Branch 4&nbsp;Merged mining coinbase 5&nbsp;Aux work merkle tree 6&nbsp;Example 7&nbsp;Notes Terminology Auxiliary Proof-of-Work (POW) a.k.a &quot;AuxPOW&quot;. This is the way that merged mining can exist; it is the relationship between two blockchains for one to trust the other&#39;s work as their own and accept AuxPOW blocks. Merged Mining The act of using work done on one blockchain on more than one chain, using Auxiliary POW. Auxiliary Blockchain The altcoin that is accepting work done on alternate chains as valid on its own chain. Client applications have to be modified to accept Auxiliary POW. Parent Blockchain The blockchain where the actual mining work is taking place. This chain does not need to be aware of the Auxiliary POW logic, as AuxPOW blocks submitted to this chain are still valid blocks. Parent Block Not to be confused with the &quot;previous block&quot;. This is a block that is structured for the parent blockchain (i.e. the&nbsp; prev_block&nbsp;hash points to the prior block on the parent blockchain). The header of this block is part of the AuxPOW Block in the auxiliary blockchain. AuxPOW Block This is a new type of block that is similar to a standard blockchain block, with two important differences. Firstly, the hash of the block header does NOT meet the difficulty level of the blockchain (so, if interpreted by a naive client, will be thrown out as not meeting the difficulty level). Secondly, it has additional data elements that show that the miner who created this block actually did mining activity (hashing) on the parent blockchain, and that work meets the difficulty level of the auxiliary blockchain, which is why this block should be accepted. Aux proof-of-work block This is used to prove work on the auxiliary blockchain. In vinced&#39;s original implementation it&#39;s generated by calling the&nbsp;getworkaux&nbsp;RPC method on the parent blockchain client (bitcoind) and then the work is then submitted by passing it to the auxiliary chain client (namecoind) as the second parameter to&nbsp;getauxblock. When receiving an Aux proof-of-work block in a&nbsp;&quot;block&quot; network message, the data received is similar to a standard block, but extra data is inserted between the&nbsp;nonce&nbsp;andtxn_count&nbsp;elements. In the below table, the shaded rows are the same as the standard block definition: Field Size Description Data type Comments 4 version uint32_t &nbsp; 32 prev_block char[32] &nbsp; 32 merkle_root char[32] &nbsp; 4 timestamp uint32_t &nbsp; 4 bits uint32_t &nbsp; 4 nonce uint32_t &nbsp; &nbsp;? coinbase_txn txn Coinbase transaction that is in the parent block,&nbsp;linking&nbsp;the AuxPOW block to its parent block 32 block_hash char[32] Hash of the&nbsp;parent_block&nbsp;header &nbsp;? coinbase_branch Merkle branch The merkle branch linking the&nbsp;coinbase_txn&nbsp;to the parent block&#39;s&nbsp;merkle_root &nbsp;? blockchain_branch Merkle branch The merkle branch linking this auxiliary blockchain to the others, when used in a merged mining setup with multiple auxiliary chains 80 parent_block Block header Parent block header &nbsp;? txn_count var_int &nbsp; &nbsp;? txns tx[] &nbsp; For the&nbsp;coinbase_branch&nbsp;merkle branch, because the coinbase transaction is the first transaction in the block (if using Bitcoin as a parent chain, i.e. hash #7 in the example given&nbsp;below), the&nbsp;branch_side_mask&nbsp;is always going to be all zeroes, because the branch hashes will always be &quot;on the right&quot; of the working hash. When only working on one auxiliary blockchain, the&nbsp;blockchain_branch&nbsp;link is not needed, and is nulled-out by being presented as 5 bytes of zeros (interpreted as a one-byte&nbsp;var_int&nbsp;indicating a&nbsp;branch_length&nbsp;of zero, and a 32-bit (4 byte)&nbsp;branch_side_mask&nbsp;of all zeroes). Note that the&nbsp;block_hash&nbsp;element is not needed as you have the full&nbsp;parent_block&nbsp;header element and can calculate the hash from that. The current Namecoin client doesn&#39;t check this field for validity, and as such some AuxPOW blocks have it little-endian, and some have it big-endian. Merkle Branch Say Alice created a Merkle tree, and it&#39;s root element is publicly available. For example: merkleRoot (0) / \\ / \\ 1 2 / \\ / \\ / \\ / \\ 3 4 5 6 / \\ / \\ / \\ / \\ 7 8 9 10 11 12 13 14 Now she wants to prove to Bob that a given hash (#10) was part of that tree, but Bob doesn&#39;t have the full tree (only the public root; hash #0). Alice can send Bob all the hashes she used to make the tree in the first place (hashes #7-#14, total of 7 extra hashes), so Bob can build the whole tree to verify the root is the same, but that&#39;s rather data-intensive. Instead, she could give Bob hashes #9, #3, and #2 (one from each level of the tree, working #10 back to the root). Without Bob knowing the structure of the tree, Alice also has to tell Bob what order to apply the hashes in (since&nbsp;hash(#9, #10) == #4, but&nbsp;hash(#10, #9)&nbsp;!= #4). So Alice tells Bob &quot;left, left, right&quot; to indicate which operand #9, #3, and #2 are, respectively. That can be encoded as a bitmask and take up very little data to transmit. So, instead of transmitting 7 hashes to Bob, Alice transmits 3 hashes and a bitmask. The data savings get even more pronounced if the merkle tree gets even bigger. That is the overall premise, and specifically for the AuxPOW protocol, it&#39;s been termed a &quot;merkle branch&quot; (since it&#39;s one pathway of a merkle tree), and is transmitted thus: Field Size Description Data type Comments &nbsp;? branch_length var_int The number of hashes making up the branch &nbsp;? branch_hash[] char[32] Individual hash in the branch; repeated&nbsp;branch_length&nbsp;number of times 4 branch_side_mask int32_t Bitmask of which side of the merkle hash function the&nbsp;branch_hash&nbsp;element should go on. Zero means it goes on the right, One means on the left. The first&nbsp;branch_hash&nbsp;is used first, and the least-significant bit of the&nbsp;branch_side_mask&nbsp;determines its hash position. Then the second&nbsp;branch_hash&nbsp;is applied with the second-least-significant bit of the&nbsp;branch_side_mask, etc. So for Alice&#39;s example,&nbsp;branch_length&nbsp;would be 3, the hashes would be given in the order #9, #3, then #2, and the&nbsp;branch_side_mask&nbsp;would be&nbsp;0b011&nbsp;= 3. Merged mining coinbase Insert exactly one of these headers into the&nbsp;scriptSig&nbsp;of the coinbase transaction in the parent block. Field Size Description Data type Comments 4 magic char[4] 0xfa,&nbsp;0xbe, &#39;m&#39;, &#39;m&#39;&nbsp;(only required if over 20 bytes past the start of the script; optional otherwise) 32 block_hash char[32] Hash of the AuxPOW block header 4 merkle_size int32_t Number of entries in aux work merkle tree.&nbsp;(Must be a power of 2) 4 merkle_nonce int32_t Nonce used to calculate indexes into aux work merkle tree; you may as well leave this at zero That string of 44 bytes being part of the coinbase script means that the miner constructed the AuxPOW Block before creating the coinbase. Aux work merkle tree If you&#39;re just mining a single auxiliary chain and using getauxblock, you don&#39;t have to worry about this - just set the merkle tree hash in the coinbase to the aux chain block&#39;s hash as given by getauxblock, the merkle size to 1, and the merkle nonce to 0. If you&#39;re mining more than one, this is a bit broken. It uses the following algorithm to convert the chain ID to a slot at the base of the merkle tree in which that chain&#39;s block hash must slot: unsigned int rand = merkle_nonce; rand = rand * 1103515245 + 12345; rand += chain_id; rand = rand * 1103515245 + 12345; slot_num = rand&nbsp;% merkle_size The idea is that you can increment merkle_nonce until the chains you&#39;re mining don&#39;t clash for the same slot. The trouble is that this doesn&#39;t work; because it just adds a number derived from the merkle_nonce to the chain_id, if two chains clash for one nonce they&#39;ll still clash for all possible nonces.[1]&nbsp;New implementers: please pick your chain_id so that not clashing with existing chains requires as small a value of merkle_size as possible, or use a better algorithm to calculate the slot id for your chain. Once you know where in the merkle tree the different chains go,&nbsp;reverse the bytes of each chain&#39;s block hash as given you by getauxblock&nbsp;(so the byte at the start moves to the end, etc) and insert into the appropriate slot, filling the unused ones with arbitrary data. Now build up the merkle tree as usual by taking each pair of values in the initial row and double SHA-256 hashing them to give a new row of hashes, repeating this until you only have a single hash. This last hash is the merkle root. You need toreverse the bytes of this again&nbsp;before inserting it into the coinbase. If you&#39;re not using getauxblock to get the block hash, you can skip the first reversal but still need to reverse the final merkle root when adding it to the coinbase. The aux proof-of-work also needs a merkle branch, which is built as follows: find the location of the block&#39;s hash in the merkle tree, and add the other value that you hashed it with in building the merkle tree. Now add the value you hashed that result with. Keep doing this until you reach the root. The merkle root itself is&nbsp;neverincluded in the merkle branch. If you just have a single aux chain, this can be left entirely empty. (It also appears you&nbsp;don&#39;t&nbsp;need to reverse these hashes.) Example This is the AuxPOW block at&nbsp;height 19200&nbsp;in the Namecoin chain (the first block that allowed AuxPOW authentication). It has a hash ofd8a7c3e01e1e95bcee015e6fcc7583a2ca60b79e5a3aa0a171eddd344ada903d, and only has one Namecoin transaction (coinbase sending 50 NMC to the miner&#39;s address). The parent block that was used as Proof of Work has a hash less than the difficulty target of Namecoin at the time, but not the Bitcoin target: 0000000000003d47277359fb969c43e3c7e7c0306a17f6444b8e91e19def03a9 -- parent block hash 000000000000b269000000000000000000000000000000000000000000000000 -- Namecoin difficulty target 00000000000009ee5d0000000000000000000000000000000000000000000000 -- Bitcoin difficulty target Hence, this AuxPOW block was valid in the Namecoin blockchain, but not in the Bitcoin blockchain (you will find no Bitcoin block with the hash starting&nbsp;3d47277359fb969c. If it were, it would be right after&nbsp;4a59b7deb5c4e01b, since that&#39;s the&nbsp;previous_block&nbsp;hash used) Block Header: 01 01 01 00 // Version 36 90 9a c0 7a 16 73 da f6 5f a7 d8 28 88 2e 66 c9 e8 9f 85 46 cd d5 0a 9f b1 00 00 00 00 00 00 // Previous block hash 0f 5c 65 49 bc d6 08 ab 7c 4e ac 59 3e 5b d5 a7 3b 2d 43 2e b6 35 18 70 8f 77 8f c7 dc df af 88 // Merkle root 8d 1a 90 4e // Timestamp 69 b2 00 1b // Bits 00 00 00 00 // Nonce Parent Block Coinbase Transaction: 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 35 // Script size 04 5d ee 09 1a 01 4d 52 2c fa be 6d 6d d8 a7 c3 e0 1e 1e 95 bc ee 01 5e 6f cc 75 83 a2 ca 60 b7 // Script 9e 5a 3a a0 a1 71 ed dd 34 4a da 90 3d 01 00 00 00 00 00 00 00 ff ff ff ff // Sequence Number 01 // TxOut Count 60 a0 10 2a 01 00 00 00 // Amount 43 // Script Size 41 04 f8 bb e9 7e d2 ac bc 5b ba 11 c6 8f 6f 1a 03 13 f9 18 f3 d3 c0 e8 47 50 55 e3 51 e3 bf 44 // Script 2f 8c 8d ce e6 82 d2 45 7b dc 53 51 b7 0d d9 e3 40 26 76 6e ba 18 b0 6e ae e2 e1 02 ef d1 ab 63 46 67 ac 00 00 00 00 // Lock Time Coinbase Link: a9 03 ef 9d e1 91 8e 4b 44 f6 17 6a 30 c0 e7 c7 e3 43 9c 96 fb 59 73 27 47 3d 00 00 00 00 00 00 // Hash of parent block header 05 // Number of links in branch 05 0a c4 a1 a1 e1 bc e0 c4 8e 55 5b 1a 9f 93 52 81 96 8c 72 d6 37 9b 24 72 9c a0 42 5a 3f c3 cb // Hash #1 43 3c d3 48 b3 5e a2 28 06 cf 21 c7 b1 46 48 9a ef 69 89 55 1e b5 ad 23 73 ab 61 21 06 0f 30 34 // Hash #2 1d 64 87 57 c0 21 7d 43 e6 6c 57 ea ed 64 fc 18 20 ec 65 d1 57 f3 3b 74 19 65 18 3a 5e 0c 85 06 // Hash #3 ac 26 02 df e2 f5 47 01 2d 1c c7 50 04 d4 8f 97 ab a4 6b d9 93 0f f2 85 c9 f2 76 f5 bd 09 f3 56 // Hash #4 df 19 72 45 79 d6 5e c7 cb 62 bf 97 94 6d fc 6f b0 e3 b2 83 9b 7f da b3 7c db 60 e5 51 22 d3 5b // Hash #5 00 00 00 00 // Branch sides bitmask Aux Blockchain Link: 00 // Number of links in branch 00 00 00 00 // Branch sides bitmask Parent Block Header: 01 00 00 00 // Version 08 be 13 29 5c 03 e6 7c b7 0d 00 da e8 1e a0 6e 78 b9 01 4e 5c eb 7d 9b a5 04 00 00 00 00 00 00 // Previous block hash e0 fd 42 db 8e f6 d7 83 f0 79 d1 26 be a1 2e 2d 10 c1 04 c0 92 7c d6 8f 95 4d 85 6f 9e 81 11 e5 // Merkle root 9a 23 90 4e // Timestamp 5d ee 09 1a // Bits 1c 65 50 86 // Nonce Transactions: 01 // Tx Count 01 00 00 00 // Version 01 // TxIn Count 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // Previous Out 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 08 // Script size 04 69 b2 00 1b 01 01 52 // Script ff ff ff ff // Sequence number 01 // TxOut Count 00 f2 05 2a 01 00 00 00 // Amount 43 // Script size 41 04 89 fe 91 e6 28 47 57 5c 98 de ea b0 20 f6 5f df f1 7a 3a 87 0e bb 05 82 0b 41 4f 3d 80 97 // Script 21 8e c9 a6 5f 1e 0a e0 ac 35 af 72 47 bd 79 ed 1f 2a 24 67 5f ff b5 aa 6f 96 20 e1 92 0a d4 bf 5a a6 ac 00 00 00 00 // Lock Time http://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work 非合并挖矿得到的namecoin block 合并挖矿的block，没有显示插入的AuxPow部分 bool CheckWork(CBlock* pblock, CWallet&amp; wallet, CReserveKey&amp; reservekey) { uint256 hash = pblock-&gt;GetHash(); uint256 hashTarget = CBigNum().SetCompact(pblock-&gt;nBits).getuint256(); CAuxPow *auxpow = pblock-&gt;auxpow.get(); if (auxpow != NULL) { if (!auxpow-&gt;Check(hash, pblock-&gt;GetChainID())) return error(&quot;AUX POW is not valid&quot;); if (auxpow-&gt;GetParentBlockHash() &gt; hashTarget) return error(&quot;AUX POW parent hash %s is not under target %s&quot;, auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); //// debug print printf(&quot;BitcoinMiner:\\n&quot;); printf(&quot;AUX proof-of-work found \\n our hash: %s \\n parent hash: %s \\n target: %s\\n&quot;, hash.GetHex().c_str(), auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str()); } else { if (hash &gt; hashTarget) return false; //// debug print printf(&quot;BitcoinMiner:\\n&quot;); printf(&quot;proof-of-work found \\n hash: %s \\ntarget: %s\\n&quot;, hash.GetHex().c_str(), hashTarget.GetHex().c_str()); } pblock-&gt;print(); printf(&quot;%s &quot;, DateTimeStrFormat(&quot;%x %H:%M&quot;, GetTime()).c_str()); printf(&quot;generated %s\\n&quot;, FormatMoney(pblock-&gt;vtx[0].vout[0].nValue).c_str()); // Found a solution CRITICAL_BLOCK(cs_main) { if (pblock-&gt;hashPrevBlock != hashBestChain) return error(&quot;BitcoinMiner : generated block is stale&quot;); // Remove key from key pool reservekey.KeepKey(); // Track how many getdata requests this block gets CRITICAL_BLOCK(wallet.cs_mapRequestCount) wallet.mapRequestCount[pblock-&gt;GetHash()] = 0; // Process this block the same as if we had received it from another node if (!ProcessBlock(NULL, pblock)) return error(&quot;BitcoinMiner : ProcessBlock, block not accepted&quot;); } Sleep(2000); return true; } bool CAuxPow::Check(uint256 hashAuxBlock, int nChainID) { if (nIndex != 0) return error(&quot;AuxPow is not a generate&quot;); if (!fTestNet &amp;&amp; parentBlock.GetChainID() == nChainID) return error(&quot;Aux POW parent has our chain ID&quot;); if (vChainMerkleBranch.size() &gt; 30) return error(&quot;Aux POW chain merkle branch too long&quot;); // Check that the chain merkle root is in the coinbase uint256 nRootHash = CBlock::CheckMerkleBranch(hashAuxBlock, vChainMerkleBranch, nChainIndex); vector&lt;unsigned char&gt; vchRootHash(nRootHash.begin(), nRootHash.end()); std::reverse(vchRootHash.begin(), vchRootHash.end()); // correct endian // Check that we are in the parent block merkle tree if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != parentBlock.hashMerkleRoot) return error(&quot;Aux POW merkle root incorrect&quot;); const CScript script = vin[0].scriptSig; // Check that the same work is not submitted twice to our chain. // CScript::const_iterator pcHead = std::search(script.begin(), script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader)); CScript::const_iterator pc = std::search(script.begin(), script.end(), vchRootHash.begin(), vchRootHash.end()); if (pc == script.end()) return error(&quot;Aux POW missing chain merkle root in parent coinbase&quot;); if (pcHead != script.end()) { // Enforce only one chain merkle root by checking that a single instance of the merged // mining header exists just before. if (script.end() != std::search(pcHead + 1, script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader))) return error(&quot;Multiple merged mining headers in coinbase&quot;); if (pcHead + sizeof(pchMergedMiningHeader) != pc) return error(&quot;Merged mining header is not just before chain merkle root&quot;); } else { // For backward compatibility. // Enforce only one chain merkle root by checking that it starts early in the coinbase. // 8-12 bytes are enough to encode extraNonce and nBits. if (pc - script.begin() &gt; 20) return error(&quot;Aux POW chain merkle root must start in the first 20 bytes of the parent coinbase&quot;); } // Ensure we are at a deterministic point in the merkle leaves by hashing // a nonce and our chain ID and comparing to the index. pc += vchRootHash.size(); if (script.end() - pc &lt; 8) return error(&quot;Aux POW missing chain merkle tree size and nonce in parent coinbase&quot;); int nSize; memcpy(&amp;nSize, &amp;pc[0], 4); if (nSize != (1 &lt;&lt; vChainMerkleBranch.size())) return error(&quot;Aux POW merkle branch size does not match parent coinbase&quot;); int nNonce; memcpy(&amp;nNonce, &amp;pc[4], 4); // Choose a pseudo-random slot in the chain merkle tree // but have it be fixed for a size/nonce/chain combination. // // This prevents the same work from being used twice for the // same chain while reducing the chance that two chains clash // for the same slot. unsigned int rand = nNonce; rand = rand * 1103515245 + 12345; rand += nChainID; rand = rand * 1103515245 + 12345; if (nChainIndex != (rand % nSize)) return error(&quot;Aux POW wrong index&quot;); return true; } 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2015/01/06/ae4b2b85fc20bc9abc8d9eae347fe65b.html","headline":"【比特币】Namecoin原理","dateModified":"2015-01-06T00:00:00+08:00","datePublished":"2015-01-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2015/01/06/ae4b2b85fc20bc9abc8d9eae347fe65b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【比特币】Namecoin原理</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="line-height:inherit;color:rgb(37,37,37);font-family:sans-serif;font-size:.875em;"><span style="color:rgb(37,37,37);font-family:sans-serif;">N</span>OTE: This standard is used by&nbsp;</span><a href="https://en.bitcoin.it/wiki/Namecoin" rel="nofollow" title="Namecoin" class="mw-redirect" style="line-height:inherit;font-family:sans-serif;font-size:.875em;text-decoration:none;color:rgb(11,0,128);background:none;">Namecoin</a><span style="line-height:inherit;color:rgb(37,37,37);font-family:sans-serif;font-size:.875em;">, but new merged mining data should likely propose a new BIP to supercede it with something based on p2pool's merged mining.</span></p> 
  <div id="bodyContent" style="line-height:1.6;font-size:.875em;color:rgb(37,37,37);font-family:sans-serif;"> 
   <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr" xml:lang="en"> 
    <div id="toc" class="toc" style="border:1px solid rgb(170,170,170);font-size:13px;display:table;background-color:rgb(249,249,249);"> 
     <div id="toctitle" style="text-align:center;"> 
      <h2 style="color:#000000;overflow:hidden;border:none;font-size:13px;display:inline;line-height:1.3;background:none;"> Contents</h2> 
      <span class="toctoggle">&nbsp;[<a href="https://en.bitcoin.it/wiki/Merged_mining_specification#" rel="nofollow" class="internal" id="togglelink" style="text-decoration:none;color:rgb(11,0,128);background:none;">hide</a>]&nbsp;</span>
     </div> 
     <ul style="line-height:1.5em;list-style-type:none;">
      <li class="toclevel-1 tocsection-1"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Terminology" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">1</span>&nbsp;<span class="toctext">Terminology</span></a></li>
      <li class="toclevel-1 tocsection-2"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Aux_proof-of-work_block" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">2</span>&nbsp;<span class="toctext">Aux proof-of-work block</span></a></li>
      <li class="toclevel-1 tocsection-3"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merkle_Branch" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">3</span>&nbsp;<span class="toctext">Merkle Branch</span></a></li>
      <li class="toclevel-1 tocsection-4"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merged_mining_coinbase" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">4</span>&nbsp;<span class="toctext">Merged mining coinbase</span></a></li>
      <li class="toclevel-1 tocsection-5"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Aux_work_merkle_tree" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">5</span>&nbsp;<span class="toctext">Aux work merkle tree</span></a></li>
      <li class="toclevel-1 tocsection-6"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Example" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">6</span>&nbsp;<span class="toctext">Example</span></a></li>
      <li class="toclevel-1 tocsection-7"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Notes" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;"><span class="tocnumber">7</span>&nbsp;<span class="toctext">Notes</span></a></li>
     </ul>
    </div> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Terminology">Terminology</span></h2> 
    <dl>
     <dt style="font-weight:bold;">
       Auxiliary Proof-of-Work (POW)
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       a.k.a "AuxPOW". This is the way that merged mining can exist; it is the relationship between two blockchains for one to trust the other's work as their own and accept AuxPOW blocks.
     </dd>
     <dt style="font-weight:bold;">
      Merged Mining
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       The act of using work done on one blockchain on more than one chain, using Auxiliary POW.
     </dd>
    </dl>
    <hr style="color:rgb(170,170,170);border:0px;background-color:rgb(170,170,170);">
    <dl>
     <dt style="font-weight:bold;">
       Auxiliary Blockchain
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       The altcoin that is accepting work done on alternate chains as valid on its own chain. Client applications have to be modified to accept Auxiliary POW.
     </dd>
     <dt style="font-weight:bold;">
      Parent Blockchain
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       The blockchain where the actual mining work is taking place. This chain does not need to be aware of the Auxiliary POW logic, as AuxPOW blocks submitted to this chain are still valid blocks.
     </dd>
    </dl>
    <hr style="color:rgb(170,170,170);border:0px;background-color:rgb(170,170,170);">
    <dl>
     <dt style="font-weight:bold;">
       Parent Block
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       Not to be confused with the "previous block". This is a block that is structured for the parent blockchain (i.e. the&nbsp;
      <tt style="font-family:monospace, Courier;">prev_block</tt>&nbsp;hash points to the prior block on the parent blockchain). The header of this block is part of the AuxPOW Block in the auxiliary blockchain.
     </dd>
     <dt style="font-weight:bold;">
      AuxPOW Block
     </dt>
     <dd style="line-height:1.5em;margin-left:1.6em;">
       This is a new type of block that is similar to a standard blockchain block, with two important differences. Firstly, the hash of the block header does NOT meet the difficulty level of the blockchain (so, if interpreted by a naive client, will be thrown out as not meeting the difficulty level). Secondly, it has additional data elements that show that the miner who created this block actually did mining activity (hashing) on the parent blockchain, and that work meets the difficulty level of the auxiliary blockchain, which is why this block should be accepted.
     </dd>
    </dl>
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Aux_proof-of-work_block">Aux proof-of-work block</span></h2> 
    <p style="line-height:inherit;">This is used to prove work on the auxiliary blockchain. In vinced's original implementation it's generated by calling the&nbsp;<tt style="font-family:monospace, Courier;">getworkaux</tt>&nbsp;RPC method on the parent blockchain client (<tt style="font-family:monospace, Courier;">bitcoind</tt>) and then the work is then submitted by passing it to the auxiliary chain client (<tt style="font-family:monospace, Courier;">namecoind</tt>) as the second parameter to&nbsp;<tt style="font-family:monospace, Courier;">getauxblock</tt>.</p> 
    <p style="line-height:inherit;">When receiving an Aux proof-of-work block in a&nbsp;<a href="https://en.bitcoin.it/wiki/Protocol_specification#block" rel="nofollow" title="Protocol specification" style="text-decoration:none;color:rgb(11,0,128);background:none;">"<tt style="font-family:monospace, Courier;">block</tt>" network message</a>, the data received is similar to a standard block, but extra data is inserted between the&nbsp;<tt style="font-family:monospace, Courier;">nonce</tt>&nbsp;and<tt style="font-family:monospace, Courier;">txn_count</tt>&nbsp;elements. In the below table, the shaded rows are the same as the standard block definition:</p> 
    <table class="wikitable" style="font-size:14px;border:1px solid rgb(170,170,170);border-collapse:collapse;color:#000000;background-color:rgb(249,249,249);">
     <tbody>
      <tr>
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Field Size</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Description</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Data type</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Comments</th> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">version</td> 
       <td style="border:1px solid rgb(170,170,170);">uint32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">32</td> 
       <td style="border:1px solid rgb(170,170,170);">prev_block</td> 
       <td style="border:1px solid rgb(170,170,170);">char[32]</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">32</td> 
       <td style="border:1px solid rgb(170,170,170);">merkle_root</td> 
       <td style="border:1px solid rgb(170,170,170);">char[32]</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">timestamp</td> 
       <td style="border:1px solid rgb(170,170,170);">uint32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">bits</td> 
       <td style="border:1px solid rgb(170,170,170);">uint32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">nonce</td> 
       <td style="border:1px solid rgb(170,170,170);">uint32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">coinbase_txn</td> 
       <td style="border:1px solid rgb(170,170,170);"><a href="https://en.bitcoin.it/wiki/Protocol_specification#tx" rel="nofollow" title="Protocol specification" style="text-decoration:none;color:rgb(11,0,128);background:none;">txn</a></td> 
       <td style="border:1px solid rgb(170,170,170);">Coinbase transaction that is in the parent block,&nbsp;<a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merged_mining_coinbase" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;">linking</a>&nbsp;the AuxPOW block to its parent block</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">32</td> 
       <td style="border:1px solid rgb(170,170,170);">block_hash</td> 
       <td style="border:1px solid rgb(170,170,170);">char[32]</td> 
       <td style="border:1px solid rgb(170,170,170);">Hash of the&nbsp;<tt style="font-family:monospace, Courier;">parent_block</tt>&nbsp;header</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">coinbase_branch</td> 
       <td style="border:1px solid rgb(170,170,170);"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merkle_Branch" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;">Merkle branch</a></td> 
       <td style="border:1px solid rgb(170,170,170);">The merkle branch linking the&nbsp;<tt style="font-family:monospace, Courier;">coinbase_txn</tt>&nbsp;to the parent block's&nbsp;<tt style="font-family:monospace, Courier;">merkle_root</tt></td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">blockchain_branch</td> 
       <td style="border:1px solid rgb(170,170,170);"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merkle_Branch" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;">Merkle branch</a></td> 
       <td style="border:1px solid rgb(170,170,170);">The merkle branch linking this auxiliary blockchain to the others, when used in a merged mining setup with multiple auxiliary chains</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">80</td> 
       <td style="border:1px solid rgb(170,170,170);">parent_block</td> 
       <td style="border:1px solid rgb(170,170,170);"><a href="https://en.bitcoin.it/wiki/Protocol_specification#block" rel="nofollow" title="Protocol specification" style="text-decoration:none;color:rgb(11,0,128);background:none;">Block header</a></td> 
       <td style="border:1px solid rgb(170,170,170);">Parent block header</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">txn_count</td> 
       <td style="border:1px solid rgb(170,170,170);">var_int</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
      <tr style="color:rgb(153,153,153);background-color:rgb(221,221,221);">
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">txns</td> 
       <td style="border:1px solid rgb(170,170,170);">tx[]</td> 
       <td style="border:1px solid rgb(170,170,170);">&nbsp;</td> 
      </tr>
     </tbody>
    </table>
    <p style="line-height:inherit;">For the&nbsp;<tt style="font-family:monospace, Courier;">coinbase_branch</tt>&nbsp;merkle branch, because the coinbase transaction is the first transaction in the block (if using Bitcoin as a parent chain, i.e. hash #7 in the example given&nbsp;<a href="https://en.bitcoin.it/wiki/Merged_mining_specification#Merkle_Branch" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;">below</a>), the&nbsp;<tt style="font-family:monospace, Courier;">branch_side_mask</tt>&nbsp;is always going to be all zeroes, because the branch hashes will always be "on the right" of the working hash.</p> 
    <p style="line-height:inherit;">When only working on one auxiliary blockchain, the&nbsp;<tt style="font-family:monospace, Courier;">blockchain_branch</tt>&nbsp;link is not needed, and is nulled-out by being presented as 5 bytes of zeros (interpreted as a one-byte&nbsp;<tt style="font-family:monospace, Courier;">var_int</tt>&nbsp;indicating a&nbsp;<tt style="font-family:monospace, Courier;">branch_length</tt>&nbsp;of zero, and a 32-bit (4 byte)&nbsp;<tt style="font-family:monospace, Courier;">branch_side_mask</tt>&nbsp;of all zeroes).</p> 
    <p style="line-height:inherit;">Note that the&nbsp;<tt style="font-family:monospace, Courier;">block_hash</tt>&nbsp;element is not needed as you have the full&nbsp;<tt style="font-family:monospace, Courier;">parent_block</tt>&nbsp;header element and can calculate the hash from that. The current Namecoin client doesn't check this field for validity, and as such some AuxPOW blocks have it little-endian, and some have it big-endian.</p> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Merkle_Branch">Merkle Branch</span></h2> 
    <p style="line-height:inherit;">Say Alice created a Merkle tree, and it's root element is publicly available. For example:</p> 
    <pre style="font-family:monospace, Courier;border:1px solid rgb(221,221,221);color:#000000;line-height:1.3em;background-color:rgb(249,249,249);">             merkleRoot (0)
              /        \
             /          \
            1            2
           / \          / \
          /   \        /   \
         3     4      5     6
        / \   / \    / \   / \
       7   8 9  10  11 12 13 14
</pre> 
    <p style="line-height:inherit;">Now she wants to prove to Bob that a given hash (#10) was part of that tree, but Bob doesn't have the full tree (only the public root; hash #0). Alice can send Bob all the hashes she used to make the tree in the first place (hashes #7-#14, total of 7 extra hashes), so Bob can build the whole tree to verify the root is the same, but that's rather data-intensive. Instead, she could give Bob hashes #9, #3, and #2 (one from each level of the tree, working #10 back to the root). Without Bob knowing the structure of the tree, Alice also has to tell Bob what order to apply the hashes in (since&nbsp;<tt style="font-family:monospace, Courier;">hash(#9, #10) == #4</tt>, but&nbsp;<tt style="font-family:monospace, Courier;">hash(#10, #9)&nbsp;!= #4</tt>). So Alice tells Bob "left, left, right" to indicate which operand #9, #3, and #2 are, respectively. That can be encoded as a bitmask and take up very little data to transmit. So, instead of transmitting 7 hashes to Bob, Alice transmits 3 hashes and a bitmask. The data savings get even more pronounced if the merkle tree gets even bigger.</p> 
    <p style="line-height:inherit;">That is the overall premise, and specifically for the AuxPOW protocol, it's been termed a "merkle branch" (since it's one pathway of a merkle tree), and is transmitted thus:</p> 
    <table class="wikitable" style="font-size:14px;border:1px solid rgb(170,170,170);border-collapse:collapse;color:#000000;background-color:rgb(249,249,249);">
     <tbody>
      <tr>
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Field Size</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Description</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Data type</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Comments</th> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">branch_length</td> 
       <td style="border:1px solid rgb(170,170,170);"><a href="https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer" rel="nofollow" title="Protocol specification" style="text-decoration:none;color:rgb(11,0,128);background:none;">var_int</a></td> 
       <td style="border:1px solid rgb(170,170,170);">The number of hashes making up the branch</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">&nbsp;?</td> 
       <td style="border:1px solid rgb(170,170,170);">branch_hash[]</td> 
       <td style="border:1px solid rgb(170,170,170);">char[32]</td> 
       <td style="border:1px solid rgb(170,170,170);">Individual hash in the branch; repeated&nbsp;<tt style="font-family:monospace, Courier;">branch_length</tt>&nbsp;number of times</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">branch_side_mask</td> 
       <td style="border:1px solid rgb(170,170,170);">int32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">Bitmask of which side of the merkle hash function the&nbsp;<tt style="font-family:monospace, Courier;">branch_hash</tt>&nbsp;element should go on. Zero means it goes on the right, One means on the left.</td> 
      </tr>
     </tbody>
    </table>
    <p style="line-height:inherit;">The first&nbsp;<tt style="font-family:monospace, Courier;">branch_hash</tt>&nbsp;is used first, and the least-significant bit of the&nbsp;<tt style="font-family:monospace, Courier;">branch_side_mask</tt>&nbsp;determines its hash position. Then the second&nbsp;<tt style="font-family:monospace, Courier;">branch_hash</tt>&nbsp;is applied with the second-least-significant bit of the&nbsp;<tt style="font-family:monospace, Courier;">branch_side_mask</tt>, etc. So for Alice's example,&nbsp;<tt style="font-family:monospace, Courier;">branch_length</tt>&nbsp;would be 3, the hashes would be given in the order #9, #3, then #2, and the&nbsp;<tt style="font-family:monospace, Courier;">branch_side_mask</tt>&nbsp;would be&nbsp;<tt style="font-family:monospace, Courier;">0b011</tt>&nbsp;= 3.</p> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Merged_mining_coinbase">Merged mining coinbase</span></h2> 
    <p style="line-height:inherit;">Insert exactly one of these headers into the&nbsp;<tt style="font-family:monospace, Courier;">scriptSig</tt>&nbsp;of the coinbase transaction in the parent block.</p> 
    <table class="wikitable" style="font-size:14px;border:1px solid rgb(170,170,170);border-collapse:collapse;color:#000000;background-color:rgb(249,249,249);">
     <tbody>
      <tr>
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Field Size</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Description</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Data type</th> 
       <th style="border:1px solid rgb(170,170,170);text-align:center;background-color:rgb(242,242,242);"> Comments</th> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">magic</td> 
       <td style="border:1px solid rgb(170,170,170);">char[4]</td> 
       <td style="border:1px solid rgb(170,170,170);"><tt style="font-family:monospace, Courier;">0xfa</tt>,&nbsp;<tt style="font-family:monospace, Courier;">0xbe</tt>, 'm', 'm'&nbsp;<strong>(only required if over 20 bytes past the start of the script; optional otherwise)</strong></td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">32</td> 
       <td style="border:1px solid rgb(170,170,170);">block_hash</td> 
       <td style="border:1px solid rgb(170,170,170);">char[32]</td> 
       <td style="border:1px solid rgb(170,170,170);">Hash of the AuxPOW block header</td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">merkle_size</td> 
       <td style="border:1px solid rgb(170,170,170);">int32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">Number of entries in aux work merkle tree.&nbsp;<strong>(Must be a power of 2)</strong></td> 
      </tr>
      <tr>
       <td style="border:1px solid rgb(170,170,170);">4</td> 
       <td style="border:1px solid rgb(170,170,170);">merkle_nonce</td> 
       <td style="border:1px solid rgb(170,170,170);">int32_t</td> 
       <td style="border:1px solid rgb(170,170,170);">Nonce used to calculate indexes into aux work merkle tree; you may as well leave this at zero</td> 
      </tr>
     </tbody>
    </table>
    <p style="line-height:inherit;">That string of 44 bytes being part of the coinbase script means that the miner constructed the AuxPOW Block before creating the coinbase.</p> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Aux_work_merkle_tree">Aux work merkle tree</span></h2> 
    <p style="line-height:inherit;">If you're just mining a single auxiliary chain and using getauxblock, you don't have to worry about this - just set the merkle tree hash in the coinbase to the aux chain block's hash as given by getauxblock, the merkle size to 1, and the merkle nonce to 0. If you're mining more than one, this is a bit broken. It uses the following algorithm to convert the chain ID to a slot at the base of the merkle tree in which that chain's block hash must slot:</p> 
    <pre style="font-family:monospace, Courier;border:1px solid rgb(221,221,221);color:#000000;line-height:1.3em;background-color:rgb(249,249,249);">unsigned int rand = merkle_nonce;
rand = rand * 1103515245 + 12345;
rand += chain_id;
rand = rand * 1103515245 + 12345;
slot_num = rand&nbsp;% merkle_size</pre> 
    <p style="line-height:inherit;">The idea is that you can increment merkle_nonce until the chains you're mining don't clash for the same slot. The trouble is that this doesn't work; because it just adds a number derived from the merkle_nonce to the chain_id, if two chains clash for one nonce they'll still clash for all possible nonces.<sup id="cite_ref-0" class="reference" style="line-height:1;"><a href="https://en.bitcoin.it/wiki/Merged_mining_specification#cite_note-0" rel="nofollow" style="text-decoration:none;color:rgb(11,0,128);background:none;">[1]</a></sup>&nbsp;New implementers: please pick your chain_id so that not clashing with existing chains requires as small a value of merkle_size as possible, or use a better algorithm to calculate the slot id for your chain.</p> 
    <p style="line-height:inherit;">Once you know where in the merkle tree the different chains go,&nbsp;<em>reverse the bytes of each chain's block hash as given you by getauxblock</em>&nbsp;(so the byte at the start moves to the end, etc) and insert into the appropriate slot, filling the unused ones with arbitrary data. Now build up the merkle tree as usual by taking each pair of values in the initial row and double SHA-256 hashing them to give a new row of hashes, repeating this until you only have a single hash. This last hash is the merkle root. You need to<em>reverse the bytes of this again</em>&nbsp;before inserting it into the coinbase. If you're not using getauxblock to get the block hash, you can skip the first reversal but still need to reverse the final merkle root when adding it to the coinbase.</p> 
    <p style="line-height:inherit;">The aux proof-of-work also needs a merkle branch, which is built as follows: find the location of the block's hash in the merkle tree, and add the other value that you hashed it with in building the merkle tree. Now add the value you hashed that result with. Keep doing this until you reach the root. The merkle root itself is&nbsp;<em>never</em>included in the merkle branch. If you just have a single aux chain, this can be left entirely empty. (It also appears you&nbsp;<em>don't</em>&nbsp;need to reverse these hashes.)</p> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span class="mw-headline" id="Example">Example</span></h2> 
    <p style="line-height:inherit;">This is the AuxPOW block at&nbsp;<a class="external text" href="http://explorer.dot-bit.org/b/19200" rel="nofollow" style="text-decoration:none;color:rgb(102,51,102);">height 19200</a>&nbsp;in the Namecoin chain (the first block that allowed AuxPOW authentication). It has a hash of<tt style="font-family:monospace, Courier;">d8a7c3e01e1e95bcee015e6fcc7583a2ca60b79e5a3aa0a171eddd344ada903d</tt>, and only has one Namecoin transaction (coinbase sending 50 NMC to the miner's address). The parent block that was used as Proof of Work has a hash less than the difficulty target of Namecoin at the time, but not the Bitcoin target:</p> 
    <pre style="font-family:monospace, Courier;border:1px solid rgb(221,221,221);color:#000000;line-height:1.3em;background-color:rgb(249,249,249);">0000000000003d47277359fb969c43e3c7e7c0306a17f6444b8e91e19def03a9 -- parent block hash
000000000000b269000000000000000000000000000000000000000000000000 -- Namecoin difficulty target
00000000000009ee5d0000000000000000000000000000000000000000000000 -- Bitcoin difficulty target
</pre> 
    <p style="line-height:inherit;">Hence, this AuxPOW block was valid in the Namecoin blockchain, but not in the Bitcoin blockchain (you will find no Bitcoin block with the hash starting&nbsp;<tt style="font-family:monospace, Courier;">3d47277359fb969c</tt>. If it were, it would be right after&nbsp;<a class="external text" href="https://blockchain.info/block-index/163650/00000000000004a59b7deb5c4e01b9786ea01ee8da000db77ce6035c2913be08" rel="nofollow" style="text-decoration:none;color:rgb(102,51,102);"><tt style="font-family:monospace, Courier;">4a59b7deb5c4e01b</tt></a>, since that's the&nbsp;<tt style="font-family:monospace, Courier;">previous_block</tt>&nbsp;hash used)</p> 
    <pre style="font-family:monospace, Courier;border:1px solid rgb(221,221,221);color:#000000;line-height:1.3em;background-color:rgb(249,249,249);">Block Header:
 01 01 01 00                                                                                        // Version
 36 90 9a c0 7a 16 73 da f6 5f a7 d8 28 88 2e 66 c9 e8 9f 85 46 cd d5 0a 9f b1 00 00 00 00 00 00    // Previous block hash
 0f 5c 65 49 bc d6 08 ab 7c 4e ac 59 3e 5b d5 a7 3b 2d 43 2e b6 35 18 70 8f 77 8f c7 dc df af 88    // Merkle root
 8d 1a 90 4e                                                                                        // Timestamp
 69 b2 00 1b                                                                                        // Bits
 00 00 00 00                                                                                        // Nonce

Parent Block Coinbase Transaction:
 01 00 00 00                                              // Version
 01                                                       // TxIn Count

 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    // Previous Out
 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff

 35                                                                                                 // Script size
 04 5d ee 09 1a 01 4d 52 2c fa be 6d 6d d8 a7 c3 e0 1e 1e 95 bc ee 01 5e 6f cc 75 83 a2 ca 60 b7    // Script
 9e 5a 3a a0 a1 71 ed dd 34 4a da 90 3d 01 00 00 00 00 00 00 00

 ff ff ff ff                                              // Sequence Number
 01                                                       // TxOut Count
 60 a0 10 2a 01 00 00 00                                  // Amount

 43                                                                                                 // Script Size
 41 04 f8 bb e9 7e d2 ac bc 5b ba 11 c6 8f 6f 1a 03 13 f9 18 f3 d3 c0 e8 47 50 55 e3 51 e3 bf 44    // Script
 2f 8c 8d ce e6 82 d2 45 7b dc 53 51 b7 0d d9 e3 40 26 76 6e ba 18 b0 6e ae e2 e1 02 ef d1 ab 63
 46 67 ac

 00 00 00 00                                              // Lock Time

Coinbase Link:
 a9 03 ef 9d e1 91 8e 4b 44 f6 17 6a 30 c0 e7 c7 e3 43 9c 96 fb 59 73 27 47 3d 00 00 00 00 00 00    // Hash of parent block header
 05                                                                                                 // Number of links in branch
 05 0a c4 a1 a1 e1 bc e0 c4 8e 55 5b 1a 9f 93 52 81 96 8c 72 d6 37 9b 24 72 9c a0 42 5a 3f c3 cb    // Hash #1
 43 3c d3 48 b3 5e a2 28 06 cf 21 c7 b1 46 48 9a ef 69 89 55 1e b5 ad 23 73 ab 61 21 06 0f 30 34    // Hash #2
 1d 64 87 57 c0 21 7d 43 e6 6c 57 ea ed 64 fc 18 20 ec 65 d1 57 f3 3b 74 19 65 18 3a 5e 0c 85 06    // Hash #3
 ac 26 02 df e2 f5 47 01 2d 1c c7 50 04 d4 8f 97 ab a4 6b d9 93 0f f2 85 c9 f2 76 f5 bd 09 f3 56    // Hash #4
 df 19 72 45 79 d6 5e c7 cb 62 bf 97 94 6d fc 6f b0 e3 b2 83 9b 7f da b3 7c db 60 e5 51 22 d3 5b    // Hash #5
 00 00 00 00                                                                                        // Branch sides bitmask

Aux Blockchain Link:
 00             // Number of links in branch
 00 00 00 00    // Branch sides bitmask

Parent Block Header:
 01 00 00 00                                                                                        // Version
 08 be 13 29 5c 03 e6 7c b7 0d 00 da e8 1e a0 6e 78 b9 01 4e 5c eb 7d 9b a5 04 00 00 00 00 00 00    // Previous block hash
 e0 fd 42 db 8e f6 d7 83 f0 79 d1 26 be a1 2e 2d 10 c1 04 c0 92 7c d6 8f 95 4d 85 6f 9e 81 11 e5    // Merkle root
 9a 23 90 4e                                                                                        // Timestamp
 5d ee 09 1a                                                                                        // Bits
 1c 65 50 86                                                                                        // Nonce

Transactions:
 01                                                       // Tx  Count
 01 00 00 00                                              // Version
 01                                                       // TxIn Count

 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    // Previous Out
 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff

 08                                                       // Script size
 04 69 b2 00 1b 01 01 52                                  // Script
 ff ff ff ff                                              // Sequence number
 01                                                       // TxOut Count
 00 f2 05 2a 01 00 00 00                                  // Amount

 43                                                                                                 // Script size
 41 04 89 fe 91 e6 28 47 57 5c 98 de ea b0 20 f6 5f df f1 7a 3a 87 0e bb 05 82 0b 41 4f 3d 80 97    // Script
 21 8e c9 a6 5f 1e 0a e0 ac 35 af 72 47 bd 79 ed 1f 2a 24 67 5f ff b5 aa 6f 96 20 e1 92 0a d4 bf
 5a a6 ac

 00 00 00 00                                              // Lock Time
</pre> 
    <h2 style="color:#000000;font-weight:normal;overflow:hidden;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(170,170,170);line-height:1.3;background:none;"> <span style="font-family:Arial, Helvetica, sans-serif;font-size:12px;">http://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work</span></h2> 
   </div> 
  </div> 
  <p><br></p> 
  <p>非合并挖矿得到的namecoin block</p> 
  <p><img src="https://img-blog.csdn.net/20150108095751612" alt=""><br></p> 
  <p>合并挖矿的block，没有显示插入的AuxPow部分</p> 
  <p><img src="https://img-blog.csdn.net/20150108095733359" alt=""><br></p> 
  <p><br></p> 
  <pre><code class="language-cpp">bool CheckWork(CBlock* pblock, CWallet&amp; wallet, CReserveKey&amp; reservekey)
{
    uint256 hash = pblock-&gt;GetHash();
    uint256 hashTarget = CBigNum().SetCompact(pblock-&gt;nBits).getuint256();

    CAuxPow *auxpow = pblock-&gt;auxpow.get();

    if (auxpow != NULL)
    {
        if (!auxpow-&gt;Check(hash, pblock-&gt;GetChainID()))
            return error("AUX POW is not valid");

        if (auxpow-&gt;GetParentBlockHash() &gt; hashTarget)
            return error("AUX POW parent hash %s is not under target %s", auxpow-&gt;GetParentBlockHash().GetHex().c_str(), hashTarget.GetHex().c_str());

        //// debug print
        printf("BitcoinMiner:\n");
        printf("AUX proof-of-work found  \n     our hash: %s   \n  parent hash: %s  \n       target: %s\n",
                hash.GetHex().c_str(),
                auxpow-&gt;GetParentBlockHash().GetHex().c_str(),
                hashTarget.GetHex().c_str());
    }
    else
    {
        if (hash &gt; hashTarget)
            return false;

        //// debug print
        printf("BitcoinMiner:\n");
        printf("proof-of-work found  \n  hash: %s  \ntarget: %s\n", hash.GetHex().c_str(), hashTarget.GetHex().c_str());
    }

    pblock-&gt;print();
    printf("%s ", DateTimeStrFormat("%x %H:%M", GetTime()).c_str());
    printf("generated %s\n", FormatMoney(pblock-&gt;vtx[0].vout[0].nValue).c_str());

    // Found a solution
    CRITICAL_BLOCK(cs_main)
    {
        if (pblock-&gt;hashPrevBlock != hashBestChain)
            return error("BitcoinMiner : generated block is stale");

        // Remove key from key pool
        reservekey.KeepKey();

        // Track how many getdata requests this block gets
        CRITICAL_BLOCK(wallet.cs_mapRequestCount)
            wallet.mapRequestCount[pblock-&gt;GetHash()] = 0;

        // Process this block the same as if we had received it from another node
        if (!ProcessBlock(NULL, pblock))
            return error("BitcoinMiner : ProcessBlock, block not accepted");
    }

    Sleep(2000);
    return true;
}</code></pre>
  <pre><code class="language-cpp">bool CAuxPow::Check(uint256 hashAuxBlock, int nChainID)
{
    if (nIndex != 0)
        return error("AuxPow is not a generate");

    if (!fTestNet &amp;&amp; parentBlock.GetChainID() == nChainID)
        return error("Aux POW parent has our chain ID");

    if (vChainMerkleBranch.size() &gt; 30)
        return error("Aux POW chain merkle branch too long");

    // Check that the chain merkle root is in the coinbase
    uint256 nRootHash = CBlock::CheckMerkleBranch(hashAuxBlock, vChainMerkleBranch, nChainIndex);
    vector&lt;unsigned char&gt; vchRootHash(nRootHash.begin(), nRootHash.end());
    std::reverse(vchRootHash.begin(), vchRootHash.end()); // correct endian

    // Check that we are in the parent block merkle tree
    if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != parentBlock.hashMerkleRoot)
        return error("Aux POW merkle root incorrect");

    const CScript script = vin[0].scriptSig;

    // Check that the same work is not submitted twice to our chain.
    //

    CScript::const_iterator pcHead =
        std::search(script.begin(), script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader));

    CScript::const_iterator pc =
        std::search(script.begin(), script.end(), vchRootHash.begin(), vchRootHash.end());

    if (pc == script.end())
        return error("Aux POW missing chain merkle root in parent coinbase");

    if (pcHead != script.end())
    {
        // Enforce only one chain merkle root by checking that a single instance of the merged
        // mining header exists just before.
        if (script.end() != std::search(pcHead + 1, script.end(), UBEGIN(pchMergedMiningHeader), UEND(pchMergedMiningHeader)))
            return error("Multiple merged mining headers in coinbase");
        if (pcHead + sizeof(pchMergedMiningHeader) != pc)
            return error("Merged mining header is not just before chain merkle root");
    }
    else
    {
        // For backward compatibility.
        // Enforce only one chain merkle root by checking that it starts early in the coinbase.
        // 8-12 bytes are enough to encode extraNonce and nBits.
        if (pc - script.begin() &gt; 20)
            return error("Aux POW chain merkle root must start in the first 20 bytes of the parent coinbase");
    }


    // Ensure we are at a deterministic point in the merkle leaves by hashing
    // a nonce and our chain ID and comparing to the index.
    pc += vchRootHash.size();
    if (script.end() - pc &lt; 8)
        return error("Aux POW missing chain merkle tree size and nonce in parent coinbase");

    int nSize;
    memcpy(&amp;nSize, &amp;pc[0], 4);
    if (nSize != (1 &lt;&lt; vChainMerkleBranch.size()))
        return error("Aux POW merkle branch size does not match parent coinbase");

    int nNonce;
    memcpy(&amp;nNonce, &amp;pc[4], 4);

    // Choose a pseudo-random slot in the chain merkle tree
    // but have it be fixed for a size/nonce/chain combination.
    //
    // This prevents the same work from being used twice for the
    // same chain while reducing the chance that two chains clash
    // for the same slot.
    unsigned int rand = nNonce;
    rand = rand * 1103515245 + 12345;
    rand += nChainID;
    rand = rand * 1103515245 + 12345;

    if (nChainIndex != (rand % nSize))
        return error("Aux POW wrong index");

    return true;
}</code></pre>
  <br>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/42457197,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/hacode/article/details/42457197,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
