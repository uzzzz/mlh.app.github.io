<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>快速进入Android世界 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="快速进入Android世界" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Android概述 Android是什么 Android是一种以Linux为基础的开放源码操作系统和应用程序，主要使用于便携设备。 Android操作系统最初由Andy Rubin开发，最初主要支持手机。 2005年由Google收购注资，并组建开放手机联盟开发改良，逐渐扩展到平板电脑及其他领域上。 2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。 2011年11月数据，Android占据全球智能手机操作系统市场52.5%的份额，中国市场占有率为58%。 Android名称来源&nbsp; Android一词最早出现于法国作家利尔亚当（Auguste Villiers de l&#39;Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L&#39;ève future）中。他将外表像人的机器起名Android。 Android的版本 android1.1 … android4.0 android4.1&nbsp; &nbsp; &nbsp; &nbsp; ... Android开发方向 系统开发 扩展操作系统功能 比较高难 ,android底层使用c c++开发。从事android系统开发，除了对java需要有深入的了解和开发经验，还需要对c 和c++有深入了解和足够的开发经验 应用开发 开发应用程序 难度一般 Android的系统架构 应用层 应用是用Java语言编写的运行在虚拟机上的程序。 应用框架层&nbsp; 这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架开发自己的应用，这样便简化了程序开发的框架设计，但是必须遵守其框架的开发原则。 系统运行库层 当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其能更好的为我们服务。 Linux 内核层&nbsp; Android的核心系统服务于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Linux内核同时也作为硬件和软件栈之间的抽象层。 开发环境搭建 这里主要说下Eclipse下开发的环境搭建，官方现在推荐Android Studio ,关于Android Studio 我也是刚开始接触，我会把遇到的问题总结出来，以后以博文的形式进行分享。&nbsp; Android开发准备工作 所需软件： JDK 1.5或更高（推荐使用JDK1.6版本） 、Eclipse 3.5或更高（推荐使用3.7版本） &nbsp;、Android SDK Android SDK 4.0.3 、ADT ADT 20.0.2 Android开发环境搭建 安装SDK SDK是Android开发工具包，包含开发Android应用程序的API SDK需要JDK1.5及以上的版本支持 安装SDK前需要先安装JDK SDK的官方下载地址： http://developer.android.com/sdk/index.html 下载后双击安装即可 安装后的SDK只是一个SDK版本的管理器，点击SDK Manager，里面管理的是android SDK也就是android系统的版本 勾选点击Install Packages即可对应下载 android版本: 1.X 较早手机版本 2.X 主流手机版本 3.X 平板电脑版本 4.X 为2.X与3.X整合版 ,即可手机使用，也可平板使用 配置SDK的环境变量 找到SDK的安装路径打开tools文件夹 &nbsp;添加到环境变量path里 打开platform-form-tools文件夹 一样的道理，把路径复制好后，加入环境变量path里 安装ADT插件 ADT 使用eclipse并不能直接使用SDK开发android应用程序，这就需要添加eclipse对SDK的支持，也就是，eclipse需要插件来支持SDK 这个插件就是--ADT 下载ADT 下载ADT插件，ADT插件的版本号一定要与下载的SDK版本号一致 启动Eclipse，“Help”→“Install New Software..”→“add” 指定ADT所在路径即可，单击OK 点击finish完成安装，若出现如下图所示警告，单击OK继续安装即可 出现如下提示，则安装成功，重启eclipse 若工具栏出现android图标，即插件安装成功 在eclipse中配置SDK 点击Windows→Preferences→android 创建AVD（模拟器） AVD AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，即模拟手机。 创建AVD 点击图标 点击Create AVD 点击start 出现如下窗口 点击Launch启动模拟器 启动成功后会看到一个模拟手机的画面 第一个HelloWorld程序 创建一个Android项目 连续点击下一步 直到完成按钮可以点击 运行程序 点击项目右键 运行结果 Android项目的目录结构 gen： 当向res文件夹内添加资源时，会在R.java内自动生成，代表添加资源的变量，通过访问变量(即R.变量名)，直接可以访问资源。如下图：当向drawable-hdpi内添加图片a.JPG，则R类自动添加代表a.JPG的变量 res: Android组件 Activity(活动)： 活动是最基本的Android应用程序组件，应用程序中，一个活动通常就是一个单独的屏幕。每一个活动都被实现为一个独立的类，并且从活动基类中继承而来，活动类将会显示由视图控件组成的用户接口，并对事件做出响应。大多数的应用是由多个屏幕显示组成。例如:一个文本信息的应用也许有一个显示发送消息的联系人列表屏幕，第二个屏幕用来写文本消息和选择收件人，再来一个屏幕查看消息历史或者消息设置操作 等。这里每一个这样的屏幕就是一个活动，很容易实现从一个屏幕到一个新的屏幕并且完成新的活动。在某些情况下当前的屏幕也许需要向上一个屏幕活动提供返回值--比如让用户从手机中挑选一张照片返回通讯录做为电话拨入者的头像。 当一个新的屏幕打开后，前一个屏幕将会暂停，并保存在历史堆栈中。用户可以返回到历史堆栈中的前一个屏幕。当屏幕不再使用时，还可以从历史堆栈中删除。默认情况下，Android将会保留从主屏幕到每一个应用的运行屏幕。 简单理解Activity代表一个用户所能看到的屏幕，Activity主要是处理一个应用的整体性工作，例如，监听系统事件(按键事件、触摸屏事件等)、为用户显示指定的View，启动其他Activity等。所有应用的Activity都继承于android.app.Activity类，该类是Android提供的基层类，其他的Activity继承该父类后，通过Override父类的方法来实现各种功能，这种设计在其他领域也较为常见。 Service(服务): 一个Service是一段长生命周期的，没有用户界面的程序。比较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。然而，音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。在这个例子中，媒体播放器这个activity会使用Context.startService()来启动一个service，从而可以在后台保持音乐的播放。同时，系统也将保持这个service一直执行，直到这个service运行结束。另外我们还可以通过使用Context.bindService()方法，连接到一个service上（如果这个service还没有运行将启动它）。当连接到一个service之后，我们还可以service提供的接口与它进行通讯。拿媒体播放器这个例子来说我们还可以进行暂停、重播等操作。 ContentProvider(内容提供者): Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据与其它的应用共享时，内容提供器就可以发挥作用了。因为内容提供器类实现了一组标准的方法，从而能够让其它的应用保存或读取此内容提供器处理的各种数据类型。 数据是应用的核心。在Android中，默认使用鼎鼎大名的SQLite作为系统DB。但是在Android中，使用方法有点小小的不一样。在Android中每一个应用都运行在各自的进程中，当你的应用需要访问其他应用的数据时，也就需要数据在不同的虚拟机之间传递，这样的情况操作起来可能有些困难(正常情况下，你不能读取其他的应用的db文件)，ContentProvider正是用来解决在不同的应用包之间共享数据的工具。 BroadcastReceiver(广播接收者): 一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据。一个应用程序可以有任意数量的广播接收者去反应任何它认为重要的公告。所有的接受者继承自BroadcastReceiver基类。Android 中的广播要么来自于系统，要么来自普通应用程序。很多事件都可能导致系统广播，如手机所在时区发生变化，电池电量低，用户改变系统语言设置等。来自普通应用程序，如一个应用程序通知其他应用程序某些数据已经下载完毕。 为了响应不同的事件通知，应用程序可以注册不同的 Broadcast Receiver 。所有的 Broadcast Receiver都继承自基类 BroadcastReceiver 。BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以启动Activity 作为响应，或者通过 NotificationMananger 提醒用户。BroadcastReceiver 是对发送出来的 Broadcast 进行过滤接收并响应的一类组件。 Intent(意图)： Android使用了Intent这个特殊类，实现在屏幕与屏幕之间移动。Intent类用于描述一个应用将会做什么事。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。典型的动作类型有：MAIN（activity的门户）、VIEW、PICK、EDIT等。而动作对应的数据则以URI的形式进行表示。例如：要查看一个人的联系方式，你需要创建一个动作类型为VIEW的intent，以及一个表示这个人的URI。与之有关系的一个类叫IntentFilter。相对于intent是一个有效的做某事的请求，一个intentfilter则用于描述一个activity（或者IntentReceiver）能够操作哪些intent。一个activity如果要显示一个人的联系方式时，需要声明一个IntentFilter，这个IntentFilter要知道怎么去处理VIEW动作和表示一个人的URI。IntentFilter需要在AndroidManifest.xml中定义。通过解析各种intent，从一个屏幕导航到另一个屏幕是很简单的。当向前导航时，activity将会调用 startActivity(IntentmyIntent)方法。然后，系统会在所有安装的应用程序中定义的IntentFilter中查找，找到最匹配myIntent的Intent对应的activity。新的activity接收到myIntent的通知后，开始运行。当startActivity方法被调用将触发解析myIntent的动作，这个机制提供了两个关键好处： A、Activities能够重复利用从其它组件中以Intent的形式产生的一个请求。 B、Activities可以在任何时候被一个具有相同IntentFilter的新的Activity取代。 ps:csdn编辑器写博客太麻烦了，尤其是排版上，还好现在支持markdown语法了。还是希望能将精力更多集中在内容上，而不是排版上，markdown解决了这个问题。" />
<meta property="og:description" content="Android概述 Android是什么 Android是一种以Linux为基础的开放源码操作系统和应用程序，主要使用于便携设备。 Android操作系统最初由Andy Rubin开发，最初主要支持手机。 2005年由Google收购注资，并组建开放手机联盟开发改良，逐渐扩展到平板电脑及其他领域上。 2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。 2011年11月数据，Android占据全球智能手机操作系统市场52.5%的份额，中国市场占有率为58%。 Android名称来源&nbsp; Android一词最早出现于法国作家利尔亚当（Auguste Villiers de l&#39;Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L&#39;ève future）中。他将外表像人的机器起名Android。 Android的版本 android1.1 … android4.0 android4.1&nbsp; &nbsp; &nbsp; &nbsp; ... Android开发方向 系统开发 扩展操作系统功能 比较高难 ,android底层使用c c++开发。从事android系统开发，除了对java需要有深入的了解和开发经验，还需要对c 和c++有深入了解和足够的开发经验 应用开发 开发应用程序 难度一般 Android的系统架构 应用层 应用是用Java语言编写的运行在虚拟机上的程序。 应用框架层&nbsp; 这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架开发自己的应用，这样便简化了程序开发的框架设计，但是必须遵守其框架的开发原则。 系统运行库层 当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其能更好的为我们服务。 Linux 内核层&nbsp; Android的核心系统服务于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Linux内核同时也作为硬件和软件栈之间的抽象层。 开发环境搭建 这里主要说下Eclipse下开发的环境搭建，官方现在推荐Android Studio ,关于Android Studio 我也是刚开始接触，我会把遇到的问题总结出来，以后以博文的形式进行分享。&nbsp; Android开发准备工作 所需软件： JDK 1.5或更高（推荐使用JDK1.6版本） 、Eclipse 3.5或更高（推荐使用3.7版本） &nbsp;、Android SDK Android SDK 4.0.3 、ADT ADT 20.0.2 Android开发环境搭建 安装SDK SDK是Android开发工具包，包含开发Android应用程序的API SDK需要JDK1.5及以上的版本支持 安装SDK前需要先安装JDK SDK的官方下载地址： http://developer.android.com/sdk/index.html 下载后双击安装即可 安装后的SDK只是一个SDK版本的管理器，点击SDK Manager，里面管理的是android SDK也就是android系统的版本 勾选点击Install Packages即可对应下载 android版本: 1.X 较早手机版本 2.X 主流手机版本 3.X 平板电脑版本 4.X 为2.X与3.X整合版 ,即可手机使用，也可平板使用 配置SDK的环境变量 找到SDK的安装路径打开tools文件夹 &nbsp;添加到环境变量path里 打开platform-form-tools文件夹 一样的道理，把路径复制好后，加入环境变量path里 安装ADT插件 ADT 使用eclipse并不能直接使用SDK开发android应用程序，这就需要添加eclipse对SDK的支持，也就是，eclipse需要插件来支持SDK 这个插件就是--ADT 下载ADT 下载ADT插件，ADT插件的版本号一定要与下载的SDK版本号一致 启动Eclipse，“Help”→“Install New Software..”→“add” 指定ADT所在路径即可，单击OK 点击finish完成安装，若出现如下图所示警告，单击OK继续安装即可 出现如下提示，则安装成功，重启eclipse 若工具栏出现android图标，即插件安装成功 在eclipse中配置SDK 点击Windows→Preferences→android 创建AVD（模拟器） AVD AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，即模拟手机。 创建AVD 点击图标 点击Create AVD 点击start 出现如下窗口 点击Launch启动模拟器 启动成功后会看到一个模拟手机的画面 第一个HelloWorld程序 创建一个Android项目 连续点击下一步 直到完成按钮可以点击 运行程序 点击项目右键 运行结果 Android项目的目录结构 gen： 当向res文件夹内添加资源时，会在R.java内自动生成，代表添加资源的变量，通过访问变量(即R.变量名)，直接可以访问资源。如下图：当向drawable-hdpi内添加图片a.JPG，则R类自动添加代表a.JPG的变量 res: Android组件 Activity(活动)： 活动是最基本的Android应用程序组件，应用程序中，一个活动通常就是一个单独的屏幕。每一个活动都被实现为一个独立的类，并且从活动基类中继承而来，活动类将会显示由视图控件组成的用户接口，并对事件做出响应。大多数的应用是由多个屏幕显示组成。例如:一个文本信息的应用也许有一个显示发送消息的联系人列表屏幕，第二个屏幕用来写文本消息和选择收件人，再来一个屏幕查看消息历史或者消息设置操作 等。这里每一个这样的屏幕就是一个活动，很容易实现从一个屏幕到一个新的屏幕并且完成新的活动。在某些情况下当前的屏幕也许需要向上一个屏幕活动提供返回值--比如让用户从手机中挑选一张照片返回通讯录做为电话拨入者的头像。 当一个新的屏幕打开后，前一个屏幕将会暂停，并保存在历史堆栈中。用户可以返回到历史堆栈中的前一个屏幕。当屏幕不再使用时，还可以从历史堆栈中删除。默认情况下，Android将会保留从主屏幕到每一个应用的运行屏幕。 简单理解Activity代表一个用户所能看到的屏幕，Activity主要是处理一个应用的整体性工作，例如，监听系统事件(按键事件、触摸屏事件等)、为用户显示指定的View，启动其他Activity等。所有应用的Activity都继承于android.app.Activity类，该类是Android提供的基层类，其他的Activity继承该父类后，通过Override父类的方法来实现各种功能，这种设计在其他领域也较为常见。 Service(服务): 一个Service是一段长生命周期的，没有用户界面的程序。比较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。然而，音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。在这个例子中，媒体播放器这个activity会使用Context.startService()来启动一个service，从而可以在后台保持音乐的播放。同时，系统也将保持这个service一直执行，直到这个service运行结束。另外我们还可以通过使用Context.bindService()方法，连接到一个service上（如果这个service还没有运行将启动它）。当连接到一个service之后，我们还可以service提供的接口与它进行通讯。拿媒体播放器这个例子来说我们还可以进行暂停、重播等操作。 ContentProvider(内容提供者): Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据与其它的应用共享时，内容提供器就可以发挥作用了。因为内容提供器类实现了一组标准的方法，从而能够让其它的应用保存或读取此内容提供器处理的各种数据类型。 数据是应用的核心。在Android中，默认使用鼎鼎大名的SQLite作为系统DB。但是在Android中，使用方法有点小小的不一样。在Android中每一个应用都运行在各自的进程中，当你的应用需要访问其他应用的数据时，也就需要数据在不同的虚拟机之间传递，这样的情况操作起来可能有些困难(正常情况下，你不能读取其他的应用的db文件)，ContentProvider正是用来解决在不同的应用包之间共享数据的工具。 BroadcastReceiver(广播接收者): 一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据。一个应用程序可以有任意数量的广播接收者去反应任何它认为重要的公告。所有的接受者继承自BroadcastReceiver基类。Android 中的广播要么来自于系统，要么来自普通应用程序。很多事件都可能导致系统广播，如手机所在时区发生变化，电池电量低，用户改变系统语言设置等。来自普通应用程序，如一个应用程序通知其他应用程序某些数据已经下载完毕。 为了响应不同的事件通知，应用程序可以注册不同的 Broadcast Receiver 。所有的 Broadcast Receiver都继承自基类 BroadcastReceiver 。BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以启动Activity 作为响应，或者通过 NotificationMananger 提醒用户。BroadcastReceiver 是对发送出来的 Broadcast 进行过滤接收并响应的一类组件。 Intent(意图)： Android使用了Intent这个特殊类，实现在屏幕与屏幕之间移动。Intent类用于描述一个应用将会做什么事。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。典型的动作类型有：MAIN（activity的门户）、VIEW、PICK、EDIT等。而动作对应的数据则以URI的形式进行表示。例如：要查看一个人的联系方式，你需要创建一个动作类型为VIEW的intent，以及一个表示这个人的URI。与之有关系的一个类叫IntentFilter。相对于intent是一个有效的做某事的请求，一个intentfilter则用于描述一个activity（或者IntentReceiver）能够操作哪些intent。一个activity如果要显示一个人的联系方式时，需要声明一个IntentFilter，这个IntentFilter要知道怎么去处理VIEW动作和表示一个人的URI。IntentFilter需要在AndroidManifest.xml中定义。通过解析各种intent，从一个屏幕导航到另一个屏幕是很简单的。当向前导航时，activity将会调用 startActivity(IntentmyIntent)方法。然后，系统会在所有安装的应用程序中定义的IntentFilter中查找，找到最匹配myIntent的Intent对应的activity。新的activity接收到myIntent的通知后，开始运行。当startActivity方法被调用将触发解析myIntent的动作，这个机制提供了两个关键好处： A、Activities能够重复利用从其它组件中以Intent的形式产生的一个请求。 B、Activities可以在任何时候被一个具有相同IntentFilter的新的Activity取代。 ps:csdn编辑器写博客太麻烦了，尤其是排版上，还好现在支持markdown语法了。还是希望能将精力更多集中在内容上，而不是排版上，markdown解决了这个问题。" />
<link rel="canonical" href="https://mlh.app/2015/05/24/730188.html" />
<meta property="og:url" content="https://mlh.app/2015/05/24/730188.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-05-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Android概述 Android是什么 Android是一种以Linux为基础的开放源码操作系统和应用程序，主要使用于便携设备。 Android操作系统最初由Andy Rubin开发，最初主要支持手机。 2005年由Google收购注资，并组建开放手机联盟开发改良，逐渐扩展到平板电脑及其他领域上。 2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。 2011年11月数据，Android占据全球智能手机操作系统市场52.5%的份额，中国市场占有率为58%。 Android名称来源&nbsp; Android一词最早出现于法国作家利尔亚当（Auguste Villiers de l&#39;Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L&#39;ève future）中。他将外表像人的机器起名Android。 Android的版本 android1.1 … android4.0 android4.1&nbsp; &nbsp; &nbsp; &nbsp; ... Android开发方向 系统开发 扩展操作系统功能 比较高难 ,android底层使用c c++开发。从事android系统开发，除了对java需要有深入的了解和开发经验，还需要对c 和c++有深入了解和足够的开发经验 应用开发 开发应用程序 难度一般 Android的系统架构 应用层 应用是用Java语言编写的运行在虚拟机上的程序。 应用框架层&nbsp; 这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架开发自己的应用，这样便简化了程序开发的框架设计，但是必须遵守其框架的开发原则。 系统运行库层 当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其能更好的为我们服务。 Linux 内核层&nbsp; Android的核心系统服务于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Linux内核同时也作为硬件和软件栈之间的抽象层。 开发环境搭建 这里主要说下Eclipse下开发的环境搭建，官方现在推荐Android Studio ,关于Android Studio 我也是刚开始接触，我会把遇到的问题总结出来，以后以博文的形式进行分享。&nbsp; Android开发准备工作 所需软件： JDK 1.5或更高（推荐使用JDK1.6版本） 、Eclipse 3.5或更高（推荐使用3.7版本） &nbsp;、Android SDK Android SDK 4.0.3 、ADT ADT 20.0.2 Android开发环境搭建 安装SDK SDK是Android开发工具包，包含开发Android应用程序的API SDK需要JDK1.5及以上的版本支持 安装SDK前需要先安装JDK SDK的官方下载地址： http://developer.android.com/sdk/index.html 下载后双击安装即可 安装后的SDK只是一个SDK版本的管理器，点击SDK Manager，里面管理的是android SDK也就是android系统的版本 勾选点击Install Packages即可对应下载 android版本: 1.X 较早手机版本 2.X 主流手机版本 3.X 平板电脑版本 4.X 为2.X与3.X整合版 ,即可手机使用，也可平板使用 配置SDK的环境变量 找到SDK的安装路径打开tools文件夹 &nbsp;添加到环境变量path里 打开platform-form-tools文件夹 一样的道理，把路径复制好后，加入环境变量path里 安装ADT插件 ADT 使用eclipse并不能直接使用SDK开发android应用程序，这就需要添加eclipse对SDK的支持，也就是，eclipse需要插件来支持SDK 这个插件就是--ADT 下载ADT 下载ADT插件，ADT插件的版本号一定要与下载的SDK版本号一致 启动Eclipse，“Help”→“Install New Software..”→“add” 指定ADT所在路径即可，单击OK 点击finish完成安装，若出现如下图所示警告，单击OK继续安装即可 出现如下提示，则安装成功，重启eclipse 若工具栏出现android图标，即插件安装成功 在eclipse中配置SDK 点击Windows→Preferences→android 创建AVD（模拟器） AVD AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，即模拟手机。 创建AVD 点击图标 点击Create AVD 点击start 出现如下窗口 点击Launch启动模拟器 启动成功后会看到一个模拟手机的画面 第一个HelloWorld程序 创建一个Android项目 连续点击下一步 直到完成按钮可以点击 运行程序 点击项目右键 运行结果 Android项目的目录结构 gen： 当向res文件夹内添加资源时，会在R.java内自动生成，代表添加资源的变量，通过访问变量(即R.变量名)，直接可以访问资源。如下图：当向drawable-hdpi内添加图片a.JPG，则R类自动添加代表a.JPG的变量 res: Android组件 Activity(活动)： 活动是最基本的Android应用程序组件，应用程序中，一个活动通常就是一个单独的屏幕。每一个活动都被实现为一个独立的类，并且从活动基类中继承而来，活动类将会显示由视图控件组成的用户接口，并对事件做出响应。大多数的应用是由多个屏幕显示组成。例如:一个文本信息的应用也许有一个显示发送消息的联系人列表屏幕，第二个屏幕用来写文本消息和选择收件人，再来一个屏幕查看消息历史或者消息设置操作 等。这里每一个这样的屏幕就是一个活动，很容易实现从一个屏幕到一个新的屏幕并且完成新的活动。在某些情况下当前的屏幕也许需要向上一个屏幕活动提供返回值--比如让用户从手机中挑选一张照片返回通讯录做为电话拨入者的头像。 当一个新的屏幕打开后，前一个屏幕将会暂停，并保存在历史堆栈中。用户可以返回到历史堆栈中的前一个屏幕。当屏幕不再使用时，还可以从历史堆栈中删除。默认情况下，Android将会保留从主屏幕到每一个应用的运行屏幕。 简单理解Activity代表一个用户所能看到的屏幕，Activity主要是处理一个应用的整体性工作，例如，监听系统事件(按键事件、触摸屏事件等)、为用户显示指定的View，启动其他Activity等。所有应用的Activity都继承于android.app.Activity类，该类是Android提供的基层类，其他的Activity继承该父类后，通过Override父类的方法来实现各种功能，这种设计在其他领域也较为常见。 Service(服务): 一个Service是一段长生命周期的，没有用户界面的程序。比较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。然而，音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。在这个例子中，媒体播放器这个activity会使用Context.startService()来启动一个service，从而可以在后台保持音乐的播放。同时，系统也将保持这个service一直执行，直到这个service运行结束。另外我们还可以通过使用Context.bindService()方法，连接到一个service上（如果这个service还没有运行将启动它）。当连接到一个service之后，我们还可以service提供的接口与它进行通讯。拿媒体播放器这个例子来说我们还可以进行暂停、重播等操作。 ContentProvider(内容提供者): Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据与其它的应用共享时，内容提供器就可以发挥作用了。因为内容提供器类实现了一组标准的方法，从而能够让其它的应用保存或读取此内容提供器处理的各种数据类型。 数据是应用的核心。在Android中，默认使用鼎鼎大名的SQLite作为系统DB。但是在Android中，使用方法有点小小的不一样。在Android中每一个应用都运行在各自的进程中，当你的应用需要访问其他应用的数据时，也就需要数据在不同的虚拟机之间传递，这样的情况操作起来可能有些困难(正常情况下，你不能读取其他的应用的db文件)，ContentProvider正是用来解决在不同的应用包之间共享数据的工具。 BroadcastReceiver(广播接收者): 一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据。一个应用程序可以有任意数量的广播接收者去反应任何它认为重要的公告。所有的接受者继承自BroadcastReceiver基类。Android 中的广播要么来自于系统，要么来自普通应用程序。很多事件都可能导致系统广播，如手机所在时区发生变化，电池电量低，用户改变系统语言设置等。来自普通应用程序，如一个应用程序通知其他应用程序某些数据已经下载完毕。 为了响应不同的事件通知，应用程序可以注册不同的 Broadcast Receiver 。所有的 Broadcast Receiver都继承自基类 BroadcastReceiver 。BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以启动Activity 作为响应，或者通过 NotificationMananger 提醒用户。BroadcastReceiver 是对发送出来的 Broadcast 进行过滤接收并响应的一类组件。 Intent(意图)： Android使用了Intent这个特殊类，实现在屏幕与屏幕之间移动。Intent类用于描述一个应用将会做什么事。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。典型的动作类型有：MAIN（activity的门户）、VIEW、PICK、EDIT等。而动作对应的数据则以URI的形式进行表示。例如：要查看一个人的联系方式，你需要创建一个动作类型为VIEW的intent，以及一个表示这个人的URI。与之有关系的一个类叫IntentFilter。相对于intent是一个有效的做某事的请求，一个intentfilter则用于描述一个activity（或者IntentReceiver）能够操作哪些intent。一个activity如果要显示一个人的联系方式时，需要声明一个IntentFilter，这个IntentFilter要知道怎么去处理VIEW动作和表示一个人的URI。IntentFilter需要在AndroidManifest.xml中定义。通过解析各种intent，从一个屏幕导航到另一个屏幕是很简单的。当向前导航时，activity将会调用 startActivity(IntentmyIntent)方法。然后，系统会在所有安装的应用程序中定义的IntentFilter中查找，找到最匹配myIntent的Intent对应的activity。新的activity接收到myIntent的通知后，开始运行。当startActivity方法被调用将触发解析myIntent的动作，这个机制提供了两个关键好处： A、Activities能够重复利用从其它组件中以Intent的形式产生的一个请求。 B、Activities可以在任何时候被一个具有相同IntentFilter的新的Activity取代。 ps:csdn编辑器写博客太麻烦了，尤其是排版上，还好现在支持markdown语法了。还是希望能将精力更多集中在内容上，而不是排版上，markdown解决了这个问题。","@type":"BlogPosting","url":"https://mlh.app/2015/05/24/730188.html","headline":"快速进入Android世界","dateModified":"2015-05-24T00:00:00+08:00","datePublished":"2015-05-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2015/05/24/730188.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>快速进入Android世界</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h2>Android概述</h2> 
  <h3>Android是什么<span> </span></h3> 
  <span></span>Android是一种以Linux为基础的开放源码操作系统和应用程序，主要使用于便携设备。
  <span></span>
  <br> Android操作系统最初由Andy Rubin开发，最初主要支持手机。
  <span></span>
  <br> 2005年由Google收购注资，并组建开放手机联盟开发改良，逐渐扩展到平板电脑及其他领域上。
  <span></span>
  <br> 2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。
  <span></span>
  <br> 2011年11月数据，Android占据全球智能手机操作系统市场52.5%的份额，中国市场占有率为58%。
  <span></span>
  <br>
  <h3>Android名称来源<span>&nbsp;</span></h3> 
  <p><span style="font-size:12px;">Android一词最早出现于法国作家利尔亚当（Auguste Villiers de l'Isle-Adam）在1886年发</span><span style="font-size:12px;">表的科幻小说《未来夏娃》（L'ève future）中。他将外表像人的机器起名Android。</span></p> 
  <p><strong>Android的版本<span> </span></strong></p> 
  <span></span>android1.1
  <span> </span> 
  <br> …
  <span> </span>
  <br> android4.0
  <span> </span>
  <br>
  <p>android4.1<span>&nbsp;</span></p> 
  <p>&nbsp; &nbsp; &nbsp; ...<span> </span></p> 
  <h3>Android开发方向<span> </span></h3> 
  <span></span>
  <strong>系统开发</strong>
  <span><strong></strong></span>
  <br>
  <span></span> 
  <p>扩展操作系统功能 比较高难<span> ,</span>android底层使用c c++开发。从事android系统开发，除了对java需要有深入的了解和开发经验，还需要对c 和c++有深入了解和足够的开发经验</p> 
  <strong>应用开发</strong>
  <span></span>
  <br>
  <p>开发应用程序<span> </span>难度一般<span></span></p> 
  <h3><span>Android的系统架构<span> </span> <span></span><span></span></span></h3> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150515104657092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <div> 
   <h3>应用层<span> </span></h3> 应用是用Java语言编写的运行在虚拟机上的程序。
   <span> </span>
   <br>
   <h3>应用框架层<span>&nbsp;</span></h3> 
   <p><span style="font-size:12px;">这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架开发自己的应用，这样便简化了程序开发的框架设计，但是必须遵守其框架的开发原则。</span><span style="font-size:12px;"></span></p> 
   <h3>系统运行库层<span> </span></h3> 当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其能更好的为我们服务。 
   <h3>Linux 内核层<span>&nbsp;</span></h3> 
   <p><span style="font-size:12px;">Android的核心系统服务于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Linux内核同时也作为硬件和软件栈之间的抽象层。</span><span style="font-size:12px;"></span></p> 
  </div> 
  <h2>开发环境搭建<span> </span></h2> 
  <div>
   这里主要说下Eclipse下开发的环境搭建，官方现在推荐Android Studio ,关于Android Studio 我也是刚开始接触，我会把遇到的问题总结出来，以后以博文的形式进行分享。&nbsp;
  </div> 
  <div> 
   <h3>Android开发准备工作<span> </span></h3> 
   <strong>所需软件：</strong>
   <span> </span>
   <br>
   <span></span>JDK
   <span> </span>1.5或更高（推荐使用JDK1.6版本） 、Eclipse
   <span></span>3.5或更高（推荐使用3.7版本）
   <span>&nbsp;、</span>Android SDK
   <span></span>Android SDK 4.0.3
   <span> 、</span>ADT
   <span></span>ADT 20.0.2
  </div> 
  <div> 
   <h3>Android开发环境搭建<span> </span></h3> 
   <strong>安装SDK</strong>
   <span><strong> </strong></span>
   <br>
   <span></span>SDK是Android开发工具包，包含开发Android应用程序的API
   <span></span>
   <br> SDK需要JDK1.5及以上的版本支持 安装SDK前需要先安装JDK
   <span></span>
   <br> SDK的官方下载地址：
   <span> </span>
   <br> http://developer.android.com/sdk/index.html
   <span></span>
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150515105740886?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">
  </div> 
  <div>
   下载后双击安装即可
   <span> </span>
   <br> 安装后的SDK只是一个SDK版本的管理器，点击SDK Manager，里面管理的是android SDK也就是android系统的版本
  </div> 
  <div>
   勾选点击Install Packages即可对应下载
  </div> 
  <div>
   <span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150515105904970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span>
   <br>
   <span><span></span><br><strong>android版本:</strong><span><strong> </strong></span><br><span></span></span> 
   <p><span>1.X 较早手机版本<span> </span> </span><span>2.X 主流手机版本<span> </span> </span><span>3.X 平板电脑版本<span> </span> </span><span>4.X 为2.X与3.X整合版 ,</span><span>即可手机使用，也可平板使用<span></span></span></p> 
   <h3><span>配置SDK的环境变量<span> </span> </span><span style="font-size:12px;"></span></h3> 
   <p><span>找到SDK的安装路径<br></span><span>打开tools文件夹</span></p> 
  </div> 
  <div></div> 
  <div></div> 
  <div></div> 
  <div></div> 
  <div></div> 
  <div></div> 
  <div></div> 
  <div>
   <span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150515110157054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span>
   <br>
  </div> 
  <div>
   &nbsp;添加到环境变量path里
  </div> 
  <div>
   <br>
  </div> 
  <div>
   <span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150515110410048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span>
  </div> 
  <div>
   <br>
  </div> 
  <div>
   打开platform-form-tools文件夹
   <span> </span>
  </div> 
  <div>
   一样的道理，把路径复制好后，加入环境变量path里
  </div> 
  <div> 
   <h3>安装ADT插件<span> </span></h3> 
   <span></span>
   <strong>ADT</strong>
   <br>
   <span></span>使用eclipse并不能直接使用SDK开发android应用程序，这就需要添加eclipse对SDK的支持，也就是，eclipse需要插件来支持SDK
   <span></span>
   <br>
   <span></span>这个插件就是--ADT
   <span> </span> 
   <br>
   <strong><span></span>下载ADT</strong>
   <br>
   <span></span>下载ADT插件，ADT插件的版本号一定要与下载的SDK版本号一致
   <br>
   <span></span>启动Eclipse，“Help”→“Install New Software..”→“add” 指定ADT所在路径即可，单击OK
   <span></span>
   <br>
   <span></span>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517183524803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517183603257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517183836671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517184021453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   点击finish完成安装，若出现如下图所示警告，单击OK继续安装即可
  </div> 
  <div>
   <span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517184145229?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span>
  </div> 
  <div>
   <span><br> 出现如下提示，则安装成功，重启eclipse<span> </span></span>
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517184519308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   若工具栏出现android图标，即插件安装成功
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517184610070?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <h3>在eclipse中配置SDK</h3> 
  <p><span style="font-size:12px;">点击Windows→Preferences→android<span></span></span></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517184719440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p> 
  <h2>创建AVD（模拟器）<span style="font-size:12px;"> </span></h2> 
  <div> 
   <h3>AVD <span></span></h3> AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，即模拟手机。
   <span></span>
   <br>
   <h3>创建AVD<span> </span></h3> 
   <p><span style="font-size:12px;">点击图标</span></p> 
   <p><span style="font-size:12px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517185027673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p> 
   <p><span style="font-size:12px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517193306776?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p> 
   <p><span style="font-size:12px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517193508226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p> 
  </div> 
  <p><span>点击Create AVD<span> </span> </span></p> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517193529111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <div>
   点击start 出现如下窗口 点击Launch启动模拟器
  </div> 
  <div>
   <span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517193948508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span>
  </div> 
  <div>
   <span>启动成功后会看到一个模拟手机的画面<span></span><span></span></span>
  </div> 
  <div></div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517194434226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
   <br>
  </div> 
  <h2>第一个HelloWorld程序</h2> 
  <p><span>创建一个Android项目<span> </span> <span></span></span></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517194700114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517194825840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>连续点击下一步 直到完成按钮可以点击</p> 
  <p><span><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517194832170?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p> 
  <p>运行程序<span> </span></p> 
  <p>点击项目右键<span> </span></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517195038315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>运行结果<br></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517195055362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <h2>Android项目的目录结构<span> </span></h2> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517195401428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" width="800" height="700" alt="">
   <br>
  </div> 
  <div>
   gen：
   <span> </span>
  </div> 
  <div>
   当向res文件夹内添加资源时，会在R.java内自动生成，代表添加资源的变量，通过访问变量(即R.变量名)，直接可以访问资源。如下图：当向drawable-hdpi内添加图片a.JPG，则R类自动添加代表a.JPG的变量
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517195450034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">
  </div> 
  <div>
   res:
  </div> 
  <div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150517195822245?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvend0bzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" width="800" height="700" alt="">
  </div> 
  <div> 
   <h2>Android组件<span> </span></h2> 
   <h3><span style="font-size:12px;">Activity(活动)：</span><span style="font-size:12px;"></span></h3> 
   <p>活动是最基本的Android应用程序组件，应用程序中，一个活动通常就是一个单独的屏幕。每一个活动都被实现为一个独立的类，并且从活动基类中继承而来，活动类将会显示由视图控件组成的用户接口，并对事件做出响应。大多数的应用是由多个屏幕显示组成。例如:一个文本信息的应用也许有一个显示发送消息的联系人列表屏幕，第二个屏幕用来写文本消息和选择收件人，再来一个屏幕查看消息历史或者消息设置操作 等。这里每一个这样的屏幕就是一个活动，很容易实现从一个屏幕到一个新的屏幕并且完成新的活动。在某些情况下当前的屏幕也许需要向上一个屏幕活动提供返回值--比如让用户从手机中挑选一张照片返回通讯录做为电话拨入者的头像。<span></span><span></span></p> 
   <p>当一个新的屏幕打开后，前一个屏幕将会暂停，并保存在历史堆栈中。用户可以返回到历史堆栈中的前一个屏幕。当屏幕不再使用时，还可以从历史堆栈中删除。默认情况下，Android将会保留从主屏幕到每一个应用的运行屏幕。<span></span><br> 简单理解Activity代表一个用户所能看到的屏幕，Activity主要是处理一个应用的整体性工作，例如，监听系统事件(按键事件、触摸屏事件等)、为用户显示指定的View，启动其他Activity等。所有应用的Activity都继承于android.app.Activity类，该类是Android提供的基层类，其他的Activity继承该父类后，通过Override父类的方法来实现各种功能，这种设计在其他领域也较为常见。</p> 
   <h3>Service(服务):</h3> 
   <p>一个Service是一段长生命周期的，没有用户界面的程序。比较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。然而，音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。在这个例子中，媒体播放器这个activity会使用Context.startService()来启动一个service，从而可以在后台保持音乐的播放。同时，系统也将保持这个service一直执行，直到这个service运行结束。另外我们还可以通过使用Context.bindService()方法，连接到一个service上（如果这个service还没有运行将启动它）。当连接到一个service之后，我们还可以service提供的接口与它进行通讯。拿媒体播放器这个例子来说我们还可以进行暂停、重播等操作。</p> 
   <h3>ContentProvider(内容提供者): <span></span></h3> 
   <p>Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据与其它的应用共享时，内容提供器就可以发挥作用了。因为内容提供器类实现了一组标准的方法，从而能够让其它的应用保存或读取此内容提供器处理的各种数据类型。 数据是应用的核心。在Android中，默认使用鼎鼎大名的SQLite作为系统DB。但是在Android中，使用方法有点小小的不一样。在Android中每一个应用都运行在各自的进程中，当你的应用需要访问其他应用的数据时，也就需要数据在不同的虚拟机之间传递，这样的情况操作起来可能有些困难(正常情况下，你不能读取其他的应用的db文件)，ContentProvider正是用来解决在不同的应用包之间共享数据的工具。</p> 
   <h3>BroadcastReceiver(广播接收者): <span></span></h3> 
   <p>一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据。一个应用程序可以有任意数量的广播接收者去反应任何它认为重要的公告。所有的接受者继承自BroadcastReceiver基类。Android 中的广播要么来自于系统，要么来自普通应用程序。很多事件都可能导致系统广播，如手机所在时区发生变化，电池电量低，用户改变系统语言设置等。来自普通应用程序，如一个应用程序通知其他应用程序某些数据已经下载完毕。</p> 为了响应不同的事件通知，应用程序可以注册不同的 Broadcast Receiver 。所有的 Broadcast Receiver都继承自基类 BroadcastReceiver 。BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以启动Activity 作为响应，或者通过 NotificationMananger 提醒用户。BroadcastReceiver 是对发送出来的 Broadcast 进行过滤接收并响应的一类组件。 
   <h3> </h3>
   <p>Intent(意图)：<span> </span></p> 
   <p>Android使用了Intent这个特殊类，实现在屏幕与屏幕之间移动。Intent类用于描述一个应用将会做什么事。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。典型的动作类型有：MAIN（activity的门户）、VIEW、PICK、EDIT等。而动作对应的数据则以URI的形式进行表示。例如：要查看一个人的联系方式，你需要创建一个动作类型为VIEW的intent，以及一个表示这个人的URI。与之有关系的一个类叫IntentFilter。相对于intent是一个有效的做某事的请求，一个intentfilter则用于描述一个activity（或者IntentReceiver）能够操作哪些intent。一个activity如果要显示一个人的联系方式时，需要声明一个IntentFilter，这个IntentFilter要知道怎么去处理VIEW动作和表示一个人的URI。IntentFilter需要在AndroidManifest.xml中定义。通过解析各种intent，从一个屏幕导航到另一个屏幕是很简单的。当向前导航时，activity将会调用 startActivity(IntentmyIntent)方法。然后，系统会在所有安装的应用程序中定义的IntentFilter中查找，找到最匹配myIntent的Intent对应的activity。新的activity接收到myIntent的通知后，开始运行。当startActivity方法被调用将触发解析myIntent的动作，这个机制提供了两个关键好处：</p> 
   <p>A、Activities能够重复利用从其它组件中以Intent的形式产生的一个请求。 <br> B、Activities可以在任何时候被一个具有相同IntentFilter的新的Activity取代。</p> 
   <p><br></p> 
   <p>ps:csdn编辑器写博客太麻烦了，尤其是排版上，还好现在支持markdown语法了。还是希望能将精力更多集中在内容上，而不是排版上，markdown解决了这个问题。</p> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
