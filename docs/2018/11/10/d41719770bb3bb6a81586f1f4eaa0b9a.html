<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、base58实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、base58实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、BASE58实现 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 椭圆曲线原理参考(讲解得很易懂): http://blog.51cto.com/11821908/2057726 ecdsa中文文档：https://studygolang.com/pkgdoc 本文主要讲解使用Go的ecdsa库实现椭圆曲线加解密、签名、验证算法，同时通过公钥生成比特币地址，具体代码逻辑参考bitcoin0.1的key.h、base58.h。 有兴趣的朋友可以阅读一下bitcoin0.1源码，我注释写得详细，因为内容太多太多，暂时我就不单独写关于比特币源码阅读的博客了（后续也许会有专栏），有不懂的朋友可以email。同时本人正在寻找一份合适的有关区块链开发的工作，希望各位朋友推荐一下哟！ 源码地址在文章末尾，喜欢可以Star支持一下哦！ 后续会有区块链其他技术部分的go实现，有兴趣的朋友可以关注一下哦。 生成密钥对 func MakeNewKey(randKey string) (*GKey, error) { var err error var gkey GKey var curve elliptic.Curve // 椭圆曲线参数 lenth := len(randKey) if lenth &lt; 224/8+8 { err = errors.New(&quot;RandKey is too short. It mast be longer than 36 bytes.&quot;) return &amp;gkey, err } else if lenth &gt; 521/8+8 { curve = elliptic.P521() } else if lenth &gt; 384/8+8 { curve = elliptic.P384() } else if lenth &gt; 256/8+8 { curve = elliptic.P256() } else if lenth &gt; 224/8+8 { curve = elliptic.P224() } private, err := ecdsa.GenerateKey(curve, strings.NewReader(randKey)) if err != nil { log.Panic(err) } gkey = GKey{private, private.PublicKey} return &amp;gkey, nil } 解释：randKey可以是随机的，也可以是用户输入的助记词，randKey决定私钥，当然同时也决定了公钥。 公钥转换为比特币地址 具体逻辑实现逻辑是： 先对pubKey进行sha256运算 再对1步骤得到的值进行ripemed160运算 再对2得到的值在首部加上2个字节的版本号 再对3得到的值进行sha256运算 再对4得到的值进行sha256运算 把5得到的值的前4个字节加到3得到的值(加上版本号的值)的末尾 把6得到的值进行base58运算 如果6得到的值中有出现0，则在7得到的值前加入一个&quot;1&quot; 得到地址 代码实现： func (k GKey) GetAddress() (address string) { /* See https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses */ pub_bytes := k.GetPubKey() /* SHA256 HASH */ fmt.Println(&quot;1 - Perform SHA-256 hashing on the public key&quot;) sha256_h := sha256.New() sha256_h.Reset() sha256_h.Write(pub_bytes) pub_hash_1 := sha256_h.Sum(nil) // 对公钥进行hash256运算 fmt.Println(ByteToString(pub_hash_1)) fmt.Println(&quot;================&quot;) /* RIPEMD-160 HASH */ fmt.Println(&quot;2 - Perform RIPEMD-160 hashing on the result of SHA-256&quot;) ripemd160_h := ripemd160.New() ripemd160_h.Reset() ripemd160_h.Write(pub_hash_1) pub_hash_2 := ripemd160_h.Sum(nil) // 对公钥hash进行ripemd160运算 fmt.Println(ByteToString(pub_hash_2)) fmt.Println(&quot;================&quot;) /* Convert hash bytes to base58 chech encoded sequence */ address = b58checkencode(0x00, pub_hash_2) return address } func b58checkencode(ver uint8, b []byte) (s string) { /* Prepend version */ fmt.Println(&quot;3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network)&quot;) bcpy := append([]byte{ver}, b...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Create a new SHA256 context */ sha256H := sha256.New() /* SHA256 HASH #1 */ fmt.Println(&quot;4 - Perform SHA-256 hash on the extended PIPEMD-160 result&quot;) sha256H.Reset() sha256H.Write(bcpy) hash1 := sha256H.Sum(nil) fmt.Println(ByteToString(hash1)) fmt.Println(&quot;================&quot;) /* SHA256 HASH #2 */ fmt.Println(&quot;5 - Perform SHA-256 hash on the result of the previous SHA-256 hash&quot;) sha256H.Reset() sha256H.Write(hash1) hash2 := sha256H.Sum(nil) fmt.Println(ByteToString(hash2)) fmt.Println(&quot;================&quot;) /* Append first four bytes of hash */ fmt.Println(&quot;6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum&quot;) fmt.Println(ByteToString(hash2[0:4])) fmt.Println(&quot;================&quot;) fmt.Println(&quot;7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address.&quot;) bcpy = append(bcpy, hash2[0:4]...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Encode base58 string */ s = b58encode(bcpy) /* For number of leading 0&#39;s in bytes, prepend 1 */ for _, v := range bcpy { if v != 0 { break } s = &quot;1&quot; + s } fmt.Println(&quot;8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format&quot;) fmt.Println(s) fmt.Println(&quot;================&quot;) return s } base58实现 func b58encode(b []byte) (s string) { /* See https://en.bitcoin.it/wiki/Base58Check_encoding */ const BITCOIN_BASE58_TABLE = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot; x := new(big.Int).SetBytes(b) // Initialize r := new(big.Int) m := big.NewInt(58) zero := big.NewInt(0) s = &quot;&quot; /* Convert big int to string */ for x.Cmp(zero) &gt; 0 { /* x, r = (x /58, x % 58) */ x.QuoRem(x, m, r) /* Prepend ASCII character */ s = string(BITCOIN_BASE58_TABLE[r.Int64()]) + s } return s } 数字签名 /* 对text签名 返回加密结果，结果为数字证书r、s的序列化后拼接，然后用hex转换为string */ func (k GKey) Sign(text []byte) (string, error) { r, s, err := ecdsa.Sign(rand.Reader, k.privateKey, text) if err != nil { return &quot;&quot;, err } rt, err := r.MarshalText() if err != nil { return &quot;&quot;, err } st, err := s.MarshalText() if err != nil { return &quot;&quot;, err } var b bytes.Buffer w := gzip.NewWriter(&amp;b) defer w.Close() _, err = w.Write([]byte(string(rt) + &quot;+&quot; + string(st))) if err != nil { return &quot;&quot;, err } w.Flush() return hex.EncodeToString(b.Bytes()), nil } 验证签名 /* 校验文本内容是否与签名一致 使用公钥校验签名和文本内容 */ func Verify(text []byte, signature string, pubKey *ecdsa.PublicKey) (bool, error) { rint, sint, err := getSign(signature) if err != nil { return false, err } result := ecdsa.Verify(pubKey, text, &amp;rint, &amp;sint) return result, nil } /* 证书分解 通过hex解码，分割成数字证书r，s */ func getSign(signature string) (rint, sint big.Int, err error) { byterun, err := hex.DecodeString(signature) if err != nil { err = errors.New(&quot;decrypt error,&quot; + err.Error()) return } r, err := gzip.NewReader(bytes.NewBuffer(byterun)) if err != nil { err = errors.New(&quot;decode error,&quot; + err.Error()) return } defer r.Close() buf := make([]byte, 1024) count, err := r.Read(buf) if err != nil { fmt.Println(&quot;decode = &quot;, err) err = errors.New(&quot;decode read error,&quot; + err.Error()) return } rs := strings.Split(string(buf[:count]), &quot;+&quot;) if len(rs) != 2 { err = errors.New(&quot;decode fail&quot;) return } err = rint.UnmarshalText([]byte(rs[0])) if err != nil { err = errors.New(&quot;decrypt rint fail, &quot; + err.Error()) return } err = sint.UnmarshalText([]byte(rs[1])) if err != nil { err = errors.New(&quot;decrypt sint fail, &quot; + err.Error()) return } return } 运行结果 $ go run test.go My privateKey is : 00000000323132324153720678C83DFE6126497EF4A8C75CBC9862EEEC77F006 My publickKey is : EF855DD23C7E3462DCA1935EA516573CF44E8C226EC31146D380A9BCC053CE277222BD827B18187152197F5F36B3002812A636615498E40E 1 - Perform SHA-256 hashing on the public key 0EF6B0BCBB3A0434A08EB0190CF5DEE38CF62866BC1F51D9F8EAB71AAC0C0A80 ================ 2 - Perform RIPEMD-160 hashing on the result of SHA-256 368FE10638FB2890B9C7BC334035F656F0B450FA ================ 3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network) 00368FE10638FB2890B9C7BC334035F656F0B450FA ================ 4 - Perform SHA-256 hash on the extended PIPEMD-160 result 569F0D58CAB5195D5C84ABBA2FFA3883CC93A2C19BF60FF54E5E7E5565251FA2 ================ 5 - Perform SHA-256 hash on the result of the previous SHA-256 hash 8FEB0E8C808D61D40EC8D9CC17CAB2C12FE1FE841582AEE024A7F6839596CD45 ================ 6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum 8FEB0E8C ================ 7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address. 00368FE10638FB2890B9C7BC334035F656F0B450FA8FEB0E8C ================ 8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm ================ My address is: 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm Signature is : 1f8b08000000000000ff04c0c101c0500c01d0817a49888ffd17eb7b4dd18874c185472e94db29bd0c549cde598a07e008c4001b8a97dea7c2c3971adcc9dd3a48ccb16e1cc37a150727d502e36773fb467d3eec0f0000ffff Verify success 源码地址 转载请注明出处：https://blog.csdn.net/AlexTan_/article/details/83934075 阅读更多" />
<meta property="og:description" content="go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、BASE58实现 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 椭圆曲线原理参考(讲解得很易懂): http://blog.51cto.com/11821908/2057726 ecdsa中文文档：https://studygolang.com/pkgdoc 本文主要讲解使用Go的ecdsa库实现椭圆曲线加解密、签名、验证算法，同时通过公钥生成比特币地址，具体代码逻辑参考bitcoin0.1的key.h、base58.h。 有兴趣的朋友可以阅读一下bitcoin0.1源码，我注释写得详细，因为内容太多太多，暂时我就不单独写关于比特币源码阅读的博客了（后续也许会有专栏），有不懂的朋友可以email。同时本人正在寻找一份合适的有关区块链开发的工作，希望各位朋友推荐一下哟！ 源码地址在文章末尾，喜欢可以Star支持一下哦！ 后续会有区块链其他技术部分的go实现，有兴趣的朋友可以关注一下哦。 生成密钥对 func MakeNewKey(randKey string) (*GKey, error) { var err error var gkey GKey var curve elliptic.Curve // 椭圆曲线参数 lenth := len(randKey) if lenth &lt; 224/8+8 { err = errors.New(&quot;RandKey is too short. It mast be longer than 36 bytes.&quot;) return &amp;gkey, err } else if lenth &gt; 521/8+8 { curve = elliptic.P521() } else if lenth &gt; 384/8+8 { curve = elliptic.P384() } else if lenth &gt; 256/8+8 { curve = elliptic.P256() } else if lenth &gt; 224/8+8 { curve = elliptic.P224() } private, err := ecdsa.GenerateKey(curve, strings.NewReader(randKey)) if err != nil { log.Panic(err) } gkey = GKey{private, private.PublicKey} return &amp;gkey, nil } 解释：randKey可以是随机的，也可以是用户输入的助记词，randKey决定私钥，当然同时也决定了公钥。 公钥转换为比特币地址 具体逻辑实现逻辑是： 先对pubKey进行sha256运算 再对1步骤得到的值进行ripemed160运算 再对2得到的值在首部加上2个字节的版本号 再对3得到的值进行sha256运算 再对4得到的值进行sha256运算 把5得到的值的前4个字节加到3得到的值(加上版本号的值)的末尾 把6得到的值进行base58运算 如果6得到的值中有出现0，则在7得到的值前加入一个&quot;1&quot; 得到地址 代码实现： func (k GKey) GetAddress() (address string) { /* See https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses */ pub_bytes := k.GetPubKey() /* SHA256 HASH */ fmt.Println(&quot;1 - Perform SHA-256 hashing on the public key&quot;) sha256_h := sha256.New() sha256_h.Reset() sha256_h.Write(pub_bytes) pub_hash_1 := sha256_h.Sum(nil) // 对公钥进行hash256运算 fmt.Println(ByteToString(pub_hash_1)) fmt.Println(&quot;================&quot;) /* RIPEMD-160 HASH */ fmt.Println(&quot;2 - Perform RIPEMD-160 hashing on the result of SHA-256&quot;) ripemd160_h := ripemd160.New() ripemd160_h.Reset() ripemd160_h.Write(pub_hash_1) pub_hash_2 := ripemd160_h.Sum(nil) // 对公钥hash进行ripemd160运算 fmt.Println(ByteToString(pub_hash_2)) fmt.Println(&quot;================&quot;) /* Convert hash bytes to base58 chech encoded sequence */ address = b58checkencode(0x00, pub_hash_2) return address } func b58checkencode(ver uint8, b []byte) (s string) { /* Prepend version */ fmt.Println(&quot;3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network)&quot;) bcpy := append([]byte{ver}, b...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Create a new SHA256 context */ sha256H := sha256.New() /* SHA256 HASH #1 */ fmt.Println(&quot;4 - Perform SHA-256 hash on the extended PIPEMD-160 result&quot;) sha256H.Reset() sha256H.Write(bcpy) hash1 := sha256H.Sum(nil) fmt.Println(ByteToString(hash1)) fmt.Println(&quot;================&quot;) /* SHA256 HASH #2 */ fmt.Println(&quot;5 - Perform SHA-256 hash on the result of the previous SHA-256 hash&quot;) sha256H.Reset() sha256H.Write(hash1) hash2 := sha256H.Sum(nil) fmt.Println(ByteToString(hash2)) fmt.Println(&quot;================&quot;) /* Append first four bytes of hash */ fmt.Println(&quot;6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum&quot;) fmt.Println(ByteToString(hash2[0:4])) fmt.Println(&quot;================&quot;) fmt.Println(&quot;7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address.&quot;) bcpy = append(bcpy, hash2[0:4]...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Encode base58 string */ s = b58encode(bcpy) /* For number of leading 0&#39;s in bytes, prepend 1 */ for _, v := range bcpy { if v != 0 { break } s = &quot;1&quot; + s } fmt.Println(&quot;8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format&quot;) fmt.Println(s) fmt.Println(&quot;================&quot;) return s } base58实现 func b58encode(b []byte) (s string) { /* See https://en.bitcoin.it/wiki/Base58Check_encoding */ const BITCOIN_BASE58_TABLE = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot; x := new(big.Int).SetBytes(b) // Initialize r := new(big.Int) m := big.NewInt(58) zero := big.NewInt(0) s = &quot;&quot; /* Convert big int to string */ for x.Cmp(zero) &gt; 0 { /* x, r = (x /58, x % 58) */ x.QuoRem(x, m, r) /* Prepend ASCII character */ s = string(BITCOIN_BASE58_TABLE[r.Int64()]) + s } return s } 数字签名 /* 对text签名 返回加密结果，结果为数字证书r、s的序列化后拼接，然后用hex转换为string */ func (k GKey) Sign(text []byte) (string, error) { r, s, err := ecdsa.Sign(rand.Reader, k.privateKey, text) if err != nil { return &quot;&quot;, err } rt, err := r.MarshalText() if err != nil { return &quot;&quot;, err } st, err := s.MarshalText() if err != nil { return &quot;&quot;, err } var b bytes.Buffer w := gzip.NewWriter(&amp;b) defer w.Close() _, err = w.Write([]byte(string(rt) + &quot;+&quot; + string(st))) if err != nil { return &quot;&quot;, err } w.Flush() return hex.EncodeToString(b.Bytes()), nil } 验证签名 /* 校验文本内容是否与签名一致 使用公钥校验签名和文本内容 */ func Verify(text []byte, signature string, pubKey *ecdsa.PublicKey) (bool, error) { rint, sint, err := getSign(signature) if err != nil { return false, err } result := ecdsa.Verify(pubKey, text, &amp;rint, &amp;sint) return result, nil } /* 证书分解 通过hex解码，分割成数字证书r，s */ func getSign(signature string) (rint, sint big.Int, err error) { byterun, err := hex.DecodeString(signature) if err != nil { err = errors.New(&quot;decrypt error,&quot; + err.Error()) return } r, err := gzip.NewReader(bytes.NewBuffer(byterun)) if err != nil { err = errors.New(&quot;decode error,&quot; + err.Error()) return } defer r.Close() buf := make([]byte, 1024) count, err := r.Read(buf) if err != nil { fmt.Println(&quot;decode = &quot;, err) err = errors.New(&quot;decode read error,&quot; + err.Error()) return } rs := strings.Split(string(buf[:count]), &quot;+&quot;) if len(rs) != 2 { err = errors.New(&quot;decode fail&quot;) return } err = rint.UnmarshalText([]byte(rs[0])) if err != nil { err = errors.New(&quot;decrypt rint fail, &quot; + err.Error()) return } err = sint.UnmarshalText([]byte(rs[1])) if err != nil { err = errors.New(&quot;decrypt sint fail, &quot; + err.Error()) return } return } 运行结果 $ go run test.go My privateKey is : 00000000323132324153720678C83DFE6126497EF4A8C75CBC9862EEEC77F006 My publickKey is : EF855DD23C7E3462DCA1935EA516573CF44E8C226EC31146D380A9BCC053CE277222BD827B18187152197F5F36B3002812A636615498E40E 1 - Perform SHA-256 hashing on the public key 0EF6B0BCBB3A0434A08EB0190CF5DEE38CF62866BC1F51D9F8EAB71AAC0C0A80 ================ 2 - Perform RIPEMD-160 hashing on the result of SHA-256 368FE10638FB2890B9C7BC334035F656F0B450FA ================ 3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network) 00368FE10638FB2890B9C7BC334035F656F0B450FA ================ 4 - Perform SHA-256 hash on the extended PIPEMD-160 result 569F0D58CAB5195D5C84ABBA2FFA3883CC93A2C19BF60FF54E5E7E5565251FA2 ================ 5 - Perform SHA-256 hash on the result of the previous SHA-256 hash 8FEB0E8C808D61D40EC8D9CC17CAB2C12FE1FE841582AEE024A7F6839596CD45 ================ 6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum 8FEB0E8C ================ 7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address. 00368FE10638FB2890B9C7BC334035F656F0B450FA8FEB0E8C ================ 8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm ================ My address is: 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm Signature is : 1f8b08000000000000ff04c0c101c0500c01d0817a49888ffd17eb7b4dd18874c185472e94db29bd0c549cde598a07e008c4001b8a97dea7c2c3971adcc9dd3a48ccb16e1cc37a150727d502e36773fb467d3eec0f0000ffff Verify success 源码地址 转载请注明出处：https://blog.csdn.net/AlexTan_/article/details/83934075 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/11/10/d41719770bb3bb6a81586f1f4eaa0b9a.html" />
<meta property="og:url" content="https://mlh.app/2018/11/10/d41719770bb3bb6a81586f1f4eaa0b9a.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、BASE58实现 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 椭圆曲线原理参考(讲解得很易懂): http://blog.51cto.com/11821908/2057726 ecdsa中文文档：https://studygolang.com/pkgdoc 本文主要讲解使用Go的ecdsa库实现椭圆曲线加解密、签名、验证算法，同时通过公钥生成比特币地址，具体代码逻辑参考bitcoin0.1的key.h、base58.h。 有兴趣的朋友可以阅读一下bitcoin0.1源码，我注释写得详细，因为内容太多太多，暂时我就不单独写关于比特币源码阅读的博客了（后续也许会有专栏），有不懂的朋友可以email。同时本人正在寻找一份合适的有关区块链开发的工作，希望各位朋友推荐一下哟！ 源码地址在文章末尾，喜欢可以Star支持一下哦！ 后续会有区块链其他技术部分的go实现，有兴趣的朋友可以关注一下哦。 生成密钥对 func MakeNewKey(randKey string) (*GKey, error) { var err error var gkey GKey var curve elliptic.Curve // 椭圆曲线参数 lenth := len(randKey) if lenth &lt; 224/8+8 { err = errors.New(&quot;RandKey is too short. It mast be longer than 36 bytes.&quot;) return &amp;gkey, err } else if lenth &gt; 521/8+8 { curve = elliptic.P521() } else if lenth &gt; 384/8+8 { curve = elliptic.P384() } else if lenth &gt; 256/8+8 { curve = elliptic.P256() } else if lenth &gt; 224/8+8 { curve = elliptic.P224() } private, err := ecdsa.GenerateKey(curve, strings.NewReader(randKey)) if err != nil { log.Panic(err) } gkey = GKey{private, private.PublicKey} return &amp;gkey, nil } 解释：randKey可以是随机的，也可以是用户输入的助记词，randKey决定私钥，当然同时也决定了公钥。 公钥转换为比特币地址 具体逻辑实现逻辑是： 先对pubKey进行sha256运算 再对1步骤得到的值进行ripemed160运算 再对2得到的值在首部加上2个字节的版本号 再对3得到的值进行sha256运算 再对4得到的值进行sha256运算 把5得到的值的前4个字节加到3得到的值(加上版本号的值)的末尾 把6得到的值进行base58运算 如果6得到的值中有出现0，则在7得到的值前加入一个&quot;1&quot; 得到地址 代码实现： func (k GKey) GetAddress() (address string) { /* See https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses */ pub_bytes := k.GetPubKey() /* SHA256 HASH */ fmt.Println(&quot;1 - Perform SHA-256 hashing on the public key&quot;) sha256_h := sha256.New() sha256_h.Reset() sha256_h.Write(pub_bytes) pub_hash_1 := sha256_h.Sum(nil) // 对公钥进行hash256运算 fmt.Println(ByteToString(pub_hash_1)) fmt.Println(&quot;================&quot;) /* RIPEMD-160 HASH */ fmt.Println(&quot;2 - Perform RIPEMD-160 hashing on the result of SHA-256&quot;) ripemd160_h := ripemd160.New() ripemd160_h.Reset() ripemd160_h.Write(pub_hash_1) pub_hash_2 := ripemd160_h.Sum(nil) // 对公钥hash进行ripemd160运算 fmt.Println(ByteToString(pub_hash_2)) fmt.Println(&quot;================&quot;) /* Convert hash bytes to base58 chech encoded sequence */ address = b58checkencode(0x00, pub_hash_2) return address } func b58checkencode(ver uint8, b []byte) (s string) { /* Prepend version */ fmt.Println(&quot;3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network)&quot;) bcpy := append([]byte{ver}, b...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Create a new SHA256 context */ sha256H := sha256.New() /* SHA256 HASH #1 */ fmt.Println(&quot;4 - Perform SHA-256 hash on the extended PIPEMD-160 result&quot;) sha256H.Reset() sha256H.Write(bcpy) hash1 := sha256H.Sum(nil) fmt.Println(ByteToString(hash1)) fmt.Println(&quot;================&quot;) /* SHA256 HASH #2 */ fmt.Println(&quot;5 - Perform SHA-256 hash on the result of the previous SHA-256 hash&quot;) sha256H.Reset() sha256H.Write(hash1) hash2 := sha256H.Sum(nil) fmt.Println(ByteToString(hash2)) fmt.Println(&quot;================&quot;) /* Append first four bytes of hash */ fmt.Println(&quot;6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum&quot;) fmt.Println(ByteToString(hash2[0:4])) fmt.Println(&quot;================&quot;) fmt.Println(&quot;7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address.&quot;) bcpy = append(bcpy, hash2[0:4]...) fmt.Println(ByteToString(bcpy)) fmt.Println(&quot;================&quot;) /* Encode base58 string */ s = b58encode(bcpy) /* For number of leading 0&#39;s in bytes, prepend 1 */ for _, v := range bcpy { if v != 0 { break } s = &quot;1&quot; + s } fmt.Println(&quot;8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format&quot;) fmt.Println(s) fmt.Println(&quot;================&quot;) return s } base58实现 func b58encode(b []byte) (s string) { /* See https://en.bitcoin.it/wiki/Base58Check_encoding */ const BITCOIN_BASE58_TABLE = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot; x := new(big.Int).SetBytes(b) // Initialize r := new(big.Int) m := big.NewInt(58) zero := big.NewInt(0) s = &quot;&quot; /* Convert big int to string */ for x.Cmp(zero) &gt; 0 { /* x, r = (x /58, x % 58) */ x.QuoRem(x, m, r) /* Prepend ASCII character */ s = string(BITCOIN_BASE58_TABLE[r.Int64()]) + s } return s } 数字签名 /* 对text签名 返回加密结果，结果为数字证书r、s的序列化后拼接，然后用hex转换为string */ func (k GKey) Sign(text []byte) (string, error) { r, s, err := ecdsa.Sign(rand.Reader, k.privateKey, text) if err != nil { return &quot;&quot;, err } rt, err := r.MarshalText() if err != nil { return &quot;&quot;, err } st, err := s.MarshalText() if err != nil { return &quot;&quot;, err } var b bytes.Buffer w := gzip.NewWriter(&amp;b) defer w.Close() _, err = w.Write([]byte(string(rt) + &quot;+&quot; + string(st))) if err != nil { return &quot;&quot;, err } w.Flush() return hex.EncodeToString(b.Bytes()), nil } 验证签名 /* 校验文本内容是否与签名一致 使用公钥校验签名和文本内容 */ func Verify(text []byte, signature string, pubKey *ecdsa.PublicKey) (bool, error) { rint, sint, err := getSign(signature) if err != nil { return false, err } result := ecdsa.Verify(pubKey, text, &amp;rint, &amp;sint) return result, nil } /* 证书分解 通过hex解码，分割成数字证书r，s */ func getSign(signature string) (rint, sint big.Int, err error) { byterun, err := hex.DecodeString(signature) if err != nil { err = errors.New(&quot;decrypt error,&quot; + err.Error()) return } r, err := gzip.NewReader(bytes.NewBuffer(byterun)) if err != nil { err = errors.New(&quot;decode error,&quot; + err.Error()) return } defer r.Close() buf := make([]byte, 1024) count, err := r.Read(buf) if err != nil { fmt.Println(&quot;decode = &quot;, err) err = errors.New(&quot;decode read error,&quot; + err.Error()) return } rs := strings.Split(string(buf[:count]), &quot;+&quot;) if len(rs) != 2 { err = errors.New(&quot;decode fail&quot;) return } err = rint.UnmarshalText([]byte(rs[0])) if err != nil { err = errors.New(&quot;decrypt rint fail, &quot; + err.Error()) return } err = sint.UnmarshalText([]byte(rs[1])) if err != nil { err = errors.New(&quot;decrypt sint fail, &quot; + err.Error()) return } return } 运行结果 $ go run test.go My privateKey is : 00000000323132324153720678C83DFE6126497EF4A8C75CBC9862EEEC77F006 My publickKey is : EF855DD23C7E3462DCA1935EA516573CF44E8C226EC31146D380A9BCC053CE277222BD827B18187152197F5F36B3002812A636615498E40E 1 - Perform SHA-256 hashing on the public key 0EF6B0BCBB3A0434A08EB0190CF5DEE38CF62866BC1F51D9F8EAB71AAC0C0A80 ================ 2 - Perform RIPEMD-160 hashing on the result of SHA-256 368FE10638FB2890B9C7BC334035F656F0B450FA ================ 3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network) 00368FE10638FB2890B9C7BC334035F656F0B450FA ================ 4 - Perform SHA-256 hash on the extended PIPEMD-160 result 569F0D58CAB5195D5C84ABBA2FFA3883CC93A2C19BF60FF54E5E7E5565251FA2 ================ 5 - Perform SHA-256 hash on the result of the previous SHA-256 hash 8FEB0E8C808D61D40EC8D9CC17CAB2C12FE1FE841582AEE024A7F6839596CD45 ================ 6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum 8FEB0E8C ================ 7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address. 00368FE10638FB2890B9C7BC334035F656F0B450FA8FEB0E8C ================ 8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm ================ My address is: 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm Signature is : 1f8b08000000000000ff04c0c101c0500c01d0817a49888ffd17eb7b4dd18874c185472e94db29bd0c549cde598a07e008c4001b8a97dea7c2c3971adcc9dd3a48ccb16e1cc37a150727d502e36773fb467d3eec0f0000ffff Verify success 源码地址 转载请注明出处：https://blog.csdn.net/AlexTan_/article/details/83934075 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/11/10/d41719770bb3bb6a81586f1f4eaa0b9a.html","headline":"go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、base58实现","dateModified":"2018-11-10T00:00:00+08:00","datePublished":"2018-11-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/11/10/d41719770bb3bb6a81586f1f4eaa0b9a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、base58实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="gogo_ecdsaBASE58_0"></a>go实现椭圆曲线加解密、签名验证算法（go ecdsa库的运用），及生成比特币地址过程讲解、BASE58实现</h1> 
  <p><em>作者: AlexTan</em><br> <em>CSDN: <a href="http://blog.csdn.net/alextan_" rel="nofollow">http://blog.csdn.net/alextan_</a></em><br> <em>Github: <a href="https://github.com/AlexTan-b-z" rel="nofollow">https://github.com/AlexTan-b-z</a></em><br> <em>e-mail: <a href="mailto:alextanbz@gmail.com" rel="nofollow">alextanbz@gmail.com</a></em></p> 
  <h2><a id="_9"></a>前言</h2> 
  <ul> 
   <li> <p>椭圆曲线原理参考(讲解得很易懂): <a href="http://blog.51cto.com/11821908/2057726" rel="nofollow">http://blog.51cto.com/11821908/2057726</a></p> </li> 
   <li> <p>ecdsa中文文档：<a href="https://studygolang.com/pkgdoc" rel="nofollow">https://studygolang.com/pkgdoc</a></p> </li> 
   <li> <p>本文主要讲解使用Go的ecdsa库实现椭圆曲线加解密、签名、验证算法，同时通过公钥生成比特币地址，具体代码逻辑参考bitcoin0.1的key.h、base58.h。</p> </li> 
   <li> <p>有兴趣的朋友可以阅读一下<a href="https://github.com/AlexTan-b-z/bitcoin-0.1" rel="nofollow">bitcoin0.1源码</a>，我注释写得详细，因为内容太多太多，暂时我就不单独写关于比特币源码阅读的博客了（后续也许会有专栏），有不懂的朋友可以email。<strong>同时本人正在寻找一份合适的有关区块链开发的工作</strong>，希望各位朋友推荐一下哟！</p> </li> 
   <li> <p>源码地址在文章末尾，喜欢可以Star支持一下哦！</p> </li> 
   <li> <p>后续会有区块链其他技术部分的go实现，有兴趣的朋友可以关注一下哦。</p> </li> 
  </ul> 
  <h2><a id="_23"></a>生成密钥对</h2> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">MakeNewKey</span><span class="token punctuation">(</span>randKey <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>GKey<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> err <span class="token builtin">error</span>
	<span class="token keyword">var</span> gkey GKey
	<span class="token keyword">var</span> curve elliptic<span class="token punctuation">.</span>Curve <span class="token comment">// 椭圆曲线参数</span>

	lenth <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>randKey<span class="token punctuation">)</span>
	<span class="token keyword">if</span> lenth <span class="token operator">&lt;</span> <span class="token number">224</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"RandKey is too short. It mast be longer than 36 bytes."</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>gkey<span class="token punctuation">,</span> err
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lenth <span class="token operator">&gt;</span> <span class="token number">521</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span> <span class="token punctuation">{</span>
		curve <span class="token operator">=</span> elliptic<span class="token punctuation">.</span><span class="token function">P521</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lenth <span class="token operator">&gt;</span> <span class="token number">384</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span> <span class="token punctuation">{</span>
		curve <span class="token operator">=</span> elliptic<span class="token punctuation">.</span><span class="token function">P384</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lenth <span class="token operator">&gt;</span> <span class="token number">256</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span> <span class="token punctuation">{</span>
		curve <span class="token operator">=</span> elliptic<span class="token punctuation">.</span><span class="token function">P256</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lenth <span class="token operator">&gt;</span> <span class="token number">224</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span> <span class="token punctuation">{</span>
		curve <span class="token operator">=</span> elliptic<span class="token punctuation">.</span><span class="token function">P224</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	private<span class="token punctuation">,</span> err <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">GenerateKey</span><span class="token punctuation">(</span>curve<span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>randKey<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	gkey <span class="token operator">=</span> GKey<span class="token punctuation">{</span>private<span class="token punctuation">,</span> private<span class="token punctuation">.</span>PublicKey<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>gkey<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>解释：randKey可以是随机的，也可以是用户输入的助记词，randKey决定私钥，当然同时也决定了公钥。</p> 
  <h2><a id="_60"></a>公钥转换为比特币地址</h2> 
  <h4><a id="_62"></a>具体逻辑实现逻辑是：</h4> 
  <ol> 
   <li>先对pubKey进行sha256运算</li> 
   <li>再对1步骤得到的值进行ripemed160运算</li> 
   <li>再对2得到的值在首部加上2个字节的版本号</li> 
   <li>再对3得到的值进行sha256运算</li> 
   <li>再对4得到的值进行sha256运算</li> 
   <li>把5得到的值的前4个字节加到3得到的值(加上版本号的值)的末尾</li> 
   <li>把6得到的值进行base58运算</li> 
   <li>如果6得到的值中有出现0，则在7得到的值前加入一个"1"</li> 
   <li>得到地址</li> 
  </ol> 
  <h4><a id="_74"></a>代码实现：</h4> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>k GKey<span class="token punctuation">)</span> <span class="token function">GetAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>address <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">/* See https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses */</span>
	pub_bytes <span class="token operator">:=</span> k<span class="token punctuation">.</span><span class="token function">GetPubKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">/* SHA256 HASH */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"1 - Perform SHA-256 hashing on the public key"</span><span class="token punctuation">)</span>
	sha256_h <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	sha256_h<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	sha256_h<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pub_bytes<span class="token punctuation">)</span>
	pub_hash_1 <span class="token operator">:=</span> sha256_h<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// 对公钥进行hash256运算</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>pub_hash_1<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token comment">/* RIPEMD-160 HASH */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"2 - Perform RIPEMD-160 hashing on the result of SHA-256"</span><span class="token punctuation">)</span>
	ripemd160_h <span class="token operator">:=</span> ripemd160<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	ripemd160_h<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	ripemd160_h<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pub_hash_1<span class="token punctuation">)</span>
	pub_hash_2 <span class="token operator">:=</span> ripemd160_h<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// 对公钥hash进行ripemd160运算</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>pub_hash_2<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>
	<span class="token comment">/* Convert hash bytes to base58 chech encoded sequence */</span>
	address <span class="token operator">=</span> <span class="token function">b58checkencode</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">,</span> pub_hash_2<span class="token punctuation">)</span>

	<span class="token keyword">return</span> address
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">b58checkencode</span><span class="token punctuation">(</span>ver <span class="token builtin">uint8</span><span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">/* Prepend version */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"3 - Add version byte in front of RIPEMD-160 hash (0x00 for Main Network)"</span><span class="token punctuation">)</span>
	bcpy <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span>ver<span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token operator">...</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>bcpy<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token comment">/* Create a new SHA256 context */</span>
	sha256H <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">/* SHA256 HASH #1 */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"4 - Perform SHA-256 hash on the extended PIPEMD-160 result"</span><span class="token punctuation">)</span>
	sha256H<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	sha256H<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bcpy<span class="token punctuation">)</span>
	hash1 <span class="token operator">:=</span> sha256H<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>hash1<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token comment">/* SHA256 HASH #2 */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"5 - Perform SHA-256 hash on the result of the previous SHA-256 hash"</span><span class="token punctuation">)</span>
	sha256H<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	sha256H<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>hash1<span class="token punctuation">)</span>
	hash2 <span class="token operator">:=</span> sha256H<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>hash2<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token comment">/* Append first four bytes of hash */</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>hash2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 hash from stage 4. This is the 25-byte binary Bitcoin Address."</span><span class="token punctuation">)</span>
	bcpy <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>bcpy<span class="token punctuation">,</span> hash2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">ByteToString</span><span class="token punctuation">(</span>bcpy<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token comment">/* Encode base58 string */</span>
	s <span class="token operator">=</span> <span class="token function">b58encode</span><span class="token punctuation">(</span>bcpy<span class="token punctuation">)</span>

	<span class="token comment">/* For number of leading 0's in bytes, prepend 1 */</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> bcpy <span class="token punctuation">{</span>
		<span class="token keyword">if</span> v <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		s <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token operator">+</span> s
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the most commonly used Bitcoin Address format"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> s
<span class="token punctuation">}</span>
</code></pre> 
  <h4><a id="base58_158"></a>base58实现</h4> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">b58encode</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">/* See https://en.bitcoin.it/wiki/Base58Check_encoding */</span>
	<span class="token keyword">const</span> BITCOIN_BASE58_TABLE <span class="token operator">=</span> <span class="token string">"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"</span>

	x <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token comment">// Initialize</span>
	r <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span>
	m <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">)</span>
	zero <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	s <span class="token operator">=</span> <span class="token string">""</span>

	<span class="token comment">/* Convert big int to string */</span>
	<span class="token keyword">for</span> x<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>zero<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token comment">/* x, r = (x /58, x % 58) */</span>
		x<span class="token punctuation">.</span><span class="token function">QuoRem</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
		<span class="token comment">/* Prepend ASCII character */</span>
		s <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>BITCOIN_BASE58_TABLE<span class="token punctuation">[</span>r<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> s
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> s
<span class="token punctuation">}</span>
</code></pre> 
  <h2><a id="_185"></a>数字签名</h2> 
  <pre><code class="prism language-go"><span class="token comment">/* 对text签名 返回加密结果，结果为数字证书r、s的序列化后拼接，然后用hex转换为string */</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>k GKey<span class="token punctuation">)</span> <span class="token function">Sign</span><span class="token punctuation">(</span>text <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	r<span class="token punctuation">,</span> s<span class="token punctuation">,</span> err <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> k<span class="token punctuation">.</span>privateKey<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	rt<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">MarshalText</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	st<span class="token punctuation">,</span> err <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">MarshalText</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> b bytes<span class="token punctuation">.</span>Buffer
	w <span class="token operator">:=</span> gzip<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> w<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	w<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h2><a id="_219"></a>验证签名</h2> 
  <pre><code class="prism language-go"><span class="token comment">/* 校验文本内容是否与签名一致 使用公钥校验签名和文本内容 */</span>
<span class="token keyword">func</span> <span class="token function">Verify</span><span class="token punctuation">(</span>text <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> signature <span class="token builtin">string</span><span class="token punctuation">,</span> pubKey <span class="token operator">*</span>ecdsa<span class="token punctuation">.</span>PublicKey<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	rint<span class="token punctuation">,</span> sint<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">getSign</span><span class="token punctuation">(</span>signature<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	result <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">Verify</span><span class="token punctuation">(</span>pubKey<span class="token punctuation">,</span> text<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rint<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sint<span class="token punctuation">)</span>
	<span class="token keyword">return</span> result<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 证书分解 通过hex解码，分割成数字证书r，s */</span>
<span class="token keyword">func</span> <span class="token function">getSign</span><span class="token punctuation">(</span>signature <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rint<span class="token punctuation">,</span> sint big<span class="token punctuation">.</span>Int<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	byterun<span class="token punctuation">,</span> err <span class="token operator">:=</span> hex<span class="token punctuation">.</span><span class="token function">DecodeString</span><span class="token punctuation">(</span>signature<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decrypt error,"</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	r<span class="token punctuation">,</span> err <span class="token operator">:=</span> gzip<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span>byterun<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decode error,"</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> r<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	count<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"decode = "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decode read error,"</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	rs <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decode fail"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	err <span class="token operator">=</span> rint<span class="token punctuation">.</span><span class="token function">UnmarshalText</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>rs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decrypt rint fail, "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	err <span class="token operator">=</span> sint<span class="token punctuation">.</span><span class="token function">UnmarshalText</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>rs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"decrypt sint fail, "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h2><a id="_279"></a>运行结果</h2> 
  <pre><code class="prism language-shell">$ go run test.go 
My privateKey is <span class="token keyword">:</span> 00000000323132324153720678C83DFE6126497EF4A8C75CBC9862EEEC77F006
My publickKey is <span class="token keyword">:</span> EF855DD23C7E3462DCA1935EA516573CF44E8C226EC31146D380A9BCC053CE277222BD827B18187152197F5F36B3002812A636615498E40E
1 - Perform SHA-256 hashing on the public key
0EF6B0BCBB3A0434A08EB0190CF5DEE38CF62866BC1F51D9F8EAB71AAC0C0A80
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
2 - Perform RIPEMD-160 hashing on the result of SHA-256
368FE10638FB2890B9C7BC334035F656F0B450FA
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
3 - Add version byte <span class="token keyword">in</span> front of RIPEMD-160 <span class="token function">hash</span> <span class="token punctuation">(</span>0x00 <span class="token keyword">for</span> Main Network<span class="token punctuation">)</span>
00368FE10638FB2890B9C7BC334035F656F0B450FA
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
4 - Perform SHA-256 <span class="token function">hash</span> on the extended PIPEMD-160 result
569F0D58CAB5195D5C84ABBA2FFA3883CC93A2C19BF60FF54E5E7E5565251FA2
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
5 - Perform SHA-256 <span class="token function">hash</span> on the result of the previous SHA-256 <span class="token function">hash</span>
8FEB0E8C808D61D40EC8D9CC17CAB2C12FE1FE841582AEE024A7F6839596CD45
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
6 - Take the first 4 bytes of the second SHA-256 hash. This is the address chechsum
8FEB0E8C
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
7 - Add the 4 checksum bytes from stage 7 at the end of extended PIPEMD-160 <span class="token function">hash</span> from stage 4. This is the 25-byte binary Bitcoin Address.
00368FE10638FB2890B9C7BC334035F656F0B450FA8FEB0E8C
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
8 - Convet the result from a byte string into a base58 string using Base58Check encoding. This is the <span class="token function">most</span> commonly used Bitcoin Address <span class="token function">format</span>
15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
My address is: 15yVrFLFoKvh5H5pjUuwF2CpSD4b2rwRqm
Signature is <span class="token keyword">:</span> 1f8b08000000000000ff04c0c101c0500c01d0817a49888ffd17eb7b4dd18874c185472e94db29bd0c549cde598a07e008c4001b8a97dea7c2c3971adcc9dd3a48ccb16e1cc37a150727d502e36773fb467d3eec0f0000ffff
Verify success
</code></pre> 
  <p><a href="https://github.com/AlexTan-b-z/Bitcoin_address-and-Sign-Verify" rel="nofollow">源码地址</a><br> 转载请注明出处：<a href="https://blog.csdn.net/AlexTan_/article/details/83934075" rel="nofollow">https://blog.csdn.net/AlexTan_/article/details/83934075</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-a47e74522c.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AlexTan_/article/details/83934075,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AlexTan_/article/details/83934075,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
