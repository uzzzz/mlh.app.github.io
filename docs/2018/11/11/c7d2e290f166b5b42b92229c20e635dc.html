<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>简单区块链的实现（带POW挖矿系统） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="简单区块链的实现（带POW挖矿系统）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为作者原创，如需转载，请注明出处 https://blog.csdn.net/weixin_42940826 前言 在IT界，2018最火的热词相必就是区块链了，C++和GO是目前最适合区块链开发的两种语言，所以咱们学GO的肯定得学一点区块链的知识，但是区块链涉及太多密码学，金融学、p2p网络等知识了，从哪里切入呢，今天我们就从用go实现一条带有模拟挖矿系统的简单区块链。 代码分析 三大模块 代码还是比较简单清晰的，主要有三个模块，Block模块、BlockChain模块、POW模块即挖矿模块。 运行流程 首先从定义一个区块开始，一个区块中包含的信息有区块信息，时间戳，前区块哈希值，现区块哈希值，经过挖矿后得到的哈希碰撞值等等。 接着我们开启一个切片用来存放一个个区块，但是第一个区块是比较特殊的，我们称之为创世区块，在真实的比特币中，第一个区块是由创始人中本聪挖矿所得，没有前哈希值，所以这里我们直接将第一个创世区块创建添加到区块切片中。 然后给到一个添加区块的方法，用户添加区块信息后，经过POW挖矿系统才能成功添加到区块链上。 有了大概的运行流程接下来再来看代码就会轻松很多了。 代码 package main import ( &quot;math/big&quot; &quot;bytes&quot; &quot;encoding/binary&quot; &quot;crypto/sha256&quot; &quot;fmt&quot; &quot;time&quot; ) //Block模块 type Block struct { Version uint64 //版本号 MerkelRoot []byte //这是一个默克尔数，这里先默认为空 TimeStamp string //时间戳 Difficulty uint64 //难度值 Nonce uint64 //挖矿所找到的随机数 PrevBlockHash []byte//前区块哈希值 Data []byte //插入的数据 Hash []byte //当前区块哈希值 } //给到一个创建新区块的方法 func newBlock(data,prehash []byte)*Block { block:=Block{ Version:00, MerkelRoot:[]byte{}, TimeStamp:time.Now().Format(&quot;2006-15:04:05&quot;), Difficulty:difficulty, Data:data, PrevBlockHash:prehash, } //需要被挖矿之后才能创建区块，所以调用挖矿函数 pow:=NewPOW(&amp;block) nonce,hash:=pow.Mine() //挖矿结束，得到哈希碰撞值 block.Nonce=nonce block.Hash=hash return &amp;block } //Blockchain模块 const gnnesinfo=&quot;1996年9月2日,一代伟人诞生了&quot; //给到一个区块链结构 type Blockchain struct { blocks []*Block } //将创世区块加入区块链，并返回一条可供操作的区块链 func NewblockChain()*Blockchain { var bc Blockchain block:=newBlock([]byte(gnnesinfo),[]byte{}) bc.blocks=append(bc.blocks,block) return &amp;bc } //给到一个增加区块的方法 func (this *Blockchain)Addblock(data []byte) { lastblockhash:=this.blocks[len(this.blocks)-1].Hash block:=newBlock(data,lastblockhash) this.blocks=append(this.blocks,block) } //遍历，打印所有 func (this *Blockchain)PrintAll() { for i,v:=range this.blocks { fmt.Printf(&quot;=========区块高度%d=========\n&quot;,i) fmt.Printf(&quot;Version : %d\n&quot;, v.Version) fmt.Printf(&quot;PrevBlockHash : %x\n&quot;, v.PrevBlockHash) fmt.Printf(&quot;Hash : %x\n&quot;, v.Hash) fmt.Printf(&quot;MerkleRoot : %x\n&quot;, v.MerkelRoot) fmt.Printf(&quot;TimeStamp : %s\n&quot;, v.TimeStamp) fmt.Printf(&quot;Difficuty : %d\n&quot;, v.Difficulty) fmt.Printf(&quot;Nonce : %d\n&quot;, v.Nonce) fmt.Printf(&quot;Data : %s\n&quot;, v.Data) } } //pow挖矿模块 const difficulty=24 //POW挖矿结构需要两个参数，一个是所需挖矿的区块，另一个是挖矿成功所需目标数字 type ProofOfWork struct { target *big.Int block *Block } //给到一个根据难度值得到哈希碰撞目标值的函数 func Gettargetint()*big.Int { targetint:=big.NewInt(1) targetint.Lsh(targetint,256-difficulty) return targetint } //创建挖矿的方法 func NewPOW(block *Block)*ProofOfWork { var this ProofOfWork this.block=block targetint:=Gettargetint() this.target=targetint return &amp;this } //一个用来将uint64转化为字符切片的小函数，方便接下来的转化 func uint2byte(num uint64)[]byte { var buff bytes.Buffer binary.Write(&amp;buff,binary.BigEndian,&amp;num) return buff.Bytes() } //挖矿的准备工作，将其他字符组合起来之后求其哈希值 func (pow *ProofOfWork)PreparetoMine(nonce uint64)[]byte { info:=[][]byte{ pow.block.PrevBlockHash, pow.block.Data, uint2byte(nonce), uint2byte(pow.block.Version), uint2byte(pow.block.Difficulty), []byte(pow.block.TimeStamp), pow.block.MerkelRoot, } allinfo:=bytes.Join(info,[]byte{}) hash:=sha256.Sum256(allinfo) return hash[:] } //pow挖矿方法,返回两个参数，一个是碰撞成功的数字nonce，另一个是当前区块哈希值 func (pow *ProofOfWork)Mine()(uint64,[]byte) { var nonce uint64 //nonce从0开始穷举，直到出现哈希值小于给到的目标值 var hash []byte for { hash=pow.PreparetoMine(nonce) var hashint big.Int hashint.SetBytes(hash) //对比哈希值是否小于目标值，小于则成功退出 if hashint.Cmp(pow.target)==-1 { break } //不小于则继续穷举 nonce++ } return nonce,hash } //调用 func main() { bc:=NewblockChain() bc.Addblock([]byte(&quot;welcometo&quot;)) bc.Addblock([]byte(&quot;mycsdnblog&quot;)) bc.PrintAll() } 以上就是一个微型的区块链了，虽然看起来很简单，但是对于理解比特币、区块链还是有不少帮助的。 若是感兴趣或者不屑一顾的大牛们可以戳我的githubGO语言实现比特币系统，是这个小区块链的升级版本，并且将持续维护更新，加入了命令行功能、UTXO转账机制，bolt数据库存储、钱包等，更加接近真正的比特币系统 也欢迎各位给我留言，共同学习： ） 阅读更多" />
<meta property="og:description" content="版权声明：本文为作者原创，如需转载，请注明出处 https://blog.csdn.net/weixin_42940826 前言 在IT界，2018最火的热词相必就是区块链了，C++和GO是目前最适合区块链开发的两种语言，所以咱们学GO的肯定得学一点区块链的知识，但是区块链涉及太多密码学，金融学、p2p网络等知识了，从哪里切入呢，今天我们就从用go实现一条带有模拟挖矿系统的简单区块链。 代码分析 三大模块 代码还是比较简单清晰的，主要有三个模块，Block模块、BlockChain模块、POW模块即挖矿模块。 运行流程 首先从定义一个区块开始，一个区块中包含的信息有区块信息，时间戳，前区块哈希值，现区块哈希值，经过挖矿后得到的哈希碰撞值等等。 接着我们开启一个切片用来存放一个个区块，但是第一个区块是比较特殊的，我们称之为创世区块，在真实的比特币中，第一个区块是由创始人中本聪挖矿所得，没有前哈希值，所以这里我们直接将第一个创世区块创建添加到区块切片中。 然后给到一个添加区块的方法，用户添加区块信息后，经过POW挖矿系统才能成功添加到区块链上。 有了大概的运行流程接下来再来看代码就会轻松很多了。 代码 package main import ( &quot;math/big&quot; &quot;bytes&quot; &quot;encoding/binary&quot; &quot;crypto/sha256&quot; &quot;fmt&quot; &quot;time&quot; ) //Block模块 type Block struct { Version uint64 //版本号 MerkelRoot []byte //这是一个默克尔数，这里先默认为空 TimeStamp string //时间戳 Difficulty uint64 //难度值 Nonce uint64 //挖矿所找到的随机数 PrevBlockHash []byte//前区块哈希值 Data []byte //插入的数据 Hash []byte //当前区块哈希值 } //给到一个创建新区块的方法 func newBlock(data,prehash []byte)*Block { block:=Block{ Version:00, MerkelRoot:[]byte{}, TimeStamp:time.Now().Format(&quot;2006-15:04:05&quot;), Difficulty:difficulty, Data:data, PrevBlockHash:prehash, } //需要被挖矿之后才能创建区块，所以调用挖矿函数 pow:=NewPOW(&amp;block) nonce,hash:=pow.Mine() //挖矿结束，得到哈希碰撞值 block.Nonce=nonce block.Hash=hash return &amp;block } //Blockchain模块 const gnnesinfo=&quot;1996年9月2日,一代伟人诞生了&quot; //给到一个区块链结构 type Blockchain struct { blocks []*Block } //将创世区块加入区块链，并返回一条可供操作的区块链 func NewblockChain()*Blockchain { var bc Blockchain block:=newBlock([]byte(gnnesinfo),[]byte{}) bc.blocks=append(bc.blocks,block) return &amp;bc } //给到一个增加区块的方法 func (this *Blockchain)Addblock(data []byte) { lastblockhash:=this.blocks[len(this.blocks)-1].Hash block:=newBlock(data,lastblockhash) this.blocks=append(this.blocks,block) } //遍历，打印所有 func (this *Blockchain)PrintAll() { for i,v:=range this.blocks { fmt.Printf(&quot;=========区块高度%d=========\n&quot;,i) fmt.Printf(&quot;Version : %d\n&quot;, v.Version) fmt.Printf(&quot;PrevBlockHash : %x\n&quot;, v.PrevBlockHash) fmt.Printf(&quot;Hash : %x\n&quot;, v.Hash) fmt.Printf(&quot;MerkleRoot : %x\n&quot;, v.MerkelRoot) fmt.Printf(&quot;TimeStamp : %s\n&quot;, v.TimeStamp) fmt.Printf(&quot;Difficuty : %d\n&quot;, v.Difficulty) fmt.Printf(&quot;Nonce : %d\n&quot;, v.Nonce) fmt.Printf(&quot;Data : %s\n&quot;, v.Data) } } //pow挖矿模块 const difficulty=24 //POW挖矿结构需要两个参数，一个是所需挖矿的区块，另一个是挖矿成功所需目标数字 type ProofOfWork struct { target *big.Int block *Block } //给到一个根据难度值得到哈希碰撞目标值的函数 func Gettargetint()*big.Int { targetint:=big.NewInt(1) targetint.Lsh(targetint,256-difficulty) return targetint } //创建挖矿的方法 func NewPOW(block *Block)*ProofOfWork { var this ProofOfWork this.block=block targetint:=Gettargetint() this.target=targetint return &amp;this } //一个用来将uint64转化为字符切片的小函数，方便接下来的转化 func uint2byte(num uint64)[]byte { var buff bytes.Buffer binary.Write(&amp;buff,binary.BigEndian,&amp;num) return buff.Bytes() } //挖矿的准备工作，将其他字符组合起来之后求其哈希值 func (pow *ProofOfWork)PreparetoMine(nonce uint64)[]byte { info:=[][]byte{ pow.block.PrevBlockHash, pow.block.Data, uint2byte(nonce), uint2byte(pow.block.Version), uint2byte(pow.block.Difficulty), []byte(pow.block.TimeStamp), pow.block.MerkelRoot, } allinfo:=bytes.Join(info,[]byte{}) hash:=sha256.Sum256(allinfo) return hash[:] } //pow挖矿方法,返回两个参数，一个是碰撞成功的数字nonce，另一个是当前区块哈希值 func (pow *ProofOfWork)Mine()(uint64,[]byte) { var nonce uint64 //nonce从0开始穷举，直到出现哈希值小于给到的目标值 var hash []byte for { hash=pow.PreparetoMine(nonce) var hashint big.Int hashint.SetBytes(hash) //对比哈希值是否小于目标值，小于则成功退出 if hashint.Cmp(pow.target)==-1 { break } //不小于则继续穷举 nonce++ } return nonce,hash } //调用 func main() { bc:=NewblockChain() bc.Addblock([]byte(&quot;welcometo&quot;)) bc.Addblock([]byte(&quot;mycsdnblog&quot;)) bc.PrintAll() } 以上就是一个微型的区块链了，虽然看起来很简单，但是对于理解比特币、区块链还是有不少帮助的。 若是感兴趣或者不屑一顾的大牛们可以戳我的githubGO语言实现比特币系统，是这个小区块链的升级版本，并且将持续维护更新，加入了命令行功能、UTXO转账机制，bolt数据库存储、钱包等，更加接近真正的比特币系统 也欢迎各位给我留言，共同学习： ） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/11/11/c7d2e290f166b5b42b92229c20e635dc.html" />
<meta property="og:url" content="https://mlh.app/2018/11/11/c7d2e290f166b5b42b92229c20e635dc.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为作者原创，如需转载，请注明出处 https://blog.csdn.net/weixin_42940826 前言 在IT界，2018最火的热词相必就是区块链了，C++和GO是目前最适合区块链开发的两种语言，所以咱们学GO的肯定得学一点区块链的知识，但是区块链涉及太多密码学，金融学、p2p网络等知识了，从哪里切入呢，今天我们就从用go实现一条带有模拟挖矿系统的简单区块链。 代码分析 三大模块 代码还是比较简单清晰的，主要有三个模块，Block模块、BlockChain模块、POW模块即挖矿模块。 运行流程 首先从定义一个区块开始，一个区块中包含的信息有区块信息，时间戳，前区块哈希值，现区块哈希值，经过挖矿后得到的哈希碰撞值等等。 接着我们开启一个切片用来存放一个个区块，但是第一个区块是比较特殊的，我们称之为创世区块，在真实的比特币中，第一个区块是由创始人中本聪挖矿所得，没有前哈希值，所以这里我们直接将第一个创世区块创建添加到区块切片中。 然后给到一个添加区块的方法，用户添加区块信息后，经过POW挖矿系统才能成功添加到区块链上。 有了大概的运行流程接下来再来看代码就会轻松很多了。 代码 package main import ( &quot;math/big&quot; &quot;bytes&quot; &quot;encoding/binary&quot; &quot;crypto/sha256&quot; &quot;fmt&quot; &quot;time&quot; ) //Block模块 type Block struct { Version uint64 //版本号 MerkelRoot []byte //这是一个默克尔数，这里先默认为空 TimeStamp string //时间戳 Difficulty uint64 //难度值 Nonce uint64 //挖矿所找到的随机数 PrevBlockHash []byte//前区块哈希值 Data []byte //插入的数据 Hash []byte //当前区块哈希值 } //给到一个创建新区块的方法 func newBlock(data,prehash []byte)*Block { block:=Block{ Version:00, MerkelRoot:[]byte{}, TimeStamp:time.Now().Format(&quot;2006-15:04:05&quot;), Difficulty:difficulty, Data:data, PrevBlockHash:prehash, } //需要被挖矿之后才能创建区块，所以调用挖矿函数 pow:=NewPOW(&amp;block) nonce,hash:=pow.Mine() //挖矿结束，得到哈希碰撞值 block.Nonce=nonce block.Hash=hash return &amp;block } //Blockchain模块 const gnnesinfo=&quot;1996年9月2日,一代伟人诞生了&quot; //给到一个区块链结构 type Blockchain struct { blocks []*Block } //将创世区块加入区块链，并返回一条可供操作的区块链 func NewblockChain()*Blockchain { var bc Blockchain block:=newBlock([]byte(gnnesinfo),[]byte{}) bc.blocks=append(bc.blocks,block) return &amp;bc } //给到一个增加区块的方法 func (this *Blockchain)Addblock(data []byte) { lastblockhash:=this.blocks[len(this.blocks)-1].Hash block:=newBlock(data,lastblockhash) this.blocks=append(this.blocks,block) } //遍历，打印所有 func (this *Blockchain)PrintAll() { for i,v:=range this.blocks { fmt.Printf(&quot;=========区块高度%d=========\\n&quot;,i) fmt.Printf(&quot;Version : %d\\n&quot;, v.Version) fmt.Printf(&quot;PrevBlockHash : %x\\n&quot;, v.PrevBlockHash) fmt.Printf(&quot;Hash : %x\\n&quot;, v.Hash) fmt.Printf(&quot;MerkleRoot : %x\\n&quot;, v.MerkelRoot) fmt.Printf(&quot;TimeStamp : %s\\n&quot;, v.TimeStamp) fmt.Printf(&quot;Difficuty : %d\\n&quot;, v.Difficulty) fmt.Printf(&quot;Nonce : %d\\n&quot;, v.Nonce) fmt.Printf(&quot;Data : %s\\n&quot;, v.Data) } } //pow挖矿模块 const difficulty=24 //POW挖矿结构需要两个参数，一个是所需挖矿的区块，另一个是挖矿成功所需目标数字 type ProofOfWork struct { target *big.Int block *Block } //给到一个根据难度值得到哈希碰撞目标值的函数 func Gettargetint()*big.Int { targetint:=big.NewInt(1) targetint.Lsh(targetint,256-difficulty) return targetint } //创建挖矿的方法 func NewPOW(block *Block)*ProofOfWork { var this ProofOfWork this.block=block targetint:=Gettargetint() this.target=targetint return &amp;this } //一个用来将uint64转化为字符切片的小函数，方便接下来的转化 func uint2byte(num uint64)[]byte { var buff bytes.Buffer binary.Write(&amp;buff,binary.BigEndian,&amp;num) return buff.Bytes() } //挖矿的准备工作，将其他字符组合起来之后求其哈希值 func (pow *ProofOfWork)PreparetoMine(nonce uint64)[]byte { info:=[][]byte{ pow.block.PrevBlockHash, pow.block.Data, uint2byte(nonce), uint2byte(pow.block.Version), uint2byte(pow.block.Difficulty), []byte(pow.block.TimeStamp), pow.block.MerkelRoot, } allinfo:=bytes.Join(info,[]byte{}) hash:=sha256.Sum256(allinfo) return hash[:] } //pow挖矿方法,返回两个参数，一个是碰撞成功的数字nonce，另一个是当前区块哈希值 func (pow *ProofOfWork)Mine()(uint64,[]byte) { var nonce uint64 //nonce从0开始穷举，直到出现哈希值小于给到的目标值 var hash []byte for { hash=pow.PreparetoMine(nonce) var hashint big.Int hashint.SetBytes(hash) //对比哈希值是否小于目标值，小于则成功退出 if hashint.Cmp(pow.target)==-1 { break } //不小于则继续穷举 nonce++ } return nonce,hash } //调用 func main() { bc:=NewblockChain() bc.Addblock([]byte(&quot;welcometo&quot;)) bc.Addblock([]byte(&quot;mycsdnblog&quot;)) bc.PrintAll() } 以上就是一个微型的区块链了，虽然看起来很简单，但是对于理解比特币、区块链还是有不少帮助的。 若是感兴趣或者不屑一顾的大牛们可以戳我的githubGO语言实现比特币系统，是这个小区块链的升级版本，并且将持续维护更新，加入了命令行功能、UTXO转账机制，bolt数据库存储、钱包等，更加接近真正的比特币系统 也欢迎各位给我留言，共同学习： ） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/11/11/c7d2e290f166b5b42b92229c20e635dc.html","headline":"简单区块链的实现（带POW挖矿系统）","dateModified":"2018-11-11T00:00:00+08:00","datePublished":"2018-11-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/11/11/c7d2e290f166b5b42b92229c20e635dc.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1><golang>简单区块链的实现（带POW挖矿系统）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <blockquote> 
   <p>版权声明：本文为作者原创，如需转载，请注明出处<br> <a href="https://blog.csdn.net/weixin_42940826" rel="nofollow">https://blog.csdn.net/weixin_42940826</a></p> 
  </blockquote> 
  <h2><a id="_3"></a>前言</h2> 
  <p>在IT界，2018最火的热词相必就是区块链了，C++和GO是目前最适合区块链开发的两种语言，所以咱们学GO的肯定得学一点区块链的知识，但是区块链涉及太多密码学，金融学、p2p网络等知识了，从哪里切入呢，今天我们就从用go实现一条带有模拟挖矿系统的简单区块链。</p> 
  <hr> 
  <h2><a id="_6"></a>代码分析</h2> 
  <p><strong>三大模块</strong><br> 代码还是比较简单清晰的，主要有三个模块，<strong>Block模块、BlockChain模块、POW模块</strong>即挖矿模块。<br> <strong>运行流程</strong></p> 
  <ul> 
   <li>首先从定义一个区块开始，一个区块中包含的信息有区块信息，时间戳，前区块哈希值，现区块哈希值，经过挖矿后得到的哈希碰撞值等等。</li> 
   <li>接着我们开启一个切片用来存放一个个区块，但是第一个区块是比较特殊的，我们称之为创世区块，在真实的比特币中，第一个区块是由创始人中本聪挖矿所得，没有前哈希值，所以这里我们直接将第一个创世区块创建添加到区块切片中。</li> 
   <li>然后给到一个添加区块的方法，用户添加区块信息后，经过POW挖矿系统才能成功添加到区块链上。</li> 
  </ul> 
  <p><strong>有了大概的运行流程接下来再来看代码就会轻松很多了。</strong></p> 
  <hr> 
  <h2><a id="_16"></a>代码</h2> 
  <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"math/big"</span>
	<span class="token string">"bytes"</span>
	<span class="token string">"encoding/binary"</span>
	<span class="token string">"crypto/sha256"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token comment">//Block模块</span>
<span class="token keyword">type</span> Block <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Version <span class="token builtin">uint64</span>		<span class="token comment">//版本号</span>
	MerkelRoot <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>	<span class="token comment">//这是一个默克尔数，这里先默认为空</span>
	TimeStamp <span class="token builtin">string</span> 	<span class="token comment">//时间戳</span>
	Difficulty <span class="token builtin">uint64</span>	<span class="token comment">//难度值</span>
	Nonce <span class="token builtin">uint64</span>		<span class="token comment">//挖矿所找到的随机数</span>
	PrevBlockHash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token comment">//前区块哈希值</span>
	Data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>			<span class="token comment">//插入的数据</span>
	Hash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>			<span class="token comment">//当前区块哈希值</span>
<span class="token punctuation">}</span>

<span class="token comment">//给到一个创建新区块的方法</span>
<span class="token keyword">func</span> <span class="token function">newBlock</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>prehash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token operator">*</span>Block  <span class="token punctuation">{</span>
	block<span class="token operator">:=</span>Block<span class="token punctuation">{</span>
		Version<span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">,</span>
		MerkelRoot<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		TimeStamp<span class="token punctuation">:</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		Difficulty<span class="token punctuation">:</span>difficulty<span class="token punctuation">,</span>
		Data<span class="token punctuation">:</span>data<span class="token punctuation">,</span>
		PrevBlockHash<span class="token punctuation">:</span>prehash<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//需要被挖矿之后才能创建区块，所以调用挖矿函数</span>
	pow<span class="token operator">:=</span><span class="token function">NewPOW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
	nonce<span class="token punctuation">,</span>hash<span class="token operator">:=</span>pow<span class="token punctuation">.</span><span class="token function">Mine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//挖矿结束，得到哈希碰撞值</span>
	block<span class="token punctuation">.</span>Nonce<span class="token operator">=</span>nonce
	block<span class="token punctuation">.</span>Hash<span class="token operator">=</span>hash
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>block
<span class="token punctuation">}</span>

<span class="token comment">//Blockchain模块</span>
<span class="token keyword">const</span> gnnesinfo<span class="token operator">=</span><span class="token string">"1996年9月2日,一代伟人诞生了"</span> 

<span class="token comment">//给到一个区块链结构</span>
<span class="token keyword">type</span> Blockchain <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	blocks <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Block
<span class="token punctuation">}</span>
<span class="token comment">//将创世区块加入区块链，并返回一条可供操作的区块链</span>
<span class="token keyword">func</span> <span class="token function">NewblockChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>Blockchain  <span class="token punctuation">{</span>
	<span class="token keyword">var</span> bc Blockchain
	block<span class="token operator">:=</span><span class="token function">newBlock</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>gnnesinfo<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	bc<span class="token punctuation">.</span>blocks<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>bc<span class="token punctuation">.</span>blocks<span class="token punctuation">,</span>block<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>bc
<span class="token punctuation">}</span>

<span class="token comment">//给到一个增加区块的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span><span class="token function">Addblock</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
		lastblockhash<span class="token operator">:=</span>this<span class="token punctuation">.</span>blocks<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>blocks<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Hash
		block<span class="token operator">:=</span><span class="token function">newBlock</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>lastblockhash<span class="token punctuation">)</span>
		this<span class="token punctuation">.</span>blocks<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>blocks<span class="token punctuation">,</span>block<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//遍历，打印所有</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span><span class="token function">PrintAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span>v<span class="token operator">:=</span><span class="token keyword">range</span> this<span class="token punctuation">.</span>blocks <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"=========区块高度%d=========\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Version : %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Version<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"PrevBlockHash : %x\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>PrevBlockHash<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hash : %x\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"MerkleRoot : %x\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>MerkelRoot<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"TimeStamp : %s\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Difficuty : %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Difficulty<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Nonce : %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Nonce<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Data : %s\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//pow挖矿模块</span>
<span class="token keyword">const</span> difficulty<span class="token operator">=</span><span class="token number">24</span>

<span class="token comment">//POW挖矿结构需要两个参数，一个是所需挖矿的区块，另一个是挖矿成功所需目标数字</span>
<span class="token keyword">type</span> ProofOfWork <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	target <span class="token operator">*</span>big<span class="token punctuation">.</span>Int
	block <span class="token operator">*</span>Block
<span class="token punctuation">}</span>

<span class="token comment">//给到一个根据难度值得到哈希碰撞目标值的函数</span>
<span class="token keyword">func</span> <span class="token function">Gettargetint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int  <span class="token punctuation">{</span>
	targetint<span class="token operator">:=</span>big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	targetint<span class="token punctuation">.</span><span class="token function">Lsh</span><span class="token punctuation">(</span>targetint<span class="token punctuation">,</span><span class="token number">256</span><span class="token operator">-</span>difficulty<span class="token punctuation">)</span>
	<span class="token keyword">return</span> targetint
<span class="token punctuation">}</span>

<span class="token comment">//创建挖矿的方法</span>
<span class="token keyword">func</span> <span class="token function">NewPOW</span><span class="token punctuation">(</span>block <span class="token operator">*</span>Block<span class="token punctuation">)</span><span class="token operator">*</span>ProofOfWork  <span class="token punctuation">{</span>
	<span class="token keyword">var</span> this ProofOfWork
	this<span class="token punctuation">.</span>block<span class="token operator">=</span>block
	targetint<span class="token operator">:=</span><span class="token function">Gettargetint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	this<span class="token punctuation">.</span>target<span class="token operator">=</span>targetint
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>this
<span class="token punctuation">}</span>
<span class="token comment">//一个用来将uint64转化为字符切片的小函数，方便接下来的转化</span>
<span class="token keyword">func</span> <span class="token function">uint2byte</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>  <span class="token punctuation">{</span>
	<span class="token keyword">var</span> buff bytes<span class="token punctuation">.</span>Buffer
	binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buff<span class="token punctuation">,</span>binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>
	<span class="token keyword">return</span> buff<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//挖矿的准备工作，将其他字符组合起来之后求其哈希值</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pow <span class="token operator">*</span>ProofOfWork<span class="token punctuation">)</span><span class="token function">PreparetoMine</span><span class="token punctuation">(</span>nonce <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	info<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span>
		pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>PrevBlockHash<span class="token punctuation">,</span>
		pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>Data<span class="token punctuation">,</span>
		<span class="token function">uint2byte</span><span class="token punctuation">(</span>nonce<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token function">uint2byte</span><span class="token punctuation">(</span>pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>Version<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token function">uint2byte</span><span class="token punctuation">(</span>pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>Difficulty<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">)</span><span class="token punctuation">,</span>
		pow<span class="token punctuation">.</span>block<span class="token punctuation">.</span>MerkelRoot<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	allinfo<span class="token operator">:=</span>bytes<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	hash<span class="token operator">:=</span>sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span>allinfo<span class="token punctuation">)</span>
	<span class="token keyword">return</span> hash<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">//pow挖矿方法,返回两个参数，一个是碰撞成功的数字nonce，另一个是当前区块哈希值</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pow <span class="token operator">*</span>ProofOfWork<span class="token punctuation">)</span><span class="token function">Mine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">uint64</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token keyword">var</span> nonce <span class="token builtin">uint64</span>
	<span class="token comment">//nonce从0开始穷举，直到出现哈希值小于给到的目标值</span>
	<span class="token keyword">var</span> hash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	<span class="token keyword">for</span>  <span class="token punctuation">{</span>
		hash<span class="token operator">=</span>pow<span class="token punctuation">.</span><span class="token function">PreparetoMine</span><span class="token punctuation">(</span>nonce<span class="token punctuation">)</span>
		<span class="token keyword">var</span> hashint big<span class="token punctuation">.</span>Int
		hashint<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
		<span class="token comment">//对比哈希值是否小于目标值，小于则成功退出</span>
		<span class="token keyword">if</span> hashint<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>pow<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//不小于则继续穷举</span>
		nonce<span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> nonce<span class="token punctuation">,</span>hash
<span class="token punctuation">}</span>

<span class="token comment">//调用</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
bc<span class="token operator">:=</span><span class="token function">NewblockChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
bc<span class="token punctuation">.</span><span class="token function">Addblock</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"welcometo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
bc<span class="token punctuation">.</span><span class="token function">Addblock</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"mycsdnblog"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
bc<span class="token punctuation">.</span><span class="token function">PrintAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> 
  <p>以上就是一个微型的区块链了，虽然看起来很简单，但是对于理解比特币、区块链还是有不少帮助的。</p> 
  <hr> 
  <p><strong>若是感兴趣或者不屑一顾的大牛们可以戳我的github<a href="https://github.com/CNbluer/GO_BTC" rel="nofollow">GO语言实现比特币系统</a>，是这个小区块链的升级版本，并且将持续维护更新，加入了命令行功能、UTXO转账机制，bolt数据库存储、钱包等，更加接近真正的比特币系统</strong></p> 
  <p>也欢迎各位给我留言，共同学习： ）</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-a47e74522c.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_42940826/article/details/83934629,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_42940826/article/details/83934629,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
