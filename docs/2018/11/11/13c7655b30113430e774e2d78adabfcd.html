<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>精通比特币-第4章 密钥 地址 钱包 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="精通比特币-第4章 密钥 地址 钱包" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="分享一下我老师大神的人工智能教程！零基础，通俗易懂！http://blog.csdn.net/jiangjunshow 也欢迎大家转载本篇文章。分享知识，造福人民，实现我们中华民族伟大复兴！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 简介 比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需区块链或网络连接。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。 每笔比特币交易都需要一个有效的签名才会被存储在区块链。只有有效的数字密钥才能产生有效的数字签名，因此拥有比特币的密钥副本就拥有了该帐户的比特币控制权。密钥是成对出现的，由一个私钥和一个公钥所组成。公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们被存储在钱包文件内，由比特币钱包软件进行管理。 在比特币交易的支付环节，收件人的公钥是通过其数字指纹表示的，称为比特币地址，就像支票上的支付对象的名字（即“收款方”）。一般情况下，比特币地址由一个公钥生成并对应于这个公钥。然而，并非所有比特币地址都是公钥；他们也可以代表其他支付对象，譬如脚本，我们将在本章后面提及。这样一来，比特币地址把收款方抽象起来了，使得交易的目的地更灵活，就像支票一样：这个支付工具可支付到个人账户、公司账户，进行账单支付或现金支付。比特币地址是用户经常看到的密钥的唯一代表，他们只需要把比特币地址告诉其他人即可。 在本章中，我们将介绍钱包，也就是密钥所在之处。我们将了解密钥如何被产生、存储和管理。我们将回顾私钥和公钥、地址和脚本地址的各种编码格式。最后，我们将讲解密钥的特殊用途：生成签名、证明所有权以及创造比特币靓号地址和纸钱包。 4.1.1 公钥加密和加密货币 公钥加密发明于20世纪70年代。它是计算机和信息安全的数学基础。 自从公钥加密被发明之后，一些合适的数学函数被提出，譬如：素数幂和椭圆曲线乘法。这些数学函数都是不可逆的，就是说很容易向一个方向计算，但不可以向相反方向倒推。基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。比特币正是使用椭圆曲线乘法作为其公钥加密的基础算法。 在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名。 公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 大多数比特币钱包工具为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到，所以只存储私钥也是可以的。 4.1.2 私钥和公钥 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。在本节中，我们将从生成私钥开始，讲述如何使用椭圆曲线运算将私钥生成公钥，并最终由公钥生成比特币地址。私钥、公钥和比特币地址之间的关系如下图所示。 4.1.3 私钥 私钥就是一个随机选出的数字而已。一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。在比特币交易中，私钥用于生成支付比特币所必需的签名以证明资金的所有权。私钥必须始终保持机密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就难以复原，其所保护的比特币也将永远丢失。 比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。 从一个随机数生成私钥 生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2256之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。通常情况下，操作系统随机数生成器由人工的随机源进行初始化，也可能需要通过几秒钟内不停晃动鼠标等方式进行初始化。对于真正的偏执狂，可以使用掷骰子的方法，并用铅笔和纸记录。 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158*1077，略小于2256），并由比特币所使用的椭圆曲线的阶所定义（见4.1.5&nbsp;椭圆曲线密码学解释）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。 本书强烈建议读者不要使用自己写的代码或使用编程语言内建的简易随机数生成器来获得一个随机数。我们建议读者使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。使用随机数发生器的程序库时，需仔细研读其文档，以确保它是加密安全的。对CSPRNG的正确实现是密钥安全性的关键所在。 以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）： 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD 比特币私钥空间的大小是2256，这是一个非常大的数字。用十进制表示的话，大约是1077，而可见宇宙被估计只含有1080个原子。 要使用比特币核心客户端生成一个新的密钥（参见第3章），可使用getnewaddress命令。出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用dumpprivkey命令。dumpprivkey命令会把私钥以Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet&nbsp;Import Format），在“私钥的格式”一节有详细讲解。下面给出了使用这两个命令生成和显示私钥的例子： $ bitcoind getnewaddress1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZyKxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ dumpprivkey命令只是读取钱包里由getnewaddress命令生成的私钥，然后显示出来。bitcoind的并不能从公钥得知私钥。除非密钥对都存储在钱包里，dumpprivkey命令才有效。 dumpprivkey命令无法从公钥得到对应的私钥，因为这是不可能的。这个命令只是提取钱包中已有的私钥，也就是提取由getnewaddress命令生成的私钥。 你也可以使用命令行sx工具 （参见“3.3.1 Libbitcoin和sx Tools”）用newkey命令来生成并显示私钥: $ sx newkey5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 4.1.4 公钥 通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G&nbsp;。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线加密学。 4.1.5 椭圆曲线密码学解释 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 上图是一个椭圆曲线的示例，类似于比特币所用的曲线。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院（NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2&nbsp;= (x3&nbsp;+ 7)} over (Fp) 或 y2&nbsp;mod&nbsp;p&nbsp;= (x3&nbsp;+ 7) mod&nbsp;p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2256&nbsp;– 232&nbsp;– 29&nbsp;– 28&nbsp;– 27&nbsp;–&nbsp;26&nbsp;– 24&nbsp;– 1，这是一个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散点图，因此很难画图表示。不过，其中的数学原理与实数范围的椭圆曲线相似。作为一个例子，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。而secp256k1的比特币椭圆曲线可以被想象成一个极大的网格上一系列更为复杂的散点。 图为：椭圆曲线密码学F(p)上的椭圆曲线，其中p = 17 下面举一个例子，这是secp256k1曲线上的点P，其坐标为(x，y)。可以使用Python对其检验： P =（55066263022277343669578718895168534326250603453777594175500187360389116729240,32670510020758816978083085130507043184471273380659243275938904335757337482424）Python 3.4.0 (default, Mar 30 2014, 19:23:13)[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663&gt;&gt;&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240&gt;&gt;&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424&gt;&gt;&gt; (x ** 3 + 7 - y**2) % p0 在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。 还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3&nbsp;= P1&nbsp;+&nbsp;P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线上的一点相交。此点记为 P3&#39;=(x，y)。然后，在x轴做映射获得 P3=(x，-y)。 下面是几个可以解释“无穷远点”之存在需要的特殊情况。 若 P1和 P2是同一点，P1和P2间的连线则为点P1&nbsp;的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微分求得。即使限制曲线点为两个整数坐标也可求得斜率！ 在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3&nbsp;= “无穷远点”。 若P1就是“无穷远点”，那么其和 P1&nbsp;+ P2= P2。类似地，当P2是无穷远点，则P1+ P2&nbsp;= P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)C = A(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 至此，我们已经定义了椭圆加法，为扩展加法下面我们对乘法进行标准定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，k被有时被混淆而称为“指数”。 4.1.6 生成公钥 以一个随机生成的私钥k为起点，我们将其与曲线上已定义的 生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的： {K = k * G} 其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生）与任何人共享而不会泄露私钥（k）的原因。 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G 公钥K 被定义为一个点 K = (x, y)： K = (x, y)其中，x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 上图显示了在曲线上得到 G、2G、4G 的几何操作。 大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul() 函数，可计算得到公钥。 4.2 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。下面是一个比特币地址的例子： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人，也就是我们要写入收款人一栏的内容。一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。支票不需要指定一个特定的账户，而是用一个普通的名字作为收款人，这使它成为一种相当灵活的支付工具。与此类似，比特币地址的使用也使比特币交易变得很灵活。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其它东西，比如会在132页的“P2SH (Pay-to-Script-Hash)”一节讲到的付款脚本。现在，让我们来看一个简单的例子，由公钥生成比特币地址。 比特币地址可由公钥经过单向的加密哈希算法得到。哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，特别是SHA256和RIPEMD160。 以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160比特（20字节）的数字： A = RIPEMD160(SHA256(K)) 公式中，K是公钥，A是生成的比特币地址。 比特币地址与公钥不同。比特币地址是由公钥经过单向的哈希函数生成的。 通常用户见到的比特币地址是经过“Base58Check”编码的（参见72页“Base58和Base58Check编码”一节），这种编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。下一节中我们会详细解释Base58Check的编码机制，以及它产生的结果。下图描述了如何从公钥生成比特币地址。 4.2.1 Base58和Base58Check编码 为了更简洁方便地表示长串的数字，许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法。例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。一个同样的数字，它的十六进制表示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。Base64通常用于编码邮件中的附件。Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。 例4-1 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。 为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。 接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法： checksum = SHA256(SHA256(prefix+data)) 在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为校验码。校验码会添加到数据之后。 结果由三部分组成：前缀、数据和校验码。这个结果采用之前描述的Base58字母表编码。下图描述了Base58Check编码的过程。 Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式 在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。表4-1展示了一些版本前缀和他们对应的Base58格式。 表4-1 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。例4-2的C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。代码中使用“3.3&nbsp;其他客户端、资料库、工具包&nbsp;”一节中介绍的libbitcoin library来实现某些辅助功能。 例4-2 从私钥产生一个Base58Check格式编码的比特币地址 #include &lt;bitcoin/bitcoin.hpp&gt;int main() {&nbsp;&nbsp;&nbsp; // Private secret key.&nbsp;&nbsp;&nbsp; bc::ec_secret secret = bc::decode_hash(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776&quot;);&nbsp;&nbsp;&nbsp; // Get public key.&nbsp;&nbsp;&nbsp; bc::ec_point public_key = bc::secret_to_public_key(secret);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Public key: &quot; &lt;&lt; bc::encode_hex(public_key) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; // Create Bitcoin address.&nbsp;&nbsp;&nbsp; // Normally you can use:&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::payment_address payaddr;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::set_public_key(payaddr, public_key);&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; const std::string address = payaddr.encoded();&nbsp;&nbsp;&nbsp; // Compute hash of public key for P2PKH address.&nbsp;&nbsp;&nbsp; const bc::short_hash hash = bc::bitcoin_short_hash(public_key);&nbsp;&nbsp;&nbsp; bc::data_chunk unencoded_address; // Reserve 25 bytes&nbsp;&nbsp;&nbsp; // [ version:1 ]&nbsp;&nbsp;&nbsp; // [ hash:20 ]&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; [ checksum:4 ]&nbsp;&nbsp;&nbsp; unencoded_address.reserve(25);&nbsp;&nbsp;&nbsp; // Version byte, 0 is normal BTC address (P2PKH).&nbsp;&nbsp;&nbsp;&nbsp; unencoded_address.push_back(0);&nbsp;&nbsp;&nbsp; // Hash data&nbsp;&nbsp;&nbsp; bc::extend_data(unencoded_address, hash);&nbsp;&nbsp;&nbsp; // Checksum is computed by hashing data, and adding 4 bytes from hash. bc::append_checksum(unencoded_address);&nbsp;&nbsp;&nbsp; // Finally we must encode the result in Bitcoin&#39;s base58 encoding assert(unencoded_address.size() == 25);&nbsp;&nbsp;&nbsp; const std::string address = bc::encode_base58(unencoded_address);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; return 0; } 正如编译并运行addr代码中展示的，由于代码使用预定义的私钥，所以每次运行都会产生相同的比特币地址。如例4-3所示。 例4-3 编译并运行addr代码 # Compile the addr.cpp code$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)# Run the addr executable$ ./addrPublic key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK 4.2.2 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。 表4-2 私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 表4-3展示了用这三种格式所生成的私钥。 表4-3 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 将Base58Check编码解码为十六进制 sx工具包（参见“3.3.1 Libbitcoin和sx Tools”）可用来编写一些操作比特币密钥、地址及交易的shell脚本和命令行“管道”。你也可以使用sx工具从命令行对Base58Check格式进行解码。 我们使用的命令是base58check-decode： $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 所得结果是十六进制的密钥，紧接着是钱包导入格式（Wallet Import Format,WIF）的版本前缀128。 将十六进制转换为Base58Check编码 要转换成Base58Check编码（和之前的命令正好相反），我们需提供十六进制的私钥和钱包导入格式（Wallet Import Format，WIF）的版本号前缀128： $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 要将压缩格式的私钥编码为Base58Check（参见“压缩格式私钥”一节），我们需在十六进制私钥的后面添加后缀01，然后使用跟上面一样的方法： $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 生成的WIF压缩格式的私钥以字母“K”开头，用以表明被编码的私钥有一个后缀“01”，且该私钥只能被用于生成压缩格式的公钥（参见“压缩格式公钥”一节）。 公钥的格式 公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。 我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 下面是由前文中的私钥所生成的公钥，其坐标x和y如下： x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 下面是同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y： K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 压缩格式公钥 引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。 正如我们在“4.1.4 公钥”一节所见，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2mod&nbsp;p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。 未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲线加密的公式的左边是y2&nbsp;，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。下图阐释了公钥压缩： 下面是前述章节所生成的公钥，使用了264比特（66个十六进制数字）的压缩格式公钥格式，其中前缀03表示y坐标是一个奇数： K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 这个压缩格式公钥对应着同样的一个私钥，这意味它是由同样的私钥所生成。但是压缩格式公钥和非压缩格式公钥差别很大。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。 压缩格式公钥渐渐成为了各种不同的比特币客户端的默认格式，它可以大大减少交易所需的字节数，同时也让存储区块链所需的磁盘空间变小。然而，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。 为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。我们将在下一节详细解释这种机制是如何工作的。 压缩格式私钥 实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。 要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。 如果一个比特币钱包实现了压缩格式公钥，那么它将会在所有交易中使用该压格式缩公钥。钱包中的私钥将会被用来生成压缩格式公钥，压缩格式公钥然后被用来生成交易中的比特币地址。当从一个实现了压缩格式公钥的比特币钱包导出私钥时，钱包导入格式（WIF）将会被修改为WIF压缩格式，该格式将会在私钥的后面附加一个字节大小的后缀01。最终的Base58Check编码格式的私钥被称作WIF（“压缩”）私钥，以字母“K”或“L”开头。而以“5”开头的是从较老的钱包中以WIF（非压缩）格式导出的私钥。 表4-4展示了同样的私钥使用不同的WIF和WIF压缩格式编码。 表4-4 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ “压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。 4.3 用Python实现密钥和比特币地址 最全面的比特币Python库是 Vitalik Buterin写的&nbsp;pybitcointools。在例4-4中，我们使用pybitcointools库（导入为“bitcoin”）来生成和显示不同格式的密钥和比特币地址。 例4-4 使用pybitcointools库的密钥和比特币地址的生成和格式化过 import bitcoin# Generate a random private keyvalid_private_key = False while not valid_private_key:&nbsp;&nbsp;&nbsp; private_key = bitcoin.random_key()&nbsp;&nbsp;&nbsp; decoded_private_key = bitcoin.decode_privkey(private_key, &#39;hex&#39;)&nbsp;&nbsp;&nbsp; valid_private_key =&nbsp; 0 &lt; decoded_private_key &lt; bitcoin.Nprint &quot;Private Key (hex) is: &quot;, private_keyprint &quot;Private Key (decimal) is: &quot;, decoded_private_key# Convert private key to WIF formatwif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, &#39;wif&#39;)print &quot;Private Key (WIF) is: &quot;, wif_encoded_private_key# Add suffix &quot;01&quot; to indicate a compressed private keycompressed_private_key = private_key + &#39;01&#39;print &quot;Private Key Compressed (hex) is: &quot;, compressed_private_key# Generate a WIF format from the compressed private key (WIF-compressed)wif_compressed_private_key = bitcoin.encode_privkey(&nbsp;&nbsp;&nbsp; bitcoin.decode_privkey(compressed_private_key, &#39;hex&#39;), &#39;wif&#39;)print &quot;Private Key (WIF-Compressed) is: &quot;, wif_compressed_private_key# Multiply the EC generator point G with the private key to get a public key pointpublic_key = bitcoin.base10_multiply(bitcoin.G, decoded_private_key) print &quot;Public Key (x,y) coordinates is:&quot;, public_key# Encode as hex, prefix 04hex_encoded_public_key = bitcoin.encode_pubkey(public_key,&#39;hex&#39;) print &quot;Public Key (hex) is:&quot;, hex_encoded_public_key# Compress public key, adjust prefix depending on whether y is even or odd(public_key_x, public_key_y) = public_key if (public_key_y % 2) == 0:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;02&#39; else:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;03&#39;hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, 16) print &quot;Compressed Public Key (hex) is:&quot;, hex_compressed_public_key# Generate bitcoin address from public keyprint &quot;Bitcoin Address (b58check) is:&quot;, bitcoin.pubkey_to_address(public_key)# Generate compressed bitcoin address from compressed public keyprint &quot;Compressed Bitcoin Address (b58check) is:&quot;, \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitcoin.pubkey_to_address(hex_compressed_public_key) 例4-5显示了上段代码运行结果。 例4-5 运行 key-to-address-ecc-example.py $ python key-to-address-ecc-example.pyPrivate Key (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6Private Key (decimal) is:&nbsp;26563230048437957592232553826663696440606756685920117476832299673293013768870Private Key (WIF) is:&nbsp;5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4KPrivate Key Compressed (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601Private Key (WIF-Compressed) is:&nbsp;KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6SPublic Key (x,y) coordinates is:&nbsp;(41637322786646325214887832269588396900663353932545912953362782457239403430124L,&nbsp;16388935128781238405526710466724741593761085120864331449066658622400339362166L)Public Key (hex) is:&nbsp;045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176Compressed Public Key (hex) is:&nbsp;025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ecBitcoin Address (b58check) is:&nbsp;1thMirt546nngXqyPEz532S8fLwbozud8Compressed Bitcoin Address (b58check) is:&nbsp;14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3 例4-6是另外一个示例，使用的是Python ECDSA库来做椭圆曲线计算而非使用bitcoin的库。 例4-6 使用在比特币密钥中的椭圆曲线算法的脚本 import ecdsaimport randomfrom ecdsa.util import string_to_number, number_to_string# secp256k1, http://www.oid-info.com/get/1.3.132.0.10_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L_b = 0x0000000000000000000000000000000000000000000000000000000000000007L_a = 0x0000000000000000000000000000000000000000000000000000000000000000L_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8Lcurve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)oid_secp256k1 = (1, 3, 132, 0, 10)SECP256k1 = ecdsa.curves.Curve(&quot;SECP256k1&quot;, curve_secp256k1, generator_secp256k1,oid_secp256k1)ec_order = _rcurve = curve_secp256k1generator = generator_secp256k1def random_secret():&nbsp;&nbsp;&nbsp; random_char = lambda: chr(random.randint(0, 255))&nbsp;&nbsp;&nbsp; convert_to_int = lambda array:&nbsp;&nbsp;&nbsp;&nbsp; int(&quot;&quot;.join(array).encode(&quot;hex&quot;), 16) &nbsp;&nbsp;&nbsp; byte_array = [random_char() for i in range(32)]&nbsp;&nbsp;&nbsp; return convert_to_int(byte_array)def get_point_pubkey(point): &nbsp;&nbsp;&nbsp; if point.y() &amp; 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;03&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;02&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)def get_point_pubkey_uncompressed(point): &nbsp;&nbsp;&nbsp; key=&#39;04&#39;+\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.x() + \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.y() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)# Generate a new private key.secret = random_secret() print &quot;Secret: &quot;, secret# Get the public key point.point = secret * generator print &quot;EC point:&quot;, pointprint &quot;BTC public key:&quot;, get_point_pubkey(point).encode(&quot;hex&quot;)# Given the point (x, y) we can create the object using:point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order) assert point1 == point 例4-7显示了运行脚本的结果。 例4-7 安装Python ECDSA库，运行ec_math.py脚本 running the ec_math.py script$ # Install Python PIP package manager$ sudo apt-get install python-pip$ # Install the Python ECDSA library$ sudo pip install ecdsa$ # Run the script$ python ec-math.pySecret:38090835015954358862481132628887443905906204995912378278060168703580660294000EC point:(70048853531867179489857750497606966272382583471322935454624595540007269312627,105262206478686743191060800263479589329920209527285803935736021686045542353380)BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873 4.4 比特币钱包 钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。另外一种制作私钥的途径是 确定性密钥生成。在这里你可以用原先的私钥，通过单向哈希函数来生成每一个新的私钥，并将新生成的密钥按顺序连接。只要你可以重新创建这个序列，你只需要第一个私钥（称作种子、主私钥）来生成它们。在本节中，我们将会检查不同的私钥生成方法及其钱包结构。 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 4.4.1 非确定性（随机）钱包 在最早的一批比特币客户端中，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。举个例子，比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每把钥匙只使用一次。这种类型的钱包有一个昵称“Just a Bunch Of Keys（一堆私钥）”简称JBOK。这种钱包现在正在被确定性钱包替换，因为它们难以管理、备份以及导入。随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一把钥匙都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址通过关联多重交易和对方的地址重复使用会减少隐私。0型非确定性钱包并不是钱包的好选择，尤其是当你不想重复使用地址而创造过多的私钥并且要保存它们。虽然比特币核心客户包含0型钱包，但比特币的核心开发者并不想鼓励大家使用。下图表示包含有松散结构的随机钥匙的集合的非确定性钱包。 4.4.2 确定性（种子）钱包 确定性，或者“种子”钱包包含通过使用单项离散方程而可从公共的种子生成的私钥。种子是随机生成的数字。这个数字也含有比如索引号码或者可生成私钥的“链码”（参见“4.4.4&nbsp;分层确定性钱包（BIP0032/BIP0044）”一节）。在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。 4.4.3 助记码词汇 助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。单词的顺序就是钱包的备份。它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。 助记码被定义在比特币的改进建议39中（参见&quot;附录２ 比特币改进协议[bip0039]”），目前还处于草案状态。需注意的是，BIP0039是一个建议草案而不是标准方案。具体地来说，电子钱包和BIP0039使用不同的标准且对应不同组的词汇。Trezor钱包以及一些其他钱包使用BIP0039，但是BIP0039和电子钱包的运行不兼容。 BIP0039定义助记码和种子的创建过程如下： 1.创造一个128到256位的随机顺序（熵）。&nbsp;2.提出SHA256哈希前几位，就可以创造一个随机序列的校验和。&nbsp;3.把校验和加在随机顺序的后面。&nbsp;4.把顺序分解成11位的不同集合，并用这些集合去和一个预先已经定义的2048个单词字典做对应。&nbsp;5.生成一个12至24个词的助记码。 表4-5表示了熵数据的大小和助记码单词的长度之间的关系。 表4-5 助记码：熵及字段长度 熵（bits） 校验符（bits） 熵＋校验符 字段长 128 4 132 12 160 5 165 15 192 6 198 18 224 7 231 21 256 8 264 24 助记码表示128至256位数。这可以通过使用私钥抻拉函数PBKDF2来导出更长的（512位）的种子。所得的种子可以用来创造一个确定性钱包以及其所派生的所有钥匙。 表4-6和表4-7展示了一些助记码的例子和它所生成的种子。 表4-6 128位熵的助记码以及所产生的种子 负熵输入 (128 bits) 0c1e24e5917779d297e14d45f14e1a1a 助记码 (12 个单词) army van defense carry jealous true garbage claim echo media make crunch 种子 (512 bits) 　　　　　　　　　 3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88 8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf 表4-7 256位熵的助记码以及所产生的种子 负熵输入 (256 bits) 2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c 助记码 (24个单词) cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige 种子 (512 bits) 　　　　　　　　　 3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22 fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343 4.4.4 分层确定性钱包（BIP0032/BIP0044） 确定性钱包被开发成更容易从单个“种子”中生成许多关键的钥匙。最高级的来自确定性钱包的形是通过BIP0032标准生成的 the hierarchical deterministic wallet or HD wallet defined。分层确定性钱包包含从数结构所生成的钥匙。这种母钥匙可以生成子钥匙的序列。这些子钥匙又可以衍生出孙钥匙，以此无穷类推。这个树结构表如下图所示。 如果你想安装运行一个比特币钱包，你需要建造一个符合BIP0032和BIP0044标准的HD钱包。 HD钱包提供了随机（不确定性）钥匙有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门，子公司，具体功能以及会计类别。 HD钱包的第二个好处就是它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。 从种子中创造HD钱包 HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。根种子一般总是被表示为a mnemonic word sequence，正如&quot;4.4.3&nbsp;助记码词汇&quot;一节所表述的，助记码词汇可以让人们更容易地抄写和储存。 创建主密钥以及HD钱包地主链代码的过程如下图所示。 根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造master private key(m) 和 a master chain code的哈希。主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）。链代码可以给从母密钥中创造子密钥的那个方程中引入的熵。 私有子密钥的衍生 分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。 子密钥衍生方程是基于单项哈希方程。这个方程结合了： • 一个母私钥或者公共钥匙（ECDSA未压缩键）&nbsp;• 一个叫做链码（256 bits）的种子&nbsp;• 一个索引号（32 bits） 链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。 这三个项目相结合并散列可以生成子密钥，如下。 母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512方程散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。在图4-11中，我们看到这种这个说明——索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。 图4-11 延长母私钥去创造子私钥 改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。比如子0，子1，子2等等。每一个母密钥可以右20亿个子密钥。 向密码树下一层重复这个过程，每个子密钥可以依次成为母密钥继续创造它自己的子密钥，直到无限代。 使用衍生的子密钥 子私钥不能从非确定性（随机）密钥中被区分出来。因为衍生方程是单向方程，所以子密钥不能被用来发现他们的母密钥。子密钥也不能用来发现他们的相同层级的姊妹密钥。如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。只有母密钥以及链码才能得到所有的子密钥。没有子链码的话，子密钥也不能用来衍生出任何孙密钥。你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。 那子私钥自己可被用做什么呢？它可以用来做公共钥匙和比特币地址。之后它就可以被用那个地址来签署交易和支付任何东西。 子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。 扩展密钥 正如我们之前看到的，密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做extended key。术语“extended key”也被认为是“可扩展的密钥”是因为这种密钥可以用来衍生子密钥。 扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。有两种扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。这个钥匙可以用来扩展子公共钥匙，见“4.1.6&nbsp;生成公钥”。 想象一个扩展密钥作为HD钱包中钥匙树结构的一个分支的根。你可以衍生出这个分支的剩下所有部分。扩展私人钥匙可以创建一个完整的分支而扩展公共钥匙只能够创造一个公共钥匙的分支。 一个扩展钥匙包括一个私钥（或者公共钥匙）以及一个链码。一个扩展密钥可以创造出子密钥并且能创造出在钥匙树结构中的整个分支。分享扩展钥匙就可以访问整个分支。 扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP0032-兼容钱包之间导入导出。扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check-encoded串更长一些。 这是一个在Base58Check中编码的扩展私钥的例子： xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c 这是在Base58Check中编码的对应的扩展公共钥匙： xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9 公共子钥匙推导 正如之前提到的，分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。 因此，扩展的公共钥匙可以再HD钱包结构的分支中，被用来衍生所有的公钥（且只有公共钥匙）。 这种快捷方式可以用来创造非常保密的public-key-only配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公共钥匙的副本。这种配置可以创造出无限数量的公共钥匙以及比特币地址。但是不可以花送到这个地址里的任何比特币。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 这种方案的一个常见的方案是安装一个扩展的公共钥匙在服务电商公共程序的网络服务器上。网络服务器可以使用这个公共钥匙衍生方程去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公共钥匙。 这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包）与此同时扩展公共钥匙可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如Trezor）签署交易。图4-12阐述了扩展母公共钥匙来衍生子公共钥匙的传递机制。 图4-12 扩展母公共钥匙来创造一个子公共钥匙 硬化子密钥的衍生 从扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。访问扩展公共钥匙并不能得到访问子私人密钥的途径。但是，因为扩展公共钥匙包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。一个简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD钱包使用一种叫做hardened derivation的替代衍生方程。这就“打破”了母公共钥匙以及子链码之间的关系。这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙，如图4-13所示。 图4-13 子密钥的强化衍生；忽略了母公共密钥 当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，因为它所含的链码不能被用来开发或者暴露任何私钥。强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。 简单地来说，如果你想要利用扩展公共钥匙的便捷来衍生公共钥匙的分支而不将你自己暴露在泄露扩展链码的风险下，你应该从强化母私钥，而不是一般的母私钥，来衍生公共钥匙。最好的方式是，为了避免了推到出主钥匙，主钥匙所衍生的第一层级的子钥匙最好使用强化衍生。 正常衍生和强化衍生的索引号码 用在衍生方程中的索引号码是32位的整数。为了区分密钥是从正常衍生方程中衍生出来还是从强化衍生方程中产出，这个索引号被分为两个范围。索引号在0和231–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在231和232–1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生方程。因此，索引号小于231就意味着子密钥是常规的，而大于或者等于231的子密钥就是强化型的。 为了让索引号码更容易被阅读和展示，强化子密码的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0&#39;。第二个强化密钥依序有了索引号0x80000001，且被显示为1&#39;，以此类推。当你看到HD钱包索引号i&#39;，这就意味着 231+i。 HD钱包密钥识别符（路径） HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表4-8）。由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。 密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。 表4-8 HD钱包路径的例子 HD path 密钥描述 m/0 从主私钥（m）衍生出的第一个（0）子密钥。 m/0/0 第一个私人子密钥（m/0）的子密钥。 m/0&#39;/0 第一个子强化密钥first hardened child（m/0&#39;）的第一个常规子密钥。 m/1/0 第2个子密钥（m/1）的第一个常规子密钥 M/23/17/0/0 主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。 HD钱包树状结构的导航 HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。 两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP0043，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i&#39;/是为了表明那个被索引号“i”定义的特殊为目地。 在BIP0043标准下，为了延长的那个特殊规范，BIP0044提议了多账户结构作为“purpose”。所有遵循BIP0044的HD钱包依据只使用树的第一个分支的要求而被定义：m/44&#39;/。 BIP0044指定了包含5个预定义树状层级的结构： m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index 第一层的目的地总是被设定为44&#39;。第二层的“coin_type”特指密码货币硬币的种类并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44&#39;/0&#39;、Bitcoin Testnet is m/44&#39;/1&#39;，以及Litecoin is m/44&#39;/2&#39;。 树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。举个例子，一个HD钱包可能包含两个比特币“账户”：m/44&#39;/0&#39;/0&#39; 和 m/44&#39;/0&#39;/1&#39;。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在可供不安全环境下，输出扩展的公共钥匙。被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44&#39;/0&#39;/0&#39;/0/2。表4-9展示了更多的例子。 表4-9 BIP0044 HD 钱包结构的例子 HD 路径 主要描述 M/44&#39;/0&#39;/0&#39;/0/2 第三个收到公共钥匙的主比特币账户 M/44&#39;/0&#39;/3&#39;/1/14 第十五改变地址公钥的第四个比特币账户 m/44&#39;/2&#39;/0&#39;/0/1 为了签署交易的在莱特币主账户的第二个私钥 使用比特币浏览器实验比特币钱包 依据第3章介绍的使用比特币浏览管理器命令工具，你可以试着生产和延伸BIP0032确定性密钥以及将它们用不同的格式进行展示： $ sx hd-seed &gt; m # create a new master private key from a seed and store in file &quot;m&quot;$ cat m # show the master extended private key￼96 | Chapter 4: Keys, Addresses, Walletsxprv9s21ZrQH143K38iQ9Y5p6qoB8C75TE71NfpyQPdfGvzghDt39DHPFpovvtWZaR- gY5uPwV7RpEgHs7cvdgfiSjLjjbuGKGcjRyU7RGGSS8Xa$ cat m | sx hd-pub 0 # generate the M/0 extended public key xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KE- CeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9$ cat m | sx hd-priv 0 # generate the m/0 extended private key xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CA- WrUE9i6GoNMKUga5biW6Hx4tws2six3b9c$ cat m | sx hd-priv 0 | sx hd-to-wif # show the private key of m/0 as a WIF L1pbvV86crAGoDzqmgY85xURkz3c435Z9nirMt52UbnGjYMzKBUN$ cat m | sx hd-pub 0 | sx hd-to-address # show the bitcoin address of M/0 1CHCnCjgMNb6digimckNQ6TBVcTWBAmPHK$ cat m | sx hd-priv 0 | sx hd-priv 12 --hard | sx hd-priv 4 # generate m/ 0/12&#39;/4 xprv9yL8ndfdPVeDWJenF18oiHguRUj8jHmVrqqD97YQHeTcR3LCeh53q5PXPkLsy2kRaqgwoS6YZ- BLatRZRyUeAkRPe1kLR1P6Mn7jUrXFquUt 4.5 高级密钥和地址 在以下部分中，我们将看到高级形式的密钥和地址，诸如加密私钥、脚本和多重签名地址，靓号地址，和纸钱包。 4.5.1 加密私钥（BIP0038） 私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。有时，例如用户因为要升级或重装钱包软件，而需要把密钥从一个钱包转移到另一个。私钥备份也可能需要存储在纸张上（参见“4.5.4&nbsp;纸钱包”一节）或者外部存储介质里，比如U盘。但如果一旦备份文件失窃或丢失呢？这些矛盾的安全目标推进了便携、方便、可以被众多不同钱包和比特币客户端理解的加密私钥标准BIP0038的出台。 BIP0038提出了一个通用标准，使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。 BIP0038加密方案是：输入一个比特币私钥，通常使用WIF编码过，base58chek字符串的前缀“5”。此外BIP0038加密方案需要一个长密码作为口令，通常由多个单词或一段复杂的数字字母字符串组成。BIP0038加密方案的结果是一个由base58check编码过的加密私钥，前缀为6P。如果你看到一个6P开头的的密钥，这就意味着该密钥是被加密过，并需要一个口令来转换（解码）该密钥回到可被用在任何钱包WIF格式的私钥（前缀为5）。许多钱包APP现在能够识别BIP0038加密过的私钥，会要求用户提供口令解码并导入密钥。第三方APP，诸如非常好用基于浏览器的Bit&nbsp;Address，可以被用来解码BIP00038的密钥。 最通常使用BIP0038加密的密钥用例是纸钱包——一张纸张上备份私钥。只要用户选择了强口令，使用BIP0038加密的私钥的纸钱包就无比的安全，这也是一种很棒的比特币离线存储方式（也被称作“冷存储”）。 在bitaddress.org上测试表4-10中加密密钥，看看如何输入密码以得到加密密钥。 表4-10 BIP0038加密私钥例子 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 密码 MyTestPassphrase 加密私钥（BIP0038） 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ 4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址 正如我们所知，传统的比特币地址从数字1开头，来源于公钥，而公钥来源于私钥。虽然任何人都可以将比特币发送到一个1开头的地址，但比特币只能在通过相应的私钥签名和公钥哈希值后才能消费。 以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者。这个特性在2012年1月由BIP0016引进，目前因为BIP0016提供了增加功能到地址本身的机会而被广泛的采纳。不同于P2PKH交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，需要的不仅仅是一个公钥的哈希值，同时也需要一个私钥签名作为所有者证明。在创建地址的时候，这些要求会被定义在脚本中，所有对地址的输入都会被这些要求阻隔。 一个P2SH地址从事务脚本中创建，它定义谁能消耗这个事务输出。（132页“P2SH（Pay-to-Script-Hash）”一节对此有详细的介绍）编码一个P2SH地址涉及使用一个在创建比特币地址用到过的双重哈希函数，并且只能应用在脚本而不是公钥： script hash = RIPEMD160(SHA256(script)) 脚本哈希的结果是由Base58Check编码前缀为5的版本、编码后得到开头为3的编码地址。一个P2SH地址例子是32M8ednmuyZ2zVbes4puqe44NZumgG92sM。 P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。 4.5.2.1 多重签名地址和P2SH 目前，P2SH函数最常见的实现是用于多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性是需要从总共N个密钥中需要M个签名（也被称为“阈值”），被称为M-N多签名，其中M是等于或小于N。例如，第一章中提到的咖啡店主鲍勃使用多重签名地址需要1-2签名，一个是属于他的密钥和一个属于他同伴的密钥，以确保其中一方可以签署度过一个事务锁定输出到这个地址。这类似于传统的银行中的一个“联合账户”，其中任何一方配偶可以凭借单一签名消费。或Gopesh，&nbsp;Bob雇佣的网页设计师创立一个网站，可能为他的业务需要一个2-3的多签名地址，确保没有资金会被花费除非至少两个业务合作伙伴签署这笔交易。 我们将会在第五章节探索如何使用P2SH地址创建事务用来消费资金。 4.5.3 比特币靓号地址 靓号地址包含了可读信息的有效比特币地址。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33就是包含了Base-58字母love的。靓号地址需要生成并通过数十亿的候选私钥测试，直到一个私钥能生成具有所需图案的比特币地址。虽然有一些优化过的靓号生成算法，该方法必须涉及随机上选择一个私钥，生成公钥，再生成比特币地址，并检查是否与所要的靓号图案相匹配，重复数十亿次，直到找到一个匹配。 一旦找到一个匹配所要图案的靓号地址，来自这个靓号地址的私钥可以和其他地址相同的方式被拥有者消费比特币。靓号地址不比其他地址具有更多安全性。它们依靠和其他地址相同的ECC和SHA。你无法比任何别的地址更容易的获得一个靓号图案开头的私钥。 在第一章中，我们介绍了Eugenia，一位在菲律宾工作的儿童慈善总监。我们假设Eugenia组织了一场比特币募捐活动，并希望使用靓号比特币地址来宣布这个募捐活动。Eugenia将会创造一个以1Kids开头的靓号地址来促进儿童慈善募捐的活动。让我们看看这个靓号地址如何被创建，这个靓号地址对Eugenia慈善募捐的安全性又意味着什么。 4.5.3.1 生成靓号地址 我们必须认识到使用来自Base58字母表中简单符号来代表比特币地址是非常重要的。搜索“1kids”开头的图案我们会发现从1Kids11111111111111111111111111111到1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz的地址。这些以“1kid”开头的地址范围中大约有58的29次方地址。表4-11显示了这些有“1kids”前缀的地址。 表4-11 “1Kids”靓号的范围 From 1Kids11111111111111111111111111111 To 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz 我们把“1Kids”这个前缀当作数字，我们可以看看比特币地址中这个前缀出现的频率。如果是一台普通性能的桌面电脑，没有任何特殊的硬件，可以每秒发现大约10万个密钥。 表4-12 靓号的出现的频率（1KidsCharity）以及生成所需时间 长度 地址前缀 概率 平均生成时间 1 1K 1/58 &lt; 1毫秒 2 1Ki 1/3,364 50毫秒 3 1Kid 1/(195*103) &lt; 2秒 4 1Kids 1/(11*106) 1分钟 5 1KidsC 1/(656*106) 1小时 6 1KidsCh 1/(38*109) 2天 7 1KidsCha 1/(2.2*1012) 3–4 月 8 1KidsChar 1/(128*1012) 13–18年 9 1KidsChari 1/(7*1015) 800年 10 1KidsCharit 1/(400*1015) 46,000年 11 1KidsCharity 1/(23*1018) 250万年 正如你所见，Eugenia将不会很快地创建出以“1KidsCharity”开头的靓号地址，即使她有数千台的电脑同时进行运算。每增加一个字符就会增加58倍的计算难度。超过七个字符的搜索模式通常需要专用的硬件才能被找出，譬如用户定制的具有多图形处理单元（GPU）的桌面级设备。那些通常是无法继续在比特币挖矿中盈利的钻机，被重新赋予了寻找靓号地址的任务。用GPU系统搜索靓号的速度比用通用CPU要快很多个量级。 另一种寻找靓号地址的方法是将工作外包给一个矿池里的靓号矿工们，如靓号矿池中的矿池。一个矿池是一种允许那些GPU硬件通过为他人寻找靓号地址来获得比特币的服务。对小额的账单，Eugenia可以外包搜索模式为7个字符靓号地址寻找工作，在几个小时内就可以得到结果，而不必用一个CPU搜索上几个月才得到结果。 生成一个靓号地址是一项通过蛮力的过程：尝试一个随机密钥，检查结果地址是否和所需的图案相匹配，重复这个过程直到成功找到为止。例4-8是个靓号矿工的例子，用C++程序来寻找靓号地址。这个例子运用到了我们在56页“其他替代客户端、资料库、工具包”一节介绍过的libbitcoin库。 例4-8 靓号挖掘程序 #include &lt;bitcoin/bitcoin.hpp&gt;// The string we are searching forconst std::string search = &quot;1kid&quot;;// Generate a random secret key. A random 32 bytes.bc::ec_secret random_secret(std::default_random_engine&amp; engine); // Extract the Bitcoin address from an EC secret.std::string bitcoin_address(const bc::ec_secret&amp; secret);// Case insensitive comparison with the search string.bool match_found(const std::string&amp; address);int main() {&nbsp;&nbsp;&nbsp; std::random_device random; &nbsp;&nbsp;&nbsp; std::default_random_engine engine(random()); &nbsp;&nbsp;&nbsp; // Loop continuously...&nbsp;&nbsp;&nbsp; while (true) &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Generate a random secret.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc::ec_secret secret = random_secret(engine); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the address.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string address = bitcoin_address(secret); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Does it match our search string? (1kid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match_found(address)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Found vanity address! &quot; &lt;&lt; address &lt;&lt; std::endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Secret: &quot; &lt;&lt; bc::encode_hex(secret) &lt;&lt; std::endl; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; // Should never reach here!&nbsp;&nbsp;&nbsp; return 0; }bc::ec_secret random_secret(std::default_random_engine&amp; engine){&nbsp;&nbsp;&nbsp; // Create new secret...&nbsp;&nbsp;&nbsp; bc::ec_secret secret;&nbsp;&nbsp;&nbsp; // Iterate through every byte setting a random value... for (uint8_t&amp; byte: secret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max(); &nbsp;&nbsp;&nbsp; // Return result.&nbsp;&nbsp;&nbsp; return secret;}std::string bitcoin_address(const bc::ec_secret&amp; secret) {&nbsp;&nbsp;&nbsp; // Convert secret to pubkey...&nbsp;&nbsp;&nbsp; bc::ec_point pubkey = bc::secret_to_public_key(secret); &nbsp;&nbsp;&nbsp; // Finally create address.&nbsp;&nbsp;&nbsp; bc::payment_address payaddr; bc::set_public_key(payaddr, pubkey);&nbsp;&nbsp;&nbsp; // Return encoded form.&nbsp;&nbsp;&nbsp; return payaddr.encoded(); }bool match_found(const std::string&amp; address) {&nbsp;&nbsp;&nbsp; auto addr_it = address.begin();&nbsp;&nbsp;&nbsp; // Loop through the search string comparing it to the lower case &nbsp;&nbsp;&nbsp; // character of the supplied address.&nbsp;&nbsp;&nbsp; for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*it != std::tolower(*addr_it)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; // Reached end of search string, so address matches.&nbsp;&nbsp;&nbsp; return true; &nbsp;&nbsp;&nbsp; } 示例程序需要用C编译器链接libbitcoin库（此库需要提前装入该系统）进行编译。直接执行vanity-miner的可执行文件（不用参数，参见例4-9），它就会尝试碰撞以“1kid”开头的比特币地址。 例4-9 编译并运行vanity-miner程序示例 $ # Compile the code with g++$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the example$ ./vanity-minerFound vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YTSecret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f$ # Run it again for a different result$ ./vanity-minerFound vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFnSecret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623# Use &quot;time&quot; to see how long it takes to find a result$ time ./vanity-minerFound vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXMSecret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349real&nbsp;&nbsp;&nbsp; 0m8.868suser&nbsp;&nbsp;&nbsp; 0m8.828ssys&nbsp;&nbsp;&nbsp;&nbsp; 0m0.035s 正如我们运行Unix命令time所测出的运行时间所示，示例代码要花几秒钟来找出匹配“kid”三个字符模板的结果。读者们可以在源代码中改变search这一搜索模板，看一看如果是四个字符或者五个字符的搜索模板需要花多久时间！ 4.5.3.2 靓号地址安全性 靓号地址既可以增加、也可以削弱安全措施，它们着实是一把双刃剑。用于改善安全性时，一个独特的地址使对手难以使用他们自己的地址替代你的地址，以欺骗你的顾客支付他们的账单。不幸的是，靓号地址也可能使得任何人都能创建一个类似于随机地址的地址，甚至另一个靓号地址，从而欺骗你的客户。 Eugenia可以让捐款人捐款到她宣布的一个随机生成地址（例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy）。或者她可以生成一个以“1Kids”开头的靓号地址以显得更独特。 在这两种情况下，使用单一固定地址（而不是每比捐款用一个独立的动态地址）的风险之一是小偷有可能会黑进你的网站，用他自己的网址取代你的网址，从而将捐赠转移给自己。如果你在不同的地方公布了你的捐款地址，你的用户可以在付款之前直观地检查以确保这个地址跟在你的网站、邮件和传单上看到的地址是同一个。在随机地址1j7mdg5rbqyuhenydx39wvwk7fslpeoxzy的情况下，普通用户可能会只检查头几个字符“1j7mdg”，就认为地址匹配。使用靓号地址生成器，那些想通过替换类似地址来盗窃的人可以快速生成与前几个字符相匹配的地址，如表4-13所示。 表4-13 生成匹配某随机地址的多个靓号 原版随机地址 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 4位字符匹配 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy 5位字符匹配 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n 6位字符匹配 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX 那靓号地址会不会增加安全性？如果Eugenia生成1Kids33q44erFfpeXrmDSz7zEqG2FesZEN的靓号地址，用户可能看到靓号图案的字母和一些字符在上面，例如在地址部分中注明了1Kids33。这样就会迫使攻击者生成至少6个字母相匹配的的靓号地址（比之前多2个字符），就要花费比Eugenia多3364倍的靓号图案。本质上，Eugenia付出的努力（或者靓号池付出的）迫使攻击者不得不生成更长的靓号图案。如果Eugenia花钱请矿池生成8个字符的靓号地址，攻击者将会被逼迫到10字符的境地，那将是个人电脑，甚至昂贵自定义靓号挖掘机或靓号池也无法生成。对Eugenia来说可承担的起支出，对攻击者来说则变成了无法承担支出，特别是如果欺诈的回报不足以支付生成靓号地址所需的费用。 4.5.4 纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷钱包）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。作为一个冷存储的机制，如果纸钱包密钥在线下生成并永久不在电脑系统中存储，他们在应对黑客攻击，键盘记录器，或其他在线电脑欺骗更有安全性。 纸钱包有许多不同的形状，大小，和外观设计，但非常基本的原则是一个密钥和一个地址打印在纸张上。表4-14展现了纸钱包最基本的形式。 表4-14 比特币纸钱包的私钥和公钥的打印形式 公开地址 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 通过使用工具，就可以很容易地生成纸钱包，譬如使用bitaddress.org网站上的客户端Javascript生成器。这个页面包含所有必要的代码，甚至在完全失去网络连接的情况下，也可以生成密钥和纸钱包。若要使用它，先将HTML页面保存在本地磁盘或外部U盘。从Internet网络断开，从浏览器中打开文件。更方便的，使用一个原始操作系统启动电脑，比如一个光盘启动的Linux系统。任何在脱机情况下使用这个工具所生成的密钥，都可以通过USB线在本地打印机上打印出来，从而制造了密钥只存在纸张上而从未存储在在线系统上的纸钱包。将这些纸钱包放置在防火容器内，发送比特币到对应的比特币地址上，从而实现了一个简单但非常有效的冷存储解决方案。图4-14展示了通过bitaddress.org&nbsp;生成的纸钱包。 图4-14 通过bitaddress.org 生成的普通纸钱包 这个简单的纸钱包系统的不足之处是那些被打印下来的密钥容易被盗窃。一个能够接近这些纸的小偷只需偷走纸或者用把拍摄纸上的密钥，就能控制被这些密钥锁定的比特币。一个更复杂的纸钱包存储系统使用BIP0038加密的私钥。打印在纸钱包上的这些私钥被其所有者记住的一个口令保护起来。没有口令，这些被加密过的密钥也是毫无用处的。但它们仍旧优于用口令保护，因为这些密钥从没有在线过，并且必须从保险箱或者其他物理的安全存储中导出。图4-15展示了通过bitaddress.org 生成的加密纸钱包。 图4-15 通过bitaddress.org 生成的加密纸钱包。密码是“test”。 虽然你可以多次存款到纸钱包中，但是你最好一次性提款，一次性提取里面所有的资金。因为如果你提取的金额少于其中的金额的话，会生成一个找零地址。并且，你所用的电脑可能被病毒感染，那么就有可能泄露私钥。一次性提款可以减少私钥泄露的风险，如果你所需的金额比较少，那么请把余额找零到另一个纸钱包中。 纸钱包有许多设计和大小，并有许多不同的特性。有些作为礼物送给他人，有季节性的主题，像圣诞节和新年主题。另外一些则是设计保存在银行金库或通过某种方式隐藏私钥的保险箱内，或者用不透明的刮刮贴，或者折叠和防篡改的铝箔胶粘密封。图4-16至图4-18展示了几个不同安全和备份功能的纸钱包的例子。 图4-16 通过bitcoinpaperwallet.com生成的、私钥写在折叠皮瓣上的纸钱包 图4-17 通过bitcoinpaperwallet.com 生成的、私钥被密封住的纸钱包 其他设计有密钥和地址的额外副本，类似于票根形式的可以拆卸存根，让你可以存储多个副本以防火灾、洪水或其他自然灾害。 图4-18 在备份“存根”上有多个私钥副本的纸钱包 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给我老师的人工智能教程打call！http://blog.csdn.net/jiangjunshow 你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 标记文本 删除文本 引用文本 H2O is是液体。 210 运算结果是 1024. 插入链接与图片 链接: link. 图片: 带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = &#39;bar&#39;; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格 一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： TYPE ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash 创建一个自定义列表 Markdown Text-to- HTML conversion tool Authors John Luke 如何创建一个注脚 一个具有注脚的文本。2 注释也是必不可少的 Markdown将文本转换为 HTML。 KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 Γ ( n ) = ( n − 1 ) ! ∀ n ∈ N \Gamma(n) = (n-1)!\quad\forall n\in\mathbb N Γ(n)=(n−1)!∀n∈N 是通过欧拉积分 Γ ( z ) = ∫ 0 ∞ t z − 1 e − t d t &amp;ThinSpace; . \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 张三 李四 王五 你好！李四, 最近怎么样? 你最近怎么样，王五？ 我很好，谢谢! 我很好，谢谢! 李四想了很长时间, 文字太长了 不适合放在一行. 打量着王五... 很好... 王五, 你怎么样? 张三 李四 王五 这将产生一个流程图。: 链接 长方形 圆 圆角长方形 菱形 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： 关于 Flowchart流程图 语法，参考 这儿. 导出与导入 导出 如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 mermaid语法说明 ↩︎ 注脚的解释 ↩︎ 阅读更多" />
<meta property="og:description" content="分享一下我老师大神的人工智能教程！零基础，通俗易懂！http://blog.csdn.net/jiangjunshow 也欢迎大家转载本篇文章。分享知识，造福人民，实现我们中华民族伟大复兴！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 简介 比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需区块链或网络连接。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。 每笔比特币交易都需要一个有效的签名才会被存储在区块链。只有有效的数字密钥才能产生有效的数字签名，因此拥有比特币的密钥副本就拥有了该帐户的比特币控制权。密钥是成对出现的，由一个私钥和一个公钥所组成。公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们被存储在钱包文件内，由比特币钱包软件进行管理。 在比特币交易的支付环节，收件人的公钥是通过其数字指纹表示的，称为比特币地址，就像支票上的支付对象的名字（即“收款方”）。一般情况下，比特币地址由一个公钥生成并对应于这个公钥。然而，并非所有比特币地址都是公钥；他们也可以代表其他支付对象，譬如脚本，我们将在本章后面提及。这样一来，比特币地址把收款方抽象起来了，使得交易的目的地更灵活，就像支票一样：这个支付工具可支付到个人账户、公司账户，进行账单支付或现金支付。比特币地址是用户经常看到的密钥的唯一代表，他们只需要把比特币地址告诉其他人即可。 在本章中，我们将介绍钱包，也就是密钥所在之处。我们将了解密钥如何被产生、存储和管理。我们将回顾私钥和公钥、地址和脚本地址的各种编码格式。最后，我们将讲解密钥的特殊用途：生成签名、证明所有权以及创造比特币靓号地址和纸钱包。 4.1.1 公钥加密和加密货币 公钥加密发明于20世纪70年代。它是计算机和信息安全的数学基础。 自从公钥加密被发明之后，一些合适的数学函数被提出，譬如：素数幂和椭圆曲线乘法。这些数学函数都是不可逆的，就是说很容易向一个方向计算，但不可以向相反方向倒推。基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。比特币正是使用椭圆曲线乘法作为其公钥加密的基础算法。 在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名。 公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 大多数比特币钱包工具为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到，所以只存储私钥也是可以的。 4.1.2 私钥和公钥 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。在本节中，我们将从生成私钥开始，讲述如何使用椭圆曲线运算将私钥生成公钥，并最终由公钥生成比特币地址。私钥、公钥和比特币地址之间的关系如下图所示。 4.1.3 私钥 私钥就是一个随机选出的数字而已。一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。在比特币交易中，私钥用于生成支付比特币所必需的签名以证明资金的所有权。私钥必须始终保持机密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就难以复原，其所保护的比特币也将永远丢失。 比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。 从一个随机数生成私钥 生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2256之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。通常情况下，操作系统随机数生成器由人工的随机源进行初始化，也可能需要通过几秒钟内不停晃动鼠标等方式进行初始化。对于真正的偏执狂，可以使用掷骰子的方法，并用铅笔和纸记录。 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158*1077，略小于2256），并由比特币所使用的椭圆曲线的阶所定义（见4.1.5&nbsp;椭圆曲线密码学解释）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。 本书强烈建议读者不要使用自己写的代码或使用编程语言内建的简易随机数生成器来获得一个随机数。我们建议读者使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。使用随机数发生器的程序库时，需仔细研读其文档，以确保它是加密安全的。对CSPRNG的正确实现是密钥安全性的关键所在。 以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）： 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD 比特币私钥空间的大小是2256，这是一个非常大的数字。用十进制表示的话，大约是1077，而可见宇宙被估计只含有1080个原子。 要使用比特币核心客户端生成一个新的密钥（参见第3章），可使用getnewaddress命令。出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用dumpprivkey命令。dumpprivkey命令会把私钥以Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet&nbsp;Import Format），在“私钥的格式”一节有详细讲解。下面给出了使用这两个命令生成和显示私钥的例子： $ bitcoind getnewaddress1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZyKxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ dumpprivkey命令只是读取钱包里由getnewaddress命令生成的私钥，然后显示出来。bitcoind的并不能从公钥得知私钥。除非密钥对都存储在钱包里，dumpprivkey命令才有效。 dumpprivkey命令无法从公钥得到对应的私钥，因为这是不可能的。这个命令只是提取钱包中已有的私钥，也就是提取由getnewaddress命令生成的私钥。 你也可以使用命令行sx工具 （参见“3.3.1 Libbitcoin和sx Tools”）用newkey命令来生成并显示私钥: $ sx newkey5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 4.1.4 公钥 通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G&nbsp;。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线加密学。 4.1.5 椭圆曲线密码学解释 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 上图是一个椭圆曲线的示例，类似于比特币所用的曲线。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院（NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2&nbsp;= (x3&nbsp;+ 7)} over (Fp) 或 y2&nbsp;mod&nbsp;p&nbsp;= (x3&nbsp;+ 7) mod&nbsp;p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2256&nbsp;– 232&nbsp;– 29&nbsp;– 28&nbsp;– 27&nbsp;–&nbsp;26&nbsp;– 24&nbsp;– 1，这是一个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散点图，因此很难画图表示。不过，其中的数学原理与实数范围的椭圆曲线相似。作为一个例子，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。而secp256k1的比特币椭圆曲线可以被想象成一个极大的网格上一系列更为复杂的散点。 图为：椭圆曲线密码学F(p)上的椭圆曲线，其中p = 17 下面举一个例子，这是secp256k1曲线上的点P，其坐标为(x，y)。可以使用Python对其检验： P =（55066263022277343669578718895168534326250603453777594175500187360389116729240,32670510020758816978083085130507043184471273380659243275938904335757337482424）Python 3.4.0 (default, Mar 30 2014, 19:23:13)[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663&gt;&gt;&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240&gt;&gt;&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424&gt;&gt;&gt; (x ** 3 + 7 - y**2) % p0 在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。 还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3&nbsp;= P1&nbsp;+&nbsp;P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线上的一点相交。此点记为 P3&#39;=(x，y)。然后，在x轴做映射获得 P3=(x，-y)。 下面是几个可以解释“无穷远点”之存在需要的特殊情况。 若 P1和 P2是同一点，P1和P2间的连线则为点P1&nbsp;的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微分求得。即使限制曲线点为两个整数坐标也可求得斜率！ 在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3&nbsp;= “无穷远点”。 若P1就是“无穷远点”，那么其和 P1&nbsp;+ P2= P2。类似地，当P2是无穷远点，则P1+ P2&nbsp;= P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)C = A(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 至此，我们已经定义了椭圆加法，为扩展加法下面我们对乘法进行标准定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，k被有时被混淆而称为“指数”。 4.1.6 生成公钥 以一个随机生成的私钥k为起点，我们将其与曲线上已定义的 生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的： {K = k * G} 其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生）与任何人共享而不会泄露私钥（k）的原因。 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G 公钥K 被定义为一个点 K = (x, y)： K = (x, y)其中，x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 上图显示了在曲线上得到 G、2G、4G 的几何操作。 大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul() 函数，可计算得到公钥。 4.2 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。下面是一个比特币地址的例子： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人，也就是我们要写入收款人一栏的内容。一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。支票不需要指定一个特定的账户，而是用一个普通的名字作为收款人，这使它成为一种相当灵活的支付工具。与此类似，比特币地址的使用也使比特币交易变得很灵活。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其它东西，比如会在132页的“P2SH (Pay-to-Script-Hash)”一节讲到的付款脚本。现在，让我们来看一个简单的例子，由公钥生成比特币地址。 比特币地址可由公钥经过单向的加密哈希算法得到。哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，特别是SHA256和RIPEMD160。 以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160比特（20字节）的数字： A = RIPEMD160(SHA256(K)) 公式中，K是公钥，A是生成的比特币地址。 比特币地址与公钥不同。比特币地址是由公钥经过单向的哈希函数生成的。 通常用户见到的比特币地址是经过“Base58Check”编码的（参见72页“Base58和Base58Check编码”一节），这种编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。下一节中我们会详细解释Base58Check的编码机制，以及它产生的结果。下图描述了如何从公钥生成比特币地址。 4.2.1 Base58和Base58Check编码 为了更简洁方便地表示长串的数字，许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法。例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。一个同样的数字，它的十六进制表示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。Base64通常用于编码邮件中的附件。Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。 例4-1 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。 为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。 接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法： checksum = SHA256(SHA256(prefix+data)) 在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为校验码。校验码会添加到数据之后。 结果由三部分组成：前缀、数据和校验码。这个结果采用之前描述的Base58字母表编码。下图描述了Base58Check编码的过程。 Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式 在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。表4-1展示了一些版本前缀和他们对应的Base58格式。 表4-1 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。例4-2的C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。代码中使用“3.3&nbsp;其他客户端、资料库、工具包&nbsp;”一节中介绍的libbitcoin library来实现某些辅助功能。 例4-2 从私钥产生一个Base58Check格式编码的比特币地址 #include &lt;bitcoin/bitcoin.hpp&gt;int main() {&nbsp;&nbsp;&nbsp; // Private secret key.&nbsp;&nbsp;&nbsp; bc::ec_secret secret = bc::decode_hash(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776&quot;);&nbsp;&nbsp;&nbsp; // Get public key.&nbsp;&nbsp;&nbsp; bc::ec_point public_key = bc::secret_to_public_key(secret);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Public key: &quot; &lt;&lt; bc::encode_hex(public_key) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; // Create Bitcoin address.&nbsp;&nbsp;&nbsp; // Normally you can use:&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::payment_address payaddr;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::set_public_key(payaddr, public_key);&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; const std::string address = payaddr.encoded();&nbsp;&nbsp;&nbsp; // Compute hash of public key for P2PKH address.&nbsp;&nbsp;&nbsp; const bc::short_hash hash = bc::bitcoin_short_hash(public_key);&nbsp;&nbsp;&nbsp; bc::data_chunk unencoded_address; // Reserve 25 bytes&nbsp;&nbsp;&nbsp; // [ version:1 ]&nbsp;&nbsp;&nbsp; // [ hash:20 ]&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; [ checksum:4 ]&nbsp;&nbsp;&nbsp; unencoded_address.reserve(25);&nbsp;&nbsp;&nbsp; // Version byte, 0 is normal BTC address (P2PKH).&nbsp;&nbsp;&nbsp;&nbsp; unencoded_address.push_back(0);&nbsp;&nbsp;&nbsp; // Hash data&nbsp;&nbsp;&nbsp; bc::extend_data(unencoded_address, hash);&nbsp;&nbsp;&nbsp; // Checksum is computed by hashing data, and adding 4 bytes from hash. bc::append_checksum(unencoded_address);&nbsp;&nbsp;&nbsp; // Finally we must encode the result in Bitcoin&#39;s base58 encoding assert(unencoded_address.size() == 25);&nbsp;&nbsp;&nbsp; const std::string address = bc::encode_base58(unencoded_address);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; return 0; } 正如编译并运行addr代码中展示的，由于代码使用预定义的私钥，所以每次运行都会产生相同的比特币地址。如例4-3所示。 例4-3 编译并运行addr代码 # Compile the addr.cpp code$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)# Run the addr executable$ ./addrPublic key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK 4.2.2 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。 表4-2 私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 表4-3展示了用这三种格式所生成的私钥。 表4-3 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 将Base58Check编码解码为十六进制 sx工具包（参见“3.3.1 Libbitcoin和sx Tools”）可用来编写一些操作比特币密钥、地址及交易的shell脚本和命令行“管道”。你也可以使用sx工具从命令行对Base58Check格式进行解码。 我们使用的命令是base58check-decode： $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 所得结果是十六进制的密钥，紧接着是钱包导入格式（Wallet Import Format,WIF）的版本前缀128。 将十六进制转换为Base58Check编码 要转换成Base58Check编码（和之前的命令正好相反），我们需提供十六进制的私钥和钱包导入格式（Wallet Import Format，WIF）的版本号前缀128： $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 要将压缩格式的私钥编码为Base58Check（参见“压缩格式私钥”一节），我们需在十六进制私钥的后面添加后缀01，然后使用跟上面一样的方法： $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 生成的WIF压缩格式的私钥以字母“K”开头，用以表明被编码的私钥有一个后缀“01”，且该私钥只能被用于生成压缩格式的公钥（参见“压缩格式公钥”一节）。 公钥的格式 公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。 我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 下面是由前文中的私钥所生成的公钥，其坐标x和y如下： x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 下面是同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y： K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 压缩格式公钥 引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。 正如我们在“4.1.4 公钥”一节所见，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2mod&nbsp;p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。 未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲线加密的公式的左边是y2&nbsp;，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。下图阐释了公钥压缩： 下面是前述章节所生成的公钥，使用了264比特（66个十六进制数字）的压缩格式公钥格式，其中前缀03表示y坐标是一个奇数： K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 这个压缩格式公钥对应着同样的一个私钥，这意味它是由同样的私钥所生成。但是压缩格式公钥和非压缩格式公钥差别很大。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。 压缩格式公钥渐渐成为了各种不同的比特币客户端的默认格式，它可以大大减少交易所需的字节数，同时也让存储区块链所需的磁盘空间变小。然而，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。 为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。我们将在下一节详细解释这种机制是如何工作的。 压缩格式私钥 实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。 要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。 如果一个比特币钱包实现了压缩格式公钥，那么它将会在所有交易中使用该压格式缩公钥。钱包中的私钥将会被用来生成压缩格式公钥，压缩格式公钥然后被用来生成交易中的比特币地址。当从一个实现了压缩格式公钥的比特币钱包导出私钥时，钱包导入格式（WIF）将会被修改为WIF压缩格式，该格式将会在私钥的后面附加一个字节大小的后缀01。最终的Base58Check编码格式的私钥被称作WIF（“压缩”）私钥，以字母“K”或“L”开头。而以“5”开头的是从较老的钱包中以WIF（非压缩）格式导出的私钥。 表4-4展示了同样的私钥使用不同的WIF和WIF压缩格式编码。 表4-4 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ “压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。 4.3 用Python实现密钥和比特币地址 最全面的比特币Python库是 Vitalik Buterin写的&nbsp;pybitcointools。在例4-4中，我们使用pybitcointools库（导入为“bitcoin”）来生成和显示不同格式的密钥和比特币地址。 例4-4 使用pybitcointools库的密钥和比特币地址的生成和格式化过 import bitcoin# Generate a random private keyvalid_private_key = False while not valid_private_key:&nbsp;&nbsp;&nbsp; private_key = bitcoin.random_key()&nbsp;&nbsp;&nbsp; decoded_private_key = bitcoin.decode_privkey(private_key, &#39;hex&#39;)&nbsp;&nbsp;&nbsp; valid_private_key =&nbsp; 0 &lt; decoded_private_key &lt; bitcoin.Nprint &quot;Private Key (hex) is: &quot;, private_keyprint &quot;Private Key (decimal) is: &quot;, decoded_private_key# Convert private key to WIF formatwif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, &#39;wif&#39;)print &quot;Private Key (WIF) is: &quot;, wif_encoded_private_key# Add suffix &quot;01&quot; to indicate a compressed private keycompressed_private_key = private_key + &#39;01&#39;print &quot;Private Key Compressed (hex) is: &quot;, compressed_private_key# Generate a WIF format from the compressed private key (WIF-compressed)wif_compressed_private_key = bitcoin.encode_privkey(&nbsp;&nbsp;&nbsp; bitcoin.decode_privkey(compressed_private_key, &#39;hex&#39;), &#39;wif&#39;)print &quot;Private Key (WIF-Compressed) is: &quot;, wif_compressed_private_key# Multiply the EC generator point G with the private key to get a public key pointpublic_key = bitcoin.base10_multiply(bitcoin.G, decoded_private_key) print &quot;Public Key (x,y) coordinates is:&quot;, public_key# Encode as hex, prefix 04hex_encoded_public_key = bitcoin.encode_pubkey(public_key,&#39;hex&#39;) print &quot;Public Key (hex) is:&quot;, hex_encoded_public_key# Compress public key, adjust prefix depending on whether y is even or odd(public_key_x, public_key_y) = public_key if (public_key_y % 2) == 0:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;02&#39; else:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;03&#39;hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, 16) print &quot;Compressed Public Key (hex) is:&quot;, hex_compressed_public_key# Generate bitcoin address from public keyprint &quot;Bitcoin Address (b58check) is:&quot;, bitcoin.pubkey_to_address(public_key)# Generate compressed bitcoin address from compressed public keyprint &quot;Compressed Bitcoin Address (b58check) is:&quot;, \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitcoin.pubkey_to_address(hex_compressed_public_key) 例4-5显示了上段代码运行结果。 例4-5 运行 key-to-address-ecc-example.py $ python key-to-address-ecc-example.pyPrivate Key (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6Private Key (decimal) is:&nbsp;26563230048437957592232553826663696440606756685920117476832299673293013768870Private Key (WIF) is:&nbsp;5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4KPrivate Key Compressed (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601Private Key (WIF-Compressed) is:&nbsp;KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6SPublic Key (x,y) coordinates is:&nbsp;(41637322786646325214887832269588396900663353932545912953362782457239403430124L,&nbsp;16388935128781238405526710466724741593761085120864331449066658622400339362166L)Public Key (hex) is:&nbsp;045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176Compressed Public Key (hex) is:&nbsp;025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ecBitcoin Address (b58check) is:&nbsp;1thMirt546nngXqyPEz532S8fLwbozud8Compressed Bitcoin Address (b58check) is:&nbsp;14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3 例4-6是另外一个示例，使用的是Python ECDSA库来做椭圆曲线计算而非使用bitcoin的库。 例4-6 使用在比特币密钥中的椭圆曲线算法的脚本 import ecdsaimport randomfrom ecdsa.util import string_to_number, number_to_string# secp256k1, http://www.oid-info.com/get/1.3.132.0.10_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L_b = 0x0000000000000000000000000000000000000000000000000000000000000007L_a = 0x0000000000000000000000000000000000000000000000000000000000000000L_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8Lcurve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)oid_secp256k1 = (1, 3, 132, 0, 10)SECP256k1 = ecdsa.curves.Curve(&quot;SECP256k1&quot;, curve_secp256k1, generator_secp256k1,oid_secp256k1)ec_order = _rcurve = curve_secp256k1generator = generator_secp256k1def random_secret():&nbsp;&nbsp;&nbsp; random_char = lambda: chr(random.randint(0, 255))&nbsp;&nbsp;&nbsp; convert_to_int = lambda array:&nbsp;&nbsp;&nbsp;&nbsp; int(&quot;&quot;.join(array).encode(&quot;hex&quot;), 16) &nbsp;&nbsp;&nbsp; byte_array = [random_char() for i in range(32)]&nbsp;&nbsp;&nbsp; return convert_to_int(byte_array)def get_point_pubkey(point): &nbsp;&nbsp;&nbsp; if point.y() &amp; 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;03&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;02&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)def get_point_pubkey_uncompressed(point): &nbsp;&nbsp;&nbsp; key=&#39;04&#39;+\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.x() + \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.y() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)# Generate a new private key.secret = random_secret() print &quot;Secret: &quot;, secret# Get the public key point.point = secret * generator print &quot;EC point:&quot;, pointprint &quot;BTC public key:&quot;, get_point_pubkey(point).encode(&quot;hex&quot;)# Given the point (x, y) we can create the object using:point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order) assert point1 == point 例4-7显示了运行脚本的结果。 例4-7 安装Python ECDSA库，运行ec_math.py脚本 running the ec_math.py script$ # Install Python PIP package manager$ sudo apt-get install python-pip$ # Install the Python ECDSA library$ sudo pip install ecdsa$ # Run the script$ python ec-math.pySecret:38090835015954358862481132628887443905906204995912378278060168703580660294000EC point:(70048853531867179489857750497606966272382583471322935454624595540007269312627,105262206478686743191060800263479589329920209527285803935736021686045542353380)BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873 4.4 比特币钱包 钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。另外一种制作私钥的途径是 确定性密钥生成。在这里你可以用原先的私钥，通过单向哈希函数来生成每一个新的私钥，并将新生成的密钥按顺序连接。只要你可以重新创建这个序列，你只需要第一个私钥（称作种子、主私钥）来生成它们。在本节中，我们将会检查不同的私钥生成方法及其钱包结构。 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 4.4.1 非确定性（随机）钱包 在最早的一批比特币客户端中，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。举个例子，比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每把钥匙只使用一次。这种类型的钱包有一个昵称“Just a Bunch Of Keys（一堆私钥）”简称JBOK。这种钱包现在正在被确定性钱包替换，因为它们难以管理、备份以及导入。随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一把钥匙都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址通过关联多重交易和对方的地址重复使用会减少隐私。0型非确定性钱包并不是钱包的好选择，尤其是当你不想重复使用地址而创造过多的私钥并且要保存它们。虽然比特币核心客户包含0型钱包，但比特币的核心开发者并不想鼓励大家使用。下图表示包含有松散结构的随机钥匙的集合的非确定性钱包。 4.4.2 确定性（种子）钱包 确定性，或者“种子”钱包包含通过使用单项离散方程而可从公共的种子生成的私钥。种子是随机生成的数字。这个数字也含有比如索引号码或者可生成私钥的“链码”（参见“4.4.4&nbsp;分层确定性钱包（BIP0032/BIP0044）”一节）。在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。 4.4.3 助记码词汇 助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。单词的顺序就是钱包的备份。它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。 助记码被定义在比特币的改进建议39中（参见&quot;附录２ 比特币改进协议[bip0039]”），目前还处于草案状态。需注意的是，BIP0039是一个建议草案而不是标准方案。具体地来说，电子钱包和BIP0039使用不同的标准且对应不同组的词汇。Trezor钱包以及一些其他钱包使用BIP0039，但是BIP0039和电子钱包的运行不兼容。 BIP0039定义助记码和种子的创建过程如下： 1.创造一个128到256位的随机顺序（熵）。&nbsp;2.提出SHA256哈希前几位，就可以创造一个随机序列的校验和。&nbsp;3.把校验和加在随机顺序的后面。&nbsp;4.把顺序分解成11位的不同集合，并用这些集合去和一个预先已经定义的2048个单词字典做对应。&nbsp;5.生成一个12至24个词的助记码。 表4-5表示了熵数据的大小和助记码单词的长度之间的关系。 表4-5 助记码：熵及字段长度 熵（bits） 校验符（bits） 熵＋校验符 字段长 128 4 132 12 160 5 165 15 192 6 198 18 224 7 231 21 256 8 264 24 助记码表示128至256位数。这可以通过使用私钥抻拉函数PBKDF2来导出更长的（512位）的种子。所得的种子可以用来创造一个确定性钱包以及其所派生的所有钥匙。 表4-6和表4-7展示了一些助记码的例子和它所生成的种子。 表4-6 128位熵的助记码以及所产生的种子 负熵输入 (128 bits) 0c1e24e5917779d297e14d45f14e1a1a 助记码 (12 个单词) army van defense carry jealous true garbage claim echo media make crunch 种子 (512 bits) 　　　　　　　　　 3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88 8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf 表4-7 256位熵的助记码以及所产生的种子 负熵输入 (256 bits) 2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c 助记码 (24个单词) cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige 种子 (512 bits) 　　　　　　　　　 3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22 fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343 4.4.4 分层确定性钱包（BIP0032/BIP0044） 确定性钱包被开发成更容易从单个“种子”中生成许多关键的钥匙。最高级的来自确定性钱包的形是通过BIP0032标准生成的 the hierarchical deterministic wallet or HD wallet defined。分层确定性钱包包含从数结构所生成的钥匙。这种母钥匙可以生成子钥匙的序列。这些子钥匙又可以衍生出孙钥匙，以此无穷类推。这个树结构表如下图所示。 如果你想安装运行一个比特币钱包，你需要建造一个符合BIP0032和BIP0044标准的HD钱包。 HD钱包提供了随机（不确定性）钥匙有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门，子公司，具体功能以及会计类别。 HD钱包的第二个好处就是它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。 从种子中创造HD钱包 HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。根种子一般总是被表示为a mnemonic word sequence，正如&quot;4.4.3&nbsp;助记码词汇&quot;一节所表述的，助记码词汇可以让人们更容易地抄写和储存。 创建主密钥以及HD钱包地主链代码的过程如下图所示。 根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造master private key(m) 和 a master chain code的哈希。主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）。链代码可以给从母密钥中创造子密钥的那个方程中引入的熵。 私有子密钥的衍生 分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。 子密钥衍生方程是基于单项哈希方程。这个方程结合了： • 一个母私钥或者公共钥匙（ECDSA未压缩键）&nbsp;• 一个叫做链码（256 bits）的种子&nbsp;• 一个索引号（32 bits） 链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。 这三个项目相结合并散列可以生成子密钥，如下。 母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512方程散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。在图4-11中，我们看到这种这个说明——索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。 图4-11 延长母私钥去创造子私钥 改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。比如子0，子1，子2等等。每一个母密钥可以右20亿个子密钥。 向密码树下一层重复这个过程，每个子密钥可以依次成为母密钥继续创造它自己的子密钥，直到无限代。 使用衍生的子密钥 子私钥不能从非确定性（随机）密钥中被区分出来。因为衍生方程是单向方程，所以子密钥不能被用来发现他们的母密钥。子密钥也不能用来发现他们的相同层级的姊妹密钥。如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。只有母密钥以及链码才能得到所有的子密钥。没有子链码的话，子密钥也不能用来衍生出任何孙密钥。你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。 那子私钥自己可被用做什么呢？它可以用来做公共钥匙和比特币地址。之后它就可以被用那个地址来签署交易和支付任何东西。 子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。 扩展密钥 正如我们之前看到的，密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做extended key。术语“extended key”也被认为是“可扩展的密钥”是因为这种密钥可以用来衍生子密钥。 扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。有两种扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。这个钥匙可以用来扩展子公共钥匙，见“4.1.6&nbsp;生成公钥”。 想象一个扩展密钥作为HD钱包中钥匙树结构的一个分支的根。你可以衍生出这个分支的剩下所有部分。扩展私人钥匙可以创建一个完整的分支而扩展公共钥匙只能够创造一个公共钥匙的分支。 一个扩展钥匙包括一个私钥（或者公共钥匙）以及一个链码。一个扩展密钥可以创造出子密钥并且能创造出在钥匙树结构中的整个分支。分享扩展钥匙就可以访问整个分支。 扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP0032-兼容钱包之间导入导出。扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check-encoded串更长一些。 这是一个在Base58Check中编码的扩展私钥的例子： xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c 这是在Base58Check中编码的对应的扩展公共钥匙： xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9 公共子钥匙推导 正如之前提到的，分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。 因此，扩展的公共钥匙可以再HD钱包结构的分支中，被用来衍生所有的公钥（且只有公共钥匙）。 这种快捷方式可以用来创造非常保密的public-key-only配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公共钥匙的副本。这种配置可以创造出无限数量的公共钥匙以及比特币地址。但是不可以花送到这个地址里的任何比特币。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 这种方案的一个常见的方案是安装一个扩展的公共钥匙在服务电商公共程序的网络服务器上。网络服务器可以使用这个公共钥匙衍生方程去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公共钥匙。 这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包）与此同时扩展公共钥匙可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如Trezor）签署交易。图4-12阐述了扩展母公共钥匙来衍生子公共钥匙的传递机制。 图4-12 扩展母公共钥匙来创造一个子公共钥匙 硬化子密钥的衍生 从扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。访问扩展公共钥匙并不能得到访问子私人密钥的途径。但是，因为扩展公共钥匙包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。一个简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD钱包使用一种叫做hardened derivation的替代衍生方程。这就“打破”了母公共钥匙以及子链码之间的关系。这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙，如图4-13所示。 图4-13 子密钥的强化衍生；忽略了母公共密钥 当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，因为它所含的链码不能被用来开发或者暴露任何私钥。强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。 简单地来说，如果你想要利用扩展公共钥匙的便捷来衍生公共钥匙的分支而不将你自己暴露在泄露扩展链码的风险下，你应该从强化母私钥，而不是一般的母私钥，来衍生公共钥匙。最好的方式是，为了避免了推到出主钥匙，主钥匙所衍生的第一层级的子钥匙最好使用强化衍生。 正常衍生和强化衍生的索引号码 用在衍生方程中的索引号码是32位的整数。为了区分密钥是从正常衍生方程中衍生出来还是从强化衍生方程中产出，这个索引号被分为两个范围。索引号在0和231–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在231和232–1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生方程。因此，索引号小于231就意味着子密钥是常规的，而大于或者等于231的子密钥就是强化型的。 为了让索引号码更容易被阅读和展示，强化子密码的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0&#39;。第二个强化密钥依序有了索引号0x80000001，且被显示为1&#39;，以此类推。当你看到HD钱包索引号i&#39;，这就意味着 231+i。 HD钱包密钥识别符（路径） HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表4-8）。由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。 密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。 表4-8 HD钱包路径的例子 HD path 密钥描述 m/0 从主私钥（m）衍生出的第一个（0）子密钥。 m/0/0 第一个私人子密钥（m/0）的子密钥。 m/0&#39;/0 第一个子强化密钥first hardened child（m/0&#39;）的第一个常规子密钥。 m/1/0 第2个子密钥（m/1）的第一个常规子密钥 M/23/17/0/0 主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。 HD钱包树状结构的导航 HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。 两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP0043，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i&#39;/是为了表明那个被索引号“i”定义的特殊为目地。 在BIP0043标准下，为了延长的那个特殊规范，BIP0044提议了多账户结构作为“purpose”。所有遵循BIP0044的HD钱包依据只使用树的第一个分支的要求而被定义：m/44&#39;/。 BIP0044指定了包含5个预定义树状层级的结构： m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index 第一层的目的地总是被设定为44&#39;。第二层的“coin_type”特指密码货币硬币的种类并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44&#39;/0&#39;、Bitcoin Testnet is m/44&#39;/1&#39;，以及Litecoin is m/44&#39;/2&#39;。 树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。举个例子，一个HD钱包可能包含两个比特币“账户”：m/44&#39;/0&#39;/0&#39; 和 m/44&#39;/0&#39;/1&#39;。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在可供不安全环境下，输出扩展的公共钥匙。被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44&#39;/0&#39;/0&#39;/0/2。表4-9展示了更多的例子。 表4-9 BIP0044 HD 钱包结构的例子 HD 路径 主要描述 M/44&#39;/0&#39;/0&#39;/0/2 第三个收到公共钥匙的主比特币账户 M/44&#39;/0&#39;/3&#39;/1/14 第十五改变地址公钥的第四个比特币账户 m/44&#39;/2&#39;/0&#39;/0/1 为了签署交易的在莱特币主账户的第二个私钥 使用比特币浏览器实验比特币钱包 依据第3章介绍的使用比特币浏览管理器命令工具，你可以试着生产和延伸BIP0032确定性密钥以及将它们用不同的格式进行展示： $ sx hd-seed &gt; m # create a new master private key from a seed and store in file &quot;m&quot;$ cat m # show the master extended private key￼96 | Chapter 4: Keys, Addresses, Walletsxprv9s21ZrQH143K38iQ9Y5p6qoB8C75TE71NfpyQPdfGvzghDt39DHPFpovvtWZaR- gY5uPwV7RpEgHs7cvdgfiSjLjjbuGKGcjRyU7RGGSS8Xa$ cat m | sx hd-pub 0 # generate the M/0 extended public key xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KE- CeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9$ cat m | sx hd-priv 0 # generate the m/0 extended private key xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CA- WrUE9i6GoNMKUga5biW6Hx4tws2six3b9c$ cat m | sx hd-priv 0 | sx hd-to-wif # show the private key of m/0 as a WIF L1pbvV86crAGoDzqmgY85xURkz3c435Z9nirMt52UbnGjYMzKBUN$ cat m | sx hd-pub 0 | sx hd-to-address # show the bitcoin address of M/0 1CHCnCjgMNb6digimckNQ6TBVcTWBAmPHK$ cat m | sx hd-priv 0 | sx hd-priv 12 --hard | sx hd-priv 4 # generate m/ 0/12&#39;/4 xprv9yL8ndfdPVeDWJenF18oiHguRUj8jHmVrqqD97YQHeTcR3LCeh53q5PXPkLsy2kRaqgwoS6YZ- BLatRZRyUeAkRPe1kLR1P6Mn7jUrXFquUt 4.5 高级密钥和地址 在以下部分中，我们将看到高级形式的密钥和地址，诸如加密私钥、脚本和多重签名地址，靓号地址，和纸钱包。 4.5.1 加密私钥（BIP0038） 私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。有时，例如用户因为要升级或重装钱包软件，而需要把密钥从一个钱包转移到另一个。私钥备份也可能需要存储在纸张上（参见“4.5.4&nbsp;纸钱包”一节）或者外部存储介质里，比如U盘。但如果一旦备份文件失窃或丢失呢？这些矛盾的安全目标推进了便携、方便、可以被众多不同钱包和比特币客户端理解的加密私钥标准BIP0038的出台。 BIP0038提出了一个通用标准，使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。 BIP0038加密方案是：输入一个比特币私钥，通常使用WIF编码过，base58chek字符串的前缀“5”。此外BIP0038加密方案需要一个长密码作为口令，通常由多个单词或一段复杂的数字字母字符串组成。BIP0038加密方案的结果是一个由base58check编码过的加密私钥，前缀为6P。如果你看到一个6P开头的的密钥，这就意味着该密钥是被加密过，并需要一个口令来转换（解码）该密钥回到可被用在任何钱包WIF格式的私钥（前缀为5）。许多钱包APP现在能够识别BIP0038加密过的私钥，会要求用户提供口令解码并导入密钥。第三方APP，诸如非常好用基于浏览器的Bit&nbsp;Address，可以被用来解码BIP00038的密钥。 最通常使用BIP0038加密的密钥用例是纸钱包——一张纸张上备份私钥。只要用户选择了强口令，使用BIP0038加密的私钥的纸钱包就无比的安全，这也是一种很棒的比特币离线存储方式（也被称作“冷存储”）。 在bitaddress.org上测试表4-10中加密密钥，看看如何输入密码以得到加密密钥。 表4-10 BIP0038加密私钥例子 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 密码 MyTestPassphrase 加密私钥（BIP0038） 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ 4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址 正如我们所知，传统的比特币地址从数字1开头，来源于公钥，而公钥来源于私钥。虽然任何人都可以将比特币发送到一个1开头的地址，但比特币只能在通过相应的私钥签名和公钥哈希值后才能消费。 以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者。这个特性在2012年1月由BIP0016引进，目前因为BIP0016提供了增加功能到地址本身的机会而被广泛的采纳。不同于P2PKH交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，需要的不仅仅是一个公钥的哈希值，同时也需要一个私钥签名作为所有者证明。在创建地址的时候，这些要求会被定义在脚本中，所有对地址的输入都会被这些要求阻隔。 一个P2SH地址从事务脚本中创建，它定义谁能消耗这个事务输出。（132页“P2SH（Pay-to-Script-Hash）”一节对此有详细的介绍）编码一个P2SH地址涉及使用一个在创建比特币地址用到过的双重哈希函数，并且只能应用在脚本而不是公钥： script hash = RIPEMD160(SHA256(script)) 脚本哈希的结果是由Base58Check编码前缀为5的版本、编码后得到开头为3的编码地址。一个P2SH地址例子是32M8ednmuyZ2zVbes4puqe44NZumgG92sM。 P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。 4.5.2.1 多重签名地址和P2SH 目前，P2SH函数最常见的实现是用于多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性是需要从总共N个密钥中需要M个签名（也被称为“阈值”），被称为M-N多签名，其中M是等于或小于N。例如，第一章中提到的咖啡店主鲍勃使用多重签名地址需要1-2签名，一个是属于他的密钥和一个属于他同伴的密钥，以确保其中一方可以签署度过一个事务锁定输出到这个地址。这类似于传统的银行中的一个“联合账户”，其中任何一方配偶可以凭借单一签名消费。或Gopesh，&nbsp;Bob雇佣的网页设计师创立一个网站，可能为他的业务需要一个2-3的多签名地址，确保没有资金会被花费除非至少两个业务合作伙伴签署这笔交易。 我们将会在第五章节探索如何使用P2SH地址创建事务用来消费资金。 4.5.3 比特币靓号地址 靓号地址包含了可读信息的有效比特币地址。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33就是包含了Base-58字母love的。靓号地址需要生成并通过数十亿的候选私钥测试，直到一个私钥能生成具有所需图案的比特币地址。虽然有一些优化过的靓号生成算法，该方法必须涉及随机上选择一个私钥，生成公钥，再生成比特币地址，并检查是否与所要的靓号图案相匹配，重复数十亿次，直到找到一个匹配。 一旦找到一个匹配所要图案的靓号地址，来自这个靓号地址的私钥可以和其他地址相同的方式被拥有者消费比特币。靓号地址不比其他地址具有更多安全性。它们依靠和其他地址相同的ECC和SHA。你无法比任何别的地址更容易的获得一个靓号图案开头的私钥。 在第一章中，我们介绍了Eugenia，一位在菲律宾工作的儿童慈善总监。我们假设Eugenia组织了一场比特币募捐活动，并希望使用靓号比特币地址来宣布这个募捐活动。Eugenia将会创造一个以1Kids开头的靓号地址来促进儿童慈善募捐的活动。让我们看看这个靓号地址如何被创建，这个靓号地址对Eugenia慈善募捐的安全性又意味着什么。 4.5.3.1 生成靓号地址 我们必须认识到使用来自Base58字母表中简单符号来代表比特币地址是非常重要的。搜索“1kids”开头的图案我们会发现从1Kids11111111111111111111111111111到1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz的地址。这些以“1kid”开头的地址范围中大约有58的29次方地址。表4-11显示了这些有“1kids”前缀的地址。 表4-11 “1Kids”靓号的范围 From 1Kids11111111111111111111111111111 To 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz 我们把“1Kids”这个前缀当作数字，我们可以看看比特币地址中这个前缀出现的频率。如果是一台普通性能的桌面电脑，没有任何特殊的硬件，可以每秒发现大约10万个密钥。 表4-12 靓号的出现的频率（1KidsCharity）以及生成所需时间 长度 地址前缀 概率 平均生成时间 1 1K 1/58 &lt; 1毫秒 2 1Ki 1/3,364 50毫秒 3 1Kid 1/(195*103) &lt; 2秒 4 1Kids 1/(11*106) 1分钟 5 1KidsC 1/(656*106) 1小时 6 1KidsCh 1/(38*109) 2天 7 1KidsCha 1/(2.2*1012) 3–4 月 8 1KidsChar 1/(128*1012) 13–18年 9 1KidsChari 1/(7*1015) 800年 10 1KidsCharit 1/(400*1015) 46,000年 11 1KidsCharity 1/(23*1018) 250万年 正如你所见，Eugenia将不会很快地创建出以“1KidsCharity”开头的靓号地址，即使她有数千台的电脑同时进行运算。每增加一个字符就会增加58倍的计算难度。超过七个字符的搜索模式通常需要专用的硬件才能被找出，譬如用户定制的具有多图形处理单元（GPU）的桌面级设备。那些通常是无法继续在比特币挖矿中盈利的钻机，被重新赋予了寻找靓号地址的任务。用GPU系统搜索靓号的速度比用通用CPU要快很多个量级。 另一种寻找靓号地址的方法是将工作外包给一个矿池里的靓号矿工们，如靓号矿池中的矿池。一个矿池是一种允许那些GPU硬件通过为他人寻找靓号地址来获得比特币的服务。对小额的账单，Eugenia可以外包搜索模式为7个字符靓号地址寻找工作，在几个小时内就可以得到结果，而不必用一个CPU搜索上几个月才得到结果。 生成一个靓号地址是一项通过蛮力的过程：尝试一个随机密钥，检查结果地址是否和所需的图案相匹配，重复这个过程直到成功找到为止。例4-8是个靓号矿工的例子，用C++程序来寻找靓号地址。这个例子运用到了我们在56页“其他替代客户端、资料库、工具包”一节介绍过的libbitcoin库。 例4-8 靓号挖掘程序 #include &lt;bitcoin/bitcoin.hpp&gt;// The string we are searching forconst std::string search = &quot;1kid&quot;;// Generate a random secret key. A random 32 bytes.bc::ec_secret random_secret(std::default_random_engine&amp; engine); // Extract the Bitcoin address from an EC secret.std::string bitcoin_address(const bc::ec_secret&amp; secret);// Case insensitive comparison with the search string.bool match_found(const std::string&amp; address);int main() {&nbsp;&nbsp;&nbsp; std::random_device random; &nbsp;&nbsp;&nbsp; std::default_random_engine engine(random()); &nbsp;&nbsp;&nbsp; // Loop continuously...&nbsp;&nbsp;&nbsp; while (true) &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Generate a random secret.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc::ec_secret secret = random_secret(engine); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the address.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string address = bitcoin_address(secret); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Does it match our search string? (1kid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match_found(address)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Found vanity address! &quot; &lt;&lt; address &lt;&lt; std::endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Secret: &quot; &lt;&lt; bc::encode_hex(secret) &lt;&lt; std::endl; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; // Should never reach here!&nbsp;&nbsp;&nbsp; return 0; }bc::ec_secret random_secret(std::default_random_engine&amp; engine){&nbsp;&nbsp;&nbsp; // Create new secret...&nbsp;&nbsp;&nbsp; bc::ec_secret secret;&nbsp;&nbsp;&nbsp; // Iterate through every byte setting a random value... for (uint8_t&amp; byte: secret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max(); &nbsp;&nbsp;&nbsp; // Return result.&nbsp;&nbsp;&nbsp; return secret;}std::string bitcoin_address(const bc::ec_secret&amp; secret) {&nbsp;&nbsp;&nbsp; // Convert secret to pubkey...&nbsp;&nbsp;&nbsp; bc::ec_point pubkey = bc::secret_to_public_key(secret); &nbsp;&nbsp;&nbsp; // Finally create address.&nbsp;&nbsp;&nbsp; bc::payment_address payaddr; bc::set_public_key(payaddr, pubkey);&nbsp;&nbsp;&nbsp; // Return encoded form.&nbsp;&nbsp;&nbsp; return payaddr.encoded(); }bool match_found(const std::string&amp; address) {&nbsp;&nbsp;&nbsp; auto addr_it = address.begin();&nbsp;&nbsp;&nbsp; // Loop through the search string comparing it to the lower case &nbsp;&nbsp;&nbsp; // character of the supplied address.&nbsp;&nbsp;&nbsp; for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*it != std::tolower(*addr_it)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; // Reached end of search string, so address matches.&nbsp;&nbsp;&nbsp; return true; &nbsp;&nbsp;&nbsp; } 示例程序需要用C编译器链接libbitcoin库（此库需要提前装入该系统）进行编译。直接执行vanity-miner的可执行文件（不用参数，参见例4-9），它就会尝试碰撞以“1kid”开头的比特币地址。 例4-9 编译并运行vanity-miner程序示例 $ # Compile the code with g++$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the example$ ./vanity-minerFound vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YTSecret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f$ # Run it again for a different result$ ./vanity-minerFound vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFnSecret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623# Use &quot;time&quot; to see how long it takes to find a result$ time ./vanity-minerFound vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXMSecret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349real&nbsp;&nbsp;&nbsp; 0m8.868suser&nbsp;&nbsp;&nbsp; 0m8.828ssys&nbsp;&nbsp;&nbsp;&nbsp; 0m0.035s 正如我们运行Unix命令time所测出的运行时间所示，示例代码要花几秒钟来找出匹配“kid”三个字符模板的结果。读者们可以在源代码中改变search这一搜索模板，看一看如果是四个字符或者五个字符的搜索模板需要花多久时间！ 4.5.3.2 靓号地址安全性 靓号地址既可以增加、也可以削弱安全措施，它们着实是一把双刃剑。用于改善安全性时，一个独特的地址使对手难以使用他们自己的地址替代你的地址，以欺骗你的顾客支付他们的账单。不幸的是，靓号地址也可能使得任何人都能创建一个类似于随机地址的地址，甚至另一个靓号地址，从而欺骗你的客户。 Eugenia可以让捐款人捐款到她宣布的一个随机生成地址（例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy）。或者她可以生成一个以“1Kids”开头的靓号地址以显得更独特。 在这两种情况下，使用单一固定地址（而不是每比捐款用一个独立的动态地址）的风险之一是小偷有可能会黑进你的网站，用他自己的网址取代你的网址，从而将捐赠转移给自己。如果你在不同的地方公布了你的捐款地址，你的用户可以在付款之前直观地检查以确保这个地址跟在你的网站、邮件和传单上看到的地址是同一个。在随机地址1j7mdg5rbqyuhenydx39wvwk7fslpeoxzy的情况下，普通用户可能会只检查头几个字符“1j7mdg”，就认为地址匹配。使用靓号地址生成器，那些想通过替换类似地址来盗窃的人可以快速生成与前几个字符相匹配的地址，如表4-13所示。 表4-13 生成匹配某随机地址的多个靓号 原版随机地址 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 4位字符匹配 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy 5位字符匹配 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n 6位字符匹配 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX 那靓号地址会不会增加安全性？如果Eugenia生成1Kids33q44erFfpeXrmDSz7zEqG2FesZEN的靓号地址，用户可能看到靓号图案的字母和一些字符在上面，例如在地址部分中注明了1Kids33。这样就会迫使攻击者生成至少6个字母相匹配的的靓号地址（比之前多2个字符），就要花费比Eugenia多3364倍的靓号图案。本质上，Eugenia付出的努力（或者靓号池付出的）迫使攻击者不得不生成更长的靓号图案。如果Eugenia花钱请矿池生成8个字符的靓号地址，攻击者将会被逼迫到10字符的境地，那将是个人电脑，甚至昂贵自定义靓号挖掘机或靓号池也无法生成。对Eugenia来说可承担的起支出，对攻击者来说则变成了无法承担支出，特别是如果欺诈的回报不足以支付生成靓号地址所需的费用。 4.5.4 纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷钱包）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。作为一个冷存储的机制，如果纸钱包密钥在线下生成并永久不在电脑系统中存储，他们在应对黑客攻击，键盘记录器，或其他在线电脑欺骗更有安全性。 纸钱包有许多不同的形状，大小，和外观设计，但非常基本的原则是一个密钥和一个地址打印在纸张上。表4-14展现了纸钱包最基本的形式。 表4-14 比特币纸钱包的私钥和公钥的打印形式 公开地址 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 通过使用工具，就可以很容易地生成纸钱包，譬如使用bitaddress.org网站上的客户端Javascript生成器。这个页面包含所有必要的代码，甚至在完全失去网络连接的情况下，也可以生成密钥和纸钱包。若要使用它，先将HTML页面保存在本地磁盘或外部U盘。从Internet网络断开，从浏览器中打开文件。更方便的，使用一个原始操作系统启动电脑，比如一个光盘启动的Linux系统。任何在脱机情况下使用这个工具所生成的密钥，都可以通过USB线在本地打印机上打印出来，从而制造了密钥只存在纸张上而从未存储在在线系统上的纸钱包。将这些纸钱包放置在防火容器内，发送比特币到对应的比特币地址上，从而实现了一个简单但非常有效的冷存储解决方案。图4-14展示了通过bitaddress.org&nbsp;生成的纸钱包。 图4-14 通过bitaddress.org 生成的普通纸钱包 这个简单的纸钱包系统的不足之处是那些被打印下来的密钥容易被盗窃。一个能够接近这些纸的小偷只需偷走纸或者用把拍摄纸上的密钥，就能控制被这些密钥锁定的比特币。一个更复杂的纸钱包存储系统使用BIP0038加密的私钥。打印在纸钱包上的这些私钥被其所有者记住的一个口令保护起来。没有口令，这些被加密过的密钥也是毫无用处的。但它们仍旧优于用口令保护，因为这些密钥从没有在线过，并且必须从保险箱或者其他物理的安全存储中导出。图4-15展示了通过bitaddress.org 生成的加密纸钱包。 图4-15 通过bitaddress.org 生成的加密纸钱包。密码是“test”。 虽然你可以多次存款到纸钱包中，但是你最好一次性提款，一次性提取里面所有的资金。因为如果你提取的金额少于其中的金额的话，会生成一个找零地址。并且，你所用的电脑可能被病毒感染，那么就有可能泄露私钥。一次性提款可以减少私钥泄露的风险，如果你所需的金额比较少，那么请把余额找零到另一个纸钱包中。 纸钱包有许多设计和大小，并有许多不同的特性。有些作为礼物送给他人，有季节性的主题，像圣诞节和新年主题。另外一些则是设计保存在银行金库或通过某种方式隐藏私钥的保险箱内，或者用不透明的刮刮贴，或者折叠和防篡改的铝箔胶粘密封。图4-16至图4-18展示了几个不同安全和备份功能的纸钱包的例子。 图4-16 通过bitcoinpaperwallet.com生成的、私钥写在折叠皮瓣上的纸钱包 图4-17 通过bitcoinpaperwallet.com 生成的、私钥被密封住的纸钱包 其他设计有密钥和地址的额外副本，类似于票根形式的可以拆卸存根，让你可以存储多个副本以防火灾、洪水或其他自然灾害。 图4-18 在备份“存根”上有多个私钥副本的纸钱包 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给我老师的人工智能教程打call！http://blog.csdn.net/jiangjunshow 你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 标记文本 删除文本 引用文本 H2O is是液体。 210 运算结果是 1024. 插入链接与图片 链接: link. 图片: 带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = &#39;bar&#39;; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格 一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： TYPE ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash 创建一个自定义列表 Markdown Text-to- HTML conversion tool Authors John Luke 如何创建一个注脚 一个具有注脚的文本。2 注释也是必不可少的 Markdown将文本转换为 HTML。 KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 Γ ( n ) = ( n − 1 ) ! ∀ n ∈ N \Gamma(n) = (n-1)!\quad\forall n\in\mathbb N Γ(n)=(n−1)!∀n∈N 是通过欧拉积分 Γ ( z ) = ∫ 0 ∞ t z − 1 e − t d t &amp;ThinSpace; . \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 张三 李四 王五 你好！李四, 最近怎么样? 你最近怎么样，王五？ 我很好，谢谢! 我很好，谢谢! 李四想了很长时间, 文字太长了 不适合放在一行. 打量着王五... 很好... 王五, 你怎么样? 张三 李四 王五 这将产生一个流程图。: 链接 长方形 圆 圆角长方形 菱形 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： 关于 Flowchart流程图 语法，参考 这儿. 导出与导入 导出 如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 mermaid语法说明 ↩︎ 注脚的解释 ↩︎ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/11/11/13c7655b30113430e774e2d78adabfcd.html" />
<meta property="og:url" content="https://mlh.app/2018/11/11/13c7655b30113430e774e2d78adabfcd.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"分享一下我老师大神的人工智能教程！零基础，通俗易懂！http://blog.csdn.net/jiangjunshow 也欢迎大家转载本篇文章。分享知识，造福人民，实现我们中华民族伟大复兴！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 简介 比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需区块链或网络连接。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。 每笔比特币交易都需要一个有效的签名才会被存储在区块链。只有有效的数字密钥才能产生有效的数字签名，因此拥有比特币的密钥副本就拥有了该帐户的比特币控制权。密钥是成对出现的，由一个私钥和一个公钥所组成。公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们被存储在钱包文件内，由比特币钱包软件进行管理。 在比特币交易的支付环节，收件人的公钥是通过其数字指纹表示的，称为比特币地址，就像支票上的支付对象的名字（即“收款方”）。一般情况下，比特币地址由一个公钥生成并对应于这个公钥。然而，并非所有比特币地址都是公钥；他们也可以代表其他支付对象，譬如脚本，我们将在本章后面提及。这样一来，比特币地址把收款方抽象起来了，使得交易的目的地更灵活，就像支票一样：这个支付工具可支付到个人账户、公司账户，进行账单支付或现金支付。比特币地址是用户经常看到的密钥的唯一代表，他们只需要把比特币地址告诉其他人即可。 在本章中，我们将介绍钱包，也就是密钥所在之处。我们将了解密钥如何被产生、存储和管理。我们将回顾私钥和公钥、地址和脚本地址的各种编码格式。最后，我们将讲解密钥的特殊用途：生成签名、证明所有权以及创造比特币靓号地址和纸钱包。 4.1.1 公钥加密和加密货币 公钥加密发明于20世纪70年代。它是计算机和信息安全的数学基础。 自从公钥加密被发明之后，一些合适的数学函数被提出，譬如：素数幂和椭圆曲线乘法。这些数学函数都是不可逆的，就是说很容易向一个方向计算，但不可以向相反方向倒推。基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。比特币正是使用椭圆曲线乘法作为其公钥加密的基础算法。 在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名。 公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 大多数比特币钱包工具为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到，所以只存储私钥也是可以的。 4.1.2 私钥和公钥 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。在本节中，我们将从生成私钥开始，讲述如何使用椭圆曲线运算将私钥生成公钥，并最终由公钥生成比特币地址。私钥、公钥和比特币地址之间的关系如下图所示。 4.1.3 私钥 私钥就是一个随机选出的数字而已。一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。在比特币交易中，私钥用于生成支付比特币所必需的签名以证明资金的所有权。私钥必须始终保持机密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就难以复原，其所保护的比特币也将永远丢失。 比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。 从一个随机数生成私钥 生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2256之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。通常情况下，操作系统随机数生成器由人工的随机源进行初始化，也可能需要通过几秒钟内不停晃动鼠标等方式进行初始化。对于真正的偏执狂，可以使用掷骰子的方法，并用铅笔和纸记录。 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158*1077，略小于2256），并由比特币所使用的椭圆曲线的阶所定义（见4.1.5&nbsp;椭圆曲线密码学解释）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。 本书强烈建议读者不要使用自己写的代码或使用编程语言内建的简易随机数生成器来获得一个随机数。我们建议读者使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。使用随机数发生器的程序库时，需仔细研读其文档，以确保它是加密安全的。对CSPRNG的正确实现是密钥安全性的关键所在。 以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）： 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD 比特币私钥空间的大小是2256，这是一个非常大的数字。用十进制表示的话，大约是1077，而可见宇宙被估计只含有1080个原子。 要使用比特币核心客户端生成一个新的密钥（参见第3章），可使用getnewaddress命令。出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用dumpprivkey命令。dumpprivkey命令会把私钥以Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet&nbsp;Import Format），在“私钥的格式”一节有详细讲解。下面给出了使用这两个命令生成和显示私钥的例子： $ bitcoind getnewaddress1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZyKxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ dumpprivkey命令只是读取钱包里由getnewaddress命令生成的私钥，然后显示出来。bitcoind的并不能从公钥得知私钥。除非密钥对都存储在钱包里，dumpprivkey命令才有效。 dumpprivkey命令无法从公钥得到对应的私钥，因为这是不可能的。这个命令只是提取钱包中已有的私钥，也就是提取由getnewaddress命令生成的私钥。 你也可以使用命令行sx工具 （参见“3.3.1 Libbitcoin和sx Tools”）用newkey命令来生成并显示私钥: $ sx newkey5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 4.1.4 公钥 通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G&nbsp;。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线加密学。 4.1.5 椭圆曲线密码学解释 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 上图是一个椭圆曲线的示例，类似于比特币所用的曲线。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院（NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2&nbsp;= (x3&nbsp;+ 7)} over (Fp) 或 y2&nbsp;mod&nbsp;p&nbsp;= (x3&nbsp;+ 7) mod&nbsp;p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2256&nbsp;– 232&nbsp;– 29&nbsp;– 28&nbsp;– 27&nbsp;–&nbsp;26&nbsp;– 24&nbsp;– 1，这是一个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散点图，因此很难画图表示。不过，其中的数学原理与实数范围的椭圆曲线相似。作为一个例子，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。而secp256k1的比特币椭圆曲线可以被想象成一个极大的网格上一系列更为复杂的散点。 图为：椭圆曲线密码学F(p)上的椭圆曲线，其中p = 17 下面举一个例子，这是secp256k1曲线上的点P，其坐标为(x，y)。可以使用Python对其检验： P =（55066263022277343669578718895168534326250603453777594175500187360389116729240,32670510020758816978083085130507043184471273380659243275938904335757337482424）Python 3.4.0 (default, Mar 30 2014, 19:23:13)[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; p = 115792089237316195423570985008687907853269984665640564039457584007908834671663&gt;&gt;&gt; x = 55066263022277343669578718895168534326250603453777594175500187360389116729240&gt;&gt;&gt; y = 32670510020758816978083085130507043184471273380659243275938904335757337482424&gt;&gt;&gt; (x ** 3 + 7 - y**2) % p0 在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。 还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3&nbsp;= P1&nbsp;+&nbsp;P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线上的一点相交。此点记为 P3&#39;=(x，y)。然后，在x轴做映射获得 P3=(x，-y)。 下面是几个可以解释“无穷远点”之存在需要的特殊情况。 若 P1和 P2是同一点，P1和P2间的连线则为点P1&nbsp;的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微分求得。即使限制曲线点为两个整数坐标也可求得斜率！ 在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3&nbsp;= “无穷远点”。 若P1就是“无穷远点”，那么其和 P1&nbsp;+ P2= P2。类似地，当P2是无穷远点，则P1+ P2&nbsp;= P1。这就是把无穷远点类似于0的作用。 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)C = A(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。 至此，我们已经定义了椭圆加法，为扩展加法下面我们对乘法进行标准定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，k被有时被混淆而称为“指数”。 4.1.6 生成公钥 以一个随机生成的私钥k为起点，我们将其与曲线上已定义的 生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的： {K = k * G} 其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生）与任何人共享而不会泄露私钥（k）的原因。 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G 公钥K 被定义为一个点 K = (x, y)： K = (x, y)其中，x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 上图显示了在曲线上得到 G、2G、4G 的几何操作。 大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul() 函数，可计算得到公钥。 4.2 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。下面是一个比特币地址的例子： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人，也就是我们要写入收款人一栏的内容。一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。支票不需要指定一个特定的账户，而是用一个普通的名字作为收款人，这使它成为一种相当灵活的支付工具。与此类似，比特币地址的使用也使比特币交易变得很灵活。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其它东西，比如会在132页的“P2SH (Pay-to-Script-Hash)”一节讲到的付款脚本。现在，让我们来看一个简单的例子，由公钥生成比特币地址。 比特币地址可由公钥经过单向的加密哈希算法得到。哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，特别是SHA256和RIPEMD160。 以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160比特（20字节）的数字： A = RIPEMD160(SHA256(K)) 公式中，K是公钥，A是生成的比特币地址。 比特币地址与公钥不同。比特币地址是由公钥经过单向的哈希函数生成的。 通常用户见到的比特币地址是经过“Base58Check”编码的（参见72页“Base58和Base58Check编码”一节），这种编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。下一节中我们会详细解释Base58Check的编码机制，以及它产生的结果。下图描述了如何从公钥生成比特币地址。 4.2.1 Base58和Base58Check编码 为了更简洁方便地表示长串的数字，许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法。例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。一个同样的数字，它的十六进制表示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。Base64通常用于编码邮件中的附件。Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。 例4-1 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。 为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。 接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法： checksum = SHA256(SHA256(prefix+data)) 在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为校验码。校验码会添加到数据之后。 结果由三部分组成：前缀、数据和校验码。这个结果采用之前描述的Base58字母表编码。下图描述了Base58Check编码的过程。 Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式 在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。表4-1展示了一些版本前缀和他们对应的Base58格式。 表4-1 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。例4-2的C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。代码中使用“3.3&nbsp;其他客户端、资料库、工具包&nbsp;”一节中介绍的libbitcoin library来实现某些辅助功能。 例4-2 从私钥产生一个Base58Check格式编码的比特币地址 #include &lt;bitcoin/bitcoin.hpp&gt;int main() {&nbsp;&nbsp;&nbsp; // Private secret key.&nbsp;&nbsp;&nbsp; bc::ec_secret secret = bc::decode_hash(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776&quot;);&nbsp;&nbsp;&nbsp; // Get public key.&nbsp;&nbsp;&nbsp; bc::ec_point public_key = bc::secret_to_public_key(secret);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Public key: &quot; &lt;&lt; bc::encode_hex(public_key) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; // Create Bitcoin address.&nbsp;&nbsp;&nbsp; // Normally you can use:&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::payment_address payaddr;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; bc::set_public_key(payaddr, public_key);&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; const std::string address = payaddr.encoded();&nbsp;&nbsp;&nbsp; // Compute hash of public key for P2PKH address.&nbsp;&nbsp;&nbsp; const bc::short_hash hash = bc::bitcoin_short_hash(public_key);&nbsp;&nbsp;&nbsp; bc::data_chunk unencoded_address; // Reserve 25 bytes&nbsp;&nbsp;&nbsp; // [ version:1 ]&nbsp;&nbsp;&nbsp; // [ hash:20 ]&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; [ checksum:4 ]&nbsp;&nbsp;&nbsp; unencoded_address.reserve(25);&nbsp;&nbsp;&nbsp; // Version byte, 0 is normal BTC address (P2PKH).&nbsp;&nbsp;&nbsp;&nbsp; unencoded_address.push_back(0);&nbsp;&nbsp;&nbsp; // Hash data&nbsp;&nbsp;&nbsp; bc::extend_data(unencoded_address, hash);&nbsp;&nbsp;&nbsp; // Checksum is computed by hashing data, and adding 4 bytes from hash. bc::append_checksum(unencoded_address);&nbsp;&nbsp;&nbsp; // Finally we must encode the result in Bitcoin&#39;s base58 encoding assert(unencoded_address.size() == 25);&nbsp;&nbsp;&nbsp; const std::string address = bc::encode_base58(unencoded_address);&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; return 0; } 正如编译并运行addr代码中展示的，由于代码使用预定义的私钥，所以每次运行都会产生相同的比特币地址。如例4-3所示。 例4-3 编译并运行addr代码 # Compile the addr.cpp code$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)# Run the addr executable$ ./addrPublic key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK 4.2.2 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。 表4-2 私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 表4-3展示了用这三种格式所生成的私钥。 表4-3 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 将Base58Check编码解码为十六进制 sx工具包（参见“3.3.1 Libbitcoin和sx Tools”）可用来编写一些操作比特币密钥、地址及交易的shell脚本和命令行“管道”。你也可以使用sx工具从命令行对Base58Check格式进行解码。 我们使用的命令是base58check-decode： $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 所得结果是十六进制的密钥，紧接着是钱包导入格式（Wallet Import Format,WIF）的版本前缀128。 将十六进制转换为Base58Check编码 要转换成Base58Check编码（和之前的命令正好相反），我们需提供十六进制的私钥和钱包导入格式（Wallet Import Format，WIF）的版本号前缀128： $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 要将压缩格式的私钥编码为Base58Check（参见“压缩格式私钥”一节），我们需在十六进制私钥的后面添加后缀01，然后使用跟上面一样的方法： $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 生成的WIF压缩格式的私钥以字母“K”开头，用以表明被编码的私钥有一个后缀“01”，且该私钥只能被用于生成压缩格式的公钥（参见“压缩格式公钥”一节）。 公钥的格式 公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。 我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 下面是由前文中的私钥所生成的公钥，其坐标x和y如下： x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 下面是同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y： K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 压缩格式公钥 引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。 正如我们在“4.1.4 公钥”一节所见，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2mod&nbsp;p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。 未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲线加密的公式的左边是y2&nbsp;，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。下图阐释了公钥压缩： 下面是前述章节所生成的公钥，使用了264比特（66个十六进制数字）的压缩格式公钥格式，其中前缀03表示y坐标是一个奇数： K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 这个压缩格式公钥对应着同样的一个私钥，这意味它是由同样的私钥所生成。但是压缩格式公钥和非压缩格式公钥差别很大。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。 压缩格式公钥渐渐成为了各种不同的比特币客户端的默认格式，它可以大大减少交易所需的字节数，同时也让存储区块链所需的磁盘空间变小。然而，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。 为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。我们将在下一节详细解释这种机制是如何工作的。 压缩格式私钥 实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。 要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。 如果一个比特币钱包实现了压缩格式公钥，那么它将会在所有交易中使用该压格式缩公钥。钱包中的私钥将会被用来生成压缩格式公钥，压缩格式公钥然后被用来生成交易中的比特币地址。当从一个实现了压缩格式公钥的比特币钱包导出私钥时，钱包导入格式（WIF）将会被修改为WIF压缩格式，该格式将会在私钥的后面附加一个字节大小的后缀01。最终的Base58Check编码格式的私钥被称作WIF（“压缩”）私钥，以字母“K”或“L”开头。而以“5”开头的是从较老的钱包中以WIF（非压缩）格式导出的私钥。 表4-4展示了同样的私钥使用不同的WIF和WIF压缩格式编码。 表4-4 示例：同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ “压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。 4.3 用Python实现密钥和比特币地址 最全面的比特币Python库是 Vitalik Buterin写的&nbsp;pybitcointools。在例4-4中，我们使用pybitcointools库（导入为“bitcoin”）来生成和显示不同格式的密钥和比特币地址。 例4-4 使用pybitcointools库的密钥和比特币地址的生成和格式化过 import bitcoin# Generate a random private keyvalid_private_key = False while not valid_private_key:&nbsp;&nbsp;&nbsp; private_key = bitcoin.random_key()&nbsp;&nbsp;&nbsp; decoded_private_key = bitcoin.decode_privkey(private_key, &#39;hex&#39;)&nbsp;&nbsp;&nbsp; valid_private_key =&nbsp; 0 &lt; decoded_private_key &lt; bitcoin.Nprint &quot;Private Key (hex) is: &quot;, private_keyprint &quot;Private Key (decimal) is: &quot;, decoded_private_key# Convert private key to WIF formatwif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, &#39;wif&#39;)print &quot;Private Key (WIF) is: &quot;, wif_encoded_private_key# Add suffix &quot;01&quot; to indicate a compressed private keycompressed_private_key = private_key + &#39;01&#39;print &quot;Private Key Compressed (hex) is: &quot;, compressed_private_key# Generate a WIF format from the compressed private key (WIF-compressed)wif_compressed_private_key = bitcoin.encode_privkey(&nbsp;&nbsp;&nbsp; bitcoin.decode_privkey(compressed_private_key, &#39;hex&#39;), &#39;wif&#39;)print &quot;Private Key (WIF-Compressed) is: &quot;, wif_compressed_private_key# Multiply the EC generator point G with the private key to get a public key pointpublic_key = bitcoin.base10_multiply(bitcoin.G, decoded_private_key) print &quot;Public Key (x,y) coordinates is:&quot;, public_key# Encode as hex, prefix 04hex_encoded_public_key = bitcoin.encode_pubkey(public_key,&#39;hex&#39;) print &quot;Public Key (hex) is:&quot;, hex_encoded_public_key# Compress public key, adjust prefix depending on whether y is even or odd(public_key_x, public_key_y) = public_key if (public_key_y % 2) == 0:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;02&#39; else:&nbsp;&nbsp;&nbsp; compressed_prefix = &#39;03&#39;hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, 16) print &quot;Compressed Public Key (hex) is:&quot;, hex_compressed_public_key# Generate bitcoin address from public keyprint &quot;Bitcoin Address (b58check) is:&quot;, bitcoin.pubkey_to_address(public_key)# Generate compressed bitcoin address from compressed public keyprint &quot;Compressed Bitcoin Address (b58check) is:&quot;, \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitcoin.pubkey_to_address(hex_compressed_public_key) 例4-5显示了上段代码运行结果。 例4-5 运行 key-to-address-ecc-example.py $ python key-to-address-ecc-example.pyPrivate Key (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6Private Key (decimal) is:&nbsp;26563230048437957592232553826663696440606756685920117476832299673293013768870Private Key (WIF) is:&nbsp;5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4KPrivate Key Compressed (hex) is:&nbsp;3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601Private Key (WIF-Compressed) is:&nbsp;KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6SPublic Key (x,y) coordinates is:&nbsp;(41637322786646325214887832269588396900663353932545912953362782457239403430124L,&nbsp;16388935128781238405526710466724741593761085120864331449066658622400339362166L)Public Key (hex) is:&nbsp;045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176Compressed Public Key (hex) is:&nbsp;025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ecBitcoin Address (b58check) is:&nbsp;1thMirt546nngXqyPEz532S8fLwbozud8Compressed Bitcoin Address (b58check) is:&nbsp;14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3 例4-6是另外一个示例，使用的是Python ECDSA库来做椭圆曲线计算而非使用bitcoin的库。 例4-6 使用在比特币密钥中的椭圆曲线算法的脚本 import ecdsaimport randomfrom ecdsa.util import string_to_number, number_to_string# secp256k1, http://www.oid-info.com/get/1.3.132.0.10_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L_b = 0x0000000000000000000000000000000000000000000000000000000000000007L_a = 0x0000000000000000000000000000000000000000000000000000000000000000L_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8Lcurve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)oid_secp256k1 = (1, 3, 132, 0, 10)SECP256k1 = ecdsa.curves.Curve(&quot;SECP256k1&quot;, curve_secp256k1, generator_secp256k1,oid_secp256k1)ec_order = _rcurve = curve_secp256k1generator = generator_secp256k1def random_secret():&nbsp;&nbsp;&nbsp; random_char = lambda: chr(random.randint(0, 255))&nbsp;&nbsp;&nbsp; convert_to_int = lambda array:&nbsp;&nbsp;&nbsp;&nbsp; int(&quot;&quot;.join(array).encode(&quot;hex&quot;), 16) &nbsp;&nbsp;&nbsp; byte_array = [random_char() for i in range(32)]&nbsp;&nbsp;&nbsp; return convert_to_int(byte_array)def get_point_pubkey(point): &nbsp;&nbsp;&nbsp; if point.y() &amp; 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;03&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = &#39;02&#39; + &#39;%064x&#39; % point.x() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)def get_point_pubkey_uncompressed(point): &nbsp;&nbsp;&nbsp; key=&#39;04&#39;+\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.x() + \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;%064x&#39; % point.y() &nbsp;&nbsp;&nbsp; return key.decode(&#39;hex&#39;)# Generate a new private key.secret = random_secret() print &quot;Secret: &quot;, secret# Get the public key point.point = secret * generator print &quot;EC point:&quot;, pointprint &quot;BTC public key:&quot;, get_point_pubkey(point).encode(&quot;hex&quot;)# Given the point (x, y) we can create the object using:point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order) assert point1 == point 例4-7显示了运行脚本的结果。 例4-7 安装Python ECDSA库，运行ec_math.py脚本 running the ec_math.py script$ # Install Python PIP package manager$ sudo apt-get install python-pip$ # Install the Python ECDSA library$ sudo pip install ecdsa$ # Run the script$ python ec-math.pySecret:38090835015954358862481132628887443905906204995912378278060168703580660294000EC point:(70048853531867179489857750497606966272382583471322935454624595540007269312627,105262206478686743191060800263479589329920209527285803935736021686045542353380)BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873 4.4 比特币钱包 钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。另外一种制作私钥的途径是 确定性密钥生成。在这里你可以用原先的私钥，通过单向哈希函数来生成每一个新的私钥，并将新生成的密钥按顺序连接。只要你可以重新创建这个序列，你只需要第一个私钥（称作种子、主私钥）来生成它们。在本节中，我们将会检查不同的私钥生成方法及其钱包结构。 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 4.4.1 非确定性（随机）钱包 在最早的一批比特币客户端中，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。举个例子，比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每把钥匙只使用一次。这种类型的钱包有一个昵称“Just a Bunch Of Keys（一堆私钥）”简称JBOK。这种钱包现在正在被确定性钱包替换，因为它们难以管理、备份以及导入。随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一把钥匙都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址通过关联多重交易和对方的地址重复使用会减少隐私。0型非确定性钱包并不是钱包的好选择，尤其是当你不想重复使用地址而创造过多的私钥并且要保存它们。虽然比特币核心客户包含0型钱包，但比特币的核心开发者并不想鼓励大家使用。下图表示包含有松散结构的随机钥匙的集合的非确定性钱包。 4.4.2 确定性（种子）钱包 确定性，或者“种子”钱包包含通过使用单项离散方程而可从公共的种子生成的私钥。种子是随机生成的数字。这个数字也含有比如索引号码或者可生成私钥的“链码”（参见“4.4.4&nbsp;分层确定性钱包（BIP0032/BIP0044）”一节）。在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。 4.4.3 助记码词汇 助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。单词的顺序就是钱包的备份。它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。 助记码被定义在比特币的改进建议39中（参见&quot;附录２ 比特币改进协议[bip0039]”），目前还处于草案状态。需注意的是，BIP0039是一个建议草案而不是标准方案。具体地来说，电子钱包和BIP0039使用不同的标准且对应不同组的词汇。Trezor钱包以及一些其他钱包使用BIP0039，但是BIP0039和电子钱包的运行不兼容。 BIP0039定义助记码和种子的创建过程如下： 1.创造一个128到256位的随机顺序（熵）。&nbsp;2.提出SHA256哈希前几位，就可以创造一个随机序列的校验和。&nbsp;3.把校验和加在随机顺序的后面。&nbsp;4.把顺序分解成11位的不同集合，并用这些集合去和一个预先已经定义的2048个单词字典做对应。&nbsp;5.生成一个12至24个词的助记码。 表4-5表示了熵数据的大小和助记码单词的长度之间的关系。 表4-5 助记码：熵及字段长度 熵（bits） 校验符（bits） 熵＋校验符 字段长 128 4 132 12 160 5 165 15 192 6 198 18 224 7 231 21 256 8 264 24 助记码表示128至256位数。这可以通过使用私钥抻拉函数PBKDF2来导出更长的（512位）的种子。所得的种子可以用来创造一个确定性钱包以及其所派生的所有钥匙。 表4-6和表4-7展示了一些助记码的例子和它所生成的种子。 表4-6 128位熵的助记码以及所产生的种子 负熵输入 (128 bits) 0c1e24e5917779d297e14d45f14e1a1a 助记码 (12 个单词) army van defense carry jealous true garbage claim echo media make crunch 种子 (512 bits) 　　　　　　　　　 3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88 8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf 表4-7 256位熵的助记码以及所产生的种子 负熵输入 (256 bits) 2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c 助记码 (24个单词) cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige 种子 (512 bits) 　　　　　　　　　 3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22 fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343 4.4.4 分层确定性钱包（BIP0032/BIP0044） 确定性钱包被开发成更容易从单个“种子”中生成许多关键的钥匙。最高级的来自确定性钱包的形是通过BIP0032标准生成的 the hierarchical deterministic wallet or HD wallet defined。分层确定性钱包包含从数结构所生成的钥匙。这种母钥匙可以生成子钥匙的序列。这些子钥匙又可以衍生出孙钥匙，以此无穷类推。这个树结构表如下图所示。 如果你想安装运行一个比特币钱包，你需要建造一个符合BIP0032和BIP0044标准的HD钱包。 HD钱包提供了随机（不确定性）钥匙有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门，子公司，具体功能以及会计类别。 HD钱包的第二个好处就是它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。 从种子中创造HD钱包 HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。根种子一般总是被表示为a mnemonic word sequence，正如&quot;4.4.3&nbsp;助记码词汇&quot;一节所表述的，助记码词汇可以让人们更容易地抄写和储存。 创建主密钥以及HD钱包地主链代码的过程如下图所示。 根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造master private key(m) 和 a master chain code的哈希。主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）。链代码可以给从母密钥中创造子密钥的那个方程中引入的熵。 私有子密钥的衍生 分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。 子密钥衍生方程是基于单项哈希方程。这个方程结合了： • 一个母私钥或者公共钥匙（ECDSA未压缩键）&nbsp;• 一个叫做链码（256 bits）的种子&nbsp;• 一个索引号（32 bits） 链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。 这三个项目相结合并散列可以生成子密钥，如下。 母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512方程散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。在图4-11中，我们看到这种这个说明——索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。 图4-11 延长母私钥去创造子私钥 改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。比如子0，子1，子2等等。每一个母密钥可以右20亿个子密钥。 向密码树下一层重复这个过程，每个子密钥可以依次成为母密钥继续创造它自己的子密钥，直到无限代。 使用衍生的子密钥 子私钥不能从非确定性（随机）密钥中被区分出来。因为衍生方程是单向方程，所以子密钥不能被用来发现他们的母密钥。子密钥也不能用来发现他们的相同层级的姊妹密钥。如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。只有母密钥以及链码才能得到所有的子密钥。没有子链码的话，子密钥也不能用来衍生出任何孙密钥。你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。 那子私钥自己可被用做什么呢？它可以用来做公共钥匙和比特币地址。之后它就可以被用那个地址来签署交易和支付任何东西。 子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。 扩展密钥 正如我们之前看到的，密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做extended key。术语“extended key”也被认为是“可扩展的密钥”是因为这种密钥可以用来衍生子密钥。 扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。有两种扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。这个钥匙可以用来扩展子公共钥匙，见“4.1.6&nbsp;生成公钥”。 想象一个扩展密钥作为HD钱包中钥匙树结构的一个分支的根。你可以衍生出这个分支的剩下所有部分。扩展私人钥匙可以创建一个完整的分支而扩展公共钥匙只能够创造一个公共钥匙的分支。 一个扩展钥匙包括一个私钥（或者公共钥匙）以及一个链码。一个扩展密钥可以创造出子密钥并且能创造出在钥匙树结构中的整个分支。分享扩展钥匙就可以访问整个分支。 扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP0032-兼容钱包之间导入导出。扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check-encoded串更长一些。 这是一个在Base58Check中编码的扩展私钥的例子： xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c 这是在Base58Check中编码的对应的扩展公共钥匙： xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9 公共子钥匙推导 正如之前提到的，分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。 因此，扩展的公共钥匙可以再HD钱包结构的分支中，被用来衍生所有的公钥（且只有公共钥匙）。 这种快捷方式可以用来创造非常保密的public-key-only配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公共钥匙的副本。这种配置可以创造出无限数量的公共钥匙以及比特币地址。但是不可以花送到这个地址里的任何比特币。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 这种方案的一个常见的方案是安装一个扩展的公共钥匙在服务电商公共程序的网络服务器上。网络服务器可以使用这个公共钥匙衍生方程去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公共钥匙。 这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包）与此同时扩展公共钥匙可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如Trezor）签署交易。图4-12阐述了扩展母公共钥匙来衍生子公共钥匙的传递机制。 图4-12 扩展母公共钥匙来创造一个子公共钥匙 硬化子密钥的衍生 从扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。访问扩展公共钥匙并不能得到访问子私人密钥的途径。但是，因为扩展公共钥匙包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。一个简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD钱包使用一种叫做hardened derivation的替代衍生方程。这就“打破”了母公共钥匙以及子链码之间的关系。这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙，如图4-13所示。 图4-13 子密钥的强化衍生；忽略了母公共密钥 当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，因为它所含的链码不能被用来开发或者暴露任何私钥。强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。 简单地来说，如果你想要利用扩展公共钥匙的便捷来衍生公共钥匙的分支而不将你自己暴露在泄露扩展链码的风险下，你应该从强化母私钥，而不是一般的母私钥，来衍生公共钥匙。最好的方式是，为了避免了推到出主钥匙，主钥匙所衍生的第一层级的子钥匙最好使用强化衍生。 正常衍生和强化衍生的索引号码 用在衍生方程中的索引号码是32位的整数。为了区分密钥是从正常衍生方程中衍生出来还是从强化衍生方程中产出，这个索引号被分为两个范围。索引号在0和231–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在231和232–1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生方程。因此，索引号小于231就意味着子密钥是常规的，而大于或者等于231的子密钥就是强化型的。 为了让索引号码更容易被阅读和展示，强化子密码的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0&#39;。第二个强化密钥依序有了索引号0x80000001，且被显示为1&#39;，以此类推。当你看到HD钱包索引号i&#39;，这就意味着 231+i。 HD钱包密钥识别符（路径） HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表4-8）。由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。 密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。 表4-8 HD钱包路径的例子 HD path 密钥描述 m/0 从主私钥（m）衍生出的第一个（0）子密钥。 m/0/0 第一个私人子密钥（m/0）的子密钥。 m/0&#39;/0 第一个子强化密钥first hardened child（m/0&#39;）的第一个常规子密钥。 m/1/0 第2个子密钥（m/1）的第一个常规子密钥 M/23/17/0/0 主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。 HD钱包树状结构的导航 HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。 两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP0043，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i&#39;/是为了表明那个被索引号“i”定义的特殊为目地。 在BIP0043标准下，为了延长的那个特殊规范，BIP0044提议了多账户结构作为“purpose”。所有遵循BIP0044的HD钱包依据只使用树的第一个分支的要求而被定义：m/44&#39;/。 BIP0044指定了包含5个预定义树状层级的结构： m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index 第一层的目的地总是被设定为44&#39;。第二层的“coin_type”特指密码货币硬币的种类并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44&#39;/0&#39;、Bitcoin Testnet is m/44&#39;/1&#39;，以及Litecoin is m/44&#39;/2&#39;。 树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。举个例子，一个HD钱包可能包含两个比特币“账户”：m/44&#39;/0&#39;/0&#39; 和 m/44&#39;/0&#39;/1&#39;。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在可供不安全环境下，输出扩展的公共钥匙。被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44&#39;/0&#39;/0&#39;/0/2。表4-9展示了更多的例子。 表4-9 BIP0044 HD 钱包结构的例子 HD 路径 主要描述 M/44&#39;/0&#39;/0&#39;/0/2 第三个收到公共钥匙的主比特币账户 M/44&#39;/0&#39;/3&#39;/1/14 第十五改变地址公钥的第四个比特币账户 m/44&#39;/2&#39;/0&#39;/0/1 为了签署交易的在莱特币主账户的第二个私钥 使用比特币浏览器实验比特币钱包 依据第3章介绍的使用比特币浏览管理器命令工具，你可以试着生产和延伸BIP0032确定性密钥以及将它们用不同的格式进行展示： $ sx hd-seed &gt; m # create a new master private key from a seed and store in file &quot;m&quot;$ cat m # show the master extended private key￼96 | Chapter 4: Keys, Addresses, Walletsxprv9s21ZrQH143K38iQ9Y5p6qoB8C75TE71NfpyQPdfGvzghDt39DHPFpovvtWZaR- gY5uPwV7RpEgHs7cvdgfiSjLjjbuGKGcjRyU7RGGSS8Xa$ cat m | sx hd-pub 0 # generate the M/0 extended public key xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KE- CeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9$ cat m | sx hd-priv 0 # generate the m/0 extended private key xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CA- WrUE9i6GoNMKUga5biW6Hx4tws2six3b9c$ cat m | sx hd-priv 0 | sx hd-to-wif # show the private key of m/0 as a WIF L1pbvV86crAGoDzqmgY85xURkz3c435Z9nirMt52UbnGjYMzKBUN$ cat m | sx hd-pub 0 | sx hd-to-address # show the bitcoin address of M/0 1CHCnCjgMNb6digimckNQ6TBVcTWBAmPHK$ cat m | sx hd-priv 0 | sx hd-priv 12 --hard | sx hd-priv 4 # generate m/ 0/12&#39;/4 xprv9yL8ndfdPVeDWJenF18oiHguRUj8jHmVrqqD97YQHeTcR3LCeh53q5PXPkLsy2kRaqgwoS6YZ- BLatRZRyUeAkRPe1kLR1P6Mn7jUrXFquUt 4.5 高级密钥和地址 在以下部分中，我们将看到高级形式的密钥和地址，诸如加密私钥、脚本和多重签名地址，靓号地址，和纸钱包。 4.5.1 加密私钥（BIP0038） 私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。有时，例如用户因为要升级或重装钱包软件，而需要把密钥从一个钱包转移到另一个。私钥备份也可能需要存储在纸张上（参见“4.5.4&nbsp;纸钱包”一节）或者外部存储介质里，比如U盘。但如果一旦备份文件失窃或丢失呢？这些矛盾的安全目标推进了便携、方便、可以被众多不同钱包和比特币客户端理解的加密私钥标准BIP0038的出台。 BIP0038提出了一个通用标准，使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。 BIP0038加密方案是：输入一个比特币私钥，通常使用WIF编码过，base58chek字符串的前缀“5”。此外BIP0038加密方案需要一个长密码作为口令，通常由多个单词或一段复杂的数字字母字符串组成。BIP0038加密方案的结果是一个由base58check编码过的加密私钥，前缀为6P。如果你看到一个6P开头的的密钥，这就意味着该密钥是被加密过，并需要一个口令来转换（解码）该密钥回到可被用在任何钱包WIF格式的私钥（前缀为5）。许多钱包APP现在能够识别BIP0038加密过的私钥，会要求用户提供口令解码并导入密钥。第三方APP，诸如非常好用基于浏览器的Bit&nbsp;Address，可以被用来解码BIP00038的密钥。 最通常使用BIP0038加密的密钥用例是纸钱包——一张纸张上备份私钥。只要用户选择了强口令，使用BIP0038加密的私钥的纸钱包就无比的安全，这也是一种很棒的比特币离线存储方式（也被称作“冷存储”）。 在bitaddress.org上测试表4-10中加密密钥，看看如何输入密码以得到加密密钥。 表4-10 BIP0038加密私钥例子 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 密码 MyTestPassphrase 加密私钥（BIP0038） 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ 4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址 正如我们所知，传统的比特币地址从数字1开头，来源于公钥，而公钥来源于私钥。虽然任何人都可以将比特币发送到一个1开头的地址，但比特币只能在通过相应的私钥签名和公钥哈希值后才能消费。 以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者。这个特性在2012年1月由BIP0016引进，目前因为BIP0016提供了增加功能到地址本身的机会而被广泛的采纳。不同于P2PKH交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，需要的不仅仅是一个公钥的哈希值，同时也需要一个私钥签名作为所有者证明。在创建地址的时候，这些要求会被定义在脚本中，所有对地址的输入都会被这些要求阻隔。 一个P2SH地址从事务脚本中创建，它定义谁能消耗这个事务输出。（132页“P2SH（Pay-to-Script-Hash）”一节对此有详细的介绍）编码一个P2SH地址涉及使用一个在创建比特币地址用到过的双重哈希函数，并且只能应用在脚本而不是公钥： script hash = RIPEMD160(SHA256(script)) 脚本哈希的结果是由Base58Check编码前缀为5的版本、编码后得到开头为3的编码地址。一个P2SH地址例子是32M8ednmuyZ2zVbes4puqe44NZumgG92sM。 P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。 4.5.2.1 多重签名地址和P2SH 目前，P2SH函数最常见的实现是用于多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性是需要从总共N个密钥中需要M个签名（也被称为“阈值”），被称为M-N多签名，其中M是等于或小于N。例如，第一章中提到的咖啡店主鲍勃使用多重签名地址需要1-2签名，一个是属于他的密钥和一个属于他同伴的密钥，以确保其中一方可以签署度过一个事务锁定输出到这个地址。这类似于传统的银行中的一个“联合账户”，其中任何一方配偶可以凭借单一签名消费。或Gopesh，&nbsp;Bob雇佣的网页设计师创立一个网站，可能为他的业务需要一个2-3的多签名地址，确保没有资金会被花费除非至少两个业务合作伙伴签署这笔交易。 我们将会在第五章节探索如何使用P2SH地址创建事务用来消费资金。 4.5.3 比特币靓号地址 靓号地址包含了可读信息的有效比特币地址。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33就是包含了Base-58字母love的。靓号地址需要生成并通过数十亿的候选私钥测试，直到一个私钥能生成具有所需图案的比特币地址。虽然有一些优化过的靓号生成算法，该方法必须涉及随机上选择一个私钥，生成公钥，再生成比特币地址，并检查是否与所要的靓号图案相匹配，重复数十亿次，直到找到一个匹配。 一旦找到一个匹配所要图案的靓号地址，来自这个靓号地址的私钥可以和其他地址相同的方式被拥有者消费比特币。靓号地址不比其他地址具有更多安全性。它们依靠和其他地址相同的ECC和SHA。你无法比任何别的地址更容易的获得一个靓号图案开头的私钥。 在第一章中，我们介绍了Eugenia，一位在菲律宾工作的儿童慈善总监。我们假设Eugenia组织了一场比特币募捐活动，并希望使用靓号比特币地址来宣布这个募捐活动。Eugenia将会创造一个以1Kids开头的靓号地址来促进儿童慈善募捐的活动。让我们看看这个靓号地址如何被创建，这个靓号地址对Eugenia慈善募捐的安全性又意味着什么。 4.5.3.1 生成靓号地址 我们必须认识到使用来自Base58字母表中简单符号来代表比特币地址是非常重要的。搜索“1kids”开头的图案我们会发现从1Kids11111111111111111111111111111到1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz的地址。这些以“1kid”开头的地址范围中大约有58的29次方地址。表4-11显示了这些有“1kids”前缀的地址。 表4-11 “1Kids”靓号的范围 From 1Kids11111111111111111111111111111 To 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz 我们把“1Kids”这个前缀当作数字，我们可以看看比特币地址中这个前缀出现的频率。如果是一台普通性能的桌面电脑，没有任何特殊的硬件，可以每秒发现大约10万个密钥。 表4-12 靓号的出现的频率（1KidsCharity）以及生成所需时间 长度 地址前缀 概率 平均生成时间 1 1K 1/58 &lt; 1毫秒 2 1Ki 1/3,364 50毫秒 3 1Kid 1/(195*103) &lt; 2秒 4 1Kids 1/(11*106) 1分钟 5 1KidsC 1/(656*106) 1小时 6 1KidsCh 1/(38*109) 2天 7 1KidsCha 1/(2.2*1012) 3–4 月 8 1KidsChar 1/(128*1012) 13–18年 9 1KidsChari 1/(7*1015) 800年 10 1KidsCharit 1/(400*1015) 46,000年 11 1KidsCharity 1/(23*1018) 250万年 正如你所见，Eugenia将不会很快地创建出以“1KidsCharity”开头的靓号地址，即使她有数千台的电脑同时进行运算。每增加一个字符就会增加58倍的计算难度。超过七个字符的搜索模式通常需要专用的硬件才能被找出，譬如用户定制的具有多图形处理单元（GPU）的桌面级设备。那些通常是无法继续在比特币挖矿中盈利的钻机，被重新赋予了寻找靓号地址的任务。用GPU系统搜索靓号的速度比用通用CPU要快很多个量级。 另一种寻找靓号地址的方法是将工作外包给一个矿池里的靓号矿工们，如靓号矿池中的矿池。一个矿池是一种允许那些GPU硬件通过为他人寻找靓号地址来获得比特币的服务。对小额的账单，Eugenia可以外包搜索模式为7个字符靓号地址寻找工作，在几个小时内就可以得到结果，而不必用一个CPU搜索上几个月才得到结果。 生成一个靓号地址是一项通过蛮力的过程：尝试一个随机密钥，检查结果地址是否和所需的图案相匹配，重复这个过程直到成功找到为止。例4-8是个靓号矿工的例子，用C++程序来寻找靓号地址。这个例子运用到了我们在56页“其他替代客户端、资料库、工具包”一节介绍过的libbitcoin库。 例4-8 靓号挖掘程序 #include &lt;bitcoin/bitcoin.hpp&gt;// The string we are searching forconst std::string search = &quot;1kid&quot;;// Generate a random secret key. A random 32 bytes.bc::ec_secret random_secret(std::default_random_engine&amp; engine); // Extract the Bitcoin address from an EC secret.std::string bitcoin_address(const bc::ec_secret&amp; secret);// Case insensitive comparison with the search string.bool match_found(const std::string&amp; address);int main() {&nbsp;&nbsp;&nbsp; std::random_device random; &nbsp;&nbsp;&nbsp; std::default_random_engine engine(random()); &nbsp;&nbsp;&nbsp; // Loop continuously...&nbsp;&nbsp;&nbsp; while (true) &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Generate a random secret.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc::ec_secret secret = random_secret(engine); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the address.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string address = bitcoin_address(secret); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Does it match our search string? (1kid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match_found(address)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Found vanity address! &quot; &lt;&lt; address &lt;&lt; std::endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Secret: &quot; &lt;&lt; bc::encode_hex(secret) &lt;&lt; std::endl; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; // Should never reach here!&nbsp;&nbsp;&nbsp; return 0; }bc::ec_secret random_secret(std::default_random_engine&amp; engine){&nbsp;&nbsp;&nbsp; // Create new secret...&nbsp;&nbsp;&nbsp; bc::ec_secret secret;&nbsp;&nbsp;&nbsp; // Iterate through every byte setting a random value... for (uint8_t&amp; byte: secret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max(); &nbsp;&nbsp;&nbsp; // Return result.&nbsp;&nbsp;&nbsp; return secret;}std::string bitcoin_address(const bc::ec_secret&amp; secret) {&nbsp;&nbsp;&nbsp; // Convert secret to pubkey...&nbsp;&nbsp;&nbsp; bc::ec_point pubkey = bc::secret_to_public_key(secret); &nbsp;&nbsp;&nbsp; // Finally create address.&nbsp;&nbsp;&nbsp; bc::payment_address payaddr; bc::set_public_key(payaddr, pubkey);&nbsp;&nbsp;&nbsp; // Return encoded form.&nbsp;&nbsp;&nbsp; return payaddr.encoded(); }bool match_found(const std::string&amp; address) {&nbsp;&nbsp;&nbsp; auto addr_it = address.begin();&nbsp;&nbsp;&nbsp; // Loop through the search string comparing it to the lower case &nbsp;&nbsp;&nbsp; // character of the supplied address.&nbsp;&nbsp;&nbsp; for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*it != std::tolower(*addr_it)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; // Reached end of search string, so address matches.&nbsp;&nbsp;&nbsp; return true; &nbsp;&nbsp;&nbsp; } 示例程序需要用C编译器链接libbitcoin库（此库需要提前装入该系统）进行编译。直接执行vanity-miner的可执行文件（不用参数，参见例4-9），它就会尝试碰撞以“1kid”开头的比特币地址。 例4-9 编译并运行vanity-miner程序示例 $ # Compile the code with g++$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the example$ ./vanity-minerFound vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YTSecret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f$ # Run it again for a different result$ ./vanity-minerFound vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFnSecret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623# Use &quot;time&quot; to see how long it takes to find a result$ time ./vanity-minerFound vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXMSecret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349real&nbsp;&nbsp;&nbsp; 0m8.868suser&nbsp;&nbsp;&nbsp; 0m8.828ssys&nbsp;&nbsp;&nbsp;&nbsp; 0m0.035s 正如我们运行Unix命令time所测出的运行时间所示，示例代码要花几秒钟来找出匹配“kid”三个字符模板的结果。读者们可以在源代码中改变search这一搜索模板，看一看如果是四个字符或者五个字符的搜索模板需要花多久时间！ 4.5.3.2 靓号地址安全性 靓号地址既可以增加、也可以削弱安全措施，它们着实是一把双刃剑。用于改善安全性时，一个独特的地址使对手难以使用他们自己的地址替代你的地址，以欺骗你的顾客支付他们的账单。不幸的是，靓号地址也可能使得任何人都能创建一个类似于随机地址的地址，甚至另一个靓号地址，从而欺骗你的客户。 Eugenia可以让捐款人捐款到她宣布的一个随机生成地址（例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy）。或者她可以生成一个以“1Kids”开头的靓号地址以显得更独特。 在这两种情况下，使用单一固定地址（而不是每比捐款用一个独立的动态地址）的风险之一是小偷有可能会黑进你的网站，用他自己的网址取代你的网址，从而将捐赠转移给自己。如果你在不同的地方公布了你的捐款地址，你的用户可以在付款之前直观地检查以确保这个地址跟在你的网站、邮件和传单上看到的地址是同一个。在随机地址1j7mdg5rbqyuhenydx39wvwk7fslpeoxzy的情况下，普通用户可能会只检查头几个字符“1j7mdg”，就认为地址匹配。使用靓号地址生成器，那些想通过替换类似地址来盗窃的人可以快速生成与前几个字符相匹配的地址，如表4-13所示。 表4-13 生成匹配某随机地址的多个靓号 原版随机地址 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 4位字符匹配 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy 5位字符匹配 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n 6位字符匹配 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX 那靓号地址会不会增加安全性？如果Eugenia生成1Kids33q44erFfpeXrmDSz7zEqG2FesZEN的靓号地址，用户可能看到靓号图案的字母和一些字符在上面，例如在地址部分中注明了1Kids33。这样就会迫使攻击者生成至少6个字母相匹配的的靓号地址（比之前多2个字符），就要花费比Eugenia多3364倍的靓号图案。本质上，Eugenia付出的努力（或者靓号池付出的）迫使攻击者不得不生成更长的靓号图案。如果Eugenia花钱请矿池生成8个字符的靓号地址，攻击者将会被逼迫到10字符的境地，那将是个人电脑，甚至昂贵自定义靓号挖掘机或靓号池也无法生成。对Eugenia来说可承担的起支出，对攻击者来说则变成了无法承担支出，特别是如果欺诈的回报不足以支付生成靓号地址所需的费用。 4.5.4 纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷钱包）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。作为一个冷存储的机制，如果纸钱包密钥在线下生成并永久不在电脑系统中存储，他们在应对黑客攻击，键盘记录器，或其他在线电脑欺骗更有安全性。 纸钱包有许多不同的形状，大小，和外观设计，但非常基本的原则是一个密钥和一个地址打印在纸张上。表4-14展现了纸钱包最基本的形式。 表4-14 比特币纸钱包的私钥和公钥的打印形式 公开地址 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x 私钥（WIF） 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 通过使用工具，就可以很容易地生成纸钱包，譬如使用bitaddress.org网站上的客户端Javascript生成器。这个页面包含所有必要的代码，甚至在完全失去网络连接的情况下，也可以生成密钥和纸钱包。若要使用它，先将HTML页面保存在本地磁盘或外部U盘。从Internet网络断开，从浏览器中打开文件。更方便的，使用一个原始操作系统启动电脑，比如一个光盘启动的Linux系统。任何在脱机情况下使用这个工具所生成的密钥，都可以通过USB线在本地打印机上打印出来，从而制造了密钥只存在纸张上而从未存储在在线系统上的纸钱包。将这些纸钱包放置在防火容器内，发送比特币到对应的比特币地址上，从而实现了一个简单但非常有效的冷存储解决方案。图4-14展示了通过bitaddress.org&nbsp;生成的纸钱包。 图4-14 通过bitaddress.org 生成的普通纸钱包 这个简单的纸钱包系统的不足之处是那些被打印下来的密钥容易被盗窃。一个能够接近这些纸的小偷只需偷走纸或者用把拍摄纸上的密钥，就能控制被这些密钥锁定的比特币。一个更复杂的纸钱包存储系统使用BIP0038加密的私钥。打印在纸钱包上的这些私钥被其所有者记住的一个口令保护起来。没有口令，这些被加密过的密钥也是毫无用处的。但它们仍旧优于用口令保护，因为这些密钥从没有在线过，并且必须从保险箱或者其他物理的安全存储中导出。图4-15展示了通过bitaddress.org 生成的加密纸钱包。 图4-15 通过bitaddress.org 生成的加密纸钱包。密码是“test”。 虽然你可以多次存款到纸钱包中，但是你最好一次性提款，一次性提取里面所有的资金。因为如果你提取的金额少于其中的金额的话，会生成一个找零地址。并且，你所用的电脑可能被病毒感染，那么就有可能泄露私钥。一次性提款可以减少私钥泄露的风险，如果你所需的金额比较少，那么请把余额找零到另一个纸钱包中。 纸钱包有许多设计和大小，并有许多不同的特性。有些作为礼物送给他人，有季节性的主题，像圣诞节和新年主题。另外一些则是设计保存在银行金库或通过某种方式隐藏私钥的保险箱内，或者用不透明的刮刮贴，或者折叠和防篡改的铝箔胶粘密封。图4-16至图4-18展示了几个不同安全和备份功能的纸钱包的例子。 图4-16 通过bitcoinpaperwallet.com生成的、私钥写在折叠皮瓣上的纸钱包 图4-17 通过bitcoinpaperwallet.com 生成的、私钥被密封住的纸钱包 其他设计有密钥和地址的额外副本，类似于票根形式的可以拆卸存根，让你可以存储多个副本以防火灾、洪水或其他自然灾害。 图4-18 在备份“存根”上有多个私钥副本的纸钱包 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给我老师的人工智能教程打call！http://blog.csdn.net/jiangjunshow 你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 标记文本 删除文本 引用文本 H2O is是液体。 210 运算结果是 1024. 插入链接与图片 链接: link. 图片: 带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = &#39;bar&#39;; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格 一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： TYPE ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash 创建一个自定义列表 Markdown Text-to- HTML conversion tool Authors John Luke 如何创建一个注脚 一个具有注脚的文本。2 注释也是必不可少的 Markdown将文本转换为 HTML。 KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 Γ ( n ) = ( n − 1 ) ! ∀ n ∈ N \\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N Γ(n)=(n−1)!∀n∈N 是通过欧拉积分 Γ ( z ) = ∫ 0 ∞ t z − 1 e − t d t &amp;ThinSpace; . \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 张三 李四 王五 你好！李四, 最近怎么样? 你最近怎么样，王五？ 我很好，谢谢! 我很好，谢谢! 李四想了很长时间, 文字太长了 不适合放在一行. 打量着王五... 很好... 王五, 你怎么样? 张三 李四 王五 这将产生一个流程图。: 链接 长方形 圆 圆角长方形 菱形 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： 关于 Flowchart流程图 语法，参考 这儿. 导出与导入 导出 如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 mermaid语法说明 ↩︎ 注脚的解释 ↩︎ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/11/11/13c7655b30113430e774e2d78adabfcd.html","headline":"精通比特币-第4章 密钥 地址 钱包","dateModified":"2018-11-11T00:00:00+08:00","datePublished":"2018-11-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/11/11/13c7655b30113430e774e2d78adabfcd.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>精通比特币-第4章 密钥 地址 钱包</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><strong>分享一下我老师大神的人工智能教程！零基础，通俗易懂！<a href="https://blog.csdn.net/jiangjunshow/article/details/77338485" rel="nofollow">http://blog.csdn.net/jiangjunshow</a></strong></p>
  <p></p>
  <p><strong>也欢迎大家转载本篇文章。分享知识，造福人民，实现我们中华民族伟大复兴！</strong></p>
  <p></p>
  <div class="htmledit_views">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   <h2 id="4-1-%E7%AE%80%E4%BB%8B"><a></a>4.1 简介</h2>
   <p>比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需区块链或网络连接。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。</p>
   <p>每笔比特币交易都需要一个有效的签名才会被存储在区块链。只有有效的数字密钥才能产生有效的数字签名，因此拥有比特币的密钥副本就拥有了该帐户的比特币控制权。密钥是成对出现的，由一个私钥和一个公钥所组成。公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们被存储在钱包文件内，由比特币钱包软件进行管理。</p>
   <p>在比特币交易的支付环节，收件人的公钥是通过其数字指纹表示的，称为比特币地址，就像支票上的支付对象的名字（即“收款方”）。一般情况下，比特币地址由一个公钥生成并对应于这个公钥。然而，并非所有比特币地址都是公钥；他们也可以代表其他支付对象，譬如脚本，我们将在本章后面提及。这样一来，比特币地址把收款方抽象起来了，使得交易的目的地更灵活，就像支票一样：这个支付工具可支付到个人账户、公司账户，进行账单支付或现金支付。比特币地址是用户经常看到的密钥的唯一代表，他们只需要把比特币地址告诉其他人即可。</p>
   <p>在本章中，我们将介绍钱包，也就是密钥所在之处。我们将了解密钥如何被产生、存储和管理。我们将回顾私钥和公钥、地址和脚本地址的各种编码格式。最后，我们将讲解密钥的特殊用途：生成签名、证明所有权以及创造比特币靓号地址和纸钱包。</p>
   <h2 id="4-1-1-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%92%8C%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81"><a></a>4.1.1 公钥加密和加密货币</h2>
   <p>公钥加密发明于20世纪70年代。它是计算机和信息安全的数学基础。</p>
   <p>自从公钥加密被发明之后，一些合适的数学函数被提出，譬如：素数幂和椭圆曲线乘法。这些数学函数都是不可逆的，就是说很容易向一个方向计算，但不可以向相反方向倒推。基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。比特币正是使用椭圆曲线乘法作为其公钥加密的基础算法。</p>
   <p>在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名。</p>
   <p>公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。</p>
   <p>支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>大多数比特币钱包工具为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到，所以只存储私钥也是可以的。</p>
   </blockquote>
   <h3 id="4-1-2-%E7%A7%81%E9%92%A5%E5%92%8C%E5%85%AC%E9%92%A5"><a></a>4.1.2 私钥和公钥</h3>
   <p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。在本节中，我们将从生成私钥开始，讲述如何使用椭圆曲线运算将私钥生成公钥，并最终由公钥生成比特币地址。私钥、公钥和比特币地址之间的关系如下图所示。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig401.png"></p>
   <h3 id="4-1-3-%E7%A7%81%E9%92%A5"><a></a>4.1.3 私钥</h3>
   <p>私钥就是一个随机选出的数字而已。一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。在比特币交易中，私钥用于生成支付比特币所必需的签名以证明资金的所有权。私钥必须始终保持机密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就难以复原，其所保护的比特币也将永远丢失。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。</p>
   </blockquote>
   <h4 id="%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E7%A7%81%E9%92%A5">从一个随机数生成私钥</h4>
   <p>生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2<span>256</span>之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。通常情况下，操作系统随机数生成器由人工的随机源进行初始化，也可能需要通过几秒钟内不停晃动鼠标等方式进行初始化。对于真正的偏执狂，可以使用掷骰子的方法，并用铅笔和纸记录。</p>
   <p>更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158*10<span>77</span>，略小于2<span>256</span>），并由比特币所使用的椭圆曲线的阶所定义（见<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-1-5-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%E8%A7%A3%E9%87%8A" rel="nofollow" target="_blank">4.1.5&nbsp;椭圆曲线密码学解释</a>）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>本书强烈建议读者不要使用自己写的代码或使用编程语言内建的简易随机数生成器来获得一个随机数。我们建议读者使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。使用随机数发生器的程序库时，需仔细研读其文档，以确保它是加密安全的。对CSPRNG的正确实现是密钥安全性的关键所在。</p>
   </blockquote>
   <p>以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：</p>
   <pre><code class="hljs">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</code></pre>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>比特币私钥空间的大小是2<span>256</span>，这是一个非常大的数字。用十进制表示的话，大约是10<span>77</span>，而可见宇宙被估计只含有10<span>80</span>个原子。</p>
   </blockquote>
   <p>要使用比特币核心客户端生成一个新的密钥（参见<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter03.html#%E7%AC%AC3%E7%AB%A0-%E6%AF%94%E7%89%B9%E5%B8%81%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow" target="_blank">第3章</a>），可使用<code>getnewaddress</code>命令。出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用<code>dumpprivkey</code>命令。<code>dumpprivkey</code>命令会把私钥以Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet&nbsp;Import Format），在“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#%E7%A7%81%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow" target="_blank">私钥的格式</a>”一节有详细讲解。下面给出了使用这两个命令生成和显示私钥的例子：</p>
   <pre><code class="hljs ruby">$ bitcoind getnewaddress<span class="hljs-number">1</span>J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy$ bitcoind dumpprivkey <span class="hljs-number">1</span>J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZyKxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</code></pre>
   <p><code>dumpprivkey</code>命令只是读取钱包里由<code>getnewaddress</code>命令生成的私钥，然后显示出来。bitcoind的并不能从公钥得知私钥。除非密钥对都存储在钱包里，<code>dumpprivkey</code>命令才有效。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br><code>dumpprivkey</code>命令无法从公钥得到对应的私钥，因为这是不可能的。这个命令只是提取钱包中已有的私钥，也就是提取由<code>getnewaddress</code>命令生成的私钥。</p>
   </blockquote>
   <p>你也可以使用命令行sx工具 （参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter03.html#3-3-1-libbitcoin%E5%92%8Csx-tools" rel="nofollow" target="_blank">3.3.1 Libbitcoin和sx Tools</a>”）用newkey命令来生成并显示私钥:</p>
   <pre><code class="hljs ruby">$ sx newkey<span class="hljs-number">5</span>J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</code></pre>
   <h3 id="4-1-4-%E5%85%AC%E9%92%A5"><a></a>4.1.4 公钥</h3>
   <p>通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：<code>K = k * G</code>&nbsp;。其中<code>k</code>是私钥，<code>G</code>是被称为生成点的常数点，而<code>K</code>是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥<code>K</code>来求出私钥<code>k</code>——是非常困难的，就像去试验所有可能的<code>k</code>值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线加密学。</p>
   <h3 id="4-1-5-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%E8%A7%A3%E9%87%8A"><a></a>4.1.5 椭圆曲线密码学解释</h3>
   <p>椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig402.png"></p>
   <p>上图是一个椭圆曲线的示例，类似于比特币所用的曲线。</p>
   <p>比特币使用了<code>secp256k1</code>标准所定义的一条特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院（NIST）设立。<code>secp256k1</code>曲线由下述函数定义，该函数可产生一条椭圆曲线：</p>
   <p>y<span>2</span>&nbsp;= (x<span>3</span>&nbsp;+ 7)} over (F<span><span>p</span></span>)</p>
   <p>或</p>
   <p>y<span>2</span>&nbsp;mod&nbsp;<span>p</span>&nbsp;= (x<span>3</span>&nbsp;+ 7) mod&nbsp;<span>p</span></p>
   <p>上述<span>mod p</span>（素数p取模）表明该曲线是在素数阶<span>p</span>的有限域内，也写作F<span><span>p</span></span>，其中p = 2<span>256</span>&nbsp;– 2<span>32</span>&nbsp;– 2<span>9</span>&nbsp;– 2<span>8</span>&nbsp;– 2<span>7</span>&nbsp;–&nbsp;2<span>6</span>&nbsp;– 2<span>4</span>&nbsp;– 1，这是一个非常大的素数。</p>
   <p>因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散点图，因此很难画图表示。不过，其中的数学原理与实数范围的椭圆曲线相似。作为一个例子，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。而<code>secp256k1</code>的比特币椭圆曲线可以被想象成一个极大的网格上一系列更为复杂的散点。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig403.png"></p>
   <p>图为：椭圆曲线密码学F(<span><span>p</span></span>)上的椭圆曲线，其中p = 17</p>
   <p>下面举一个例子，这是<code>secp256k1</code>曲线上的点P，其坐标为(x，y)。可以使用Python对其检验：</p>
   <pre><code class="hljs ruby">P =（<span class="hljs-number">55066263022277343669578718895168534326250603453777594175500187360389116729240</span>,<span class="hljs-number">32670510020758816978083085130507043184471273380659243275938904335757337482424</span>）Python <span class="hljs-number">3.4</span>.<span class="hljs-number">0</span> (default, Mar <span class="hljs-number">30</span> <span class="hljs-number">2014</span>, <span class="hljs-number">19</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span>)[GCC <span class="hljs-number">4.2</span>.<span class="hljs-number">1</span> Compatible Apple LLVM <span class="hljs-number">5.1</span> (clang-<span class="hljs-number">503.0</span>.<span class="hljs-number">38</span>)] on darwinType <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.<span class="hljs-meta">&gt;&gt;</span>&gt; p = <span class="hljs-number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span><span class="hljs-meta">&gt;&gt;</span>&gt; x = <span class="hljs-number">55066263022277343669578718895168534326250603453777594175500187360389116729240</span><span class="hljs-meta">&gt;&gt;</span>&gt; y = <span class="hljs-number">32670510020758816978083085130507043184471273380659243275938904335757337482424</span><span class="hljs-meta">&gt;&gt;</span>&gt; (x ** <span class="hljs-number">3</span> + <span class="hljs-number">7</span> - y**<span class="hljs-number">2</span>) % p<span class="hljs-number">0</span></code></pre>
   <p>在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。 还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P<span>1</span>和P<span>2</span>，则椭圆曲线上必定有第三点 P<span>3</span>&nbsp;= P<span>1</span>&nbsp;+&nbsp;P<span>2</span>。</p>
   <p>几何图形中，该第三点P<span>3</span>可以在P<span>1</span>和P<span>2</span>之间画一条线来确定。这条直线恰好与椭圆曲线上的一点相交。此点记为 P<span>3</span>'=(x，y)。然后，在x轴做映射获得 P<span>3</span>=(x，-y)。</p>
   <p>下面是几个可以解释“无穷远点”之存在需要的特殊情况。 若 P<span>1</span>和 P<span>2</span>是同一点，P<span>1</span>和P<span>2</span>间的连线则为点P<span>1</span>&nbsp;的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微分求得。即使限制曲线点为两个整数坐标也可求得斜率！</p>
   <p>在某些情况下（即，如果P<span>1</span>和P<span>2</span>具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P<span>3</span>&nbsp;= “无穷远点”。</p>
   <p>若P1就是“无穷远点”，那么其和 P<span>1</span>&nbsp;+ P<span>2</span>= P<span>2</span>。类似地，当P<span>2</span>是无穷远点，则P<span>1</span>+ P<span>2</span>&nbsp;= P<span>1</span>。这就是把无穷远点类似于0的作用。</p>
   <p>事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)C = A(B+C)。这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。</p>
   <p>至此，我们已经定义了椭圆加法，为扩展加法下面我们对乘法进行标准定义。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，k被有时被混淆而称为“指数”。</p>
   <h3 id="4-1-6-%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5"><a></a>4.1.6 生成公钥</h3>
   <p>以一个随机生成的私钥k为起点，我们将其与曲线上已定义的 生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：</p>
   <pre><code class="hljs">{K = k * G}</code></pre>
   <p>其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生）与任何人共享而不会泄露私钥（k）的原因。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br><br>因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。</p>
   </blockquote>
   <p>为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：</p>
   <pre><code class="hljs">K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</code></pre>
   <p>公钥K 被定义为一个点 K = (x, y)：</p>
   <pre><code class="hljs">K = (x, y)其中，x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code></pre>
   <p>为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig0404.png"></p>
   <p>上图显示了在曲线上得到 G、2G、4G 的几何操作。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul() 函数，可计算得到公钥。</p>
   </blockquote>
   <h2 id="4-2-%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80"><a></a>4.2 比特币地址</h2>
   <p>比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。下面是一个比特币地址的例子：</p>
   <pre><code class="hljs">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</code></pre>
   <p>在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人，也就是我们要写入收款人一栏的内容。一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。支票不需要指定一个特定的账户，而是用一个普通的名字作为收款人，这使它成为一种相当灵活的支付工具。与此类似，比特币地址的使用也使比特币交易变得很灵活。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其它东西，比如会在132页的“P2SH (Pay-to-Script-Hash)”一节讲到的付款脚本。现在，让我们来看一个简单的例子，由公钥生成比特币地址。</p>
   <p>比特币地址可由公钥经过单向的加密哈希算法得到。哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，特别是SHA256和RIPEMD160。</p>
   <p>以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160比特（20字节）的数字：</p>
   <pre><code class="hljs">A = RIPEMD160(SHA256(K))</code></pre>
   <p>公式中，K是公钥，A是生成的比特币地址。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>比特币地址与公钥不同。比特币地址是由公钥经过单向的哈希函数生成的。</p>
   </blockquote>
   <p>通常用户见到的比特币地址是经过“Base58Check”编码的（参见72页“Base58和Base58Check编码”一节），这种编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。下一节中我们会详细解释Base58Check的编码机制，以及它产生的结果。下图描述了如何从公钥生成比特币地址。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig405.png"></p>
   <h3 id="4-2-1-base58%E5%92%8Cbase58check%E7%BC%96%E7%A0%81"><a></a>4.2.1 Base58和Base58Check编码</h3>
   <p>为了更简洁方便地表示长串的数字，许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法。例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。一个同样的数字，它的十六进制表示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。Base64通常用于编码邮件中的附件。Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。</p>
   <p>例4-1 比特币的Base58字母表</p>
   <pre><code class="hljs">123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</code></pre>
   <p>Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。</p>
   <p>为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。</p>
   <p>接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法：</p>
   <pre><code class="hljs sql"><span class="hljs-keyword">checksum</span> = SHA256(SHA256(prefix+<span class="hljs-keyword">data</span>))</code></pre>
   <p>在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为校验码。校验码会添加到数据之后。</p>
   <p>结果由三部分组成：前缀、数据和校验码。这个结果采用之前描述的Base58字母表编码。下图描述了Base58Check编码的过程。</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig406.png"></p>
   <blockquote>
    <p>Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式</p>
   </blockquote>
   <p>在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。Base58Check编码中的版本前缀是数据的格式易于辨别，编码之后的数据头包含了明确的属性。这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。表4-1展示了一些版本前缀和他们对应的Base58格式。</p>
   <p><span>表4-1 Base58Check版本前缀和编码后的结果</span></p>
   <table>
    <thead>
     <tr>
      <th>种类</th>
      <th>版本前缀 (hex)</th>
      <th>Base58格式</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>Bitcoin Address</td>
      <td>0x00</td>
      <td>1</td>
     </tr>
     <tr>
      <td>Pay-to-Script-Hash Address</td>
      <td>0x05</td>
      <td>3</td>
     </tr>
     <tr>
      <td>Bitcoin Testnet Address</td>
      <td>0x6F</td>
      <td>m or n</td>
     </tr>
     <tr>
      <td>Private Key WIF</td>
      <td>0x80</td>
      <td>5, K or L</td>
     </tr>
     <tr>
      <td>BIP38 Encrypted Private Key</td>
      <td>0x0142</td>
      <td>6P</td>
     </tr>
     <tr>
      <td>BIP32 Extended Public Key</td>
      <td>0x0488B21E</td>
      <td>xpub</td>
     </tr>
    </tbody>
   </table>
   <p>我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。例4-2的C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。代码中使用“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter03.html#3-3-%E5%85%B6%E4%BB%96%E6%9B%BF%E4%BB%A3%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%81%E8%B5%84%E6%96%99%E5%BA%93%E3%80%81%E5%B7%A5%E5%85%B7%E5%8C%85" rel="nofollow" target="_blank">3.3&nbsp;其他客户端、资料库、工具包&nbsp;</a>”一节中介绍的libbitcoin library来实现某些辅助功能。</p>
   <p>例4-2 从私钥产生一个Base58Check格式编码的比特币地址</p>
   <pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitcoin/bitcoin.hpp&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Private secret key.</span>&nbsp;&nbsp;&nbsp; bc::ec_secret secret = bc::decode_hash(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-string">"038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776"</span>);&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Get public key.</span>&nbsp;&nbsp;&nbsp; bc::ec_point public_key = bc::secret_to_public_key(secret);&nbsp;&nbsp;&nbsp; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Public key: "</span> &lt;&lt; bc::encode_hex(public_key) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Create Bitcoin address.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Normally you can use:</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//&nbsp;&nbsp; bc::payment_address payaddr;</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//&nbsp;&nbsp; bc::set_public_key(payaddr, public_key);</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//&nbsp;&nbsp; const std::string address = payaddr.encoded();</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Compute hash of public key for P2PKH address.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">const</span> bc::short_hash hash = bc::bitcoin_short_hash(public_key);&nbsp;&nbsp;&nbsp; bc::data_chunk unencoded_address; <span class="hljs-comment">// Reserve 25 bytes</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// [ version:1 ]</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// [ hash:20 ]</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//&nbsp;&nbsp; [ checksum:4 ]</span>&nbsp;&nbsp;&nbsp; unencoded_address.reserve(<span class="hljs-number">25</span>);&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Version byte, 0 is normal BTC address (P2PKH).&nbsp;&nbsp;&nbsp;&nbsp; unencoded_address.push_back(0);</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Hash data</span>&nbsp;&nbsp;&nbsp; bc::extend_data(unencoded_address, hash);&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Checksum is computed by hashing data, and adding 4 bytes from hash. bc::append_checksum(unencoded_address);</span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Finally we must encode the result in Bitcoin's base58 encoding assert(unencoded_address.size() == 25);</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> address = bc::encode_base58(unencoded_address);&nbsp;&nbsp;&nbsp; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Address: "</span> &lt;&lt; address &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }</code></pre>
   <p>正如编译并运行addr代码中展示的，由于代码使用预定义的私钥，所以每次运行都会产生相同的比特币地址。如例4-3所示。</p>
   <p>例4-3 编译并运行addr代码</p>
   <pre><code class="hljs ruby"><span class="hljs-comment"># Compile the addr.cpp code</span>$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)<span class="hljs-comment"># Run the addr executable</span>$ ./addrPublic <span class="hljs-symbol">key:</span> <span class="hljs-number">0202</span>a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa <span class="hljs-symbol">Address:</span> <span class="hljs-number">1</span>PRTTaJesdNovgne6Ehcdu1fpEdX7913CK</code></pre>
   <h3 id="4-2-2-%E5%AF%86%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F"><a></a>4.2.2 密钥的格式</h3>
   <p>公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。</p>
   <h4 id="%E7%A7%81%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">私钥的格式</h4>
   <p>私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。</p>
   <p><span>表4-2 私钥表示法（编码格式）</span></p>
   <table>
    <thead>
     <tr>
      <th>种类</th>
      <th>版本</th>
      <th>描述</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>Hex</td>
      <td>None</td>
      <td>64 hexadecimal digits</td>
     </tr>
     <tr>
      <td>WIF</td>
      <td>5</td>
      <td>Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum</td>
     </tr>
     <tr>
      <td>WIF-compressed</td>
      <td>K or L</td>
      <td>As above, with added suffix 0x01 before encoding</td>
     </tr>
    </tbody>
   </table>
   <p>表4-3展示了用这三种格式所生成的私钥。</p>
   <p><span>表4-3 示例：同样的私钥，不同的格式</span></p>
   <table>
    <thead>
     <tr>
      <th>格式</th>
      <th>私钥</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>Hex</td>
      <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</td>
     </tr>
     <tr>
      <td>WIF</td>
      <td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td>
     </tr>
     <tr>
      <td>WIF-compressed</td>
      <td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td>
     </tr>
    </tbody>
   </table>
   <p>这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。</p>
   <h4 id="%E5%B0%86base58check%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">将Base58Check编码解码为十六进制</h4>
   <p>sx工具包（参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter03.html#3-3-1-libbitcoin%E5%92%8Csx-tools" rel="nofollow" target="_blank">3.3.1 Libbitcoin和sx Tools</a>”）可用来编写一些操作比特币密钥、地址及交易的shell脚本和命令行“管道”。你也可以使用sx工具从命令行对Base58Check格式进行解码。</p>
   <p>我们使用的命令是<code>base58check-decode</code>：</p>
   <pre><code class="hljs ruby">$ sx base58check-decode <span class="hljs-number">5</span>J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn<span class="hljs-number">1</span>e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd <span class="hljs-number">128</span></code></pre>
   <p>所得结果是十六进制的密钥，紧接着是钱包导入格式（Wallet Import Format,WIF）的版本前缀128。</p>
   <h4 id="%E5%B0%86%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAbase58check%E7%BC%96%E7%A0%81">将十六进制转换为Base58Check编码</h4>
   <p>要转换成Base58Check编码（和之前的命令正好相反），我们需提供十六进制的私钥和钱包导入格式（Wallet Import Format，WIF）的版本号前缀128：</p>
   <pre><code class="hljs php">$sx base58check-encode <span class="hljs-number">1e99423</span>a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd <span class="hljs-number">128</span> <span class="hljs-number">5</span>J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</code></pre>
   <h4 id="%E5%B0%86%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%EF%BC%88%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E5%AF%86%E9%92%A5%EF%BC%89%E8%BD%AC%E6%8D%A2%E4%B8%BAbase58check%E7%BC%96%E7%A0%81">将十六进制（压缩格式密钥）转换为Base58Check编码</h4>
   <p>要将压缩格式的私钥编码为Base58Check（参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E7%A7%81%E9%92%A5" rel="nofollow" target="_blank">压缩格式私钥</a>”一节），我们需在十六进制私钥的后面添加后缀01，然后使用跟上面一样的方法：</p>
   <pre><code class="hljs ruby">$ sx base58check-encode <span class="hljs-number">1</span>e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 <span class="hljs-number">128</span>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</code></pre>
   <p>生成的WIF压缩格式的私钥以字母“K”开头，用以表明被编码的私钥有一个后缀“01”，且该私钥只能被用于生成压缩格式的公钥（参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E5%85%AC%E9%92%A5" rel="nofollow" target="_blank">压缩格式公钥</a>”一节）。</p>
   <h4 id="%E5%85%AC%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">公钥的格式</h4>
   <p>公钥也可以用多种不同格式来表示，最重要的是它们分为非压缩格式或压缩格式公钥这两种形式。</p>
   <p>我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。</p>
   <p>下面是由前文中的私钥所生成的公钥，其坐标x和y如下：</p>
   <pre><code class="hljs">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code></pre>
   <p>下面是同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y：</p>
   <pre><code class="hljs">K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code></pre>
   <h4 id="%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E5%85%AC%E9%92%A5">压缩格式公钥</h4>
   <p>引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭据和支付比特币。每个公钥有520比特（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。</p>
   <p>正如我们在“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-1-4-%E5%85%AC%E9%92%A5" rel="nofollow" target="_blank">4.1.4 公钥</a>”一节所见，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y<span>2</span>mod&nbsp;p = (x<span>3</span>&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。</p>
   <p>未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲线加密的公式的左边是y<span>2</span>&nbsp;，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。下图阐释了公钥压缩：</p>
   <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig407.png"></p>
   <p>下面是前述章节所生成的公钥，使用了264比特（66个十六进制数字）的压缩格式公钥格式，其中前缀03表示y坐标是一个奇数：</p>
   <pre><code class="hljs">K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</code></pre>
   <p>这个压缩格式公钥对应着同样的一个私钥，这意味它是由同样的私钥所生成。但是压缩格式公钥和非压缩格式公钥差别很大。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，因为一个私钥可以生成两种不同格式的公钥——压缩格式和非压缩格式，而这两种格式的公钥可以生成两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。</p>
   <p>压缩格式公钥渐渐成为了各种不同的比特币客户端的默认格式，它可以大大减少交易所需的字节数，同时也让存储区块链所需的磁盘空间变小。然而，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。这在钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入私钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？新客户端不知道应该使用哪个公钥：因为不论是通过压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址，两个都是合法的比特币地址，都可以被私钥正确签名，但是他们是完全不同的比特币地址。</p>
   <p>为了解决这个问题，当私钥从钱包中被导出时，较新的比特币客户端将使用一种不同的钱包导入格式（Wallet Import Format）。这种新的钱包导入格式可以用来表明该私钥已经被用来生成压缩的公钥，同时生成的比特币地址也是基于该压缩的公钥。这个方案可以解决导入私钥来自于老钱包还是新钱包的问题，同时也解决了通过公钥生成的比特币地址是来自于压缩格式公钥还是非压缩格式公钥的问题。最后新钱包在扫描区块链时，就可以使用对应的比特币地址去查找该比特币地址在区块链里所发生的交易。我们将在下一节详细解释这种机制是如何工作的。</p>
   <h4 id="%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E7%A7%81%E9%92%A5">压缩格式私钥</h4>
   <p>实际上“压缩格式私钥”是一种名称上的误导，因为当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩的公钥。私钥是非压缩的，也不能被压缩。“压缩的私钥”实际上只是表示“用于生成压缩格式公钥的私钥”，而“非压缩格式私钥”用来表明“用于生成非压缩格式公钥的私钥”。为避免更多误解，应该只可以说导出格式是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。</p>
   <p>要注意的是，这些格式并不是可互换使用的。在较新的实现了压缩格式公钥的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥将只能被导出为WIF格式（以5为前缀）导出。这样做的目的就是为了给导入这些私钥的钱包一个信号：到底是使用压缩格式公钥和比特币地址去扫描区块链，还是使用非压缩格式公钥和比特币地址。</p>
   <p>如果一个比特币钱包实现了压缩格式公钥，那么它将会在所有交易中使用该压格式缩公钥。钱包中的私钥将会被用来生成压缩格式公钥，压缩格式公钥然后被用来生成交易中的比特币地址。当从一个实现了压缩格式公钥的比特币钱包导出私钥时，钱包导入格式（WIF）将会被修改为WIF压缩格式，该格式将会在私钥的后面附加一个字节大小的后缀01。最终的Base58Check编码格式的私钥被称作WIF（“压缩”）私钥，以字母“K”或“L”开头。而以“5”开头的是从较老的钱包中以WIF（非压缩）格式导出的私钥。</p>
   <p>表4-4展示了同样的私钥使用不同的WIF和WIF压缩格式编码。</p>
   <p><span>表4-4 示例：同样的私钥，不同的格式</span></p>
   <table>
    <thead>
     <tr>
      <th>格式</th>
      <th>私钥</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>Hex</td>
      <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</td>
     </tr>
     <tr>
      <td>WIF</td>
      <td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td>
     </tr>
     <tr>
      <td>Hex-compressed</td>
      <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD<span>01</span></td>
     </tr>
     <tr>
      <td>WIF-compressed</td>
      <td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td>
     </tr>
    </tbody>
   </table>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>“压缩格式私钥”是一个不当用词！私钥不是压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩的公钥和对应的比特币地址。相反地，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”私钥和“压缩格式”私钥。</p>
   </blockquote>
   <h2 id="4-3-%E7%94%A8python%E5%AE%9E%E7%8E%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80"><a></a>4.3 用Python实现密钥和比特币地址</h2>
   <p>最全面的比特币Python库是 Vitalik Buterin写的&nbsp;<a href="https://github.com/vbuterin/pybitcointools" rel="nofollow" target="_blank">pybitcointools</a>。在例4-4中，我们使用pybitcointools库（导入为“bitcoin”）来生成和显示不同格式的密钥和比特币地址。</p>
   <p><span>例4-4 使用pybitcointools库的密钥和比特币地址的生成和格式化过</span></p>
   <pre><code class="hljs python"><span class="hljs-keyword">import</span> bitcoin<span class="hljs-comment"># Generate a random private key</span>valid_private_key = <span class="hljs-keyword">False</span> <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> valid_private_key:&nbsp;&nbsp;&nbsp; private_key = bitcoin.random_key()&nbsp;&nbsp;&nbsp; decoded_private_key = bitcoin.decode_privkey(private_key, <span class="hljs-string">'hex'</span>)&nbsp;&nbsp;&nbsp; valid_private_key =&nbsp; <span class="hljs-number">0</span> &lt; decoded_private_key &lt; bitcoin.N<span class="hljs-keyword">print</span> <span class="hljs-string">"Private Key (hex) is: "</span>, private_key<span class="hljs-keyword">print</span> <span class="hljs-string">"Private Key (decimal) is: "</span>, decoded_private_key<span class="hljs-comment"># Convert private key to WIF format</span>wif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, <span class="hljs-string">'wif'</span>)<span class="hljs-keyword">print</span> <span class="hljs-string">"Private Key (WIF) is: "</span>, wif_encoded_private_key<span class="hljs-comment"># Add suffix "01" to indicate a compressed private key</span>compressed_private_key = private_key + <span class="hljs-string">'01'</span><span class="hljs-keyword">print</span> <span class="hljs-string">"Private Key Compressed (hex) is: "</span>, compressed_private_key<span class="hljs-comment"># Generate a WIF format from the compressed private key (WIF-compressed)</span>wif_compressed_private_key = bitcoin.encode_privkey(&nbsp;&nbsp;&nbsp; bitcoin.decode_privkey(compressed_private_key, <span class="hljs-string">'hex'</span>), <span class="hljs-string">'wif'</span>)<span class="hljs-keyword">print</span> <span class="hljs-string">"Private Key (WIF-Compressed) is: "</span>, wif_compressed_private_key<span class="hljs-comment"># Multiply the EC generator point G with the private key to get a public key point</span>public_key = bitcoin.base10_multiply(bitcoin.G, decoded_private_key) <span class="hljs-keyword">print</span> <span class="hljs-string">"Public Key (x,y) coordinates is:"</span>, public_key<span class="hljs-comment"># Encode as hex, prefix 04</span>hex_encoded_public_key = bitcoin.encode_pubkey(public_key,<span class="hljs-string">'hex'</span>) <span class="hljs-keyword">print</span> <span class="hljs-string">"Public Key (hex) is:"</span>, hex_encoded_public_key<span class="hljs-comment"># Compress public key, adjust prefix depending on whether y is even or odd</span>(public_key_x, public_key_y) = public_key <span class="hljs-keyword">if</span> (public_key_y % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>:&nbsp;&nbsp;&nbsp; compressed_prefix = <span class="hljs-string">'02'</span> <span class="hljs-keyword">else</span>:&nbsp;&nbsp;&nbsp; compressed_prefix = <span class="hljs-string">'03'</span>hex_compressed_public_key = compressed_prefix + bitcoin.encode(public_key_x, <span class="hljs-number">16</span>) <span class="hljs-keyword">print</span> <span class="hljs-string">"Compressed Public Key (hex) is:"</span>, hex_compressed_public_key<span class="hljs-comment"># Generate bitcoin address from public key</span><span class="hljs-keyword">print</span> <span class="hljs-string">"Bitcoin Address (b58check) is:"</span>, bitcoin.pubkey_to_address(public_key)<span class="hljs-comment"># Generate compressed bitcoin address from compressed public key</span><span class="hljs-keyword">print</span> <span class="hljs-string">"Compressed Bitcoin Address (b58check) is:"</span>, \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitcoin.pubkey_to_address(hex_compressed_public_key)</code></pre>
   <p>例4-5显示了上段代码运行结果。</p>
   <p><span>例4-5 运行 key-to-address-ecc-example.py</span></p>
   <pre><code class="hljs vbnet">$ python <span class="hljs-keyword">key</span>-<span class="hljs-keyword">to</span>-address-ecc-example.py<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Key</span> (hex) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">3</span>aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Key</span> (<span class="hljs-built_in">decimal</span>) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">26563230048437957592232553826663696440606756685920117476832299673293013768870</span><span class="hljs-keyword">Private</span> <span class="hljs-keyword">Key</span> (WIF) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">5</span>JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Key</span> Compressed (hex) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">3</span>aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Key</span> (WIF-Compressed) <span class="hljs-keyword">is</span>:&nbsp;KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S<span class="hljs-keyword">Public</span> <span class="hljs-keyword">Key</span> (x,y) coordinates <span class="hljs-keyword">is</span>:&nbsp;(<span class="hljs-number">41637322786646325214887832269588396900663353932545912953362782457239403430124</span>L,&nbsp;<span class="hljs-number">16388935128781238405526710466724741593761085120864331449066658622400339362166</span>L)<span class="hljs-keyword">Public</span> <span class="hljs-keyword">Key</span> (hex) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">045</span>c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵<span class="hljs-number">243</span>bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176Compressed <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Key</span> (hex) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">025</span>c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ecBitcoin Address (b58check) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">1</span>thMirt546nngXqyPEz532S8fLwbozud8Compressed Bitcoin Address (b58check) <span class="hljs-keyword">is</span>:&nbsp;<span class="hljs-number">14</span>cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3</code></pre>
   <p>例4-6是另外一个示例，使用的是Python ECDSA库来做椭圆曲线计算而非使用bitcoin的库。</p>
   <p><span>例4-6 使用在比特币密钥中的椭圆曲线算法的脚本</span></p>
   <pre><code class="hljs python"><span class="hljs-keyword">import</span> ecdsa<span class="hljs-keyword">import</span> random<span class="hljs-keyword">from</span> ecdsa.util <span class="hljs-keyword">import</span> string_to_number, number_to_string<span class="hljs-comment"># secp256k1, http://www.oid-info.com/get/1.3.132.0.10</span>_p = <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL</span>_r = <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L</span>_b = <span class="hljs-number">0x0000000000000000000000000000000000000000000000000000000000000007L</span>_a = <span class="hljs-number">0x0000000000000000000000000000000000000000000000000000000000000000L</span>_Gx = <span class="hljs-number">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L</span>_Gy = <span class="hljs-number">0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L</span>curve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b)generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)oid_secp256k1 = (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">132</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)SECP256k1 = ecdsa.curves.Curve(<span class="hljs-string">"SECP256k1"</span>, curve_secp256k1, generator_secp256k1,oid_secp256k1)ec_order = _rcurve = curve_secp256k1generator = generator_secp256k1<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_secret</span><span class="hljs-params">()</span>:</span>&nbsp;&nbsp;&nbsp; random_char = <span class="hljs-keyword">lambda</span>: chr(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>))&nbsp;&nbsp;&nbsp; convert_to_int = <span class="hljs-keyword">lambda</span> array:&nbsp;&nbsp;&nbsp;&nbsp; int(<span class="hljs-string">""</span>.join(array).encode(<span class="hljs-string">"hex"</span>), <span class="hljs-number">16</span>) &nbsp;&nbsp;&nbsp; byte_array = [random_char() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>)]&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> convert_to_int(byte_array)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_point_pubkey</span><span class="hljs-params">(point)</span>:</span> &nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> point.y() &amp; <span class="hljs-number">1</span>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = <span class="hljs-string">'03'</span> + <span class="hljs-string">'%064x'</span> % point.x() &nbsp;&nbsp;&nbsp; <span class="hljs-keyword">else</span>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = <span class="hljs-string">'02'</span> + <span class="hljs-string">'%064x'</span> % point.x() &nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> key.decode(<span class="hljs-string">'hex'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_point_pubkey_uncompressed</span><span class="hljs-params">(point)</span>:</span> &nbsp;&nbsp;&nbsp; key=<span class="hljs-string">'04'</span>+\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-string">'%064x'</span> % point.x() + \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-string">'%064x'</span> % point.y() &nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> key.decode(<span class="hljs-string">'hex'</span>)<span class="hljs-comment"># Generate a new private key.</span>secret = random_secret() <span class="hljs-keyword">print</span> <span class="hljs-string">"Secret: "</span>, secret<span class="hljs-comment"># Get the public key point.</span>point = secret * generator <span class="hljs-keyword">print</span> <span class="hljs-string">"EC point:"</span>, point<span class="hljs-keyword">print</span> <span class="hljs-string">"BTC public key:"</span>, get_point_pubkey(point).encode(<span class="hljs-string">"hex"</span>)<span class="hljs-comment"># Given the point (x, y) we can create the object using:</span>point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order) <span class="hljs-keyword">assert</span> point1 == point</code></pre>
   <p>例4-7显示了运行脚本的结果。</p>
   <p><span>例4-7 安装Python ECDSA库，运行ec_math.py脚本</span></p>
   <pre><code class="hljs ruby">running the ec_math.py script$ <span class="hljs-comment"># Install Python PIP package manager</span>$ sudo apt-get install python-pip$ <span class="hljs-comment"># Install the Python ECDSA library</span>$ sudo pip install ecdsa$ <span class="hljs-comment"># Run the script</span>$ python ec-math.py<span class="hljs-symbol">Secret:</span><span class="hljs-number">38090835015954358862481132628887443905906204995912378278060168703580660294000</span>EC <span class="hljs-symbol">point:</span>(<span class="hljs-number">70048853531867179489857750497606966272382583471322935454624595540007269312627</span>,<span class="hljs-number">105262206478686743191060800263479589329920209527285803935736021686045542353380</span>)BTC public <span class="hljs-symbol">key:</span> <span class="hljs-number">02</span>9ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873</code></pre>
   <h2 id="4-4-%E6%AF%94%E7%89%B9%E5%B8%81%E9%92%B1%E5%8C%85"><a></a>4.4 比特币钱包</h2>
   <p>钱包是私钥的容器，通常通过有序文件或者简单的数据库实现。另外一种制作私钥的途径是 确定性密钥生成。在这里你可以用原先的私钥，通过单向哈希函数来生成每一个新的私钥，并将新生成的密钥按顺序连接。只要你可以重新创建这个序列，你只需要第一个私钥（称作种子、主私钥）来生成它们。在本节中，我们将会检查不同的私钥生成方法及其钱包结构。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。</p>
   </blockquote>
   <h3 id="4-4-1-%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%EF%BC%88%E9%9A%8F%E6%9C%BA%EF%BC%89%E9%92%B1%E5%8C%85"><a></a>4.4.1 非确定性（随机）钱包</h3>
   <p>在最早的一批比特币客户端中，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。举个例子，比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每把钥匙只使用一次。这种类型的钱包有一个昵称“Just a Bunch Of Keys（一堆私钥）”简称JBOK。这种钱包现在正在被确定性钱包替换，因为它们难以管理、备份以及导入。随机钥匙的缺点就是如果你生成很多，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性地备份。每一把钥匙都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址通过关联多重交易和对方的地址重复使用会减少隐私。0型非确定性钱包并不是钱包的好选择，尤其是当你不想重复使用地址而创造过多的私钥并且要保存它们。虽然比特币核心客户包含0型钱包，但比特币的核心开发者并不想鼓励大家使用。下图表示包含有松散结构的随机钥匙的集合的非确定性钱包。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig408.png"></p>
   </blockquote>
   <h3 id="4-4-2-%E7%A1%AE%E5%AE%9A%E6%80%A7%EF%BC%88%E7%A7%8D%E5%AD%90%EF%BC%89%E9%92%B1%E5%8C%85"><a></a>4.4.2 确定性（种子）钱包</h3>
   <p>确定性，或者“种子”钱包包含通过使用单项离散方程而可从公共的种子生成的私钥。种子是随机生成的数字。这个数字也含有比如索引号码或者可生成私钥的“链码”（参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-4-4-%E5%88%86%E5%B1%82%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%92%B1%E5%8C%85%EF%BC%88bip0032-bip0044%EF%BC%89" rel="nofollow" target="_blank">4.4.4&nbsp;分层确定性钱包（BIP0032/BIP0044）</a>”一节）。在确定性钱包中，种子足够收回所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包输入或者输出。这就很容易允许使用者的私钥在钱包之间轻松转移输入。</p>
   <h3 id="4-4-3-%E5%8A%A9%E8%AE%B0%E7%A0%81%E8%AF%8D%E6%B1%87"><a></a>4.4.3 助记码词汇</h3>
   <p>助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。单词的顺序就是钱包的备份。它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的钥匙。助记码代码可以让使用者复制钱包更容易一些，因为它们相比较随机数字顺序来说，可以很容易地被读出来并且正确抄写。</p>
   <p>助记码被定义在比特币的改进建议39中（参见"<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#%E9%99%84%E5%BD%95%EF%BC%92-%E6%AF%94%E7%89%B9%E5%B8%81%E6%94%B9%E8%BF%9B%E5%8D%8F%E8%AE%AE" rel="nofollow" target="_blank">附录２ 比特币改进协议[bip0039]</a>”），目前还处于草案状态。需注意的是，BIP0039是一个建议草案而不是标准方案。具体地来说，电子钱包和BIP0039使用不同的标准且对应不同组的词汇。Trezor钱包以及一些其他钱包使用BIP0039，但是BIP0039和电子钱包的运行不兼容。</p>
   <p>BIP0039定义助记码和种子的创建过程如下：</p>
   <p>1.创造一个128到256位的随机顺序（熵）。&nbsp;<br>2.提出SHA256哈希前几位，就可以创造一个随机序列的校验和。&nbsp;<br>3.把校验和加在随机顺序的后面。&nbsp;<br>4.把顺序分解成11位的不同集合，并用这些集合去和一个预先已经定义的2048个单词字典做对应。&nbsp;<br>5.生成一个12至24个词的助记码。</p>
   <p>表4-5表示了熵数据的大小和助记码单词的长度之间的关系。</p>
   <p><span>表4-5 助记码：熵及字段长度</span></p>
   <table>
    <thead>
     <tr>
      <th>熵（bits）</th>
      <th>校验符（bits）</th>
      <th>熵＋校验符</th>
      <th>字段长</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>128</td>
      <td>4</td>
      <td>132</td>
      <td>12</td>
     </tr>
     <tr>
      <td>160</td>
      <td>5</td>
      <td>165</td>
      <td>15</td>
     </tr>
     <tr>
      <td>192</td>
      <td>6</td>
      <td>198</td>
      <td>18</td>
     </tr>
     <tr>
      <td>224</td>
      <td>7</td>
      <td>231</td>
      <td>21</td>
     </tr>
     <tr>
      <td>256</td>
      <td>8</td>
      <td>264</td>
      <td>24</td>
     </tr>
    </tbody>
   </table>
   <p>助记码表示128至256位数。这可以通过使用私钥抻拉函数PBKDF2来导出更长的（512位）的种子。所得的种子可以用来创造一个确定性钱包以及其所派生的所有钥匙。</p>
   <p>表4-6和表4-7展示了一些助记码的例子和它所生成的种子。</p>
   <p><span>表4-6 128位熵的助记码以及所产生的种子</span></p>
   <table>
    <thead>
     <tr>
      <th><span>负熵输入 (128 bits)</span></th>
      <th>0c1e24e5917779d297e14d45f14e1a1a</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><span>助记码 (12 个单词)</span></td>
      <td><span>army van defense carry jealous true garbage claim echo media make crunch</span></td>
     </tr>
     <tr>
      <td><span>种子 (512 bits) 　　　　　　　　　</span></td>
      <td><span>3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88 8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf</span></td>
     </tr>
    </tbody>
   </table>
   <p><span>表4-7 256位熵的助记码以及所产生的种子</span></p>
   <table>
    <thead>
     <tr>
      <th><span>负熵输入 (256 bits)</span></th>
      <th>2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><span>助记码 (24个单词)</span></td>
      <td><span>cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige</span></td>
     </tr>
     <tr>
      <td><span>种子 (512 bits) 　　　　　　　　　</span></td>
      <td><span>3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22 fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343</span></td>
     </tr>
    </tbody>
   </table>
   <h3 id="4-4-4-%E5%88%86%E5%B1%82%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%92%B1%E5%8C%85%EF%BC%88bip0032-bip0044%EF%BC%89"><a></a>4.4.4 分层确定性钱包（BIP0032/BIP0044）</h3>
   <p>确定性钱包被开发成更容易从单个“种子”中生成许多关键的钥匙。最高级的来自确定性钱包的形是通过BIP0032标准生成的 the hierarchical deterministic wallet or HD wallet defined。分层确定性钱包包含从数结构所生成的钥匙。这种母钥匙可以生成子钥匙的序列。这些子钥匙又可以衍生出孙钥匙，以此无穷类推。这个树结构表如下图所示。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig409.png"></p>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>如果你想安装运行一个比特币钱包，你需要建造一个符合BIP0032和BIP0044标准的HD钱包。</p>
   </blockquote>
   <p>HD钱包提供了随机（不确定性）钥匙有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门，子公司，具体功能以及会计类别。</p>
   <p>HD钱包的第二个好处就是它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，但是在服务器中不具有可用来支付的私钥。</p>
   <h4 id="%E4%BB%8E%E7%A7%8D%E5%AD%90%E4%B8%AD%E5%88%9B%E9%80%A0hd%E9%92%B1%E5%8C%85">从种子中创造HD钱包</h4>
   <p>HD钱包从单个root seed中创建，为128到256位的随机数。HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。根种子一般总是被表示为a mnemonic word sequence，正如"<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-4-3-%E5%8A%A9%E8%AE%B0%E7%A0%81%E8%AF%8D%E6%B1%87" rel="nofollow" target="_blank">4.4.3&nbsp;助记码词汇</a>"一节所表述的，助记码词汇可以让人们更容易地抄写和储存。</p>
   <p>创建主密钥以及HD钱包地主链代码的过程如下图所示。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig410.png"></p>
   </blockquote>
   <p>根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造master private key(m) 和 a master chain code的哈希。主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线<code>m * G</code>过程生来成相对应的主公钥（M）。链代码可以给从母密钥中创造子密钥的那个方程中引入的熵。</p>
   <h4 id="%E7%A7%81%E6%9C%89%E5%AD%90%E5%AF%86%E9%92%A5%E7%9A%84%E8%A1%8D%E7%94%9F">私有子密钥的衍生</h4>
   <p>分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。</p>
   <p>子密钥衍生方程是基于单项哈希方程。这个方程结合了：</p>
   <p>• 一个母私钥或者公共钥匙（ECDSA未压缩键）&nbsp;<br>• 一个叫做链码（256 bits）的种子&nbsp;<br>• 一个索引号（32 bits）</p>
   <p>链码是用来给这个过程引入看似的随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的相似子密钥，除非你已经有了链码。最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。</p>
   <p>这三个项目相结合并散列可以生成子密钥，如下。</p>
   <p>母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512方程散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。在图4-11中，我们看到这种这个说明——索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig411.png">图4-11 延长母私钥去创造子私钥</p>
   </blockquote>
   <p>改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。比如子0，子1，子2等等。每一个母密钥可以右20亿个子密钥。</p>
   <p>向密码树下一层重复这个过程，每个子密钥可以依次成为母密钥继续创造它自己的子密钥，直到无限代。</p>
   <h4 id="%E4%BD%BF%E7%94%A8%E8%A1%8D%E7%94%9F%E7%9A%84%E5%AD%90%E5%AF%86%E9%92%A5">使用衍生的子密钥</h4>
   <p>子私钥不能从非确定性（随机）密钥中被区分出来。因为衍生方程是单向方程，所以子密钥不能被用来发现他们的母密钥。子密钥也不能用来发现他们的相同层级的姊妹密钥。如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。只有母密钥以及链码才能得到所有的子密钥。没有子链码的话，子密钥也不能用来衍生出任何孙密钥。你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。</p>
   <p>那子私钥自己可被用做什么呢？它可以用来做公共钥匙和比特币地址。之后它就可以被用那个地址来签署交易和支付任何东西。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>子密钥、对应的公共钥匙以及比特币地址都不能从随机创造的密钥和地址中被区分出来。事实是它们所在的序列，在创造他们的HD钱包方程之外是不可见的。一旦被创造出来，它们就和“正常”钥匙一样运行了。</p>
   </blockquote>
   <h4 id="%E6%89%A9%E5%B1%95%E5%AF%86%E9%92%A5">扩展密钥</h4>
   <p>正如我们之前看到的，密钥衍生方程可以被用来创造钥匙树上任何层级的子密钥。这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做extended key。术语“extended key”也被认为是“可扩展的密钥”是因为这种密钥可以用来衍生子密钥。</p>
   <p>扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。有两种扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公共密钥）公共钥匙以及链码组成扩展公共钥匙。这个钥匙可以用来扩展子公共钥匙，见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-1-6-%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5" rel="nofollow" target="_blank">4.1.6&nbsp;生成公钥</a>”。</p>
   <p>想象一个扩展密钥作为HD钱包中钥匙树结构的一个分支的根。你可以衍生出这个分支的剩下所有部分。扩展私人钥匙可以创建一个完整的分支而扩展公共钥匙只能够创造一个公共钥匙的分支。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>一个扩展钥匙包括一个私钥（或者公共钥匙）以及一个链码。一个扩展密钥可以创造出子密钥并且能创造出在钥匙树结构中的整个分支。分享扩展钥匙就可以访问整个分支。</p>
   </blockquote>
   <p>扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP0032-兼容钱包之间导入导出。扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check-encoded串更长一些。</p>
   <p>这是一个在Base58Check中编码的扩展私钥的例子：</p>
   <pre><code class="hljs">xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</code></pre>
   <p>这是在Base58Check中编码的对应的扩展公共钥匙：</p>
   <pre><code class="hljs">xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</code></pre>
   <h4 id="%E5%85%AC%E5%85%B1%E5%AD%90%E9%92%A5%E5%8C%99%E6%8E%A8%E5%AF%BC">公共子钥匙推导</h4>
   <p>正如之前提到的，分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从公共母钥匙派生出公共子钥匙的能力。这就给了我们两种去衍生子公共钥匙的方法：或者通过子私钥，再或者就是直接通过母公共钥匙。</p>
   <p>因此，扩展的公共钥匙可以再HD钱包结构的分支中，被用来衍生所有的公钥（且只有公共钥匙）。</p>
   <p>这种快捷方式可以用来创造非常保密的public-key-only配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公共钥匙的副本。这种配置可以创造出无限数量的公共钥匙以及比特币地址。但是不可以花送到这个地址里的任何比特币。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p>
   <p>这种方案的一个常见的方案是安装一个扩展的公共钥匙在服务电商公共程序的网络服务器上。网络服务器可以使用这个公共钥匙衍生方程去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。但为了避免被偷，网络服务商不会有任何私钥。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后就提前上传到电商服务器上。这种方法比较繁琐而且要求持续的维护来确保电商服务器不“用光”公共钥匙。</p>
   <p>这种解决方案的另一种常见的应用是冷藏或者硬件钱包。在这种情况下，扩展的私钥可以被储存在纸质钱包中或者硬件设备中（比如 Trezor 硬件钱包）与此同时扩展公共钥匙可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下被保存。为了支付资金，使用者可以使用扩展的私钥离线签署比特币客户或者通过硬件钱包设备（比如Trezor）签署交易。图4-12阐述了扩展母公共钥匙来衍生子公共钥匙的传递机制。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig412.png">图4-12 扩展母公共钥匙来创造一个子公共钥匙</p>
   </blockquote>
   <h4 id="%E7%A1%AC%E5%8C%96%E5%AD%90%E5%AF%86%E9%92%A5%E7%9A%84%E8%A1%8D%E7%94%9F">硬化子密钥的衍生</h4>
   <p>从扩展公共钥匙衍生一个分支公共钥匙的能力是很重要的，但牵扯一些风险。访问扩展公共钥匙并不能得到访问子私人密钥的途径。但是，因为扩展公共钥匙包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。一个简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>
   <p>为了应对这种风险，HD钱包使用一种叫做hardened derivation的替代衍生方程。这就“打破”了母公共钥匙以及子链码之间的关系。这个硬化衍生方程使用了母私钥去推到子链码，而不是母公共钥匙。这就在母/子顺序中创造了一道“防火墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化的衍生方程看起来几乎与一般的衍生的子私钥相同，不同的是是母私钥被用来输入散列方程中而不是母公共钥匙，如图4-13所示。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig413.png">图4-13 子密钥的强化衍生；忽略了母公共密钥</p>
   </blockquote>
   <p>当强化私钥衍生方程被使用时，得到的子私钥以及链码与使用一般衍生方程所得到的结果完全不同的。得到的密钥“分支”可以被用来生产不易被攻击的扩展公共钥匙，因为它所含的链码不能被用来开发或者暴露任何私钥。强化的衍生也因此被用来在上一层级，使用扩展公共钥匙的的密钥树中创造“间隙”。</p>
   <p>简单地来说，如果你想要利用扩展公共钥匙的便捷来衍生公共钥匙的分支而不将你自己暴露在泄露扩展链码的风险下，你应该从强化母私钥，而不是一般的母私钥，来衍生公共钥匙。最好的方式是，为了避免了推到出主钥匙，主钥匙所衍生的第一层级的子钥匙最好使用强化衍生。</p>
   <h4 id="%E6%AD%A3%E5%B8%B8%E8%A1%8D%E7%94%9F%E5%92%8C%E5%BC%BA%E5%8C%96%E8%A1%8D%E7%94%9F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%B7%E7%A0%81">正常衍生和强化衍生的索引号码</h4>
   <p>用在衍生方程中的索引号码是32位的整数。为了区分密钥是从正常衍生方程中衍生出来还是从强化衍生方程中产出，这个索引号被分为两个范围。索引号在0和2<span>31</span>–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2<span>31</span>和2<span>32</span>–1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生方程。因此，索引号小于2<span>31</span>就意味着子密钥是常规的，而大于或者等于2<span>31</span>的子密钥就是强化型的。</p>
   <p>为了让索引号码更容易被阅读和展示，强化子密码的索引号码是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥因此被表述为0，但是第一个强化子密钥（索引号为0x80000000）就被表示为0'。第二个强化密钥依序有了索引号0x80000001，且被显示为1'，以此类推。当你看到HD钱包索引号i'，这就意味着 2<span>31</span>+i。</p>
   <h4 id="hd%E9%92%B1%E5%8C%85%E5%AF%86%E9%92%A5%E8%AF%86%E5%88%AB%E7%AC%A6%EF%BC%88%E8%B7%AF%E5%BE%84%EF%BC%89">HD钱包密钥识别符（路径）</h4>
   <p>HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表4-8）。由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。</p>
   <p>密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。</p>
   <p><span>表4-8 HD钱包路径的例子</span></p>
   <table>
    <thead>
     <tr>
      <th>HD path</th>
      <th>密钥描述</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>m/0</td>
      <td>从主私钥（m）衍生出的第一个（0）子密钥。</td>
     </tr>
     <tr>
      <td>m/0/0</td>
      <td>第一个私人子密钥（m/0）的子密钥。</td>
     </tr>
     <tr>
      <td>m/0'/0</td>
      <td>第一个子强化密钥first hardened child（m/0'）的第一个常规子密钥。</td>
     </tr>
     <tr>
      <td>m/1/0</td>
      <td>第2个子密钥（m/1）的第一个常规子密钥</td>
     </tr>
     <tr>
      <td>M/23/17/0/0</td>
      <td>主密钥衍生出的第24个子密钥所衍生出的第17个子密钥的第一个子密钥所衍生出的第一个子密钥。</td>
     </tr>
    </tbody>
   </table>
   <h4 id="hd%E9%92%B1%E5%8C%85%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%AF%BC%E8%88%AA">HD钱包树状结构的导航</h4>
   <p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40已个子密钥：20亿个常规子密钥和20亿个强化子密钥。而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的。</p>
   <p>两个比特币改进建议（BIPs）提供了这个复杂问的解决办法——通过创建几个HD钱包树的提议标准。BIP0043提出使用第一个强化子索引作为特殊的标识符表示树状结构的“purpose”。基于BIP0043，HD钱包应该使用且只用第一层级的树的分支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个例子，HD钱包只使用分支m/i'/是为了表明那个被索引号“i”定义的特殊为目地。</p>
   <p>在BIP0043标准下，为了延长的那个特殊规范，BIP0044提议了多账户结构作为“purpose”。所有遵循BIP0044的HD钱包依据只使用树的第一个分支的要求而被定义：m/44'/。</p>
   <p>BIP0044指定了包含5个预定义树状层级的结构：</p>
   <pre><code class="hljs go">m / purpose<span class="hljs-string">' / coin_type'</span> / account<span class="hljs-string">' / change / address_index</span></code></pre>
   <p>第一层的目的地总是被设定为44'。第二层的“coin_type”特指密码货币硬币的种类并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m/44'/0'、Bitcoin Testnet is m/44'/1'，以及Litecoin is m/44'/2'。</p>
   <p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。举个例子，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个账户都是它自己亚树的根。</p>
   <p>第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在可供不安全环境下，输出扩展的公共钥匙。被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44'/0'/0'/0/2。表4-9展示了更多的例子。</p>
   <p><span>表4-9 BIP0044 HD 钱包结构的例子</span></p>
   <table>
    <thead>
     <tr>
      <th>HD 路径</th>
      <th>主要描述</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>M/44'/0'/0'/0/2</td>
      <td>第三个收到公共钥匙的主比特币账户</td>
     </tr>
     <tr>
      <td>M/44'/0'/3'/1/14</td>
      <td>第十五改变地址公钥的第四个比特币账户</td>
     </tr>
     <tr>
      <td>m/44'/2'/0'/0/1</td>
      <td>为了签署交易的在莱特币主账户的第二个私钥</td>
     </tr>
    </tbody>
   </table>
   <h4 id="%E4%BD%BF%E7%94%A8%E6%AF%94%E7%89%B9%E5%B8%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E9%AA%8C%E6%AF%94%E7%89%B9%E5%B8%81%E9%92%B1%E5%8C%85">使用比特币浏览器实验比特币钱包</h4>
   <p>依据第3章介绍的使用比特币浏览管理器命令工具，你可以试着生产和延伸BIP0032确定性密钥以及将它们用不同的格式进行展示：</p>
   <pre><code class="hljs ruby">$ sx hd-seed &gt; m <span class="hljs-comment"># create a new master private key from a seed and store in file "m"</span>$ cat m <span class="hljs-comment"># show the master extended private key</span>￼<span class="hljs-number">96</span> <span class="hljs-params">| Chapter 4: Keys, Addresses, Walletsxprv9s21ZrQH143K38iQ9Y5p6qoB8C75TE71NfpyQPdfGvzghDt39DHPFpovvtWZaR- gY5uPwV7RpEgHs7cvdgfiSjLjjbuGKGcjRyU7RGGSS8Xa$ cat m |</span> sx hd-pub <span class="hljs-number">0</span> <span class="hljs-comment"># generate the M/0 extended public key xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KE- CeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</span>$ cat m <span class="hljs-params">| sx hd-priv 0 # generate the m/0 extended private key xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CA- WrUE9i6GoNMKUga5biW6Hx4tws2six3b9c$ cat m |</span> sx hd-priv <span class="hljs-number">0</span> <span class="hljs-params">| sx hd-to-wif # show the private key of m/0 as a WIF L1pbvV86crAGoDzqmgY85xURkz3c435Z9nirMt52UbnGjYMzKBUN$ cat m |</span> sx hd-pub <span class="hljs-number">0</span> <span class="hljs-params">| sx hd-to-address # show the bitcoin address of M/0 1CHCnCjgMNb6digimckNQ6TBVcTWBAmPHK$ cat m |</span> sx hd-priv <span class="hljs-number">0</span> <span class="hljs-params">| sx hd-priv 12 --hard |</span> sx hd-priv <span class="hljs-number">4</span> <span class="hljs-comment"># generate m/ 0/12'/4 xprv9yL8ndfdPVeDWJenF18oiHguRUj8jHmVrqqD97YQHeTcR3LCeh53q5PXPkLsy2kRaqgwoS6YZ- BLatRZRyUeAkRPe1kLR1P6Mn7jUrXFquUt</span></code></pre>
   <h2 id="4-5-%E9%AB%98%E7%BA%A7%E5%AF%86%E9%92%A5%E5%92%8C%E5%9C%B0%E5%9D%80"><a></a>4.5 高级密钥和地址</h2>
   <p>在以下部分中，我们将看到高级形式的密钥和地址，诸如加密私钥、脚本和多重签名地址，靓号地址，和纸钱包。</p>
   <h3 id="4-5-1-%E5%8A%A0%E5%AF%86%E7%A7%81%E9%92%A5%EF%BC%88bip0038%EF%BC%89"><a></a>4.5.1 加密私钥（BIP0038）</h3>
   <p>私钥必须保密。私钥的机密性需求事实情况是，在实践中相当难以实现，因为该需求与同样重要的安全对象可用性相互矛盾。当你需要为了避免私钥丢失而存储备份时，会发现维护私钥私密性是一件相当困难的事情。通过密码加密内有私钥的钱包可能要安全一点，但那个钱包也需要备份。有时，例如用户因为要升级或重装钱包软件，而需要把密钥从一个钱包转移到另一个。私钥备份也可能需要存储在纸张上（参见“<a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/chapter04.html#4-5-4-%E7%BA%B8%E9%92%B1%E5%8C%85" rel="nofollow" target="_blank">4.5.4&nbsp;纸钱包</a>”一节）或者外部存储介质里，比如U盘。但如果一旦备份文件失窃或丢失呢？这些矛盾的安全目标推进了便携、方便、可以被众多不同钱包和比特币客户端理解的加密私钥标准BIP0038的出台。</p>
   <p>BIP0038提出了一个通用标准，使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。这个加密标准使用了AES，这个标准由NIST建立，并广泛应用于商业和军事应用的数据加密。</p>
   <p>BIP0038加密方案是：输入一个比特币私钥，通常使用WIF编码过，base58chek字符串的前缀“5”。此外BIP0038加密方案需要一个长密码作为口令，通常由多个单词或一段复杂的数字字母字符串组成。BIP0038加密方案的结果是一个由base58check编码过的加密私钥，前缀为6P。如果你看到一个6P开头的的密钥，这就意味着该密钥是被加密过，并需要一个口令来转换（解码）该密钥回到可被用在任何钱包WIF格式的私钥（前缀为5）。许多钱包APP现在能够识别BIP0038加密过的私钥，会要求用户提供口令解码并导入密钥。第三方APP，诸如非常好用基于浏览器的Bit&nbsp;Address，可以被用来解码BIP00038的密钥。</p>
   <p>最通常使用BIP0038加密的密钥用例是纸钱包——一张纸张上备份私钥。只要用户选择了强口令，使用BIP0038加密的私钥的纸钱包就无比的安全，这也是一种很棒的比特币离线存储方式（也被称作“冷存储”）。</p>
   <p>在bitaddress.org上测试表4-10中加密密钥，看看如何输入密码以得到加密密钥。</p>
   <p><span>表4-10 BIP0038加密私钥例子</span></p>
   <table>
    <thead>
     <tr>
      <th>私钥（WIF）</th>
      <th>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><span>密码</span></td>
      <td><span>MyTestPassphrase</span></td>
     </tr>
     <tr>
      <td><span>加密私钥（BIP0038）</span></td>
      <td><span>6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ</span></td>
     </tr>
    </tbody>
   </table>
   <h3 id="4-5-2-p2sh-pay-to-script-hash-%E5%92%8C%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D%E5%9C%B0%E5%9D%80"><a></a>4.5.2 P2SH (Pay-to-Script Hash)和多重签名地址</h3>
   <p>正如我们所知，传统的比特币地址从数字1开头，来源于公钥，而公钥来源于私钥。虽然任何人都可以将比特币发送到一个1开头的地址，但比特币只能在通过相应的私钥签名和公钥哈希值后才能消费。</p>
   <p>以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。他们指定比特币交易中受益人作为哈希的脚本，而不是公钥的所有者。这个特性在2012年1月由BIP0016引进，目前因为BIP0016提供了增加功能到地址本身的机会而被广泛的采纳。不同于P2PKH交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，需要的不仅仅是一个公钥的哈希值，同时也需要一个私钥签名作为所有者证明。在创建地址的时候，这些要求会被定义在脚本中，所有对地址的输入都会被这些要求阻隔。</p>
   <p>一个P2SH地址从事务脚本中创建，它定义谁能消耗这个事务输出。（132页“P2SH（Pay-to-Script-Hash）”一节对此有详细的介绍）编码一个P2SH地址涉及使用一个在创建比特币地址用到过的双重哈希函数，并且只能应用在脚本而不是公钥：</p>
   <pre><code class="hljs bash">script <span class="hljs-built_in">hash</span> = RIPEMD160(SHA256(script))</code></pre>
   <p>脚本哈希的结果是由Base58Check编码前缀为5的版本、编码后得到开头为3的编码地址。一个P2SH地址例子是32M8ednmuyZ2zVbes4puqe44NZumgG92sM。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon01.png"><br>P2SH 不一定是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能是其他类型的交易脚本。</p>
   </blockquote>
   <h4 id="4-5-2-1-%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D%E5%9C%B0%E5%9D%80%E5%92%8Cp2sh">4.5.2.1 多重签名地址和P2SH</h4>
   <p>目前，P2SH函数最常见的实现是用于多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性是需要从总共N个密钥中需要M个签名（也被称为“阈值”），被称为M-N多签名，其中M是等于或小于N。例如，第一章中提到的咖啡店主鲍勃使用多重签名地址需要1-2签名，一个是属于他的密钥和一个属于他同伴的密钥，以确保其中一方可以签署度过一个事务锁定输出到这个地址。这类似于传统的银行中的一个“联合账户”，其中任何一方配偶可以凭借单一签名消费。或Gopesh，&nbsp;Bob雇佣的网页设计师创立一个网站，可能为他的业务需要一个2-3的多签名地址，确保没有资金会被花费除非至少两个业务合作伙伴签署这笔交易。</p>
   <p>我们将会在第五章节探索如何使用P2SH地址创建事务用来消费资金。</p>
   <h3 id="4-5-3-%E6%AF%94%E7%89%B9%E5%B8%81%E9%9D%93%E5%8F%B7%E5%9C%B0%E5%9D%80"><a></a>4.5.3 比特币靓号地址</h3>
   <p>靓号地址包含了可读信息的有效比特币地址。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33就是包含了Base-58字母love的。靓号地址需要生成并通过数十亿的候选私钥测试，直到一个私钥能生成具有所需图案的比特币地址。虽然有一些优化过的靓号生成算法，该方法必须涉及随机上选择一个私钥，生成公钥，再生成比特币地址，并检查是否与所要的靓号图案相匹配，重复数十亿次，直到找到一个匹配。</p>
   <p>一旦找到一个匹配所要图案的靓号地址，来自这个靓号地址的私钥可以和其他地址相同的方式被拥有者消费比特币。靓号地址不比其他地址具有更多安全性。它们依靠和其他地址相同的ECC和SHA。你无法比任何别的地址更容易的获得一个靓号图案开头的私钥。</p>
   <p>在第一章中，我们介绍了Eugenia，一位在菲律宾工作的儿童慈善总监。我们假设Eugenia组织了一场比特币募捐活动，并希望使用靓号比特币地址来宣布这个募捐活动。Eugenia将会创造一个以1Kids开头的靓号地址来促进儿童慈善募捐的活动。让我们看看这个靓号地址如何被创建，这个靓号地址对Eugenia慈善募捐的安全性又意味着什么。</p>
   <h4 id="4-5-3-1-%E7%94%9F%E6%88%90%E9%9D%93%E5%8F%B7%E5%9C%B0%E5%9D%80">4.5.3.1 生成靓号地址</h4>
   <p>我们必须认识到使用来自Base58字母表中简单符号来代表比特币地址是非常重要的。搜索“1kids”开头的图案我们会发现从1Kids11111111111111111111111111111到1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz的地址。这些以“1kid”开头的地址范围中大约有58的29次方地址。表4-11显示了这些有“1kids”前缀的地址。</p>
   <p><span>表4-11 “1Kids”靓号的范围</span></p>
   <table>
    <thead>
     <tr>
      <th>From</th>
      <th>1Kids11111111111111111111111111111</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><span>To</span></td>
      <td><span>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</span></td>
     </tr>
    </tbody>
   </table>
   <p>我们把“1Kids”这个前缀当作数字，我们可以看看比特币地址中这个前缀出现的频率。如果是一台普通性能的桌面电脑，没有任何特殊的硬件，可以每秒发现大约10万个密钥。</p>
   <p><span>表4-12 靓号的出现的频率（1KidsCharity）以及生成所需时间</span></p>
   <table>
    <thead>
     <tr>
      <th>长度</th>
      <th>地址前缀</th>
      <th>概率</th>
      <th>平均生成时间</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>1</td>
      <td>1K</td>
      <td>1/58</td>
      <td>&lt; 1毫秒</td>
     </tr>
     <tr>
      <td>2</td>
      <td>1Ki</td>
      <td>1/3,364</td>
      <td>50毫秒</td>
     </tr>
     <tr>
      <td>3</td>
      <td>1Kid</td>
      <td>1/(195*10<span>3</span>)</td>
      <td>&lt; 2秒</td>
     </tr>
     <tr>
      <td>4</td>
      <td>1Kids</td>
      <td>1/(11*10<span>6</span>)</td>
      <td>1分钟</td>
     </tr>
     <tr>
      <td>5</td>
      <td>1KidsC</td>
      <td>1/(656*10<span>6</span>)</td>
      <td>1小时</td>
     </tr>
     <tr>
      <td>6</td>
      <td>1KidsCh</td>
      <td>1/(38*10<span>9</span>)</td>
      <td>2天</td>
     </tr>
     <tr>
      <td>7</td>
      <td>1KidsCha</td>
      <td>1/(2.2*10<span>12</span>)</td>
      <td>3–4 月</td>
     </tr>
     <tr>
      <td>8</td>
      <td>1KidsChar</td>
      <td>1/(128*10<span>12</span>)</td>
      <td>13–18年</td>
     </tr>
     <tr>
      <td>9</td>
      <td>1KidsChari</td>
      <td>1/(7*10<span>15</span>)</td>
      <td>800年</td>
     </tr>
     <tr>
      <td>10</td>
      <td>1KidsCharit</td>
      <td>1/(400*10<span>15</span>)</td>
      <td>46,000年</td>
     </tr>
     <tr>
      <td>11</td>
      <td>1KidsCharity</td>
      <td>1/(23*10<span>18</span>)</td>
      <td>250万年</td>
     </tr>
    </tbody>
   </table>
   <p>正如你所见，Eugenia将不会很快地创建出以“1KidsCharity”开头的靓号地址，即使她有数千台的电脑同时进行运算。每增加一个字符就会增加58倍的计算难度。超过七个字符的搜索模式通常需要专用的硬件才能被找出，譬如用户定制的具有多图形处理单元（GPU）的桌面级设备。那些通常是无法继续在比特币挖矿中盈利的钻机，被重新赋予了寻找靓号地址的任务。用GPU系统搜索靓号的速度比用通用CPU要快很多个量级。</p>
   <p>另一种寻找靓号地址的方法是将工作外包给一个矿池里的靓号矿工们，如<a href="https://vanitypool.appspot.com/" rel="nofollow" target="_blank">靓号矿池</a>中的矿池。一个矿池是一种允许那些GPU硬件通过为他人寻找靓号地址来获得比特币的服务。对小额的账单，Eugenia可以外包搜索模式为7个字符靓号地址寻找工作，在几个小时内就可以得到结果，而不必用一个CPU搜索上几个月才得到结果。</p>
   <p>生成一个靓号地址是一项通过蛮力的过程：尝试一个随机密钥，检查结果地址是否和所需的图案相匹配，重复这个过程直到成功找到为止。例4-8是个靓号矿工的例子，用C++程序来寻找靓号地址。这个例子运用到了我们在56页“其他替代客户端、资料库、工具包”一节介绍过的libbitcoin库。</p>
   <p><span>例4-8 靓号挖掘程序</span></p>
   <pre><code class="hljs php"><span class="hljs-comment">#include &lt;bitcoin/bitcoin.hpp&gt;</span><span class="hljs-comment">// The string we are searching for</span><span class="hljs-keyword">const</span> std::string search = <span class="hljs-string">"1kid"</span>;<span class="hljs-comment">// Generate a random secret key. A random 32 bytes.</span>bc::ec_secret random_secret(std::default_random_engine&amp; engine); <span class="hljs-comment">// Extract the Bitcoin address from an EC secret.</span>std::string bitcoin_address(<span class="hljs-keyword">const</span> bc::ec_secret&amp; secret);<span class="hljs-comment">// Case insensitive comparison with the search string.</span>bool match_found(<span class="hljs-keyword">const</span> std::string&amp; address);int main() {&nbsp;&nbsp;&nbsp; std::random_device random; &nbsp;&nbsp;&nbsp; std::default_random_engine engine(random()); &nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Loop continuously...</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Generate a random secret.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc::ec_secret secret = random_secret(engine); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Get the address.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string address = bitcoin_address(secret); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Does it match our search string? (1kid)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (match_found(address)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Success!</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <span class="hljs-string">"Found vanity address! "</span> &lt;&lt; address &lt;&lt; std::endl; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <span class="hljs-string">"Secret: "</span> &lt;&lt; bc::encode_hex(secret) &lt;&lt; std::endl; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Should never reach here!</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }bc::ec_secret random_secret(std::default_random_engine&amp; engine){&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Create new secret...</span>&nbsp;&nbsp;&nbsp; bc::ec_secret secret;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Iterate through every byte setting a random value... for (uint8_t&amp; byte: secret)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte = engine() % std::numeric_limits&lt;uint8_t&gt;::max(); &nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Return result.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> secret;}std::string bitcoin_address(<span class="hljs-keyword">const</span> bc::ec_secret&amp; secret) {&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Convert secret to pubkey...</span>&nbsp;&nbsp;&nbsp; bc::ec_point pubkey = bc::secret_to_public_key(secret); &nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Finally create address.</span>&nbsp;&nbsp;&nbsp; bc::payment_address payaddr; bc::set_public_key(payaddr, pubkey);&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Return encoded form.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> payaddr.encoded(); }bool match_found(<span class="hljs-keyword">const</span> std::string&amp; address) {&nbsp;&nbsp;&nbsp; auto addr_it = address.begin();&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Loop through the search string comparing it to the lower case </span>&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// character of the supplied address.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">for</span> (auto it = search.begin(); it != search.end(); ++it, ++addr_it)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (*it != std::tolower(*addr_it)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// Reached end of search string, so address matches.</span>&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; &nbsp;&nbsp;&nbsp; }</code></pre>
   <p>示例程序需要用C编译器链接libbitcoin库（此库需要提前装入该系统）进行编译。直接执行vanity-miner的可执行文件（不用参数，参见例4-9），它就会尝试碰撞以“1kid”开头的比特币地址。</p>
   <p><span>例4-9 编译并运行vanity-miner程序示例</span></p>
   <pre><code class="hljs ruby">$ <span class="hljs-comment"># Compile the code with g++</span>$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ <span class="hljs-comment"># Run the example</span>$ ./vanity-minerFound vanity address! <span class="hljs-number">1</span>KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT<span class="hljs-symbol">Secret:</span> <span class="hljs-number">57</span>cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f$ <span class="hljs-comment"># Run it again for a different result</span>$ ./vanity-minerFound vanity address! <span class="hljs-number">1</span>Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn<span class="hljs-symbol">Secret:</span> <span class="hljs-number">7</span>f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623<span class="hljs-comment"># Use "time" to see how long it takes to find a result</span>$ time ./vanity-minerFound vanity address! <span class="hljs-number">1</span>KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM<span class="hljs-symbol">Secret:</span> <span class="hljs-number">2</span>a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349real&nbsp;&nbsp;&nbsp; 0m8.<span class="hljs-number">868</span>suser&nbsp;&nbsp;&nbsp; 0m8.<span class="hljs-number">828</span>ssys&nbsp;&nbsp;&nbsp;&nbsp; 0m<span class="hljs-number">0</span>.<span class="hljs-number">035</span>s</code></pre>
   <p>正如我们运行Unix命令time所测出的运行时间所示，示例代码要花几秒钟来找出匹配“kid”三个字符模板的结果。读者们可以在源代码中改变search这一搜索模板，看一看如果是四个字符或者五个字符的搜索模板需要花多久时间！</p>
   <h4 id="4-5-3-2-%E9%9D%93%E5%8F%B7%E5%9C%B0%E5%9D%80%E5%AE%89%E5%85%A8%E6%80%A7">4.5.3.2 靓号地址安全性</h4>
   <p>靓号地址既可以增加、也可以削弱安全措施，它们着实是一把双刃剑。用于改善安全性时，一个独特的地址使对手难以使用他们自己的地址替代你的地址，以欺骗你的顾客支付他们的账单。不幸的是，靓号地址也可能使得任何人都能创建一个类似于随机地址的地址，甚至另一个靓号地址，从而欺骗你的客户。</p>
   <p>Eugenia可以让捐款人捐款到她宣布的一个随机生成地址（例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy）。或者她可以生成一个以“1Kids”开头的靓号地址以显得更独特。</p>
   <p>在这两种情况下，使用单一固定地址（而不是每比捐款用一个独立的动态地址）的风险之一是小偷有可能会黑进你的网站，用他自己的网址取代你的网址，从而将捐赠转移给自己。如果你在不同的地方公布了你的捐款地址，你的用户可以在付款之前直观地检查以确保这个地址跟在你的网站、邮件和传单上看到的地址是同一个。在随机地址1j7mdg5rbqyuhenydx39wvwk7fslpeoxzy的情况下，普通用户可能会只检查头几个字符“1j7mdg”，就认为地址匹配。使用靓号地址生成器，那些想通过替换类似地址来盗窃的人可以快速生成与前几个字符相匹配的地址，如表4-13所示。</p>
   <p><span>表4-13 生成匹配某随机地址的多个靓号</span></p>
   <table>
    <thead>
     <tr>
      <th>原版随机地址</th>
      <th>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><span>4位字符匹配</span></td>
      <td><span>1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</span></td>
     </tr>
     <tr>
      <td><span>5位字符匹配</span></td>
      <td><span>1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</span></td>
     </tr>
     <tr>
      <td><span>6位字符匹配</span></td>
      <td><span>1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</span></td>
     </tr>
    </tbody>
   </table>
   <p>那靓号地址会不会增加安全性？如果Eugenia生成1Kids33q44erFfpeXrmDSz7zEqG2FesZEN的靓号地址，用户可能看到靓号图案的字母和一些字符在上面，例如在地址部分中注明了1Kids33。这样就会迫使攻击者生成至少6个字母相匹配的的靓号地址（比之前多2个字符），就要花费比Eugenia多3364倍的靓号图案。本质上，Eugenia付出的努力（或者靓号池付出的）迫使攻击者不得不生成更长的靓号图案。如果Eugenia花钱请矿池生成8个字符的靓号地址，攻击者将会被逼迫到10字符的境地，那将是个人电脑，甚至昂贵自定义靓号挖掘机或靓号池也无法生成。对Eugenia来说可承担的起支出，对攻击者来说则变成了无法承担支出，特别是如果欺诈的回报不足以支付生成靓号地址所需的费用。</p>
   <h3 id="4-5-4-%E7%BA%B8%E9%92%B1%E5%8C%85"><a></a>4.5.4 纸钱包</h3>
   <p>纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷钱包）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。作为一个冷存储的机制，如果纸钱包密钥在线下生成并永久不在电脑系统中存储，他们在应对黑客攻击，键盘记录器，或其他在线电脑欺骗更有安全性。</p>
   <p>纸钱包有许多不同的形状，大小，和外观设计，但非常基本的原则是一个密钥和一个地址打印在纸张上。表4-14展现了纸钱包最基本的形式。</p>
   <p><span>表4-14 比特币纸钱包的私钥和公钥的打印形式</span></p>
   <table>
    <thead>
     <tr>
      <th>公开地址</th>
      <th>1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>私钥（WIF）</td>
      <td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td>
     </tr>
    </tbody>
   </table>
   <p>通过使用工具，就可以很容易地生成纸钱包，譬如使用bitaddress.org网站上的客户端Javascript生成器。这个页面包含所有必要的代码，甚至在完全失去网络连接的情况下，也可以生成密钥和纸钱包。若要使用它，先将HTML页面保存在本地磁盘或外部U盘。从Internet网络断开，从浏览器中打开文件。更方便的，使用一个原始操作系统启动电脑，比如一个光盘启动的Linux系统。任何在脱机情况下使用这个工具所生成的密钥，都可以通过USB线在本地打印机上打印出来，从而制造了密钥只存在纸张上而从未存储在在线系统上的纸钱包。将这些纸钱包放置在防火容器内，发送比特币到对应的比特币地址上，从而实现了一个简单但非常有效的冷存储解决方案。图4-14展示了通过bitaddress.org&nbsp;生成的纸钱包。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig414.png"><br><br>图4-14 通过bitaddress.org 生成的普通纸钱包</p>
   </blockquote>
   <p>这个简单的纸钱包系统的不足之处是那些被打印下来的密钥容易被盗窃。一个能够接近这些纸的小偷只需偷走纸或者用把拍摄纸上的密钥，就能控制被这些密钥锁定的比特币。一个更复杂的纸钱包存储系统使用BIP0038加密的私钥。打印在纸钱包上的这些私钥被其所有者记住的一个口令保护起来。没有口令，这些被加密过的密钥也是毫无用处的。但它们仍旧优于用口令保护，因为这些密钥从没有在线过，并且必须从保险箱或者其他物理的安全存储中导出。图4-15展示了通过bitaddress.org 生成的加密纸钱包。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig415.png"><br><br>图4-15 通过bitaddress.org 生成的加密纸钱包。密码是“test”。</p>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Icon02.png"><br>虽然你可以多次存款到纸钱包中，但是你最好一次性提款，一次性提取里面所有的资金。因为如果你提取的金额少于其中的金额的话，会生成一个找零地址。并且，你所用的电脑可能被病毒感染，那么就有可能泄露私钥。一次性提款可以减少私钥泄露的风险，如果你所需的金额比较少，那么请把余额找零到另一个纸钱包中。</p>
   </blockquote>
   <p>纸钱包有许多设计和大小，并有许多不同的特性。有些作为礼物送给他人，有季节性的主题，像圣诞节和新年主题。另外一些则是设计保存在银行金库或通过某种方式隐藏私钥的保险箱内，或者用不透明的刮刮贴，或者折叠和防篡改的铝箔胶粘密封。图4-16至图4-18展示了几个不同安全和备份功能的纸钱包的例子。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig416.png"><br><br>图4-16 通过bitcoinpaperwallet.com生成的、私钥写在折叠皮瓣上的纸钱包</p>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig417.png"><br><br>图4-17 通过bitcoinpaperwallet.com 生成的、私钥被密封住的纸钱包</p>
   </blockquote>
   <p>其他设计有密钥和地址的额外副本，类似于票根形式的可以拆卸存根，让你可以存储多个副本以防火灾、洪水或其他自然灾害。</p>
   <blockquote>
    <p><img alt="" src="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Images/Fig418.png"><br><br>图4-18 在备份“存根”上有多个私钥副本的纸钱包</p>
   </blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </div>
  <p></p>
  <strong></strong>
  <h4>给我老师的人工智能教程打call！<a href="https://blog.csdn.net/jiangjunshow/article/details/77338485" rel="nofollow">http://blog.csdn.net/jiangjunshow</a></h4>
  <div align="center">
   <img title="" alt="这里写图片描述" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161220210733446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VuaHVhcWlhbmcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
  </div> 你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 
  <h2><a id="_3"></a>新的改变</h2> 
  <p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p> 
  <ol> 
   <li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li> 
   <li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li> 
   <li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li> 
   <li>全新的 <strong>KaTeX数学公式</strong> 语法；</li> 
   <li>增加了支持<strong>甘特图的mermaid语法<sup class="footnote-ref"><a id="fnref1" href="#fn1" rel="nofollow">1</a></sup></strong> 功能；</li> 
   <li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li> 
   <li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li> 
   <li>增加了 <strong>检查列表</strong> 功能。</li> 
  </ol> 
  <h2><a id="_17"></a>功能快捷键</h2> 
  <p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br> 重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br> 加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br> 斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br> 标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br> 无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br> 有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br> 检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br> 插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br> 插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br> 插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></p> 
  <h2><a id="_32"></a>合理的创建标题，有助于目录的生成</h2> 
  <p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br> 输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br> 以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p> 
  <h2><a id="_40"></a>如何改变文本的样式</h2> 
  <p><em>强调文本</em> <em>强调文本</em></p> 
  <p><strong>加粗文本</strong> <strong>加粗文本</strong></p> 
  <p><mark>标记文本</mark></p> 
  <p><s>删除文本</s></p> 
  <blockquote> 
   <p>引用文本</p> 
  </blockquote> 
  <p>H<sub>2</sub>O is是液体。</p> 
  <p>2<sup>10</sup> 运算结果是 1024.</p> 
  <h2><a id="_58"></a>插入链接与图片</h2> 
  <p>链接: <a href="https://mp.csdn.net" rel="nofollow">link</a>.</p> 
  <p>图片: <img alt="Alt" src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg"></p> 
  <p>带尺寸的图片: <img width="30" height="30" alt="Alt" src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg"></p> 
  <p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p> 
  <h2><a id="_69"></a>如何插入一段漂亮的代码片</h2> 
  <p>去<a href="https://mp.csdn.net/configure" rel="nofollow">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p> 
  <pre><code class="prism language-javascript"><span class="token comment">// An highlighted block var foo = 'bar'; </span></code></pre> 
  <h2><a id="_78"></a>生成一个适合你的列表</h2> 
  <ul> 
   <li>项目 
    <ul> 
     <li>项目 
      <ul> 
       <li>项目</li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
  <ol> 
   <li>项目1</li> 
   <li>项目2</li> 
   <li>项目3</li> 
  </ol> 
  <ul> 
   <li class="task-list-item"><input disabled class="task-list-item-checkbox" type="checkbox"> 计划任务</li> 
   <li class="task-list-item"><input disabled class="task-list-item-checkbox" type="checkbox" checked="true"> 完成任务</li> 
  </ul> 
  <h2><a id="_92"></a>创建一个表格</h2> 
  <p>一个简单的表格是这么创建的：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>项目</th> 
     <th>Value</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>电脑</td> 
     <td>$1600</td> 
    </tr> 
    <tr> 
     <td>手机</td> 
     <td>$12</td> 
    </tr> 
    <tr> 
     <td>导管</td> 
     <td>$1</td> 
    </tr> 
   </tbody> 
  </table>
  <h3><a id="_100"></a>设定内容居中、居左、居右</h3> 
  <p>使用<code>:---------:</code>居中<br> 使用<code>:----------</code>居左<br> 使用<code>----------:</code>居右</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">第一列</th> 
     <th align="right">第二列</th> 
     <th align="left">第三列</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">第一列文本居中</td> 
     <td align="right">第二列文本居右</td> 
     <td align="left">第三列文本居左</td> 
    </tr> 
   </tbody> 
  </table>
  <h3><a id="SmartyPants_109"></a>SmartyPants</h3> 
  <p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>TYPE</th> 
     <th>ASCII</th> 
     <th><abbr title="超文本标记语言">HTML</abbr></th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>Single backticks</td> 
     <td><code>'Isn't this fun?'</code></td> 
     <td>‘Isn’t this fun?’</td> 
    </tr> 
    <tr> 
     <td>Quotes</td> 
     <td><code>"Isn't this fun?"</code></td> 
     <td>“Isn’t this fun?”</td> 
    </tr> 
    <tr> 
     <td>Dashes</td> 
     <td><code>-- is en-dash, --- is em-dash</code></td> 
     <td>– is en-dash, — is em-dash</td> 
    </tr> 
   </tbody> 
  </table>
  <h2><a id="_118"></a>创建一个自定义列表</h2> 
  <dl> 
   <dt>
    Markdown
   </dt> 
   <dd>
    Text-to-
    <abbr title="超文本标记语言">HTML</abbr> conversion tool
   </dd> 
   <dt>
    Authors
   </dt> 
   <dd>
    John
   </dd> 
   <dd>
    Luke
   </dd> 
  </dl> 
  <h2><a id="_127"></a>如何创建一个注脚</h2> 
  <p>一个具有注脚的文本。<sup class="footnote-ref"><a id="fnref2" href="#fn2" rel="nofollow">2</a></sup></p> 
  <h2><a id="_134"></a>注释也是必不可少的</h2> 
  <p>Markdown将文本转换为 <abbr title="超文本标记语言">HTML</abbr>。</p> 
  <h2><a id="KaTeX_141"></a>KaTeX数学公式</h2> 
  <p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" rel="nofollow">KaTeX</a>:</p> 
  <p>Gamma公式展示 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi mathvariant="normal">
          Γ
         </mi>
         <mo>
          (
         </mo>
         <mi>
          n
         </mi>
         <mo>
          )
         </mo>
         <mo>
          =
         </mo>
         <mo>
          (
         </mo>
         <mi>
          n
         </mi>
         <mo>
          −
         </mo>
         <mn>
          1
         </mn>
         <mo>
          )
         </mo>
         <mo>
          !
         </mo>
         <mspace width="1em"></mspace>
         <mi mathvariant="normal">
          ∀
         </mi>
         <mi>
          n
         </mi>
         <mo>
          ∈
         </mo>
         <mi mathvariant="double-struck">
          N
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         \Gamma(n) = (n-1)!\quad\forall n\in\mathbb N
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.22em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right: 1em;"></span><span class="mord">∀</span><span class="mord mathit">n</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathbb">N</span></span></span></span></span> 是通过欧拉积分</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi mathvariant="normal">
           Γ
          </mi>
          <mo>
           (
          </mo>
          <mi>
           z
          </mi>
          <mo>
           )
          </mo>
          <mo>
           =
          </mo>
          <msubsup>
           <mo>
            ∫
           </mo>
           <mn>
            0
           </mn>
           <mi mathvariant="normal">
            ∞
           </mi>
          </msubsup>
          <msup>
           <mi>
            t
           </mi>
           <mrow>
            <mi>
             z
            </mi>
            <mo>
             −
            </mo>
            <mn>
             1
            </mn>
           </mrow>
          </msup>
          <msup>
           <mi>
            e
           </mi>
           <mrow>
            <mo>
             −
            </mo>
            <mi>
             t
            </mi>
           </mrow>
          </msup>
          <mi>
           d
          </mi>
          <mi>
           t
          </mi>&amp;ThinSpace;
          <mi mathvariant="normal">
           .
          </mi>
         </mrow>
         <annotation encoding="application/x-tex">
           \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.04em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.32em; vertical-align: -0.91em;"></span><span class="mop"><span class="mop op-symbol large-op" style="top: 0em; margin-right: 0.44em; position: relative;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.41em;"><span style="top: -1.78em; margin-right: 0.05em; margin-left: -0.44em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top: -3.81em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.91em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.86em;"><span style="top: -3.11em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.04em;">z</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.84em;"><span style="top: -3.11em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathit mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathit">d</span><span class="mord mathit">t</span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord">.</span></span></span></span></span></span></p> 
  <blockquote> 
   <p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" rel="nofollow">here</a>.</p> 
  </blockquote> 
  <h2><a id="_155"></a>新的甘特图功能，丰富你的文章</h2> 
  <pre><code class="prism language-mermaid">gantt
        dateFormat  YYYY-MM-DD
        title Adding GANTT diagram functionality to mermaid
        section 现有任务
        已完成               :done,    des1, 2014-01-06,2014-01-08
        进行中               :active,  des2, 2014-01-09, 3d
        计划一               :         des3, after des2, 5d
        计划二               :         des4, after des3, 5d
</code></pre> 
  <ul> 
   <li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" rel="nofollow">这儿</a>,</li> 
  </ul> 
  <h2><a id="UML__169"></a>UML 图表</h2> 
  <p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" rel="nofollow">Mermaid</a>. 例如下面产生的一个序列图：:</p> 
  <div class="mermaid">
   <svg xmlns="http://www.w3.org/2000/svg" id="mermaid-svg-21QpzxHRyODIZW7H" style="max-width: 750px;" viewbox="-50 -10 750 467.35" width="100%" height="100%">
    <g />
    <g>
     <line class="actor-line" id="actor3" stroke="#999" stroke-width="0.5px" x1="75" y1="5" x2="75" y2="456.35" />
     <rect class="actor" fill="#eaeaea" stroke="#666" x="0" y="0" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="75" y="32.5">
      <tspan x="75" dy="0">
       张三
      </tspan>
     </text>
    </g>
    <g>
     <line class="actor-line" id="actor4" stroke="#999" stroke-width="0.5px" x1="275" y1="5" x2="275" y2="456.35" />
     <rect class="actor" fill="#eaeaea" stroke="#666" x="200" y="0" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="275" y="32.5">
      <tspan x="275" dy="0">
       李四
      </tspan>
     </text>
    </g>
    <g>
     <line class="actor-line" id="actor5" stroke="#999" stroke-width="0.5px" x1="475" y1="5" x2="475" y2="456.35" />
     <rect class="actor" fill="#eaeaea" stroke="#666" x="400" y="0" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="475" y="32.5">
      <tspan x="475" dy="0">
       王五
      </tspan>
     </text>
    </g>
    <defs>
     <marker id="arrowhead" refx="5" refy="2" markerwidth="6" markerheight="4" orient="auto">
      <path d="M 0 0 V 4 L 6 2 Z" />
     </marker>
    </defs>
    <defs>
     <marker id="crosshead" refx="16" refy="4" markerwidth="15" markerheight="8" orient="auto">
      <path style="stroke-dasharray: 0,0;" fill="black" stroke="#000000" stroke-width="1px" d="M 9 2 V 6 L 16 4 Z" />
      <path style="stroke-dasharray: 0,0;" fill="none" stroke="#000000" stroke-width="1px" d="M 0 1 L 6 7 M 6 1 L 0 7" />
     </marker>
    </defs>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="175" y="93">
      你好！李四, 最近怎么样?
     </text>
     <line class="messageLine0" style="fill: none;" marker-end="url(&quot;#arrowhead&quot;)" stroke="black" stroke-width="2" x1="75" y1="100" x2="275" y2="100" />
    </g>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="375" y="128">
      你最近怎么样，王五？
     </text>
     <line class="messageLine1" style="fill: none; stroke-dasharray: 3,3;" marker-end="url(&quot;#arrowhead&quot;)" stroke="black" stroke-width="2" x1="275" y1="135" x2="475" y2="135" />
    </g>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="175" y="163">
      我很好，谢谢!
     </text>
     <line class="messageLine1" style="fill: none; stroke-dasharray: 3,3;" marker-end="url(&quot;#crosshead&quot;)" stroke="black" stroke-width="2" x1="275" y1="170" x2="75" y2="170" />
    </g>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="375" y="198">
      我很好，谢谢!
     </text>
     <line class="messageLine0" style="fill: none;" marker-end="url(&quot;#crosshead&quot;)" stroke="black" stroke-width="2" x1="275" y1="205" x2="475" y2="205" />
    </g>
    <g>
     <rect class="note" fill="#edf2ae" stroke="#666" x="500" y="215" width="150" height="86.35" rx="0" ry="0" />
     <text class="noteText" fill="black" x="516" y="245">
      <tspan x="516">
       李四想了很长时间,
      </tspan>
      <tspan x="516" dy="23">
       文字太长了
      </tspan>
      <tspan x="516" dy="23">
       不适合放在一行.
      </tspan>
     </text>
    </g>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="175" y="329.35">
      打量着王五...
     </text>
     <line class="messageLine1" style="fill: none; stroke-dasharray: 3,3;" marker-end="url(&quot;#arrowhead&quot;)" stroke="black" stroke-width="2" x1="275" y1="336.35" x2="75" y2="336.35" />
    </g>
    <g>
     <text class="messageText" style="text-anchor: middle;" x="275" y="364.35">
      很好... 王五, 你怎么样?
     </text>
     <line class="messageLine0" style="fill: none;" marker-end="url(&quot;#arrowhead&quot;)" stroke="black" stroke-width="2" x1="75" y1="371.35" x2="475" y2="371.35" />
    </g>
    <g>
     <rect class="actor" fill="#eaeaea" stroke="#666" x="0" y="391.35" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="75" y="423.85">
      <tspan x="75" dy="0">
       张三
      </tspan>
     </text>
    </g>
    <g>
     <rect class="actor" fill="#eaeaea" stroke="#666" x="200" y="391.35" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="275" y="423.85">
      <tspan x="275" dy="0">
       李四
      </tspan>
     </text>
    </g>
    <g>
     <rect class="actor" fill="#eaeaea" stroke="#666" x="400" y="391.35" width="150" height="65" rx="3" ry="3" />
     <text class="actor" style="text-anchor: middle;" alignment-baseline="central" dominant-baseline="central" x="475" y="423.85">
      <tspan x="475" dy="0">
       王五
      </tspan>
     </text>
    </g>
   </svg>
  </div> 
  <p>这将产生一个流程图。:</p> 
  <div class="mermaid">
   <svg xmlns="http://www.w3.org/2000/svg" id="mermaid-svg-w5uNXzgwzHE086Kw" viewbox="0 0 232 150" width="212" height="130">
    <g>
     <g class="output">
      <g class="clusters" />
      <g class="edgePaths">
       <g class="edgePath" style="opacity: 1;">
        <path class="path" style="fill: none;" marker-end="url(&quot;#arrowhead31&quot;)" d="M 40 55 L 65 30 L 90 30" />
        <defs>
         <marker id="arrowhead31" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto">
          <path class="arrowheadPath" style="stroke-dasharray: 1,0; stroke-width: 1;" d="M 0 0 L 10 5 L 0 10 Z" />
         </marker>
        </defs>
       </g>
       <g class="edgePath" style="opacity: 1;">
        <path class="path" style="fill: none;" marker-end="url(&quot;#arrowhead32&quot;)" d="M 40 75 L 65 100 L 90 100" />
        <defs>
         <marker id="arrowhead32" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto">
          <path class="arrowheadPath" style="stroke-dasharray: 1,0; stroke-width: 1;" d="M 0 0 L 10 5 L 0 10 Z" />
         </marker>
        </defs>
       </g>
       <g class="edgePath" style="opacity: 1;">
        <path class="path" style="fill: none;" marker-end="url(&quot;#arrowhead33&quot;)" d="M 110 30 L 135 30 L 167.868 58.1316" />
        <defs>
         <marker id="arrowhead33" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto">
          <path class="arrowheadPath" style="stroke-dasharray: 1,0; stroke-width: 1;" d="M 0 0 L 10 5 L 0 10 Z" />
         </marker>
        </defs>
       </g>
       <g class="edgePath" style="opacity: 1;">
        <path class="path" style="fill: none;" marker-end="url(&quot;#arrowhead34&quot;)" d="M 110 100 L 135 100 L 167.868 72.8684" />
        <defs>
         <marker id="arrowhead34" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto">
          <path class="arrowheadPath" style="stroke-dasharray: 1,0; stroke-width: 1;" d="M 0 0 L 10 5 L 0 10 Z" />
         </marker>
        </defs>
       </g>
      </g>
      <g class="edgeLabels">
       <g class="edgeLabel" style="opacity: 1;" transform="">
        <g class="label" transform="translate(0)">
         <foreignobject width="0" height="0">
          <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
           <span class="edgeLabel">链接</span>
          </div>
         </foreignobject>
        </g>
       </g>
       <g class="edgeLabel" style="opacity: 1;" transform="">
        <g class="label" transform="translate(0)">
         <foreignobject width="0" height="0">
          <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
           <span class="edgeLabel"></span>
          </div>
         </foreignobject>
        </g>
       </g>
       <g class="edgeLabel" style="opacity: 1;" transform="">
        <g class="label" transform="translate(0)">
         <foreignobject width="0" height="0">
          <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
           <span class="edgeLabel"></span>
          </div>
         </foreignobject>
        </g>
       </g>
       <g class="edgeLabel" style="opacity: 1;" transform="">
        <g class="label" transform="translate(0)">
         <foreignobject width="0" height="0">
          <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
           <span class="edgeLabel"></span>
          </div>
         </foreignobject>
        </g>
       </g>
      </g>
      <g class="nodes">
       <g class="node" id="A" style="opacity: 1;" transform="translate(30 65)">
        <rect x="-10" y="-10" width="20" height="20" rx="0" ry="0" />
        <g class="label" transform="translate(0)">
         <g transform="translate(0)">
          <foreignobject width="0" height="0">
           <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
            长方形
           </div>
          </foreignobject>
         </g>
        </g>
       </g>
       <g class="node" id="B" style="opacity: 1;" transform="translate(100 30)">
        <circle r="10" x="-10" y="-10" />
        <g class="label" transform="translate(0)">
         <g transform="translate(0)">
          <foreignobject width="0" height="0">
           <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
            圆
           </div>
          </foreignobject>
         </g>
        </g>
       </g>
       <g class="node" id="C" style="opacity: 1;" transform="translate(100 100)">
        <rect x="-10" y="-10" width="20" height="20" rx="5" ry="5" />
        <g class="label" transform="translate(0)">
         <g transform="translate(0)">
          <foreignobject width="0" height="0">
           <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
            圆角长方形
           </div>
          </foreignobject>
         </g>
        </g>
       </g>
       <g class="node" id="D" style="opacity: 1;" transform="translate(176 65)">
        <polygon transform="translate(-16 16)" points="16,0 32,-16 16,-32 0,-16" rx="5" ry="5" />
        <g class="label" transform="translate(0)">
         <g transform="translate(0)">
          <foreignobject width="0" height="0">
           <div style="display: inline-block; white-space: nowrap;" xmlns="http://www.w3.org/1999/xhtml">
            菱形
           </div>
          </foreignobject>
         </g>
        </g>
       </g>
      </g>
     </g>
    </g>
   </svg>
  </div> 
  <ul> 
   <li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" rel="nofollow">这儿</a>,</li> 
  </ul> 
  <h2><a id="FLowchart_197"></a>FLowchart流程图</h2> 
  <p>我们依旧会支持flowchart的流程图：</p> 
  <div class="mermaid">
   <svg xmlns="http://www.w3.org/2000/svg" id="mermaid-svg-EdQq9TcJBf53JZhB">
    <g />
   </svg>
  </div> 
  <ul> 
   <li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" rel="nofollow">这儿</a>.</li> 
  </ul> 
  <h2><a id="_215"></a>导出与导入</h2> 
  <h3><a id="_217"></a>导出</h3> 
  <p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p> 
  <h3><a id="_220"></a>导入</h3> 
  <p>如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br> 继续你的创作。</p> 
  <hr class="footnotes-sep"> 
  <section class="footnotes"> 
   <ol class="footnotes-list"> 
    <li class="footnote-item" id="fn1"><p><a href="https://mermaidjs.github.io/" rel="nofollow">mermaid语法说明</a> <a class="footnote-backref" href="#fnref1" rel="nofollow">↩︎</a></p> </li> 
    <li class="footnote-item" id="fn2"><p>注脚的解释 <a class="footnote-backref" href="#fnref2" rel="nofollow">↩︎</a></p> </li> 
   </ol> 
  </section> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-a47e74522c.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ggjttfc/article/details/83956467,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ggjttfc/article/details/83956467,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
