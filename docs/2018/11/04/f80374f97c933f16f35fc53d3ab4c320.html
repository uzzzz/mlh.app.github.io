<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊搭建私有链(非常详细！！！）(一） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊搭建私有链(非常详细！！！）(一）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yujuan110/article/details/83721440 我的系统：CentOS7 64位 环境需要：Go 1.9以上版本 geth工具 WARN [11-04|09:34:47.411] System clock seems off by -10h15m43.047110838s, which can prevent network connectivity WARN [11-04|09:34:47.411] Please enable network time synchronisation in system settings. 一.环境搭建 1.安装Go 下载源码 https://golang.org/dl/ 找到适合自己操作系统的版本，必须1.9版本以上。我安装的是1.9.5 解压到/usr/local下 tar -zxvf go1.9.5.linux-amd64.tar.gz -C /usr/local/ 创建软链接 ln -s /usr/local/go/bin/go /usr/bin/go 测试是否成功 go version #go version go1.9.5 linux/amd64 2.安装geth工具 下载geth源码 git clone https://github.com/ethereum/go-ethereum.git 解压到/usr/local/下 unzip -d /usr/local/ go-ethereum-master.zip 编译源码 cd /usr/local/go-ethereum make 成功的话会出现如下： Done building. Run &quot;/usr/local/go-ethereum-master/build/bin/geth&quot; to launch geth. 创建软链接 这样我们可以直接用geth命令，而不用输入路径 ln -s /usr/local/go-ethereum-master/build/bin/geth /usr/bin/geth make过程中 如果出现以下错误： exec: “gcc”: executable file not found in $PATH 则是没有安装gcc的原因，执行 yum install gcc 二.搭建私有链 1.创建用户 mkdir geth cd geth 进入geth控制台 geth --datadir db --nodiscover console 创建用户 &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 查看用户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 给用户创建别名 &gt; yujuan=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; hcb=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 可以看到在db目录下，有个keystore目录，里面已经存了我们刚刚创建的两个账户。 [root@localhost mychain]# tree . ├── geth │ ├── chaindata │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ ├── LOCK │ ├── nodekey │ ├── nodes │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ └── transactions.rlp ├── geth.ipc └── keystore ├── UTC--2018-11-04T16-02-52.181405978Z--12844bb3206f10a331557bffb7c8d34ee4ca8b65 └── UTC--2018-11-04T16-03-15.055116889Z--a6faa81cad6a3b038d9a51db80cedbe65184c7e2 2.传世区块配置文件 cd mychain vim gensis.json 在gensis.json中输入如下内容 { &quot;alloc&quot;: { &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;: { &quot;balance&quot;: &quot;999000000000000000000&quot; } }, &quot;config&quot;:{ &quot;chainId&quot;:15, &quot;homesteadBlock&quot;:0, &quot;eip155Block&quot;:0, &quot;eip158Block&quot;:0 }, &quot;nonce&quot;:&quot;0x0000000000000001&quot;, &quot;mixhash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x01&quot;, &quot;coinbase&quot;:&quot;0x0000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;parentHash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x777573686f756865&quot;, &quot;gasLimit&quot;:&quot;0xffffffff&quot; } 注意这里的alloc后的地址要用之前创建的地址 2.初始化 准备好创世区块配置文件后，需要初始化区块链，将上面的传世区块信息写入到区块链中。 始初始化区块 geth --datadir “./mychain/” init ./mychain/gensis.json –datadir 指定数据存放目录 可能出现如下错误，原因是前面启动私有链时已经创建了默认的创世区块 Fatal: Failed to write genesis block: database already contains an incompatible genesis block 如下删除数据 geth removedb 成功的话可以看到如下结果 [root@localhost blockchain]# geth --datadir &quot;./mychain/&quot; init ./mychain/gensis.json WARN [11-04|11:59:11.370] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 INFO [11-04|11:59:11.380] Maximum peer count ETH=25 LES=0 total=25 INFO [11-04|11:59:11.383] Allocated cache and file handles database=/home/blockchain/mychain/geth/chaindata cache=16 handles=16 INFO [11-04|11:59:11.411] Writing custom genesis block INFO [11-04|11:59:11.412] Persisted trie from memory database nodes=1 size=149.00B time=230.093µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.412] Successfully wrote genesis state database=chaindata hash=481cfe…9fd026 INFO [11-04|11:59:11.412] Allocated cache and file handles database=/home/blockchain/mychain/geth/lightchaindata cache=16 handles=16 INFO [11-04|11:59:11.425] Writing custom genesis block INFO [11-04|11:59:11.426] Persisted trie from memory database nodes=1 size=149.00B time=1.090266ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.427] Successfully wrote genesis state database=lightchaindata hash=481cfe…9fd026 3.测试基本的操作 1）此时再查看余额，可以看到 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;] &gt; eth.getBalance(eth.accounts[0]) 999000000000000000000 2）转账 &gt; a1=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; a2=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 我们从账户a1转10个以太币给a2 转账之前需要先对账户a1解锁 &gt; personal.unlockAccount(a1,&quot;123456&quot;) true 转账 &gt; eth.sendTransaction({from:a1, to:a2, value:web3.toWei(10,&quot;ether&quot;)}) INFO [11-04|12:28:37.209] Setting new local account address=0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65 INFO [11-04|12:28:37.210] Submitted transaction fullhash=0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56 recipient=0xA6fAA81cAD6A3b038D9a51DB80CEDbe65184c7E2 &quot;0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56&quot; 交易已经成功执行，最后一排即是交易的hash值 那我们再来看一下两个账户的余额 &gt; eth.getBalance(a1) 999000000000000000000 &gt; eth.getBalance(a2) 0 奇怪，为什么账户的余额根本就没有变呢。那是因为这里没有矿工参与，所以也没有人来将交易打包写入区块。 3）启动节点 geth --datadir &quot;./mychain&quot; --rpc --rpcaddr=0.0.0.0 --rpcport 8545 --rpccorsdomain &quot;*&quot; --rpcapi &quot;eth,net,web3,personal,admin,ssh,txpool,debug,miner&quot; --nodiscover --maxpeers 30 --networkid 1981 --mine --minerthreads 1 --etherbase &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; console 这样我们就成功运行了一个私有链，再稍过一会儿 就会发现出现了斧头，说明已经开始挖矿了 这个时候我们再来看刚刚转账后的账户余额 &gt; web3.fromWei(eth.getBalance(eth.accounts[0])) 994 &gt; web3.fromWei(eth.getBalance(eth.accounts[1])) 10 web3.fromWei是将Wei转换成ether 因为我们设置的矿工奖励地址是accounts[0],所以这里的账户余额是994,而不是989 4) 交易 通过attach命令，连接一个已经启动的节点，启动JS命令环境 geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc 成功进入 [root@localhost blockchain]# geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc WARN [11-04|14:01:44.332] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-unstable/linux-amd64/go1.9.5 coinbase: 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 at block: 1 (Sun, 04 Nov 2018 12:43:43 EST) datadir: /home/blockchain/mychain modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 现在开始挖矿 可以通过miner.setEtherbase(eth.accounts[0])来设置挖矿奖励地址 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;, &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot;] &gt; a2=eth.accounts[2] &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; a0=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.unlockAccount(a0) Unlock account 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 Passphrase: true &gt; eth.sendTransaction({from:a0,to:a2,value:web3.toWei(20,&quot;ether&quot;)}) &quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot; 将账户a2设置为挖矿奖励地址 &gt; miner.setEtherbase(a2) true &gt; eth.coinbase &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; 现在已经有一个未打包进区块的交易在交易池中。txpool.status返回正在等待打包的交易。pending表示已经提交还未被处理的交易 &gt; txpool.status { pending: 1, queued: 0 } 查看pending交易详情 &gt; txpool.inspect.pending { 0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65: { 1: &quot;0x0CDBA6A391a52155042D4709A90fBC9ed3B72F06: 20000000000000000000 wei + 90000 gas × 1000000000 wei&quot; } } 5）挖矿 要使交易被处理，必须要挖矿， 这里启动挖矿，然后等到挖到第一个区块之后就停止挖矿 miner.start(1);admin.sleepBlocks(1);miner.stop(); 6)区块 之前交易的hash值0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745 得到发起交易时的详情 eth.getTransaction(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 下面是交易被打包进区块时详细信息： eth.getTransactionReceipt(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 查看当前区块总数 eth.blockNumber 查询最新区块 eth.getBlock(‘latest’) 返回区块number的信息 eth.getBlock(0) 4远程节点管理 重新开一台机子（当然贫困的我是重开了一个虚拟机） 依照上面配置环境后启动节点。注意gensis.block需要一样。 添加其他节点 可以通过admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是连接的，并且启动时指定的networkid相同。 通过下面的命令获得另一个节点的ecode信息 &gt; admin.nodeInfo.enode &quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@127.0.0.1:30303?discport=0&quot; 链接节点2： &gt; admin.addPeer(&quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@192.168.183.137:30303?discport=0&quot;) true 注意这里需要把ip地址改成节点2的ip地址。 连接成功后，节点二会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块。 查看已连接到的节点" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yujuan110/article/details/83721440 我的系统：CentOS7 64位 环境需要：Go 1.9以上版本 geth工具 WARN [11-04|09:34:47.411] System clock seems off by -10h15m43.047110838s, which can prevent network connectivity WARN [11-04|09:34:47.411] Please enable network time synchronisation in system settings. 一.环境搭建 1.安装Go 下载源码 https://golang.org/dl/ 找到适合自己操作系统的版本，必须1.9版本以上。我安装的是1.9.5 解压到/usr/local下 tar -zxvf go1.9.5.linux-amd64.tar.gz -C /usr/local/ 创建软链接 ln -s /usr/local/go/bin/go /usr/bin/go 测试是否成功 go version #go version go1.9.5 linux/amd64 2.安装geth工具 下载geth源码 git clone https://github.com/ethereum/go-ethereum.git 解压到/usr/local/下 unzip -d /usr/local/ go-ethereum-master.zip 编译源码 cd /usr/local/go-ethereum make 成功的话会出现如下： Done building. Run &quot;/usr/local/go-ethereum-master/build/bin/geth&quot; to launch geth. 创建软链接 这样我们可以直接用geth命令，而不用输入路径 ln -s /usr/local/go-ethereum-master/build/bin/geth /usr/bin/geth make过程中 如果出现以下错误： exec: “gcc”: executable file not found in $PATH 则是没有安装gcc的原因，执行 yum install gcc 二.搭建私有链 1.创建用户 mkdir geth cd geth 进入geth控制台 geth --datadir db --nodiscover console 创建用户 &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 查看用户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 给用户创建别名 &gt; yujuan=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; hcb=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 可以看到在db目录下，有个keystore目录，里面已经存了我们刚刚创建的两个账户。 [root@localhost mychain]# tree . ├── geth │ ├── chaindata │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ ├── LOCK │ ├── nodekey │ ├── nodes │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ └── transactions.rlp ├── geth.ipc └── keystore ├── UTC--2018-11-04T16-02-52.181405978Z--12844bb3206f10a331557bffb7c8d34ee4ca8b65 └── UTC--2018-11-04T16-03-15.055116889Z--a6faa81cad6a3b038d9a51db80cedbe65184c7e2 2.传世区块配置文件 cd mychain vim gensis.json 在gensis.json中输入如下内容 { &quot;alloc&quot;: { &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;: { &quot;balance&quot;: &quot;999000000000000000000&quot; } }, &quot;config&quot;:{ &quot;chainId&quot;:15, &quot;homesteadBlock&quot;:0, &quot;eip155Block&quot;:0, &quot;eip158Block&quot;:0 }, &quot;nonce&quot;:&quot;0x0000000000000001&quot;, &quot;mixhash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x01&quot;, &quot;coinbase&quot;:&quot;0x0000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;parentHash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x777573686f756865&quot;, &quot;gasLimit&quot;:&quot;0xffffffff&quot; } 注意这里的alloc后的地址要用之前创建的地址 2.初始化 准备好创世区块配置文件后，需要初始化区块链，将上面的传世区块信息写入到区块链中。 始初始化区块 geth --datadir “./mychain/” init ./mychain/gensis.json –datadir 指定数据存放目录 可能出现如下错误，原因是前面启动私有链时已经创建了默认的创世区块 Fatal: Failed to write genesis block: database already contains an incompatible genesis block 如下删除数据 geth removedb 成功的话可以看到如下结果 [root@localhost blockchain]# geth --datadir &quot;./mychain/&quot; init ./mychain/gensis.json WARN [11-04|11:59:11.370] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 INFO [11-04|11:59:11.380] Maximum peer count ETH=25 LES=0 total=25 INFO [11-04|11:59:11.383] Allocated cache and file handles database=/home/blockchain/mychain/geth/chaindata cache=16 handles=16 INFO [11-04|11:59:11.411] Writing custom genesis block INFO [11-04|11:59:11.412] Persisted trie from memory database nodes=1 size=149.00B time=230.093µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.412] Successfully wrote genesis state database=chaindata hash=481cfe…9fd026 INFO [11-04|11:59:11.412] Allocated cache and file handles database=/home/blockchain/mychain/geth/lightchaindata cache=16 handles=16 INFO [11-04|11:59:11.425] Writing custom genesis block INFO [11-04|11:59:11.426] Persisted trie from memory database nodes=1 size=149.00B time=1.090266ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.427] Successfully wrote genesis state database=lightchaindata hash=481cfe…9fd026 3.测试基本的操作 1）此时再查看余额，可以看到 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;] &gt; eth.getBalance(eth.accounts[0]) 999000000000000000000 2）转账 &gt; a1=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; a2=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 我们从账户a1转10个以太币给a2 转账之前需要先对账户a1解锁 &gt; personal.unlockAccount(a1,&quot;123456&quot;) true 转账 &gt; eth.sendTransaction({from:a1, to:a2, value:web3.toWei(10,&quot;ether&quot;)}) INFO [11-04|12:28:37.209] Setting new local account address=0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65 INFO [11-04|12:28:37.210] Submitted transaction fullhash=0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56 recipient=0xA6fAA81cAD6A3b038D9a51DB80CEDbe65184c7E2 &quot;0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56&quot; 交易已经成功执行，最后一排即是交易的hash值 那我们再来看一下两个账户的余额 &gt; eth.getBalance(a1) 999000000000000000000 &gt; eth.getBalance(a2) 0 奇怪，为什么账户的余额根本就没有变呢。那是因为这里没有矿工参与，所以也没有人来将交易打包写入区块。 3）启动节点 geth --datadir &quot;./mychain&quot; --rpc --rpcaddr=0.0.0.0 --rpcport 8545 --rpccorsdomain &quot;*&quot; --rpcapi &quot;eth,net,web3,personal,admin,ssh,txpool,debug,miner&quot; --nodiscover --maxpeers 30 --networkid 1981 --mine --minerthreads 1 --etherbase &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; console 这样我们就成功运行了一个私有链，再稍过一会儿 就会发现出现了斧头，说明已经开始挖矿了 这个时候我们再来看刚刚转账后的账户余额 &gt; web3.fromWei(eth.getBalance(eth.accounts[0])) 994 &gt; web3.fromWei(eth.getBalance(eth.accounts[1])) 10 web3.fromWei是将Wei转换成ether 因为我们设置的矿工奖励地址是accounts[0],所以这里的账户余额是994,而不是989 4) 交易 通过attach命令，连接一个已经启动的节点，启动JS命令环境 geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc 成功进入 [root@localhost blockchain]# geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc WARN [11-04|14:01:44.332] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-unstable/linux-amd64/go1.9.5 coinbase: 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 at block: 1 (Sun, 04 Nov 2018 12:43:43 EST) datadir: /home/blockchain/mychain modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 现在开始挖矿 可以通过miner.setEtherbase(eth.accounts[0])来设置挖矿奖励地址 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;, &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot;] &gt; a2=eth.accounts[2] &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; a0=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.unlockAccount(a0) Unlock account 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 Passphrase: true &gt; eth.sendTransaction({from:a0,to:a2,value:web3.toWei(20,&quot;ether&quot;)}) &quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot; 将账户a2设置为挖矿奖励地址 &gt; miner.setEtherbase(a2) true &gt; eth.coinbase &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; 现在已经有一个未打包进区块的交易在交易池中。txpool.status返回正在等待打包的交易。pending表示已经提交还未被处理的交易 &gt; txpool.status { pending: 1, queued: 0 } 查看pending交易详情 &gt; txpool.inspect.pending { 0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65: { 1: &quot;0x0CDBA6A391a52155042D4709A90fBC9ed3B72F06: 20000000000000000000 wei + 90000 gas × 1000000000 wei&quot; } } 5）挖矿 要使交易被处理，必须要挖矿， 这里启动挖矿，然后等到挖到第一个区块之后就停止挖矿 miner.start(1);admin.sleepBlocks(1);miner.stop(); 6)区块 之前交易的hash值0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745 得到发起交易时的详情 eth.getTransaction(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 下面是交易被打包进区块时详细信息： eth.getTransactionReceipt(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 查看当前区块总数 eth.blockNumber 查询最新区块 eth.getBlock(‘latest’) 返回区块number的信息 eth.getBlock(0) 4远程节点管理 重新开一台机子（当然贫困的我是重开了一个虚拟机） 依照上面配置环境后启动节点。注意gensis.block需要一样。 添加其他节点 可以通过admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是连接的，并且启动时指定的networkid相同。 通过下面的命令获得另一个节点的ecode信息 &gt; admin.nodeInfo.enode &quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@127.0.0.1:30303?discport=0&quot; 链接节点2： &gt; admin.addPeer(&quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@192.168.183.137:30303?discport=0&quot;) true 注意这里需要把ip地址改成节点2的ip地址。 连接成功后，节点二会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块。 查看已连接到的节点" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yujuan110/article/details/83721440 我的系统：CentOS7 64位 环境需要：Go 1.9以上版本 geth工具 WARN [11-04|09:34:47.411] System clock seems off by -10h15m43.047110838s, which can prevent network connectivity WARN [11-04|09:34:47.411] Please enable network time synchronisation in system settings. 一.环境搭建 1.安装Go 下载源码 https://golang.org/dl/ 找到适合自己操作系统的版本，必须1.9版本以上。我安装的是1.9.5 解压到/usr/local下 tar -zxvf go1.9.5.linux-amd64.tar.gz -C /usr/local/ 创建软链接 ln -s /usr/local/go/bin/go /usr/bin/go 测试是否成功 go version #go version go1.9.5 linux/amd64 2.安装geth工具 下载geth源码 git clone https://github.com/ethereum/go-ethereum.git 解压到/usr/local/下 unzip -d /usr/local/ go-ethereum-master.zip 编译源码 cd /usr/local/go-ethereum make 成功的话会出现如下： Done building. Run &quot;/usr/local/go-ethereum-master/build/bin/geth&quot; to launch geth. 创建软链接 这样我们可以直接用geth命令，而不用输入路径 ln -s /usr/local/go-ethereum-master/build/bin/geth /usr/bin/geth make过程中 如果出现以下错误： exec: “gcc”: executable file not found in $PATH 则是没有安装gcc的原因，执行 yum install gcc 二.搭建私有链 1.创建用户 mkdir geth cd geth 进入geth控制台 geth --datadir db --nodiscover console 创建用户 &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.newAccount() Passphrase: Repeat passphrase: &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 查看用户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 给用户创建别名 &gt; yujuan=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; hcb=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 可以看到在db目录下，有个keystore目录，里面已经存了我们刚刚创建的两个账户。 [root@localhost mychain]# tree . ├── geth │ ├── chaindata │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ ├── LOCK │ ├── nodekey │ ├── nodes │ │ ├── 000001.log │ │ ├── CURRENT │ │ ├── LOCK │ │ ├── LOG │ │ └── MANIFEST-000000 │ └── transactions.rlp ├── geth.ipc └── keystore ├── UTC--2018-11-04T16-02-52.181405978Z--12844bb3206f10a331557bffb7c8d34ee4ca8b65 └── UTC--2018-11-04T16-03-15.055116889Z--a6faa81cad6a3b038d9a51db80cedbe65184c7e2 2.传世区块配置文件 cd mychain vim gensis.json 在gensis.json中输入如下内容 { &quot;alloc&quot;: { &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;: { &quot;balance&quot;: &quot;999000000000000000000&quot; } }, &quot;config&quot;:{ &quot;chainId&quot;:15, &quot;homesteadBlock&quot;:0, &quot;eip155Block&quot;:0, &quot;eip158Block&quot;:0 }, &quot;nonce&quot;:&quot;0x0000000000000001&quot;, &quot;mixhash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x01&quot;, &quot;coinbase&quot;:&quot;0x0000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;parentHash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x777573686f756865&quot;, &quot;gasLimit&quot;:&quot;0xffffffff&quot; } 注意这里的alloc后的地址要用之前创建的地址 2.初始化 准备好创世区块配置文件后，需要初始化区块链，将上面的传世区块信息写入到区块链中。 始初始化区块 geth --datadir “./mychain/” init ./mychain/gensis.json –datadir 指定数据存放目录 可能出现如下错误，原因是前面启动私有链时已经创建了默认的创世区块 Fatal: Failed to write genesis block: database already contains an incompatible genesis block 如下删除数据 geth removedb 成功的话可以看到如下结果 [root@localhost blockchain]# geth --datadir &quot;./mychain/&quot; init ./mychain/gensis.json WARN [11-04|11:59:11.370] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 INFO [11-04|11:59:11.380] Maximum peer count ETH=25 LES=0 total=25 INFO [11-04|11:59:11.383] Allocated cache and file handles database=/home/blockchain/mychain/geth/chaindata cache=16 handles=16 INFO [11-04|11:59:11.411] Writing custom genesis block INFO [11-04|11:59:11.412] Persisted trie from memory database nodes=1 size=149.00B time=230.093µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.412] Successfully wrote genesis state database=chaindata hash=481cfe…9fd026 INFO [11-04|11:59:11.412] Allocated cache and file handles database=/home/blockchain/mychain/geth/lightchaindata cache=16 handles=16 INFO [11-04|11:59:11.425] Writing custom genesis block INFO [11-04|11:59:11.426] Persisted trie from memory database nodes=1 size=149.00B time=1.090266ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [11-04|11:59:11.427] Successfully wrote genesis state database=lightchaindata hash=481cfe…9fd026 3.测试基本的操作 1）此时再查看余额，可以看到 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;] &gt; eth.getBalance(eth.accounts[0]) 999000000000000000000 2）转账 &gt; a1=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; a2=eth.accounts[1] &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot; 我们从账户a1转10个以太币给a2 转账之前需要先对账户a1解锁 &gt; personal.unlockAccount(a1,&quot;123456&quot;) true 转账 &gt; eth.sendTransaction({from:a1, to:a2, value:web3.toWei(10,&quot;ether&quot;)}) INFO [11-04|12:28:37.209] Setting new local account address=0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65 INFO [11-04|12:28:37.210] Submitted transaction fullhash=0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56 recipient=0xA6fAA81cAD6A3b038D9a51DB80CEDbe65184c7E2 &quot;0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56&quot; 交易已经成功执行，最后一排即是交易的hash值 那我们再来看一下两个账户的余额 &gt; eth.getBalance(a1) 999000000000000000000 &gt; eth.getBalance(a2) 0 奇怪，为什么账户的余额根本就没有变呢。那是因为这里没有矿工参与，所以也没有人来将交易打包写入区块。 3）启动节点 geth --datadir &quot;./mychain&quot; --rpc --rpcaddr=0.0.0.0 --rpcport 8545 --rpccorsdomain &quot;*&quot; --rpcapi &quot;eth,net,web3,personal,admin,ssh,txpool,debug,miner&quot; --nodiscover --maxpeers 30 --networkid 1981 --mine --minerthreads 1 --etherbase &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; console 这样我们就成功运行了一个私有链，再稍过一会儿 就会发现出现了斧头，说明已经开始挖矿了 这个时候我们再来看刚刚转账后的账户余额 &gt; web3.fromWei(eth.getBalance(eth.accounts[0])) 994 &gt; web3.fromWei(eth.getBalance(eth.accounts[1])) 10 web3.fromWei是将Wei转换成ether 因为我们设置的矿工奖励地址是accounts[0],所以这里的账户余额是994,而不是989 4) 交易 通过attach命令，连接一个已经启动的节点，启动JS命令环境 geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc 成功进入 [root@localhost blockchain]# geth --datadir &#39;./mychain/&#39; attach ipc:./mychain/geth.ipc WARN [11-04|14:01:44.332] Sanitizing cache to Go&#39;s GC limits provided=1024 updated=324 Welcome to the Geth JavaScript console! instance: Geth/v1.8.18-unstable/linux-amd64/go1.9.5 coinbase: 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 at block: 1 (Sun, 04 Nov 2018 12:43:43 EST) datadir: /home/blockchain/mychain modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 现在开始挖矿 可以通过miner.setEtherbase(eth.accounts[0])来设置挖矿奖励地址 &gt; eth.accounts [&quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot;, &quot;0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2&quot;, &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot;] &gt; a2=eth.accounts[2] &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; a0=eth.accounts[0] &quot;0x12844bb3206f10a331557bffb7c8d34ee4ca8b65&quot; &gt; personal.unlockAccount(a0) Unlock account 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65 Passphrase: true &gt; eth.sendTransaction({from:a0,to:a2,value:web3.toWei(20,&quot;ether&quot;)}) &quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot; 将账户a2设置为挖矿奖励地址 &gt; miner.setEtherbase(a2) true &gt; eth.coinbase &quot;0x0cdba6a391a52155042d4709a90fbc9ed3b72f06&quot; &gt; 现在已经有一个未打包进区块的交易在交易池中。txpool.status返回正在等待打包的交易。pending表示已经提交还未被处理的交易 &gt; txpool.status { pending: 1, queued: 0 } 查看pending交易详情 &gt; txpool.inspect.pending { 0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65: { 1: &quot;0x0CDBA6A391a52155042D4709A90fBC9ed3B72F06: 20000000000000000000 wei + 90000 gas × 1000000000 wei&quot; } } 5）挖矿 要使交易被处理，必须要挖矿， 这里启动挖矿，然后等到挖到第一个区块之后就停止挖矿 miner.start(1);admin.sleepBlocks(1);miner.stop(); 6)区块 之前交易的hash值0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745 得到发起交易时的详情 eth.getTransaction(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 下面是交易被打包进区块时详细信息： eth.getTransactionReceipt(&quot;0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745&quot;) 查看当前区块总数 eth.blockNumber 查询最新区块 eth.getBlock(‘latest’) 返回区块number的信息 eth.getBlock(0) 4远程节点管理 重新开一台机子（当然贫困的我是重开了一个虚拟机） 依照上面配置环境后启动节点。注意gensis.block需要一样。 添加其他节点 可以通过admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是连接的，并且启动时指定的networkid相同。 通过下面的命令获得另一个节点的ecode信息 &gt; admin.nodeInfo.enode &quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@127.0.0.1:30303?discport=0&quot; 链接节点2： &gt; admin.addPeer(&quot;enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@192.168.183.137:30303?discport=0&quot;) true 注意这里需要把ip地址改成节点2的ip地址。 连接成功后，节点二会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块。 查看已连接到的节点","@type":"BlogPosting","url":"/2018/11/04/f80374f97c933f16f35fc53d3ab4c320.html","headline":"以太坊搭建私有链(非常详细！！！）(一）","dateModified":"2018-11-04T00:00:00+08:00","datePublished":"2018-11-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/11/04/f80374f97c933f16f35fc53d3ab4c320.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊搭建私有链(非常详细！！！）(一）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yujuan110/article/details/83721440 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>我的系统：CentOS7 64位</p> 
  <p>环境需要：Go 1.9以上版本<br> geth工具</p> 
  <pre><code>WARN [11-04|09:34:47.411] System clock seems off by -10h15m43.047110838s, which can prevent network connectivity 
WARN [11-04|09:34:47.411] Please enable network time synchronisation in system settings. 
</code></pre> 
  <h1><a id="_8"></a>一.环境搭建</h1> 
  <h2><a id="1Go_9"></a>1.安装Go</h2> 
  <p>下载源码 <a href="https://golang.org/dl/" rel="nofollow">https://golang.org/dl/</a><br> 找到适合自己操作系统的版本，必须1.9版本以上。我安装的是1.9.5<br> 解压到/usr/local下</p> 
  <pre><code>tar   -zxvf   go1.9.5.linux-amd64.tar.gz   -C /usr/local/
</code></pre> 
  <p>创建软链接</p> 
  <pre><code>ln -s /usr/local/go/bin/go  /usr/bin/go
</code></pre> 
  <p>测试是否成功</p> 
  <pre><code>go version
#go version go1.9.5 linux/amd64
</code></pre> 
  <h2><a id="2geth_23"></a>2.安装geth工具</h2> 
  <p>下载geth源码</p> 
  <pre><code>git clone https://github.com/ethereum/go-ethereum.git
</code></pre> 
  <p>解压到/usr/local/下</p> 
  <pre><code>unzip -d /usr/local/ go-ethereum-master.zip
</code></pre> 
  <p>编译源码</p> 
  <pre><code>cd /usr/local/go-ethereum
make
</code></pre> 
  <p>成功的话会出现如下：</p> 
  <pre><code>Done building.
Run "/usr/local/go-ethereum-master/build/bin/geth" to launch geth.
</code></pre> 
  <p>创建软链接 这样我们可以直接用geth命令，而不用输入路径</p> 
  <pre><code>ln -s /usr/local/go-ethereum-master/build/bin/geth /usr/bin/geth
</code></pre> 
  <p>make过程中 如果出现以下错误：<br> exec: “gcc”: executable file not found in $PATH</p> 
  <p>则是没有安装gcc的原因，执行</p> 
  <pre><code>yum install gcc
</code></pre> 
  <h1><a id="_50"></a>二.搭建私有链</h1> 
  <h2><a id="1_51"></a>1.创建用户</h2> 
  <pre><code>mkdir geth
cd geth
</code></pre> 
  <p>进入geth控制台</p> 
  <pre><code>geth  --datadir db  --nodiscover console
</code></pre> 
  <p>创建用户</p> 
  <pre><code>&gt; personal.newAccount()
Passphrase: 
Repeat passphrase: 
"0x12844bb3206f10a331557bffb7c8d34ee4ca8b65"
&gt; personal.newAccount()
Passphrase: 
Repeat passphrase: 
"0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2"
</code></pre> 
  <p>查看用户余额</p> 
  <pre><code>&gt; eth.getBalance(eth.accounts[0])
0
&gt; eth.getBalance(eth.accounts[1])
0
</code></pre> 
  <p>给用户创建别名</p> 
  <pre><code>&gt; yujuan=eth.accounts[0]
"0x12844bb3206f10a331557bffb7c8d34ee4ca8b65"
&gt; hcb=eth.accounts[1]
"0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2"
</code></pre> 
  <p>可以看到在db目录下，有个keystore目录，里面已经存了我们刚刚创建的两个账户。</p> 
  <pre><code>[root@localhost mychain]# tree
.
├── geth
│   ├── chaindata
│   │   ├── 000001.log
│   │   ├── CURRENT
│   │   ├── LOCK
│   │   ├── LOG
│   │   └── MANIFEST-000000
│   ├── LOCK
│   ├── nodekey
│   ├── nodes
│   │   ├── 000001.log
│   │   ├── CURRENT
│   │   ├── LOCK
│   │   ├── LOG
│   │   └── MANIFEST-000000
│   └── transactions.rlp
├── geth.ipc
└── keystore
    ├── UTC--2018-11-04T16-02-52.181405978Z--12844bb3206f10a331557bffb7c8d34ee4ca8b65
    └── UTC--2018-11-04T16-03-15.055116889Z--a6faa81cad6a3b038d9a51db80cedbe65184c7e2
</code></pre> 
  <h2><a id="2_111"></a>2.传世区块配置文件</h2> 
  <pre><code>cd mychain
 vim gensis.json
</code></pre> 
  <p>在gensis.json中输入如下内容</p> 
  <pre><code>{
   "alloc": {
      "0x12844bb3206f10a331557bffb7c8d34ee4ca8b65": {
      "balance": "999000000000000000000"
      }
   },
    "config":{
        "chainId":15,
        "homesteadBlock":0,
        "eip155Block":0,
        "eip158Block":0
    },
    "nonce":"0x0000000000000001",
    "mixhash":"0x0000000000000000000000000000000000000000000000000000000000000000",
    "difficulty": "0x01",
    "coinbase":"0x0000000000000000000000000000000000000000",
    "timestamp": "0x00",
    "parentHash":"0x0000000000000000000000000000000000000000000000000000000000000000",
    "extraData": "0x777573686f756865",
    "gasLimit":"0xffffffff"
}
</code></pre> 
  <p>注意这里的alloc后的地址要用之前创建的地址</p> 
  <h2><a id="2_141"></a>2.初始化</h2> 
  <p>准备好创世区块配置文件后，需要初始化区块链，将上面的传世区块信息写入到区块链中。</p> 
  <p>始初始化区块</p> 
  <p>geth --datadir “./mychain/” init ./mychain/gensis.json</p> 
  <p>–datadir 指定数据存放目录<br> 可能出现如下错误，原因是前面启动私有链时已经创建了默认的创世区块</p> 
  <pre><code>Fatal: Failed to write genesis block: database already contains an incompatible genesis block
</code></pre> 
  <p>如下删除数据</p> 
  <pre><code>geth removedb
</code></pre> 
  <p>成功的话可以看到如下结果</p> 
  <pre><code>[root@localhost blockchain]# geth --datadir "./mychain/" init ./mychain/gensis.json 
WARN [11-04|11:59:11.370] Sanitizing cache to Go's GC limits       provided=1024 updated=324
INFO [11-04|11:59:11.380] Maximum peer count                       ETH=25 LES=0 total=25
INFO [11-04|11:59:11.383] Allocated cache and file handles         database=/home/blockchain/mychain/geth/chaindata cache=16 handles=16
INFO [11-04|11:59:11.411] Writing custom genesis block 
INFO [11-04|11:59:11.412] Persisted trie from memory database      nodes=1 size=149.00B time=230.093µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [11-04|11:59:11.412] Successfully wrote genesis state         database=chaindata                               hash=481cfe…9fd026
INFO [11-04|11:59:11.412] Allocated cache and file handles         database=/home/blockchain/mychain/geth/lightchaindata cache=16 handles=16
INFO [11-04|11:59:11.425] Writing custom genesis block 
INFO [11-04|11:59:11.426] Persisted trie from memory database      nodes=1 size=149.00B time=1.090266ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [11-04|11:59:11.427] Successfully wrote genesis state         database=lightchaindata                               hash=481cfe…9fd026
</code></pre> 
  <h2><a id="3_172"></a>3.测试基本的操作</h2> 
  <h3><a id="1_173"></a>1）此时再查看余额，可以看到</h3> 
  <pre><code>&gt; eth.accounts
["0x12844bb3206f10a331557bffb7c8d34ee4ca8b65", "0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2"]
&gt; eth.getBalance(eth.accounts[0])
999000000000000000000
</code></pre> 
  <h3><a id="2_179"></a>2）转账</h3> 
  <pre><code>&gt; a1=eth.accounts[0]
"0x12844bb3206f10a331557bffb7c8d34ee4ca8b65"
&gt; a2=eth.accounts[1]
"0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2"
我们从账户a1转10个以太币给a2
转账之前需要先对账户a1解锁
&gt; personal.unlockAccount(a1,"123456")
true
</code></pre> 
  <p>转账</p> 
  <pre><code>&gt; eth.sendTransaction({from:a1, to:a2, value:web3.toWei(10,"ether")})
INFO [11-04|12:28:37.209] Setting new local account                address=0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65
INFO [11-04|12:28:37.210] Submitted transaction                    fullhash=0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56 recipient=0xA6fAA81cAD6A3b038D9a51DB80CEDbe65184c7E2
"0x21d4e590f240322b2ab16b750f6e7ded187242ecdfb17c49cb5d229649f1bc56"
</code></pre> 
  <p>交易已经成功执行，最后一排即是交易的hash值<br> 那我们再来看一下两个账户的余额</p> 
  <pre><code>&gt; eth.getBalance(a1)
999000000000000000000
&gt; eth.getBalance(a2)
0
</code></pre> 
  <p>奇怪，为什么账户的余额根本就没有变呢。那是因为这里没有矿工参与，所以也没有人来将交易打包写入区块。</p> 
  <h3><a id="3_205"></a>3）启动节点</h3> 
  <pre><code>    geth --datadir "./mychain" --rpc --rpcaddr=0.0.0.0 --rpcport 8545 --rpccorsdomain "*"  --rpcapi "eth,net,web3,personal,admin,ssh,txpool,debug,miner" --nodiscover --maxpeers 30  --networkid 1981 --mine --minerthreads 1 --etherbase  "0x12844bb3206f10a331557bffb7c8d34ee4ca8b65" console
</code></pre> 
  <p><img src="https://img-blog.csdnimg.cn/20181105200454391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1anVhbjExMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">这样我们就成功运行了一个私有链，再稍过一会儿<br> 就会发现出现了斧头，说明已经开始挖矿了<br> 这个时候我们再来看刚刚转账后的账户余额</p> 
  <pre><code>&gt; web3.fromWei(eth.getBalance(eth.accounts[0]))
994
&gt; web3.fromWei(eth.getBalance(eth.accounts[1]))
10
</code></pre> 
  <p>web3.fromWei是将Wei转换成ether<br> 因为我们设置的矿工奖励地址是accounts[0],所以这里的账户余额是994,而不是989</p> 
  <h3><a id="4__220"></a>4) 交易</h3> 
  <p>通过attach命令，连接一个已经启动的节点，启动JS命令环境</p> 
  <pre><code>geth --datadir './mychain/' attach ipc:./mychain/geth.ipc 
</code></pre> 
  <p>成功进入</p> 
  <pre><code>  [root@localhost blockchain]# geth --datadir './mychain/' attach ipc:./mychain/geth.ipc 
    WARN [11-04|14:01:44.332] Sanitizing cache to Go's GC limits       provided=1024 updated=324
    Welcome to the Geth JavaScript console!
    
    instance: Geth/v1.8.18-unstable/linux-amd64/go1.9.5
    coinbase: 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65
    at block: 1 (Sun, 04 Nov 2018 12:43:43 EST)
     datadir: /home/blockchain/mychain
     modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
</code></pre> 
  <p>现在开始挖矿<br> 可以通过miner.setEtherbase(eth.accounts[0])来设置挖矿奖励地址</p> 
  <pre><code>&gt; eth.accounts
["0x12844bb3206f10a331557bffb7c8d34ee4ca8b65", "0xa6faa81cad6a3b038d9a51db80cedbe65184c7e2", "0x0cdba6a391a52155042d4709a90fbc9ed3b72f06"]
 &gt; a2=eth.accounts[2]
  "0x0cdba6a391a52155042d4709a90fbc9ed3b72f06"
&gt; a0=eth.accounts[0]
"0x12844bb3206f10a331557bffb7c8d34ee4ca8b65"
&gt; personal.unlockAccount(a0)
Unlock account 0x12844bb3206f10a331557bffb7c8d34ee4ca8b65
Passphrase: 
 true
 &gt; eth.sendTransaction({from:a0,to:a2,value:web3.toWei(20,"ether")})
"0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745"
</code></pre> 
  <p>将账户a2设置为挖矿奖励地址</p> 
  <pre><code>&gt; miner.setEtherbase(a2)
 true
&gt; eth.coinbase
"0x0cdba6a391a52155042d4709a90fbc9ed3b72f06"
&gt; 
</code></pre> 
  <p>现在已经有一个未打包进区块的交易在交易池中。txpool.status返回正在等待打包的交易。pending表示已经提交还未被处理的交易</p> 
  <pre><code>&gt; txpool.status
{
  pending: 1,
  queued: 0
}
</code></pre> 
  <p>查看pending交易详情</p> 
  <pre><code>&gt; txpool.inspect.pending
{
  0x12844bB3206F10A331557bFfB7c8D34eE4ca8b65: {
    1: "0x0CDBA6A391a52155042D4709A90fBC9ed3B72F06: 20000000000000000000 wei + 90000 gas × 1000000000 wei"
  }
}
</code></pre> 
  <h3><a id="5_277"></a>5）挖矿</h3> 
  <p>要使交易被处理，必须要挖矿，<br> 这里启动挖矿，然后等到挖到第一个区块之后就停止挖矿<br> miner.start(1);admin.sleepBlocks(1);miner.stop();</p> 
  <h3><a id="6_282"></a>6)区块</h3> 
  <p>之前交易的hash值0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745<br> 得到发起交易时的详情</p> 
  <pre><code>eth.getTransaction("0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745")
</code></pre> 
  <p>下面是交易被打包进区块时详细信息：</p> 
  <pre><code>eth.getTransactionReceipt("0x0d711995130df3809294b5e8f62652a91cd9154188282b10c250fc99a6d06745")
</code></pre> 
  <p>查看当前区块总数<br> eth.blockNumber<br> 查询最新区块<br> eth.getBlock(‘latest’)<br> 返回区块number的信息<br> eth.getBlock(0)</p> 
  <h2><a id="4_302"></a>4远程节点管理</h2> 
  <p>重新开一台机子（当然贫困的我是重开了一个虚拟机）<br> 依照上面配置环境后启动节点。注意gensis.block需要一样。</p> 
  <p>添加其他节点<br> 可以通过admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是连接的，并且启动时指定的networkid相同。<br> 通过下面的命令获得另一个节点的ecode信息</p> 
  <pre><code>&gt; admin.nodeInfo.enode
"enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@127.0.0.1:30303?discport=0"
</code></pre> 
  <p>链接节点2：</p> 
  <pre><code>&gt; admin.addPeer("enode://c56903836723db6d643a2b9fb13e11ed30e53618606c600f7c0ebab89246d24b381df7ef6f08b19461b423b72d88d62dcbf6aa2989024093b24536633977515a@192.168.183.137:30303?discport=0")
true
</code></pre> 
  <p>注意这里需要把ip地址改成节点2的ip地址。<br> 连接成功后，节点二会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块。<br> 查看已连接到的节点</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center">  
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
