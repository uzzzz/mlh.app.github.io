<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《比特币：一种点对点电子现金系统》解读 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《比特币：一种点对点电子现金系统》解读" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/abcamus/article/details/83715004 摘要 为了去除现金系统对第三方金融机构的依赖（譬如银行），并且解决双花（double spending）的问题，引入了peer-to-peer network。在这样一个网络上，交易哈希被放入一个持续增长的链，这个链基于工作量证明生成，使得任何人不得篡改历史记录，除非再做一次工作量证明。最长的链不仅是发生的所有事件的见证，同时证明它来自于算力最强的节点。只要大部分的CPU算力是被善良节点（不会攻击网络）控制，这些节点就会不断的生成最长的链，并且抵制恶意的攻击。所有节点可以随时加入或者离开这个网络，只要接受最长的链这个事实不变的话。 一、引言 讲了基于第三方信用机构，不可避免的诈骗和篡改交易的情况。引入点对点分布式时间戳服务器，即blockchain，来防止双花。 二、交易 定义电子货币形式为一连串的数字签名。每一个货币拥有者对上一笔交易以及下一个货币拥有者进行hash签名，payee可以很容易的验证这笔交易是给自己的。 这样存在一个问题：怎么确定一笔交易没有被双花呢？即A即发了一笔给B，这笔钱同时也发给了C。只有公开所有的交易才能知道到底有没有double-spending，以及我们需要这样一个系统：所有参与者都认同唯一的历史记录，按照交易顺序排列。 三、时间戳服务器 构建基于block的链式结构，每个block的哈希基于上一个block的哈希和当前block中所有的item生成，这样的话，每一个block的哈希包含了之前所有的时间戳，每生成一个新的block，就是对之前所有时间戳的一次加强（保证唯一性）。 四、工作量证明 引入一种哈希算法，譬如SHA-256，带多个前导0，而且使得工作量随着前导0的数量呈现指数增长。把这样一种工作量证明的方法引入到前面的时间戳服务器中，只有当发现满足前导0数量时，block nonce值才会加一（证明当前block有效）。随着block的增长，如果要改变一个block，那就意味着要重新计算（碰撞）之后所有的block hash。 同时，工作量证明也解决了多数人表决的机制。假设一个IP一票，那么可以随意的伪造IP进行投票。Proof-of-work相当于一CPU一票。多数人的投票体现在了最长的chain当中。如果大多数的CPU是诚信节点的，那么最长的链将会是可靠的。 为了补偿硬件计算速度的增长，以及参与的节点数量的增加，block的难度会根据每小时生成block的数量进行调整，如果太快，难度就会增加。 五、网络 上述网络的运行方式如下： 新的交易被广播给所有节点。 每个节点收集新的交易进入一个block。 每个节点对各自的block做proof-of-work。 当一个节点证明了一个新的block，该block被广播给所有节点。 其他节点如果验证了新的block中的交易是有效并且没有出现过，那么接受新的block。 节点如果接受新的block，它将基于这个block（作为previous hash）继续生成新的block。 所有的节点都认当前最长的链，并且基于该链生成新的block。 如果两个节点同时广播了不同的block，一部分节点收到了第一个，而另外的收到了第二个，那么就形成了两条chain。在这种情况下，节点会保存晚收到的那个block，继续在先收到的block后面添加block。等到下一次PoW完成后，节点就会收到新的block，根据这个新的block就知道之前的哪个block位于最长的chain上面。在另一个branch上工作的节点就会重新切回到更长的chain上。值得一提的是：新的交易并不需要广播给所有的节点，只要它们到达足够多的节点，就会进入到新的block中。block的广播也不受消息丢失的影响。一旦一个节点没有成功收到block，当它收到下一个block的时候就知道自己已经错过了已有的block了。 六、激励 按照惯例，一个block中的第一笔交易创建了一个新的coin，用来奖励区块的创建者，相当于产生货币进行流通。同时，如果一笔交易的输入要比输出高的话，多余的部分作为交易费用支付给节点。在这种鼓励机制下，恶意节点与其消耗巨大的算力去破坏网络，不如做一些诚信的工作来的收益高。 七、对硬盘空间的利用 如果最新的一笔交易进入到了足够多的区块中，那么它之前的交易信息可以丢弃掉来节省硬盘空间。通过Merkle树来实现这种机制，同时保证区块的哈希值不变（交易位于叶子节点）。 如图所示，如果Tx0-2已经在新的block中了，那么可以减掉Tx0-2的哈希。右图因为还有一笔Tx3，Hash3要保留，同时也要保留Hash2来计算Hash23。 一个空的block header大约占80个字节，假设10分钟产生一个新的区块，每年就是80bytes624*365 = 4.2MB每年。现在计算机的内存容量，普遍在4GB，就算全部放进内存也是不成问题的。 八、简单的支付验证 如果要验证一笔交易的话，用户并不需要完整的运行一遍节点，而只需要拿到最长链中各block的header信息即可。通过往前追溯自己的交易信息即可确认是否被接受。对于交易频繁的商业机构，还是要运行自己的节点用来在网络被攻击（伪造了block）的情况下快速验证交易。 九、价值的组合和分割 一次交易可以有多个输入和两个输出，输入指明该次交易的金钱来源（之前的tx），一个输出指支付的钱，另一个输出则是找零。 十、隐私 网络上的交易只能看到公钥，并不能和具体的个体对应上（匿名机制），就跟股票市场只看到交易是一样的。 十一、计算 假设有一个攻击者，它尝试比诚信节点更快的生成chain。假设它要给自己赚钱，那么就要构造一笔合法的交易（需要交易发起方的签名），如果是非法的，其他节点并不会认同生成的block。一个攻击者能做的也仅仅是修改掉自己之前的交易，把钱给拿回来。 诚信链和攻击者之间的竞争可以用Binomial Random Walk（二叉树随机漫步）来描述。一次成功的事件表示诚信链条涨了一个block，使得两者差距加1；一次失败的事件表示攻击者的chain涨了一个block，使得两者差距减1。那么攻击者追上诚信链条的概率类比于赌徒破产问题（Gambler’s Ruin Problem）。假设一个赌徒拥有无限的信用，可以赌无数次来达到收支平衡。计算收支平衡的概率如下： p = 诚 信 节 点 发 现 下 一 个 b l o c k p=诚信节点发现下一个block p=诚信节点发现下一个block q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q=攻击者发现下一个block q = 攻击者发现下一个blockq=攻击者发现下一个block q=攻击者发现下一个blockq=攻击者发现下一个blockq=攻击者发现下一个block q z = 攻 击 者 在 落 后 z 个 b l o c k 的 情 况 下 追 上 的 概 率 q_z = 攻击者在落后z个block的情况下追上的概率 qz​=攻击者在落后z个block的情况下追上的概率 q z = { 1 i f &nbsp; p ≤ q z = ( q p ) z i f &nbsp; p &amp;gt; q q_z = \begin{cases} 1 &amp;amp;if\ p\le q \\ z = (\frac{q}{p})^z &amp;amp;if\ p \gt q \end{cases} qz​={1z=(pq​)z​if&nbsp;p≤qif&nbsp;p&gt;q​ 假设 p &amp;gt; q p&amp;gt;q p&gt;q，攻击者追上诚信链条的概率随着攻击者落后的block数量呈指数递减。除非攻击者在网络初期发动攻击，否则随着chain的不断增长，攻击成功的概率非常渺茫。 考虑一笔交易的接收者需要多久可以确认发起方无法篡改交易的问题。假设现在交易发起方是攻击者，它想要迷惑接收方一段时间，然后在把交易对象换成自己，来达到空手套白狼的目的。 在接收方收到正常交易后，攻击者立刻开始在一条平行的chain上工作，假设某个时刻，接收方已经发现有z个block跟在了正常交易的后面，那么攻击者还要赶上诚信链条的概率计算如下： 攻击者新生产的block数量服从泊松分布。 λ = z q p \lambda = z\frac{q}{p} λ=zpq​ 那么攻击者追上的概率为： 计算结果如下： 如果要使得攻击者追上的概率小于0.1% 十二、结论 就是非常简洁明了的解决了双重支付的问题，网络结构简单，而且节点可以随之离开或者加入。这个框架包含了一个P2P电子货币系统所需要的所有规则和激励措施。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/abcamus/article/details/83715004 摘要 为了去除现金系统对第三方金融机构的依赖（譬如银行），并且解决双花（double spending）的问题，引入了peer-to-peer network。在这样一个网络上，交易哈希被放入一个持续增长的链，这个链基于工作量证明生成，使得任何人不得篡改历史记录，除非再做一次工作量证明。最长的链不仅是发生的所有事件的见证，同时证明它来自于算力最强的节点。只要大部分的CPU算力是被善良节点（不会攻击网络）控制，这些节点就会不断的生成最长的链，并且抵制恶意的攻击。所有节点可以随时加入或者离开这个网络，只要接受最长的链这个事实不变的话。 一、引言 讲了基于第三方信用机构，不可避免的诈骗和篡改交易的情况。引入点对点分布式时间戳服务器，即blockchain，来防止双花。 二、交易 定义电子货币形式为一连串的数字签名。每一个货币拥有者对上一笔交易以及下一个货币拥有者进行hash签名，payee可以很容易的验证这笔交易是给自己的。 这样存在一个问题：怎么确定一笔交易没有被双花呢？即A即发了一笔给B，这笔钱同时也发给了C。只有公开所有的交易才能知道到底有没有double-spending，以及我们需要这样一个系统：所有参与者都认同唯一的历史记录，按照交易顺序排列。 三、时间戳服务器 构建基于block的链式结构，每个block的哈希基于上一个block的哈希和当前block中所有的item生成，这样的话，每一个block的哈希包含了之前所有的时间戳，每生成一个新的block，就是对之前所有时间戳的一次加强（保证唯一性）。 四、工作量证明 引入一种哈希算法，譬如SHA-256，带多个前导0，而且使得工作量随着前导0的数量呈现指数增长。把这样一种工作量证明的方法引入到前面的时间戳服务器中，只有当发现满足前导0数量时，block nonce值才会加一（证明当前block有效）。随着block的增长，如果要改变一个block，那就意味着要重新计算（碰撞）之后所有的block hash。 同时，工作量证明也解决了多数人表决的机制。假设一个IP一票，那么可以随意的伪造IP进行投票。Proof-of-work相当于一CPU一票。多数人的投票体现在了最长的chain当中。如果大多数的CPU是诚信节点的，那么最长的链将会是可靠的。 为了补偿硬件计算速度的增长，以及参与的节点数量的增加，block的难度会根据每小时生成block的数量进行调整，如果太快，难度就会增加。 五、网络 上述网络的运行方式如下： 新的交易被广播给所有节点。 每个节点收集新的交易进入一个block。 每个节点对各自的block做proof-of-work。 当一个节点证明了一个新的block，该block被广播给所有节点。 其他节点如果验证了新的block中的交易是有效并且没有出现过，那么接受新的block。 节点如果接受新的block，它将基于这个block（作为previous hash）继续生成新的block。 所有的节点都认当前最长的链，并且基于该链生成新的block。 如果两个节点同时广播了不同的block，一部分节点收到了第一个，而另外的收到了第二个，那么就形成了两条chain。在这种情况下，节点会保存晚收到的那个block，继续在先收到的block后面添加block。等到下一次PoW完成后，节点就会收到新的block，根据这个新的block就知道之前的哪个block位于最长的chain上面。在另一个branch上工作的节点就会重新切回到更长的chain上。值得一提的是：新的交易并不需要广播给所有的节点，只要它们到达足够多的节点，就会进入到新的block中。block的广播也不受消息丢失的影响。一旦一个节点没有成功收到block，当它收到下一个block的时候就知道自己已经错过了已有的block了。 六、激励 按照惯例，一个block中的第一笔交易创建了一个新的coin，用来奖励区块的创建者，相当于产生货币进行流通。同时，如果一笔交易的输入要比输出高的话，多余的部分作为交易费用支付给节点。在这种鼓励机制下，恶意节点与其消耗巨大的算力去破坏网络，不如做一些诚信的工作来的收益高。 七、对硬盘空间的利用 如果最新的一笔交易进入到了足够多的区块中，那么它之前的交易信息可以丢弃掉来节省硬盘空间。通过Merkle树来实现这种机制，同时保证区块的哈希值不变（交易位于叶子节点）。 如图所示，如果Tx0-2已经在新的block中了，那么可以减掉Tx0-2的哈希。右图因为还有一笔Tx3，Hash3要保留，同时也要保留Hash2来计算Hash23。 一个空的block header大约占80个字节，假设10分钟产生一个新的区块，每年就是80bytes624*365 = 4.2MB每年。现在计算机的内存容量，普遍在4GB，就算全部放进内存也是不成问题的。 八、简单的支付验证 如果要验证一笔交易的话，用户并不需要完整的运行一遍节点，而只需要拿到最长链中各block的header信息即可。通过往前追溯自己的交易信息即可确认是否被接受。对于交易频繁的商业机构，还是要运行自己的节点用来在网络被攻击（伪造了block）的情况下快速验证交易。 九、价值的组合和分割 一次交易可以有多个输入和两个输出，输入指明该次交易的金钱来源（之前的tx），一个输出指支付的钱，另一个输出则是找零。 十、隐私 网络上的交易只能看到公钥，并不能和具体的个体对应上（匿名机制），就跟股票市场只看到交易是一样的。 十一、计算 假设有一个攻击者，它尝试比诚信节点更快的生成chain。假设它要给自己赚钱，那么就要构造一笔合法的交易（需要交易发起方的签名），如果是非法的，其他节点并不会认同生成的block。一个攻击者能做的也仅仅是修改掉自己之前的交易，把钱给拿回来。 诚信链和攻击者之间的竞争可以用Binomial Random Walk（二叉树随机漫步）来描述。一次成功的事件表示诚信链条涨了一个block，使得两者差距加1；一次失败的事件表示攻击者的chain涨了一个block，使得两者差距减1。那么攻击者追上诚信链条的概率类比于赌徒破产问题（Gambler’s Ruin Problem）。假设一个赌徒拥有无限的信用，可以赌无数次来达到收支平衡。计算收支平衡的概率如下： p = 诚 信 节 点 发 现 下 一 个 b l o c k p=诚信节点发现下一个block p=诚信节点发现下一个block q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q=攻击者发现下一个block q = 攻击者发现下一个blockq=攻击者发现下一个block q=攻击者发现下一个blockq=攻击者发现下一个blockq=攻击者发现下一个block q z = 攻 击 者 在 落 后 z 个 b l o c k 的 情 况 下 追 上 的 概 率 q_z = 攻击者在落后z个block的情况下追上的概率 qz​=攻击者在落后z个block的情况下追上的概率 q z = { 1 i f &nbsp; p ≤ q z = ( q p ) z i f &nbsp; p &amp;gt; q q_z = \begin{cases} 1 &amp;amp;if\ p\le q \\ z = (\frac{q}{p})^z &amp;amp;if\ p \gt q \end{cases} qz​={1z=(pq​)z​if&nbsp;p≤qif&nbsp;p&gt;q​ 假设 p &amp;gt; q p&amp;gt;q p&gt;q，攻击者追上诚信链条的概率随着攻击者落后的block数量呈指数递减。除非攻击者在网络初期发动攻击，否则随着chain的不断增长，攻击成功的概率非常渺茫。 考虑一笔交易的接收者需要多久可以确认发起方无法篡改交易的问题。假设现在交易发起方是攻击者，它想要迷惑接收方一段时间，然后在把交易对象换成自己，来达到空手套白狼的目的。 在接收方收到正常交易后，攻击者立刻开始在一条平行的chain上工作，假设某个时刻，接收方已经发现有z个block跟在了正常交易的后面，那么攻击者还要赶上诚信链条的概率计算如下： 攻击者新生产的block数量服从泊松分布。 λ = z q p \lambda = z\frac{q}{p} λ=zpq​ 那么攻击者追上的概率为： 计算结果如下： 如果要使得攻击者追上的概率小于0.1% 十二、结论 就是非常简洁明了的解决了双重支付的问题，网络结构简单，而且节点可以随之离开或者加入。这个框架包含了一个P2P电子货币系统所需要的所有规则和激励措施。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/abcamus/article/details/83715004 摘要 为了去除现金系统对第三方金融机构的依赖（譬如银行），并且解决双花（double spending）的问题，引入了peer-to-peer network。在这样一个网络上，交易哈希被放入一个持续增长的链，这个链基于工作量证明生成，使得任何人不得篡改历史记录，除非再做一次工作量证明。最长的链不仅是发生的所有事件的见证，同时证明它来自于算力最强的节点。只要大部分的CPU算力是被善良节点（不会攻击网络）控制，这些节点就会不断的生成最长的链，并且抵制恶意的攻击。所有节点可以随时加入或者离开这个网络，只要接受最长的链这个事实不变的话。 一、引言 讲了基于第三方信用机构，不可避免的诈骗和篡改交易的情况。引入点对点分布式时间戳服务器，即blockchain，来防止双花。 二、交易 定义电子货币形式为一连串的数字签名。每一个货币拥有者对上一笔交易以及下一个货币拥有者进行hash签名，payee可以很容易的验证这笔交易是给自己的。 这样存在一个问题：怎么确定一笔交易没有被双花呢？即A即发了一笔给B，这笔钱同时也发给了C。只有公开所有的交易才能知道到底有没有double-spending，以及我们需要这样一个系统：所有参与者都认同唯一的历史记录，按照交易顺序排列。 三、时间戳服务器 构建基于block的链式结构，每个block的哈希基于上一个block的哈希和当前block中所有的item生成，这样的话，每一个block的哈希包含了之前所有的时间戳，每生成一个新的block，就是对之前所有时间戳的一次加强（保证唯一性）。 四、工作量证明 引入一种哈希算法，譬如SHA-256，带多个前导0，而且使得工作量随着前导0的数量呈现指数增长。把这样一种工作量证明的方法引入到前面的时间戳服务器中，只有当发现满足前导0数量时，block nonce值才会加一（证明当前block有效）。随着block的增长，如果要改变一个block，那就意味着要重新计算（碰撞）之后所有的block hash。 同时，工作量证明也解决了多数人表决的机制。假设一个IP一票，那么可以随意的伪造IP进行投票。Proof-of-work相当于一CPU一票。多数人的投票体现在了最长的chain当中。如果大多数的CPU是诚信节点的，那么最长的链将会是可靠的。 为了补偿硬件计算速度的增长，以及参与的节点数量的增加，block的难度会根据每小时生成block的数量进行调整，如果太快，难度就会增加。 五、网络 上述网络的运行方式如下： 新的交易被广播给所有节点。 每个节点收集新的交易进入一个block。 每个节点对各自的block做proof-of-work。 当一个节点证明了一个新的block，该block被广播给所有节点。 其他节点如果验证了新的block中的交易是有效并且没有出现过，那么接受新的block。 节点如果接受新的block，它将基于这个block（作为previous hash）继续生成新的block。 所有的节点都认当前最长的链，并且基于该链生成新的block。 如果两个节点同时广播了不同的block，一部分节点收到了第一个，而另外的收到了第二个，那么就形成了两条chain。在这种情况下，节点会保存晚收到的那个block，继续在先收到的block后面添加block。等到下一次PoW完成后，节点就会收到新的block，根据这个新的block就知道之前的哪个block位于最长的chain上面。在另一个branch上工作的节点就会重新切回到更长的chain上。值得一提的是：新的交易并不需要广播给所有的节点，只要它们到达足够多的节点，就会进入到新的block中。block的广播也不受消息丢失的影响。一旦一个节点没有成功收到block，当它收到下一个block的时候就知道自己已经错过了已有的block了。 六、激励 按照惯例，一个block中的第一笔交易创建了一个新的coin，用来奖励区块的创建者，相当于产生货币进行流通。同时，如果一笔交易的输入要比输出高的话，多余的部分作为交易费用支付给节点。在这种鼓励机制下，恶意节点与其消耗巨大的算力去破坏网络，不如做一些诚信的工作来的收益高。 七、对硬盘空间的利用 如果最新的一笔交易进入到了足够多的区块中，那么它之前的交易信息可以丢弃掉来节省硬盘空间。通过Merkle树来实现这种机制，同时保证区块的哈希值不变（交易位于叶子节点）。 如图所示，如果Tx0-2已经在新的block中了，那么可以减掉Tx0-2的哈希。右图因为还有一笔Tx3，Hash3要保留，同时也要保留Hash2来计算Hash23。 一个空的block header大约占80个字节，假设10分钟产生一个新的区块，每年就是80bytes624*365 = 4.2MB每年。现在计算机的内存容量，普遍在4GB，就算全部放进内存也是不成问题的。 八、简单的支付验证 如果要验证一笔交易的话，用户并不需要完整的运行一遍节点，而只需要拿到最长链中各block的header信息即可。通过往前追溯自己的交易信息即可确认是否被接受。对于交易频繁的商业机构，还是要运行自己的节点用来在网络被攻击（伪造了block）的情况下快速验证交易。 九、价值的组合和分割 一次交易可以有多个输入和两个输出，输入指明该次交易的金钱来源（之前的tx），一个输出指支付的钱，另一个输出则是找零。 十、隐私 网络上的交易只能看到公钥，并不能和具体的个体对应上（匿名机制），就跟股票市场只看到交易是一样的。 十一、计算 假设有一个攻击者，它尝试比诚信节点更快的生成chain。假设它要给自己赚钱，那么就要构造一笔合法的交易（需要交易发起方的签名），如果是非法的，其他节点并不会认同生成的block。一个攻击者能做的也仅仅是修改掉自己之前的交易，把钱给拿回来。 诚信链和攻击者之间的竞争可以用Binomial Random Walk（二叉树随机漫步）来描述。一次成功的事件表示诚信链条涨了一个block，使得两者差距加1；一次失败的事件表示攻击者的chain涨了一个block，使得两者差距减1。那么攻击者追上诚信链条的概率类比于赌徒破产问题（Gambler’s Ruin Problem）。假设一个赌徒拥有无限的信用，可以赌无数次来达到收支平衡。计算收支平衡的概率如下： p = 诚 信 节 点 发 现 下 一 个 b l o c k p=诚信节点发现下一个block p=诚信节点发现下一个block q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q = 攻 击 者 发 现 下 一 个 b l o c k q=攻击者发现下一个block q = 攻击者发现下一个blockq=攻击者发现下一个block q=攻击者发现下一个blockq=攻击者发现下一个blockq=攻击者发现下一个block q z = 攻 击 者 在 落 后 z 个 b l o c k 的 情 况 下 追 上 的 概 率 q_z = 攻击者在落后z个block的情况下追上的概率 qz​=攻击者在落后z个block的情况下追上的概率 q z = { 1 i f &nbsp; p ≤ q z = ( q p ) z i f &nbsp; p &amp;gt; q q_z = \\begin{cases} 1 &amp;amp;if\\ p\\le q \\\\ z = (\\frac{q}{p})^z &amp;amp;if\\ p \\gt q \\end{cases} qz​={1z=(pq​)z​if&nbsp;p≤qif&nbsp;p&gt;q​ 假设 p &amp;gt; q p&amp;gt;q p&gt;q，攻击者追上诚信链条的概率随着攻击者落后的block数量呈指数递减。除非攻击者在网络初期发动攻击，否则随着chain的不断增长，攻击成功的概率非常渺茫。 考虑一笔交易的接收者需要多久可以确认发起方无法篡改交易的问题。假设现在交易发起方是攻击者，它想要迷惑接收方一段时间，然后在把交易对象换成自己，来达到空手套白狼的目的。 在接收方收到正常交易后，攻击者立刻开始在一条平行的chain上工作，假设某个时刻，接收方已经发现有z个block跟在了正常交易的后面，那么攻击者还要赶上诚信链条的概率计算如下： 攻击者新生产的block数量服从泊松分布。 λ = z q p \\lambda = z\\frac{q}{p} λ=zpq​ 那么攻击者追上的概率为： 计算结果如下： 如果要使得攻击者追上的概率小于0.1% 十二、结论 就是非常简洁明了的解决了双重支付的问题，网络结构简单，而且节点可以随之离开或者加入。这个框架包含了一个P2P电子货币系统所需要的所有规则和激励措施。 阅读更多","@type":"BlogPosting","url":"/2018/11/04/e717c519a97b06f33a72543b6ea27b3a.html","headline":"《比特币：一种点对点电子现金系统》解读","dateModified":"2018-11-04T00:00:00+08:00","datePublished":"2018-11-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/11/04/e717c519a97b06f33a72543b6ea27b3a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《比特币：一种点对点电子现金系统》解读</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/abcamus/article/details/83715004 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><strong>摘要</strong><br> 为了去除现金系统对第三方金融机构的依赖（譬如银行），并且解决双花（double spending）的问题，引入了peer-to-peer network。在这样一个网络上，交易哈希被放入一个持续增长的链，这个链基于工作量证明生成，使得任何人不得篡改历史记录，除非再做一次工作量证明。最长的链不仅是发生的所有事件的见证，同时证明它来自于算力最强的节点。只要大部分的CPU算力是被善良节点（不会攻击网络）控制，这些节点就会不断的生成最长的链，并且抵制恶意的攻击。所有节点可以随时加入或者离开这个网络，只要接受最长的链这个事实不变的话。</p> 
  <h2><a id="_3"></a>一、引言</h2> 
  <p>讲了基于第三方信用机构，不可避免的诈骗和篡改交易的情况。引入点对点分布式时间戳服务器，即blockchain，来防止双花。</p> 
  <h2><a id="_7"></a>二、交易</h2> 
  <p>定义电子货币形式为一连串的数字签名。每一个货币拥有者对上一笔交易以及下一个货币拥有者进行hash签名，payee可以很容易的验证这笔交易是给自己的。<br> 这样存在一个问题：怎么确定一笔交易没有被双花呢？即A即发了一笔给B，这笔钱同时也发给了C。只有公开所有的交易才能知道到底有没有double-spending，以及我们需要这样一个系统：所有参与者都认同唯一的历史记录，按照交易顺序排列。</p> 
  <h2><a id="_12"></a>三、时间戳服务器</h2> 
  <p>构建基于block的链式结构，每个block的哈希基于上一个block的哈希和当前block中所有的item生成，这样的话，每一个block的哈希包含了之前所有的时间戳，每生成一个新的block，就是对之前所有时间戳的一次加强（保证唯一性）。</p> 
  <h2><a id="_16"></a>四、工作量证明</h2> 
  <p>引入一种哈希算法，譬如SHA-256，带多个前导0，而且使得工作量随着前导0的数量呈现指数增长。把这样一种工作量证明的方法引入到前面的时间戳服务器中，只有当发现满足前导0数量时，block nonce值才会加一（证明当前block有效）。随着block的增长，如果要改变一个block，那就意味着要重新计算（碰撞）之后所有的block hash。</p> 
  <p>同时，工作量证明也解决了多数人表决的机制。假设一个IP一票，那么可以随意的伪造IP进行投票。Proof-of-work相当于一CPU一票。多数人的投票体现在了最长的chain当中。如果大多数的CPU是诚信节点的，那么最长的链将会是可靠的。</p> 
  <p>为了补偿硬件计算速度的增长，以及参与的节点数量的增加，block的难度会根据每小时生成block的数量进行调整，如果太快，难度就会增加。</p> 
  <h2><a id="_24"></a>五、网络</h2> 
  <p>上述网络的运行方式如下：</p> 
  <p>新的交易被广播给所有节点。<br> 每个节点收集新的交易进入一个block。<br> 每个节点对各自的block做proof-of-work。<br> 当一个节点证明了一个新的block，该block被广播给所有节点。<br> 其他节点如果验证了新的block中的交易是有效并且没有出现过，那么接受新的block。<br> 节点如果接受新的block，它将基于这个block（作为previous hash）继续生成新的block。<br> 所有的节点都认当前最长的链，并且基于该链生成新的block。</p> 
  <p>如果两个节点同时广播了不同的block，一部分节点收到了第一个，而另外的收到了第二个，那么就形成了两条chain。在这种情况下，节点会保存晚收到的那个block，继续在先收到的block后面添加block。等到下一次PoW完成后，节点就会收到新的block，根据这个新的block就知道之前的哪个block位于最长的chain上面。在另一个branch上工作的节点就会重新切回到更长的chain上。值得一提的是：新的交易并不需要广播给所有的节点，只要它们到达足够多的节点，就会进入到新的block中。block的广播也不受消息丢失的影响。一旦一个节点没有成功收到block，当它收到下一个block的时候就知道自己已经错过了已有的block了。</p> 
  <h2><a id="_38"></a>六、激励</h2> 
  <p>按照惯例，一个block中的第一笔交易创建了一个新的coin，用来奖励区块的创建者，相当于产生货币进行流通。同时，如果一笔交易的输入要比输出高的话，多余的部分作为交易费用支付给节点。在这种鼓励机制下，恶意节点与其消耗巨大的算力去破坏网络，不如做一些诚信的工作来的收益高。</p> 
  <h2><a id="_42"></a>七、对硬盘空间的利用</h2> 
  <p>如果最新的一笔交易进入到了足够多的区块中，那么它之前的交易信息可以丢弃掉来节省硬盘空间。通过Merkle树来实现这种机制，同时保证区块的哈希值不变（交易位于叶子节点）。</p> 
  <p><img src="https://img-blog.csdnimg.cn/20181104122243915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FiY2FtdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p>如图所示，如果Tx0-2已经在新的block中了，那么可以减掉Tx0-2的哈希。右图因为还有一笔Tx3，Hash3要保留，同时也要保留Hash2来计算Hash23。</p> 
  <p>一个空的block header大约占80个字节，假设10分钟产生一个新的区块，每年就是80bytes624*365 = 4.2MB每年。现在计算机的内存容量，普遍在4GB，就算全部放进内存也是不成问题的。</p> 
  <h2><a id="_52"></a>八、简单的支付验证</h2> 
  <p>如果要验证一笔交易的话，用户并不需要完整的运行一遍节点，而只需要拿到最长链中各block的header信息即可。通过往前追溯自己的交易信息即可确认是否被接受。对于交易频繁的商业机构，还是要运行自己的节点用来在网络被攻击（伪造了block）的情况下快速验证交易。</p> 
  <h2><a id="_56"></a>九、价值的组合和分割</h2> 
  <p>一次交易可以有多个输入和两个输出，输入指明该次交易的金钱来源（之前的tx），一个输出指支付的钱，另一个输出则是找零。</p> 
  <h2><a id="_60"></a>十、隐私</h2> 
  <p>网络上的交易只能看到公钥，并不能和具体的个体对应上（匿名机制），就跟股票市场只看到交易是一样的。</p> 
  <h2><a id="_64"></a>十一、计算</h2> 
  <p>假设有一个攻击者，它尝试比诚信节点更快的生成chain。假设它要给自己赚钱，那么就要构造一笔合法的交易（需要交易发起方的签名），如果是非法的，其他节点并不会认同生成的block。一个攻击者能做的也仅仅是修改掉自己之前的交易，把钱给拿回来。</p> 
  <p>诚信链和攻击者之间的竞争可以用Binomial Random Walk（二叉树随机漫步）来描述。一次成功的事件表示诚信链条涨了一个block，使得两者差距加1；一次失败的事件表示攻击者的chain涨了一个block，使得两者差距减1。那么攻击者追上诚信链条的概率类比于赌徒破产问题（Gambler’s Ruin Problem）。假设一个赌徒拥有无限的信用，可以赌无数次来达到收支平衡。计算收支平衡的概率如下：</p> 
  <p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          p
         </mi>
         <mo>
          =
         </mo>
         <mi mathvariant="normal">
          诚
         </mi>
         <mi mathvariant="normal">
          信
         </mi>
         <mi mathvariant="normal">
          节
         </mi>
         <mi mathvariant="normal">
          点
         </mi>
         <mi mathvariant="normal">
          发
         </mi>
         <mi mathvariant="normal">
          现
         </mi>
         <mi mathvariant="normal">
          下
         </mi>
         <mi mathvariant="normal">
          一
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          b
         </mi>
         <mi>
          l
         </mi>
         <mi>
          o
         </mi>
         <mi>
          c
         </mi>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         p=诚信节点发现下一个block
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathit">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">诚</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          q
         </mi>
         <mo>
          =
         </mo>
         <mi mathvariant="normal">
          攻
         </mi>
         <mi mathvariant="normal">
          击
         </mi>
         <mi mathvariant="normal">
          者
         </mi>
         <mi mathvariant="normal">
          发
         </mi>
         <mi mathvariant="normal">
          现
         </mi>
         <mi mathvariant="normal">
          下
         </mi>
         <mi mathvariant="normal">
          一
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          b
         </mi>
         <mi>
          l
         </mi>
         <mi>
          o
         </mi>
         <mi>
          c
         </mi>
         <mi>
          k
         </mi>
         <mi>
          q
         </mi>
         <mo>
          =
         </mo>
         <mi mathvariant="normal">
          攻
         </mi>
         <mi mathvariant="normal">
          击
         </mi>
         <mi mathvariant="normal">
          者
         </mi>
         <mi mathvariant="normal">
          发
         </mi>
         <mi mathvariant="normal">
          现
         </mi>
         <mi mathvariant="normal">
          下
         </mi>
         <mi mathvariant="normal">
          一
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          b
         </mi>
         <mi>
          l
         </mi>
         <mi>
          o
         </mi>
         <mi>
          c
         </mi>
         <mi>
          k
         </mi>
         <mi>
          q
         </mi>
         <mo>
          =
         </mo>
         <mi mathvariant="normal">
          攻
         </mi>
         <mi mathvariant="normal">
          击
         </mi>
         <mi mathvariant="normal">
          者
         </mi>
         <mi mathvariant="normal">
          发
         </mi>
         <mi mathvariant="normal">
          现
         </mi>
         <mi mathvariant="normal">
          下
         </mi>
         <mi mathvariant="normal">
          一
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          b
         </mi>
         <mi>
          l
         </mi>
         <mi>
          o
         </mi>
         <mi>
          c
         </mi>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         q=攻击者发现下一个block q = 攻击者发现下一个blockq=攻击者发现下一个block
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           q
          </mi>
          <mi>
           z
          </mi>
         </msub>
         <mo>
          =
         </mo>
         <mi mathvariant="normal">
          攻
         </mi>
         <mi mathvariant="normal">
          击
         </mi>
         <mi mathvariant="normal">
          者
         </mi>
         <mi mathvariant="normal">
          在
         </mi>
         <mi mathvariant="normal">
          落
         </mi>
         <mi mathvariant="normal">
          后
         </mi>
         <mi>
          z
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          b
         </mi>
         <mi>
          l
         </mi>
         <mi>
          o
         </mi>
         <mi>
          c
         </mi>
         <mi>
          k
         </mi>
         <mi mathvariant="normal">
          的
         </mi>
         <mi mathvariant="normal">
          情
         </mi>
         <mi mathvariant="normal">
          况
         </mi>
         <mi mathvariant="normal">
          下
         </mi>
         <mi mathvariant="normal">
          追
         </mi>
         <mi mathvariant="normal">
          上
         </mi>
         <mi mathvariant="normal">
          的
         </mi>
         <mi mathvariant="normal">
          概
         </mi>
         <mi mathvariant="normal">
          率
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         q_z = 攻击者在落后z个block的情况下追上的概率
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">落</span><span class="mord cjk_fallback">后</span><span class="mord mathit" style="margin-right: 0.04398em;">z</span><span class="mord cjk_fallback">个</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">追</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           q
          </mi>
          <mi>
           z
          </mi>
         </msub>
         <mo>
          =
         </mo>
         <mrow>
          <mo fence="true">
           {
          </mo>
          <mtable>
           <mtr>
            <mtd>
             <mstyle scriptlevel="0" displaystyle="false">
              <mn>
               1
              </mn>
             </mstyle>
            </mtd>
            <mtd>
             <mstyle scriptlevel="0" displaystyle="false">
              <mrow>
               <mi>
                i
               </mi>
               <mi>
                f
               </mi>
               <mtext>
                &nbsp;
               </mtext>
               <mi>
                p
               </mi>
               <mo>
                ≤
               </mo>
               <mi>
                q
               </mi>
              </mrow>
             </mstyle>
            </mtd>
           </mtr>
           <mtr>
            <mtd>
             <mstyle scriptlevel="0" displaystyle="false">
              <mrow>
               <mi>
                z
               </mi>
               <mo>
                =
               </mo>
               <mo>
                (
               </mo>
               <mfrac>
                <mi>
                 q
                </mi>
                <mi>
                 p
                </mi>
               </mfrac>
               <msup>
                <mo>
                 )
                </mo>
                <mi>
                 z
                </mi>
               </msup>
              </mrow>
             </mstyle>
            </mtd>
            <mtd>
             <mstyle scriptlevel="0" displaystyle="false">
              <mrow>
               <mi>
                i
               </mi>
               <mi>
                f
               </mi>
               <mtext>
                &nbsp;
               </mtext>
               <mi>
                p
               </mi>
               <mo>
                &amp;gt;
               </mo>
               <mi>
                q
               </mi>
              </mrow>
             </mstyle>
            </mtd>
           </mtr>
          </mtable>
         </mrow>
        </mrow>
        <annotation encoding="application/x-tex">
         q_z = \begin{cases} 1 &amp;amp;if\ p\le q \\ z = (\frac{q}{p})^z &amp;amp;if\ p \gt q \end{cases}
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.00003em; vertical-align: -1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.71455em;"><span class="" style="top: -3.71455em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -2.27455em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.04398em;">z</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7475em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.44611em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.481108em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.21455em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.71455em;"><span class="" style="top: -3.71455em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mspace">&nbsp;</span><span class="mord mathit">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span><span class="" style="top: -2.27455em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mspace">&nbsp;</span><span class="mord mathit">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.21455em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
  <p>假设<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          p
         </mi>
         <mo>
          &amp;gt;
         </mo>
         <mi>
          q
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         p&amp;gt;q
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mord mathit">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span></span>，攻击者追上诚信链条的概率随着攻击者落后的block数量呈指数递减。除非攻击者在网络初期发动攻击，否则随着chain的不断增长，攻击成功的概率非常渺茫。</p> 
  <p>考虑一笔交易的接收者需要多久可以确认发起方无法篡改交易的问题。假设现在交易发起方是攻击者，它想要迷惑接收方一段时间，然后在把交易对象换成自己，来达到空手套白狼的目的。</p> 
  <p>在接收方收到正常交易后，攻击者立刻开始在一条平行的chain上工作，假设某个时刻，接收方已经发现有z个block跟在了正常交易的后面，那么攻击者还要赶上诚信链条的概率计算如下：</p> 
  <p>攻击者新生产的block数量服从泊松分布。</p> 
  <p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          λ
         </mi>
         <mo>
          =
         </mo>
         <mi>
          z
         </mi>
         <mfrac>
          <mi>
           q
          </mi>
          <mi>
           p
          </mi>
         </mfrac>
        </mrow>
        <annotation encoding="application/x-tex">
         \lambda = z\frac{q}{p}
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit">λ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.22861em; vertical-align: -0.481108em;"></span><span class="mord mathit" style="margin-right: 0.04398em;">z</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7475em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.44611em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.481108em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
  <p>那么攻击者追上的概率为：</p> 
  <p><img src="https://img-blog.csdnimg.cn/20181104125844317.png" alt="在这里插入图片描述"></p> 
  <p>计算结果如下：</p> 
  <p><img src="https://img-blog.csdnimg.cn/20181104125903630.png" alt="在这里插入图片描述"></p> 
  <p>如果要使得攻击者追上的概率小于0.1%</p> 
  <p><img src="https://img-blog.csdnimg.cn/20181104125921159.png" alt="在这里插入图片描述"></p> 
  <h2><a id="_100"></a>十二、结论</h2> 
  <p>就是非常简洁明了的解决了双重支付的问题，网络结构简单，而且节点可以随之离开或者加入。这个框架包含了一个P2P电子货币系统所需要的所有规则和激励措施。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-a47e74522c.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/abcamus/article/details/83715004,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/abcamus/article/details/83715004,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
