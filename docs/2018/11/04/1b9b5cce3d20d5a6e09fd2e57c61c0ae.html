<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链基本知识梳理 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链基本知识梳理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：版权所有。转载请注明出处：扶风的博客 https://blog.csdn.net/JohnnyMartin/article/details/83622286 公钥、私钥、与地址 私钥是一切的根本，由它可以导出公钥、地址，而无法通过公钥推出私钥 公钥加密私钥解密，私钥签名公钥验证 以太坊使用的椭圆曲线算法可以从签名的数据中推算出该数据发送方的地址 公钥经过一系列操作之后可以推出地址，以太坊是将公钥做Keccak-256哈希，然后取最后的40位16进制字符 私钥一定要妥善备份，常用备份方式有： 助记词,一般由12个单词组成，得到它就等于得到了私钥 keystore文件，一个json文件，本质上是把私钥加密之后的数据文件，解密需要输入加密时的密码 公链、私链、联盟链 主要区别：公有链向所有人开放，联盟链向授权的组织或机构开放，私有链向满足特定条件的个人开放（比如只对本公司的人开放）。 开放程度 出块节点 效率 共识算法 典型代表 公链 完全开放 任何节点 低 POW、POS、DPOS等 比特币、以太坊、EOS 私链 不开放、针对个人开放 少量节点出块 高 Raft、Paxos 蚂蚁金服 联盟链 针对特定机构、组织开放 授权节点出块 高 DBFT、PBFT 超级账本(Hyperledger)、ChinaLedger 钱包、热钱包、冷钱包 钱包的本质：生成密钥、管理密钥、使用密钥的工具。 钱宝负责生成一个随机的私钥，根据此私钥生成公钥，再根据公钥得到地址 冷热钱包的本质区别在于存储私钥的方式 冷钱包：网络无法访问到私钥 热钱包：网络可以访问到私钥 冷钱包安全性好但是不适合频繁交易，热钱包反之。 硬分叉、软分叉 本质区别：区块链网络上旧的节点是否认可新节点产生的区块。（一般新节点会在共识规则上做出一些改变） 若不认可，则新节点挖出的区块会被旧节点否决（达不成共识），于是新节点和旧节点会开始在不同的链上运行（挖矿、交易、验证等） 旧矿工的去留将决定旧分叉的生死 硬分叉影响较大，除非得到整个链生态的同意，否则贸然硬分叉极易造成该链的分裂。同时，硬分叉又具有相当大的”医疗作用“，尤其当发现重大bug、重大缺陷的时候（此时较容易得到整个链生态的同意） 软分叉不会产生两条链，新节点产生的区块可以被旧节点承认（达成共识），但是旧节点却无法识别新块中属于新规则的那部分数据真实意义。 软分叉不能增加数据字段，只能在现有结构上修改，升级空间有限，而且会让代码变复杂。 硬分叉通常是扩展共识规则，而软分叉是收紧共识规则，所以一旦进行了软分叉，想要回退就非常困难了，很可能造成硬分叉而导致资金损失 UTXO 熟悉比特币的人应该都知道，为了尽可能少的泄露公钥，每次交易时比特币社区建议将余额转向一个新的地址。 （从公钥反推私钥虽然是极为困难的，但是不一定抵抗量子计算机，比特币地址的双重hash以及交易时将余额转向一个新的地址都是为了保护公钥，尽可能少的暴漏） 那么问题来了，每次都将余额转到了一个新的地址，那我的账户下的余额岂不是无端没了？ 当然不会没了，事实上比特币世界中并没有账户的概念，也没有余额的概念，有的只是UTXO(Unspend Transaction Output)未花费的交易输出。“账户的余额”便是与该账户相关的UTXO的和。 简单来说，比特币只记转账过程，不记余额。一笔转账由两大部分组成：输入部分、输出部分。输入部分便由一个个UTXO组成，例如，A打算转5个BTC给B，钱包知道A的所有UTXO，于是钱包挑出了A的A1，A2，A3三个UTXO，每个2 BTC，将这三个UTXO作为本次转账的输入，本次的输出有两部分：一部分将5 BTC转给 B，另一部分将剩余的1BTC转到一个新的地址（此处假设没有矿工费），这个新的地址是由钱包管理的。于是，这个拥有一个BTC的UTXO又可以作为下一次交易的输入。 最关键的问题是：每一次都将未花费的余额存入新地址，新地址意味着对应一个新的私钥，这么多私钥，我都得一一备份么？当然不用——HD钱包（Hierarchical Deterministic 分层确定性）只是用一个“根私钥”也就是种子（seed），生成任意多的子私钥。我们备份钱包，只需备份“根私钥”的助记词即可。比如我们可以用这样一套算法生成子私钥：SHA256(seed + n)。只要seed确定了，后面的所有子私钥也都确定了。 双花问题的解决 每发起一个交易，都要检查该交易的各个输入是否是“未花费的”。 交易接受者要等待6个确认块之后再确定本次交易成功了。（以太坊是12） 拜占庭将军问题及其解决 问题场景：ABCD四个将军在不同的地方围攻敌军，任何一个将军都无法单独战胜敌人——他们需要协商一个一致的时间来一起发动进攻才能取胜。四个将军中最多有一个可能是叛徒，并且正直的将军不知道叛徒是谁。叛徒会想办法破坏将军们的进攻计划。那么，正直的将军们如何才能达成一致、战胜敌人呢？ 该问题的计算机语言描述是这样的：如何在一个可能存在失效节点、作恶节点的对等网络中达成共识呢？ 我们先模仿一下将军们可能的做法： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，1点到了，B按兵不动，ACD如期进攻并打败了敌人。这是比较简单的情形。 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。于是BCD三方依次单独进攻，统统被灭了。 我们可以很直观的看出上述做法的缺点：BCD收到的建议未经过验证。 于是最简单的PBFT算法出现了——对每个收到建议的将军，他们每人都要询问其他人收到的内容，并以此做出判断。 于是上面的情形2变成这个样子： 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。B收到了建议，并派出b1、b2两个信使去询问CD两人收到的内容，CD也会做类似的事情。询问之后发现，我擦A给我们三个发的建议完全不一样啊——A这厮一定是叛徒无疑了。 情形2的问题随之而解，情形1又新的变化，请看： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，当C派信使c1来询问B的时候，B对信使说了谎——B这个叛徒试图打乱进攻的时间。对C来说，他收到A的建议是下午一点，信使c1从B处带回的建议是下午两点，信使c2从D处带回的建议也是下午一点，于是C立刻可以判断出来，B是叛徒了。同样的，D也能判断出B是叛徒，而采用“下午一点进攻”这一建议。 PBFT算法本质上是以通信次数达成共识——如果节点较多，效率低下。 共识算法，本质上都是在解决拜占庭将军问题。 POW、POS、DPOS等都是在解决“如何在一个不靠谱的对等网络内达成一个大家都认可的一致意见”这个问题。 POW简单粗暴，相当于让将军们在10公里之外朝着敌人扔石头，砸死敌人相当于挖矿成功，没砸死就一直扔。 POS兼顾效率，按照将军的资历排个顺序，资历老的将军可以发号施令（出块），统一进攻时间 DPOS接近于POS，投票选出几个超级将军，这几个超级将军发号施令、统一进攻时间。 隔离见证 叔块奖励 叔块奖励是以太坊中的机制。比特币中的叔块并没有任何奖励，以太坊为何要给挖出叔块的矿工奖励呢？ 源于GOHST协议。 叔块是什么。在比特币中，最长链就是权威。假若两个矿工几乎同时挖出了同一个高度的两个块A1、A2，那么哪个块才是最终的块呢？这取决于谁的后面有更长的链。所以两个矿工会拼命的广播自己的块，以求让别的矿工在自己的块之上挖出更多的区块，使自己的块所在的链成为最长链、进而获得奖励。假设A1最终胜出，那A2就会成为孤块，没有任何奖励。在以太坊中，使用的是“最重链”这一概念。由于以太坊14秒出一块，块间隔远远小于BTC的10min，这就大大增加了矿工们挖出同一高度的块的概率。以太坊的GHOST协议认为，孤块，以太坊中称之为叔块，作为一个合法的区块，不是没有意义的，它可以为主链的安全做出贡献，因而也会奖励挖出孤块的旷工。 为何要给挖出叔块的人奖励。与这个问题等效的问题是：叔块如何为主链的安全做出贡献? 叔块成为主链的一部分，那么叔块里的coinbase自然就是合法的交易，自然就会收到奖励。 叔块如何为主链的安全做出贡献? 以太坊的区块可以包含 0~2 个叔块，并将这(些)叔块放到头部的UncleHash字段中。引用叔块需要遵守以下规则： 区块最多引用2个叔块，可以不引用 所引用的叔块必须是当前块的前2~前7个节点的直接子块 被别的块引用过的叔块不能再次被引用 奖励计算公式。 区块(非叔块)的奖励公式（执笔时基本奖励为2eth）= 2eth + 2eth*（引用的叔块数/32）+ 矿工费 叔块奖励公式：叔块得到的奖励取决于引用这个叔块的区块与该叔块间隔的层数，层数范围为1~6，我们姑且将间隔的层数称为：层差，则计算叔块奖励公式可表示为：（8 - 层差）/ 8 * 2eth。 由上述公式可见：引用叔块能够增加本区块的奖励；层差越小叔块得到的奖励越多。 最重的链：与比特币使用最长链做主链不同，以太坊使用最重链这一概念，所谓的最重链，就是在该链上所完成的计算量是最大的。包含叔块能够增加本链条的重量。这便是GHOST协议的主要内容：定义确定主链的算法。换句话说，以太坊的GHOST协议就是一个“主链选择协议”。因而，在以太坊中，最长的链不一定是主链！ 重放攻击 该现象出现在硬分叉当中。假设一个币种N，有1000个币，在2018.11.11分叉了，新链币种叫NA，旧链币种仍然是N。分叉后，你的NA钱包中余额会显示是1000，N钱包显示的余额也是1000。 当你在NA钱包发出一笔交易，想要发给B，10 NA币。你签署完该交易后广播到NA网络，此时B动了歪脑筋，把你签署的交易原封不动的转发到了N网络，如果没有重放吧保护，这次交易可能同时被两个链承认——B同时收到了10 NA币 + 10 N币。 共识算法 POW（Proof of Work，工作量证明） 比特币、当下的以太坊都是用此类共识算法，耗电量巨大。 比特币的POW是计算一个hash值，它的前N位为0，N反映了当前的难度。我们可以通过比特币区块浏览器直接“看出”这个明显的挖矿成功的特征。“挖矿”过程是这样的：矿工不断将新的nonce填到块头中，计算块头的hash值，直到计算出的hash值的前N个值为0，挖矿成功。在此过程中，矿工需要自己组装块头，或者从矿池接受块头。 以太坊的POW比比特币要稍微多绕了一个弯，RAND(hashNoNonce, nonce) &lt;= M/d; RAND是一个抽象函数代表一系列操作；hashNoNonce是组装好的块头除去nonce字段的hash值，nonce是每次迭代尝试的随机数；M是一个极大值；d是难度；简单来说就是：使用hashNoNonce + nonce做输入参数，通过RAND函数寻找一个hash值，该值的大小不大于 M/d; （当难度增加时，d变大，M/d变小，挖矿难度增加）。 以太坊的挖矿过程只需要hashNoNonce而不需要整个块头，这在矿池-矿工模式中非常省心，矿池只需下发hashNoNonce以及对应的nonce范围给矿工即可，无需像比特币矿池一样发整个块头给各个矿工。 比特币的POW算法在最初设计时没有预料到后来矿机的崛起，以太坊的Ethash算法在设计之初就考虑了抵抗矿机这一特性。 POS （Proof of Stock，股权证明）类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，二者相乘便得到币龄，币龄越大，分配给你的利息就越多、记账概率越大。当获得激励之后，币龄清零，重新积累，如此周而复始。Peer Coin（点点币，PPC）、新星币(Nova Coin，NVC)、黑币（Black Coin，BLK）、NextCoin（未来币，NXT）等等,都是用的POS。 POA(Proofof Authority，授权证明) 由一组授权节点来负责新区块的产生和区块验证。以太坊测试网（Kovan）便是采用POA共识。一般用来搭建联盟链。 DPOS (Delegated Proof of Stake，委任权益证明) BTS/EOS正在使用的共识规则。它的原理是让每一个持有BTS/EOS的人进行投票，由此产生101(BTS)/21(EOS)位代表 , 也就是101/21个超级节点，这些超级节点负责打包交易、出块。超级节点要将出块所获得的奖励的一部分，分给支持自己的股民。 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法），联盟链常用的共识算法。 Paxos，私链常用的共识算法。 Raft，私链常用的共识算法。 关于共识算法的详细讨论，详见另一篇拙作。" />
<meta property="og:description" content="版权声明：版权所有。转载请注明出处：扶风的博客 https://blog.csdn.net/JohnnyMartin/article/details/83622286 公钥、私钥、与地址 私钥是一切的根本，由它可以导出公钥、地址，而无法通过公钥推出私钥 公钥加密私钥解密，私钥签名公钥验证 以太坊使用的椭圆曲线算法可以从签名的数据中推算出该数据发送方的地址 公钥经过一系列操作之后可以推出地址，以太坊是将公钥做Keccak-256哈希，然后取最后的40位16进制字符 私钥一定要妥善备份，常用备份方式有： 助记词,一般由12个单词组成，得到它就等于得到了私钥 keystore文件，一个json文件，本质上是把私钥加密之后的数据文件，解密需要输入加密时的密码 公链、私链、联盟链 主要区别：公有链向所有人开放，联盟链向授权的组织或机构开放，私有链向满足特定条件的个人开放（比如只对本公司的人开放）。 开放程度 出块节点 效率 共识算法 典型代表 公链 完全开放 任何节点 低 POW、POS、DPOS等 比特币、以太坊、EOS 私链 不开放、针对个人开放 少量节点出块 高 Raft、Paxos 蚂蚁金服 联盟链 针对特定机构、组织开放 授权节点出块 高 DBFT、PBFT 超级账本(Hyperledger)、ChinaLedger 钱包、热钱包、冷钱包 钱包的本质：生成密钥、管理密钥、使用密钥的工具。 钱宝负责生成一个随机的私钥，根据此私钥生成公钥，再根据公钥得到地址 冷热钱包的本质区别在于存储私钥的方式 冷钱包：网络无法访问到私钥 热钱包：网络可以访问到私钥 冷钱包安全性好但是不适合频繁交易，热钱包反之。 硬分叉、软分叉 本质区别：区块链网络上旧的节点是否认可新节点产生的区块。（一般新节点会在共识规则上做出一些改变） 若不认可，则新节点挖出的区块会被旧节点否决（达不成共识），于是新节点和旧节点会开始在不同的链上运行（挖矿、交易、验证等） 旧矿工的去留将决定旧分叉的生死 硬分叉影响较大，除非得到整个链生态的同意，否则贸然硬分叉极易造成该链的分裂。同时，硬分叉又具有相当大的”医疗作用“，尤其当发现重大bug、重大缺陷的时候（此时较容易得到整个链生态的同意） 软分叉不会产生两条链，新节点产生的区块可以被旧节点承认（达成共识），但是旧节点却无法识别新块中属于新规则的那部分数据真实意义。 软分叉不能增加数据字段，只能在现有结构上修改，升级空间有限，而且会让代码变复杂。 硬分叉通常是扩展共识规则，而软分叉是收紧共识规则，所以一旦进行了软分叉，想要回退就非常困难了，很可能造成硬分叉而导致资金损失 UTXO 熟悉比特币的人应该都知道，为了尽可能少的泄露公钥，每次交易时比特币社区建议将余额转向一个新的地址。 （从公钥反推私钥虽然是极为困难的，但是不一定抵抗量子计算机，比特币地址的双重hash以及交易时将余额转向一个新的地址都是为了保护公钥，尽可能少的暴漏） 那么问题来了，每次都将余额转到了一个新的地址，那我的账户下的余额岂不是无端没了？ 当然不会没了，事实上比特币世界中并没有账户的概念，也没有余额的概念，有的只是UTXO(Unspend Transaction Output)未花费的交易输出。“账户的余额”便是与该账户相关的UTXO的和。 简单来说，比特币只记转账过程，不记余额。一笔转账由两大部分组成：输入部分、输出部分。输入部分便由一个个UTXO组成，例如，A打算转5个BTC给B，钱包知道A的所有UTXO，于是钱包挑出了A的A1，A2，A3三个UTXO，每个2 BTC，将这三个UTXO作为本次转账的输入，本次的输出有两部分：一部分将5 BTC转给 B，另一部分将剩余的1BTC转到一个新的地址（此处假设没有矿工费），这个新的地址是由钱包管理的。于是，这个拥有一个BTC的UTXO又可以作为下一次交易的输入。 最关键的问题是：每一次都将未花费的余额存入新地址，新地址意味着对应一个新的私钥，这么多私钥，我都得一一备份么？当然不用——HD钱包（Hierarchical Deterministic 分层确定性）只是用一个“根私钥”也就是种子（seed），生成任意多的子私钥。我们备份钱包，只需备份“根私钥”的助记词即可。比如我们可以用这样一套算法生成子私钥：SHA256(seed + n)。只要seed确定了，后面的所有子私钥也都确定了。 双花问题的解决 每发起一个交易，都要检查该交易的各个输入是否是“未花费的”。 交易接受者要等待6个确认块之后再确定本次交易成功了。（以太坊是12） 拜占庭将军问题及其解决 问题场景：ABCD四个将军在不同的地方围攻敌军，任何一个将军都无法单独战胜敌人——他们需要协商一个一致的时间来一起发动进攻才能取胜。四个将军中最多有一个可能是叛徒，并且正直的将军不知道叛徒是谁。叛徒会想办法破坏将军们的进攻计划。那么，正直的将军们如何才能达成一致、战胜敌人呢？ 该问题的计算机语言描述是这样的：如何在一个可能存在失效节点、作恶节点的对等网络中达成共识呢？ 我们先模仿一下将军们可能的做法： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，1点到了，B按兵不动，ACD如期进攻并打败了敌人。这是比较简单的情形。 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。于是BCD三方依次单独进攻，统统被灭了。 我们可以很直观的看出上述做法的缺点：BCD收到的建议未经过验证。 于是最简单的PBFT算法出现了——对每个收到建议的将军，他们每人都要询问其他人收到的内容，并以此做出判断。 于是上面的情形2变成这个样子： 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。B收到了建议，并派出b1、b2两个信使去询问CD两人收到的内容，CD也会做类似的事情。询问之后发现，我擦A给我们三个发的建议完全不一样啊——A这厮一定是叛徒无疑了。 情形2的问题随之而解，情形1又新的变化，请看： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，当C派信使c1来询问B的时候，B对信使说了谎——B这个叛徒试图打乱进攻的时间。对C来说，他收到A的建议是下午一点，信使c1从B处带回的建议是下午两点，信使c2从D处带回的建议也是下午一点，于是C立刻可以判断出来，B是叛徒了。同样的，D也能判断出B是叛徒，而采用“下午一点进攻”这一建议。 PBFT算法本质上是以通信次数达成共识——如果节点较多，效率低下。 共识算法，本质上都是在解决拜占庭将军问题。 POW、POS、DPOS等都是在解决“如何在一个不靠谱的对等网络内达成一个大家都认可的一致意见”这个问题。 POW简单粗暴，相当于让将军们在10公里之外朝着敌人扔石头，砸死敌人相当于挖矿成功，没砸死就一直扔。 POS兼顾效率，按照将军的资历排个顺序，资历老的将军可以发号施令（出块），统一进攻时间 DPOS接近于POS，投票选出几个超级将军，这几个超级将军发号施令、统一进攻时间。 隔离见证 叔块奖励 叔块奖励是以太坊中的机制。比特币中的叔块并没有任何奖励，以太坊为何要给挖出叔块的矿工奖励呢？ 源于GOHST协议。 叔块是什么。在比特币中，最长链就是权威。假若两个矿工几乎同时挖出了同一个高度的两个块A1、A2，那么哪个块才是最终的块呢？这取决于谁的后面有更长的链。所以两个矿工会拼命的广播自己的块，以求让别的矿工在自己的块之上挖出更多的区块，使自己的块所在的链成为最长链、进而获得奖励。假设A1最终胜出，那A2就会成为孤块，没有任何奖励。在以太坊中，使用的是“最重链”这一概念。由于以太坊14秒出一块，块间隔远远小于BTC的10min，这就大大增加了矿工们挖出同一高度的块的概率。以太坊的GHOST协议认为，孤块，以太坊中称之为叔块，作为一个合法的区块，不是没有意义的，它可以为主链的安全做出贡献，因而也会奖励挖出孤块的旷工。 为何要给挖出叔块的人奖励。与这个问题等效的问题是：叔块如何为主链的安全做出贡献? 叔块成为主链的一部分，那么叔块里的coinbase自然就是合法的交易，自然就会收到奖励。 叔块如何为主链的安全做出贡献? 以太坊的区块可以包含 0~2 个叔块，并将这(些)叔块放到头部的UncleHash字段中。引用叔块需要遵守以下规则： 区块最多引用2个叔块，可以不引用 所引用的叔块必须是当前块的前2~前7个节点的直接子块 被别的块引用过的叔块不能再次被引用 奖励计算公式。 区块(非叔块)的奖励公式（执笔时基本奖励为2eth）= 2eth + 2eth*（引用的叔块数/32）+ 矿工费 叔块奖励公式：叔块得到的奖励取决于引用这个叔块的区块与该叔块间隔的层数，层数范围为1~6，我们姑且将间隔的层数称为：层差，则计算叔块奖励公式可表示为：（8 - 层差）/ 8 * 2eth。 由上述公式可见：引用叔块能够增加本区块的奖励；层差越小叔块得到的奖励越多。 最重的链：与比特币使用最长链做主链不同，以太坊使用最重链这一概念，所谓的最重链，就是在该链上所完成的计算量是最大的。包含叔块能够增加本链条的重量。这便是GHOST协议的主要内容：定义确定主链的算法。换句话说，以太坊的GHOST协议就是一个“主链选择协议”。因而，在以太坊中，最长的链不一定是主链！ 重放攻击 该现象出现在硬分叉当中。假设一个币种N，有1000个币，在2018.11.11分叉了，新链币种叫NA，旧链币种仍然是N。分叉后，你的NA钱包中余额会显示是1000，N钱包显示的余额也是1000。 当你在NA钱包发出一笔交易，想要发给B，10 NA币。你签署完该交易后广播到NA网络，此时B动了歪脑筋，把你签署的交易原封不动的转发到了N网络，如果没有重放吧保护，这次交易可能同时被两个链承认——B同时收到了10 NA币 + 10 N币。 共识算法 POW（Proof of Work，工作量证明） 比特币、当下的以太坊都是用此类共识算法，耗电量巨大。 比特币的POW是计算一个hash值，它的前N位为0，N反映了当前的难度。我们可以通过比特币区块浏览器直接“看出”这个明显的挖矿成功的特征。“挖矿”过程是这样的：矿工不断将新的nonce填到块头中，计算块头的hash值，直到计算出的hash值的前N个值为0，挖矿成功。在此过程中，矿工需要自己组装块头，或者从矿池接受块头。 以太坊的POW比比特币要稍微多绕了一个弯，RAND(hashNoNonce, nonce) &lt;= M/d; RAND是一个抽象函数代表一系列操作；hashNoNonce是组装好的块头除去nonce字段的hash值，nonce是每次迭代尝试的随机数；M是一个极大值；d是难度；简单来说就是：使用hashNoNonce + nonce做输入参数，通过RAND函数寻找一个hash值，该值的大小不大于 M/d; （当难度增加时，d变大，M/d变小，挖矿难度增加）。 以太坊的挖矿过程只需要hashNoNonce而不需要整个块头，这在矿池-矿工模式中非常省心，矿池只需下发hashNoNonce以及对应的nonce范围给矿工即可，无需像比特币矿池一样发整个块头给各个矿工。 比特币的POW算法在最初设计时没有预料到后来矿机的崛起，以太坊的Ethash算法在设计之初就考虑了抵抗矿机这一特性。 POS （Proof of Stock，股权证明）类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，二者相乘便得到币龄，币龄越大，分配给你的利息就越多、记账概率越大。当获得激励之后，币龄清零，重新积累，如此周而复始。Peer Coin（点点币，PPC）、新星币(Nova Coin，NVC)、黑币（Black Coin，BLK）、NextCoin（未来币，NXT）等等,都是用的POS。 POA(Proofof Authority，授权证明) 由一组授权节点来负责新区块的产生和区块验证。以太坊测试网（Kovan）便是采用POA共识。一般用来搭建联盟链。 DPOS (Delegated Proof of Stake，委任权益证明) BTS/EOS正在使用的共识规则。它的原理是让每一个持有BTS/EOS的人进行投票，由此产生101(BTS)/21(EOS)位代表 , 也就是101/21个超级节点，这些超级节点负责打包交易、出块。超级节点要将出块所获得的奖励的一部分，分给支持自己的股民。 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法），联盟链常用的共识算法。 Paxos，私链常用的共识算法。 Raft，私链常用的共识算法。 关于共识算法的详细讨论，详见另一篇拙作。" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：版权所有。转载请注明出处：扶风的博客 https://blog.csdn.net/JohnnyMartin/article/details/83622286 公钥、私钥、与地址 私钥是一切的根本，由它可以导出公钥、地址，而无法通过公钥推出私钥 公钥加密私钥解密，私钥签名公钥验证 以太坊使用的椭圆曲线算法可以从签名的数据中推算出该数据发送方的地址 公钥经过一系列操作之后可以推出地址，以太坊是将公钥做Keccak-256哈希，然后取最后的40位16进制字符 私钥一定要妥善备份，常用备份方式有： 助记词,一般由12个单词组成，得到它就等于得到了私钥 keystore文件，一个json文件，本质上是把私钥加密之后的数据文件，解密需要输入加密时的密码 公链、私链、联盟链 主要区别：公有链向所有人开放，联盟链向授权的组织或机构开放，私有链向满足特定条件的个人开放（比如只对本公司的人开放）。 开放程度 出块节点 效率 共识算法 典型代表 公链 完全开放 任何节点 低 POW、POS、DPOS等 比特币、以太坊、EOS 私链 不开放、针对个人开放 少量节点出块 高 Raft、Paxos 蚂蚁金服 联盟链 针对特定机构、组织开放 授权节点出块 高 DBFT、PBFT 超级账本(Hyperledger)、ChinaLedger 钱包、热钱包、冷钱包 钱包的本质：生成密钥、管理密钥、使用密钥的工具。 钱宝负责生成一个随机的私钥，根据此私钥生成公钥，再根据公钥得到地址 冷热钱包的本质区别在于存储私钥的方式 冷钱包：网络无法访问到私钥 热钱包：网络可以访问到私钥 冷钱包安全性好但是不适合频繁交易，热钱包反之。 硬分叉、软分叉 本质区别：区块链网络上旧的节点是否认可新节点产生的区块。（一般新节点会在共识规则上做出一些改变） 若不认可，则新节点挖出的区块会被旧节点否决（达不成共识），于是新节点和旧节点会开始在不同的链上运行（挖矿、交易、验证等） 旧矿工的去留将决定旧分叉的生死 硬分叉影响较大，除非得到整个链生态的同意，否则贸然硬分叉极易造成该链的分裂。同时，硬分叉又具有相当大的”医疗作用“，尤其当发现重大bug、重大缺陷的时候（此时较容易得到整个链生态的同意） 软分叉不会产生两条链，新节点产生的区块可以被旧节点承认（达成共识），但是旧节点却无法识别新块中属于新规则的那部分数据真实意义。 软分叉不能增加数据字段，只能在现有结构上修改，升级空间有限，而且会让代码变复杂。 硬分叉通常是扩展共识规则，而软分叉是收紧共识规则，所以一旦进行了软分叉，想要回退就非常困难了，很可能造成硬分叉而导致资金损失 UTXO 熟悉比特币的人应该都知道，为了尽可能少的泄露公钥，每次交易时比特币社区建议将余额转向一个新的地址。 （从公钥反推私钥虽然是极为困难的，但是不一定抵抗量子计算机，比特币地址的双重hash以及交易时将余额转向一个新的地址都是为了保护公钥，尽可能少的暴漏） 那么问题来了，每次都将余额转到了一个新的地址，那我的账户下的余额岂不是无端没了？ 当然不会没了，事实上比特币世界中并没有账户的概念，也没有余额的概念，有的只是UTXO(Unspend Transaction Output)未花费的交易输出。“账户的余额”便是与该账户相关的UTXO的和。 简单来说，比特币只记转账过程，不记余额。一笔转账由两大部分组成：输入部分、输出部分。输入部分便由一个个UTXO组成，例如，A打算转5个BTC给B，钱包知道A的所有UTXO，于是钱包挑出了A的A1，A2，A3三个UTXO，每个2 BTC，将这三个UTXO作为本次转账的输入，本次的输出有两部分：一部分将5 BTC转给 B，另一部分将剩余的1BTC转到一个新的地址（此处假设没有矿工费），这个新的地址是由钱包管理的。于是，这个拥有一个BTC的UTXO又可以作为下一次交易的输入。 最关键的问题是：每一次都将未花费的余额存入新地址，新地址意味着对应一个新的私钥，这么多私钥，我都得一一备份么？当然不用——HD钱包（Hierarchical Deterministic 分层确定性）只是用一个“根私钥”也就是种子（seed），生成任意多的子私钥。我们备份钱包，只需备份“根私钥”的助记词即可。比如我们可以用这样一套算法生成子私钥：SHA256(seed + n)。只要seed确定了，后面的所有子私钥也都确定了。 双花问题的解决 每发起一个交易，都要检查该交易的各个输入是否是“未花费的”。 交易接受者要等待6个确认块之后再确定本次交易成功了。（以太坊是12） 拜占庭将军问题及其解决 问题场景：ABCD四个将军在不同的地方围攻敌军，任何一个将军都无法单独战胜敌人——他们需要协商一个一致的时间来一起发动进攻才能取胜。四个将军中最多有一个可能是叛徒，并且正直的将军不知道叛徒是谁。叛徒会想办法破坏将军们的进攻计划。那么，正直的将军们如何才能达成一致、战胜敌人呢？ 该问题的计算机语言描述是这样的：如何在一个可能存在失效节点、作恶节点的对等网络中达成共识呢？ 我们先模仿一下将军们可能的做法： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，1点到了，B按兵不动，ACD如期进攻并打败了敌人。这是比较简单的情形。 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。于是BCD三方依次单独进攻，统统被灭了。 我们可以很直观的看出上述做法的缺点：BCD收到的建议未经过验证。 于是最简单的PBFT算法出现了——对每个收到建议的将军，他们每人都要询问其他人收到的内容，并以此做出判断。 于是上面的情形2变成这个样子： 情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。B收到了建议，并派出b1、b2两个信使去询问CD两人收到的内容，CD也会做类似的事情。询问之后发现，我擦A给我们三个发的建议完全不一样啊——A这厮一定是叛徒无疑了。 情形2的问题随之而解，情形1又新的变化，请看： 情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，当C派信使c1来询问B的时候，B对信使说了谎——B这个叛徒试图打乱进攻的时间。对C来说，他收到A的建议是下午一点，信使c1从B处带回的建议是下午两点，信使c2从D处带回的建议也是下午一点，于是C立刻可以判断出来，B是叛徒了。同样的，D也能判断出B是叛徒，而采用“下午一点进攻”这一建议。 PBFT算法本质上是以通信次数达成共识——如果节点较多，效率低下。 共识算法，本质上都是在解决拜占庭将军问题。 POW、POS、DPOS等都是在解决“如何在一个不靠谱的对等网络内达成一个大家都认可的一致意见”这个问题。 POW简单粗暴，相当于让将军们在10公里之外朝着敌人扔石头，砸死敌人相当于挖矿成功，没砸死就一直扔。 POS兼顾效率，按照将军的资历排个顺序，资历老的将军可以发号施令（出块），统一进攻时间 DPOS接近于POS，投票选出几个超级将军，这几个超级将军发号施令、统一进攻时间。 隔离见证 叔块奖励 叔块奖励是以太坊中的机制。比特币中的叔块并没有任何奖励，以太坊为何要给挖出叔块的矿工奖励呢？ 源于GOHST协议。 叔块是什么。在比特币中，最长链就是权威。假若两个矿工几乎同时挖出了同一个高度的两个块A1、A2，那么哪个块才是最终的块呢？这取决于谁的后面有更长的链。所以两个矿工会拼命的广播自己的块，以求让别的矿工在自己的块之上挖出更多的区块，使自己的块所在的链成为最长链、进而获得奖励。假设A1最终胜出，那A2就会成为孤块，没有任何奖励。在以太坊中，使用的是“最重链”这一概念。由于以太坊14秒出一块，块间隔远远小于BTC的10min，这就大大增加了矿工们挖出同一高度的块的概率。以太坊的GHOST协议认为，孤块，以太坊中称之为叔块，作为一个合法的区块，不是没有意义的，它可以为主链的安全做出贡献，因而也会奖励挖出孤块的旷工。 为何要给挖出叔块的人奖励。与这个问题等效的问题是：叔块如何为主链的安全做出贡献? 叔块成为主链的一部分，那么叔块里的coinbase自然就是合法的交易，自然就会收到奖励。 叔块如何为主链的安全做出贡献? 以太坊的区块可以包含 0~2 个叔块，并将这(些)叔块放到头部的UncleHash字段中。引用叔块需要遵守以下规则： 区块最多引用2个叔块，可以不引用 所引用的叔块必须是当前块的前2~前7个节点的直接子块 被别的块引用过的叔块不能再次被引用 奖励计算公式。 区块(非叔块)的奖励公式（执笔时基本奖励为2eth）= 2eth + 2eth*（引用的叔块数/32）+ 矿工费 叔块奖励公式：叔块得到的奖励取决于引用这个叔块的区块与该叔块间隔的层数，层数范围为1~6，我们姑且将间隔的层数称为：层差，则计算叔块奖励公式可表示为：（8 - 层差）/ 8 * 2eth。 由上述公式可见：引用叔块能够增加本区块的奖励；层差越小叔块得到的奖励越多。 最重的链：与比特币使用最长链做主链不同，以太坊使用最重链这一概念，所谓的最重链，就是在该链上所完成的计算量是最大的。包含叔块能够增加本链条的重量。这便是GHOST协议的主要内容：定义确定主链的算法。换句话说，以太坊的GHOST协议就是一个“主链选择协议”。因而，在以太坊中，最长的链不一定是主链！ 重放攻击 该现象出现在硬分叉当中。假设一个币种N，有1000个币，在2018.11.11分叉了，新链币种叫NA，旧链币种仍然是N。分叉后，你的NA钱包中余额会显示是1000，N钱包显示的余额也是1000。 当你在NA钱包发出一笔交易，想要发给B，10 NA币。你签署完该交易后广播到NA网络，此时B动了歪脑筋，把你签署的交易原封不动的转发到了N网络，如果没有重放吧保护，这次交易可能同时被两个链承认——B同时收到了10 NA币 + 10 N币。 共识算法 POW（Proof of Work，工作量证明） 比特币、当下的以太坊都是用此类共识算法，耗电量巨大。 比特币的POW是计算一个hash值，它的前N位为0，N反映了当前的难度。我们可以通过比特币区块浏览器直接“看出”这个明显的挖矿成功的特征。“挖矿”过程是这样的：矿工不断将新的nonce填到块头中，计算块头的hash值，直到计算出的hash值的前N个值为0，挖矿成功。在此过程中，矿工需要自己组装块头，或者从矿池接受块头。 以太坊的POW比比特币要稍微多绕了一个弯，RAND(hashNoNonce, nonce) &lt;= M/d; RAND是一个抽象函数代表一系列操作；hashNoNonce是组装好的块头除去nonce字段的hash值，nonce是每次迭代尝试的随机数；M是一个极大值；d是难度；简单来说就是：使用hashNoNonce + nonce做输入参数，通过RAND函数寻找一个hash值，该值的大小不大于 M/d; （当难度增加时，d变大，M/d变小，挖矿难度增加）。 以太坊的挖矿过程只需要hashNoNonce而不需要整个块头，这在矿池-矿工模式中非常省心，矿池只需下发hashNoNonce以及对应的nonce范围给矿工即可，无需像比特币矿池一样发整个块头给各个矿工。 比特币的POW算法在最初设计时没有预料到后来矿机的崛起，以太坊的Ethash算法在设计之初就考虑了抵抗矿机这一特性。 POS （Proof of Stock，股权证明）类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，二者相乘便得到币龄，币龄越大，分配给你的利息就越多、记账概率越大。当获得激励之后，币龄清零，重新积累，如此周而复始。Peer Coin（点点币，PPC）、新星币(Nova Coin，NVC)、黑币（Black Coin，BLK）、NextCoin（未来币，NXT）等等,都是用的POS。 POA(Proofof Authority，授权证明) 由一组授权节点来负责新区块的产生和区块验证。以太坊测试网（Kovan）便是采用POA共识。一般用来搭建联盟链。 DPOS (Delegated Proof of Stake，委任权益证明) BTS/EOS正在使用的共识规则。它的原理是让每一个持有BTS/EOS的人进行投票，由此产生101(BTS)/21(EOS)位代表 , 也就是101/21个超级节点，这些超级节点负责打包交易、出块。超级节点要将出块所获得的奖励的一部分，分给支持自己的股民。 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法），联盟链常用的共识算法。 Paxos，私链常用的共识算法。 Raft，私链常用的共识算法。 关于共识算法的详细讨论，详见另一篇拙作。","@type":"BlogPosting","url":"/2018/11/04/1b9b5cce3d20d5a6e09fd2e57c61c0ae.html","headline":"区块链基本知识梳理","dateModified":"2018-11-04T00:00:00+08:00","datePublished":"2018-11-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/11/04/1b9b5cce3d20d5a6e09fd2e57c61c0ae.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链基本知识梳理</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：版权所有。转载请注明出处：扶风的博客 https://blog.csdn.net/JohnnyMartin/article/details/83622286 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h4><a id="_0"></a>公钥、私钥、与地址</h4> 
  <blockquote> 
   <ul> 
    <li>私钥是一切的根本，由它可以导出公钥、地址，而无法通过公钥推出私钥</li> 
    <li>公钥加密私钥解密，私钥签名公钥验证</li> 
    <li>以太坊使用的椭圆曲线算法可以从签名的数据中推算出该数据发送方的地址</li> 
    <li>公钥经过一系列操作之后可以推出地址，以太坊是将公钥做Keccak-256哈希，然后取最后的40位16进制字符</li> 
    <li>私钥一定要妥善备份，常用备份方式有：</li> 
   </ul> 
   <blockquote> 
    <ul> 
     <li>助记词,一般由12个单词组成，得到它就等于得到了私钥</li> 
     <li>keystore文件，一个json文件，本质上是把私钥加密之后的数据文件，解密需要输入加密时的密码</li> 
    </ul> 
   </blockquote> 
  </blockquote> 
  <h4><a id="_9"></a>公链、私链、联盟链</h4> 
  <p>主要区别：公有链向所有人开放，联盟链向授权的组织或机构开放，私有链向满足特定条件的个人开放（比如只对本公司的人开放）。</p> 
  <table> 
   <thead> 
    <tr> 
     <th></th> 
     <th>开放程度</th> 
     <th>出块节点</th> 
     <th>效率</th> 
     <th>共识算法</th> 
     <th>典型代表</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>公链</td> 
     <td>完全开放</td> 
     <td>任何节点</td> 
     <td>低</td> 
     <td>POW、POS、DPOS等</td> 
     <td>比特币、以太坊、EOS</td> 
    </tr> 
    <tr> 
     <td>私链</td> 
     <td>不开放、针对个人开放</td> 
     <td>少量节点出块</td> 
     <td>高</td> 
     <td>Raft、Paxos</td> 
     <td>蚂蚁金服</td> 
    </tr> 
    <tr> 
     <td>联盟链</td> 
     <td>针对特定机构、组织开放</td> 
     <td>授权节点出块</td> 
     <td>高</td> 
     <td>DBFT、PBFT</td> 
     <td>超级账本(Hyperledger)、ChinaLedger</td> 
    </tr> 
   </tbody> 
  </table>
  <h4><a id="_17"></a>钱包、热钱包、冷钱包</h4> 
  <blockquote> 
   <ul> 
    <li>钱包的本质：生成密钥、管理密钥、使用密钥的工具。</li> 
    <li>钱宝负责生成一个随机的私钥，根据此私钥生成公钥，再根据公钥得到地址</li> 
    <li>冷热钱包的本质区别在于存储私钥的方式</li> 
   </ul> 
   <blockquote> 
    <ul> 
     <li>冷钱包：网络无法访问到私钥</li> 
     <li>热钱包：网络可以访问到私钥</li> 
    </ul> 
   </blockquote> 
   <ul> 
    <li>冷钱包安全性好但是不适合频繁交易，热钱包反之。</li> 
   </ul> 
  </blockquote> 
  <h4><a id="_25"></a>硬分叉、软分叉</h4> 
  <blockquote> 
   <ul> 
    <li>本质区别：区块链网络上旧的节点是否认可新节点产生的区块。（一般新节点会在共识规则上做出一些改变）</li> 
    <li>若不认可，则新节点挖出的区块会被旧节点否决（达不成共识），于是新节点和旧节点会开始在不同的链上运行（挖矿、交易、验证等）</li> 
    <li>旧矿工的去留将决定旧分叉的生死</li> 
    <li>硬分叉影响较大，除非得到整个链生态的同意，否则贸然硬分叉极易造成该链的分裂。同时，硬分叉又具有相当大的”医疗作用“，尤其当发现重大bug、重大缺陷的时候（此时较容易得到整个链生态的同意）</li> 
    <li>软分叉不会产生两条链，新节点产生的区块可以被旧节点承认（达成共识），但是旧节点却无法识别新块中属于新规则的那部分数据真实意义。</li> 
    <li>软分叉不能增加数据字段，只能在现有结构上修改，升级空间有限，而且会让代码变复杂。</li> 
    <li>硬分叉通常是扩展共识规则，而软分叉是收紧共识规则，所以一旦进行了软分叉，想要回退就非常困难了，很可能造成硬分叉而导致资金损失</li> 
   </ul> 
  </blockquote> 
  <h4><a id="UTXO_34"></a>UTXO</h4> 
  <blockquote> 
   <ul> 
    <li>熟悉比特币的人应该都知道，为了尽可能少的泄露公钥，每次交易时比特币社区建议将余额转向一个新的地址。<br> （从公钥反推私钥虽然是极为困难的，但是不一定抵抗量子计算机，比特币地址的双重hash以及交易时将余额转向一个新的地址都是为了保护公钥，尽可能少的暴漏）<br> 那么问题来了，每次都将余额转到了一个新的地址，那我的账户下的余额岂不是无端没了？<br> 当然不会没了，事实上比特币世界中并没有账户的概念，也没有余额的概念，有的只是UTXO(Unspend Transaction Output)未花费的交易输出。“账户的余额”便是与该账户相关的UTXO的和。<br> 简单来说，比特币只记转账过程，不记余额。一笔转账由两大部分组成：输入部分、输出部分。输入部分便由一个个UTXO组成，例如，A打算转5个BTC给B，钱包知道A的所有UTXO，于是钱包挑出了A的A1，A2，A3三个UTXO，每个2 BTC，将这三个UTXO作为本次转账的输入，本次的输出有两部分：一部分将5 BTC转给 B，另一部分将剩余的1BTC转到一个新的地址（此处假设没有矿工费），这个新的地址是由钱包管理的。于是，这个拥有一个BTC的UTXO又可以作为下一次交易的输入。<br> 最关键的问题是：每一次都将未花费的余额存入新地址，新地址意味着对应一个新的私钥，这么多私钥，我都得一一备份么？当然不用——HD钱包（Hierarchical Deterministic 分层确定性）只是用一个“根私钥”也就是种子（seed），生成任意多的子私钥。我们备份钱包，只需备份“根私钥”的助记词即可。比如我们可以用这样一套算法生成子私钥：SHA256(seed + n)。只要seed确定了，后面的所有子私钥也都确定了。</li> 
   </ul> 
  </blockquote> 
  <h4><a id="_42"></a>双花问题的解决</h4> 
  <blockquote> 
   <ul> 
    <li>每发起一个交易，都要检查该交易的各个输入是否是“未花费的”。</li> 
    <li>交易接受者要等待6个确认块之后再确定本次交易成功了。（以太坊是12）</li> 
   </ul> 
  </blockquote> 
  <h4><a id="_46"></a>拜占庭将军问题及其解决</h4> 
  <p>问题场景：ABCD四个将军在不同的地方围攻敌军，任何一个将军都无法单独战胜敌人——他们需要协商一个一致的时间来一起发动进攻才能取胜。四个将军中最多有一个可能是叛徒，并且正直的将军不知道叛徒是谁。叛徒会想办法破坏将军们的进攻计划。那么，正直的将军们如何才能达成一致、战胜敌人呢？</p> 
  <p>该问题的计算机语言描述是这样的：如何在一个可能存在失效节点、作恶节点的对等网络中达成共识呢？<br> 我们先模仿一下将军们可能的做法：</p> 
  <blockquote> 
   <ul> 
    <li>情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，1点到了，B按兵不动，ACD如期进攻并打败了敌人。这是比较简单的情形。</li> 
    <li>情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。于是BCD三方依次单独进攻，统统被灭了。</li> 
   </ul> 
  </blockquote> 
  <p>我们可以很直观的看出上述做法的缺点：BCD收到的建议未经过验证。<br> 于是最简单的PBFT算法出现了——对每个收到建议的将军，他们每人都要询问其他人收到的内容，并以此做出判断。<br> 于是上面的情形2变成这个样子：</p> 
  <blockquote> 
   <ul> 
    <li>情形2：A是叛徒，A向B发出建议：下午1点进攻；向C发出建议：下午2点进攻；向D建议：下午3点进攻。B收到了建议，并派出b1、b2两个信使去询问CD两人收到的内容，CD也会做类似的事情。询问之后发现，我擦A给我们三个发的建议完全不一样啊——A这厮一定是叛徒无疑了。</li> 
   </ul> 
  </blockquote> 
  <p>情形2的问题随之而解，情形1又新的变化，请看：</p> 
  <blockquote> 
   <ul> 
    <li>情形1：A向BCD三个将军发出建议：下午1点进攻。B是叛徒，当C派信使c1来询问B的时候，B对信使说了谎——B这个叛徒试图打乱进攻的时间。对C来说，他收到A的建议是下午一点，信使c1从B处带回的建议是下午两点，信使c2从D处带回的建议也是下午一点，于是C立刻可以判断出来，B是叛徒了。同样的，D也能判断出B是叛徒，而采用“下午一点进攻”这一建议。</li> 
   </ul> 
  </blockquote> 
  <p>PBFT算法本质上是以通信次数达成共识——如果节点较多，效率低下。<br> <strong>共识算法，本质上都是在解决拜占庭将军问题。</strong> POW、POS、DPOS等都是在解决“如何在一个不靠谱的对等网络内达成一个大家都认可的一致意见”这个问题。</p> 
  <blockquote> 
   <ul> 
    <li>POW简单粗暴，相当于让将军们在10公里之外朝着敌人扔石头，砸死敌人相当于挖矿成功，没砸死就一直扔。</li> 
    <li>POS兼顾效率，按照将军的资历排个顺序，资历老的将军可以发号施令（出块），统一进攻时间</li> 
    <li>DPOS接近于POS，投票选出几个超级将军，这几个超级将军发号施令、统一进攻时间。</li> 
   </ul> 
  </blockquote> 
  <h4><a id="_69"></a>隔离见证</h4> 
  <h4><a id="_71"></a>叔块奖励</h4> 
  <p>叔块奖励是以太坊中的机制。比特币中的叔块并没有任何奖励，以太坊为何要给挖出叔块的矿工奖励呢？<br> 源于GOHST协议。</p> 
  <blockquote> 
   <ul> 
    <li>叔块是什么。在比特币中，最长链就是权威。假若两个矿工几乎同时挖出了同一个高度的两个块A1、A2，那么哪个块才是最终的块呢？这取决于谁的后面有更长的链。所以两个矿工会拼命的广播自己的块，以求让别的矿工在自己的块之上挖出更多的区块，使自己的块所在的链成为最长链、进而获得奖励。假设A1最终胜出，那A2就会成为孤块，没有任何奖励。在以太坊中，使用的是“最重链”这一概念。由于以太坊14秒出一块，块间隔远远小于BTC的10min，这就大大增加了矿工们挖出同一高度的块的概率。以太坊的GHOST协议认为，孤块，以太坊中称之为叔块，作为一个合法的区块，不是没有意义的，它可以为主链的安全做出贡献，因而也会奖励挖出孤块的旷工。</li> 
    <li>为何要给挖出叔块的人奖励。与这个问题等效的问题是：叔块如何为主链的安全做出贡献? 叔块成为主链的一部分，那么叔块里的coinbase自然就是合法的交易，自然就会收到奖励。</li> 
    <li>叔块如何为主链的安全做出贡献? 以太坊的区块可以包含 0~2 个叔块，并将这(些)叔块放到头部的UncleHash字段中。引用叔块需要遵守以下规则：</li> 
   </ul> 
   <blockquote> 
    <ul> 
     <li>区块最多引用2个叔块，可以不引用</li> 
     <li>所引用的叔块必须是当前块的前2~前7个节点的直接子块</li> 
     <li>被别的块引用过的叔块不能再次被引用</li> 
    </ul> 
   </blockquote> 
   <ul> 
    <li>奖励计算公式。</li> 
   </ul> 
   <blockquote> 
    <ul> 
     <li>区块(非叔块)的奖励公式（执笔时基本奖励为2eth）= 2eth + 2eth*（引用的叔块数/32）+ 矿工费</li> 
     <li>叔块奖励公式：叔块得到的奖励取决于引用这个叔块的区块与该叔块间隔的层数，层数范围为1~6，我们姑且将间隔的层数称为：层差，则计算叔块奖励公式可表示为：（8 - 层差）/ 8 * 2eth。</li> 
    </ul> 
   </blockquote> 
   <ul> 
    <li>由上述公式可见：引用叔块能够增加本区块的奖励；层差越小叔块得到的奖励越多。</li> 
    <li>最重的链：与比特币使用最长链做主链不同，以太坊使用最重链这一概念，所谓的最重链，就是在该链上所完成的计算量是最大的。包含叔块能够增加本链条的重量。这便是GHOST协议的主要内容：定义确定主链的算法。换句话说，以太坊的GHOST协议就是一个“主链选择协议”。因而，在以太坊中，最长的链不一定是主链！</li> 
   </ul> 
  </blockquote> 
  <h4><a id="_86"></a>重放攻击</h4> 
  <p>该现象出现在硬分叉当中。假设一个币种N，有1000个币，在2018.11.11分叉了，新链币种叫NA，旧链币种仍然是N。分叉后，你的NA钱包中余额会显示是1000，N钱包显示的余额也是1000。<br> 当你在NA钱包发出一笔交易，想要发给B，10 NA币。你签署完该交易后广播到NA网络，此时B动了歪脑筋，把你签署的交易原封不动的转发到了N网络，如果没有重放吧保护，这次交易可能同时被两个链承认——B同时收到了10 NA币 + 10 N币。</p> 
  <h4><a id="_90"></a>共识算法</h4> 
  <blockquote> 
   <ul> 
    <li>POW（Proof of Work，工作量证明） 比特币、当下的以太坊都是用此类共识算法，耗电量巨大。</li> 
   </ul> 
   <blockquote> 
    <ul> 
     <li>比特币的POW是计算一个hash值，它的前N位为0，N反映了当前的难度。我们可以通过比特币区块浏览器直接“看出”这个明显的挖矿成功的特征。“挖矿”过程是这样的：矿工不断将新的nonce填到块头中，计算块头的hash值，直到计算出的hash值的前N个值为0，挖矿成功。在此过程中，矿工需要自己组装块头，或者从矿池接受块头。</li> 
     <li>以太坊的POW比比特币要稍微多绕了一个弯，RAND(hashNoNonce, nonce) &lt;= M/d; RAND是一个抽象函数代表一系列操作；hashNoNonce是组装好的块头除去nonce字段的hash值，nonce是每次迭代尝试的随机数；M是一个极大值；d是难度；简单来说就是：使用hashNoNonce + nonce做输入参数，通过RAND函数寻找一个hash值，该值的大小不大于 M/d; （当难度增加时，d变大，M/d变小，挖矿难度增加）。</li> 
     <li>以太坊的挖矿过程只需要hashNoNonce而不需要整个块头，这在矿池-矿工模式中非常省心，矿池只需下发hashNoNonce以及对应的nonce范围给矿工即可，无需像比特币矿池一样发整个块头给各个矿工。</li> 
     <li>比特币的POW算法在最初设计时没有预料到后来矿机的崛起，以太坊的Ethash算法在设计之初就考虑了抵抗矿机这一特性。</li> 
    </ul> 
   </blockquote> 
   <ul> 
    <li>POS （Proof of Stock，股权证明）类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，二者相乘便得到币龄，币龄越大，分配给你的利息就越多、记账概率越大。当获得激励之后，币龄清零，重新积累，如此周而复始。Peer Coin（点点币，PPC）、新星币(Nova Coin，NVC)、黑币（Black Coin，BLK）、NextCoin（未来币，NXT）等等,都是用的POS。</li> 
    <li>POA(Proofof Authority，授权证明) 由一组授权节点来负责新区块的产生和区块验证。以太坊测试网（Kovan）便是采用POA共识。一般用来搭建联盟链。</li> 
    <li>DPOS (Delegated Proof of Stake，委任权益证明) BTS/EOS正在使用的共识规则。它的原理是让每一个持有BTS/EOS的人进行投票，由此产生101(BTS)/21(EOS)位代表 , 也就是101/21个超级节点，这些超级节点负责打包交易、出块。超级节点要将出块所获得的奖励的一部分，分给支持自己的股民。</li> 
    <li>PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法），联盟链常用的共识算法。</li> 
    <li>Paxos，私链常用的共识算法。</li> 
    <li>Raft，私链常用的共识算法。</li> 
   </ul> 
  </blockquote> 
  <p>关于共识算法的详细讨论，详见另一篇拙作。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center">  
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
