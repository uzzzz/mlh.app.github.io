<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hyperledger Fabric（一）—— Fabric简介及Fabric术语总结 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Hyperledger Fabric（一）—— Fabric简介及Fabric术语总结" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/The_Reader/article/details/83792662 背景 超级账本（Hyperledger）是linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。由于点对点网络的特性，分布式账本技术是完全共享、透明和去中心化的，故非常适合于在金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。通过创建分布式账本的公开标准，实现虚拟和数字形式的价值交换，例如资产合约、能源交易、结婚证书、能够安全和高效低成本的进行追踪和交易。 公有链：全网公开，没有类似CA的用户体验 联盟链：只针对某个群体的成员和有限的第三方，内部指定多个预选节点为记账人，每个块的生成由所有的预选节点共同决定 私有链：所有网络中的节点都掌握在一家机构手中 项目的目标是区块链及分布式记账系统的跨行业发展与协作，并着重发展性能和可靠性（相对于类似的数字货币的设计）使之可以支持主要的技术、金融和供应链公司中的全球商业交易。该项目将继承独立的开放协议和标准，通过框架方法和专用模块，包括各区块链的共识机制和存储方式，以及身份服务、访问控制和智能合约。 Hyperledger与数字货币 都是基于区块链技术实现的。 比特币1秒7笔交易，以太坊1分钟几百笔，hyperledger理论上1分钟50万比交易。 hyperledger 因为不用挖矿，不需要很强的硬件支持，也不耗费资源。 Hyperledger没有51%攻击问题，加入链中的成员经过CA认证，是有许可的网络 Hyperledger官网 https://www.hyperledger.org/ Hyperledger全家福 BURROW和SAWTOOTH是对以太坊智能合约虚拟机方面的拓展 INDY做去中心化的数字身份平台 CALIPER：是一个去中心化的性能测试工具 COMPOSER：区块链模板部署，设一些参数，直接部署 EXPLORER：是区块链web端查看工具 Fabric是什么？ hyperledger fabric 只是超级账本的项目之一，目前基于它开发的区块链项目非常多，不过需要注意，Hyperledger fabric 是一个联盟链开发平台，与时下流行的以太坊，EOS等公链平台有较大的不同，hyperledger fabric的中心化成都更高，并且链只限于联盟内的成员使用。但Hyperledger fabric相对来说能够达到更高的性能。 Hyperledger Fabric旨在作为开发模块化体系结构的区块链应用程序的基础，以便诸如共识和会员服务等组件可以即插即用。它使用容器技术来托管构成系统应用逻辑的智能合约（也称为链代码）。 简而言之，Hyperledger Fabric是为企业构建的领先的开源、通用区块链结构。 Fabric的本质 与一般区块链技术的相同点：Fabric与其他区块链技术一样，都有一个账本。和以太坊相像，也允许使用智能合约。从本质上看，它是参与者共同管理交易的系统，是联盟链的典型应用。 与一般区块链技术的不同点： 1）具有多种节点类型。不同节点赋予了不同的功能，增加了交易处理效率。 2）拥有准入资格授权机制。要成为超级账本Fabric的成员，首先要在MSP进行注册。 3）提供可插拔的选项。数据可以以多种格式存储，支持多种功能模块，如共识、权限管理模块等，模块允许加入或退出。 4）允许创建多通道。允许参与者建立单独的交易账本，不同通道间信息隔离。 Fabric的共享账本 在Fabric中，每个参与者都拥有所参与网络的共享账本副本，账本主要由以下两部分组成： 1）世界状态：以数据库的形式存在，描述了某个时间点的账本状态。世界状态数据库可以替换。 2）交易日志：记录某个世界状态对应的交易，描述了世界状态更新前后的数据库的值。 Fabric中的智能合约 在超级账本Fabric中，引入了一个新概念“系统链码”（chaincode）。系统链码应用于区块链系统的处理过程中，以实现可编程性以及支持第三方的参与。 应用：因此，Fabric中的智能合约，是写在链码中，可以使用多种编程语言来实现。当区块链外部应用程序需要与账本发生交易时，智能合约会被外部应用程序调用。 与账本的交互：链码通常是与账本中的数据库，即世界状态进行交互。 Fabric的几个特性 代币：Fabric是准入型网络，通过激励制度来保证网络安全与可持续性的需求不大，因此也没有代币机制。 区块打包：没有设置出块时间，有交易时才创建新区块，另外区块的大小也可以灵活设置。 共识不可逆转：以基于工作量证明共识机制的公有链为例，共识结果是可以随着时间的发生进行调整或改变。而Fabric的共识机制具有最终性，一旦达成，不可逆转。 数据的隐私与安全：Fabric可以对交易进行追踪，防止抵赖，但数据只有进行了授权才可以访问，隐私性强。另外，也有对数据的监管和审计，安全性高。 目标： 做企业联盟链的基础设施 可插拔的共识机制（solo（整个网咯中只含有一个order节点）和kafka（整个网络中含有多个order节点）等） 多链多通道隔离，做业务隔离，保护业务数据隐私 fabric的重要组件 fabric CA 自动生成认证证书 创建账户 是一个工具集 fabric Peer 可以又很多Peer,是ledger和blockchain存储的位置 一个Peer可以加入不同的channel fabric ordering service 提供排序服务 创建block区块 使用solo排序，配置成使用kafka排序（有限状态机） fabric的开发语言 智能合约（一下排序是根据github上的用户体验） go java SDK（以下排序是根据github上的用户体验） java node.js（官方推荐，效率） go（大坑，支持是最差的） python fabric的channel 每个channle可以理解成独立的fabric实例 不同的channel是私有的子网，类似于微信群，隔离业务数据，docker namespace peer是微信里的人，peer可以加入不同的channle 还可以设置允许什么人加入 fabric的chaiincode chaincode（链码）就是智能合约，是一个应用程序 用于更新账本数据，由peer去执行chaincode 在fabirc里，chaincode是数据唯一的更新的方式 chaincode属于某一个channel的 chaincode是生命周期 安装链码 实例化（调用init方法） 调用使用（调用invoke方法） 每个chaincode有不同的背书策略（如何去达成共识） 可能有的chaincode是所有人都同意才可以 可能有的chaincode是至少有一个人同意才可以 可能有的chaincode是有4个人同意才可以 适应企业复杂应用场景 fabric的msp 是一组重要的密码学签名工具 定义了你是谁，你在哪（在那个channel中） CA去颁发证书 fabric术语总结 Anchor Peer / 锚节点 所有其他peer可以发现并与之通信的channel上的一个peer。channel上的每个Member都有一个（或者对个，以防止单点故障）Anchor Peer，允许属于不同Member的peer发现channel上的现有其他peer。 Block / 区块 在一个channel上与前一个block加密连接的一组有序交易集。 Chain / 链 chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。 Chaincode / 链码 Chaincode是一个运行在ledger上的软件，对资产和交易指令（业务逻辑）编码来修改资产。 Channel / 通道 channel是在Fabric网络中的私有区块链区域，实现了数据的隔离和保密。channel特定的ledger在该channel上的所有peer之间共享，交易方必须有对该channel正确的认证才能与该ledger交互。channel由Configuration Block定义。 Commitment / 提交 一个channel中的每个peer都会验证交易的有序block，然后将block提交（写或追加）至该channel上ledger的各个副本。peer还会标记每个block中的每个交易是否有效。 Concurrency Control Version Check / CCVC CCVC是一种channel中各peer间保持状态同步的方法。peer并行执行交易，在提交至ledger之前会检查在执行期间读到的数据有没有被修改。如果读取的数据在执行和提交之间被改变，就会引发CCVC冲突，该交易就会被标记为无效，值不会更新到状态数据库中。 Configuration Block / 配置区块 包含 system chain (ordering service) 或 channel 的Member和策略配置数据。对某个channel或整个网络的任何修改（比如，Member离开或加入）都将导致一个新的Configuration Block追加到适当的chain中。这个Configuration Block会包含 genesis block的内容加上增量。 Consensus / 共识 Consensus是贯穿整个交易流程的广义术语，其用于产生对于order的共识和确认构成block的所有交易的正确性。 Current State / 当前状态 ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。 Dynamic Membership / 动态成员 Fabric支持动态添加/移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加/移除实体时，Dynamic Membership至关重要。 Endorsement / 背书 Endorsement 是指一个peer执行一个交易并返回YES/NO给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。 Endorsement policy / 背书策略 Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。 Fabric-ca Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。 Genesis Block / 初始区块 Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。 Gossip Protocol / Gossip协议 Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。 Initialize / 初始化 一个初始化chaincode程序的方法。 Install / 安装 将chaincode放到peer的文件系统的过程。（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath/chaincodeName.chainVersion文件中） Instantiate / 实例化 启动chaincode容器的过程。（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法） Invoke / 调用 用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。 Leading Peer / 主导节点 每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。 Ledger / 账本 Ledger是个channel的chain和由channel中每个peer维护的world state。（这个解释有点怪） Member / 成员 拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。 Membership Service Provider / MSP MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。 Membership Services / 成员服务 成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。 fabric-ca组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。 Ordering Service / 排序服务或共识服务 将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。 Peer / 节点 一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read/write操作。peer由Member拥有和维护。 Policy / 策略 有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络/通道管理策略。 Proposal / 提案 一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。 Query / 查询 对于current state中某个key的value的查询请求。 Software Development Kit / SDK SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。 State Database / stateDB 为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。 System Chain / 系统链 包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。 系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。 Transaction / 交易 Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read/write set；Instantiate是请求在peer上启动Chaincode容器。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/The_Reader/article/details/83792662 背景 超级账本（Hyperledger）是linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。由于点对点网络的特性，分布式账本技术是完全共享、透明和去中心化的，故非常适合于在金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。通过创建分布式账本的公开标准，实现虚拟和数字形式的价值交换，例如资产合约、能源交易、结婚证书、能够安全和高效低成本的进行追踪和交易。 公有链：全网公开，没有类似CA的用户体验 联盟链：只针对某个群体的成员和有限的第三方，内部指定多个预选节点为记账人，每个块的生成由所有的预选节点共同决定 私有链：所有网络中的节点都掌握在一家机构手中 项目的目标是区块链及分布式记账系统的跨行业发展与协作，并着重发展性能和可靠性（相对于类似的数字货币的设计）使之可以支持主要的技术、金融和供应链公司中的全球商业交易。该项目将继承独立的开放协议和标准，通过框架方法和专用模块，包括各区块链的共识机制和存储方式，以及身份服务、访问控制和智能合约。 Hyperledger与数字货币 都是基于区块链技术实现的。 比特币1秒7笔交易，以太坊1分钟几百笔，hyperledger理论上1分钟50万比交易。 hyperledger 因为不用挖矿，不需要很强的硬件支持，也不耗费资源。 Hyperledger没有51%攻击问题，加入链中的成员经过CA认证，是有许可的网络 Hyperledger官网 https://www.hyperledger.org/ Hyperledger全家福 BURROW和SAWTOOTH是对以太坊智能合约虚拟机方面的拓展 INDY做去中心化的数字身份平台 CALIPER：是一个去中心化的性能测试工具 COMPOSER：区块链模板部署，设一些参数，直接部署 EXPLORER：是区块链web端查看工具 Fabric是什么？ hyperledger fabric 只是超级账本的项目之一，目前基于它开发的区块链项目非常多，不过需要注意，Hyperledger fabric 是一个联盟链开发平台，与时下流行的以太坊，EOS等公链平台有较大的不同，hyperledger fabric的中心化成都更高，并且链只限于联盟内的成员使用。但Hyperledger fabric相对来说能够达到更高的性能。 Hyperledger Fabric旨在作为开发模块化体系结构的区块链应用程序的基础，以便诸如共识和会员服务等组件可以即插即用。它使用容器技术来托管构成系统应用逻辑的智能合约（也称为链代码）。 简而言之，Hyperledger Fabric是为企业构建的领先的开源、通用区块链结构。 Fabric的本质 与一般区块链技术的相同点：Fabric与其他区块链技术一样，都有一个账本。和以太坊相像，也允许使用智能合约。从本质上看，它是参与者共同管理交易的系统，是联盟链的典型应用。 与一般区块链技术的不同点： 1）具有多种节点类型。不同节点赋予了不同的功能，增加了交易处理效率。 2）拥有准入资格授权机制。要成为超级账本Fabric的成员，首先要在MSP进行注册。 3）提供可插拔的选项。数据可以以多种格式存储，支持多种功能模块，如共识、权限管理模块等，模块允许加入或退出。 4）允许创建多通道。允许参与者建立单独的交易账本，不同通道间信息隔离。 Fabric的共享账本 在Fabric中，每个参与者都拥有所参与网络的共享账本副本，账本主要由以下两部分组成： 1）世界状态：以数据库的形式存在，描述了某个时间点的账本状态。世界状态数据库可以替换。 2）交易日志：记录某个世界状态对应的交易，描述了世界状态更新前后的数据库的值。 Fabric中的智能合约 在超级账本Fabric中，引入了一个新概念“系统链码”（chaincode）。系统链码应用于区块链系统的处理过程中，以实现可编程性以及支持第三方的参与。 应用：因此，Fabric中的智能合约，是写在链码中，可以使用多种编程语言来实现。当区块链外部应用程序需要与账本发生交易时，智能合约会被外部应用程序调用。 与账本的交互：链码通常是与账本中的数据库，即世界状态进行交互。 Fabric的几个特性 代币：Fabric是准入型网络，通过激励制度来保证网络安全与可持续性的需求不大，因此也没有代币机制。 区块打包：没有设置出块时间，有交易时才创建新区块，另外区块的大小也可以灵活设置。 共识不可逆转：以基于工作量证明共识机制的公有链为例，共识结果是可以随着时间的发生进行调整或改变。而Fabric的共识机制具有最终性，一旦达成，不可逆转。 数据的隐私与安全：Fabric可以对交易进行追踪，防止抵赖，但数据只有进行了授权才可以访问，隐私性强。另外，也有对数据的监管和审计，安全性高。 目标： 做企业联盟链的基础设施 可插拔的共识机制（solo（整个网咯中只含有一个order节点）和kafka（整个网络中含有多个order节点）等） 多链多通道隔离，做业务隔离，保护业务数据隐私 fabric的重要组件 fabric CA 自动生成认证证书 创建账户 是一个工具集 fabric Peer 可以又很多Peer,是ledger和blockchain存储的位置 一个Peer可以加入不同的channel fabric ordering service 提供排序服务 创建block区块 使用solo排序，配置成使用kafka排序（有限状态机） fabric的开发语言 智能合约（一下排序是根据github上的用户体验） go java SDK（以下排序是根据github上的用户体验） java node.js（官方推荐，效率） go（大坑，支持是最差的） python fabric的channel 每个channle可以理解成独立的fabric实例 不同的channel是私有的子网，类似于微信群，隔离业务数据，docker namespace peer是微信里的人，peer可以加入不同的channle 还可以设置允许什么人加入 fabric的chaiincode chaincode（链码）就是智能合约，是一个应用程序 用于更新账本数据，由peer去执行chaincode 在fabirc里，chaincode是数据唯一的更新的方式 chaincode属于某一个channel的 chaincode是生命周期 安装链码 实例化（调用init方法） 调用使用（调用invoke方法） 每个chaincode有不同的背书策略（如何去达成共识） 可能有的chaincode是所有人都同意才可以 可能有的chaincode是至少有一个人同意才可以 可能有的chaincode是有4个人同意才可以 适应企业复杂应用场景 fabric的msp 是一组重要的密码学签名工具 定义了你是谁，你在哪（在那个channel中） CA去颁发证书 fabric术语总结 Anchor Peer / 锚节点 所有其他peer可以发现并与之通信的channel上的一个peer。channel上的每个Member都有一个（或者对个，以防止单点故障）Anchor Peer，允许属于不同Member的peer发现channel上的现有其他peer。 Block / 区块 在一个channel上与前一个block加密连接的一组有序交易集。 Chain / 链 chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。 Chaincode / 链码 Chaincode是一个运行在ledger上的软件，对资产和交易指令（业务逻辑）编码来修改资产。 Channel / 通道 channel是在Fabric网络中的私有区块链区域，实现了数据的隔离和保密。channel特定的ledger在该channel上的所有peer之间共享，交易方必须有对该channel正确的认证才能与该ledger交互。channel由Configuration Block定义。 Commitment / 提交 一个channel中的每个peer都会验证交易的有序block，然后将block提交（写或追加）至该channel上ledger的各个副本。peer还会标记每个block中的每个交易是否有效。 Concurrency Control Version Check / CCVC CCVC是一种channel中各peer间保持状态同步的方法。peer并行执行交易，在提交至ledger之前会检查在执行期间读到的数据有没有被修改。如果读取的数据在执行和提交之间被改变，就会引发CCVC冲突，该交易就会被标记为无效，值不会更新到状态数据库中。 Configuration Block / 配置区块 包含 system chain (ordering service) 或 channel 的Member和策略配置数据。对某个channel或整个网络的任何修改（比如，Member离开或加入）都将导致一个新的Configuration Block追加到适当的chain中。这个Configuration Block会包含 genesis block的内容加上增量。 Consensus / 共识 Consensus是贯穿整个交易流程的广义术语，其用于产生对于order的共识和确认构成block的所有交易的正确性。 Current State / 当前状态 ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。 Dynamic Membership / 动态成员 Fabric支持动态添加/移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加/移除实体时，Dynamic Membership至关重要。 Endorsement / 背书 Endorsement 是指一个peer执行一个交易并返回YES/NO给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。 Endorsement policy / 背书策略 Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。 Fabric-ca Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。 Genesis Block / 初始区块 Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。 Gossip Protocol / Gossip协议 Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。 Initialize / 初始化 一个初始化chaincode程序的方法。 Install / 安装 将chaincode放到peer的文件系统的过程。（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath/chaincodeName.chainVersion文件中） Instantiate / 实例化 启动chaincode容器的过程。（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法） Invoke / 调用 用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。 Leading Peer / 主导节点 每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。 Ledger / 账本 Ledger是个channel的chain和由channel中每个peer维护的world state。（这个解释有点怪） Member / 成员 拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。 Membership Service Provider / MSP MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。 Membership Services / 成员服务 成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。 fabric-ca组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。 Ordering Service / 排序服务或共识服务 将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。 Peer / 节点 一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read/write操作。peer由Member拥有和维护。 Policy / 策略 有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络/通道管理策略。 Proposal / 提案 一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。 Query / 查询 对于current state中某个key的value的查询请求。 Software Development Kit / SDK SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。 State Database / stateDB 为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。 System Chain / 系统链 包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。 系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。 Transaction / 交易 Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read/write set；Instantiate是请求在peer上启动Chaincode容器。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/11/06/d91c6e561019f20dff824ec4f27cdda5.html" />
<meta property="og:url" content="https://mlh.app/2018/11/06/d91c6e561019f20dff824ec4f27cdda5.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/The_Reader/article/details/83792662 背景 超级账本（Hyperledger）是linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。由于点对点网络的特性，分布式账本技术是完全共享、透明和去中心化的，故非常适合于在金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。通过创建分布式账本的公开标准，实现虚拟和数字形式的价值交换，例如资产合约、能源交易、结婚证书、能够安全和高效低成本的进行追踪和交易。 公有链：全网公开，没有类似CA的用户体验 联盟链：只针对某个群体的成员和有限的第三方，内部指定多个预选节点为记账人，每个块的生成由所有的预选节点共同决定 私有链：所有网络中的节点都掌握在一家机构手中 项目的目标是区块链及分布式记账系统的跨行业发展与协作，并着重发展性能和可靠性（相对于类似的数字货币的设计）使之可以支持主要的技术、金融和供应链公司中的全球商业交易。该项目将继承独立的开放协议和标准，通过框架方法和专用模块，包括各区块链的共识机制和存储方式，以及身份服务、访问控制和智能合约。 Hyperledger与数字货币 都是基于区块链技术实现的。 比特币1秒7笔交易，以太坊1分钟几百笔，hyperledger理论上1分钟50万比交易。 hyperledger 因为不用挖矿，不需要很强的硬件支持，也不耗费资源。 Hyperledger没有51%攻击问题，加入链中的成员经过CA认证，是有许可的网络 Hyperledger官网 https://www.hyperledger.org/ Hyperledger全家福 BURROW和SAWTOOTH是对以太坊智能合约虚拟机方面的拓展 INDY做去中心化的数字身份平台 CALIPER：是一个去中心化的性能测试工具 COMPOSER：区块链模板部署，设一些参数，直接部署 EXPLORER：是区块链web端查看工具 Fabric是什么？ hyperledger fabric 只是超级账本的项目之一，目前基于它开发的区块链项目非常多，不过需要注意，Hyperledger fabric 是一个联盟链开发平台，与时下流行的以太坊，EOS等公链平台有较大的不同，hyperledger fabric的中心化成都更高，并且链只限于联盟内的成员使用。但Hyperledger fabric相对来说能够达到更高的性能。 Hyperledger Fabric旨在作为开发模块化体系结构的区块链应用程序的基础，以便诸如共识和会员服务等组件可以即插即用。它使用容器技术来托管构成系统应用逻辑的智能合约（也称为链代码）。 简而言之，Hyperledger Fabric是为企业构建的领先的开源、通用区块链结构。 Fabric的本质 与一般区块链技术的相同点：Fabric与其他区块链技术一样，都有一个账本。和以太坊相像，也允许使用智能合约。从本质上看，它是参与者共同管理交易的系统，是联盟链的典型应用。 与一般区块链技术的不同点： 1）具有多种节点类型。不同节点赋予了不同的功能，增加了交易处理效率。 2）拥有准入资格授权机制。要成为超级账本Fabric的成员，首先要在MSP进行注册。 3）提供可插拔的选项。数据可以以多种格式存储，支持多种功能模块，如共识、权限管理模块等，模块允许加入或退出。 4）允许创建多通道。允许参与者建立单独的交易账本，不同通道间信息隔离。 Fabric的共享账本 在Fabric中，每个参与者都拥有所参与网络的共享账本副本，账本主要由以下两部分组成： 1）世界状态：以数据库的形式存在，描述了某个时间点的账本状态。世界状态数据库可以替换。 2）交易日志：记录某个世界状态对应的交易，描述了世界状态更新前后的数据库的值。 Fabric中的智能合约 在超级账本Fabric中，引入了一个新概念“系统链码”（chaincode）。系统链码应用于区块链系统的处理过程中，以实现可编程性以及支持第三方的参与。 应用：因此，Fabric中的智能合约，是写在链码中，可以使用多种编程语言来实现。当区块链外部应用程序需要与账本发生交易时，智能合约会被外部应用程序调用。 与账本的交互：链码通常是与账本中的数据库，即世界状态进行交互。 Fabric的几个特性 代币：Fabric是准入型网络，通过激励制度来保证网络安全与可持续性的需求不大，因此也没有代币机制。 区块打包：没有设置出块时间，有交易时才创建新区块，另外区块的大小也可以灵活设置。 共识不可逆转：以基于工作量证明共识机制的公有链为例，共识结果是可以随着时间的发生进行调整或改变。而Fabric的共识机制具有最终性，一旦达成，不可逆转。 数据的隐私与安全：Fabric可以对交易进行追踪，防止抵赖，但数据只有进行了授权才可以访问，隐私性强。另外，也有对数据的监管和审计，安全性高。 目标： 做企业联盟链的基础设施 可插拔的共识机制（solo（整个网咯中只含有一个order节点）和kafka（整个网络中含有多个order节点）等） 多链多通道隔离，做业务隔离，保护业务数据隐私 fabric的重要组件 fabric CA 自动生成认证证书 创建账户 是一个工具集 fabric Peer 可以又很多Peer,是ledger和blockchain存储的位置 一个Peer可以加入不同的channel fabric ordering service 提供排序服务 创建block区块 使用solo排序，配置成使用kafka排序（有限状态机） fabric的开发语言 智能合约（一下排序是根据github上的用户体验） go java SDK（以下排序是根据github上的用户体验） java node.js（官方推荐，效率） go（大坑，支持是最差的） python fabric的channel 每个channle可以理解成独立的fabric实例 不同的channel是私有的子网，类似于微信群，隔离业务数据，docker namespace peer是微信里的人，peer可以加入不同的channle 还可以设置允许什么人加入 fabric的chaiincode chaincode（链码）就是智能合约，是一个应用程序 用于更新账本数据，由peer去执行chaincode 在fabirc里，chaincode是数据唯一的更新的方式 chaincode属于某一个channel的 chaincode是生命周期 安装链码 实例化（调用init方法） 调用使用（调用invoke方法） 每个chaincode有不同的背书策略（如何去达成共识） 可能有的chaincode是所有人都同意才可以 可能有的chaincode是至少有一个人同意才可以 可能有的chaincode是有4个人同意才可以 适应企业复杂应用场景 fabric的msp 是一组重要的密码学签名工具 定义了你是谁，你在哪（在那个channel中） CA去颁发证书 fabric术语总结 Anchor Peer / 锚节点 所有其他peer可以发现并与之通信的channel上的一个peer。channel上的每个Member都有一个（或者对个，以防止单点故障）Anchor Peer，允许属于不同Member的peer发现channel上的现有其他peer。 Block / 区块 在一个channel上与前一个block加密连接的一组有序交易集。 Chain / 链 chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。 Chaincode / 链码 Chaincode是一个运行在ledger上的软件，对资产和交易指令（业务逻辑）编码来修改资产。 Channel / 通道 channel是在Fabric网络中的私有区块链区域，实现了数据的隔离和保密。channel特定的ledger在该channel上的所有peer之间共享，交易方必须有对该channel正确的认证才能与该ledger交互。channel由Configuration Block定义。 Commitment / 提交 一个channel中的每个peer都会验证交易的有序block，然后将block提交（写或追加）至该channel上ledger的各个副本。peer还会标记每个block中的每个交易是否有效。 Concurrency Control Version Check / CCVC CCVC是一种channel中各peer间保持状态同步的方法。peer并行执行交易，在提交至ledger之前会检查在执行期间读到的数据有没有被修改。如果读取的数据在执行和提交之间被改变，就会引发CCVC冲突，该交易就会被标记为无效，值不会更新到状态数据库中。 Configuration Block / 配置区块 包含 system chain (ordering service) 或 channel 的Member和策略配置数据。对某个channel或整个网络的任何修改（比如，Member离开或加入）都将导致一个新的Configuration Block追加到适当的chain中。这个Configuration Block会包含 genesis block的内容加上增量。 Consensus / 共识 Consensus是贯穿整个交易流程的广义术语，其用于产生对于order的共识和确认构成block的所有交易的正确性。 Current State / 当前状态 ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。 Dynamic Membership / 动态成员 Fabric支持动态添加/移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加/移除实体时，Dynamic Membership至关重要。 Endorsement / 背书 Endorsement 是指一个peer执行一个交易并返回YES/NO给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。 Endorsement policy / 背书策略 Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。 Fabric-ca Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。 Genesis Block / 初始区块 Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。 Gossip Protocol / Gossip协议 Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。 Initialize / 初始化 一个初始化chaincode程序的方法。 Install / 安装 将chaincode放到peer的文件系统的过程。（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath/chaincodeName.chainVersion文件中） Instantiate / 实例化 启动chaincode容器的过程。（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法） Invoke / 调用 用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。 Leading Peer / 主导节点 每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。 Ledger / 账本 Ledger是个channel的chain和由channel中每个peer维护的world state。（这个解释有点怪） Member / 成员 拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。 Membership Service Provider / MSP MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。 Membership Services / 成员服务 成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。 fabric-ca组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。 Ordering Service / 排序服务或共识服务 将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。 Peer / 节点 一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read/write操作。peer由Member拥有和维护。 Policy / 策略 有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络/通道管理策略。 Proposal / 提案 一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。 Query / 查询 对于current state中某个key的value的查询请求。 Software Development Kit / SDK SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。 State Database / stateDB 为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。 System Chain / 系统链 包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。 系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。 Transaction / 交易 Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read/write set；Instantiate是请求在peer上启动Chaincode容器。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/11/06/d91c6e561019f20dff824ec4f27cdda5.html","headline":"Hyperledger Fabric（一）—— Fabric简介及Fabric术语总结","dateModified":"2018-11-06T00:00:00+08:00","datePublished":"2018-11-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/11/06/d91c6e561019f20dff824ec4f27cdda5.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Hyperledger Fabric（一）—— Fabric简介及Fabric术语总结</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/The_Reader/article/details/83792662 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d7e2a68c7c.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>背景</h1> 
  <p style="text-indent:50px;">超级账本（Hyperledger）是linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。由于点对点网络的特性，分布式账本技术是完全共享、透明和去中心化的，故非常适合于在金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。通过创建分布式账本的公开标准，实现虚拟和数字形式的价值交换，例如资产合约、能源交易、结婚证书、能够安全和高效低成本的进行追踪和交易。</p> 
  <ul>
   <li>公有链：全网公开，没有类似CA的用户体验</li> 
   <li>联盟链：只针对某个群体的成员和有限的第三方，内部指定多个预选节点为记账人，每个块的生成由所有的预选节点共同决定</li> 
   <li>私有链：所有网络中的节点都掌握在一家机构手中</li> 
  </ul>
  <p style="text-indent:50px;">项目的目标是区块链及分布式记账系统的跨行业发展与协作，并着重发展性能和可靠性（相对于类似的<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81" rel="nofollow">数字货币</a>的设计）使之可以支持主要的技术、金融和供应链公司中的全球商业交易。该项目将继承独立的开放协议和标准，通过框架方法和专用模块，包括各区块链的共识机制和存储方式，以及身份服务、访问控制和智能合约。</p> 
  <h1>Hyperledger与数字货币</h1> 
  <ul>
   <li>都是基于区块链技术实现的。</li> 
   <li>比特币1秒7笔交易，以太坊1分钟几百笔，hyperledger理论上1分钟50万比交易。</li> 
   <li>hyperledger 因为不用挖矿，不需要很强的硬件支持，也不耗费资源。</li> 
   <li>Hyperledger没有51%攻击问题，加入链中的成员经过CA认证，是有许可的网络</li> 
  </ul>
  <h3>Hyperledger官网</h3> 
  <pre class="has">
<code>https://www.hyperledger.org/</code></pre> 
  <h3>Hyperledger全家福</h3> 
  <p><img alt="" class="has" height="280" src="https://img-blog.csdnimg.cn/2018110619203965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoZV9SZWFkZXI=,size_16,color_FFFFFF,t_70" width="585"></p> 
  <ul>
   <li>BURROW和SAWTOOTH是对以太坊智能合约虚拟机方面的拓展</li> 
   <li>INDY做去中心化的数字身份平台</li> 
   <li>CALIPER：是一个去中心化的性能测试工具</li> 
   <li>COMPOSER：区块链模板部署，设一些参数，直接部署</li> 
   <li>EXPLORER：是区块链web端查看工具</li> 
  </ul>
  <h3>Fabric是什么？</h3> 
  <p style="text-indent:50px;">hyperledger fabric 只是超级账本的项目之一，目前基于它开发的区块链项目非常多，不过需要注意，Hyperledger fabric 是一个联盟链开发平台，与时下流行的以太坊，EOS等公链平台有较大的不同，hyperledger fabric的中心化成都更高，并且链只限于联盟内的成员使用。但Hyperledger fabric相对来说能够达到更高的性能。</p> 
  <p style="text-indent:50px;">Hyperledger Fabric旨在作为开发模块化体系结构的区块链应用程序的基础，以便诸如共识和会员服务等组件可以即插即用。它使用容器技术来托管构成系统应用逻辑的智能合约（也称为链代码）。 简而言之，Hyperledger Fabric是为企业构建的领先的开源、通用区块链结构。</p> 
  <h3>Fabric的本质</h3> 
  <p>与一般区块链技术的相同点：Fabric与其他区块链技术一样，都有一个账本。和以太坊相像，也允许使用智能合约。从本质上看，它是参与者共同管理交易的系统，是联盟链的典型应用。</p> 
  <p><strong>与一般区块链技术的不同点：</strong></p> 
  <p>1）具有多种节点类型。不同节点赋予了不同的功能，增加了交易处理效率。</p> 
  <p>2）拥有准入资格授权机制。要成为超级账本Fabric的成员，首先要在MSP进行注册。</p> 
  <p>3）提供可插拔的选项。数据可以以多种格式存储，支持多种功能模块，如共识、权限管理模块等，模块允许加入或退出。</p> 
  <p>4）允许创建多通道。允许参与者建立单独的交易账本，不同通道间信息隔离。</p> 
  <h3>Fabric的共享账本</h3> 
  <p>在Fabric中，每个参与者都拥有所参与网络的共享账本副本，账本主要由以下两部分组成：</p> 
  <p>1）世界状态：以数据库的形式存在，描述了某个时间点的账本状态。世界状态数据库可以替换。</p> 
  <p>2）交易日志：记录某个世界状态对应的交易，描述了世界状态更新前后的数据库的值。</p> 
  <h3>Fabric中的智能合约</h3> 
  <p>在超级账本Fabric中，引入了一个新概念“系统链码”（chaincode）。系统链码应用于区块链系统的处理过程中，以实现可编程性以及支持第三方的参与。</p> 
  <p><strong>应用</strong>：因此，Fabric中的智能合约，是写在链码中，可以使用多种编程语言来实现。当区块链外部应用程序需要与账本发生交易时，智能合约会被外部应用程序调用。</p> 
  <p><strong>与账本的交互</strong>：链码通常是与账本中的数据库，即世界状态进行交互。</p> 
  <h3>Fabric的几个特性</h3> 
  <p><strong>代币</strong>：Fabric是准入型网络，通过激励制度来保证网络安全与可持续性的需求不大，因此也没有代币机制。</p> 
  <p><strong>区块打包</strong>：没有设置出块时间，有交易时才创建新区块，另外区块的大小也可以灵活设置。</p> 
  <p><strong>共识不可逆转</strong>：以基于工作量证明共识机制的公有链为例，共识结果是可以随着时间的发生进行调整或改变。而Fabric的共识机制具有最终性，一旦达成，不可逆转。</p> 
  <p><strong>数据的隐私与安全</strong>：Fabric可以对交易进行追踪，防止抵赖，但数据只有进行了授权才可以访问，隐私性强。另外，也有对数据的监管和审计，安全性高。</p> 
  <h3>目标：</h3> 
  <p style="text-indent:50px;">做企业联盟链的基础设施</p> 
  <ol>
   <li>可插拔的共识机制（solo（整个网咯中只含有一个order节点）和kafka（整个网络中含有多个order节点）等）</li> 
   <li>多链多通道隔离，做业务隔离，保护业务数据隐私</li> 
  </ol>
  <h3>fabric的重要组件</h3> 
  <ul>
   <li>fabric CA</li> 
  </ul>
  <ol>
   <li>自动生成认证证书</li> 
   <li>创建账户</li> 
   <li>是一个工具集</li> 
  </ol>
  <ul>
   <li>fabric Peer</li> 
  </ul>
  <ol>
   <li>可以又很多Peer,是ledger和blockchain存储的位置</li> 
   <li>一个Peer可以加入不同的channel</li> 
  </ol>
  <ul>
   <li>fabric ordering service</li> 
  </ul>
  <ol>
   <li>提供排序服务</li> 
   <li>创建block区块</li> 
   <li>使用solo排序，配置成使用kafka排序（有限状态机）</li> 
  </ol>
  <h3>fabric的开发语言</h3> 
  <ul>
   <li>智能合约（一下排序是根据github上的用户体验）</li> 
  </ul>
  <ol>
   <li>go</li> 
   <li>java</li> 
  </ol>
  <ul>
   <li>SDK（以下排序是根据github上的用户体验）</li> 
  </ul>
  <ol>
   <li>java</li> 
   <li>node.js（官方推荐，效率）</li> 
   <li>go（大坑，支持是最差的）</li> 
   <li>python</li> 
  </ol>
  <h3>fabric的channel</h3> 
  <ol>
   <li>每个channle可以理解成独立的fabric实例</li> 
   <li>不同的channel是私有的子网，类似于微信群，隔离业务数据，docker namespace</li> 
   <li>peer是微信里的人，peer可以加入不同的channle</li> 
   <li>还可以设置允许什么人加入</li> 
  </ol>
  <h3>fabric的chaiincode</h3> 
  <ul>
   <li>chaincode（链码）就是智能合约，是一个应用程序</li> 
   <li>用于更新账本数据，由peer去执行chaincode</li> 
   <li>在fabirc里，chaincode是数据唯一的更新的方式</li> 
   <li>chaincode属于某一个channel的</li> 
   <li>chaincode是生命周期 
    <ol>
     <li>安装链码</li> 
     <li>实例化（调用init方法）</li> 
     <li>调用使用（调用invoke方法）</li> 
    </ol></li> 
   <li>每个chaincode有不同的<span style="color:#ff0000;">背书策略</span>（如何去达成共识） 
    <ol>
     <li>可能有的chaincode是所有人都同意才可以</li> 
     <li>可能有的chaincode是至少有一个人同意才可以</li> 
     <li>可能有的chaincode是有4个人同意才可以</li> 
     <li>适应企业复杂应用场景</li> 
    </ol></li> 
  </ul>
  <h3>fabric的msp</h3> 
  <ol>
   <li>是一组重要的密码学签名工具</li> 
   <li>定义了你是谁，你在哪（在那个channel中）</li> 
   <li>CA去颁发证书</li> 
  </ol>
  <h1>fabric术语总结</h1> 
  <h3 id="anchor-peer--锚节点">Anchor Peer / 锚节点</h3> 
  <p>所有其他peer可以发现并与之通信的channel上的一个peer。channel上的每个Member都有一个（或者对个，以防止单点故障）Anchor Peer，允许属于不同Member的peer发现channel上的现有其他peer。</p> 
  <h3 id="block--区块">Block / 区块</h3> 
  <p>在一个channel上与前一个block加密连接的一组有序交易集。</p> 
  <h3 id="chain--链">Chain / 链</h3> 
  <p>chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。</p> 
  <h3 id="chaincode--链码">Chaincode / 链码</h3> 
  <p>Chaincode是一个运行在ledger上的软件，对资产和交易指令（业务逻辑）编码来修改资产。</p> 
  <h3 id="channel--通道">Channel / 通道</h3> 
  <p>channel是在Fabric网络中的私有区块链区域，实现了数据的隔离和保密。channel特定的ledger在该channel上的所有peer之间共享，交易方必须有对该channel正确的认证才能与该ledger交互。channel由Configuration Block定义。</p> 
  <h3 id="commitment--提交">Commitment / 提交</h3> 
  <p>一个channel中的每个peer都会验证交易的有序block，然后将block提交（写或追加）至该channel上ledger的各个副本。peer还会标记每个block中的每个交易是否有效。</p> 
  <h3 id="concurrency-control-version-check--ccvc">Concurrency Control Version Check / CCVC</h3> 
  <p>CCVC是一种channel中各peer间保持状态同步的方法。peer并行执行交易，在提交至ledger之前会检查在执行期间读到的数据有没有被修改。如果读取的数据在执行和提交之间被改变，就会引发CCVC冲突，该交易就会被标记为无效，值不会更新到状态数据库中。</p> 
  <h3 id="configuration-block--配置区块">Configuration Block / 配置区块</h3> 
  <p>包含 system chain (ordering service) 或 channel 的Member和策略配置数据。对某个channel或整个网络的任何修改（比如，Member离开或加入）都将导致一个新的Configuration Block追加到适当的chain中。这个Configuration Block会包含 genesis block的内容加上增量。</p> 
  <h3 id="consensus--共识">Consensus / 共识</h3> 
  <p>Consensus是贯穿整个交易流程的广义术语，其用于产生对于order的共识和确认构成block的所有交易的正确性。</p> 
  <h3 id="current-state--当前状态">Current State / 当前状态</h3> 
  <p>ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。</p> 
  <h3 id="dynamic-membership--动态成员">Dynamic Membership / 动态成员</h3> 
  <p>Fabric支持动态添加/移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加/移除实体时，Dynamic Membership至关重要。</p> 
  <h3 id="endorsement--背书">Endorsement / 背书</h3> 
  <p>Endorsement 是指一个peer执行一个交易并返回YES/NO给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。</p> 
  <h3 id="endorsement-policy--背书策略">Endorsement policy / 背书策略</h3> 
  <p>Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。</p> 
  <h3 id="fabric-ca">Fabric-ca</h3> 
  <p>Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。</p> 
  <h3 id="genesis-block--初始区块">Genesis Block / 初始区块</h3> 
  <p>Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。</p> 
  <h3 id="gossip-protocol--gossip协议">Gossip Protocol / Gossip协议</h3> 
  <p>Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。</p> 
  <h3 id="initialize--初始化">Initialize / 初始化</h3> 
  <p>一个初始化chaincode程序的方法。</p> 
  <h3 id="install--安装">Install / 安装</h3> 
  <p>将chaincode放到peer的文件系统的过程。<em>（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath/chaincodeName.chainVersion文件中）</em></p> 
  <h3 id="instantiate--实例化">Instantiate / 实例化</h3> 
  <p>启动chaincode容器的过程。<em>（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法）</em></p> 
  <h3 id="invoke--调用">Invoke / 调用</h3> 
  <p>用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。</p> 
  <h3 id="leading-peer--主导节点">Leading Peer / 主导节点</h3> 
  <p>每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。</p> 
  <h3 id="ledger--账本">Ledger / 账本</h3> 
  <p>Ledger是个channel的chain和由channel中每个peer维护的world state。<em>（这个解释有点怪）</em></p> 
  <h3 id="member--成员">Member / 成员</h3> 
  <p>拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。</p> 
  <h3 id="membership-service-provider--msp">Membership Service Provider / MSP</h3> 
  <p>MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。</p> 
  <h3 id="membership-services--成员服务">Membership Services / 成员服务</h3> 
  <p>成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。</p> 
  <p><code>fabric-ca</code>组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。</p> 
  <h3 id="ordering-service--排序服务或共识服务">Ordering Service / 排序服务或共识服务</h3> 
  <p>将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。</p> 
  <h3 id="peer--节点">Peer / 节点</h3> 
  <p>一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read/write操作。peer由Member拥有和维护。</p> 
  <h3 id="policy--策略">Policy / 策略</h3> 
  <p>有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络/通道管理策略。</p> 
  <h3 id="proposal--提案">Proposal / 提案</h3> 
  <p>一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。</p> 
  <h3 id="query--查询">Query / 查询</h3> 
  <p>对于current state中某个key的value的查询请求。</p> 
  <h3 id="software-development-kit--sdk">Software Development Kit / SDK</h3> 
  <p>SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。</p> 
  <h3 id="state-database--statedb">State Database / stateDB</h3> 
  <p>为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。</p> 
  <h3 id="system-chain--系统链">System Chain / 系统链</h3> 
  <p>包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。</p> 
  <p>系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。</p> 
  <h3 id="transaction--交易">Transaction / 交易</h3> 
  <p>Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read/write set；Instantiate是请求在peer上启动Chaincode容器。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/The_Reader/article/details/83792662,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/The_Reader/article/details/83792662,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
