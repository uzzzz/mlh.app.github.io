<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码–交易的产生（二）–创建交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码–交易的产生（二）–创建交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82493420 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 目录 CreateTransaction 1）计算总支出金额 2）nLockTime 3）交易的输入输出 4) 选择可用币 5）找零 6）dust output 7）vin &amp; sign 8）判断是否满足 9）参数读取 Createrawtransaction CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 注释部分，这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1）计算总支出金额 参数说明 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;}接收者数组 CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易，比如为啥发送 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired=0 int&amp; nChangePosRet 改变标志位？=-1 std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能=NULL bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值-1 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//累加每个接收者的金额 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++;//如果要从交易金额中减去交易费，则计数增加 } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，我之前写到过 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping. For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 以下解说引用自《精通比特币（第二版）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）交易的输入输出 先来介绍用到的函数AvailableCoins,就是找到可用utxo void CWallet::AvailableCoins(vector&lt;COutput&gt;&amp; vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const { vCoins.clear();//清空数组 { LOCK2(cs_main, cs_wallet); //std::map&lt;uint256, CWalletTx&gt; mapWallet; CWallet的类内成员，保存和钱包有关的交易 for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const uint256&amp; wtxid = it-&gt;first; const CWalletTx* pcoin = &amp;(*it).second; if (!CheckFinalTx(*pcoin)) continue; if (fOnlyConfirmed &amp;&amp; !pcoin-&gt;IsTrusted()) continue; if (pcoin-&gt;IsCoinBase() &amp;&amp; pcoin-&gt;GetBlocksToMaturity() &gt; 0) continue; int nDepth = pcoin-&gt;GetDepthInMainChain(); if (nDepth &lt; 0) continue; // We should not consider coins which aren&#39;t at least in our mempool // It&#39;s possible for these to be conflicted via ancestors which we may never be able to detect if (nDepth == 0 &amp;&amp; !pcoin-&gt;InMempool()) continue; for (unsigned int i = 0; i &lt; pcoin-&gt;vout.size(); i++) { isminetype mine = IsMine(pcoin-&gt;vout[i]);//isminetype是枚举类型 //未被花费，可以被我花费，未被锁定的交易， ISMINE_NO =0 if (!(IsSpent(wtxid, i)) &amp;&amp; mine != ISMINE_NO &amp;&amp; !IsLockedCoin((*it).first, i) &amp;&amp; (pcoin-&gt;vout[i].nValue &gt; 0 || fIncludeZeroValue) &amp;&amp; (!coinControl || !coinControl-&gt;HasSelected() || coinControl-&gt;fAllowOtherInputs || coinControl-&gt;IsSelected(COutPoint((*it).first, i)))) vCoins.push_back(COutput(pcoin, i, nDepth, ((mine &amp; ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl &amp;&amp; coinControl-&gt;fAllowWatchOnly &amp;&amp; (mine &amp; ISMINE_WATCH_SOLVABLE) != ISMINE_NO), (mine &amp; (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO)); } } } } 这里开始的while循环很长 { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins;//可用的交易输出，就是这笔交易的输入 //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0;//交易费是从0开始 // Start with no fee and loop until there is enough fee循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest;//-1 txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true;//第一轮循环 CAmount nValueToSelect = nValue;//需要选择的金额，初始为之前统计的所有接受者的金额 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet;//加上交易费，初始为0 double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); //如果设置从交易金额中减去交易费，那么需要分摊到每个设置的接收者，减去平均交易费 if (recipient.fSubtractFeeFromAmount） { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者，还需要支出不能被整除的需要的交易费的剩余部分 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分，压入数组底部 } 4) 选择可用币 // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue;//金额 //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级，优先级为币龄*金额 } 可以来看一下SelectCoins，CCoinControl的值一直为null，看代码的时候可以忽略大部分内容,那么可以看到主要是调用了SelectCoinsMinConf这个函数 bool CWallet::SelectCoins(const vector&lt;COutput&gt;&amp; vAvailableCoins, const CAmount&amp; nTargetValue, set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt;&amp; setCoinsRet, CAmount&amp; nValueRet, const CCoinControl* coinControl) const { vector&lt;COutput&gt; vCoins(vAvailableCoins); // calculate value from preset inputs and store them从预设输入计算金额 set&lt;pair&lt;const CWalletTx*, uint32_t&gt; &gt; setPresetCoins; CAmount nValueFromPresetInputs = 0; size_t nMaxChainLength = std::min(GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT), GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT)); bool fRejectLongChains = GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS); bool res = nTargetValue &lt;= nValueFromPresetInputs || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, 0, vCoins, setCoinsRet, nValueRet) || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, 0, vCoins, setCoinsRet, nValueRet) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, 2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::min((size_t)4, nMaxChainLength/3), vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength/2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; !fRejectLongChains &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::numeric_limits&lt;uint64_t&gt;::max(), vCoins, setCoinsRet, nValueRet)); // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end()); // add preset inputs to the total value selected nValueRet += nValueFromPresetInputs; return res; } SelectCoinsMinConf这个函数的注释 随机排列并选择硬币，直到达到nTargetValue，同时避免小的找零; 该方法对于某些输入是随机的，并且在完成时组装硬币组和相应的实际目标值 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address 找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control的话默认没有设置）那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是在不重复使用之前的密钥的情况下，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey);//获取一个公钥 if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID());//找零脚本 } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数（只是一个初始的对象） bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1)//初始的时候被设置为-1 { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素，所以说是获取最老的密钥 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中这一句我写的是有点问题的 这里纠正一下，TopUpKeyPool()在填充密钥池的时候也是用到GenerateNewKey()这个函数来生成新的密钥对，生成的密钥对调用AddKeyPubKey函数里面的CWalletDB(strWalletFile).WriteKey（）把私钥公钥哈希值都写入数据库，键值为(“keymeta&quot;,vchPubKey)和（（“key”,vchPubKey),(vchPrivKey,hash值），false) 然后TopUpKeyPool()的话会再把公钥写入数据库键值对((“pool”,n),keypool),keypool只保存时间和公钥 TopUpKeyPool(); //DEFAULT_KEYPOOL_SIZE=100，填满池子到有100把密钥，nIndex保存在setKeyPool， /** walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey()) 密钥写入berkerly database数据库键值对((“pool&quot;,nEne),(ntime,pubkey)) */ 也就是说创建后的密钥公钥写入数据库，保存为ckeypool,创建时的索引保存在setKeyPool这个集合中，新建时以最后一个索引的值递增，也就是用掉1之后，不会再生成索引1，而是101 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF，使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output 灰尘交易 // Never create dust outputs; if we would, just add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及交易的输入vin的序列号的相关背景 // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入数组中。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名,写在另一篇中 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断是否满足 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); //默认coinControl为空，这段逻辑跳过，以后懂了再说 if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded)//直到有足够的费用 break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded;// continue; } } } 到这里是循环结束，满足条件则跳出循环，否则再次循环或报错 这里来关注下GetMinimumFee的实现，用来计算最小交易费用，和交易的字节相关，但是交易的字节是在交易构造后才能计算，所以用nFeeRet保存预估费用，在此基础上构建新的交易，如果得到的真实交易费小于预估，则需要要替换交易费，再次构建。 CAmount CWallet::GetRequiredFee(unsigned int nTxBytes) { ////! -mintxfee default //static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000; //CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE); return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes)); //static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; //CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); } CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool&amp; pool) { // payTxFee is user-set &quot;I want to pay this much&quot; CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes); // User didn&#39;t set: use -txconfirmtarget to estimate... if (nFeeNeeded == 0) { int estimateFoundTarget = nConfirmTarget; nFeeNeeded = pool.estimateSmartFee(nConfirmTarget, &amp;estimateFoundTarget).GetFee(nTxBytes); // ... unless we don&#39;t have enough mempool data for estimatefee, then use fallbackFee if (nFeeNeeded == 0)//没有足够的信息计算，那么使用这个费用 nFeeNeeded = fallbackFee.GetFee(nTxBytes); ////! -fallbackfee default //static const CAmount DEFAULT_FALLBACK_FEE = 20,000; //CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE); } // prevent user from paying a fee below minRelayTxFee or minTxFee //阻止用户支付低于minRelayTxFee或minTxFee的费用 nFeeNeeded = std::max(nFeeNeeded, GetRequiredFee(nTxBytes)); // But always obey the maximum if (nFeeNeeded &gt; maxTxFee)//大于最大费用 nFeeNeeded = maxTxFee; return nFeeNeeded; } payTxfee是类CFeeRate的对象，全局变量，表示每千字节的费用,初始化0 /** * Fee rate in satoshis per kilobyte: CAmount / kB */ 首先调用该类的成员函数GetFee（）,计算字节对应的费用，用到的nSatoshisPerK是CFeeRate的私有成员变量 CAmount CFeeRate::GetFee(size_t nBytes_) const { assert(nBytes_ &lt;= uint64_t(std::numeric_limits&lt;int64_t&gt;::max())); int64_t nSize = int64_t(nBytes_); CAmount nFee = nSatoshisPerK * nSize / 1000; if (nFee == 0 &amp;&amp; nSize != 0) { if (nSatoshisPerK &gt; 0) nFee = CAmount(1); if (nSatoshisPerK &lt; 0) nFee = CAmount(-1); } return nFee; } 可以看到，按默认值计算得到的nFeeNeeded就是0，所以有第二段，针对nFeeNeeded==0的操作语句，注释也表明用户没有设置-txconfirmtarget参数来估算会这样 //wallet.cpp /** Transaction fee set by the user */ CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);//0 unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;//2 用到的nTxConfirmTarget是默认设置为2 satoshis/kb,变量pool是传入的参数，类CTxMemPool，调用函数estimateSmartFee这个函数展开又比较大了 大致看了下，里面调用EstimateMedianVal，会统计在这个目标金额下确认的交易数，总交易数和未确认的交易数，统计平均最佳值，然后返回。大概是这个意思，等我想看了再写 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易 附：支付给自己 mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw是我的比特币地址 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot; 0.03 ae1d05e0443736379b0184c3c1b9017ed074f232ae8def8fd208848538cb8904 我给自己转了0.03，以及一大笔交易费 如果sendmany里面写两次同一个地址，报重复地址的错误，这个限制是接口里面设置的，因为是用set集合来保存的地址，最后构造成接收者存入vector数组中的，createtransaction函数内部是没有地址重复限制的。 Createrawtransaction 这种创建的方式更加自由，不过需要注意金额的填写，这里没有默认找零，差额全部支付给矿工 parallels@parallels-vm:~$ bitcoin-cli listaddressgroupings [ [ [ &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, 0.00044634 ], [ &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, 0.00000000 ], [ &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, 0.02467234, &quot;my&quot; ] ] ] parallels@parallels-vm:~$ bitcoin-cli encryptwallet a123456 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, &quot;account&quot;: &quot;my&quot;, &quot;scriptPubKey&quot;: &quot;76a914b3963733828c665a987a12e9c4eb04868ec4511188ac&quot;, &quot;amount&quot;: 0.02467234, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 2, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 创建一笔交易，把地址mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw的0.02467234转到两个地址，给mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT分配0.024，给mi6E46piWPryxA9J7K58J4hswL9815fAPa分配0.00066，余下的0.00001234作为手续费奖励给矿工 parallels@parallels-vm:~$ bitcoin-cli createrawtransaction &#39;[{&quot;txid&quot;:&quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;,&quot;vout&quot;:1}]&#39; &#39;{&quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;:0.024,&quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;:0.00066}&#39; 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 然后打开钱包准备转账 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase a123456 1200 对交易签名 parallels@parallels-vm:~$ bitcoin-cli signrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 { &quot;hex&quot;: &quot;0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000&quot;, &quot;complete&quot;: true } 然后发送交易 parallels@parallels-vm:~$ bitcoin-cli sendrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44 过段时间后我们来看我们的余额，10分钟左右吧，6个区块确认 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.02400000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00066000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21883, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 22, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 可以看到去掉支出的那一笔，新增两笔支出 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82493420 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 目录 CreateTransaction 1）计算总支出金额 2）nLockTime 3）交易的输入输出 4) 选择可用币 5）找零 6）dust output 7）vin &amp; sign 8）判断是否满足 9）参数读取 Createrawtransaction CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 注释部分，这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1）计算总支出金额 参数说明 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;}接收者数组 CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易，比如为啥发送 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired=0 int&amp; nChangePosRet 改变标志位？=-1 std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能=NULL bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值-1 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//累加每个接收者的金额 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++;//如果要从交易金额中减去交易费，则计数增加 } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，我之前写到过 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping. For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 以下解说引用自《精通比特币（第二版）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）交易的输入输出 先来介绍用到的函数AvailableCoins,就是找到可用utxo void CWallet::AvailableCoins(vector&lt;COutput&gt;&amp; vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const { vCoins.clear();//清空数组 { LOCK2(cs_main, cs_wallet); //std::map&lt;uint256, CWalletTx&gt; mapWallet; CWallet的类内成员，保存和钱包有关的交易 for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const uint256&amp; wtxid = it-&gt;first; const CWalletTx* pcoin = &amp;(*it).second; if (!CheckFinalTx(*pcoin)) continue; if (fOnlyConfirmed &amp;&amp; !pcoin-&gt;IsTrusted()) continue; if (pcoin-&gt;IsCoinBase() &amp;&amp; pcoin-&gt;GetBlocksToMaturity() &gt; 0) continue; int nDepth = pcoin-&gt;GetDepthInMainChain(); if (nDepth &lt; 0) continue; // We should not consider coins which aren&#39;t at least in our mempool // It&#39;s possible for these to be conflicted via ancestors which we may never be able to detect if (nDepth == 0 &amp;&amp; !pcoin-&gt;InMempool()) continue; for (unsigned int i = 0; i &lt; pcoin-&gt;vout.size(); i++) { isminetype mine = IsMine(pcoin-&gt;vout[i]);//isminetype是枚举类型 //未被花费，可以被我花费，未被锁定的交易， ISMINE_NO =0 if (!(IsSpent(wtxid, i)) &amp;&amp; mine != ISMINE_NO &amp;&amp; !IsLockedCoin((*it).first, i) &amp;&amp; (pcoin-&gt;vout[i].nValue &gt; 0 || fIncludeZeroValue) &amp;&amp; (!coinControl || !coinControl-&gt;HasSelected() || coinControl-&gt;fAllowOtherInputs || coinControl-&gt;IsSelected(COutPoint((*it).first, i)))) vCoins.push_back(COutput(pcoin, i, nDepth, ((mine &amp; ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl &amp;&amp; coinControl-&gt;fAllowWatchOnly &amp;&amp; (mine &amp; ISMINE_WATCH_SOLVABLE) != ISMINE_NO), (mine &amp; (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO)); } } } } 这里开始的while循环很长 { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins;//可用的交易输出，就是这笔交易的输入 //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0;//交易费是从0开始 // Start with no fee and loop until there is enough fee循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest;//-1 txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true;//第一轮循环 CAmount nValueToSelect = nValue;//需要选择的金额，初始为之前统计的所有接受者的金额 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet;//加上交易费，初始为0 double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); //如果设置从交易金额中减去交易费，那么需要分摊到每个设置的接收者，减去平均交易费 if (recipient.fSubtractFeeFromAmount） { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者，还需要支出不能被整除的需要的交易费的剩余部分 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分，压入数组底部 } 4) 选择可用币 // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue;//金额 //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级，优先级为币龄*金额 } 可以来看一下SelectCoins，CCoinControl的值一直为null，看代码的时候可以忽略大部分内容,那么可以看到主要是调用了SelectCoinsMinConf这个函数 bool CWallet::SelectCoins(const vector&lt;COutput&gt;&amp; vAvailableCoins, const CAmount&amp; nTargetValue, set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt;&amp; setCoinsRet, CAmount&amp; nValueRet, const CCoinControl* coinControl) const { vector&lt;COutput&gt; vCoins(vAvailableCoins); // calculate value from preset inputs and store them从预设输入计算金额 set&lt;pair&lt;const CWalletTx*, uint32_t&gt; &gt; setPresetCoins; CAmount nValueFromPresetInputs = 0; size_t nMaxChainLength = std::min(GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT), GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT)); bool fRejectLongChains = GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS); bool res = nTargetValue &lt;= nValueFromPresetInputs || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, 0, vCoins, setCoinsRet, nValueRet) || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, 0, vCoins, setCoinsRet, nValueRet) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, 2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::min((size_t)4, nMaxChainLength/3), vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength/2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; !fRejectLongChains &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::numeric_limits&lt;uint64_t&gt;::max(), vCoins, setCoinsRet, nValueRet)); // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end()); // add preset inputs to the total value selected nValueRet += nValueFromPresetInputs; return res; } SelectCoinsMinConf这个函数的注释 随机排列并选择硬币，直到达到nTargetValue，同时避免小的找零; 该方法对于某些输入是随机的，并且在完成时组装硬币组和相应的实际目标值 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address 找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control的话默认没有设置）那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是在不重复使用之前的密钥的情况下，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey);//获取一个公钥 if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID());//找零脚本 } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数（只是一个初始的对象） bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1)//初始的时候被设置为-1 { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素，所以说是获取最老的密钥 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中这一句我写的是有点问题的 这里纠正一下，TopUpKeyPool()在填充密钥池的时候也是用到GenerateNewKey()这个函数来生成新的密钥对，生成的密钥对调用AddKeyPubKey函数里面的CWalletDB(strWalletFile).WriteKey（）把私钥公钥哈希值都写入数据库，键值为(“keymeta&quot;,vchPubKey)和（（“key”,vchPubKey),(vchPrivKey,hash值），false) 然后TopUpKeyPool()的话会再把公钥写入数据库键值对((“pool”,n),keypool),keypool只保存时间和公钥 TopUpKeyPool(); //DEFAULT_KEYPOOL_SIZE=100，填满池子到有100把密钥，nIndex保存在setKeyPool， /** walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey()) 密钥写入berkerly database数据库键值对((“pool&quot;,nEne),(ntime,pubkey)) */ 也就是说创建后的密钥公钥写入数据库，保存为ckeypool,创建时的索引保存在setKeyPool这个集合中，新建时以最后一个索引的值递增，也就是用掉1之后，不会再生成索引1，而是101 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF，使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output 灰尘交易 // Never create dust outputs; if we would, just add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及交易的输入vin的序列号的相关背景 // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入数组中。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名,写在另一篇中 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断是否满足 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); //默认coinControl为空，这段逻辑跳过，以后懂了再说 if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded)//直到有足够的费用 break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded;// continue; } } } 到这里是循环结束，满足条件则跳出循环，否则再次循环或报错 这里来关注下GetMinimumFee的实现，用来计算最小交易费用，和交易的字节相关，但是交易的字节是在交易构造后才能计算，所以用nFeeRet保存预估费用，在此基础上构建新的交易，如果得到的真实交易费小于预估，则需要要替换交易费，再次构建。 CAmount CWallet::GetRequiredFee(unsigned int nTxBytes) { ////! -mintxfee default //static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000; //CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE); return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes)); //static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; //CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); } CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool&amp; pool) { // payTxFee is user-set &quot;I want to pay this much&quot; CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes); // User didn&#39;t set: use -txconfirmtarget to estimate... if (nFeeNeeded == 0) { int estimateFoundTarget = nConfirmTarget; nFeeNeeded = pool.estimateSmartFee(nConfirmTarget, &amp;estimateFoundTarget).GetFee(nTxBytes); // ... unless we don&#39;t have enough mempool data for estimatefee, then use fallbackFee if (nFeeNeeded == 0)//没有足够的信息计算，那么使用这个费用 nFeeNeeded = fallbackFee.GetFee(nTxBytes); ////! -fallbackfee default //static const CAmount DEFAULT_FALLBACK_FEE = 20,000; //CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE); } // prevent user from paying a fee below minRelayTxFee or minTxFee //阻止用户支付低于minRelayTxFee或minTxFee的费用 nFeeNeeded = std::max(nFeeNeeded, GetRequiredFee(nTxBytes)); // But always obey the maximum if (nFeeNeeded &gt; maxTxFee)//大于最大费用 nFeeNeeded = maxTxFee; return nFeeNeeded; } payTxfee是类CFeeRate的对象，全局变量，表示每千字节的费用,初始化0 /** * Fee rate in satoshis per kilobyte: CAmount / kB */ 首先调用该类的成员函数GetFee（）,计算字节对应的费用，用到的nSatoshisPerK是CFeeRate的私有成员变量 CAmount CFeeRate::GetFee(size_t nBytes_) const { assert(nBytes_ &lt;= uint64_t(std::numeric_limits&lt;int64_t&gt;::max())); int64_t nSize = int64_t(nBytes_); CAmount nFee = nSatoshisPerK * nSize / 1000; if (nFee == 0 &amp;&amp; nSize != 0) { if (nSatoshisPerK &gt; 0) nFee = CAmount(1); if (nSatoshisPerK &lt; 0) nFee = CAmount(-1); } return nFee; } 可以看到，按默认值计算得到的nFeeNeeded就是0，所以有第二段，针对nFeeNeeded==0的操作语句，注释也表明用户没有设置-txconfirmtarget参数来估算会这样 //wallet.cpp /** Transaction fee set by the user */ CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);//0 unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;//2 用到的nTxConfirmTarget是默认设置为2 satoshis/kb,变量pool是传入的参数，类CTxMemPool，调用函数estimateSmartFee这个函数展开又比较大了 大致看了下，里面调用EstimateMedianVal，会统计在这个目标金额下确认的交易数，总交易数和未确认的交易数，统计平均最佳值，然后返回。大概是这个意思，等我想看了再写 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易 附：支付给自己 mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw是我的比特币地址 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot; 0.03 ae1d05e0443736379b0184c3c1b9017ed074f232ae8def8fd208848538cb8904 我给自己转了0.03，以及一大笔交易费 如果sendmany里面写两次同一个地址，报重复地址的错误，这个限制是接口里面设置的，因为是用set集合来保存的地址，最后构造成接收者存入vector数组中的，createtransaction函数内部是没有地址重复限制的。 Createrawtransaction 这种创建的方式更加自由，不过需要注意金额的填写，这里没有默认找零，差额全部支付给矿工 parallels@parallels-vm:~$ bitcoin-cli listaddressgroupings [ [ [ &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, 0.00044634 ], [ &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, 0.00000000 ], [ &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, 0.02467234, &quot;my&quot; ] ] ] parallels@parallels-vm:~$ bitcoin-cli encryptwallet a123456 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, &quot;account&quot;: &quot;my&quot;, &quot;scriptPubKey&quot;: &quot;76a914b3963733828c665a987a12e9c4eb04868ec4511188ac&quot;, &quot;amount&quot;: 0.02467234, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 2, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 创建一笔交易，把地址mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw的0.02467234转到两个地址，给mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT分配0.024，给mi6E46piWPryxA9J7K58J4hswL9815fAPa分配0.00066，余下的0.00001234作为手续费奖励给矿工 parallels@parallels-vm:~$ bitcoin-cli createrawtransaction &#39;[{&quot;txid&quot;:&quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;,&quot;vout&quot;:1}]&#39; &#39;{&quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;:0.024,&quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;:0.00066}&#39; 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 然后打开钱包准备转账 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase a123456 1200 对交易签名 parallels@parallels-vm:~$ bitcoin-cli signrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 { &quot;hex&quot;: &quot;0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000&quot;, &quot;complete&quot;: true } 然后发送交易 parallels@parallels-vm:~$ bitcoin-cli sendrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44 过段时间后我们来看我们的余额，10分钟左右吧，6个区块确认 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.02400000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00066000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21883, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 22, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 可以看到去掉支出的那一笔，新增两笔支出 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/07/97d3390401dabb1a8a910630eafba0fe.html" />
<meta property="og:url" content="https://mlh.app/2018/09/07/97d3390401dabb1a8a910630eafba0fe.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82493420 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 目录 CreateTransaction 1）计算总支出金额 2）nLockTime 3）交易的输入输出 4) 选择可用币 5）找零 6）dust output 7）vin &amp; sign 8）判断是否满足 9）参数读取 Createrawtransaction CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 注释部分，这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1）计算总支出金额 参数说明 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;}接收者数组 CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易，比如为啥发送 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired=0 int&amp; nChangePosRet 改变标志位？=-1 std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能=NULL bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值-1 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//累加每个接收者的金额 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++;//如果要从交易金额中减去交易费，则计数增加 } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，我之前写到过 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping. For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 以下解说引用自《精通比特币（第二版）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）交易的输入输出 先来介绍用到的函数AvailableCoins,就是找到可用utxo void CWallet::AvailableCoins(vector&lt;COutput&gt;&amp; vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const { vCoins.clear();//清空数组 { LOCK2(cs_main, cs_wallet); //std::map&lt;uint256, CWalletTx&gt; mapWallet; CWallet的类内成员，保存和钱包有关的交易 for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const uint256&amp; wtxid = it-&gt;first; const CWalletTx* pcoin = &amp;(*it).second; if (!CheckFinalTx(*pcoin)) continue; if (fOnlyConfirmed &amp;&amp; !pcoin-&gt;IsTrusted()) continue; if (pcoin-&gt;IsCoinBase() &amp;&amp; pcoin-&gt;GetBlocksToMaturity() &gt; 0) continue; int nDepth = pcoin-&gt;GetDepthInMainChain(); if (nDepth &lt; 0) continue; // We should not consider coins which aren&#39;t at least in our mempool // It&#39;s possible for these to be conflicted via ancestors which we may never be able to detect if (nDepth == 0 &amp;&amp; !pcoin-&gt;InMempool()) continue; for (unsigned int i = 0; i &lt; pcoin-&gt;vout.size(); i++) { isminetype mine = IsMine(pcoin-&gt;vout[i]);//isminetype是枚举类型 //未被花费，可以被我花费，未被锁定的交易， ISMINE_NO =0 if (!(IsSpent(wtxid, i)) &amp;&amp; mine != ISMINE_NO &amp;&amp; !IsLockedCoin((*it).first, i) &amp;&amp; (pcoin-&gt;vout[i].nValue &gt; 0 || fIncludeZeroValue) &amp;&amp; (!coinControl || !coinControl-&gt;HasSelected() || coinControl-&gt;fAllowOtherInputs || coinControl-&gt;IsSelected(COutPoint((*it).first, i)))) vCoins.push_back(COutput(pcoin, i, nDepth, ((mine &amp; ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl &amp;&amp; coinControl-&gt;fAllowWatchOnly &amp;&amp; (mine &amp; ISMINE_WATCH_SOLVABLE) != ISMINE_NO), (mine &amp; (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO)); } } } } 这里开始的while循环很长 { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins;//可用的交易输出，就是这笔交易的输入 //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0;//交易费是从0开始 // Start with no fee and loop until there is enough fee循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest;//-1 txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true;//第一轮循环 CAmount nValueToSelect = nValue;//需要选择的金额，初始为之前统计的所有接受者的金额 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet;//加上交易费，初始为0 double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); //如果设置从交易金额中减去交易费，那么需要分摊到每个设置的接收者，减去平均交易费 if (recipient.fSubtractFeeFromAmount） { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者，还需要支出不能被整除的需要的交易费的剩余部分 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分，压入数组底部 } 4) 选择可用币 // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue;//金额 //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级，优先级为币龄*金额 } 可以来看一下SelectCoins，CCoinControl的值一直为null，看代码的时候可以忽略大部分内容,那么可以看到主要是调用了SelectCoinsMinConf这个函数 bool CWallet::SelectCoins(const vector&lt;COutput&gt;&amp; vAvailableCoins, const CAmount&amp; nTargetValue, set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt;&amp; setCoinsRet, CAmount&amp; nValueRet, const CCoinControl* coinControl) const { vector&lt;COutput&gt; vCoins(vAvailableCoins); // calculate value from preset inputs and store them从预设输入计算金额 set&lt;pair&lt;const CWalletTx*, uint32_t&gt; &gt; setPresetCoins; CAmount nValueFromPresetInputs = 0; size_t nMaxChainLength = std::min(GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT), GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT)); bool fRejectLongChains = GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS); bool res = nTargetValue &lt;= nValueFromPresetInputs || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, 0, vCoins, setCoinsRet, nValueRet) || SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, 0, vCoins, setCoinsRet, nValueRet) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, 2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::min((size_t)4, nMaxChainLength/3), vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength/2, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength, vCoins, setCoinsRet, nValueRet)) || (bSpendZeroConfChange &amp;&amp; !fRejectLongChains &amp;&amp; SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::numeric_limits&lt;uint64_t&gt;::max(), vCoins, setCoinsRet, nValueRet)); // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end()); // add preset inputs to the total value selected nValueRet += nValueFromPresetInputs; return res; } SelectCoinsMinConf这个函数的注释 随机排列并选择硬币，直到达到nTargetValue，同时避免小的找零; 该方法对于某些输入是随机的，并且在完成时组装硬币组和相应的实际目标值 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address 找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control的话默认没有设置）那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是在不重复使用之前的密钥的情况下，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey);//获取一个公钥 if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID());//找零脚本 } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数（只是一个初始的对象） bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1)//初始的时候被设置为-1 { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素，所以说是获取最老的密钥 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中这一句我写的是有点问题的 这里纠正一下，TopUpKeyPool()在填充密钥池的时候也是用到GenerateNewKey()这个函数来生成新的密钥对，生成的密钥对调用AddKeyPubKey函数里面的CWalletDB(strWalletFile).WriteKey（）把私钥公钥哈希值都写入数据库，键值为(“keymeta&quot;,vchPubKey)和（（“key”,vchPubKey),(vchPrivKey,hash值），false) 然后TopUpKeyPool()的话会再把公钥写入数据库键值对((“pool”,n),keypool),keypool只保存时间和公钥 TopUpKeyPool(); //DEFAULT_KEYPOOL_SIZE=100，填满池子到有100把密钥，nIndex保存在setKeyPool， /** walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey()) 密钥写入berkerly database数据库键值对((“pool&quot;,nEne),(ntime,pubkey)) */ 也就是说创建后的密钥公钥写入数据库，保存为ckeypool,创建时的索引保存在setKeyPool这个集合中，新建时以最后一个索引的值递增，也就是用掉1之后，不会再生成索引1，而是101 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF，使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output 灰尘交易 // Never create dust outputs; if we would, just add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及交易的输入vin的序列号的相关背景 // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入数组中。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名,写在另一篇中 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断是否满足 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); //默认coinControl为空，这段逻辑跳过，以后懂了再说 if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded)//直到有足够的费用 break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded;// continue; } } } 到这里是循环结束，满足条件则跳出循环，否则再次循环或报错 这里来关注下GetMinimumFee的实现，用来计算最小交易费用，和交易的字节相关，但是交易的字节是在交易构造后才能计算，所以用nFeeRet保存预估费用，在此基础上构建新的交易，如果得到的真实交易费小于预估，则需要要替换交易费，再次构建。 CAmount CWallet::GetRequiredFee(unsigned int nTxBytes) { ////! -mintxfee default //static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000; //CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE); return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes)); //static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; //CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); } CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool&amp; pool) { // payTxFee is user-set &quot;I want to pay this much&quot; CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes); // User didn&#39;t set: use -txconfirmtarget to estimate... if (nFeeNeeded == 0) { int estimateFoundTarget = nConfirmTarget; nFeeNeeded = pool.estimateSmartFee(nConfirmTarget, &amp;estimateFoundTarget).GetFee(nTxBytes); // ... unless we don&#39;t have enough mempool data for estimatefee, then use fallbackFee if (nFeeNeeded == 0)//没有足够的信息计算，那么使用这个费用 nFeeNeeded = fallbackFee.GetFee(nTxBytes); ////! -fallbackfee default //static const CAmount DEFAULT_FALLBACK_FEE = 20,000; //CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE); } // prevent user from paying a fee below minRelayTxFee or minTxFee //阻止用户支付低于minRelayTxFee或minTxFee的费用 nFeeNeeded = std::max(nFeeNeeded, GetRequiredFee(nTxBytes)); // But always obey the maximum if (nFeeNeeded &gt; maxTxFee)//大于最大费用 nFeeNeeded = maxTxFee; return nFeeNeeded; } payTxfee是类CFeeRate的对象，全局变量，表示每千字节的费用,初始化0 /** * Fee rate in satoshis per kilobyte: CAmount / kB */ 首先调用该类的成员函数GetFee（）,计算字节对应的费用，用到的nSatoshisPerK是CFeeRate的私有成员变量 CAmount CFeeRate::GetFee(size_t nBytes_) const { assert(nBytes_ &lt;= uint64_t(std::numeric_limits&lt;int64_t&gt;::max())); int64_t nSize = int64_t(nBytes_); CAmount nFee = nSatoshisPerK * nSize / 1000; if (nFee == 0 &amp;&amp; nSize != 0) { if (nSatoshisPerK &gt; 0) nFee = CAmount(1); if (nSatoshisPerK &lt; 0) nFee = CAmount(-1); } return nFee; } 可以看到，按默认值计算得到的nFeeNeeded就是0，所以有第二段，针对nFeeNeeded==0的操作语句，注释也表明用户没有设置-txconfirmtarget参数来估算会这样 //wallet.cpp /** Transaction fee set by the user */ CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);//0 unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;//2 用到的nTxConfirmTarget是默认设置为2 satoshis/kb,变量pool是传入的参数，类CTxMemPool，调用函数estimateSmartFee这个函数展开又比较大了 大致看了下，里面调用EstimateMedianVal，会统计在这个目标金额下确认的交易数，总交易数和未确认的交易数，统计平均最佳值，然后返回。大概是这个意思，等我想看了再写 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易 附：支付给自己 mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw是我的比特币地址 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot; 0.03 ae1d05e0443736379b0184c3c1b9017ed074f232ae8def8fd208848538cb8904 我给自己转了0.03，以及一大笔交易费 如果sendmany里面写两次同一个地址，报重复地址的错误，这个限制是接口里面设置的，因为是用set集合来保存的地址，最后构造成接收者存入vector数组中的，createtransaction函数内部是没有地址重复限制的。 Createrawtransaction 这种创建的方式更加自由，不过需要注意金额的填写，这里没有默认找零，差额全部支付给矿工 parallels@parallels-vm:~$ bitcoin-cli listaddressgroupings [ [ [ &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, 0.00044634 ], [ &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, 0.00000000 ], [ &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, 0.02467234, &quot;my&quot; ] ] ] parallels@parallels-vm:~$ bitcoin-cli encryptwallet a123456 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw&quot;, &quot;account&quot;: &quot;my&quot;, &quot;scriptPubKey&quot;: &quot;76a914b3963733828c665a987a12e9c4eb04868ec4511188ac&quot;, &quot;amount&quot;: 0.02467234, &quot;confirmations&quot;: 21863, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 2, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 创建一笔交易，把地址mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw的0.02467234转到两个地址，给mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT分配0.024，给mi6E46piWPryxA9J7K58J4hswL9815fAPa分配0.00066，余下的0.00001234作为手续费奖励给矿工 parallels@parallels-vm:~$ bitcoin-cli createrawtransaction &#39;[{&quot;txid&quot;:&quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;,&quot;vout&quot;:1}]&#39; &#39;{&quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;:0.024,&quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;:0.00066}&#39; 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 然后打开钱包准备转账 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase a123456 1200 对交易签名 parallels@parallels-vm:~$ bitcoin-cli signrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 { &quot;hex&quot;: &quot;0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000&quot;, &quot;complete&quot;: true } 然后发送交易 parallels@parallels-vm:~$ bitcoin-cli sendrawtransaction 0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000 1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44 过段时间后我们来看我们的余额，10分钟左右吧，6个区块确认 parallels@parallels-vm:~$ bitcoin-cli listunspent [ { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.02400000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00066000, &quot;confirmations&quot;: 7, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4&quot;, &quot;vout&quot;: 0, &quot;address&quot;: &quot;mi6E46piWPryxA9J7K58J4hswL9815fAPa&quot;, &quot;scriptPubKey&quot;: &quot;76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac&quot;, &quot;amount&quot;: 0.00044634, &quot;confirmations&quot;: 21883, &quot;spendable&quot;: true, &quot;solvable&quot;: true }, { &quot;txid&quot;: &quot;50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff&quot;, &quot;vout&quot;: 1, &quot;address&quot;: &quot;mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT&quot;, &quot;scriptPubKey&quot;: &quot;76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac&quot;, &quot;amount&quot;: 0.07400000, &quot;confirmations&quot;: 22, &quot;spendable&quot;: true, &quot;solvable&quot;: true } ] 可以看到去掉支出的那一笔，新增两笔支出 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/07/97d3390401dabb1a8a910630eafba0fe.html","headline":"比特币源码–交易的产生（二）–创建交易","dateModified":"2018-09-07T00:00:00+08:00","datePublished":"2018-09-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/07/97d3390401dabb1a8a910630eafba0fe.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码--交易的产生（二）--创建交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82493420 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81906838" rel="nofollow">交易的产生（一）–生成地址</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">交易的产生（二）–创建交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82351978" rel="nofollow">交易的产生（三）–承诺交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82866757" rel="nofollow">交易的产生（四）–脚本和签名</a></p> 
  <hr> 
  <p></p>
  <div class="toc">
   <h3>目录</h3>
   <ul>
    <ul>
     <li><a href="#CreateTransaction_8" rel="nofollow">CreateTransaction</a></li>
     <ul>
      <li><a href="#1_17" rel="nofollow">1）计算总支出金额</a></li>
      <li><a href="#2nLockTime_58" rel="nofollow">2）nLockTime</a></li>
      <li><a href="#3_88" rel="nofollow">3）交易的输入输出</a></li>
      <li><a href="#4__199" rel="nofollow">4) 选择可用币</a></li>
      <li><a href="#5_262" rel="nofollow">5）找零</a></li>
      <li><a href="#6dust_output_391" rel="nofollow">6）dust output</a></li>
      <li><a href="#7vin__sign_423" rel="nofollow">7）vin &amp; sign</a></li>
      <li><a href="#8_472" rel="nofollow">8）判断是否满足</a></li>
      <li><a href="#9_608" rel="nofollow">9）参数读取</a></li>
     </ul>
     <li><a href="#Createrawtransaction_641" rel="nofollow">Createrawtransaction</a></li>
    </ul>
   </ul>
  </div>
  <p></p> 
  <h2><a id="CreateTransaction_8"></a>CreateTransaction</h2> 
  <blockquote> 
   <p>/**<br> * Create a new transaction paying the recipients with a set of coins<br> * selected by SelectCoins(); Also create the change output, when needed<br> * @note passing nChangePosInOut as -1 will result in setting a random position<br> */</p> 
  </blockquote> 
  <p>注释部分，这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额<br> 鉴于这段代码很长，分段来讲</p> 
  <h3><a id="1_17"></a>1）计算总支出金额</h3> 
  <p>参数说明</p> 
  <table> 
   <thead> 
    <tr> 
     <th>类型</th> 
     <th align="left">名称</th> 
     <th align="left">说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>vector<code>&lt;CRecipient&gt;</code></td> 
     <td align="left">vecSend</td> 
     <td align="left">struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;}接收者数组</td> 
    </tr> 
    <tr> 
     <td>CWalletTx&amp;</td> 
     <td align="left">wtxNew</td> 
     <td align="left">包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易，比如为啥发送</td> 
    </tr> 
    <tr> 
     <td>CReserveKey&amp;</td> 
     <td align="left">reservekey</td> 
     <td align="left">密钥池分配的密钥</td> 
    </tr> 
    <tr> 
     <td>CAmount&amp;</td> 
     <td align="left">nFeeRet</td> 
     <td align="left">CAmount nFeeRequired=0</td> 
    </tr> 
    <tr> 
     <td>int&amp;</td> 
     <td align="left">nChangePosRet</td> 
     <td align="left">改变标志位？=-1</td> 
    </tr> 
    <tr> 
     <td>std::string&amp;</td> 
     <td align="left">strFailReason</td> 
     <td align="left">失败的原因</td> 
    </tr> 
    <tr> 
     <td>CCoinControl*</td> 
     <td align="left">coinControl</td> 
     <td align="left">币控制功能=NULL</td> 
    </tr> 
    <tr> 
     <td>bool</td> 
     <td align="left">sign</td> 
     <td align="left">默认为true</td> 
    </tr> 
   </tbody> 
  </table>
  <pre><code class="prism language-c">bool CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">CreateTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>CRecipient<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vecSend<span class="token punctuation">,</span> CWalletTx<span class="token operator">&amp;</span> wtxNew<span class="token punctuation">,</span> CReserveKey<span class="token operator">&amp;</span> reservekey<span class="token punctuation">,</span> CAmount<span class="token operator">&amp;</span> nFeeRet<span class="token punctuation">,</span>
                                <span class="token keyword">int</span><span class="token operator">&amp;</span> nChangePosInOut<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> strFailReason<span class="token punctuation">,</span> <span class="token keyword">const</span> CCoinControl<span class="token operator">*</span> coinControl<span class="token punctuation">,</span> bool sign<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CAmount nValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化为0</span>
    <span class="token keyword">int</span> nChangePosRequest <span class="token operator">=</span> nChangePosInOut<span class="token punctuation">;</span><span class="token comment">//赋值-1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nSubtractFeeFromAmount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    BOOST_FOREACH <span class="token punctuation">(</span><span class="token keyword">const</span> CRecipient<span class="token operator">&amp;</span> recipient<span class="token punctuation">,</span> vecSend<span class="token punctuation">)</span><span class="token comment">//解析接收者的信息</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nValue <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> recipient<span class="token punctuation">.</span>nAmount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span><span class="token comment">//交易金额不能为负</span>
            strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction amounts must be positive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        nValue <span class="token operator">+</span><span class="token operator">=</span> recipient<span class="token punctuation">.</span>nAmount<span class="token punctuation">;</span><span class="token comment">//累加每个接收者的金额</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>recipient<span class="token punctuation">.</span>fSubtractFeeFromAmount<span class="token punctuation">)</span>
            nSubtractFeeFromAmount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//如果要从交易金额中减去交易费，则计数增加</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vecSend<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> nValue <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction amounts must be positive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    wtxNew<span class="token punctuation">.</span>fTimeReceivedIsTxTime <span class="token operator">=</span> true<span class="token punctuation">;</span>
    wtxNew<span class="token punctuation">.</span><span class="token function">BindWallet</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绑定钱包</span>
    CMutableTransaction txNew<span class="token punctuation">;</span><span class="token comment">//A mutable version of CTransaction.</span>
</code></pre> 
  <h3><a id="2nLockTime_58"></a>2）nLockTime</h3> 
  <p>nLockTime是交易类的成员变量，我之前写到过<br> <a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction</a><br> 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。<br> 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。</p> 
  <blockquote> 
   <p>Discourage fee sniping.<br> For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack.<br> A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain.<br> Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later.</p> 
  </blockquote> 
  <p>以下解说引用自《精通比特币（第二版）》</p> 
  <blockquote> 
   <p><mark>费用狙击</mark>是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。<br> 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。<br> 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。<br> 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。</p> 
  </blockquote> 
  <pre><code class="prism language-c">txNew<span class="token punctuation">.</span>nLockTime <span class="token operator">=</span> chainActive<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前有效区块的高度</span>
</code></pre> 
  <blockquote> 
   <p>Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy.<br> 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。</p> 
  </blockquote> 
  <pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetRandInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        txNew<span class="token punctuation">.</span>nLockTime <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>txNew<span class="token punctuation">.</span>nLockTime <span class="token operator">-</span> <span class="token function">GetRandInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert</span><span class="token punctuation">(</span>txNew<span class="token punctuation">.</span>nLockTime <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>chainActive<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>txNew<span class="token punctuation">.</span>nLockTime <span class="token operator">&lt;</span> LOCKTIME_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <h3><a id="3_88"></a>3）交易的输入输出</h3> 
  <p>先来介绍用到的函数AvailableCoins,就是找到可用utxo</p> 
  <pre><code class="prism language-c"><span class="token keyword">void</span> CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AvailableCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>COutput<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vCoins<span class="token punctuation">,</span> bool fOnlyConfirmed<span class="token punctuation">,</span> <span class="token keyword">const</span> CCoinControl <span class="token operator">*</span>coinControl<span class="token punctuation">,</span> bool fIncludeZeroValue<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    vCoins<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清空数组</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK2</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">,</span> cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//std::map&lt;uint256, CWalletTx&gt; mapWallet; CWallet的类内成员，保存和钱包有关的交易</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>map<span class="token operator">&lt;</span>uint256<span class="token punctuation">,</span> CWalletTx<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>const_iterator it <span class="token operator">=</span> mapWallet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> mapWallet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> wtxid <span class="token operator">=</span> it<span class="token operator">-&gt;</span>first<span class="token punctuation">;</span>
            <span class="token keyword">const</span> CWalletTx<span class="token operator">*</span> pcoin <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CheckFinalTx</span><span class="token punctuation">(</span><span class="token operator">*</span>pcoin<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>fOnlyConfirmed <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pcoin<span class="token operator">-&gt;</span><span class="token function">IsTrusted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>pcoin<span class="token operator">-&gt;</span><span class="token function">IsCoinBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pcoin<span class="token operator">-&gt;</span><span class="token function">GetBlocksToMaturity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">int</span> nDepth <span class="token operator">=</span> pcoin<span class="token operator">-&gt;</span><span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nDepth <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token comment">// We should not consider coins which aren't at least in our mempool</span>
            <span class="token comment">// It's possible for these to be conflicted via ancestors which we may never be able to detect</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nDepth <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pcoin<span class="token operator">-&gt;</span><span class="token function">InMempool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pcoin<span class="token operator">-&gt;</span>vout<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                isminetype mine <span class="token operator">=</span> <span class="token function">IsMine</span><span class="token punctuation">(</span>pcoin<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//isminetype是枚举类型</span>
                <span class="token comment">//未被花费，可以被我花费，未被锁定的交易， ISMINE_NO =0</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">IsSpent</span><span class="token punctuation">(</span>wtxid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mine <span class="token operator">!=</span> ISMINE_NO <span class="token operator">&amp;&amp;</span>
                    <span class="token operator">!</span><span class="token function">IsLockedCoin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pcoin<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nValue <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> fIncludeZeroValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token operator">!</span>coinControl <span class="token operator">||</span> <span class="token operator">!</span>coinControl<span class="token operator">-&gt;</span><span class="token function">HasSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> coinControl<span class="token operator">-&gt;</span>fAllowOtherInputs <span class="token operator">||</span> coinControl<span class="token operator">-&gt;</span><span class="token function">IsSelected</span><span class="token punctuation">(</span><span class="token function">COutPoint</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        vCoins<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">COutput</span><span class="token punctuation">(</span>pcoin<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nDepth<span class="token punctuation">,</span>
                                                 <span class="token punctuation">(</span><span class="token punctuation">(</span>mine <span class="token operator">&amp;</span> ISMINE_SPENDABLE<span class="token punctuation">)</span> <span class="token operator">!=</span> ISMINE_NO<span class="token punctuation">)</span> <span class="token operator">||</span>
                                                  <span class="token punctuation">(</span>coinControl <span class="token operator">&amp;&amp;</span> coinControl<span class="token operator">-&gt;</span>fAllowWatchOnly <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mine <span class="token operator">&amp;</span> ISMINE_WATCH_SOLVABLE<span class="token punctuation">)</span> <span class="token operator">!=</span> ISMINE_NO<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                 <span class="token punctuation">(</span>mine <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ISMINE_SPENDABLE <span class="token operator">|</span> ISMINE_WATCH_SOLVABLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ISMINE_NO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这里开始的while循环很长</p> 
  <pre><code class="prism language-c"><span class="token punctuation">{</span>
        <span class="token function">LOCK2</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">,</span> cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">{</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>COutput<span class="token operator">&gt;</span> vAvailableCoins<span class="token punctuation">;</span><span class="token comment">//可用的交易输出，就是这笔交易的输入</span>
            <span class="token comment">//用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出</span>
            <span class="token function">AvailableCoins</span><span class="token punctuation">(</span>vAvailableCoins<span class="token punctuation">,</span> true<span class="token punctuation">,</span> coinControl<span class="token punctuation">)</span><span class="token punctuation">;</span>

            nFeeRet <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//交易费是从0开始</span>
            <span class="token comment">// Start with no fee and loop until there is enough fee循环直到有足够的交易金额</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
            <span class="token comment">//初始化工作，清零</span>
                nChangePosInOut <span class="token operator">=</span> nChangePosRequest<span class="token punctuation">;</span><span class="token comment">//-1</span>
                txNew<span class="token punctuation">.</span>vin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                txNew<span class="token punctuation">.</span>wit<span class="token punctuation">.</span><span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                wtxNew<span class="token punctuation">.</span>fFromMe <span class="token operator">=</span> true<span class="token punctuation">;</span>
                bool fFirst <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">//第一轮循环</span>

                CAmount nValueToSelect <span class="token operator">=</span> nValue<span class="token punctuation">;</span><span class="token comment">//需要选择的金额，初始为之前统计的所有接受者的金额</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nSubtractFeeFromAmount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    nValueToSelect <span class="token operator">+</span><span class="token operator">=</span> nFeeRet<span class="token punctuation">;</span><span class="token comment">//加上交易费，初始为0</span>
                <span class="token keyword">double</span> dPriority <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
  <p>对每个接收者的处理，对每个接收者创建一个<a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout" rel="nofollow">CTxOut</a></p> 
  <pre><code class="prism language-c"><span class="token comment">// vouts to the payees</span>
                BOOST_FOREACH <span class="token punctuation">(</span><span class="token keyword">const</span> CRecipient<span class="token operator">&amp;</span> recipient<span class="token punctuation">,</span> vecSend<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    CTxOut <span class="token function">txout</span><span class="token punctuation">(</span>recipient<span class="token punctuation">.</span>nAmount<span class="token punctuation">,</span> recipient<span class="token punctuation">.</span>scriptPubKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//如果设置从交易金额中减去交易费，那么需要分摊到每个设置的接收者，减去平均交易费</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>recipient<span class="token punctuation">.</span>fSubtractFeeFromAmount）
                    <span class="token punctuation">{</span>
                        txout<span class="token punctuation">.</span>nValue <span class="token operator">-</span><span class="token operator">=</span> nFeeRet <span class="token operator">/</span> nSubtractFeeFromAmount<span class="token punctuation">;</span> <span class="token comment">// Subtract fee equally from each selected recipient</span>


<span class="token comment">//第一个接收者，还需要支出不能被整除的需要的交易费的剩余部分</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fFirst<span class="token punctuation">)</span> <span class="token comment">// first receiver pays the remainder not divisible by output count</span>
                        <span class="token punctuation">{</span>
                            fFirst <span class="token operator">=</span> false<span class="token punctuation">;</span>
                            txout<span class="token punctuation">.</span>nValue <span class="token operator">-</span><span class="token operator">=</span> nFeeRet <span class="token operator">%</span> nSubtractFeeFromAmount<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
<span class="token comment">//如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>txout<span class="token punctuation">.</span><span class="token function">IsDust</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token punctuation">:</span>minRelayTxFee<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>recipient<span class="token punctuation">.</span>fSubtractFeeFromAmount <span class="token operator">&amp;&amp;</span> nFeeRet <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>txout<span class="token punctuation">.</span>nValue <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"The transaction amount is too small to pay the fee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"The transaction amount is too small to send after the fee has been deducted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span>
                            strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction amount too small"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>txout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写入交易的输出部分，压入数组底部</span>
                <span class="token punctuation">}</span>
</code></pre> 
  <hr> 
  <h3><a id="4__199"></a>4) 选择可用币</h3> 
  <pre><code class="prism language-c"><span class="token comment">// Choose coins to use</span>
set<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> setCoins<span class="token punctuation">;</span>
CAmount nValueIn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">//Shuffle and select coins until nTargetValue is reached while avoiding small change;</span>
<span class="token comment">//打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect </span>
<span class="token comment">//setCoins包含支付给你本人地址的交易，即你所拥有的币 </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SelectCoins</span><span class="token punctuation">(</span>vAvailableCoins<span class="token punctuation">,</span> nValueToSelect<span class="token punctuation">,</span> setCoins<span class="token punctuation">,</span> nValueIn<span class="token punctuation">,</span> coinControl<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Insufficient funds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//对选择好的这一组coins的每个来源计算优先级</span>
<span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token function">PAIRTYPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> pcoin<span class="token punctuation">,</span> setCoins<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	CAmount nCredit <span class="token operator">=</span> pcoin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>pcoin<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">.</span>nValue<span class="token punctuation">;</span><span class="token comment">//金额</span>
	<span class="token comment">//The coin age after the next block (depth+1) is used instead of the current,</span>
	<span class="token comment">//reflecting an assumption the user would accept a bit more delay for</span>
	<span class="token comment">//a chance at a free transaction.</span>
	<span class="token comment">//But mempool inputs might still be in the mempool, so their age stays 0</span>
	<span class="token comment">/*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/</span>
	<span class="token keyword">int</span> age <span class="token operator">=</span> pcoin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span><span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>age <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
       age <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    dPriority <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>nCredit <span class="token operator">*</span> age<span class="token punctuation">;</span><span class="token comment">//增加优先级，优先级为币龄*金额</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>可以来看一下SelectCoins，CCoinControl的值一直为null，看代码的时候可以忽略大部分内容,那么可以看到主要是调用了SelectCoinsMinConf这个函数</p> 
  <pre><code class="prism language-c">bool CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">SelectCoins</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>COutput<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vAvailableCoins<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount<span class="token operator">&amp;</span> nTargetValue<span class="token punctuation">,</span> set<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token operator">&amp;</span> setCoinsRet<span class="token punctuation">,</span> CAmount<span class="token operator">&amp;</span> nValueRet<span class="token punctuation">,</span> <span class="token keyword">const</span> CCoinControl<span class="token operator">*</span> coinControl<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>COutput<span class="token operator">&gt;</span> <span class="token function">vCoins</span><span class="token punctuation">(</span>vAvailableCoins<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// calculate value from preset inputs and store them从预设输入计算金额</span>
    set<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span> uint32_t<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> setPresetCoins<span class="token punctuation">;</span>
    CAmount nValueFromPresetInputs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    size_t nMaxChainLength <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitancestorcount"</span><span class="token punctuation">,</span> DEFAULT_ANCESTOR_LIMIT<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitdescendantcount"</span><span class="token punctuation">,</span> DEFAULT_DESCENDANT_LIMIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool fRejectLongChains <span class="token operator">=</span> <span class="token function">GetBoolArg</span><span class="token punctuation">(</span><span class="token string">"-walletrejectlongchains"</span><span class="token punctuation">,</span> DEFAULT_WALLET_REJECT_LONG_CHAINS<span class="token punctuation">)</span><span class="token punctuation">;</span>

    bool res <span class="token operator">=</span> nTargetValue <span class="token operator">&lt;=</span> nValueFromPresetInputs <span class="token operator">||</span>
        <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>bSpendZeroConfChange <span class="token operator">&amp;&amp;</span> <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>bSpendZeroConfChange <span class="token operator">&amp;&amp;</span> <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">,</span> nMaxChainLength<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>bSpendZeroConfChange <span class="token operator">&amp;&amp;</span> <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nMaxChainLength<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>bSpendZeroConfChange <span class="token operator">&amp;&amp;</span> <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nMaxChainLength<span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>bSpendZeroConfChange <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>fRejectLongChains <span class="token operator">&amp;&amp;</span> <span class="token function">SelectCoinsMinConf</span><span class="token punctuation">(</span>nTargetValue <span class="token operator">-</span> nValueFromPresetInputs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>numeric_limits<span class="token operator">&lt;</span>uint64_t<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vCoins<span class="token punctuation">,</span> setCoinsRet<span class="token punctuation">,</span> nValueRet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset</span>
    setCoinsRet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>setPresetCoins<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> setPresetCoins<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// add preset inputs to the total value selected</span>
    nValueRet <span class="token operator">+</span><span class="token operator">=</span> nValueFromPresetInputs<span class="token punctuation">;</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p><code>SelectCoinsMinConf</code>这个函数的注释</p> 
  <blockquote> 
   <p>随机排列并选择硬币，直到达到nTargetValue，同时避免小的找零; 该方法对于某些输入是随机的，并且在完成时组装硬币组和相应的实际目标值</p> 
  </blockquote> 
  <hr> 
  <h3><a id="5_262"></a>5）找零</h3> 
  <pre><code class="prism language-c"><span class="token keyword">const</span> CAmount nChange <span class="token operator">=</span> nValueIn <span class="token operator">-</span> nValueToSelect<span class="token punctuation">;</span><span class="token comment">//超出所需支出，那么需要找零</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>nChange <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
<span class="token comment">// Fill a vout to ourself</span>
<span class="token comment">// TODO: pass in scriptChange instead of reservekey so</span>
<span class="token comment">// change transaction isn't always pay-to-bitcoin-address</span>
<span class="token comment">/*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/</span>
	CScript scriptChange<span class="token punctuation">;</span>

    <span class="token comment">// coin control: send change to custom address 找零支付回习惯地址，如果设置的话</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>coinControl <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>boost<span class="token punctuation">:</span><span class="token punctuation">:</span>get<span class="token operator">&lt;</span>CNoDestination<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>coinControl<span class="token operator">-&gt;</span>destChange<span class="token punctuation">)</span><span class="token punctuation">)</span>
           scriptChange <span class="token operator">=</span> <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span>coinControl<span class="token operator">-&gt;</span>destChange<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">// no coin control: send change to newly generated address</span>
     <span class="token comment">//没有coin control的话默认没有设置）那么找零到一个新创建的地址</span>
      <span class="token keyword">else</span>
      <span class="token punctuation">{</span>
       <span class="token comment">// Note: We use a new key here to keep it from being obvious which side is the change.</span>
       <span class="token comment">// The drawback is that by not reusing a previous key, the change may be lost if a</span>
       <span class="token comment">// backup is restored, if the backup doesn't have the new private key for the change.</span>
       <span class="token comment">// If we reused the old key, it would be possible to add code to look for and</span>
       <span class="token comment">// rediscover unknown transactions that were written with keys of ours to recover</span>
       <span class="token comment">// post-backup change.</span>
      <span class="token comment">/*我们使用一个新的密钥避免找零地址变得明显。缺点是在不重复使用之前的密钥的情况下，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/</span>
      <span class="token comment">// Reserve a new key pair from key pool 从密钥池中预约一个新的密钥</span>
	      CPubKey vchPubKey<span class="token punctuation">;</span>
          bool ret<span class="token punctuation">;</span>
          ret <span class="token operator">=</span> reservekey<span class="token punctuation">.</span><span class="token function">GetReservedKey</span><span class="token punctuation">(</span>vchPubKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取一个公钥</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
                strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Keypool ran out, please call keypoolrefill first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token keyword">return</span> false<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

           scriptChange <span class="token operator">=</span> <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span>vchPubKey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找零脚本</span>
                    <span class="token punctuation">}</span>
       CTxOut <span class="token function">newTxOut</span><span class="token punctuation">(</span>nChange<span class="token punctuation">,</span> scriptChange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//新建一笔找零交易</span>
</code></pre> 
  <p>上述代码调用<code>reservekey</code>的<code>GetReservedKey</code>，<code>reservekey</code>是传入的参数（只是一个初始的对象）</p> 
  <pre><code class="prism language-c">bool CReserveKey<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetReservedKey</span><span class="token punctuation">(</span>CPubKey<span class="token operator">&amp;</span> pubkey<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nIndex <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//初始的时候被设置为-1</span>
    <span class="token punctuation">{</span>
        CKeyPool keypool<span class="token punctuation">;</span>
        pwallet<span class="token operator">-&gt;</span><span class="token function">ReserveKeyFromKeyPool</span><span class="token punctuation">(</span>nIndex<span class="token punctuation">,</span> keypool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nIndex <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            vchPubKey <span class="token operator">=</span> keypool<span class="token punctuation">.</span>vchPubKey<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>vchPubKey<span class="token punctuation">.</span><span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pubkey <span class="token operator">=</span> vchPubKey<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p><code>GetReservedKey</code>调用<code>CWallet</code>类的<code>ReserveKeyFromKeyPool</code></p> 
  <pre><code class="prism language-c"><span class="token keyword">void</span> CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ReserveKeyFromKeyPool</span><span class="token punctuation">(</span>int64_t<span class="token operator">&amp;</span> nIndex<span class="token punctuation">,</span> CKeyPool<span class="token operator">&amp;</span> keypool<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    nIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    keypool<span class="token punctuation">.</span>vchPubKey <span class="token operator">=</span> <span class="token function">CPubKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造一个无效的PubKey</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">TopUpKeyPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中</span>

        <span class="token comment">// Get the oldest key </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>setKeyPool<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        CWalletDB <span class="token function">walletdb</span><span class="token punctuation">(</span>strWalletFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

        nIndex <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>setKeyPool<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回容器指向的第一个元素，所以说是获取最老的密钥</span>
        setKeyPool<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>setKeyPool<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//擦除这个指针指向的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>walletdb<span class="token punctuation">.</span><span class="token function">ReadPool</span><span class="token punctuation">(</span>nIndex<span class="token punctuation">,</span> keypool<span class="token punctuation">)</span><span class="token punctuation">)</span>
            throw <span class="token function">runtime_error</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": read failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">HaveKey</span><span class="token punctuation">(</span>keypool<span class="token punctuation">.</span>vchPubKey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            throw <span class="token function">runtime_error</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": unknown key in key pool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>keypool<span class="token punctuation">.</span>vchPubKey<span class="token punctuation">.</span><span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LogPrintf</span><span class="token punctuation">(</span><span class="token string">"keypool reserve %d\n"</span><span class="token punctuation">,</span> nIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>需要注意这里的setKeyPool是signd long long的set容器类型<br> 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，<mark>虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中</mark>这一句我写的是有点问题的<br> <strong>这里纠正一下，TopUpKeyPool()在填充密钥池的时候也是用到GenerateNewKey()这个函数来生成新的密钥对，生成的密钥对调用AddKeyPubKey函数里面的<code>CWalletDB(strWalletFile).WriteKey（）</code>把私钥公钥哈希值都写入数据库，键值为(“keymeta",vchPubKey)和（（“key”,vchPubKey),(vchPrivKey,hash值），false)<br> 然后TopUpKeyPool()的话会再把公钥写入数据库键值对((“pool”,n),keypool),keypool只保存时间和公钥</strong></p> 
  <pre><code class="prism language-c"><span class="token function">TopUpKeyPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//DEFAULT_KEYPOOL_SIZE=100，填满池子到有100把密钥，nIndex保存在setKeyPool，</span>
            <span class="token comment">/** walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey()) 密钥写入berkerly database数据库键值对((“pool",nEne),(ntime,pubkey)) */</span>
</code></pre> 
  <p>也就是说创建后的密钥公钥写入数据库，保存为ckeypool,创建时的索引保存在setKeyPool这个集合中，新建时以最后一个索引的值递增，也就是用掉1之后，不会再生成索引1，而是101</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827170709446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF，使用rpc指令<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827155338293?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 创建两笔交易</p> 
  <pre><code>parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300
parallels@parallels-vm:~$ bitcoin-cli sendtoaddress "2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF" 0.2
441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04
parallels@parallels-vm:~$ bitcoin-cli getbalance
1.09896799
parallels@parallels-vm:~$ bitcoin-cli sendtoaddress "2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF" 0.2
aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641
parallels@parallels-vm:~$ 

</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827155901752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827160155945?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827160045373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 在创建三笔交易，创建一个地址，创建一个交易<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018082716174691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p> 
  <hr> 
  <h3><a id="6dust_output_391"></a>6）dust output</h3> 
  <p>灰尘交易</p> 
  <pre><code class="prism language-c"><span class="token comment">// Never create dust outputs; if we would, just add the dust to the fee.</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>newTxOut<span class="token punctuation">.</span><span class="token function">IsDust</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token punctuation">:</span>minRelayTxFee<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        nChangePosInOut <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                        nFeeRet <span class="token operator">+</span><span class="token operator">=</span> nChange<span class="token punctuation">;</span>
                        reservekey<span class="token punctuation">.</span><span class="token function">ReturnKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span>
                    <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>nChangePosInOut <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token punctuation">{</span>
                            <span class="token comment">// Insert change txn at random position:</span>
                            nChangePosInOut <span class="token operator">=</span> <span class="token function">GetRandInt</span><span class="token punctuation">(</span>txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>nChangePosInOut <span class="token operator">&gt;</span> txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">{</span>
                            strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Change index out of range"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                        vector<span class="token operator">&lt;</span>CTxOut<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator position <span class="token operator">=</span> txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>nChangePosInOut<span class="token punctuation">;</span>
                        txNew<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> newTxOut<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span>
                    reservekey<span class="token punctuation">.</span><span class="token function">ReturnKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <h3><a id="7vin__sign_423"></a>7）vin &amp; sign</h3> 
  <p>涉及交易的输入<a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin" rel="nofollow">vin</a>的序列号的相关背景</p> 
  <pre><code class="prism language-c"><span class="token comment">// Fill vin</span>
<span class="token comment">//</span>
<span class="token comment">// Note how the sequence number is set to max()-1 so that the</span>
<span class="token comment">// nLockTime set above actually works.</span>
<span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token function">PAIRTYPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> coin<span class="token punctuation">,</span> setCoins<span class="token punctuation">)</span>
    txNew<span class="token punctuation">.</span>vin<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">CTxIn</span><span class="token punctuation">(</span>coin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>coin<span class="token punctuation">.</span>second<span class="token punctuation">,</span><span class="token function">CScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>numeric_limits<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数<code>CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);</code>第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入数组中。<br> 接下来看签名</p> 
  <pre><code class="prism language-c"><span class="token comment">// Sign</span>
<span class="token keyword">int</span> nIn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
CTransaction <span class="token function">txNewConst</span><span class="token punctuation">(</span>txNew<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token function">PAIRTYPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> CWalletTx<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> coin<span class="token punctuation">,</span> setCoins<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		bool signSuccess<span class="token punctuation">;</span>
        <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptPubKey <span class="token operator">=</span> coin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>coin<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">.</span>scriptPubKey<span class="token punctuation">;</span>
        SignatureData sigdata<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sign<span class="token punctuation">)</span>
        <span class="token comment">//非隔离见证的交易</span>
	        signSuccess <span class="token operator">=</span> <span class="token function">ProduceSignature</span><span class="token punctuation">(</span><span class="token function">TransactionSignatureCreator</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> <span class="token operator">&amp;</span>txNewConst<span class="token punctuation">,</span> nIn<span class="token punctuation">,</span> coin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>coin<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">.</span>nValue<span class="token punctuation">,</span> SIGHASH_ALL<span class="token punctuation">)</span><span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> sigdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">else</span>
         <span class="token comment">//使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证</span>
             signSuccess <span class="token operator">=</span> <span class="token function">ProduceSignature</span><span class="token punctuation">(</span><span class="token function">DummySignatureCreator</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> sigdata<span class="token punctuation">)</span><span class="token punctuation">;</span>

           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>signSuccess<span class="token punctuation">)</span>
	           <span class="token punctuation">{</span>
                   strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Signing transaction failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token keyword">return</span> false<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">//从交易中抽取签名数据然后插入</span>
                   <span class="token function">UpdateTransaction</span><span class="token punctuation">(</span>txNew<span class="token punctuation">,</span> nIn<span class="token punctuation">,</span> sigdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

           nIn<span class="token operator">++</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
</code></pre> 
  <p>对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类<code>CMerkleTx</code>的父类<code>CTransaction</code>有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。<br> 调用函数<a href="https://blog.csdn.net/m0_37847176/article/details/82866757" rel="nofollow">ProduceSignature</a>使用通用签名创建者生成脚本签名,写在另一篇中</p> 
  <pre><code class="prism language-c"><span class="token comment">//sign.h</span>
<span class="token comment">/** Produce a script signature using a generic signature creator. */</span>
bool <span class="token function">ProduceSignature</span><span class="token punctuation">(</span><span class="token keyword">const</span> BaseSignatureCreator<span class="token operator">&amp;</span> creator<span class="token punctuation">,</span> <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptPubKey<span class="token punctuation">,</span> SignatureData<span class="token operator">&amp;</span> sigdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <h3><a id="8_472"></a>8）判断是否满足</h3> 
  <pre><code class="prism language-c"> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nBytes <span class="token operator">=</span> <span class="token function">GetVirtualTransactionSize</span><span class="token punctuation">(</span>txNew<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// Remove scriptSigs if we used dummy signatures for fee calculation</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sign<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    BOOST_FOREACH <span class="token punctuation">(</span>CTxIn<span class="token operator">&amp;</span> vin<span class="token punctuation">,</span> txNew<span class="token punctuation">.</span>vin<span class="token punctuation">)</span>
                        vin<span class="token punctuation">.</span>scriptSig <span class="token operator">=</span> <span class="token function">CScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    txNew<span class="token punctuation">.</span>wit<span class="token punctuation">.</span><span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// Embed the constructed transaction data in wtxNew.</span>
                <span class="token operator">*</span>static_cast<span class="token operator">&lt;</span>CTransaction<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wtxNew<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">CTransaction</span><span class="token punctuation">(</span>txNew<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// Limit size限制大小</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetTransactionWeight</span><span class="token punctuation">(</span>txNew<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> MAX_STANDARD_TX_WEIGHT<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction too large"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                dPriority <span class="token operator">=</span> wtxNew<span class="token punctuation">.</span><span class="token function">ComputePriority</span><span class="token punctuation">(</span>dPriority<span class="token punctuation">,</span> nBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// Can we complete this as a free transaction?</span>
                <span class="token comment">//构造一个免费的交易，费用不够的话用优先级来凑</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>fSendFreeTransactions <span class="token operator">&amp;&amp;</span> nBytes <span class="token operator">&lt;=</span> MAX_FREE_TRANSACTION_CREATE_SIZE<span class="token punctuation">)</span><span class="token comment">//默认值分别为false、1000</span>
                <span class="token punctuation">{</span>
                    <span class="token comment">// Not enough fee: enough priority?</span>
                    <span class="token keyword">double</span> dPriorityNeeded <span class="token operator">=</span> mempool<span class="token punctuation">.</span><span class="token function">estimateSmartPriority</span><span class="token punctuation">(</span>nTxConfirmTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// Require at least hard-coded AllowFree.</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dPriority <span class="token operator">&gt;=</span> dPriorityNeeded <span class="token operator">&amp;&amp;</span> <span class="token function">AllowFree</span><span class="token punctuation">(</span>dPriority<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
<span class="token comment">//获取最小交易费</span>
                CAmount nFeeNeeded <span class="token operator">=</span> <span class="token function">GetMinimumFee</span><span class="token punctuation">(</span>nBytes<span class="token punctuation">,</span> nTxConfirmTarget<span class="token punctuation">,</span> mempool<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//默认coinControl为空，这段逻辑跳过，以后懂了再说</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>coinControl <span class="token operator">&amp;&amp;</span> nFeeNeeded <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> coinControl<span class="token operator">-&gt;</span>nMinimumTotalFee <span class="token operator">&gt;</span> nFeeNeeded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    nFeeNeeded <span class="token operator">=</span> coinControl<span class="token operator">-&gt;</span>nMinimumTotalFee<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>coinControl <span class="token operator">&amp;&amp;</span> coinControl<span class="token operator">-&gt;</span>fOverrideFeeRate<span class="token punctuation">)</span>
                    nFeeNeeded <span class="token operator">=</span> coinControl<span class="token operator">-&gt;</span>nFeeRate<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// If we made it here and we aren't even able to meet the relay fee on the next pass, give up</span>
                <span class="token comment">// because we must be at the maximum allowed fee.</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nFeeNeeded <span class="token operator">&lt;</span> <span class="token punctuation">:</span><span class="token punctuation">:</span>minRelayTxFee<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nBytes<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction too large for fee policy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>nFeeRet <span class="token operator">&gt;=</span> nFeeNeeded<span class="token punctuation">)</span><span class="token comment">//直到有足够的费用</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// Done, enough fee included.</span>

                <span class="token comment">// Include more fee and try again.</span>
                nFeeRet <span class="token operator">=</span> nFeeNeeded<span class="token punctuation">;</span><span class="token comment">//</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
  <p>到这里是循环结束，满足条件则跳出循环，否则再次循环或报错<br> 这里来关注下<code>GetMinimumFee</code>的实现，用来计算最小交易费用，和交易的字节相关，但是交易的字节是在交易构造后才能计算，所以用nFeeRet保存预估费用，在此基础上构建新的交易，如果得到的真实交易费小于预估，则需要要替换交易费，再次构建。</p> 
  <pre><code class="prism language-c">CAmount CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetRequiredFee</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTxBytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">////! -mintxfee default</span>
<span class="token comment">//static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;</span>
<span class="token comment">//CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE);</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span>minTxFee<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span>minRelayTxFee<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000;</span>
    <span class="token comment">//CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);</span>
<span class="token punctuation">}</span>

CAmount CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetMinimumFee</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTxBytes<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nConfirmTarget<span class="token punctuation">,</span> <span class="token keyword">const</span> CTxMemPool<span class="token operator">&amp;</span> pool<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// payTxFee is user-set "I want to pay this much"</span>
    CAmount nFeeNeeded <span class="token operator">=</span> payTxFee<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// User didn't set: use -txconfirmtarget to estimate...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nFeeNeeded <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> estimateFoundTarget <span class="token operator">=</span> nConfirmTarget<span class="token punctuation">;</span>
        nFeeNeeded <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">estimateSmartFee</span><span class="token punctuation">(</span>nConfirmTarget<span class="token punctuation">,</span> <span class="token operator">&amp;</span>estimateFoundTarget<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ... unless we don't have enough mempool data for estimatefee, then use fallbackFee</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nFeeNeeded <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//没有足够的信息计算，那么使用这个费用</span>
            nFeeNeeded <span class="token operator">=</span> fallbackFee<span class="token punctuation">.</span><span class="token function">GetFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">////! -fallbackfee default</span>
<span class="token comment">//static const CAmount DEFAULT_FALLBACK_FEE = 20,000;</span>
<span class="token comment">//CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// prevent user from paying a fee below minRelayTxFee or minTxFee</span>
    <span class="token comment">//阻止用户支付低于minRelayTxFee或minTxFee的费用</span>
    nFeeNeeded <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span>nFeeNeeded<span class="token punctuation">,</span> <span class="token function">GetRequiredFee</span><span class="token punctuation">(</span>nTxBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// But always obey the maximum</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nFeeNeeded <span class="token operator">&gt;</span> maxTxFee<span class="token punctuation">)</span><span class="token comment">//大于最大费用</span>
        nFeeNeeded <span class="token operator">=</span> maxTxFee<span class="token punctuation">;</span>
    <span class="token keyword">return</span> nFeeNeeded<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>payTxfee是类CFeeRate的对象，全局变量，表示每千字节的费用,初始化0</p> 
  <pre><code class="prism language-c"><span class="token comment">/** * Fee rate in satoshis per kilobyte: CAmount / kB */</span>
</code></pre> 
  <p>首先调用该类的成员函数GetFee（）,计算字节对应的费用，用到的<code>nSatoshisPerK</code>是CFeeRate的私有成员变量</p> 
  <pre><code class="prism language-c">CAmount CFeeRate<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetFee</span><span class="token punctuation">(</span>size_t nBytes_<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>nBytes_ <span class="token operator">&lt;=</span> <span class="token function">uint64_t</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>numeric_limits<span class="token operator">&lt;</span>int64_t<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    int64_t nSize <span class="token operator">=</span> <span class="token function">int64_t</span><span class="token punctuation">(</span>nBytes_<span class="token punctuation">)</span><span class="token punctuation">;</span>

    CAmount nFee <span class="token operator">=</span> nSatoshisPerK <span class="token operator">*</span> nSize <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>nFee <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nSize <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nSatoshisPerK <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            nFee <span class="token operator">=</span> <span class="token function">CAmount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nSatoshisPerK <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            nFee <span class="token operator">=</span> <span class="token function">CAmount</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nFee<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>可以看到，按默认值计算得到的nFeeNeeded就是0，所以有第二段，针对nFeeNeeded==0的操作语句，注释也表明用户没有设置-txconfirmtarget参数来估算会这样</p> 
  <pre><code class="prism language-c"><span class="token comment">//wallet.cpp</span>
<span class="token comment">/** Transaction fee set by the user */</span>
CFeeRate <span class="token function">payTxFee</span><span class="token punctuation">(</span>DEFAULT_TRANSACTION_FEE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTxConfirmTarget <span class="token operator">=</span> DEFAULT_TX_CONFIRM_TARGET<span class="token punctuation">;</span><span class="token comment">//2</span>
</code></pre> 
  <p>用到的nTxConfirmTarget是默认设置为2 satoshis/kb,变量pool是传入的参数，类CTxMemPool，调用函数estimateSmartFee这个函数展开又比较大了<br> 大致看了下，里面调用EstimateMedianVal，会统计在这个目标金额下确认的交易数，总交易数和未确认的交易数，统计平均最佳值，然后返回。大概是这个意思，等我想看了再写</p> 
  <hr> 
  <h3><a id="9_608"></a>9）参数读取</h3> 
  <pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetBoolArg</span><span class="token punctuation">(</span><span class="token string">"-walletrejectlongchains"</span><span class="token punctuation">,</span> DEFAULT_WALLET_REJECT_LONG_CHAINS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Lastly, ensure this tx will pass the mempool's chain limits</span>
        LockPoints lp<span class="token punctuation">;</span>
        CTxMemPoolEntry <span class="token function">entry</span><span class="token punctuation">(</span>txNew<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        CTxMemPool<span class="token punctuation">:</span><span class="token punctuation">:</span>setEntries setAncestors<span class="token punctuation">;</span>
        size_t nLimitAncestors <span class="token operator">=</span> <span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitancestorcount"</span><span class="token punctuation">,</span> DEFAULT_ANCESTOR_LIMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size_t nLimitAncestorSize <span class="token operator">=</span> <span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitancestorsize"</span><span class="token punctuation">,</span> DEFAULT_ANCESTOR_SIZE_LIMIT<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">;</span>
        size_t nLimitDescendants <span class="token operator">=</span> <span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitdescendantcount"</span><span class="token punctuation">,</span> DEFAULT_DESCENDANT_LIMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size_t nLimitDescendantSize <span class="token operator">=</span> <span class="token function">GetArg</span><span class="token punctuation">(</span><span class="token string">"-limitdescendantsize"</span><span class="token punctuation">,</span> DEFAULT_DESCENDANT_SIZE_LIMIT<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>string errString<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mempool<span class="token punctuation">.</span><span class="token function">CalculateMemPoolAncestors</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> setAncestors<span class="token punctuation">,</span> nLimitAncestors<span class="token punctuation">,</span> nLimitAncestorSize<span class="token punctuation">,</span> nLimitDescendants<span class="token punctuation">,</span> nLimitDescendantSize<span class="token punctuation">,</span> errString<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            strFailReason <span class="token operator">=</span> <span class="token function">_</span><span class="token punctuation">(</span><span class="token string">"Transaction has too long of a mempool chain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
  <p>那么到这里就创建完交易了，接下来<a href="https://blog.csdn.net/m0_37847176/article/details/82351978" rel="nofollow">提交交易</a></p> 
  <p>附：支付给自己<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018091814593842?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw是我的比特币地址</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli sendtoaddress <span class="token string">"mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw"</span> <span class="token number">0.03</span>
ae1d05e0443736379b0184c3c1b9017ed074f232ae8def8fd208848538cb8904
</code></pre> 
  <p>我给自己转了0.03，以及一大笔交易费<br> 如果sendmany里面写两次同一个地址，报重复地址的错误，这个限制是接口里面设置的，因为是用set集合来保存的地址，最后构造成接收者存入vector数组中的，createtransaction函数内部是没有地址重复限制的。</p> 
  <hr> 
  <h2><a id="Createrawtransaction_641"></a>Createrawtransaction</h2> 
  <p>这种创建的方式更加自由，不过需要注意金额的填写，这里没有默认找零，差额全部支付给矿工</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli listaddressgroupings
<span class="token punctuation">[</span>
  <span class="token punctuation">[</span>
    <span class="token punctuation">[</span>
      <span class="token string">"mi6E46piWPryxA9J7K58J4hswL9815fAPa"</span><span class="token punctuation">,</span> 
      <span class="token number">0.00044634</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span> 
    <span class="token punctuation">[</span>
      <span class="token string">"mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT"</span><span class="token punctuation">,</span> 
      <span class="token number">0.00000000</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span> 
    <span class="token punctuation">[</span>
      <span class="token string">"mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw"</span><span class="token punctuation">,</span> 
      <span class="token number">0.02467234</span><span class="token punctuation">,</span> 
      <span class="token string">"my"</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">]</span>
parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli encryptwallet a123456
parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli listunspent
<span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mi6E46piWPryxA9J7K58J4hswL9815fAPa"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.00044634</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">21863</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw"</span><span class="token punctuation">,</span>
    <span class="token string">"account"</span><span class="token punctuation">:</span> <span class="token string">"my"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a914b3963733828c665a987a12e9c4eb04868ec4511188ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.02467234</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">21863</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.07400000</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> 
  <p>创建一笔交易，把地址<mark>mwtXCZEe8Wz9TkLHd4L8NAAjzdK8QrxaNw</mark>的0.02467234转到两个地址，给<mark>mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT</mark>分配0.024，给<mark>mi6E46piWPryxA9J7K58J4hswL9815fAPa</mark>分配0.00066，余下的0.00001234作为手续费奖励给矿工</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli  createrawtransaction <span class="token string">'[{"txid":"16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4","vout":1}]'</span> <span class="token string">'{"mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT":0.024,"mi6E46piWPryxA9J7K58J4hswL9815fAPa":0.00066}'</span> 
<span class="token number">0100000001f</span><span class="token number">4035</span>a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000
</code></pre> 
  <p>然后打开钱包准备转账</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli walletpassphrase a123456 <span class="token number">1200</span>
</code></pre> 
  <p>对交易签名</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli signrawtransaction <span class="token number">0100000001f</span><span class="token number">4035</span>a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd160100000000ffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000
<span class="token punctuation">{</span>
  <span class="token string">"hex"</span><span class="token punctuation">:</span> <span class="token string">"0100000001f4035a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000"</span><span class="token punctuation">,</span>
  <span class="token string">"complete"</span><span class="token punctuation">:</span> true
<span class="token punctuation">}</span>
</code></pre> 
  <p>然后发送交易</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli sendrawtransaction <span class="token number">0100000001f</span><span class="token number">4035</span>a19d31ebc03257ed982b1449315dffcee24d9cb4d489003f49a5f8fdd16010000006a47304402204f2e48935f0a2ae76076cb89b800816d5953b772e238bcd22317d4b3e008cb4c02206dd671fdf84b5024d7354653bbd5a285a811baf78780fc1e6605bf8e776e043d012103bfd9224018307649f7741aad40f8e817d9a957d416a65da7632cfc0a68e4e2cdffffffff02009f2400000000001976a914b0bc2d08863f46f7c279efbeecbd4237de2626c788acd0010100000000001976a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac00000000
<span class="token number">1</span>b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44
</code></pre> 
  <p>过段时间后我们来看我们的余额，10分钟左右吧，6个区块确认</p> 
  <pre><code class="prism language-c">parallels@parallels<span class="token operator">-</span>vm<span class="token punctuation">:</span><span class="token operator">~</span>$ bitcoin<span class="token operator">-</span>cli listunspent
<span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.02400000</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"1b27bfbc22e746eefaba7896765281ceb7a5d0b225c4ccc9154e8780d22a0f44"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mi6E46piWPryxA9J7K58J4hswL9815fAPa"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.00066000</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"16dd8f5f9af40390484dcbd924eefcdf159344b182d97e2503bc1ed3195a03f4"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mi6E46piWPryxA9J7K58J4hswL9815fAPa"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a9141c3b2234e89210ef29d3063cdc219aa3d673b67c88ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.00044634</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">21883</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token string">"txid"</span><span class="token punctuation">:</span> <span class="token string">"50cdfbe406e441c6740a61008a562319ceb228ea9bde91b1e2d0f6d43f7ad2ff"</span><span class="token punctuation">,</span>
    <span class="token string">"vout"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"mwdSeWQBe1UmeM5ztQasQGrHiNTiNWwCTT"</span><span class="token punctuation">,</span>
    <span class="token string">"scriptPubKey"</span><span class="token punctuation">:</span> <span class="token string">"76a914b0bc2d08863f46f7c279efbeecbd4237de2626c788ac"</span><span class="token punctuation">,</span>
    <span class="token string">"amount"</span><span class="token punctuation">:</span> <span class="token number">0.07400000</span><span class="token punctuation">,</span>
    <span class="token string">"confirmations"</span><span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span>
    <span class="token string">"spendable"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"solvable"</span><span class="token punctuation">:</span> true
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> 
  <p>可以看到去掉支出的那一笔，新增两笔支出</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-778f64ae39.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82493420,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82493420,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
