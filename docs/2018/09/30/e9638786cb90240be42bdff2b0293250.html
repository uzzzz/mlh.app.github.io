<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【我的区块链之路】- go实现区块链中常见的各类算法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【我的区块链之路】- go实现区块链中常见的各类算法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="【转载请标明出处】https://blog.csdn.net/qq_25870633/article/details/82900508 咳咳，为什么要出这一篇文章呢？首先，这段时间本人在找工作，然后被问到了各类算法的底层细节，有些确实很懵逼。这里做个总结，也顺便给大家归纳归纳一下！ 上主题： 椭圆曲线加密： 我们先来说一说最常用的 ECC 吧，ECC 就是 Elliptic Curve Cryptography 的缩写。那么，在说椭圆曲线加密之前，我们来说一说什么是椭圆曲线？ 中学的时候我们学过圆锥曲线，比如椭圆、双曲线和抛物线。因为描述这些曲线的方程都是二次方程，圆锥曲线又被称为二次曲线。而椭圆曲线是则是由三次方程描述的一些曲线。更准确地说，椭圆曲线是由下面的方程描述的曲线： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，椭圆曲线之所以叫“椭圆曲线”，是因为其曲线方程跟利用微积分计算椭圆周长的公式相似。实际上它的图像跟椭圆完全不搭边。 &nbsp; 如椭圆曲线 y^2=x^3−x+1 的图像： &nbsp; 【注意】椭圆曲线有这样的两个性质： 关于X轴对称 画一条直线跟椭圆曲线相交，它们最多有三个交点 &nbsp; 椭圆曲线上的运算 由于椭圆曲线加密进行的运算实际上都是在椭圆曲线上进行的，必须注意的是，这里把这些运算称为“加法”和“乘法”仅仅是方便描述，他们跟平时认知的加法和乘法完全是两码事，完全可以给他们取其它名字（比如”乘法“和”幂运算“等）。总之就是规定，规定，规定(重要的事说三遍) 首先定义坐标系中距离X轴无穷远点为椭圆曲线上的一个特殊点，称为0点。 那么此时上述第二条性质可以加强为：过曲线上任意两点（可重合）的直线必定与曲线相交于第三点。 然后定义椭圆曲线上点的加法。设椭圆曲线上有两点，A和B点，那么作过这两点的直线与该曲线相交于第三点（C点），然后关于X轴对称得到D点，则D为这两个点的和，记作D=A+B&nbsp;(注意： 这仅仅是规定)。很明显，D点也在该曲线上。所以椭圆曲线上两点之和也是曲线上的点。 特别地，如果两点重合，则作椭圆曲线在A点处的切线，与曲线相交于第二点（B点），然后关于X轴对称得到C点，则C点为A点与自身的和，记作 C =&nbsp; 2A。 &nbsp; 加法，我们可以得到以下结论： A+B = B+A 也就是椭圆曲线上的加法满足交换律。 A+0 = A 因为0点是无穷远点，所以过A点与0点的直线是垂直于X轴的，它与曲线相交于另一点B点，那么B点关于X轴对称的点就是A点，即A点为A点和0点之和。 &nbsp; 然后在加法的基础上，定义椭圆曲线上点的乘法。 乘法：(下列的也是一种规定，是规定) 设P是椭圆曲线上的一个点，那么正整数k乘以点P的结果由下面的式子定义，注意式子中的加法是上面提到的椭圆曲线上点的加法： &nbsp; 1∗P=P1 2∗P=P+P 3∗P=2∗P+P …&nbsp; k∗P=(k−1)∗P+P 乘法满足以下性质： 对于任意正整数k和j，有&nbsp; k∗(j∗P) = (kj)∗P = (jk)∗P = j∗(k∗P) 知道公钥反推私钥： k 为正整数，P 是椭圆曲线上的点（称为基点），已知 k∗P 和 P，计算 k 进一步为： &nbsp; k 为正整数，P 是椭圆曲线上的点，已知 P^k 和 P，计算 k = logP P^k &nbsp; 以上，是复杂度很高的操作，公钥反推私钥很难求 （在椭圆曲线算法中很难求） 【注意】： 密码学中，并不能使用上面介绍的实数域上的椭圆曲线。因为： 1. 实数域上的椭圆曲线是连续的，有无限个点，密码学要求有限点。 2. 实数域上的椭圆曲线的运算有误差，不精确。密码学要求精确。 所以我们需要引入有限域上的椭圆曲线。 &nbsp; 有限域上的椭圆曲线： 所谓有限域上的椭圆曲线，简单来说就是满足下面式子要求的曲线（x, y, a, b都是小于素数【也即是质数】p的 非负整数）： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 对比一下原先的椭圆曲线的方程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以看到这个只是对原式进行了简单的取模处理而已。 按数论定义，有限域GF(p)指给定某个质数p，由0、1、2......p-1共p个元素组成的整数集合。且方程的坐标点满足了在有限域中定义的加减乘除运算的结果也应该是在域中。 假设椭圆曲线为 y² = x³ + x + 1，其在有限域GF(23)上时，写作： 　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y² ≡ x³ + x + 1 (mod 23) 此时，椭圆曲线不再是一条光滑曲线，而是一些不连续的点，如以点(1,7)为例，7² ≡ 1³ + 1 + 1 ≡ 3 (mod 23)。如此还有如下点： &nbsp; 　　(0,1) (0,22) 　　(1,7) (1,16) 　　(3,10) (3,13) 　　(4,0) 　　(5,4) (5,19) 　　(6,4) (6,19) 　　(7,11) (7,12) 　　(9,7) (9,16) 　　(11,3) (11,20) 　　等等。 &nbsp; 另外，如果P(x,y)为椭圆曲线上的点，则-P即(x,-y)也为椭圆曲线上的点。如点P(0,1)，-P=(0,-1)=(0,22)也为椭圆曲线上的点。看图：（该图的点全部以 y = 23/2 对称）并不代表着关于某水平线对称哦,参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 又如下图是椭圆曲线 y²&nbsp;= x³−x+1 对素数97取模后的图像： 原本连续光滑的曲线变成了离散的点，基本已经面目全非了，但是依然可以看到它是关于某条水平直线（y= 97/2）对称的。而且上面定义的椭圆曲线的加法仍然可用（当然乘法也可以）。 &nbsp; 【注意】：密码学中有限域上的椭圆曲线一般有两种，一种是定义在以素数p为模的整数域GF(p)，也就是上面介绍的；另一种则是定义在特征为 2 的伽罗瓦域 GF(2^m)上。 &nbsp; 好了我们下面来看看，逼逼了这么久我们到底是要做什么？ 用生成的私钥 + 椭圆曲线 求 公钥的过程就是计算xG的坐标的过程 计算 xG 就是 【私钥 * 基点 = 公钥】 &nbsp; 　　相关公式如下： 　　有限域GF(p)上的椭圆曲线 y² = x³ + ax + b，若P(Xp, Yp), Q(Xq, Yq)，且P≠-Q，则R(Xr,Yr) = P+Q 由如下规则确定： &nbsp; 　　Xr = (λ² - Xp - Xq) mod p 　　Yr = (λ(Xp - Xr) - Yp) mod p 　　其中【公式 1】&nbsp;λ = (Yq - Yp)/(Xq - Xp) mod p（若P≠Q）,&nbsp;【公式 2】 λ = (3Xp² + a)/2Yp mod p（若P=Q） &nbsp; 　　因此，有限域GF(23)上的椭圆曲线 y² ≡ x³ + x + 1 (mod 23)，假设以(0,1)为G点，计算2G、3G、4G...xG等等，方法如下： &nbsp; 　　计算2G： &nbsp; &nbsp; &nbsp; &nbsp;2G = G + G ，所以用 【公式 2】求&nbsp;λ 　　λ = (3x0² + 1)/2x1 mod 23 = (1/2) mod 23 = 12 　　Xr = (12² - 0 - 0) mod 23 = 6 　　Yr = (12(0 - 6) - 1) mod 23 = 19 　　即2G为点(6,19) &nbsp; 　　计算3G： 　　3G = G + 2G，即(0,1) + (6,19)，用【公式 1】求&nbsp;λ 　　λ = (19 - 1)/(6 - 0) mod 23 = 3 　　Xr = (3² - 0 - 6) mod 23 = 3 　　Yr = (3(0 - 3) - 1) mod 23 = 13 　　即3G为点(3, 13) &nbsp; 　　同理计算4G、5G...xG，分布如下图： &nbsp; 所以，上述就是在说，我们如何根据 提前生成好的私钥 X (私钥 可以是有某种随机算法求出来的一个 数字) 和 选定的椭圆曲线 （如：Curve25519，prime256v1，secp256k1）(以上曲线均为有限质数域下的椭圆曲线，表现为 离散的点，根据 y = 质数P/2 水平线对称)，求出 公式&nbsp; XG 点的 坐标 (x ,y) 既是组成公钥的 x 和 y。（其中 G 为选好的椭圆曲线上的基点,即 (x，y) == （0, 0）求出来的曲线上的坐标点，XG 也是曲线上的一点。 实际应用中，我们并不需要关心椭圆曲线的众多参数如何选取（要选对参数&nbsp;a, b&nbsp;对于普通使用者来说并不现实），只要从密码学家们精心挑选的一堆曲线中选择一个就行了。一般来说曲线Curve25519，prime256v1是比较常用的，比特币选择secp256k1则是有自己的考量 建立基于椭圆曲线的加密机制，需要找到类似RSA质因子分解或其他求离散对数这样的难题。而椭圆曲线上的已知G和xG求x，是非常困难的(为什么呢？请看计算出XG的步骤就知道的，每一步的 λ&nbsp;都是不一样的)，此即为椭圆曲线上的的离散对数问题。此处x即为私钥，xG即为公钥。 &nbsp;椭圆曲线加密算法原理如下： &nbsp; 　　设私钥、公钥分别为k、Y，即Y = kG，其中G为基点。 &nbsp; 　　公钥加密： 　　选择随机数r，将消息M生成密文C，该密文是一个点对，即： 　　C = {rG, M+rY}，其中Y为公钥 &nbsp; 　　私钥解密： 　　M + rY - k(rG) = M + r(kG) - k(rG) = M 　　其中k、Y分别为私钥、公钥。 椭圆曲线签名算法原理 &nbsp; 　　椭圆曲线签名算法，即 ECDSA。 　　设私钥、公钥分别为k、Y，即&nbsp;Y = kG，其中G为G点。 &nbsp; 　　私钥签名： 　　1、选择随机数 r，计算点 rG(x, y)。 　　2、根据随机数r、消息M的哈希h、私钥 k，计算&nbsp;s = (h + kx)/r。 　　3、将消息M、和&nbsp;签名{rG, s}发给接收方。 &nbsp; 　　公钥验证签名： 　　1、接收方收到消息M、以及签名{rG=(x,y), s}。 　　2、根据消息求哈希h。 　　3、使用发送方公钥K计算：hG/s + xY/s，并与rG比较，如相等即验签成功。 &nbsp; 　　原理如下： 　　hG/s + xY/s = hG/s + x(kG)/s = (h+xk)G/s 　　= r(h+xk)G / (h+kx) =&nbsp; rG &nbsp; 详细可以参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; Diffie–Hellman密钥交换 (DH) Diffie–Hellman密钥交换（以下简称DH）是用于双方在可能被窃听环境下安全交换密钥的一种方法。&nbsp; 算法的安全性是由上面提到的离散对数难题保证。 &nbsp; 具体算法流程如下： 小红和小明约定 p 和 g 的值 小红生成私钥 x，计算 g^x mod p 作为 公钥 公布出去 小明生成私钥 y，计算 g^y mod p 作为 公钥 公布出去 &nbsp; &nbsp; &nbsp; 小红得知 g^y mod p后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^y mod p)^x mod p = (g^y)^x mod p = g^xy mod p &nbsp; 小明得到gxmodpgxmodp后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^x mod p)^y mod p = (g^x)^y mod p = g^xy mod p 双方都得到了相同的密钥的ss，交换完毕 &nbsp; 上面的流程中，x 和 y 始终由两人自行保管的，第三方窃听得到的只有 p、g、g^x mod p和 g^y mod p这几个值。 上面说过，离散对数是很难算的，所以第三方不能由这些信息计算出 x 或 y，也就没办法计算出密钥 s 了 &nbsp; 基于椭圆曲线的DH密钥交换（ECDH） ECDH跟DH的流程基本是一致的。 小红和小明约定使用某条椭圆曲线（包括曲线参数，有限域参数以及基点P等） 小红生成私钥 x，计算 x∗P 作为公钥公布出去 小明生成私钥 y，计算 y∗P 作为公钥公布出去 &nbsp; 小红得知 y∗P 后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = x∗(y∗P) = xy∗P &nbsp; 小明得到x∗Px∗P后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = y∗(x∗P) = yx∗P 双方都得到了相同的密钥的ss，交换完毕 由于计算椭圆曲线上的离散对数是很难的，所以第三方没办法在只知道 x∗P 和 y∗P 的情况下计算出 x 或 y 的值。好了，下面我们来看看椭圆曲线的 go 代码实现吧。【主要为 go 原生的crypto/elliptic和crypto/ecdsa包下的代码分析】 如代码： /** 曲线接口 库引用路径： crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type Curve interface { // 获取椭圆曲线参数 Params() *CurveParams // 某点是否在曲线上 IsOnCurve(x, y *big.Int) bool // 加法 (x1,y1) + (x2,y2) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) // 二倍运算 2*(x,y) Double(x1, y1 *big.Int) (x, y *big.Int) // 即乘法 k*(Bx,By) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) // 即 k*G 其中G 为基点. ScalarBaseMult(k []byte) (x, y *big.Int) } 上述代码是操作曲线 实现对象的，主要定义了判断曲线上的点，返回曲线的基本参数 (P, n, b，Gx，Gy，BitSize， Name)，及曲线上点的加法和乘法运算。 我们再看看，CurveParams 曲线的主要组成参数都是些什么：【其实CurveParams也就是 Curve 的实现】 /** 曲线的实现结构体 代码引用路径：crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type CurveParams struct { //有限域GF(p)中质数p P *big.Int //G点的阶 //如果存在最小正整数n，使得nG=O∞，则n为G点的阶 N *big.Int //椭圆曲线方程y²= x³-3x+b中常数b B *big.Int //G点(x,y) Gx, Gy *big.Int //密钥长度 BitSize int //椭圆曲线名称 Name string } func (curve *CurveParams) Params() *CurveParams { //获取椭圆曲线参数，即curve return curve } func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool { //是否在曲线y²=x³-3x+b上 // y² = x³ - 3x + b y2 := new(big.Int).Mul(y, y) y2.Mod(y2, curve.P) x3 := new(big.Int).Mul(x, x) x3.Mul(x3, x) threeX := new(big.Int).Lsh(x, 1) threeX.Add(threeX, x) x3.Sub(x3, threeX) x3.Add(x3, curve.B) x3.Mod(x3, curve.P) return x3.Cmp(y2) == 0 } func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) { //加法运算，代码略 } func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) { //二倍运算，代码略 } func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) { //k*(Bx,By)，代码略 } func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int) { //k*G, G为基点，代码略 } 我们再往下看看公私钥对，及签名验签等操作的代码： //代码位置src/crypto/ecdsa/ecdsa.go // 公钥 type PublicKey struct { // 曲线实例 elliptic.Curve // 公钥对应去上线的一点坐标 (即：kG的坐标，其中名k为私钥，G为基点) X, Y *big.Int } // 私钥 type PrivateKey struct { // 公钥实例 PublicKey // 私钥的数字，即kG中的k D *big.Int } // 签名 // rand 随机写入流 // priv 私钥 // 待签名Hash // @return r 签名的 {r, s}中的r // @return s 签名的 {r, s}中的s // @return err func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) { entropylen := (priv.Curve.Params().BitSize + 7) / 16 if entropylen &gt; 32 { entropylen = 32 } entropy := make([]byte, entropylen) _, err = io.ReadFull(rand, entropy) if err != nil { return } md := sha512.New() md.Write(priv.D.Bytes()) //私钥 md.Write(entropy) md.Write(hash) key := md.Sum(nil)[:32] block, err := aes.NewCipher(key) if err != nil { return nil, nil, err } csprng := cipher.StreamReader{ R: zeroReader, S: cipher.NewCTR(block, []byte(aesIV)), } c := priv.PublicKey.Curve //椭圆曲线 N := c.Params().N //G点的阶 if N.Sign() == 0 { return nil, nil, errZeroParam } var k, kInv *big.Int for { for { //取随机数k k, err = randFieldElement(c, csprng) if err != nil { r = nil return } //求k在有限域GF(P)的逆，即1/k if in, ok := priv.Curve.(invertible); ok { kInv = in.Inverse(k) } else { kInv = fermatInverse(k, N) // N != 0 } //求r = kG r, _ = priv.Curve.ScalarBaseMult(k.Bytes()) r.Mod(r, N) if r.Sign() != 0 { break } } e := hashToInt(hash, c) //e即哈希 s = new(big.Int).Mul(priv.D, r) //Dr，即DkG s.Add(s, e) //e+DkG s.Mul(s, kInv) //(e+DkG)/k s.Mod(s, N) // N != 0 if s.Sign() != 0 { break } //签名为{r, s}，即{kG, (e+DkG)/k} } return } // 验签 // pub 公钥 // hash 等待和签名做对比的被签名的原文Hash (和 签名方法入参中的待签名Hash) // r 签名的 {r, s}中的r // s 签名的 {r, s}中的s // @return bool 是否通过校验 true 是 false 否 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool { c := pub.Curve //椭圆曲线 N := c.Params().N //G点的阶 if r.Sign() &lt;= 0 || s.Sign() &lt;= 0 { return false } if r.Cmp(N) &gt;= 0 || s.Cmp(N) &gt;= 0 { return false } e := hashToInt(hash, c) //e即哈希 var w *big.Int //求s在有限域GF(P)的逆，即1/s if in, ok := c.(invertible); ok { w = in.Inverse(s) } else { w = new(big.Int).ModInverse(s, N) } u1 := e.Mul(e, w) //即e/s u1.Mod(u1, N) u2 := w.Mul(r, w) //即r/s u2.Mod(u2, N) var x, y *big.Int if opt, ok := c.(combinedMult); ok { x, y = opt.CombinedMult(pub.X, pub.Y, u1.Bytes(), u2.Bytes()) } else { x1, y1 := c.ScalarBaseMult(u1.Bytes()) //即eG/s x2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes()) //即DGr/s //即eG/s + DGr/s = (e + Dr)G/s //= (e + Dr)kG / (e + DkG) = (e + Dr)r / (e + Dr) = r x, y = c.Add(x1, y1, x2, y2) } if x.Sign() == 0 &amp;&amp; y.Sign() == 0 { return false } x.Mod(x, N) return x.Cmp(r) == 0 } 使用如下： package main import ( &quot;crypto/ecdsa&quot; &quot;crypto/elliptic&quot; &quot;crypto/rand&quot; &quot;log&quot; &quot;fmt&quot; &quot;crypto/sha256&quot; ) func main() { // 先获取一个椭圆实例 curve := elliptic.P256() //得到私钥 privateKey, err := ecdsa.GenerateKey(curve, rand.Reader) if err != nil { log.Panic(err) } //产生公钥 publicKey := privateKey.PublicKey fmt.Println(&quot;priKey&quot;, privateKey, &quot;\npubKey&quot;, publicKey) strHash := sha256.New().Sum([]byte( &quot;我是学生&quot;)) // 签名 r, s, err := ecdsa.Sign(rand.Reader, privateKey, strHash) if nil != err { log.Panic(err) } fmt.Println(&quot;r&quot;, r, &quot;\ns&quot;, s) strHash2 := sha256.New().Sum([]byte(&quot;我是个程序员&quot;)) // 验签 fmt.Println(ecdsa.Verify(&amp;publicKey, strHash2, r, s)) // false fmt.Println(ecdsa.Verify(&amp;publicKey, strHash, r, s)) // true } 好了，以上就是对椭圆曲线加密的讲解，其实以太坊中不是直接用go的原生库crypto中的ecdsa哦，而是用了比特币所使用的一个C++的库 libsecp256k1，在目录：crypto/secp256k1 路径中。 &nbsp; 【本文还未写完，国庆这几天会完善完.......】 阅读更多" />
<meta property="og:description" content="【转载请标明出处】https://blog.csdn.net/qq_25870633/article/details/82900508 咳咳，为什么要出这一篇文章呢？首先，这段时间本人在找工作，然后被问到了各类算法的底层细节，有些确实很懵逼。这里做个总结，也顺便给大家归纳归纳一下！ 上主题： 椭圆曲线加密： 我们先来说一说最常用的 ECC 吧，ECC 就是 Elliptic Curve Cryptography 的缩写。那么，在说椭圆曲线加密之前，我们来说一说什么是椭圆曲线？ 中学的时候我们学过圆锥曲线，比如椭圆、双曲线和抛物线。因为描述这些曲线的方程都是二次方程，圆锥曲线又被称为二次曲线。而椭圆曲线是则是由三次方程描述的一些曲线。更准确地说，椭圆曲线是由下面的方程描述的曲线： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，椭圆曲线之所以叫“椭圆曲线”，是因为其曲线方程跟利用微积分计算椭圆周长的公式相似。实际上它的图像跟椭圆完全不搭边。 &nbsp; 如椭圆曲线 y^2=x^3−x+1 的图像： &nbsp; 【注意】椭圆曲线有这样的两个性质： 关于X轴对称 画一条直线跟椭圆曲线相交，它们最多有三个交点 &nbsp; 椭圆曲线上的运算 由于椭圆曲线加密进行的运算实际上都是在椭圆曲线上进行的，必须注意的是，这里把这些运算称为“加法”和“乘法”仅仅是方便描述，他们跟平时认知的加法和乘法完全是两码事，完全可以给他们取其它名字（比如”乘法“和”幂运算“等）。总之就是规定，规定，规定(重要的事说三遍) 首先定义坐标系中距离X轴无穷远点为椭圆曲线上的一个特殊点，称为0点。 那么此时上述第二条性质可以加强为：过曲线上任意两点（可重合）的直线必定与曲线相交于第三点。 然后定义椭圆曲线上点的加法。设椭圆曲线上有两点，A和B点，那么作过这两点的直线与该曲线相交于第三点（C点），然后关于X轴对称得到D点，则D为这两个点的和，记作D=A+B&nbsp;(注意： 这仅仅是规定)。很明显，D点也在该曲线上。所以椭圆曲线上两点之和也是曲线上的点。 特别地，如果两点重合，则作椭圆曲线在A点处的切线，与曲线相交于第二点（B点），然后关于X轴对称得到C点，则C点为A点与自身的和，记作 C =&nbsp; 2A。 &nbsp; 加法，我们可以得到以下结论： A+B = B+A 也就是椭圆曲线上的加法满足交换律。 A+0 = A 因为0点是无穷远点，所以过A点与0点的直线是垂直于X轴的，它与曲线相交于另一点B点，那么B点关于X轴对称的点就是A点，即A点为A点和0点之和。 &nbsp; 然后在加法的基础上，定义椭圆曲线上点的乘法。 乘法：(下列的也是一种规定，是规定) 设P是椭圆曲线上的一个点，那么正整数k乘以点P的结果由下面的式子定义，注意式子中的加法是上面提到的椭圆曲线上点的加法： &nbsp; 1∗P=P1 2∗P=P+P 3∗P=2∗P+P …&nbsp; k∗P=(k−1)∗P+P 乘法满足以下性质： 对于任意正整数k和j，有&nbsp; k∗(j∗P) = (kj)∗P = (jk)∗P = j∗(k∗P) 知道公钥反推私钥： k 为正整数，P 是椭圆曲线上的点（称为基点），已知 k∗P 和 P，计算 k 进一步为： &nbsp; k 为正整数，P 是椭圆曲线上的点，已知 P^k 和 P，计算 k = logP P^k &nbsp; 以上，是复杂度很高的操作，公钥反推私钥很难求 （在椭圆曲线算法中很难求） 【注意】： 密码学中，并不能使用上面介绍的实数域上的椭圆曲线。因为： 1. 实数域上的椭圆曲线是连续的，有无限个点，密码学要求有限点。 2. 实数域上的椭圆曲线的运算有误差，不精确。密码学要求精确。 所以我们需要引入有限域上的椭圆曲线。 &nbsp; 有限域上的椭圆曲线： 所谓有限域上的椭圆曲线，简单来说就是满足下面式子要求的曲线（x, y, a, b都是小于素数【也即是质数】p的 非负整数）： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 对比一下原先的椭圆曲线的方程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以看到这个只是对原式进行了简单的取模处理而已。 按数论定义，有限域GF(p)指给定某个质数p，由0、1、2......p-1共p个元素组成的整数集合。且方程的坐标点满足了在有限域中定义的加减乘除运算的结果也应该是在域中。 假设椭圆曲线为 y² = x³ + x + 1，其在有限域GF(23)上时，写作： 　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y² ≡ x³ + x + 1 (mod 23) 此时，椭圆曲线不再是一条光滑曲线，而是一些不连续的点，如以点(1,7)为例，7² ≡ 1³ + 1 + 1 ≡ 3 (mod 23)。如此还有如下点： &nbsp; 　　(0,1) (0,22) 　　(1,7) (1,16) 　　(3,10) (3,13) 　　(4,0) 　　(5,4) (5,19) 　　(6,4) (6,19) 　　(7,11) (7,12) 　　(9,7) (9,16) 　　(11,3) (11,20) 　　等等。 &nbsp; 另外，如果P(x,y)为椭圆曲线上的点，则-P即(x,-y)也为椭圆曲线上的点。如点P(0,1)，-P=(0,-1)=(0,22)也为椭圆曲线上的点。看图：（该图的点全部以 y = 23/2 对称）并不代表着关于某水平线对称哦,参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 又如下图是椭圆曲线 y²&nbsp;= x³−x+1 对素数97取模后的图像： 原本连续光滑的曲线变成了离散的点，基本已经面目全非了，但是依然可以看到它是关于某条水平直线（y= 97/2）对称的。而且上面定义的椭圆曲线的加法仍然可用（当然乘法也可以）。 &nbsp; 【注意】：密码学中有限域上的椭圆曲线一般有两种，一种是定义在以素数p为模的整数域GF(p)，也就是上面介绍的；另一种则是定义在特征为 2 的伽罗瓦域 GF(2^m)上。 &nbsp; 好了我们下面来看看，逼逼了这么久我们到底是要做什么？ 用生成的私钥 + 椭圆曲线 求 公钥的过程就是计算xG的坐标的过程 计算 xG 就是 【私钥 * 基点 = 公钥】 &nbsp; 　　相关公式如下： 　　有限域GF(p)上的椭圆曲线 y² = x³ + ax + b，若P(Xp, Yp), Q(Xq, Yq)，且P≠-Q，则R(Xr,Yr) = P+Q 由如下规则确定： &nbsp; 　　Xr = (λ² - Xp - Xq) mod p 　　Yr = (λ(Xp - Xr) - Yp) mod p 　　其中【公式 1】&nbsp;λ = (Yq - Yp)/(Xq - Xp) mod p（若P≠Q）,&nbsp;【公式 2】 λ = (3Xp² + a)/2Yp mod p（若P=Q） &nbsp; 　　因此，有限域GF(23)上的椭圆曲线 y² ≡ x³ + x + 1 (mod 23)，假设以(0,1)为G点，计算2G、3G、4G...xG等等，方法如下： &nbsp; 　　计算2G： &nbsp; &nbsp; &nbsp; &nbsp;2G = G + G ，所以用 【公式 2】求&nbsp;λ 　　λ = (3x0² + 1)/2x1 mod 23 = (1/2) mod 23 = 12 　　Xr = (12² - 0 - 0) mod 23 = 6 　　Yr = (12(0 - 6) - 1) mod 23 = 19 　　即2G为点(6,19) &nbsp; 　　计算3G： 　　3G = G + 2G，即(0,1) + (6,19)，用【公式 1】求&nbsp;λ 　　λ = (19 - 1)/(6 - 0) mod 23 = 3 　　Xr = (3² - 0 - 6) mod 23 = 3 　　Yr = (3(0 - 3) - 1) mod 23 = 13 　　即3G为点(3, 13) &nbsp; 　　同理计算4G、5G...xG，分布如下图： &nbsp; 所以，上述就是在说，我们如何根据 提前生成好的私钥 X (私钥 可以是有某种随机算法求出来的一个 数字) 和 选定的椭圆曲线 （如：Curve25519，prime256v1，secp256k1）(以上曲线均为有限质数域下的椭圆曲线，表现为 离散的点，根据 y = 质数P/2 水平线对称)，求出 公式&nbsp; XG 点的 坐标 (x ,y) 既是组成公钥的 x 和 y。（其中 G 为选好的椭圆曲线上的基点,即 (x，y) == （0, 0）求出来的曲线上的坐标点，XG 也是曲线上的一点。 实际应用中，我们并不需要关心椭圆曲线的众多参数如何选取（要选对参数&nbsp;a, b&nbsp;对于普通使用者来说并不现实），只要从密码学家们精心挑选的一堆曲线中选择一个就行了。一般来说曲线Curve25519，prime256v1是比较常用的，比特币选择secp256k1则是有自己的考量 建立基于椭圆曲线的加密机制，需要找到类似RSA质因子分解或其他求离散对数这样的难题。而椭圆曲线上的已知G和xG求x，是非常困难的(为什么呢？请看计算出XG的步骤就知道的，每一步的 λ&nbsp;都是不一样的)，此即为椭圆曲线上的的离散对数问题。此处x即为私钥，xG即为公钥。 &nbsp;椭圆曲线加密算法原理如下： &nbsp; 　　设私钥、公钥分别为k、Y，即Y = kG，其中G为基点。 &nbsp; 　　公钥加密： 　　选择随机数r，将消息M生成密文C，该密文是一个点对，即： 　　C = {rG, M+rY}，其中Y为公钥 &nbsp; 　　私钥解密： 　　M + rY - k(rG) = M + r(kG) - k(rG) = M 　　其中k、Y分别为私钥、公钥。 椭圆曲线签名算法原理 &nbsp; 　　椭圆曲线签名算法，即 ECDSA。 　　设私钥、公钥分别为k、Y，即&nbsp;Y = kG，其中G为G点。 &nbsp; 　　私钥签名： 　　1、选择随机数 r，计算点 rG(x, y)。 　　2、根据随机数r、消息M的哈希h、私钥 k，计算&nbsp;s = (h + kx)/r。 　　3、将消息M、和&nbsp;签名{rG, s}发给接收方。 &nbsp; 　　公钥验证签名： 　　1、接收方收到消息M、以及签名{rG=(x,y), s}。 　　2、根据消息求哈希h。 　　3、使用发送方公钥K计算：hG/s + xY/s，并与rG比较，如相等即验签成功。 &nbsp; 　　原理如下： 　　hG/s + xY/s = hG/s + x(kG)/s = (h+xk)G/s 　　= r(h+xk)G / (h+kx) =&nbsp; rG &nbsp; 详细可以参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; Diffie–Hellman密钥交换 (DH) Diffie–Hellman密钥交换（以下简称DH）是用于双方在可能被窃听环境下安全交换密钥的一种方法。&nbsp; 算法的安全性是由上面提到的离散对数难题保证。 &nbsp; 具体算法流程如下： 小红和小明约定 p 和 g 的值 小红生成私钥 x，计算 g^x mod p 作为 公钥 公布出去 小明生成私钥 y，计算 g^y mod p 作为 公钥 公布出去 &nbsp; &nbsp; &nbsp; 小红得知 g^y mod p后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^y mod p)^x mod p = (g^y)^x mod p = g^xy mod p &nbsp; 小明得到gxmodpgxmodp后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^x mod p)^y mod p = (g^x)^y mod p = g^xy mod p 双方都得到了相同的密钥的ss，交换完毕 &nbsp; 上面的流程中，x 和 y 始终由两人自行保管的，第三方窃听得到的只有 p、g、g^x mod p和 g^y mod p这几个值。 上面说过，离散对数是很难算的，所以第三方不能由这些信息计算出 x 或 y，也就没办法计算出密钥 s 了 &nbsp; 基于椭圆曲线的DH密钥交换（ECDH） ECDH跟DH的流程基本是一致的。 小红和小明约定使用某条椭圆曲线（包括曲线参数，有限域参数以及基点P等） 小红生成私钥 x，计算 x∗P 作为公钥公布出去 小明生成私钥 y，计算 y∗P 作为公钥公布出去 &nbsp; 小红得知 y∗P 后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = x∗(y∗P) = xy∗P &nbsp; 小明得到x∗Px∗P后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = y∗(x∗P) = yx∗P 双方都得到了相同的密钥的ss，交换完毕 由于计算椭圆曲线上的离散对数是很难的，所以第三方没办法在只知道 x∗P 和 y∗P 的情况下计算出 x 或 y 的值。好了，下面我们来看看椭圆曲线的 go 代码实现吧。【主要为 go 原生的crypto/elliptic和crypto/ecdsa包下的代码分析】 如代码： /** 曲线接口 库引用路径： crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type Curve interface { // 获取椭圆曲线参数 Params() *CurveParams // 某点是否在曲线上 IsOnCurve(x, y *big.Int) bool // 加法 (x1,y1) + (x2,y2) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) // 二倍运算 2*(x,y) Double(x1, y1 *big.Int) (x, y *big.Int) // 即乘法 k*(Bx,By) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) // 即 k*G 其中G 为基点. ScalarBaseMult(k []byte) (x, y *big.Int) } 上述代码是操作曲线 实现对象的，主要定义了判断曲线上的点，返回曲线的基本参数 (P, n, b，Gx，Gy，BitSize， Name)，及曲线上点的加法和乘法运算。 我们再看看，CurveParams 曲线的主要组成参数都是些什么：【其实CurveParams也就是 Curve 的实现】 /** 曲线的实现结构体 代码引用路径：crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type CurveParams struct { //有限域GF(p)中质数p P *big.Int //G点的阶 //如果存在最小正整数n，使得nG=O∞，则n为G点的阶 N *big.Int //椭圆曲线方程y²= x³-3x+b中常数b B *big.Int //G点(x,y) Gx, Gy *big.Int //密钥长度 BitSize int //椭圆曲线名称 Name string } func (curve *CurveParams) Params() *CurveParams { //获取椭圆曲线参数，即curve return curve } func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool { //是否在曲线y²=x³-3x+b上 // y² = x³ - 3x + b y2 := new(big.Int).Mul(y, y) y2.Mod(y2, curve.P) x3 := new(big.Int).Mul(x, x) x3.Mul(x3, x) threeX := new(big.Int).Lsh(x, 1) threeX.Add(threeX, x) x3.Sub(x3, threeX) x3.Add(x3, curve.B) x3.Mod(x3, curve.P) return x3.Cmp(y2) == 0 } func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) { //加法运算，代码略 } func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) { //二倍运算，代码略 } func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) { //k*(Bx,By)，代码略 } func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int) { //k*G, G为基点，代码略 } 我们再往下看看公私钥对，及签名验签等操作的代码： //代码位置src/crypto/ecdsa/ecdsa.go // 公钥 type PublicKey struct { // 曲线实例 elliptic.Curve // 公钥对应去上线的一点坐标 (即：kG的坐标，其中名k为私钥，G为基点) X, Y *big.Int } // 私钥 type PrivateKey struct { // 公钥实例 PublicKey // 私钥的数字，即kG中的k D *big.Int } // 签名 // rand 随机写入流 // priv 私钥 // 待签名Hash // @return r 签名的 {r, s}中的r // @return s 签名的 {r, s}中的s // @return err func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) { entropylen := (priv.Curve.Params().BitSize + 7) / 16 if entropylen &gt; 32 { entropylen = 32 } entropy := make([]byte, entropylen) _, err = io.ReadFull(rand, entropy) if err != nil { return } md := sha512.New() md.Write(priv.D.Bytes()) //私钥 md.Write(entropy) md.Write(hash) key := md.Sum(nil)[:32] block, err := aes.NewCipher(key) if err != nil { return nil, nil, err } csprng := cipher.StreamReader{ R: zeroReader, S: cipher.NewCTR(block, []byte(aesIV)), } c := priv.PublicKey.Curve //椭圆曲线 N := c.Params().N //G点的阶 if N.Sign() == 0 { return nil, nil, errZeroParam } var k, kInv *big.Int for { for { //取随机数k k, err = randFieldElement(c, csprng) if err != nil { r = nil return } //求k在有限域GF(P)的逆，即1/k if in, ok := priv.Curve.(invertible); ok { kInv = in.Inverse(k) } else { kInv = fermatInverse(k, N) // N != 0 } //求r = kG r, _ = priv.Curve.ScalarBaseMult(k.Bytes()) r.Mod(r, N) if r.Sign() != 0 { break } } e := hashToInt(hash, c) //e即哈希 s = new(big.Int).Mul(priv.D, r) //Dr，即DkG s.Add(s, e) //e+DkG s.Mul(s, kInv) //(e+DkG)/k s.Mod(s, N) // N != 0 if s.Sign() != 0 { break } //签名为{r, s}，即{kG, (e+DkG)/k} } return } // 验签 // pub 公钥 // hash 等待和签名做对比的被签名的原文Hash (和 签名方法入参中的待签名Hash) // r 签名的 {r, s}中的r // s 签名的 {r, s}中的s // @return bool 是否通过校验 true 是 false 否 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool { c := pub.Curve //椭圆曲线 N := c.Params().N //G点的阶 if r.Sign() &lt;= 0 || s.Sign() &lt;= 0 { return false } if r.Cmp(N) &gt;= 0 || s.Cmp(N) &gt;= 0 { return false } e := hashToInt(hash, c) //e即哈希 var w *big.Int //求s在有限域GF(P)的逆，即1/s if in, ok := c.(invertible); ok { w = in.Inverse(s) } else { w = new(big.Int).ModInverse(s, N) } u1 := e.Mul(e, w) //即e/s u1.Mod(u1, N) u2 := w.Mul(r, w) //即r/s u2.Mod(u2, N) var x, y *big.Int if opt, ok := c.(combinedMult); ok { x, y = opt.CombinedMult(pub.X, pub.Y, u1.Bytes(), u2.Bytes()) } else { x1, y1 := c.ScalarBaseMult(u1.Bytes()) //即eG/s x2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes()) //即DGr/s //即eG/s + DGr/s = (e + Dr)G/s //= (e + Dr)kG / (e + DkG) = (e + Dr)r / (e + Dr) = r x, y = c.Add(x1, y1, x2, y2) } if x.Sign() == 0 &amp;&amp; y.Sign() == 0 { return false } x.Mod(x, N) return x.Cmp(r) == 0 } 使用如下： package main import ( &quot;crypto/ecdsa&quot; &quot;crypto/elliptic&quot; &quot;crypto/rand&quot; &quot;log&quot; &quot;fmt&quot; &quot;crypto/sha256&quot; ) func main() { // 先获取一个椭圆实例 curve := elliptic.P256() //得到私钥 privateKey, err := ecdsa.GenerateKey(curve, rand.Reader) if err != nil { log.Panic(err) } //产生公钥 publicKey := privateKey.PublicKey fmt.Println(&quot;priKey&quot;, privateKey, &quot;\npubKey&quot;, publicKey) strHash := sha256.New().Sum([]byte( &quot;我是学生&quot;)) // 签名 r, s, err := ecdsa.Sign(rand.Reader, privateKey, strHash) if nil != err { log.Panic(err) } fmt.Println(&quot;r&quot;, r, &quot;\ns&quot;, s) strHash2 := sha256.New().Sum([]byte(&quot;我是个程序员&quot;)) // 验签 fmt.Println(ecdsa.Verify(&amp;publicKey, strHash2, r, s)) // false fmt.Println(ecdsa.Verify(&amp;publicKey, strHash, r, s)) // true } 好了，以上就是对椭圆曲线加密的讲解，其实以太坊中不是直接用go的原生库crypto中的ecdsa哦，而是用了比特币所使用的一个C++的库 libsecp256k1，在目录：crypto/secp256k1 路径中。 &nbsp; 【本文还未写完，国庆这几天会完善完.......】 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/30/e9638786cb90240be42bdff2b0293250.html" />
<meta property="og:url" content="https://mlh.app/2018/09/30/e9638786cb90240be42bdff2b0293250.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"【转载请标明出处】https://blog.csdn.net/qq_25870633/article/details/82900508 咳咳，为什么要出这一篇文章呢？首先，这段时间本人在找工作，然后被问到了各类算法的底层细节，有些确实很懵逼。这里做个总结，也顺便给大家归纳归纳一下！ 上主题： 椭圆曲线加密： 我们先来说一说最常用的 ECC 吧，ECC 就是 Elliptic Curve Cryptography 的缩写。那么，在说椭圆曲线加密之前，我们来说一说什么是椭圆曲线？ 中学的时候我们学过圆锥曲线，比如椭圆、双曲线和抛物线。因为描述这些曲线的方程都是二次方程，圆锥曲线又被称为二次曲线。而椭圆曲线是则是由三次方程描述的一些曲线。更准确地说，椭圆曲线是由下面的方程描述的曲线： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，椭圆曲线之所以叫“椭圆曲线”，是因为其曲线方程跟利用微积分计算椭圆周长的公式相似。实际上它的图像跟椭圆完全不搭边。 &nbsp; 如椭圆曲线 y^2=x^3−x+1 的图像： &nbsp; 【注意】椭圆曲线有这样的两个性质： 关于X轴对称 画一条直线跟椭圆曲线相交，它们最多有三个交点 &nbsp; 椭圆曲线上的运算 由于椭圆曲线加密进行的运算实际上都是在椭圆曲线上进行的，必须注意的是，这里把这些运算称为“加法”和“乘法”仅仅是方便描述，他们跟平时认知的加法和乘法完全是两码事，完全可以给他们取其它名字（比如”乘法“和”幂运算“等）。总之就是规定，规定，规定(重要的事说三遍) 首先定义坐标系中距离X轴无穷远点为椭圆曲线上的一个特殊点，称为0点。 那么此时上述第二条性质可以加强为：过曲线上任意两点（可重合）的直线必定与曲线相交于第三点。 然后定义椭圆曲线上点的加法。设椭圆曲线上有两点，A和B点，那么作过这两点的直线与该曲线相交于第三点（C点），然后关于X轴对称得到D点，则D为这两个点的和，记作D=A+B&nbsp;(注意： 这仅仅是规定)。很明显，D点也在该曲线上。所以椭圆曲线上两点之和也是曲线上的点。 特别地，如果两点重合，则作椭圆曲线在A点处的切线，与曲线相交于第二点（B点），然后关于X轴对称得到C点，则C点为A点与自身的和，记作 C =&nbsp; 2A。 &nbsp; 加法，我们可以得到以下结论： A+B = B+A 也就是椭圆曲线上的加法满足交换律。 A+0 = A 因为0点是无穷远点，所以过A点与0点的直线是垂直于X轴的，它与曲线相交于另一点B点，那么B点关于X轴对称的点就是A点，即A点为A点和0点之和。 &nbsp; 然后在加法的基础上，定义椭圆曲线上点的乘法。 乘法：(下列的也是一种规定，是规定) 设P是椭圆曲线上的一个点，那么正整数k乘以点P的结果由下面的式子定义，注意式子中的加法是上面提到的椭圆曲线上点的加法： &nbsp; 1∗P=P1 2∗P=P+P 3∗P=2∗P+P …&nbsp; k∗P=(k−1)∗P+P 乘法满足以下性质： 对于任意正整数k和j，有&nbsp; k∗(j∗P) = (kj)∗P = (jk)∗P = j∗(k∗P) 知道公钥反推私钥： k 为正整数，P 是椭圆曲线上的点（称为基点），已知 k∗P 和 P，计算 k 进一步为： &nbsp; k 为正整数，P 是椭圆曲线上的点，已知 P^k 和 P，计算 k = logP P^k &nbsp; 以上，是复杂度很高的操作，公钥反推私钥很难求 （在椭圆曲线算法中很难求） 【注意】： 密码学中，并不能使用上面介绍的实数域上的椭圆曲线。因为： 1. 实数域上的椭圆曲线是连续的，有无限个点，密码学要求有限点。 2. 实数域上的椭圆曲线的运算有误差，不精确。密码学要求精确。 所以我们需要引入有限域上的椭圆曲线。 &nbsp; 有限域上的椭圆曲线： 所谓有限域上的椭圆曲线，简单来说就是满足下面式子要求的曲线（x, y, a, b都是小于素数【也即是质数】p的 非负整数）： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 对比一下原先的椭圆曲线的方程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以看到这个只是对原式进行了简单的取模处理而已。 按数论定义，有限域GF(p)指给定某个质数p，由0、1、2......p-1共p个元素组成的整数集合。且方程的坐标点满足了在有限域中定义的加减乘除运算的结果也应该是在域中。 假设椭圆曲线为 y² = x³ + x + 1，其在有限域GF(23)上时，写作： 　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y² ≡ x³ + x + 1 (mod 23) 此时，椭圆曲线不再是一条光滑曲线，而是一些不连续的点，如以点(1,7)为例，7² ≡ 1³ + 1 + 1 ≡ 3 (mod 23)。如此还有如下点： &nbsp; 　　(0,1) (0,22) 　　(1,7) (1,16) 　　(3,10) (3,13) 　　(4,0) 　　(5,4) (5,19) 　　(6,4) (6,19) 　　(7,11) (7,12) 　　(9,7) (9,16) 　　(11,3) (11,20) 　　等等。 &nbsp; 另外，如果P(x,y)为椭圆曲线上的点，则-P即(x,-y)也为椭圆曲线上的点。如点P(0,1)，-P=(0,-1)=(0,22)也为椭圆曲线上的点。看图：（该图的点全部以 y = 23/2 对称）并不代表着关于某水平线对称哦,参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 又如下图是椭圆曲线 y²&nbsp;= x³−x+1 对素数97取模后的图像： 原本连续光滑的曲线变成了离散的点，基本已经面目全非了，但是依然可以看到它是关于某条水平直线（y= 97/2）对称的。而且上面定义的椭圆曲线的加法仍然可用（当然乘法也可以）。 &nbsp; 【注意】：密码学中有限域上的椭圆曲线一般有两种，一种是定义在以素数p为模的整数域GF(p)，也就是上面介绍的；另一种则是定义在特征为 2 的伽罗瓦域 GF(2^m)上。 &nbsp; 好了我们下面来看看，逼逼了这么久我们到底是要做什么？ 用生成的私钥 + 椭圆曲线 求 公钥的过程就是计算xG的坐标的过程 计算 xG 就是 【私钥 * 基点 = 公钥】 &nbsp; 　　相关公式如下： 　　有限域GF(p)上的椭圆曲线 y² = x³ + ax + b，若P(Xp, Yp), Q(Xq, Yq)，且P≠-Q，则R(Xr,Yr) = P+Q 由如下规则确定： &nbsp; 　　Xr = (λ² - Xp - Xq) mod p 　　Yr = (λ(Xp - Xr) - Yp) mod p 　　其中【公式 1】&nbsp;λ = (Yq - Yp)/(Xq - Xp) mod p（若P≠Q）,&nbsp;【公式 2】 λ = (3Xp² + a)/2Yp mod p（若P=Q） &nbsp; 　　因此，有限域GF(23)上的椭圆曲线 y² ≡ x³ + x + 1 (mod 23)，假设以(0,1)为G点，计算2G、3G、4G...xG等等，方法如下： &nbsp; 　　计算2G： &nbsp; &nbsp; &nbsp; &nbsp;2G = G + G ，所以用 【公式 2】求&nbsp;λ 　　λ = (3x0² + 1)/2x1 mod 23 = (1/2) mod 23 = 12 　　Xr = (12² - 0 - 0) mod 23 = 6 　　Yr = (12(0 - 6) - 1) mod 23 = 19 　　即2G为点(6,19) &nbsp; 　　计算3G： 　　3G = G + 2G，即(0,1) + (6,19)，用【公式 1】求&nbsp;λ 　　λ = (19 - 1)/(6 - 0) mod 23 = 3 　　Xr = (3² - 0 - 6) mod 23 = 3 　　Yr = (3(0 - 3) - 1) mod 23 = 13 　　即3G为点(3, 13) &nbsp; 　　同理计算4G、5G...xG，分布如下图： &nbsp; 所以，上述就是在说，我们如何根据 提前生成好的私钥 X (私钥 可以是有某种随机算法求出来的一个 数字) 和 选定的椭圆曲线 （如：Curve25519，prime256v1，secp256k1）(以上曲线均为有限质数域下的椭圆曲线，表现为 离散的点，根据 y = 质数P/2 水平线对称)，求出 公式&nbsp; XG 点的 坐标 (x ,y) 既是组成公钥的 x 和 y。（其中 G 为选好的椭圆曲线上的基点,即 (x，y) == （0, 0）求出来的曲线上的坐标点，XG 也是曲线上的一点。 实际应用中，我们并不需要关心椭圆曲线的众多参数如何选取（要选对参数&nbsp;a, b&nbsp;对于普通使用者来说并不现实），只要从密码学家们精心挑选的一堆曲线中选择一个就行了。一般来说曲线Curve25519，prime256v1是比较常用的，比特币选择secp256k1则是有自己的考量 建立基于椭圆曲线的加密机制，需要找到类似RSA质因子分解或其他求离散对数这样的难题。而椭圆曲线上的已知G和xG求x，是非常困难的(为什么呢？请看计算出XG的步骤就知道的，每一步的 λ&nbsp;都是不一样的)，此即为椭圆曲线上的的离散对数问题。此处x即为私钥，xG即为公钥。 &nbsp;椭圆曲线加密算法原理如下： &nbsp; 　　设私钥、公钥分别为k、Y，即Y = kG，其中G为基点。 &nbsp; 　　公钥加密： 　　选择随机数r，将消息M生成密文C，该密文是一个点对，即： 　　C = {rG, M+rY}，其中Y为公钥 &nbsp; 　　私钥解密： 　　M + rY - k(rG) = M + r(kG) - k(rG) = M 　　其中k、Y分别为私钥、公钥。 椭圆曲线签名算法原理 &nbsp; 　　椭圆曲线签名算法，即 ECDSA。 　　设私钥、公钥分别为k、Y，即&nbsp;Y = kG，其中G为G点。 &nbsp; 　　私钥签名： 　　1、选择随机数 r，计算点 rG(x, y)。 　　2、根据随机数r、消息M的哈希h、私钥 k，计算&nbsp;s = (h + kx)/r。 　　3、将消息M、和&nbsp;签名{rG, s}发给接收方。 &nbsp; 　　公钥验证签名： 　　1、接收方收到消息M、以及签名{rG=(x,y), s}。 　　2、根据消息求哈希h。 　　3、使用发送方公钥K计算：hG/s + xY/s，并与rG比较，如相等即验签成功。 &nbsp; 　　原理如下： 　　hG/s + xY/s = hG/s + x(kG)/s = (h+xk)G/s 　　= r(h+xk)G / (h+kx) =&nbsp; rG &nbsp; 详细可以参考：https://www.cnblogs.com/X-knight/p/9153209.html &nbsp; &nbsp; Diffie–Hellman密钥交换 (DH) Diffie–Hellman密钥交换（以下简称DH）是用于双方在可能被窃听环境下安全交换密钥的一种方法。&nbsp; 算法的安全性是由上面提到的离散对数难题保证。 &nbsp; 具体算法流程如下： 小红和小明约定 p 和 g 的值 小红生成私钥 x，计算 g^x mod p 作为 公钥 公布出去 小明生成私钥 y，计算 g^y mod p 作为 公钥 公布出去 &nbsp; &nbsp; &nbsp; 小红得知 g^y mod p后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^y mod p)^x mod p = (g^y)^x mod p = g^xy mod p &nbsp; 小明得到gxmodpgxmodp后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^x mod p)^y mod p = (g^x)^y mod p = g^xy mod p 双方都得到了相同的密钥的ss，交换完毕 &nbsp; 上面的流程中，x 和 y 始终由两人自行保管的，第三方窃听得到的只有 p、g、g^x mod p和 g^y mod p这几个值。 上面说过，离散对数是很难算的，所以第三方不能由这些信息计算出 x 或 y，也就没办法计算出密钥 s 了 &nbsp; 基于椭圆曲线的DH密钥交换（ECDH） ECDH跟DH的流程基本是一致的。 小红和小明约定使用某条椭圆曲线（包括曲线参数，有限域参数以及基点P等） 小红生成私钥 x，计算 x∗P 作为公钥公布出去 小明生成私钥 y，计算 y∗P 作为公钥公布出去 &nbsp; 小红得知 y∗P 后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = x∗(y∗P) = xy∗P &nbsp; 小明得到x∗Px∗P后，计算&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s = y∗(x∗P) = yx∗P 双方都得到了相同的密钥的ss，交换完毕 由于计算椭圆曲线上的离散对数是很难的，所以第三方没办法在只知道 x∗P 和 y∗P 的情况下计算出 x 或 y 的值。好了，下面我们来看看椭圆曲线的 go 代码实现吧。【主要为 go 原生的crypto/elliptic和crypto/ecdsa包下的代码分析】 如代码： /** 曲线接口 库引用路径： crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type Curve interface { // 获取椭圆曲线参数 Params() *CurveParams // 某点是否在曲线上 IsOnCurve(x, y *big.Int) bool // 加法 (x1,y1) + (x2,y2) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) // 二倍运算 2*(x,y) Double(x1, y1 *big.Int) (x, y *big.Int) // 即乘法 k*(Bx,By) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) // 即 k*G 其中G 为基点. ScalarBaseMult(k []byte) (x, y *big.Int) } 上述代码是操作曲线 实现对象的，主要定义了判断曲线上的点，返回曲线的基本参数 (P, n, b，Gx，Gy，BitSize， Name)，及曲线上点的加法和乘法运算。 我们再看看，CurveParams 曲线的主要组成参数都是些什么：【其实CurveParams也就是 Curve 的实现】 /** 曲线的实现结构体 代码引用路径：crypto/elliptic 代码所在文件路径：src/crypto/elliptic/elliptic.go */ type CurveParams struct { //有限域GF(p)中质数p P *big.Int //G点的阶 //如果存在最小正整数n，使得nG=O∞，则n为G点的阶 N *big.Int //椭圆曲线方程y²= x³-3x+b中常数b B *big.Int //G点(x,y) Gx, Gy *big.Int //密钥长度 BitSize int //椭圆曲线名称 Name string } func (curve *CurveParams) Params() *CurveParams { //获取椭圆曲线参数，即curve return curve } func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool { //是否在曲线y²=x³-3x+b上 // y² = x³ - 3x + b y2 := new(big.Int).Mul(y, y) y2.Mod(y2, curve.P) x3 := new(big.Int).Mul(x, x) x3.Mul(x3, x) threeX := new(big.Int).Lsh(x, 1) threeX.Add(threeX, x) x3.Sub(x3, threeX) x3.Add(x3, curve.B) x3.Mod(x3, curve.P) return x3.Cmp(y2) == 0 } func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) { //加法运算，代码略 } func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) { //二倍运算，代码略 } func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) { //k*(Bx,By)，代码略 } func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int) { //k*G, G为基点，代码略 } 我们再往下看看公私钥对，及签名验签等操作的代码： //代码位置src/crypto/ecdsa/ecdsa.go // 公钥 type PublicKey struct { // 曲线实例 elliptic.Curve // 公钥对应去上线的一点坐标 (即：kG的坐标，其中名k为私钥，G为基点) X, Y *big.Int } // 私钥 type PrivateKey struct { // 公钥实例 PublicKey // 私钥的数字，即kG中的k D *big.Int } // 签名 // rand 随机写入流 // priv 私钥 // 待签名Hash // @return r 签名的 {r, s}中的r // @return s 签名的 {r, s}中的s // @return err func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) { entropylen := (priv.Curve.Params().BitSize + 7) / 16 if entropylen &gt; 32 { entropylen = 32 } entropy := make([]byte, entropylen) _, err = io.ReadFull(rand, entropy) if err != nil { return } md := sha512.New() md.Write(priv.D.Bytes()) //私钥 md.Write(entropy) md.Write(hash) key := md.Sum(nil)[:32] block, err := aes.NewCipher(key) if err != nil { return nil, nil, err } csprng := cipher.StreamReader{ R: zeroReader, S: cipher.NewCTR(block, []byte(aesIV)), } c := priv.PublicKey.Curve //椭圆曲线 N := c.Params().N //G点的阶 if N.Sign() == 0 { return nil, nil, errZeroParam } var k, kInv *big.Int for { for { //取随机数k k, err = randFieldElement(c, csprng) if err != nil { r = nil return } //求k在有限域GF(P)的逆，即1/k if in, ok := priv.Curve.(invertible); ok { kInv = in.Inverse(k) } else { kInv = fermatInverse(k, N) // N != 0 } //求r = kG r, _ = priv.Curve.ScalarBaseMult(k.Bytes()) r.Mod(r, N) if r.Sign() != 0 { break } } e := hashToInt(hash, c) //e即哈希 s = new(big.Int).Mul(priv.D, r) //Dr，即DkG s.Add(s, e) //e+DkG s.Mul(s, kInv) //(e+DkG)/k s.Mod(s, N) // N != 0 if s.Sign() != 0 { break } //签名为{r, s}，即{kG, (e+DkG)/k} } return } // 验签 // pub 公钥 // hash 等待和签名做对比的被签名的原文Hash (和 签名方法入参中的待签名Hash) // r 签名的 {r, s}中的r // s 签名的 {r, s}中的s // @return bool 是否通过校验 true 是 false 否 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool { c := pub.Curve //椭圆曲线 N := c.Params().N //G点的阶 if r.Sign() &lt;= 0 || s.Sign() &lt;= 0 { return false } if r.Cmp(N) &gt;= 0 || s.Cmp(N) &gt;= 0 { return false } e := hashToInt(hash, c) //e即哈希 var w *big.Int //求s在有限域GF(P)的逆，即1/s if in, ok := c.(invertible); ok { w = in.Inverse(s) } else { w = new(big.Int).ModInverse(s, N) } u1 := e.Mul(e, w) //即e/s u1.Mod(u1, N) u2 := w.Mul(r, w) //即r/s u2.Mod(u2, N) var x, y *big.Int if opt, ok := c.(combinedMult); ok { x, y = opt.CombinedMult(pub.X, pub.Y, u1.Bytes(), u2.Bytes()) } else { x1, y1 := c.ScalarBaseMult(u1.Bytes()) //即eG/s x2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes()) //即DGr/s //即eG/s + DGr/s = (e + Dr)G/s //= (e + Dr)kG / (e + DkG) = (e + Dr)r / (e + Dr) = r x, y = c.Add(x1, y1, x2, y2) } if x.Sign() == 0 &amp;&amp; y.Sign() == 0 { return false } x.Mod(x, N) return x.Cmp(r) == 0 } 使用如下： package main import ( &quot;crypto/ecdsa&quot; &quot;crypto/elliptic&quot; &quot;crypto/rand&quot; &quot;log&quot; &quot;fmt&quot; &quot;crypto/sha256&quot; ) func main() { // 先获取一个椭圆实例 curve := elliptic.P256() //得到私钥 privateKey, err := ecdsa.GenerateKey(curve, rand.Reader) if err != nil { log.Panic(err) } //产生公钥 publicKey := privateKey.PublicKey fmt.Println(&quot;priKey&quot;, privateKey, &quot;\\npubKey&quot;, publicKey) strHash := sha256.New().Sum([]byte( &quot;我是学生&quot;)) // 签名 r, s, err := ecdsa.Sign(rand.Reader, privateKey, strHash) if nil != err { log.Panic(err) } fmt.Println(&quot;r&quot;, r, &quot;\\ns&quot;, s) strHash2 := sha256.New().Sum([]byte(&quot;我是个程序员&quot;)) // 验签 fmt.Println(ecdsa.Verify(&amp;publicKey, strHash2, r, s)) // false fmt.Println(ecdsa.Verify(&amp;publicKey, strHash, r, s)) // true } 好了，以上就是对椭圆曲线加密的讲解，其实以太坊中不是直接用go的原生库crypto中的ecdsa哦，而是用了比特币所使用的一个C++的库 libsecp256k1，在目录：crypto/secp256k1 路径中。 &nbsp; 【本文还未写完，国庆这几天会完善完.......】 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/30/e9638786cb90240be42bdff2b0293250.html","headline":"【我的区块链之路】- go实现区块链中常见的各类算法","dateModified":"2018-09-30T00:00:00+08:00","datePublished":"2018-09-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/30/e9638786cb90240be42bdff2b0293250.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【我的区块链之路】- go实现区块链中常见的各类算法</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="color:#f33b45;">【转载请标明出处】</span><a href="https://blog.csdn.net/qq_25870633/article/details/82900508" rel="nofollow"><span style="color:#f33b45;">https://blog.csdn.net/qq_25870633/article/details/82900508</span></a></p> 
  <p>咳咳，为什么要出这一篇文章呢？首先，这段时间本人在找工作，然后被问到了各类算法的底层细节，有些确实很懵逼。这里做个总结，也顺便给大家归纳归纳一下！</p> 
  <p>上主题：</p> 
  <h1><span style="color:#f33b45;"><strong>椭圆曲线加密</strong></span><strong>：</strong></h1> 
  <p>我们先来说一说最常用的 ECC 吧，ECC 就是 Elliptic Curve Cryptography 的缩写。那么，在说椭圆曲线加密之前，我们来说一说什么是椭圆曲线？</p> 
  <p>中学的时候我们学过圆锥曲线，比如椭圆、双曲线和抛物线。因为描述这些曲线的方程都是二次方程，圆锥曲线又被称为二次曲线。而<span style="color:#f33b45;"><strong>椭圆曲线是则是由三次方程描述的一些曲线</strong></span>。更准确地说，<strong>椭圆曲线是由下面的方程描述的曲线</strong>：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930095510111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p><br> 需要注意的是，<strong><span style="color:#f33b45;">椭圆曲线之所以叫“椭圆曲线”，是因为其曲线方程跟利用微积分计算椭圆周长的公式相似</span></strong>。实际上它的图像跟椭圆完全不搭边。</p> 
  <p>&nbsp;</p> 
  <h3>如椭圆曲线 <span style="color:#f33b45;"><strong>y^2=x^3−x+1</strong></span> 的图像：</h3> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930095728468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <h2><strong>【注意】椭圆曲线有这样的两个性质：</strong></h2> 
  <ol>
   <li>关于X轴对称</li> 
   <li>画一条直线跟椭圆曲线相交，它们最多有三个交点</li> 
  </ol>
  <p>&nbsp;</p> 
  <h1><strong><span style="color:#f33b45;">椭圆曲线上的运算</span></strong></h1> 
  <p>由于椭圆曲线加密进行的运算实际上都是在椭圆曲线上进行的，必须注意的是，<span style="color:#f33b45;">这里把这些运算称为“加法”和“乘法”仅仅是方便描述，他们跟平时认知的加法和乘法完全是两码事，完全可以给他们取其它名字（比如”乘法“和”幂运算“等）</span>。总之就是规定，规定，规定(重要的事说三遍)</p> 
  <ul>
   <li> <p>首先定义坐标系中距离X轴无穷远点为椭圆曲线上的一个特殊点，称为<strong>0点</strong>。<br> 那么此时上述第二条性质可以加强为：过曲线上任意两点（可重合）的直线必定与曲线相交于第三点。</p> </li> 
   <li> <p>然后定义椭圆曲线上点的<span style="color:#f33b45;"><strong>加法</strong></span>。设椭圆曲线上有两点，A和B点，那么作过这两点的直线与该曲线相交于第三点（C点），然后关于X轴对称得到D点，则D为这两个点的和，记作<span style="color:#f33b45;"><strong>D=A+B&nbsp;</strong></span><strong>(注意： 这仅仅是规定)</strong>。很明显，<strong>D点也在该曲线上</strong>。所以<strong><span style="color:#3399ea;">椭圆曲线上两点之和也是曲线上的点</span></strong>。</p> </li> 
  </ul>
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930101614110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>特别地，如果两点重合，则作椭圆曲线在A点处的切线，与曲线相交于第二点（B点），然后关于X轴对称得到C点，则C点为A点与自身的和，记作<strong><span style="color:#f33b45;"> C =&nbsp; 2A</span></strong>。</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930101629605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <h2><strong>加法，我们可以得到以下结论：</strong></h2> 
  <ul>
   <li> <p>A+B = B+A<br> 也就是椭圆曲线上的加法满足交换律。</p> </li> 
   <li> <p>A+0 = A<br> 因为<span style="color:#f33b45;"><strong>0点是无穷远点</strong></span>，所以过A点与0点的直线是<span style="color:#f33b45;">垂直于X轴</span>的，它与曲线相交于另一点B点，那么B点关于X轴对称的点就是A点，即A点为A点和0点之和。</p> </li> 
  </ul>
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930102232375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>然后在加法的基础上，定义椭圆曲线上点的<strong>乘法。</strong></p> 
  <h2><strong>乘法：(下列的也是一种规定，是规定)</strong></h2> 
  <p>设<strong><span style="color:#f33b45;">P是椭圆曲线上的一个点</span></strong>，那么正整数k乘以点P的结果由下面的式子定义，注意式子中的加法是上面提到的椭圆曲线上点的加法：</p> 
  <p>&nbsp;</p> 
  <h1><strong>1∗P=P1<br> 2∗P=P+P<br> 3∗P=2∗P+P<br> …&nbsp;<br> k∗P=(k−1)∗P+P</strong></h1> 
  <p>乘法满足以下性质：</p> 
  <blockquote> 
   <p>对于任意正整数k和j，有&nbsp;<br> k∗(j∗P) = (kj)∗P = (jk)∗P = j∗(k∗P)</p> 
  </blockquote> 
  <h1><strong>知道公钥反推私钥：</strong></h1> 
  <h2><strong>k</strong><span style="color:#f33b45;"><strong> 为正整数，</strong></span><strong>P</strong><span style="color:#f33b45;"><strong> 是椭圆曲线上的点（称为基点），已知 </strong></span><strong>k∗P</strong><span style="color:#f33b45;"><strong> 和</strong></span><strong> P</strong><span style="color:#f33b45;"><strong>，计算 </strong></span><strong>k</strong></h2> 
  <p><strong>进一步为：</strong></p> 
  <p>&nbsp;</p> 
  <h2><strong>k </strong><span style="color:#f33b45;"><strong>为正整数，</strong></span><strong>P</strong><span style="color:#f33b45;"><strong> 是椭圆曲线上的点，已知 </strong></span><strong>P^k</strong><span style="color:#f33b45;"><strong> 和 </strong></span><strong>P</strong><span style="color:#f33b45;"><strong>，计算 </strong></span><strong>k = logP P^k</strong></h2> 
  <p>&nbsp;</p> 
  <p><span style="color:#3399ea;"><strong>以上，是复杂度很高的操作，公钥反推私钥很难求 （在椭圆曲线算法中很难求）</strong></span></p> 
  <h1><span style="color:#f33b45;"><strong>【注意】：</strong></span></h1> 
  <p>密码学中，并不能使用上面介绍的实数域上的椭圆曲线。因为：<br> 1. 实数域上的椭圆曲线是连续的，有无限个点，<strong><span style="color:#f33b45;">密码学要求有限点</span></strong>。<br> 2. 实数域上的椭圆曲线的运算有误差，不精确。<span style="color:#f33b45;"><strong>密码学要求精确</strong></span>。</p> 
  <p>所以我们需要引入<span style="color:#f33b45;"><strong>有限域上的椭圆曲线</strong></span>。</p> 
  <p>&nbsp;</p> 
  <h1><strong>有限域上的椭圆曲线：</strong></h1> 
  <p>所谓有限域上的椭圆曲线，简单来说就是满足下面式子要求的曲线（x, y, a, b都是小于素数【也即是质数】p的 非负整数）：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930105158512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>对比一下原先的椭圆曲线的方程：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930105333728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>可以看到这个<strong><span style="color:#f33b45;">只是对原式进行了简单的取模处理而已</span></strong>。</p> 
  <p>按数论定义，<strong>有限域GF(p)指给定某个质数p，由<span style="color:#f33b45;">0、1、2......p-1</span>共p个元素组成的整数集合</strong>。且方程的坐标点满足了在有限域中定义的加减乘除运算的结果也应该是在域中。</p> 
  <p>假设椭圆曲线为 y² = x³ + x + 1，其在有限域GF(23)上时，写作：<br> 　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p> 
  <h1>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp; y² ≡ x³ + x + 1 (mod 23)</strong></h1> 
  <p><span style="color:#f33b45;"><strong>此时，椭圆曲线不再是一条光滑曲线，而是一些不连续的点</strong></span>，如以点(1,7)为例，7² ≡ 1³ + 1 + 1 ≡ 3 (mod 23)。如此还有如下点：<br> &nbsp;<br> 　　(0,1) (0,22)<br> 　　(1,7) (1,16)<br> 　　(3,10) (3,13)<br> 　　(4,0)<br> 　　(5,4) (5,19)<br> 　　(6,4) (6,19)<br> 　　(7,11) (7,12)<br> 　　(9,7) (9,16)<br> 　　(11,3) (11,20)<br> 　　等等。<br> &nbsp;<br> 另外，如果P(x,y)为椭圆曲线上的点，则-P即(x,-y)也为椭圆曲线上的点。如点P(0,1)，-P=(0,-1)=(0,22)也为椭圆曲线上的点。看图：（<strong>该图的点全部以 <span style="color:#f33b45;">y = 23/2</span> 对称</strong>）并不代表着关于某水平线对称哦,参考：<a href="https://www.cnblogs.com/X-knight/p/9153209.html" rel="nofollow">https://www.cnblogs.com/X-knight/p/9153209.html</a></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930111954534?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>又如下图是椭圆曲线<strong><span style="color:#f33b45;"> y²&nbsp;= x³−x+1 </span></strong>对素数<strong><span style="color:#f33b45;">97</span></strong>取模后的图像：</p> 
  <p><img alt="" class="has" src="https://cdn.arstechnica.net/wp-content/uploads/2013/10/elliptic-curve-crypt-image06-640x456.png"></p> 
  <p>原本连续光滑的曲线变成了离散的点，基本已经面目全非了，但是依然可以看到它是关于某条水平直线（<span style="color:#f33b45;">y= 97/2</span>）对称的。<strong>而且上面定义的椭圆曲线的加法仍然可用（当然乘法也可以）</strong>。</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://cdn.arstechnica.net/wp-content/uploads/2013/10/elliptic-curve-crypt-image01.gif"></p> 
  <p>【注意】：密码学中有限域上的椭圆曲线一般有两种，一种是定义在以素数p为模的整数域GF(p)，也就是上面介绍的；另一种则是定义在特征为 2 的伽罗瓦域 GF(<span style="color:#f33b45;">2^m</span>)上。<br> &nbsp;</p> 
  <p>好了我们下面来看看，逼逼了这么久我们到底是要做什么？</p> 
  <h1><span style="color:#f33b45;"><strong>用生成的</strong></span><strong>私钥 </strong><span style="color:#f33b45;"><strong>+ </strong></span><strong>椭圆曲线</strong><span style="color:#f33b45;"><strong> 求 </strong></span><strong>公钥的过程就是计算xG的坐标的过程</strong></h1> 
  <h3>计算 xG 就是 【私钥 * 基点 = 公钥】</h3> 
  <p>&nbsp;<br> 　　相关公式如下：<br> 　　有限域GF(p)上的椭圆曲线 y² = x³ + ax + b，若P(Xp, Yp), Q(Xq, Yq)，且P≠-Q，则R(Xr,Yr) = P+Q 由如下规则确定：<br> &nbsp;<br> 　<strong>　Xr = (λ² - Xp - Xq) mod p<br> 　　Yr = (λ(Xp - Xr) - Yp) mod p</strong></p> 
  <p><br> 　　其中【公式 1】&nbsp;<strong><span style="color:#f33b45;">λ = (Yq - Yp)/(Xq - Xp) mod p</span></strong>（若P≠Q）,&nbsp;【公式 2】<span style="color:#f33b45;"> <strong>λ = (3Xp² + a)/2Yp mod p</strong></span>（若P=Q）<br> &nbsp;<br> 　　因此，有限域GF(23)上的椭圆曲线 y² ≡ x³ + x + 1 (mod 23)，假设以<span style="color:#f33b45;"><strong>(0,1)</strong></span>为G点，计算2G、3G、4G...xG等等，方法如下：<br> &nbsp;<br> 　<strong>　计算2G：</strong></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;2G = G + G ，所以用 【公式 2】求&nbsp;λ<br> 　　λ = (3x0² + 1)/2x1 mod 23 = (1/2) mod 23 = 12<br> 　　Xr = (12² - 0 - 0) mod 23 = 6<br> 　　Yr = (12(0 - 6) - 1) mod 23 = 19<br> 　　即2G为点(6,19)<br> &nbsp;<br> 　<strong>　计算3G：</strong><br> 　　3G = G + 2G，即(0,1) + (6,19)，用【公式 1】求&nbsp;λ<br> 　　λ = (19 - 1)/(6 - 0) mod 23 = 3<br> 　　Xr = (3² - 0 - 6) mod 23 = 3<br> 　　Yr = (3(0 - 3) - 1) mod 23 = 13<br> 　　即3G为点(3, 13)<br> &nbsp;<br> 　　同理计算4G、5G...<span style="color:#f33b45;"><strong>xG</strong></span>，分布如下图：<br> &nbsp;<br><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180930113724797?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <h1><strong>所以，上述就是在说，我们如何根据 提前生成好的私钥 <span style="color:#f33b45;">X</span> (私钥 可以是有某种随机算法求出来的一个 数字) 和 选定的椭圆曲线 （如：<span style="color:#f33b45;">Curve25519，prime256v1，secp256k1</span>）(以上曲线均为有限质数域下的椭圆曲线，表现为 离散的点，根据 y = 质数P/2 水平线对称)，求出 公式&nbsp; <span style="color:#f33b45;">XG</span> 点的 坐标 (x ,y) 既是组成<span style="color:#f33b45;">公钥</span>的 x 和 y。（其中 <span style="color:#f33b45;">G</span> 为选好的椭圆曲线上的基点,即 (x，y) == （0, 0）求出来的曲线上的坐标点，XG 也是曲线上的一点。</strong></h1> 
  <p><span style="color:#f33b45;"><strong>实际应用中，我们并不需要关心椭圆曲线的众多参数如何选取（要选对</strong></span><strong>参数&nbsp;</strong>a, b&nbsp;<span style="color:#f33b45;"><strong>对于普通使用者来说并不现实），只要从密码学家们精心挑选的一堆曲线中选择一个就行了。一般来说曲线Curve25519，prime256v1是比较常用的，比特币选择secp256k1则是有自己的考量</strong></span></p> 
  <p><br><strong>建立基于椭圆曲线的加密机制，需要找到类似RSA质因子分解或其他求离散对数这样的难题</strong>。而<span style="color:#f33b45;"><strong>椭圆曲线上的已知G和xG求x，是非常困难的</strong></span><strong>(为什么呢？请看计算出XG的步骤就知道的，每一步的 </strong>λ&nbsp;都是不一样的<strong>)，此即为椭圆曲线上的的离散对数问题。此处x即为</strong><span style="color:#f33b45;"><strong>私钥</strong></span><strong>，xG即为</strong><span style="color:#f33b45;"><strong>公钥</strong></span>。</p> 
  <h1><br> &nbsp;<br><strong><span style="color:#f33b45;">椭圆曲线加密算法原理</span>如下：</strong></h1> 
  <p><br> &nbsp;<br> 　　设私钥、公钥分别为k、Y，即Y = kG，其中<span style="color:#f33b45;">G为基点</span>。<br> &nbsp;<br> 　　<span style="color:#f33b45;"><strong>公钥加密</strong></span>：<br> 　　选择随机数r，将消息M生成密文C，该<strong>密文是一个<span style="color:#f33b45;">点对</span></strong>，即：<br> 　　C = <span style="color:#f33b45;"><strong>{rG, M+rY}</strong></span>，其中Y为公钥<br> &nbsp;<br> 　　<span style="color:#f33b45;"><strong>私钥解密</strong></span>：<br> 　　<strong>M + rY</strong> - k(rG) = M + r(kG) - k(rG) = M<br> 　　其中k、Y分别为私钥、公钥。</p> 
  <h1><span style="color:#f33b45;"><strong>椭圆曲线签名算法原理</strong></span></h1> 
  <p>&nbsp;<br> 　　椭圆曲线签名算法，即<span style="color:#f33b45;"><strong> ECDSA</strong></span>。<br> 　　设私钥、公钥分别为k、Y，即&nbsp;Y = kG，其中G为G点。<br> &nbsp;<br> 　　私钥签名：<br> 　　1、选择<strong>随机数 <span style="color:#f33b45;">r</span></strong>，计算点 <strong>rG(x, y)</strong>。<br> 　　2、根据随机数r、消息M的哈希h、<strong>私钥 <span style="color:#f33b45;">k</span></strong>，计算&nbsp;<span style="color:#f33b45;"><strong>s = (h + kx)/r</strong></span>。<br> 　　3、将消息M、和&nbsp;<span style="color:#f33b45;"><strong>签名{rG, s}</strong></span>发给接收方。<br> &nbsp;<br> 　　公钥验证签名：<br> 　　1、接收方收到消息M、以及签名{rG=(x,y), s}。<br> 　　2、根据消息求哈希h。<br> 　　3、使用发送方公钥K计算：<span style="color:#f33b45;"><strong>hG/s + xY/s</strong></span>，并与rG比较，如相等即验签成功。<br> &nbsp;<br> 　　原理如下：<br> 　　<span style="color:#f33b45;"><strong>hG/s + xY/s = hG/s + x(kG)/s = (h+xk)G/s<br> 　　= r(h+xk)G / (h+kx) =&nbsp; rG</strong></span></p> 
  <p>&nbsp;</p> 
  <p>详细可以参考：<a href="https://www.cnblogs.com/X-knight/p/9153209.html" rel="nofollow">https://www.cnblogs.com/X-knight/p/9153209.html</a></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h1 id="diffiehellman密钥交换">Diffie–Hellman密钥交换 (DH)</h1> 
  <p>Diffie–Hellman密钥交换（以下简称DH）是用于双方在可能被窃听环境下安全交换密钥的一种方法。&nbsp;<br> 算法的安全性是由上面提到的离散对数难题保证。</p> 
  <p>&nbsp;</p> 
  <p>具体算法流程如下：</p> 
  <ul>
   <li>小红和小明约定 p 和 g 的值</li> 
  </ul>
  <ul>
   <li>小红生成私钥 x，计算 g^x mod p 作为 公钥 公布出去</li> 
  </ul>
  <ul>
   <li>小明生成私钥 y，计算 g^y mod p 作为 公钥 公布出去</li> 
  </ul>
  <p>&nbsp;</p> 
  <ul>
   <li>&nbsp; &nbsp; 小红得知 g^y mod p后，计算&nbsp;</li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^y mod p)^x mod p = (g^y)^x mod p = g^xy mod p</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>小明得到gxmodpgxmodp后，计算&nbsp;</li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (g^x mod p)^y mod p = (g^x)^y mod p = g^xy mod p</p> 
  <ul>
   <li>双方都得到了相同的密钥的ss，交换完毕</li> 
  </ul>
  <p>&nbsp;</p> 
  <p>上面的流程中，x 和 y 始终由两人自行保管的，第三方窃听得到的只有 p、g、g^x mod p和 g^y mod p这几个值。<br> 上面说过，离散对数是很难算的，所以第三方不能由这些信息计算出 x 或 y，也就没办法计算出密钥 s 了</p> 
  <p>&nbsp;</p> 
  <h1 id="基于椭圆曲线的dh密钥交换ecdh">基于椭圆曲线的DH密钥交换（ECDH）</h1> 
  <p>ECDH跟DH的流程基本是一致的。</p> 
  <ul>
   <li>小红和小明约定使用某条椭圆曲线（包括曲线参数，有限域参数以及基点P等）</li> 
  </ul>
  <ul>
   <li>小红生成私钥 x，计算 x∗P 作为公钥公布出去</li> 
   <li>小明生成私钥 y，计算 y∗P 作为公钥公布出去</li> 
  </ul>
  <p>&nbsp;</p> 
  <ul>
   <li>小红得知 y∗P 后，计算&nbsp;</li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;s = x∗(y∗P) = xy∗P</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>小明得到x∗Px∗P后，计算&nbsp;</li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;s = y∗(x∗P) = yx∗P</p> 
  <ul>
   <li>双方都得到了相同的密钥的ss，交换完毕</li> 
  </ul>
  <p>由于计算椭圆曲线上的离散对数是很难的，所以第三方没办法在只知道 x∗P 和 y∗P 的情况下计算出 x 或 y 的值。好了，下面我们来看看椭圆曲线的 go 代码实现吧。【主要为 go 原生的crypto/elliptic和crypto/ecdsa包下的代码分析】</p> 
  <p>如代码：</p> 
  <pre class="has">
<code class="language-Go">/**
曲线接口
库引用路径： crypto/elliptic
代码所在文件路径：src/crypto/elliptic/elliptic.go
*/
type Curve interface {
	// 获取椭圆曲线参数
	Params() *CurveParams
	// 某点是否在曲线上
	IsOnCurve(x, y *big.Int) bool
	// 加法 (x1,y1) + (x2,y2)
	Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int)
	// 二倍运算 2*(x,y)
	Double(x1, y1 *big.Int) (x, y *big.Int)
	// 即乘法 k*(Bx,By) 
	ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int)
	// 即 k*G 其中G 为基点.
	ScalarBaseMult(k []byte) (x, y *big.Int)
}</code></pre> 
  <p>上述代码是操作曲线 实现对象的，主要定义了判断曲线上的点，返回曲线的基本参数 (P, n, b，Gx，Gy，BitSize， Name)，及曲线上点的加法和乘法运算。</p> 
  <p>我们再看看，CurveParams 曲线的主要组成参数都是些什么：【其实CurveParams也就是 Curve 的实现】</p> 
  <pre class="has">
<code class="language-Go">/**
曲线的实现结构体
代码引用路径：crypto/elliptic
代码所在文件路径：src/crypto/elliptic/elliptic.go
*/
type CurveParams struct {
    //有限域GF(p)中质数p
    P       *big.Int
    //G点的阶
    //如果存在最小正整数n，使得nG=O∞，则n为G点的阶
    N       *big.Int
    //椭圆曲线方程y²= x³-3x+b中常数b
    B       *big.Int
    //G点(x,y)
    Gx, Gy  *big.Int
    //密钥长度
    BitSize int
    //椭圆曲线名称
    Name    string
}

func (curve *CurveParams) Params() *CurveParams {
    //获取椭圆曲线参数，即curve
    return curve
}

func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {
    //是否在曲线y²=x³-3x+b上
    // y² = x³ - 3x + b
	y2 := new(big.Int).Mul(y, y)
	y2.Mod(y2, curve.P)

	x3 := new(big.Int).Mul(x, x)
	x3.Mul(x3, x)

	threeX := new(big.Int).Lsh(x, 1)
	threeX.Add(threeX, x)

	x3.Sub(x3, threeX)
	x3.Add(x3, curve.B)
	x3.Mod(x3, curve.P)

	return x3.Cmp(y2) == 0
}

func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) {
    //加法运算，代码略
}

func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) {
    //二倍运算，代码略
}

func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {
    //k*(Bx,By)，代码略
}

func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int) {
    //k*G, G为基点，代码略
}
</code></pre> 
  <p>我们再往下看看公私钥对，及签名验签等操作的代码：</p> 
  <pre class="has">
<code class="language-Go">//代码位置src/crypto/ecdsa/ecdsa.go

// 公钥
type PublicKey struct {
    // 曲线实例
	elliptic.Curve
    // 公钥对应去上线的一点坐标 (即：kG的坐标，其中名k为私钥，G为基点)
	X, Y *big.Int
}

// 私钥
type PrivateKey struct {
    // 公钥实例
	PublicKey
    // 私钥的数字，即kG中的k
	D *big.Int
}


// 签名
// rand 随机写入流
// priv 私钥
// 待签名Hash
// @return r 签名的 {r, s}中的r
// @return s 签名的 {r, s}中的s
// @return err
func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {
    entropylen := (priv.Curve.Params().BitSize + 7) / 16
    if entropylen &gt; 32 {
        entropylen = 32
    }
    entropy := make([]byte, entropylen)
    _, err = io.ReadFull(rand, entropy)
    if err != nil {
        return
    }

    md := sha512.New()
    md.Write(priv.D.Bytes()) //私钥
    md.Write(entropy)
    md.Write(hash)
    key := md.Sum(nil)[:32]

    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, nil, err
    }

    csprng := cipher.StreamReader{
        R: zeroReader,
        S: cipher.NewCTR(block, []byte(aesIV)),
    }

    c := priv.PublicKey.Curve //椭圆曲线
    N := c.Params().N //G点的阶
    if N.Sign() == 0 {
        return nil, nil, errZeroParam
    }
    var k, kInv *big.Int
    for {
        for {
            //取随机数k
            k, err = randFieldElement(c, csprng)
            if err != nil {
                r = nil
                return
            }

            //求k在有限域GF(P)的逆，即1/k
            if in, ok := priv.Curve.(invertible); ok {
                kInv = in.Inverse(k)
            } else {
                kInv = fermatInverse(k, N) // N != 0
            }

            //求r = kG
            r, _ = priv.Curve.ScalarBaseMult(k.Bytes())
            r.Mod(r, N)
            if r.Sign() != 0 {
                break
            }
        }

        e := hashToInt(hash, c) //e即哈希
        s = new(big.Int).Mul(priv.D, r) //Dr，即DkG
        s.Add(s, e) //e+DkG
        s.Mul(s, kInv) //(e+DkG)/k
        s.Mod(s, N) // N != 0
        if s.Sign() != 0 {
            break
        }

        //签名为{r, s}，即{kG, (e+DkG)/k}
    }

    return
}

// 验签
// pub 公钥
// hash 等待和签名做对比的被签名的原文Hash (和 签名方法入参中的待签名Hash)
// r 签名的 {r, s}中的r
// s 签名的 {r, s}中的s
// @return bool 是否通过校验 true 是 false 否
func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
    c := pub.Curve //椭圆曲线
    N := c.Params().N //G点的阶

    if r.Sign() &lt;= 0 || s.Sign() &lt;= 0 {
        return false
    }
    if r.Cmp(N) &gt;= 0 || s.Cmp(N) &gt;= 0 {
        return false
    }
    e := hashToInt(hash, c) //e即哈希

    var w *big.Int
    //求s在有限域GF(P)的逆，即1/s
    if in, ok := c.(invertible); ok {
        w = in.Inverse(s)
    } else {
        w = new(big.Int).ModInverse(s, N)
    }

    u1 := e.Mul(e, w) //即e/s
    u1.Mod(u1, N)
    u2 := w.Mul(r, w) //即r/s
    u2.Mod(u2, N)

    var x, y *big.Int
    if opt, ok := c.(combinedMult); ok {
        x, y = opt.CombinedMult(pub.X, pub.Y, u1.Bytes(), u2.Bytes())
    } else {
        x1, y1 := c.ScalarBaseMult(u1.Bytes()) //即eG/s
        x2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes()) //即DGr/s
        //即eG/s + DGr/s = (e + Dr)G/s
        //= (e + Dr)kG / (e + DkG) = (e + Dr)r / (e + Dr) = r
        x, y = c.Add(x1, y1, x2, y2) 
    }

    if x.Sign() == 0 &amp;&amp; y.Sign() == 0 {
        return false
    }
    x.Mod(x, N)
    return x.Cmp(r) == 0
}</code></pre> 
  <p>使用如下：</p> 
  <pre class="has">
<code class="language-Go">package main
import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"log"
	"fmt"
	"crypto/sha256"
)
func main() {
	// 先获取一个椭圆实例
	curve := elliptic.P256()
	//得到私钥
	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		log.Panic(err)
	}
	//产生公钥
	publicKey := privateKey.PublicKey
	fmt.Println("priKey", privateKey, "\npubKey", publicKey)

	strHash := sha256.New().Sum([]byte( "我是学生"))
	// 签名
	r, s, err := ecdsa.Sign(rand.Reader, privateKey, strHash)
	if nil != err {
		log.Panic(err)
	}
	fmt.Println("r", r, "\ns", s)
	strHash2 := sha256.New().Sum([]byte("我是个程序员"))
	// 验签
	fmt.Println(ecdsa.Verify(&amp;publicKey, strHash2, r, s))  	// false
	fmt.Println(ecdsa.Verify(&amp;publicKey, strHash, r, s))	// true
}
</code></pre> 
  <p>好了，以上就是对椭圆曲线加密的讲解，其实<span style="color:#f33b45;"><strong>以太坊中不是直接用go的原生库crypto中的ecdsa</strong></span>哦，而是<strong>用了比特币所使用的一个C++的库</strong> <strong><span style="color:#f33b45;">libsecp256k1</span></strong>，在目录：<strong><span style="color:#f33b45;">crypto/secp256k1</span></strong> 路径中。</p> 
  <p>&nbsp;</p> 
  <p>【本文还未写完，国庆这几天会完善完.......】</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82900508,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82900508,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
