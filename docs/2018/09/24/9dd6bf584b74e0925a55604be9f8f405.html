<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链学习1.4-比特币源码的学习-比特币基础 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链学习1.4-比特币源码的学习-比特币基础" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1.3就已经提到区块链的四大技术组合，我认为还是有必要了解背后的原理的。下面做一个简要的介绍。 一. 区块链数据结构和数字签名算法 1.数据结构Merkel树 说到merkle树就不得不谈到交易，merkle树就是用于存放交易的 数据结构。如下图： 它是一个哈希二叉树，哈希的过程如上图所示。merkleroot表示整条链的交易摘要哈希值。 其中一个区块包含的信息如下： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 其中包含的信息： 1）元信息：size，version，time 2）挖矿信息：nonce，difficulty 3）交易数据：tx 4）交易摘要：merkleroot，previousblockhash 如下是一个链的示例： &nbsp; 其中有关merkle树的代码在&nbsp; consensus/merkle.cpp // Copyright (c) 2015-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #include &lt;consensus/merkle.h&gt; #include &lt;hash.h&gt; #include &lt;utilstrencodings.h&gt; /* WARNING! If you&#39;re reading this because you&#39;re learning about crypto and/or designing a new system that will use merkle trees, keep in mind that the following merkle tree algorithm has a serious flaw related to duplicate txids, resulting in a vulnerability (CVE-2012-2459). The reason is that if the number of hashes in the list at a given time is odd, the last one is duplicated before computing the next level (which is unusual in Merkle trees). This results in certain sequences of transactions leading to the same merkle root. For example, these two trees: A A / \ / \ B C B C / \ | / \ / \ D E F D E F F / \ / \ / \ / \ / \ / \ / \ 1 2 3 4 5 6 1 2 3 4 5 6 5 6 for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and 6 are repeated) result in the same root hash A (because the hash of both of (F) and (F,F) is C). The vulnerability results from being able to send a block with such a transaction list, with the same merkle root, and the same block hash as the original without duplication, resulting in failed validation. If the receiving node proceeds to mark that block as permanently invalid however, it will fail to accept further unmodified (and thus potentially valid) versions of the same block. We defend against this by detecting the case where we would hash two identical hashes at the end of the list together, and treating that identically to the block having an invalid merkle root. Assuming no double-SHA256 collisions, this will detect all known ways of changing the transactions without affecting the merkle root. */ uint256 ComputeMerkleRoot(std::vector&lt;uint256&gt; hashes, bool* mutated) { bool mutation = false; while (hashes.size() &gt; 1) {//if mutation is true,then it means that found a duplicate subtree if (mutated) { for (size_t pos = 0; pos + 1 &lt; hashes.size(); pos += 2) { if (hashes[pos] == hashes[pos + 1]) mutation = true; } } if (hashes.size() &amp; 1) { hashes.push_back(hashes.back()); } SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2); hashes.resize(hashes.size() / 2); } if (mutated) *mutated = mutation; if (hashes.size() == 0) return uint256(); return hashes[0]; } uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); for (size_t s = 0; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } uint256 BlockWitnessMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); leaves[0].SetNull(); // The witness hash of the coinbase is 0. for (size_t s = 1; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetWitnessHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } 2. 数字签名算法 2.1 椭圆曲线算法 椭圆曲线密码学（Elliptic curve cryptography），简称ECC，是一种建立公开密钥加密的算法，也就是非对称加密。类似的还有RSA，ElGamal算法等。ECC被公认为在给定密钥长度下最安全的加密算法。比特币中的公私钥生成以及签名算法ECDSA都是基于ECC的。下面简单介绍ECC以及ECDSA的原理。（我认为有高人能解释的更清楚，贴链接） 椭圆曲线加密算法 &nbsp; 2.2 HASH算法 其次就是哈希算法，SHA-256，此算法用途很广泛，比特币地址，公钥，挖矿工作量证明。 此处简要贴一下由公钥生成比特币的地址的实现过程： 在源码中SHA-256的实现：在 src/crypto/sha256.cpp 中，代码太长，此处就不贴了。具体解释注释基本写清了。 &nbsp; 二. 交易 2.1交易格式 现存的交易系统的固有思维是给每个人建立账户，账户里有余额。每次进行交易时，中央的交易系统会确认发起人是否有那么多钱，如果有，才会支付给要支付的人，交易才算成功。 而比特币的处理思路是没有个人的账户余额，他在记录历史上发生的交易记录，以未消费交易输出（UTXO）分布式的保存在区块链上，网络节点共同验证UTXO是否合法。区块链上的一笔交易，代表一组UTXO集合状态转换到另外一组UTXO集合状态。产生新的比特币时，UTXO集合大小会增加。那么个人的账户余额相当于可以消费UTXO的总额。 一笔交易的内容具体如下： { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } vin代表输入，每个输入都会包含一项scriptSig；vout代表输出，每个输出都会包含scriptPubKey。 比特币交易结构大致如下：见src/primitives/transaction.h /** An outpoint - a combination of a transaction hash and an index n into its vout */ class COutPoint /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ template&lt;typename Stream, typename TxType&gt; inline void UnserializeTransaction(TxType&amp; tx, Stream&amp; s) template&lt;typename Stream, typename TxType&gt; inline void SerializeTransaction(const TxType&amp; tx, Stream&amp; s) /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. */ class CTransaction /** A mutable version of CTransaction. */ struct CMutableTransaction 基本的结构如上，注释也都贴上了。具体在源码里面可以读到。 2.2 交易脚本 比特币脚本语言是专为比特币设计的程序语言。比特币脚本语言是非图灵完备语言，计算表达语言受到了一定的限制。 比特币脚本不支持循环；比特币的脚本可用内存和时间被限制；数据存在栈中，不支持定义变量。 2.3 UTXO 源码在src/coins.h // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_COINS_H #define BITCOIN_COINS_H #include &lt;primitives/transaction.h&gt; #include &lt;compressor.h&gt; #include &lt;core_memusage.h&gt; #include &lt;hash.h&gt; #include &lt;memusage.h&gt; #include &lt;serialize.h&gt; #include &lt;uint256.h&gt; #include &lt;assert.h&gt; #include &lt;stdint.h&gt; #include &lt;unordered_map&gt; /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, CTxOutCompressor(out)); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; class SaltedOutpointHasher { private: /** Salt */ const uint64_t k0, k1; public: SaltedOutpointHasher(); /** * This *must* return size_t. With Boost 1.46 on 32-bit systems the * unordered_map will behave unpredictably if the custom hasher returns a * uint64_t, resulting in failures when syncing the chain (#4634). */ size_t operator()(const COutPoint&amp; id) const { return SipHashUint256Extra(k0, k1, id.hash, id.n); } }; struct CCoinsCacheEntry { Coin coin; // The actual cached data. unsigned char flags; enum Flags { DIRTY = (1 &lt;&lt; 0), // This cache entry is potentially different from the version in the parent view. FRESH = (1 &lt;&lt; 1), // The parent view does not have this entry (or it is pruned). /* Note that FRESH is a performance optimization with which we can * erase coins that are fully spent if we know we do not need to * flush the changes to the parent cache. It is always safe to * not mark FRESH if that condition is not guaranteed. */ }; CCoinsCacheEntry() : flags(0) {} explicit CCoinsCacheEntry(Coin&amp;&amp; coin_) : coin(std::move(coin_)), flags(0) {} }; typedef std::unordered_map&lt;COutPoint, CCoinsCacheEntry, SaltedOutpointHasher&gt; CCoinsMap; /** Cursor for iterating over CoinsView state */ class CCoinsViewCursor { public: CCoinsViewCursor(const uint256 &amp;hashBlockIn): hashBlock(hashBlockIn) {} virtual ~CCoinsViewCursor() {} virtual bool GetKey(COutPoint &amp;key) const = 0; virtual bool GetValue(Coin &amp;coin) const = 0; virtual unsigned int GetValueSize() const = 0; virtual bool Valid() const = 0; virtual void Next() = 0; //! Get best block at the time this cursor was created const uint256 &amp;GetBestBlock() const { return hashBlock; } private: uint256 hashBlock; }; /** Abstract view on the open txout dataset. */ class CCoinsView { public: /** Retrieve the Coin (unspent transaction output) for a given outpoint. * Returns true only when an unspent coin was found, which is returned in coin. * When false is returned, coin&#39;s value is unspecified. */ virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; //! Just check whether a given outpoint is unspent. virtual bool HaveCoin(const COutPoint &amp;outpoint) const; //! Retrieve the block hash whose state this CCoinsView currently represents virtual uint256 GetBestBlock() const; //! Retrieve the range of blocks that may have been only partially written. //! If the database is in a consistent state, the result is the empty vector. //! Otherwise, a two-element vector is returned consisting of the new and //! the old block hash, in that order. virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; //! Do a bulk modification (multiple Coin changes + BestBlock change). //! The passed mapCoins can be modified. virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); //! Get a cursor to iterate over the whole state virtual CCoinsViewCursor *Cursor() const; //! As we use CCoinsViews polymorphically, have a virtual destructor virtual ~CCoinsView() {} //! Estimate database size (0 if not implemented) virtual size_t EstimateSize() const { return 0; } }; /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: CCoinsView *base; public: CCoinsViewBacked(CCoinsView *viewIn); bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; std::vector&lt;uint256&gt; GetHeadBlocks() const override; void SetBackend(CCoinsView &amp;viewIn); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor *Cursor() const override; size_t EstimateSize() const override; }; /** CCoinsView that adds a memory cache for transactions to another CCoinsView */ class CCoinsViewCache : public CCoinsViewBacked { protected: /** * Make mutable so that we can &quot;fill the cache&quot; even from Get-methods * declared as &quot;const&quot;. */ mutable uint256 hashBlock; mutable CCoinsMap cacheCoins; /* Cached dynamic memory usage for the inner Coin objects. */ mutable size_t cachedCoinsUsage; public: CCoinsViewCache(CCoinsView *baseIn); /** * By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache. */ CCoinsViewCache(const CCoinsViewCache &amp;) = delete; // Standard CCoinsView methods bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; void SetBestBlock(const uint256 &amp;hashBlock); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor* Cursor() const override { throw std::logic_error(&quot;CCoinsViewCache cursor iteration not supported.&quot;); } /** * Check if we have the given utxo already loaded in this cache. * The semantics are the same as HaveCoin(), but no calls to * the backing CCoinsView are made. */ bool HaveCoinInCache(const COutPoint &amp;outpoint) const; /** * Return a reference to Coin in the cache, or a pruned one if not found. This is * more efficient than GetCoin. * * Generally, do not hold the reference returned for more than a short scope. * While the current implementation allows for modifications to the contents * of the cache while holding the reference, this behavior should not be relied * on! To be safe, best to not hold the returned reference through any other * calls to this cache. */ const Coin&amp; AccessCoin(const COutPoint &amp;output) const; /** * Add a coin. Set potential_overwrite to true if a non-pruned version may * already exist. */ void AddCoin(const COutPoint&amp; outpoint, Coin&amp;&amp; coin, bool potential_overwrite); /** * Spend a coin. Pass moveto in order to get the deleted data. * If no unspent output exists for the passed outpoint, this call * has no effect. */ bool SpendCoin(const COutPoint &amp;outpoint, Coin* moveto = nullptr); /** * Push the modifications applied to this cache to its base. * Failure to call this method before destruction will cause the changes to be forgotten. * If false is returned, the state of this cache (and its backing view) will be undefined. */ bool Flush(); /** * Removes the UTXO with the given outpoint from the cache, if it is * not modified. */ void Uncache(const COutPoint &amp;outpoint); //! Calculate the size of the cache (in number of transaction outputs) unsigned int GetCacheSize() const; //! Calculate the size of the cache (in bytes) size_t DynamicMemoryUsage() const; /** * Amount of bitcoins coming in to a transaction * Note that lightweight clients may not know anything besides the hash of previous transactions, * so may not be able to calculate this. * * @param[in] tx transaction for which we are checking input total * @return Sum of value of all inputs (scriptSigs) */ CAmount GetValueIn(const CTransaction&amp; tx) const; //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view bool HaveInputs(const CTransaction&amp; tx) const; private: CCoinsMap::iterator FetchCoin(const COutPoint &amp;outpoint) const; }; //! Utility function to add all of a transaction&#39;s outputs to a cache. // When check is false, this assumes that overwrites are only possible for coinbase transactions. // When check is true, the underlying view may be queried to determine whether an addition is // an overwrite. // TODO: pass in a boolean to limit these possible overwrites to known // (pre-BIP34) cases. void AddCoins(CCoinsViewCache&amp; cache, const CTransaction&amp; tx, int nHeight, bool check = false); //! Utility function to find any unspent output with a given txid. // This function can be quite expensive because in the event of a transaction // which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK // lookups to database, so it should be used with care. const Coin&amp; AccessByTxid(const CCoinsViewCache&amp; cache, const uint256&amp; txid); #endif // BITCOIN_COINS_H &nbsp; 阅读更多" />
<meta property="og:description" content="1.3就已经提到区块链的四大技术组合，我认为还是有必要了解背后的原理的。下面做一个简要的介绍。 一. 区块链数据结构和数字签名算法 1.数据结构Merkel树 说到merkle树就不得不谈到交易，merkle树就是用于存放交易的 数据结构。如下图： 它是一个哈希二叉树，哈希的过程如上图所示。merkleroot表示整条链的交易摘要哈希值。 其中一个区块包含的信息如下： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 其中包含的信息： 1）元信息：size，version，time 2）挖矿信息：nonce，difficulty 3）交易数据：tx 4）交易摘要：merkleroot，previousblockhash 如下是一个链的示例： &nbsp; 其中有关merkle树的代码在&nbsp; consensus/merkle.cpp // Copyright (c) 2015-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #include &lt;consensus/merkle.h&gt; #include &lt;hash.h&gt; #include &lt;utilstrencodings.h&gt; /* WARNING! If you&#39;re reading this because you&#39;re learning about crypto and/or designing a new system that will use merkle trees, keep in mind that the following merkle tree algorithm has a serious flaw related to duplicate txids, resulting in a vulnerability (CVE-2012-2459). The reason is that if the number of hashes in the list at a given time is odd, the last one is duplicated before computing the next level (which is unusual in Merkle trees). This results in certain sequences of transactions leading to the same merkle root. For example, these two trees: A A / \ / \ B C B C / \ | / \ / \ D E F D E F F / \ / \ / \ / \ / \ / \ / \ 1 2 3 4 5 6 1 2 3 4 5 6 5 6 for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and 6 are repeated) result in the same root hash A (because the hash of both of (F) and (F,F) is C). The vulnerability results from being able to send a block with such a transaction list, with the same merkle root, and the same block hash as the original without duplication, resulting in failed validation. If the receiving node proceeds to mark that block as permanently invalid however, it will fail to accept further unmodified (and thus potentially valid) versions of the same block. We defend against this by detecting the case where we would hash two identical hashes at the end of the list together, and treating that identically to the block having an invalid merkle root. Assuming no double-SHA256 collisions, this will detect all known ways of changing the transactions without affecting the merkle root. */ uint256 ComputeMerkleRoot(std::vector&lt;uint256&gt; hashes, bool* mutated) { bool mutation = false; while (hashes.size() &gt; 1) {//if mutation is true,then it means that found a duplicate subtree if (mutated) { for (size_t pos = 0; pos + 1 &lt; hashes.size(); pos += 2) { if (hashes[pos] == hashes[pos + 1]) mutation = true; } } if (hashes.size() &amp; 1) { hashes.push_back(hashes.back()); } SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2); hashes.resize(hashes.size() / 2); } if (mutated) *mutated = mutation; if (hashes.size() == 0) return uint256(); return hashes[0]; } uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); for (size_t s = 0; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } uint256 BlockWitnessMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); leaves[0].SetNull(); // The witness hash of the coinbase is 0. for (size_t s = 1; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetWitnessHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } 2. 数字签名算法 2.1 椭圆曲线算法 椭圆曲线密码学（Elliptic curve cryptography），简称ECC，是一种建立公开密钥加密的算法，也就是非对称加密。类似的还有RSA，ElGamal算法等。ECC被公认为在给定密钥长度下最安全的加密算法。比特币中的公私钥生成以及签名算法ECDSA都是基于ECC的。下面简单介绍ECC以及ECDSA的原理。（我认为有高人能解释的更清楚，贴链接） 椭圆曲线加密算法 &nbsp; 2.2 HASH算法 其次就是哈希算法，SHA-256，此算法用途很广泛，比特币地址，公钥，挖矿工作量证明。 此处简要贴一下由公钥生成比特币的地址的实现过程： 在源码中SHA-256的实现：在 src/crypto/sha256.cpp 中，代码太长，此处就不贴了。具体解释注释基本写清了。 &nbsp; 二. 交易 2.1交易格式 现存的交易系统的固有思维是给每个人建立账户，账户里有余额。每次进行交易时，中央的交易系统会确认发起人是否有那么多钱，如果有，才会支付给要支付的人，交易才算成功。 而比特币的处理思路是没有个人的账户余额，他在记录历史上发生的交易记录，以未消费交易输出（UTXO）分布式的保存在区块链上，网络节点共同验证UTXO是否合法。区块链上的一笔交易，代表一组UTXO集合状态转换到另外一组UTXO集合状态。产生新的比特币时，UTXO集合大小会增加。那么个人的账户余额相当于可以消费UTXO的总额。 一笔交易的内容具体如下： { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } vin代表输入，每个输入都会包含一项scriptSig；vout代表输出，每个输出都会包含scriptPubKey。 比特币交易结构大致如下：见src/primitives/transaction.h /** An outpoint - a combination of a transaction hash and an index n into its vout */ class COutPoint /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ template&lt;typename Stream, typename TxType&gt; inline void UnserializeTransaction(TxType&amp; tx, Stream&amp; s) template&lt;typename Stream, typename TxType&gt; inline void SerializeTransaction(const TxType&amp; tx, Stream&amp; s) /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. */ class CTransaction /** A mutable version of CTransaction. */ struct CMutableTransaction 基本的结构如上，注释也都贴上了。具体在源码里面可以读到。 2.2 交易脚本 比特币脚本语言是专为比特币设计的程序语言。比特币脚本语言是非图灵完备语言，计算表达语言受到了一定的限制。 比特币脚本不支持循环；比特币的脚本可用内存和时间被限制；数据存在栈中，不支持定义变量。 2.3 UTXO 源码在src/coins.h // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_COINS_H #define BITCOIN_COINS_H #include &lt;primitives/transaction.h&gt; #include &lt;compressor.h&gt; #include &lt;core_memusage.h&gt; #include &lt;hash.h&gt; #include &lt;memusage.h&gt; #include &lt;serialize.h&gt; #include &lt;uint256.h&gt; #include &lt;assert.h&gt; #include &lt;stdint.h&gt; #include &lt;unordered_map&gt; /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, CTxOutCompressor(out)); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; class SaltedOutpointHasher { private: /** Salt */ const uint64_t k0, k1; public: SaltedOutpointHasher(); /** * This *must* return size_t. With Boost 1.46 on 32-bit systems the * unordered_map will behave unpredictably if the custom hasher returns a * uint64_t, resulting in failures when syncing the chain (#4634). */ size_t operator()(const COutPoint&amp; id) const { return SipHashUint256Extra(k0, k1, id.hash, id.n); } }; struct CCoinsCacheEntry { Coin coin; // The actual cached data. unsigned char flags; enum Flags { DIRTY = (1 &lt;&lt; 0), // This cache entry is potentially different from the version in the parent view. FRESH = (1 &lt;&lt; 1), // The parent view does not have this entry (or it is pruned). /* Note that FRESH is a performance optimization with which we can * erase coins that are fully spent if we know we do not need to * flush the changes to the parent cache. It is always safe to * not mark FRESH if that condition is not guaranteed. */ }; CCoinsCacheEntry() : flags(0) {} explicit CCoinsCacheEntry(Coin&amp;&amp; coin_) : coin(std::move(coin_)), flags(0) {} }; typedef std::unordered_map&lt;COutPoint, CCoinsCacheEntry, SaltedOutpointHasher&gt; CCoinsMap; /** Cursor for iterating over CoinsView state */ class CCoinsViewCursor { public: CCoinsViewCursor(const uint256 &amp;hashBlockIn): hashBlock(hashBlockIn) {} virtual ~CCoinsViewCursor() {} virtual bool GetKey(COutPoint &amp;key) const = 0; virtual bool GetValue(Coin &amp;coin) const = 0; virtual unsigned int GetValueSize() const = 0; virtual bool Valid() const = 0; virtual void Next() = 0; //! Get best block at the time this cursor was created const uint256 &amp;GetBestBlock() const { return hashBlock; } private: uint256 hashBlock; }; /** Abstract view on the open txout dataset. */ class CCoinsView { public: /** Retrieve the Coin (unspent transaction output) for a given outpoint. * Returns true only when an unspent coin was found, which is returned in coin. * When false is returned, coin&#39;s value is unspecified. */ virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; //! Just check whether a given outpoint is unspent. virtual bool HaveCoin(const COutPoint &amp;outpoint) const; //! Retrieve the block hash whose state this CCoinsView currently represents virtual uint256 GetBestBlock() const; //! Retrieve the range of blocks that may have been only partially written. //! If the database is in a consistent state, the result is the empty vector. //! Otherwise, a two-element vector is returned consisting of the new and //! the old block hash, in that order. virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; //! Do a bulk modification (multiple Coin changes + BestBlock change). //! The passed mapCoins can be modified. virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); //! Get a cursor to iterate over the whole state virtual CCoinsViewCursor *Cursor() const; //! As we use CCoinsViews polymorphically, have a virtual destructor virtual ~CCoinsView() {} //! Estimate database size (0 if not implemented) virtual size_t EstimateSize() const { return 0; } }; /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: CCoinsView *base; public: CCoinsViewBacked(CCoinsView *viewIn); bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; std::vector&lt;uint256&gt; GetHeadBlocks() const override; void SetBackend(CCoinsView &amp;viewIn); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor *Cursor() const override; size_t EstimateSize() const override; }; /** CCoinsView that adds a memory cache for transactions to another CCoinsView */ class CCoinsViewCache : public CCoinsViewBacked { protected: /** * Make mutable so that we can &quot;fill the cache&quot; even from Get-methods * declared as &quot;const&quot;. */ mutable uint256 hashBlock; mutable CCoinsMap cacheCoins; /* Cached dynamic memory usage for the inner Coin objects. */ mutable size_t cachedCoinsUsage; public: CCoinsViewCache(CCoinsView *baseIn); /** * By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache. */ CCoinsViewCache(const CCoinsViewCache &amp;) = delete; // Standard CCoinsView methods bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; void SetBestBlock(const uint256 &amp;hashBlock); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor* Cursor() const override { throw std::logic_error(&quot;CCoinsViewCache cursor iteration not supported.&quot;); } /** * Check if we have the given utxo already loaded in this cache. * The semantics are the same as HaveCoin(), but no calls to * the backing CCoinsView are made. */ bool HaveCoinInCache(const COutPoint &amp;outpoint) const; /** * Return a reference to Coin in the cache, or a pruned one if not found. This is * more efficient than GetCoin. * * Generally, do not hold the reference returned for more than a short scope. * While the current implementation allows for modifications to the contents * of the cache while holding the reference, this behavior should not be relied * on! To be safe, best to not hold the returned reference through any other * calls to this cache. */ const Coin&amp; AccessCoin(const COutPoint &amp;output) const; /** * Add a coin. Set potential_overwrite to true if a non-pruned version may * already exist. */ void AddCoin(const COutPoint&amp; outpoint, Coin&amp;&amp; coin, bool potential_overwrite); /** * Spend a coin. Pass moveto in order to get the deleted data. * If no unspent output exists for the passed outpoint, this call * has no effect. */ bool SpendCoin(const COutPoint &amp;outpoint, Coin* moveto = nullptr); /** * Push the modifications applied to this cache to its base. * Failure to call this method before destruction will cause the changes to be forgotten. * If false is returned, the state of this cache (and its backing view) will be undefined. */ bool Flush(); /** * Removes the UTXO with the given outpoint from the cache, if it is * not modified. */ void Uncache(const COutPoint &amp;outpoint); //! Calculate the size of the cache (in number of transaction outputs) unsigned int GetCacheSize() const; //! Calculate the size of the cache (in bytes) size_t DynamicMemoryUsage() const; /** * Amount of bitcoins coming in to a transaction * Note that lightweight clients may not know anything besides the hash of previous transactions, * so may not be able to calculate this. * * @param[in] tx transaction for which we are checking input total * @return Sum of value of all inputs (scriptSigs) */ CAmount GetValueIn(const CTransaction&amp; tx) const; //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view bool HaveInputs(const CTransaction&amp; tx) const; private: CCoinsMap::iterator FetchCoin(const COutPoint &amp;outpoint) const; }; //! Utility function to add all of a transaction&#39;s outputs to a cache. // When check is false, this assumes that overwrites are only possible for coinbase transactions. // When check is true, the underlying view may be queried to determine whether an addition is // an overwrite. // TODO: pass in a boolean to limit these possible overwrites to known // (pre-BIP34) cases. void AddCoins(CCoinsViewCache&amp; cache, const CTransaction&amp; tx, int nHeight, bool check = false); //! Utility function to find any unspent output with a given txid. // This function can be quite expensive because in the event of a transaction // which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK // lookups to database, so it should be used with care. const Coin&amp; AccessByTxid(const CCoinsViewCache&amp; cache, const uint256&amp; txid); #endif // BITCOIN_COINS_H &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/24/9dd6bf584b74e0925a55604be9f8f405.html" />
<meta property="og:url" content="https://mlh.app/2018/09/24/9dd6bf584b74e0925a55604be9f8f405.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1.3就已经提到区块链的四大技术组合，我认为还是有必要了解背后的原理的。下面做一个简要的介绍。 一. 区块链数据结构和数字签名算法 1.数据结构Merkel树 说到merkle树就不得不谈到交易，merkle树就是用于存放交易的 数据结构。如下图： 它是一个哈希二叉树，哈希的过程如上图所示。merkleroot表示整条链的交易摘要哈希值。 其中一个区块包含的信息如下： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 其中包含的信息： 1）元信息：size，version，time 2）挖矿信息：nonce，difficulty 3）交易数据：tx 4）交易摘要：merkleroot，previousblockhash 如下是一个链的示例： &nbsp; 其中有关merkle树的代码在&nbsp; consensus/merkle.cpp // Copyright (c) 2015-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #include &lt;consensus/merkle.h&gt; #include &lt;hash.h&gt; #include &lt;utilstrencodings.h&gt; /* WARNING! If you&#39;re reading this because you&#39;re learning about crypto and/or designing a new system that will use merkle trees, keep in mind that the following merkle tree algorithm has a serious flaw related to duplicate txids, resulting in a vulnerability (CVE-2012-2459). The reason is that if the number of hashes in the list at a given time is odd, the last one is duplicated before computing the next level (which is unusual in Merkle trees). This results in certain sequences of transactions leading to the same merkle root. For example, these two trees: A A / \\ / \\ B C B C / \\ | / \\ / \\ D E F D E F F / \\ / \\ / \\ / \\ / \\ / \\ / \\ 1 2 3 4 5 6 1 2 3 4 5 6 5 6 for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and 6 are repeated) result in the same root hash A (because the hash of both of (F) and (F,F) is C). The vulnerability results from being able to send a block with such a transaction list, with the same merkle root, and the same block hash as the original without duplication, resulting in failed validation. If the receiving node proceeds to mark that block as permanently invalid however, it will fail to accept further unmodified (and thus potentially valid) versions of the same block. We defend against this by detecting the case where we would hash two identical hashes at the end of the list together, and treating that identically to the block having an invalid merkle root. Assuming no double-SHA256 collisions, this will detect all known ways of changing the transactions without affecting the merkle root. */ uint256 ComputeMerkleRoot(std::vector&lt;uint256&gt; hashes, bool* mutated) { bool mutation = false; while (hashes.size() &gt; 1) {//if mutation is true,then it means that found a duplicate subtree if (mutated) { for (size_t pos = 0; pos + 1 &lt; hashes.size(); pos += 2) { if (hashes[pos] == hashes[pos + 1]) mutation = true; } } if (hashes.size() &amp; 1) { hashes.push_back(hashes.back()); } SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2); hashes.resize(hashes.size() / 2); } if (mutated) *mutated = mutation; if (hashes.size() == 0) return uint256(); return hashes[0]; } uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); for (size_t s = 0; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } uint256 BlockWitnessMerkleRoot(const CBlock&amp; block, bool* mutated) { std::vector&lt;uint256&gt; leaves; leaves.resize(block.vtx.size()); leaves[0].SetNull(); // The witness hash of the coinbase is 0. for (size_t s = 1; s &lt; block.vtx.size(); s++) { leaves[s] = block.vtx[s]-&gt;GetWitnessHash(); } return ComputeMerkleRoot(std::move(leaves), mutated); } 2. 数字签名算法 2.1 椭圆曲线算法 椭圆曲线密码学（Elliptic curve cryptography），简称ECC，是一种建立公开密钥加密的算法，也就是非对称加密。类似的还有RSA，ElGamal算法等。ECC被公认为在给定密钥长度下最安全的加密算法。比特币中的公私钥生成以及签名算法ECDSA都是基于ECC的。下面简单介绍ECC以及ECDSA的原理。（我认为有高人能解释的更清楚，贴链接） 椭圆曲线加密算法 &nbsp; 2.2 HASH算法 其次就是哈希算法，SHA-256，此算法用途很广泛，比特币地址，公钥，挖矿工作量证明。 此处简要贴一下由公钥生成比特币的地址的实现过程： 在源码中SHA-256的实现：在 src/crypto/sha256.cpp 中，代码太长，此处就不贴了。具体解释注释基本写清了。 &nbsp; 二. 交易 2.1交易格式 现存的交易系统的固有思维是给每个人建立账户，账户里有余额。每次进行交易时，中央的交易系统会确认发起人是否有那么多钱，如果有，才会支付给要支付的人，交易才算成功。 而比特币的处理思路是没有个人的账户余额，他在记录历史上发生的交易记录，以未消费交易输出（UTXO）分布式的保存在区块链上，网络节点共同验证UTXO是否合法。区块链上的一笔交易，代表一组UTXO集合状态转换到另外一组UTXO集合状态。产生新的比特币时，UTXO集合大小会增加。那么个人的账户余额相当于可以消费UTXO的总额。 一笔交易的内容具体如下： { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } vin代表输入，每个输入都会包含一项scriptSig；vout代表输出，每个输出都会包含scriptPubKey。 比特币交易结构大致如下：见src/primitives/transaction.h /** An outpoint - a combination of a transaction hash and an index n into its vout */ class COutPoint /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ template&lt;typename Stream, typename TxType&gt; inline void UnserializeTransaction(TxType&amp; tx, Stream&amp; s) template&lt;typename Stream, typename TxType&gt; inline void SerializeTransaction(const TxType&amp; tx, Stream&amp; s) /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. */ class CTransaction /** A mutable version of CTransaction. */ struct CMutableTransaction 基本的结构如上，注释也都贴上了。具体在源码里面可以读到。 2.2 交易脚本 比特币脚本语言是专为比特币设计的程序语言。比特币脚本语言是非图灵完备语言，计算表达语言受到了一定的限制。 比特币脚本不支持循环；比特币的脚本可用内存和时间被限制；数据存在栈中，不支持定义变量。 2.3 UTXO 源码在src/coins.h // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_COINS_H #define BITCOIN_COINS_H #include &lt;primitives/transaction.h&gt; #include &lt;compressor.h&gt; #include &lt;core_memusage.h&gt; #include &lt;hash.h&gt; #include &lt;memusage.h&gt; #include &lt;serialize.h&gt; #include &lt;uint256.h&gt; #include &lt;assert.h&gt; #include &lt;stdint.h&gt; #include &lt;unordered_map&gt; /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, CTxOutCompressor(out)); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; class SaltedOutpointHasher { private: /** Salt */ const uint64_t k0, k1; public: SaltedOutpointHasher(); /** * This *must* return size_t. With Boost 1.46 on 32-bit systems the * unordered_map will behave unpredictably if the custom hasher returns a * uint64_t, resulting in failures when syncing the chain (#4634). */ size_t operator()(const COutPoint&amp; id) const { return SipHashUint256Extra(k0, k1, id.hash, id.n); } }; struct CCoinsCacheEntry { Coin coin; // The actual cached data. unsigned char flags; enum Flags { DIRTY = (1 &lt;&lt; 0), // This cache entry is potentially different from the version in the parent view. FRESH = (1 &lt;&lt; 1), // The parent view does not have this entry (or it is pruned). /* Note that FRESH is a performance optimization with which we can * erase coins that are fully spent if we know we do not need to * flush the changes to the parent cache. It is always safe to * not mark FRESH if that condition is not guaranteed. */ }; CCoinsCacheEntry() : flags(0) {} explicit CCoinsCacheEntry(Coin&amp;&amp; coin_) : coin(std::move(coin_)), flags(0) {} }; typedef std::unordered_map&lt;COutPoint, CCoinsCacheEntry, SaltedOutpointHasher&gt; CCoinsMap; /** Cursor for iterating over CoinsView state */ class CCoinsViewCursor { public: CCoinsViewCursor(const uint256 &amp;hashBlockIn): hashBlock(hashBlockIn) {} virtual ~CCoinsViewCursor() {} virtual bool GetKey(COutPoint &amp;key) const = 0; virtual bool GetValue(Coin &amp;coin) const = 0; virtual unsigned int GetValueSize() const = 0; virtual bool Valid() const = 0; virtual void Next() = 0; //! Get best block at the time this cursor was created const uint256 &amp;GetBestBlock() const { return hashBlock; } private: uint256 hashBlock; }; /** Abstract view on the open txout dataset. */ class CCoinsView { public: /** Retrieve the Coin (unspent transaction output) for a given outpoint. * Returns true only when an unspent coin was found, which is returned in coin. * When false is returned, coin&#39;s value is unspecified. */ virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; //! Just check whether a given outpoint is unspent. virtual bool HaveCoin(const COutPoint &amp;outpoint) const; //! Retrieve the block hash whose state this CCoinsView currently represents virtual uint256 GetBestBlock() const; //! Retrieve the range of blocks that may have been only partially written. //! If the database is in a consistent state, the result is the empty vector. //! Otherwise, a two-element vector is returned consisting of the new and //! the old block hash, in that order. virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; //! Do a bulk modification (multiple Coin changes + BestBlock change). //! The passed mapCoins can be modified. virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); //! Get a cursor to iterate over the whole state virtual CCoinsViewCursor *Cursor() const; //! As we use CCoinsViews polymorphically, have a virtual destructor virtual ~CCoinsView() {} //! Estimate database size (0 if not implemented) virtual size_t EstimateSize() const { return 0; } }; /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: CCoinsView *base; public: CCoinsViewBacked(CCoinsView *viewIn); bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; std::vector&lt;uint256&gt; GetHeadBlocks() const override; void SetBackend(CCoinsView &amp;viewIn); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor *Cursor() const override; size_t EstimateSize() const override; }; /** CCoinsView that adds a memory cache for transactions to another CCoinsView */ class CCoinsViewCache : public CCoinsViewBacked { protected: /** * Make mutable so that we can &quot;fill the cache&quot; even from Get-methods * declared as &quot;const&quot;. */ mutable uint256 hashBlock; mutable CCoinsMap cacheCoins; /* Cached dynamic memory usage for the inner Coin objects. */ mutable size_t cachedCoinsUsage; public: CCoinsViewCache(CCoinsView *baseIn); /** * By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache. */ CCoinsViewCache(const CCoinsViewCache &amp;) = delete; // Standard CCoinsView methods bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; bool HaveCoin(const COutPoint &amp;outpoint) const override; uint256 GetBestBlock() const override; void SetBestBlock(const uint256 &amp;hashBlock); bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override; CCoinsViewCursor* Cursor() const override { throw std::logic_error(&quot;CCoinsViewCache cursor iteration not supported.&quot;); } /** * Check if we have the given utxo already loaded in this cache. * The semantics are the same as HaveCoin(), but no calls to * the backing CCoinsView are made. */ bool HaveCoinInCache(const COutPoint &amp;outpoint) const; /** * Return a reference to Coin in the cache, or a pruned one if not found. This is * more efficient than GetCoin. * * Generally, do not hold the reference returned for more than a short scope. * While the current implementation allows for modifications to the contents * of the cache while holding the reference, this behavior should not be relied * on! To be safe, best to not hold the returned reference through any other * calls to this cache. */ const Coin&amp; AccessCoin(const COutPoint &amp;output) const; /** * Add a coin. Set potential_overwrite to true if a non-pruned version may * already exist. */ void AddCoin(const COutPoint&amp; outpoint, Coin&amp;&amp; coin, bool potential_overwrite); /** * Spend a coin. Pass moveto in order to get the deleted data. * If no unspent output exists for the passed outpoint, this call * has no effect. */ bool SpendCoin(const COutPoint &amp;outpoint, Coin* moveto = nullptr); /** * Push the modifications applied to this cache to its base. * Failure to call this method before destruction will cause the changes to be forgotten. * If false is returned, the state of this cache (and its backing view) will be undefined. */ bool Flush(); /** * Removes the UTXO with the given outpoint from the cache, if it is * not modified. */ void Uncache(const COutPoint &amp;outpoint); //! Calculate the size of the cache (in number of transaction outputs) unsigned int GetCacheSize() const; //! Calculate the size of the cache (in bytes) size_t DynamicMemoryUsage() const; /** * Amount of bitcoins coming in to a transaction * Note that lightweight clients may not know anything besides the hash of previous transactions, * so may not be able to calculate this. * * @param[in] tx transaction for which we are checking input total * @return Sum of value of all inputs (scriptSigs) */ CAmount GetValueIn(const CTransaction&amp; tx) const; //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view bool HaveInputs(const CTransaction&amp; tx) const; private: CCoinsMap::iterator FetchCoin(const COutPoint &amp;outpoint) const; }; //! Utility function to add all of a transaction&#39;s outputs to a cache. // When check is false, this assumes that overwrites are only possible for coinbase transactions. // When check is true, the underlying view may be queried to determine whether an addition is // an overwrite. // TODO: pass in a boolean to limit these possible overwrites to known // (pre-BIP34) cases. void AddCoins(CCoinsViewCache&amp; cache, const CTransaction&amp; tx, int nHeight, bool check = false); //! Utility function to find any unspent output with a given txid. // This function can be quite expensive because in the event of a transaction // which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK // lookups to database, so it should be used with care. const Coin&amp; AccessByTxid(const CCoinsViewCache&amp; cache, const uint256&amp; txid); #endif // BITCOIN_COINS_H &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/24/9dd6bf584b74e0925a55604be9f8f405.html","headline":"区块链学习1.4-比特币源码的学习-比特币基础","dateModified":"2018-09-24T00:00:00+08:00","datePublished":"2018-09-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/24/9dd6bf584b74e0925a55604be9f8f405.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链学习1.4-比特币源码的学习-比特币基础</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>1.3就已经提到区块链的四大技术组合，我认为还是有必要了解背后的原理的。下面做一个简要的介绍。</strong></p> 
  <h1>一. 区块链数据结构和数字签名算法</h1> 
  <h2>1.数据结构Merkel树</h2> 
  <p>说到merkle树就不得不谈到交易，merkle树就是用于存放交易的 数据结构。如下图：</p> 
  <p><img alt="WX20180224-010301@2x.png-61.3kB" class="has" src="http://static.zybuluo.com/renqHIT/far07jrcaeswpvnb6m89u30l/WX20180224-010301@2x.png"></p> 
  <p>它是一个哈希二叉树，哈希的过程如上图所示。merkleroot表示整条链的交易摘要哈希值。</p> 
  <p>其中一个区块包含的信息如下：</p> 
  <pre class="has">
<code>{
    "size": 43560,
    "version": 2,
    "previousblockhash": "00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249",
    "merkleroot": "5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d",
    "time": 1388185038,
    "difficulty": 1180923195.25802612,
    "nonce": 4215469401,
    "tx": ["257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77", # [...many more transactions omitted...]
        "05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"
    ]
}</code></pre> 
  <p>其中包含的信息：</p> 
  <p>1）元信息：size，version，time</p> 
  <p>2）挖矿信息：nonce，difficulty</p> 
  <p>3）交易数据：tx</p> 
  <p>4）交易摘要：merkleroot，previousblockhash</p> 
  <p>如下是一个链的示例：</p> 
  <p><img alt="WX20180224-004307@2x.png-337.5kB" class="has" src="http://static.zybuluo.com/renqHIT/ccfr1cl2ki0v8dbuh4vhaxzf/WX20180224-004307@2x.png"></p> 
  <p>&nbsp;</p> 
  <p>其中有关merkle树的代码在&nbsp; consensus/merkle.cpp</p> 
  <pre class="has">
<code>// Copyright (c) 2015-2017 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include &lt;consensus/merkle.h&gt;
#include &lt;hash.h&gt;
#include &lt;utilstrencodings.h&gt;

/*     WARNING! If you're reading this because you're learning about crypto
       and/or designing a new system that will use merkle trees, keep in mind
       that the following merkle tree algorithm has a serious flaw related to
       duplicate txids, resulting in a vulnerability (CVE-2012-2459).

       The reason is that if the number of hashes in the list at a given time
       is odd, the last one is duplicated before computing the next level (which
       is unusual in Merkle trees). This results in certain sequences of
       transactions leading to the same merkle root. For example, these two
       trees:

                    A               A
                  /  \            /   \
                B     C         B       C
               / \    |        / \     / \
              D   E   F       D   E   F   F
             / \ / \ / \     / \ / \ / \ / \
             1 2 3 4 5 6     1 2 3 4 5 6 5 6

       for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and
       6 are repeated) result in the same root hash A (because the hash of both
       of (F) and (F,F) is C).

       The vulnerability results from being able to send a block with such a
       transaction list, with the same merkle root, and the same block hash as
       the original without duplication, resulting in failed validation. If the
       receiving node proceeds to mark that block as permanently invalid
       however, it will fail to accept further unmodified (and thus potentially
       valid) versions of the same block. We defend against this by detecting
       the case where we would hash two identical hashes at the end of the list
       together, and treating that identically to the block having an invalid
       merkle root. Assuming no double-SHA256 collisions, this will detect all
       known ways of changing the transactions without affecting the merkle
       root.
*/


uint256 ComputeMerkleRoot(std::vector&lt;uint256&gt; hashes, bool* mutated) {
    bool mutation = false;
    while (hashes.size() &gt; 1) {//if mutation is true,then it means that found a duplicate subtree
        if (mutated) {
            for (size_t pos = 0; pos + 1 &lt; hashes.size(); pos += 2) {
                if (hashes[pos] == hashes[pos + 1])
                    mutation = true;
            }
        }
        if (hashes.size() &amp; 1) {
            hashes.push_back(hashes.back());
        }
        SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2);
        hashes.resize(hashes.size() / 2);
    }
    if (mutated)
        *mutated = mutation;
    if (hashes.size() == 0)
        return uint256();

    return hashes[0];
}


uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated)
{
    std::vector&lt;uint256&gt; leaves;
    leaves.resize(block.vtx.size());
    for (size_t s = 0; s &lt; block.vtx.size(); s++) {
        leaves[s] = block.vtx[s]-&gt;GetHash();
    }
    return ComputeMerkleRoot(std::move(leaves), mutated);
}

uint256 BlockWitnessMerkleRoot(const CBlock&amp; block, bool* mutated)
{
    std::vector&lt;uint256&gt; leaves;
    leaves.resize(block.vtx.size());
    leaves[0].SetNull(); // The witness hash of the coinbase is 0.
    for (size_t s = 1; s &lt; block.vtx.size(); s++) {
        leaves[s] = block.vtx[s]-&gt;GetWitnessHash();
    }
    return ComputeMerkleRoot(std::move(leaves), mutated);
}

</code></pre> 
  <h2>2. 数字签名算法</h2> 
  <h2>2.1 椭圆曲线算法</h2> 
  <p>椭圆曲线密码学（Elliptic curve cryptography），简称ECC，是一种建立公开密钥加密的算法，也就是非对称加密。类似的还有RSA，ElGamal算法等。ECC被公认为在给定密钥长度下最安全的加密算法。比特币中的公私钥生成以及签名算法ECDSA都是基于ECC的。下面简单介绍ECC以及ECDSA的原理。（我认为有高人能解释的更清楚，贴链接）</p> 
  <p><a href="https://juejin.im/post/5a67f3836fb9a01c9b661bd3" rel="nofollow">椭圆曲线加密算法</a></p> 
  <p>&nbsp;</p> 
  <h2>2.2 HASH算法</h2> 
  <p>其次就是哈希算法，SHA-256，此算法用途很广泛，比特币地址，公钥，挖矿工作量证明。</p> 
  <p>此处简要贴一下由公钥生成比特币的地址的实现过程：</p> 
  <p><img alt="公钥-比特币地址.png-158.2kB" class="has" src="http://static.zybuluo.com/renqHIT/aiypemwfigo9zizw50gjuwjz/%E5%85%AC%E9%92%A5-%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80.png"></p> 
  <p>在源码中SHA-256的实现：在 src/crypto/sha256.cpp 中，代码太长，此处就不贴了。具体解释注释基本写清了。</p> 
  <p>&nbsp;</p> 
  <h1>二. 交易</h1> 
  <h2>2.1交易格式</h2> 
  <p>现存的交易系统的固有思维是给每个人建立账户，账户里有余额。每次进行交易时，中央的交易系统会确认发起人是否有那么多钱，如果有，才会支付给要支付的人，交易才算成功。</p> 
  <p>而比特币的处理思路是没有个人的账户余额，他在记录历史上发生的交易记录，以未消费交易输出（UTXO）分布式的保存在区块链上，网络节点共同验证UTXO是否合法。区块链上的一笔交易，代表一组UTXO集合状态转换到另外一组UTXO集合状态。产生新的比特币时，UTXO集合大小会增加。那么个人的账户余额相当于可以消费UTXO的总额。</p> 
  <p>一笔交易的内容具体如下：</p> 
  <pre class="has">
<code>{
    "version": 1,
    "locktime": 0,
    "vin": [{
        "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
        "vout": 0,
        "scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
        "sequence": 4294967295
    }],
    "vout": [{
        "value": 0.01500000,
        "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG "
    }, {
        "value": 0.08450000,
        "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
    }]
}
</code></pre> 
  <p>vin代表输入，每个输入都会包含一项scriptSig；vout代表输出，每个输出都会包含scriptPubKey。</p> 
  <p>比特币交易结构大致如下：见src/primitives/transaction.h</p> 
  <pre class="has">
<code>/** An outpoint - a combination of a transaction hash and an index n into its vout */
class COutPoint


/** An input of a transaction.  It contains the location of the previous
 * transaction's output that it claims and a signature that matches the
 * output's public key.
 */
class CTxIn


/** An output of a transaction.  It contains the public key that the next input
 * must be able to sign with to claim it.
 */
class CTxOut


/**
 * Basic transaction serialization format:
 * - int32_t nVersion
 * - std::vector&lt;CTxIn&gt; vin
 * - std::vector&lt;CTxOut&gt; vout
 * - uint32_t nLockTime
 *
 * Extended transaction serialization format:
 * - int32_t nVersion
 * - unsigned char dummy = 0x00
 * - unsigned char flags (!= 0)
 * - std::vector&lt;CTxIn&gt; vin
 * - std::vector&lt;CTxOut&gt; vout
 * - if (flags &amp; 1):
 *   - CTxWitness wit;
 * - uint32_t nLockTime
 */
template&lt;typename Stream, typename TxType&gt;
inline void UnserializeTransaction(TxType&amp; tx, Stream&amp; s) 



template&lt;typename Stream, typename TxType&gt;
inline void SerializeTransaction(const TxType&amp; tx, Stream&amp; s)


/** The basic transaction that is broadcasted on the network and contained in
 * blocks.  A transaction can contain multiple inputs and outputs.
 */
class CTransaction


/** A mutable version of CTransaction. */
struct CMutableTransaction</code></pre> 
  <p>基本的结构如上，注释也都贴上了。具体在源码里面可以读到。</p> 
  <h2>2.2 交易脚本</h2> 
  <p>比特币脚本语言是专为比特币设计的程序语言。比特币脚本语言是非图灵完备语言，计算表达语言受到了一定的限制。</p> 
  <p>比特币脚本不支持循环；比特币的脚本可用内存和时间被限制；数据存在栈中，不支持定义变量。</p> 
  <h2>2.3 UTXO</h2> 
  <p>源码在src/coins.h</p> 
  <pre class="has">
<code>// Copyright (c) 2009-2010 Satoshi Nakamoto
// Copyright (c) 2009-2017 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef BITCOIN_COINS_H
#define BITCOIN_COINS_H

#include &lt;primitives/transaction.h&gt;
#include &lt;compressor.h&gt;
#include &lt;core_memusage.h&gt;
#include &lt;hash.h&gt;
#include &lt;memusage.h&gt;
#include &lt;serialize.h&gt;
#include &lt;uint256.h&gt;

#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;

#include &lt;unordered_map&gt;

/**
 * A UTXO entry.
 *
 * Serialized format:
 * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1))
 * - the non-spent CTxOut (via CTxOutCompressor)
 */
class Coin
{
public:
    //! unspent transaction output
    CTxOut out;

    //! whether containing transaction was a coinbase
    unsigned int fCoinBase : 1;

    //! at which height this containing transaction was included in the active block chain
    uint32_t nHeight : 31;

    //! construct a Coin from a CTxOut and height/coinbase information.
    Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}
    Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}

    void Clear() {
        out.SetNull();
        fCoinBase = false;
        nHeight = 0;
    }

    //! empty constructor
    Coin() : fCoinBase(false), nHeight(0) { }

    bool IsCoinBase() const {
        return fCoinBase;
    }

    template&lt;typename Stream&gt;
    void Serialize(Stream &amp;s) const {
        assert(!IsSpent());
        uint32_t code = nHeight * 2 + fCoinBase;
        ::Serialize(s, VARINT(code));
        ::Serialize(s, CTxOutCompressor(REF(out)));
    }

    template&lt;typename Stream&gt;
    void Unserialize(Stream &amp;s) {
        uint32_t code = 0;
        ::Unserialize(s, VARINT(code));
        nHeight = code &gt;&gt; 1;
        fCoinBase = code &amp; 1;
        ::Unserialize(s, CTxOutCompressor(out));
    }

    bool IsSpent() const {
        return out.IsNull();
    }

    size_t DynamicMemoryUsage() const {
        return memusage::DynamicUsage(out.scriptPubKey);
    }
};

class SaltedOutpointHasher
{
private:
    /** Salt */
    const uint64_t k0, k1;

public:
    SaltedOutpointHasher();

    /**
     * This *must* return size_t. With Boost 1.46 on 32-bit systems the
     * unordered_map will behave unpredictably if the custom hasher returns a
     * uint64_t, resulting in failures when syncing the chain (#4634).
     */
    size_t operator()(const COutPoint&amp; id) const {
        return SipHashUint256Extra(k0, k1, id.hash, id.n);
    }
};

struct CCoinsCacheEntry
{
    Coin coin; // The actual cached data.
    unsigned char flags;

    enum Flags {
        DIRTY = (1 &lt;&lt; 0), // This cache entry is potentially different from the version in the parent view.
        FRESH = (1 &lt;&lt; 1), // The parent view does not have this entry (or it is pruned).
        /* Note that FRESH is a performance optimization with which we can
         * erase coins that are fully spent if we know we do not need to
         * flush the changes to the parent cache.  It is always safe to
         * not mark FRESH if that condition is not guaranteed.
         */
    };

    CCoinsCacheEntry() : flags(0) {}
    explicit CCoinsCacheEntry(Coin&amp;&amp; coin_) : coin(std::move(coin_)), flags(0) {}
};

typedef std::unordered_map&lt;COutPoint, CCoinsCacheEntry, SaltedOutpointHasher&gt; CCoinsMap;

/** Cursor for iterating over CoinsView state */
class CCoinsViewCursor
{
public:
    CCoinsViewCursor(const uint256 &amp;hashBlockIn): hashBlock(hashBlockIn) {}
    virtual ~CCoinsViewCursor() {}

    virtual bool GetKey(COutPoint &amp;key) const = 0;
    virtual bool GetValue(Coin &amp;coin) const = 0;
    virtual unsigned int GetValueSize() const = 0;

    virtual bool Valid() const = 0;
    virtual void Next() = 0;

    //! Get best block at the time this cursor was created
    const uint256 &amp;GetBestBlock() const { return hashBlock; }
private:
    uint256 hashBlock;
};

/** Abstract view on the open txout dataset. */
class CCoinsView
{
public:
    /** Retrieve the Coin (unspent transaction output) for a given outpoint.
     *  Returns true only when an unspent coin was found, which is returned in coin.
     *  When false is returned, coin's value is unspecified.
     */
    virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const;

    //! Just check whether a given outpoint is unspent.
    virtual bool HaveCoin(const COutPoint &amp;outpoint) const;

    //! Retrieve the block hash whose state this CCoinsView currently represents
    virtual uint256 GetBestBlock() const;

    //! Retrieve the range of blocks that may have been only partially written.
    //! If the database is in a consistent state, the result is the empty vector.
    //! Otherwise, a two-element vector is returned consisting of the new and
    //! the old block hash, in that order.
    virtual std::vector&lt;uint256&gt; GetHeadBlocks() const;

    //! Do a bulk modification (multiple Coin changes + BestBlock change).
    //! The passed mapCoins can be modified.
    virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock);

    //! Get a cursor to iterate over the whole state
    virtual CCoinsViewCursor *Cursor() const;

    //! As we use CCoinsViews polymorphically, have a virtual destructor
    virtual ~CCoinsView() {}

    //! Estimate database size (0 if not implemented)
    virtual size_t EstimateSize() const { return 0; }
};


/** CCoinsView backed by another CCoinsView */
class CCoinsViewBacked : public CCoinsView
{
protected:
    CCoinsView *base;

public:
    CCoinsViewBacked(CCoinsView *viewIn);
    bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override;
    bool HaveCoin(const COutPoint &amp;outpoint) const override;
    uint256 GetBestBlock() const override;
    std::vector&lt;uint256&gt; GetHeadBlocks() const override;
    void SetBackend(CCoinsView &amp;viewIn);
    bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override;
    CCoinsViewCursor *Cursor() const override;
    size_t EstimateSize() const override;
};


/** CCoinsView that adds a memory cache for transactions to another CCoinsView */
class CCoinsViewCache : public CCoinsViewBacked
{
protected:
    /**
     * Make mutable so that we can "fill the cache" even from Get-methods
     * declared as "const".
     */
    mutable uint256 hashBlock;
    mutable CCoinsMap cacheCoins;

    /* Cached dynamic memory usage for the inner Coin objects. */
    mutable size_t cachedCoinsUsage;

public:
    CCoinsViewCache(CCoinsView *baseIn);

    /**
     * By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache.
     */
    CCoinsViewCache(const CCoinsViewCache &amp;) = delete;

    // Standard CCoinsView methods
    bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override;
    bool HaveCoin(const COutPoint &amp;outpoint) const override;
    uint256 GetBestBlock() const override;
    void SetBestBlock(const uint256 &amp;hashBlock);
    bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock) override;
    CCoinsViewCursor* Cursor() const override {
        throw std::logic_error("CCoinsViewCache cursor iteration not supported.");
    }

    /**
     * Check if we have the given utxo already loaded in this cache.
     * The semantics are the same as HaveCoin(), but no calls to
     * the backing CCoinsView are made.
     */
    bool HaveCoinInCache(const COutPoint &amp;outpoint) const;

    /**
     * Return a reference to Coin in the cache, or a pruned one if not found. This is
     * more efficient than GetCoin.
     *
     * Generally, do not hold the reference returned for more than a short scope.
     * While the current implementation allows for modifications to the contents
     * of the cache while holding the reference, this behavior should not be relied
     * on! To be safe, best to not hold the returned reference through any other
     * calls to this cache.
     */
    const Coin&amp; AccessCoin(const COutPoint &amp;output) const;

    /**
     * Add a coin. Set potential_overwrite to true if a non-pruned version may
     * already exist.
     */
    void AddCoin(const COutPoint&amp; outpoint, Coin&amp;&amp; coin, bool potential_overwrite);

    /**
     * Spend a coin. Pass moveto in order to get the deleted data.
     * If no unspent output exists for the passed outpoint, this call
     * has no effect.
     */
    bool SpendCoin(const COutPoint &amp;outpoint, Coin* moveto = nullptr);

    /**
     * Push the modifications applied to this cache to its base.
     * Failure to call this method before destruction will cause the changes to be forgotten.
     * If false is returned, the state of this cache (and its backing view) will be undefined.
     */
    bool Flush();

    /**
     * Removes the UTXO with the given outpoint from the cache, if it is
     * not modified.
     */
    void Uncache(const COutPoint &amp;outpoint);

    //! Calculate the size of the cache (in number of transaction outputs)
    unsigned int GetCacheSize() const;

    //! Calculate the size of the cache (in bytes)
    size_t DynamicMemoryUsage() const;

    /**
     * Amount of bitcoins coming in to a transaction
     * Note that lightweight clients may not know anything besides the hash of previous transactions,
     * so may not be able to calculate this.
     *
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)
     */
    CAmount GetValueIn(const CTransaction&amp; tx) const;

    //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view
    bool HaveInputs(const CTransaction&amp; tx) const;

private:
    CCoinsMap::iterator FetchCoin(const COutPoint &amp;outpoint) const;
};

//! Utility function to add all of a transaction's outputs to a cache.
// When check is false, this assumes that overwrites are only possible for coinbase transactions.
// When check is true, the underlying view may be queried to determine whether an addition is
// an overwrite.
// TODO: pass in a boolean to limit these possible overwrites to known
// (pre-BIP34) cases.
void AddCoins(CCoinsViewCache&amp; cache, const CTransaction&amp; tx, int nHeight, bool check = false);

//! Utility function to find any unspent output with a given txid.
// This function can be quite expensive because in the event of a transaction
// which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK
// lookups to database, so it should be used with care.
const Coin&amp; AccessByTxid(const CCoinsViewCache&amp; cache, const uint256&amp; txid);

#endif // BITCOIN_COINS_H

</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Billy1900/article/details/82826845,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Billy1900/article/details/82826845,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/Billy1900/article/details/82826845,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/Billy1900/article/details/82826845,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
