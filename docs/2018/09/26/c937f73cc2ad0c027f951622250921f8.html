<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《以太坊技术详解与实战》第2章 - 太坊架构和组成 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《以太坊技术详解与实战》第2章 - 太坊架构和组成" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yzpbright/article/details/82855245 2.1 以太坊整体架构 以太坊的整体架构如图 2-1 所示，分为三层：底层服务、核心层、顶层应用 。 ( 1 ）底层服务 底层服务包含 P2P 网络服务 、 LeveIDB 数据库、密码学算法以及分片（ Sharding ）优化等基础服务 。 P2P 网络中每一个节点彼此对等，各个节点共同提供服务，不存在任何特殊节点，网络中的节点能够生成或审核新数据 。 而以太坊中的区块、交易等数据最终都是被存储在 LeveIDB 数据库中 。 密码学算法用于保证数据的隐私性和区块链的安全。 分片优化使得可以并行验证交易，大大加快了区块生成速度 。 这些底层服务共同促使区块链系统平稳地运行 。 ( 2 ）核心层 核心层包含区块链、共识算法和以太坊虚拟机等核心元件，其以区块链技术为主体，辅以以太坊特有的共识算法，并以 EVM （以太坊虚拟机）作为运行智能合约的载体，该层是以太坊的核心组成部分。 区块链构造的去中心化账本需要解决的首要问题就是如何确保不同节点上的账本数据的一致性和正确性，而共识算法正是用于解决这个问题。 EVM 是以太坊的一个主要创新，它是以太坊中智能合约的运行环境，使得以太坊能够实现更复杂的逻辑 。 ( 3 ）顶层应用 这一层包括 API 接口、智能合约以及去中心化应用等，以太坊的 DApp 通过 Web3.js与智能合约层进行信息交换，所有的智能合约都运行在 EVM 上，并会用到 RPC 的调用，该层是最接近用户的一层 。 企业可以根据自己的业务逻辑，实现自身特有的智能合约，以帮助企业高效地执行业务 。 底层服务中 LeveIDB 数据库中存储了交易、区块等数据，密码学算法为区块的生成、交易的传输等进行加密，分片优化加快了交易验证的速度，共识算法用于解决 P2P 网络节点之间账本的一致性，顶层应用中的去中心化应用（ DApp）需要在以太坊虚拟机（ EVM)上执行，因此各层结构相互协同又各司其职，共同组成一个完整的以太坊系统 。 2.2区块 比特币的每个区块包含区块头（ Header）和区块体（ Body）两部分 。 以太坊同样使用了比特币区块链的技术，但是它在比特币区块链技术上做了一些调整 。 区块主要由区块头、交易列表和叔区块头三部分组成。 区块头包含下列信息：父块的散列值（ Prev Hash ）、叔区块的散列值（ Uncles Hash ）、状态树根散列值（ stateRoot ）、交易树根散列值（ Transaction Root ）、收据树根散列值（ Receipt Root）、时间戳（ Timestamp ）、随机数（ Nonce ）等 。 以太坊区块链上区块数据结构的一个重大改变就是保存了 三棵 Merkle树根，分别是状态树、交易树和收据树 。 存储三棵树可方便账户做更多查询 。 交易列表是由矿工从交易池中选择收入区块中的一系列交易 。 区块链上的第一个区块称为“创世区块”，区块链上除了创世区块以外每个区块都有它的父区块，这些区块连接起来组成一个区块链 。 以太坊大约每 15s 可以挖出一个新的区块 。 图 2-3 显示了以太坊区块结构中状态树的更新 。 2.3账户 在以太坊中，有一个重要的概念就是账户（ Account ） 。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20 字节（关于公钥将在 2.3.3 节具体介绍） 。 在以太坊系统中存在两种类型的账户，分别是外部账户（ Externally Owned Account, EOA）和合约账户 （关于智能合约的内容将在第 4 章详细介绍） 。 外部账户一般简称为“账户”，它们都是由人创建的，可以存储以太币， 是由公钥和私钥控制的账户 。 合约账户是由外部账户创建的账户 。 以太坊中这两种账户统称为“状态对象”（存储状态） 。 其中外部账户存储以太币余额状态，而合约账户除了余额还有智能合约及其变量的状态 。 通过交易的执行，这些状态对象发生变化，而 Merkle 树用于索引和验证状态对象的更新。一个以太坊的账户包含四个部分。 该地址交易的次数（ nonce ），它是用于保障每笔交易能且只能被处理一次的计数器，有效避免重放（ replay ）攻击。 账户目前的以太币余额 。 账户的合约二进制代码（合约账户） 。 账户的存储（默认为空） 。 Etherscan.io ( https://etherscan.io）是一个浏览、查询和分析以太坊区块的平台，读者可以在上面查看以太坊中的账户 、交易以及代币等信息 。 我们会在第 8 章介绍 Etherscan.io 。 2.3.1外部账户 外部账户（ EOA ）由私钥来控制，是由用户实际控制的账户 。 每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定 。 外部账户不能包含以太坊虚拟机(EVM ）代码 。 我们可以做一个简单的类比，把外部账户看作用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码 。 一个外部账户具有以下特性：拥有一定的账户余额、可以发送交易、通过私钥控制，以及没有相关联的代码 。 用户可以使用 Geth 指令创建一个外部账户 。 生成一个账户地址的过程主要有三步 。 1 ）设置账户的私钥，也就是通常意义的用户密码 。 2 ）使用加密算法由私钥生成对应的公钥 。 3 ）根据公钥得出相应的账户地址 。 其中第 2 步中使用的加密算法是 secp256kl 椭圆曲线密码算法，而不是 RSA 加密算法，因为前者相对于后者更加高效安全 。 对于由公钥得到账户地址，在以太坊中使用 SHA3方法 。 https://etherscan.io/address/0xb794f5ea0ba39494ce839613fffba74279579268 是 一个显示以太币（ ETH ）的账户实例，其列出了该账户的以太币余额，以及该账户相关的所有历史交易 。 2.3.2合约账户 合约账户是一个包含合约代码的账户 。 合约账户不是由私钥文件直接控制，而是由合约代码控制 。 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的 。 一个合约账户具有下列特性：拥有一定的以太币余额；有相关联的代码，代码通过交易或者其他合约发送的调用来激活；当合约被执行时，只能操作合约账户拥有的特定存储。 合约账户和普通账户最大的不同就是它还存有智能合约 。 以太坊区块链上的所有操作都是根据从账户发出的交易来执行的 。 每当合约账户收到一条交易消息时，其合约代码将被交易输入的参数调用执行 。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新块验证的一部分。 https://etherscan.io/address/0x744d70fdbe2ba4cf95131626614a1763df805b9e 是一个合约账户的实例（ SNT ），介绍了合约账户的余额、账户交易详情以及合约的发起人等内容 。 2.3.3 私钥和公钥 公钥和私钥都是属于密码学的概念。在现代密码学体系中，加密和解密采用了不同的密钥，也就是非对称密钥加密系统，每个通信方都需要两个密钥，这两个密钥就是公钥和私钥 。 公钥是公开的，不需要保密，而私钥是私有的，对其需要保管和隐蔽，以防别人知道 。 每一个公钥对应一个私钥 。 在密钥对中，如果一个用作加密，则另一个用作解密 。 非对称密钥加密系统的主要应用有两个，分别是公钥加密和公钥认证。 公钥加密和公钥认证的过程并不一样，下面分别进行简单介绍 。 为了让读者更容易理解什么是公钥加密，先来看一个简单的例子 。 若有两个用户 Jack和 Michael, Jack 想把一段文字通过公钥加密技术发送给 Michael ，而 Michael 有一对公钥和私钥，那么这个加密和解密过程如下：首先， Michael 将他的公钥发送给 Jack ，接着 Jack就用他收到的公钥对文字进行加密，将加密后的结果发送给 Michael ，最后 Michael 用他的私钥解密 Jack 发送给他的消息 。 整体过程如图 2-4 所示 。 公钥认证即通过鉴别一个用户的私钥是否正确来鉴别这个用户的真伪 。 列举一个简单的例子， Michael 想让 Jack 知道自己是真实的 Michael ，而不是其他人假 冒的，所以Michael 使用私钥对文件进行签名，发送给 Jack, Jack 再用 Michael 的公钥解密文件，从而验证签名是否来自真实的 M ichael 。 整体流程如图 2-5 所示 。 从上述两个例子可以看出，公钥加密是发送者先用公钥加密，接收者再用私钥解密，而公钥认证则是发送者先用私钥加密，接收者再用公钥解密以验证。 以太坊中每个外部账户都由一对密匙定义，即一个私钥和一个公钥 。 每对密钥都编码在一个钥匙文件里 。 钥匙文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览 。 钥匙文件的关键部分一一账户私钥，通常使用创建账户时设置的密码进行加密 。 目前最新的密钥文件格式是： UTC--&lt;created at UTC IS08601&gt;-&lt;address hex&gt; 。 钥匙文件可以在以太坊节点数据目录的 keystore 子目录下找到 。 目前常见的私钥有三种形态： Private key、 Keystore &amp; Password 以及 Memonic code 。 1 ) Private key 就是一份随机生成的 256 位二进制数字，用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串 256 位的仅包含“0”或“ 1 ”的字符串 。 该 256 位二进制数字就是私钥最初始的状态 。 2 ）而在以太坊官方钱包中，私钥和公钥将会以加密的方式保存一份 JSON 文件，存储在 keystore 子目录下 。 这份 JSON 文件就是 Keystore ，所以用户需要同时备份 Keystore和对应的 Password （创建钱包时设置的密码） 。 3 ）最后一种 Memonic code 是由 BIP 39 方案提出的，目的是随机生成 12 ～ 24 个比较容易记住的单词，该单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子，该种子通过 BIP-0032 提案的方式生成确定性钱包 。 2.3.4 钱包 钱包是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的用户就可以拥有对应地址的账户里的以太币使用权 。 我们通常把管理这些数字密钥的软件称为“钱包”，而我们所说的“备份钱包”其实就是备份账户的私钥文件 。 2.4 数据结构与存储 包括以太坊和比特币在内的大多数区块链项目，会使用 Merkle 树或基于 Merkle 树的数据结构，比特币中保存了一棵 Merkle 树，而以太坊针对三种对象设计了 三棵 Merkle 树( Merkle Patrcia 树），分别是状态树、交易树和收据树，这三种树可以帮助以太坊客户端做一些简易的查询，如查询某个账户的余额 、 某笔交易是否被包含在区块中等 。 区块 、 交易等数据最终都是存储在 LeveIDB 数据库中 。 LeveIDB 数据库是一个键值对（ key-value ）数 据库， key 一般与散列相关， value 则是存储内容的 RLP 编码 。 2.4.1 数据组织形式 以太坊使用了 Merkle Patircia 树（又称 Merkle Patricia Trie ，简称 MPT ），作为数据组织形式，用来组织管理用户的账户状态、交易信息等重要数据 。 MPT 是一种加密认证的数据结构，它融合了 Merkle 树和 Trie 树（前缀树）两种数据类型的优点，我们首先来介绍一下这两种数据结构 。 Merkle 树 Trie 树 Merkle Patricia 树 2.4.2 状态树 2.4.3 交易树 2.4.4 收据树 2.4.5 数据库支持一一LevelDB 2.5 共识机制 共识机制是区块链事务达成分布式共识的算法 。 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 。 2.5.1 Pow PoW 即通过工作结果来证明你完成了相应的工作 。 由于工作过程繁琐而低效，而其验证忽视工作过程、直接认证结果，这样工作者虽花费一定的时间完成工作，但是验证者却可以瞬间完成检验，因此这种方法往往简洁而高效。 在以太坊中，有一个专门设计的 PoW 算法一Ethash 算法 。 之所以用 Ethash 算法来代替原有的 PoW 算法，是为了解决挖矿中心化问题。 现在的情况是，在 Pow 算法下，小部分的硬件公司和挖矿机构通过挖矿资源的集 中， 获得了可 以 “操控”现有网络 内经济力量的优势，并以此获得高利润（如比特币和莱特币） 。这些组织可以生产具有超高散列计算性能的 ASIC (Application Specific Integrated Circuit ，特殊应用的集成电路），为自己赚取利润，这意味着挖矿不再是高度去中心化和追求平等主义的， 而是需要巨额资本的有效参与 。在这种情况下很可能会出现一个现象：一个以实现“去中心化”为目的的系统因为现实生活中矿机资源的集中而有了中心 。 为了解决这一问题，以太坊基金会专门设计了一个能‘抵制 ASIC ”、轻客户端可快速验证的 PoW 算法，希望减少中心化挖矿在以太坊中获得的经济奖励，这就是 Ethash 算法 。 以太坊试图让挖矿者从区块链状态中获取随机数据，计算一些从区块链最后的 N个区块中随机选择的交易，返回结果散列 。 这样做的好处有两点 。 首先， 以太坊合约能够包含任何种类的计算方式，这样以太坊的 ASIC 本质上其实是一个提供普通计算的专门集成电路，相当于一个性能很好的 CPU 。 其次 ，挖矿需要访问整个区块链，这就迫使挖矿者保存完整的区块链 。 Ethash 算法的特点是挖矿的效率基本与 CPU 无关，而与内存大小、带宽正相关，目的是去除专用硬件的优势，抵抗 ASIC 。 该算法的基本流程如下 。 1 ）对于每一个区块，都能通过扫描区块头的方式计算出一个种子（ seed ），该种子只与当前区块有关。 2 ）使用种子能产生一个 16MB 的伪随机缓存，轻客户端会存储缓存 。 3 ）基于缓存再生成一个 1GB 的数据集，称其为 DAG 。 数据集中的每一个元素都只依赖于缓存中的某几个元素 ，也就是说，只要有缓存，就可以快速地计算出 DAG 中指定位置的元素 。 挖矿者存储数据集，数据集随时间线性增长 。 4 ）挖矿可以概括为“矿工 ”从 DAG 中随机选择元素并对其进行散列的过程， DAG 也可以理解为一个完整的搜索空间，挖矿的过程就是从 DAG 中随机选择元素（类似比特币挖矿中试探合适 nonce 的过程）进行散列运算 。 5 ）验证者只需要花费少量的内存存储缓存就可以了，因为验证者能够基于缓存计算得到 DAG 中自己需要的指定位置的元素，然后验证这些指定元素的散列是不是小于某个散列值，也就是验证“矿工”的工作是否符合要求 。 缓存和 DAG 中每增加 30000 个区块更新一次，所以绝大多数的“矿工”将把精力放在读取数据集上，而不是改变它 。 2.5.2 PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是一种对货币所有权的证明 。 PoS 可以被描述成虚拟挖矿， 一般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 。 不过相比于 PoW 机制下的挖矿，虚拟挖矿消耗的电力可以忽略不计。 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式的交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程。 有许多共识算法和方式对验证者进行奖励，以此来激励以太坊用户支持 PoS 。 从算法的角度来说，主要有两种类型：基于链的 PoS 和 BFT (Byzantine Fault Tolerant ，拜占庭容错）风格的 PoS 。 在基于链的 PoS 中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者（比如，设置每 lOs 一个周期，每个周期都是一个时隙），给予验证者创建新区块的权利，但是验证者要确保该块指向最多的块（指向的上一个块通常是最长链的最后一个块） 。 因此，随着时间的推移，大多数的块都收敛到一条链上 。 在 BFT 风格的 PoS 中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链 。 在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将 “商量”被给定的块是否可以添加到区块链中，并且意见不能改变 。 相比于 PoW, PoS 有以下优点 。 不需要为了保证区块链的安全而消耗大量的电力资掘 。由于消耗较少，通过发行新币以激励参与者继续参与网络活动的压力会减少，理论上货币的负总发行量成为可能。 PoS 促进区块链技术的发展。 “矿工”从消耗大量资源的挖矿行为中解放出来，将算力资源转向区块链技术的开发应用上，促使区块链技术的蓬勃发展 。 随着规模经济（指扩大生产规模引起经济效益增加的现象）的消失，中心化所带来的风险减小 。 价值 100 万法币的以太币带来的回报比 10万法币带来的多 10 倍，不会有人负担大规模的生产工具却得不到相应的回报。 PoS 更安全 。 其实施的奖励惩罚措施使得各种恶意攻击变得极其昂贵，从而确保网络安全 。 2.6 以太币 以太币（ ETH ）是以太坊发行的一种数字货币，被认为是“比特币 2.0 版” 。 以太币是以太坊中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 。 以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。具体的分配大致如下： 预付款的贡献者总共有 6000 万个以太币 。 每挖出 一个新的区块，给挖出该区块的矿工奖励 5 个以太币 。 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用，每个叔区块会为挖矿者产出大约 4.375个以太币（ 5 个以太币奖励的 7/8 ），这被称为叔区块奖励 。 另外矿工每引用一个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 。 2.7 交易 以太坊的交易主要是指一条外部账户发送到区块链上另 一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 。以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 。 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 。 GasPrice 根据市场波动调整，避免以太币价值受市场价格的影响。 交易是以太坊整体架构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用 。 2.7.1 交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 0 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 。 Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 。 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 。 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改；对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 。 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 。 一笔普通的转账交易会消耗 21000Gas ，而一个创建智能合约的交易可能会消耗几万，甚至几百万 Gas 。 Gas Price Gas Price ( Gas 价格）是一单位 Gas 所需的手续费（以太币，即 Ether），例如一个转账交易消耗 21000Gas，假设 Gas Price 为 1 Gwei/Gas ，那么这笔交易的手续费为 0.000021Ether 。 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为 0。 但是，目前以1太坊钱包客户端默认的 GasPrice 是 0.00000000 I Ether /Gas ( I Gwei, /Gas=1 G wei Gas ） 。因为矿工有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 1 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 。 Gas Limit 上文讲了 Gas 是衡量交易的计算开销的基本单位 。 在以太坊的实际操作中，用户需要注意两个 Gas Limit 的概念：对于单个交易， Gas Limit （有时也会称作 Start Gas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 。 2.7.2 交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 。 一条交易包含以下内容 。 from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input）：存在的数据字段，如果存在，则是表明该交易是一个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发 出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r 、 s 、 v ：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 。 以上是以太坊中交易可能包含的内容，在不同的场景下，交易有三种类型 。 1 ）转账交易 ：转账是最简单的一种交易， 从一个账户向另一个账户发送以太币 。 发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit 、 Gas Price 、 nonce 、 hash 、签名可以按照默认方式生成），如下所示 。 web3.eth.sendTransaction({ from:”0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xd46e8dd67c5d32be8058bb8eb970870f07244567”, value: 10000000000000000 }); 2 ）创建智能合约的交易：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的 。 在创建合约的交易中 ， “ to” 字段是一个空字符串，在“data”字段中指定初始化合约的二进制代码，在之后合约被调用时，该代码的执行结果将作为合约代码 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, data:”contract binary code” }); 3 ）执行智能合约的交易 ：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ to”字段指定为要调用的智能合约的地址，通过“data”字段指定要调用的方法以及向该方法传递参数 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xb4259e5d9bc67a0f2ce3ed372ffc5lbe46c33c4d&quot;, data:“hash of the invoked method signature and encoded parameters ” }); 2.7.3 一个交易在以太坊中的“旅程” 在以太坊中，交易的处理是一个过程， 从账户发起交易请求开始，到包含该交易的区块被共识节点同步为止（一般来说，出于安全性的考虑，会等到该区块后面再“挖”出一些块，这笔交易才算确定），满足这一过程才算完成了一笔“交易” 。 一笔普通的转账或合约调用交易的“旅程” 一个创建智能合约的交易在以太坊中的“旅程” 2.8 数据编码与压缩 RLP ( Recursive Length Prefix）是一种编码算法，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 。 2.9 以大坊客户端和 API 2.10 以太坊域名服务 ENS ( Ethereum Name Service ，以太坊域名服务）是建立在以太坊区块链上的分布式、开放的命名系统 。 2.11 本章小结 作为先进公有链的代表之一，以太坊区块链本质是一串连接的数据区块，区块之间由使用密码学算法生成的散列指针链接 。 本章主要向读者介绍了以太坊的基本架构和组成，让用户对以太坊的区块、交易、账户等基本组成有一定了解 。 除此以外还向用户介绍了以太坊的数据结构和存储支持，以便读者能够对其底层结构有所了解 。 最后，本章还介绍了以太坊的人口一一客户端和以太坊域名服务（ ENS ），让用户能够了解以太坊的顶层应用 。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yzpbright/article/details/82855245 2.1 以太坊整体架构 以太坊的整体架构如图 2-1 所示，分为三层：底层服务、核心层、顶层应用 。 ( 1 ）底层服务 底层服务包含 P2P 网络服务 、 LeveIDB 数据库、密码学算法以及分片（ Sharding ）优化等基础服务 。 P2P 网络中每一个节点彼此对等，各个节点共同提供服务，不存在任何特殊节点，网络中的节点能够生成或审核新数据 。 而以太坊中的区块、交易等数据最终都是被存储在 LeveIDB 数据库中 。 密码学算法用于保证数据的隐私性和区块链的安全。 分片优化使得可以并行验证交易，大大加快了区块生成速度 。 这些底层服务共同促使区块链系统平稳地运行 。 ( 2 ）核心层 核心层包含区块链、共识算法和以太坊虚拟机等核心元件，其以区块链技术为主体，辅以以太坊特有的共识算法，并以 EVM （以太坊虚拟机）作为运行智能合约的载体，该层是以太坊的核心组成部分。 区块链构造的去中心化账本需要解决的首要问题就是如何确保不同节点上的账本数据的一致性和正确性，而共识算法正是用于解决这个问题。 EVM 是以太坊的一个主要创新，它是以太坊中智能合约的运行环境，使得以太坊能够实现更复杂的逻辑 。 ( 3 ）顶层应用 这一层包括 API 接口、智能合约以及去中心化应用等，以太坊的 DApp 通过 Web3.js与智能合约层进行信息交换，所有的智能合约都运行在 EVM 上，并会用到 RPC 的调用，该层是最接近用户的一层 。 企业可以根据自己的业务逻辑，实现自身特有的智能合约，以帮助企业高效地执行业务 。 底层服务中 LeveIDB 数据库中存储了交易、区块等数据，密码学算法为区块的生成、交易的传输等进行加密，分片优化加快了交易验证的速度，共识算法用于解决 P2P 网络节点之间账本的一致性，顶层应用中的去中心化应用（ DApp）需要在以太坊虚拟机（ EVM)上执行，因此各层结构相互协同又各司其职，共同组成一个完整的以太坊系统 。 2.2区块 比特币的每个区块包含区块头（ Header）和区块体（ Body）两部分 。 以太坊同样使用了比特币区块链的技术，但是它在比特币区块链技术上做了一些调整 。 区块主要由区块头、交易列表和叔区块头三部分组成。 区块头包含下列信息：父块的散列值（ Prev Hash ）、叔区块的散列值（ Uncles Hash ）、状态树根散列值（ stateRoot ）、交易树根散列值（ Transaction Root ）、收据树根散列值（ Receipt Root）、时间戳（ Timestamp ）、随机数（ Nonce ）等 。 以太坊区块链上区块数据结构的一个重大改变就是保存了 三棵 Merkle树根，分别是状态树、交易树和收据树 。 存储三棵树可方便账户做更多查询 。 交易列表是由矿工从交易池中选择收入区块中的一系列交易 。 区块链上的第一个区块称为“创世区块”，区块链上除了创世区块以外每个区块都有它的父区块，这些区块连接起来组成一个区块链 。 以太坊大约每 15s 可以挖出一个新的区块 。 图 2-3 显示了以太坊区块结构中状态树的更新 。 2.3账户 在以太坊中，有一个重要的概念就是账户（ Account ） 。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20 字节（关于公钥将在 2.3.3 节具体介绍） 。 在以太坊系统中存在两种类型的账户，分别是外部账户（ Externally Owned Account, EOA）和合约账户 （关于智能合约的内容将在第 4 章详细介绍） 。 外部账户一般简称为“账户”，它们都是由人创建的，可以存储以太币， 是由公钥和私钥控制的账户 。 合约账户是由外部账户创建的账户 。 以太坊中这两种账户统称为“状态对象”（存储状态） 。 其中外部账户存储以太币余额状态，而合约账户除了余额还有智能合约及其变量的状态 。 通过交易的执行，这些状态对象发生变化，而 Merkle 树用于索引和验证状态对象的更新。一个以太坊的账户包含四个部分。 该地址交易的次数（ nonce ），它是用于保障每笔交易能且只能被处理一次的计数器，有效避免重放（ replay ）攻击。 账户目前的以太币余额 。 账户的合约二进制代码（合约账户） 。 账户的存储（默认为空） 。 Etherscan.io ( https://etherscan.io）是一个浏览、查询和分析以太坊区块的平台，读者可以在上面查看以太坊中的账户 、交易以及代币等信息 。 我们会在第 8 章介绍 Etherscan.io 。 2.3.1外部账户 外部账户（ EOA ）由私钥来控制，是由用户实际控制的账户 。 每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定 。 外部账户不能包含以太坊虚拟机(EVM ）代码 。 我们可以做一个简单的类比，把外部账户看作用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码 。 一个外部账户具有以下特性：拥有一定的账户余额、可以发送交易、通过私钥控制，以及没有相关联的代码 。 用户可以使用 Geth 指令创建一个外部账户 。 生成一个账户地址的过程主要有三步 。 1 ）设置账户的私钥，也就是通常意义的用户密码 。 2 ）使用加密算法由私钥生成对应的公钥 。 3 ）根据公钥得出相应的账户地址 。 其中第 2 步中使用的加密算法是 secp256kl 椭圆曲线密码算法，而不是 RSA 加密算法，因为前者相对于后者更加高效安全 。 对于由公钥得到账户地址，在以太坊中使用 SHA3方法 。 https://etherscan.io/address/0xb794f5ea0ba39494ce839613fffba74279579268 是 一个显示以太币（ ETH ）的账户实例，其列出了该账户的以太币余额，以及该账户相关的所有历史交易 。 2.3.2合约账户 合约账户是一个包含合约代码的账户 。 合约账户不是由私钥文件直接控制，而是由合约代码控制 。 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的 。 一个合约账户具有下列特性：拥有一定的以太币余额；有相关联的代码，代码通过交易或者其他合约发送的调用来激活；当合约被执行时，只能操作合约账户拥有的特定存储。 合约账户和普通账户最大的不同就是它还存有智能合约 。 以太坊区块链上的所有操作都是根据从账户发出的交易来执行的 。 每当合约账户收到一条交易消息时，其合约代码将被交易输入的参数调用执行 。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新块验证的一部分。 https://etherscan.io/address/0x744d70fdbe2ba4cf95131626614a1763df805b9e 是一个合约账户的实例（ SNT ），介绍了合约账户的余额、账户交易详情以及合约的发起人等内容 。 2.3.3 私钥和公钥 公钥和私钥都是属于密码学的概念。在现代密码学体系中，加密和解密采用了不同的密钥，也就是非对称密钥加密系统，每个通信方都需要两个密钥，这两个密钥就是公钥和私钥 。 公钥是公开的，不需要保密，而私钥是私有的，对其需要保管和隐蔽，以防别人知道 。 每一个公钥对应一个私钥 。 在密钥对中，如果一个用作加密，则另一个用作解密 。 非对称密钥加密系统的主要应用有两个，分别是公钥加密和公钥认证。 公钥加密和公钥认证的过程并不一样，下面分别进行简单介绍 。 为了让读者更容易理解什么是公钥加密，先来看一个简单的例子 。 若有两个用户 Jack和 Michael, Jack 想把一段文字通过公钥加密技术发送给 Michael ，而 Michael 有一对公钥和私钥，那么这个加密和解密过程如下：首先， Michael 将他的公钥发送给 Jack ，接着 Jack就用他收到的公钥对文字进行加密，将加密后的结果发送给 Michael ，最后 Michael 用他的私钥解密 Jack 发送给他的消息 。 整体过程如图 2-4 所示 。 公钥认证即通过鉴别一个用户的私钥是否正确来鉴别这个用户的真伪 。 列举一个简单的例子， Michael 想让 Jack 知道自己是真实的 Michael ，而不是其他人假 冒的，所以Michael 使用私钥对文件进行签名，发送给 Jack, Jack 再用 Michael 的公钥解密文件，从而验证签名是否来自真实的 M ichael 。 整体流程如图 2-5 所示 。 从上述两个例子可以看出，公钥加密是发送者先用公钥加密，接收者再用私钥解密，而公钥认证则是发送者先用私钥加密，接收者再用公钥解密以验证。 以太坊中每个外部账户都由一对密匙定义，即一个私钥和一个公钥 。 每对密钥都编码在一个钥匙文件里 。 钥匙文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览 。 钥匙文件的关键部分一一账户私钥，通常使用创建账户时设置的密码进行加密 。 目前最新的密钥文件格式是： UTC--&lt;created at UTC IS08601&gt;-&lt;address hex&gt; 。 钥匙文件可以在以太坊节点数据目录的 keystore 子目录下找到 。 目前常见的私钥有三种形态： Private key、 Keystore &amp; Password 以及 Memonic code 。 1 ) Private key 就是一份随机生成的 256 位二进制数字，用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串 256 位的仅包含“0”或“ 1 ”的字符串 。 该 256 位二进制数字就是私钥最初始的状态 。 2 ）而在以太坊官方钱包中，私钥和公钥将会以加密的方式保存一份 JSON 文件，存储在 keystore 子目录下 。 这份 JSON 文件就是 Keystore ，所以用户需要同时备份 Keystore和对应的 Password （创建钱包时设置的密码） 。 3 ）最后一种 Memonic code 是由 BIP 39 方案提出的，目的是随机生成 12 ～ 24 个比较容易记住的单词，该单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子，该种子通过 BIP-0032 提案的方式生成确定性钱包 。 2.3.4 钱包 钱包是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的用户就可以拥有对应地址的账户里的以太币使用权 。 我们通常把管理这些数字密钥的软件称为“钱包”，而我们所说的“备份钱包”其实就是备份账户的私钥文件 。 2.4 数据结构与存储 包括以太坊和比特币在内的大多数区块链项目，会使用 Merkle 树或基于 Merkle 树的数据结构，比特币中保存了一棵 Merkle 树，而以太坊针对三种对象设计了 三棵 Merkle 树( Merkle Patrcia 树），分别是状态树、交易树和收据树，这三种树可以帮助以太坊客户端做一些简易的查询，如查询某个账户的余额 、 某笔交易是否被包含在区块中等 。 区块 、 交易等数据最终都是存储在 LeveIDB 数据库中 。 LeveIDB 数据库是一个键值对（ key-value ）数 据库， key 一般与散列相关， value 则是存储内容的 RLP 编码 。 2.4.1 数据组织形式 以太坊使用了 Merkle Patircia 树（又称 Merkle Patricia Trie ，简称 MPT ），作为数据组织形式，用来组织管理用户的账户状态、交易信息等重要数据 。 MPT 是一种加密认证的数据结构，它融合了 Merkle 树和 Trie 树（前缀树）两种数据类型的优点，我们首先来介绍一下这两种数据结构 。 Merkle 树 Trie 树 Merkle Patricia 树 2.4.2 状态树 2.4.3 交易树 2.4.4 收据树 2.4.5 数据库支持一一LevelDB 2.5 共识机制 共识机制是区块链事务达成分布式共识的算法 。 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 。 2.5.1 Pow PoW 即通过工作结果来证明你完成了相应的工作 。 由于工作过程繁琐而低效，而其验证忽视工作过程、直接认证结果，这样工作者虽花费一定的时间完成工作，但是验证者却可以瞬间完成检验，因此这种方法往往简洁而高效。 在以太坊中，有一个专门设计的 PoW 算法一Ethash 算法 。 之所以用 Ethash 算法来代替原有的 PoW 算法，是为了解决挖矿中心化问题。 现在的情况是，在 Pow 算法下，小部分的硬件公司和挖矿机构通过挖矿资源的集 中， 获得了可 以 “操控”现有网络 内经济力量的优势，并以此获得高利润（如比特币和莱特币） 。这些组织可以生产具有超高散列计算性能的 ASIC (Application Specific Integrated Circuit ，特殊应用的集成电路），为自己赚取利润，这意味着挖矿不再是高度去中心化和追求平等主义的， 而是需要巨额资本的有效参与 。在这种情况下很可能会出现一个现象：一个以实现“去中心化”为目的的系统因为现实生活中矿机资源的集中而有了中心 。 为了解决这一问题，以太坊基金会专门设计了一个能‘抵制 ASIC ”、轻客户端可快速验证的 PoW 算法，希望减少中心化挖矿在以太坊中获得的经济奖励，这就是 Ethash 算法 。 以太坊试图让挖矿者从区块链状态中获取随机数据，计算一些从区块链最后的 N个区块中随机选择的交易，返回结果散列 。 这样做的好处有两点 。 首先， 以太坊合约能够包含任何种类的计算方式，这样以太坊的 ASIC 本质上其实是一个提供普通计算的专门集成电路，相当于一个性能很好的 CPU 。 其次 ，挖矿需要访问整个区块链，这就迫使挖矿者保存完整的区块链 。 Ethash 算法的特点是挖矿的效率基本与 CPU 无关，而与内存大小、带宽正相关，目的是去除专用硬件的优势，抵抗 ASIC 。 该算法的基本流程如下 。 1 ）对于每一个区块，都能通过扫描区块头的方式计算出一个种子（ seed ），该种子只与当前区块有关。 2 ）使用种子能产生一个 16MB 的伪随机缓存，轻客户端会存储缓存 。 3 ）基于缓存再生成一个 1GB 的数据集，称其为 DAG 。 数据集中的每一个元素都只依赖于缓存中的某几个元素 ，也就是说，只要有缓存，就可以快速地计算出 DAG 中指定位置的元素 。 挖矿者存储数据集，数据集随时间线性增长 。 4 ）挖矿可以概括为“矿工 ”从 DAG 中随机选择元素并对其进行散列的过程， DAG 也可以理解为一个完整的搜索空间，挖矿的过程就是从 DAG 中随机选择元素（类似比特币挖矿中试探合适 nonce 的过程）进行散列运算 。 5 ）验证者只需要花费少量的内存存储缓存就可以了，因为验证者能够基于缓存计算得到 DAG 中自己需要的指定位置的元素，然后验证这些指定元素的散列是不是小于某个散列值，也就是验证“矿工”的工作是否符合要求 。 缓存和 DAG 中每增加 30000 个区块更新一次，所以绝大多数的“矿工”将把精力放在读取数据集上，而不是改变它 。 2.5.2 PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是一种对货币所有权的证明 。 PoS 可以被描述成虚拟挖矿， 一般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 。 不过相比于 PoW 机制下的挖矿，虚拟挖矿消耗的电力可以忽略不计。 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式的交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程。 有许多共识算法和方式对验证者进行奖励，以此来激励以太坊用户支持 PoS 。 从算法的角度来说，主要有两种类型：基于链的 PoS 和 BFT (Byzantine Fault Tolerant ，拜占庭容错）风格的 PoS 。 在基于链的 PoS 中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者（比如，设置每 lOs 一个周期，每个周期都是一个时隙），给予验证者创建新区块的权利，但是验证者要确保该块指向最多的块（指向的上一个块通常是最长链的最后一个块） 。 因此，随着时间的推移，大多数的块都收敛到一条链上 。 在 BFT 风格的 PoS 中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链 。 在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将 “商量”被给定的块是否可以添加到区块链中，并且意见不能改变 。 相比于 PoW, PoS 有以下优点 。 不需要为了保证区块链的安全而消耗大量的电力资掘 。由于消耗较少，通过发行新币以激励参与者继续参与网络活动的压力会减少，理论上货币的负总发行量成为可能。 PoS 促进区块链技术的发展。 “矿工”从消耗大量资源的挖矿行为中解放出来，将算力资源转向区块链技术的开发应用上，促使区块链技术的蓬勃发展 。 随着规模经济（指扩大生产规模引起经济效益增加的现象）的消失，中心化所带来的风险减小 。 价值 100 万法币的以太币带来的回报比 10万法币带来的多 10 倍，不会有人负担大规模的生产工具却得不到相应的回报。 PoS 更安全 。 其实施的奖励惩罚措施使得各种恶意攻击变得极其昂贵，从而确保网络安全 。 2.6 以太币 以太币（ ETH ）是以太坊发行的一种数字货币，被认为是“比特币 2.0 版” 。 以太币是以太坊中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 。 以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。具体的分配大致如下： 预付款的贡献者总共有 6000 万个以太币 。 每挖出 一个新的区块，给挖出该区块的矿工奖励 5 个以太币 。 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用，每个叔区块会为挖矿者产出大约 4.375个以太币（ 5 个以太币奖励的 7/8 ），这被称为叔区块奖励 。 另外矿工每引用一个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 。 2.7 交易 以太坊的交易主要是指一条外部账户发送到区块链上另 一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 。以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 。 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 。 GasPrice 根据市场波动调整，避免以太币价值受市场价格的影响。 交易是以太坊整体架构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用 。 2.7.1 交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 0 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 。 Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 。 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 。 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改；对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 。 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 。 一笔普通的转账交易会消耗 21000Gas ，而一个创建智能合约的交易可能会消耗几万，甚至几百万 Gas 。 Gas Price Gas Price ( Gas 价格）是一单位 Gas 所需的手续费（以太币，即 Ether），例如一个转账交易消耗 21000Gas，假设 Gas Price 为 1 Gwei/Gas ，那么这笔交易的手续费为 0.000021Ether 。 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为 0。 但是，目前以1太坊钱包客户端默认的 GasPrice 是 0.00000000 I Ether /Gas ( I Gwei, /Gas=1 G wei Gas ） 。因为矿工有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 1 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 。 Gas Limit 上文讲了 Gas 是衡量交易的计算开销的基本单位 。 在以太坊的实际操作中，用户需要注意两个 Gas Limit 的概念：对于单个交易， Gas Limit （有时也会称作 Start Gas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 。 2.7.2 交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 。 一条交易包含以下内容 。 from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input）：存在的数据字段，如果存在，则是表明该交易是一个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发 出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r 、 s 、 v ：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 。 以上是以太坊中交易可能包含的内容，在不同的场景下，交易有三种类型 。 1 ）转账交易 ：转账是最简单的一种交易， 从一个账户向另一个账户发送以太币 。 发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit 、 Gas Price 、 nonce 、 hash 、签名可以按照默认方式生成），如下所示 。 web3.eth.sendTransaction({ from:”0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xd46e8dd67c5d32be8058bb8eb970870f07244567”, value: 10000000000000000 }); 2 ）创建智能合约的交易：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的 。 在创建合约的交易中 ， “ to” 字段是一个空字符串，在“data”字段中指定初始化合约的二进制代码，在之后合约被调用时，该代码的执行结果将作为合约代码 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, data:”contract binary code” }); 3 ）执行智能合约的交易 ：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ to”字段指定为要调用的智能合约的地址，通过“data”字段指定要调用的方法以及向该方法传递参数 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xb4259e5d9bc67a0f2ce3ed372ffc5lbe46c33c4d&quot;, data:“hash of the invoked method signature and encoded parameters ” }); 2.7.3 一个交易在以太坊中的“旅程” 在以太坊中，交易的处理是一个过程， 从账户发起交易请求开始，到包含该交易的区块被共识节点同步为止（一般来说，出于安全性的考虑，会等到该区块后面再“挖”出一些块，这笔交易才算确定），满足这一过程才算完成了一笔“交易” 。 一笔普通的转账或合约调用交易的“旅程” 一个创建智能合约的交易在以太坊中的“旅程” 2.8 数据编码与压缩 RLP ( Recursive Length Prefix）是一种编码算法，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 。 2.9 以大坊客户端和 API 2.10 以太坊域名服务 ENS ( Ethereum Name Service ，以太坊域名服务）是建立在以太坊区块链上的分布式、开放的命名系统 。 2.11 本章小结 作为先进公有链的代表之一，以太坊区块链本质是一串连接的数据区块，区块之间由使用密码学算法生成的散列指针链接 。 本章主要向读者介绍了以太坊的基本架构和组成，让用户对以太坊的区块、交易、账户等基本组成有一定了解 。 除此以外还向用户介绍了以太坊的数据结构和存储支持，以便读者能够对其底层结构有所了解 。 最后，本章还介绍了以太坊的人口一一客户端和以太坊域名服务（ ENS ），让用户能够了解以太坊的顶层应用 。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yzpbright/article/details/82855245 2.1 以太坊整体架构 以太坊的整体架构如图 2-1 所示，分为三层：底层服务、核心层、顶层应用 。 ( 1 ）底层服务 底层服务包含 P2P 网络服务 、 LeveIDB 数据库、密码学算法以及分片（ Sharding ）优化等基础服务 。 P2P 网络中每一个节点彼此对等，各个节点共同提供服务，不存在任何特殊节点，网络中的节点能够生成或审核新数据 。 而以太坊中的区块、交易等数据最终都是被存储在 LeveIDB 数据库中 。 密码学算法用于保证数据的隐私性和区块链的安全。 分片优化使得可以并行验证交易，大大加快了区块生成速度 。 这些底层服务共同促使区块链系统平稳地运行 。 ( 2 ）核心层 核心层包含区块链、共识算法和以太坊虚拟机等核心元件，其以区块链技术为主体，辅以以太坊特有的共识算法，并以 EVM （以太坊虚拟机）作为运行智能合约的载体，该层是以太坊的核心组成部分。 区块链构造的去中心化账本需要解决的首要问题就是如何确保不同节点上的账本数据的一致性和正确性，而共识算法正是用于解决这个问题。 EVM 是以太坊的一个主要创新，它是以太坊中智能合约的运行环境，使得以太坊能够实现更复杂的逻辑 。 ( 3 ）顶层应用 这一层包括 API 接口、智能合约以及去中心化应用等，以太坊的 DApp 通过 Web3.js与智能合约层进行信息交换，所有的智能合约都运行在 EVM 上，并会用到 RPC 的调用，该层是最接近用户的一层 。 企业可以根据自己的业务逻辑，实现自身特有的智能合约，以帮助企业高效地执行业务 。 底层服务中 LeveIDB 数据库中存储了交易、区块等数据，密码学算法为区块的生成、交易的传输等进行加密，分片优化加快了交易验证的速度，共识算法用于解决 P2P 网络节点之间账本的一致性，顶层应用中的去中心化应用（ DApp）需要在以太坊虚拟机（ EVM)上执行，因此各层结构相互协同又各司其职，共同组成一个完整的以太坊系统 。 2.2区块 比特币的每个区块包含区块头（ Header）和区块体（ Body）两部分 。 以太坊同样使用了比特币区块链的技术，但是它在比特币区块链技术上做了一些调整 。 区块主要由区块头、交易列表和叔区块头三部分组成。 区块头包含下列信息：父块的散列值（ Prev Hash ）、叔区块的散列值（ Uncles Hash ）、状态树根散列值（ stateRoot ）、交易树根散列值（ Transaction Root ）、收据树根散列值（ Receipt Root）、时间戳（ Timestamp ）、随机数（ Nonce ）等 。 以太坊区块链上区块数据结构的一个重大改变就是保存了 三棵 Merkle树根，分别是状态树、交易树和收据树 。 存储三棵树可方便账户做更多查询 。 交易列表是由矿工从交易池中选择收入区块中的一系列交易 。 区块链上的第一个区块称为“创世区块”，区块链上除了创世区块以外每个区块都有它的父区块，这些区块连接起来组成一个区块链 。 以太坊大约每 15s 可以挖出一个新的区块 。 图 2-3 显示了以太坊区块结构中状态树的更新 。 2.3账户 在以太坊中，有一个重要的概念就是账户（ Account ） 。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20 字节（关于公钥将在 2.3.3 节具体介绍） 。 在以太坊系统中存在两种类型的账户，分别是外部账户（ Externally Owned Account, EOA）和合约账户 （关于智能合约的内容将在第 4 章详细介绍） 。 外部账户一般简称为“账户”，它们都是由人创建的，可以存储以太币， 是由公钥和私钥控制的账户 。 合约账户是由外部账户创建的账户 。 以太坊中这两种账户统称为“状态对象”（存储状态） 。 其中外部账户存储以太币余额状态，而合约账户除了余额还有智能合约及其变量的状态 。 通过交易的执行，这些状态对象发生变化，而 Merkle 树用于索引和验证状态对象的更新。一个以太坊的账户包含四个部分。 该地址交易的次数（ nonce ），它是用于保障每笔交易能且只能被处理一次的计数器，有效避免重放（ replay ）攻击。 账户目前的以太币余额 。 账户的合约二进制代码（合约账户） 。 账户的存储（默认为空） 。 Etherscan.io ( https://etherscan.io）是一个浏览、查询和分析以太坊区块的平台，读者可以在上面查看以太坊中的账户 、交易以及代币等信息 。 我们会在第 8 章介绍 Etherscan.io 。 2.3.1外部账户 外部账户（ EOA ）由私钥来控制，是由用户实际控制的账户 。 每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定 。 外部账户不能包含以太坊虚拟机(EVM ）代码 。 我们可以做一个简单的类比，把外部账户看作用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码 。 一个外部账户具有以下特性：拥有一定的账户余额、可以发送交易、通过私钥控制，以及没有相关联的代码 。 用户可以使用 Geth 指令创建一个外部账户 。 生成一个账户地址的过程主要有三步 。 1 ）设置账户的私钥，也就是通常意义的用户密码 。 2 ）使用加密算法由私钥生成对应的公钥 。 3 ）根据公钥得出相应的账户地址 。 其中第 2 步中使用的加密算法是 secp256kl 椭圆曲线密码算法，而不是 RSA 加密算法，因为前者相对于后者更加高效安全 。 对于由公钥得到账户地址，在以太坊中使用 SHA3方法 。 https://etherscan.io/address/0xb794f5ea0ba39494ce839613fffba74279579268 是 一个显示以太币（ ETH ）的账户实例，其列出了该账户的以太币余额，以及该账户相关的所有历史交易 。 2.3.2合约账户 合约账户是一个包含合约代码的账户 。 合约账户不是由私钥文件直接控制，而是由合约代码控制 。 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的 。 一个合约账户具有下列特性：拥有一定的以太币余额；有相关联的代码，代码通过交易或者其他合约发送的调用来激活；当合约被执行时，只能操作合约账户拥有的特定存储。 合约账户和普通账户最大的不同就是它还存有智能合约 。 以太坊区块链上的所有操作都是根据从账户发出的交易来执行的 。 每当合约账户收到一条交易消息时，其合约代码将被交易输入的参数调用执行 。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新块验证的一部分。 https://etherscan.io/address/0x744d70fdbe2ba4cf95131626614a1763df805b9e 是一个合约账户的实例（ SNT ），介绍了合约账户的余额、账户交易详情以及合约的发起人等内容 。 2.3.3 私钥和公钥 公钥和私钥都是属于密码学的概念。在现代密码学体系中，加密和解密采用了不同的密钥，也就是非对称密钥加密系统，每个通信方都需要两个密钥，这两个密钥就是公钥和私钥 。 公钥是公开的，不需要保密，而私钥是私有的，对其需要保管和隐蔽，以防别人知道 。 每一个公钥对应一个私钥 。 在密钥对中，如果一个用作加密，则另一个用作解密 。 非对称密钥加密系统的主要应用有两个，分别是公钥加密和公钥认证。 公钥加密和公钥认证的过程并不一样，下面分别进行简单介绍 。 为了让读者更容易理解什么是公钥加密，先来看一个简单的例子 。 若有两个用户 Jack和 Michael, Jack 想把一段文字通过公钥加密技术发送给 Michael ，而 Michael 有一对公钥和私钥，那么这个加密和解密过程如下：首先， Michael 将他的公钥发送给 Jack ，接着 Jack就用他收到的公钥对文字进行加密，将加密后的结果发送给 Michael ，最后 Michael 用他的私钥解密 Jack 发送给他的消息 。 整体过程如图 2-4 所示 。 公钥认证即通过鉴别一个用户的私钥是否正确来鉴别这个用户的真伪 。 列举一个简单的例子， Michael 想让 Jack 知道自己是真实的 Michael ，而不是其他人假 冒的，所以Michael 使用私钥对文件进行签名，发送给 Jack, Jack 再用 Michael 的公钥解密文件，从而验证签名是否来自真实的 M ichael 。 整体流程如图 2-5 所示 。 从上述两个例子可以看出，公钥加密是发送者先用公钥加密，接收者再用私钥解密，而公钥认证则是发送者先用私钥加密，接收者再用公钥解密以验证。 以太坊中每个外部账户都由一对密匙定义，即一个私钥和一个公钥 。 每对密钥都编码在一个钥匙文件里 。 钥匙文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览 。 钥匙文件的关键部分一一账户私钥，通常使用创建账户时设置的密码进行加密 。 目前最新的密钥文件格式是： UTC--&lt;created at UTC IS08601&gt;-&lt;address hex&gt; 。 钥匙文件可以在以太坊节点数据目录的 keystore 子目录下找到 。 目前常见的私钥有三种形态： Private key、 Keystore &amp; Password 以及 Memonic code 。 1 ) Private key 就是一份随机生成的 256 位二进制数字，用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串 256 位的仅包含“0”或“ 1 ”的字符串 。 该 256 位二进制数字就是私钥最初始的状态 。 2 ）而在以太坊官方钱包中，私钥和公钥将会以加密的方式保存一份 JSON 文件，存储在 keystore 子目录下 。 这份 JSON 文件就是 Keystore ，所以用户需要同时备份 Keystore和对应的 Password （创建钱包时设置的密码） 。 3 ）最后一种 Memonic code 是由 BIP 39 方案提出的，目的是随机生成 12 ～ 24 个比较容易记住的单词，该单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子，该种子通过 BIP-0032 提案的方式生成确定性钱包 。 2.3.4 钱包 钱包是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的用户就可以拥有对应地址的账户里的以太币使用权 。 我们通常把管理这些数字密钥的软件称为“钱包”，而我们所说的“备份钱包”其实就是备份账户的私钥文件 。 2.4 数据结构与存储 包括以太坊和比特币在内的大多数区块链项目，会使用 Merkle 树或基于 Merkle 树的数据结构，比特币中保存了一棵 Merkle 树，而以太坊针对三种对象设计了 三棵 Merkle 树( Merkle Patrcia 树），分别是状态树、交易树和收据树，这三种树可以帮助以太坊客户端做一些简易的查询，如查询某个账户的余额 、 某笔交易是否被包含在区块中等 。 区块 、 交易等数据最终都是存储在 LeveIDB 数据库中 。 LeveIDB 数据库是一个键值对（ key-value ）数 据库， key 一般与散列相关， value 则是存储内容的 RLP 编码 。 2.4.1 数据组织形式 以太坊使用了 Merkle Patircia 树（又称 Merkle Patricia Trie ，简称 MPT ），作为数据组织形式，用来组织管理用户的账户状态、交易信息等重要数据 。 MPT 是一种加密认证的数据结构，它融合了 Merkle 树和 Trie 树（前缀树）两种数据类型的优点，我们首先来介绍一下这两种数据结构 。 Merkle 树 Trie 树 Merkle Patricia 树 2.4.2 状态树 2.4.3 交易树 2.4.4 收据树 2.4.5 数据库支持一一LevelDB 2.5 共识机制 共识机制是区块链事务达成分布式共识的算法 。 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 。 2.5.1 Pow PoW 即通过工作结果来证明你完成了相应的工作 。 由于工作过程繁琐而低效，而其验证忽视工作过程、直接认证结果，这样工作者虽花费一定的时间完成工作，但是验证者却可以瞬间完成检验，因此这种方法往往简洁而高效。 在以太坊中，有一个专门设计的 PoW 算法一Ethash 算法 。 之所以用 Ethash 算法来代替原有的 PoW 算法，是为了解决挖矿中心化问题。 现在的情况是，在 Pow 算法下，小部分的硬件公司和挖矿机构通过挖矿资源的集 中， 获得了可 以 “操控”现有网络 内经济力量的优势，并以此获得高利润（如比特币和莱特币） 。这些组织可以生产具有超高散列计算性能的 ASIC (Application Specific Integrated Circuit ，特殊应用的集成电路），为自己赚取利润，这意味着挖矿不再是高度去中心化和追求平等主义的， 而是需要巨额资本的有效参与 。在这种情况下很可能会出现一个现象：一个以实现“去中心化”为目的的系统因为现实生活中矿机资源的集中而有了中心 。 为了解决这一问题，以太坊基金会专门设计了一个能‘抵制 ASIC ”、轻客户端可快速验证的 PoW 算法，希望减少中心化挖矿在以太坊中获得的经济奖励，这就是 Ethash 算法 。 以太坊试图让挖矿者从区块链状态中获取随机数据，计算一些从区块链最后的 N个区块中随机选择的交易，返回结果散列 。 这样做的好处有两点 。 首先， 以太坊合约能够包含任何种类的计算方式，这样以太坊的 ASIC 本质上其实是一个提供普通计算的专门集成电路，相当于一个性能很好的 CPU 。 其次 ，挖矿需要访问整个区块链，这就迫使挖矿者保存完整的区块链 。 Ethash 算法的特点是挖矿的效率基本与 CPU 无关，而与内存大小、带宽正相关，目的是去除专用硬件的优势，抵抗 ASIC 。 该算法的基本流程如下 。 1 ）对于每一个区块，都能通过扫描区块头的方式计算出一个种子（ seed ），该种子只与当前区块有关。 2 ）使用种子能产生一个 16MB 的伪随机缓存，轻客户端会存储缓存 。 3 ）基于缓存再生成一个 1GB 的数据集，称其为 DAG 。 数据集中的每一个元素都只依赖于缓存中的某几个元素 ，也就是说，只要有缓存，就可以快速地计算出 DAG 中指定位置的元素 。 挖矿者存储数据集，数据集随时间线性增长 。 4 ）挖矿可以概括为“矿工 ”从 DAG 中随机选择元素并对其进行散列的过程， DAG 也可以理解为一个完整的搜索空间，挖矿的过程就是从 DAG 中随机选择元素（类似比特币挖矿中试探合适 nonce 的过程）进行散列运算 。 5 ）验证者只需要花费少量的内存存储缓存就可以了，因为验证者能够基于缓存计算得到 DAG 中自己需要的指定位置的元素，然后验证这些指定元素的散列是不是小于某个散列值，也就是验证“矿工”的工作是否符合要求 。 缓存和 DAG 中每增加 30000 个区块更新一次，所以绝大多数的“矿工”将把精力放在读取数据集上，而不是改变它 。 2.5.2 PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是一种对货币所有权的证明 。 PoS 可以被描述成虚拟挖矿， 一般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 。 不过相比于 PoW 机制下的挖矿，虚拟挖矿消耗的电力可以忽略不计。 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式的交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程。 有许多共识算法和方式对验证者进行奖励，以此来激励以太坊用户支持 PoS 。 从算法的角度来说，主要有两种类型：基于链的 PoS 和 BFT (Byzantine Fault Tolerant ，拜占庭容错）风格的 PoS 。 在基于链的 PoS 中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者（比如，设置每 lOs 一个周期，每个周期都是一个时隙），给予验证者创建新区块的权利，但是验证者要确保该块指向最多的块（指向的上一个块通常是最长链的最后一个块） 。 因此，随着时间的推移，大多数的块都收敛到一条链上 。 在 BFT 风格的 PoS 中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链 。 在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将 “商量”被给定的块是否可以添加到区块链中，并且意见不能改变 。 相比于 PoW, PoS 有以下优点 。 不需要为了保证区块链的安全而消耗大量的电力资掘 。由于消耗较少，通过发行新币以激励参与者继续参与网络活动的压力会减少，理论上货币的负总发行量成为可能。 PoS 促进区块链技术的发展。 “矿工”从消耗大量资源的挖矿行为中解放出来，将算力资源转向区块链技术的开发应用上，促使区块链技术的蓬勃发展 。 随着规模经济（指扩大生产规模引起经济效益增加的现象）的消失，中心化所带来的风险减小 。 价值 100 万法币的以太币带来的回报比 10万法币带来的多 10 倍，不会有人负担大规模的生产工具却得不到相应的回报。 PoS 更安全 。 其实施的奖励惩罚措施使得各种恶意攻击变得极其昂贵，从而确保网络安全 。 2.6 以太币 以太币（ ETH ）是以太坊发行的一种数字货币，被认为是“比特币 2.0 版” 。 以太币是以太坊中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 。 以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。具体的分配大致如下： 预付款的贡献者总共有 6000 万个以太币 。 每挖出 一个新的区块，给挖出该区块的矿工奖励 5 个以太币 。 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用，每个叔区块会为挖矿者产出大约 4.375个以太币（ 5 个以太币奖励的 7/8 ），这被称为叔区块奖励 。 另外矿工每引用一个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 。 2.7 交易 以太坊的交易主要是指一条外部账户发送到区块链上另 一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 。以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 。 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 。 GasPrice 根据市场波动调整，避免以太币价值受市场价格的影响。 交易是以太坊整体架构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用 。 2.7.1 交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 0 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 。 Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 。 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 。 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改；对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 。 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 。 一笔普通的转账交易会消耗 21000Gas ，而一个创建智能合约的交易可能会消耗几万，甚至几百万 Gas 。 Gas Price Gas Price ( Gas 价格）是一单位 Gas 所需的手续费（以太币，即 Ether），例如一个转账交易消耗 21000Gas，假设 Gas Price 为 1 Gwei/Gas ，那么这笔交易的手续费为 0.000021Ether 。 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为 0。 但是，目前以1太坊钱包客户端默认的 GasPrice 是 0.00000000 I Ether /Gas ( I Gwei, /Gas=1 G wei Gas ） 。因为矿工有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 1 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 。 Gas Limit 上文讲了 Gas 是衡量交易的计算开销的基本单位 。 在以太坊的实际操作中，用户需要注意两个 Gas Limit 的概念：对于单个交易， Gas Limit （有时也会称作 Start Gas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 。 2.7.2 交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 。 一条交易包含以下内容 。 from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input）：存在的数据字段，如果存在，则是表明该交易是一个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发 出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r 、 s 、 v ：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 。 以上是以太坊中交易可能包含的内容，在不同的场景下，交易有三种类型 。 1 ）转账交易 ：转账是最简单的一种交易， 从一个账户向另一个账户发送以太币 。 发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit 、 Gas Price 、 nonce 、 hash 、签名可以按照默认方式生成），如下所示 。 web3.eth.sendTransaction({ from:”0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xd46e8dd67c5d32be8058bb8eb970870f07244567”, value: 10000000000000000 }); 2 ）创建智能合约的交易：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的 。 在创建合约的交易中 ， “ to” 字段是一个空字符串，在“data”字段中指定初始化合约的二进制代码，在之后合约被调用时，该代码的执行结果将作为合约代码 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, data:”contract binary code” }); 3 ）执行智能合约的交易 ：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ to”字段指定为要调用的智能合约的地址，通过“data”字段指定要调用的方法以及向该方法传递参数 。 如下所示 。 web3.eth.sendTransaction({ from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”, to:”0xb4259e5d9bc67a0f2ce3ed372ffc5lbe46c33c4d&quot;, data:“hash of the invoked method signature and encoded parameters ” }); 2.7.3 一个交易在以太坊中的“旅程” 在以太坊中，交易的处理是一个过程， 从账户发起交易请求开始，到包含该交易的区块被共识节点同步为止（一般来说，出于安全性的考虑，会等到该区块后面再“挖”出一些块，这笔交易才算确定），满足这一过程才算完成了一笔“交易” 。 一笔普通的转账或合约调用交易的“旅程” 一个创建智能合约的交易在以太坊中的“旅程” 2.8 数据编码与压缩 RLP ( Recursive Length Prefix）是一种编码算法，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 。 2.9 以大坊客户端和 API 2.10 以太坊域名服务 ENS ( Ethereum Name Service ，以太坊域名服务）是建立在以太坊区块链上的分布式、开放的命名系统 。 2.11 本章小结 作为先进公有链的代表之一，以太坊区块链本质是一串连接的数据区块，区块之间由使用密码学算法生成的散列指针链接 。 本章主要向读者介绍了以太坊的基本架构和组成，让用户对以太坊的区块、交易、账户等基本组成有一定了解 。 除此以外还向用户介绍了以太坊的数据结构和存储支持，以便读者能够对其底层结构有所了解 。 最后，本章还介绍了以太坊的人口一一客户端和以太坊域名服务（ ENS ），让用户能够了解以太坊的顶层应用 。 阅读更多","@type":"BlogPosting","url":"/2018/09/26/c937f73cc2ad0c027f951622250921f8.html","headline":"《以太坊技术详解与实战》第2章 - 太坊架构和组成","dateModified":"2018-09-26T00:00:00+08:00","datePublished":"2018-09-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/09/26/c937f73cc2ad0c027f951622250921f8.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《以太坊技术详解与实战》第2章 - 太坊架构和组成</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yzpbright/article/details/82855245 
 </div> 
 <div class="markdown_views prism-dracula"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2><a id="21__0"></a>2.1 以太坊整体架构</h2> 
  <p>以太坊的整体架构如图 2-1 所示，分为三层：底层服务、核心层、顶层应用 。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927105106458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6cGJyaWdodA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p>( 1 ）底层服务<br> 底层服务包含 P2P 网络服务 、 LeveIDB 数据库、密码学算法以及分片（ Sharding ）优化等基础服务 。 P2P 网络中每一个节点彼此对等，各个节点共同提供服务，不存在任何特殊节点，网络中的节点能够生成或审核新数据 。 而以太坊中的区块、交易等数据最终都是被存储在 LeveIDB 数据库中 。 密码学算法用于保证数据的隐私性和区块链的安全。 分片优化使得可以并行验证交易，大大加快了区块生成速度 。 这些底层服务共同促使区块链系统平稳地运行 。<br> ( 2 ）核心层<br> 核心层包含区块链、共识算法和以太坊虚拟机等核心元件，其以区块链技术为主体，辅以以太坊特有的共识算法，并以 EVM （以太坊虚拟机）作为运行智能合约的载体，该层是以太坊的核心组成部分。 区块链构造的去中心化账本需要解决的首要问题就是如何确保不同节点上的账本数据的一致性和正确性，而共识算法正是用于解决这个问题。 EVM 是以太坊的一个主要创新，它是以太坊中智能合约的运行环境，使得以太坊能够实现更复杂的逻辑 。<br> ( 3 ）顶层应用<br> 这一层包括 API 接口、智能合约以及去中心化应用等，以太坊的 DApp 通过 Web3.js与智能合约层进行信息交换，所有的智能合约都运行在 EVM 上，并会用到 RPC 的调用，该层是最接近用户的一层 。 企业可以根据自己的业务逻辑，实现自身特有的智能合约，以帮助企业高效地执行业务 。</p> 
  <p>底层服务中 LeveIDB 数据库中存储了交易、区块等数据，密码学算法为区块的生成、交易的传输等进行加密，分片优化加快了交易验证的速度，共识算法用于解决 P2P 网络节点之间账本的一致性，顶层应用中的去中心化应用（ DApp）需要在以太坊虚拟机（ EVM)上执行，因此各层结构相互协同又各司其职，共同组成一个完整的以太坊系统 。</p> 
  <h2><a id="22_14"></a>2.2区块</h2> 
  <p>比特币的每个区块包含区块头（ Header）和区块体（ Body）两部分 。<br> 以太坊同样使用了比特币区块链的技术，但是它在比特币区块链技术上做了一些调整 。<br> 区块主要由区块头、交易列表和叔区块头三部分组成。<br> 区块头包含下列信息：父块的散列值（ Prev Hash ）、叔区块的散列值（ Uncles Hash ）、状态树根散列值（ stateRoot ）、交易树根散列值（ Transaction Root ）、收据树根散列值（ Receipt Root）、时间戳（ Timestamp ）、随机数（ Nonce ）等 。<br> 以太坊区块链上区块数据结构的一个重大改变就是保存了 三棵 Merkle树根，分别是状态树、交易树和收据树 。 存储三棵树可方便账户做更多查询 。 交易列表是由矿工从交易池中选择收入区块中的一系列交易 。 区块链上的第一个区块称为“创世区块”，区块链上除了创世区块以外每个区块都有它的父区块，这些区块连接起来组成一个区块链 。 以太坊大约每 15s 可以挖出一个新的区块 。 图 2-3 显示了以太坊区块结构中状态树的更新 。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927141521964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6cGJyaWdodA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <h2><a id="23_22"></a>2.3账户</h2> 
  <p>在以太坊中，有一个重要的概念就是账户（ Account ） 。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20 字节（关于公钥将在 2.3.3 节具体介绍） 。 在以太坊系统中存在两种类型的账户，分别是外部账户（ Externally Owned Account, EOA）和合约账户 （关于智能合约的内容将在第 4 章详细介绍） 。</p> 
  <ul> 
   <li>外部账户一般简称为“账户”，它们都是由人创建的，可以存储以太币， 是由公钥和私钥控制的账户 。</li> 
   <li>合约账户是由外部账户创建的账户 。</li> 
  </ul> 
  <p>以太坊中这两种账户统称为“状态对象”（存储状态） 。 其中外部账户存储以太币余额状态，而合约账户除了余额还有智能合约及其变量的状态 。 通过交易的执行，这些状态对象发生变化，而 Merkle 树用于索引和验证状态对象的更新。一个以太坊的账户包含四个部分。</p> 
  <ul> 
   <li>该地址交易的次数（ nonce ），它是用于保障每笔交易能且只能被处理一次的计数器，有效避免重放（ replay ）攻击。</li> 
   <li>账户目前的以太币余额 。</li> 
   <li>账户的合约二进制代码（合约账户） 。</li> 
   <li>账户的存储（默认为空） 。</li> 
  </ul> 
  <p><a href="http://Etherscan.io" rel="nofollow">Etherscan.io</a> ( <a href="https://etherscan.io" rel="nofollow">https://etherscan.io</a>）是一个浏览、查询和分析以太坊区块的平台，读者可以在上面查看以太坊中的账户 、交易以及代币等信息 。 我们会在第 8 章介绍 <a href="http://Etherscan.io" rel="nofollow">Etherscan.io</a> 。</p> 
  <p><strong>2.3.1外部账户</strong><br> 外部账户（ EOA ）由私钥来控制，是由用户实际控制的账户 。 每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定 。 外部账户不能包含以太坊虚拟机(EVM ）代码 。 我们可以做一个简单的类比，把外部账户看作用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码 。 一个外部账户具有以下特性：拥有一定的账户余额、可以发送交易、通过私钥控制，以及没有相关联的代码 。<br> 用户可以使用 Geth 指令创建一个外部账户 。 生成一个账户地址的过程主要有三步 。<br> 1 ）设置账户的私钥，也就是通常意义的用户密码 。<br> 2 ）使用加密算法由私钥生成对应的公钥 。<br> 3 ）根据公钥得出相应的账户地址 。<br> 其中第 2 步中使用的加密算法是 secp256kl 椭圆曲线密码算法，而不是 RSA 加密算法，因为前者相对于后者更加高效安全 。 对于由公钥得到账户地址，在以太坊中使用 SHA3方法 。<br> <a href="https://etherscan.io/address/0xb794f5ea0ba39494ce839613fffba74279579268" rel="nofollow">https://etherscan.io/address/0xb794f5ea0ba39494ce839613fffba74279579268</a> 是 一个显示以太币（ ETH ）的账户实例，其列出了该账户的以太币余额，以及该账户相关的所有历史交易 。</p> 
  <p><strong>2.3.2合约账户</strong><br> 合约账户是一个包含合约代码的账户 。 合约账户不是由私钥文件直接控制，而是由合约代码控制 。 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的 。 一个合约账户具有下列特性：拥有一定的以太币余额；有相关联的代码，代码通过交易或者其他合约发送的调用来激活；当合约被执行时，只能操作合约账户拥有的特定存储。 合约账户和普通账户最大的不同就是它还存有智能合约 。<br> 以太坊区块链上的所有操作都是根据从账户发出的交易来执行的 。 每当合约账户收到一条交易消息时，其合约代码将被交易输入的参数调用执行 。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新块验证的一部分。<br> <a href="https://etherscan.io/address/0x744d70fdbe2ba4cf95131626614a1763df805b9e" rel="nofollow">https://etherscan.io/address/0x744d70fdbe2ba4cf95131626614a1763df805b9e</a> 是一个合约账户的实例（ SNT ），介绍了合约账户的余额、账户交易详情以及合约的发起人等内容 。</p> 
  <p><strong>2.3.3 私钥和公钥</strong><br> 公钥和私钥都是属于密码学的概念。在现代密码学体系中，加密和解密采用了不同的密钥，也就是非对称密钥加密系统，每个通信方都需要两个密钥，这两个密钥就是公钥和私钥 。 公钥是公开的，不需要保密，而私钥是私有的，对其需要保管和隐蔽，以防别人知道 。<br> 每一个公钥对应一个私钥 。 在密钥对中，如果一个用作加密，则另一个用作解密 。 非对称密钥加密系统的主要应用有两个，分别是公钥加密和公钥认证。 公钥加密和公钥认证的过程并不一样，下面分别进行简单介绍 。</p> 
  <p>为了让读者更容易理解什么是<strong>公钥加密</strong>，先来看一个简单的例子 。 若有两个用户 Jack和 Michael, Jack 想把一段文字通过公钥加密技术发送给 Michael ，而 Michael 有一对公钥和私钥，那么这个加密和解密过程如下：首先， Michael 将他的公钥发送给 Jack ，接着 Jack就用他收到的公钥对文字进行加密，将加密后的结果发送给 Michael ，最后 Michael 用他的私钥解密 Jack 发送给他的消息 。 整体过程如图 2-4 所示 。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927162024964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6cGJyaWdodA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><strong>公钥认证</strong>即通过鉴别一个用户的私钥是否正确来鉴别这个用户的真伪 。 列举一个简单的例子， Michael 想让 Jack 知道自己是真实的 Michael ，而不是其他人假 冒的，所以Michael 使用私钥对文件进行签名，发送给 Jack, Jack 再用 Michael 的公钥解密文件，从而验证签名是否来自真实的 M ichael 。 整体流程如图 2-5 所示 。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927162224919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l6cGJyaWdodA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p>从上述两个例子可以看出，公钥加密是发送者先用公钥加密，接收者再用私钥解密，而公钥认证则是发送者先用私钥加密，接收者再用公钥解密以验证。</p> 
  <p>以太坊中每个外部账户都由一对密匙定义，即一个私钥和一个公钥 。 每对密钥都编码在一个钥匙文件里 。 钥匙文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览 。 钥匙文件的关键部分一一账户私钥，通常使用创建账户时设置的密码进行加密 。 目前最新的密钥文件格式是： <code>UTC--&lt;created at UTC IS08601&gt;-&lt;address hex&gt;</code> 。 钥匙文件可以在以太坊节点数据目录的 keystore 子目录下找到 。</p> 
  <p>目前常见的私钥有三种形态： Private key、 Keystore &amp; Password 以及 Memonic code 。<br> 1 ) Private key 就是一份随机生成的 256 位二进制数字，用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串 256 位的仅包含“0”或“ 1 ”的字符串 。 该 256 位二进制数字就是私钥最初始的状态 。<br> 2 ）而在以太坊官方钱包中，私钥和公钥将会以加密的方式保存一份 JSON 文件，存储在 keystore 子目录下 。 这份 JSON 文件就是 Keystore ，所以用户需要同时备份 Keystore和对应的 Password （创建钱包时设置的密码） 。<br> 3 ）最后一种 Memonic code 是由 BIP 39 方案提出的，目的是随机生成 12 ～ 24 个比较容易记住的单词，该单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子，该种子通过 BIP-0032 提案的方式生成确定性钱包 。</p> 
  <p><strong>2.3.4 钱包</strong><br> 钱包是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的用户就可以拥有对应地址的账户里的以太币使用权 。 我们通常把管理这些数字密钥的软件称为“钱包”，而我们所说的“备份钱包”其实就是备份账户的私钥文件 。</p> 
  <h2><a id="24__75"></a>2.4 数据结构与存储</h2> 
  <p>包括以太坊和比特币在内的大多数区块链项目，会使用 Merkle 树或基于 Merkle 树的数据结构，比特币中保存了一棵 Merkle 树，而以太坊针对三种对象设计了 三棵 Merkle 树( Merkle Patrcia 树），分别是状态树、交易树和收据树，这三种树可以帮助以太坊客户端做一些简易的查询，如查询某个账户的余额 、 某笔交易是否被包含在区块中等 。 区块 、 交易等数据最终都是存储在 LeveIDB 数据库中 。 LeveIDB 数据库是一个键值对（ key-value ）数<br> 据库， key 一般与散列相关， value 则是存储内容的 RLP 编码 。</p> 
  <p><strong>2.4.1 数据组织形式</strong><br> 以太坊使用了 Merkle Patircia 树（又称 Merkle Patricia Trie ，简称 MPT ），作为数据组织形式，用来组织管理用户的账户状态、交易信息等重要数据 。 MPT 是一种加密认证的数据结构，它融合了 Merkle 树和 Trie 树（前缀树）两种数据类型的优点，我们首先来介绍一下这两种数据结构 。</p> 
  <ol> 
   <li>Merkle 树</li> 
   <li>Trie 树</li> 
   <li>Merkle Patricia 树</li> 
  </ol> 
  <p><strong>2.4.2 状态树</strong></p> 
  <p><strong>2.4.3 交易树</strong></p> 
  <p><strong>2.4.4 收据树</strong></p> 
  <p><strong>2.4.5 数据库支持一一LevelDB</strong></p> 
  <h2><a id="25__99"></a>2.5 共识机制</h2> 
  <p>共识机制是区块链事务达成分布式共识的算法 。 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 。<br> <strong>2.5.1 Pow</strong><br> PoW 即通过工作结果来证明你完成了相应的工作 。 由于工作过程繁琐而低效，而其验证忽视工作过程、直接认证结果，这样工作者虽花费一定的时间完成工作，但是验证者却可以瞬间完成检验，因此这种方法往往简洁而高效。</p> 
  <p>在以太坊中，有一个专门设计的 PoW 算法一Ethash 算法 。 之所以用 Ethash 算法来代替原有的 PoW 算法，是为了解决挖矿中心化问题。 现在的情况是，在 Pow 算法下，小部分的硬件公司和挖矿机构通过挖矿资源的集 中， 获得了可 以 “操控”现有网络 内经济力量的优势，并以此获得高利润（如比特币和莱特币） 。这些组织可以生产具有超高散列计算性能的 ASIC (Application Specific Integrated Circuit ，特殊应用的集成电路），为自己赚取利润，这意味着挖矿不再是高度去中心化和追求平等主义的， 而是需要巨额资本的有效参与 。在这种情况下很可能会出现一个现象：一个以实现“去中心化”为目的的系统因为现实生活中矿机资源的集中而有了中心 。 为了解决这一问题，以太坊基金会专门设计了一个能‘抵制 ASIC ”、轻客户端可快速验证的 PoW 算法，希望减少中心化挖矿在以太坊中获得的经济奖励，这就是 Ethash 算法 。</p> 
  <p>以太坊试图让挖矿者从区块链状态中获取随机数据，计算一些从区块链最后的 N个区块中随机选择的交易，返回结果散列 。 这样做的好处有两点 。 首先， 以太坊合约能够包含任何种类的计算方式，这样以太坊的 ASIC 本质上其实是一个提供普通计算的专门集成电路，相当于一个性能很好的 CPU 。 其次 ，挖矿需要访问整个区块链，这就迫使挖矿者保存完整的区块链 。</p> 
  <p>Ethash 算法的特点是挖矿的效率基本与 CPU 无关，而与内存大小、带宽正相关，目的是去除专用硬件的优势，抵抗 ASIC 。 该算法的基本流程如下 。<br> 1 ）对于每一个区块，都能通过扫描区块头的方式计算出一个种子（ seed ），该种子只与当前区块有关。<br> 2 ）使用种子能产生一个 16MB 的伪随机缓存，轻客户端会存储缓存 。<br> 3 ）基于缓存再生成一个 1GB 的数据集，称其为 DAG 。 数据集中的每一个元素都只依赖于缓存中的某几个元素 ，也就是说，只要有缓存，就可以快速地计算出 DAG 中指定位置的元素 。 挖矿者存储数据集，数据集随时间线性增长 。<br> 4 ）挖矿可以概括为“矿工 ”从 DAG 中随机选择元素并对其进行散列的过程， DAG 也可以理解为一个完整的搜索空间，挖矿的过程就是从 DAG 中随机选择元素（类似比特币挖矿中试探合适 nonce 的过程）进行散列运算 。<br> 5 ）验证者只需要花费少量的内存存储缓存就可以了，因为验证者能够基于缓存计算得到 DAG 中自己需要的指定位置的元素，然后验证这些指定元素的散列是不是小于某个散列值，也就是验证“矿工”的工作是否符合要求 。</p> 
  <p>缓存和 DAG 中每增加 30000 个区块更新一次，所以绝大多数的“矿工”将把精力放在读取数据集上，而不是改变它 。</p> 
  <p><strong>2.5.2 PoS</strong><br> PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是一种对货币所有权的证明 。 PoS 可以被描述成虚拟挖矿， 一般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 。 不过相比于 PoW 机制下的挖矿，虚拟挖矿消耗的电力可以忽略不计。</p> 
  <p>在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式的交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程。</p> 
  <p>有许多共识算法和方式对验证者进行奖励，以此来激励以太坊用户支持 PoS 。 从算法的角度来说，主要有两种类型：基于链的 PoS 和 BFT (Byzantine Fault Tolerant ，拜占庭容错）风格的 PoS 。</p> 
  <p>在基于链的 PoS 中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者（比如，设置每 lOs 一个周期，每个周期都是一个时隙），给予验证者创建新区块的权利，但是验证者要确保该块指向最多的块（指向的上一个块通常是最长链的最后一个块） 。 因此，随着时间的推移，大多数的块都收敛到一条链上 。</p> 
  <p>在 BFT 风格的 PoS 中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链 。 在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将 “商量”被给定的块是否可以添加到区块链中，并且意见不能改变 。</p> 
  <p>相比于 PoW, PoS 有以下优点 。</p> 
  <ul> 
   <li>不需要为了保证区块链的安全而消耗大量的电力资掘 。由于消耗较少，通过发行新币以激励参与者继续参与网络活动的压力会减少，理论上货币的负总发行量成为可能。</li> 
   <li>PoS 促进区块链技术的发展。 “矿工”从消耗大量资源的挖矿行为中解放出来，将算力资源转向区块链技术的开发应用上，促使区块链技术的蓬勃发展 。</li> 
   <li>随着规模经济（指扩大生产规模引起经济效益增加的现象）的消失，中心化所带来的风险减小 。 价值 100 万法币的以太币带来的回报比 10万法币带来的多 10 倍，不会有人负担大规模的生产工具却得不到相应的回报。</li> 
   <li>PoS 更安全 。 其实施的奖励惩罚措施使得各种恶意攻击变得极其昂贵，从而确保网络安全 。</li> 
  </ul> 
  <h2><a id="26__136"></a>2.6 以太币</h2> 
  <p>以太币（ ETH ）是以太坊发行的一种数字货币，被认为是“比特币 2.0 版” 。 以太币是以太坊中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 。<br> 以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。具体的分配大致如下：</p> 
  <ul> 
   <li>预付款的贡献者总共有 6000 万个以太币 。</li> 
   <li>每挖出 一个新的区块，给挖出该区块的矿工奖励 5 个以太币 。</li> 
   <li>如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用，每个叔区块会为挖矿者产出大约 4.375个以太币（ 5 个以太币奖励的 7/8 ），这被称为叔区块奖励 。 另外矿工每引用一个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 。</li> 
  </ul> 
  <h2><a id="27__144"></a>2.7 交易</h2> 
  <p>以太坊的交易主要是指一条外部账户发送到区块链上另 一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 。以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 。 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 。 GasPrice 根据市场波动调整，避免以太币价值受市场价格的影响。 交易是以太坊整体架构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用 。</p> 
  <p><strong>2.7.1 交易费用</strong><br> 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 0 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 。</p> 
  <ul> 
   <li> <p>Gas<br> Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 。 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 。 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改；对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 。 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 。<br> 一笔普通的转账交易会消耗 21000Gas ，而一个创建智能合约的交易可能会消耗几万，甚至几百万 Gas 。</p> </li> 
   <li> <p>Gas Price<br> Gas Price ( Gas 价格）是一单位 Gas 所需的手续费（以太币，即 Ether），例如一个转账交易消耗 21000Gas，假设 Gas Price 为 1 Gwei/Gas ，那么这笔交易的手续费为 0.000021Ether 。<br> 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为 0。 但是，目前以1太坊钱包客户端默认的 GasPrice 是 0.00000000 I Ether /Gas ( I Gwei, /Gas=1 G wei Gas ） 。因为矿工有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 1 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 。</p> </li> 
   <li> <p>Gas Limit<br> 上文讲了 Gas 是衡量交易的计算开销的基本单位 。 在以太坊的实际操作中，用户需要注意两个 Gas Limit 的概念：对于单个交易， Gas Limit （有时也会称作 Start Gas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 。</p> </li> 
  </ul> 
  <p><strong>2.7.2 交易内容</strong><br> 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 。<br> 一条交易包含以下内容 。</p> 
  <ul> 
   <li>from ：交易发送者的地址，必填；</li> 
   <li>to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易；</li> 
   <li>value ：发送者要转移给接收者的以太币数量；</li> 
   <li>data （也写作 input）：存在的数据字段，如果存在，则是表明该交易是一个创建或者调用智能合约交易；</li> 
   <li>Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量；</li> 
   <li>GasPrice ：表示发送者愿意支付给矿工的 Gas 价格；</li> 
   <li>nonce ：用来区别同一用户发 出的不同交易的标记；</li> 
   <li>hash ：由以上信息生成的散列值（哈希值），作为交易的 ID;</li> 
   <li>r 、 s 、 v ：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 。</li> 
  </ul> 
  <p>以上是以太坊中交易可能包含的内容，在不同的场景下，交易有三种类型 。</p> 
  <p>1 ）转账交易 ：转账是最简单的一种交易， 从一个账户向另一个账户发送以太币 。 发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit 、 Gas Price 、 nonce 、 hash 、签名可以按照默认方式生成），如下所示 。</p> 
  <pre><code>web3.eth.sendTransaction({
	from:”0xb60e8dd6lc5d32be8058bb8eb970870f07233155”,
	to:”0xd46e8dd67c5d32be8058bb8eb970870f07244567”,
	value: 10000000000000000
});
</code></pre> 
  <p>2 ）创建智能合约的交易：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的 。 在创建合约的交易中 ， “ to” 字段是一个空字符串，在“data”字段中指定初始化合约的二进制代码，在之后合约被调用时，该代码的执行结果将作为合约代码 。 如下所示 。</p> 
  <pre><code>web3.eth.sendTransaction({
	from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”,
	data:”contract binary code”
});
</code></pre> 
  <p>3 ）执行智能合约的交易 ：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ to”字段指定为要调用的智能合约的地址，通过“data”字段指定要调用的方法以及向该方法传递参数 。 如下所示 。</p> 
  <pre><code>web3.eth.sendTransaction({
	from:” 0xb60e8dd6lc5d32be8058bb8eb970870f07233155”,
	to:”0xb4259e5d9bc67a0f2ce3ed372ffc5lbe46c33c4d",
	data:“hash of the invoked method signature and encoded parameters ”
});
</code></pre> 
  <p><strong>2.7.3 一个交易在以太坊中的“旅程”</strong><br> 在以太坊中，交易的处理是一个过程， 从账户发起交易请求开始，到包含该交易的区块被共识节点同步为止（一般来说，出于安全性的考虑，会等到该区块后面再“挖”出一些块，这笔交易才算确定），满足这一过程才算完成了一笔“交易” 。</p> 
  <ol> 
   <li> <p>一笔普通的转账或合约调用交易的“旅程”</p> </li> 
   <li> <p>一个创建智能合约的交易在以太坊中的“旅程”</p> </li> 
  </ol> 
  <h2><a id="28__210"></a>2.8 数据编码与压缩</h2> 
  <p>RLP ( Recursive Length Prefix）是一种编码算法，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 。</p> 
  <h2><a id="29__API_214"></a>2.9 以大坊客户端和 API</h2> 
  <h2><a id="210__217"></a>2.10 以太坊域名服务</h2> 
  <p>ENS ( Ethereum Name Service ，以太坊域名服务）是建立在以太坊区块链上的分布式、开放的命名系统 。</p> 
  <h2><a id="211__220"></a>2.11 本章小结</h2> 
  <p>作为先进公有链的代表之一，以太坊区块链本质是一串连接的数据区块，区块之间由使用密码学算法生成的散列指针链接 。 本章主要向读者介绍了以太坊的基本架构和组成，让用户对以太坊的区块、交易、账户等基本组成有一定了解 。 除此以外还向用户介绍了以太坊的数据结构和存储支持，以便读者能够对其底层结构有所了解 。 最后，本章还介绍了以太坊的人口一一客户端和以太坊域名服务（ ENS ），让用户能够了解以太坊的顶层应用 。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yzpbright/article/details/82855245,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yzpbright/article/details/82855245,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
