<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码–交易的产生（四）–脚本和签名 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码–交易的产生（四）–脚本和签名" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82866757 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 1.address 2.脚本构建 2.1GetScriptForDestination 2.2GetScriptForMultisig 2.3GetScriptForWitness 3.签名 3.1ProduceSignature 3.1.1SignStep 3.1.2Solver 3.1.3Sign1 在sendmany里为每个接受者地址构建脚本是 CScript scriptPubKey = GetScriptForDestination(address.Get()); 1.address 这里的address是CBitcoinAddress address(name_);，调用了CTxDestination CBitcoinAddress::Get() typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; 介绍一下variant，variant相当于增强型的union，也就是CTxDestination可以是CNoDestination, CKeyID, CScriptID中的任意一个类型 vchVersion是CBitcoinAddress的父类CBase58Data的保护变量 CTxDestination CBitcoinAddress::Get() const { if (!IsValid()) return CNoDestination(); uint160 id; memcpy(&amp;id, &amp;vchData[0], 20); if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) return CKeyID(id); else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) return CScriptID(id); else return CNoDestination(); } 这段代码就是做逻辑判断，如果是公钥地址则调用CKeyID(id)，如果是脚本地址则调用CScriptID(id)。 其中的CChainParams::PUBKEY_ADDRESS参数是 class CChainParams { public: enum Base58Type { PUBKEY_ADDRESS, SCRIPT_ADDRESS, SECRET_KEY, EXT_PUBLIC_KEY, EXT_SECRET_KEY, MAX_BASE58_TYPES }; 这个CChainParams下还有三个子类，分别对应不同网络的可调整参数,我们先来看测试网的，其中一段 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); base58Prefixes[SECRET_KEY] = std::vector&lt;unsigned char&gt;(1,239); base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); 接下来看CKeyID CKeyID(const uint160&amp; in) : uint160(in) {} 就是对输入做了hash160的处理，那么来看CScriptID CScriptID(const uint160&amp; in) : uint160(in) {} 也是一样的处理 2.脚本构建 2.1GetScriptForDestination 接着来看GetScriptForDestination函数 CScript GetScriptForDestination(const CTxDestination&amp; dest) { CScript script; boost::apply_visitor(CScriptVisitor(&amp;script), dest); return script; } 因为CTxDestination是boost::variant类型的，根据CScriptVisitor的内部结构来看是用了访问者模式 CScriptVisitor继承类boost::static_visitor，在类里面需要重载()操作符，通过boost::apply_visitor来访问原始类型的值 namespace { class CScriptVisitor : public boost::static_visitor&lt;bool&gt; { private: CScript *script; public: CScriptVisitor(CScript *scriptin) { script = scriptin; } bool operator()(const CNoDestination &amp;dest) const { script-&gt;clear(); return false; } //这里是比特币地址的处理，script用于保存组装好的脚本 bool operator()(const CKeyID &amp;keyID) const { script-&gt;clear(); *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG; return true; } //这里是支付到脚本地址的处理 bool operator()(const CScriptID &amp;scriptID) const { script-&gt;clear(); *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL; return true; } }; } 回顾一下锁定脚本，给出的例子就是 1）P2PKH： OP_DUP OP_HSAH160 OP_EQUALVERIFY OP_CHECKSIG 2）P2SH： OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL 和上面的代码是符合的，另外脚本操作都定义在script.h中 在standard.cpp目录下还有多重签名脚本和隔离见证的脚本构造也一并介绍了 2.2GetScriptForMultisig CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { CScript script; script &lt;&lt; CScript::EncodeOP_N(nRequired); BOOST_FOREACH(const CPubKey&amp; key, keys) script &lt;&lt; ToByteVector(key); script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; return script; } 多重签名的锁定脚本例子 M &lt;Public Key 1&gt; &lt;Public Key 2&gt; … N CHECKMULTISIG 其中M 是花费输出所需的签名的数量，N 是列出的公钥的总数 2.3GetScriptForWitness CScript GetScriptForWitness(const CScript&amp; redeemscript) { CScript ret; txnouttype typ; std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (Solver(redeemscript, typ, vSolutions)) { if (typ == TX_PUBKEY) { unsigned char h160[20]; CHash160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160); ret &lt;&lt; OP_0 &lt;&lt; std::vector&lt;unsigned char&gt;(&amp;h160[0], &amp;h160[20]); return ret; } else if (typ == TX_PUBKEYHASH) { ret &lt;&lt; OP_0 &lt;&lt; vSolutions[0]; return ret; } } uint256 hash; CSHA256().Write(&amp;redeemscript[0], redeemscript.size()).Finalize(hash.begin()); ret &lt;&lt; OP_0 &lt;&lt; ToByteVector(hash); return ret; } 这个函数的传入参数就是脚本，也就是之前构建好的脚本。这里的逻辑是针对公钥和公钥hash有不同的处理方法，以及对支付给脚本hash的处理 例子是 1)P2WPKH : OP_0 &lt;20-byte witness program&gt; 2)P2WSH:OP_0 &lt;32-byte witness program&gt; 3.签名 在createtransaction中的签名是调用 if (sign) signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); SIGHASH_ALL是签名哈希类型的一个，表示签名承诺的交易部分，all表示承诺所有的输入和输出 3.1ProduceSignature 先来看ProduceSignature这个函数，主要逻辑是判断锁定脚本类型,然后对应处理 如果是P2SH第一次调用SignStep返回的不是签名而是赎回脚本，需要另外处理，还有隔离见证的也需要。 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { CScript script = fromPubKey; bool solved = true; std::vector&lt;valtype&gt; result; txnouttype whichType; solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);//SIGVERSION_BASE=0 bool P2SH = false; CScript subscript; sigdata.scriptWitness.stack.clear(); if (solved &amp;&amp; whichType == TX_SCRIPTHASH)//解析赎回脚本 { // Solver returns the subscript that needs to be evaluated; // the final scriptSig is the signatures from that // and then the serialized subscript: script = subscript = CScript(result[0].begin(), result[0].end()); solved = solved &amp;&amp; SignStep(creator, script, result, whichType, SIGVERSION_BASE) &amp;&amp; whichType != TX_SCRIPTHASH; P2SH = true; } if (solved &amp;&amp; whichType == TX_WITNESS_V0_KEYHASH)//隔离见证 { CScript witnessscript; witnessscript &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(result[0]) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG;//隔离见证脚本的组装 txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0); sigdata.scriptWitness.stack = result; result.clear(); } else if (solved &amp;&amp; whichType == TX_WITNESS_V0_SCRIPTHASH)//隔离见证 { CScript witnessscript(result[0].begin(), result[0].end()); txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) &amp;&amp; subType != TX_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_KEYHASH; result.push_back(std::vector&lt;unsigned char&gt;(witnessscript.begin(), witnessscript.end())); sigdata.scriptWitness.stack = result; result.clear(); } if (P2SH) {//脚本公钥 result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); } sigdata.scriptSig = PushAll(result); // Test solution return solved &amp;&amp; VerifyScript(sigdata.scriptSig, fromPubKey, &amp;sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker()); } 签名数据保存在sigdata中 3.1.1SignStep 需要先了解SignStep，从注释来看 使用创建者(creator)签名签署scriptPubKey。 签名在scriptSigRet中返回（如果无法对scriptPubKey进行签名，则返回false），除非whichTypeRet是TX_SCRIPTHASH，在这种情况下，scriptSigRet是兑换脚本。 如果无法完全满足scriptPubKey，则返回false。 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { CScript scriptRet; uint160 h160; ret.clear(); vector&lt;valtype&gt; vSolutions; if (!Solver(scriptPubKey, whichTypeRet, vSolutions))//whichTypeRet脚本类型，vSolutions保存脚本hash值 return false; CKeyID keyID; switch (whichTypeRet) { case TX_NONSTANDARD: case TX_NULL_DATA: return false; case TX_PUBKEY: keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion);//签名保存在ret case TX_PUBKEYHASH: keyID = CKeyID(uint160(vSolutions[0])); if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) return false; else { CPubKey vch; creator.KeyStore().GetPubKey(keyID, vch); ret.push_back(ToByteVector(vch)); } return true; case TX_SCRIPTHASH: if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; case TX_MULTISIG: ret.push_back(valtype()); // workaround CHECKMULTISIG bug return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); case TX_WITNESS_V0_KEYHASH: ret.push_back(vSolutions[0]); return true; case TX_WITNESS_V0_SCRIPTHASH: CRIPEMD160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin()); if (creator.KeyStore().GetCScript(h160, scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; default: return false; } } 可以看到有三个类型TX_SCRIPTHASH，TX_WITNESS_V0_KEYHASH，TX_WITNESS_V0_SCRIPTHASH没有调用签名函数，所以还要再次调用签名处理的。 3.1.2Solver Return public keys or hashes from scriptPubKey, for ‘standard’ transaction types. 对于“标准”事务类型，从scriptPubKey返回公钥或哈希值。 鉴于这个代码也很长，不想说了，scriptPubKey是指锁定脚本，不是单指公钥脚本，好吧稍微写一点好了 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, vector&lt;vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) {// Templates static multimap&lt;txnouttype, CScript&gt; mTemplates;//构造模版 if (mTemplates.empty()) { // Standard tx, sender provides pubkey, receiver adds signature //标准交易，发送者提供公钥，接收者添加签名 mTemplates.insert(make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey //比特币地址交易，发送者提供公钥哈希，接收者提供签名和公钥 mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); // Sender provides N pubkeys, receivers provides M signatures //多重签名，发送者提供n个公钥，接收者提供m个签名 mTemplates.insert(make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); } vSolutionsRet.clear(); // Shortcut for pay-to-script-hash, which are more constrained than the other types: // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL //付费到脚本哈希的快捷方式，比其他类型更受限制：它总是OP_HASH160 20 [20字节哈希] OP_EQUAL if (scriptPubKey.IsPayToScriptHash())//对P2SH的处理 { typeRet = TX_SCRIPTHASH; //20字节哈希我们是知道，前面两字节是操作OP_HASH160和代表长度的字节 vector&lt;unsigned char&gt; hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22); vSolutionsRet.push_back(hashBytes); return true; } ···· 判断是否脚本hash，写的比较明确了 bool CScript::IsPayToScriptHash() const { // Extra-fast test for pay-to-script-hash CScripts: return (this-&gt;size() == 23 &amp;&amp; (*this)[0] == OP_HASH160 &amp;&amp; (*this)[1] == 0x14 &amp;&amp; (*this)[22] == OP_EQUAL); } vSolutionsRet保存的是hash值 函数运行后，typeRet会保存锁定脚本的类型，这是枚举类型 enum txnouttype { TX_NONSTANDARD, // &#39;standard&#39; transaction types: TX_PUBKEY, TX_PUBKEYHASH, TX_SCRIPTHASH, TX_MULTISIG, TX_NULL_DATA, TX_WITNESS_V0_SCRIPTHASH, TX_WITNESS_V0_KEYHASH, }; 在来说点函数里的代码，接上一段代码，这里是对隔离见证的处理，隔离见证也是固定的长度，20或者32字节 int witnessversion; std::vector&lt;unsigned char&gt; witnessprogram; if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 20) { typeRet = TX_WITNESS_V0_KEYHASH; vSolutionsRet.push_back(witnessprogram); return true; } if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 32) { typeRet = TX_WITNESS_V0_SCRIPTHASH; vSolutionsRet.push_back(witnessprogram); return true; } return false; } 这里涉及到的判断,也写的很清楚，截取见证内容保存到program中 bool CScript::IsWitnessProgram(int&amp; version, std::vector&lt;unsigned char&gt;&amp; program) const { if (this-&gt;size() &lt; 4 || this-&gt;size() &gt; 42) { return false; } if ((*this)[0] != OP_0 &amp;&amp; ((*this)[0] &lt; OP_1 || (*this)[0] &gt; OP_16)) { return false; } if ((size_t)((*this)[1] + 2) == this-&gt;size()) { version = DecodeOP_N((opcodetype)(*this)[0]); program = std::vector&lt;unsigned char&gt;(this-&gt;begin() + 2, this-&gt;end()); return true; } return false; } 再返回函数部分， if (scriptPubKey.size() &gt;= 1 &amp;&amp; scriptPubKey[0] == OP_RETURN &amp;&amp; scriptPubKey.IsPushOnly(scriptPubKey.begin()+1)) { typeRet = TX_NULL_DATA; return true; } 在这段之后就是对最开始的mTemplates的处理，对三种的处理，轮询处理 3.1.3Sign1 在解析出脚本类型和脚本hash或公钥后回到SignStep函数中，以公钥脚本为例，查看如何签名 keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion); 来看Sign1这个函数,签名保存在ret变量中 static bool Sign1(const CKeyID&amp; address, const BaseSignatureCreator&amp; creator, const CScript&amp; scriptCode, std::vector&lt;valtype&gt;&amp; ret, SigVersion sigversion) { vector&lt;unsigned char&gt; vchSig; if (!creator.CreateSig(vchSig, address, scriptCode, sigversion)) return false; ret.push_back(vchSig); return true; } 函数中是调用的CreateSig,不能用非压缩格式的私钥签名个隔离见证脚本 bool TransactionSignatureCreator::CreateSig(std::vector&lt;unsigned char&gt;&amp; vchSig, const CKeyID&amp; address, const CScript&amp; scriptCode, SigVersion sigversion) const { CKey key; if (!keystore-&gt;GetKey(address, key)) return false; // Signing with uncompressed keys is disabled in witness scripts if (sigversion == SIGVERSION_WITNESS_V0 &amp;&amp; !key.IsCompressed()) return false; uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);//要签名的hash if (!key.Sign(hash, vchSig))//签名的调用 return false; vchSig.push_back((unsigned char)nHashType);//加上hash类型 return true; } 到这里就有签名了 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82866757 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 1.address 2.脚本构建 2.1GetScriptForDestination 2.2GetScriptForMultisig 2.3GetScriptForWitness 3.签名 3.1ProduceSignature 3.1.1SignStep 3.1.2Solver 3.1.3Sign1 在sendmany里为每个接受者地址构建脚本是 CScript scriptPubKey = GetScriptForDestination(address.Get()); 1.address 这里的address是CBitcoinAddress address(name_);，调用了CTxDestination CBitcoinAddress::Get() typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; 介绍一下variant，variant相当于增强型的union，也就是CTxDestination可以是CNoDestination, CKeyID, CScriptID中的任意一个类型 vchVersion是CBitcoinAddress的父类CBase58Data的保护变量 CTxDestination CBitcoinAddress::Get() const { if (!IsValid()) return CNoDestination(); uint160 id; memcpy(&amp;id, &amp;vchData[0], 20); if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) return CKeyID(id); else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) return CScriptID(id); else return CNoDestination(); } 这段代码就是做逻辑判断，如果是公钥地址则调用CKeyID(id)，如果是脚本地址则调用CScriptID(id)。 其中的CChainParams::PUBKEY_ADDRESS参数是 class CChainParams { public: enum Base58Type { PUBKEY_ADDRESS, SCRIPT_ADDRESS, SECRET_KEY, EXT_PUBLIC_KEY, EXT_SECRET_KEY, MAX_BASE58_TYPES }; 这个CChainParams下还有三个子类，分别对应不同网络的可调整参数,我们先来看测试网的，其中一段 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); base58Prefixes[SECRET_KEY] = std::vector&lt;unsigned char&gt;(1,239); base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); 接下来看CKeyID CKeyID(const uint160&amp; in) : uint160(in) {} 就是对输入做了hash160的处理，那么来看CScriptID CScriptID(const uint160&amp; in) : uint160(in) {} 也是一样的处理 2.脚本构建 2.1GetScriptForDestination 接着来看GetScriptForDestination函数 CScript GetScriptForDestination(const CTxDestination&amp; dest) { CScript script; boost::apply_visitor(CScriptVisitor(&amp;script), dest); return script; } 因为CTxDestination是boost::variant类型的，根据CScriptVisitor的内部结构来看是用了访问者模式 CScriptVisitor继承类boost::static_visitor，在类里面需要重载()操作符，通过boost::apply_visitor来访问原始类型的值 namespace { class CScriptVisitor : public boost::static_visitor&lt;bool&gt; { private: CScript *script; public: CScriptVisitor(CScript *scriptin) { script = scriptin; } bool operator()(const CNoDestination &amp;dest) const { script-&gt;clear(); return false; } //这里是比特币地址的处理，script用于保存组装好的脚本 bool operator()(const CKeyID &amp;keyID) const { script-&gt;clear(); *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG; return true; } //这里是支付到脚本地址的处理 bool operator()(const CScriptID &amp;scriptID) const { script-&gt;clear(); *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL; return true; } }; } 回顾一下锁定脚本，给出的例子就是 1）P2PKH： OP_DUP OP_HSAH160 OP_EQUALVERIFY OP_CHECKSIG 2）P2SH： OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL 和上面的代码是符合的，另外脚本操作都定义在script.h中 在standard.cpp目录下还有多重签名脚本和隔离见证的脚本构造也一并介绍了 2.2GetScriptForMultisig CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { CScript script; script &lt;&lt; CScript::EncodeOP_N(nRequired); BOOST_FOREACH(const CPubKey&amp; key, keys) script &lt;&lt; ToByteVector(key); script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; return script; } 多重签名的锁定脚本例子 M &lt;Public Key 1&gt; &lt;Public Key 2&gt; … N CHECKMULTISIG 其中M 是花费输出所需的签名的数量，N 是列出的公钥的总数 2.3GetScriptForWitness CScript GetScriptForWitness(const CScript&amp; redeemscript) { CScript ret; txnouttype typ; std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (Solver(redeemscript, typ, vSolutions)) { if (typ == TX_PUBKEY) { unsigned char h160[20]; CHash160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160); ret &lt;&lt; OP_0 &lt;&lt; std::vector&lt;unsigned char&gt;(&amp;h160[0], &amp;h160[20]); return ret; } else if (typ == TX_PUBKEYHASH) { ret &lt;&lt; OP_0 &lt;&lt; vSolutions[0]; return ret; } } uint256 hash; CSHA256().Write(&amp;redeemscript[0], redeemscript.size()).Finalize(hash.begin()); ret &lt;&lt; OP_0 &lt;&lt; ToByteVector(hash); return ret; } 这个函数的传入参数就是脚本，也就是之前构建好的脚本。这里的逻辑是针对公钥和公钥hash有不同的处理方法，以及对支付给脚本hash的处理 例子是 1)P2WPKH : OP_0 &lt;20-byte witness program&gt; 2)P2WSH:OP_0 &lt;32-byte witness program&gt; 3.签名 在createtransaction中的签名是调用 if (sign) signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); SIGHASH_ALL是签名哈希类型的一个，表示签名承诺的交易部分，all表示承诺所有的输入和输出 3.1ProduceSignature 先来看ProduceSignature这个函数，主要逻辑是判断锁定脚本类型,然后对应处理 如果是P2SH第一次调用SignStep返回的不是签名而是赎回脚本，需要另外处理，还有隔离见证的也需要。 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { CScript script = fromPubKey; bool solved = true; std::vector&lt;valtype&gt; result; txnouttype whichType; solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);//SIGVERSION_BASE=0 bool P2SH = false; CScript subscript; sigdata.scriptWitness.stack.clear(); if (solved &amp;&amp; whichType == TX_SCRIPTHASH)//解析赎回脚本 { // Solver returns the subscript that needs to be evaluated; // the final scriptSig is the signatures from that // and then the serialized subscript: script = subscript = CScript(result[0].begin(), result[0].end()); solved = solved &amp;&amp; SignStep(creator, script, result, whichType, SIGVERSION_BASE) &amp;&amp; whichType != TX_SCRIPTHASH; P2SH = true; } if (solved &amp;&amp; whichType == TX_WITNESS_V0_KEYHASH)//隔离见证 { CScript witnessscript; witnessscript &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(result[0]) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG;//隔离见证脚本的组装 txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0); sigdata.scriptWitness.stack = result; result.clear(); } else if (solved &amp;&amp; whichType == TX_WITNESS_V0_SCRIPTHASH)//隔离见证 { CScript witnessscript(result[0].begin(), result[0].end()); txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) &amp;&amp; subType != TX_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_KEYHASH; result.push_back(std::vector&lt;unsigned char&gt;(witnessscript.begin(), witnessscript.end())); sigdata.scriptWitness.stack = result; result.clear(); } if (P2SH) {//脚本公钥 result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); } sigdata.scriptSig = PushAll(result); // Test solution return solved &amp;&amp; VerifyScript(sigdata.scriptSig, fromPubKey, &amp;sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker()); } 签名数据保存在sigdata中 3.1.1SignStep 需要先了解SignStep，从注释来看 使用创建者(creator)签名签署scriptPubKey。 签名在scriptSigRet中返回（如果无法对scriptPubKey进行签名，则返回false），除非whichTypeRet是TX_SCRIPTHASH，在这种情况下，scriptSigRet是兑换脚本。 如果无法完全满足scriptPubKey，则返回false。 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { CScript scriptRet; uint160 h160; ret.clear(); vector&lt;valtype&gt; vSolutions; if (!Solver(scriptPubKey, whichTypeRet, vSolutions))//whichTypeRet脚本类型，vSolutions保存脚本hash值 return false; CKeyID keyID; switch (whichTypeRet) { case TX_NONSTANDARD: case TX_NULL_DATA: return false; case TX_PUBKEY: keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion);//签名保存在ret case TX_PUBKEYHASH: keyID = CKeyID(uint160(vSolutions[0])); if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) return false; else { CPubKey vch; creator.KeyStore().GetPubKey(keyID, vch); ret.push_back(ToByteVector(vch)); } return true; case TX_SCRIPTHASH: if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; case TX_MULTISIG: ret.push_back(valtype()); // workaround CHECKMULTISIG bug return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); case TX_WITNESS_V0_KEYHASH: ret.push_back(vSolutions[0]); return true; case TX_WITNESS_V0_SCRIPTHASH: CRIPEMD160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin()); if (creator.KeyStore().GetCScript(h160, scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; default: return false; } } 可以看到有三个类型TX_SCRIPTHASH，TX_WITNESS_V0_KEYHASH，TX_WITNESS_V0_SCRIPTHASH没有调用签名函数，所以还要再次调用签名处理的。 3.1.2Solver Return public keys or hashes from scriptPubKey, for ‘standard’ transaction types. 对于“标准”事务类型，从scriptPubKey返回公钥或哈希值。 鉴于这个代码也很长，不想说了，scriptPubKey是指锁定脚本，不是单指公钥脚本，好吧稍微写一点好了 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, vector&lt;vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) {// Templates static multimap&lt;txnouttype, CScript&gt; mTemplates;//构造模版 if (mTemplates.empty()) { // Standard tx, sender provides pubkey, receiver adds signature //标准交易，发送者提供公钥，接收者添加签名 mTemplates.insert(make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey //比特币地址交易，发送者提供公钥哈希，接收者提供签名和公钥 mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); // Sender provides N pubkeys, receivers provides M signatures //多重签名，发送者提供n个公钥，接收者提供m个签名 mTemplates.insert(make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); } vSolutionsRet.clear(); // Shortcut for pay-to-script-hash, which are more constrained than the other types: // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL //付费到脚本哈希的快捷方式，比其他类型更受限制：它总是OP_HASH160 20 [20字节哈希] OP_EQUAL if (scriptPubKey.IsPayToScriptHash())//对P2SH的处理 { typeRet = TX_SCRIPTHASH; //20字节哈希我们是知道，前面两字节是操作OP_HASH160和代表长度的字节 vector&lt;unsigned char&gt; hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22); vSolutionsRet.push_back(hashBytes); return true; } ···· 判断是否脚本hash，写的比较明确了 bool CScript::IsPayToScriptHash() const { // Extra-fast test for pay-to-script-hash CScripts: return (this-&gt;size() == 23 &amp;&amp; (*this)[0] == OP_HASH160 &amp;&amp; (*this)[1] == 0x14 &amp;&amp; (*this)[22] == OP_EQUAL); } vSolutionsRet保存的是hash值 函数运行后，typeRet会保存锁定脚本的类型，这是枚举类型 enum txnouttype { TX_NONSTANDARD, // &#39;standard&#39; transaction types: TX_PUBKEY, TX_PUBKEYHASH, TX_SCRIPTHASH, TX_MULTISIG, TX_NULL_DATA, TX_WITNESS_V0_SCRIPTHASH, TX_WITNESS_V0_KEYHASH, }; 在来说点函数里的代码，接上一段代码，这里是对隔离见证的处理，隔离见证也是固定的长度，20或者32字节 int witnessversion; std::vector&lt;unsigned char&gt; witnessprogram; if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 20) { typeRet = TX_WITNESS_V0_KEYHASH; vSolutionsRet.push_back(witnessprogram); return true; } if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 32) { typeRet = TX_WITNESS_V0_SCRIPTHASH; vSolutionsRet.push_back(witnessprogram); return true; } return false; } 这里涉及到的判断,也写的很清楚，截取见证内容保存到program中 bool CScript::IsWitnessProgram(int&amp; version, std::vector&lt;unsigned char&gt;&amp; program) const { if (this-&gt;size() &lt; 4 || this-&gt;size() &gt; 42) { return false; } if ((*this)[0] != OP_0 &amp;&amp; ((*this)[0] &lt; OP_1 || (*this)[0] &gt; OP_16)) { return false; } if ((size_t)((*this)[1] + 2) == this-&gt;size()) { version = DecodeOP_N((opcodetype)(*this)[0]); program = std::vector&lt;unsigned char&gt;(this-&gt;begin() + 2, this-&gt;end()); return true; } return false; } 再返回函数部分， if (scriptPubKey.size() &gt;= 1 &amp;&amp; scriptPubKey[0] == OP_RETURN &amp;&amp; scriptPubKey.IsPushOnly(scriptPubKey.begin()+1)) { typeRet = TX_NULL_DATA; return true; } 在这段之后就是对最开始的mTemplates的处理，对三种的处理，轮询处理 3.1.3Sign1 在解析出脚本类型和脚本hash或公钥后回到SignStep函数中，以公钥脚本为例，查看如何签名 keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion); 来看Sign1这个函数,签名保存在ret变量中 static bool Sign1(const CKeyID&amp; address, const BaseSignatureCreator&amp; creator, const CScript&amp; scriptCode, std::vector&lt;valtype&gt;&amp; ret, SigVersion sigversion) { vector&lt;unsigned char&gt; vchSig; if (!creator.CreateSig(vchSig, address, scriptCode, sigversion)) return false; ret.push_back(vchSig); return true; } 函数中是调用的CreateSig,不能用非压缩格式的私钥签名个隔离见证脚本 bool TransactionSignatureCreator::CreateSig(std::vector&lt;unsigned char&gt;&amp; vchSig, const CKeyID&amp; address, const CScript&amp; scriptCode, SigVersion sigversion) const { CKey key; if (!keystore-&gt;GetKey(address, key)) return false; // Signing with uncompressed keys is disabled in witness scripts if (sigversion == SIGVERSION_WITNESS_V0 &amp;&amp; !key.IsCompressed()) return false; uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);//要签名的hash if (!key.Sign(hash, vchSig))//签名的调用 return false; vchSig.push_back((unsigned char)nHashType);//加上hash类型 return true; } 到这里就有签名了 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/28/7efbb3ce8dfebbde1a5d4c274694ae93.html" />
<meta property="og:url" content="https://mlh.app/2018/09/28/7efbb3ce8dfebbde1a5d4c274694ae93.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82866757 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 1.address 2.脚本构建 2.1GetScriptForDestination 2.2GetScriptForMultisig 2.3GetScriptForWitness 3.签名 3.1ProduceSignature 3.1.1SignStep 3.1.2Solver 3.1.3Sign1 在sendmany里为每个接受者地址构建脚本是 CScript scriptPubKey = GetScriptForDestination(address.Get()); 1.address 这里的address是CBitcoinAddress address(name_);，调用了CTxDestination CBitcoinAddress::Get() typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; 介绍一下variant，variant相当于增强型的union，也就是CTxDestination可以是CNoDestination, CKeyID, CScriptID中的任意一个类型 vchVersion是CBitcoinAddress的父类CBase58Data的保护变量 CTxDestination CBitcoinAddress::Get() const { if (!IsValid()) return CNoDestination(); uint160 id; memcpy(&amp;id, &amp;vchData[0], 20); if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) return CKeyID(id); else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) return CScriptID(id); else return CNoDestination(); } 这段代码就是做逻辑判断，如果是公钥地址则调用CKeyID(id)，如果是脚本地址则调用CScriptID(id)。 其中的CChainParams::PUBKEY_ADDRESS参数是 class CChainParams { public: enum Base58Type { PUBKEY_ADDRESS, SCRIPT_ADDRESS, SECRET_KEY, EXT_PUBLIC_KEY, EXT_SECRET_KEY, MAX_BASE58_TYPES }; 这个CChainParams下还有三个子类，分别对应不同网络的可调整参数,我们先来看测试网的，其中一段 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); base58Prefixes[SECRET_KEY] = std::vector&lt;unsigned char&gt;(1,239); base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container&lt;std::vector&lt;unsigned char&gt; &gt;(); 接下来看CKeyID CKeyID(const uint160&amp; in) : uint160(in) {} 就是对输入做了hash160的处理，那么来看CScriptID CScriptID(const uint160&amp; in) : uint160(in) {} 也是一样的处理 2.脚本构建 2.1GetScriptForDestination 接着来看GetScriptForDestination函数 CScript GetScriptForDestination(const CTxDestination&amp; dest) { CScript script; boost::apply_visitor(CScriptVisitor(&amp;script), dest); return script; } 因为CTxDestination是boost::variant类型的，根据CScriptVisitor的内部结构来看是用了访问者模式 CScriptVisitor继承类boost::static_visitor，在类里面需要重载()操作符，通过boost::apply_visitor来访问原始类型的值 namespace { class CScriptVisitor : public boost::static_visitor&lt;bool&gt; { private: CScript *script; public: CScriptVisitor(CScript *scriptin) { script = scriptin; } bool operator()(const CNoDestination &amp;dest) const { script-&gt;clear(); return false; } //这里是比特币地址的处理，script用于保存组装好的脚本 bool operator()(const CKeyID &amp;keyID) const { script-&gt;clear(); *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG; return true; } //这里是支付到脚本地址的处理 bool operator()(const CScriptID &amp;scriptID) const { script-&gt;clear(); *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL; return true; } }; } 回顾一下锁定脚本，给出的例子就是 1）P2PKH： OP_DUP OP_HSAH160 OP_EQUALVERIFY OP_CHECKSIG 2）P2SH： OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL 和上面的代码是符合的，另外脚本操作都定义在script.h中 在standard.cpp目录下还有多重签名脚本和隔离见证的脚本构造也一并介绍了 2.2GetScriptForMultisig CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { CScript script; script &lt;&lt; CScript::EncodeOP_N(nRequired); BOOST_FOREACH(const CPubKey&amp; key, keys) script &lt;&lt; ToByteVector(key); script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; return script; } 多重签名的锁定脚本例子 M &lt;Public Key 1&gt; &lt;Public Key 2&gt; … N CHECKMULTISIG 其中M 是花费输出所需的签名的数量，N 是列出的公钥的总数 2.3GetScriptForWitness CScript GetScriptForWitness(const CScript&amp; redeemscript) { CScript ret; txnouttype typ; std::vector&lt;std::vector&lt;unsigned char&gt; &gt; vSolutions; if (Solver(redeemscript, typ, vSolutions)) { if (typ == TX_PUBKEY) { unsigned char h160[20]; CHash160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160); ret &lt;&lt; OP_0 &lt;&lt; std::vector&lt;unsigned char&gt;(&amp;h160[0], &amp;h160[20]); return ret; } else if (typ == TX_PUBKEYHASH) { ret &lt;&lt; OP_0 &lt;&lt; vSolutions[0]; return ret; } } uint256 hash; CSHA256().Write(&amp;redeemscript[0], redeemscript.size()).Finalize(hash.begin()); ret &lt;&lt; OP_0 &lt;&lt; ToByteVector(hash); return ret; } 这个函数的传入参数就是脚本，也就是之前构建好的脚本。这里的逻辑是针对公钥和公钥hash有不同的处理方法，以及对支付给脚本hash的处理 例子是 1)P2WPKH : OP_0 &lt;20-byte witness program&gt; 2)P2WSH:OP_0 &lt;32-byte witness program&gt; 3.签名 在createtransaction中的签名是调用 if (sign) signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); SIGHASH_ALL是签名哈希类型的一个，表示签名承诺的交易部分，all表示承诺所有的输入和输出 3.1ProduceSignature 先来看ProduceSignature这个函数，主要逻辑是判断锁定脚本类型,然后对应处理 如果是P2SH第一次调用SignStep返回的不是签名而是赎回脚本，需要另外处理，还有隔离见证的也需要。 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { CScript script = fromPubKey; bool solved = true; std::vector&lt;valtype&gt; result; txnouttype whichType; solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);//SIGVERSION_BASE=0 bool P2SH = false; CScript subscript; sigdata.scriptWitness.stack.clear(); if (solved &amp;&amp; whichType == TX_SCRIPTHASH)//解析赎回脚本 { // Solver returns the subscript that needs to be evaluated; // the final scriptSig is the signatures from that // and then the serialized subscript: script = subscript = CScript(result[0].begin(), result[0].end()); solved = solved &amp;&amp; SignStep(creator, script, result, whichType, SIGVERSION_BASE) &amp;&amp; whichType != TX_SCRIPTHASH; P2SH = true; } if (solved &amp;&amp; whichType == TX_WITNESS_V0_KEYHASH)//隔离见证 { CScript witnessscript; witnessscript &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(result[0]) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG;//隔离见证脚本的组装 txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0); sigdata.scriptWitness.stack = result; result.clear(); } else if (solved &amp;&amp; whichType == TX_WITNESS_V0_SCRIPTHASH)//隔离见证 { CScript witnessscript(result[0].begin(), result[0].end()); txnouttype subType; solved = solved &amp;&amp; SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) &amp;&amp; subType != TX_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_SCRIPTHASH &amp;&amp; subType != TX_WITNESS_V0_KEYHASH; result.push_back(std::vector&lt;unsigned char&gt;(witnessscript.begin(), witnessscript.end())); sigdata.scriptWitness.stack = result; result.clear(); } if (P2SH) {//脚本公钥 result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); } sigdata.scriptSig = PushAll(result); // Test solution return solved &amp;&amp; VerifyScript(sigdata.scriptSig, fromPubKey, &amp;sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker()); } 签名数据保存在sigdata中 3.1.1SignStep 需要先了解SignStep，从注释来看 使用创建者(creator)签名签署scriptPubKey。 签名在scriptSigRet中返回（如果无法对scriptPubKey进行签名，则返回false），除非whichTypeRet是TX_SCRIPTHASH，在这种情况下，scriptSigRet是兑换脚本。 如果无法完全满足scriptPubKey，则返回false。 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { CScript scriptRet; uint160 h160; ret.clear(); vector&lt;valtype&gt; vSolutions; if (!Solver(scriptPubKey, whichTypeRet, vSolutions))//whichTypeRet脚本类型，vSolutions保存脚本hash值 return false; CKeyID keyID; switch (whichTypeRet) { case TX_NONSTANDARD: case TX_NULL_DATA: return false; case TX_PUBKEY: keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion);//签名保存在ret case TX_PUBKEYHASH: keyID = CKeyID(uint160(vSolutions[0])); if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) return false; else { CPubKey vch; creator.KeyStore().GetPubKey(keyID, vch); ret.push_back(ToByteVector(vch)); } return true; case TX_SCRIPTHASH: if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; case TX_MULTISIG: ret.push_back(valtype()); // workaround CHECKMULTISIG bug return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); case TX_WITNESS_V0_KEYHASH: ret.push_back(vSolutions[0]); return true; case TX_WITNESS_V0_SCRIPTHASH: CRIPEMD160().Write(&amp;vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin()); if (creator.KeyStore().GetCScript(h160, scriptRet)) { ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); return true; } return false; default: return false; } } 可以看到有三个类型TX_SCRIPTHASH，TX_WITNESS_V0_KEYHASH，TX_WITNESS_V0_SCRIPTHASH没有调用签名函数，所以还要再次调用签名处理的。 3.1.2Solver Return public keys or hashes from scriptPubKey, for ‘standard’ transaction types. 对于“标准”事务类型，从scriptPubKey返回公钥或哈希值。 鉴于这个代码也很长，不想说了，scriptPubKey是指锁定脚本，不是单指公钥脚本，好吧稍微写一点好了 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, vector&lt;vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) {// Templates static multimap&lt;txnouttype, CScript&gt; mTemplates;//构造模版 if (mTemplates.empty()) { // Standard tx, sender provides pubkey, receiver adds signature //标准交易，发送者提供公钥，接收者添加签名 mTemplates.insert(make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey //比特币地址交易，发送者提供公钥哈希，接收者提供签名和公钥 mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); // Sender provides N pubkeys, receivers provides M signatures //多重签名，发送者提供n个公钥，接收者提供m个签名 mTemplates.insert(make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); } vSolutionsRet.clear(); // Shortcut for pay-to-script-hash, which are more constrained than the other types: // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL //付费到脚本哈希的快捷方式，比其他类型更受限制：它总是OP_HASH160 20 [20字节哈希] OP_EQUAL if (scriptPubKey.IsPayToScriptHash())//对P2SH的处理 { typeRet = TX_SCRIPTHASH; //20字节哈希我们是知道，前面两字节是操作OP_HASH160和代表长度的字节 vector&lt;unsigned char&gt; hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22); vSolutionsRet.push_back(hashBytes); return true; } ···· 判断是否脚本hash，写的比较明确了 bool CScript::IsPayToScriptHash() const { // Extra-fast test for pay-to-script-hash CScripts: return (this-&gt;size() == 23 &amp;&amp; (*this)[0] == OP_HASH160 &amp;&amp; (*this)[1] == 0x14 &amp;&amp; (*this)[22] == OP_EQUAL); } vSolutionsRet保存的是hash值 函数运行后，typeRet会保存锁定脚本的类型，这是枚举类型 enum txnouttype { TX_NONSTANDARD, // &#39;standard&#39; transaction types: TX_PUBKEY, TX_PUBKEYHASH, TX_SCRIPTHASH, TX_MULTISIG, TX_NULL_DATA, TX_WITNESS_V0_SCRIPTHASH, TX_WITNESS_V0_KEYHASH, }; 在来说点函数里的代码，接上一段代码，这里是对隔离见证的处理，隔离见证也是固定的长度，20或者32字节 int witnessversion; std::vector&lt;unsigned char&gt; witnessprogram; if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 20) { typeRet = TX_WITNESS_V0_KEYHASH; vSolutionsRet.push_back(witnessprogram); return true; } if (witnessversion == 0 &amp;&amp; witnessprogram.size() == 32) { typeRet = TX_WITNESS_V0_SCRIPTHASH; vSolutionsRet.push_back(witnessprogram); return true; } return false; } 这里涉及到的判断,也写的很清楚，截取见证内容保存到program中 bool CScript::IsWitnessProgram(int&amp; version, std::vector&lt;unsigned char&gt;&amp; program) const { if (this-&gt;size() &lt; 4 || this-&gt;size() &gt; 42) { return false; } if ((*this)[0] != OP_0 &amp;&amp; ((*this)[0] &lt; OP_1 || (*this)[0] &gt; OP_16)) { return false; } if ((size_t)((*this)[1] + 2) == this-&gt;size()) { version = DecodeOP_N((opcodetype)(*this)[0]); program = std::vector&lt;unsigned char&gt;(this-&gt;begin() + 2, this-&gt;end()); return true; } return false; } 再返回函数部分， if (scriptPubKey.size() &gt;= 1 &amp;&amp; scriptPubKey[0] == OP_RETURN &amp;&amp; scriptPubKey.IsPushOnly(scriptPubKey.begin()+1)) { typeRet = TX_NULL_DATA; return true; } 在这段之后就是对最开始的mTemplates的处理，对三种的处理，轮询处理 3.1.3Sign1 在解析出脚本类型和脚本hash或公钥后回到SignStep函数中，以公钥脚本为例，查看如何签名 keyID = CPubKey(vSolutions[0]).GetID(); return Sign1(keyID, creator, scriptPubKey, ret, sigversion); 来看Sign1这个函数,签名保存在ret变量中 static bool Sign1(const CKeyID&amp; address, const BaseSignatureCreator&amp; creator, const CScript&amp; scriptCode, std::vector&lt;valtype&gt;&amp; ret, SigVersion sigversion) { vector&lt;unsigned char&gt; vchSig; if (!creator.CreateSig(vchSig, address, scriptCode, sigversion)) return false; ret.push_back(vchSig); return true; } 函数中是调用的CreateSig,不能用非压缩格式的私钥签名个隔离见证脚本 bool TransactionSignatureCreator::CreateSig(std::vector&lt;unsigned char&gt;&amp; vchSig, const CKeyID&amp; address, const CScript&amp; scriptCode, SigVersion sigversion) const { CKey key; if (!keystore-&gt;GetKey(address, key)) return false; // Signing with uncompressed keys is disabled in witness scripts if (sigversion == SIGVERSION_WITNESS_V0 &amp;&amp; !key.IsCompressed()) return false; uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);//要签名的hash if (!key.Sign(hash, vchSig))//签名的调用 return false; vchSig.push_back((unsigned char)nHashType);//加上hash类型 return true; } 到这里就有签名了 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/28/7efbb3ce8dfebbde1a5d4c274694ae93.html","headline":"比特币源码–交易的产生（四）–脚本和签名","dateModified":"2018-09-28T00:00:00+08:00","datePublished":"2018-09-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/28/7efbb3ce8dfebbde1a5d4c274694ae93.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码--交易的产生（四）--脚本和签名</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82866757 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81906838" rel="nofollow">交易的产生（一）–生成地址</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">交易的产生（二）–创建交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82351978" rel="nofollow">交易的产生（三）–提交交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82866757" rel="nofollow">交易的产生（四）–脚本和签名</a></p> 
  <hr> 
  <p></p>
  <div class="toc">
   <h3>目录</h3>
   <ul>
    <li><a href="#1address_13" rel="nofollow">1.address</a></li>
    <li><a href="#2_74" rel="nofollow">2.脚本构建</a></li>
    <ul>
     <li><a href="#21GetScriptForDestination_75" rel="nofollow">2.1GetScriptForDestination</a></li>
     <li><a href="#22GetScriptForMultisig_122" rel="nofollow">2.2GetScriptForMultisig</a></li>
     <li><a href="#23GetScriptForWitness_138" rel="nofollow">2.3GetScriptForWitness</a></li>
    </ul>
    <li><a href="#3_168" rel="nofollow">3.签名</a></li>
    <ul>
     <li><a href="#31ProduceSignature_176" rel="nofollow">3.1ProduceSignature</a></li>
     <ul>
      <li><a href="#311SignStep_231" rel="nofollow">3.1.1SignStep</a></li>
      <li><a href="#312Solver_295" rel="nofollow">3.1.2Solver</a></li>
      <li><a href="#313Sign1_406" rel="nofollow">3.1.3Sign1</a></li>
     </ul>
    </ul>
   </ul>
  </div>
  <p></p> 
  <hr> 
  <p>在sendmany里为每个接受者地址构建脚本是</p> 
  <pre class=" language-c"><code class="prism  language-c">CScript scriptPubKey <span class="token operator">=</span> <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span>address<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <h1><a id="1address_13"></a>1.address</h1> 
  <p>这里的address是CBitcoinAddress address(name_);，调用了CTxDestination CBitcoinAddress::Get()<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927142731674?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">typedef</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>variant<span class="token operator">&lt;</span>CNoDestination<span class="token punctuation">,</span> CKeyID<span class="token punctuation">,</span> CScriptID<span class="token operator">&gt;</span> CTxDestination<span class="token punctuation">;</span>
</code></pre> 
  <p>介绍一下<mark>variant</mark>，variant相当于增强型的union，也就是CTxDestination可以是CNoDestination, CKeyID, CScriptID中的任意一个类型<br> vchVersion是CBitcoinAddress的父类CBase58Data的保护变量</p> 
  <pre class=" language-c"><code class="prism  language-c">CTxDestination CBitcoinAddress<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">CNoDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint160 id<span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vchData<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vchVersion <span class="token operator">==</span> <span class="token function">Params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Base58Prefix</span><span class="token punctuation">(</span>CChainParams<span class="token punctuation">:</span><span class="token punctuation">:</span>PUBKEY_ADDRESS<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">CKeyID</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vchVersion <span class="token operator">==</span> <span class="token function">Params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Base58Prefix</span><span class="token punctuation">(</span>CChainParams<span class="token punctuation">:</span><span class="token punctuation">:</span>SCRIPT_ADDRESS<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">CScriptID</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">CNoDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这段代码就是做逻辑判断，如果是公钥地址则调用CKeyID(id)，如果是脚本地址则调用CScriptID(id)。<br> 其中的CChainParams::PUBKEY_ADDRESS参数是</p> 
  <pre class=" language-c"><code class="prism  language-c">class CChainParams
<span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    <span class="token keyword">enum</span> Base58Type <span class="token punctuation">{</span>
        PUBKEY_ADDRESS<span class="token punctuation">,</span>
        SCRIPT_ADDRESS<span class="token punctuation">,</span>
        SECRET_KEY<span class="token punctuation">,</span>
        EXT_PUBLIC_KEY<span class="token punctuation">,</span>
        EXT_SECRET_KEY<span class="token punctuation">,</span>

        MAX_BASE58_TYPES
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>这个CChainParams下还有三个子类，分别对应不同网络的可调整参数,我们先来看测试网的，其中一段</p> 
  <pre class=" language-c"><code class="prism  language-c">base58Prefixes<span class="token punctuation">[</span>PUBKEY_ADDRESS<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base58Prefixes<span class="token punctuation">[</span>SCRIPT_ADDRESS<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">196</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base58Prefixes<span class="token punctuation">[</span>SECRET_KEY<span class="token punctuation">]</span> <span class="token operator">=</span>     std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">239</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base58Prefixes<span class="token punctuation">[</span>EXT_PUBLIC_KEY<span class="token punctuation">]</span> <span class="token operator">=</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>assign<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">list_of</span><span class="token punctuation">(</span><span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x35</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x87</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0xCF</span><span class="token punctuation">)</span><span class="token punctuation">.</span>convert_to_container<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base58Prefixes<span class="token punctuation">[</span>EXT_SECRET_KEY<span class="token punctuation">]</span> <span class="token operator">=</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>assign<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">list_of</span><span class="token punctuation">(</span><span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x35</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x83</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x94</span><span class="token punctuation">)</span><span class="token punctuation">.</span>convert_to_container<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>接下来看CKeyID</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token function">CKeyID</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint160<span class="token operator">&amp;</span> in<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">uint160</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> 
  <p>就是对输入做了hash160的处理，那么来看CScriptID</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token function">CScriptID</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint160<span class="token operator">&amp;</span> in<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">uint160</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> 
  <p>也是一样的处理</p> 
  <hr> 
  <h1><a id="2_74"></a>2.脚本构建</h1> 
  <h2><a id="21GetScriptForDestination_75"></a>2.1GetScriptForDestination</h2> 
  <p>接着来看GetScriptForDestination函数</p> 
  <pre class=" language-c"><code class="prism  language-c">CScript <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxDestination<span class="token operator">&amp;</span> dest<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CScript script<span class="token punctuation">;</span>

    boost<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">apply_visitor</span><span class="token punctuation">(</span><span class="token function">CScriptVisitor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>script<span class="token punctuation">)</span><span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> script<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>因为CTxDestination是boost::variant类型的，根据CScriptVisitor的内部结构来看是用了访问者模式<br> CScriptVisitor继承类boost::static_visitor，在类里面需要重载()操作符，通过boost::apply_visitor来访问原始类型的值</p> 
  <pre class=" language-c"><code class="prism  language-c">namespace
<span class="token punctuation">{</span>
class CScriptVisitor <span class="token punctuation">:</span> public boost<span class="token punctuation">:</span><span class="token punctuation">:</span>static_visitor<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
    CScript <span class="token operator">*</span>script<span class="token punctuation">;</span>
public<span class="token punctuation">:</span>
    <span class="token function">CScriptVisitor</span><span class="token punctuation">(</span>CScript <span class="token operator">*</span>scriptin<span class="token punctuation">)</span> <span class="token punctuation">{</span> script <span class="token operator">=</span> scriptin<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CNoDestination <span class="token operator">&amp;</span>dest<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        script<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//这里是比特币地址的处理，script用于保存组装好的脚本</span>
    bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKeyID <span class="token operator">&amp;</span>keyID<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        script<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>script <span class="token operator">&lt;&lt;</span> OP_DUP <span class="token operator">&lt;&lt;</span> OP_HASH160 <span class="token operator">&lt;&lt;</span> <span class="token function">ToByteVector</span><span class="token punctuation">(</span>keyID<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_EQUALVERIFY <span class="token operator">&lt;&lt;</span> OP_CHECKSIG<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//这里是支付到脚本地址的处理</span>
    bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CScriptID <span class="token operator">&amp;</span>scriptID<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        script<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>script <span class="token operator">&lt;&lt;</span> OP_HASH160 <span class="token operator">&lt;&lt;</span> <span class="token function">ToByteVector</span><span class="token punctuation">(</span>scriptID<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_EQUAL<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>回顾一下锁定脚本，给出的例子就是<br> 1）P2PKH： OP_DUP OP_HSAH160 OP_EQUALVERIFY OP_CHECKSIG<br> 2）P2SH： OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL<br> 和上面的代码是符合的，另外脚本操作都定义在script.h中<br> 在standard.cpp目录下还有多重签名脚本和隔离见证的脚本构造也一并介绍了</p> 
  <h2><a id="22GetScriptForMultisig_122"></a>2.2GetScriptForMultisig</h2> 
  <pre class=" language-c"><code class="prism  language-c">CScript <span class="token function">GetScriptForMultisig</span><span class="token punctuation">(</span><span class="token keyword">int</span> nRequired<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>CPubKey<span class="token operator">&gt;</span><span class="token operator">&amp;</span> keys<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CScript script<span class="token punctuation">;</span>

    script <span class="token operator">&lt;&lt;</span> CScript<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">EncodeOP_N</span><span class="token punctuation">(</span>nRequired<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CPubKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> keys<span class="token punctuation">)</span>
        script <span class="token operator">&lt;&lt;</span> <span class="token function">ToByteVector</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    script <span class="token operator">&lt;&lt;</span> CScript<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">EncodeOP_N</span><span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_CHECKMULTISIG<span class="token punctuation">;</span>
    <span class="token keyword">return</span> script<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>多重签名的锁定脚本例子<br> M &lt;Public Key 1&gt; &lt;Public Key 2&gt; … N CHECKMULTISIG<br> 其中M 是花费输出所需的签名的数量，N 是列出的公钥的总数</p> 
  <h2><a id="23GetScriptForWitness_138"></a>2.3GetScriptForWitness</h2> 
  <pre class=" language-c"><code class="prism  language-c">CScript <span class="token function">GetScriptForWitness</span><span class="token punctuation">(</span><span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> redeemscript<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CScript ret<span class="token punctuation">;</span>

    txnouttype typ<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> vSolutions<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Solver</span><span class="token punctuation">(</span>redeemscript<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> vSolutions<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>typ <span class="token operator">==</span> TX_PUBKEY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">char</span> h160<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">CHash160</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span>h160<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">&lt;&lt;</span> OP_0 <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>h160<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>h160<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>typ <span class="token operator">==</span> TX_PUBKEYHASH<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           ret <span class="token operator">&lt;&lt;</span> OP_0 <span class="token operator">&lt;&lt;</span> vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    uint256 hash<span class="token punctuation">;</span>
    <span class="token function">CSHA256</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>redeemscript<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> redeemscript<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">&lt;&lt;</span> OP_0 <span class="token operator">&lt;&lt;</span> <span class="token function">ToByteVector</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这个函数的传入参数就是脚本，也就是之前构建好的脚本。这里的逻辑是针对公钥和公钥hash有不同的处理方法，以及对支付给脚本hash的处理<br> 例子是 1)P2WPKH : OP_0 &lt;<mark>20</mark>-byte witness program&gt;<br> 2)P2WSH:OP_0 &lt;<mark>32</mark>-byte witness program&gt;</p> 
  <hr> 
  <h1><a id="3_168"></a>3.签名</h1> 
  <p>在createtransaction中的签名是调用</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>sign<span class="token punctuation">)</span>
signSuccess <span class="token operator">=</span> <span class="token function">ProduceSignature</span><span class="token punctuation">(</span><span class="token function">TransactionSignatureCreator</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> <span class="token operator">&amp;</span>txNewConst<span class="token punctuation">,</span> nIn<span class="token punctuation">,</span> coin<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>coin<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">.</span>nValue<span class="token punctuation">,</span> SIGHASH_ALL<span class="token punctuation">)</span><span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> sigdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p><mark>SIGHASH_ALL</mark>是签名哈希类型的一个，表示签名承诺的交易部分，all表示承诺所有的输入和输出<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180927150730923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <h2><a id="31ProduceSignature_176"></a>3.1ProduceSignature</h2> 
  <p>先来看ProduceSignature这个函数，主要逻辑是判断锁定脚本类型,然后对应处理<br> 如果是P2SH第一次调用SignStep返回的不是签名而是赎回脚本，需要另外处理，还有隔离见证的也需要。</p> 
  <pre class=" language-c"><code class="prism  language-c">bool <span class="token function">ProduceSignature</span><span class="token punctuation">(</span><span class="token keyword">const</span> BaseSignatureCreator<span class="token operator">&amp;</span> creator<span class="token punctuation">,</span> <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> fromPubKey<span class="token punctuation">,</span> SignatureData<span class="token operator">&amp;</span> sigdata<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CScript script <span class="token operator">=</span> fromPubKey<span class="token punctuation">;</span>
    bool solved <span class="token operator">=</span> true<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>valtype<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    txnouttype whichType<span class="token punctuation">;</span>
    solved <span class="token operator">=</span> <span class="token function">SignStep</span><span class="token punctuation">(</span>creator<span class="token punctuation">,</span> script<span class="token punctuation">,</span> result<span class="token punctuation">,</span> whichType<span class="token punctuation">,</span> SIGVERSION_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SIGVERSION_BASE=0</span>
    bool P2SH <span class="token operator">=</span> false<span class="token punctuation">;</span>
    CScript subscript<span class="token punctuation">;</span>
    sigdata<span class="token punctuation">.</span>scriptWitness<span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>solved <span class="token operator">&amp;&amp;</span> whichType <span class="token operator">==</span> TX_SCRIPTHASH<span class="token punctuation">)</span><span class="token comment">//解析赎回脚本</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Solver returns the subscript that needs to be evaluated;</span>
        <span class="token comment">// the final scriptSig is the signatures from that</span>
        <span class="token comment">// and then the serialized subscript:</span>
        script <span class="token operator">=</span> subscript <span class="token operator">=</span> <span class="token function">CScript</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        solved <span class="token operator">=</span> solved <span class="token operator">&amp;&amp;</span> <span class="token function">SignStep</span><span class="token punctuation">(</span>creator<span class="token punctuation">,</span> script<span class="token punctuation">,</span> result<span class="token punctuation">,</span> whichType<span class="token punctuation">,</span> SIGVERSION_BASE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> whichType <span class="token operator">!=</span> TX_SCRIPTHASH<span class="token punctuation">;</span>
        P2SH <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>solved <span class="token operator">&amp;&amp;</span> whichType <span class="token operator">==</span> TX_WITNESS_V0_KEYHASH<span class="token punctuation">)</span><span class="token comment">//隔离见证</span>
    <span class="token punctuation">{</span>
        CScript witnessscript<span class="token punctuation">;</span>
        witnessscript <span class="token operator">&lt;&lt;</span> OP_DUP <span class="token operator">&lt;&lt;</span> OP_HASH160 <span class="token operator">&lt;&lt;</span> <span class="token function">ToByteVector</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_EQUALVERIFY <span class="token operator">&lt;&lt;</span> OP_CHECKSIG<span class="token punctuation">;</span><span class="token comment">//隔离见证脚本的组装</span>
        txnouttype subType<span class="token punctuation">;</span>
        solved <span class="token operator">=</span> solved <span class="token operator">&amp;&amp;</span> <span class="token function">SignStep</span><span class="token punctuation">(</span>creator<span class="token punctuation">,</span> witnessscript<span class="token punctuation">,</span> result<span class="token punctuation">,</span> subType<span class="token punctuation">,</span> SIGVERSION_WITNESS_V0<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sigdata<span class="token punctuation">.</span>scriptWitness<span class="token punctuation">.</span>stack <span class="token operator">=</span> result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>solved <span class="token operator">&amp;&amp;</span> whichType <span class="token operator">==</span> TX_WITNESS_V0_SCRIPTHASH<span class="token punctuation">)</span><span class="token comment">//隔离见证</span>
    <span class="token punctuation">{</span>
        CScript <span class="token function">witnessscript</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        txnouttype subType<span class="token punctuation">;</span>
        solved <span class="token operator">=</span> solved <span class="token operator">&amp;&amp;</span> <span class="token function">SignStep</span><span class="token punctuation">(</span>creator<span class="token punctuation">,</span> witnessscript<span class="token punctuation">,</span> result<span class="token punctuation">,</span> subType<span class="token punctuation">,</span> SIGVERSION_WITNESS_V0<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> subType <span class="token operator">!=</span> TX_SCRIPTHASH <span class="token operator">&amp;&amp;</span> subType <span class="token operator">!=</span> TX_WITNESS_V0_SCRIPTHASH <span class="token operator">&amp;&amp;</span> subType <span class="token operator">!=</span> TX_WITNESS_V0_KEYHASH<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>witnessscript<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> witnessscript<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sigdata<span class="token punctuation">.</span>scriptWitness<span class="token punctuation">.</span>stack <span class="token operator">=</span> result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>P2SH<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//脚本公钥</span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>subscript<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> subscript<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sigdata<span class="token punctuation">.</span>scriptSig <span class="token operator">=</span> <span class="token function">PushAll</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Test solution</span>
    <span class="token keyword">return</span> solved <span class="token operator">&amp;&amp;</span> <span class="token function">VerifyScript</span><span class="token punctuation">(</span>sigdata<span class="token punctuation">.</span>scriptSig<span class="token punctuation">,</span> fromPubKey<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sigdata<span class="token punctuation">.</span>scriptWitness<span class="token punctuation">,</span> STANDARD_SCRIPT_VERIFY_FLAGS<span class="token punctuation">,</span> creator<span class="token punctuation">.</span><span class="token function">Checker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>签名数据保存在sigdata中</p> 
  <h3><a id="311SignStep_231"></a>3.1.1SignStep</h3> 
  <p>需要先了解SignStep，从注释来看</p> 
  <blockquote> 
   <p>使用创建者(creator)签名签署scriptPubKey。 签名在scriptSigRet中返回（如果无法对scriptPubKey进行签名，则返回false），除非whichTypeRet是TX_SCRIPTHASH，在这种情况下，scriptSigRet是兑换脚本。 如果无法完全满足scriptPubKey，则返回false。</p> 
  </blockquote> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">static</span> bool <span class="token function">SignStep</span><span class="token punctuation">(</span><span class="token keyword">const</span> BaseSignatureCreator<span class="token operator">&amp;</span> creator<span class="token punctuation">,</span> <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptPubKey<span class="token punctuation">,</span>
                     std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>valtype<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ret<span class="token punctuation">,</span> txnouttype<span class="token operator">&amp;</span> whichTypeRet<span class="token punctuation">,</span> SigVersion sigversion<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CScript scriptRet<span class="token punctuation">;</span>
    uint160 h160<span class="token punctuation">;</span>
    ret<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span>valtype<span class="token operator">&gt;</span> vSolutions<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Solver</span><span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">,</span> whichTypeRet<span class="token punctuation">,</span> vSolutions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//whichTypeRet脚本类型，vSolutions保存脚本hash值</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    CKeyID keyID<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>whichTypeRet<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token keyword">case</span> TX_NONSTANDARD<span class="token punctuation">:</span>
    <span class="token keyword">case</span> TX_NULL_DATA<span class="token punctuation">:</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">case</span> TX_PUBKEY<span class="token punctuation">:</span>
        keyID <span class="token operator">=</span> <span class="token function">CPubKey</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">Sign1</span><span class="token punctuation">(</span>keyID<span class="token punctuation">,</span> creator<span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//签名保存在ret</span>
    <span class="token keyword">case</span> TX_PUBKEYHASH<span class="token punctuation">:</span>
        keyID <span class="token operator">=</span> <span class="token function">CKeyID</span><span class="token punctuation">(</span><span class="token function">uint160</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Sign1</span><span class="token punctuation">(</span>keyID<span class="token punctuation">,</span> creator<span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            CPubKey vch<span class="token punctuation">;</span>
            creator<span class="token punctuation">.</span><span class="token function">KeyStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetPubKey</span><span class="token punctuation">(</span>keyID<span class="token punctuation">,</span> vch<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">ToByteVector</span><span class="token punctuation">(</span>vch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">case</span> TX_SCRIPTHASH<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>creator<span class="token punctuation">.</span><span class="token function">KeyStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetCScript</span><span class="token punctuation">(</span><span class="token function">uint160</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scriptRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>scriptRet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scriptRet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token keyword">case</span> TX_MULTISIG<span class="token punctuation">:</span>
        ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">valtype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// workaround CHECKMULTISIG bug</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">SignN</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">,</span> creator<span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> TX_WITNESS_V0_KEYHASH<span class="token punctuation">:</span>
        ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>

    <span class="token keyword">case</span> TX_WITNESS_V0_SCRIPTHASH<span class="token punctuation">:</span>
        <span class="token function">CRIPEMD160</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span>h160<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>creator<span class="token punctuation">.</span><span class="token function">KeyStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetCScript</span><span class="token punctuation">(</span>h160<span class="token punctuation">,</span> scriptRet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>scriptRet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scriptRet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>可以看到有三个类型TX_SCRIPTHASH，TX_WITNESS_V0_KEYHASH，TX_WITNESS_V0_SCRIPTHASH没有调用签名函数，所以还要再次调用签名处理的。</p> 
  <h3><a id="312Solver_295"></a>3.1.2Solver</h3> 
  <blockquote> 
   <p>Return public keys or hashes from scriptPubKey, for ‘standard’ transaction types.<br> 对于“标准”事务类型，从scriptPubKey返回公钥或哈希值。</p> 
  </blockquote> 
  <p>鉴于这个代码也很长，不想说了，scriptPubKey是指锁定脚本，不是单指公钥脚本，好吧稍微写一点好了</p> 
  <pre class=" language-c"><code class="prism  language-c">bool <span class="token function">Solver</span><span class="token punctuation">(</span><span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptPubKey<span class="token punctuation">,</span> txnouttype<span class="token operator">&amp;</span> typeRet<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token operator">&amp;</span> vSolutionsRet<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">// Templates</span>
    <span class="token keyword">static</span> multimap<span class="token operator">&lt;</span>txnouttype<span class="token punctuation">,</span> CScript<span class="token operator">&gt;</span> mTemplates<span class="token punctuation">;</span><span class="token comment">//构造模版</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mTemplates<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Standard tx, sender provides pubkey, receiver adds signature</span>
        <span class="token comment">//标准交易，发送者提供公钥，接收者添加签名</span>
        mTemplates<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>TX_PUBKEY<span class="token punctuation">,</span> <span class="token function">CScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_PUBKEY <span class="token operator">&lt;&lt;</span> OP_CHECKSIG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey</span>
        <span class="token comment">//比特币地址交易，发送者提供公钥哈希，接收者提供签名和公钥</span>
        mTemplates<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>TX_PUBKEYHASH<span class="token punctuation">,</span> <span class="token function">CScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_DUP <span class="token operator">&lt;&lt;</span> OP_HASH160 <span class="token operator">&lt;&lt;</span> OP_PUBKEYHASH <span class="token operator">&lt;&lt;</span> OP_EQUALVERIFY <span class="token operator">&lt;&lt;</span> OP_CHECKSIG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Sender provides N pubkeys, receivers provides M signatures</span>
        <span class="token comment">//多重签名，发送者提供n个公钥，接收者提供m个签名</span>
        mTemplates<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>TX_MULTISIG<span class="token punctuation">,</span> <span class="token function">CScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> OP_SMALLINTEGER <span class="token operator">&lt;&lt;</span> OP_PUBKEYS <span class="token operator">&lt;&lt;</span> OP_SMALLINTEGER <span class="token operator">&lt;&lt;</span> OP_CHECKMULTISIG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    vSolutionsRet<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Shortcut for pay-to-script-hash, which are more constrained than the other types:</span>
    <span class="token comment">// it is always OP_HASH160 20 [20 byte hash] OP_EQUAL</span>
    <span class="token comment">//付费到脚本哈希的快捷方式，比其他类型更受限制：它总是OP_HASH160 20 [20字节哈希] OP_EQUAL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">.</span><span class="token function">IsPayToScriptHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//对P2SH的处理</span>
    <span class="token punctuation">{</span>
        typeRet <span class="token operator">=</span> TX_SCRIPTHASH<span class="token punctuation">;</span>
        <span class="token comment">//20字节哈希我们是知道，前面两字节是操作OP_HASH160和代表长度的字节</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">hashBytes</span><span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vSolutionsRet<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>hashBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ····
</code></pre> 
  <p>判断是否脚本hash，写的比较明确了</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CScript<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">IsPayToScriptHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Extra-fast test for pay-to-script-hash CScripts:</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">23</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> OP_HASH160 <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x14</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">==</span> OP_EQUAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>vSolutionsRet保存的是hash值<br> 函数运行后，typeRet会保存锁定脚本的类型，这是枚举类型</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">enum</span> txnouttype
<span class="token punctuation">{</span>
    TX_NONSTANDARD<span class="token punctuation">,</span>
    <span class="token comment">// 'standard' transaction types:</span>
    TX_PUBKEY<span class="token punctuation">,</span>
    TX_PUBKEYHASH<span class="token punctuation">,</span>
    TX_SCRIPTHASH<span class="token punctuation">,</span>
    TX_MULTISIG<span class="token punctuation">,</span>
    TX_NULL_DATA<span class="token punctuation">,</span>
    TX_WITNESS_V0_SCRIPTHASH<span class="token punctuation">,</span>
    TX_WITNESS_V0_KEYHASH<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>在来说点函数里的代码，接上一段代码，这里是对隔离见证的处理，隔离见证也是固定的长度，20或者32字节</p> 
  <pre class=" language-c"><code class="prism  language-c"> <span class="token keyword">int</span> witnessversion<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> witnessprogram<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">.</span><span class="token function">IsWitnessProgram</span><span class="token punctuation">(</span>witnessversion<span class="token punctuation">,</span> witnessprogram<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>witnessversion <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> witnessprogram<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            typeRet <span class="token operator">=</span> TX_WITNESS_V0_KEYHASH<span class="token punctuation">;</span>
            vSolutionsRet<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>witnessprogram<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>witnessversion <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> witnessprogram<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            typeRet <span class="token operator">=</span> TX_WITNESS_V0_SCRIPTHASH<span class="token punctuation">;</span>
            vSolutionsRet<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>witnessprogram<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
  <p>这里涉及到的判断,也写的很清楚，截取见证内容保存到program中</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CScript<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">IsWitnessProgram</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> version<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> program<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">||</span> this<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> OP_0 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> OP_1 <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> OP_16<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> this<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        version <span class="token operator">=</span> <span class="token function">DecodeOP_N</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opcodetype<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        program <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>this<span class="token operator">-&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> this<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>再返回函数部分，</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> scriptPubKey<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> OP_RETURN <span class="token operator">&amp;&amp;</span> scriptPubKey<span class="token punctuation">.</span><span class="token function">IsPushOnly</span><span class="token punctuation">(</span>scriptPubKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        typeRet <span class="token operator">=</span> TX_NULL_DATA<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
  <p>在这段之后就是对最开始的mTemplates的处理，对三种的处理，轮询处理</p> 
  <h3><a id="313Sign1_406"></a>3.1.3Sign1</h3> 
  <p>在解析出脚本类型和脚本hash或公钥后回到SignStep函数中，以公钥脚本为例，查看如何签名</p> 
  <pre class=" language-c"><code class="prism  language-c"> keyID <span class="token operator">=</span> <span class="token function">CPubKey</span><span class="token punctuation">(</span>vSolutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">Sign1</span><span class="token punctuation">(</span>keyID<span class="token punctuation">,</span> creator<span class="token punctuation">,</span> scriptPubKey<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>来看Sign1这个函数,签名保存在ret变量中</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">static</span> bool <span class="token function">Sign1</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKeyID<span class="token operator">&amp;</span> address<span class="token punctuation">,</span> <span class="token keyword">const</span> BaseSignatureCreator<span class="token operator">&amp;</span> creator<span class="token punctuation">,</span> <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptCode<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>valtype<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ret<span class="token punctuation">,</span> SigVersion sigversion<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> vchSig<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>creator<span class="token punctuation">.</span><span class="token function">CreateSig</span><span class="token punctuation">(</span>vchSig<span class="token punctuation">,</span> address<span class="token punctuation">,</span> scriptCode<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vchSig<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>函数中是调用的CreateSig,不能用非压缩格式的私钥签名个隔离见证脚本</p> 
  <pre class=" language-c"><code class="prism  language-c">
bool TransactionSignatureCreator<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">CreateSig</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> vchSig<span class="token punctuation">,</span> <span class="token keyword">const</span> CKeyID<span class="token operator">&amp;</span> address<span class="token punctuation">,</span> <span class="token keyword">const</span> CScript<span class="token operator">&amp;</span> scriptCode<span class="token punctuation">,</span> SigVersion sigversion<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    CKey key<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>keystore<span class="token operator">-&gt;</span><span class="token function">GetKey</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token comment">// Signing with uncompressed keys is disabled in witness scripts</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sigversion <span class="token operator">==</span> SIGVERSION_WITNESS_V0 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">IsCompressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    uint256 hash <span class="token operator">=</span> <span class="token function">SignatureHash</span><span class="token punctuation">(</span>scriptCode<span class="token punctuation">,</span> <span class="token operator">*</span>txTo<span class="token punctuation">,</span> nIn<span class="token punctuation">,</span> nHashType<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> sigversion<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要签名的hash</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> vchSig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//签名的调用</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    vchSig<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span>nHashType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加上hash类型</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>到这里就有签名了</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82866757,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82866757,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/82866757,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/82866757,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
