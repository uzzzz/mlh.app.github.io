<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>智能合约基础语言（四）——Solidity函数 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="智能合约基础语言（四）——Solidity函数" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="原文链接：智能合约基础语言（四）：Solidity函数 下 &nbsp; 一、目录 &nbsp; ▪&nbsp;函数的定义 ▪&nbsp;函数的调用方式 ▪&nbsp;函数的可见性 ▪&nbsp;函数修改器 ▪&nbsp;pure函数 ▪&nbsp;constant、view函数 ▪&nbsp;payable函数 ▪&nbsp;回退函数 ▪&nbsp;构造函数 ▪&nbsp;函数参数 ▪&nbsp;抽象函数 ▪&nbsp;数学和加密函数 二、函数的定义 function关键字声明的，合约中的可执行单元，一个函数的完整定义如下： &nbsp; function (funcName) (&lt;parameter types&gt;) {public|external|internal|private} [constant|view|payable] [returns (&lt;return types&gt;)] 三、函数的调用方式 Solidity封装了两种函数的调用方式internal（内部调用）和external（外部调用）。 3.1 internal（内部调用方式） internal调用，实现时转为简单的EVM跳转，所以它能直接使用上下文环境中的数据，对于引用传递时将会变得非常高效（不用拷贝数据）。 在当前的代码单元内，如对合约内函数，引入的库函数，以及父类合约中的函数直接使用即是以internal方式的调用。我们来看个简单的例子： &nbsp; pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function f(){} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以internal的方式调用 &nbsp; &nbsp;function callInternally(){ &nbsp; &nbsp; &nbsp; &nbsp;f(); &nbsp; &nbsp;} } 在上述代码中，callInternally()以internal的方式对f()函数进行了调用。 简而言之，internal（内部调用方式）就是直接使用函数名去调用函数。 3.2 external（外部调用方式） external调用，实现为合约的外部消息调用。所以在合约初始化时不能external的方式调用自身函数，因为合约还未初始化完成。下面来看一个以external方式调用的例子： &nbsp; pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function f(){} } contract B{ &nbsp; &nbsp; &nbsp; &nbsp;//以external的方式调用另一合约中的函数 &nbsp; &nbsp;function callExternal(A a){ &nbsp; &nbsp; &nbsp; &nbsp;a.f(); &nbsp; &nbsp;} } 虽然当前合约A和B的代码放在一起，但部署到网络上后，它们是两个完全独立的合约，它们之间的方法调用是通过消息调用。上述代码中，在合约B中的callExternal()以external的方式调用了合约A的f()。 简而言之，external（外部调用方式）就是使用合约实例名.函数名的方式去调用函数。 3.3 this 我们可以在合约的调用函数前加this.来强制以external方式的调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function f() external{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function callExternally(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.f(); &nbsp; &nbsp;} } 3.4 调用方式说明 上面所提到的internal和external指的函数调用方式，请不要与后面的函数可见性声明的external，public，internal，private弄混。声明只是意味着这个函数需要使用相对应的调用方式去调用。 四、函数的可见性 Solidity为函数提供了四种可见性，external，public，internal，private。 4.1 external（外部函数） ▪&nbsp;声明为external的函数可以从其它合约来进行调用，所以声明为external的函数是合约对外接口的一部分。 ▪&nbsp;不能以internal的方式进行调用。 ▪&nbsp;有时在接收大的数据数组时性能更好。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp; function externalFunc() external{} &nbsp; &nbsp; &nbsp; &nbsp; function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数报错 &nbsp; &nbsp; &nbsp; &nbsp;//Error: Undeclared identifier. &nbsp; &nbsp; &nbsp; &nbsp;//externalFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.externalFunc(); &nbsp; &nbsp;} } 声明为external的externalFunc()只能以external的方式进行调用，以internal的方式调用会报Error: Undeclared identifier。 4.2 pulic（公有函数） ▪&nbsp;函数默认声明为public。 ▪&nbsp;public的函数既允许以internal的方式调用，也允许以external的方式调用。 ▪&nbsp;public的函数由于允许被外部合约访问，是合约对外接口的一部分。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp;//默认是public函数 &nbsp; &nbsp;function publicFunc(){} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;publicFunc(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.publicFunc(); &nbsp; &nbsp;} } 我们可以看到声明为public的publicFunc()允许两种调用方式。 4.3 internal（内部函数） 在当前的合约或继承的合约中，只允许以internal的方式调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function internalFunc() internal{} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//子合约中调用 &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } 上述例子中声明为internal的internalFunc()在定义合约，和子合约中均只能以internal的方式可以进行调用。 4.4 private（私有函数） ▪&nbsp;只能在当前合约中被访问（不可在被继承的合约中访问）。 ▪&nbsp;即使声明为private，仍能被所有人查看到里面的数据，但是不能修改数据且不能被其它合约访问。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function privateFunc() private{} &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; privateFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//不可调用`private` &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//privateFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//这里无法调用合约A中的内部函数, &nbsp; &nbsp; &nbsp; &nbsp;//且在编译阶段就会报错 &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//但是间接调用private函数，但是需要这个private函数处在public中 &nbsp; &nbsp;//function callPrivateByPublicFunc(){ &nbsp; &nbsp;// &nbsp; &nbsp;callFunc(); &nbsp; &nbsp;//} } 五、pure（纯函数） 既不从状态读取数据也不写入数据的函数可以被声明为纯函数 除了之前修改状态数据的情况外，我们认为一下情况属于从状态读取数据。 1. 读取状态变量 2. 调用this.balance或者address.balance 3. 调用block、tx、msg的成员 4. 调用任何非纯函数 5. 使用了包含某些操作码的内联汇编 pragma solidity ^0.4.24; contract C { &nbsp; &nbsp; function f(uint a, uint b) public pure returns (uint) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return a * (b + 42); &nbsp; &nbsp;} } 六、constant/view（只读函数） 不改变状态的函数可以被声明为只读函数一下几种情况被视为修改了状态： 1. 修改状态变量 2. 触发事件 3. 创建了其他合约的实例 4. 使用了selfdestruct自我销毁 5. 调用了向合约转账的函数 6. 调用了非只读函数或者纯函数 7. 使用了底层调用 8. 使用了包含某些操作码的内联汇编 注意： constant是view的一个别名，会在0.5.0版本中遗弃，访问器(getter)方法默认被标记为view调用只读函数。 七、函数修改器 在实际情况中，我们经常需要对调用者进行一些限制。比如，只能是合约的所有者才能改变归属。我们一起来看看如何用函数修改器实现这一限制： pragma solidity ^0.4.24; contract Ownable { &nbsp;address public owner = msg.sender; &nbsp; &nbsp;/// 限制只有创建者才能访问 &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender != owner) throw; &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;/// 改变合约的所有者 &nbsp;function changeOwner(address _newOwner) &nbsp;onlyOwner &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if(_newOwner == 0x0) throw; &nbsp; &nbsp;owner = _newOwner; &nbsp;} } 7.1 函数修改器支持参数 pragma solidity ^0.4.24; contract Parameter{ &nbsp; &nbsp;uint balance = 10; &nbsp;modifier lowerLimit(uint _balance, uint _withdraw){ &nbsp; &nbsp; &nbsp; &nbsp;if( _withdraw &lt; 0 || _withdraw &gt; _balance) throw; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;//含参数的函数修改器 &nbsp;function f(uint withdraw) lowerLimit(balance, withdraw) returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return balance; &nbsp;} } 在上面的例子中，f()函数，有一个函数修改器lowerLimit()，传入了状态变量参数balance，和入参withdraw，以lowerLimit(balance, withdraw)的方式进行调用。最后函数能否正确执行取决于输入的withdraw值大小。 7.2 函数修改器参数支持表达式 pragma solidity ^0.4.24; contract ParameterExpression{ &nbsp;modifier m(uint a){ &nbsp; &nbsp; &nbsp; &nbsp;if(a &gt; 0) &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;function add(uint a, uint b) private returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return a + b; &nbsp;} &nbsp; &nbsp;function f() m(add(1, 1)) returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return 1; &nbsp;} } 八、payable（接收以太币函数） 是声明了该函数涉及接收以太币操作，如果函数没有声明为payable,并且在调用过程中有以太币通过被调用的函数转入合约，那么EVM虚拟机将会抛出异常，状态回退。 pragma solidity ^0.4.24; contract AddressExample { &nbsp; &nbsp; &nbsp; &nbsp;function AddressExample() payable{} &nbsp; &nbsp; &nbsp; &nbsp;function giveEthersTo(address _toAccount,uint amount){ &nbsp; &nbsp; &nbsp; &nbsp;if (this.balance &gt;=amount){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _toAccount.transfer(amount); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//function() payable{} } 九、回退函数 每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。 下述提供给回退函数可执行的操作会比常规的花费得多一点。 写入到存储(storage) 创建一个合约 执行一个外部(external)函数调用，会花费非常多的gas 发送ether 请在部署合约到网络前，保证透彻的测试你的回退函数，来保证函数执行的花费控制在2300gas以内。 一个没有定义一个回退函数的合约。如果接收ether，会触发异常，并返还ether（solidity v0.4.0开始）。所以合约要接收ether，必须实现回退函数。下面来看个例子。下面来看个例子： pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function() public payable{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getX() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return x; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } contract Caller { &nbsp; &nbsp; &nbsp; &nbsp;function Caller()payable{} &nbsp; &nbsp; &nbsp; &nbsp;function callTest(Test test) public{ &nbsp; &nbsp; &nbsp; &nbsp;test.call(0xabcdef01); &nbsp; &nbsp; &nbsp; &nbsp;// test.transfer(2 ether); &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } 如果涉及支付以太币，即回退函数被声明为payable类型，并且通过send或者transfer被调用，那么回退函数仅有你2300gas可以使用，如果回退函数中的代码执行消耗超过2300gas那么被转入的以太币将会退回，修改过的数据状态回退。 以下操作会消耗超过2300gas： 1. 修改状态变量 2. 创建新的合约实例 3. 调用了会消耗gas较多的外部函数 4. 发送以太币 用做接收以太币回退函数内部仅能进行触发事件操作。 十、构造函数 构造函数是一个用constructor关键字声明的可选函数，它在创建合约时执行。构造函数可以是public，也可以是internal。如果没有构造函数，则该合约将生成默认构造函数：contructor() public {}。 pragma solidity ^0.4.24; contract A { &nbsp; &nbsp; &nbsp; &nbsp;uint public a; &nbsp; &nbsp;constructor(uint _a) internal { &nbsp; &nbsp; &nbsp; &nbsp;a = _a; &nbsp; &nbsp;} } 在版本0.4.22之前，构造函数被定义为与合同名称相同的特殊函数，有且只能有一个，不允许重载。这个函数将在合约创建时，执行一次，用于初始化一些配置。这个语法现在不推荐使用。 pragma solidity ^0.4.24; contract ContractConstructor{ &nbsp; &nbsp;uint public counter; &nbsp; &nbsp;function ContractConstructor(){ &nbsp; &nbsp;counter++; &nbsp;} } 上述合约在创建成功后，counter的值将为1。说明合约在创建时，被调用了一次。 十一、函数的输入参数与输出参数 Solidity函数的输入参数的数量是可选的，也可以有任意数量的返回参数。 入参(Input Parameter)与变量的定义方式一致，稍微不同的是，不会用到的参数可以省略变量名称。一种可接受两个整型参数的函数如下: pragma solidity ^0.4.0; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;function taker(uint _a, uint) { &nbsp; &nbsp; &nbsp; &nbsp;// do something with _a. &nbsp; &nbsp;} } 出参（Output Paramets）在returns关键字后定义，语法类似变量的定义方式。返回结果的数量需要与定义的一致。如果给定了参数名，则函数可以不适用return关键字返回，如果没有给定参数名则需要函数体重使用return关键字按照顺序返回。 pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) { &nbsp; &nbsp; &nbsp; &nbsp;o_sum = _a + _b; &nbsp; &nbsp; &nbsp; &nbsp;o_product = _a * _b; &nbsp; &nbsp;} } pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) &nbsp;pure returns (uint , uint ) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(_a + _b,_a * _b); &nbsp; &nbsp;} } 十二、访问函数 编译器为自动为所有的public的状态变量创建访问函数。下面的合约例子中，编译器会生成一个名叫data的无参，返回值是uint的类型的值data。状态变量的初始化可以在定义时完成。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp; &nbsp; &nbsp;uint public c = 10; } contract D{ &nbsp; &nbsp; &nbsp; &nbsp;C c = new C(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getDataUsingAccessor() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c.c(); &nbsp; &nbsp;} } 访问函数有外部(external)可见性。如果通过内部(internal)的方式访问，比如直接访问，你可以直接把它当一个变量进行使用，但如果使用外部(external)的方式来访问，如通过this.，那么它必须通过函数的方式来调用。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp;uint public c = 10; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessInternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessExternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.c(); &nbsp; &nbsp;} } 十三、抽象函数 是没有函数体的的函数。如下： pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); } 这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。 pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getContractName() returns (string){ &nbsp; &nbsp; &nbsp; &nbsp;return &quot;Feline&quot;; &nbsp; &nbsp;} } contract Cat is Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32) { return &quot;miaow&quot;; } } 如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。 十四、数字和加密函数 以下函数式solidity自带的函数 asser(bool condition): 如果条件不满足，抛出异常。 addmod(uint x, uint y, uint k) returns (uint): 计算(x + y) % k。加法支持任意的精度。但不超过(wrap around？)2**256。 mulmod(uint x, uint y, uint k) returns (uint): 计算(x * y) % k。乘法支持任意精度，但不超过(wrap around？)2**256。 keccak256(...) returns (bytes32): 使用以太坊的（Keccak-256）计算HASH值。紧密打包。 sha3(...) returns (bytes32): 等同于keccak256()。紧密打包。 sha256(...) returns (bytes32): 使用SHA-256计算HASH值。紧密打包。 ripemd160(...) returns (bytes20): 使用RIPEMD-160计算HASH值。紧密打包。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 通过签名信息恢复非对称加密算法公匙地址。如果出错会返回0，例如: function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) { &nbsp; &nbsp; &nbsp; &nbsp;bytes memory prefix = &quot;\x19Ethereum Signed Message:\n32&quot;; &nbsp; &nbsp;bytes32 prefixedHash = keccak256(prefix, hash); &nbsp; &nbsp;return ecrecover(prefixedHash, v, r, s) == (Your Address); } revert()： 取消执行，并回撤状态变化。 需要注意的是参数是“紧密打包（tightly packed）”的，意思是说参数不会补位，就直接连接在一起的。下面来看一个例子: keccak256(&quot;ab&quot;, &quot;c&quot;) keccak256(&quot;abc&quot;) //hex keccak256(0x616263) keccak256(6382179) //ascii keccak256(97, 98, 99) 上述例子中，三种表达方式都是一致的。 如果需要补位，需要明确的类型转换，如keccak256(&quot;\x00\x12&quot;)等同于keccak256(uint16(0x12)) 需要注意的是字面量会用，尽可能小的空间来存储它们。比如，keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678)) &nbsp; 注意: 在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为它们实现了一种预编译的机制，但合约要在收到第一个消息后才会存在。向一个不存在的合约发送消息，非常昂贵，所以才会导致Out-Of-Gas的问题。一种解决办法是每个在你真正使用它们前，先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。 &nbsp; -END- &nbsp; 阅读更多" />
<meta property="og:description" content="原文链接：智能合约基础语言（四）：Solidity函数 下 &nbsp; 一、目录 &nbsp; ▪&nbsp;函数的定义 ▪&nbsp;函数的调用方式 ▪&nbsp;函数的可见性 ▪&nbsp;函数修改器 ▪&nbsp;pure函数 ▪&nbsp;constant、view函数 ▪&nbsp;payable函数 ▪&nbsp;回退函数 ▪&nbsp;构造函数 ▪&nbsp;函数参数 ▪&nbsp;抽象函数 ▪&nbsp;数学和加密函数 二、函数的定义 function关键字声明的，合约中的可执行单元，一个函数的完整定义如下： &nbsp; function (funcName) (&lt;parameter types&gt;) {public|external|internal|private} [constant|view|payable] [returns (&lt;return types&gt;)] 三、函数的调用方式 Solidity封装了两种函数的调用方式internal（内部调用）和external（外部调用）。 3.1 internal（内部调用方式） internal调用，实现时转为简单的EVM跳转，所以它能直接使用上下文环境中的数据，对于引用传递时将会变得非常高效（不用拷贝数据）。 在当前的代码单元内，如对合约内函数，引入的库函数，以及父类合约中的函数直接使用即是以internal方式的调用。我们来看个简单的例子： &nbsp; pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function f(){} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以internal的方式调用 &nbsp; &nbsp;function callInternally(){ &nbsp; &nbsp; &nbsp; &nbsp;f(); &nbsp; &nbsp;} } 在上述代码中，callInternally()以internal的方式对f()函数进行了调用。 简而言之，internal（内部调用方式）就是直接使用函数名去调用函数。 3.2 external（外部调用方式） external调用，实现为合约的外部消息调用。所以在合约初始化时不能external的方式调用自身函数，因为合约还未初始化完成。下面来看一个以external方式调用的例子： &nbsp; pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function f(){} } contract B{ &nbsp; &nbsp; &nbsp; &nbsp;//以external的方式调用另一合约中的函数 &nbsp; &nbsp;function callExternal(A a){ &nbsp; &nbsp; &nbsp; &nbsp;a.f(); &nbsp; &nbsp;} } 虽然当前合约A和B的代码放在一起，但部署到网络上后，它们是两个完全独立的合约，它们之间的方法调用是通过消息调用。上述代码中，在合约B中的callExternal()以external的方式调用了合约A的f()。 简而言之，external（外部调用方式）就是使用合约实例名.函数名的方式去调用函数。 3.3 this 我们可以在合约的调用函数前加this.来强制以external方式的调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function f() external{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function callExternally(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.f(); &nbsp; &nbsp;} } 3.4 调用方式说明 上面所提到的internal和external指的函数调用方式，请不要与后面的函数可见性声明的external，public，internal，private弄混。声明只是意味着这个函数需要使用相对应的调用方式去调用。 四、函数的可见性 Solidity为函数提供了四种可见性，external，public，internal，private。 4.1 external（外部函数） ▪&nbsp;声明为external的函数可以从其它合约来进行调用，所以声明为external的函数是合约对外接口的一部分。 ▪&nbsp;不能以internal的方式进行调用。 ▪&nbsp;有时在接收大的数据数组时性能更好。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp; function externalFunc() external{} &nbsp; &nbsp; &nbsp; &nbsp; function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数报错 &nbsp; &nbsp; &nbsp; &nbsp;//Error: Undeclared identifier. &nbsp; &nbsp; &nbsp; &nbsp;//externalFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.externalFunc(); &nbsp; &nbsp;} } 声明为external的externalFunc()只能以external的方式进行调用，以internal的方式调用会报Error: Undeclared identifier。 4.2 pulic（公有函数） ▪&nbsp;函数默认声明为public。 ▪&nbsp;public的函数既允许以internal的方式调用，也允许以external的方式调用。 ▪&nbsp;public的函数由于允许被外部合约访问，是合约对外接口的一部分。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp;//默认是public函数 &nbsp; &nbsp;function publicFunc(){} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;publicFunc(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.publicFunc(); &nbsp; &nbsp;} } 我们可以看到声明为public的publicFunc()允许两种调用方式。 4.3 internal（内部函数） 在当前的合约或继承的合约中，只允许以internal的方式调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function internalFunc() internal{} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//子合约中调用 &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } 上述例子中声明为internal的internalFunc()在定义合约，和子合约中均只能以internal的方式可以进行调用。 4.4 private（私有函数） ▪&nbsp;只能在当前合约中被访问（不可在被继承的合约中访问）。 ▪&nbsp;即使声明为private，仍能被所有人查看到里面的数据，但是不能修改数据且不能被其它合约访问。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function privateFunc() private{} &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; privateFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//不可调用`private` &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//privateFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//这里无法调用合约A中的内部函数, &nbsp; &nbsp; &nbsp; &nbsp;//且在编译阶段就会报错 &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//但是间接调用private函数，但是需要这个private函数处在public中 &nbsp; &nbsp;//function callPrivateByPublicFunc(){ &nbsp; &nbsp;// &nbsp; &nbsp;callFunc(); &nbsp; &nbsp;//} } 五、pure（纯函数） 既不从状态读取数据也不写入数据的函数可以被声明为纯函数 除了之前修改状态数据的情况外，我们认为一下情况属于从状态读取数据。 1. 读取状态变量 2. 调用this.balance或者address.balance 3. 调用block、tx、msg的成员 4. 调用任何非纯函数 5. 使用了包含某些操作码的内联汇编 pragma solidity ^0.4.24; contract C { &nbsp; &nbsp; function f(uint a, uint b) public pure returns (uint) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return a * (b + 42); &nbsp; &nbsp;} } 六、constant/view（只读函数） 不改变状态的函数可以被声明为只读函数一下几种情况被视为修改了状态： 1. 修改状态变量 2. 触发事件 3. 创建了其他合约的实例 4. 使用了selfdestruct自我销毁 5. 调用了向合约转账的函数 6. 调用了非只读函数或者纯函数 7. 使用了底层调用 8. 使用了包含某些操作码的内联汇编 注意： constant是view的一个别名，会在0.5.0版本中遗弃，访问器(getter)方法默认被标记为view调用只读函数。 七、函数修改器 在实际情况中，我们经常需要对调用者进行一些限制。比如，只能是合约的所有者才能改变归属。我们一起来看看如何用函数修改器实现这一限制： pragma solidity ^0.4.24; contract Ownable { &nbsp;address public owner = msg.sender; &nbsp; &nbsp;/// 限制只有创建者才能访问 &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender != owner) throw; &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;/// 改变合约的所有者 &nbsp;function changeOwner(address _newOwner) &nbsp;onlyOwner &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if(_newOwner == 0x0) throw; &nbsp; &nbsp;owner = _newOwner; &nbsp;} } 7.1 函数修改器支持参数 pragma solidity ^0.4.24; contract Parameter{ &nbsp; &nbsp;uint balance = 10; &nbsp;modifier lowerLimit(uint _balance, uint _withdraw){ &nbsp; &nbsp; &nbsp; &nbsp;if( _withdraw &lt; 0 || _withdraw &gt; _balance) throw; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;//含参数的函数修改器 &nbsp;function f(uint withdraw) lowerLimit(balance, withdraw) returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return balance; &nbsp;} } 在上面的例子中，f()函数，有一个函数修改器lowerLimit()，传入了状态变量参数balance，和入参withdraw，以lowerLimit(balance, withdraw)的方式进行调用。最后函数能否正确执行取决于输入的withdraw值大小。 7.2 函数修改器参数支持表达式 pragma solidity ^0.4.24; contract ParameterExpression{ &nbsp;modifier m(uint a){ &nbsp; &nbsp; &nbsp; &nbsp;if(a &gt; 0) &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;function add(uint a, uint b) private returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return a + b; &nbsp;} &nbsp; &nbsp;function f() m(add(1, 1)) returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return 1; &nbsp;} } 八、payable（接收以太币函数） 是声明了该函数涉及接收以太币操作，如果函数没有声明为payable,并且在调用过程中有以太币通过被调用的函数转入合约，那么EVM虚拟机将会抛出异常，状态回退。 pragma solidity ^0.4.24; contract AddressExample { &nbsp; &nbsp; &nbsp; &nbsp;function AddressExample() payable{} &nbsp; &nbsp; &nbsp; &nbsp;function giveEthersTo(address _toAccount,uint amount){ &nbsp; &nbsp; &nbsp; &nbsp;if (this.balance &gt;=amount){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _toAccount.transfer(amount); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//function() payable{} } 九、回退函数 每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。 下述提供给回退函数可执行的操作会比常规的花费得多一点。 写入到存储(storage) 创建一个合约 执行一个外部(external)函数调用，会花费非常多的gas 发送ether 请在部署合约到网络前，保证透彻的测试你的回退函数，来保证函数执行的花费控制在2300gas以内。 一个没有定义一个回退函数的合约。如果接收ether，会触发异常，并返还ether（solidity v0.4.0开始）。所以合约要接收ether，必须实现回退函数。下面来看个例子。下面来看个例子： pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function() public payable{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getX() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return x; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } contract Caller { &nbsp; &nbsp; &nbsp; &nbsp;function Caller()payable{} &nbsp; &nbsp; &nbsp; &nbsp;function callTest(Test test) public{ &nbsp; &nbsp; &nbsp; &nbsp;test.call(0xabcdef01); &nbsp; &nbsp; &nbsp; &nbsp;// test.transfer(2 ether); &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } 如果涉及支付以太币，即回退函数被声明为payable类型，并且通过send或者transfer被调用，那么回退函数仅有你2300gas可以使用，如果回退函数中的代码执行消耗超过2300gas那么被转入的以太币将会退回，修改过的数据状态回退。 以下操作会消耗超过2300gas： 1. 修改状态变量 2. 创建新的合约实例 3. 调用了会消耗gas较多的外部函数 4. 发送以太币 用做接收以太币回退函数内部仅能进行触发事件操作。 十、构造函数 构造函数是一个用constructor关键字声明的可选函数，它在创建合约时执行。构造函数可以是public，也可以是internal。如果没有构造函数，则该合约将生成默认构造函数：contructor() public {}。 pragma solidity ^0.4.24; contract A { &nbsp; &nbsp; &nbsp; &nbsp;uint public a; &nbsp; &nbsp;constructor(uint _a) internal { &nbsp; &nbsp; &nbsp; &nbsp;a = _a; &nbsp; &nbsp;} } 在版本0.4.22之前，构造函数被定义为与合同名称相同的特殊函数，有且只能有一个，不允许重载。这个函数将在合约创建时，执行一次，用于初始化一些配置。这个语法现在不推荐使用。 pragma solidity ^0.4.24; contract ContractConstructor{ &nbsp; &nbsp;uint public counter; &nbsp; &nbsp;function ContractConstructor(){ &nbsp; &nbsp;counter++; &nbsp;} } 上述合约在创建成功后，counter的值将为1。说明合约在创建时，被调用了一次。 十一、函数的输入参数与输出参数 Solidity函数的输入参数的数量是可选的，也可以有任意数量的返回参数。 入参(Input Parameter)与变量的定义方式一致，稍微不同的是，不会用到的参数可以省略变量名称。一种可接受两个整型参数的函数如下: pragma solidity ^0.4.0; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;function taker(uint _a, uint) { &nbsp; &nbsp; &nbsp; &nbsp;// do something with _a. &nbsp; &nbsp;} } 出参（Output Paramets）在returns关键字后定义，语法类似变量的定义方式。返回结果的数量需要与定义的一致。如果给定了参数名，则函数可以不适用return关键字返回，如果没有给定参数名则需要函数体重使用return关键字按照顺序返回。 pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) { &nbsp; &nbsp; &nbsp; &nbsp;o_sum = _a + _b; &nbsp; &nbsp; &nbsp; &nbsp;o_product = _a * _b; &nbsp; &nbsp;} } pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) &nbsp;pure returns (uint , uint ) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(_a + _b,_a * _b); &nbsp; &nbsp;} } 十二、访问函数 编译器为自动为所有的public的状态变量创建访问函数。下面的合约例子中，编译器会生成一个名叫data的无参，返回值是uint的类型的值data。状态变量的初始化可以在定义时完成。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp; &nbsp; &nbsp;uint public c = 10; } contract D{ &nbsp; &nbsp; &nbsp; &nbsp;C c = new C(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getDataUsingAccessor() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c.c(); &nbsp; &nbsp;} } 访问函数有外部(external)可见性。如果通过内部(internal)的方式访问，比如直接访问，你可以直接把它当一个变量进行使用，但如果使用外部(external)的方式来访问，如通过this.，那么它必须通过函数的方式来调用。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp;uint public c = 10; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessInternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessExternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.c(); &nbsp; &nbsp;} } 十三、抽象函数 是没有函数体的的函数。如下： pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); } 这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。 pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getContractName() returns (string){ &nbsp; &nbsp; &nbsp; &nbsp;return &quot;Feline&quot;; &nbsp; &nbsp;} } contract Cat is Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32) { return &quot;miaow&quot;; } } 如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。 十四、数字和加密函数 以下函数式solidity自带的函数 asser(bool condition): 如果条件不满足，抛出异常。 addmod(uint x, uint y, uint k) returns (uint): 计算(x + y) % k。加法支持任意的精度。但不超过(wrap around？)2**256。 mulmod(uint x, uint y, uint k) returns (uint): 计算(x * y) % k。乘法支持任意精度，但不超过(wrap around？)2**256。 keccak256(...) returns (bytes32): 使用以太坊的（Keccak-256）计算HASH值。紧密打包。 sha3(...) returns (bytes32): 等同于keccak256()。紧密打包。 sha256(...) returns (bytes32): 使用SHA-256计算HASH值。紧密打包。 ripemd160(...) returns (bytes20): 使用RIPEMD-160计算HASH值。紧密打包。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 通过签名信息恢复非对称加密算法公匙地址。如果出错会返回0，例如: function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) { &nbsp; &nbsp; &nbsp; &nbsp;bytes memory prefix = &quot;\x19Ethereum Signed Message:\n32&quot;; &nbsp; &nbsp;bytes32 prefixedHash = keccak256(prefix, hash); &nbsp; &nbsp;return ecrecover(prefixedHash, v, r, s) == (Your Address); } revert()： 取消执行，并回撤状态变化。 需要注意的是参数是“紧密打包（tightly packed）”的，意思是说参数不会补位，就直接连接在一起的。下面来看一个例子: keccak256(&quot;ab&quot;, &quot;c&quot;) keccak256(&quot;abc&quot;) //hex keccak256(0x616263) keccak256(6382179) //ascii keccak256(97, 98, 99) 上述例子中，三种表达方式都是一致的。 如果需要补位，需要明确的类型转换，如keccak256(&quot;\x00\x12&quot;)等同于keccak256(uint16(0x12)) 需要注意的是字面量会用，尽可能小的空间来存储它们。比如，keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678)) &nbsp; 注意: 在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为它们实现了一种预编译的机制，但合约要在收到第一个消息后才会存在。向一个不存在的合约发送消息，非常昂贵，所以才会导致Out-Of-Gas的问题。一种解决办法是每个在你真正使用它们前，先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。 &nbsp; -END- &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/21/157def86ac9dfb5741fbe749bea2cd91.html" />
<meta property="og:url" content="https://mlh.app/2018/09/21/157def86ac9dfb5741fbe749bea2cd91.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"原文链接：智能合约基础语言（四）：Solidity函数 下 &nbsp; 一、目录 &nbsp; ▪&nbsp;函数的定义 ▪&nbsp;函数的调用方式 ▪&nbsp;函数的可见性 ▪&nbsp;函数修改器 ▪&nbsp;pure函数 ▪&nbsp;constant、view函数 ▪&nbsp;payable函数 ▪&nbsp;回退函数 ▪&nbsp;构造函数 ▪&nbsp;函数参数 ▪&nbsp;抽象函数 ▪&nbsp;数学和加密函数 二、函数的定义 function关键字声明的，合约中的可执行单元，一个函数的完整定义如下： &nbsp; function (funcName) (&lt;parameter types&gt;) {public|external|internal|private} [constant|view|payable] [returns (&lt;return types&gt;)] 三、函数的调用方式 Solidity封装了两种函数的调用方式internal（内部调用）和external（外部调用）。 3.1 internal（内部调用方式） internal调用，实现时转为简单的EVM跳转，所以它能直接使用上下文环境中的数据，对于引用传递时将会变得非常高效（不用拷贝数据）。 在当前的代码单元内，如对合约内函数，引入的库函数，以及父类合约中的函数直接使用即是以internal方式的调用。我们来看个简单的例子： &nbsp; pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function f(){} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以internal的方式调用 &nbsp; &nbsp;function callInternally(){ &nbsp; &nbsp; &nbsp; &nbsp;f(); &nbsp; &nbsp;} } 在上述代码中，callInternally()以internal的方式对f()函数进行了调用。 简而言之，internal（内部调用方式）就是直接使用函数名去调用函数。 3.2 external（外部调用方式） external调用，实现为合约的外部消息调用。所以在合约初始化时不能external的方式调用自身函数，因为合约还未初始化完成。下面来看一个以external方式调用的例子： &nbsp; pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function f(){} } contract B{ &nbsp; &nbsp; &nbsp; &nbsp;//以external的方式调用另一合约中的函数 &nbsp; &nbsp;function callExternal(A a){ &nbsp; &nbsp; &nbsp; &nbsp;a.f(); &nbsp; &nbsp;} } 虽然当前合约A和B的代码放在一起，但部署到网络上后，它们是两个完全独立的合约，它们之间的方法调用是通过消息调用。上述代码中，在合约B中的callExternal()以external的方式调用了合约A的f()。 简而言之，external（外部调用方式）就是使用合约实例名.函数名的方式去调用函数。 3.3 this 我们可以在合约的调用函数前加this.来强制以external方式的调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function f() external{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function callExternally(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.f(); &nbsp; &nbsp;} } 3.4 调用方式说明 上面所提到的internal和external指的函数调用方式，请不要与后面的函数可见性声明的external，public，internal，private弄混。声明只是意味着这个函数需要使用相对应的调用方式去调用。 四、函数的可见性 Solidity为函数提供了四种可见性，external，public，internal，private。 4.1 external（外部函数） ▪&nbsp;声明为external的函数可以从其它合约来进行调用，所以声明为external的函数是合约对外接口的一部分。 ▪&nbsp;不能以internal的方式进行调用。 ▪&nbsp;有时在接收大的数据数组时性能更好。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp; function externalFunc() external{} &nbsp; &nbsp; &nbsp; &nbsp; function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数报错 &nbsp; &nbsp; &nbsp; &nbsp;//Error: Undeclared identifier. &nbsp; &nbsp; &nbsp; &nbsp;//externalFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.externalFunc(); &nbsp; &nbsp;} } 声明为external的externalFunc()只能以external的方式进行调用，以internal的方式调用会报Error: Undeclared identifier。 4.2 pulic（公有函数） ▪&nbsp;函数默认声明为public。 ▪&nbsp;public的函数既允许以internal的方式调用，也允许以external的方式调用。 ▪&nbsp;public的函数由于允许被外部合约访问，是合约对外接口的一部分。 pragma solidity ^0.4.24; contract FuntionTest{ &nbsp; &nbsp; &nbsp; &nbsp;//默认是public函数 &nbsp; &nbsp;function publicFunc(){} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;publicFunc(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;this.publicFunc(); &nbsp; &nbsp;} } 我们可以看到声明为public的publicFunc()允许两种调用方式。 4.3 internal（内部函数） 在当前的合约或继承的合约中，只允许以internal的方式调用。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp; &nbsp;function internalFunc() internal{} &nbsp; &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//子合约中调用 &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp;internalFunc(); &nbsp; &nbsp;} } 上述例子中声明为internal的internalFunc()在定义合约，和子合约中均只能以internal的方式可以进行调用。 4.4 private（私有函数） ▪&nbsp;只能在当前合约中被访问（不可在被继承的合约中访问）。 ▪&nbsp;即使声明为private，仍能被所有人查看到里面的数据，但是不能修改数据且不能被其它合约访问。 pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp; &nbsp;function privateFunc() private{} &nbsp; &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //以`internal`的方式调用函数 &nbsp; &nbsp; &nbsp; privateFunc(); &nbsp; &nbsp;} } contract B is A{ &nbsp; &nbsp; &nbsp; &nbsp;//不可调用`private` &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//privateFunc(); &nbsp; &nbsp; &nbsp; &nbsp;//这里无法调用合约A中的内部函数, &nbsp; &nbsp; &nbsp; &nbsp;//且在编译阶段就会报错 &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//但是间接调用private函数，但是需要这个private函数处在public中 &nbsp; &nbsp;//function callPrivateByPublicFunc(){ &nbsp; &nbsp;// &nbsp; &nbsp;callFunc(); &nbsp; &nbsp;//} } 五、pure（纯函数） 既不从状态读取数据也不写入数据的函数可以被声明为纯函数 除了之前修改状态数据的情况外，我们认为一下情况属于从状态读取数据。 1. 读取状态变量 2. 调用this.balance或者address.balance 3. 调用block、tx、msg的成员 4. 调用任何非纯函数 5. 使用了包含某些操作码的内联汇编 pragma solidity ^0.4.24; contract C { &nbsp; &nbsp; function f(uint a, uint b) public pure returns (uint) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return a * (b + 42); &nbsp; &nbsp;} } 六、constant/view（只读函数） 不改变状态的函数可以被声明为只读函数一下几种情况被视为修改了状态： 1. 修改状态变量 2. 触发事件 3. 创建了其他合约的实例 4. 使用了selfdestruct自我销毁 5. 调用了向合约转账的函数 6. 调用了非只读函数或者纯函数 7. 使用了底层调用 8. 使用了包含某些操作码的内联汇编 注意： constant是view的一个别名，会在0.5.0版本中遗弃，访问器(getter)方法默认被标记为view调用只读函数。 七、函数修改器 在实际情况中，我们经常需要对调用者进行一些限制。比如，只能是合约的所有者才能改变归属。我们一起来看看如何用函数修改器实现这一限制： pragma solidity ^0.4.24; contract Ownable { &nbsp;address public owner = msg.sender; &nbsp; &nbsp;/// 限制只有创建者才能访问 &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender != owner) throw; &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;/// 改变合约的所有者 &nbsp;function changeOwner(address _newOwner) &nbsp;onlyOwner &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if(_newOwner == 0x0) throw; &nbsp; &nbsp;owner = _newOwner; &nbsp;} } 7.1 函数修改器支持参数 pragma solidity ^0.4.24; contract Parameter{ &nbsp; &nbsp;uint balance = 10; &nbsp;modifier lowerLimit(uint _balance, uint _withdraw){ &nbsp; &nbsp; &nbsp; &nbsp;if( _withdraw &lt; 0 || _withdraw &gt; _balance) throw; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;//含参数的函数修改器 &nbsp;function f(uint withdraw) lowerLimit(balance, withdraw) returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return balance; &nbsp;} } 在上面的例子中，f()函数，有一个函数修改器lowerLimit()，传入了状态变量参数balance，和入参withdraw，以lowerLimit(balance, withdraw)的方式进行调用。最后函数能否正确执行取决于输入的withdraw值大小。 7.2 函数修改器参数支持表达式 pragma solidity ^0.4.24; contract ParameterExpression{ &nbsp;modifier m(uint a){ &nbsp; &nbsp; &nbsp; &nbsp;if(a &gt; 0) &nbsp; &nbsp; &nbsp;_; &nbsp;} &nbsp; &nbsp;function add(uint a, uint b) private returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return a + b; &nbsp;} &nbsp; &nbsp;function f() m(add(1, 1)) returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return 1; &nbsp;} } 八、payable（接收以太币函数） 是声明了该函数涉及接收以太币操作，如果函数没有声明为payable,并且在调用过程中有以太币通过被调用的函数转入合约，那么EVM虚拟机将会抛出异常，状态回退。 pragma solidity ^0.4.24; contract AddressExample { &nbsp; &nbsp; &nbsp; &nbsp;function AddressExample() payable{} &nbsp; &nbsp; &nbsp; &nbsp;function giveEthersTo(address _toAccount,uint amount){ &nbsp; &nbsp; &nbsp; &nbsp;if (this.balance &gt;=amount){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _toAccount.transfer(amount); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;//function() payable{} } 九、回退函数 每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。 下述提供给回退函数可执行的操作会比常规的花费得多一点。 写入到存储(storage) 创建一个合约 执行一个外部(external)函数调用，会花费非常多的gas 发送ether 请在部署合约到网络前，保证透彻的测试你的回退函数，来保证函数执行的花费控制在2300gas以内。 一个没有定义一个回退函数的合约。如果接收ether，会触发异常，并返还ether（solidity v0.4.0开始）。所以合约要接收ether，必须实现回退函数。下面来看个例子。下面来看个例子： pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp; &nbsp; &nbsp;function() public payable{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getX() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return x; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } contract Caller { &nbsp; &nbsp; &nbsp; &nbsp;function Caller()payable{} &nbsp; &nbsp; &nbsp; &nbsp;function callTest(Test test) public{ &nbsp; &nbsp; &nbsp; &nbsp;test.call(0xabcdef01); &nbsp; &nbsp; &nbsp; &nbsp;// test.transfer(2 ether); &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function getBalance() view returns(uint){ &nbsp; &nbsp; &nbsp; &nbsp;return this.balance; &nbsp; &nbsp;} } 如果涉及支付以太币，即回退函数被声明为payable类型，并且通过send或者transfer被调用，那么回退函数仅有你2300gas可以使用，如果回退函数中的代码执行消耗超过2300gas那么被转入的以太币将会退回，修改过的数据状态回退。 以下操作会消耗超过2300gas： 1. 修改状态变量 2. 创建新的合约实例 3. 调用了会消耗gas较多的外部函数 4. 发送以太币 用做接收以太币回退函数内部仅能进行触发事件操作。 十、构造函数 构造函数是一个用constructor关键字声明的可选函数，它在创建合约时执行。构造函数可以是public，也可以是internal。如果没有构造函数，则该合约将生成默认构造函数：contructor() public {}。 pragma solidity ^0.4.24; contract A { &nbsp; &nbsp; &nbsp; &nbsp;uint public a; &nbsp; &nbsp;constructor(uint _a) internal { &nbsp; &nbsp; &nbsp; &nbsp;a = _a; &nbsp; &nbsp;} } 在版本0.4.22之前，构造函数被定义为与合同名称相同的特殊函数，有且只能有一个，不允许重载。这个函数将在合约创建时，执行一次，用于初始化一些配置。这个语法现在不推荐使用。 pragma solidity ^0.4.24; contract ContractConstructor{ &nbsp; &nbsp;uint public counter; &nbsp; &nbsp;function ContractConstructor(){ &nbsp; &nbsp;counter++; &nbsp;} } 上述合约在创建成功后，counter的值将为1。说明合约在创建时，被调用了一次。 十一、函数的输入参数与输出参数 Solidity函数的输入参数的数量是可选的，也可以有任意数量的返回参数。 入参(Input Parameter)与变量的定义方式一致，稍微不同的是，不会用到的参数可以省略变量名称。一种可接受两个整型参数的函数如下: pragma solidity ^0.4.0; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;function taker(uint _a, uint) { &nbsp; &nbsp; &nbsp; &nbsp;// do something with _a. &nbsp; &nbsp;} } 出参（Output Paramets）在returns关键字后定义，语法类似变量的定义方式。返回结果的数量需要与定义的一致。如果给定了参数名，则函数可以不适用return关键字返回，如果没有给定参数名则需要函数体重使用return关键字按照顺序返回。 pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) { &nbsp; &nbsp; &nbsp; &nbsp;o_sum = _a + _b; &nbsp; &nbsp; &nbsp; &nbsp;o_product = _a * _b; &nbsp; &nbsp;} } pragma solidity ^0.4.24; contract Simple { &nbsp; &nbsp; &nbsp; &nbsp;//return sum and product &nbsp; &nbsp;function arithmetics(uint _a, uint _b) &nbsp;pure returns (uint , uint ) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(_a + _b,_a * _b); &nbsp; &nbsp;} } 十二、访问函数 编译器为自动为所有的public的状态变量创建访问函数。下面的合约例子中，编译器会生成一个名叫data的无参，返回值是uint的类型的值data。状态变量的初始化可以在定义时完成。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp; &nbsp; &nbsp;uint public c = 10; } contract D{ &nbsp; &nbsp; &nbsp; &nbsp;C c = new C(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getDataUsingAccessor() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c.c(); &nbsp; &nbsp;} } 访问函数有外部(external)可见性。如果通过内部(internal)的方式访问，比如直接访问，你可以直接把它当一个变量进行使用，但如果使用外部(external)的方式来访问，如通过this.，那么它必须通过函数的方式来调用。 pragma solidity ^0.4.0; contract C{ &nbsp; &nbsp;uint public c = 10; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessInternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp;return c; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function accessExternal() returns (uint){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.c(); &nbsp; &nbsp;} } 十三、抽象函数 是没有函数体的的函数。如下： pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); } 这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。 pragma solidity ^0.4.0; contract Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function getContractName() returns (string){ &nbsp; &nbsp; &nbsp; &nbsp;return &quot;Feline&quot;; &nbsp; &nbsp;} } contract Cat is Feline { &nbsp; &nbsp; &nbsp; &nbsp;function utterance() returns (bytes32) { return &quot;miaow&quot;; } } 如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。 十四、数字和加密函数 以下函数式solidity自带的函数 asser(bool condition): 如果条件不满足，抛出异常。 addmod(uint x, uint y, uint k) returns (uint): 计算(x + y) % k。加法支持任意的精度。但不超过(wrap around？)2**256。 mulmod(uint x, uint y, uint k) returns (uint): 计算(x * y) % k。乘法支持任意精度，但不超过(wrap around？)2**256。 keccak256(...) returns (bytes32): 使用以太坊的（Keccak-256）计算HASH值。紧密打包。 sha3(...) returns (bytes32): 等同于keccak256()。紧密打包。 sha256(...) returns (bytes32): 使用SHA-256计算HASH值。紧密打包。 ripemd160(...) returns (bytes20): 使用RIPEMD-160计算HASH值。紧密打包。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 通过签名信息恢复非对称加密算法公匙地址。如果出错会返回0，例如: function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) { &nbsp; &nbsp; &nbsp; &nbsp;bytes memory prefix = &quot;\\x19Ethereum Signed Message:\\n32&quot;; &nbsp; &nbsp;bytes32 prefixedHash = keccak256(prefix, hash); &nbsp; &nbsp;return ecrecover(prefixedHash, v, r, s) == (Your Address); } revert()： 取消执行，并回撤状态变化。 需要注意的是参数是“紧密打包（tightly packed）”的，意思是说参数不会补位，就直接连接在一起的。下面来看一个例子: keccak256(&quot;ab&quot;, &quot;c&quot;) keccak256(&quot;abc&quot;) //hex keccak256(0x616263) keccak256(6382179) //ascii keccak256(97, 98, 99) 上述例子中，三种表达方式都是一致的。 如果需要补位，需要明确的类型转换，如keccak256(&quot;\\x00\\x12&quot;)等同于keccak256(uint16(0x12)) 需要注意的是字面量会用，尽可能小的空间来存储它们。比如，keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678)) &nbsp; 注意: 在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为它们实现了一种预编译的机制，但合约要在收到第一个消息后才会存在。向一个不存在的合约发送消息，非常昂贵，所以才会导致Out-Of-Gas的问题。一种解决办法是每个在你真正使用它们前，先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。 &nbsp; -END- &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/21/157def86ac9dfb5741fbe749bea2cd91.html","headline":"智能合约基础语言（四）——Solidity函数","dateModified":"2018-09-21T00:00:00+08:00","datePublished":"2018-09-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/21/157def86ac9dfb5741fbe749bea2cd91.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>智能合约基础语言（四）——Solidity函数</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>原文链接：<a href="http://www.liankuai.tech/public/technology/80.html" rel="nofollow">智能合约基础语言（四）：Solidity函数 下</a></strong></p> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p>一、目录</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p><strong>▪&nbsp;</strong>函数的定义</p> 
  <p><strong>▪&nbsp;</strong>函数的调用方式</p> 
  <p><strong>▪&nbsp;</strong>函数的可见性</p> 
  <p>▪&nbsp;函数修改器</p> 
  <p>▪&nbsp;pure函数</p> 
  <p>▪&nbsp;constant、view函数</p> 
  <p>▪&nbsp;payable函数</p> 
  <p>▪&nbsp;回退函数</p> 
  <p>▪&nbsp;构造函数</p> 
  <p>▪&nbsp;函数参数</p> 
  <p>▪&nbsp;抽象函数</p> 
  <p>▪&nbsp;数学和加密函数</p> 
  <blockquote> 
   <p>二、函数的定义</p> 
  </blockquote> 
  <p>function关键字声明的，合约中的可执行单元，一个函数的完整定义如下：</p> 
  <blockquote> 
   <pre>

<code class="language-html hljs">&nbsp;</code></pre> 
   <p><code>function (funcName) (&lt;parameter types&gt;) {public|external|internal|private} [constant|view|payable] [returns (&lt;return types&gt;)]</code></p> 
  </blockquote> 
  <blockquote> 
   <p><strong>三、函数的调用方式</strong></p> 
  </blockquote> 
  <p>Solidity封装了两种函数的调用方式internal（内部调用）和external（外部调用）。</p> 
  <p><strong>3.1 internal（内部调用方式）</strong></p> 
  <p>internal调用，实现时转为简单的EVM跳转，所以它能直接使用上下文环境中的数据，对于引用传递时将会变得非常高效（不用拷贝数据）。</p> 
  <p>在当前的代码单元内，如对合约内函数，引入的库函数，以及父类合约中的函数直接使用即是以internal方式的调用。我们来看个简单的例子：</p> 
  <blockquote> 
   <pre>

<code class="language-html hljs">&nbsp;</code></pre> 
   <p><code>pragma solidity ^0.4.24; contract Test { &nbsp; &nbsp;<br> &nbsp; &nbsp;function </code><strong><code>f</code></strong><code>(){} &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp;//以internal的方式调用 &nbsp; &nbsp;function </code><strong><code>callInternally</code></strong><code>(){ &nbsp; &nbsp; &nbsp; &nbsp;f(); &nbsp; &nbsp;} }</code></p> 
  </blockquote> 
  <p>在上述代码中，callInternally()以internal的方式对f()函数进行了调用。<br> 简而言之，internal（内部调用方式）就是直接使用函数名去调用函数。</p> 
  <p><strong>3.2 external（外部调用方式）</strong></p> 
  <p>external调用，实现为合约的外部消息调用。所以在合约初始化时不能external的方式调用自身函数，因为合约还未初始化完成。下面来看一个以external方式调用的例子：</p> 
  <blockquote> 
   <pre>

<code class="language-html hljs">&nbsp;</code></pre> 
   <p><code>pragma solidity ^0.4.24; contract A{ &nbsp; &nbsp;<br> &nbsp; &nbsp;function </code><code>f</code><code>(){} } contract B{ &nbsp; &nbsp;<br> &nbsp; &nbsp;//以external的方式调用另一合约中的函数 &nbsp; &nbsp;function </code><code>callExternal</code><code>(A a){ &nbsp; &nbsp; &nbsp; &nbsp;a.f(); &nbsp; &nbsp;} }</code></p> 
  </blockquote> 
  <p>虽然当前合约A和B的代码放在一起，但部署到网络上后，它们是两个完全独立的合约，它们之间的方法调用是通过消息调用。上述代码中，在合约B中的callExternal()以external的方式调用了合约A的f()。<br> 简而言之，external（外部调用方式）就是使用合约实例名.函数名的方式去调用函数。</p> 
  <p><strong>3.3 this</strong></p> 
  <p>我们可以在合约的调用函数前加this.来强制以external方式的调用。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract A{ &nbsp; 
<strong> &nbsp; &nbsp;function</strong> </code><strong><code>f</code></strong><code>() </code><strong><code>external</code></strong><code>{} &nbsp; 
 &nbsp; &nbsp;
<strong> &nbsp; &nbsp;function</strong> </code><strong><code>callExternally</code></strong><code>(){ &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;this.f();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p><strong>3.4 调用方式说明</strong></p> 
  <p>上面所提到的internal和external指的函数调用方式，请不要与后面的函数可见性声明的external，public，internal，private弄混。声明只是意味着这个函数需要使用相对应的调用方式去调用。</p> 
  <blockquote> 
   <p><strong>四、函数的可见性</strong></p> 
  </blockquote> 
  <p>Solidity为函数提供了四种可见性，external，public，internal，private。</p> 
  <p><strong>4.1 external（外部函数）</strong></p> 
  <p>▪&nbsp;声明为external的函数可以从其它合约来进行调用，所以声明为external的函数是合约对外接口的一部分。</p> 
  <p>▪&nbsp;不能以internal的方式进行调用。</p> 
  <p>▪&nbsp;有时在接收大的数据数组时性能更好。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract FuntionTest{ &nbsp; &nbsp;
 &nbsp; &nbsp; <strong>function</strong> </code><strong><code>externalFunc</code></strong><code>() </code><strong><code>external</code></strong><code>{} &nbsp; &nbsp;

 &nbsp; &nbsp; <strong>function</strong> </code><strong><code>callFunc</code></strong><code>(){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数报错
 &nbsp; &nbsp; &nbsp; &nbsp;//Error: Undeclared identifier.
 &nbsp; &nbsp; &nbsp; &nbsp;//externalFunc();
 &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数
 &nbsp; &nbsp; &nbsp; &nbsp;this.externalFunc();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>声明为external的externalFunc()只能以external的方式进行调用，以internal的方式调用会报Error: Undeclared identifier。</p> 
  <p><strong>4.2 pulic（公有函数）</strong></p> 
  <p>▪&nbsp;函数默认声明为public。</p> 
  <p>▪&nbsp;public的函数既允许以internal的方式调用，也允许以external的方式调用。</p> 
  <p>▪&nbsp;public的函数由于允许被外部合约访问，是合约对外接口的一部分。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract FuntionTest{ &nbsp; &nbsp;
 &nbsp; &nbsp;//默认是public函数
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>publicFunc</strong></code><code>(){} &nbsp; &nbsp;

 &nbsp; &nbsp;<strong>function </strong></code><code><strong>callFunc</strong></code><code>(){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数
 &nbsp; &nbsp; &nbsp; &nbsp;publicFunc(); 
&nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;//以`external`的方式调用函数
 &nbsp; &nbsp; &nbsp; &nbsp;this.publicFunc();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>我们可以看到声明为public的publicFunc()允许两种调用方式。</p> 
  <p><strong>4.3 internal（内部函数）</strong></p> 
  <p>在当前的合约或继承的合约中，只允许以internal的方式调用。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract A{ &nbsp; &nbsp;

<strong> &nbsp; &nbsp;function </strong></code><code><strong>internalFunc</strong></code><code>() </code><code><strong>internal</strong></code><code>{} &nbsp; &nbsp;

<strong> &nbsp; &nbsp;function </strong></code><code><strong>callFunc</strong></code><code>(){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;//以`internal`的方式调用函数
 &nbsp; &nbsp; &nbsp; &nbsp;internalFunc();
 &nbsp; &nbsp;}
}
contract B is A{ &nbsp; &nbsp;
 &nbsp; &nbsp;//子合约中调用
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>callFunc</strong></code><code>(){
 &nbsp; &nbsp; &nbsp; &nbsp;internalFunc();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>上述例子中声明为internal的internalFunc()在定义合约，和子合约中均只能以internal的方式可以进行调用。</p> 
  <p><strong>4.4 private（私有函数）</strong></p> 
  <p>▪&nbsp;只能在当前合约中被访问（不可在被继承的合约中访问）。</p> 
  <p>▪&nbsp;即使声明为private，仍能被所有人查看到里面的数据，但是不能修改数据且不能被其它合约访问。</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.24;

contract A{ &nbsp; &nbsp;
 &nbsp;function privateFunc() private{} &nbsp; &nbsp;
 &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; //以`internal`的方式调用函数
 &nbsp; &nbsp; &nbsp; privateFunc();
 &nbsp; &nbsp;}
}
contract B is A{ &nbsp; &nbsp;
 &nbsp; &nbsp;//不可调用`private`
 &nbsp; &nbsp;function callFunc(){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;//privateFunc();
 &nbsp; &nbsp; &nbsp; &nbsp;//这里无法调用合约A中的内部函数,
 &nbsp; &nbsp; &nbsp; &nbsp;//且在编译阶段就会报错
 &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;//但是间接调用private函数，但是需要这个private函数处在public中
 &nbsp; &nbsp;//function callPrivateByPublicFunc(){
 &nbsp; &nbsp;// &nbsp; &nbsp;callFunc();
 &nbsp; &nbsp;//}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>五、pure（纯函数）</strong></p> 
  </blockquote> 
  <p>既不从状态读取数据也不写入数据的函数可以被声明为纯函数 除了之前修改状态数据的情况外，我们认为一下情况属于从状态读取数据。</p> 
  <p>1. 读取状态变量</p> 
  <p>2. 调用this.balance或者address.balance</p> 
  <p>3. 调用block、tx、msg的成员</p> 
  <p>4. 调用任何非纯函数</p> 
  <p>5. 使用了包含某些操作码的内联汇编</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.24;

contract C { &nbsp; &nbsp;
function f(uint a, uint b) public pure returns (uint) { &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp;return a * (b + 42);
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>六、constant/view（只读函数）</strong></p> 
  </blockquote> 
  <p>不改变状态的函数可以被声明为只读函数一下几种情况被视为修改了状态：</p> 
  <p>1. 修改状态变量</p> 
  <p>2. 触发事件</p> 
  <p>3. 创建了其他合约的实例</p> 
  <p>4. 使用了selfdestruct自我销毁</p> 
  <p>5. 调用了向合约转账的函数</p> 
  <p>6. 调用了非只读函数或者纯函数</p> 
  <p>7. 使用了底层调用</p> 
  <p>8. 使用了包含某些操作码的内联汇编</p> 
  <p><strong>注意：</strong></p> 
  <p>constant是view的一个别名，会在0.5.0版本中遗弃，访问器(getter)方法默认被标记为view调用只读函数。</p> 
  <blockquote> 
   <p><strong>七、函数修改器</strong></p> 
  </blockquote> 
  <p>在实际情况中，我们经常需要对调用者进行一些限制。比如，只能是合约的所有者才能改变归属。我们一起来看看如何用函数修改器实现这一限制：</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract Ownable {
 &nbsp;address public owner = msg.sender; &nbsp;

 &nbsp;/// 限制只有创建者才能访问
 &nbsp;modifier onlyOwner { &nbsp; &nbsp; 
 &nbsp; &nbsp;if (msg.sender != owner) throw; &nbsp; &nbsp;
 &nbsp; &nbsp;_;
 &nbsp;} &nbsp;

 &nbsp;/// 改变合约的所有者<strong> &nbsp;function </strong></code><code><strong>changeOwner</strong></code><code>(address _newOwner)
 &nbsp;onlyOwner
 &nbsp;{ &nbsp; &nbsp;
 &nbsp; &nbsp;if(_newOwner == 0x0) throw;
 &nbsp; &nbsp;owner = _newOwner;
 &nbsp;}
}</code></pre> 
  </blockquote> 
  <p><strong>7.1 函数修改器支持参数</strong></p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract Parameter{ &nbsp;
 &nbsp;uint balance = 10;

 &nbsp;modifier lowerLimit(uint _balance, uint _withdraw){ &nbsp; &nbsp;
 &nbsp; &nbsp;if( _withdraw &lt; 0 || _withdraw &gt; _balance) throw;
 &nbsp; &nbsp;_;
 &nbsp;} &nbsp;

 &nbsp;//含参数的函数修改器
 &nbsp;function </code><strong><code>f</code></strong><code>(uint withdraw) </code><strong><code>lowerLimit</code></strong><code>(balance, withdraw) </code><strong><code>returns</code></strong><code> (uint){ &nbsp; &nbsp;
 &nbsp; &nbsp;return balance;
 &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>在上面的例子中，f()函数，有一个函数修改器lowerLimit()，传入了状态变量参数balance，和入参withdraw，以lowerLimit(balance, withdraw)的方式进行调用。最后函数能否正确执行取决于输入的withdraw值大小。</p> 
  <p><strong>7.2 函数修改器参数支持表达式</strong></p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract ParameterExpression{
 &nbsp;modifier m(uint a){ &nbsp; &nbsp;
 &nbsp; &nbsp;if(a &gt; 0)
 &nbsp; &nbsp; &nbsp;_;
 &nbsp;} &nbsp;

 &nbsp;function </code><strong><code>add</code></strong><code>(uint a, uint b) </code><strong><code>private returns</code></strong><code>(uint){ &nbsp; &nbsp;
 &nbsp; &nbsp;return a + b;
 &nbsp;} &nbsp;

 &nbsp;function </code><strong><code>f</code></strong><code>() </code><code>m</code><code>(add(1, 1)) </code><strong><code>returns</code></strong><code>(uint){ &nbsp; &nbsp;
 &nbsp; &nbsp;return 1;
 &nbsp;}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>八、payable（接收以太币函数）</strong></p> 
  </blockquote> 
  <p>是声明了该函数涉及接收以太币操作，如果函数没有声明为payable,并且在调用过程中有以太币通过被调用的函数转入合约，那么EVM虚拟机将会抛出异常，状态回退。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract AddressExample { &nbsp; &nbsp;
 &nbsp; &nbsp;function </code><strong><code>AddressExample</code></strong><code>() </code><strong><code>payable</code></strong><code>{} &nbsp; &nbsp;
 &nbsp; &nbsp;function </code><strong><code>giveEthersTo</code></strong><code>(address _toAccount,uint amount){ 
 &nbsp; &nbsp; &nbsp; &nbsp;if (this.balance &gt;=amount){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _toAccount.transfer(amount);
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;function </code><code>getBalance</code><code>() </code><strong><code>view returns</code></strong><code>(uint){ &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;return this.balance;
 &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;//function() payable{}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>九、回退函数</strong></p> 
  </blockquote> 
  <p>每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。</p> 
  <p>此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。</p> 
  <p>下述提供给回退函数可执行的操作会比常规的花费得多一点。</p> 
  <p>写入到存储(storage) 创建一个合约 执行一个外部(external)函数调用，会花费非常多的gas 发送ether 请在部署合约到网络前，保证透彻的测试你的回退函数，来保证函数执行的花费控制在2300gas以内。</p> 
  <p>一个没有定义一个回退函数的合约。如果接收ether，会触发异常，并返还ether（solidity v0.4.0开始）。所以合约要接收ether，必须实现回退函数。下面来看个例子。下面来看个例子：</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.24;

contract Test { &nbsp; &nbsp;

 &nbsp; &nbsp;<strong>function</strong>() </code><code><strong>public paya</strong></code><code><strong>ble</strong></code><code>{} &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;function </code><strong><code>getX</code></strong><code>() </code><strong><code>view returns</code></strong><code>(uint){ &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp;return x;
 &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>getBalance</strong></code><code>() </code><strong><code>view returns</code></strong><code>(uint){ 
 &nbsp; &nbsp; &nbsp; &nbsp;return this.balance;
 &nbsp; &nbsp;}
}


contract Caller { &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>Caller</strong></code><code>()</code><strong><code>payable</code></strong><code>{} &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>callTest</strong></code><code>(Test test) </code><code><strong>public</strong></code><code>{
 &nbsp; &nbsp; &nbsp; &nbsp;test.call(0xabcdef01); 
 &nbsp; &nbsp; &nbsp; &nbsp;// test.transfer(2 ether);
 &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; <strong> function </strong></code><code><strong>getBalance</strong></code><code><strong>() </strong></code><code><strong>view returns</strong></code><code>(uint){ 
 &nbsp; &nbsp; &nbsp; &nbsp;return this.balance;
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>如果涉及支付以太币，即回退函数被声明为payable类型，并且通过send或者transfer被调用，那么回退函数仅有你2300gas可以使用，如果回退函数中的代码执行消耗超过2300gas那么被转入的以太币将会退回，修改过的数据状态回退。</p> 
  <p>以下操作会消耗超过2300gas：</p> 
  <p>1. 修改状态变量</p> 
  <p>2. 创建新的合约实例</p> 
  <p>3. 调用了会消耗gas较多的外部函数</p> 
  <p>4. 发送以太币</p> 
  <p><strong>用做接收以太币回退函数内部仅能进行触发事件操作。</strong></p> 
  <blockquote> 
   <p><strong>十、构造函数</strong></p> 
  </blockquote> 
  <p>构造函数是一个用constructor关键字声明的可选函数，它在创建合约时执行。构造函数可以是public，也可以是internal。如果没有构造函数，则该合约将生成默认构造函数：contructor() public {}。</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.24;

contract A { &nbsp; &nbsp;
 &nbsp; &nbsp;uint public a;

 &nbsp; &nbsp;constructor(uint _a) internal {
 &nbsp; &nbsp; &nbsp; &nbsp;a = _a;
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>在版本0.4.22之前，构造函数被定义为与合同名称相同的特殊函数，有且只能有一个，不允许重载。这个函数将在合约创建时，执行一次，用于初始化一些配置。这个语法现在不推荐使用。</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.24;

contract ContractConstructor{ &nbsp;
 &nbsp;uint public counter; &nbsp;

 &nbsp;function ContractConstructor(){
 &nbsp; &nbsp;counter++;
 &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>上述合约在创建成功后，counter的值将为1。说明合约在创建时，被调用了一次。</p> 
  <blockquote> 
   <p><strong>十一、函数的输入参数与输出参数</strong></p> 
  </blockquote> 
  <p>Solidity函数的输入参数的数量是可选的，也可以有任意数量的返回参数。</p> 
  <p>入参(Input Parameter)与变量的定义方式一致，稍微不同的是，不会用到的参数可以省略变量名称。一种可接受两个整型参数的函数如下:</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.0;
contract Simple { &nbsp; &nbsp;
 &nbsp; &nbsp;function taker(uint _a, uint) {
 &nbsp; &nbsp; &nbsp; &nbsp;// do something with _a.
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>出参（Output Paramets）在returns关键字后定义，语法类似变量的定义方式。返回结果的数量需要与定义的一致。如果给定了参数名，则函数可以不适用return关键字返回，如果没有给定参数名则需要函数体重使用return关键字按照顺序返回。</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.24;

contract Simple { &nbsp; &nbsp;
 &nbsp; &nbsp;//return sum and product
 &nbsp; &nbsp;function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
 &nbsp; &nbsp; &nbsp; &nbsp;o_sum = _a + _b;
 &nbsp; &nbsp; &nbsp; &nbsp;o_product = _a * _b;
 &nbsp; &nbsp;}
}

pragma solidity ^0.4.24;

contract Simple { &nbsp; &nbsp;
 &nbsp; &nbsp;//return sum and product
 &nbsp; &nbsp;function arithmetics(uint _a, uint _b) &nbsp;pure returns (uint , uint ) { &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;return(_a + _b,_a * _b);
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>十二、访问函数</strong></p> 
  </blockquote> 
  <p>编译器为自动为所有的public的状态变量创建访问函数。下面的合约例子中，编译器会生成一个名叫data的无参，返回值是uint的类型的值data。状态变量的初始化可以在定义时完成。</p> 
  <blockquote> 
   <pre class="has">
<code>pragma solidity ^0.4.0;

contract C{ &nbsp; &nbsp;
 &nbsp; &nbsp;uint public c = 10;
}

contract D{ &nbsp; &nbsp;
 &nbsp; &nbsp;C c = new C(); &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;function getDataUsingAccessor() returns (uint){ 
 &nbsp; &nbsp; &nbsp; &nbsp;return c.c();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <p>访问函数有外部(external)可见性。如果通过内部(internal)的方式访问，比如直接访问，你可以直接把它当一个变量进行使用，但如果使用外部(external)的方式来访问，如通过this.，那么它必须通过函数的方式来调用。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.0;


contract C{
 &nbsp; &nbsp;uint public c = 10; &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>accessInternal</strong></code><code>() </code><strong><code>returns</code></strong><code> (uint){ 
 &nbsp; &nbsp; &nbsp; &nbsp;return c;
 &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>accessExternal</strong></code><code>() </code><code><strong>returns</strong></code><code> (uint){ &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;return this.c();
 &nbsp; &nbsp;}
}</code></pre> 
  </blockquote> 
  <blockquote> 
   <p><strong>十三、抽象函数</strong></p> 
  </blockquote> 
  <p>是没有函数体的的函数。如下：</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.0;

contract Feline { &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>utterance</strong></code><code>() </code><code><strong>returns</strong></code><code> (bytes32);
}</code></pre> 
  </blockquote> 
  <p>这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。</p> 
  <blockquote> 
   <pre>
<code>pragma solidity ^0.4.0;

contract Feline { &nbsp; &nbsp;
 &nbsp; &nbsp;function utterance() returns (bytes32); &nbsp; &nbsp;
 &nbsp; &nbsp;
 &nbsp; &nbsp;function getContractName() returns (string){ 
 &nbsp; &nbsp; &nbsp; &nbsp;return "Feline";
 &nbsp; &nbsp;}
}


contract Cat is Feline { &nbsp; &nbsp;
 &nbsp; &nbsp;<strong>function </strong></code><code><strong>utterance</strong></code><code>() </code><code><strong>returns</strong></code><code> (bytes32) { return "miaow"; }
}</code></pre> 
  </blockquote> 
  <p>如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。</p> 
  <blockquote> 
   <p><strong>十四、数字和加密函数</strong></p> 
  </blockquote> 
  <p>以下函数式solidity自带的函数</p> 
  <blockquote> 
   <p>asser(bool condition):</p> 
  </blockquote> 
  <p>如果条件不满足，抛出异常。</p> 
  <blockquote> 
   <p>addmod(uint x, uint y, uint k) returns (uint):</p> 
  </blockquote> 
  <p>计算(x + y) % k。加法支持任意的精度。但不超过(wrap around？)2**256。</p> 
  <blockquote> 
   <p>mulmod(uint x, uint y, uint k) returns (uint):</p> 
  </blockquote> 
  <p>计算(x * y) % k。乘法支持任意精度，但不超过(wrap around？)2**256。</p> 
  <blockquote> 
   <p>keccak256(...) returns (bytes32):</p> 
  </blockquote> 
  <p>使用以太坊的（Keccak-256）计算HASH值。紧密打包。</p> 
  <blockquote> 
   <p>sha3(...) returns (bytes32):</p> 
  </blockquote> 
  <p>等同于keccak256()。紧密打包。</p> 
  <blockquote> 
   <p>sha256(...) returns (bytes32):</p> 
  </blockquote> 
  <p>使用SHA-256计算HASH值。紧密打包。</p> 
  <blockquote> 
   <p>ripemd160(...) returns (bytes20):</p> 
  </blockquote> 
  <p>使用RIPEMD-160计算HASH值。紧密打包。</p> 
  <blockquote> 
   <p>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):</p> 
  </blockquote> 
  <p>通过签名信息恢复非对称加密算法公匙地址。如果出错会返回0，例如:</p> 
  <blockquote> 
   <pre class="has">
<code>function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) { &nbsp; &nbsp;

 &nbsp; &nbsp;bytes memory prefix = "\x19Ethereum Signed Message:\n32";
 &nbsp; &nbsp;bytes32 prefixedHash = keccak256(prefix, hash);
 &nbsp; &nbsp;return ecrecover(prefixedHash, v, r, s) == (Your Address);
}</code></pre> 
  </blockquote> 
  <p>revert()：</p> 
  <p>取消执行，并回撤状态变化。</p> 
  <p>需要注意的是参数是“紧密打包（tightly packed）”的，意思是说参数不会补位，就直接连接在一起的。下面来看一个例子:</p> 
  <blockquote> 
   <pre>
<strong><code>keccak256</code></strong><code>(</code><code>"ab"</code><code>, </code><code>"c"</code><code>)
</code><strong><code>keccak256</code></strong><code>(</code><code>"abc"</code><code>)
//hex
</code><strong><code>keccak256</code></strong><code>(</code><code>0</code><code>x616263)
</code><strong><code>keccak256</code></strong><code>(</code><code>6382179</code><code>)
//ascii
</code><strong><code>keccak256</code></strong><code>(</code><code>97</code><code>, </code><code>98</code><code>, </code><code>99</code><code>)</code></pre> 
  </blockquote> 
  <p>上述例子中，三种表达方式都是一致的。</p> 
  <p>如果需要补位，需要明确的类型转换，如keccak256("\x00\x12")等同于keccak256(uint16(0x12))</p> 
  <p>需要注意的是字面量会用，尽可能小的空间来存储它们。比如，keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678))</p> 
  <p>&nbsp;</p> 
  <p><strong>注意:</strong></p> 
  <p><strong>在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为它们实现了一种预编译的机制，但合约要在收到第一个消息后才会存在。向一个不存在的合约发送消息，非常昂贵，所以才会导致Out-Of-Gas的问题。一种解决办法是每个在你真正使用它们前，先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。</strong></p> 
  <p>&nbsp;</p> 
  <p>-END-</p> 
  <p style="text-align:center;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180921192015555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5rdWFpeHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liankuaixy/article/details/82805999,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liankuaixy/article/details/82805999,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/liankuaixy/article/details/82805999,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/liankuaixy/article/details/82805999,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
