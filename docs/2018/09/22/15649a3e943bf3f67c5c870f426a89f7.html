<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Plasma Cash 合约解读 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Plasma Cash 合约解读" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者介绍 虫洞社区·签约作者 steven bai Plasma Cash 合约解读 Plasma Cash 合约解读 1. 合约代码 2. 合约文件简单介绍 3. Plasma Cash 的基础数据结构 3.1 Plasma Cash 中的资产 3.2 Plasma Cash中的交易 3.3 Plasma Cash 中的 Block 3.4 Plasma Cash 中资产的回归主链以太坊 3.4.1 资产拥有证明 3.4.2 等待其他人来挑战我 3.4.3 挑战期过了, Bob 拿回资产 uid 4. Plasma Cash 中的退出示例 5. 其他问题 此文来自 SmartMesh 团队，转载请联系作者。 Plasma 由 V 神在2017年8月提出,希望通过链下交易来大幅提高以太坊的 TPS. 每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。 Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问. 1. 合约代码 SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上 plasma cash. 2. 合约文件简单介绍 文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看. Mediator.sol 是 Plasma Cash 链中资产的进出口 RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等 libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof. libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的. libraries/PlasmaLib.sol 生成 uid 的辅助函数 ECRecovery.sol 签名验证 datastructures/Transaction.sol 描述交易的数据结构 3. Plasma Cash 的基础数据结构 Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链. 3.1 Plasma Cash 中的资产 Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割. 可以参考 Mediator.sol的deposit函数. Mediator就是 Plasma Cash 资产存放的地方. /** @dev Adds deposits on Smart Plasma. * @param currency Currency address. * @param amount Amount amount of currency. */ function deposit(address currency, uint amount) public { require(amount &gt; 0); Token token = Token(currency); token.transferFrom(msg.sender, this, amount); /// deposit test1 bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2 cash[uid] = entry({ currency: currency, amount: amount }); } 通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个. 3.2 Plasma Cash中的交易 关键代码在 Transaction.sol中. struct Tx { uint prevBlock; uint uid; uint amount; address newOwner; uint nonce; address signer; bytes32 hash; } 这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释. prevBlock就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到. uid 就是交易的资产 ID newOwner 交易输出给谁, 这里也不支持像 比特币一样的脚本. nonce 是这笔资产的第多少次交易,在双花证明中有重要作用. signer必须由资产原拥有者的签名. amount 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 hash 则是可以直接计算出来. 3.3 Plasma Cash 中的 Block 如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成. 具体代码可见 RootChain.sol的. function newBlock(bytes32 hash) public onlyOperator { blockNumber = blockNumber.add(uint256(1)); childChain[blockNumber] = hash; NewBlock(hash); } 交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则. 3.4 Plasma Cash 中资产的回归主链以太坊 当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么就需要向以太坊合约也就是 RootChain证明,他确实拥有这一笔资产. 3.4.1 资产拥有证明 这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.具体见RootChain.sol中的startExit函数. 其思路非常简单,证明 这笔资产来自哪里(在哪 M块中转移到了 Alice 手中) 经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我) 具体看代码 startExit /** @dev Starts the procedure for withdrawal of the deposit from the system. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function startExit( bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); // 证明在 prevBlock的时候 Alice 拥有资产 uid require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); //amount 不变,证明资产不可分割 require(prevDecodedTx.amount == decodedTx.amount); //Alice 确实签名转移给了我,并且交易是相邻的两笔交易 require(prevDecodedTx.newOwner == decodedTx.signer); require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易 //我是 Bob, 我要来拿走这笔资产 require(msg.sender == decodedTx.newOwner); require(wallet[bytes32(decodedTx.uid)] != 0); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); /// Record the exit tx. require(exits[decodedTx.uid].state == 0); require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid] = exit({ state: 2, exitTime: now.add(challengePeriod), exitTxBlkNum: lastTxBlockNum, exitTx: lastTx, txBeforeExitTxBlkNum: previousTxBlockNum, txBeforeExitTx: previousTx }); StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum); } 代码的前一半都是在用来证明在lastTxBlockNum的时候,资产 uid 归Bob所有. 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战. 3.4.2 等待其他人来挑战我 有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人. 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者? 这些问题,看起来很难回答,其实思路也很简单. 这个思路和雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证. 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花. 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益. //challengeExit 挑战资产uid 其实不属于 Bob /** @dev Challenges a exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param proof Proof of inclusion of the transaction in a Smart Plasma block. * @param challengeBlockNum The number of the block in which the transaction is included. */ function challengeExit( uint256 uid, bytes challengeTx, bytes proof, uint256 challengeBlockNum ) public { require(exits[uid].state == 2); Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx(); Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx(); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); require(exitDecodedTx.uid == challengeDecodedTx.uid); require(exitDecodedTx.amount == challengeDecodedTx.amount); bytes32 txHash = challengeDecodedTx.hash; bytes32 blockRoot = childChain[challengeBlockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); // test challenge #1 &amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花 if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; exitDecodedTx.nonce &lt; challengeDecodedTx.nonce) { delete exits[uid]; return; } // test challenge #3, 双花了, Alice 给了两个人,并且挑战者 Carol的BlockNumer 更小,也就是发生的更早. if (challengeBlockNum &lt; exits[uid].exitTxBlkNum &amp;&amp; (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; challengeDecodedTx.nonce &gt; beforeExitDecodedTx.nonce)) { delete exits[uid]; return; } // test challenge #4 在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid if (challengeBlockNum &lt; exits[uid].txBeforeExitTxBlkNum ) { exits[uid].state = 1; addChallenge(uid, challengeTx, challengeBlockNum); } require(exits[uid].state == 1); ChallengeExit(uid); } //Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid /** @dev Answers a challenge exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param respondTx Transaction that answers to a dispute transaction. * @param proof Proof of inclusion of the respond transaction in a Smart Plasma block. * @param blockNum The number of the block in which the respond transaction is included. */ function respondChallengeExit( uint256 uid, bytes challengeTx, bytes respondTx, bytes proof, uint blockNum ) public { require(challengeExists(uid, challengeTx)); require(exits[uid].state == 1); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); Transaction.Tx memory respondDecodedTx = respondTx.createTx(); require(challengeDecodedTx.uid == respondDecodedTx.uid); require(challengeDecodedTx.amount == respondDecodedTx.amount); require(challengeDecodedTx.newOwner == respondDecodedTx.signer); require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce); require(blockNum &lt; exits[uid].txBeforeExitTxBlkNum); bytes32 txHash = respondDecodedTx.hash; bytes32 blockRoot = childChain[blockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); removeChallenge(uid, challengeTx); if (challengesLength(uid) == 0) { exits[uid].state = 2; } RespondChallengeExit(uid); } 3.4.3 挑战期过了, Bob 拿回资产 uid 挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中 /** @dev withdraws deposit from Smart Plasma. * @param prevTx Penultimate deposit transaction. * @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param prevTxBlkNum The number of the block in which the penultimate transaction is included. * @param txRaw lastTx Last deposit transaction. * @param txProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param txBlkNum The number of the block in which the last transaction is included. */ function withdraw( bytes prevTx, bytes prevTxProof, uint prevTxBlkNum, bytes txRaw, bytes txProof, uint txBlkNum ) public { bytes32 uid = rootChain.finishExit( msg.sender, prevTx, prevTxProof, prevTxBlkNum, txRaw, txProof, txBlkNum ); entry invoice = cash[uid]; Token token = Token(invoice.currency); token.transfer(msg.sender, invoice.amount); /// 真正的资产转移 delete(cash[uid]); } RootChain 再次验证 /** @dev Finishes the procedure for withdrawal of the deposit from the system. * Can only call the owner. Usually the owner is the mediator contract. * @param account Account that initialized the deposit withdrawal. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function finishExit( address account, bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public onlyOwner returns (bytes32) { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); require(prevDecodedTx.amount == decodedTx.amount); require(prevDecodedTx.newOwner == decodedTx.signer); require(account == decodedTx.newOwner); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); require(exits[decodedTx.uid].exitTime &lt; now); //挑战期过了 require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据 require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid].state = 3; delete(wallet[bytes32(decodedTx.uid)]); FinishExit(decodedTx.uid); return bytes32(decodedTx.uid); } 4. Plasma Cash 中的退出示例 5. 其他问题 为什么 Plasma Cash 中的资产是不可分割的? 进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出. operator 的作用是什么 operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中. operator 是否必须可信任的? 是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中. 当然这部分是可以改进,降低 operator 作恶带来的风险. operator 是否可以是一个合约呢? 是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险 添加微信（cdong1024），加入区块链开发者技术交流群 虫洞社区：https://www.uzanapp.com/ 阅读更多" />
<meta property="og:description" content="作者介绍 虫洞社区·签约作者 steven bai Plasma Cash 合约解读 Plasma Cash 合约解读 1. 合约代码 2. 合约文件简单介绍 3. Plasma Cash 的基础数据结构 3.1 Plasma Cash 中的资产 3.2 Plasma Cash中的交易 3.3 Plasma Cash 中的 Block 3.4 Plasma Cash 中资产的回归主链以太坊 3.4.1 资产拥有证明 3.4.2 等待其他人来挑战我 3.4.3 挑战期过了, Bob 拿回资产 uid 4. Plasma Cash 中的退出示例 5. 其他问题 此文来自 SmartMesh 团队，转载请联系作者。 Plasma 由 V 神在2017年8月提出,希望通过链下交易来大幅提高以太坊的 TPS. 每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。 Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问. 1. 合约代码 SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上 plasma cash. 2. 合约文件简单介绍 文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看. Mediator.sol 是 Plasma Cash 链中资产的进出口 RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等 libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof. libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的. libraries/PlasmaLib.sol 生成 uid 的辅助函数 ECRecovery.sol 签名验证 datastructures/Transaction.sol 描述交易的数据结构 3. Plasma Cash 的基础数据结构 Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链. 3.1 Plasma Cash 中的资产 Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割. 可以参考 Mediator.sol的deposit函数. Mediator就是 Plasma Cash 资产存放的地方. /** @dev Adds deposits on Smart Plasma. * @param currency Currency address. * @param amount Amount amount of currency. */ function deposit(address currency, uint amount) public { require(amount &gt; 0); Token token = Token(currency); token.transferFrom(msg.sender, this, amount); /// deposit test1 bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2 cash[uid] = entry({ currency: currency, amount: amount }); } 通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个. 3.2 Plasma Cash中的交易 关键代码在 Transaction.sol中. struct Tx { uint prevBlock; uint uid; uint amount; address newOwner; uint nonce; address signer; bytes32 hash; } 这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释. prevBlock就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到. uid 就是交易的资产 ID newOwner 交易输出给谁, 这里也不支持像 比特币一样的脚本. nonce 是这笔资产的第多少次交易,在双花证明中有重要作用. signer必须由资产原拥有者的签名. amount 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 hash 则是可以直接计算出来. 3.3 Plasma Cash 中的 Block 如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成. 具体代码可见 RootChain.sol的. function newBlock(bytes32 hash) public onlyOperator { blockNumber = blockNumber.add(uint256(1)); childChain[blockNumber] = hash; NewBlock(hash); } 交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则. 3.4 Plasma Cash 中资产的回归主链以太坊 当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么就需要向以太坊合约也就是 RootChain证明,他确实拥有这一笔资产. 3.4.1 资产拥有证明 这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.具体见RootChain.sol中的startExit函数. 其思路非常简单,证明 这笔资产来自哪里(在哪 M块中转移到了 Alice 手中) 经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我) 具体看代码 startExit /** @dev Starts the procedure for withdrawal of the deposit from the system. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function startExit( bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); // 证明在 prevBlock的时候 Alice 拥有资产 uid require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); //amount 不变,证明资产不可分割 require(prevDecodedTx.amount == decodedTx.amount); //Alice 确实签名转移给了我,并且交易是相邻的两笔交易 require(prevDecodedTx.newOwner == decodedTx.signer); require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易 //我是 Bob, 我要来拿走这笔资产 require(msg.sender == decodedTx.newOwner); require(wallet[bytes32(decodedTx.uid)] != 0); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); /// Record the exit tx. require(exits[decodedTx.uid].state == 0); require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid] = exit({ state: 2, exitTime: now.add(challengePeriod), exitTxBlkNum: lastTxBlockNum, exitTx: lastTx, txBeforeExitTxBlkNum: previousTxBlockNum, txBeforeExitTx: previousTx }); StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum); } 代码的前一半都是在用来证明在lastTxBlockNum的时候,资产 uid 归Bob所有. 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战. 3.4.2 等待其他人来挑战我 有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人. 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者? 这些问题,看起来很难回答,其实思路也很简单. 这个思路和雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证. 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花. 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益. //challengeExit 挑战资产uid 其实不属于 Bob /** @dev Challenges a exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param proof Proof of inclusion of the transaction in a Smart Plasma block. * @param challengeBlockNum The number of the block in which the transaction is included. */ function challengeExit( uint256 uid, bytes challengeTx, bytes proof, uint256 challengeBlockNum ) public { require(exits[uid].state == 2); Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx(); Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx(); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); require(exitDecodedTx.uid == challengeDecodedTx.uid); require(exitDecodedTx.amount == challengeDecodedTx.amount); bytes32 txHash = challengeDecodedTx.hash; bytes32 blockRoot = childChain[challengeBlockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); // test challenge #1 &amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花 if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; exitDecodedTx.nonce &lt; challengeDecodedTx.nonce) { delete exits[uid]; return; } // test challenge #3, 双花了, Alice 给了两个人,并且挑战者 Carol的BlockNumer 更小,也就是发生的更早. if (challengeBlockNum &lt; exits[uid].exitTxBlkNum &amp;&amp; (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; challengeDecodedTx.nonce &gt; beforeExitDecodedTx.nonce)) { delete exits[uid]; return; } // test challenge #4 在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid if (challengeBlockNum &lt; exits[uid].txBeforeExitTxBlkNum ) { exits[uid].state = 1; addChallenge(uid, challengeTx, challengeBlockNum); } require(exits[uid].state == 1); ChallengeExit(uid); } //Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid /** @dev Answers a challenge exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param respondTx Transaction that answers to a dispute transaction. * @param proof Proof of inclusion of the respond transaction in a Smart Plasma block. * @param blockNum The number of the block in which the respond transaction is included. */ function respondChallengeExit( uint256 uid, bytes challengeTx, bytes respondTx, bytes proof, uint blockNum ) public { require(challengeExists(uid, challengeTx)); require(exits[uid].state == 1); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); Transaction.Tx memory respondDecodedTx = respondTx.createTx(); require(challengeDecodedTx.uid == respondDecodedTx.uid); require(challengeDecodedTx.amount == respondDecodedTx.amount); require(challengeDecodedTx.newOwner == respondDecodedTx.signer); require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce); require(blockNum &lt; exits[uid].txBeforeExitTxBlkNum); bytes32 txHash = respondDecodedTx.hash; bytes32 blockRoot = childChain[blockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); removeChallenge(uid, challengeTx); if (challengesLength(uid) == 0) { exits[uid].state = 2; } RespondChallengeExit(uid); } 3.4.3 挑战期过了, Bob 拿回资产 uid 挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中 /** @dev withdraws deposit from Smart Plasma. * @param prevTx Penultimate deposit transaction. * @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param prevTxBlkNum The number of the block in which the penultimate transaction is included. * @param txRaw lastTx Last deposit transaction. * @param txProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param txBlkNum The number of the block in which the last transaction is included. */ function withdraw( bytes prevTx, bytes prevTxProof, uint prevTxBlkNum, bytes txRaw, bytes txProof, uint txBlkNum ) public { bytes32 uid = rootChain.finishExit( msg.sender, prevTx, prevTxProof, prevTxBlkNum, txRaw, txProof, txBlkNum ); entry invoice = cash[uid]; Token token = Token(invoice.currency); token.transfer(msg.sender, invoice.amount); /// 真正的资产转移 delete(cash[uid]); } RootChain 再次验证 /** @dev Finishes the procedure for withdrawal of the deposit from the system. * Can only call the owner. Usually the owner is the mediator contract. * @param account Account that initialized the deposit withdrawal. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function finishExit( address account, bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public onlyOwner returns (bytes32) { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); require(prevDecodedTx.amount == decodedTx.amount); require(prevDecodedTx.newOwner == decodedTx.signer); require(account == decodedTx.newOwner); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); require(exits[decodedTx.uid].exitTime &lt; now); //挑战期过了 require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据 require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid].state = 3; delete(wallet[bytes32(decodedTx.uid)]); FinishExit(decodedTx.uid); return bytes32(decodedTx.uid); } 4. Plasma Cash 中的退出示例 5. 其他问题 为什么 Plasma Cash 中的资产是不可分割的? 进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出. operator 的作用是什么 operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中. operator 是否必须可信任的? 是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中. 当然这部分是可以改进,降低 operator 作恶带来的风险. operator 是否可以是一个合约呢? 是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险 添加微信（cdong1024），加入区块链开发者技术交流群 虫洞社区：https://www.uzanapp.com/ 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者介绍 虫洞社区·签约作者 steven bai Plasma Cash 合约解读 Plasma Cash 合约解读 1. 合约代码 2. 合约文件简单介绍 3. Plasma Cash 的基础数据结构 3.1 Plasma Cash 中的资产 3.2 Plasma Cash中的交易 3.3 Plasma Cash 中的 Block 3.4 Plasma Cash 中资产的回归主链以太坊 3.4.1 \b资产拥有证明 3.4.2 等待其他人来挑战我 3.4.3 挑战期过了, Bob 拿回资产 uid 4. Plasma Cash 中的退出示例 5. 其他问题 此文来自 SmartMesh 团队，转载请联系作者。 Plasma 由 V 神在2017年8月提出,希望通过链下交易来大幅提高以太坊的 TPS. 每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。 Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问. 1. 合约代码 SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上 plasma cash. 2. 合约文件简单介绍 文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看. Mediator.sol 是 Plasma Cash 链中资产的进出口 RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等 libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof. libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的. libraries/PlasmaLib.sol 生成 uid 的辅助函数 ECRecovery.sol 签名验证 datastructures/Transaction.sol 描述交易的数据结构 3. Plasma Cash 的基础数据结构 Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链. 3.1 Plasma Cash 中的资产 Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割. 可以参考 Mediator.sol的deposit函数. Mediator就是 Plasma Cash 资产存放的地方. /** @dev Adds deposits on Smart Plasma. * @param currency Currency address. * @param amount Amount amount of currency. */ function deposit(address currency, uint amount) public { require(amount &gt; 0); Token token = Token(currency); token.transferFrom(msg.sender, this, amount); /// deposit test1 bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2 cash[uid] = entry({ currency: currency, amount: amount }); } 通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个. 3.2 Plasma Cash中的交易 关键代码在 Transaction.sol中. struct Tx { uint prevBlock; uint uid; uint amount; address newOwner; uint nonce; address signer; bytes32 hash; } 这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释. prevBlock就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到. uid 就是交易的资产 ID newOwner 交易输出给谁, 这里也不支持像 比特币一样的脚本. nonce 是这笔资产的第多少次交易,在双花证明中有重要作用. signer必须由资产原拥有者的签名. amount 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 hash 则是可以直接计算出来. 3.3 Plasma Cash 中的 Block 如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成. 具体代码可见 RootChain.sol的. function newBlock(bytes32 hash) public onlyOperator { blockNumber = blockNumber.add(uint256(1)); childChain[blockNumber] = hash; NewBlock(hash); } 交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则. 3.4 Plasma Cash 中资产的回归主链以太坊 当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么\b就需要向以太坊合约也就是 RootChain\b证明,他确实拥有这一笔\b\b资产. 3.4.1 \b资产拥有证明 这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.\b具体见RootChain.sol中的startExit函数. 其思路非常简单,证明 这笔资产来自哪里(在哪 M块中转移到了 Alice 手中) 经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我) 具体看代码 startExit /** @dev Starts the procedure for withdrawal of the deposit from the system. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function startExit( bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); // 证明在 prevBlock的时候 Alice 拥有资产 uid require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); //amount 不变,证明\b资产不可分割 require(prevDecodedTx.amount == decodedTx.amount); //Alice 确实签名转移给了我,并且交易是相邻的两笔交易 require(prevDecodedTx.newOwner == decodedTx.signer); require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易 //我是 Bob, 我要来拿走这笔资产 require(msg.sender == decodedTx.newOwner); require(wallet[bytes32(decodedTx.uid)] != 0); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); /// Record the exit tx. require(exits[decodedTx.uid].state == 0); require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid] = exit({ state: 2, exitTime: now.add(challengePeriod), exitTxBlkNum: lastTxBlockNum, exitTx: lastTx, txBeforeExitTxBlkNum: previousTxBlockNum, txBeforeExitTx: previousTx }); StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum); } 代码的前一半都是在用来证明在lastTxBlockNum的时候,资产 uid 归B\bob所有. 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战. 3.4.2 等待其他人来挑战我 有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人. 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者? 这些问题,\b看起来很难回答,其实思路也很简单. 这个思路和\b雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证. 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花. 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益. //challengeExit 挑战资产uid 其实不属于 Bob /** @dev Challenges a exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param proof Proof of inclusion of the transaction in a Smart Plasma block. * @param challengeBlockNum The number of the block in which the transaction is included. */ function challengeExit( uint256 uid, bytes challengeTx, bytes proof, uint256 challengeBlockNum ) public { require(exits[uid].state == 2); Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx(); Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx(); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); require(exitDecodedTx.uid == challengeDecodedTx.uid); require(exitDecodedTx.amount == challengeDecodedTx.amount); bytes32 txHash = challengeDecodedTx.hash; bytes32 blockRoot = childChain[challengeBlockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); // test challenge #1 &amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花 if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; exitDecodedTx.nonce &lt; challengeDecodedTx.nonce) { delete exits[uid]; return; } // test challenge #3, 双花了, Alice 给了两个人,并且\b挑战者 Carol的BlockNumer 更小,也就是发生的更早. if (challengeBlockNum &lt; exits[uid].exitTxBlkNum &amp;&amp; (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp; challengeDecodedTx.nonce &gt; beforeExitDecodedTx.nonce)) { delete exits[uid]; return; } // test challenge #4 在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid if (challengeBlockNum &lt; exits[uid].txBeforeExitTxBlkNum ) { exits[uid].state = 1; addChallenge(uid, challengeTx, challengeBlockNum); } require(exits[uid].state == 1); ChallengeExit(uid); } //Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid /** @dev Answers a challenge exit. * @param uid Unique identifier of a deposit. * @param challengeTx Transaction that disputes an exit. * @param respondTx Transaction that answers to a dispute transaction. * @param proof Proof of inclusion of the respond transaction in a Smart Plasma block. * @param blockNum The number of the block in which the respond transaction is included. */ function respondChallengeExit( uint256 uid, bytes challengeTx, bytes respondTx, bytes proof, uint blockNum ) public { require(challengeExists(uid, challengeTx)); require(exits[uid].state == 1); Transaction.Tx memory challengeDecodedTx = challengeTx.createTx(); Transaction.Tx memory respondDecodedTx = respondTx.createTx(); require(challengeDecodedTx.uid == respondDecodedTx.uid); require(challengeDecodedTx.amount == respondDecodedTx.amount); require(challengeDecodedTx.newOwner == respondDecodedTx.signer); require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce); require(blockNum &lt; exits[uid].txBeforeExitTxBlkNum); bytes32 txHash = respondDecodedTx.hash; bytes32 blockRoot = childChain[blockNum]; require(txHash.verifyProof(uid, blockRoot, proof)); removeChallenge(uid, challengeTx); if (challengesLength(uid) == 0) { exits[uid].state = 2; } RespondChallengeExit(uid); } 3.4.3 挑战期过了, Bob 拿回资产 uid 挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中 /** @dev withdraws deposit from Smart Plasma. * @param prevTx Penultimate deposit transaction. * @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param prevTxBlkNum The number of the block in which the penultimate transaction is included. * @param txRaw lastTx Last deposit transaction. * @param txProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param txBlkNum The number of the block in which the last transaction is included. */ function withdraw( bytes prevTx, bytes prevTxProof, uint prevTxBlkNum, bytes txRaw, bytes txProof, uint txBlkNum ) public { bytes32 uid = rootChain.finishExit( msg.sender, prevTx, prevTxProof, prevTxBlkNum, txRaw, txProof, txBlkNum ); entry invoice = cash[uid]; Token token = Token(invoice.currency); token.transfer(msg.sender, invoice.amount); /// 真正的资产转移 delete(cash[uid]); } RootChain 再次验证 /** @dev Finishes the procedure for withdrawal of the deposit from the system. * Can only call the owner. Usually the owner is the mediator contract. * @param account Account that initialized the deposit withdrawal. * @param previousTx Penultimate deposit transaction. * @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block. * @param previousTxBlockNum The number of the block in which the penultimate transaction is included. * @param lastTx Last deposit transaction. * @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block. * @param lastTxBlockNum The number of the block in which the last transaction is included. */ function finishExit( address account, bytes previousTx, bytes previousTxProof, uint256 previousTxBlockNum, bytes lastTx, bytes lastTxProof, uint256 lastTxBlockNum ) public onlyOwner returns (bytes32) { Transaction.Tx memory prevDecodedTx = previousTx.createTx(); Transaction.Tx memory decodedTx = lastTx.createTx(); require(previousTxBlockNum == decodedTx.prevBlock); require(prevDecodedTx.uid == decodedTx.uid); require(prevDecodedTx.amount == decodedTx.amount); require(prevDecodedTx.newOwner == decodedTx.signer); require(account == decodedTx.newOwner); bytes32 prevTxHash = prevDecodedTx.hash; bytes32 prevBlockRoot = childChain[previousTxBlockNum]; bytes32 txHash = decodedTx.hash; bytes32 blockRoot = childChain[lastTxBlockNum]; require( prevTxHash.verifyProof( prevDecodedTx.uid, prevBlockRoot, previousTxProof ) ); require( txHash.verifyProof( decodedTx.uid, blockRoot, lastTxProof ) ); require(exits[decodedTx.uid].exitTime &lt; now); //挑战期过了 require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据 require(challengesLength(decodedTx.uid) == 0); exits[decodedTx.uid].state = 3; delete(wallet[bytes32(decodedTx.uid)]); FinishExit(decodedTx.uid); return bytes32(decodedTx.uid); } 4. Plasma Cash 中的退出示例 5. 其他问题 为什么 Plasma Cash 中的资产是不可分割的? 进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出. operator 的作用是什么 operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中. operator 是否必须可信任的? 是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中. 当然这部分是可以改进,降低 operator 作恶带来的风险. operator 是否可以是一个合约呢? 是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险 添加微信（cdong1024），加入区块链开发者技术交流群 虫洞社区：https://www.uzanapp.com/ 阅读更多","@type":"BlogPosting","url":"/2018/09/22/15649a3e943bf3f67c5c870f426a89f7.html","headline":"Plasma Cash 合约解读","dateModified":"2018-09-22T00:00:00+08:00","datePublished":"2018-09-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/09/22/15649a3e943bf3f67c5c870f426a89f7.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Plasma Cash 合约解读</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3><a id="_0"></a>作者介绍</h3> 
  <p>虫洞社区·签约作者 steven bai</p> 
  <h1><a id="Plasma_Cash__3"></a>Plasma Cash 合约解读</h1> 
  <ul> 
   <li><a href="#smartplasma-%E5%90%88%E7%BA%A6%E8%A7%A3%E8%AF%BB" rel="nofollow">Plasma Cash 合约解读</a> 
    <ul> 
     <li><a href="#1-%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81" rel="nofollow">1. 合约代码</a></li> 
     <li><a href="#2-%E5%90%88%E7%BA%A6%E6%96%87%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" rel="nofollow">2. 合约文件简单介绍</a></li> 
     <li><a href="#3-plasma-cash-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">3. Plasma Cash 的基础数据结构</a> 
      <ul> 
       <li><a href="#31-plasma-cash-%E4%B8%AD%E7%9A%84%E8%B5%84%E4%BA%A7" rel="nofollow">3.1 Plasma Cash 中的资产</a></li> 
       <li><a href="#32-plasma-cash%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%98%93" rel="nofollow">3.2 Plasma Cash中的交易</a></li> 
       <li><a href="#33-plasma-cash-%E4%B8%AD%E7%9A%84-block" rel="nofollow">3.3 Plasma Cash 中的 Block</a></li> 
       <li><a href="#34-plasma-cash-%E4%B8%AD%E8%B5%84%E4%BA%A7%E7%9A%84%E5%9B%9E%E5%BD%92%E4%B8%BB%E9%93%BE%E4%BB%A5%E5%A4%AA%E5%9D%8A" rel="nofollow">3.4 Plasma Cash 中资产的回归主链以太坊</a> 
        <ul> 
         <li><a href="#341-%08%E8%B5%84%E4%BA%A7%E6%8B%A5%E6%9C%89%E8%AF%81%E6%98%8E" rel="nofollow">3.4.1 资产拥有证明</a></li> 
         <li><a href="#342-%E7%AD%89%E5%BE%85%E5%85%B6%E4%BB%96%E4%BA%BA%E6%9D%A5%E6%8C%91%E6%88%98%E6%88%91" rel="nofollow">3.4.2 等待其他人来挑战我</a></li> 
         <li><a href="#343-%E6%8C%91%E6%88%98%E6%9C%9F%E8%BF%87%E4%BA%86-bob-%E6%8B%BF%E5%9B%9E%E8%B5%84%E4%BA%A7-uid" rel="nofollow">3.4.3 挑战期过了, Bob 拿回资产 uid</a></li> 
        </ul> </li> 
      </ul> </li> 
     <li><a href="#4-plasma-cash-%E4%B8%AD%E7%9A%84%E9%80%80%E5%87%BA%E7%A4%BA%E4%BE%8B" rel="nofollow">4. Plasma Cash 中的退出示例</a></li> 
     <li><a href="#5-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" rel="nofollow">5. 其他问题</a></li> 
    </ul> </li> 
  </ul> 
  <p>此文来自 SmartMesh 团队，转载请联系作者。</p> 
  <p>Plasma 由 V 神在2017年8月提出,希望通过链下交易来大幅提高以太坊的 TPS.</p> 
  <p>每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。</p> 
  <p>Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问.</p> 
  <h2><a id="1__27"></a>1. 合约代码</h2> 
  <p>SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上<a href="https://github.com/nkbai/blog/tree/master/smartplasma/contracts" rel="nofollow"> plasma cash</a>.</p> 
  <h2><a id="2__30"></a>2. 合约文件简单介绍</h2> 
  <p>文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看.</p> 
  <ul> 
   <li>Mediator.sol 是 Plasma Cash 链中资产的进出口</li> 
   <li>RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等</li> 
   <li>libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof.</li> 
   <li>libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的.</li> 
   <li>libraries/PlasmaLib.sol 生成 uid 的辅助函数</li> 
   <li>ECRecovery.sol 签名验证</li> 
   <li>datastructures/Transaction.sol 描述交易的数据结构</li> 
  </ul> 
  <h2><a id="3_Plasma_Cash__40"></a>3. Plasma Cash 的基础数据结构</h2> 
  <p>Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链.</p> 
  <h3><a id="31_Plasma_Cash__43"></a>3.1 Plasma Cash 中的资产</h3> 
  <p>Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割.<br> 可以参考 <a href="https://github.com/nkbai/blog/blob/master/smartplasma/contracts/Mediator.sol" rel="nofollow">Mediator.sol</a>的deposit函数. Mediator就是 Plasma Cash 资产存放的地方.</p> 
  <pre class=" language-solidity"><code class="prism  language-solidity">        /** @dev Adds deposits on Smart Plasma.
     *  @param currency Currency address.
     *  @param amount Amount amount of currency.
     */
    function deposit(address currency, uint amount) public {
        require(amount &gt; 0);

        Token token = Token(currency);
        token.transferFrom(msg.sender, this, amount); /// deposit test1

        bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2
        cash[uid] = entry({
            currency: currency,
            amount: amount
        });
    }
</code></pre> 
  <p>通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个.</p> 
  <h3><a id="32_Plasma_Cash_66"></a>3.2 Plasma Cash中的交易</h3> 
  <p>关键代码在<a href="https://github.com/nkbai/blog/blob/master/smartplasma/contracts/libraries/datastructures/Transaction.sol" rel="nofollow"> Transaction.sol</a>中.</p> 
  <pre class=" language-solidity"><code class="prism  language-solidity">    struct Tx {
        uint prevBlock;
        uint uid;
        uint amount;
        address newOwner;
        uint nonce;
        address signer;
        bytes32 hash;
    }
</code></pre> 
  <p>这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释.</p> 
  <p><code>prevBlock</code>就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到.<br> <code>uid</code> 就是交易的资产 ID<br> <code>newOwner</code> 交易输出给谁, 这里也不支持像 比特币一样的脚本.<br> <code>nonce</code> 是这笔资产的第多少次交易,在双花证明中有重要作用.<br> <code>signer</code>必须由资产原拥有者的签名.</p> 
  <p><code>amount</code> 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 <code>hash</code> 则是可以直接计算出来.</p> 
  <h3><a id="33_Plasma_Cash__Block_89"></a>3.3 Plasma Cash 中的 Block</h3> 
  <p>如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成.<br> 具体代码可见<a href="https://github.com/nkbai/blog/blob/master/smartplasma/contracts/RootChain.sol" rel="nofollow"> RootChain.sol</a>的.</p> 
  <pre class=" language-solidity"><code class="prism  language-solidity">    function newBlock(bytes32 hash) public onlyOperator {
        blockNumber = blockNumber.add(uint256(1));
        childChain[blockNumber] = hash;

        NewBlock(hash);
    }
</code></pre> 
  <p>交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则.</p> 
  <h3><a id="34_Plasma_Cash__102"></a>3.4 Plasma Cash 中资产的回归主链以太坊</h3> 
  <p>当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么就需要向以太坊合约也就是 RootChain证明,他确实拥有这一笔资产.</p> 
  <h4><a id="341__104"></a>3.4.1 资产拥有证明</h4> 
  <p>这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.具体见<a href="" rel="nofollow">RootChain.sol</a>中的<code>startExit</code>函数. 其思路非常简单,证明</p> 
  <ul> 
   <li>这笔资产来自哪里(在哪 M块中转移到了 Alice 手中)</li> 
   <li>经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我)<br> 具体看代码 startExit</li> 
  </ul> 
  <pre class=" language-solidity"><code class="prism  language-solidity">/** @dev Starts the procedure for withdrawal of the deposit from the system.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function startExit(
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();
        // 证明在 prevBlock的时候 Alice 拥有资产 uid
        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        //amount 不变,证明资产不可分割
        require(prevDecodedTx.amount == decodedTx.amount);
        //Alice 确实签名转移给了我,并且交易是相邻的两笔交易
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易
        //我是 Bob, 我要来拿走这笔资产
        require(msg.sender == decodedTx.newOwner);
        require(wallet[bytes32(decodedTx.uid)] != 0);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );
        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        /// Record the exit tx.
        require(exits[decodedTx.uid].state == 0);
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid] = exit({
            state: 2,
            exitTime: now.add(challengePeriod),
            exitTxBlkNum: lastTxBlockNum,
            exitTx: lastTx,
            txBeforeExitTxBlkNum: previousTxBlockNum,
            txBeforeExitTx: previousTx
        });

        StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum);
    }
</code></pre> 
  <p>代码的前一半都是在用来证明在<code>lastTxBlockNum</code>的时候,资产 uid 归Bob所有.<br> 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战.</p> 
  <h4><a id="342__181"></a>3.4.2 等待其他人来挑战我</h4> 
  <p>有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人.<br> 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者?<br> 这些问题,看起来很难回答,其实思路也很简单.<br> 这个思路和雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证.<br> 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花.<br> 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益.</p> 
  <pre><code>//challengeExit 挑战资产uid 其实不属于 Bob
  /** @dev Challenges a exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param proof Proof of inclusion of the transaction in a Smart Plasma block.
     *  @param challengeBlockNum The number of the block in which the transaction is included.
     */
    function challengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes proof,
        uint256 challengeBlockNum
    )
        public
    {
        require(exits[uid].state == 2);

        Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx();
        Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx();
        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();

        require(exitDecodedTx.uid == challengeDecodedTx.uid);
        require(exitDecodedTx.amount == challengeDecodedTx.amount);

        bytes32 txHash = challengeDecodedTx.hash;
        bytes32 blockRoot = childChain[challengeBlockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        // test challenge #1 &amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花
        if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp;
        exitDecodedTx.nonce &lt; challengeDecodedTx.nonce) {
            delete exits[uid];
            return;
        }

        // test challenge #3, 双花了,  Alice 给了两个人,并且挑战者 Carol的BlockNumer 更小,也就是发生的更早.
        if (challengeBlockNum &lt; exits[uid].exitTxBlkNum &amp;&amp;
            (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;&amp;
            challengeDecodedTx.nonce &gt; beforeExitDecodedTx.nonce)) {
            delete exits[uid];
            return;
        }

        // test challenge #4   在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid
        if (challengeBlockNum &lt; exits[uid].txBeforeExitTxBlkNum ) {
            exits[uid].state = 1;
            addChallenge(uid, challengeTx, challengeBlockNum);
        }

        require(exits[uid].state == 1);

        ChallengeExit(uid);
    }

//Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid
 /** @dev Answers a challenge exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param respondTx Transaction that answers to a dispute transaction.
     *  @param proof Proof of inclusion of the respond transaction in a Smart Plasma block.
     *  @param blockNum The number of the block in which the respond transaction is included.
     */
    function respondChallengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes respondTx,
        bytes proof,
        uint blockNum
    )
        public
    {
        require(challengeExists(uid, challengeTx));
        require(exits[uid].state == 1);

        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();
        Transaction.Tx memory respondDecodedTx = respondTx.createTx();

        require(challengeDecodedTx.uid == respondDecodedTx.uid);
        require(challengeDecodedTx.amount == respondDecodedTx.amount);
        require(challengeDecodedTx.newOwner == respondDecodedTx.signer);
        require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce);
        require(blockNum &lt; exits[uid].txBeforeExitTxBlkNum);

        bytes32 txHash = respondDecodedTx.hash;
        bytes32 blockRoot = childChain[blockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        removeChallenge(uid, challengeTx);

        if (challengesLength(uid) == 0) {
            exits[uid].state = 2;
        }

        RespondChallengeExit(uid);
    }
</code></pre> 
  <h4><a id="343__Bob__uid_287"></a>3.4.3 挑战期过了, Bob 拿回资产 uid</h4> 
  <p>挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中</p> 
  <pre class=" language-solidity"><code class="prism  language-solidity"> /** @dev withdraws deposit from Smart Plasma.
     *  @param prevTx Penultimate deposit transaction.
     *  @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param prevTxBlkNum The number of the block in which the penultimate transaction is included.
     *  @param txRaw lastTx Last deposit transaction.
     *  @param txProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param txBlkNum The number of the block in which the last transaction is included.
     */
    function withdraw(
        bytes prevTx,
        bytes prevTxProof,
        uint prevTxBlkNum,
        bytes txRaw,
        bytes txProof,
        uint txBlkNum
    )
        public
    {
        bytes32 uid = rootChain.finishExit(
            msg.sender,
            prevTx,
            prevTxProof,
            prevTxBlkNum,
            txRaw,
            txProof,
            txBlkNum
        );

        entry invoice = cash[uid];

        Token token = Token(invoice.currency);
        token.transfer(msg.sender, invoice.amount); /// 真正的资产转移

        delete(cash[uid]); 
    }
</code></pre> 
  <p>RootChain 再次验证</p> 
  <pre class=" language-solidity"><code class="prism  language-solidity"> /** @dev Finishes the procedure for withdrawal of the deposit from the system.
     *       Can only call the owner. Usually the owner is the mediator contract.
     *  @param account Account that initialized the deposit withdrawal.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function finishExit(
        address account,
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
        onlyOwner
        returns (bytes32)
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();

        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        require(prevDecodedTx.amount == decodedTx.amount);
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(account == decodedTx.newOwner);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );

        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        require(exits[decodedTx.uid].exitTime &lt; now); //挑战期过了
        require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid].state = 3;

        delete(wallet[bytes32(decodedTx.uid)]);

        FinishExit(decodedTx.uid);

        return bytes32(decodedTx.uid);
    }
</code></pre> 
  <h2><a id="4_Plasma_Cash__395"></a>4. Plasma Cash 中的退出示例</h2> 
  <p><img src="https://cdn.ktvsky.com/62dedfbd863eb85950ad414922c2f5fc.png" alt=""></p> 
  <h2><a id="5__398"></a>5. 其他问题</h2> 
  <ul> 
   <li> 
    <ol> 
     <li>为什么 Plasma Cash 中的资产是不可分割的?<br> 进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出.</li> 
    </ol> </li> 
   <li> 
    <ol start="2"> 
     <li>operator 的作用是什么<br> operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中.</li> 
    </ol> </li> 
   <li> 
    <ol start="3"> 
     <li>operator 是否必须可信任的?<br> 是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中.<br> 当然这部分是可以改进,降低 operator 作恶带来的风险.</li> 
    </ol> </li> 
   <li> 
    <ol start="4"> 
     <li>operator 是否可以是一个合约呢?<br> 是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险</li> 
    </ol> </li> 
  </ul> 
  <h4><a id="cdong1024_409"></a>添加微信（cdong1024），加入区块链开发者技术交流群</h4> 
  <h4><a id="httpswwwuzanappcom_410"></a>虫洞社区：<a href="https://www.uzanapp.com/" rel="nofollow">https://www.uzanapp.com/</a></h4> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180922102727310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0OTMzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="虫洞社区"></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_43249339/article/details/82810428,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_43249339/article/details/82810428,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/weixin_43249339/article/details/82810428,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/weixin_43249339/article/details/82810428,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
