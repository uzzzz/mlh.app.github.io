<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币-一个交易的产生（三）-承诺交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币-一个交易的产生（三）-承诺交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82351978 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 /Call after CreateTransaction unless you want to abort/ 承诺交易 1.CommitTransaction 1.1AddToWallet 2.AcceptToMemoryPool 3.AcceptToMemoryPoolWorker 3.1条件判断 3.1.1CheckTransaction 2)条件判断 在创建交易后需要承诺或者说约束这个交易除非你想抛弃这个交易。所以这个函数里面就是对交易个各种检查 1.CommitTransaction 位于src/wallet/wallet.cpp,属于类wallet bool CWallet::CommitTransaction(CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey) { { LOCK2(cs_main, cs_wallet); LogPrintf(&quot;CommitTransaction:\n%s&quot;, wtxNew.ToString()); { // This is only to keep the database open to defeat the auto-flush for the // duration of this scope. This is the only place where this optimization // maybe makes sense; please don&#39;t do it anywhere else. CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,&quot;r+&quot;) : NULL; // Take key pair from key pool so it won&#39;t be used again reservekey.KeepKey(); // Add tx to wallet, because if it has change it&#39;s also ours, // otherwise just for transaction history. AddToWallet(wtxNew, false, pwalletdb); // Notify that old coins are spent通知币已经被花费 set&lt;CWalletTx*&gt; setCoins; BOOST_FOREACH(const CTxIn&amp; txin, wtxNew.vin) { CWalletTx &amp;coin = mapWallet[txin.prevout.hash]; coin.BindWallet(this); NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED); } if (fFileBacked) delete pwalletdb; } // Track how many getdata requests our transaction gets mapRequestCount[wtxNew.GetHash()] = 0; if (fBroadcastTransactions) { CValidationState state;//捕获交易的验证信息 // Broadcast if (!wtxNew.AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;CommitTransaction(): Transaction cannot be broadcast immediately, %s\n&quot;, state.GetRejectReason()); // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure. } else { wtxNew.RelayWalletTransaction(); } } } return true; } 步骤的注释很清晰，用过的密钥对就从密钥池中移除（主要是指用于找零的密钥对），这样保证不会重复使用，导致信息泄漏。将交易加入到钱包中，因为即使交易改变了也是我们的或者用作历史记录。通知钱包中在这笔交易中花费的币。最后是广播，判断这个交易是否被加入到交易池（mempool）中。 maxTxFee是一笔交易的最大交易费，设置为0.1比特币，位于mian.h 1.1AddToWallet 2.AcceptToMemoryPool bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, CAmount nAbsurdFee, CValidationState&amp; state) { return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, false, nAbsurdFee); } 调用全局函数AcceptToMemoryPool，下面是类图 :::直接用在全局函数前，表示是全局函数 mempool不是CMerkleTx或其父类的成员，是一个全局对象。 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);//1000聪 CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;//0.1*coin CTxMemPool mempool(::minRelayTxFee); static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 设置费率最低是1000聪，这是进入内存池的最低要求，是以这个值初始化内存池。 CTxMemPool的数据结构之前写过了 bool AcceptToMemoryPool(CTxMemPool&amp; pool, CValidationState &amp;state, const CTransaction &amp;tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount nAbsurdFee) { std::vector&lt;uint256&gt; vHashTxToUncache; bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache); if (!res) { BOOST_FOREACH(const uint256&amp; hashTx, vHashTxToUncache) pcoinsTip-&gt;Uncache(hashTx); } return res; } 3.AcceptToMemoryPoolWorker 这里又调用了AcceptToMemoryPoolWorker这个函数，在main.cpp中，这个函数很长，一段段来看 bool AcceptToMemoryPoolWorker(CTxMemPool&amp; pool, CValidationState&amp; state, const CTransaction&amp; tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount&amp; nAbsurdFee, std::vector&lt;uint256&gt;&amp; vHashTxnToUncache) { const uint256 hash = tx.GetHash(); AssertLockHeld(cs_main); if (pfMissingInputs) *pfMissingInputs = false; if (!CheckTransaction(tx, state)) return false; // state filled in by CheckTransaction 3.1条件判断 函数的前面部分是各种检查 3.1.1CheckTransaction bool CheckTransaction(const CTransaction&amp; tx, CValidationState &amp;state) { // Basic checks that don&#39;t depend on any context 基本检验，与上下文无关的 if (tx.vin.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vin-empty&quot;); if (tx.vout.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vout-empty&quot;); // Size limits (this doesn&#39;t take the witness into account, as that hasn&#39;t been checked for malleability)不计算隔离见证的数据 if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) &gt; MAX_BLOCK_BASE_SIZE) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-oversize&quot;); // Check for negative or overflow output values检查负输出值或者值溢出 CAmount nValueOut = 0; BOOST_FOREACH(const CTxOut&amp; txout, tx.vout) { if (txout.nValue &lt; 0) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-negative&quot;); if (txout.nValue &gt; MAX_MONEY) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-toolarge&quot;); nValueOut += txout.nValue; if (!MoneyRange(nValueOut)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-txouttotal-toolarge&quot;); } // Check for duplicate inputs set&lt;COutPoint&gt; vInOutPoints; BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) { if (vInOutPoints.count(txin.prevout)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-inputs-duplicate&quot;); vInOutPoints.insert(txin.prevout); } if (tx.IsCoinBase())//coinbase交易的检查 { if (tx.vin[0].scriptSig.size() &lt; 2 || tx.vin[0].scriptSig.size() &gt; 100) return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-length&quot;); } else { BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) if (txin.prevout.IsNull()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-prevout-null&quot;); } return true; } 1.交易的语法和数据结构必须正确。 2.输入与输出列表都不能为空。 3.一笔交易的字节大小是小于MAX_BLOCK_BASE_SIZE的 /** The maximum allowed size for a block excluding witness data, in bytes (network rule) */ static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;//1M大小 4.每一个输出值，以及总量，必须在规定值的范围内 (小于 2,100 万个币，大于 0)。 5.对于每一个输入，引用的输出是必须存在的，并且没有被花费。 然后回到代码，后面也是一些检查 // Coinbase is only valid in a block, not as a loose transaction if (tx.IsCoinBase())//Coinbase是特殊的交易，不是普通交易处理，不会放到池中，在块中有效 return state.DoS(100, false, REJECT_INVALID, &quot;coinbase&quot;); // Don&#39;t relay version 2 transactions until CSV is active, and we can be // sure that such transactions will be mined (unless we&#39;re on // -testnet/-regtest). /*在 const CChainParams&amp; chainparams = Params(); if (fRequireStandard &amp;&amp; tx.nVersion &gt;= 2 &amp;&amp; VersionBitsTipState(chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV) != THRESHOLD_ACTIVE) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;premature-version2-tx&quot;); } // Reject transactions with witness before segregated witness activates (override with -prematurewitness) /*在隔离见证激活前拒绝使用见证的交易*/ bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()); if (!GetBoolArg(&quot;-prematurewitness&quot;,false) &amp;&amp; !tx.wit.IsNull() &amp;&amp; !witnessEnabled) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;no-witness-yet&quot;, true); } // Rather not work on nonstandard transactions (unless -testnet/-regtest) //不支持费标准交易，除非是测试网 string reason; if (fRequireStandard &amp;&amp; !IsStandardTx(tx, reason, witnessEnabled)) return state.DoS(0, false, REJECT_NONSTANDARD, reason); // Only accept nLockTime-using transactions that can be mined in the next // block; we don&#39;t want our mempool filled up with transactions that can&#39;t // be mined yet. /*对于使用nLockTime限定的交易只接收能进入下一个区块的交易，不希望池中充满不能被包含在下一个区块的交易*/ if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS)) return state.DoS(0, false, REJECT_NONSTANDARD, &quot;non-final&quot;); // is it already in the memory pool?是否已在池中 if (pool.exists(hash)) return state.Invalid(false, REJECT_ALREADY_KNOWN, &quot;txn-already-in-mempool&quot;); 2)条件判断 省略判断部分的代码 // Check for conflicts with in-memory transactions检查是否与已在池中的交易冲突 // do we already have it? // do all inputs exist? // are the actual inputs available? // Check for non-standard pay-to-script-hash in inputs // Check for non-standard witness in P2WSH // Keep track of transactions that spend a coinbase CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsCost, lp); // Check that the transaction doesn&#39;t have an excessive number of sigops, making it impossible to mine // Continuously rate-limit free (really, very-low-fee) transactions // A transaction that spends outputs that would be replaced by it is invalid. //Don&#39;t allow the replacement to reduce the feerate of the mempool. // Store transaction in memory pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload()); 另外还有关于交易替换的逻辑代码，正在看 BOOST_FOREACH(const uint256 &amp;hashConflicting, setConflicts) { 针对有冲突的交易，用高交易费的交易替换低交易费的交易。 如果提交到内存池失败的化，提示不能马上被广播，接着调用函数RelayWalletTransaction ##RelayWalletTransaction 中继钱包交易，如果这个交易已经在池中或者再次提交成功的话，那么中继这个交易成功，否则失败。 bool CWalletTx::RelayWalletTransaction() { assert(pwallet-&gt;GetBroadcastTransactions()); if (!IsCoinBase() &amp;&amp; !isAbandoned() &amp;&amp; GetDepthInMainChain() == 0) { CValidationState state; /* GetDepthInMainChain already catches known conflicts. */ if (InMempool() || AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;Relaying wtx %s\n&quot;, GetHash().ToString()); RelayTransaction((CTransaction)*this); return true; } } return false; } 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82351978 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 /Call after CreateTransaction unless you want to abort/ 承诺交易 1.CommitTransaction 1.1AddToWallet 2.AcceptToMemoryPool 3.AcceptToMemoryPoolWorker 3.1条件判断 3.1.1CheckTransaction 2)条件判断 在创建交易后需要承诺或者说约束这个交易除非你想抛弃这个交易。所以这个函数里面就是对交易个各种检查 1.CommitTransaction 位于src/wallet/wallet.cpp,属于类wallet bool CWallet::CommitTransaction(CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey) { { LOCK2(cs_main, cs_wallet); LogPrintf(&quot;CommitTransaction:\n%s&quot;, wtxNew.ToString()); { // This is only to keep the database open to defeat the auto-flush for the // duration of this scope. This is the only place where this optimization // maybe makes sense; please don&#39;t do it anywhere else. CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,&quot;r+&quot;) : NULL; // Take key pair from key pool so it won&#39;t be used again reservekey.KeepKey(); // Add tx to wallet, because if it has change it&#39;s also ours, // otherwise just for transaction history. AddToWallet(wtxNew, false, pwalletdb); // Notify that old coins are spent通知币已经被花费 set&lt;CWalletTx*&gt; setCoins; BOOST_FOREACH(const CTxIn&amp; txin, wtxNew.vin) { CWalletTx &amp;coin = mapWallet[txin.prevout.hash]; coin.BindWallet(this); NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED); } if (fFileBacked) delete pwalletdb; } // Track how many getdata requests our transaction gets mapRequestCount[wtxNew.GetHash()] = 0; if (fBroadcastTransactions) { CValidationState state;//捕获交易的验证信息 // Broadcast if (!wtxNew.AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;CommitTransaction(): Transaction cannot be broadcast immediately, %s\n&quot;, state.GetRejectReason()); // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure. } else { wtxNew.RelayWalletTransaction(); } } } return true; } 步骤的注释很清晰，用过的密钥对就从密钥池中移除（主要是指用于找零的密钥对），这样保证不会重复使用，导致信息泄漏。将交易加入到钱包中，因为即使交易改变了也是我们的或者用作历史记录。通知钱包中在这笔交易中花费的币。最后是广播，判断这个交易是否被加入到交易池（mempool）中。 maxTxFee是一笔交易的最大交易费，设置为0.1比特币，位于mian.h 1.1AddToWallet 2.AcceptToMemoryPool bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, CAmount nAbsurdFee, CValidationState&amp; state) { return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, false, nAbsurdFee); } 调用全局函数AcceptToMemoryPool，下面是类图 :::直接用在全局函数前，表示是全局函数 mempool不是CMerkleTx或其父类的成员，是一个全局对象。 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);//1000聪 CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;//0.1*coin CTxMemPool mempool(::minRelayTxFee); static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 设置费率最低是1000聪，这是进入内存池的最低要求，是以这个值初始化内存池。 CTxMemPool的数据结构之前写过了 bool AcceptToMemoryPool(CTxMemPool&amp; pool, CValidationState &amp;state, const CTransaction &amp;tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount nAbsurdFee) { std::vector&lt;uint256&gt; vHashTxToUncache; bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache); if (!res) { BOOST_FOREACH(const uint256&amp; hashTx, vHashTxToUncache) pcoinsTip-&gt;Uncache(hashTx); } return res; } 3.AcceptToMemoryPoolWorker 这里又调用了AcceptToMemoryPoolWorker这个函数，在main.cpp中，这个函数很长，一段段来看 bool AcceptToMemoryPoolWorker(CTxMemPool&amp; pool, CValidationState&amp; state, const CTransaction&amp; tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount&amp; nAbsurdFee, std::vector&lt;uint256&gt;&amp; vHashTxnToUncache) { const uint256 hash = tx.GetHash(); AssertLockHeld(cs_main); if (pfMissingInputs) *pfMissingInputs = false; if (!CheckTransaction(tx, state)) return false; // state filled in by CheckTransaction 3.1条件判断 函数的前面部分是各种检查 3.1.1CheckTransaction bool CheckTransaction(const CTransaction&amp; tx, CValidationState &amp;state) { // Basic checks that don&#39;t depend on any context 基本检验，与上下文无关的 if (tx.vin.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vin-empty&quot;); if (tx.vout.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vout-empty&quot;); // Size limits (this doesn&#39;t take the witness into account, as that hasn&#39;t been checked for malleability)不计算隔离见证的数据 if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) &gt; MAX_BLOCK_BASE_SIZE) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-oversize&quot;); // Check for negative or overflow output values检查负输出值或者值溢出 CAmount nValueOut = 0; BOOST_FOREACH(const CTxOut&amp; txout, tx.vout) { if (txout.nValue &lt; 0) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-negative&quot;); if (txout.nValue &gt; MAX_MONEY) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-toolarge&quot;); nValueOut += txout.nValue; if (!MoneyRange(nValueOut)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-txouttotal-toolarge&quot;); } // Check for duplicate inputs set&lt;COutPoint&gt; vInOutPoints; BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) { if (vInOutPoints.count(txin.prevout)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-inputs-duplicate&quot;); vInOutPoints.insert(txin.prevout); } if (tx.IsCoinBase())//coinbase交易的检查 { if (tx.vin[0].scriptSig.size() &lt; 2 || tx.vin[0].scriptSig.size() &gt; 100) return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-length&quot;); } else { BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) if (txin.prevout.IsNull()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-prevout-null&quot;); } return true; } 1.交易的语法和数据结构必须正确。 2.输入与输出列表都不能为空。 3.一笔交易的字节大小是小于MAX_BLOCK_BASE_SIZE的 /** The maximum allowed size for a block excluding witness data, in bytes (network rule) */ static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;//1M大小 4.每一个输出值，以及总量，必须在规定值的范围内 (小于 2,100 万个币，大于 0)。 5.对于每一个输入，引用的输出是必须存在的，并且没有被花费。 然后回到代码，后面也是一些检查 // Coinbase is only valid in a block, not as a loose transaction if (tx.IsCoinBase())//Coinbase是特殊的交易，不是普通交易处理，不会放到池中，在块中有效 return state.DoS(100, false, REJECT_INVALID, &quot;coinbase&quot;); // Don&#39;t relay version 2 transactions until CSV is active, and we can be // sure that such transactions will be mined (unless we&#39;re on // -testnet/-regtest). /*在 const CChainParams&amp; chainparams = Params(); if (fRequireStandard &amp;&amp; tx.nVersion &gt;= 2 &amp;&amp; VersionBitsTipState(chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV) != THRESHOLD_ACTIVE) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;premature-version2-tx&quot;); } // Reject transactions with witness before segregated witness activates (override with -prematurewitness) /*在隔离见证激活前拒绝使用见证的交易*/ bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()); if (!GetBoolArg(&quot;-prematurewitness&quot;,false) &amp;&amp; !tx.wit.IsNull() &amp;&amp; !witnessEnabled) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;no-witness-yet&quot;, true); } // Rather not work on nonstandard transactions (unless -testnet/-regtest) //不支持费标准交易，除非是测试网 string reason; if (fRequireStandard &amp;&amp; !IsStandardTx(tx, reason, witnessEnabled)) return state.DoS(0, false, REJECT_NONSTANDARD, reason); // Only accept nLockTime-using transactions that can be mined in the next // block; we don&#39;t want our mempool filled up with transactions that can&#39;t // be mined yet. /*对于使用nLockTime限定的交易只接收能进入下一个区块的交易，不希望池中充满不能被包含在下一个区块的交易*/ if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS)) return state.DoS(0, false, REJECT_NONSTANDARD, &quot;non-final&quot;); // is it already in the memory pool?是否已在池中 if (pool.exists(hash)) return state.Invalid(false, REJECT_ALREADY_KNOWN, &quot;txn-already-in-mempool&quot;); 2)条件判断 省略判断部分的代码 // Check for conflicts with in-memory transactions检查是否与已在池中的交易冲突 // do we already have it? // do all inputs exist? // are the actual inputs available? // Check for non-standard pay-to-script-hash in inputs // Check for non-standard witness in P2WSH // Keep track of transactions that spend a coinbase CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsCost, lp); // Check that the transaction doesn&#39;t have an excessive number of sigops, making it impossible to mine // Continuously rate-limit free (really, very-low-fee) transactions // A transaction that spends outputs that would be replaced by it is invalid. //Don&#39;t allow the replacement to reduce the feerate of the mempool. // Store transaction in memory pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload()); 另外还有关于交易替换的逻辑代码，正在看 BOOST_FOREACH(const uint256 &amp;hashConflicting, setConflicts) { 针对有冲突的交易，用高交易费的交易替换低交易费的交易。 如果提交到内存池失败的化，提示不能马上被广播，接着调用函数RelayWalletTransaction ##RelayWalletTransaction 中继钱包交易，如果这个交易已经在池中或者再次提交成功的话，那么中继这个交易成功，否则失败。 bool CWalletTx::RelayWalletTransaction() { assert(pwallet-&gt;GetBroadcastTransactions()); if (!IsCoinBase() &amp;&amp; !isAbandoned() &amp;&amp; GetDepthInMainChain() == 0) { CValidationState state; /* GetDepthInMainChain already catches known conflicts. */ if (InMempool() || AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;Relaying wtx %s\n&quot;, GetHash().ToString()); RelayTransaction((CTransaction)*this); return true; } } return false; } 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/09/06/8055593eb0485d20bbad9b5d644f571c.html" />
<meta property="og:url" content="https://mlh.app/2018/09/06/8055593eb0485d20bbad9b5d644f571c.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82351978 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–承诺交易 交易的产生（四）–脚本和签名 /Call after CreateTransaction unless you want to abort/ 承诺交易 1.CommitTransaction 1.1AddToWallet 2.AcceptToMemoryPool 3.AcceptToMemoryPoolWorker 3.1条件判断 3.1.1CheckTransaction 2)条件判断 在创建交易后需要承诺或者说约束这个交易除非你想抛弃这个交易。所以这个函数里面就是对交易个各种检查 1.CommitTransaction 位于src/wallet/wallet.cpp,属于类wallet bool CWallet::CommitTransaction(CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey) { { LOCK2(cs_main, cs_wallet); LogPrintf(&quot;CommitTransaction:\\n%s&quot;, wtxNew.ToString()); { // This is only to keep the database open to defeat the auto-flush for the // duration of this scope. This is the only place where this optimization // maybe makes sense; please don&#39;t do it anywhere else. CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,&quot;r+&quot;) : NULL; // Take key pair from key pool so it won&#39;t be used again reservekey.KeepKey(); // Add tx to wallet, because if it has change it&#39;s also ours, // otherwise just for transaction history. AddToWallet(wtxNew, false, pwalletdb); // Notify that old coins are spent通知币已经被花费 set&lt;CWalletTx*&gt; setCoins; BOOST_FOREACH(const CTxIn&amp; txin, wtxNew.vin) { CWalletTx &amp;coin = mapWallet[txin.prevout.hash]; coin.BindWallet(this); NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED); } if (fFileBacked) delete pwalletdb; } // Track how many getdata requests our transaction gets mapRequestCount[wtxNew.GetHash()] = 0; if (fBroadcastTransactions) { CValidationState state;//捕获交易的验证信息 // Broadcast if (!wtxNew.AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n&quot;, state.GetRejectReason()); // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure. } else { wtxNew.RelayWalletTransaction(); } } } return true; } 步骤的注释很清晰，用过的密钥对就从密钥池中移除（主要是指用于找零的密钥对），这样保证不会重复使用，导致信息泄漏。将交易加入到钱包中，因为即使交易改变了也是我们的或者用作历史记录。通知钱包中在这笔交易中花费的币。最后是广播，判断这个交易是否被加入到交易池（mempool）中。 maxTxFee是一笔交易的最大交易费，设置为0.1比特币，位于mian.h 1.1AddToWallet 2.AcceptToMemoryPool bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, CAmount nAbsurdFee, CValidationState&amp; state) { return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, false, nAbsurdFee); } 调用全局函数AcceptToMemoryPool，下面是类图 :::直接用在全局函数前，表示是全局函数 mempool不是CMerkleTx或其父类的成员，是一个全局对象。 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);//1000聪 CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;//0.1*coin CTxMemPool mempool(::minRelayTxFee); static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 设置费率最低是1000聪，这是进入内存池的最低要求，是以这个值初始化内存池。 CTxMemPool的数据结构之前写过了 bool AcceptToMemoryPool(CTxMemPool&amp; pool, CValidationState &amp;state, const CTransaction &amp;tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount nAbsurdFee) { std::vector&lt;uint256&gt; vHashTxToUncache; bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache); if (!res) { BOOST_FOREACH(const uint256&amp; hashTx, vHashTxToUncache) pcoinsTip-&gt;Uncache(hashTx); } return res; } 3.AcceptToMemoryPoolWorker 这里又调用了AcceptToMemoryPoolWorker这个函数，在main.cpp中，这个函数很长，一段段来看 bool AcceptToMemoryPoolWorker(CTxMemPool&amp; pool, CValidationState&amp; state, const CTransaction&amp; tx, bool fLimitFree, bool* pfMissingInputs, bool fOverrideMempoolLimit, const CAmount&amp; nAbsurdFee, std::vector&lt;uint256&gt;&amp; vHashTxnToUncache) { const uint256 hash = tx.GetHash(); AssertLockHeld(cs_main); if (pfMissingInputs) *pfMissingInputs = false; if (!CheckTransaction(tx, state)) return false; // state filled in by CheckTransaction 3.1条件判断 函数的前面部分是各种检查 3.1.1CheckTransaction bool CheckTransaction(const CTransaction&amp; tx, CValidationState &amp;state) { // Basic checks that don&#39;t depend on any context 基本检验，与上下文无关的 if (tx.vin.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vin-empty&quot;); if (tx.vout.empty()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-vout-empty&quot;); // Size limits (this doesn&#39;t take the witness into account, as that hasn&#39;t been checked for malleability)不计算隔离见证的数据 if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) &gt; MAX_BLOCK_BASE_SIZE) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-oversize&quot;); // Check for negative or overflow output values检查负输出值或者值溢出 CAmount nValueOut = 0; BOOST_FOREACH(const CTxOut&amp; txout, tx.vout) { if (txout.nValue &lt; 0) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-negative&quot;); if (txout.nValue &gt; MAX_MONEY) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-vout-toolarge&quot;); nValueOut += txout.nValue; if (!MoneyRange(nValueOut)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-txouttotal-toolarge&quot;); } // Check for duplicate inputs set&lt;COutPoint&gt; vInOutPoints; BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) { if (vInOutPoints.count(txin.prevout)) return state.DoS(100, false, REJECT_INVALID, &quot;bad-txns-inputs-duplicate&quot;); vInOutPoints.insert(txin.prevout); } if (tx.IsCoinBase())//coinbase交易的检查 { if (tx.vin[0].scriptSig.size() &lt; 2 || tx.vin[0].scriptSig.size() &gt; 100) return state.DoS(100, false, REJECT_INVALID, &quot;bad-cb-length&quot;); } else { BOOST_FOREACH(const CTxIn&amp; txin, tx.vin) if (txin.prevout.IsNull()) return state.DoS(10, false, REJECT_INVALID, &quot;bad-txns-prevout-null&quot;); } return true; } 1.交易的语法和数据结构必须正确。 2.输入与输出列表都不能为空。 3.一笔交易的字节大小是小于MAX_BLOCK_BASE_SIZE的 /** The maximum allowed size for a block excluding witness data, in bytes (network rule) */ static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;//1M大小 4.每一个输出值，以及总量，必须在规定值的范围内 (小于 2,100 万个币，大于 0)。 5.对于每一个输入，引用的输出是必须存在的，并且没有被花费。 然后回到代码，后面也是一些检查 // Coinbase is only valid in a block, not as a loose transaction if (tx.IsCoinBase())//Coinbase是特殊的交易，不是普通交易处理，不会放到池中，在块中有效 return state.DoS(100, false, REJECT_INVALID, &quot;coinbase&quot;); // Don&#39;t relay version 2 transactions until CSV is active, and we can be // sure that such transactions will be mined (unless we&#39;re on // -testnet/-regtest). /*在 const CChainParams&amp; chainparams = Params(); if (fRequireStandard &amp;&amp; tx.nVersion &gt;= 2 &amp;&amp; VersionBitsTipState(chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV) != THRESHOLD_ACTIVE) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;premature-version2-tx&quot;); } // Reject transactions with witness before segregated witness activates (override with -prematurewitness) /*在隔离见证激活前拒绝使用见证的交易*/ bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()); if (!GetBoolArg(&quot;-prematurewitness&quot;,false) &amp;&amp; !tx.wit.IsNull() &amp;&amp; !witnessEnabled) { return state.DoS(0, false, REJECT_NONSTANDARD, &quot;no-witness-yet&quot;, true); } // Rather not work on nonstandard transactions (unless -testnet/-regtest) //不支持费标准交易，除非是测试网 string reason; if (fRequireStandard &amp;&amp; !IsStandardTx(tx, reason, witnessEnabled)) return state.DoS(0, false, REJECT_NONSTANDARD, reason); // Only accept nLockTime-using transactions that can be mined in the next // block; we don&#39;t want our mempool filled up with transactions that can&#39;t // be mined yet. /*对于使用nLockTime限定的交易只接收能进入下一个区块的交易，不希望池中充满不能被包含在下一个区块的交易*/ if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS)) return state.DoS(0, false, REJECT_NONSTANDARD, &quot;non-final&quot;); // is it already in the memory pool?是否已在池中 if (pool.exists(hash)) return state.Invalid(false, REJECT_ALREADY_KNOWN, &quot;txn-already-in-mempool&quot;); 2)条件判断 省略判断部分的代码 // Check for conflicts with in-memory transactions检查是否与已在池中的交易冲突 // do we already have it? // do all inputs exist? // are the actual inputs available? // Check for non-standard pay-to-script-hash in inputs // Check for non-standard witness in P2WSH // Keep track of transactions that spend a coinbase CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsCost, lp); // Check that the transaction doesn&#39;t have an excessive number of sigops, making it impossible to mine // Continuously rate-limit free (really, very-low-fee) transactions // A transaction that spends outputs that would be replaced by it is invalid. //Don&#39;t allow the replacement to reduce the feerate of the mempool. // Store transaction in memory pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload()); 另外还有关于交易替换的逻辑代码，正在看 BOOST_FOREACH(const uint256 &amp;hashConflicting, setConflicts) { 针对有冲突的交易，用高交易费的交易替换低交易费的交易。 如果提交到内存池失败的化，提示不能马上被广播，接着调用函数RelayWalletTransaction ##RelayWalletTransaction 中继钱包交易，如果这个交易已经在池中或者再次提交成功的话，那么中继这个交易成功，否则失败。 bool CWalletTx::RelayWalletTransaction() { assert(pwallet-&gt;GetBroadcastTransactions()); if (!IsCoinBase() &amp;&amp; !isAbandoned() &amp;&amp; GetDepthInMainChain() == 0) { CValidationState state; /* GetDepthInMainChain already catches known conflicts. */ if (InMempool() || AcceptToMemoryPool(false, maxTxFee, state)) { LogPrintf(&quot;Relaying wtx %s\\n&quot;, GetHash().ToString()); RelayTransaction((CTransaction)*this); return true; } } return false; } 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/09/06/8055593eb0485d20bbad9b5d644f571c.html","headline":"比特币-一个交易的产生（三）-承诺交易","dateModified":"2018-09-06T00:00:00+08:00","datePublished":"2018-09-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/06/8055593eb0485d20bbad9b5d644f571c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币-一个交易的产生（三）-承诺交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82351978 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81906838" rel="nofollow">交易的产生（一）–生成地址</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">交易的产生（二）–创建交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82351978" rel="nofollow">交易的产生（三）–承诺交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82866757" rel="nofollow">交易的产生（四）–脚本和签名</a></p> 
  <hr> 
  <blockquote> 
   <p>/<em>Call after CreateTransaction unless you want to abort</em>/</p> 
  </blockquote> 
  <p></p>
  <div class="toc">
   <h3>承诺交易</h3>
   <ul>
    <li><a href="#1CommitTransaction_12" rel="nofollow">1.CommitTransaction</a></li>
    <li><a href="#11AddToWallet_66" rel="nofollow">1.1AddToWallet</a></li>
    <li><a href="#2AcceptToMemoryPool_73" rel="nofollow">2.AcceptToMemoryPool</a></li>
    <ul>
     <li><a href="#3AcceptToMemoryPoolWorker_110" rel="nofollow">3.AcceptToMemoryPoolWorker</a></li>
     <ul>
      <li><a href="#31_125" rel="nofollow">3.1条件判断</a></li>
      <ul>
       <li><a href="#311CheckTransaction_127" rel="nofollow">3.1.1CheckTransaction</a></li>
      </ul>
      <li><a href="#2_225" rel="nofollow">2)条件判断</a></li>
     </ul>
    </ul>
   </ul>
  </div>
  <p></p> 
  <hr> 
  <p>在创建交易后需要承诺或者说约束这个交易除非你想抛弃这个交易。所以这个函数里面就是对交易个各种检查</p> 
  <h1><a id="1CommitTransaction_12"></a>1.CommitTransaction</h1> 
  <p>位于src/wallet/wallet.cpp,属于类wallet</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">CommitTransaction</span><span class="token punctuation">(</span>CWalletTx<span class="token operator">&amp;</span> wtxNew<span class="token punctuation">,</span> CReserveKey<span class="token operator">&amp;</span> reservekey<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK2</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">,</span> cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LogPrintf</span><span class="token punctuation">(</span><span class="token string">"CommitTransaction:\n%s"</span><span class="token punctuation">,</span> wtxNew<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// This is only to keep the database open to defeat the auto-flush for the</span>
            <span class="token comment">// duration of this scope. This is the only place where this optimization</span>
            <span class="token comment">// maybe makes sense; please don't do it anywhere else.</span>
            CWalletDB<span class="token operator">*</span> pwalletdb <span class="token operator">=</span> fFileBacked <span class="token operator">?</span> new <span class="token function">CWalletDB</span><span class="token punctuation">(</span>strWalletFile<span class="token punctuation">,</span><span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

            <span class="token comment">// Take key pair from key pool so it won't be used again</span>
            reservekey<span class="token punctuation">.</span><span class="token function">KeepKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Add tx to wallet, because if it has change it's also ours,</span>
            <span class="token comment">// otherwise just for transaction history.</span>
            <span class="token function">AddToWallet</span><span class="token punctuation">(</span>wtxNew<span class="token punctuation">,</span> false<span class="token punctuation">,</span> pwalletdb<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Notify that old coins are spent通知币已经被花费</span>
            set<span class="token operator">&lt;</span>CWalletTx<span class="token operator">*</span><span class="token operator">&gt;</span> setCoins<span class="token punctuation">;</span>
            <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxIn<span class="token operator">&amp;</span> txin<span class="token punctuation">,</span> wtxNew<span class="token punctuation">.</span>vin<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                CWalletTx <span class="token operator">&amp;</span>coin <span class="token operator">=</span> mapWallet<span class="token punctuation">[</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">.</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span>
                coin<span class="token punctuation">.</span><span class="token function">BindWallet</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">NotifyTransactionChanged</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> coin<span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CT_UPDATED<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>fFileBacked<span class="token punctuation">)</span>
                delete pwalletdb<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Track how many getdata requests our transaction gets</span>
        mapRequestCount<span class="token punctuation">[</span>wtxNew<span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>fBroadcastTransactions<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            CValidationState state<span class="token punctuation">;</span><span class="token comment">//捕获交易的验证信息</span>
            <span class="token comment">// Broadcast</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wtxNew<span class="token punctuation">.</span><span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>false<span class="token punctuation">,</span> maxTxFee<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">LogPrintf</span><span class="token punctuation">(</span><span class="token string">"CommitTransaction(): Transaction cannot be broadcast immediately, %s\n"</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token function">GetRejectReason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                wtxNew<span class="token punctuation">.</span><span class="token function">RelayWalletTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>步骤的注释很清晰，用过的密钥对就从密钥池中移除（主要是指用于找零的密钥对），这样保证不会重复使用，导致信息泄漏。将交易加入到钱包中，因为即使交易改变了也是我们的或者用作历史记录。通知钱包中在这笔交易中花费的币。最后是广播，判断这个交易是否被加入到交易池（mempool）中。<br> <code>maxTxFee</code>是一笔交易的最大交易费，设置为0.1比特币，位于mian.h</p> 
  <h1><a id="11AddToWallet_66"></a>1.1AddToWallet</h1> 
  <pre class=" language-c"><code class="prism  language-c">
</code></pre> 
  <hr> 
  <h1><a id="2AcceptToMemoryPool_73"></a>2.AcceptToMemoryPool</h1> 
  <pre class=" language-c"><code class="prism  language-c">bool CMerkleTx<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>bool fLimitFree<span class="token punctuation">,</span> CAmount nAbsurdFee<span class="token punctuation">,</span> CValidationState<span class="token operator">&amp;</span> state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>mempool<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token operator">*</span>this<span class="token punctuation">,</span> fLimitFree<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> nAbsurdFee<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>调用全局函数AcceptToMemoryPool，下面是类图</p> 
  <blockquote> 
   <p><code>::</code>:直接用在全局函数前，表示是全局函数</p> 
  </blockquote> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180904105559129?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p> 
  <p>mempool不是CMerkleTx或其父类的成员，是一个全局对象。</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//main.cpp</span>
CFeeRate minRelayTxFee <span class="token operator">=</span> <span class="token function">CFeeRate</span><span class="token punctuation">(</span>DEFAULT_MIN_RELAY_TX_FEE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000聪</span>
CAmount maxTxFee <span class="token operator">=</span> DEFAULT_TRANSACTION_MAXFEE<span class="token punctuation">;</span><span class="token comment">//0.1*coin</span>
CTxMemPool <span class="token function">mempool</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token punctuation">:</span>minRelayTxFee<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <blockquote> 
   <p>static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000;</p> 
  </blockquote> 
  <p>设置费率最低是1000聪，这是进入内存池的最低要求，是以这个值初始化内存池。<br> <a href="https://blog.csdn.net/m0_37847176/article/details/81699796#ctxmempool" rel="nofollow">CTxMemPool</a>的数据结构之前写过了</p> 
  <pre class=" language-c"><code class="prism  language-c">bool <span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>CTxMemPool<span class="token operator">&amp;</span> pool<span class="token punctuation">,</span> CValidationState <span class="token operator">&amp;</span>state<span class="token punctuation">,</span> <span class="token keyword">const</span> CTransaction <span class="token operator">&amp;</span>tx<span class="token punctuation">,</span> bool fLimitFree<span class="token punctuation">,</span>
                        bool<span class="token operator">*</span> pfMissingInputs<span class="token punctuation">,</span> bool fOverrideMempoolLimit<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount nAbsurdFee<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span> vHashTxToUncache<span class="token punctuation">;</span>
    bool res <span class="token operator">=</span> <span class="token function">AcceptToMemoryPoolWorker</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> state<span class="token punctuation">,</span> tx<span class="token punctuation">,</span> fLimitFree<span class="token punctuation">,</span> pfMissingInputs<span class="token punctuation">,</span> fOverrideMempoolLimit<span class="token punctuation">,</span> nAbsurdFee<span class="token punctuation">,</span> vHashTxToUncache<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hashTx<span class="token punctuation">,</span> vHashTxToUncache<span class="token punctuation">)</span>
            pcoinsTip<span class="token operator">-&gt;</span><span class="token function">Uncache</span><span class="token punctuation">(</span>hashTx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h2><a id="3AcceptToMemoryPoolWorker_110"></a>3.AcceptToMemoryPoolWorker</h2> 
  <p>这里又调用了<code>AcceptToMemoryPoolWorker</code>这个函数，在main.cpp中，这个函数很长，一段段来看</p> 
  <pre class=" language-c"><code class="prism  language-c">bool <span class="token function">AcceptToMemoryPoolWorker</span><span class="token punctuation">(</span>CTxMemPool<span class="token operator">&amp;</span> pool<span class="token punctuation">,</span> CValidationState<span class="token operator">&amp;</span> state<span class="token punctuation">,</span> <span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> tx<span class="token punctuation">,</span> bool fLimitFree<span class="token punctuation">,</span>
                              bool<span class="token operator">*</span> pfMissingInputs<span class="token punctuation">,</span> bool fOverrideMempoolLimit<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount<span class="token operator">&amp;</span> nAbsurdFee<span class="token punctuation">,</span>
                              std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vHashTxnToUncache<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> uint256 hash <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">AssertLockHeld</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pfMissingInputs<span class="token punctuation">)</span>
        <span class="token operator">*</span>pfMissingInputs <span class="token operator">=</span> false<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CheckTransaction</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// state filled in by CheckTransaction</span>
</code></pre> 
  <h3><a id="31_125"></a>3.1条件判断</h3> 
  <p>函数的前面部分是各种检查</p> 
  <h4><a id="311CheckTransaction_127"></a>3.1.1CheckTransaction</h4> 
  <pre class=" language-c"><code class="prism  language-c">bool <span class="token function">CheckTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> tx<span class="token punctuation">,</span> CValidationState <span class="token operator">&amp;</span>state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Basic checks that don't depend on any context 基本检验，与上下文无关的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tx<span class="token punctuation">.</span>vin<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-vin-empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tx<span class="token punctuation">.</span>vout<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-vout-empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)不计算隔离见证的数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetSerializeSize</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> SER_NETWORK<span class="token punctuation">,</span> PROTOCOL_VERSION <span class="token operator">|</span> SERIALIZE_TRANSACTION_NO_WITNESS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_BLOCK_BASE_SIZE<span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-oversize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Check for negative or overflow output values检查负输出值或者值溢出</span>
    CAmount nValueOut <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxOut<span class="token operator">&amp;</span> txout<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>vout<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>txout<span class="token punctuation">.</span>nValue <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-vout-negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>txout<span class="token punctuation">.</span>nValue <span class="token operator">&gt;</span> MAX_MONEY<span class="token punctuation">)</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-vout-toolarge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nValueOut <span class="token operator">+</span><span class="token operator">=</span> txout<span class="token punctuation">.</span>nValue<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">MoneyRange</span><span class="token punctuation">(</span>nValueOut<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-txouttotal-toolarge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Check for duplicate inputs</span>
    set<span class="token operator">&lt;</span>COutPoint<span class="token operator">&gt;</span> vInOutPoints<span class="token punctuation">;</span>
    <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxIn<span class="token operator">&amp;</span> txin<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>vin<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vInOutPoints<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-inputs-duplicate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vInOutPoints<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>tx<span class="token punctuation">.</span><span class="token function">IsCoinBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//coinbase交易的检查</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tx<span class="token punctuation">.</span>vin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>scriptSig<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> tx<span class="token punctuation">.</span>vin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>scriptSig<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-cb-length"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxIn<span class="token operator">&amp;</span> txin<span class="token punctuation">,</span> tx<span class="token punctuation">.</span>vin<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">.</span><span class="token function">IsNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"bad-txns-prevout-null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>1.交易的语法和数据结构必须正确。<br> 2.输入与输出列表都不能为空。<br> 3.一笔交易的字节大小是小于MAX_BLOCK_BASE_SIZE的</p> 
  <blockquote> 
   <p>/** The maximum allowed size for a block excluding witness data, in bytes (network rule) */<br> static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;//1M大小</p> 
  </blockquote> 
  <p>4.每一个输出值，以及总量，必须在规定值的范围内 (小于 2,100 万个币，大于<br> 0)。<br> 5.对于每一个输入，引用的输出是必须存在的，并且没有被花费。</p> 
  <p>然后回到代码，后面也是一些检查</p> 
  <pre class=" language-c"><code class="prism  language-c">    <span class="token comment">// Coinbase is only valid in a block, not as a loose transaction</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tx<span class="token punctuation">.</span><span class="token function">IsCoinBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//Coinbase是特殊的交易，不是普通交易处理，不会放到池中，在块中有效</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_INVALID<span class="token punctuation">,</span> <span class="token string">"coinbase"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Don't relay version 2 transactions until CSV is active, and we can be</span>
    <span class="token comment">// sure that such transactions will be mined (unless we're on</span>
    <span class="token comment">// -testnet/-regtest).</span>
    <span class="token comment">/*在 const CChainParams&amp; chainparams = Params(); if (fRequireStandard &amp;&amp; tx.nVersion &gt;= 2 &amp;&amp; VersionBitsTipState(chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV) != THRESHOLD_ACTIVE) { return state.DoS(0, false, REJECT_NONSTANDARD, "premature-version2-tx"); } // Reject transactions with witness before segregated witness activates (override with -prematurewitness) /*在隔离见证激活前拒绝使用见证的交易*/</span>
    bool witnessEnabled <span class="token operator">=</span> <span class="token function">IsWitnessEnabled</span><span class="token punctuation">(</span>chainActive<span class="token punctuation">.</span><span class="token function">Tip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetConsensus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GetBoolArg</span><span class="token punctuation">(</span><span class="token string">"-prematurewitness"</span><span class="token punctuation">,</span>false<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tx<span class="token punctuation">.</span>wit<span class="token punctuation">.</span><span class="token function">IsNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>witnessEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_NONSTANDARD<span class="token punctuation">,</span> <span class="token string">"no-witness-yet"</span><span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token comment">// Rather not work on nonstandard transactions (unless -testnet/-regtest)</span>
     <span class="token comment">//不支持费标准交易，除非是测试网</span>
    string reason<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fRequireStandard <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">IsStandardTx</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> reason<span class="token punctuation">,</span> witnessEnabled<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_NONSTANDARD<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// Only accept nLockTime-using transactions that can be mined in the next</span>
    <span class="token comment">// block; we don't want our mempool filled up with transactions that can't</span>
    <span class="token comment">// be mined yet.</span>
    <span class="token comment">/*对于使用nLockTime限定的交易只接收能进入下一个区块的交易，不希望池中充满不能被包含在下一个区块的交易*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CheckFinalTx</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> STANDARD_LOCKTIME_VERIFY_FLAGS<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">DoS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> REJECT_NONSTANDARD<span class="token punctuation">,</span> <span class="token string">"non-final"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// is it already in the memory pool?是否已在池中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">Invalid</span><span class="token punctuation">(</span>false<span class="token punctuation">,</span> REJECT_ALREADY_KNOWN<span class="token punctuation">,</span> <span class="token string">"txn-already-in-mempool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
  <h3><a id="2_225"></a>2)条件判断</h3> 
  <p>省略判断部分的代码</p> 
  <pre class=" language-c"><code class="prism  language-c"> <span class="token comment">// Check for conflicts with in-memory transactions检查是否与已在池中的交易冲突</span>
 <span class="token comment">// do we already have it?</span>
 <span class="token comment">// do all inputs exist?</span>
 <span class="token comment">// are the actual inputs available?</span>
 <span class="token comment">// Check for non-standard pay-to-script-hash in inputs </span>
 <span class="token comment">// Check for non-standard witness in P2WSH</span>
 <span class="token comment">// Keep track of transactions that spend a coinbase</span>
 
  CTxMemPoolEntry <span class="token function">entry</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> nFees<span class="token punctuation">,</span> <span class="token function">GetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dPriority<span class="token punctuation">,</span> chainActive<span class="token punctuation">.</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pool<span class="token punctuation">.</span><span class="token function">HasNoInputsOf</span><span class="token punctuation">(</span>tx<span class="token punctuation">)</span><span class="token punctuation">,</span> inChainInputValue<span class="token punctuation">,</span> fSpendsCoinbase<span class="token punctuation">,</span> nSigOpsCost<span class="token punctuation">,</span> lp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
 <span class="token comment">// Check that the transaction doesn't have an excessive number of sigops, making it impossible to mine</span>
 <span class="token comment">// Continuously rate-limit free (really, very-low-fee) transactions</span>
 <span class="token comment">// A transaction that spends outputs that would be replaced by it is invalid.</span>
 <span class="token comment">//Don't allow the replacement to reduce the feerate of the mempool.</span>

<span class="token comment">// Store transaction in memory</span>
 pool<span class="token punctuation">.</span><span class="token function">addUnchecked</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> entry<span class="token punctuation">,</span> setAncestors<span class="token punctuation">,</span> <span class="token operator">!</span><span class="token function">IsInitialBlockDownload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>另外还有关于交易替换的逻辑代码，正在看</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256 <span class="token operator">&amp;</span>hashConflicting<span class="token punctuation">,</span> setConflicts<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
</code></pre> 
  <p>针对有冲突的交易，用高交易费的交易替换低交易费的交易。</p> 
  <hr> 
  <p>如果提交到内存池失败的化，提示不能马上被广播，接着调用函数RelayWalletTransaction<br> ##RelayWalletTransaction<br> 中继钱包交易，如果这个交易已经在池中或者再次提交成功的话，那么中继这个交易成功，否则失败。</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CWalletTx<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">RelayWalletTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pwallet<span class="token operator">-&gt;</span><span class="token function">GetBroadcastTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsCoinBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isAbandoned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        CValidationState state<span class="token punctuation">;</span>
        <span class="token comment">/* GetDepthInMainChain already catches known conflicts. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">InMempool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>false<span class="token punctuation">,</span> maxTxFee<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">LogPrintf</span><span class="token punctuation">(</span><span class="token string">"Relaying wtx %s\n"</span><span class="token punctuation">,</span> <span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">RelayTransaction</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CTransaction<span class="token punctuation">)</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-f77b6af6fd.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82351978,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82351978,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
