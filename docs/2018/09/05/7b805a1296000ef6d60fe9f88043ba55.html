<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Python与以太坊区块链交互并使用SQL将数据存入数据库 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Python与以太坊区块链交互并使用SQL将数据存入数据库" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="关于区块链介绍性的研讨会通常以易于理解的点对点网络和银行分类账这类故事开头，然后直接跳到编写智能合约，这显得非常突兀。因此，想象自己走进丛林，想象以太坊区块链是一个你即将研究的奇怪生物。今天我们将观察该生物，并与其进行交互然后将有关它的所有数据收集到一个集中存储中供自己使用。 进行第一次设置 首先，你需要安装web3py。Web3py是一个用于连接以太坊区块链的Python库。你需要事先知道的是，没有可以从中下载数据的中央管理系统。彼此共享资源的内连节点（“对等体”）存储经验证的数据副本（或其一部分）。网络执行以太坊协议，该协议定义节点彼此之间的交互规则及网络上的智能合约。 如果要访问有关交易，余额，区块或其他任何被写入区块链的信息，协议需要你连接到节点。节点不断地相互共享新数据并验证数据，因此这样你就可以确定那些是未被篡改的数据，那些是最新的数据。 你可以在第一次接触以太坊的方法中使用两种基本类型的节点：本地或托管。本地节点可以在你的计算机上运行，这意味着你首先需要下载像geth这样的客户端，它会将区块链同步到你的设备，要占用存储空间并花费大量时间来完成。对于第一次学习，托管节点是更好的选择——它由其他人控制，但你可以轻松连接到它并自己玩区块链。 去Infura并创建自己的免费帐户以访问此类托管节点。当你完成后，你可以看到mainnet主网（即以太坊区块链）和一堆testnets测试网，它们基本上可以测试你的智能合约，这样你就可以在将昂贵的代码部署到mainnet之前犯错误，并纠正它们。 这第一次我们先导入Web3对象并建立HTTP连接。 from web3 import Web3 web3 = Web3(Web3.HTTPProvider(&quot;https://mainnet.infura.io/your-own-personal-number&quot;)) 现在你已经完成了！你可以使用web3 API浏览查询数据结构了。 查询特定区块信息 #current block number &gt;&gt;&gt; web3.eth.blockNumber 5658173 #get the content of the most recently mined block &gt;&gt;&gt; web3.eth.getBlock(&#39;latest&#39;) 此命令返回AttributeDict数据结构，该结构是key-value键值对的字典，如下所示： AttributeDict({&#39;difficulty&#39;: 3297284143124448, &#39;extraData&#39;: HexBytes(&#39;0x65746865726d696e652d6177732d61736961312d34&#39;), &#39;gasLimit&#39;: 7999992, &#39;gasUsed&#39;: 7990111, &#39;hash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;logsBloom&#39;: HexBytes(&#39;0x348000240b40620836308460180004415000c8ccb260021402420721c22801ca847c625c0a89030482044001523a4d100050100250d100858381260a186312088006c154010000491216446840888200c1812088c12b06000809a808530014160000812c2ac20008a201c83380314d02242338400c0500c2a028005010988c44b0608a020400201032e10e16142b931115469824248066100b082224200222140a41a20aa2006224d608210f1a22811d03969423e8c08058100388c0800402002a000802130c40d289201900c38142a1cc0380a4010f0201040d4022200022018c5801346c168502841906940485ea1d9864044060a00000a00616004d006090&#39;), &#39;miner&#39;: &#39;0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8&#39;, &#39;mixHash&#39;: HexBytes(&#39;0x84320fd71345778b48e437f3403e9021575520ba23aaac48dd7a352c9ce31f75&#39;), &#39;nonce&#39;: HexBytes(&#39;0x98a0b1e00bfabac6&#39;), &#39;number&#39;: 5658173, &#39;parentHash&#39;: HexBytes(&#39;0x01eda8a47a0151533d1afacf9b9108606d4d89a86e269dddaac9698b6fb12930&#39;), &#39;receiptsRoot&#39;: HexBytes(&#39;0xc40f774ad10ad443457c3a5a0db96b539af3007f8d351b198ca7bf2ef196b7e0&#39;), &#39;sha3Uncles&#39;: HexBytes(&#39;0x55725ec296c6c64257ed6a88d7d8c66160abe7b672f5d89bbad5487779b1d5fe&#39;), &#39;size&#39;: 27161, &#39;stateRoot&#39;: HexBytes(&#39;0x5bfc7a9a87fb9991f2760807d56319154f1dab91d3cfc9530a597b6c5d064aba&#39;), &#39;timestamp&#39;: 1527002893, &#39;totalDifficulty&#39;: 4339832462578780814928, &#39;transactions&#39;: [HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), HexBytes(&#39;0x6ba5e657243aea5f95afb40090313d10bb9443db41ed1216fbf7e7e60a16749a&#39;), loooooots_of_transactions_here], &#39;transactionsRoot&#39;: HexBytes(&#39;0x67e1e1f2f4b1d33791a0fba2d5ebf039bd6c331c665cb8020ff41d0e0eade46e&#39;), &#39;uncles&#39;: [HexBytes(&#39;0x3df1bffa62d73b3847b434e9ea459c10cfdc3e212a2e78ebbf0db58adbef30b5&#39;), HexBytes(&#39;0x74bdcd4b88427854ae18f9c7ada28d46f26411bed09af6b040cbede66fdb1853&#39;)]}) 并非所有这些变量都会立即对你有用，因为有些变量非常技术性，只有当你对区块链的实际工作方式有了更深入的了解时，它们的含义才有意义。你可以在所谓的黄皮书中阅读有关它们的更多信息，或暂时跳过它们并使用易于理解的方法。 简而言之，一个包含区块头部信息的区块，一个写入它的已验证交易列表和一个未确认列表（矿工的块标识符，他们的区块太慢，无法进入主区块链，但仍因其计算工作量而获得以太奖励）。下面你可以看到每个变量的含义，我把它分成子类别。 General常规数据 Block variable Meaning 翻译 number scalar value equal to the number of ancestor blocks (genesis block=0) 标量值相对创始块的数量，genesis block=0 size size of the block in bytes 块的大小，以字节为单位 timestamp Unix’s time() at this block’s inception 这个块开始时的Unix时间 miner 160-bit address for fees collected from successful mining 成功采矿收取以太的160位地址 gasLimit maximum gas expenditure allowed in this block 此区块允许的最大气体消耗量 gasUsed total gas used by all transactions in this block 此区块中所有交易使用的总气体 transactions list of transaction hashes included in the block 块中包含的交易哈希列表 parentHash Keccak256 hash of the parent block’s header 父块区块头的Keccak 256哈希值 hash current block’s hash 当前块的哈希值 extraData extra data in byte array 字节数组中的额外数据 挖矿相关 Block variable Meaning 翻译 difficulty scalar value corresponding to the difficulty level of the block 对应于块的难度级别的标量值 totalDifficulty integer of the total difficulty of the chain until this block 直到此区块的链的总难度值 nonce hash of the generated proof-of-work; null when its a pending block 生成工作量证明的哈希值;当区块挂起时为null mixHash 256-bit hash which is combined with the nonce and used to prove that sufficient amount of computation has been carried out on this block 256位哈希与nonce结合使用来证明已对此块执行了足够的计算量 uncle相关 Block variable Meaning 翻译 uncles list of uncle hashes uncle哈希值列表 sha3Uncles SHA3 of the uncles data in the block 块中uncles数据的SHA3值 技术相关 Block variable Meaning 翻译 receiptsRoot Keccak 256-bit hash of the root node of the tree structure populated with receipts of all transactions in this block Keccak树结构的根节点的256位哈希填充了此块中所有交易的收据 stateRoot Keccak256 hash of the root node if the state trie after all transactions are executed and finalisations applied 在执行所有交易并应用终止后，如状态为trie根节点的keccak256哈希值 transactionsRoot Keccak256 hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list trie结构的根节点的keccak256哈希填充了交易列表中每个交易的收据 logsBloom the Bloom filter from indexable info (logger address and log topics) contained in each log entry from the receipt of each transaction in the transaction list 交易列表中每个交易的接收日志条目中包含的可索引信息（记录器地址和日志主题）的Bloom过滤器 交易和收据 现在，我们还可以通过其唯一标识符（即交易哈希）查找区块中的单个交易。 &gt;&gt;&gt; web3.eth.getTransaction(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;blockNumber&#39;: 5658173, &#39;from&#39;: &#39;0x390dE26d772D2e2005C6d1d24afC902bae37a4bB&#39;, &#39;gas&#39;: 45000, &#39;gasPrice&#39;: 123400000000, &#39;hash&#39;: HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), &#39;input&#39;: &#39;0x&#39;, &#39;nonce&#39;: 415710, &#39;r&#39;: HexBytes(&#39;0x1bb901ad0a3add517504cc459fdb1545d193020ec5c63a566e440ee39dbfe131&#39;), &#39;s&#39;: HexBytes(&#39;0x4b7ac95eb321b5947948ecb624e1d80b19d9cc876668c69cc2b32670f52b061a&#39;), &#39;to&#39;: &#39;0xBbA2D99C9B3aF394B0d6417b1D58815eE495029D&#39;, &#39;transactionIndex&#39;: 0, &#39;v&#39;: 37, &#39;value&#39;: 1000000000000000000}) 和以前一样，web3py返回一个属性字典。下表总结了每个键的含义。 Transaction variable Meaning 翻译 blockHash hash of the block the transaction belongs to 交易所属区块的哈希值 blockNumber number of that block 该块的编号 hash transaction hash (unique identifier) 交易地址哈希（唯一标识符） from 160-bit address of a sender of a transaction 来自交易发送方的160位地址哈希 to address of the recipient or null for a contract creation transaction 收件人的地址或者创建合约交易时为null value number of wei to be transfered to the recipient or newly created account (case of contract creation) 要转移给收件人或新创建帐户的wei数量（创建合约的情况） gas gas consumed by the transaction 交易消耗的天然气 gasPrice number of Wei to be paid per unit of gas for all computatioon costs of this transaction 此交易所有计算成本的每单位天然气的支付数量 nonce number of transactions/contract creations sent by the sender prior to this one 发送方在此之前发送的交易和创建合约的数量 v/r/s used to identify the sender; the signature values of the transaction 用于识别发件人交易的签名值 input the data sent along with the transaction 与交易一起发送的数据 transactionIndex index of the transaction in the block 区块中交易的索引 最后，我们还可以查看交易收据： &gt;&gt;&gt; web3.eth.getTransactionReceipt(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x44338e1f80302037c7213e8f56dd35d8a473b000319bc200f76e910e62d12f98&#39;), &#39;blockNumber&#39;: 5617795, &#39;contractAddress&#39;: None, &#39;cumulativeGasUsed&#39;: 21004, &#39;from&#39;: &#39;0xea6e3e41ebaa09d550d3c3f0d72971b3c5ccc261&#39;, &#39;gasUsed&#39;: 21004, &#39;logs&#39;: [], &#39;logsBloom&#39;: HexBytes(&#39;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#39;), &#39;status&#39;: 1, &#39;to&#39;: &#39;0xd96a6e75d099ce529bbd257cbcb403224cceaebf&#39;, &#39;transactionHash&#39;: HexBytes(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;), &#39;transactionIndex&#39;: 0}) 交易收据包含一些重复和新条目，新的条目解释如下。 Receipt variable Meaning 翻译 status boolean whether the transaction was successfull; false if the EVM (Ethereum Virtual Machine) reverted the transaction 交易是否成功，如果EVM（以太坊虚拟机）还原了交易则返回false contractAddress the contract address created if the transaction was a contract creation; otherwise null 如果交易是合约创建，则创建的合同地址;否则为null gasUsed the total amount of gas used when this transaction was executed in the block 在区块中执行此交易时使用的总气体量 cumulativeGasUsed the sum of gasUsed by this transaction and all preceding transactions in the same block 此交易使用的gasUse和同一块中所有先前交易的总和 logs array of log objects which the transaction has generated 交易生成的日志对象数组 作为参考，除了黄皮书之外，我还包括各种额外资源来编制这些表格2,3,4,5。 如你所见，只需几个简单的命令，就可以连接到网络并获得有关原始格式的交易，区块或状态的基本信息。这将为这些数据打开一个新窗口！ 数据库管理系统 当计划将数据写入适当的数据库时，你可能会意识到有许多针对Python爱好者的管理系统解决方案，例如无服务器SQLite，或基于服务器的MySQL，PostgreSQL或Hadoop。根据你的意图，必须确定哪个选项最适合你的项目。总的来说，我发现这些要点很有帮助： 数据库的预期大小是什么（即可以在单个机器系统上处理）？ 这些条目是经常编辑还是会保持不变？ 数据库是否应该由多方/应用程序同时访问和编辑？ 随着时间的推移，以太坊区块链正在稳步增长，截止到2018年6月接近1TB，这个很小，因此对于像Hadoop这样的分布式处理系统来说并不是最佳选择。区块链数据库将被写入一次，然后仅使用新条目进行扩展，保留旧条目不变。此数据库的预期用例由一个通道编写，并由其他通道以只读方式访问，因此我们实际上不需要在服务器上运行它。在你的机器上本地保存数据库将导致快速读取，这对于像SQLite这样的无服务器管理系统是可取的和可实现的。Python有一个内置的库sqlite3，因此我们甚至不需要安装新的包。 数据库设计 下一步是设计数据库。请记住哪些数据字段与你的分析最相关，并且旨在优化搜索和存储。例如，如果你不打算使用stateRoot，则可能需要完全跳过它或将其保存在单独的表中。可以更快地搜索具有较少列的表，如果稍后意识到你实际上具有stateRoot的用例，你仍然可以访问它。你可能还希望将块信息与交易信息分开;如果不这样做，那么区块属性如timestamp将对区块中的所有交易重复N次，浪费大量空间。稍后使用JOIN操作可以轻松地将交易与其块属性进行匹配。 我设计的数据库包含3个表： Quick：最相关的交易信息，用于快速访问和分析。 TX：所有剩余的交易信息， Block：指定区块的信息。 变量的命名约定相对于原始的web3py略有改变，以消除歧义，例如将块哈希和交易哈希都称为“哈希”，或使用“from”/“to”作为列名，这在SQL有不同的含义，会使程序崩溃。 交易值，余额和其他大数字需要作为字符串存储在数据库中。原因是SQLite只能处理最多8字节存储的有符号整数，最大值为2的63次方-1大约是9223372036854775807.这通常远低于wei中的交易值（例如，1ETH = 10*18 wei）。 构建你的迷你数据库 完整的代码可以在GitHub上找到。它将根据上层架构组织区块链信息，并输出包含预先指定数量的块数据的blockchain.db文件。要测试它，请转到database.py文件并为要写入的块数选择合理的数字，例如: Nblocks = 10000 默认情况下，你应该将web3对象指向Infura端点。 如果你有IPC提供商（即你的本地节点），也可以切换到IPC提供商，只需取消注释该行： # or connection via node on the VM #web3 = Web3(Web3.IPCProvider(&#39;/path-to-geth.ipc/&#39;)) 修改路径，然后只需在命令行python database.py中运行。代码会将最后写入的块的编号转储到lastblock.txt文件中，以防你需要重新启动。 如何使用数据库 一旦将第一个条目写入数据库，就可以通过ipython shell开始与它进行通信。例如，要打印表“Quick”的前5行，你可以运行下面的代码。 import sqlite3 as sq3 conn = sq3.connect(&quot;blockchain.db&quot;) cur = conn.cursor() # some SQL code, e.g. select first five entries of the table Quick cur.execute(&quot;SELECT * FROM Quick LIMIT 5&quot;) a = cur.fetchall() #list of tuples containing all elements of the row print(a) conn.close() 本地节点与Infura 如果要构建大型数据库，则应下载geth并同步节点。同步可以在3种基本模式下完成： 如果你不需要过去的帐户状态，则可以在快速模式下同步节点6。 下面的图表显示了此代码写入数据库的速度，与本地完全同步的节点（IPC）与Infura（Infura）上的地址进行通信。正如你所看到的，在本地节点上运行此代码是值得的，因为你可以将速度提升近2个数量级（即100x）！ 总结 现在你已拥有自己的本地数据库，了解区块链上发生的事情，可以开始探索它。例如，你可以计算自其起源以来的交易数量，查看作为时间函数生成的地址数量——天空是你可以了解的有关区块链的限制。我们为你的数据科学游乐场奠定了基础。因此，请继续探讨，或查看下一篇文章，了解潜在的应用。 python用web3.py库开发以太坊来说非常的方便，有兴趣的用户可以关注我们的python以太坊教程，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 另外其他语言可以学习的以太坊教程如下： web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开" />
<meta property="og:description" content="关于区块链介绍性的研讨会通常以易于理解的点对点网络和银行分类账这类故事开头，然后直接跳到编写智能合约，这显得非常突兀。因此，想象自己走进丛林，想象以太坊区块链是一个你即将研究的奇怪生物。今天我们将观察该生物，并与其进行交互然后将有关它的所有数据收集到一个集中存储中供自己使用。 进行第一次设置 首先，你需要安装web3py。Web3py是一个用于连接以太坊区块链的Python库。你需要事先知道的是，没有可以从中下载数据的中央管理系统。彼此共享资源的内连节点（“对等体”）存储经验证的数据副本（或其一部分）。网络执行以太坊协议，该协议定义节点彼此之间的交互规则及网络上的智能合约。 如果要访问有关交易，余额，区块或其他任何被写入区块链的信息，协议需要你连接到节点。节点不断地相互共享新数据并验证数据，因此这样你就可以确定那些是未被篡改的数据，那些是最新的数据。 你可以在第一次接触以太坊的方法中使用两种基本类型的节点：本地或托管。本地节点可以在你的计算机上运行，这意味着你首先需要下载像geth这样的客户端，它会将区块链同步到你的设备，要占用存储空间并花费大量时间来完成。对于第一次学习，托管节点是更好的选择——它由其他人控制，但你可以轻松连接到它并自己玩区块链。 去Infura并创建自己的免费帐户以访问此类托管节点。当你完成后，你可以看到mainnet主网（即以太坊区块链）和一堆testnets测试网，它们基本上可以测试你的智能合约，这样你就可以在将昂贵的代码部署到mainnet之前犯错误，并纠正它们。 这第一次我们先导入Web3对象并建立HTTP连接。 from web3 import Web3 web3 = Web3(Web3.HTTPProvider(&quot;https://mainnet.infura.io/your-own-personal-number&quot;)) 现在你已经完成了！你可以使用web3 API浏览查询数据结构了。 查询特定区块信息 #current block number &gt;&gt;&gt; web3.eth.blockNumber 5658173 #get the content of the most recently mined block &gt;&gt;&gt; web3.eth.getBlock(&#39;latest&#39;) 此命令返回AttributeDict数据结构，该结构是key-value键值对的字典，如下所示： AttributeDict({&#39;difficulty&#39;: 3297284143124448, &#39;extraData&#39;: HexBytes(&#39;0x65746865726d696e652d6177732d61736961312d34&#39;), &#39;gasLimit&#39;: 7999992, &#39;gasUsed&#39;: 7990111, &#39;hash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;logsBloom&#39;: HexBytes(&#39;0x348000240b40620836308460180004415000c8ccb260021402420721c22801ca847c625c0a89030482044001523a4d100050100250d100858381260a186312088006c154010000491216446840888200c1812088c12b06000809a808530014160000812c2ac20008a201c83380314d02242338400c0500c2a028005010988c44b0608a020400201032e10e16142b931115469824248066100b082224200222140a41a20aa2006224d608210f1a22811d03969423e8c08058100388c0800402002a000802130c40d289201900c38142a1cc0380a4010f0201040d4022200022018c5801346c168502841906940485ea1d9864044060a00000a00616004d006090&#39;), &#39;miner&#39;: &#39;0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8&#39;, &#39;mixHash&#39;: HexBytes(&#39;0x84320fd71345778b48e437f3403e9021575520ba23aaac48dd7a352c9ce31f75&#39;), &#39;nonce&#39;: HexBytes(&#39;0x98a0b1e00bfabac6&#39;), &#39;number&#39;: 5658173, &#39;parentHash&#39;: HexBytes(&#39;0x01eda8a47a0151533d1afacf9b9108606d4d89a86e269dddaac9698b6fb12930&#39;), &#39;receiptsRoot&#39;: HexBytes(&#39;0xc40f774ad10ad443457c3a5a0db96b539af3007f8d351b198ca7bf2ef196b7e0&#39;), &#39;sha3Uncles&#39;: HexBytes(&#39;0x55725ec296c6c64257ed6a88d7d8c66160abe7b672f5d89bbad5487779b1d5fe&#39;), &#39;size&#39;: 27161, &#39;stateRoot&#39;: HexBytes(&#39;0x5bfc7a9a87fb9991f2760807d56319154f1dab91d3cfc9530a597b6c5d064aba&#39;), &#39;timestamp&#39;: 1527002893, &#39;totalDifficulty&#39;: 4339832462578780814928, &#39;transactions&#39;: [HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), HexBytes(&#39;0x6ba5e657243aea5f95afb40090313d10bb9443db41ed1216fbf7e7e60a16749a&#39;), loooooots_of_transactions_here], &#39;transactionsRoot&#39;: HexBytes(&#39;0x67e1e1f2f4b1d33791a0fba2d5ebf039bd6c331c665cb8020ff41d0e0eade46e&#39;), &#39;uncles&#39;: [HexBytes(&#39;0x3df1bffa62d73b3847b434e9ea459c10cfdc3e212a2e78ebbf0db58adbef30b5&#39;), HexBytes(&#39;0x74bdcd4b88427854ae18f9c7ada28d46f26411bed09af6b040cbede66fdb1853&#39;)]}) 并非所有这些变量都会立即对你有用，因为有些变量非常技术性，只有当你对区块链的实际工作方式有了更深入的了解时，它们的含义才有意义。你可以在所谓的黄皮书中阅读有关它们的更多信息，或暂时跳过它们并使用易于理解的方法。 简而言之，一个包含区块头部信息的区块，一个写入它的已验证交易列表和一个未确认列表（矿工的块标识符，他们的区块太慢，无法进入主区块链，但仍因其计算工作量而获得以太奖励）。下面你可以看到每个变量的含义，我把它分成子类别。 General常规数据 Block variable Meaning 翻译 number scalar value equal to the number of ancestor blocks (genesis block=0) 标量值相对创始块的数量，genesis block=0 size size of the block in bytes 块的大小，以字节为单位 timestamp Unix’s time() at this block’s inception 这个块开始时的Unix时间 miner 160-bit address for fees collected from successful mining 成功采矿收取以太的160位地址 gasLimit maximum gas expenditure allowed in this block 此区块允许的最大气体消耗量 gasUsed total gas used by all transactions in this block 此区块中所有交易使用的总气体 transactions list of transaction hashes included in the block 块中包含的交易哈希列表 parentHash Keccak256 hash of the parent block’s header 父块区块头的Keccak 256哈希值 hash current block’s hash 当前块的哈希值 extraData extra data in byte array 字节数组中的额外数据 挖矿相关 Block variable Meaning 翻译 difficulty scalar value corresponding to the difficulty level of the block 对应于块的难度级别的标量值 totalDifficulty integer of the total difficulty of the chain until this block 直到此区块的链的总难度值 nonce hash of the generated proof-of-work; null when its a pending block 生成工作量证明的哈希值;当区块挂起时为null mixHash 256-bit hash which is combined with the nonce and used to prove that sufficient amount of computation has been carried out on this block 256位哈希与nonce结合使用来证明已对此块执行了足够的计算量 uncle相关 Block variable Meaning 翻译 uncles list of uncle hashes uncle哈希值列表 sha3Uncles SHA3 of the uncles data in the block 块中uncles数据的SHA3值 技术相关 Block variable Meaning 翻译 receiptsRoot Keccak 256-bit hash of the root node of the tree structure populated with receipts of all transactions in this block Keccak树结构的根节点的256位哈希填充了此块中所有交易的收据 stateRoot Keccak256 hash of the root node if the state trie after all transactions are executed and finalisations applied 在执行所有交易并应用终止后，如状态为trie根节点的keccak256哈希值 transactionsRoot Keccak256 hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list trie结构的根节点的keccak256哈希填充了交易列表中每个交易的收据 logsBloom the Bloom filter from indexable info (logger address and log topics) contained in each log entry from the receipt of each transaction in the transaction list 交易列表中每个交易的接收日志条目中包含的可索引信息（记录器地址和日志主题）的Bloom过滤器 交易和收据 现在，我们还可以通过其唯一标识符（即交易哈希）查找区块中的单个交易。 &gt;&gt;&gt; web3.eth.getTransaction(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;blockNumber&#39;: 5658173, &#39;from&#39;: &#39;0x390dE26d772D2e2005C6d1d24afC902bae37a4bB&#39;, &#39;gas&#39;: 45000, &#39;gasPrice&#39;: 123400000000, &#39;hash&#39;: HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), &#39;input&#39;: &#39;0x&#39;, &#39;nonce&#39;: 415710, &#39;r&#39;: HexBytes(&#39;0x1bb901ad0a3add517504cc459fdb1545d193020ec5c63a566e440ee39dbfe131&#39;), &#39;s&#39;: HexBytes(&#39;0x4b7ac95eb321b5947948ecb624e1d80b19d9cc876668c69cc2b32670f52b061a&#39;), &#39;to&#39;: &#39;0xBbA2D99C9B3aF394B0d6417b1D58815eE495029D&#39;, &#39;transactionIndex&#39;: 0, &#39;v&#39;: 37, &#39;value&#39;: 1000000000000000000}) 和以前一样，web3py返回一个属性字典。下表总结了每个键的含义。 Transaction variable Meaning 翻译 blockHash hash of the block the transaction belongs to 交易所属区块的哈希值 blockNumber number of that block 该块的编号 hash transaction hash (unique identifier) 交易地址哈希（唯一标识符） from 160-bit address of a sender of a transaction 来自交易发送方的160位地址哈希 to address of the recipient or null for a contract creation transaction 收件人的地址或者创建合约交易时为null value number of wei to be transfered to the recipient or newly created account (case of contract creation) 要转移给收件人或新创建帐户的wei数量（创建合约的情况） gas gas consumed by the transaction 交易消耗的天然气 gasPrice number of Wei to be paid per unit of gas for all computatioon costs of this transaction 此交易所有计算成本的每单位天然气的支付数量 nonce number of transactions/contract creations sent by the sender prior to this one 发送方在此之前发送的交易和创建合约的数量 v/r/s used to identify the sender; the signature values of the transaction 用于识别发件人交易的签名值 input the data sent along with the transaction 与交易一起发送的数据 transactionIndex index of the transaction in the block 区块中交易的索引 最后，我们还可以查看交易收据： &gt;&gt;&gt; web3.eth.getTransactionReceipt(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x44338e1f80302037c7213e8f56dd35d8a473b000319bc200f76e910e62d12f98&#39;), &#39;blockNumber&#39;: 5617795, &#39;contractAddress&#39;: None, &#39;cumulativeGasUsed&#39;: 21004, &#39;from&#39;: &#39;0xea6e3e41ebaa09d550d3c3f0d72971b3c5ccc261&#39;, &#39;gasUsed&#39;: 21004, &#39;logs&#39;: [], &#39;logsBloom&#39;: HexBytes(&#39;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#39;), &#39;status&#39;: 1, &#39;to&#39;: &#39;0xd96a6e75d099ce529bbd257cbcb403224cceaebf&#39;, &#39;transactionHash&#39;: HexBytes(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;), &#39;transactionIndex&#39;: 0}) 交易收据包含一些重复和新条目，新的条目解释如下。 Receipt variable Meaning 翻译 status boolean whether the transaction was successfull; false if the EVM (Ethereum Virtual Machine) reverted the transaction 交易是否成功，如果EVM（以太坊虚拟机）还原了交易则返回false contractAddress the contract address created if the transaction was a contract creation; otherwise null 如果交易是合约创建，则创建的合同地址;否则为null gasUsed the total amount of gas used when this transaction was executed in the block 在区块中执行此交易时使用的总气体量 cumulativeGasUsed the sum of gasUsed by this transaction and all preceding transactions in the same block 此交易使用的gasUse和同一块中所有先前交易的总和 logs array of log objects which the transaction has generated 交易生成的日志对象数组 作为参考，除了黄皮书之外，我还包括各种额外资源来编制这些表格2,3,4,5。 如你所见，只需几个简单的命令，就可以连接到网络并获得有关原始格式的交易，区块或状态的基本信息。这将为这些数据打开一个新窗口！ 数据库管理系统 当计划将数据写入适当的数据库时，你可能会意识到有许多针对Python爱好者的管理系统解决方案，例如无服务器SQLite，或基于服务器的MySQL，PostgreSQL或Hadoop。根据你的意图，必须确定哪个选项最适合你的项目。总的来说，我发现这些要点很有帮助： 数据库的预期大小是什么（即可以在单个机器系统上处理）？ 这些条目是经常编辑还是会保持不变？ 数据库是否应该由多方/应用程序同时访问和编辑？ 随着时间的推移，以太坊区块链正在稳步增长，截止到2018年6月接近1TB，这个很小，因此对于像Hadoop这样的分布式处理系统来说并不是最佳选择。区块链数据库将被写入一次，然后仅使用新条目进行扩展，保留旧条目不变。此数据库的预期用例由一个通道编写，并由其他通道以只读方式访问，因此我们实际上不需要在服务器上运行它。在你的机器上本地保存数据库将导致快速读取，这对于像SQLite这样的无服务器管理系统是可取的和可实现的。Python有一个内置的库sqlite3，因此我们甚至不需要安装新的包。 数据库设计 下一步是设计数据库。请记住哪些数据字段与你的分析最相关，并且旨在优化搜索和存储。例如，如果你不打算使用stateRoot，则可能需要完全跳过它或将其保存在单独的表中。可以更快地搜索具有较少列的表，如果稍后意识到你实际上具有stateRoot的用例，你仍然可以访问它。你可能还希望将块信息与交易信息分开;如果不这样做，那么区块属性如timestamp将对区块中的所有交易重复N次，浪费大量空间。稍后使用JOIN操作可以轻松地将交易与其块属性进行匹配。 我设计的数据库包含3个表： Quick：最相关的交易信息，用于快速访问和分析。 TX：所有剩余的交易信息， Block：指定区块的信息。 变量的命名约定相对于原始的web3py略有改变，以消除歧义，例如将块哈希和交易哈希都称为“哈希”，或使用“from”/“to”作为列名，这在SQL有不同的含义，会使程序崩溃。 交易值，余额和其他大数字需要作为字符串存储在数据库中。原因是SQLite只能处理最多8字节存储的有符号整数，最大值为2的63次方-1大约是9223372036854775807.这通常远低于wei中的交易值（例如，1ETH = 10*18 wei）。 构建你的迷你数据库 完整的代码可以在GitHub上找到。它将根据上层架构组织区块链信息，并输出包含预先指定数量的块数据的blockchain.db文件。要测试它，请转到database.py文件并为要写入的块数选择合理的数字，例如: Nblocks = 10000 默认情况下，你应该将web3对象指向Infura端点。 如果你有IPC提供商（即你的本地节点），也可以切换到IPC提供商，只需取消注释该行： # or connection via node on the VM #web3 = Web3(Web3.IPCProvider(&#39;/path-to-geth.ipc/&#39;)) 修改路径，然后只需在命令行python database.py中运行。代码会将最后写入的块的编号转储到lastblock.txt文件中，以防你需要重新启动。 如何使用数据库 一旦将第一个条目写入数据库，就可以通过ipython shell开始与它进行通信。例如，要打印表“Quick”的前5行，你可以运行下面的代码。 import sqlite3 as sq3 conn = sq3.connect(&quot;blockchain.db&quot;) cur = conn.cursor() # some SQL code, e.g. select first five entries of the table Quick cur.execute(&quot;SELECT * FROM Quick LIMIT 5&quot;) a = cur.fetchall() #list of tuples containing all elements of the row print(a) conn.close() 本地节点与Infura 如果要构建大型数据库，则应下载geth并同步节点。同步可以在3种基本模式下完成： 如果你不需要过去的帐户状态，则可以在快速模式下同步节点6。 下面的图表显示了此代码写入数据库的速度，与本地完全同步的节点（IPC）与Infura（Infura）上的地址进行通信。正如你所看到的，在本地节点上运行此代码是值得的，因为你可以将速度提升近2个数量级（即100x）！ 总结 现在你已拥有自己的本地数据库，了解区块链上发生的事情，可以开始探索它。例如，你可以计算自其起源以来的交易数量，查看作为时间函数生成的地址数量——天空是你可以了解的有关区块链的限制。我们为你的数据科学游乐场奠定了基础。因此，请继续探讨，或查看下一篇文章，了解潜在的应用。 python用web3.py库开发以太坊来说非常的方便，有兴趣的用户可以关注我们的python以太坊教程，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 另外其他语言可以学习的以太坊教程如下： web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/09/05/7b805a1296000ef6d60fe9f88043ba55.html" />
<meta property="og:url" content="https://mlh.app/2018/09/05/7b805a1296000ef6d60fe9f88043ba55.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"关于区块链介绍性的研讨会通常以易于理解的点对点网络和银行分类账这类故事开头，然后直接跳到编写智能合约，这显得非常突兀。因此，想象自己走进丛林，想象以太坊区块链是一个你即将研究的奇怪生物。今天我们将观察该生物，并与其进行交互然后将有关它的所有数据收集到一个集中存储中供自己使用。 进行第一次设置 首先，你需要安装web3py。Web3py是一个用于连接以太坊区块链的Python库。你需要事先知道的是，没有可以从中下载数据的中央管理系统。彼此共享资源的内连节点（“对等体”）存储经验证的数据副本（或其一部分）。网络执行以太坊协议，该协议定义节点彼此之间的交互规则及网络上的智能合约。 如果要访问有关交易，余额，区块或其他任何被写入区块链的信息，协议需要你连接到节点。节点不断地相互共享新数据并验证数据，因此这样你就可以确定那些是未被篡改的数据，那些是最新的数据。 你可以在第一次接触以太坊的方法中使用两种基本类型的节点：本地或托管。本地节点可以在你的计算机上运行，这意味着你首先需要下载像geth这样的客户端，它会将区块链同步到你的设备，要占用存储空间并花费大量时间来完成。对于第一次学习，托管节点是更好的选择——它由其他人控制，但你可以轻松连接到它并自己玩区块链。 去Infura并创建自己的免费帐户以访问此类托管节点。当你完成后，你可以看到mainnet主网（即以太坊区块链）和一堆testnets测试网，它们基本上可以测试你的智能合约，这样你就可以在将昂贵的代码部署到mainnet之前犯错误，并纠正它们。 这第一次我们先导入Web3对象并建立HTTP连接。 from web3 import Web3 web3 = Web3(Web3.HTTPProvider(&quot;https://mainnet.infura.io/your-own-personal-number&quot;)) 现在你已经完成了！你可以使用web3 API浏览查询数据结构了。 查询特定区块信息 #current block number &gt;&gt;&gt; web3.eth.blockNumber 5658173 #get the content of the most recently mined block &gt;&gt;&gt; web3.eth.getBlock(&#39;latest&#39;) 此命令返回AttributeDict数据结构，该结构是key-value键值对的字典，如下所示： AttributeDict({&#39;difficulty&#39;: 3297284143124448, &#39;extraData&#39;: HexBytes(&#39;0x65746865726d696e652d6177732d61736961312d34&#39;), &#39;gasLimit&#39;: 7999992, &#39;gasUsed&#39;: 7990111, &#39;hash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;logsBloom&#39;: HexBytes(&#39;0x348000240b40620836308460180004415000c8ccb260021402420721c22801ca847c625c0a89030482044001523a4d100050100250d100858381260a186312088006c154010000491216446840888200c1812088c12b06000809a808530014160000812c2ac20008a201c83380314d02242338400c0500c2a028005010988c44b0608a020400201032e10e16142b931115469824248066100b082224200222140a41a20aa2006224d608210f1a22811d03969423e8c08058100388c0800402002a000802130c40d289201900c38142a1cc0380a4010f0201040d4022200022018c5801346c168502841906940485ea1d9864044060a00000a00616004d006090&#39;), &#39;miner&#39;: &#39;0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8&#39;, &#39;mixHash&#39;: HexBytes(&#39;0x84320fd71345778b48e437f3403e9021575520ba23aaac48dd7a352c9ce31f75&#39;), &#39;nonce&#39;: HexBytes(&#39;0x98a0b1e00bfabac6&#39;), &#39;number&#39;: 5658173, &#39;parentHash&#39;: HexBytes(&#39;0x01eda8a47a0151533d1afacf9b9108606d4d89a86e269dddaac9698b6fb12930&#39;), &#39;receiptsRoot&#39;: HexBytes(&#39;0xc40f774ad10ad443457c3a5a0db96b539af3007f8d351b198ca7bf2ef196b7e0&#39;), &#39;sha3Uncles&#39;: HexBytes(&#39;0x55725ec296c6c64257ed6a88d7d8c66160abe7b672f5d89bbad5487779b1d5fe&#39;), &#39;size&#39;: 27161, &#39;stateRoot&#39;: HexBytes(&#39;0x5bfc7a9a87fb9991f2760807d56319154f1dab91d3cfc9530a597b6c5d064aba&#39;), &#39;timestamp&#39;: 1527002893, &#39;totalDifficulty&#39;: 4339832462578780814928, &#39;transactions&#39;: [HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), HexBytes(&#39;0x6ba5e657243aea5f95afb40090313d10bb9443db41ed1216fbf7e7e60a16749a&#39;), loooooots_of_transactions_here], &#39;transactionsRoot&#39;: HexBytes(&#39;0x67e1e1f2f4b1d33791a0fba2d5ebf039bd6c331c665cb8020ff41d0e0eade46e&#39;), &#39;uncles&#39;: [HexBytes(&#39;0x3df1bffa62d73b3847b434e9ea459c10cfdc3e212a2e78ebbf0db58adbef30b5&#39;), HexBytes(&#39;0x74bdcd4b88427854ae18f9c7ada28d46f26411bed09af6b040cbede66fdb1853&#39;)]}) 并非所有这些变量都会立即对你有用，因为有些变量非常技术性，只有当你对区块链的实际工作方式有了更深入的了解时，它们的含义才有意义。你可以在所谓的黄皮书中阅读有关它们的更多信息，或暂时跳过它们并使用易于理解的方法。 简而言之，一个包含区块头部信息的区块，一个写入它的已验证交易列表和一个未确认列表（矿工的块标识符，他们的区块太慢，无法进入主区块链，但仍因其计算工作量而获得以太奖励）。下面你可以看到每个变量的含义，我把它分成子类别。 General常规数据 Block variable Meaning 翻译 number scalar value equal to the number of ancestor blocks (genesis block=0) 标量值相对创始块的数量，genesis block=0 size size of the block in bytes 块的大小，以字节为单位 timestamp Unix’s time() at this block’s inception 这个块开始时的Unix时间 miner 160-bit address for fees collected from successful mining 成功采矿收取以太的160位地址 gasLimit maximum gas expenditure allowed in this block 此区块允许的最大气体消耗量 gasUsed total gas used by all transactions in this block 此区块中所有交易使用的总气体 transactions list of transaction hashes included in the block 块中包含的交易哈希列表 parentHash Keccak256 hash of the parent block’s header 父块区块头的Keccak 256哈希值 hash current block’s hash 当前块的哈希值 extraData extra data in byte array 字节数组中的额外数据 挖矿相关 Block variable Meaning 翻译 difficulty scalar value corresponding to the difficulty level of the block 对应于块的难度级别的标量值 totalDifficulty integer of the total difficulty of the chain until this block 直到此区块的链的总难度值 nonce hash of the generated proof-of-work; null when its a pending block 生成工作量证明的哈希值;当区块挂起时为null mixHash 256-bit hash which is combined with the nonce and used to prove that sufficient amount of computation has been carried out on this block 256位哈希与nonce结合使用来证明已对此块执行了足够的计算量 uncle相关 Block variable Meaning 翻译 uncles list of uncle hashes uncle哈希值列表 sha3Uncles SHA3 of the uncles data in the block 块中uncles数据的SHA3值 技术相关 Block variable Meaning 翻译 receiptsRoot Keccak 256-bit hash of the root node of the tree structure populated with receipts of all transactions in this block Keccak树结构的根节点的256位哈希填充了此块中所有交易的收据 stateRoot Keccak256 hash of the root node if the state trie after all transactions are executed and finalisations applied 在执行所有交易并应用终止后，如状态为trie根节点的keccak256哈希值 transactionsRoot Keccak256 hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list trie结构的根节点的keccak256哈希填充了交易列表中每个交易的收据 logsBloom the Bloom filter from indexable info (logger address and log topics) contained in each log entry from the receipt of each transaction in the transaction list 交易列表中每个交易的接收日志条目中包含的可索引信息（记录器地址和日志主题）的Bloom过滤器 交易和收据 现在，我们还可以通过其唯一标识符（即交易哈希）查找区块中的单个交易。 &gt;&gt;&gt; web3.eth.getTransaction(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50&#39;), &#39;blockNumber&#39;: 5658173, &#39;from&#39;: &#39;0x390dE26d772D2e2005C6d1d24afC902bae37a4bB&#39;, &#39;gas&#39;: 45000, &#39;gasPrice&#39;: 123400000000, &#39;hash&#39;: HexBytes(&#39;0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225&#39;), &#39;input&#39;: &#39;0x&#39;, &#39;nonce&#39;: 415710, &#39;r&#39;: HexBytes(&#39;0x1bb901ad0a3add517504cc459fdb1545d193020ec5c63a566e440ee39dbfe131&#39;), &#39;s&#39;: HexBytes(&#39;0x4b7ac95eb321b5947948ecb624e1d80b19d9cc876668c69cc2b32670f52b061a&#39;), &#39;to&#39;: &#39;0xBbA2D99C9B3aF394B0d6417b1D58815eE495029D&#39;, &#39;transactionIndex&#39;: 0, &#39;v&#39;: 37, &#39;value&#39;: 1000000000000000000}) 和以前一样，web3py返回一个属性字典。下表总结了每个键的含义。 Transaction variable Meaning 翻译 blockHash hash of the block the transaction belongs to 交易所属区块的哈希值 blockNumber number of that block 该块的编号 hash transaction hash (unique identifier) 交易地址哈希（唯一标识符） from 160-bit address of a sender of a transaction 来自交易发送方的160位地址哈希 to address of the recipient or null for a contract creation transaction 收件人的地址或者创建合约交易时为null value number of wei to be transfered to the recipient or newly created account (case of contract creation) 要转移给收件人或新创建帐户的wei数量（创建合约的情况） gas gas consumed by the transaction 交易消耗的天然气 gasPrice number of Wei to be paid per unit of gas for all computatioon costs of this transaction 此交易所有计算成本的每单位天然气的支付数量 nonce number of transactions/contract creations sent by the sender prior to this one 发送方在此之前发送的交易和创建合约的数量 v/r/s used to identify the sender; the signature values of the transaction 用于识别发件人交易的签名值 input the data sent along with the transaction 与交易一起发送的数据 transactionIndex index of the transaction in the block 区块中交易的索引 最后，我们还可以查看交易收据： &gt;&gt;&gt; web3.eth.getTransactionReceipt(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;) AttributeDict({&#39;blockHash&#39;: HexBytes(&#39;0x44338e1f80302037c7213e8f56dd35d8a473b000319bc200f76e910e62d12f98&#39;), &#39;blockNumber&#39;: 5617795, &#39;contractAddress&#39;: None, &#39;cumulativeGasUsed&#39;: 21004, &#39;from&#39;: &#39;0xea6e3e41ebaa09d550d3c3f0d72971b3c5ccc261&#39;, &#39;gasUsed&#39;: 21004, &#39;logs&#39;: [], &#39;logsBloom&#39;: HexBytes(&#39;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#39;), &#39;status&#39;: 1, &#39;to&#39;: &#39;0xd96a6e75d099ce529bbd257cbcb403224cceaebf&#39;, &#39;transactionHash&#39;: HexBytes(&#39;0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851&#39;), &#39;transactionIndex&#39;: 0}) 交易收据包含一些重复和新条目，新的条目解释如下。 Receipt variable Meaning 翻译 status boolean whether the transaction was successfull; false if the EVM (Ethereum Virtual Machine) reverted the transaction 交易是否成功，如果EVM（以太坊虚拟机）还原了交易则返回false contractAddress the contract address created if the transaction was a contract creation; otherwise null 如果交易是合约创建，则创建的合同地址;否则为null gasUsed the total amount of gas used when this transaction was executed in the block 在区块中执行此交易时使用的总气体量 cumulativeGasUsed the sum of gasUsed by this transaction and all preceding transactions in the same block 此交易使用的gasUse和同一块中所有先前交易的总和 logs array of log objects which the transaction has generated 交易生成的日志对象数组 作为参考，除了黄皮书之外，我还包括各种额外资源来编制这些表格2,3,4,5。 如你所见，只需几个简单的命令，就可以连接到网络并获得有关原始格式的交易，区块或状态的基本信息。这将为这些数据打开一个新窗口！ 数据库管理系统 当计划将数据写入适当的数据库时，你可能会意识到有许多针对Python爱好者的管理系统解决方案，例如无服务器SQLite，或基于服务器的MySQL，PostgreSQL或Hadoop。根据你的意图，必须确定哪个选项最适合你的项目。总的来说，我发现这些要点很有帮助： 数据库的预期大小是什么（即可以在单个机器系统上处理）？ 这些条目是经常编辑还是会保持不变？ 数据库是否应该由多方/应用程序同时访问和编辑？ 随着时间的推移，以太坊区块链正在稳步增长，截止到2018年6月接近1TB，这个很小，因此对于像Hadoop这样的分布式处理系统来说并不是最佳选择。区块链数据库将被写入一次，然后仅使用新条目进行扩展，保留旧条目不变。此数据库的预期用例由一个通道编写，并由其他通道以只读方式访问，因此我们实际上不需要在服务器上运行它。在你的机器上本地保存数据库将导致快速读取，这对于像SQLite这样的无服务器管理系统是可取的和可实现的。Python有一个内置的库sqlite3，因此我们甚至不需要安装新的包。 数据库设计 下一步是设计数据库。请记住哪些数据字段与你的分析最相关，并且旨在优化搜索和存储。例如，如果你不打算使用stateRoot，则可能需要完全跳过它或将其保存在单独的表中。可以更快地搜索具有较少列的表，如果稍后意识到你实际上具有stateRoot的用例，你仍然可以访问它。你可能还希望将块信息与交易信息分开;如果不这样做，那么区块属性如timestamp将对区块中的所有交易重复N次，浪费大量空间。稍后使用JOIN操作可以轻松地将交易与其块属性进行匹配。 我设计的数据库包含3个表： Quick：最相关的交易信息，用于快速访问和分析。 TX：所有剩余的交易信息， Block：指定区块的信息。 变量的命名约定相对于原始的web3py略有改变，以消除歧义，例如将块哈希和交易哈希都称为“哈希”，或使用“from”/“to”作为列名，这在SQL有不同的含义，会使程序崩溃。 交易值，余额和其他大数字需要作为字符串存储在数据库中。原因是SQLite只能处理最多8字节存储的有符号整数，最大值为2的63次方-1大约是9223372036854775807.这通常远低于wei中的交易值（例如，1ETH = 10*18 wei）。 构建你的迷你数据库 完整的代码可以在GitHub上找到。它将根据上层架构组织区块链信息，并输出包含预先指定数量的块数据的blockchain.db文件。要测试它，请转到database.py文件并为要写入的块数选择合理的数字，例如: Nblocks = 10000 默认情况下，你应该将web3对象指向Infura端点。 如果你有IPC提供商（即你的本地节点），也可以切换到IPC提供商，只需取消注释该行： # or connection via node on the VM #web3 = Web3(Web3.IPCProvider(&#39;/path-to-geth.ipc/&#39;)) 修改路径，然后只需在命令行python database.py中运行。代码会将最后写入的块的编号转储到lastblock.txt文件中，以防你需要重新启动。 如何使用数据库 一旦将第一个条目写入数据库，就可以通过ipython shell开始与它进行通信。例如，要打印表“Quick”的前5行，你可以运行下面的代码。 import sqlite3 as sq3 conn = sq3.connect(&quot;blockchain.db&quot;) cur = conn.cursor() # some SQL code, e.g. select first five entries of the table Quick cur.execute(&quot;SELECT * FROM Quick LIMIT 5&quot;) a = cur.fetchall() #list of tuples containing all elements of the row print(a) conn.close() 本地节点与Infura 如果要构建大型数据库，则应下载geth并同步节点。同步可以在3种基本模式下完成： 如果你不需要过去的帐户状态，则可以在快速模式下同步节点6。 下面的图表显示了此代码写入数据库的速度，与本地完全同步的节点（IPC）与Infura（Infura）上的地址进行通信。正如你所看到的，在本地节点上运行此代码是值得的，因为你可以将速度提升近2个数量级（即100x）！ 总结 现在你已拥有自己的本地数据库，了解区块链上发生的事情，可以开始探索它。例如，你可以计算自其起源以来的交易数量，查看作为时间函数生成的地址数量——天空是你可以了解的有关区块链的限制。我们为你的数据科学游乐场奠定了基础。因此，请继续探讨，或查看下一篇文章，了解潜在的应用。 python用web3.py库开发以太坊来说非常的方便，有兴趣的用户可以关注我们的python以太坊教程，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 另外其他语言可以学习的以太坊教程如下： web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/09/05/7b805a1296000ef6d60fe9f88043ba55.html","headline":"Python与以太坊区块链交互并使用SQL将数据存入数据库","dateModified":"2018-09-05T00:00:00+08:00","datePublished":"2018-09-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/05/7b805a1296000ef6d60fe9f88043ba55.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Python与以太坊区块链交互并使用SQL将数据存入数据库</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>关于区块链介绍性的研讨会通常以易于理解的点对点网络和银行分类账这类故事开头，然后直接跳到编写智能合约，这显得非常突兀。因此，想象自己走进丛林，想象以太坊区块链是一个你即将研究的奇怪生物。今天我们将观察该生物，并与其进行交互然后将有关它的所有数据收集到一个集中存储中供自己使用。</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/04/ethereum-python-sql/ethereum-python-sql-1.jpeg" alt="" title=""></p> 
  <h3 id="进行第一次设置">进行第一次设置</h3> 
  <p>首先，你需要安装<a href="http://web3py.readthedocs.io/en/stable/quickstart.html" rel="nofollow">web3py</a>。Web3py是一个用于连接以太坊区块链的Python库。你需要事先知道的是，没有可以从中下载数据的中央管理系统。彼此共享资源的内连节点（“对等体”）存储经验证的数据副本（或其一部分）。网络执行以太坊协议，该协议定义节点彼此之间的交互规则及网络上的智能合约。</p> 
  <p>如果要访问有关交易，余额，区块或其他任何被写入区块链的信息，协议需要你连接到节点。节点不断地相互共享新数据并验证数据，因此这样你就可以确定那些是未被篡改的数据，那些是最新的数据。</p> 
  <p>你可以在第一次接触以太坊的方法中使用两种基本类型的节点：本地或托管。本地节点可以在你的计算机上运行，这意味着你首先需要下载像geth这样的客户端，它会将区块链同步到你的设备，要占用存储空间并花费大量时间来完成。对于第一次学习，托管节点是更好的选择——它由其他人控制，但你可以轻松连接到它并自己玩区块链。</p> 
  <p>去Infura并创建自己的免费帐户以访问此类托管节点。当你完成后，你可以看到mainnet主网（即以太坊区块链）和一堆testnets测试网，它们基本上可以测试你的智能合约，这样你就可以在将昂贵的代码部署到mainnet之前犯错误，并纠正它们。</p> 
  <p>这第一次我们先导入Web3对象并建立HTTP连接。</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> web3 <span class="hljs-keyword">import</span> Web3 
web3 = Web3(Web3.HTTPProvider(<span class="hljs-string">"https://mainnet.infura.io/your-own-personal-number"</span>))</code></pre> 
  <p>现在你已经完成了！你可以使用web3 API浏览查询数据结构了。</p> 
  <h3 id="查询特定区块信息">查询特定区块信息</h3> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment">#current block number</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>web3.eth.blockNumber
<span class="hljs-number">5658173</span>
<span class="hljs-comment">#get the content of the most recently mined block</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>web3.eth.getBlock(<span class="hljs-string">'latest'</span>)</code></pre> 
  <p>此命令返回AttributeDict数据结构，该结构是key-value键值对的字典，如下所示：</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">AttributeDict({<span class="hljs-string">'difficulty'</span>: <span class="hljs-number">3297284143124448</span>, <span class="hljs-string">'extraData'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x65746865726d696e652d6177732d61736961312d34'</span>)</span>, <span class="hljs-string">'gasLimit'</span>: <span class="hljs-number">7999992</span>, <span class="hljs-string">'gasUsed'</span>: <span class="hljs-number">7990111</span>, <span class="hljs-string">'hash'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50'</span>)</span>, <span class="hljs-string">'logsBloom'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x348000240b40620836308460180004415000c8ccb260021402420721c22801ca847c625c0a89030482044001523a4d100050100250d100858381260a186312088006c154010000491216446840888200c1812088c12b06000809a808530014160000812c2ac20008a201c83380314d02242338400c0500c2a028005010988c44b0608a020400201032e10e16142b931115469824248066100b082224200222140a41a20aa2006224d608210f1a22811d03969423e8c08058100388c0800402002a000802130c40d289201900c38142a1cc0380a4010f0201040d4022200022018c5801346c168502841906940485ea1d9864044060a00000a00616004d006090'</span>)</span>, <span class="hljs-string">'miner'</span>: <span class="hljs-string">'0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8'</span>, <span class="hljs-string">'mixHash'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x84320fd71345778b48e437f3403e9021575520ba23aaac48dd7a352c9ce31f75'</span>)</span>, <span class="hljs-string">'nonce'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x98a0b1e00bfabac6'</span>)</span>, <span class="hljs-string">'number'</span>: <span class="hljs-number">5658173</span>, <span class="hljs-string">'parentHash'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x01eda8a47a0151533d1afacf9b9108606d4d89a86e269dddaac9698b6fb12930'</span>)</span>, <span class="hljs-string">'receiptsRoot'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0xc40f774ad10ad443457c3a5a0db96b539af3007f8d351b198ca7bf2ef196b7e0'</span>)</span>, <span class="hljs-string">'sha3Uncles'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x55725ec296c6c64257ed6a88d7d8c66160abe7b672f5d89bbad5487779b1d5fe'</span>)</span>, <span class="hljs-string">'size'</span>: <span class="hljs-number">27161</span>, <span class="hljs-string">'stateRoot'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x5bfc7a9a87fb9991f2760807d56319154f1dab91d3cfc9530a597b6c5d064aba'</span>)</span>, <span class="hljs-string">'timestamp'</span>: <span class="hljs-number">1527002893</span>, <span class="hljs-string">'totalDifficulty'</span>: <span class="hljs-number">4339832462578780814928</span>, <span class="hljs-string">'transactions'</span>: [<span class="hljs-function">HexBytes(<span class="hljs-string">'0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225'</span>)</span>, <span class="hljs-function">HexBytes(<span class="hljs-string">'0x6ba5e657243aea5f95afb40090313d10bb9443db41ed1216fbf7e7e60a16749a'</span>)</span>, loooooots_of_transactions_here], <span class="hljs-string">'transactionsRoot'</span>: <span class="hljs-function">HexBytes(<span class="hljs-string">'0x67e1e1f2f4b1d33791a0fba2d5ebf039bd6c331c665cb8020ff41d0e0eade46e'</span>)</span>, <span class="hljs-string">'uncles'</span>: [<span class="hljs-function">HexBytes(<span class="hljs-string">'0x3df1bffa62d73b3847b434e9ea459c10cfdc3e212a2e78ebbf0db58adbef30b5'</span>)</span>, <span class="hljs-function">HexBytes(<span class="hljs-string">'0x74bdcd4b88427854ae18f9c7ada28d46f26411bed09af6b040cbede66fdb1853'</span>)</span>]})</span></code></pre> 
  <p>并非所有这些变量都会立即对你有用，因为有些变量非常技术性，只有当你对区块链的实际工作方式有了更深入的了解时，它们的含义才有意义。你可以在所谓的<a href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="nofollow">黄皮书</a>中阅读有关它们的更多信息，或暂时跳过它们并使用易于理解的方法。</p> 
  <p>简而言之，一个包含区块头部信息的区块，一个写入它的已验证交易列表和一个未确认列表（矿工的块标识符，他们的区块太慢，无法进入主区块链，但仍因其计算工作量而获得以太奖励）。下面你可以看到每个变量的含义，我把它分成子类别。</p> 
  <h4 id="general常规数据">General常规数据</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>Block variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>number</td> 
     <td>scalar value equal to the number of ancestor blocks (genesis block=0)</td> 
     <td>标量值相对创始块的数量，genesis block=0</td> 
    </tr> 
    <tr> 
     <td>size</td> 
     <td>size of the block in bytes</td> 
     <td>块的大小，以字节为单位</td> 
    </tr> 
    <tr> 
     <td>timestamp</td> 
     <td>Unix’s time() at this block’s inception</td> 
     <td>这个块开始时的Unix时间</td> 
    </tr> 
    <tr> 
     <td>miner</td> 
     <td>160-bit address for fees collected from successful mining</td> 
     <td>成功采矿收取以太的160位地址</td> 
    </tr> 
    <tr> 
     <td>gasLimit</td> 
     <td>maximum gas expenditure allowed in this block</td> 
     <td>此区块允许的最大气体消耗量</td> 
    </tr> 
    <tr> 
     <td>gasUsed</td> 
     <td>total gas used by all transactions in this block</td> 
     <td>此区块中所有交易使用的总气体</td> 
    </tr> 
    <tr> 
     <td>transactions</td> 
     <td>list of transaction hashes included in the block</td> 
     <td>块中包含的交易哈希列表</td> 
    </tr> 
    <tr> 
     <td>parentHash</td> 
     <td>Keccak256 hash of the parent block’s header</td> 
     <td>父块区块头的Keccak 256哈希值</td> 
    </tr> 
    <tr> 
     <td>hash</td> 
     <td>current block’s hash</td> 
     <td>当前块的哈希值</td> 
    </tr> 
    <tr> 
     <td>extraData</td> 
     <td>extra data in byte array</td> 
     <td>字节数组中的额外数据</td> 
    </tr> 
   </tbody>
  </table> 
  <h4 id="挖矿相关">挖矿相关</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>Block variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>difficulty</td> 
     <td>scalar value corresponding to the difficulty level of the block</td> 
     <td>对应于块的难度级别的标量值</td> 
    </tr> 
    <tr> 
     <td>totalDifficulty</td> 
     <td>integer of the total difficulty of the chain until this block</td> 
     <td>直到此区块的链的总难度值</td> 
    </tr> 
    <tr> 
     <td>nonce</td> 
     <td>hash of the generated proof-of-work; null when its a pending block</td> 
     <td>生成工作量证明的哈希值;当区块挂起时为null</td> 
    </tr> 
    <tr> 
     <td>mixHash</td> 
     <td>256-bit hash which is combined with the nonce and used to prove that sufficient amount of computation has been carried out on this block</td> 
     <td>256位哈希与nonce结合使用来证明已对此块执行了足够的计算量</td> 
    </tr> 
   </tbody>
  </table> 
  <h4 id="uncle相关">uncle相关</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>Block variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>uncles</td> 
     <td>list of uncle hashes</td> 
     <td>uncle哈希值列表</td> 
    </tr> 
    <tr> 
     <td>sha3Uncles</td> 
     <td>SHA3 of the uncles data in the block</td> 
     <td>块中uncles数据的SHA3值</td> 
    </tr> 
   </tbody>
  </table> 
  <h4 id="技术相关">技术相关</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>Block variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>receiptsRoot</td> 
     <td>Keccak 256-bit hash of the root node of the tree structure populated with receipts of all transactions in this block</td> 
     <td>Keccak树结构的根节点的256位哈希填充了此块中所有交易的收据</td> 
    </tr> 
    <tr> 
     <td>stateRoot</td> 
     <td>Keccak256 hash of the root node if the state trie after all transactions are executed and finalisations applied</td> 
     <td>在执行所有交易并应用终止后，如状态为trie根节点的keccak256哈希值</td> 
    </tr> 
    <tr> 
     <td>transactionsRoot</td> 
     <td>Keccak256 hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list</td> 
     <td>trie结构的根节点的keccak256哈希填充了交易列表中每个交易的收据</td> 
    </tr> 
    <tr> 
     <td>logsBloom</td> 
     <td>the Bloom filter from indexable info (logger address and log topics) contained in each log entry from the receipt of each transaction in the transaction list</td> 
     <td>交易列表中每个交易的接收日志条目中包含的可索引信息（记录器地址和日志主题）的Bloom过滤器</td> 
    </tr> 
   </tbody>
  </table> 
  <h3 id="交易和收据">交易和收据</h3> 
  <p>现在，我们还可以通过其唯一标识符（即交易哈希）查找区块中的单个交易。</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>web3.eth.getTransaction(<span class="hljs-string">'0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225'</span>)

AttributeDict({<span class="hljs-string">'blockHash'</span>: HexBytes(<span class="hljs-string">'0x8c09ba67123601c08ef5d292acaffd36798ca178b7d6fecd5e1144ce8e3b9e50'</span>),
 <span class="hljs-string">'blockNumber'</span>: <span class="hljs-number">5658173</span>,
 <span class="hljs-string">'from'</span>: <span class="hljs-string">'0x390dE26d772D2e2005C6d1d24afC902bae37a4bB'</span>,
 <span class="hljs-string">'gas'</span>: <span class="hljs-number">45000</span>,
 <span class="hljs-string">'gasPrice'</span>: <span class="hljs-number">123400000000</span>,
 <span class="hljs-string">'hash'</span>: HexBytes(<span class="hljs-string">'0x1ce6bca99701c4e8acae986b10e7649d628d70ec62b7a8314bbb13726a312225'</span>),
 <span class="hljs-string">'input'</span>: <span class="hljs-string">'0x'</span>,
 <span class="hljs-string">'nonce'</span>: <span class="hljs-number">415710</span>,
 <span class="hljs-string">'r'</span>: HexBytes(<span class="hljs-string">'0x1bb901ad0a3add517504cc459fdb1545d193020ec5c63a566e440ee39dbfe131'</span>),
 <span class="hljs-string">'s'</span>: HexBytes(<span class="hljs-string">'0x4b7ac95eb321b5947948ecb624e1d80b19d9cc876668c69cc2b32670f52b061a'</span>),
 <span class="hljs-string">'to'</span>: <span class="hljs-string">'0xBbA2D99C9B3aF394B0d6417b1D58815eE495029D'</span>,
 <span class="hljs-string">'transactionIndex'</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">'v'</span>: <span class="hljs-number">37</span>,
 <span class="hljs-string">'value'</span>: <span class="hljs-number">1000000000000000000</span>})</code></pre> 
  <p>和以前一样，web3py返回一个属性字典。下表总结了每个键的含义。</p> 
  <table> 
   <thead> 
    <tr> 
     <th>Transaction variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>blockHash</td> 
     <td>hash of the block the transaction belongs to</td> 
     <td>交易所属区块的哈希值</td> 
    </tr> 
    <tr> 
     <td>blockNumber</td> 
     <td>number of that block</td> 
     <td>该块的编号</td> 
    </tr> 
    <tr> 
     <td>hash</td> 
     <td>transaction hash (unique identifier)</td> 
     <td>交易地址哈希（唯一标识符）</td> 
    </tr> 
    <tr> 
     <td>from</td> 
     <td>160-bit address of a sender of a transaction</td> 
     <td>来自交易发送方的160位地址哈希</td> 
    </tr> 
    <tr> 
     <td>to</td> 
     <td>address of the recipient or null for a contract creation transaction</td> 
     <td>收件人的地址或者创建合约交易时为null</td> 
    </tr> 
    <tr> 
     <td>value</td> 
     <td>number of wei to be transfered to the recipient or newly created account (case of contract creation)</td> 
     <td>要转移给收件人或新创建帐户的wei数量（创建合约的情况）</td> 
    </tr> 
    <tr> 
     <td>gas</td> 
     <td>gas consumed by the transaction</td> 
     <td>交易消耗的天然气</td> 
    </tr> 
    <tr> 
     <td>gasPrice</td> 
     <td>number of Wei to be paid per unit of gas for all computatioon costs of this transaction</td> 
     <td>此交易所有计算成本的每单位天然气的支付数量</td> 
    </tr> 
    <tr> 
     <td>nonce</td> 
     <td>number of transactions/contract creations sent by the sender prior to this one</td> 
     <td>发送方在此之前发送的交易和创建合约的数量</td> 
    </tr> 
    <tr> 
     <td>v/r/s</td> 
     <td>used to identify the sender; the signature values of the transaction</td> 
     <td>用于识别发件人交易的签名值</td> 
    </tr> 
    <tr> 
     <td>input</td> 
     <td>the data sent along with the transaction</td> 
     <td>与交易一起发送的数据</td> 
    </tr> 
    <tr> 
     <td>transactionIndex</td> 
     <td>index of the transaction in the block</td> 
     <td>区块中交易的索引</td> 
    </tr> 
   </tbody>
  </table> 
  <p>最后，我们还可以查看交易收据：</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>web3.eth.getTransactionReceipt(<span class="hljs-string">'0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851'</span>)

AttributeDict({<span class="hljs-string">'blockHash'</span>: HexBytes(<span class="hljs-string">'0x44338e1f80302037c7213e8f56dd35d8a473b000319bc200f76e910e62d12f98'</span>),
 <span class="hljs-string">'blockNumber'</span>: <span class="hljs-number">5617795</span>,
 <span class="hljs-string">'contractAddress'</span>: <span class="hljs-keyword">None</span>,
 <span class="hljs-string">'cumulativeGasUsed'</span>: <span class="hljs-number">21004</span>,
 <span class="hljs-string">'from'</span>: <span class="hljs-string">'0xea6e3e41ebaa09d550d3c3f0d72971b3c5ccc261'</span>,
 <span class="hljs-string">'gasUsed'</span>: <span class="hljs-number">21004</span>,
 <span class="hljs-string">'logs'</span>: [],
 <span class="hljs-string">'logsBloom'</span>: HexBytes(<span class="hljs-string">'0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'</span>),
 <span class="hljs-string">'status'</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">'to'</span>: <span class="hljs-string">'0xd96a6e75d099ce529bbd257cbcb403224cceaebf'</span>,
 <span class="hljs-string">'transactionHash'</span>: HexBytes(<span class="hljs-string">'0x68c70c5ffe54a42ebf7118e7e931aeac018cee4656a816ffe6a01388da50c851'</span>),
 <span class="hljs-string">'transactionIndex'</span>: <span class="hljs-number">0</span>})</code></pre> 
  <p>交易收据包含一些重复和新条目，新的条目解释如下。</p> 
  <table> 
   <thead> 
    <tr> 
     <th>Receipt variable</th> 
     <th>Meaning</th> 
     <th>翻译</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>status</td> 
     <td>boolean whether the transaction was successfull; false if the EVM (Ethereum Virtual Machine) reverted the transaction</td> 
     <td>交易是否成功，如果EVM（以太坊虚拟机）还原了交易则返回false</td> 
    </tr> 
    <tr> 
     <td>contractAddress</td> 
     <td>the contract address created if the transaction was a contract creation; otherwise null</td> 
     <td>如果交易是合约创建，则创建的合同地址;否则为null</td> 
    </tr> 
    <tr> 
     <td>gasUsed</td> 
     <td>the total amount of gas used when this transaction was executed in the block</td> 
     <td>在区块中执行此交易时使用的总气体量</td> 
    </tr> 
    <tr> 
     <td>cumulativeGasUsed</td> 
     <td>the sum of gasUsed by this transaction and all preceding transactions in the same block</td> 
     <td>此交易使用的gasUse和同一块中所有先前交易的总和</td> 
    </tr> 
    <tr> 
     <td>logs</td> 
     <td>array of log objects which the transaction has generated</td> 
     <td>交易生成的日志对象数组</td> 
    </tr> 
   </tbody>
  </table> 
  <p>作为参考，除了黄皮书之外，我还包括各种额外资源来编制这些表格<a href="https://ethereum.stackexchange.com/questions/10548/what-does-every-field-in-block-means" rel="nofollow">2</a>,<a href="https://github.com/4c656554/BlockchainIllustrations/blob/master/Ethereum/EthBlockchain5.svg" rel="nofollow">3</a>,<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#gettransaction" rel="nofollow">4</a>,<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#gettransactionreceipt" rel="nofollow">5</a>。</p> 
  <p>如你所见，只需几个简单的命令，就可以连接到网络并获得有关原始格式的交易，区块或状态的基本信息。这将为这些数据打开一个新窗口！</p> 
  <h3 id="数据库管理系统">数据库管理系统</h3> 
  <p>当计划将数据写入适当的数据库时，你可能会意识到有许多针对Python爱好者的管理系统解决方案，例如无服务器SQLite，或基于服务器的MySQL，PostgreSQL或Hadoop。根据你的意图，必须确定哪个选项最适合你的项目。总的来说，我发现这些要点很有帮助：</p> 
  <ul> 
   <li>数据库的预期大小是什么（即可以在单个机器系统上处理）？</li> 
   <li>这些条目是经常编辑还是会保持不变？</li> 
   <li>数据库是否应该由多方/应用程序同时访问和编辑？</li> 
  </ul> 
  <p>随着时间的推移，以太坊区块链正在稳步增长，截止到2018年6月接近1TB，这个很小，因此对于像Hadoop这样的分布式处理系统来说并不是最佳选择。区块链数据库将被写入一次，然后仅使用新条目进行扩展，保留旧条目不变。此数据库的预期用例由一个通道编写，并由其他通道以只读方式访问，因此我们实际上不需要在服务器上运行它。在你的机器上本地保存数据库将导致快速读取，这对于像SQLite这样的无服务器管理系统是可取的和可实现的。Python有一个内置的库<code>sqlite3</code>，因此我们甚至不需要安装新的包。</p> 
  <h3 id="数据库设计">数据库设计</h3> 
  <p>下一步是设计数据库。请记住哪些数据字段与你的分析最相关，并且旨在优化搜索和存储。例如，如果你不打算使用<code>stateRoot</code>，则可能需要完全跳过它或将其保存在单独的表中。可以更快地搜索具有较少列的表，如果稍后意识到你实际上具有<code>stateRoot</code>的用例，你仍然可以访问它。你可能还希望将块信息与交易信息分开;如果不这样做，那么区块属性如<code>timestamp</code>将对区块中的所有交易重复N次，浪费大量空间。稍后使用<code>JOIN</code>操作可以轻松地将交易与其块属性进行匹配。</p> 
  <p>我设计的数据库包含3个表：</p> 
  <ul> 
   <li>Quick：最相关的交易信息，用于快速访问和分析。</li> 
   <li>TX：所有剩余的交易信息，</li> 
   <li>Block：指定区块的信息。</li> 
  </ul> 
  <p>变量的命名约定相对于原始的web3py略有改变，以消除歧义，例如将块哈希和交易哈希都称为“哈希”，或使用“from”/“to”作为列名，这在SQL有不同的含义，会使程序崩溃。</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/04/ethereum-python-sql/ethereum-python-sql-2.png" alt="" title=""></p> 
  <p>交易值，余额和其他大数字需要作为字符串存储在数据库中。原因是SQLite只能处理最多8字节存储的有符号整数，最大值为2的63次方-1大约是9223372036854775807.这通常远低于wei中的交易值（例如，1ETH = 10*18 wei）。</p> 
  <h3 id="构建你的迷你数据库">构建你的迷你数据库</h3> 
  <p>完整的代码可以在<a href="https://github.com/validitylabs/EthereumDB" rel="nofollow">GitHub</a>上找到。它将根据上层架构组织区块链信息，并输出包含预先指定数量的块数据的blockchain.db文件。要测试它，请转到<code>database.py</code>文件并为要写入的块数选择合理的数字，例如:</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">Nblocks </span>=<span class="hljs-string"> 10000</span></code></pre> 
  <p>默认情况下，你应该将web3对象指向Infura端点。 如果你有IPC提供商（即你的本地节点），也可以切换到IPC提供商，只需取消注释该行：</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># or connection via node on the VM </span>
<span class="hljs-preprocessor">#web3 = Web3(Web3.IPCProvider('/path-to-geth.ipc/'))</span></code></pre> 
  <p>修改路径，然后只需在命令行<code>python database.py</code>中运行。代码会将最后写入的块的编号转储到<code>lastblock.txt</code>文件中，以防你需要重新启动。</p> 
  <h3 id="如何使用数据库">如何使用数据库</h3> 
  <p>一旦将第一个条目写入数据库，就可以通过ipython shell开始与它进行通信。例如，要打印表“Quick”的前5行，你可以运行下面的代码。</p> 
  <pre class="prettyprint"><code class=" hljs sql">import sqlite3 as sq3
conn = sq3.connect("blockchain.db")
cur = conn.cursor()

# some SQL code, e.g. <span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-keyword">first</span> five entries <span class="hljs-keyword">of</span> the <span class="hljs-keyword">table</span> Quick cur.<span class="hljs-keyword">execute</span>(<span class="hljs-string">"SELECT * FROM Quick LIMIT 5"</span>) a = cur.fetchall() #list <span class="hljs-keyword">of</span> tuples containing <span class="hljs-keyword">all</span> elements <span class="hljs-keyword">of</span> the <span class="hljs-keyword">row</span> print(a) conn.<span class="hljs-keyword">close</span>()</span></code></pre> 
  <h3 id="本地节点与infura">本地节点与Infura</h3> 
  <p>如果要构建大型数据库，则应下载geth并同步节点。同步可以在3种基本模式下完成：</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/04/ethereum-python-sql/ethereum-python-sql-3.png" alt="" title=""></p> 
  <p>如果你不需要过去的帐户状态，则可以在快速模式下同步节点<a href="https://github.com/ethereum/go-ethereum/issues/16251" rel="nofollow">6</a>。</p> 
  <p>下面的图表显示了此代码写入数据库的速度，与本地完全同步的节点（IPC）与Infura（Infura）上的地址进行通信。正如你所看到的，在本地节点上运行此代码是值得的，因为你可以将速度提升近2个数量级（即100x）！</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/04/ethereum-python-sql/ethereum-python-sql-4.png" alt="" title=""></p> 
  <h3 id="总结">总结</h3> 
  <p>现在你已拥有自己的本地数据库，了解区块链上发生的事情，可以开始探索它。例如，你可以计算自其起源以来的交易数量，查看作为时间函数生成的地址数量——天空是你可以了解的有关区块链的限制。我们为你的数据科学游乐场奠定了基础。因此，请继续探讨，或查看下一篇文章，了解潜在的应用。</p> 
  <p>python用web3.py库开发以太坊来说非常的方便，有兴趣的用户可以关注我们的<a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=828blog" rel="nofollow">python以太坊教程</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</p> 
  <p>另外其他语言可以学习的以太坊教程如下： </p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=828blog" rel="nofollow">web3j教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=828blog" rel="nofollow">以太坊教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=828blog" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=828blog" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=828blog" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。</li> 
   </ul> 
  </blockquote> 
  <p>汇智网原创翻译，转载请标明出处。这里是<a href="http://blog.hubwiz.com/2018/09/04/ethereum-python-sql/" rel="nofollow">原文</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82414592,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82414592,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82414592,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82414592,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
