<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用EOSIO开发区块链DApp（二、智能合约） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用EOSIO开发区块链DApp（二、智能合约）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="这是一步步的用EOSIO开发区块链DApp的第二部分，这部分将主要是为EOSIO平台开发智能合约。 示例智能合约的目的是模拟选举。我创建了一个EOSIO用户来托管智能合约。创建了两个公民用户来投票给候选人。投票记录保存在EOSIO区块链中。在此示例中，所有操作都在命令模式下运行。让我们开始吧。 开发智能合约 EOSIO执行以WebAssembly标准开发的智能合约。所以我用C++开发了选举智能合约。以下是election.cpp的完整源代码： #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class election : public contract { private: // create the multi index tables to store the data /// @abi table struct candidate { uint64_t _key; // primary key std::string _name; // candidate name uint32_t _count = 0; // voted count uint64_t primary_key() const { return _key; } }; typedef eosio::multi_index&lt;N(candidate), candidate&gt; candidates; /// @abi table struct voter { uint64_t _key; uint64_t _candidate_key; // name of poll account_name _account; // this account has voted, avoid duplicate voter uint64_t primary_key() const { return _key; } uint64_t candidate_key() const { return _candidate_key; } }; typedef eosio::multi_index&lt;N(voter), voter, indexed_by&lt;N(_candidate_key), const_mem_fun&lt;voter, uint64_t, &amp;voter::candidate_key&gt;&gt;&gt; voters; // local instances of the multi indexes candidates _candidates; voters _voters; uint64_t _candidates_count; public: election(account_name s) : contract(s), _candidates(s, s), _voters(s, s), _candidates_count(0) {} // public methods exposed via the ABI // on candidates /// @abi action void version() { print(&quot;Election Smart Contract version 0.0.1\n&quot;); }; /// @abi action void addc(std::string name) { print(&quot;Adding candidate &quot;, name, &quot;\n&quot;); uint64_t key = _candidates.available_primary_key(); // update the table to include a new candidate _candidates.emplace(get_self(), [&amp;](auto &amp;p) { p._key = key; p._name = name; p._count = 0; }); print(&quot;Candidate added successfully. candidate_key = &quot;, key, &quot;\n&quot;); }; /// @abi action void reset() { // Get all keys of _candidates std::vector&lt;uint64_t&gt; keysForDeletion; for (auto &amp;itr : _candidates) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _candidates.find(key); if (itr != _candidates.end()) { _candidates.erase(itr); } } // Get all keys of _voters keysForDeletion.empty(); for (auto &amp;itr : _voters) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _voters.find(key); if (itr != _voters.end()) { _voters.erase(itr); } } print(&quot;candidates and voters reset successfully.\n&quot;); }; /// @abi action void results() { print(&quot;Start listing voted results\n&quot;); for (auto&amp; item : _candidates) { print(&quot;Candidate &quot;, item._name, &quot; has voted count: &quot;, item._count, &quot;\n&quot;); } }; /// @abi action void vote(account_name s, uint64_t candidate_key) { require_auth(s); bool found = false; // Did the voter vote before? for (auto&amp; item : _voters) { if (item._account == s) { found = true; break; } } eosio_assert(!found, &quot;You&#39;re voted already!&quot;); // Findout the candidate by id std::vector&lt;uint64_t&gt; keysForModify; for (auto&amp; item : _candidates) { if (item.primary_key() == candidate_key) { keysForModify.push_back(item.primary_key()); break; } } if (keysForModify.size() == 0) { eosio_assert(found, &quot;Invalid candidate id!&quot;); return; } // Update the voted count inside the candidate for (uint64_t key : keysForModify) { auto itr = _candidates.find(key); auto candidate = _candidates.get(key); if (itr != _candidates.end()) { _candidates.modify(itr, get_self(), [&amp;](auto&amp; p) { p._count++; }); print(&quot;Voted candidate: &quot;, candidate._name, &quot; successfully\n&quot;); } } // Add this user to voters array _voters.emplace(get_self(), [&amp;](auto&amp; p) { p._key = _voters.available_primary_key(); p._candidate_key = candidate_key; p._account = s; }); }; }; EOSIO_ABI(election, (version)(reset)(addc)(results)(vote)) 注意最后一行EOSIO_ABI()是一个宏语句，用于自动生成ABI文件而不是手动编写。ABI文件用于定义提交动作处理程序。这告诉了EOSIO智能合约中处理程序的定义。 EOSIO为我们提供了多索引数据库API，可以将数据保存到区块链中。在上面的选举智能合约中，我定义了两个multi_index（类似于SQL表）：候选人和选民。实际上是两个数组存储两个结构：候选者和选民。我使用C++ STL来操作multi_index，例如add，update，delete。 请注意，两个结构在开头标有/// @abi table。这是告诉EOSIO abi生成器在election.abi文件中生成ABI表。这很方便。 编译选举智能合约： $ eosiocpp -o election.wast election.cpp 分别生成WAST和WASM文件。但这对EOSIO来说还不够。我们还需要生成ABI文件： $ eosiocpp -g election.abi election.cpp Visual Studio Code的可选文件 为了增强开发体验，我为Visual Studio Code（VSCode）创建了一个属性文件c_cpp_properties.json，告诉它如何查找头文件。该文件需要存储在.vscode目录中，如下所示： .vscode/c_cpp_properties文件内容如下: { &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;~/eos/contracts&quot;, &quot;~/opt/boost/include&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/clang++-4.0&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; } ], &quot;version&quot;: 4 } 启动EOSIO 一直在使用配置良好的虚拟机（在第1部分中提到）。要启动单节点Testnet服务器： $ nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --access-control-allow-origin=* --contracts-console 单击此处获取nodeos参数的更多信息。 创建帐户 下一个任务是解锁默认钱包。EOSIO将密钥对存储在钱包中。每次服务器重启或每15分钟需要解锁一次。解锁钱包： $ cleos wallet unlock --password ${wallet_password} 我们需要分别创建一个所有者密钥对和活动密钥对。然后将该私钥导入钱包。键入以下命令： $ cleos create key # Create an owner key $ cleos create key # Create an active key $ cleos wallet import ${private_owner_key} $ cleos wallet import ${private_active_key} 不要忘记在某个地方记录这些密钥对。 接下来的任务是创建一个新的帐户来保存选举智能合约。 键入以下命令： $ cleos create account eosio election ${public_owner_key} ${public_active_key} 此外，为投票模拟创建两个公民： $ cleos create account eosio voter1 ${public_owner_key} ${public_active_key} $ cleos create account eosio voter2 ${public_owner_key} ${public_active_key} 部署智能合约 输入以下命令上传选举智能合约： $ cleos set contract election ../election -p election 结果类似下图： 运行智能合约 我们可以尝试运行合约。 1.运行version操作 $ cleos push action election version &#39;&#39; -p election 我们可以从nodeos检查控制台输出： 2.增加选举候选人 $ cleos push action election addc &#39;[&quot;Hillary Clinton&quot;]&#39; -p election $ cleos push action election addc &#39;[&quot;Donald J. Trump&quot;]&#39; -p election 3.显示存储在区块链中的候选数据库 $ cleos get table election election candidate 结果如图所示： 4.模拟投票（两位选民都被投票给唐纳德·J·特朗普） $ cleos push action election vote &#39;[&quot;voter1&quot;, 1]&#39; -p voter1 $ cleos push action election vote &#39;[&quot;voter2&quot;, 1]&#39; -p voter2 如果voter1再次投票： $ cleos push action election vote &#39;[&quot;voter1&quot;, 0]&#39; -p voter1 EOSIO 将返回一个例外: 5.查看投票结果 $ cleos get table election election candidate 如你所见，候选人“Donald J. Trump”的投票数为2.这意味着选举智能合约正在工作！ 这就是EOS开发dapp的第二部分。 在下一部分中，我将创建一个Web应用程序，用于演示Web访问者和区块链之间的交互。 源代码在这里github repo ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开" />
<meta property="og:description" content="这是一步步的用EOSIO开发区块链DApp的第二部分，这部分将主要是为EOSIO平台开发智能合约。 示例智能合约的目的是模拟选举。我创建了一个EOSIO用户来托管智能合约。创建了两个公民用户来投票给候选人。投票记录保存在EOSIO区块链中。在此示例中，所有操作都在命令模式下运行。让我们开始吧。 开发智能合约 EOSIO执行以WebAssembly标准开发的智能合约。所以我用C++开发了选举智能合约。以下是election.cpp的完整源代码： #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class election : public contract { private: // create the multi index tables to store the data /// @abi table struct candidate { uint64_t _key; // primary key std::string _name; // candidate name uint32_t _count = 0; // voted count uint64_t primary_key() const { return _key; } }; typedef eosio::multi_index&lt;N(candidate), candidate&gt; candidates; /// @abi table struct voter { uint64_t _key; uint64_t _candidate_key; // name of poll account_name _account; // this account has voted, avoid duplicate voter uint64_t primary_key() const { return _key; } uint64_t candidate_key() const { return _candidate_key; } }; typedef eosio::multi_index&lt;N(voter), voter, indexed_by&lt;N(_candidate_key), const_mem_fun&lt;voter, uint64_t, &amp;voter::candidate_key&gt;&gt;&gt; voters; // local instances of the multi indexes candidates _candidates; voters _voters; uint64_t _candidates_count; public: election(account_name s) : contract(s), _candidates(s, s), _voters(s, s), _candidates_count(0) {} // public methods exposed via the ABI // on candidates /// @abi action void version() { print(&quot;Election Smart Contract version 0.0.1\n&quot;); }; /// @abi action void addc(std::string name) { print(&quot;Adding candidate &quot;, name, &quot;\n&quot;); uint64_t key = _candidates.available_primary_key(); // update the table to include a new candidate _candidates.emplace(get_self(), [&amp;](auto &amp;p) { p._key = key; p._name = name; p._count = 0; }); print(&quot;Candidate added successfully. candidate_key = &quot;, key, &quot;\n&quot;); }; /// @abi action void reset() { // Get all keys of _candidates std::vector&lt;uint64_t&gt; keysForDeletion; for (auto &amp;itr : _candidates) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _candidates.find(key); if (itr != _candidates.end()) { _candidates.erase(itr); } } // Get all keys of _voters keysForDeletion.empty(); for (auto &amp;itr : _voters) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _voters.find(key); if (itr != _voters.end()) { _voters.erase(itr); } } print(&quot;candidates and voters reset successfully.\n&quot;); }; /// @abi action void results() { print(&quot;Start listing voted results\n&quot;); for (auto&amp; item : _candidates) { print(&quot;Candidate &quot;, item._name, &quot; has voted count: &quot;, item._count, &quot;\n&quot;); } }; /// @abi action void vote(account_name s, uint64_t candidate_key) { require_auth(s); bool found = false; // Did the voter vote before? for (auto&amp; item : _voters) { if (item._account == s) { found = true; break; } } eosio_assert(!found, &quot;You&#39;re voted already!&quot;); // Findout the candidate by id std::vector&lt;uint64_t&gt; keysForModify; for (auto&amp; item : _candidates) { if (item.primary_key() == candidate_key) { keysForModify.push_back(item.primary_key()); break; } } if (keysForModify.size() == 0) { eosio_assert(found, &quot;Invalid candidate id!&quot;); return; } // Update the voted count inside the candidate for (uint64_t key : keysForModify) { auto itr = _candidates.find(key); auto candidate = _candidates.get(key); if (itr != _candidates.end()) { _candidates.modify(itr, get_self(), [&amp;](auto&amp; p) { p._count++; }); print(&quot;Voted candidate: &quot;, candidate._name, &quot; successfully\n&quot;); } } // Add this user to voters array _voters.emplace(get_self(), [&amp;](auto&amp; p) { p._key = _voters.available_primary_key(); p._candidate_key = candidate_key; p._account = s; }); }; }; EOSIO_ABI(election, (version)(reset)(addc)(results)(vote)) 注意最后一行EOSIO_ABI()是一个宏语句，用于自动生成ABI文件而不是手动编写。ABI文件用于定义提交动作处理程序。这告诉了EOSIO智能合约中处理程序的定义。 EOSIO为我们提供了多索引数据库API，可以将数据保存到区块链中。在上面的选举智能合约中，我定义了两个multi_index（类似于SQL表）：候选人和选民。实际上是两个数组存储两个结构：候选者和选民。我使用C++ STL来操作multi_index，例如add，update，delete。 请注意，两个结构在开头标有/// @abi table。这是告诉EOSIO abi生成器在election.abi文件中生成ABI表。这很方便。 编译选举智能合约： $ eosiocpp -o election.wast election.cpp 分别生成WAST和WASM文件。但这对EOSIO来说还不够。我们还需要生成ABI文件： $ eosiocpp -g election.abi election.cpp Visual Studio Code的可选文件 为了增强开发体验，我为Visual Studio Code（VSCode）创建了一个属性文件c_cpp_properties.json，告诉它如何查找头文件。该文件需要存储在.vscode目录中，如下所示： .vscode/c_cpp_properties文件内容如下: { &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;~/eos/contracts&quot;, &quot;~/opt/boost/include&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/clang++-4.0&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; } ], &quot;version&quot;: 4 } 启动EOSIO 一直在使用配置良好的虚拟机（在第1部分中提到）。要启动单节点Testnet服务器： $ nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --access-control-allow-origin=* --contracts-console 单击此处获取nodeos参数的更多信息。 创建帐户 下一个任务是解锁默认钱包。EOSIO将密钥对存储在钱包中。每次服务器重启或每15分钟需要解锁一次。解锁钱包： $ cleos wallet unlock --password ${wallet_password} 我们需要分别创建一个所有者密钥对和活动密钥对。然后将该私钥导入钱包。键入以下命令： $ cleos create key # Create an owner key $ cleos create key # Create an active key $ cleos wallet import ${private_owner_key} $ cleos wallet import ${private_active_key} 不要忘记在某个地方记录这些密钥对。 接下来的任务是创建一个新的帐户来保存选举智能合约。 键入以下命令： $ cleos create account eosio election ${public_owner_key} ${public_active_key} 此外，为投票模拟创建两个公民： $ cleos create account eosio voter1 ${public_owner_key} ${public_active_key} $ cleos create account eosio voter2 ${public_owner_key} ${public_active_key} 部署智能合约 输入以下命令上传选举智能合约： $ cleos set contract election ../election -p election 结果类似下图： 运行智能合约 我们可以尝试运行合约。 1.运行version操作 $ cleos push action election version &#39;&#39; -p election 我们可以从nodeos检查控制台输出： 2.增加选举候选人 $ cleos push action election addc &#39;[&quot;Hillary Clinton&quot;]&#39; -p election $ cleos push action election addc &#39;[&quot;Donald J. Trump&quot;]&#39; -p election 3.显示存储在区块链中的候选数据库 $ cleos get table election election candidate 结果如图所示： 4.模拟投票（两位选民都被投票给唐纳德·J·特朗普） $ cleos push action election vote &#39;[&quot;voter1&quot;, 1]&#39; -p voter1 $ cleos push action election vote &#39;[&quot;voter2&quot;, 1]&#39; -p voter2 如果voter1再次投票： $ cleos push action election vote &#39;[&quot;voter1&quot;, 0]&#39; -p voter1 EOSIO 将返回一个例外: 5.查看投票结果 $ cleos get table election election candidate 如你所见，候选人“Donald J. Trump”的投票数为2.这意味着选举智能合约正在工作！ 这就是EOS开发dapp的第二部分。 在下一部分中，我将创建一个Web应用程序，用于演示Web访问者和区块链之间的交互。 源代码在这里github repo ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/09/09/bf4d9f51918137d7d4dad9aeb79c5496.html" />
<meta property="og:url" content="https://mlh.app/2018/09/09/bf4d9f51918137d7d4dad9aeb79c5496.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"这是一步步的用EOSIO开发区块链DApp的第二部分，这部分将主要是为EOSIO平台开发智能合约。 示例智能合约的目的是模拟选举。我创建了一个EOSIO用户来托管智能合约。创建了两个公民用户来投票给候选人。投票记录保存在EOSIO区块链中。在此示例中，所有操作都在命令模式下运行。让我们开始吧。 开发智能合约 EOSIO执行以WebAssembly标准开发的智能合约。所以我用C++开发了选举智能合约。以下是election.cpp的完整源代码： #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class election : public contract { private: // create the multi index tables to store the data /// @abi table struct candidate { uint64_t _key; // primary key std::string _name; // candidate name uint32_t _count = 0; // voted count uint64_t primary_key() const { return _key; } }; typedef eosio::multi_index&lt;N(candidate), candidate&gt; candidates; /// @abi table struct voter { uint64_t _key; uint64_t _candidate_key; // name of poll account_name _account; // this account has voted, avoid duplicate voter uint64_t primary_key() const { return _key; } uint64_t candidate_key() const { return _candidate_key; } }; typedef eosio::multi_index&lt;N(voter), voter, indexed_by&lt;N(_candidate_key), const_mem_fun&lt;voter, uint64_t, &amp;voter::candidate_key&gt;&gt;&gt; voters; // local instances of the multi indexes candidates _candidates; voters _voters; uint64_t _candidates_count; public: election(account_name s) : contract(s), _candidates(s, s), _voters(s, s), _candidates_count(0) {} // public methods exposed via the ABI // on candidates /// @abi action void version() { print(&quot;Election Smart Contract version 0.0.1\\n&quot;); }; /// @abi action void addc(std::string name) { print(&quot;Adding candidate &quot;, name, &quot;\\n&quot;); uint64_t key = _candidates.available_primary_key(); // update the table to include a new candidate _candidates.emplace(get_self(), [&amp;](auto &amp;p) { p._key = key; p._name = name; p._count = 0; }); print(&quot;Candidate added successfully. candidate_key = &quot;, key, &quot;\\n&quot;); }; /// @abi action void reset() { // Get all keys of _candidates std::vector&lt;uint64_t&gt; keysForDeletion; for (auto &amp;itr : _candidates) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _candidates.find(key); if (itr != _candidates.end()) { _candidates.erase(itr); } } // Get all keys of _voters keysForDeletion.empty(); for (auto &amp;itr : _voters) { keysForDeletion.push_back(itr.primary_key()); } // now delete each item for that poll for (uint64_t key : keysForDeletion) { auto itr = _voters.find(key); if (itr != _voters.end()) { _voters.erase(itr); } } print(&quot;candidates and voters reset successfully.\\n&quot;); }; /// @abi action void results() { print(&quot;Start listing voted results\\n&quot;); for (auto&amp; item : _candidates) { print(&quot;Candidate &quot;, item._name, &quot; has voted count: &quot;, item._count, &quot;\\n&quot;); } }; /// @abi action void vote(account_name s, uint64_t candidate_key) { require_auth(s); bool found = false; // Did the voter vote before? for (auto&amp; item : _voters) { if (item._account == s) { found = true; break; } } eosio_assert(!found, &quot;You&#39;re voted already!&quot;); // Findout the candidate by id std::vector&lt;uint64_t&gt; keysForModify; for (auto&amp; item : _candidates) { if (item.primary_key() == candidate_key) { keysForModify.push_back(item.primary_key()); break; } } if (keysForModify.size() == 0) { eosio_assert(found, &quot;Invalid candidate id!&quot;); return; } // Update the voted count inside the candidate for (uint64_t key : keysForModify) { auto itr = _candidates.find(key); auto candidate = _candidates.get(key); if (itr != _candidates.end()) { _candidates.modify(itr, get_self(), [&amp;](auto&amp; p) { p._count++; }); print(&quot;Voted candidate: &quot;, candidate._name, &quot; successfully\\n&quot;); } } // Add this user to voters array _voters.emplace(get_self(), [&amp;](auto&amp; p) { p._key = _voters.available_primary_key(); p._candidate_key = candidate_key; p._account = s; }); }; }; EOSIO_ABI(election, (version)(reset)(addc)(results)(vote)) 注意最后一行EOSIO_ABI()是一个宏语句，用于自动生成ABI文件而不是手动编写。ABI文件用于定义提交动作处理程序。这告诉了EOSIO智能合约中处理程序的定义。 EOSIO为我们提供了多索引数据库API，可以将数据保存到区块链中。在上面的选举智能合约中，我定义了两个multi_index（类似于SQL表）：候选人和选民。实际上是两个数组存储两个结构：候选者和选民。我使用C++ STL来操作multi_index，例如add，update，delete。 请注意，两个结构在开头标有/// @abi table。这是告诉EOSIO abi生成器在election.abi文件中生成ABI表。这很方便。 编译选举智能合约： $ eosiocpp -o election.wast election.cpp 分别生成WAST和WASM文件。但这对EOSIO来说还不够。我们还需要生成ABI文件： $ eosiocpp -g election.abi election.cpp Visual Studio Code的可选文件 为了增强开发体验，我为Visual Studio Code（VSCode）创建了一个属性文件c_cpp_properties.json，告诉它如何查找头文件。该文件需要存储在.vscode目录中，如下所示： .vscode/c_cpp_properties文件内容如下: { &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;~/eos/contracts&quot;, &quot;~/opt/boost/include&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/clang++-4.0&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; } ], &quot;version&quot;: 4 } 启动EOSIO 一直在使用配置良好的虚拟机（在第1部分中提到）。要启动单节点Testnet服务器： $ nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --access-control-allow-origin=* --contracts-console 单击此处获取nodeos参数的更多信息。 创建帐户 下一个任务是解锁默认钱包。EOSIO将密钥对存储在钱包中。每次服务器重启或每15分钟需要解锁一次。解锁钱包： $ cleos wallet unlock --password ${wallet_password} 我们需要分别创建一个所有者密钥对和活动密钥对。然后将该私钥导入钱包。键入以下命令： $ cleos create key # Create an owner key $ cleos create key # Create an active key $ cleos wallet import ${private_owner_key} $ cleos wallet import ${private_active_key} 不要忘记在某个地方记录这些密钥对。 接下来的任务是创建一个新的帐户来保存选举智能合约。 键入以下命令： $ cleos create account eosio election ${public_owner_key} ${public_active_key} 此外，为投票模拟创建两个公民： $ cleos create account eosio voter1 ${public_owner_key} ${public_active_key} $ cleos create account eosio voter2 ${public_owner_key} ${public_active_key} 部署智能合约 输入以下命令上传选举智能合约： $ cleos set contract election ../election -p election 结果类似下图： 运行智能合约 我们可以尝试运行合约。 1.运行version操作 $ cleos push action election version &#39;&#39; -p election 我们可以从nodeos检查控制台输出： 2.增加选举候选人 $ cleos push action election addc &#39;[&quot;Hillary Clinton&quot;]&#39; -p election $ cleos push action election addc &#39;[&quot;Donald J. Trump&quot;]&#39; -p election 3.显示存储在区块链中的候选数据库 $ cleos get table election election candidate 结果如图所示： 4.模拟投票（两位选民都被投票给唐纳德·J·特朗普） $ cleos push action election vote &#39;[&quot;voter1&quot;, 1]&#39; -p voter1 $ cleos push action election vote &#39;[&quot;voter2&quot;, 1]&#39; -p voter2 如果voter1再次投票： $ cleos push action election vote &#39;[&quot;voter1&quot;, 0]&#39; -p voter1 EOSIO 将返回一个例外: 5.查看投票结果 $ cleos get table election election candidate 如你所见，候选人“Donald J. Trump”的投票数为2.这意味着选举智能合约正在工作！ 这就是EOS开发dapp的第二部分。 在下一部分中，我将创建一个Web应用程序，用于演示Web访问者和区块链之间的交互。 源代码在这里github repo ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/09/09/bf4d9f51918137d7d4dad9aeb79c5496.html","headline":"用EOSIO开发区块链DApp（二、智能合约）","dateModified":"2018-09-09T00:00:00+08:00","datePublished":"2018-09-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/09/09/bf4d9f51918137d7d4dad9aeb79c5496.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用EOSIO开发区块链DApp（二、智能合约）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>这是<a href="http://blog.hubwiz.com/2018/09/07/EOS-dapp-StepbyStep/" rel="nofollow">一步步的用EOSIO开发区块链DApp</a>的第二部分，这部分将主要是为EOSIO平台开发智能合约。</p> 
  <p>示例智能合约的目的是模拟选举。我创建了一个EOSIO用户来托管智能合约。创建了两个公民用户来投票给候选人。投票记录保存在EOSIO区块链中。在此示例中，所有操作都在命令模式下运行。让我们开始吧。</p> 
  <h3 id="开发智能合约">开发智能合约</h3> 
  <p>EOSIO执行以WebAssembly标准开发的智能合约。所以我用C++开发了选举智能合约。以下是<code>election.cpp</code>的完整源代码：</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;eosiolib/eosio.hpp&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;

<span class="hljs-keyword">class</span> election : <span class="hljs-keyword">public</span> contract
{
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// create the multi index tables to store the data</span>

  <span class="hljs-comment">/// @abi table</span>
  <span class="hljs-keyword">struct</span> candidate {
    uint64_t _key;       <span class="hljs-comment">// primary key</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _name;   <span class="hljs-comment">// candidate name</span>
    uint32_t _count = <span class="hljs-number">0</span>; <span class="hljs-comment">// voted count</span>

    uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _key; }
  };
  <span class="hljs-keyword">typedef</span> eosio::multi_index&lt;N(candidate), candidate&gt; candidates;

  <span class="hljs-comment">/// @abi table</span>
  <span class="hljs-keyword">struct</span> voter {
    uint64_t _key;
    uint64_t _candidate_key; <span class="hljs-comment">// name of poll</span>
    account_name _account;   <span class="hljs-comment">// this account has voted, avoid duplicate voter</span>

    uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _key; }
    uint64_t candidate_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _candidate_key; }
  };
  <span class="hljs-keyword">typedef</span> eosio::multi_index&lt;N(voter), voter, indexed_by&lt;N(_candidate_key), const_mem_fun&lt;voter, uint64_t, &amp;voter::candidate_key&gt;&gt;&gt; voters;

  <span class="hljs-comment">// local instances of the multi indexes</span>
  candidates _candidates;
  voters _voters;
  uint64_t _candidates_count;

<span class="hljs-keyword">public</span>:
  election(account_name s) : contract(s), _candidates(s, s), _voters(s, s), _candidates_count(<span class="hljs-number">0</span>) {}

  <span class="hljs-comment">// public methods exposed via the ABI</span>
  <span class="hljs-comment">// on candidates</span>

  <span class="hljs-comment">/// @abi action</span>
  <span class="hljs-keyword">void</span> version() {
    print(<span class="hljs-string">"Election Smart Contract version 0.0.1\n"</span>);
  };

  <span class="hljs-comment">/// @abi action</span>
  <span class="hljs-keyword">void</span> addc(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name) {
    print(<span class="hljs-string">"Adding candidate "</span>, name, <span class="hljs-string">"\n"</span>);

    uint64_t key = _candidates.available_primary_key();

    <span class="hljs-comment">// update the table to include a new candidate</span>
    _candidates.emplace(get_self(), [&amp;](<span class="hljs-keyword">auto</span> &amp;p) {
      p._key = key;
      p._name = name;
      p._count = <span class="hljs-number">0</span>;
    });

    print(<span class="hljs-string">"Candidate added successfully. candidate_key = "</span>, key, <span class="hljs-string">"\n"</span>);
  };

  <span class="hljs-comment">/// @abi action</span>
  <span class="hljs-keyword">void</span> reset() {
    <span class="hljs-comment">// Get all keys of _candidates</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForDeletion;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;itr : _candidates) {
      keysForDeletion.push_back(itr.primary_key());
    }

    <span class="hljs-comment">// now delete each item for that poll</span>
    <span class="hljs-keyword">for</span> (uint64_t key : keysForDeletion) {
      <span class="hljs-keyword">auto</span> itr = _candidates.find(key);
      <span class="hljs-keyword">if</span> (itr != _candidates.end()) {
        _candidates.erase(itr);
      }
    }

    <span class="hljs-comment">// Get all keys of _voters</span>
    keysForDeletion.empty();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;itr : _voters) {
      keysForDeletion.push_back(itr.primary_key());
    }

    <span class="hljs-comment">// now delete each item for that poll</span>
    <span class="hljs-keyword">for</span> (uint64_t key : keysForDeletion) {
      <span class="hljs-keyword">auto</span> itr = _voters.find(key);
      <span class="hljs-keyword">if</span> (itr != _voters.end()) {
        _voters.erase(itr);
      }
    }

    print(<span class="hljs-string">"candidates and voters reset successfully.\n"</span>);
  };

  <span class="hljs-comment">/// @abi action</span>
  <span class="hljs-keyword">void</span> results() {
    print(<span class="hljs-string">"Start listing voted results\n"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : _candidates) {
      print(<span class="hljs-string">"Candidate "</span>, item._name, <span class="hljs-string">" has voted count: "</span>, item._count, <span class="hljs-string">"\n"</span>);
    }
  };

  <span class="hljs-comment">/// @abi action</span>
  <span class="hljs-keyword">void</span> vote(account_name s, uint64_t candidate_key) {
    require_auth(s);

    <span class="hljs-keyword">bool</span> found = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// Did the voter vote before?</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : _voters) {
      <span class="hljs-keyword">if</span> (item._account == s) {
        found = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">break</span>;
      }
    }
    eosio_assert(!found, <span class="hljs-string">"You're voted already!"</span>);

    <span class="hljs-comment">// Findout the candidate by id</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForModify;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : _candidates) {
      <span class="hljs-keyword">if</span> (item.primary_key() == candidate_key) {
        keysForModify.push_back(item.primary_key());
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">if</span> (keysForModify.size() == <span class="hljs-number">0</span>) {
      eosio_assert(found, <span class="hljs-string">"Invalid candidate id!"</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Update the voted count inside the candidate</span>
    <span class="hljs-keyword">for</span> (uint64_t key : keysForModify) {
      <span class="hljs-keyword">auto</span> itr = _candidates.find(key);
      <span class="hljs-keyword">auto</span> candidate = _candidates.get(key);
      <span class="hljs-keyword">if</span> (itr != _candidates.end()) {
        _candidates.modify(itr, get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p) {
          p._count++;
        });

        print(<span class="hljs-string">"Voted candidate: "</span>, candidate._name, <span class="hljs-string">" successfully\n"</span>);
      }
    }

    <span class="hljs-comment">// Add this user to voters array</span>
    _voters.emplace(get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p) {
      p._key = _voters.available_primary_key();
      p._candidate_key = candidate_key;
      p._account = s;
    });
  };
};

EOSIO_ABI(election, (version)(reset)(addc)(results)(vote))</code></pre> 
  <p>注意最后一行<code>EOSIO_ABI()</code>是一个宏语句，用于自动生成ABI文件而不是手动编写。ABI文件用于定义提交动作处理程序。这告诉了EOSIO智能合约中处理程序的定义。</p> 
  <p>EOSIO为我们提供了多索引数据库API，可以将数据保存到区块链中。在上面的选举智能合约中，我定义了两个<code>multi_index</code>（类似于SQL表）：候选人和选民。实际上是两个数组存储两个结构：候选者和选民。我使用C++ STL来操作<code>multi_index</code>，例如<code>add</code>，<code>update</code>，<code>delete</code>。</p> 
  <p>请注意，两个结构在开头标有<code>/// @abi table</code>。这是告诉EOSIO abi生成器在<code>election.abi</code>文件中生成ABI表。这很方便。</p> 
  <p>编译选举智能合约：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">$ eosiocpp -o election<span class="hljs-preprocessor">.wast</span> election<span class="hljs-preprocessor">.cpp</span></code></pre> 
  <p>分别生成WAST和WASM文件。但这对EOSIO来说还不够。我们还需要生成ABI文件：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">$ eosiocpp -g election<span class="hljs-preprocessor">.abi</span> election<span class="hljs-preprocessor">.cpp</span></code></pre> 
  <h3 id="visual-studio-code的可选文件">Visual Studio Code的可选文件</h3> 
  <p>为了增强开发体验，我为Visual Studio Code（VSCode）创建了一个属性文件<code>c_cpp_properties.json</code>，告诉它如何查找头文件。该文件需要存储在<code>.vscode</code>目录中，如下所示：</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr_001.png" alt="" title=""></p> 
  <p><code>.vscode/c_cpp_properties</code>文件内容如下:</p> 
  <pre class="prettyprint"><code class=" hljs json">{
  "<span class="hljs-attribute">configurations</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"Linux"</span></span>, "<span class="hljs-attribute">includePath</span>": <span class="hljs-value">[ <span class="hljs-string">"${workspaceFolder}/**"</span>, <span class="hljs-string">"~/eos/contracts"</span>, <span class="hljs-string">"~/opt/boost/include"</span> ]</span>, "<span class="hljs-attribute">defines</span>": <span class="hljs-value">[]</span>, "<span class="hljs-attribute">compilerPath</span>": <span class="hljs-value"><span class="hljs-string">"/usr/bin/clang++-4.0"</span></span>, "<span class="hljs-attribute">cStandard</span>": <span class="hljs-value"><span class="hljs-string">"c11"</span></span>, "<span class="hljs-attribute">cppStandard</span>": <span class="hljs-value"><span class="hljs-string">"c++17"</span></span>, "<span class="hljs-attribute">intelliSenseMode</span>": <span class="hljs-value"><span class="hljs-string">"clang-x64"</span> </span>} ]</span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-number">4</span> </span>}</code></pre> 
  <h3 id="启动eosio">启动EOSIO</h3> 
  <p>一直在使用配置良好的虚拟机（在第1部分中提到）。要启动单节点Testnet服务器：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ nodeos <span class="hljs-attribute">-e</span> <span class="hljs-attribute">-p</span> eosio <span class="hljs-subst">--</span>plugin eosio<span class="hljs-tag">::wallet_api_plugin</span> <span class="hljs-subst">--</span>plugin eosio<span class="hljs-tag">::chain_api_plugin</span> <span class="hljs-subst">--</span>plugin eosio<span class="hljs-tag">::history_api_plugin</span> <span class="hljs-subst">--</span>access<span class="hljs-attribute">-control</span><span class="hljs-attribute">-allow</span><span class="hljs-attribute">-origin</span><span class="hljs-subst">=*</span> <span class="hljs-subst">--</span>contracts<span class="hljs-attribute">-console</span></code></pre> 
  <p>单击此处获取<a href="https://developers.eos.io/eosio-nodeos/docs/configuration-file" rel="nofollow">nodeos参数</a>的更多信息。</p> 
  <h3 id="创建帐户">创建帐户</h3> 
  <p>下一个任务是解锁默认钱包。EOSIO将密钥对存储在钱包中。每次服务器重启或每15分钟需要解锁一次。解锁钱包：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos wallet unlock --password <span class="hljs-variable">${</span>wallet_password}</code></pre> 
  <p>我们需要分别创建一个所有者密钥对和活动密钥对。然后将该私钥导入钱包。键入以下命令：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos create key <span class="hljs-comment"># Create an owner key</span>
<span class="hljs-variable">$ </span>cleos create key <span class="hljs-comment"># Create an active key</span>
<span class="hljs-variable">$ </span>cleos wallet import <span class="hljs-variable">${</span>private_owner_key}
<span class="hljs-variable">$ </span>cleos wallet import <span class="hljs-variable">${</span>private_active_key}</code></pre> 
  <p><strong>不要忘记在某个地方记录这些密钥对。</strong></p> 
  <p>接下来的任务是创建一个新的帐户来保存选举智能合约。 键入以下命令：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos create account eosio election <span class="hljs-variable">${</span>public_owner_key} <span class="hljs-variable">${</span>public_active_key}</code></pre> 
  <p>此外，为投票模拟创建两个公民：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos create account eosio voter1 <span class="hljs-variable">${</span>public_owner_key} <span class="hljs-variable">${</span>public_active_key}
<span class="hljs-variable">$ </span>cleos create account eosio voter2 <span class="hljs-variable">${</span>public_owner_key} <span class="hljs-variable">${</span>public_active_key}</code></pre> 
  <h3 id="部署智能合约">部署智能合约</h3> 
  <p>输入以下命令上传选举智能合约：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">$ cleos <span class="hljs-built_in">set</span> contract election <span class="hljs-built_in">..</span>/election <span class="hljs-attribute">-p</span> election</code></pre> 
  <p>结果类似下图：</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr01.png" alt="" title=""></p> 
  <h3 id="运行智能合约">运行智能合约</h3> 
  <p>我们可以尝试运行合约。</p> 
  <p>1.运行<code>version</code>操作</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos push action election version <span class="hljs-string">''</span> -p election</code></pre> 
  <p>我们可以从nodeos检查控制台输出：</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr02.png" alt="" title=""></p> 
  <p>2.增加选举候选人</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos push action election addc <span class="hljs-string">'["Hillary Clinton"]'</span> -p election
<span class="hljs-variable">$ </span>cleos push action election addc <span class="hljs-string">'["Donald J. Trump"]'</span> -p election</code></pre> 
  <p>3.显示存储在区块链中的候选数据库</p> 
  <pre class="prettyprint"><code class=" hljs cs">$ cleos <span class="hljs-keyword">get</span> table election election candidate</code></pre> 
  <p>结果如图所示：</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr03.png" alt="" title=""></p> 
  <p>4.模拟投票（两位选民都被投票给唐纳德·J·特朗普）</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos push action election vote <span class="hljs-string">'["voter1", 1]'</span> -p voter1
<span class="hljs-variable">$ </span>cleos push action election vote <span class="hljs-string">'["voter2", 1]'</span> -p voter2</code></pre> 
  <p>如果voter1再次投票：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>cleos push action election vote <span class="hljs-string">'["voter1", 0]'</span> -p voter1</code></pre> 
  <p>EOSIO 将返回一个例外:</p> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr04.png" alt="" title=""></p> 
  <p>5.查看投票结果</p> 
  <pre class="prettyprint"><code class=" hljs cs">$ cleos <span class="hljs-keyword">get</span> table election election candidate</code></pre> 
  <p><img src="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/scr05.png" alt="" title=""></p> 
  <p>如你所见，候选人“Donald J. Trump”的投票数为2.这意味着选举智能合约正在工作！</p> 
  <p>这就是EOS开发dapp的第二部分。</p> 
  <p>在下一部分中，我将创建一个Web应用程序，用于演示Web访问者和区块链之间的交互。</p> 
  <p>源代码在这里<a href="https://github.com/simonho288/eosio-demo1-election" rel="nofollow">github repo</a></p> 
  <p>======================================================================</p> 
  <p>分享一个交互式的在线编程实战，<strong>EOS智能合约与DApp开发入门</strong>：</p> 
  <p><a href="http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=910csdn" rel="nofollow">EOS教程</a></p> 
  <p>本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=910csdn" rel="nofollow">web3j教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=910csdn" rel="nofollow">以太坊教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=910csdn" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=910csdn" rel="nofollow">python以太坊</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=910csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=910csdn" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。</li> 
   </ul> 
  </blockquote> 
  <p>汇智网原创翻译，转载请标明出处。这里是<a href="http://blog.hubwiz.com/2018/09/08/EOS-dapp-StepbyStep-2/" rel="nofollow">原文</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8e8a9d81f4.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82562044,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82562044,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82562044,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/82562044,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
