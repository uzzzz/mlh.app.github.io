<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链中的技术 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链中的技术" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="应用技术 一、算法加密 二、点对点通信技术（Peer to Peer） 三、分布式共识技术 3.1 共识一致性算法 3.1.1 Paxos 3.1.2 Raft 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） 3.1.4 POW （Proof of work 工作量证明） 3.1.5 POS （Proof of Stake 股权证明） 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 3.1.7 共识 四、分叉 4.1 硬分叉（hard-fork） 4.2 软分叉 4.3 软硬分叉的优缺点 4.4 向前兼容（forward compatible） 五、换个角度看区块链技术 应用技术 一、算法加密 比特币采用椭圆曲线加密算法（ECC）来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 比特币还用到哈希算法，Hash，就是把任意长度的输入通过散列算法变换成固定长度的数据信息摘要的函数。 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 二、点对点通信技术（Peer to Peer） 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 三、分布式共识技术 理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 （FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！） 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 3.1 共识一致性算法 3.1.1 Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 3.1.2 Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a) Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b) Follower: 类似选民，完全被动； c) Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。 3.1.4 POW （Proof of work 工作量证明） POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。 由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。 3.1.5 POS （Proof of Stake 股权证明） POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。 POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 以这些技术为基础，区块链实现了它去中心化的本质特征。 通过非对称密码技术，实现了区块链的历史可信； 通过点对点通信，实现了区块链网络的不可停止； 通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上。 3.1.7 共识 第一个概念,叫做 consensus,中文叫做共识,就是大家对一个事件,都 同意,不光是发生了事件 A 和 B,而且事件 A 先于事件 B 的顺序,都一致认同。 第二个概念,叫做 consensus finality,就是终极共识,意思就是我们在做 下一个决定之前,现有这个决定必须是终极的,不能改变的。 四、分叉 比特币采取的 pow,原理就是在进行哈希碰撞, 那么在这个过程中,基本上会出现几个人同一时间,达到哈希碰撞的结果。那么 pow 其实是没有终结共识的,一旦出现共识分叉,比特币原则是最长链获胜。 那么短的分叉,就会被放弃。但是在理论上,如果有一帮人,决定就是将这个短 分叉持续下去,那么真正的两条链就分出来了,当然事实上大家没有这样做。 软硬分叉涉及到的问题是去中心的化的节点软件、协议、版本升级的问题（软硬分叉都是由于软件升级导致的问题，而不是共识分歧导致的）。 一开始，所有的节点运行同样的软件，遵循着同样的共识协议，维护着同样的一条链（blockchain）。这时，一部分节点升级到了新版本的软件，拥有了新的共识协议，这时会出现下面四种情况： 新节点认为老节点发出的区块/交易合法； 新节点认为老节点发出的区块/交易不合法； 老节点认为新节点发出的区块/交易合法（没察觉变化）； 老节点认为新节点发出的区块/交易不合法（察觉出了变化）； 注意：不合法会分为所有交易都不合法和部分交易不合法。这里为了简化模型，把有部分交易不合法的都归为交易不合法。 实际情况是上面4种情况的组合，除此以外，我们还要增加一个维度，就是新节点和老节点的算力比，又分为下面两种类型： 新节点算力&gt;50%； 新节点算力&lt;50%； 注意，我们目前在网站上看到的各种关于软硬分叉的资料，都是基于新节点算力&gt;50%的情况下讨论的。这里我们也只讨论新节点算力&gt;50%。要注意，另一种情况下，即新节点算力&lt;50%，情况会完全不一样。 软分叉是一个后来才出现的词，之前并没有。我们首先来讲一下什么是硬分叉（hard-fork）。 4.1 硬分叉（hard-fork） 硬分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，老节点无法接受新节点挖出的全部或部分区块（认为不合法），导致同时出现两条链。尽管新节点算力较大，比如99%的算力为新节点，1%的老节点依然会维护着不同的一条链，因为新节点产生的区块老节点实在是无法接受（尽管它知道网络上99%的节点都接受了），这称为硬分叉。 注意：以上情况基于新节点算力&gt;50%。 当必须硬分叉时，我们需要要求所有节点同时升级软件，未升级的节点将不能正常工作。如果有较多老节点不愿意升级，他们将工作在另外一条完全不一样的链上。 硬分叉产生的原因：新的节点要求比老的节点要宽松很多。 4.2 软分叉 软分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，新节点无法接受老节点挖出的全部或部分区块（认为不合法）。因为新节点算力较大，老节点挖出的区块将没有机会得到认可，新老双方从始至终都工作在同一条链上，这称为软分叉。 注意：以上情况基于新节点算力&gt;50%。 软分叉产生的原因：新的节点要求比老的节点要严格很多。 4.3 软硬分叉的优缺点 上面的定义可以看出软硬分叉有各自的优缺点，首先软分叉和硬分叉相比拥有下面的优点： 软分叉总是只有一条链，没有分成两条链的风险； 软分叉不要求所有节点同一时间升级，允许逐步升级，且并不影响软分叉过程中的系统稳定性和有效性； 但软分叉也有缺点： 软分叉的前提是老的节点总是能够接受新节点的区块，这就要求把系统设计成向前兼容（forward compatible）； 软分叉总是建立在对老节点进行欺骗的基础上，它让老节点没有察觉实际上已经发生的变化，某种程度上违背了单点完整验证的原则； 4.4 向前兼容（forward compatible） 向前兼容是非常有意思的术语，它不同于我们通常说的软件设计中向后兼容（backward compatible）的方式。它要求对于新可能出现的区块形态、共识机制有个预先的判断，并在老的系统中留有余地或后门。当新的节点被部署时，老的节点能够接受新节点所产生的区块。 那么，比特币里是如何实现向前兼容的？ 答案是：非标准交易（non-standard transaction）。 比特币中设定了如下规则： 将所有交易分类为：标准交易、非标准交易和非法（invalid）三种； 如果发现非法交易，一律拒绝，如果该非法交易在某个区块中，则拒绝整个区块； 在标准配置下，所有节点对非标准交易采取以下态度： a. 不转发 b. 不接受 c.不打包 对于已经进入区块的非标准交易采取以下态度： 接受该区块； 对区块中的所有交易，包含该非标准交易按既有规则进行验证； 五、换个角度看区块链技术 瑞波在做汇兑的时候，用银关概念接入法币资产，还可以接入比特币和以太币，显示了瑞波银关的优势。但是瑞波缺乏的是智能合约，这个恰好是以太坊的强项。 以太坊的出现是因为随着区块链技术的发展和应用，已有密码学在区块链货币项目中功能凸显不足，而且区块链可做的也远远不止于货币——于是以太坊出现了。 当然，以太坊也有弱项：唯智能合约论——有些不需要数理逻辑的资产，它也搞智能合约——这个是给人一种大炮打蚊子的感觉。 区块链未来发展的三大技术方向： 第一种是以比特币以太坊为代表的，走的是POW+POS的路线。这个路线的优点就是可以跨国跨区域，不需要批准就可以接受上千个节点来做共识。 第二种是以IBM的Fabric、腾讯、微软等为代表的，推出的BFT的平台，基本上就是趋于更中心化的分布式。这个路线的优点就是速度可以很快，做到每秒一万以上，但是缺点是节点几乎很难超过20个，更无法跨区域。但是主要应用是取代目前昂贵的数据中心备份系统，受打击的应该是甲骨文这种大数据库集成商。推出这种项目的会和国内的阿里、腾讯，华为和国外的IBM这些去竞争。 第三种，井通科技以及海外的stella、ripple 这种，是用了中间取平衡——通过对BFT的优化，大概是速度可以做到5000每秒，节点可以支持250个，应用主要是跨区域跨国的联盟链，比如汇兑、金融联盟、行业联盟等等。 阅读更多" />
<meta property="og:description" content="应用技术 一、算法加密 二、点对点通信技术（Peer to Peer） 三、分布式共识技术 3.1 共识一致性算法 3.1.1 Paxos 3.1.2 Raft 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） 3.1.4 POW （Proof of work 工作量证明） 3.1.5 POS （Proof of Stake 股权证明） 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 3.1.7 共识 四、分叉 4.1 硬分叉（hard-fork） 4.2 软分叉 4.3 软硬分叉的优缺点 4.4 向前兼容（forward compatible） 五、换个角度看区块链技术 应用技术 一、算法加密 比特币采用椭圆曲线加密算法（ECC）来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 比特币还用到哈希算法，Hash，就是把任意长度的输入通过散列算法变换成固定长度的数据信息摘要的函数。 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 二、点对点通信技术（Peer to Peer） 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 三、分布式共识技术 理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 （FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！） 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 3.1 共识一致性算法 3.1.1 Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 3.1.2 Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a) Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b) Follower: 类似选民，完全被动； c) Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。 3.1.4 POW （Proof of work 工作量证明） POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。 由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。 3.1.5 POS （Proof of Stake 股权证明） POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。 POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 以这些技术为基础，区块链实现了它去中心化的本质特征。 通过非对称密码技术，实现了区块链的历史可信； 通过点对点通信，实现了区块链网络的不可停止； 通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上。 3.1.7 共识 第一个概念,叫做 consensus,中文叫做共识,就是大家对一个事件,都 同意,不光是发生了事件 A 和 B,而且事件 A 先于事件 B 的顺序,都一致认同。 第二个概念,叫做 consensus finality,就是终极共识,意思就是我们在做 下一个决定之前,现有这个决定必须是终极的,不能改变的。 四、分叉 比特币采取的 pow,原理就是在进行哈希碰撞, 那么在这个过程中,基本上会出现几个人同一时间,达到哈希碰撞的结果。那么 pow 其实是没有终结共识的,一旦出现共识分叉,比特币原则是最长链获胜。 那么短的分叉,就会被放弃。但是在理论上,如果有一帮人,决定就是将这个短 分叉持续下去,那么真正的两条链就分出来了,当然事实上大家没有这样做。 软硬分叉涉及到的问题是去中心的化的节点软件、协议、版本升级的问题（软硬分叉都是由于软件升级导致的问题，而不是共识分歧导致的）。 一开始，所有的节点运行同样的软件，遵循着同样的共识协议，维护着同样的一条链（blockchain）。这时，一部分节点升级到了新版本的软件，拥有了新的共识协议，这时会出现下面四种情况： 新节点认为老节点发出的区块/交易合法； 新节点认为老节点发出的区块/交易不合法； 老节点认为新节点发出的区块/交易合法（没察觉变化）； 老节点认为新节点发出的区块/交易不合法（察觉出了变化）； 注意：不合法会分为所有交易都不合法和部分交易不合法。这里为了简化模型，把有部分交易不合法的都归为交易不合法。 实际情况是上面4种情况的组合，除此以外，我们还要增加一个维度，就是新节点和老节点的算力比，又分为下面两种类型： 新节点算力&gt;50%； 新节点算力&lt;50%； 注意，我们目前在网站上看到的各种关于软硬分叉的资料，都是基于新节点算力&gt;50%的情况下讨论的。这里我们也只讨论新节点算力&gt;50%。要注意，另一种情况下，即新节点算力&lt;50%，情况会完全不一样。 软分叉是一个后来才出现的词，之前并没有。我们首先来讲一下什么是硬分叉（hard-fork）。 4.1 硬分叉（hard-fork） 硬分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，老节点无法接受新节点挖出的全部或部分区块（认为不合法），导致同时出现两条链。尽管新节点算力较大，比如99%的算力为新节点，1%的老节点依然会维护着不同的一条链，因为新节点产生的区块老节点实在是无法接受（尽管它知道网络上99%的节点都接受了），这称为硬分叉。 注意：以上情况基于新节点算力&gt;50%。 当必须硬分叉时，我们需要要求所有节点同时升级软件，未升级的节点将不能正常工作。如果有较多老节点不愿意升级，他们将工作在另外一条完全不一样的链上。 硬分叉产生的原因：新的节点要求比老的节点要宽松很多。 4.2 软分叉 软分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，新节点无法接受老节点挖出的全部或部分区块（认为不合法）。因为新节点算力较大，老节点挖出的区块将没有机会得到认可，新老双方从始至终都工作在同一条链上，这称为软分叉。 注意：以上情况基于新节点算力&gt;50%。 软分叉产生的原因：新的节点要求比老的节点要严格很多。 4.3 软硬分叉的优缺点 上面的定义可以看出软硬分叉有各自的优缺点，首先软分叉和硬分叉相比拥有下面的优点： 软分叉总是只有一条链，没有分成两条链的风险； 软分叉不要求所有节点同一时间升级，允许逐步升级，且并不影响软分叉过程中的系统稳定性和有效性； 但软分叉也有缺点： 软分叉的前提是老的节点总是能够接受新节点的区块，这就要求把系统设计成向前兼容（forward compatible）； 软分叉总是建立在对老节点进行欺骗的基础上，它让老节点没有察觉实际上已经发生的变化，某种程度上违背了单点完整验证的原则； 4.4 向前兼容（forward compatible） 向前兼容是非常有意思的术语，它不同于我们通常说的软件设计中向后兼容（backward compatible）的方式。它要求对于新可能出现的区块形态、共识机制有个预先的判断，并在老的系统中留有余地或后门。当新的节点被部署时，老的节点能够接受新节点所产生的区块。 那么，比特币里是如何实现向前兼容的？ 答案是：非标准交易（non-standard transaction）。 比特币中设定了如下规则： 将所有交易分类为：标准交易、非标准交易和非法（invalid）三种； 如果发现非法交易，一律拒绝，如果该非法交易在某个区块中，则拒绝整个区块； 在标准配置下，所有节点对非标准交易采取以下态度： a. 不转发 b. 不接受 c.不打包 对于已经进入区块的非标准交易采取以下态度： 接受该区块； 对区块中的所有交易，包含该非标准交易按既有规则进行验证； 五、换个角度看区块链技术 瑞波在做汇兑的时候，用银关概念接入法币资产，还可以接入比特币和以太币，显示了瑞波银关的优势。但是瑞波缺乏的是智能合约，这个恰好是以太坊的强项。 以太坊的出现是因为随着区块链技术的发展和应用，已有密码学在区块链货币项目中功能凸显不足，而且区块链可做的也远远不止于货币——于是以太坊出现了。 当然，以太坊也有弱项：唯智能合约论——有些不需要数理逻辑的资产，它也搞智能合约——这个是给人一种大炮打蚊子的感觉。 区块链未来发展的三大技术方向： 第一种是以比特币以太坊为代表的，走的是POW+POS的路线。这个路线的优点就是可以跨国跨区域，不需要批准就可以接受上千个节点来做共识。 第二种是以IBM的Fabric、腾讯、微软等为代表的，推出的BFT的平台，基本上就是趋于更中心化的分布式。这个路线的优点就是速度可以很快，做到每秒一万以上，但是缺点是节点几乎很难超过20个，更无法跨区域。但是主要应用是取代目前昂贵的数据中心备份系统，受打击的应该是甲骨文这种大数据库集成商。推出这种项目的会和国内的阿里、腾讯，华为和国外的IBM这些去竞争。 第三种，井通科技以及海外的stella、ripple 这种，是用了中间取平衡——通过对BFT的优化，大概是速度可以做到5000每秒，节点可以支持250个，应用主要是跨区域跨国的联盟链，比如汇兑、金融联盟、行业联盟等等。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/01/28/3944d1e4984f29f1c180c42cd886dd7e.html" />
<meta property="og:url" content="https://mlh.app/2018/01/28/3944d1e4984f29f1c180c42cd886dd7e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"应用技术 一、算法加密 二、点对点通信技术（Peer to Peer） 三、分布式共识技术 3.1 共识一致性算法 3.1.1 Paxos 3.1.2 Raft 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） 3.1.4 POW （Proof of work 工作量证明） 3.1.5 POS （Proof of Stake 股权证明） 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 3.1.7 共识 四、分叉 4.1 硬分叉（hard-fork） 4.2 软分叉 4.3 软硬分叉的优缺点 4.4 向前兼容（forward compatible） 五、换个角度看区块链技术 应用技术 一、算法加密 比特币采用椭圆曲线加密算法（ECC）来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 比特币还用到哈希算法，Hash，就是把任意长度的输入通过散列算法变换成固定长度的数据信息摘要的函数。 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 二、点对点通信技术（Peer to Peer） 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 三、分布式共识技术 理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 （FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！） 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 3.1 共识一致性算法 3.1.1 Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 3.1.2 Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a) Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b) Follower: 类似选民，完全被动； c) Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法） PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。 3.1.4 POW （Proof of work 工作量证明） POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。 由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。 3.1.5 POS （Proof of Stake 股权证明） POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。 POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 以这些技术为基础，区块链实现了它去中心化的本质特征。 通过非对称密码技术，实现了区块链的历史可信； 通过点对点通信，实现了区块链网络的不可停止； 通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。 3.1.6 DPOS（Delegated Proof of Stake，委任权益证明） 比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上。 3.1.7 共识 第一个概念,叫做 consensus,中文叫做共识,就是大家对一个事件,都 同意,不光是发生了事件 A 和 B,而且事件 A 先于事件 B 的顺序,都一致认同。 第二个概念,叫做 consensus finality,就是终极共识,意思就是我们在做 下一个决定之前,现有这个决定必须是终极的,不能改变的。 四、分叉 比特币采取的 pow,原理就是在进行哈希碰撞, 那么在这个过程中,基本上会出现几个人同一时间,达到哈希碰撞的结果。那么 pow 其实是没有终结共识的,一旦出现共识分叉,比特币原则是最长链获胜。 那么短的分叉,就会被放弃。但是在理论上,如果有一帮人,决定就是将这个短 分叉持续下去,那么真正的两条链就分出来了,当然事实上大家没有这样做。 软硬分叉涉及到的问题是去中心的化的节点软件、协议、版本升级的问题（软硬分叉都是由于软件升级导致的问题，而不是共识分歧导致的）。 一开始，所有的节点运行同样的软件，遵循着同样的共识协议，维护着同样的一条链（blockchain）。这时，一部分节点升级到了新版本的软件，拥有了新的共识协议，这时会出现下面四种情况： 新节点认为老节点发出的区块/交易合法； 新节点认为老节点发出的区块/交易不合法； 老节点认为新节点发出的区块/交易合法（没察觉变化）； 老节点认为新节点发出的区块/交易不合法（察觉出了变化）； 注意：不合法会分为所有交易都不合法和部分交易不合法。这里为了简化模型，把有部分交易不合法的都归为交易不合法。 实际情况是上面4种情况的组合，除此以外，我们还要增加一个维度，就是新节点和老节点的算力比，又分为下面两种类型： 新节点算力&gt;50%； 新节点算力&lt;50%； 注意，我们目前在网站上看到的各种关于软硬分叉的资料，都是基于新节点算力&gt;50%的情况下讨论的。这里我们也只讨论新节点算力&gt;50%。要注意，另一种情况下，即新节点算力&lt;50%，情况会完全不一样。 软分叉是一个后来才出现的词，之前并没有。我们首先来讲一下什么是硬分叉（hard-fork）。 4.1 硬分叉（hard-fork） 硬分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，老节点无法接受新节点挖出的全部或部分区块（认为不合法），导致同时出现两条链。尽管新节点算力较大，比如99%的算力为新节点，1%的老节点依然会维护着不同的一条链，因为新节点产生的区块老节点实在是无法接受（尽管它知道网络上99%的节点都接受了），这称为硬分叉。 注意：以上情况基于新节点算力&gt;50%。 当必须硬分叉时，我们需要要求所有节点同时升级软件，未升级的节点将不能正常工作。如果有较多老节点不愿意升级，他们将工作在另外一条完全不一样的链上。 硬分叉产生的原因：新的节点要求比老的节点要宽松很多。 4.2 软分叉 软分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，新节点无法接受老节点挖出的全部或部分区块（认为不合法）。因为新节点算力较大，老节点挖出的区块将没有机会得到认可，新老双方从始至终都工作在同一条链上，这称为软分叉。 注意：以上情况基于新节点算力&gt;50%。 软分叉产生的原因：新的节点要求比老的节点要严格很多。 4.3 软硬分叉的优缺点 上面的定义可以看出软硬分叉有各自的优缺点，首先软分叉和硬分叉相比拥有下面的优点： 软分叉总是只有一条链，没有分成两条链的风险； 软分叉不要求所有节点同一时间升级，允许逐步升级，且并不影响软分叉过程中的系统稳定性和有效性； 但软分叉也有缺点： 软分叉的前提是老的节点总是能够接受新节点的区块，这就要求把系统设计成向前兼容（forward compatible）； 软分叉总是建立在对老节点进行欺骗的基础上，它让老节点没有察觉实际上已经发生的变化，某种程度上违背了单点完整验证的原则； 4.4 向前兼容（forward compatible） 向前兼容是非常有意思的术语，它不同于我们通常说的软件设计中向后兼容（backward compatible）的方式。它要求对于新可能出现的区块形态、共识机制有个预先的判断，并在老的系统中留有余地或后门。当新的节点被部署时，老的节点能够接受新节点所产生的区块。 那么，比特币里是如何实现向前兼容的？ 答案是：非标准交易（non-standard transaction）。 比特币中设定了如下规则： 将所有交易分类为：标准交易、非标准交易和非法（invalid）三种； 如果发现非法交易，一律拒绝，如果该非法交易在某个区块中，则拒绝整个区块； 在标准配置下，所有节点对非标准交易采取以下态度： a. 不转发 b. 不接受 c.不打包 对于已经进入区块的非标准交易采取以下态度： 接受该区块； 对区块中的所有交易，包含该非标准交易按既有规则进行验证； 五、换个角度看区块链技术 瑞波在做汇兑的时候，用银关概念接入法币资产，还可以接入比特币和以太币，显示了瑞波银关的优势。但是瑞波缺乏的是智能合约，这个恰好是以太坊的强项。 以太坊的出现是因为随着区块链技术的发展和应用，已有密码学在区块链货币项目中功能凸显不足，而且区块链可做的也远远不止于货币——于是以太坊出现了。 当然，以太坊也有弱项：唯智能合约论——有些不需要数理逻辑的资产，它也搞智能合约——这个是给人一种大炮打蚊子的感觉。 区块链未来发展的三大技术方向： 第一种是以比特币以太坊为代表的，走的是POW+POS的路线。这个路线的优点就是可以跨国跨区域，不需要批准就可以接受上千个节点来做共识。 第二种是以IBM的Fabric、腾讯、微软等为代表的，推出的BFT的平台，基本上就是趋于更中心化的分布式。这个路线的优点就是速度可以很快，做到每秒一万以上，但是缺点是节点几乎很难超过20个，更无法跨区域。但是主要应用是取代目前昂贵的数据中心备份系统，受打击的应该是甲骨文这种大数据库集成商。推出这种项目的会和国内的阿里、腾讯，华为和国外的IBM这些去竞争。 第三种，井通科技以及海外的stella、ripple 这种，是用了中间取平衡——通过对BFT的优化，大概是速度可以做到5000每秒，节点可以支持250个，应用主要是跨区域跨国的联盟链，比如汇兑、金融联盟、行业联盟等等。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/01/28/3944d1e4984f29f1c180c42cd886dd7e.html","headline":"区块链中的技术","dateModified":"2018-01-28T00:00:00+08:00","datePublished":"2018-01-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/01/28/3944d1e4984f29f1c180c42cd886dd7e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链中的技术</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p></p>
  <div class="toc">
   <div class="toc"> 
    <ul> 
     <li><a href="#应用技术" rel="nofollow">应用技术</a>
      <ul> 
       <li><a href="#一算法加密" rel="nofollow">一、算法加密</a></li> 
       <li><a href="#二点对点通信技术peer-to-peer" rel="nofollow">二、点对点通信技术（Peer to Peer）</a></li> 
       <li><a href="#三分布式共识技术" rel="nofollow">三、分布式共识技术</a>
        <ul> 
         <li><a href="#31-共识一致性算法" rel="nofollow">3.1 共识一致性算法</a>
          <ul> 
           <li><a href="#311-paxos" rel="nofollow">3.1.1 Paxos</a></li> 
           <li><a href="#312-raft" rel="nofollow">3.1.2 Raft</a></li> 
           <li><a href="#313-pbft-practical-byzantine-fault-tolerance-拜占庭容错算法" rel="nofollow">3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法）</a></li> 
           <li><a href="#314-pow-proof-of-work-工作量证明" rel="nofollow">3.1.4 POW （Proof of work 工作量证明）</a></li> 
           <li><a href="#315-pos-proof-of-stake-股权证明" rel="nofollow">3.1.5 POS （Proof of Stake 股权证明）</a></li> 
           <li><a href="#316-dposdelegated-proof-of-stake委任权益证明" rel="nofollow">3.1.6 DPOS（Delegated Proof of Stake，委任权益证明）</a></li> 
           <li><a href="#317-共识" rel="nofollow">3.1.7 共识</a></li> 
          </ul> </li> 
        </ul> </li> 
       <li><a href="#四分叉" rel="nofollow">四、分叉</a>
        <ul> 
         <li><a href="#41-硬分叉hard-fork" rel="nofollow">4.1 硬分叉（hard-fork）</a></li> 
         <li><a href="#42-软分叉" rel="nofollow">4.2 软分叉</a></li> 
         <li><a href="#43-软硬分叉的优缺点" rel="nofollow">4.3 软硬分叉的优缺点</a></li> 
         <li><a href="#44-向前兼容forward-compatible" rel="nofollow">4.4 向前兼容（forward compatible）</a></li> 
        </ul> </li> 
       <li><a href="#五换个角度看区块链技术" rel="nofollow">五、换个角度看区块链技术</a></li> 
      </ul> </li> 
    </ul> 
   </div> 
  </div> 
  <p></p> 
  <h1 id="应用技术">应用技术</h1> 
  <h2 id="一算法加密">一、算法加密</h2> 
  <p>比特币采用<strong>椭圆曲线加密算法（ECC）</strong>来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。</p> 
  <p>比特币还用到哈希算法，Hash，就是把任意长度的输入通过散列算法变换成固定长度的数据信息摘要的函数。</p> 
  <p>区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。</p> 
  <p>相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。</p> 
  <h2 id="二点对点通信技术peer-to-peer">二、点对点通信技术（Peer to Peer）</h2> 
  <p>1、所有节点参与提供资源，包括带宽，存储空间和计算能力； <br> 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障；</p> 
  <h2 id="三分布式共识技术">三、分布式共识技术</h2> 
  <p>理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。</p> 
  <p>异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。</p> 
  <blockquote> 
   <p>（FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！）</p> 
  </blockquote> 
  <p>共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。</p> 
  <h3 id="31-共识一致性算法">3.1 共识一致性算法</h3> 
  <h4 id="311-paxos">3.1.1 Paxos</h4> 
  <p>Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。</p> 
  <p>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。</p> 
  <h4 id="312-raft">3.1.2 Raft</h4> 
  <p>Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。</p> 
  <p>在Raft中，任何时候一个服务器可以扮演下面角色之一： <br> a) Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； <br> b) Follower: 类似选民，完全被动； <br> c) Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。</p> 
  <p>Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。</p> 
  <h4 id="313-pbft-practical-byzantine-fault-tolerance-拜占庭容错算法">3.1.3 PBFT （Practical Byzantine Fault Tolerance 拜占庭容错算法）</h4> 
  <p>PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，<strong>拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。</strong></p> 
  <p>是第一个比较广泛的BFT算法，<strong>在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。</strong></p> 
  <p>PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。</p> 
  <blockquote> 
   <p>PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，假设|R|=3f+1，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p> 
  </blockquote> 
  <h4 id="314-pow-proof-of-work-工作量证明">3.1.4 POW （Proof of work 工作量证明）</h4> 
  <p>POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。</p> 
  <p>POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。</p> 
  <p>在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。</p> 
  <p><strong>POW证明机制基于的是数学上难以快速计算的问题</strong>，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。</p> 
  <p>由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。</p> 
  <p>POW现在的主要实现系统是比特币系统和以太坊系统。</p> 
  <blockquote> 
   <p>比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。</p> 
  </blockquote> 
  <h4 id="315-pos-proof-of-stake-股权证明">3.1.5 POS （Proof of Stake 股权证明）</h4> 
  <p>POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。</p> 
  <p>POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。 </p> 
  <p>POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。</p> 
  <p>POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。</p> 
  <p>以这些技术为基础，区块链实现了它去中心化的本质特征。</p> 
  <ul> 
   <li>通过非对称密码技术，实现了区块链的历史可信； </li> 
   <li>通过点对点通信，实现了区块链网络的不可停止； </li> 
   <li>通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。</li> 
  </ul> 
  <blockquote> 
   <p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 <br> 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p> 
  </blockquote> 
  <h4 id="316-dposdelegated-proof-of-stake委任权益证明">3.1.6 DPOS（Delegated Proof of Stake，委任权益证明）</h4> 
  <p>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上。</p> 
  <h4 id="317-共识">3.1.7 共识</h4> 
  <p>第一个概念,叫做 consensus,中文叫做共识,就是大家对一个事件,都 同意,不光是发生了事件 A 和 B,而且事件 A 先于事件 B 的顺序,都一致认同。</p> 
  <p>第二个概念,叫做 consensus finality,就是终极共识,意思就是我们在做 下一个决定之前,现有这个决定必须是终极的,不能改变的。</p> 
  <h2 id="四分叉">四、分叉</h2> 
  <p>比特币采取的 pow,原理就是在进行哈希碰撞, 那么在这个过程中,基本上会出现几个人同一时间,达到哈希碰撞的结果。那么 pow 其实是没有终结共识的,一旦出现共识分叉,比特币原则是最长链获胜。 那么短的分叉,就会被放弃。但是在理论上,如果有一帮人,决定就是将这个短 分叉持续下去,那么真正的两条链就分出来了,当然事实上大家没有这样做。</p> 
  <p>软硬分叉涉及到的问题是去中心的化的节点软件、协议、版本升级的问题（软硬分叉都是由于软件升级导致的问题，而不是共识分歧导致的）。</p> 
  <p>一开始，所有的节点运行同样的软件，遵循着同样的共识协议，维护着同样的一条链（blockchain）。这时，一部分节点升级到了新版本的软件，拥有了新的共识协议，这时会出现下面四种情况： <br> 新节点认为老节点发出的区块/交易合法； <br> 新节点认为老节点发出的区块/交易不合法； <br> 老节点认为新节点发出的区块/交易合法（没察觉变化）； <br> 老节点认为新节点发出的区块/交易不合法（察觉出了变化）；</p> 
  <p>注意：不合法会分为所有交易都不合法和部分交易不合法。这里为了简化模型，把有部分交易不合法的都归为交易不合法。 <br> 实际情况是上面4种情况的组合，除此以外，我们还要增加一个维度，就是新节点和老节点的算力比，又分为下面两种类型： <br> 新节点算力&gt;50%； <br> 新节点算力&lt;50%；</p> 
  <p>注意，我们目前在网站上看到的各种关于软硬分叉的资料，都是基于新节点算力&gt;50%的情况下讨论的。这里我们也只讨论新节点算力&gt;50%。要注意，另一种情况下，即新节点算力&lt;50%，情况会完全不一样。</p> 
  <p>软分叉是一个后来才出现的词，之前并没有。我们首先来讲一下什么是硬分叉（hard-fork）。</p> 
  <h3 id="41-硬分叉hard-fork">4.1 硬分叉（hard-fork）</h3> 
  <p>硬分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，老节点无法接受新节点挖出的全部或部分区块（认为不合法），导致同时出现两条链。尽管新节点算力较大，比如99%的算力为新节点，1%的老节点依然会维护着不同的一条链，因为新节点产生的区块老节点实在是无法接受（尽管它知道网络上99%的节点都接受了），这称为硬分叉。 <br> 注意：以上情况基于新节点算力&gt;50%。</p> 
  <p>当必须硬分叉时，我们需要要求所有节点同时升级软件，未升级的节点将不能正常工作。如果有较多老节点不愿意升级，他们将工作在另外一条完全不一样的链上。</p> 
  <p>硬分叉产生的原因：新的节点要求比老的节点要宽松很多。</p> 
  <h3 id="42-软分叉">4.2 软分叉</h3> 
  <p>软分叉是指：当系统中出现了新版本的软件（或称协议），并且和前版本软件不能兼容，新节点无法接受老节点挖出的全部或部分区块（认为不合法）。因为新节点算力较大，老节点挖出的区块将没有机会得到认可，新老双方从始至终都工作在同一条链上，这称为软分叉。 <br> 注意：以上情况基于新节点算力&gt;50%。</p> 
  <p>软分叉产生的原因：新的节点要求比老的节点要严格很多。</p> 
  <h3 id="43-软硬分叉的优缺点">4.3 软硬分叉的优缺点</h3> 
  <p>上面的定义可以看出软硬分叉有各自的优缺点，首先软分叉和硬分叉相比拥有下面的优点： <br> 软分叉总是只有一条链，没有分成两条链的风险； <br> 软分叉不要求所有节点同一时间升级，允许逐步升级，且并不影响软分叉过程中的系统稳定性和有效性； <br> 但软分叉也有缺点： <br> 软分叉的前提是老的节点总是能够接受新节点的区块，这就要求把系统设计成向前兼容（forward compatible）； <br> 软分叉总是建立在对老节点进行欺骗的基础上，它让老节点没有察觉实际上已经发生的变化，某种程度上违背了单点完整验证的原则；</p> 
  <h3 id="44-向前兼容forward-compatible">4.4 向前兼容（forward compatible）</h3> 
  <p>向前兼容是非常有意思的术语，它不同于我们通常说的软件设计中向后兼容（backward compatible）的方式。它要求对于新可能出现的区块形态、共识机制有个预先的判断，并在老的系统中留有余地或后门。当新的节点被部署时，老的节点能够接受新节点所产生的区块。</p> 
  <p>那么，比特币里是如何实现向前兼容的？</p> 
  <p>答案是：非标准交易（non-standard transaction）。</p> 
  <p>比特币中设定了如下规则： <br> 将所有交易分类为：标准交易、非标准交易和非法（invalid）三种； <br> 如果发现非法交易，一律拒绝，如果该非法交易在某个区块中，则拒绝整个区块； <br> 在标准配置下，所有节点对非标准交易采取以下态度： <br> a. 不转发 <br> b. 不接受 <br> c.不打包 <br> 对于已经进入区块的非标准交易采取以下态度： <br> 接受该区块； <br> 对区块中的所有交易，包含该非标准交易按既有规则进行验证；</p> 
  <h2 id="五换个角度看区块链技术">五、换个角度看区块链技术</h2> 
  <p>瑞波在做汇兑的时候，用银关概念接入法币资产，还可以接入比特币和以太币，显示了瑞波银关的优势。但是瑞波缺乏的是智能合约，这个恰好是以太坊的强项。</p> 
  <p>以太坊的出现是因为随着区块链技术的发展和应用，已有密码学在区块链货币项目中功能凸显不足，而且区块链可做的也远远不止于货币——于是以太坊出现了。</p> 
  <p>当然，以太坊也有弱项：唯智能合约论——有些不需要数理逻辑的资产，它也搞智能合约——这个是给人一种大炮打蚊子的感觉。</p> 
  <p><strong>区块链未来发展的三大技术方向：</strong></p> 
  <p>第一种是以比特币以太坊为代表的，走的是POW+POS的路线。这个路线的优点就是可以跨国跨区域，不需要批准就可以接受上千个节点来做共识。</p> 
  <p>第二种是以IBM的Fabric、腾讯、微软等为代表的，推出的BFT的平台，基本上就是趋于更中心化的分布式。这个路线的优点就是速度可以很快，做到每秒一万以上，但是缺点是节点几乎很难超过20个，更无法跨区域。但是主要应用是取代目前昂贵的数据中心备份系统，受打击的应该是甲骨文这种大数据库集成商。推出这种项目的会和国内的阿里、腾讯，华为和国外的IBM这些去竞争。</p> 
  <p>第三种，井通科技以及海外的stella、ripple 这种，是用了中间取平衡——通过对BFT的优化，大概是速度可以做到5000每秒，节点可以支持250个，应用主要是跨区域跨国的联盟链，比如汇兑、金融联盟、行业联盟等等。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_37138973/article/details/78997952,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_37138973/article/details/78997952,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
