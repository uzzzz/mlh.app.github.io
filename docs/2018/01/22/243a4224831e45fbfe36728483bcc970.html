<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链实例以太坊原理探讨 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链实例以太坊原理探讨" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="摘 要 区块链的本质上是一个去中心化的数据库。它使用密码学的相关方法产生数据块，每一个数据块中包含了一次比特币网络交易的所有信息，因此可以用来验证其信息的有效性和生成下一个区块。 区块链格式首先被应用于比特币。2008年10月，在中本聪的论文中，“区块”和“链”这两个字是被分开使用的，而在被广泛使用时被合称为区块-链，到2016年才被变成一个词：“区块链”。 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 以太坊平台应用了许多信息安全及密码学相关的技术，例如，时间戳， 非对称加密， 哈希函数， Merkle树等。 一．以太坊概述 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 上面的以太坊介绍是官方的，我通过查阅大量资料之后，有一些自己的理解。关于比特币技术，我们可以假想有一本记账本，这个记账本有一个特性：全世界每个参与者都有它的副本，即任何一个人在上面记录了一笔交易，那么这个记录立刻就会出现在全世界所有的副本上，所有的参与者也就都知道了这笔交易，同时任何人都不能擦除账本上的任何记录。 在上面例子的基础上来介绍一次交易过程： 1.Alice希望能转账10比特币给Bob。 2.Alice需要提供Alice的地址（通过对Alice的公钥进行hash得到），Bob的地址，以及转账数目。同时Alice使用自己的私钥对这笔交易进行签名。 3.这笔交易被发送到已签署交易池，等待验证。 4.系统验证完Alice的账户中确实有大于10比特币的财富，则认为这笔交易是有效的。 5.验证完成之后将这笔交易发送到已验证交易池中，所有的交易都验证完成后，打包成一个区块 ，该区块以加密方式签署，并添加到区块链上。 6.区块链更新，所有参与者下载新的区块链，也就是说Alice这笔交易显示在了所有人的账本上。 7.Bob此时收到了Alice的10个比特币。 以上的过程简单介绍了比特币的原理，以太坊在这个基础之上则有了进一步的发展，可以创建一些自动执行的小程序。例如，Alice可以添加一个小程序：“如果1月4号的NBA比赛，雷霆赢了湖人，则转账10比特币给Bob”该小程序可以在赛后自动获取比赛结果，从而判断是否需要转账给Bob。这种小程序的官方名称是智能合约。 智能合约有两个特性，一是任何参与者都可以检查源代码，保证了可信度，二是，智能合约不能被突然删除，例如，Alice看了球赛的上半场，觉得雷霆快赢了，想反悔，删掉小程序，但是这种操作是不被允许的。 二．以太坊关键技术 以太坊采用了许多信息安全及密码学的相关技术，大致有5个，工作量证明（POW），椭圆曲线密码，哈希函数，Merkle Tree,以及电子时间戳机制。 2.1 工作量证明 工作量证明机制(Proof of Work, POW)为区块链关键技术，简单来说就是用来确认你做过一定的工作量的证明。主要特征是工作者须要做出一定难度的工作才能得出结果，但验证方却可以根据该结果很容易的检查出工作者是否做了相对应的工作。流程如下图所示。 如图所示，左边的矿工需要解答密码学谜题以“挖出”一个区块并加入到区块链上。这一个过程要求大量的电力和运算。在系统中，这些谜题已经被设计成艰难而又繁重。当一个矿工解决一个谜题的时候，他们发布他们的区块到网络上接受验证。右边的人验证区块是否属于一条链是一个非常简单且快速的过程。 在工作量证明机制中也使用了哈希函数，矿工在完成计算之后，对计算结果采用Hashcash算法作为POW，其他节点可以用相关的数学公式，即可容易地验证出该数值(新区块)是否有效。 但是，目前来看，工作量证明存在非常多的问题。首先，也是最重要的，工作量证明是个极端低效的系统，因为它消耗大量的电力和能量。 其次，工作量证明并不是抗ASIC的，也就是说，可以购买更快更强劲的ASIC设备的人们和机构通常可以比其他人拥有更高的概率挖到区块。 针对以上这些缺点，人们提出了权益证明（POS），权益证明将让整个挖矿过程虚拟化，并以验证者取代矿工。首先，验证者必须锁定一些他们拥有的币作为保证金。在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。 2.2 椭圆曲线密码 在区块链中使用的公钥密码算法是基于椭圆代数的特性开发的椭圆曲线算法。椭圆曲线算法的安全性依赖于著名的数学难题，离散对数问题。椭圆曲线密码的加解密过程如下图。 如上图所示，用户Alice选定一条椭圆曲线Ep(a，b)，并取椭圆曲线上一点，作为基点P；用户A选择一个私有密钥k，并生成公开密钥L=kP；用户A将Ep(a，b)和点L、P传给用户Bob；用户Bob接到信息后，将待传输的明文编码到Ep(a，b)上一点M，并产生一个随机整数x(x小于r)；用户Bob计算点C1=M+xL，C2=xP；用户Bob将C1,C2传给用户Alice；用户Alice接到信息后，计算C1-LC2，结果就是点M。 椭圆曲线密码的出现也是受到了RSA算法的启发，RSA方法的优点主要在于原理简单，易于使用。但是，随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，作为RSA加解密安全保障的大整数要求越来越大。为了保证RSA使用的安全性，其密钥的位数一直在增加，但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对RSA的应用带来了很重的负担，对进行大量安全交易的电子商务更是如此，从而使得其应用范围越来越受到制约。 椭圆曲线加密方法与RSA方法相比，有以下优点：(1)安全性能更高。加密算法的安全性能一般通过该算法的抗攻击强度来反映。ECC和其他几种公钥系统相比，其抗攻击性具有绝对的优势。如160bitECC与1024bitRSA、有相同的安全强度。（2）处理速度快，在私钥处理上（签名与解密），ECC远比RSA快。（3）存储空间占用小，ECC的密钥尺寸比RSA要小的多。 2.3 Merkle Tree Merkle Tree多数是用来进行比对和验证处理，用户先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 Merkle Tree可以看作是哈希表的泛化，因此它的主要特征也就是哈希函数的主要特征即，输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的，因此可以用来进行验证处理。 Merkle Tree协议对以太坊的长期持续性可以说是至关重要的。区块链网络中存储所有区块的全部数据的节点所需的内存空间急速增长。Merkle Tree协议使以太坊在运行过程中，只需下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 2.4 时间戳机制 在以太坊中，要求参与交易各方不能否认其行为。这其中需要在经过数字签名的交易上打上一个可信赖的时间戳，从而解决一系列的实际和法律问题。时间戳服务工作流程大致如下：首先用户对文件数据进行Hash摘要处理；用户提出时间戳的请求，Hash值被传递给时间戳服务器；时间戳服务器对哈希值和一个日期/时间记录进行签名，生成时间戳；时间戳数据和文件信息绑定后返还，用户进行下一步电子交易操作。 2.5哈希函数 首先简单介绍一下哈希函数，一个可靠的单向哈希函数必须具备以下特性：（1）输入任意长度数据必须输出固定长度的散列值；（2）能够快速计算出散列值；（3）输入数据有细小差别也要导致散列值差别很大；（4）具备单向性，无法根据散列值反推出原始数据。常见的单向散列函数包括MD4/MD5、SHA-1/SHA-256/SHA-384/SHA-512、RIPEMD/RIPEMD-160、以及以Keccak算法作为标准的SHA-3系列函数。其中MD4/MD5、SHA-1、RIPEMD已经存在攻破的算法，不推荐在极其敏感环境下使用。以太坊中常用的哈希函数有SHA-256,Keccak-256等。 如上图，每一个打包好的区块中都有一个prehash值，这个值是指前一个区块（通常是区块头）的哈希值，在以太坊中此处使用的是SHA-256算法。在需要遍历验证所有区块时，便是通过preHash值索引到上一个区块直至创始区块。同时，在上图中还有一个值得关注的成员：MRH（Merkle Root Hash）即默克尔树根节点哈希值。在区块链的每个Block中都存放了一定数量被矿工打包的交易，区块链的交易记录是不容篡改的。而检测区块中的交易是否被篡改便是根据默克尔树根哈希的值前后是否一致来判断。 2.3中已经介绍过默克尔树，默克尔树的本质就是一个泛化的哈希表，当需要验证区块中的一笔交易是否被篡改过时，我们只需要验证这笔交易的哈希值，同时默克尔树还有一个优点，针对大块数据我们可以只对其中的一部分进行验证，这大大减小了工作量。 以太坊还有很多地方用到了散列函数，例如：区块链上的地址，是由散列法运算公钥而得到的。一个以太坊的账户地址，是以Keccak-256散列法运算一个公钥而得出的。以太坊上的签名是由私钥和需要被签名的数据散列而生成的。 三．以太坊的未来发展 目前的以太坊存在的问题还很多，比如一直都存在的可扩展性问题，由于以太坊节点需要存储这个区块链网络上发生的所有事情，因此存储成本非常昂贵，并且这种成本可能会随着系统的扩展而呈现指数增长。针对这一问题，以太坊的创始人提出了“分片”的解决方案，具体思想是标是将状态以某种形式进行分片, 从而让多个在大多数情况下独立的应用程序以并行的方式处理。很自然地，我们会怀疑，在分片之后，发起一笔交易将就只会在涉及到的几个节点间引起波动，还能确保它们相互之间传递的信息的真实性吗？针对这一问题，以太坊是依靠验证管理合约来保证真实性的。每一个区块，和每一个分片，都会经过随机可靠的验证管理合约核实查证。所以，如果要实现欺骗的目的，使得一个“说谎”的验证器能够被系统接受，你必须在攻破接管整个系统中大部分的验证器之后才能实现。 再比如隐私风险问题，，在以太坊中，隐私保护是非常重要的，目前针对这一问题，比较热门的解决方案是，zk-SNARKs（简明非交互零知识证明），这一解决方案的原理是，让一个证明者，在不提供任何额外的有用信息的情况下，使验证者相信某个论断是正确的，是一种概率证明而不是确定性证明。以Alice和Bob为例，Alice现在有一把钥匙，她需要向Bob证明她拥有这个钥匙。有两种做法，第一种是Alice把钥匙给Bob，Bob拿这个钥匙开了门进去，Bob知道Alice确实拥有进门的钥匙。另外一种做法是，Bob知道这个房子里有一样东西，他告诉Alice，Alice到房间里把这个东西拿出来给Bob看。由于Alice能做到这一点，Bob知道Alice有开门的钥匙。这第二种方法就体现了零知识证明的思想，当然这是一种概率证明，并不是确定性证明。 阅读更多" />
<meta property="og:description" content="摘 要 区块链的本质上是一个去中心化的数据库。它使用密码学的相关方法产生数据块，每一个数据块中包含了一次比特币网络交易的所有信息，因此可以用来验证其信息的有效性和生成下一个区块。 区块链格式首先被应用于比特币。2008年10月，在中本聪的论文中，“区块”和“链”这两个字是被分开使用的，而在被广泛使用时被合称为区块-链，到2016年才被变成一个词：“区块链”。 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 以太坊平台应用了许多信息安全及密码学相关的技术，例如，时间戳， 非对称加密， 哈希函数， Merkle树等。 一．以太坊概述 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 上面的以太坊介绍是官方的，我通过查阅大量资料之后，有一些自己的理解。关于比特币技术，我们可以假想有一本记账本，这个记账本有一个特性：全世界每个参与者都有它的副本，即任何一个人在上面记录了一笔交易，那么这个记录立刻就会出现在全世界所有的副本上，所有的参与者也就都知道了这笔交易，同时任何人都不能擦除账本上的任何记录。 在上面例子的基础上来介绍一次交易过程： 1.Alice希望能转账10比特币给Bob。 2.Alice需要提供Alice的地址（通过对Alice的公钥进行hash得到），Bob的地址，以及转账数目。同时Alice使用自己的私钥对这笔交易进行签名。 3.这笔交易被发送到已签署交易池，等待验证。 4.系统验证完Alice的账户中确实有大于10比特币的财富，则认为这笔交易是有效的。 5.验证完成之后将这笔交易发送到已验证交易池中，所有的交易都验证完成后，打包成一个区块 ，该区块以加密方式签署，并添加到区块链上。 6.区块链更新，所有参与者下载新的区块链，也就是说Alice这笔交易显示在了所有人的账本上。 7.Bob此时收到了Alice的10个比特币。 以上的过程简单介绍了比特币的原理，以太坊在这个基础之上则有了进一步的发展，可以创建一些自动执行的小程序。例如，Alice可以添加一个小程序：“如果1月4号的NBA比赛，雷霆赢了湖人，则转账10比特币给Bob”该小程序可以在赛后自动获取比赛结果，从而判断是否需要转账给Bob。这种小程序的官方名称是智能合约。 智能合约有两个特性，一是任何参与者都可以检查源代码，保证了可信度，二是，智能合约不能被突然删除，例如，Alice看了球赛的上半场，觉得雷霆快赢了，想反悔，删掉小程序，但是这种操作是不被允许的。 二．以太坊关键技术 以太坊采用了许多信息安全及密码学的相关技术，大致有5个，工作量证明（POW），椭圆曲线密码，哈希函数，Merkle Tree,以及电子时间戳机制。 2.1 工作量证明 工作量证明机制(Proof of Work, POW)为区块链关键技术，简单来说就是用来确认你做过一定的工作量的证明。主要特征是工作者须要做出一定难度的工作才能得出结果，但验证方却可以根据该结果很容易的检查出工作者是否做了相对应的工作。流程如下图所示。 如图所示，左边的矿工需要解答密码学谜题以“挖出”一个区块并加入到区块链上。这一个过程要求大量的电力和运算。在系统中，这些谜题已经被设计成艰难而又繁重。当一个矿工解决一个谜题的时候，他们发布他们的区块到网络上接受验证。右边的人验证区块是否属于一条链是一个非常简单且快速的过程。 在工作量证明机制中也使用了哈希函数，矿工在完成计算之后，对计算结果采用Hashcash算法作为POW，其他节点可以用相关的数学公式，即可容易地验证出该数值(新区块)是否有效。 但是，目前来看，工作量证明存在非常多的问题。首先，也是最重要的，工作量证明是个极端低效的系统，因为它消耗大量的电力和能量。 其次，工作量证明并不是抗ASIC的，也就是说，可以购买更快更强劲的ASIC设备的人们和机构通常可以比其他人拥有更高的概率挖到区块。 针对以上这些缺点，人们提出了权益证明（POS），权益证明将让整个挖矿过程虚拟化，并以验证者取代矿工。首先，验证者必须锁定一些他们拥有的币作为保证金。在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。 2.2 椭圆曲线密码 在区块链中使用的公钥密码算法是基于椭圆代数的特性开发的椭圆曲线算法。椭圆曲线算法的安全性依赖于著名的数学难题，离散对数问题。椭圆曲线密码的加解密过程如下图。 如上图所示，用户Alice选定一条椭圆曲线Ep(a，b)，并取椭圆曲线上一点，作为基点P；用户A选择一个私有密钥k，并生成公开密钥L=kP；用户A将Ep(a，b)和点L、P传给用户Bob；用户Bob接到信息后，将待传输的明文编码到Ep(a，b)上一点M，并产生一个随机整数x(x小于r)；用户Bob计算点C1=M+xL，C2=xP；用户Bob将C1,C2传给用户Alice；用户Alice接到信息后，计算C1-LC2，结果就是点M。 椭圆曲线密码的出现也是受到了RSA算法的启发，RSA方法的优点主要在于原理简单，易于使用。但是，随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，作为RSA加解密安全保障的大整数要求越来越大。为了保证RSA使用的安全性，其密钥的位数一直在增加，但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对RSA的应用带来了很重的负担，对进行大量安全交易的电子商务更是如此，从而使得其应用范围越来越受到制约。 椭圆曲线加密方法与RSA方法相比，有以下优点：(1)安全性能更高。加密算法的安全性能一般通过该算法的抗攻击强度来反映。ECC和其他几种公钥系统相比，其抗攻击性具有绝对的优势。如160bitECC与1024bitRSA、有相同的安全强度。（2）处理速度快，在私钥处理上（签名与解密），ECC远比RSA快。（3）存储空间占用小，ECC的密钥尺寸比RSA要小的多。 2.3 Merkle Tree Merkle Tree多数是用来进行比对和验证处理，用户先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 Merkle Tree可以看作是哈希表的泛化，因此它的主要特征也就是哈希函数的主要特征即，输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的，因此可以用来进行验证处理。 Merkle Tree协议对以太坊的长期持续性可以说是至关重要的。区块链网络中存储所有区块的全部数据的节点所需的内存空间急速增长。Merkle Tree协议使以太坊在运行过程中，只需下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 2.4 时间戳机制 在以太坊中，要求参与交易各方不能否认其行为。这其中需要在经过数字签名的交易上打上一个可信赖的时间戳，从而解决一系列的实际和法律问题。时间戳服务工作流程大致如下：首先用户对文件数据进行Hash摘要处理；用户提出时间戳的请求，Hash值被传递给时间戳服务器；时间戳服务器对哈希值和一个日期/时间记录进行签名，生成时间戳；时间戳数据和文件信息绑定后返还，用户进行下一步电子交易操作。 2.5哈希函数 首先简单介绍一下哈希函数，一个可靠的单向哈希函数必须具备以下特性：（1）输入任意长度数据必须输出固定长度的散列值；（2）能够快速计算出散列值；（3）输入数据有细小差别也要导致散列值差别很大；（4）具备单向性，无法根据散列值反推出原始数据。常见的单向散列函数包括MD4/MD5、SHA-1/SHA-256/SHA-384/SHA-512、RIPEMD/RIPEMD-160、以及以Keccak算法作为标准的SHA-3系列函数。其中MD4/MD5、SHA-1、RIPEMD已经存在攻破的算法，不推荐在极其敏感环境下使用。以太坊中常用的哈希函数有SHA-256,Keccak-256等。 如上图，每一个打包好的区块中都有一个prehash值，这个值是指前一个区块（通常是区块头）的哈希值，在以太坊中此处使用的是SHA-256算法。在需要遍历验证所有区块时，便是通过preHash值索引到上一个区块直至创始区块。同时，在上图中还有一个值得关注的成员：MRH（Merkle Root Hash）即默克尔树根节点哈希值。在区块链的每个Block中都存放了一定数量被矿工打包的交易，区块链的交易记录是不容篡改的。而检测区块中的交易是否被篡改便是根据默克尔树根哈希的值前后是否一致来判断。 2.3中已经介绍过默克尔树，默克尔树的本质就是一个泛化的哈希表，当需要验证区块中的一笔交易是否被篡改过时，我们只需要验证这笔交易的哈希值，同时默克尔树还有一个优点，针对大块数据我们可以只对其中的一部分进行验证，这大大减小了工作量。 以太坊还有很多地方用到了散列函数，例如：区块链上的地址，是由散列法运算公钥而得到的。一个以太坊的账户地址，是以Keccak-256散列法运算一个公钥而得出的。以太坊上的签名是由私钥和需要被签名的数据散列而生成的。 三．以太坊的未来发展 目前的以太坊存在的问题还很多，比如一直都存在的可扩展性问题，由于以太坊节点需要存储这个区块链网络上发生的所有事情，因此存储成本非常昂贵，并且这种成本可能会随着系统的扩展而呈现指数增长。针对这一问题，以太坊的创始人提出了“分片”的解决方案，具体思想是标是将状态以某种形式进行分片, 从而让多个在大多数情况下独立的应用程序以并行的方式处理。很自然地，我们会怀疑，在分片之后，发起一笔交易将就只会在涉及到的几个节点间引起波动，还能确保它们相互之间传递的信息的真实性吗？针对这一问题，以太坊是依靠验证管理合约来保证真实性的。每一个区块，和每一个分片，都会经过随机可靠的验证管理合约核实查证。所以，如果要实现欺骗的目的，使得一个“说谎”的验证器能够被系统接受，你必须在攻破接管整个系统中大部分的验证器之后才能实现。 再比如隐私风险问题，，在以太坊中，隐私保护是非常重要的，目前针对这一问题，比较热门的解决方案是，zk-SNARKs（简明非交互零知识证明），这一解决方案的原理是，让一个证明者，在不提供任何额外的有用信息的情况下，使验证者相信某个论断是正确的，是一种概率证明而不是确定性证明。以Alice和Bob为例，Alice现在有一把钥匙，她需要向Bob证明她拥有这个钥匙。有两种做法，第一种是Alice把钥匙给Bob，Bob拿这个钥匙开了门进去，Bob知道Alice确实拥有进门的钥匙。另外一种做法是，Bob知道这个房子里有一样东西，他告诉Alice，Alice到房间里把这个东西拿出来给Bob看。由于Alice能做到这一点，Bob知道Alice有开门的钥匙。这第二种方法就体现了零知识证明的思想，当然这是一种概率证明，并不是确定性证明。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/01/22/243a4224831e45fbfe36728483bcc970.html" />
<meta property="og:url" content="https://mlh.app/2018/01/22/243a4224831e45fbfe36728483bcc970.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"摘 要 区块链的本质上是一个去中心化的数据库。它使用密码学的相关方法产生数据块，每一个数据块中包含了一次比特币网络交易的所有信息，因此可以用来验证其信息的有效性和生成下一个区块。 区块链格式首先被应用于比特币。2008年10月，在中本聪的论文中，“区块”和“链”这两个字是被分开使用的，而在被广泛使用时被合称为区块-链，到2016年才被变成一个词：“区块链”。 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 以太坊平台应用了许多信息安全及密码学相关的技术，例如，时间戳， 非对称加密， 哈希函数， Merkle树等。 一．以太坊概述 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 上面的以太坊介绍是官方的，我通过查阅大量资料之后，有一些自己的理解。关于比特币技术，我们可以假想有一本记账本，这个记账本有一个特性：全世界每个参与者都有它的副本，即任何一个人在上面记录了一笔交易，那么这个记录立刻就会出现在全世界所有的副本上，所有的参与者也就都知道了这笔交易，同时任何人都不能擦除账本上的任何记录。 在上面例子的基础上来介绍一次交易过程： 1.Alice希望能转账10比特币给Bob。 2.Alice需要提供Alice的地址（通过对Alice的公钥进行hash得到），Bob的地址，以及转账数目。同时Alice使用自己的私钥对这笔交易进行签名。 3.这笔交易被发送到已签署交易池，等待验证。 4.系统验证完Alice的账户中确实有大于10比特币的财富，则认为这笔交易是有效的。 5.验证完成之后将这笔交易发送到已验证交易池中，所有的交易都验证完成后，打包成一个区块 ，该区块以加密方式签署，并添加到区块链上。 6.区块链更新，所有参与者下载新的区块链，也就是说Alice这笔交易显示在了所有人的账本上。 7.Bob此时收到了Alice的10个比特币。 以上的过程简单介绍了比特币的原理，以太坊在这个基础之上则有了进一步的发展，可以创建一些自动执行的小程序。例如，Alice可以添加一个小程序：“如果1月4号的NBA比赛，雷霆赢了湖人，则转账10比特币给Bob”该小程序可以在赛后自动获取比赛结果，从而判断是否需要转账给Bob。这种小程序的官方名称是智能合约。 智能合约有两个特性，一是任何参与者都可以检查源代码，保证了可信度，二是，智能合约不能被突然删除，例如，Alice看了球赛的上半场，觉得雷霆快赢了，想反悔，删掉小程序，但是这种操作是不被允许的。 二．以太坊关键技术 以太坊采用了许多信息安全及密码学的相关技术，大致有5个，工作量证明（POW），椭圆曲线密码，哈希函数，Merkle Tree,以及电子时间戳机制。 2.1 工作量证明 工作量证明机制(Proof of Work, POW)为区块链关键技术，简单来说就是用来确认你做过一定的工作量的证明。主要特征是工作者须要做出一定难度的工作才能得出结果，但验证方却可以根据该结果很容易的检查出工作者是否做了相对应的工作。流程如下图所示。 如图所示，左边的矿工需要解答密码学谜题以“挖出”一个区块并加入到区块链上。这一个过程要求大量的电力和运算。在系统中，这些谜题已经被设计成艰难而又繁重。当一个矿工解决一个谜题的时候，他们发布他们的区块到网络上接受验证。右边的人验证区块是否属于一条链是一个非常简单且快速的过程。 在工作量证明机制中也使用了哈希函数，矿工在完成计算之后，对计算结果采用Hashcash算法作为POW，其他节点可以用相关的数学公式，即可容易地验证出该数值(新区块)是否有效。 但是，目前来看，工作量证明存在非常多的问题。首先，也是最重要的，工作量证明是个极端低效的系统，因为它消耗大量的电力和能量。 其次，工作量证明并不是抗ASIC的，也就是说，可以购买更快更强劲的ASIC设备的人们和机构通常可以比其他人拥有更高的概率挖到区块。 针对以上这些缺点，人们提出了权益证明（POS），权益证明将让整个挖矿过程虚拟化，并以验证者取代矿工。首先，验证者必须锁定一些他们拥有的币作为保证金。在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。 2.2 椭圆曲线密码 在区块链中使用的公钥密码算法是基于椭圆代数的特性开发的椭圆曲线算法。椭圆曲线算法的安全性依赖于著名的数学难题，离散对数问题。椭圆曲线密码的加解密过程如下图。 如上图所示，用户Alice选定一条椭圆曲线Ep(a，b)，并取椭圆曲线上一点，作为基点P；用户A选择一个私有密钥k，并生成公开密钥L=kP；用户A将Ep(a，b)和点L、P传给用户Bob；用户Bob接到信息后，将待传输的明文编码到Ep(a，b)上一点M，并产生一个随机整数x(x小于r)；用户Bob计算点C1=M+xL，C2=xP；用户Bob将C1,C2传给用户Alice；用户Alice接到信息后，计算C1-LC2，结果就是点M。 椭圆曲线密码的出现也是受到了RSA算法的启发，RSA方法的优点主要在于原理简单，易于使用。但是，随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，作为RSA加解密安全保障的大整数要求越来越大。为了保证RSA使用的安全性，其密钥的位数一直在增加，但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对RSA的应用带来了很重的负担，对进行大量安全交易的电子商务更是如此，从而使得其应用范围越来越受到制约。 椭圆曲线加密方法与RSA方法相比，有以下优点：(1)安全性能更高。加密算法的安全性能一般通过该算法的抗攻击强度来反映。ECC和其他几种公钥系统相比，其抗攻击性具有绝对的优势。如160bitECC与1024bitRSA、有相同的安全强度。（2）处理速度快，在私钥处理上（签名与解密），ECC远比RSA快。（3）存储空间占用小，ECC的密钥尺寸比RSA要小的多。 2.3 Merkle Tree Merkle Tree多数是用来进行比对和验证处理，用户先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 Merkle Tree可以看作是哈希表的泛化，因此它的主要特征也就是哈希函数的主要特征即，输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的，因此可以用来进行验证处理。 Merkle Tree协议对以太坊的长期持续性可以说是至关重要的。区块链网络中存储所有区块的全部数据的节点所需的内存空间急速增长。Merkle Tree协议使以太坊在运行过程中，只需下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 2.4 时间戳机制 在以太坊中，要求参与交易各方不能否认其行为。这其中需要在经过数字签名的交易上打上一个可信赖的时间戳，从而解决一系列的实际和法律问题。时间戳服务工作流程大致如下：首先用户对文件数据进行Hash摘要处理；用户提出时间戳的请求，Hash值被传递给时间戳服务器；时间戳服务器对哈希值和一个日期/时间记录进行签名，生成时间戳；时间戳数据和文件信息绑定后返还，用户进行下一步电子交易操作。 2.5哈希函数 首先简单介绍一下哈希函数，一个可靠的单向哈希函数必须具备以下特性：（1）输入任意长度数据必须输出固定长度的散列值；（2）能够快速计算出散列值；（3）输入数据有细小差别也要导致散列值差别很大；（4）具备单向性，无法根据散列值反推出原始数据。常见的单向散列函数包括MD4/MD5、SHA-1/SHA-256/SHA-384/SHA-512、RIPEMD/RIPEMD-160、以及以Keccak算法作为标准的SHA-3系列函数。其中MD4/MD5、SHA-1、RIPEMD已经存在攻破的算法，不推荐在极其敏感环境下使用。以太坊中常用的哈希函数有SHA-256,Keccak-256等。 如上图，每一个打包好的区块中都有一个prehash值，这个值是指前一个区块（通常是区块头）的哈希值，在以太坊中此处使用的是SHA-256算法。在需要遍历验证所有区块时，便是通过preHash值索引到上一个区块直至创始区块。同时，在上图中还有一个值得关注的成员：MRH（Merkle Root Hash）即默克尔树根节点哈希值。在区块链的每个Block中都存放了一定数量被矿工打包的交易，区块链的交易记录是不容篡改的。而检测区块中的交易是否被篡改便是根据默克尔树根哈希的值前后是否一致来判断。 2.3中已经介绍过默克尔树，默克尔树的本质就是一个泛化的哈希表，当需要验证区块中的一笔交易是否被篡改过时，我们只需要验证这笔交易的哈希值，同时默克尔树还有一个优点，针对大块数据我们可以只对其中的一部分进行验证，这大大减小了工作量。 以太坊还有很多地方用到了散列函数，例如：区块链上的地址，是由散列法运算公钥而得到的。一个以太坊的账户地址，是以Keccak-256散列法运算一个公钥而得出的。以太坊上的签名是由私钥和需要被签名的数据散列而生成的。 三．以太坊的未来发展 目前的以太坊存在的问题还很多，比如一直都存在的可扩展性问题，由于以太坊节点需要存储这个区块链网络上发生的所有事情，因此存储成本非常昂贵，并且这种成本可能会随着系统的扩展而呈现指数增长。针对这一问题，以太坊的创始人提出了“分片”的解决方案，具体思想是标是将状态以某种形式进行分片, 从而让多个在大多数情况下独立的应用程序以并行的方式处理。很自然地，我们会怀疑，在分片之后，发起一笔交易将就只会在涉及到的几个节点间引起波动，还能确保它们相互之间传递的信息的真实性吗？针对这一问题，以太坊是依靠验证管理合约来保证真实性的。每一个区块，和每一个分片，都会经过随机可靠的验证管理合约核实查证。所以，如果要实现欺骗的目的，使得一个“说谎”的验证器能够被系统接受，你必须在攻破接管整个系统中大部分的验证器之后才能实现。 再比如隐私风险问题，，在以太坊中，隐私保护是非常重要的，目前针对这一问题，比较热门的解决方案是，zk-SNARKs（简明非交互零知识证明），这一解决方案的原理是，让一个证明者，在不提供任何额外的有用信息的情况下，使验证者相信某个论断是正确的，是一种概率证明而不是确定性证明。以Alice和Bob为例，Alice现在有一把钥匙，她需要向Bob证明她拥有这个钥匙。有两种做法，第一种是Alice把钥匙给Bob，Bob拿这个钥匙开了门进去，Bob知道Alice确实拥有进门的钥匙。另外一种做法是，Bob知道这个房子里有一样东西，他告诉Alice，Alice到房间里把这个东西拿出来给Bob看。由于Alice能做到这一点，Bob知道Alice有开门的钥匙。这第二种方法就体现了零知识证明的思想，当然这是一种概率证明，并不是确定性证明。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/01/22/243a4224831e45fbfe36728483bcc970.html","headline":"区块链实例以太坊原理探讨","dateModified":"2018-01-22T00:00:00+08:00","datePublished":"2018-01-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/01/22/243a4224831e45fbfe36728483bcc970.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链实例以太坊原理探讨</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><strong>摘 要</strong> <br> 区块链的本质上是一个去中心化的数据库。它使用密码学的相关方法产生数据块，每一个数据块中包含了一次比特币网络交易的所有信息，因此可以用来验证其信息的有效性和生成下一个区块。 <br> 区块链格式首先被应用于比特币。2008年10月，在中本聪的论文中，“区块”和“链”这两个字是被分开使用的，而在被广泛使用时被合称为区块-链，到2016年才被变成一个词：“区块链”。 <br> 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 <br> 以太坊平台应用了许多信息安全及密码学相关的技术，例如，时间戳， 非对称加密， 哈希函数， Merkle树等。</p> 
  <p><strong>一．以太坊概述</strong> <br> 以太坊（Ethereum）是一个开放的区块链平台，可以让任何人都能够创建和使用基于区块链技术的去中心化应用程序。与比特币一样，没有人控制或拥有以太坊，它是一个由全世界的许多人所共通创建的开源项目。 不同于比特币的是，以太坊被设计成灵活的、可根据需求修改的模式。 <br> 上面的以太坊介绍是官方的，我通过查阅大量资料之后，有一些自己的理解。关于比特币技术，我们可以假想有一本记账本，这个记账本有一个特性：全世界每个参与者都有它的副本，即任何一个人在上面记录了一笔交易，那么这个记录立刻就会出现在全世界所有的副本上，所有的参与者也就都知道了这笔交易，同时任何人都不能擦除账本上的任何记录。 <br> 在上面例子的基础上来介绍一次交易过程： <br> 1.Alice希望能转账10比特币给Bob。 <br> 2.Alice需要提供Alice的地址（通过对Alice的公钥进行hash得到），Bob的地址，以及转账数目。同时Alice使用自己的私钥对这笔交易进行签名。 <br> 3.这笔交易被发送到已签署交易池，等待验证。 <br> 4.系统验证完Alice的账户中确实有大于10比特币的财富，则认为这笔交易是有效的。 <br> 5.验证完成之后将这笔交易发送到已验证交易池中，所有的交易都验证完成后，打包成一个区块 ，该区块以加密方式签署，并添加到区块链上。 <br> 6.区块链更新，所有参与者下载新的区块链，也就是说Alice这笔交易显示在了所有人的账本上。 <br> 7.Bob此时收到了Alice的10个比特币。 <br> 以上的过程简单介绍了比特币的原理，以太坊在这个基础之上则有了进一步的发展，可以创建一些自动执行的小程序。例如，Alice可以添加一个小程序：“如果1月4号的NBA比赛，雷霆赢了湖人，则转账10比特币给Bob”该小程序可以在赛后自动获取比赛结果，从而判断是否需要转账给Bob。这种小程序的官方名称是智能合约。 <br> 智能合约有两个特性，一是任何参与者都可以检查源代码，保证了可信度，二是，智能合约不能被突然删除，例如，Alice看了球赛的上半场，觉得雷霆快赢了，想反悔，删掉小程序，但是这种操作是不被允许的。 <br> <strong>二．以太坊关键技术</strong> <br> 以太坊采用了许多信息安全及密码学的相关技术，大致有5个，工作量证明（POW），椭圆曲线密码，哈希函数，Merkle Tree,以及电子时间戳机制。 <br> 2.1 工作量证明 <br> 工作量证明机制(Proof of Work, POW)为区块链关键技术，简单来说就是用来确认你做过一定的工作量的证明。主要特征是工作者须要做出一定难度的工作才能得出结果，但验证方却可以根据该结果很容易的检查出工作者是否做了相对应的工作。流程如下图所示。<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180122152158655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FyeV9nb2Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title=""></p> 
  <p>如图所示，左边的矿工需要解答密码学谜题以“挖出”一个区块并加入到区块链上。这一个过程要求大量的电力和运算。在系统中，这些谜题已经被设计成艰难而又繁重。当一个矿工解决一个谜题的时候，他们发布他们的区块到网络上接受验证。右边的人验证区块是否属于一条链是一个非常简单且快速的过程。 <br> 在工作量证明机制中也使用了哈希函数，矿工在完成计算之后，对计算结果采用Hashcash算法作为POW，其他节点可以用相关的数学公式，即可容易地验证出该数值(新区块)是否有效。 <br> 但是，目前来看，工作量证明存在非常多的问题。首先，也是最重要的，工作量证明是个极端低效的系统，因为它消耗大量的电力和能量。 <br> 其次，工作量证明并不是抗ASIC的，也就是说，可以购买更快更强劲的ASIC设备的人们和机构通常可以比其他人拥有更高的概率挖到区块。 <br> 针对以上这些缺点，人们提出了权益证明（POS），权益证明将让整个挖矿过程虚拟化，并以验证者取代矿工。首先，验证者必须锁定一些他们拥有的币作为保证金。在此之后，他们将开始验证区块。同时，当他们发现一个他们认为可以被加到链上的区块时，他们会通过下赌注来验证它。如果该区块成功上链，验证者就将得到一个与他们的赌注成比例的奖励。</p> 
  <p>2.2 椭圆曲线密码</p> 
  <p>在区块链中使用的公钥密码算法是基于椭圆代数的特性开发的椭圆曲线算法。椭圆曲线算法的安全性依赖于著名的数学难题，离散对数问题。椭圆曲线密码的加解密过程如下图。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180122152348604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FyeV9nb2Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>如上图所示，用户Alice选定一条椭圆曲线Ep(a，b)，并取椭圆曲线上一点，作为基点P；用户A选择一个私有密钥k，并生成公开密钥L=kP；用户A将Ep(a，b)和点L、P传给用户Bob；用户Bob接到信息后，将待传输的明文编码到Ep(a，b)上一点M，并产生一个随机整数x(x小于r)；用户Bob计算点C1=M+xL，C2=xP；用户Bob将C1,C2传给用户Alice；用户Alice接到信息后，计算C1-LC2，结果就是点M。 <br> 椭圆曲线密码的出现也是受到了RSA算法的启发，RSA方法的优点主要在于原理简单，易于使用。但是，随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，作为RSA加解密安全保障的大整数要求越来越大。为了保证RSA使用的安全性，其密钥的位数一直在增加，但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对RSA的应用带来了很重的负担，对进行大量安全交易的电子商务更是如此，从而使得其应用范围越来越受到制约。 <br> 椭圆曲线加密方法与RSA方法相比，有以下优点：(1)安全性能更高。加密算法的安全性能一般通过该算法的抗攻击强度来反映。ECC和其他几种公钥系统相比，其抗攻击性具有绝对的优势。如160bitECC与1024bitRSA、有相同的安全强度。（2）处理速度快，在私钥处理上（签名与解密），ECC远比RSA快。（3）存储空间占用小，ECC的密钥尺寸比RSA要小的多。</p> 
  <p>2.3 Merkle Tree <br> Merkle Tree多数是用来进行比对和验证处理，用户先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 <br> Merkle Tree可以看作是哈希表的泛化，因此它的主要特征也就是哈希函数的主要特征即，输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的，因此可以用来进行验证处理。 <br> Merkle Tree协议对以太坊的长期持续性可以说是至关重要的。区块链网络中存储所有区块的全部数据的节点所需的内存空间急速增长。Merkle Tree协议使以太坊在运行过程中，只需下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。</p> 
  <p>2.4 时间戳机制 <br> 在以太坊中，要求参与交易各方不能否认其行为。这其中需要在经过数字签名的交易上打上一个可信赖的时间戳，从而解决一系列的实际和法律问题。时间戳服务工作流程大致如下：首先用户对文件数据进行Hash摘要处理；用户提出时间戳的请求，Hash值被传递给时间戳服务器；时间戳服务器对哈希值和一个日期/时间记录进行签名，生成时间戳；时间戳数据和文件信息绑定后返还，用户进行下一步电子交易操作。</p> 
  <p>2.5哈希函数 <br> 首先简单介绍一下哈希函数，一个可靠的单向哈希函数必须具备以下特性：（1）输入任意长度数据必须输出固定长度的散列值；（2）能够快速计算出散列值；（3）输入数据有细小差别也要导致散列值差别很大；（4）具备单向性，无法根据散列值反推出原始数据。常见的单向散列函数包括MD4/MD5、SHA-1/SHA-256/SHA-384/SHA-512、RIPEMD/RIPEMD-160、以及以Keccak算法作为标准的SHA-3系列函数。其中MD4/MD5、SHA-1、RIPEMD已经存在攻破的算法，不推荐在极其敏感环境下使用。以太坊中常用的哈希函数有SHA-256,Keccak-256等。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180122152930901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2FyeV9nb2Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>如上图，每一个打包好的区块中都有一个prehash值，这个值是指前一个区块（通常是区块头）的哈希值，在以太坊中此处使用的是SHA-256算法。在需要遍历验证所有区块时，便是通过preHash值索引到上一个区块直至创始区块。同时，在上图中还有一个值得关注的成员：MRH（Merkle Root Hash）即默克尔树根节点哈希值。在区块链的每个Block中都存放了一定数量被矿工打包的交易，区块链的交易记录是不容篡改的。而检测区块中的交易是否被篡改便是根据默克尔树根哈希的值前后是否一致来判断。 <br> 2.3中已经介绍过默克尔树，默克尔树的本质就是一个泛化的哈希表，当需要验证区块中的一笔交易是否被篡改过时，我们只需要验证这笔交易的哈希值，同时默克尔树还有一个优点，针对大块数据我们可以只对其中的一部分进行验证，这大大减小了工作量。 <br> 以太坊还有很多地方用到了散列函数，例如：区块链上的地址，是由散列法运算公钥而得到的。一个以太坊的账户地址，是以Keccak-256散列法运算一个公钥而得出的。以太坊上的签名是由私钥和需要被签名的数据散列而生成的。</p> 
  <p><strong>三．以太坊的未来发展</strong></p> 
  <p>目前的以太坊存在的问题还很多，比如一直都存在的可扩展性问题，由于以太坊节点需要存储这个区块链网络上发生的所有事情，因此存储成本非常昂贵，并且这种成本可能会随着系统的扩展而呈现指数增长。针对这一问题，以太坊的创始人提出了“分片”的解决方案，具体思想是标是将状态以某种形式进行分片, 从而让多个在大多数情况下独立的应用程序以并行的方式处理。很自然地，我们会怀疑，在分片之后，发起一笔交易将就只会在涉及到的几个节点间引起波动，还能确保它们相互之间传递的信息的真实性吗？针对这一问题，以太坊是依靠验证管理合约来保证真实性的。每一个区块，和每一个分片，都会经过随机可靠的验证管理合约核实查证。所以，如果要实现欺骗的目的，使得一个“说谎”的验证器能够被系统接受，你必须在攻破接管整个系统中大部分的验证器之后才能实现。 <br> 再比如隐私风险问题，，在以太坊中，隐私保护是非常重要的，目前针对这一问题，比较热门的解决方案是，zk-SNARKs（简明非交互零知识证明），这一解决方案的原理是，让一个证明者，在不提供任何额外的有用信息的情况下，使验证者相信某个论断是正确的，是一种概率证明而不是确定性证明。以Alice和Bob为例，Alice现在有一把钥匙，她需要向Bob证明她拥有这个钥匙。有两种做法，第一种是Alice把钥匙给Bob，Bob拿这个钥匙开了门进去，Bob知道Alice确实拥有进门的钥匙。另外一种做法是，Bob知道这个房子里有一样东西，他告诉Alice，Alice到房间里把这个东西拿出来给Bob看。由于Alice能做到这一点，Bob知道Alice有开门的钥匙。这第二种方法就体现了零知识证明的思想，当然这是一种概率证明，并不是确定性证明。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Gary_god/article/details/79129531,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Gary_god/article/details/79129531,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
