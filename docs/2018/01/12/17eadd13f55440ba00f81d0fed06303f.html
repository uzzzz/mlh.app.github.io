<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>在以太坊钱包中发行自己的数字货币 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="在以太坊钱包中发行自己的数字货币" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="以太坊钱包自带合约开发功能，这个应该是最简单的智能合约开发方式。 不过首次启动以太坊钱包后需要同步测试网络的block，这个比较费时间。虽然以太坊钱包列出了除主网外的3个测试网络，但只有Rinkeby可以用（也可能是我没有找Ropsten和Solo网络的正确启动方法）。 Rinkeby测试网络需要需要先获得测试币，获得测试币的网站连接是：&nbsp;https://faucet.rinkeby.io/ 获得测试币的方法是：把自己的地址发到Google+或者facebook（需要翻墙）上的一篇文章里，然后把这篇文章的地址输入上面网址，然后选择测试币额度，系统就会自动赠送。 拿到测试币后，就可以开始发行自己的数字货币了。以太坊上的数字货币也是一种智能合约。参考官方的文档： https://www.ethereum.org/token#the-code 因为编译器更新了，官方文档中的智能合约代码无法正常编译，下面是我修改后可以编译的（今天是2018.1.12，也可能后面编译器升级后又无法编译了）： pragma solidity ^0.4.17; contract MyToken { /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; event Transfer(address indexed from, address indexed to, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public { balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes decimals = decimalUnits; // Amount of decimals for display purposes } function transfer(address _to, uint256 _value) public { /* Check if sender has balance and for overflows */ require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; /* Notify anyone listening that this transfer took place */ Transfer(msg.sender, _to, _value); } } 注意官方文档关于return和throw的区别说明： To stop a contract execution mid execution you can either&nbsp;return&nbsp;or&nbsp;throw&nbsp;The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, &#39;throw&#39; will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any ether to be spent at all. 阅读更多" />
<meta property="og:description" content="以太坊钱包自带合约开发功能，这个应该是最简单的智能合约开发方式。 不过首次启动以太坊钱包后需要同步测试网络的block，这个比较费时间。虽然以太坊钱包列出了除主网外的3个测试网络，但只有Rinkeby可以用（也可能是我没有找Ropsten和Solo网络的正确启动方法）。 Rinkeby测试网络需要需要先获得测试币，获得测试币的网站连接是：&nbsp;https://faucet.rinkeby.io/ 获得测试币的方法是：把自己的地址发到Google+或者facebook（需要翻墙）上的一篇文章里，然后把这篇文章的地址输入上面网址，然后选择测试币额度，系统就会自动赠送。 拿到测试币后，就可以开始发行自己的数字货币了。以太坊上的数字货币也是一种智能合约。参考官方的文档： https://www.ethereum.org/token#the-code 因为编译器更新了，官方文档中的智能合约代码无法正常编译，下面是我修改后可以编译的（今天是2018.1.12，也可能后面编译器升级后又无法编译了）： pragma solidity ^0.4.17; contract MyToken { /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; event Transfer(address indexed from, address indexed to, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public { balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes decimals = decimalUnits; // Amount of decimals for display purposes } function transfer(address _to, uint256 _value) public { /* Check if sender has balance and for overflows */ require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; /* Notify anyone listening that this transfer took place */ Transfer(msg.sender, _to, _value); } } 注意官方文档关于return和throw的区别说明： To stop a contract execution mid execution you can either&nbsp;return&nbsp;or&nbsp;throw&nbsp;The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, &#39;throw&#39; will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any ether to be spent at all. 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/01/12/17eadd13f55440ba00f81d0fed06303f.html" />
<meta property="og:url" content="https://mlh.app/2018/01/12/17eadd13f55440ba00f81d0fed06303f.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"以太坊钱包自带合约开发功能，这个应该是最简单的智能合约开发方式。 不过首次启动以太坊钱包后需要同步测试网络的block，这个比较费时间。虽然以太坊钱包列出了除主网外的3个测试网络，但只有Rinkeby可以用（也可能是我没有找Ropsten和Solo网络的正确启动方法）。 Rinkeby测试网络需要需要先获得测试币，获得测试币的网站连接是：&nbsp;https://faucet.rinkeby.io/ 获得测试币的方法是：把自己的地址发到Google+或者facebook（需要翻墙）上的一篇文章里，然后把这篇文章的地址输入上面网址，然后选择测试币额度，系统就会自动赠送。 拿到测试币后，就可以开始发行自己的数字货币了。以太坊上的数字货币也是一种智能合约。参考官方的文档： https://www.ethereum.org/token#the-code 因为编译器更新了，官方文档中的智能合约代码无法正常编译，下面是我修改后可以编译的（今天是2018.1.12，也可能后面编译器升级后又无法编译了）： pragma solidity ^0.4.17; contract MyToken { /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; event Transfer(address indexed from, address indexed to, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public { balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes decimals = decimalUnits; // Amount of decimals for display purposes } function transfer(address _to, uint256 _value) public { /* Check if sender has balance and for overflows */ require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; /* Notify anyone listening that this transfer took place */ Transfer(msg.sender, _to, _value); } } 注意官方文档关于return和throw的区别说明： To stop a contract execution mid execution you can either&nbsp;return&nbsp;or&nbsp;throw&nbsp;The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, &#39;throw&#39; will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any ether to be spent at all. 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/01/12/17eadd13f55440ba00f81d0fed06303f.html","headline":"在以太坊钱包中发行自己的数字货币","dateModified":"2018-01-12T00:00:00+08:00","datePublished":"2018-01-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/01/12/17eadd13f55440ba00f81d0fed06303f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>在以太坊钱包中发行自己的数字货币</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>以太坊钱包自带合约开发功能，这个应该是最简单的智能合约开发方式。</p> 
  <p>不过首次启动以太坊钱包后需要同步测试网络的block，这个比较费时间。虽然以太坊钱包列出了除主网外的3个测试网络，但只有Rinkeby可以用（也可能是我没有找Ropsten和Solo网络的正确启动方法）。</p> 
  <p>Rinkeby测试网络需要需要先获得测试币，获得测试币的网站连接是：&nbsp;<a href="https://faucet.rinkeby.io/" rel="nofollow" style="color:rgb(42,88,111);font-family:'lucida Grande', Verdana;font-size:14px;">https://faucet.rinkeby.io/</a></p> 
  <p>获得测试币的方法是：把自己的地址发到Google+或者facebook（需要翻墙）上的一篇文章里，然后把这篇文章的地址输入上面网址，然后选择测试币额度，系统就会自动赠送。</p> 
  <p>拿到测试币后，就可以开始发行自己的数字货币了。以太坊上的数字货币也是一种智能合约。参考官方的文档：</p> 
  <p><a href="https://www.ethereum.org/token#the-code" rel="nofollow">https://www.ethereum.org/token#the-code</a><br></p> 
  <p>因为编译器更新了，官方文档中的智能合约代码无法正常编译，下面是我修改后可以编译的（今天是2018.1.12，也可能后面编译器升级后又无法编译了）：</p> 
  <p><br></p> 
  <p></p> 
  <pre><code class="language-plain">pragma solidity ^0.4.17;

contract MyToken {
    /* This creates an array with all balances */
    mapping (address =&gt; uint256) public balanceOf;
    
    string public name;
	string public symbol;
	uint8 public decimals;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
        
    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {
        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
    }
        
    function transfer(address _to, uint256 _value) public {
        /* Check if sender has balance and for overflows */
        require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);

        /* Add and subtract new balances */
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        /* Notify anyone listening that this transfer took place */
        Transfer(msg.sender, _to, _value);        
    }
}
    </code></pre> 
  <br>
  <br>
  <p><br></p> 
  <p><br></p> 
  <p>注意官方文档关于return和throw的区别说明：</p> 
  <p><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);">To stop a contract execution mid execution you can either&nbsp;</span><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);">return</span><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);">&nbsp;or&nbsp;</span><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);">throw</span><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);">&nbsp;The former will cost less gas but it can be more headache as any changes you did to the contract so far will be kept. In the other hand, 'throw' will cancel all contract execution, revert any changes that transaction could have made and the sender will lose all ether he sent for gas. But since the Wallet can detect that a contract will throw, it always shows an alert, therefore preventing any ether to be spent at all.</span><br></p> 
  <p><span style="color:rgb(68,58,55);font-family:'Source Sans Pro', 'Helvetica Neue', Helvetica, arial, sans-serif;font-size:17px;background-color:rgb(245,245,245);"><br></span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/leonqiu/article/details/79042687,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/leonqiu/article/details/79042687,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
