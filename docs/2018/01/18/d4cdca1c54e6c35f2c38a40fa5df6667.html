<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>关于区块链的解读和简单Python实现-bmwgaara的博客 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="关于区块链的解读和简单Python实现-bmwgaara的博客" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="概念解读 区块链几乎是数日间成为人尽皆知的名词，这个名词也勾起了我强烈的兴趣，但是通过在网上搜罗资料，多方阅读，发现很多介绍区块链的文献要么模棱两可，要么作者本身的理解也很有限，导致很多关键的问题叙述不清。本人花了一些时间总结归纳，希望可以给读者一个比较全面清晰的认识。 区块链的官方定义是：一个分布式账本，一种通过去中心化、去信任的方式集体维护一个可靠数据库的技术方案。那么对于圈外人该如何理解呢？以下我会详细描述一个区块链的产生过程和实现意义，从而给大家构建出一个清晰的区块链概念。我们先讲原理、再说特点、然后论用途、最后回归代码，这样你就会有一种恍然大悟的感觉。 我们以btc为例：“区块链”，顾名思义，就是由一个个区块依次连接起来组成的链条，可以类比为一条无限长度的直线铁链，每个铁环就是一个区块。那么区块的内容应该是什么呢？区块狭义上是有两种的，一个是普通区块，一个就是创世区块。创世区块就是一项区块链项目中的第一个区块，由于个人水平有限，对创世区块没有做过详细研究，但是根据我的了解，创世区块应该是具备与普通区块相似结构的，但会肯定会加入一些创始人想说的东西，并且在有些项目中可能会多一条记录，就是coin的发行量，例如swtc的6000亿数目就是写在创世区块之中的，一旦发行，无法修改。 那么，一个普通区块中到底有什么？ 1.index：就是从0-n依次产生的数字，可以称之为链高度。 2.hash：一个长度为256位随机数，是这个区块的唯一编号。 3.previous hash：上一个区块的hash，一个普通区块有且仅有一个previous hash，这就是区块链之所以称为链的原因，就是这么一环套一环链接而成的。 4.tempstamp：用于记录该区块诞生的时间。 5.difficulty：直观体现创造该区块的难度。 6.nonce：随机数，用于产生下一个区块。 上述的都存在区块头中。 7.data：存储的交易记录。只有这个存在区块体中。 Ok，上述提到了一个区块需要具备的最基本的几条要素，可能你现在还处于一脸懵逼的状态：这些东西到底是怎么工作的呢？下面我将一步步分析区块链的工作过程，不过，这里要先问两个问题：为什么要产生新的区块？怎么产生新的区块？ 为什么产生新区快？ 之前说了，一个区块记录的就是一份账单，账单中存储着若干条交易记录，是买卖双方具体活动的最有力的证明，例如我们在淘宝上的购买记录，就是我们的消费账单。人们每天的消费记录是不断增长的，不可能永远放在一个区块里，那么跟现在的中心化存储机制还有什么区别？所以，随着买卖记录的不断增加，就需要不断产生新的区块来存储这些数据。 怎么产生新的区块？ 我相信，最近除了区块链这个名词如雷贯耳以外，“挖矿”应该也没少听吧。挖矿实际上就是由那些矿工来生成新的区块的过程。在btc项目中，btc矿工挖矿成功（其实就是成功的创建了一个区块）就可以获得一定数量的被btc奖励，所以btc数量是在一定范围内慢慢增加的。在一般允许挖矿的区块链项目（也存在限制coin数量不允许挖矿的区块链项目）中，矿工的数量一般会大于6个，一般超过6个矿工认可的新区块就可以加入到区块链中。到此为止，有人会说：哇！btc这么值钱，挖矿不是很爽？其实不然，如果区块无限制的快速增加，会引起很大的问题，根据中本聪的设定，目前全网每10分钟只能产生一个新区块。而且这10分钟不是靠自己掐表算的，生成新的区块是需要大量的运算的，这10分钟是人家预先设计好的，让计算量大到全网10分钟一般只能产生一个。 好了，至此，区块链的基本概念已经介绍的差不多了，下面言归正传，讲下区块的工作流程： 1.如果A要和B达成一笔交易，比如A转给B一个btc，B给A打10w的RMB。A首先将自己的btc来源信息、交易人等发送给B，同时还要拷贝一份发到全网。什么？这样还有隐私可言吗？当然，聪明的中本聪当然不会犯这么低级的错误。在区块链中，每个交易个体（也可以理解为每个网络节点）都会有一对公钥和私钥，公钥相当于一个“收款地址”，而私钥是一个表明自己身份的256位的数字，目前一般是用sha265来生成的，这样，别人并不知道交易的双方是谁。发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用自己的私钥对摘要进行加密，加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。 2.那么此时，这笔交易是否就完成了呢？如果这就算完成了，那跟A直接用包裹装10w现金快递给B有什么区别呢？此时，全网的矿工都会得到这个交易记录，那么全网的矿工都会为了若干奖励开始创建区块的工作，矿工会利用hash函数生成一个256位的唯一编号赋予这个区块，但是这个编号并不是简简单单随便生成的。编号是根据区块的具体内容如交易内容、nonce等唯一确定的，换句话说，两块内容相同的区块所对应的编号一定是唯一的。可是你会问：这又怎么了？并不难啊。错！中本聪为了控制区块的生成时间，使区块的生成速率满足全网的每10分钟一个的标准，制定了严格的区块生成校验规则，也就是说，能不能生成一个成功的区块要看你的编号是否符合这个规则。例如：生成编号中的前n位必须为‘0’。 由于区块的交易内容是无法修改的，因此矿工们只能通过修改nonce去不断尝试这个函数，直到生成了一个成功的区块为止。如果当区块平均生成时间变快或者变慢，那么系统会对区块校验规则进行相应的调整，从而使平均的生成时间能够控制在规定范围。 如果一个矿工完成了一个区块，会立刻告知其他矿工，如果其他矿工此时没有完成新的区块生成，则会停下手头的工作，对区块进行验证，需要确认的信息主要有如下几点： 1）.区块的编号有效；这个只要将区块放入哈希函数中，看产生的编号是否和该区块中的编号一致即可。 2）.区块的前一个区块有效；之前提过，区块是一个串联的，每一个普通区块都会记载前一个区块的编号，这需要其他矿工对比当前的区块链的最后一个区块，看是否相同。 3）.交易清单有效；就是说要验证A到底有没有这一个btc可以给B。在区块链的交易信息中，会记录交易中所有btc的前世今生，区块链可以做到追本溯源，因此每一个btc在哪里，为什么在这里都可以一目了然，所以这点也没问题。 当验证完一个全新的区块后，全网就会认为这个区块有效，会将它添加到现有的区块链末端，同时结束针对该区块的挖矿工作，投入到下一个挖矿周期中。 3.但是不难想象，这样的机制是存在冲突的隐患的，就是这么巧，两个矿工同时制作了一个正确的区块，那么此时不必二选一，可以将原来线性的区块链改成树状： 但是这样会导致未来在A、B后都会增加相应的区块，那么谁长谁将作为主链延伸下去，另一个也许会渐渐被遗忘，除非哪天它变得更长。 好啦，这就是区块链最基本的知识，接下来应该谈谈优缺点了。 世界上没有一样东西可以称为完美无瑕的，要知道区块链一样，虽然它被扣上了可以颠覆未来的帽子，但是仍然存在它的局限性：1.时效性。很容易发现，区块链中存在很多的验证、传递环节，这就会导致其时效性较差。2、能耗，这点也是显而易见的，区块链需要大量无用计算来控制区块的生成时间。所以区块链不适用于高时效的网络中。 至于区块链的优点，诸如安全、去中心化等等在网络上已经描述的非常清楚，这里就不再赘述。接下来我用一段python代码来简单实现一个挖矿的流程。 代码示例 首先创建一个表示区块链的类： class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) 初始化函数中的chain表示当前的区块链，我会在其中存储区块对象；pitmen表示为这个区块链服务的矿工们，这个列表中也会存有矿工对象；results则会存储每个阶段产生的区块；new_block方法是创建区块的方法，如果当前生成的区块为第一个区块，则产生创世区块。 下面看看区块链类型的方法： @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None last_block会返回当前区块链的最后一个区块对象。 def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) get_trans方法则用来随机生成一份交易信息。 def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] 这是生成区块的核心部分，这个方法主要分成两个部分：根据传参区分是否是创世区块，如果需要的是创世区块，那就由该类型自动生成一个区块占据区块链的头一个位置。如果需要生成的是普通区块，那么则会将一些基本信息分发给矿工们进行挖矿操作。我在这里设置了6个矿工，为了公平起见，这里也开了个多线程尽量让矿工们同时收到消息从而可以同时进行挖矿操作。按理说，最先挖矿成功的矿工会将消息发给其他矿工，其他矿工会立刻停止进行校验，但由于时间有限，这一步校验环节我没有实现。在这里，我允许所有矿工都完成工作，并提交成果和相应的工作时间，生成耗时最短的区块讲作为正确的区块添加到区块链上。本质上也是依照了“快者优先”的区块链生成原则。 说了半天，区块内部到底是什么样的呢？ class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } 我用了一个相对简单的类型表示区块，在这里区块就是一个非常简单的数据结构，这里的所有字段在上述中已经有了详细的说明，因此不再赘述。 那么我们再看看矿工，毕竟矿工才是区块链的生产者和推动者，地位最为核心。矿工类中我设计了两个方法，一个mine方法，也就是挖矿的意思，用来生成新的区块，并会返回该区块生成的用时长短。 def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime 另一个方法是hash生成的方法，生成原则我自己意淫了一个，大家莫怪，因为本人计算机的实在不给力，区块的成功标准很简单，就是用sha256生成的编码最后结尾是0就满足要求，如果改成00，那会半天看不到结果。 下面我们看下这套实例的运行结果，我设置了一个长度为6的区块链，由于第一个区块是创世区块，所以真正开始创建的区块是从第二个开始的，大家注意index。 这是6个矿工完成的第一区块： All blocks generated by pitmen: {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;c3ba406bad0d87f816f629830a15e2997638bfa230484c224e5470eaa24d8790&#39;, &#39;Nonce&#39;: 62372, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;9o8UMDLe&quot;, &quot;recipient&quot;: &quot;qTOQu7kv&quot;, &quot;amount&quot;: 2746}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;8ff243885e9017296aa2ef1a611ef5b3927ddce818cb7255a04ff3228c982c60&#39;, &#39;Nonce&#39;: 67644, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;kIqy1c8C&quot;, &quot;recipient&quot;: &quot;WSdK0EXh&quot;, &quot;amount&quot;: 9329}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;ff9716bf9379e2ab7a8640419e7c7b7c7329a5e6e1bbf83a1249f49d070ca8b0&#39;, &#39;Nonce&#39;: 37336, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;vBwU0luH&quot;, &quot;recipient&quot;: &quot;d7o6cRCj&quot;, &quot;amount&quot;: 5628}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;3410c70c31f9bacbfcbd74d63f25f69f27d36075e2d44bddaa60bd72fa042e60&#39;, &#39;Nonce&#39;: 34617, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;yzcNpBnh&quot;, &quot;recipient&quot;: &quot;vbIr7SKo&quot;, &quot;amount&quot;: 6387}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;91e3dc3ef1a151557a1edd837528410b916362bcfb77dbb14dc54c8929f5a0d0&#39;, &#39;Nonce&#39;: 49121, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;p1MguhVz&quot;, &quot;recipient&quot;: &quot;gVSom4D3&quot;, &quot;amount&quot;: 7356}&#39;} 很明显前两个是最快的，为了简单，我在最快的里面随便选取一个，意思到了就行。大家可以看到，难度值，根据上文所说，这是反应一个区块生成的难易程度的，难度高的，在我这里会表示这个矿工为了得到这个区块进行了多少次尝试。看到这里也许你会问：为什么难度最大的时间并没有明显长呢？也就是用时并没有按照难度的增加而增加。我猜想应该是因为我的示例算法简单，因此结果也不是十分精确，如果计算量达到一定的规模，应该会有明显的差距。（如果有高人知道，可以回复我，在此谢过！）第三到第六个的区块创建结果格式是与之一样的，就不刷屏了。 最后看下整个区块链的结果： {&#39;Index&#39;: 0, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 0, &#39;Hash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;Nonce&#39;: 87688, &#39;PreviousHash&#39;: &#39;0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OuVCmHbs&quot;, &quot;recipient&quot;: &quot;kFxbwSLc&quot;, &quot;amount&quot;: 503}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 2, &#39;Time&#39;: 1516268156.5991132, &#39;Difficulty&#39;: 4, &#39;Hash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;Nonce&#39;: 12875, &#39;PreviousHash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;HJZSX1hk&quot;, &quot;recipient&quot;: &quot;j82k51yY&quot;, &quot;amount&quot;: 3521}&#39;} {&#39;Index&#39;: 3, &#39;Time&#39;: 1516268156.6001143, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;Nonce&#39;: 18663, &#39;PreviousHash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;cJrGxN5R&quot;, &quot;recipient&quot;: &quot;wkZI8QCv&quot;, &quot;amount&quot;: 1224}&#39;} {&#39;Index&#39;: 4, &#39;Time&#39;: 1516268156.601114, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;Nonce&#39;: 51446, &#39;PreviousHash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;nCNJoy52&quot;, &quot;recipient&quot;: &quot;kYBT9f65&quot;, &quot;amount&quot;: 3603}&#39;} {&#39;Index&#39;: 5, &#39;Time&#39;: 1516268156.605163, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;765f69163cf95584721015e3ce819c1980ce33752f8a4dea553d3bedd39f8920&#39;, &#39;Nonce&#39;: 31804, &#39;PreviousHash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;FqOkiTEu&quot;, &quot;recipient&quot;: &quot;y9EDcSYA&quot;, &quot;amount&quot;: 4185}&#39;} 这就是由这6个矿工依次创建的六个区块，根据hash值环环相扣。 到底我想说的基本就结束了，最后我想说区块链是个神奇的技术，从听到它就深深的吸引着我，期望未来区块链可以真的带来巨大的变革。要知道，随着AI的兴起，区块链的问世，属于程序员的数字时代会进一步升华，互联网时代只是一个开始！谢谢阅读，本人水平有限，如果您发现问题或我理解偏差的地方可以及时指出，在本文下方回复或者邮箱695509060@qq.com都可以，再次表示感谢。文章末尾会附上完整代码，本文由作者原创，所有版权归属作者。我是隔壁小王。 import hashlib import random import string import json import threading from decimal import Decimal from time import time class MyThread(threading.Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.args = args def run(self): self.result = self.func(*self.args) def get_result(self): try: return self.result except Exception: return None class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] def show_chain(self): print(&#39;This is mine first block chain!&#39;) for block in self.chain: print(block.get_block()) class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } class Pitman: def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime @staticmethod def generate_hash(previousHash, transactionData): difficulty = 0 nonce = random.randrange(0, 99999) guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() while myhash[-1] != &#39;0&#39;: difficulty += 1 nonce += difficulty guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() return difficulty, myhash, nonce if __name__ == &#39;__main__&#39;: chain = BlockChain(1) length = 5 for i in range(length): chain.new_block() chain.show_chain() 阅读更多" />
<meta property="og:description" content="概念解读 区块链几乎是数日间成为人尽皆知的名词，这个名词也勾起了我强烈的兴趣，但是通过在网上搜罗资料，多方阅读，发现很多介绍区块链的文献要么模棱两可，要么作者本身的理解也很有限，导致很多关键的问题叙述不清。本人花了一些时间总结归纳，希望可以给读者一个比较全面清晰的认识。 区块链的官方定义是：一个分布式账本，一种通过去中心化、去信任的方式集体维护一个可靠数据库的技术方案。那么对于圈外人该如何理解呢？以下我会详细描述一个区块链的产生过程和实现意义，从而给大家构建出一个清晰的区块链概念。我们先讲原理、再说特点、然后论用途、最后回归代码，这样你就会有一种恍然大悟的感觉。 我们以btc为例：“区块链”，顾名思义，就是由一个个区块依次连接起来组成的链条，可以类比为一条无限长度的直线铁链，每个铁环就是一个区块。那么区块的内容应该是什么呢？区块狭义上是有两种的，一个是普通区块，一个就是创世区块。创世区块就是一项区块链项目中的第一个区块，由于个人水平有限，对创世区块没有做过详细研究，但是根据我的了解，创世区块应该是具备与普通区块相似结构的，但会肯定会加入一些创始人想说的东西，并且在有些项目中可能会多一条记录，就是coin的发行量，例如swtc的6000亿数目就是写在创世区块之中的，一旦发行，无法修改。 那么，一个普通区块中到底有什么？ 1.index：就是从0-n依次产生的数字，可以称之为链高度。 2.hash：一个长度为256位随机数，是这个区块的唯一编号。 3.previous hash：上一个区块的hash，一个普通区块有且仅有一个previous hash，这就是区块链之所以称为链的原因，就是这么一环套一环链接而成的。 4.tempstamp：用于记录该区块诞生的时间。 5.difficulty：直观体现创造该区块的难度。 6.nonce：随机数，用于产生下一个区块。 上述的都存在区块头中。 7.data：存储的交易记录。只有这个存在区块体中。 Ok，上述提到了一个区块需要具备的最基本的几条要素，可能你现在还处于一脸懵逼的状态：这些东西到底是怎么工作的呢？下面我将一步步分析区块链的工作过程，不过，这里要先问两个问题：为什么要产生新的区块？怎么产生新的区块？ 为什么产生新区快？ 之前说了，一个区块记录的就是一份账单，账单中存储着若干条交易记录，是买卖双方具体活动的最有力的证明，例如我们在淘宝上的购买记录，就是我们的消费账单。人们每天的消费记录是不断增长的，不可能永远放在一个区块里，那么跟现在的中心化存储机制还有什么区别？所以，随着买卖记录的不断增加，就需要不断产生新的区块来存储这些数据。 怎么产生新的区块？ 我相信，最近除了区块链这个名词如雷贯耳以外，“挖矿”应该也没少听吧。挖矿实际上就是由那些矿工来生成新的区块的过程。在btc项目中，btc矿工挖矿成功（其实就是成功的创建了一个区块）就可以获得一定数量的被btc奖励，所以btc数量是在一定范围内慢慢增加的。在一般允许挖矿的区块链项目（也存在限制coin数量不允许挖矿的区块链项目）中，矿工的数量一般会大于6个，一般超过6个矿工认可的新区块就可以加入到区块链中。到此为止，有人会说：哇！btc这么值钱，挖矿不是很爽？其实不然，如果区块无限制的快速增加，会引起很大的问题，根据中本聪的设定，目前全网每10分钟只能产生一个新区块。而且这10分钟不是靠自己掐表算的，生成新的区块是需要大量的运算的，这10分钟是人家预先设计好的，让计算量大到全网10分钟一般只能产生一个。 好了，至此，区块链的基本概念已经介绍的差不多了，下面言归正传，讲下区块的工作流程： 1.如果A要和B达成一笔交易，比如A转给B一个btc，B给A打10w的RMB。A首先将自己的btc来源信息、交易人等发送给B，同时还要拷贝一份发到全网。什么？这样还有隐私可言吗？当然，聪明的中本聪当然不会犯这么低级的错误。在区块链中，每个交易个体（也可以理解为每个网络节点）都会有一对公钥和私钥，公钥相当于一个“收款地址”，而私钥是一个表明自己身份的256位的数字，目前一般是用sha265来生成的，这样，别人并不知道交易的双方是谁。发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用自己的私钥对摘要进行加密，加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。 2.那么此时，这笔交易是否就完成了呢？如果这就算完成了，那跟A直接用包裹装10w现金快递给B有什么区别呢？此时，全网的矿工都会得到这个交易记录，那么全网的矿工都会为了若干奖励开始创建区块的工作，矿工会利用hash函数生成一个256位的唯一编号赋予这个区块，但是这个编号并不是简简单单随便生成的。编号是根据区块的具体内容如交易内容、nonce等唯一确定的，换句话说，两块内容相同的区块所对应的编号一定是唯一的。可是你会问：这又怎么了？并不难啊。错！中本聪为了控制区块的生成时间，使区块的生成速率满足全网的每10分钟一个的标准，制定了严格的区块生成校验规则，也就是说，能不能生成一个成功的区块要看你的编号是否符合这个规则。例如：生成编号中的前n位必须为‘0’。 由于区块的交易内容是无法修改的，因此矿工们只能通过修改nonce去不断尝试这个函数，直到生成了一个成功的区块为止。如果当区块平均生成时间变快或者变慢，那么系统会对区块校验规则进行相应的调整，从而使平均的生成时间能够控制在规定范围。 如果一个矿工完成了一个区块，会立刻告知其他矿工，如果其他矿工此时没有完成新的区块生成，则会停下手头的工作，对区块进行验证，需要确认的信息主要有如下几点： 1）.区块的编号有效；这个只要将区块放入哈希函数中，看产生的编号是否和该区块中的编号一致即可。 2）.区块的前一个区块有效；之前提过，区块是一个串联的，每一个普通区块都会记载前一个区块的编号，这需要其他矿工对比当前的区块链的最后一个区块，看是否相同。 3）.交易清单有效；就是说要验证A到底有没有这一个btc可以给B。在区块链的交易信息中，会记录交易中所有btc的前世今生，区块链可以做到追本溯源，因此每一个btc在哪里，为什么在这里都可以一目了然，所以这点也没问题。 当验证完一个全新的区块后，全网就会认为这个区块有效，会将它添加到现有的区块链末端，同时结束针对该区块的挖矿工作，投入到下一个挖矿周期中。 3.但是不难想象，这样的机制是存在冲突的隐患的，就是这么巧，两个矿工同时制作了一个正确的区块，那么此时不必二选一，可以将原来线性的区块链改成树状： 但是这样会导致未来在A、B后都会增加相应的区块，那么谁长谁将作为主链延伸下去，另一个也许会渐渐被遗忘，除非哪天它变得更长。 好啦，这就是区块链最基本的知识，接下来应该谈谈优缺点了。 世界上没有一样东西可以称为完美无瑕的，要知道区块链一样，虽然它被扣上了可以颠覆未来的帽子，但是仍然存在它的局限性：1.时效性。很容易发现，区块链中存在很多的验证、传递环节，这就会导致其时效性较差。2、能耗，这点也是显而易见的，区块链需要大量无用计算来控制区块的生成时间。所以区块链不适用于高时效的网络中。 至于区块链的优点，诸如安全、去中心化等等在网络上已经描述的非常清楚，这里就不再赘述。接下来我用一段python代码来简单实现一个挖矿的流程。 代码示例 首先创建一个表示区块链的类： class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) 初始化函数中的chain表示当前的区块链，我会在其中存储区块对象；pitmen表示为这个区块链服务的矿工们，这个列表中也会存有矿工对象；results则会存储每个阶段产生的区块；new_block方法是创建区块的方法，如果当前生成的区块为第一个区块，则产生创世区块。 下面看看区块链类型的方法： @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None last_block会返回当前区块链的最后一个区块对象。 def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) get_trans方法则用来随机生成一份交易信息。 def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] 这是生成区块的核心部分，这个方法主要分成两个部分：根据传参区分是否是创世区块，如果需要的是创世区块，那就由该类型自动生成一个区块占据区块链的头一个位置。如果需要生成的是普通区块，那么则会将一些基本信息分发给矿工们进行挖矿操作。我在这里设置了6个矿工，为了公平起见，这里也开了个多线程尽量让矿工们同时收到消息从而可以同时进行挖矿操作。按理说，最先挖矿成功的矿工会将消息发给其他矿工，其他矿工会立刻停止进行校验，但由于时间有限，这一步校验环节我没有实现。在这里，我允许所有矿工都完成工作，并提交成果和相应的工作时间，生成耗时最短的区块讲作为正确的区块添加到区块链上。本质上也是依照了“快者优先”的区块链生成原则。 说了半天，区块内部到底是什么样的呢？ class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } 我用了一个相对简单的类型表示区块，在这里区块就是一个非常简单的数据结构，这里的所有字段在上述中已经有了详细的说明，因此不再赘述。 那么我们再看看矿工，毕竟矿工才是区块链的生产者和推动者，地位最为核心。矿工类中我设计了两个方法，一个mine方法，也就是挖矿的意思，用来生成新的区块，并会返回该区块生成的用时长短。 def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime 另一个方法是hash生成的方法，生成原则我自己意淫了一个，大家莫怪，因为本人计算机的实在不给力，区块的成功标准很简单，就是用sha256生成的编码最后结尾是0就满足要求，如果改成00，那会半天看不到结果。 下面我们看下这套实例的运行结果，我设置了一个长度为6的区块链，由于第一个区块是创世区块，所以真正开始创建的区块是从第二个开始的，大家注意index。 这是6个矿工完成的第一区块： All blocks generated by pitmen: {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;c3ba406bad0d87f816f629830a15e2997638bfa230484c224e5470eaa24d8790&#39;, &#39;Nonce&#39;: 62372, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;9o8UMDLe&quot;, &quot;recipient&quot;: &quot;qTOQu7kv&quot;, &quot;amount&quot;: 2746}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;8ff243885e9017296aa2ef1a611ef5b3927ddce818cb7255a04ff3228c982c60&#39;, &#39;Nonce&#39;: 67644, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;kIqy1c8C&quot;, &quot;recipient&quot;: &quot;WSdK0EXh&quot;, &quot;amount&quot;: 9329}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;ff9716bf9379e2ab7a8640419e7c7b7c7329a5e6e1bbf83a1249f49d070ca8b0&#39;, &#39;Nonce&#39;: 37336, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;vBwU0luH&quot;, &quot;recipient&quot;: &quot;d7o6cRCj&quot;, &quot;amount&quot;: 5628}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;3410c70c31f9bacbfcbd74d63f25f69f27d36075e2d44bddaa60bd72fa042e60&#39;, &#39;Nonce&#39;: 34617, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;yzcNpBnh&quot;, &quot;recipient&quot;: &quot;vbIr7SKo&quot;, &quot;amount&quot;: 6387}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;91e3dc3ef1a151557a1edd837528410b916362bcfb77dbb14dc54c8929f5a0d0&#39;, &#39;Nonce&#39;: 49121, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;p1MguhVz&quot;, &quot;recipient&quot;: &quot;gVSom4D3&quot;, &quot;amount&quot;: 7356}&#39;} 很明显前两个是最快的，为了简单，我在最快的里面随便选取一个，意思到了就行。大家可以看到，难度值，根据上文所说，这是反应一个区块生成的难易程度的，难度高的，在我这里会表示这个矿工为了得到这个区块进行了多少次尝试。看到这里也许你会问：为什么难度最大的时间并没有明显长呢？也就是用时并没有按照难度的增加而增加。我猜想应该是因为我的示例算法简单，因此结果也不是十分精确，如果计算量达到一定的规模，应该会有明显的差距。（如果有高人知道，可以回复我，在此谢过！）第三到第六个的区块创建结果格式是与之一样的，就不刷屏了。 最后看下整个区块链的结果： {&#39;Index&#39;: 0, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 0, &#39;Hash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;Nonce&#39;: 87688, &#39;PreviousHash&#39;: &#39;0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OuVCmHbs&quot;, &quot;recipient&quot;: &quot;kFxbwSLc&quot;, &quot;amount&quot;: 503}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 2, &#39;Time&#39;: 1516268156.5991132, &#39;Difficulty&#39;: 4, &#39;Hash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;Nonce&#39;: 12875, &#39;PreviousHash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;HJZSX1hk&quot;, &quot;recipient&quot;: &quot;j82k51yY&quot;, &quot;amount&quot;: 3521}&#39;} {&#39;Index&#39;: 3, &#39;Time&#39;: 1516268156.6001143, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;Nonce&#39;: 18663, &#39;PreviousHash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;cJrGxN5R&quot;, &quot;recipient&quot;: &quot;wkZI8QCv&quot;, &quot;amount&quot;: 1224}&#39;} {&#39;Index&#39;: 4, &#39;Time&#39;: 1516268156.601114, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;Nonce&#39;: 51446, &#39;PreviousHash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;nCNJoy52&quot;, &quot;recipient&quot;: &quot;kYBT9f65&quot;, &quot;amount&quot;: 3603}&#39;} {&#39;Index&#39;: 5, &#39;Time&#39;: 1516268156.605163, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;765f69163cf95584721015e3ce819c1980ce33752f8a4dea553d3bedd39f8920&#39;, &#39;Nonce&#39;: 31804, &#39;PreviousHash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;FqOkiTEu&quot;, &quot;recipient&quot;: &quot;y9EDcSYA&quot;, &quot;amount&quot;: 4185}&#39;} 这就是由这6个矿工依次创建的六个区块，根据hash值环环相扣。 到底我想说的基本就结束了，最后我想说区块链是个神奇的技术，从听到它就深深的吸引着我，期望未来区块链可以真的带来巨大的变革。要知道，随着AI的兴起，区块链的问世，属于程序员的数字时代会进一步升华，互联网时代只是一个开始！谢谢阅读，本人水平有限，如果您发现问题或我理解偏差的地方可以及时指出，在本文下方回复或者邮箱695509060@qq.com都可以，再次表示感谢。文章末尾会附上完整代码，本文由作者原创，所有版权归属作者。我是隔壁小王。 import hashlib import random import string import json import threading from decimal import Decimal from time import time class MyThread(threading.Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.args = args def run(self): self.result = self.func(*self.args) def get_result(self): try: return self.result except Exception: return None class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] def show_chain(self): print(&#39;This is mine first block chain!&#39;) for block in self.chain: print(block.get_block()) class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } class Pitman: def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime @staticmethod def generate_hash(previousHash, transactionData): difficulty = 0 nonce = random.randrange(0, 99999) guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() while myhash[-1] != &#39;0&#39;: difficulty += 1 nonce += difficulty guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() return difficulty, myhash, nonce if __name__ == &#39;__main__&#39;: chain = BlockChain(1) length = 5 for i in range(length): chain.new_block() chain.show_chain() 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"概念解读 区块链几乎是数日间成为人尽皆知的名词，这个名词也勾起了我强烈的兴趣，但是通过在网上搜罗资料，多方阅读，发现很多介绍区块链的文献要么模棱两可，要么作者本身的理解也很有限，导致很多关键的问题叙述不清。本人花了一些时间总结归纳，希望可以给读者一个比较全面清晰的认识。 区块链的官方定义是：一个分布式账本，一种通过去中心化、去信任的方式集体维护一个可靠数据库的技术方案。那么对于圈外人该如何理解呢？以下我会详细描述一个区块链的产生过程和实现意义，从而给大家构建出一个清晰的区块链概念。我们先讲原理、再说特点、然后论用途、最后回归代码，这样你就会有一种恍然大悟的感觉。 我们以btc为例：“区块链”，顾名思义，就是由一个个区块依次连接起来组成的链条，可以类比为一条无限长度的直线铁链，每个铁环就是一个区块。那么区块的内容应该是什么呢？区块狭义上是有两种的，一个是普通区块，一个就是创世区块。创世区块就是一项区块链项目中的第一个区块，由于个人水平有限，对创世区块没有做过详细研究，但是根据我的了解，创世区块应该是具备与普通区块相似结构的，但会肯定会加入一些创始人想说的东西，并且在有些项目中可能会多一条记录，就是coin的发行量，例如swtc的6000亿数目就是写在创世区块之中的，一旦发行，无法修改。 那么，一个普通区块中到底有什么？ 1.index：就是从0-n依次产生的数字，可以称之为链高度。 2.hash：一个长度为256位随机数，是这个区块的唯一编号。 3.previous hash：上一个区块的hash，一个普通区块有且仅有一个previous hash，这就是区块链之所以称为链的原因，就是这么一环套一环链接而成的。 4.tempstamp：用于记录该区块诞生的时间。 5.difficulty：直观体现创造该区块的难度。 6.nonce：随机数，用于产生下一个区块。 上述的都存在区块头中。 7.data：存储的交易记录。只有这个存在区块体中。 Ok，上述提到了一个区块需要具备的最基本的几条要素，可能你现在还处于一脸懵逼的状态：这些东西到底是怎么工作的呢？下面我将一步步分析区块链的工作过程，不过，这里要先问两个问题：为什么要产生新的区块？怎么产生新的区块？ 为什么产生新区快？ 之前说了，一个区块记录的就是一份账单，账单中存储着若干条交易记录，是买卖双方具体活动的最有力的证明，例如我们在淘宝上的购买记录，就是我们的消费账单。人们每天的消费记录是不断增长的，不可能永远放在一个区块里，那么跟现在的中心化存储机制还有什么区别？所以，随着买卖记录的不断增加，就需要不断产生新的区块来存储这些数据。 怎么产生新的区块？ 我相信，最近除了区块链这个名词如雷贯耳以外，“挖矿”应该也没少听吧。挖矿实际上就是由那些矿工来生成新的区块的过程。在btc项目中，btc矿工挖矿成功（其实就是成功的创建了一个区块）就可以获得一定数量的被btc奖励，所以btc数量是在一定范围内慢慢增加的。在一般允许挖矿的区块链项目（也存在限制coin数量不允许挖矿的区块链项目）中，矿工的数量一般会大于6个，一般超过6个矿工认可的新区块就可以加入到区块链中。到此为止，有人会说：哇！btc这么值钱，挖矿不是很爽？其实不然，如果区块无限制的快速增加，会引起很大的问题，根据中本聪的设定，目前全网每10分钟只能产生一个新区块。而且这10分钟不是靠自己掐表算的，生成新的区块是需要大量的运算的，这10分钟是人家预先设计好的，让计算量大到全网10分钟一般只能产生一个。 好了，至此，区块链的基本概念已经介绍的差不多了，下面言归正传，讲下区块的工作流程： 1.如果A要和B达成一笔交易，比如A转给B一个btc，B给A打10w的RMB。A首先将自己的btc来源信息、交易人等发送给B，同时还要拷贝一份发到全网。什么？这样还有隐私可言吗？当然，聪明的中本聪当然不会犯这么低级的错误。在区块链中，每个交易个体（也可以理解为每个网络节点）都会有一对公钥和私钥，公钥相当于一个“收款地址”，而私钥是一个表明自己身份的256位的数字，目前一般是用sha265来生成的，这样，别人并不知道交易的双方是谁。发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用自己的私钥对摘要进行加密，加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。 2.那么此时，这笔交易是否就完成了呢？如果这就算完成了，那跟A直接用包裹装10w现金快递给B有什么区别呢？此时，全网的矿工都会得到这个交易记录，那么全网的矿工都会为了若干奖励开始创建区块的工作，矿工会利用hash函数生成一个256位的唯一编号赋予这个区块，但是这个编号并不是简简单单随便生成的。编号是根据区块的具体内容如交易内容、nonce等唯一确定的，换句话说，两块内容相同的区块所对应的编号一定是唯一的。可是你会问：这又怎么了？并不难啊。错！中本聪为了控制区块的生成时间，使区块的生成速率满足全网的每10分钟一个的标准，制定了严格的区块生成校验规则，也就是说，能不能生成一个成功的区块要看你的编号是否符合这个规则。例如：生成编号中的前n位必须为‘0’。 由于区块的交易内容是无法修改的，因此矿工们只能通过修改nonce去不断尝试这个函数，直到生成了一个成功的区块为止。如果当区块平均生成时间变快或者变慢，那么系统会对区块校验规则进行相应的调整，从而使平均的生成时间能够控制在规定范围。 如果一个矿工完成了一个区块，会立刻告知其他矿工，如果其他矿工此时没有完成新的区块生成，则会停下手头的工作，对区块进行验证，需要确认的信息主要有如下几点： 1）.区块的编号有效；这个只要将区块放入哈希函数中，看产生的编号是否和该区块中的编号一致即可。 2）.区块的前一个区块有效；之前提过，区块是一个串联的，每一个普通区块都会记载前一个区块的编号，这需要其他矿工对比当前的区块链的最后一个区块，看是否相同。 3）.交易清单有效；就是说要验证A到底有没有这一个btc可以给B。在区块链的交易信息中，会记录交易中所有btc的前世今生，区块链可以做到追本溯源，因此每一个btc在哪里，为什么在这里都可以一目了然，所以这点也没问题。 当验证完一个全新的区块后，全网就会认为这个区块有效，会将它添加到现有的区块链末端，同时结束针对该区块的挖矿工作，投入到下一个挖矿周期中。 3.但是不难想象，这样的机制是存在冲突的隐患的，就是这么巧，两个矿工同时制作了一个正确的区块，那么此时不必二选一，可以将原来线性的区块链改成树状： 但是这样会导致未来在A、B后都会增加相应的区块，那么谁长谁将作为主链延伸下去，另一个也许会渐渐被遗忘，除非哪天它变得更长。 好啦，这就是区块链最基本的知识，接下来应该谈谈优缺点了。 世界上没有一样东西可以称为完美无瑕的，要知道区块链一样，虽然它被扣上了可以颠覆未来的帽子，但是仍然存在它的局限性：1.时效性。很容易发现，区块链中存在很多的验证、传递环节，这就会导致其时效性较差。2、能耗，这点也是显而易见的，区块链需要大量无用计算来控制区块的生成时间。所以区块链不适用于高时效的网络中。 至于区块链的优点，诸如安全、去中心化等等在网络上已经描述的非常清楚，这里就不再赘述。接下来我用一段python代码来简单实现一个挖矿的流程。 代码示例 首先创建一个表示区块链的类： class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) 初始化函数中的chain表示当前的区块链，我会在其中存储区块对象；pitmen表示为这个区块链服务的矿工们，这个列表中也会存有矿工对象；results则会存储每个阶段产生的区块；new_block方法是创建区块的方法，如果当前生成的区块为第一个区块，则产生创世区块。 下面看看区块链类型的方法： @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None last_block会返回当前区块链的最后一个区块对象。 def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) get_trans方法则用来随机生成一份交易信息。 def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] 这是生成区块的核心部分，这个方法主要分成两个部分：根据传参区分是否是创世区块，如果需要的是创世区块，那就由该类型自动生成一个区块占据区块链的头一个位置。如果需要生成的是普通区块，那么则会将一些基本信息分发给矿工们进行挖矿操作。我在这里设置了6个矿工，为了公平起见，这里也开了个多线程尽量让矿工们同时收到消息从而可以同时进行挖矿操作。按理说，最先挖矿成功的矿工会将消息发给其他矿工，其他矿工会立刻停止进行校验，但由于时间有限，这一步校验环节我没有实现。在这里，我允许所有矿工都完成工作，并提交成果和相应的工作时间，生成耗时最短的区块讲作为正确的区块添加到区块链上。本质上也是依照了“快者优先”的区块链生成原则。 说了半天，区块内部到底是什么样的呢？ class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } 我用了一个相对简单的类型表示区块，在这里区块就是一个非常简单的数据结构，这里的所有字段在上述中已经有了详细的说明，因此不再赘述。 那么我们再看看矿工，毕竟矿工才是区块链的生产者和推动者，地位最为核心。矿工类中我设计了两个方法，一个mine方法，也就是挖矿的意思，用来生成新的区块，并会返回该区块生成的用时长短。 def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime 另一个方法是hash生成的方法，生成原则我自己意淫了一个，大家莫怪，因为本人计算机的实在不给力，区块的成功标准很简单，就是用sha256生成的编码最后结尾是0就满足要求，如果改成00，那会半天看不到结果。 下面我们看下这套实例的运行结果，我设置了一个长度为6的区块链，由于第一个区块是创世区块，所以真正开始创建的区块是从第二个开始的，大家注意index。 这是6个矿工完成的第一区块： All blocks generated by pitmen: {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;c3ba406bad0d87f816f629830a15e2997638bfa230484c224e5470eaa24d8790&#39;, &#39;Nonce&#39;: 62372, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;9o8UMDLe&quot;, &quot;recipient&quot;: &quot;qTOQu7kv&quot;, &quot;amount&quot;: 2746}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 5, &#39;Hash&#39;: &#39;8ff243885e9017296aa2ef1a611ef5b3927ddce818cb7255a04ff3228c982c60&#39;, &#39;Nonce&#39;: 67644, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;kIqy1c8C&quot;, &quot;recipient&quot;: &quot;WSdK0EXh&quot;, &quot;amount&quot;: 9329}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;ff9716bf9379e2ab7a8640419e7c7b7c7329a5e6e1bbf83a1249f49d070ca8b0&#39;, &#39;Nonce&#39;: 37336, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;vBwU0luH&quot;, &quot;recipient&quot;: &quot;d7o6cRCj&quot;, &quot;amount&quot;: 5628}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;3410c70c31f9bacbfcbd74d63f25f69f27d36075e2d44bddaa60bd72fa042e60&#39;, &#39;Nonce&#39;: 34617, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;yzcNpBnh&quot;, &quot;recipient&quot;: &quot;vbIr7SKo&quot;, &quot;amount&quot;: 6387}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5981123, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;91e3dc3ef1a151557a1edd837528410b916362bcfb77dbb14dc54c8929f5a0d0&#39;, &#39;Nonce&#39;: 49121, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;p1MguhVz&quot;, &quot;recipient&quot;: &quot;gVSom4D3&quot;, &quot;amount&quot;: 7356}&#39;} 很明显前两个是最快的，为了简单，我在最快的里面随便选取一个，意思到了就行。大家可以看到，难度值，根据上文所说，这是反应一个区块生成的难易程度的，难度高的，在我这里会表示这个矿工为了得到这个区块进行了多少次尝试。看到这里也许你会问：为什么难度最大的时间并没有明显长呢？也就是用时并没有按照难度的增加而增加。我猜想应该是因为我的示例算法简单，因此结果也不是十分精确，如果计算量达到一定的规模，应该会有明显的差距。（如果有高人知道，可以回复我，在此谢过！）第三到第六个的区块创建结果格式是与之一样的，就不刷屏了。 最后看下整个区块链的结果： {&#39;Index&#39;: 0, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 0, &#39;Hash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;Nonce&#39;: 87688, &#39;PreviousHash&#39;: &#39;0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OuVCmHbs&quot;, &quot;recipient&quot;: &quot;kFxbwSLc&quot;, &quot;amount&quot;: 503}&#39;} {&#39;Index&#39;: 1, &#39;Time&#39;: 1516268156.5971138, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;Nonce&#39;: 91554, &#39;PreviousHash&#39;: &#39;7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;OY8z0Rrx&quot;, &quot;recipient&quot;: &quot;iSGFJsEm&quot;, &quot;amount&quot;: 8723}&#39;} {&#39;Index&#39;: 2, &#39;Time&#39;: 1516268156.5991132, &#39;Difficulty&#39;: 4, &#39;Hash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;Nonce&#39;: 12875, &#39;PreviousHash&#39;: &#39;01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;HJZSX1hk&quot;, &quot;recipient&quot;: &quot;j82k51yY&quot;, &quot;amount&quot;: 3521}&#39;} {&#39;Index&#39;: 3, &#39;Time&#39;: 1516268156.6001143, &#39;Difficulty&#39;: 27, &#39;Hash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;Nonce&#39;: 18663, &#39;PreviousHash&#39;: &#39;098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;cJrGxN5R&quot;, &quot;recipient&quot;: &quot;wkZI8QCv&quot;, &quot;amount&quot;: 1224}&#39;} {&#39;Index&#39;: 4, &#39;Time&#39;: 1516268156.601114, &#39;Difficulty&#39;: 3, &#39;Hash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;Nonce&#39;: 51446, &#39;PreviousHash&#39;: &#39;7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;nCNJoy52&quot;, &quot;recipient&quot;: &quot;kYBT9f65&quot;, &quot;amount&quot;: 3603}&#39;} {&#39;Index&#39;: 5, &#39;Time&#39;: 1516268156.605163, &#39;Difficulty&#39;: 2, &#39;Hash&#39;: &#39;765f69163cf95584721015e3ce819c1980ce33752f8a4dea553d3bedd39f8920&#39;, &#39;Nonce&#39;: 31804, &#39;PreviousHash&#39;: &#39;60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0&#39;, &#39;TransactionData&#39;: &#39;{&quot;sender&quot;: &quot;FqOkiTEu&quot;, &quot;recipient&quot;: &quot;y9EDcSYA&quot;, &quot;amount&quot;: 4185}&#39;} 这就是由这6个矿工依次创建的六个区块，根据hash值环环相扣。 到底我想说的基本就结束了，最后我想说区块链是个神奇的技术，从听到它就深深的吸引着我，期望未来区块链可以真的带来巨大的变革。要知道，随着AI的兴起，区块链的问世，属于程序员的数字时代会进一步升华，互联网时代只是一个开始！谢谢阅读，本人水平有限，如果您发现问题或我理解偏差的地方可以及时指出，在本文下方回复或者邮箱695509060@qq.com都可以，再次表示感谢。文章末尾会附上完整代码，本文由作者原创，所有版权归属作者。我是隔壁小王。 import hashlib import random import string import json import threading from decimal import Decimal from time import time class MyThread(threading.Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.args = args def run(self): self.result = self.func(*self.args) def get_result(self): try: return self.result except Exception: return None class BlockChain: def __init__(self, initialHash): # init block chain self.chain = [] # init pitman self.pitmen = [] for i in range(6): self.pitmen.append(Pitman) # collect mine results self.results = [] # generate GenesisBlock self.new_block(initialHash) @property def last_block(self): if len(self.chain): return self.chain[-1] else: return None def get_trans(self): return json.dumps({ &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;amount&#39;: random.randrange(1, 10000) }) def new_block(self, initialHash=None): if initialHash: # generate Genesis Block block = Block() block.index = 0 block.nonce = random.randrange(0, 99999) block.previousHash = &#39;0&#39; block.difficulty = 0 block.transactionData = self.get_trans() guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() block.hash = hashlib.sha256(guess).hexdigest() block.time = time() self.chain.append(block) else: for i in range(len(self.pitmen)): pm = MyThread(target=self.pitmen[i].mine, args=(self.pitmen[i], len(self.chain), self.last_block.get_block()[&#39;Hash&#39;], self.get_trans())) pm.start() pm.join() self.results.append(pm.get_result()) # show all blocks print(&quot;All blocks generated by pitmen:&quot;) for result in self.results: print(result[0].get_block()) # get new block firstblock = self.results[0][0] mintime = Decimal(self.results[0][1]) for i in range(1, len(self.results)): if Decimal(self.results[i][1]) &lt; mintime: firstblock = self.results[i][0] else: continue self.chain.append(firstblock) self.results = [] def show_chain(self): print(&#39;This is mine first block chain!&#39;) for block in self.chain: print(block.get_block()) class Block: def __init__(self): self.index = None self.time = None self.difficulty = None self.nonce = None self.hash = None self.previousHash = None self.transactionData = None def get_block(self): return { &#39;Index&#39;: self.index, &#39;Time&#39;: self.time, &#39;Difficulty&#39;: self.difficulty, &#39;Hash&#39;: self.hash, &#39;Nonce&#39;: self.nonce, &#39;PreviousHash&#39;: self.previousHash, &#39;TransactionData&#39;: self.transactionData } class Pitman: def mine(self, index, previousHash, transactionData): beginTime = time() block = Block() block.index = index block.previousHash = previousHash block.transactionData = transactionData block.difficulty, block.hash, block.nonce = self.generate_hash(previousHash, transactionData) block.time = time() endTime = time() return block, endTime - beginTime @staticmethod def generate_hash(previousHash, transactionData): difficulty = 0 nonce = random.randrange(0, 99999) guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() while myhash[-1] != &#39;0&#39;: difficulty += 1 nonce += difficulty guess = f&#39;{previousHash}{nonce}{transactionData}&#39;.encode() myhash = hashlib.sha256(guess).hexdigest() return difficulty, myhash, nonce if __name__ == &#39;__main__&#39;: chain = BlockChain(1) length = 5 for i in range(length): chain.new_block() chain.show_chain() 阅读更多","@type":"BlogPosting","url":"/2018/01/18/d4cdca1c54e6c35f2c38a40fa5df6667.html","headline":"关于区块链的解读和简单Python实现-bmwgaara的博客","dateModified":"2018-01-18T00:00:00+08:00","datePublished":"2018-01-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/01/18/d4cdca1c54e6c35f2c38a40fa5df6667.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>关于区块链的解读和简单Python实现-bmwgaara的博客</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <h2>概念解读</h2> 
  <p><span></span></p> 
  <p><span></span>区块链几乎是数日间成为人尽皆知的名词，这个名词也勾起了我强烈的兴趣，但是通过在网上搜罗资料，多方阅读，发现很多介绍区块链的文献要么模棱两可，要么作者本身的理解也很有限，导致很多关键的问题叙述不清。本人花了一些时间总结归纳，希望可以给读者一个比较全面清晰的认识。</p> 
  <p><span></span>区块链的官方定义是：一个分布式账本，一种通过去中心化、去信任的方式集体维护一个可靠数据库的技术方案。那么对于圈外人该如何理解呢？以下我会详细描述一个区块链的产生过程和实现意义，从而给大家构建出一个清晰的区块链概念。我们先讲原理、再说特点、然后论用途、最后回归代码，这样你就会有一种恍然大悟的感觉。</p> 
  <p><span></span>我们以btc为例：“区块链”，顾名思义，就是由一个个区块依次连接起来组成的链条，可以类比为一条无限长度的直线铁链，每个铁环就是一个区块。那么区块的内容应该是什么呢？区块狭义上是有两种的，一个是普通区块，一个就是创世区块。创世区块就是一项区块链项目中的第一个区块，由于个人水平有限，对创世区块没有做过详细研究，但是根据我的了解，创世区块应该是具备与普通区块相似结构的，但会肯定会加入一些创始人想说的东西，并且在有些项目中可能会多一条记录，就是coin的发行量，例如swtc的6000亿数目就是写在创世区块之中的，一旦发行，无法修改。</p> 
  <p><span></span>那么，一个普通区块中到底有什么？</p> 
  <p><span></span>1.index：就是从0-n依次产生的数字，可以称之为链高度。</p> 
  <p><span></span>2.hash：一个长度为256位随机数，是这个区块的唯一编号。</p> 
  <p><span></span>3.previous hash：上一个区块的hash，一个普通区块有且仅有一个previous hash，这就是区块链之所以称为链的原因，就是这么一环套一环链接而成的。</p> 
  <p><span></span>4.tempstamp：用于记录该区块诞生的时间。</p> 
  <p><span></span>5.difficulty：直观体现创造该区块的难度。</p> 
  <p><span></span>6.nonce：随机数，用于产生下一个区块。</p> 
  <p><span></span>上述的都存在区块头中。</p> 
  <p><span></span>7.data：存储的交易记录。只有这个存在区块体中。</p> 
  <p><span></span>Ok，上述提到了一个区块需要具备的最基本的几条要素，可能你现在还处于一脸懵逼的状态：这些东西到底是怎么工作的呢？下面我将一步步分析区块链的工作过程，不过，这里要先问两个问题：为什么要产生新的区块？怎么产生新的区块？</p> 
  <p><span></span><strong>为什么产生新区快？</strong></p> 
  <p><span></span>之前说了，一个区块记录的就是一份账单，账单中存储着若干条交易记录，是买卖双方具体活动的最有力的证明，例如我们在淘宝上的购买记录，就是我们的消费账单。人们每天的消费记录是不断增长的，不可能永远放在一个区块里，那么跟现在的中心化存储机制还有什么区别？所以，随着买卖记录的不断增加，就需要不断产生新的区块来存储这些数据。</p> 
  <p><span></span><strong>怎么产生新的区块？</strong></p> 
  <p><span></span>我相信，最近除了区块链这个名词如雷贯耳以外，“挖矿”应该也没少听吧。挖矿实际上就是由那些矿工来生成新的区块的过程。在btc项目中，btc矿工挖矿成功（其实就是成功的创建了一个区块）就可以获得一定数量的被btc奖励，所以btc数量是在一定范围内慢慢增加的。在一般允许挖矿的区块链项目（也存在限制coin数量不允许挖矿的区块链项目）中，矿工的数量一般会大于6个，一般超过6个矿工认可的新区块就可以加入到区块链中。到此为止，有人会说：哇！btc这么值钱，挖矿不是很爽？其实不然，如果区块无限制的快速增加，会引起很大的问题，<span style="color:rgb(79,79,79);text-align:justify;">根据中本聪的设定，目前全网每10分钟只能产生一个新区块。而且这10分钟不是靠自己掐表算的，生成新的区块是需要大量的运算的，这10分钟是人家预先设计好的，让计算量大到全网10分钟一般只能产生一个。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>好了，至此，区块链的基本概念已经介绍的差不多了，下面言归正传，讲下区块的工作流程：</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>1.如果A要和B达成一笔交易，比如A转给B一个btc，B给A打10w的RMB。A首先将自己的btc来源信息、交易人等发送给B，同时还要拷贝一份发到全网。什么？这样还有隐私可言吗？当然，聪明的中本聪当然不会犯这么低级的错误。在区块链中，每个交易个体（也可以理解为每个网络节点）都会有一对公钥和私钥，公钥相当于一个“<span style="color:rgb(79,79,79);text-align:justify;">收款地址</span>”，而私钥是一个表明自己身份的256位的数字，目前一般是用sha265来生成的，这样，别人并不知道交易的双方是谁。发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用自己的私钥对摘要进行加密，加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>2.那么此时，这笔交易是否就完成了呢？如果这就算完成了，那跟A直接用包裹装10w现金快递给B有什么区别呢？此时，全网的矿工都会得到这个交易记录，那么全网的矿工都会为了若干奖励开始创建区块的工作，矿工会利用hash函数生成一个256位的唯一编号赋予这个区块，但是这个编号并不是简简单单随便生成的。编号是根据区块的具体内容如交易内容、nonce等唯一确定的，换句话说，两块内容相同的区块所对应的编号一定是唯一的。可是你会问：这又怎么了？并不难啊。错！中本聪为了控制区块的生成时间，使区块的生成速率满足全网的每10分钟一个的标准，制定了严格的区块生成校验规则，也就是说，能不能生成一个成功的区块要看你的编号是否符合这个规则。例如：生成编号中的前n位必须为‘0’。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>由于区块的交易内容是无法修改的，因此矿工们只能通过修改nonce去不断尝试这个函数，直到生成了一个成功的区块为止。如果当区块平均生成时间变快或者变慢，那么系统会对区块校验规则进行相应的调整，从而使平均的生成时间能够控制在规定范围。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>如果一个矿工完成了一个区块，会立刻告知其他矿工，如果其他矿工此时没有完成新的区块生成，则会停下手头的工作，对区块进行验证，需要确认的信息主要有如下几点：</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>1）.区块的编号有效；这个只要将区块放入哈希函数中，看产生的编号是否和该区块中的编号一致即可。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>2）.区块的前一个区块有效；之前提过，区块是一个串联的，每一个普通区块都会记载前一个区块的编号，这需要其他矿工对比当前的区块链的最后一个区块，看是否相同。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>3）.交易清单有效；就是说要验证A到底有没有这一个btc可以给B。在区块链的交易信息中，会记录交易中所有btc的前世今生，区块链可以做到追本溯源，因此每一个btc在哪里，为什么在这里都可以一目了然，所以这点也没问题。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>当验证完一个全新的区块后，全网就会认为这个区块有效，会将它添加到现有的区块链末端，同时结束针对该区块的挖矿工作，投入到下一个挖矿周期中。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>3.但是不难想象，这样的机制是存在冲突的隐患的，就是这么巧，两个矿工同时制作了一个正确的区块，那么此时不必二选一，可以将原来线性的区块链改成树状：</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180117223340696?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm13R2FhcmE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><img src="" alt=""><img src="" alt=""></span></span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span><span></span>但是</span>这样会导致未来在A、B后都会增加相应的区块，那么谁长谁将作为主链延伸下去，另一个也许会渐渐被遗忘，除非哪天它变得更长。</span></p> 
  <p><span style="color:rgb(79,79,79);text-align:justify;"><span></span>好啦，这就是区块链最基本的知识，接下来应该谈谈优缺点了。</span></p> 
  <p><span></span>世界上没有一样东西可以称为完美无瑕的，要知道区块链一样，虽然它被扣上了可以颠覆未来的帽子，但是仍然存在它的局限性：1.时效性。很容易发现，区块链中存在很多的验证、传递环节，这就会导致其时效性较差。2、能耗，这点也是显而易见的，区块链需要大量无用计算来控制区块的生成时间。所以区块链不适用于高时效的网络中。</p> 
  <p><span></span>至于区块链的优点，诸如安全、去中心化等等在网络上已经描述的非常清楚，这里就不再赘述。接下来我用一段python代码来简单实现一个挖矿的流程。</p> 
  <p></p> 
  <h2>代码示例</h2> 
  <p><span></span>首先创建一个表示区块链的类：</p> 
  <p></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">BlockChain</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#b200b2;">__init__</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>initialHash</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#75715e;"># init block chain
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.chain <span style="color:#f92672;">= </span>[]

        <span style="color:#75715e;"># init pitman
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.pitmen <span style="color:#f92672;">= </span>[]
        <span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#ae81ff;">6</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#94558d;">self</span>.pitmen.append(Pitman)

        <span style="color:#75715e;"># collect mine results
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.results <span style="color:#f92672;">= </span>[]

        <span style="color:#75715e;"># generate GenesisBlock
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.new_block(<span style="color:#fd971f;"><em>initialHash</em></span>)</pre> 
  <p><span></span>初始化函数中的chain表示当前的区块链，我会在其中存储区块对象；pitmen表示为这个区块链服务的矿工们，这个列表中也会存有矿工对象；results则会存储每个阶段产生的区块；new_block方法是创建区块的方法，如果当前生成的区块为第一个区块，则产生创世区块。</p> 
  <p><span></span>下面看看区块链类型的方法：</p> 
  <p><span></span></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;">@</span><span style="color:#a6e22e;">property
</span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">last_block</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>if </em></span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.chain)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>return </em></span><span style="color:#94558d;">self</span>.chain[<span style="color:#f92672;">-</span><span style="color:#ae81ff;">1</span>]
    <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>return None</em></span></pre> 
  <p><span></span>last_block会返回当前区块链的最后一个区块对象。</p> 
  <p></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">get_trans</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>return </em></span>json.dumps({
        <span style="color:#008080;">'sender'</span><span style="color:#f92672;">: </span><span style="color:#008080;">''</span>.join(random.sample(string.ascii_letters <span style="color:#f92672;">+ </span>string.digits<span style="color:#cc7832;">, </span><span style="color:#ae81ff;">8</span>))<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">        </span><span style="color:#008080;">'recipient'</span><span style="color:#f92672;">: </span><span style="color:#008080;">''</span>.join(random.sample(string.ascii_letters <span style="color:#f92672;">+ </span>string.digits<span style="color:#cc7832;">, </span><span style="color:#ae81ff;">8</span>))<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">        </span><span style="color:#008080;">'amount'</span><span style="color:#f92672;">: </span>random.randrange(<span style="color:#ae81ff;">1</span><span style="color:#cc7832;">, </span><span style="color:#ae81ff;">10000</span>)
    })</pre> 
  <span></span>get_trans方法则用来随机生成一份交易信息。 
  <p></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">new_block</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>initialHash</em></span><span style="color:#f92672;">=</span><span style="color:#66d9ef;"><em>None</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>if </em></span><span style="color:#fd971f;"><em>initialHash</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#75715e;"># generate Genesis Block
</span><span style="color:#75715e;">        </span>block <span style="color:#f92672;">= </span>Block()
        block.index <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span style="color:#ae81ff;">        </span>block.nonce <span style="color:#f92672;">= </span>random.randrange(<span style="color:#ae81ff;">0</span><span style="color:#cc7832;">, </span><span style="color:#ae81ff;">99999</span>)
        block.previousHash <span style="color:#f92672;">= </span><span style="color:#008080;">'0'
</span><span style="color:#008080;">        </span>block.difficulty <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span style="color:#ae81ff;">        </span>block.transactionData <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.get_trans()
        guess <span style="color:#f92672;">= </span><span style="color:#008080;">f'{block.previousHash}{block.nonce}{block.transactionData}'</span>.encode()
        block.hash <span style="color:#f92672;">= </span>hashlib.sha256(guess).hexdigest()
        block.time <span style="color:#f92672;">= </span>time()
        <span style="color:#94558d;">self</span>.chain.append(block)
    <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.pitmen))<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span>pm <span style="color:#f92672;">= </span>MyThread(<span style="color:#aa4926;">target</span><span style="color:#f92672;">=</span><span style="color:#94558d;">self</span>.pitmen[i].mine<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                  </span><span style="color:#aa4926;">args</span><span style="color:#f92672;">=</span>(<span style="color:#94558d;">self</span>.pitmen[i]<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                        </span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.chain)<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                        </span><span style="color:#94558d;">self</span>.last_block.get_block()[<span style="color:#008080;">'Hash'</span>]<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                        </span><span style="color:#94558d;">self</span>.get_trans()))
            pm.start()
            pm.join()
            <span style="color:#94558d;">self</span>.results.append(pm.get_result())

        <span style="color:#75715e;"># show all blocks
</span><span style="color:#75715e;">        </span><span style="color:#66d9ef;">print</span>(<span style="color:#008080;">"All blocks generated by pitmen:"</span>)
        <span style="color:#66d9ef;"><em>for </em></span>result <span style="color:#66d9ef;"><em>in </em></span><span style="color:#94558d;">self</span>.results<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;">print</span>(result[<span style="color:#ae81ff;">0</span>].get_block())

        <span style="color:#75715e;"># get new block
</span><span style="color:#75715e;">        </span>firstblock <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.results[<span style="color:#ae81ff;">0</span>][<span style="color:#ae81ff;">0</span>]
        mintime <span style="color:#f92672;">= </span>Decimal(<span style="color:#94558d;">self</span>.results[<span style="color:#ae81ff;">0</span>][<span style="color:#ae81ff;">1</span>])
        <span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#ae81ff;">1</span><span style="color:#cc7832;">, </span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.results))<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>if </em></span>Decimal(<span style="color:#94558d;">self</span>.results[i][<span style="color:#ae81ff;">1</span>]) <span style="color:#f92672;">&lt; </span>mintime<span style="color:#f92672;">:
</span><span style="color:#f92672;">                </span>firstblock <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.results[i][<span style="color:#ae81ff;">0</span>]
            <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">                </span><span style="color:#66d9ef;"><em>continue </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.chain.append(firstblock)
        <span style="color:#94558d;">self</span>.results <span style="color:#f92672;">= </span>[]</pre> 
  <span></span>这是生成区块的核心部分，这个方法主要分成两个部分：根据传参区分是否是创世区块，如果需要的是创世区块，那就由该类型自动生成一个区块占据区块链的头一个位置。如果需要生成的是普通区块，那么则会将一些基本信息分发给矿工们进行挖矿操作。我在这里设置了6个矿工，为了公平起见，这里也开了个多线程尽量让矿工们同时收到消息从而可以同时进行挖矿操作。按理说，最先挖矿成功的矿工会将消息发给其他矿工，其他矿工会立刻停止进行校验，但由于时间有限，这一步校验环节我没有实现。在这里，我允许所有矿工都完成工作，并提交成果和相应的工作时间，生成耗时最短的区块讲作为正确的区块添加到区块链上。本质上也是依照了“快者优先”的区块链生成原则。 
  <p><span></span>说了半天，区块内部到底是什么样的呢？</p> 
  <p></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">Block</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#b200b2;">__init__</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#94558d;">self</span>.index <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.time <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.difficulty <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.nonce <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.hash <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.previousHash <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.transactionData <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#66d9ef;"><em> def </em></span><span style="color:#a6e22e;">get_block</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>return </em></span>{
            <span style="color:#008080;">'Index'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.index<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Time'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.time<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Difficulty'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.difficulty<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Hash'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.hash<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Nonce'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.nonce<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'PreviousHash'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.previousHash<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'TransactionData'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.transactionData
        }
</pre> 
  <span></span>我用了一个相对简单的类型表示区块，在这里区块就是一个非常简单的数据结构，这里的所有字段在上述中已经有了详细的说明，因此不再赘述。 
  <p><span></span>那么我们再看看矿工，毕竟矿工才是区块链的生产者和推动者，地位最为核心。矿工类中我设计了两个方法，一个mine方法，也就是挖矿的意思，用来生成新的区块，并会返回该区块生成的用时长短。</p> 
  <p><span></span></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">mine</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>index</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>previousHash</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>transactionData</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="background-color:#472c47;">beginTime</span> <span style="color:#f92672;">= </span>time()

    block <span style="color:#f92672;">= </span>Block()
    block.index <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>index </em></span><span style="color:#fd971f;"><em> </em></span>block.previousHash <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>previousHash </em></span><span style="color:#fd971f;"><em> </em></span>block.transactionData <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>transactionData </em></span><span style="color:#fd971f;"><em> </em></span>block.difficulty<span style="color:#cc7832;">, </span>block.hash<span style="color:#cc7832;">, </span>block.nonce <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.generate_hash(<span style="color:#fd971f;"><em>previousHash</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>transactionData</em></span>)
    block.time <span style="color:#f92672;">= </span>time()
    endTime <span style="color:#f92672;">= </span>time()

    <span style="color:#66d9ef;"><em>return </em></span>block<span style="color:#cc7832;">, </span>endTime <span style="color:#f92672;">- </span><span style="background-color:#3c3c57;">beginTime</span></pre> 
  <p><span></span>另一个方法是hash生成的方法，生成原则我自己意淫了一个，大家莫怪，因为本人计算机的实在不给力，区块的成功标准很简单，就是用sha256生成的编码最后结尾是0就满足要求，如果改成00，那会半天看不到结果。</p> 
  <p><span></span>下面我们看下这套实例的运行结果，我设置了一个长度为6的区块链，由于第一个区块是创世区块，所以真正开始创建的区块是从第二个开始的，大家注意index。</p> 
  <p><span></span>这是6个矿工完成的第一区块：</p> 
  <p><span>All blocks generated by pitmen:<br> {'Index': 1, 'Time': 1516268156.5971138, 'Difficulty': 2, 'Hash': '01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30', 'Nonce': 91554, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "OY8z0Rrx", "recipient": "iSGFJsEm", "amount": 8723}'}<br> {'Index': 1, 'Time': 1516268156.5971138, 'Difficulty': 5, 'Hash': 'c3ba406bad0d87f816f629830a15e2997638bfa230484c224e5470eaa24d8790', 'Nonce': 62372, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "9o8UMDLe", "recipient": "qTOQu7kv", "amount": 2746}'}<br> {'Index': 1, 'Time': 1516268156.5981123, 'Difficulty': 5, 'Hash': '8ff243885e9017296aa2ef1a611ef5b3927ddce818cb7255a04ff3228c982c60', 'Nonce': 67644, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "kIqy1c8C", "recipient": "WSdK0EXh", "amount": 9329}'}<br> {'Index': 1, 'Time': 1516268156.5981123, 'Difficulty': 3, 'Hash': 'ff9716bf9379e2ab7a8640419e7c7b7c7329a5e6e1bbf83a1249f49d070ca8b0', 'Nonce': 37336, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "vBwU0luH", "recipient": "d7o6cRCj", "amount": 5628}'}<br> {'Index': 1, 'Time': 1516268156.5981123, 'Difficulty': 3, 'Hash': '3410c70c31f9bacbfcbd74d63f25f69f27d36075e2d44bddaa60bd72fa042e60', 'Nonce': 34617, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "yzcNpBnh", "recipient": "vbIr7SKo", "amount": 6387}'}<br> {'Index': 1, 'Time': 1516268156.5981123, 'Difficulty': 27, 'Hash': '91e3dc3ef1a151557a1edd837528410b916362bcfb77dbb14dc54c8929f5a0d0', 'Nonce': 49121, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "p1MguhVz", "recipient": "gVSom4D3", "amount": 7356}'}</span></p> 
  <p><span></span>很明显前两个是最快的，为了简单，我在最快的里面随便选取一个，意思到了就行。大家可以看到，难度值，根据上文所说，这是反应一个区块生成的难易程度的，难度高的，在我这里会表示这个矿工为了得到这个区块进行了多少次尝试。看到这里也许你会问：为什么难度最大的时间并没有明显长呢？也就是用时并没有按照难度的增加而增加。我猜想应该是因为我的示例算法简单，因此结果也不是十分精确，如果计算量达到一定的规模，应该会有明显的差距。（如果有高人知道，可以回复我，在此谢过！）第三到第六个的区块创建结果格式是与之一样的，就不刷屏了。</p> 
  <p><span></span>最后看下整个区块链的结果：</p> 
  <p><span>{'Index': 0, 'Time': 1516268156.5971138, 'Difficulty': 0, 'Hash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'Nonce': 87688, 'PreviousHash': '0', 'TransactionData': '{"sender": "OuVCmHbs", "recipient": "kFxbwSLc", "amount": 503}'}<br> {'Index': 1, 'Time': 1516268156.5971138, 'Difficulty': 2, 'Hash': '01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30', 'Nonce': 91554, 'PreviousHash': '7532402844a1c130833a27600298d09a007d6124603cf44be9c05fcd5428c34a', 'TransactionData': '{"sender": "OY8z0Rrx", "recipient": "iSGFJsEm", "amount": 8723}'}<br> {'Index': 2, 'Time': 1516268156.5991132, 'Difficulty': 4, 'Hash': '098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130', 'Nonce': 12875, 'PreviousHash': '01f505a276e3f55a868d9ee18f70bcff75429e1de70f5ab59471a3551cc67a30', 'TransactionData': '{"sender": "HJZSX1hk", "recipient": "j82k51yY", "amount": 3521}'}<br> {'Index': 3, 'Time': 1516268156.6001143, 'Difficulty': 27, 'Hash': '7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200', 'Nonce': 18663, 'PreviousHash': '098544436793881e8041c0c903c96c0055e16396113d73c63bc55e7ba78ec130', 'TransactionData': '{"sender": "cJrGxN5R", "recipient": "wkZI8QCv", "amount": 1224}'}<br> {'Index': 4, 'Time': 1516268156.601114, 'Difficulty': 3, 'Hash': '60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0', 'Nonce': 51446, 'PreviousHash': '7c10243223caf39bc5a6067de8d93f6ea46bad62c4a0fbcc0aa4e086585d8200', 'TransactionData': '{"sender": "nCNJoy52", "recipient": "kYBT9f65", "amount": 3603}'}<br> {'Index': 5, 'Time': 1516268156.605163, 'Difficulty': 2, 'Hash': '765f69163cf95584721015e3ce819c1980ce33752f8a4dea553d3bedd39f8920', 'Nonce': 31804, 'PreviousHash': '60a099d3fe53e031800669fcc1d9b5ab6df1f80a40354135310a799892f1c3d0', 'TransactionData': '{"sender": "FqOkiTEu", "recipient": "y9EDcSYA", "amount": 4185}'}</span></p> 
  <p><span></span>这就是由这6个矿工依次创建的六个区块，根据hash值环环相扣。</p> 
  <p><span></span>到底我想说的基本就结束了，最后我想说区块链是个神奇的技术，从听到它就深深的吸引着我，期望未来区块链可以真的带来巨大的变革。要知道，随着AI的兴起，区块链的问世，属于程序员的数字时代会进一步升华，互联网时代只是一个开始！谢谢阅读，本人水平有限，如果您发现问题或我理解偏差的地方可以及时指出，在本文下方回复或者邮箱695509060@qq.com都可以，再次表示感谢。文章末尾会附上完整代码，本文由作者原创，所有版权归属作者。我是隔壁小王。<span></span></p> 
  <p></p> 
  <pre style="background-color:#272822;color:#f8f8f2;font-family:Consolas;font-size:12pt;"><span style="color:#66d9ef;"><em>import </em></span>hashlib
<span style="color:#66d9ef;"><em>import </em></span>random
<span style="color:#66d9ef;"><em>import </em></span>string
<span style="color:#66d9ef;"><em>import </em></span>json
<span style="color:#66d9ef;"><em>import </em></span>threading
<span style="color:#66d9ef;"><em>from </em></span>decimal <span style="color:#66d9ef;"><em>import </em></span>Decimal
<span style="color:#66d9ef;"><em>from </em></span>time <span style="color:#66d9ef;"><em>import </em></span>time


<span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">MyThread</span>(threading.Thread)<span style="color:#f92672;">:
</span><span style="color:#f92672;">
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#b200b2;">__init__</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>target</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>args</em></span><span style="color:#f92672;">=</span>())<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;">super</span>(MyThread<span style="color:#cc7832;">, </span><span style="color:#94558d;">self</span>).<span style="color:#66d9ef;">__init__</span>()
        <span style="color:#94558d;">self</span>.func <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>target </em></span><span style="color:#fd971f;"><em> </em></span><span style="color:#94558d;">self</span>.args <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>args </em></span><span style="color:#fd971f;"><em> </em></span><span style="color:#fd971f;"><em> </em></span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">run</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#94558d;">self</span>.result <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.func(<span style="color:#f92672;">*</span><span style="color:#94558d;">self</span>.args)

    <span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">get_result</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>try</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>return </em></span><span style="color:#94558d;">self</span>.result
        <span style="color:#66d9ef;"><em>except </em></span><span style="color:#66d9ef;">Exception</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>return None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">BlockChain</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#b200b2;">__init__</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>initialHash</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#75715e;"># init block chain
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.chain <span style="color:#f92672;">= </span>[]

        <span style="color:#75715e;"># init pitman
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.pitmen <span style="color:#f92672;">= </span>[]
        <span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#ae81ff;">6</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#94558d;">self</span>.pitmen.append(Pitman)

        <span style="color:#75715e;"># collect mine results
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.results <span style="color:#f92672;">= </span>[]

        <span style="color:#75715e;"># generate GenesisBlock
</span><span style="color:#75715e;">        </span><span style="color:#94558d;">self</span>.new_block(<span style="color:#fd971f;"><em>initialHash</em></span>)

    <span style="color:#66d9ef;">@</span><span style="color:#a6e22e;">property
</span><span style="color:#a6e22e;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">last_block</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>if </em></span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.chain)<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>return </em></span><span style="color:#94558d;">self</span>.chain[<span style="color:#f92672;">-</span><span style="color:#ae81ff;">1</span>]
        <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>return None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#66d9ef;"><em> def </em></span><span style="color:#a6e22e;">get_trans</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>return </em></span>json.dumps({
            <span style="color:#008080;">'sender'</span><span style="color:#f92672;">: </span><span style="color:#008080;">''</span>.join(random.sample(string.ascii_letters <span style="color:#f92672;">+ </span>string.digits<span style="color:#cc7832;">, </span><span style="color:#ae81ff;">8</span>))<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'recipient'</span><span style="color:#f92672;">: </span><span style="color:#008080;">''</span>.join(random.sample(string.ascii_letters <span style="color:#f92672;">+ </span>string.digits<span style="color:#cc7832;">, </span><span style="color:#ae81ff;">8</span>))<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'amount'</span><span style="color:#f92672;">: </span>random.randrange(<span style="color:#ae81ff;">1</span><span style="color:#cc7832;">, </span><span style="color:#ae81ff;">10000</span>)
        })

    <span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">new_block</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>initialHash</em></span><span style="color:#f92672;">=</span><span style="color:#66d9ef;"><em>None</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>if </em></span><span style="color:#fd971f;"><em>initialHash</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#75715e;"># generate Genesis Block
</span><span style="color:#75715e;">            </span>block <span style="color:#f92672;">= </span>Block()
            block.index <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span style="color:#ae81ff;">            </span>block.nonce <span style="color:#f92672;">= </span>random.randrange(<span style="color:#ae81ff;">0</span><span style="color:#cc7832;">, </span><span style="color:#ae81ff;">99999</span>)
            block.previousHash <span style="color:#f92672;">= </span><span style="color:#008080;">'0'
</span><span style="color:#008080;">            </span>block.difficulty <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span style="color:#ae81ff;">            </span>block.transactionData <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.get_trans()
            guess <span style="color:#f92672;">= </span><span style="color:#008080;">f'{block.previousHash}{block.nonce}{block.transactionData}'</span>.encode()
            block.hash <span style="color:#f92672;">= </span>hashlib.sha256(guess).hexdigest()
            block.time <span style="color:#f92672;">= </span>time()
            <span style="color:#94558d;">self</span>.chain.append(block)
        <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.pitmen))<span style="color:#f92672;">:
</span><span style="color:#f92672;">                </span>pm <span style="color:#f92672;">= </span>MyThread(<span style="color:#aa4926;">target</span><span style="color:#f92672;">=</span><span style="color:#94558d;">self</span>.pitmen[i].mine<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                      </span><span style="color:#aa4926;">args</span><span style="color:#f92672;">=</span>(<span style="color:#94558d;">self</span>.pitmen[i]<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                            </span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.chain)<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                            </span><span style="color:#94558d;">self</span>.last_block.get_block()[<span style="color:#008080;">'Hash'</span>]<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">                                            </span><span style="color:#94558d;">self</span>.get_trans()))
                pm.start()
                pm.join()
                <span style="color:#94558d;">self</span>.results.append(pm.get_result())

            <span style="color:#75715e;"># show all blocks
</span><span style="color:#75715e;">            </span><span style="color:#66d9ef;">print</span>(<span style="color:#008080;">"All blocks generated by pitmen:"</span>)
            <span style="color:#66d9ef;"><em>for </em></span>result <span style="color:#66d9ef;"><em>in </em></span><span style="color:#94558d;">self</span>.results<span style="color:#f92672;">:
</span><span style="color:#f92672;">                </span><span style="color:#66d9ef;">print</span>(result[<span style="color:#ae81ff;">0</span>].get_block())

            <span style="color:#75715e;"># get new block
</span><span style="color:#75715e;">            </span>firstblock <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.results[<span style="color:#ae81ff;">0</span>][<span style="color:#ae81ff;">0</span>]
            mintime <span style="color:#f92672;">= </span>Decimal(<span style="color:#94558d;">self</span>.results[<span style="color:#ae81ff;">0</span>][<span style="color:#ae81ff;">1</span>])
            <span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(<span style="color:#ae81ff;">1</span><span style="color:#cc7832;">, </span><span style="color:#66d9ef;">len</span>(<span style="color:#94558d;">self</span>.results))<span style="color:#f92672;">:
</span><span style="color:#f92672;">                </span><span style="color:#66d9ef;"><em>if </em></span>Decimal(<span style="color:#94558d;">self</span>.results[i][<span style="color:#ae81ff;">1</span>]) <span style="color:#f92672;">&lt; </span>mintime<span style="color:#f92672;">:
</span><span style="color:#f92672;">                    </span>firstblock <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.results[i][<span style="color:#ae81ff;">0</span>]
                <span style="color:#66d9ef;"><em>else</em></span><span style="color:#f92672;">:
</span><span style="color:#f92672;">                    </span><span style="color:#66d9ef;"><em>continue </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.chain.append(firstblock)
            <span style="color:#94558d;">self</span>.results <span style="color:#f92672;">= </span>[]

    <span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">show_chain</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;">print</span>(<span style="color:#008080;">'This is mine first block chain!'</span>)
        <span style="color:#66d9ef;"><em>for </em></span>block <span style="color:#66d9ef;"><em>in </em></span><span style="color:#94558d;">self</span>.chain<span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span><span style="color:#66d9ef;">print</span>(block.get_block())


<span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">Block</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#b200b2;">__init__</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#94558d;">self</span>.index <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.time <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.difficulty <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.nonce <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.hash <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.previousHash <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#94558d;">self</span>.transactionData <span style="color:#f92672;">= </span><span style="color:#66d9ef;"><em>None </em></span><span style="color:#66d9ef;"><em> </em></span><span style="color:#66d9ef;"><em> def </em></span><span style="color:#a6e22e;">get_block</span>(<span style="color:#94558d;">self</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>return </em></span>{
            <span style="color:#008080;">'Index'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.index<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Time'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.time<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Difficulty'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.difficulty<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Hash'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.hash<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'Nonce'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.nonce<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'PreviousHash'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.previousHash<span style="color:#cc7832;">,
</span><span style="color:#cc7832;">            </span><span style="color:#008080;">'TransactionData'</span><span style="color:#f92672;">: </span><span style="color:#94558d;">self</span>.transactionData
        }


<span style="color:#66d9ef;"><em>class </em></span><span style="color:#a6e22e;">Pitman</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">
</span><span style="color:#f92672;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">mine</span>(<span style="color:#94558d;">self</span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>index</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>previousHash</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>transactionData</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span>beginTime <span style="color:#f92672;">= </span>time()

        block <span style="color:#f92672;">= </span>Block()
        block.index <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>index </em></span><span style="color:#fd971f;"><em> </em></span>block.previousHash <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>previousHash </em></span><span style="color:#fd971f;"><em> </em></span>block.transactionData <span style="color:#f92672;">= </span><span style="color:#fd971f;"><em>transactionData </em></span><span style="color:#fd971f;"><em> </em></span>block.difficulty<span style="color:#cc7832;">, </span>block.hash<span style="color:#cc7832;">, </span>block.nonce <span style="color:#f92672;">= </span><span style="color:#94558d;">self</span>.generate_hash(<span style="color:#fd971f;"><em>previousHash</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>transactionData</em></span>)
        block.time <span style="color:#f92672;">= </span>time()
        endTime <span style="color:#f92672;">= </span>time()

        <span style="color:#66d9ef;"><em>return </em></span>block<span style="color:#cc7832;">, </span>endTime <span style="color:#f92672;">- </span>beginTime

    <span style="color:#66d9ef;">@</span><span style="color:#a6e22e;">staticmethod
</span><span style="color:#a6e22e;">    </span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">generate_hash</span>(<span style="color:#fd971f;"><em>previousHash</em></span><span style="color:#cc7832;">, </span><span style="color:#fd971f;"><em>transactionData</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span>difficulty <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span style="color:#ae81ff;">        </span>nonce <span style="color:#f92672;">= </span>random.randrange(<span style="color:#ae81ff;">0</span><span style="color:#cc7832;">, </span><span style="color:#ae81ff;">99999</span>)
        guess <span style="color:#f92672;">= </span><span style="color:#008080;">f'{previousHash}{nonce}{transactionData}'</span>.encode()
        myhash <span style="color:#f92672;">= </span>hashlib.sha256(guess).hexdigest()
        <span style="color:#66d9ef;"><em>while </em></span>myhash[<span style="color:#f92672;">-</span><span style="color:#ae81ff;">1</span>] <span style="color:#f92672;">!= </span><span style="color:#008080;">'0'</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">            </span>difficulty <span style="color:#f92672;">+= </span><span style="color:#ae81ff;">1
</span><span style="color:#ae81ff;">            </span>nonce <span style="color:#f92672;">+= </span>difficulty
            guess <span style="color:#f92672;">= </span><span style="color:#008080;">f'{previousHash}{nonce}{transactionData}'</span>.encode()
            myhash <span style="color:#f92672;">= </span>hashlib.sha256(guess).hexdigest()
        <span style="color:#66d9ef;"><em>return </em></span>difficulty<span style="color:#cc7832;">, </span>myhash<span style="color:#cc7832;">, </span>nonce


<span style="color:#66d9ef;"><em>if </em></span>__name__ <span style="color:#f92672;">== </span><span style="color:#008080;">'__main__'</span><span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span>chain <span style="color:#f92672;">= </span>BlockChain(<span style="color:#ae81ff;">1</span>)
    length <span style="color:#f92672;">= </span><span style="color:#ae81ff;">5
</span><span style="color:#ae81ff;">    </span><span style="color:#66d9ef;"><em>for </em></span>i <span style="color:#66d9ef;"><em>in </em></span><span style="color:#66d9ef;">range</span>(length)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span>chain.new_block()
    chain.show_chain()
</pre> 
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/BmwGaara/article/details/79059007,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/BmwGaara/article/details/79059007,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
