<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>使用Go语言编写区块链P2P网络(译) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="使用Go语言编写区块链P2P网络(译)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为Sunface(孙飞)原创文章，转载请注明出处 https://blog.csdn.net/abv123456789/article/details/79953019 外文发表日期： 2018-04-14 外文链接：https://medium.com/coinmonks/code-a-simple-p2p-blockchain-in-go-46662601f417 在之前的文章中，我们已经知道了怎么编写PoW也知道了IPFS怎么工作, 但是有一个致命的缺点，我们的服务都是中心化的，这篇文章会教你怎么实现一个简单的完全去中心化的P2P网络。 背景知识 什么是P2P网络 在真正的P2P架构中，不需要中心化的服务来维护区块链的状态。例如，当你给朋友发送比特币时，比特币区块链的“状态”应该更新，这样你朋友的余额就会增加，你的余额就会减少。 在这个网络中，不存在一个权力高度中心化的机构来维护状态（银行就是这样的中心化机构)。对于比特币网络来说，每个节点都会维护一份完整的区块链状态，当交易发生时，每个节点的区块链状态都会得到更新。这样，只要网络中51%的节点对区块链的状态达成一致，那么区块链网络就是安全可靠的，具体可以阅读这篇一致性协议文章。 本文将继续之前的工作,200行Go代码实现区块链, 并加入P2P网络架构。在继续之前，强烈建议你先阅读该篇文章，它会帮助你理解接下来的代码。 开始实现 编写P2P网络可不是开开玩笑就能简单视线的，有很多边边角角的情况都要覆盖到，而且需要你拥有很多工程学的知识，这样的P2P网络才是可扩展、高可靠的。有句谚语说得好：站在巨人肩膀上做事，那么我们先看看巨人们提供了哪些工具吧。 喔，看看，我们发现了什么！一个用Go语言实现的P2P库go-libp2p！如果你对新技术足够敏锐，就会发现这个库的作者和IPFS的作者是同一个团队。如果你还没看过我们的IPFS教程，可以看看这里, 你可以选择跳过IPFS教程，因为对于本文这不是必须的。 警告 目前来说，go-libp2p主要有两个缺点: 1. 安装设置比较痛苦，它使用gx作为包管理工具，怎么说呢，不咋好用，但是凑活用吧 2. 目前项目还没有成熟，正在紧密锣鼓的开发中，当使用这个库时，可能会遇到一些数据竞争(data race) 对于第一点，不必担心，有我们呢。第二点是比较大的问题，但是不会影响我们的代码。假如你在使用过程中发现了数据竞争问题，记得给项目提一个issue，帮助它更好的成长！ 总之，目前开源世界中，现代化的P2P库是非常非常少的，因为我们要多给go-libp2p一些耐心和包容，而且就目前来说，它已经能很好的满足我们的目标了。 安装设置 最好的环境设置方式是直接clone libp2p库，然后在这个库的代码中直接开发。你也可以在自己的库中，调用这个库开发，但是这样就需要用到gx了。这里我们使用简单的方式，假设你已经安装了Go: - go get -d github.com/libp2p/go-libp2p/… - 进入go-libp2p文件夹 - make - make deps 这里会通过gx包管理工具下载所有需要的包和依赖，再次申明，我们不喜欢gx，因为它打破了Go语言的很多惯例，但是为了这个很棒的库，认怂吧。 这里，我们在examples子目录下进行开发，因此在go-libp2p的examples下创建一个你自己的目录 - mkdir ./examples/p2p 然后进入到p2p文件夹下，创建main.go文件，后面所有的代码都会在该文件中。 你的目录结构是这样的： 好了，勇士们，拔出你们的剑，哦不，拔出你们的main.go，开始我们的征途吧！ 导入相关库 这里申明我们需要用的库，大部分库是来自于go-libp2p本身的，在教程中，你会学到怎么去使用它们。 package main import ( &quot;bufio&quot; &quot;context&quot; &quot;crypto/rand&quot; &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; mrand &quot;math/rand&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; golog &quot;github.com/ipfs/go-log&quot; libp2p &quot;github.com/libp2p/go-libp2p&quot; crypto &quot;github.com/libp2p/go-libp2p-crypto&quot; host &quot;github.com/libp2p/go-libp2p-host&quot; net &quot;github.com/libp2p/go-libp2p-net&quot; peer &quot;github.com/libp2p/go-libp2p-peer&quot; pstore &quot;github.com/libp2p/go-libp2p-peerstore&quot; ma &quot;github.com/multiformats/go-multiaddr&quot; gologging &quot;github.com/whyrusleeping/go-logging&quot; ) spew包可以很方便、优美的打印出我们的区块链，因此记得安装它： - go get github.com/davecgh/go-spew/spew 区块链结构 记住，请先阅读200行Go代码实现区块链， 这样，下面的部分就会简单很多。 先来申明全局变量： // Block represents each &#39;item&#39; in the blockchain type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } // Blockchain is a series of validated Blocks var Blockchain []Block var mutex = &amp;sync.Mutex{} 我们是一家健康看护公司，因此Block中存着的是用户的脉搏速率BPM Blockchain是我们的”状态”，或者严格的说：最新的Blockchain，它其实就是Block的切片（slice) mutex是为了防止资源竞争出现 下面是Blockchain相关的特定函数： // make sure block is valid by checking index, and comparing the hash of the previous block func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } // SHA256 hashing func calculateHash(block Block) string { record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } // create a new block using previous block&#39;s hash func generateBlock(oldBlock Block, BPM int) Block { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock } isBlockValid检查Block的hash是否合法 calculateHash使用sha256来对原始数据做hash generateBlock创建一个新的Block区块，然后添加到区块链Blockchain上，同时会包含所需的事务 P2P结构 下面我们快接近核心部分了，首先我们要写出创建主机的逻辑。当一个节点运行我们的程序时，它可以作为一个主机，被其它节点连接。下面一起看看代码:-) // makeBasicHost creates a LibP2P host with a random peer ID listening on the // given multiaddress. It will use secio if secio is true. func makeBasicHost(listenPort int, secio bool, randseed int64) (host.Host, error) { // If the seed is zero, use real cryptographic randomness. Otherwise, use a // deterministic randomness source to make generated keys stay the same // across multiple runs var r io.Reader if randseed == 0 { r = rand.Reader } else { r = mrand.New(mrand.NewSource(randseed)) } // Generate a key pair for this host. We will use it // to obtain a valid host ID. priv, _, err := crypto.GenerateKeyPairWithReader(crypto.RSA, 2048, r) if err != nil { return nil, err } opts := []libp2p.Option{ libp2p.ListenAddrStrings(fmt.Sprintf(&quot;/ip4/127.0.0.1/tcp/%d&quot;, listenPort)), libp2p.Identity(priv), } if !secio { opts = append(opts, libp2p.NoEncryption()) } basicHost, err := libp2p.New(context.Background(), opts...) if err != nil { return nil, err } // Build host multiaddress hostAddr, _ := ma.NewMultiaddr(fmt.Sprintf(&quot;/ipfs/%s&quot;, basicHost.ID().Pretty())) // Now we can build a full multiaddress to reach this host // by encapsulating both addresses: addr := basicHost.Addrs()[0] fullAddr := addr.Encapsulate(hostAddr) log.Printf(&quot;I am %s\n&quot;, fullAddr) if secio { log.Printf(&quot;Now run \&quot;go run main.go -l %d -d %s -secio\&quot; on a different terminal\n&quot;, listenPort+1, fullAddr) } else { log.Printf(&quot;Now run \&quot;go run main.go -l %d -d %s\&quot; on a different terminal\n&quot;, listenPort+1, fullAddr) } return basicHost, nil } makeBasicHost函数有3个参数，同时返回一个host结构体 - listenPort是主机监听的端口，其它节点会连接该端口 - secio表明是否开启数据流的安全选项，最好开启，因此它代表了”安全输入／输出” - randSeed是一个可选的命令行标识，可以允许我们提供一个随机数种子来为我们的主机生成随机的地址。这里我们不会使用 函数的第一个if语句针对随机种子生成随机key，接着我们生成公钥和私钥，这样能保证主机是安全的。opts部分开始构建网络地址部分，这样其它节点就可以连接进来。 !secio部分可以绕过加密，但是我们准备使用加密，因此这段代码不会被触发。 接着，创建了主机地址，这样其他节点就可以连接进来。log.Printf可以用来在控制台打印出其它节点的连接信息。最后我们返回生成的主机地址给调用方函数。 流处理 之前的主机需要能处理进入的数据流。当另外一个节点连接到主机时，它会想要提出一个新的区块链，来覆盖主机上的区块链，因此我们需要逻辑来判定是否要接受新的区块链。 同时，当我们往本地的区块链添加区块后，也要把相关信息广播给其它节点，这里也需要实现相关逻辑。 先来创建流处理的基本框架吧： func handleStream(s net.Stream) { log.Println(&quot;Got a new stream!&quot;) // Create a buffer stream for non blocking read and write. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) go readData(rw) go writeData(rw) // stream &#39;s&#39; will stay open until you close it (or the other side closes it). } 这里创建一个新的ReadWriter，为了能支持数据读取和写入，同时我们启动了一个单独的Go协程来处理相关读写逻辑。 读取数据 首先创建readData函数： func readData(rw *bufio.ReadWriter) { for { str, err := rw.ReadString(&#39;\n&#39;) if err != nil { log.Fatal(err) } if str == &quot;&quot; { return } if str != &quot;\n&quot; { chain := make([]Block, 0) if err := json.Unmarshal([]byte(str), &amp;chain); err != nil { log.Fatal(err) } mutex.Lock() if len(chain) &gt; len(Blockchain) { Blockchain = chain bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { log.Fatal(err) } // Green console color: \x1b[32m // Reset console color: \x1b[0m fmt.Printf(&quot;\x1b[32m%s\x1b[0m&gt; &quot;, string(bytes)) } mutex.Unlock() } } } 该函数是一个无限循环，因为它需要永不停歇的去读取外面进来的数据。首先，我们使用ReadString解析从其它节点发送过来的新的区块链（JSON字符串)。 然后检查进来的区块链的长度是否比我们本地的要长，如果进来的链更长，那么我们就接受新的链为最新的网络状态（最新的区块链)。 同时，把最新的区块链在控制台使用一种特殊的颜色打印出来，这样我们就知道有新链接受了。 如果在我们主机的本地添加了新的区块到区块链上，那就需要把本地最新的区块链广播给其它相连的节点知道，这样这些节点机会接受并更新到我们的区块链版本。这里使用writeData函数: func writeData(rw *bufio.ReadWriter) { go func() { for { time.Sleep(5 * time.Second) mutex.Lock() bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } mutex.Unlock() mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } }() stdReader := bufio.NewReader(os.Stdin) for { fmt.Print(&quot;&gt; &quot;) sendData, err := stdReader.ReadString(&#39;\n&#39;) if err != nil { log.Fatal(err) } sendData = strings.Replace(sendData, &quot;\n&quot;, &quot;&quot;, -1) bpm, err := strconv.Atoi(sendData) if err != nil { log.Fatal(err) } newBlock := generateBlock(Blockchain[len(Blockchain)-1], bpm) if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { mutex.Lock() Blockchain = append(Blockchain, newBlock) mutex.Unlock() } bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } spew.Dump(Blockchain) mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } } 首先是一个单独协程中的函数，每5秒钟会将我们的最新的区块链状态广播给其它相连的节点。它们收到后，如果发现我们的区块链比它们的要短，就会直接把我们发送的区块链信息丢弃，继续使用它们的区块链，反之则使用我们的区块链。总之，无论哪种方法，所有的节点都会定期的同步本地的区块链到最新状态。 这里我们需要一个方法来创建一个新的Block区块，包含之前提到过的脉搏速率（BPM)。为了简化实现，我们不会真的去通过物联网设备读取脉搏，而是直接在终端控制台上输入一个脉搏速率数字。 首先要验证输入的BPM是一个整数类型，然后使用之前的generateBlock来生成区块，接着使用spew.Dump输入到终端控制台，最后我们使用rw.WriteString把最新的区块链广播给相连的其它节点。 牛逼了我的哥，现在我们完成了区块链相关的函数以及大多数P2P相关的函数。在前面，我们创建了流处理，因此可以读取和写入最新的区块链状态；创建了状态同步函数，这样节点之间可以互相同步最新状态。 剩下的就是实现我们的main函数了： func main() { t := time.Now() genesisBlock := Block{} genesisBlock = Block{0, t.String(), 0, calculateHash(genesisBlock), &quot;&quot;} Blockchain = append(Blockchain, genesisBlock) // LibP2P code uses golog to log messages. They log with different // string IDs (i.e. &quot;swarm&quot;). We can control the verbosity level for // all loggers with: golog.SetAllLoggers(gologging.INFO) // Change to DEBUG for extra info // Parse options from the command line listenF := flag.Int(&quot;l&quot;, 0, &quot;wait for incoming connections&quot;) target := flag.String(&quot;d&quot;, &quot;&quot;, &quot;target peer to dial&quot;) secio := flag.Bool(&quot;secio&quot;, false, &quot;enable secio&quot;) seed := flag.Int64(&quot;seed&quot;, 0, &quot;set random seed for id generation&quot;) flag.Parse() if *listenF == 0 { log.Fatal(&quot;Please provide a port to bind on with -l&quot;) } // Make a host that listens on the given multiaddress ha, err := makeBasicHost(*listenF, *secio, *seed) if err != nil { log.Fatal(err) } if *target == &quot;&quot; { log.Println(&quot;listening for connections&quot;) // Set a stream handler on host A. /p2p/1.0.0 is // a user-defined protocol name. ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) select {} // hang forever /**** This is where the listener code ends ****/ } else { ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) // The following code extracts target&#39;s peer ID from the // given multiaddress ipfsaddr, err := ma.NewMultiaddr(*target) if err != nil { log.Fatalln(err) } pid, err := ipfsaddr.ValueForProtocol(ma.P_IPFS) if err != nil { log.Fatalln(err) } peerid, err := peer.IDB58Decode(pid) if err != nil { log.Fatalln(err) } // Decapsulate the /ipfs/&lt;peerID&gt; part from the target // /ip4/&lt;a.b.c.d&gt;/ipfs/&lt;peer&gt; becomes /ip4/&lt;a.b.c.d&gt; targetPeerAddr, _ := ma.NewMultiaddr( fmt.Sprintf(&quot;/ipfs/%s&quot;, peer.IDB58Encode(peerid))) targetAddr := ipfsaddr.Decapsulate(targetPeerAddr) // We have a peer ID and a targetAddr so we add it to the peerstore // so LibP2P knows how to contact it ha.Peerstore().AddAddr(peerid, targetAddr, pstore.PermanentAddrTTL) log.Println(&quot;opening stream&quot;) // make a new stream from host B to host A // it should be handled on host A by the handler we set above because // we use the same /p2p/1.0.0 protocol s, err := ha.NewStream(context.Background(), peerid, &quot;/p2p/1.0.0&quot;) if err != nil { log.Fatalln(err) } // Create a buffered stream so that read and writes are non blocking. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) // Create a thread to read and write data. go writeData(rw) go readData(rw) select {} // hang forever } } 首先是创建一个创世区块（如果你读了200行Go代码实现你的区块链,这里就不会陌生)。 其次我们使用go-libp2p的SetAllLoggers日志函数来记录日志。 接着，设置了所有的命令行标识： secio之前有提到，是用来加密数据流的。在我们的程序中，一定要打开该标识 target指明当前节点要连接到的主机地址 listenF是当前节点的监听主机地址，这样其它节点就可以连接进来，记住，每个节点都有两个身份：主机和客户端， 毕竟P2P不是白叫的 seed是随机数种子，用来创建主机地址时使用 然后，使用makeBasicHost函数来创建一个新的主机地址，如果我们只想做主机不想做客户端（连接其它的主机)，就使用if *target == “”。 接下来的几行，会从target解析出我们要连接到的主机地址。然后把peerID和主机目标地址targetAddr添加到”store”中，这样就可以持续跟踪我们跟其它主机的连接信息，这里使用的是ha.Peerstore().AddAddr函数。 接着我们使用ha.NewStream连接到想要连接的节点上，同时为了能接收和发送最新的区块链信息，创建了ReadWriter，同时使用一个Go协程来进行readData和writeData。 哇哦 终于完成了，写文章远比写代码累！我知道之前的内容有点难，但是相比P2P的复杂性来说，你能通过一个库来完成P2P网络，已经很牛逼了，所以继续加油！ 完整代码 mycoralhealth/blockchain-tutorial 运行结果 现在让我们来试验一下，首先打开3个独立的终端窗口做为独立节点。 开始之前，请再次进入go-libp2p的根目录运行一下make deps，确保所有依赖都正常安装。 回到你的工作目录examples/p2p，打开第一个终端窗口，输入 go run main.go -l 10000 -secio 细心的读者会发现有一段话”Now run…”，那还等啥，继续跟着做吧，打开第二个终端窗口运行：go run main.go -l 10001 -d &lt;given address in the instructions&gt; -secio 这是你会发现第一个终端窗口检测到了新连接! 接着打开第三个终端窗口，运行：go run main.go -l 10002 -d &lt;given address in the instructions&gt; -secio 检查第二终端，又发现了新连接 接着，该我们输入BPM数据了，在第一个终端窗口中输入”70”，等几秒中，观察各个窗口的打印输出。 来看看发生了什么： - 终端1向本地的区块链添加了一个新的区块Block - 终端1向终端2广播该信息 - 终端2将新的区块链跟本地的对比，发现终端1的更长，因此使用新的区块链替代了本地的区块链，然后将新的区块链广播给终端3 - 同上，终端3也进行更新 所有的3个终端节点都把区块链更新到了最新版本，同时没有使用任何外部的中心化服务，这就是P2P网络的力量！ 我们再往终端2的区块链中添加一个区块试试看，在终端2中输入”80” 结果忠诚的记录了我们的正确性，再一次欢呼吧！ 下一步 先享受一下自己的工作，你刚用了区区几百行代码就实现了一个全功能的P2P网络！这不是开玩笑，P2P编程时非常复杂的，为什么之前没有相关的教程，就是因为太难了。 但是，这里也有几个可以改进的地方，你可以挑战一下自己： 之前提到过,go-libp2p是存在数据竞争的Bug的，因此如果你要在生产环境使用，需要格外小心。一旦发现Bug，请反馈给作者团队知道 尝试将本文的P2P网络跟之前的共识协议结合，例如之前的文章PoW 和PoS (PoS是中文译文) 添加持久化存储。截止目前，为了简化实现，我们没有实现持久化存储，因此节点关闭，数据就丢失了 本文的代码没有在大量节点的环境下测试过，试着写一个脚本运行大量节点，看看性能会怎么变化。如果发现Bug记得给我们[提交]((https://github.com/mycoralhealth/blockchain-tutorial/tree/master/p2p) 学习一下节点发现技术。新节点是怎么发现已经存在的节点的？这篇文章是一个很好的起点 如果我写的任何文章曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的技术探索之路。 有时候，虽然素未谋面，却已相识很久，很微妙也很知足。 想学习区块链技术，可以搜索公众号优优区块链课堂或者添加公众微信号uulesson 阅读更多" />
<meta property="og:description" content="版权声明：本文为Sunface(孙飞)原创文章，转载请注明出处 https://blog.csdn.net/abv123456789/article/details/79953019 外文发表日期： 2018-04-14 外文链接：https://medium.com/coinmonks/code-a-simple-p2p-blockchain-in-go-46662601f417 在之前的文章中，我们已经知道了怎么编写PoW也知道了IPFS怎么工作, 但是有一个致命的缺点，我们的服务都是中心化的，这篇文章会教你怎么实现一个简单的完全去中心化的P2P网络。 背景知识 什么是P2P网络 在真正的P2P架构中，不需要中心化的服务来维护区块链的状态。例如，当你给朋友发送比特币时，比特币区块链的“状态”应该更新，这样你朋友的余额就会增加，你的余额就会减少。 在这个网络中，不存在一个权力高度中心化的机构来维护状态（银行就是这样的中心化机构)。对于比特币网络来说，每个节点都会维护一份完整的区块链状态，当交易发生时，每个节点的区块链状态都会得到更新。这样，只要网络中51%的节点对区块链的状态达成一致，那么区块链网络就是安全可靠的，具体可以阅读这篇一致性协议文章。 本文将继续之前的工作,200行Go代码实现区块链, 并加入P2P网络架构。在继续之前，强烈建议你先阅读该篇文章，它会帮助你理解接下来的代码。 开始实现 编写P2P网络可不是开开玩笑就能简单视线的，有很多边边角角的情况都要覆盖到，而且需要你拥有很多工程学的知识，这样的P2P网络才是可扩展、高可靠的。有句谚语说得好：站在巨人肩膀上做事，那么我们先看看巨人们提供了哪些工具吧。 喔，看看，我们发现了什么！一个用Go语言实现的P2P库go-libp2p！如果你对新技术足够敏锐，就会发现这个库的作者和IPFS的作者是同一个团队。如果你还没看过我们的IPFS教程，可以看看这里, 你可以选择跳过IPFS教程，因为对于本文这不是必须的。 警告 目前来说，go-libp2p主要有两个缺点: 1. 安装设置比较痛苦，它使用gx作为包管理工具，怎么说呢，不咋好用，但是凑活用吧 2. 目前项目还没有成熟，正在紧密锣鼓的开发中，当使用这个库时，可能会遇到一些数据竞争(data race) 对于第一点，不必担心，有我们呢。第二点是比较大的问题，但是不会影响我们的代码。假如你在使用过程中发现了数据竞争问题，记得给项目提一个issue，帮助它更好的成长！ 总之，目前开源世界中，现代化的P2P库是非常非常少的，因为我们要多给go-libp2p一些耐心和包容，而且就目前来说，它已经能很好的满足我们的目标了。 安装设置 最好的环境设置方式是直接clone libp2p库，然后在这个库的代码中直接开发。你也可以在自己的库中，调用这个库开发，但是这样就需要用到gx了。这里我们使用简单的方式，假设你已经安装了Go: - go get -d github.com/libp2p/go-libp2p/… - 进入go-libp2p文件夹 - make - make deps 这里会通过gx包管理工具下载所有需要的包和依赖，再次申明，我们不喜欢gx，因为它打破了Go语言的很多惯例，但是为了这个很棒的库，认怂吧。 这里，我们在examples子目录下进行开发，因此在go-libp2p的examples下创建一个你自己的目录 - mkdir ./examples/p2p 然后进入到p2p文件夹下，创建main.go文件，后面所有的代码都会在该文件中。 你的目录结构是这样的： 好了，勇士们，拔出你们的剑，哦不，拔出你们的main.go，开始我们的征途吧！ 导入相关库 这里申明我们需要用的库，大部分库是来自于go-libp2p本身的，在教程中，你会学到怎么去使用它们。 package main import ( &quot;bufio&quot; &quot;context&quot; &quot;crypto/rand&quot; &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; mrand &quot;math/rand&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; golog &quot;github.com/ipfs/go-log&quot; libp2p &quot;github.com/libp2p/go-libp2p&quot; crypto &quot;github.com/libp2p/go-libp2p-crypto&quot; host &quot;github.com/libp2p/go-libp2p-host&quot; net &quot;github.com/libp2p/go-libp2p-net&quot; peer &quot;github.com/libp2p/go-libp2p-peer&quot; pstore &quot;github.com/libp2p/go-libp2p-peerstore&quot; ma &quot;github.com/multiformats/go-multiaddr&quot; gologging &quot;github.com/whyrusleeping/go-logging&quot; ) spew包可以很方便、优美的打印出我们的区块链，因此记得安装它： - go get github.com/davecgh/go-spew/spew 区块链结构 记住，请先阅读200行Go代码实现区块链， 这样，下面的部分就会简单很多。 先来申明全局变量： // Block represents each &#39;item&#39; in the blockchain type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } // Blockchain is a series of validated Blocks var Blockchain []Block var mutex = &amp;sync.Mutex{} 我们是一家健康看护公司，因此Block中存着的是用户的脉搏速率BPM Blockchain是我们的”状态”，或者严格的说：最新的Blockchain，它其实就是Block的切片（slice) mutex是为了防止资源竞争出现 下面是Blockchain相关的特定函数： // make sure block is valid by checking index, and comparing the hash of the previous block func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } // SHA256 hashing func calculateHash(block Block) string { record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } // create a new block using previous block&#39;s hash func generateBlock(oldBlock Block, BPM int) Block { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock } isBlockValid检查Block的hash是否合法 calculateHash使用sha256来对原始数据做hash generateBlock创建一个新的Block区块，然后添加到区块链Blockchain上，同时会包含所需的事务 P2P结构 下面我们快接近核心部分了，首先我们要写出创建主机的逻辑。当一个节点运行我们的程序时，它可以作为一个主机，被其它节点连接。下面一起看看代码:-) // makeBasicHost creates a LibP2P host with a random peer ID listening on the // given multiaddress. It will use secio if secio is true. func makeBasicHost(listenPort int, secio bool, randseed int64) (host.Host, error) { // If the seed is zero, use real cryptographic randomness. Otherwise, use a // deterministic randomness source to make generated keys stay the same // across multiple runs var r io.Reader if randseed == 0 { r = rand.Reader } else { r = mrand.New(mrand.NewSource(randseed)) } // Generate a key pair for this host. We will use it // to obtain a valid host ID. priv, _, err := crypto.GenerateKeyPairWithReader(crypto.RSA, 2048, r) if err != nil { return nil, err } opts := []libp2p.Option{ libp2p.ListenAddrStrings(fmt.Sprintf(&quot;/ip4/127.0.0.1/tcp/%d&quot;, listenPort)), libp2p.Identity(priv), } if !secio { opts = append(opts, libp2p.NoEncryption()) } basicHost, err := libp2p.New(context.Background(), opts...) if err != nil { return nil, err } // Build host multiaddress hostAddr, _ := ma.NewMultiaddr(fmt.Sprintf(&quot;/ipfs/%s&quot;, basicHost.ID().Pretty())) // Now we can build a full multiaddress to reach this host // by encapsulating both addresses: addr := basicHost.Addrs()[0] fullAddr := addr.Encapsulate(hostAddr) log.Printf(&quot;I am %s\n&quot;, fullAddr) if secio { log.Printf(&quot;Now run \&quot;go run main.go -l %d -d %s -secio\&quot; on a different terminal\n&quot;, listenPort+1, fullAddr) } else { log.Printf(&quot;Now run \&quot;go run main.go -l %d -d %s\&quot; on a different terminal\n&quot;, listenPort+1, fullAddr) } return basicHost, nil } makeBasicHost函数有3个参数，同时返回一个host结构体 - listenPort是主机监听的端口，其它节点会连接该端口 - secio表明是否开启数据流的安全选项，最好开启，因此它代表了”安全输入／输出” - randSeed是一个可选的命令行标识，可以允许我们提供一个随机数种子来为我们的主机生成随机的地址。这里我们不会使用 函数的第一个if语句针对随机种子生成随机key，接着我们生成公钥和私钥，这样能保证主机是安全的。opts部分开始构建网络地址部分，这样其它节点就可以连接进来。 !secio部分可以绕过加密，但是我们准备使用加密，因此这段代码不会被触发。 接着，创建了主机地址，这样其他节点就可以连接进来。log.Printf可以用来在控制台打印出其它节点的连接信息。最后我们返回生成的主机地址给调用方函数。 流处理 之前的主机需要能处理进入的数据流。当另外一个节点连接到主机时，它会想要提出一个新的区块链，来覆盖主机上的区块链，因此我们需要逻辑来判定是否要接受新的区块链。 同时，当我们往本地的区块链添加区块后，也要把相关信息广播给其它节点，这里也需要实现相关逻辑。 先来创建流处理的基本框架吧： func handleStream(s net.Stream) { log.Println(&quot;Got a new stream!&quot;) // Create a buffer stream for non blocking read and write. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) go readData(rw) go writeData(rw) // stream &#39;s&#39; will stay open until you close it (or the other side closes it). } 这里创建一个新的ReadWriter，为了能支持数据读取和写入，同时我们启动了一个单独的Go协程来处理相关读写逻辑。 读取数据 首先创建readData函数： func readData(rw *bufio.ReadWriter) { for { str, err := rw.ReadString(&#39;\n&#39;) if err != nil { log.Fatal(err) } if str == &quot;&quot; { return } if str != &quot;\n&quot; { chain := make([]Block, 0) if err := json.Unmarshal([]byte(str), &amp;chain); err != nil { log.Fatal(err) } mutex.Lock() if len(chain) &gt; len(Blockchain) { Blockchain = chain bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { log.Fatal(err) } // Green console color: \x1b[32m // Reset console color: \x1b[0m fmt.Printf(&quot;\x1b[32m%s\x1b[0m&gt; &quot;, string(bytes)) } mutex.Unlock() } } } 该函数是一个无限循环，因为它需要永不停歇的去读取外面进来的数据。首先，我们使用ReadString解析从其它节点发送过来的新的区块链（JSON字符串)。 然后检查进来的区块链的长度是否比我们本地的要长，如果进来的链更长，那么我们就接受新的链为最新的网络状态（最新的区块链)。 同时，把最新的区块链在控制台使用一种特殊的颜色打印出来，这样我们就知道有新链接受了。 如果在我们主机的本地添加了新的区块到区块链上，那就需要把本地最新的区块链广播给其它相连的节点知道，这样这些节点机会接受并更新到我们的区块链版本。这里使用writeData函数: func writeData(rw *bufio.ReadWriter) { go func() { for { time.Sleep(5 * time.Second) mutex.Lock() bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } mutex.Unlock() mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } }() stdReader := bufio.NewReader(os.Stdin) for { fmt.Print(&quot;&gt; &quot;) sendData, err := stdReader.ReadString(&#39;\n&#39;) if err != nil { log.Fatal(err) } sendData = strings.Replace(sendData, &quot;\n&quot;, &quot;&quot;, -1) bpm, err := strconv.Atoi(sendData) if err != nil { log.Fatal(err) } newBlock := generateBlock(Blockchain[len(Blockchain)-1], bpm) if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { mutex.Lock() Blockchain = append(Blockchain, newBlock) mutex.Unlock() } bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } spew.Dump(Blockchain) mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } } 首先是一个单独协程中的函数，每5秒钟会将我们的最新的区块链状态广播给其它相连的节点。它们收到后，如果发现我们的区块链比它们的要短，就会直接把我们发送的区块链信息丢弃，继续使用它们的区块链，反之则使用我们的区块链。总之，无论哪种方法，所有的节点都会定期的同步本地的区块链到最新状态。 这里我们需要一个方法来创建一个新的Block区块，包含之前提到过的脉搏速率（BPM)。为了简化实现，我们不会真的去通过物联网设备读取脉搏，而是直接在终端控制台上输入一个脉搏速率数字。 首先要验证输入的BPM是一个整数类型，然后使用之前的generateBlock来生成区块，接着使用spew.Dump输入到终端控制台，最后我们使用rw.WriteString把最新的区块链广播给相连的其它节点。 牛逼了我的哥，现在我们完成了区块链相关的函数以及大多数P2P相关的函数。在前面，我们创建了流处理，因此可以读取和写入最新的区块链状态；创建了状态同步函数，这样节点之间可以互相同步最新状态。 剩下的就是实现我们的main函数了： func main() { t := time.Now() genesisBlock := Block{} genesisBlock = Block{0, t.String(), 0, calculateHash(genesisBlock), &quot;&quot;} Blockchain = append(Blockchain, genesisBlock) // LibP2P code uses golog to log messages. They log with different // string IDs (i.e. &quot;swarm&quot;). We can control the verbosity level for // all loggers with: golog.SetAllLoggers(gologging.INFO) // Change to DEBUG for extra info // Parse options from the command line listenF := flag.Int(&quot;l&quot;, 0, &quot;wait for incoming connections&quot;) target := flag.String(&quot;d&quot;, &quot;&quot;, &quot;target peer to dial&quot;) secio := flag.Bool(&quot;secio&quot;, false, &quot;enable secio&quot;) seed := flag.Int64(&quot;seed&quot;, 0, &quot;set random seed for id generation&quot;) flag.Parse() if *listenF == 0 { log.Fatal(&quot;Please provide a port to bind on with -l&quot;) } // Make a host that listens on the given multiaddress ha, err := makeBasicHost(*listenF, *secio, *seed) if err != nil { log.Fatal(err) } if *target == &quot;&quot; { log.Println(&quot;listening for connections&quot;) // Set a stream handler on host A. /p2p/1.0.0 is // a user-defined protocol name. ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) select {} // hang forever /**** This is where the listener code ends ****/ } else { ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) // The following code extracts target&#39;s peer ID from the // given multiaddress ipfsaddr, err := ma.NewMultiaddr(*target) if err != nil { log.Fatalln(err) } pid, err := ipfsaddr.ValueForProtocol(ma.P_IPFS) if err != nil { log.Fatalln(err) } peerid, err := peer.IDB58Decode(pid) if err != nil { log.Fatalln(err) } // Decapsulate the /ipfs/&lt;peerID&gt; part from the target // /ip4/&lt;a.b.c.d&gt;/ipfs/&lt;peer&gt; becomes /ip4/&lt;a.b.c.d&gt; targetPeerAddr, _ := ma.NewMultiaddr( fmt.Sprintf(&quot;/ipfs/%s&quot;, peer.IDB58Encode(peerid))) targetAddr := ipfsaddr.Decapsulate(targetPeerAddr) // We have a peer ID and a targetAddr so we add it to the peerstore // so LibP2P knows how to contact it ha.Peerstore().AddAddr(peerid, targetAddr, pstore.PermanentAddrTTL) log.Println(&quot;opening stream&quot;) // make a new stream from host B to host A // it should be handled on host A by the handler we set above because // we use the same /p2p/1.0.0 protocol s, err := ha.NewStream(context.Background(), peerid, &quot;/p2p/1.0.0&quot;) if err != nil { log.Fatalln(err) } // Create a buffered stream so that read and writes are non blocking. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) // Create a thread to read and write data. go writeData(rw) go readData(rw) select {} // hang forever } } 首先是创建一个创世区块（如果你读了200行Go代码实现你的区块链,这里就不会陌生)。 其次我们使用go-libp2p的SetAllLoggers日志函数来记录日志。 接着，设置了所有的命令行标识： secio之前有提到，是用来加密数据流的。在我们的程序中，一定要打开该标识 target指明当前节点要连接到的主机地址 listenF是当前节点的监听主机地址，这样其它节点就可以连接进来，记住，每个节点都有两个身份：主机和客户端， 毕竟P2P不是白叫的 seed是随机数种子，用来创建主机地址时使用 然后，使用makeBasicHost函数来创建一个新的主机地址，如果我们只想做主机不想做客户端（连接其它的主机)，就使用if *target == “”。 接下来的几行，会从target解析出我们要连接到的主机地址。然后把peerID和主机目标地址targetAddr添加到”store”中，这样就可以持续跟踪我们跟其它主机的连接信息，这里使用的是ha.Peerstore().AddAddr函数。 接着我们使用ha.NewStream连接到想要连接的节点上，同时为了能接收和发送最新的区块链信息，创建了ReadWriter，同时使用一个Go协程来进行readData和writeData。 哇哦 终于完成了，写文章远比写代码累！我知道之前的内容有点难，但是相比P2P的复杂性来说，你能通过一个库来完成P2P网络，已经很牛逼了，所以继续加油！ 完整代码 mycoralhealth/blockchain-tutorial 运行结果 现在让我们来试验一下，首先打开3个独立的终端窗口做为独立节点。 开始之前，请再次进入go-libp2p的根目录运行一下make deps，确保所有依赖都正常安装。 回到你的工作目录examples/p2p，打开第一个终端窗口，输入 go run main.go -l 10000 -secio 细心的读者会发现有一段话”Now run…”，那还等啥，继续跟着做吧，打开第二个终端窗口运行：go run main.go -l 10001 -d &lt;given address in the instructions&gt; -secio 这是你会发现第一个终端窗口检测到了新连接! 接着打开第三个终端窗口，运行：go run main.go -l 10002 -d &lt;given address in the instructions&gt; -secio 检查第二终端，又发现了新连接 接着，该我们输入BPM数据了，在第一个终端窗口中输入”70”，等几秒中，观察各个窗口的打印输出。 来看看发生了什么： - 终端1向本地的区块链添加了一个新的区块Block - 终端1向终端2广播该信息 - 终端2将新的区块链跟本地的对比，发现终端1的更长，因此使用新的区块链替代了本地的区块链，然后将新的区块链广播给终端3 - 同上，终端3也进行更新 所有的3个终端节点都把区块链更新到了最新版本，同时没有使用任何外部的中心化服务，这就是P2P网络的力量！ 我们再往终端2的区块链中添加一个区块试试看，在终端2中输入”80” 结果忠诚的记录了我们的正确性，再一次欢呼吧！ 下一步 先享受一下自己的工作，你刚用了区区几百行代码就实现了一个全功能的P2P网络！这不是开玩笑，P2P编程时非常复杂的，为什么之前没有相关的教程，就是因为太难了。 但是，这里也有几个可以改进的地方，你可以挑战一下自己： 之前提到过,go-libp2p是存在数据竞争的Bug的，因此如果你要在生产环境使用，需要格外小心。一旦发现Bug，请反馈给作者团队知道 尝试将本文的P2P网络跟之前的共识协议结合，例如之前的文章PoW 和PoS (PoS是中文译文) 添加持久化存储。截止目前，为了简化实现，我们没有实现持久化存储，因此节点关闭，数据就丢失了 本文的代码没有在大量节点的环境下测试过，试着写一个脚本运行大量节点，看看性能会怎么变化。如果发现Bug记得给我们[提交]((https://github.com/mycoralhealth/blockchain-tutorial/tree/master/p2p) 学习一下节点发现技术。新节点是怎么发现已经存在的节点的？这篇文章是一个很好的起点 如果我写的任何文章曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的技术探索之路。 有时候，虽然素未谋面，却已相识很久，很微妙也很知足。 想学习区块链技术，可以搜索公众号优优区块链课堂或者添加公众微信号uulesson 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为Sunface(孙飞)原创文章，转载请注明出处 https://blog.csdn.net/abv123456789/article/details/79953019 外文发表日期： 2018-04-14 外文链接：https://medium.com/coinmonks/code-a-simple-p2p-blockchain-in-go-46662601f417 在之前的文章中，我们已经知道了怎么编写PoW也知道了IPFS怎么工作, 但是有一个致命的缺点，我们的服务都是中心化的，这篇文章会教你怎么实现一个简单的完全去中心化的P2P网络。 背景知识 什么是P2P网络 在真正的P2P架构中，不需要中心化的服务来维护区块链的状态。例如，当你给朋友发送比特币时，比特币区块链的“状态”应该更新，这样你朋友的余额就会增加，你的余额就会减少。 在这个网络中，不存在一个权力高度中心化的机构来维护状态（银行就是这样的中心化机构)。对于比特币网络来说，每个节点都会维护一份完整的区块链状态，当交易发生时，每个节点的区块链状态都会得到更新。这样，只要网络中51%的节点对区块链的状态达成一致，那么区块链网络就是安全可靠的，具体可以阅读这篇一致性协议文章。 本文将继续之前的工作,200行Go代码实现区块链, 并加入P2P网络架构。在继续之前，强烈建议你先阅读该篇文章，它会帮助你理解接下来的代码。 开始实现 编写P2P网络可不是开开玩笑就能简单视线的，有很多边边角角的情况都要覆盖到，而且需要你拥有很多工程学的知识，这样的P2P网络才是可扩展、高可靠的。有句谚语说得好：站在巨人肩膀上做事，那么我们先看看巨人们提供了哪些工具吧。 喔，看看，我们发现了什么！一个用Go语言实现的P2P库go-libp2p！如果你对新技术足够敏锐，就会发现这个库的作者和IPFS的作者是同一个团队。如果你还没看过我们的IPFS教程，可以看看这里, 你可以选择跳过IPFS教程，因为对于本文这不是必须的。 警告 目前来说，go-libp2p主要有两个缺点: 1. 安装设置比较痛苦，它使用gx作为包管理工具，怎么说呢，不咋好用，但是凑活用吧 2. 目前项目还没有成熟，正在紧密锣鼓的开发中，当使用这个库时，可能会遇到一些数据竞争(data race) 对于第一点，不必担心，有我们呢。第二点是比较大的问题，但是不会影响我们的代码。假如你在使用过程中发现了数据竞争问题，记得给项目提一个issue，帮助它更好的成长！ 总之，目前开源世界中，现代化的P2P库是非常非常少的，因为我们要多给go-libp2p一些耐心和包容，而且就目前来说，它已经能很好的满足我们的目标了。 安装设置 最好的环境设置方式是直接clone libp2p库，然后在这个库的代码中直接开发。你也可以在自己的库中，调用这个库开发，但是这样就需要用到gx了。这里我们使用简单的方式，假设你已经安装了Go: - go get -d github.com/libp2p/go-libp2p/… - 进入go-libp2p文件夹 - make - make deps 这里会通过gx包管理工具下载所有需要的包和依赖，再次申明，我们不喜欢gx，因为它打破了Go语言的很多惯例，但是为了这个很棒的库，认怂吧。 这里，我们在examples子目录下进行开发，因此在go-libp2p的examples下创建一个你自己的目录 - mkdir ./examples/p2p 然后进入到p2p文件夹下，创建main.go文件，后面所有的代码都会在该文件中。 你的目录结构是这样的： 好了，勇士们，拔出你们的剑，哦不，拔出你们的main.go，开始我们的征途吧！ 导入相关库 这里申明我们需要用的库，大部分库是来自于go-libp2p本身的，在教程中，你会学到怎么去使用它们。 package main import ( &quot;bufio&quot; &quot;context&quot; &quot;crypto/rand&quot; &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; mrand &quot;math/rand&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; golog &quot;github.com/ipfs/go-log&quot; libp2p &quot;github.com/libp2p/go-libp2p&quot; crypto &quot;github.com/libp2p/go-libp2p-crypto&quot; host &quot;github.com/libp2p/go-libp2p-host&quot; net &quot;github.com/libp2p/go-libp2p-net&quot; peer &quot;github.com/libp2p/go-libp2p-peer&quot; pstore &quot;github.com/libp2p/go-libp2p-peerstore&quot; ma &quot;github.com/multiformats/go-multiaddr&quot; gologging &quot;github.com/whyrusleeping/go-logging&quot; ) spew包可以很方便、优美的打印出我们的区块链，因此记得安装它： - go get github.com/davecgh/go-spew/spew 区块链结构 记住，请先阅读200行Go代码实现区块链， 这样，下面的部分就会简单很多。 先来申明全局变量： // Block represents each &#39;item&#39; in the blockchain type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } // Blockchain is a series of validated Blocks var Blockchain []Block var mutex = &amp;sync.Mutex{} 我们是一家健康看护公司，因此Block中存着的是用户的脉搏速率BPM Blockchain是我们的”状态”，或者严格的说：最新的Blockchain，它其实就是Block的切片（slice) mutex是为了防止资源竞争出现 下面是Blockchain相关的特定函数： // make sure block is valid by checking index, and comparing the hash of the previous block func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } // SHA256 hashing func calculateHash(block Block) string { record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } // create a new block using previous block&#39;s hash func generateBlock(oldBlock Block, BPM int) Block { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock } isBlockValid检查Block的hash是否合法 calculateHash使用sha256来对原始数据做hash generateBlock创建一个新的Block区块，然后添加到区块链Blockchain上，同时会包含所需的事务 P2P结构 下面我们快接近核心部分了，首先我们要写出创建主机的逻辑。当一个节点运行我们的程序时，它可以作为一个主机，被其它节点连接。下面一起看看代码:-) // makeBasicHost creates a LibP2P host with a random peer ID listening on the // given multiaddress. It will use secio if secio is true. func makeBasicHost(listenPort int, secio bool, randseed int64) (host.Host, error) { // If the seed is zero, use real cryptographic randomness. Otherwise, use a // deterministic randomness source to make generated keys stay the same // across multiple runs var r io.Reader if randseed == 0 { r = rand.Reader } else { r = mrand.New(mrand.NewSource(randseed)) } // Generate a key pair for this host. We will use it // to obtain a valid host ID. priv, _, err := crypto.GenerateKeyPairWithReader(crypto.RSA, 2048, r) if err != nil { return nil, err } opts := []libp2p.Option{ libp2p.ListenAddrStrings(fmt.Sprintf(&quot;/ip4/127.0.0.1/tcp/%d&quot;, listenPort)), libp2p.Identity(priv), } if !secio { opts = append(opts, libp2p.NoEncryption()) } basicHost, err := libp2p.New(context.Background(), opts...) if err != nil { return nil, err } // Build host multiaddress hostAddr, _ := ma.NewMultiaddr(fmt.Sprintf(&quot;/ipfs/%s&quot;, basicHost.ID().Pretty())) // Now we can build a full multiaddress to reach this host // by encapsulating both addresses: addr := basicHost.Addrs()[0] fullAddr := addr.Encapsulate(hostAddr) log.Printf(&quot;I am %s\\n&quot;, fullAddr) if secio { log.Printf(&quot;Now run \\&quot;go run main.go -l %d -d %s -secio\\&quot; on a different terminal\\n&quot;, listenPort+1, fullAddr) } else { log.Printf(&quot;Now run \\&quot;go run main.go -l %d -d %s\\&quot; on a different terminal\\n&quot;, listenPort+1, fullAddr) } return basicHost, nil } makeBasicHost函数有3个参数，同时返回一个host结构体 - listenPort是主机监听的端口，其它节点会连接该端口 - secio表明是否开启数据流的安全选项，最好开启，因此它代表了”安全输入／输出” - randSeed是一个可选的命令行标识，可以允许我们提供一个随机数种子来为我们的主机生成随机的地址。这里我们不会使用 函数的第一个if语句针对随机种子生成随机key，接着我们生成公钥和私钥，这样能保证主机是安全的。opts部分开始构建网络地址部分，这样其它节点就可以连接进来。 !secio部分可以绕过加密，但是我们准备使用加密，因此这段代码不会被触发。 接着，创建了主机地址，这样其他节点就可以连接进来。log.Printf可以用来在控制台打印出其它节点的连接信息。最后我们返回生成的主机地址给调用方函数。 流处理 之前的主机需要能处理进入的数据流。当另外一个节点连接到主机时，它会想要提出一个新的区块链，来覆盖主机上的区块链，因此我们需要逻辑来判定是否要接受新的区块链。 同时，当我们往本地的区块链添加区块后，也要把相关信息广播给其它节点，这里也需要实现相关逻辑。 先来创建流处理的基本框架吧： func handleStream(s net.Stream) { log.Println(&quot;Got a new stream!&quot;) // Create a buffer stream for non blocking read and write. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) go readData(rw) go writeData(rw) // stream &#39;s&#39; will stay open until you close it (or the other side closes it). } 这里创建一个新的ReadWriter，为了能支持数据读取和写入，同时我们启动了一个单独的Go协程来处理相关读写逻辑。 读取数据 首先创建readData函数： func readData(rw *bufio.ReadWriter) { for { str, err := rw.ReadString(&#39;\\n&#39;) if err != nil { log.Fatal(err) } if str == &quot;&quot; { return } if str != &quot;\\n&quot; { chain := make([]Block, 0) if err := json.Unmarshal([]byte(str), &amp;chain); err != nil { log.Fatal(err) } mutex.Lock() if len(chain) &gt; len(Blockchain) { Blockchain = chain bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { log.Fatal(err) } // Green console color: \\x1b[32m // Reset console color: \\x1b[0m fmt.Printf(&quot;\\x1b[32m%s\\x1b[0m&gt; &quot;, string(bytes)) } mutex.Unlock() } } } 该函数是一个无限循环，因为它需要永不停歇的去读取外面进来的数据。首先，我们使用ReadString解析从其它节点发送过来的新的区块链（JSON字符串)。 然后检查进来的区块链的长度是否比我们本地的要长，如果进来的链更长，那么我们就接受新的链为最新的网络状态（最新的区块链)。 同时，把最新的区块链在控制台使用一种特殊的颜色打印出来，这样我们就知道有新链接受了。 如果在我们主机的本地添加了新的区块到区块链上，那就需要把本地最新的区块链广播给其它相连的节点知道，这样这些节点机会接受并更新到我们的区块链版本。这里使用writeData函数: func writeData(rw *bufio.ReadWriter) { go func() { for { time.Sleep(5 * time.Second) mutex.Lock() bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } mutex.Unlock() mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } }() stdReader := bufio.NewReader(os.Stdin) for { fmt.Print(&quot;&gt; &quot;) sendData, err := stdReader.ReadString(&#39;\\n&#39;) if err != nil { log.Fatal(err) } sendData = strings.Replace(sendData, &quot;\\n&quot;, &quot;&quot;, -1) bpm, err := strconv.Atoi(sendData) if err != nil { log.Fatal(err) } newBlock := generateBlock(Blockchain[len(Blockchain)-1], bpm) if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { mutex.Lock() Blockchain = append(Blockchain, newBlock) mutex.Unlock() } bytes, err := json.Marshal(Blockchain) if err != nil { log.Println(err) } spew.Dump(Blockchain) mutex.Lock() rw.WriteString(fmt.Sprintf(&quot;%s\\n&quot;, string(bytes))) rw.Flush() mutex.Unlock() } } 首先是一个单独协程中的函数，每5秒钟会将我们的最新的区块链状态广播给其它相连的节点。它们收到后，如果发现我们的区块链比它们的要短，就会直接把我们发送的区块链信息丢弃，继续使用它们的区块链，反之则使用我们的区块链。总之，无论哪种方法，所有的节点都会定期的同步本地的区块链到最新状态。 这里我们需要一个方法来创建一个新的Block区块，包含之前提到过的脉搏速率（BPM)。为了简化实现，我们不会真的去通过物联网设备读取脉搏，而是直接在终端控制台上输入一个脉搏速率数字。 首先要验证输入的BPM是一个整数类型，然后使用之前的generateBlock来生成区块，接着使用spew.Dump输入到终端控制台，最后我们使用rw.WriteString把最新的区块链广播给相连的其它节点。 牛逼了我的哥，现在我们完成了区块链相关的函数以及大多数P2P相关的函数。在前面，我们创建了流处理，因此可以读取和写入最新的区块链状态；创建了状态同步函数，这样节点之间可以互相同步最新状态。 剩下的就是实现我们的main函数了： func main() { t := time.Now() genesisBlock := Block{} genesisBlock = Block{0, t.String(), 0, calculateHash(genesisBlock), &quot;&quot;} Blockchain = append(Blockchain, genesisBlock) // LibP2P code uses golog to log messages. They log with different // string IDs (i.e. &quot;swarm&quot;). We can control the verbosity level for // all loggers with: golog.SetAllLoggers(gologging.INFO) // Change to DEBUG for extra info // Parse options from the command line listenF := flag.Int(&quot;l&quot;, 0, &quot;wait for incoming connections&quot;) target := flag.String(&quot;d&quot;, &quot;&quot;, &quot;target peer to dial&quot;) secio := flag.Bool(&quot;secio&quot;, false, &quot;enable secio&quot;) seed := flag.Int64(&quot;seed&quot;, 0, &quot;set random seed for id generation&quot;) flag.Parse() if *listenF == 0 { log.Fatal(&quot;Please provide a port to bind on with -l&quot;) } // Make a host that listens on the given multiaddress ha, err := makeBasicHost(*listenF, *secio, *seed) if err != nil { log.Fatal(err) } if *target == &quot;&quot; { log.Println(&quot;listening for connections&quot;) // Set a stream handler on host A. /p2p/1.0.0 is // a user-defined protocol name. ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) select {} // hang forever /**** This is where the listener code ends ****/ } else { ha.SetStreamHandler(&quot;/p2p/1.0.0&quot;, handleStream) // The following code extracts target&#39;s peer ID from the // given multiaddress ipfsaddr, err := ma.NewMultiaddr(*target) if err != nil { log.Fatalln(err) } pid, err := ipfsaddr.ValueForProtocol(ma.P_IPFS) if err != nil { log.Fatalln(err) } peerid, err := peer.IDB58Decode(pid) if err != nil { log.Fatalln(err) } // Decapsulate the /ipfs/&lt;peerID&gt; part from the target // /ip4/&lt;a.b.c.d&gt;/ipfs/&lt;peer&gt; becomes /ip4/&lt;a.b.c.d&gt; targetPeerAddr, _ := ma.NewMultiaddr( fmt.Sprintf(&quot;/ipfs/%s&quot;, peer.IDB58Encode(peerid))) targetAddr := ipfsaddr.Decapsulate(targetPeerAddr) // We have a peer ID and a targetAddr so we add it to the peerstore // so LibP2P knows how to contact it ha.Peerstore().AddAddr(peerid, targetAddr, pstore.PermanentAddrTTL) log.Println(&quot;opening stream&quot;) // make a new stream from host B to host A // it should be handled on host A by the handler we set above because // we use the same /p2p/1.0.0 protocol s, err := ha.NewStream(context.Background(), peerid, &quot;/p2p/1.0.0&quot;) if err != nil { log.Fatalln(err) } // Create a buffered stream so that read and writes are non blocking. rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s)) // Create a thread to read and write data. go writeData(rw) go readData(rw) select {} // hang forever } } 首先是创建一个创世区块（如果你读了200行Go代码实现你的区块链,这里就不会陌生)。 其次我们使用go-libp2p的SetAllLoggers日志函数来记录日志。 接着，设置了所有的命令行标识： secio之前有提到，是用来加密数据流的。在我们的程序中，一定要打开该标识 target指明当前节点要连接到的主机地址 listenF是当前节点的监听主机地址，这样其它节点就可以连接进来，记住，每个节点都有两个身份：主机和客户端， 毕竟P2P不是白叫的 seed是随机数种子，用来创建主机地址时使用 然后，使用makeBasicHost函数来创建一个新的主机地址，如果我们只想做主机不想做客户端（连接其它的主机)，就使用if *target == “”。 接下来的几行，会从target解析出我们要连接到的主机地址。然后把peerID和主机目标地址targetAddr添加到”store”中，这样就可以持续跟踪我们跟其它主机的连接信息，这里使用的是ha.Peerstore().AddAddr函数。 接着我们使用ha.NewStream连接到想要连接的节点上，同时为了能接收和发送最新的区块链信息，创建了ReadWriter，同时使用一个Go协程来进行readData和writeData。 哇哦 终于完成了，写文章远比写代码累！我知道之前的内容有点难，但是相比P2P的复杂性来说，你能通过一个库来完成P2P网络，已经很牛逼了，所以继续加油！ 完整代码 mycoralhealth/blockchain-tutorial 运行结果 现在让我们来试验一下，首先打开3个独立的终端窗口做为独立节点。 开始之前，请再次进入go-libp2p的根目录运行一下make deps，确保所有依赖都正常安装。 回到你的工作目录examples/p2p，打开第一个终端窗口，输入 go run main.go -l 10000 -secio 细心的读者会发现有一段话”Now run…”，那还等啥，继续跟着做吧，打开第二个终端窗口运行：go run main.go -l 10001 -d &lt;given address in the instructions&gt; -secio 这是你会发现第一个终端窗口检测到了新连接! 接着打开第三个终端窗口，运行：go run main.go -l 10002 -d &lt;given address in the instructions&gt; -secio 检查第二终端，又发现了新连接 接着，该我们输入BPM数据了，在第一个终端窗口中输入”70”，等几秒中，观察各个窗口的打印输出。 来看看发生了什么： - 终端1向本地的区块链添加了一个新的区块Block - 终端1向终端2广播该信息 - 终端2将新的区块链跟本地的对比，发现终端1的更长，因此使用新的区块链替代了本地的区块链，然后将新的区块链广播给终端3 - 同上，终端3也进行更新 所有的3个终端节点都把区块链更新到了最新版本，同时没有使用任何外部的中心化服务，这就是P2P网络的力量！ 我们再往终端2的区块链中添加一个区块试试看，在终端2中输入”80” 结果忠诚的记录了我们的正确性，再一次欢呼吧！ 下一步 先享受一下自己的工作，你刚用了区区几百行代码就实现了一个全功能的P2P网络！这不是开玩笑，P2P编程时非常复杂的，为什么之前没有相关的教程，就是因为太难了。 但是，这里也有几个可以改进的地方，你可以挑战一下自己： 之前提到过,go-libp2p是存在数据竞争的Bug的，因此如果你要在生产环境使用，需要格外小心。一旦发现Bug，请反馈给作者团队知道 尝试将本文的P2P网络跟之前的共识协议结合，例如之前的文章PoW 和PoS (PoS是中文译文) 添加持久化存储。截止目前，为了简化实现，我们没有实现持久化存储，因此节点关闭，数据就丢失了 本文的代码没有在大量节点的环境下测试过，试着写一个脚本运行大量节点，看看性能会怎么变化。如果发现Bug记得给我们[提交]((https://github.com/mycoralhealth/blockchain-tutorial/tree/master/p2p) 学习一下节点发现技术。新节点是怎么发现已经存在的节点的？这篇文章是一个很好的起点 如果我写的任何文章曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的技术探索之路。 有时候，虽然素未谋面，却已相识很久，很微妙也很知足。 想学习区块链技术，可以搜索公众号优优区块链课堂或者添加公众微信号uulesson 阅读更多","@type":"BlogPosting","url":"/2018/04/15/f3d483660de8fdbd9d8847a3f29d297c.html","headline":"使用Go语言编写区块链P2P网络(译)","dateModified":"2018-04-15T00:00:00+08:00","datePublished":"2018-04-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/04/15/f3d483660de8fdbd9d8847a3f29d297c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>使用Go语言编写区块链P2P网络(译)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为Sunface(孙飞)原创文章，转载请注明出处 https://blog.csdn.net/abv123456789/article/details/79953019 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <blockquote> 
   <p>外文发表日期： 2018-04-14 <br> 外文链接：<a href="https://medium.com/coinmonks/code-a-simple-p2p-blockchain-in-go-46662601f417" rel="nofollow">https://medium.com/coinmonks/code-a-simple-p2p-blockchain-in-go-46662601f417</a></p> 
  </blockquote> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-7ed8a7dcaa5c8fe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title=""></p> 
  <p>在之前的文章中，我们已经知道了怎么编写<a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f" rel="nofollow">PoW</a>也知道了<a href="https://medium.com/@mycoralhealth/learn-to-securely-share-files-on-the-blockchain-with-ipfs-219ee47df54c" rel="nofollow">IPFS</a>怎么工作, 但是有一个致命的缺点，我们的服务都是中心化的，这篇文章会教你怎么实现一个简单的完全去中心化的P2P网络。</p> 
  <h2 id="背景知识">背景知识</h2> 
  <h4 id="什么是p2p网络">什么是P2P网络</h4> 
  <p>在真正的P2P架构中，不需要中心化的服务来维护区块链的状态。例如，当你给朋友发送比特币时，比特币区块链的“状态”应该更新，这样你朋友的余额就会增加，你的余额就会减少。</p> 
  <p>在这个网络中，不存在一个权力高度中心化的机构来维护状态（银行就是这样的中心化机构)。对于比特币网络来说，每个节点都会维护一份完整的区块链状态，当交易发生时，每个节点的区块链状态都会得到更新。这样，只要网络中51%的节点对区块链的状态达成一致，那么区块链网络就是安全可靠的，具体可以阅读这篇一致性协议<a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f" rel="nofollow">文章</a>。</p> 
  <p>本文将继续之前的工作,<a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" rel="nofollow">200行Go代码实现区块链</a>, 并加入P2P网络架构。在继续之前，强烈建议你先阅读该篇文章，它会帮助你理解接下来的代码。</p> 
  <h2 id="开始实现">开始实现</h2> 
  <p>编写P2P网络可不是开开玩笑就能简单视线的，有很多边边角角的情况都要覆盖到，而且需要你拥有很多工程学的知识，这样的P2P网络才是可扩展、高可靠的。有句谚语说得好：站在巨人肩膀上做事，那么我们先看看巨人们提供了哪些<a href="https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants" rel="nofollow">工具</a>吧。</p> 
  <p>喔，看看，我们发现了什么！一个用Go语言实现的P2P库<a href="https://github.com/libp2p/go-libp2p" rel="nofollow">go-libp2p</a>！如果你对新技术足够敏锐，就会发现这个库的作者和IPFS的作者是同一个团队。如果你还没看过我们的IPFS教程，可以看看<a href="https://medium.com/@mycoralhealth/learn-to-securely-share-files-on-the-blockchain-with-ipfs-219ee47df54c" rel="nofollow">这里</a>, 你可以选择跳过IPFS教程，因为对于本文这不是必须的。</p> 
  <h4 id="警告">警告</h4> 
  <p>目前来说，<code>go-libp2p</code>主要有两个缺点: <br> 1. 安装设置比较痛苦，它使用gx作为包管理工具，怎么说呢，不咋好用，但是凑活用吧 <br> 2. 目前项目还没有成熟，正在紧密锣鼓的开发中，当使用这个库时，可能会遇到一些数据竞争(data race)</p> 
  <p>对于第一点，不必担心，有我们呢。第二点是比较大的问题，但是不会影响我们的代码。假如你在使用过程中发现了数据竞争问题，记得给项目提一个issue，帮助它更好的成长！</p> 
  <p>总之，目前开源世界中，现代化的P2P库是非常非常少的，因为我们要多给<code>go-libp2p</code>一些耐心和包容，而且就目前来说，它已经能很好的满足我们的目标了。</p> 
  <h4 id="安装设置">安装设置</h4> 
  <p>最好的环境设置方式是直接clone <code>libp2p</code>库，然后在这个库的代码中直接开发。你也可以在自己的库中，调用这个库开发，但是这样就需要用到<code>gx</code>了。这里我们使用简单的方式，假设你已经安装了Go: <br> - <code>go get -d github.com/libp2p/go-libp2p/…</code> <br> - 进入<code>go-libp2p</code>文件夹 <br> - <code>make</code> <br> - <code>make deps</code></p> 
  <p>这里会通过gx包管理工具下载所有需要的包和依赖，再次申明，我们不喜欢gx，因为它打破了Go语言的很多惯例，但是为了这个很棒的库，认怂吧。</p> 
  <p>这里，我们在<code>examples</code>子目录下进行开发，因此在<code>go-libp2p</code>的examples下创建一个你自己的目录 <br> - <code>mkdir ./examples/p2p</code></p> 
  <p>然后进入到p2p文件夹下，创建<code>main.go</code>文件，后面所有的代码都会在该文件中。</p> 
  <p>你的目录结构是这样的： <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-64bb1e5d2f53687e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title=""></p> 
  <p>好了，勇士们，拔出你们的剑，哦不，拔出你们的<code>main.go</code>，开始我们的征途吧！</p> 
  <h4 id="导入相关库">导入相关库</h4> 
  <p>这里申明我们需要用的库，大部分库是来自于<code>go-libp2p</code>本身的，在教程中，你会学到怎么去使用它们。</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bufio"</span>
    <span class="hljs-string">"context"</span>
    <span class="hljs-string">"crypto/rand"</span>
    <span class="hljs-string">"crypto/sha256"</span>
    <span class="hljs-string">"encoding/hex"</span>
    <span class="hljs-string">"encoding/json"</span>
    <span class="hljs-string">"flag"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"log"</span>
    mrand <span class="hljs-string">"math/rand"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"strconv"</span>
    <span class="hljs-string">"strings"</span>
    <span class="hljs-string">"sync"</span>
    <span class="hljs-string">"time"</span>

    <span class="hljs-string">"github.com/davecgh/go-spew/spew"</span>
    golog <span class="hljs-string">"github.com/ipfs/go-log"</span>
    libp2p <span class="hljs-string">"github.com/libp2p/go-libp2p"</span>
    crypto <span class="hljs-string">"github.com/libp2p/go-libp2p-crypto"</span>
    host <span class="hljs-string">"github.com/libp2p/go-libp2p-host"</span>
    net <span class="hljs-string">"github.com/libp2p/go-libp2p-net"</span>
    peer <span class="hljs-string">"github.com/libp2p/go-libp2p-peer"</span>
    pstore <span class="hljs-string">"github.com/libp2p/go-libp2p-peerstore"</span>
    ma <span class="hljs-string">"github.com/multiformats/go-multiaddr"</span>
    gologging <span class="hljs-string">"github.com/whyrusleeping/go-logging"</span>
)</code></pre> 
  <p><code>spew</code>包可以很方便、优美的打印出我们的区块链，因此记得安装它： <br> - <code>go get github.com/davecgh/go-spew/spew</code></p> 
  <h4 id="区块链结构">区块链结构</h4> 
  <p>记住，请先阅读<a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" rel="nofollow">200行Go代码实现区块链</a>， 这样，下面的部分就会简单很多。</p> 
  <p>先来申明全局变量：</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// Block represents each 'item' in the blockchain</span>
<span class="hljs-keyword">type</span> Block <span class="hljs-keyword">struct</span> {
    Index     <span class="hljs-typename">int</span>
    Timestamp <span class="hljs-typename">string</span>
    BPM       <span class="hljs-typename">int</span>
    Hash      <span class="hljs-typename">string</span>
    PrevHash  <span class="hljs-typename">string</span>
}

<span class="hljs-comment">// Blockchain is a series of validated Blocks</span>
<span class="hljs-keyword">var</span> Blockchain []Block

<span class="hljs-keyword">var</span> mutex = &amp;sync.Mutex{}</code></pre> 
  <ul> 
   <li>我们是一家健康看护公司，因此Block中存着的是用户的脉搏速率BPM</li> 
   <li>Blockchain是我们的”状态”，或者严格的说：最新的Blockchain，它其实就是Block的切片（slice)</li> 
   <li>mutex是为了防止资源竞争出现</li> 
  </ul> 
  <p>下面是Blockchain相关的特定函数：</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// make sure block is valid by checking index, and comparing the hash of the previous block</span>
<span class="hljs-keyword">func</span> isBlockValid(newBlock, oldBlock Block) <span class="hljs-typename">bool</span> {
    <span class="hljs-keyword">if</span> oldBlock.Index<span class="hljs-number">+1</span> != newBlock.Index {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }

    <span class="hljs-keyword">if</span> oldBlock.Hash != newBlock.PrevHash {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }

    <span class="hljs-keyword">if</span> calculateHash(newBlock) != newBlock.Hash {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
}

<span class="hljs-comment">// SHA256 hashing</span>
<span class="hljs-keyword">func</span> calculateHash(block Block) <span class="hljs-typename">string</span> {
    record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash
    h := sha256.New()
    h.Write([]<span class="hljs-typename">byte</span>(record))
    hashed := h.Sum(<span class="hljs-constant">nil</span>)
    <span class="hljs-keyword">return</span> hex.EncodeToString(hashed)
}

<span class="hljs-comment">// create a new block using previous block's hash</span>
<span class="hljs-keyword">func</span> generateBlock(oldBlock Block, BPM <span class="hljs-typename">int</span>) Block {

    <span class="hljs-keyword">var</span> newBlock Block

    t := time.Now()

    newBlock.Index = oldBlock.Index +<span class="hljs-number"> 1</span>
    newBlock.Timestamp = t.String()
    newBlock.BPM = BPM
    newBlock.PrevHash = oldBlock.Hash
    newBlock.Hash = calculateHash(newBlock)

    <span class="hljs-keyword">return</span> newBlock
}</code></pre> 
  <ul> 
   <li><code>isBlockValid</code>检查Block的hash是否合法</li> 
   <li><code>calculateHash</code>使用<code>sha256</code>来对原始数据做hash</li> 
   <li><code>generateBlock</code>创建一个新的Block区块，然后添加到区块链Blockchain上，同时会包含所需的事务</li> 
  </ul> 
  <h4 id="p2p结构">P2P结构</h4> 
  <p>下面我们快接近核心部分了，首先我们要写出创建主机的逻辑。当一个节点运行我们的程序时，它可以作为一个主机，被其它节点连接。下面一起看看代码:-)</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// makeBasicHost creates a LibP2P host with a random peer ID listening on the</span>
<span class="hljs-comment">// given multiaddress. It will use secio if secio is true.</span>
<span class="hljs-keyword">func</span> makeBasicHost(listenPort <span class="hljs-typename">int</span>, secio <span class="hljs-typename">bool</span>, randseed <span class="hljs-typename">int64</span>) (host.Host, error) {

    <span class="hljs-comment">// If the seed is zero, use real cryptographic randomness. Otherwise, use a</span>
    <span class="hljs-comment">// deterministic randomness source to make generated keys stay the same</span>
    <span class="hljs-comment">// across multiple runs</span>
    <span class="hljs-keyword">var</span> r io.Reader
    <span class="hljs-keyword">if</span> randseed ==<span class="hljs-number"> 0</span> {
        r = rand.Reader
    } <span class="hljs-keyword">else</span> {
        r = mrand.New(mrand.NewSource(randseed))
    }

    <span class="hljs-comment">// Generate a key pair for this host. We will use it</span>
    <span class="hljs-comment">// to obtain a valid host ID.</span>
    priv, _, err := crypto.GenerateKeyPairWithReader(crypto.RSA,<span class="hljs-number"> 2048</span>, r)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }

    opts := []libp2p.Option{
        libp2p.ListenAddrStrings(fmt.Sprintf(<span class="hljs-string">"/ip4/127.0.0.1/tcp/%d"</span>, listenPort)),
        libp2p.Identity(priv),
    }

    <span class="hljs-keyword">if</span> !secio {
        opts = <span class="hljs-built_in">append</span>(opts, libp2p.NoEncryption())
    }

    basicHost, err := libp2p.New(context.Background(), opts...)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>, err
    }

    <span class="hljs-comment">// Build host multiaddress</span>
    hostAddr, _ := ma.NewMultiaddr(fmt.Sprintf(<span class="hljs-string">"/ipfs/%s"</span>, basicHost.ID().Pretty()))

    <span class="hljs-comment">// Now we can build a full multiaddress to reach this host</span>
    <span class="hljs-comment">// by encapsulating both addresses:</span>
    addr := basicHost.Addrs()<span class="hljs-number">[0</span>]
    fullAddr := addr.Encapsulate(hostAddr)
    log.Printf(<span class="hljs-string">"I am %s\n"</span>, fullAddr)
    <span class="hljs-keyword">if</span> secio {
        log.Printf(<span class="hljs-string">"Now run \"go run main.go -l %d -d %s -secio\" on a different terminal\n"</span>, listenPort<span class="hljs-number">+1</span>, fullAddr)
    } <span class="hljs-keyword">else</span> {
        log.Printf(<span class="hljs-string">"Now run \"go run main.go -l %d -d %s\" on a different terminal\n"</span>, listenPort<span class="hljs-number">+1</span>, fullAddr)
    }

    <span class="hljs-keyword">return</span> basicHost, <span class="hljs-constant">nil</span>
}</code></pre> 
  <p><code>makeBasicHost</code>函数有3个参数，同时返回一个host结构体 <br> - <code>listenPort</code>是主机监听的端口，其它节点会连接该端口 <br> - <code>secio</code>表明是否开启数据流的安全选项，最好开启，因此它代表了”安全输入／输出” <br> - <code>randSeed</code>是一个可选的命令行标识，可以允许我们提供一个随机数种子来为我们的主机生成随机的地址。这里我们不会使用</p> 
  <p>函数的第一个<code>if</code>语句针对随机种子生成随机key，接着我们生成公钥和私钥，这样能保证主机是安全的。<code>opts</code>部分开始构建网络地址部分，这样其它节点就可以连接进来。</p> 
  <p><code>!secio</code>部分可以绕过加密，但是我们准备使用加密，因此这段代码不会被触发。</p> 
  <p>接着，创建了主机地址，这样其他节点就可以连接进来。<code>log.Printf</code>可以用来在控制台打印出其它节点的连接信息。最后我们返回生成的主机地址给调用方函数。</p> 
  <h4 id="流处理">流处理</h4> 
  <p>之前的主机需要能处理进入的数据流。当另外一个节点连接到主机时，它会想要提出一个新的区块链，来覆盖主机上的区块链，因此我们需要逻辑来判定是否要接受新的区块链。</p> 
  <p>同时，当我们往本地的区块链添加区块后，也要把相关信息广播给其它节点，这里也需要实现相关逻辑。</p> 
  <p>先来创建流处理的基本框架吧：</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> handleStream(s net.Stream) {

    log.Println(<span class="hljs-string">"Got a new stream!"</span>)

    <span class="hljs-comment">// Create a buffer stream for non blocking read and write.</span>
    rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s))

    <span class="hljs-keyword">go</span> readData(rw)
    <span class="hljs-keyword">go</span> writeData(rw)

    <span class="hljs-comment">// stream 's' will stay open until you close it (or the other side closes it).</span>
}</code></pre> 
  <p>这里创建一个新的<code>ReadWriter</code>，为了能支持数据读取和写入，同时我们启动了一个单独的Go协程来处理相关读写逻辑。</p> 
  <h4 id="读取数据">读取数据</h4> 
  <p>首先创建<code>readData</code>函数：</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> readData(rw *bufio.ReadWriter) {

    <span class="hljs-keyword">for</span> {
        str, err := rw.ReadString(<span class="hljs-string">'\n'</span>)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatal(err)
        }

        <span class="hljs-keyword">if</span> str == <span class="hljs-string">""</span> {
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-keyword">if</span> str != <span class="hljs-string">"\n"</span> {

            chain := <span class="hljs-built_in">make</span>([]Block,<span class="hljs-number"> 0</span>)
            <span class="hljs-keyword">if</span> err := json.Unmarshal([]<span class="hljs-typename">byte</span>(str), &amp;chain); err != <span class="hljs-constant">nil</span> {
                log.Fatal(err)
            }

            mutex.Lock()
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(chain) &gt; <span class="hljs-built_in">len</span>(Blockchain) {
                Blockchain = chain
                bytes, err := json.MarshalIndent(Blockchain, <span class="hljs-string">""</span>, <span class="hljs-string">" "</span>)
                <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {

                    log.Fatal(err)
                }
                <span class="hljs-comment">// Green console color: \x1b[32m</span>
                <span class="hljs-comment">// Reset console color: \x1b[0m</span>
                fmt.Printf(<span class="hljs-string">"\x1b[32m%s\x1b[0m&gt; "</span>, <span class="hljs-typename">string</span>(bytes))
            }
            mutex.Unlock()
        }
    }
}</code></pre> 
  <p>该函数是一个无限循环，因为它需要永不停歇的去读取外面进来的数据。首先，我们使用<code>ReadString</code>解析从其它节点发送过来的新的区块链（JSON字符串)。</p> 
  <p>然后检查进来的区块链的长度是否比我们本地的要长，如果进来的链更长，那么我们就接受新的链为最新的网络状态（最新的区块链)。</p> 
  <p>同时，把最新的区块链在控制台使用一种特殊的颜色打印出来，这样我们就知道有新链接受了。</p> 
  <p>如果在我们主机的本地添加了新的区块到区块链上，那就需要把本地最新的区块链广播给其它相连的节点知道，这样这些节点机会接受并更新到我们的区块链版本。这里使用<code>writeData</code>函数:</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> writeData(rw *bufio.ReadWriter) {

    <span class="hljs-keyword">go</span> <span class="hljs-keyword">func</span>() {
        <span class="hljs-keyword">for</span> {
            time.Sleep<span class="hljs-number">(5</span> * time.Second)
            mutex.Lock()
            bytes, err := json.Marshal(Blockchain)
            <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
                log.Println(err)
            }
            mutex.Unlock()

            mutex.Lock()
            rw.WriteString(fmt.Sprintf(<span class="hljs-string">"%s\n"</span>, <span class="hljs-typename">string</span>(bytes)))
            rw.Flush()
            mutex.Unlock()

        }
    }()

    stdReader := bufio.NewReader(os.Stdin)

    <span class="hljs-keyword">for</span> {
        fmt.Print(<span class="hljs-string">"&gt; "</span>)
        sendData, err := stdReader.ReadString(<span class="hljs-string">'\n'</span>)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatal(err)
        }

        sendData = strings.Replace(sendData, <span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>,<span class="hljs-number"> -1</span>)
        bpm, err := strconv.Atoi(sendData)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatal(err)
        }
        newBlock := generateBlock(Blockchain[<span class="hljs-built_in">len</span>(Blockchain<span class="hljs-number">)-1</span>], bpm)

        <span class="hljs-keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="hljs-built_in">len</span>(Blockchain<span class="hljs-number">)-1</span>]) {
            mutex.Lock()
            Blockchain = <span class="hljs-built_in">append</span>(Blockchain, newBlock)
            mutex.Unlock()
        }

        bytes, err := json.Marshal(Blockchain)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Println(err)
        }

        spew.Dump(Blockchain)

        mutex.Lock()
        rw.WriteString(fmt.Sprintf(<span class="hljs-string">"%s\n"</span>, <span class="hljs-typename">string</span>(bytes)))
        rw.Flush()
        mutex.Unlock()
    }

}</code></pre> 
  <p>首先是一个单独协程中的函数，每5秒钟会将我们的最新的区块链状态广播给其它相连的节点。它们收到后，如果发现我们的区块链比它们的要短，就会直接把我们发送的区块链信息丢弃，继续使用它们的区块链，反之则使用我们的区块链。总之，无论哪种方法，所有的节点都会定期的同步本地的区块链到最新状态。</p> 
  <p>这里我们需要一个方法来创建一个新的Block区块，包含之前提到过的脉搏速率（BPM)。为了简化实现，我们不会真的去通过物联网设备读取脉搏，而是直接在终端控制台上输入一个脉搏速率数字。</p> 
  <p>首先要验证输入的BPM是一个整数类型，然后使用之前的<code>generateBlock</code>来生成区块，接着使用<code>spew.Dump</code>输入到终端控制台，最后我们使用<code>rw.WriteString</code>把最新的区块链广播给相连的其它节点。</p> 
  <p>牛逼了我的哥，现在我们完成了区块链相关的函数以及大多数P2P相关的函数。在前面，我们创建了流处理，因此可以读取和写入最新的区块链状态；创建了状态同步函数，这样节点之间可以互相同步最新状态。</p> 
  <p>剩下的就是实现我们的<code>main</code>函数了：</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> main() {
    t := time.Now()
    genesisBlock := Block{}
    genesisBlock = Block<span class="hljs-number">{0</span>, t.String(),<span class="hljs-number"> 0</span>, calculateHash(genesisBlock), <span class="hljs-string">""</span>}

    Blockchain = <span class="hljs-built_in">append</span>(Blockchain, genesisBlock)

    <span class="hljs-comment">// LibP2P code uses golog to log messages. They log with different</span>
    <span class="hljs-comment">// string IDs (i.e. "swarm"). We can control the verbosity level for</span>
    <span class="hljs-comment">// all loggers with:</span>
    golog.SetAllLoggers(gologging.INFO) <span class="hljs-comment">// Change to DEBUG for extra info</span>

    <span class="hljs-comment">// Parse options from the command line</span>
    listenF := flag.Int(<span class="hljs-string">"l"</span>,<span class="hljs-number"> 0</span>, <span class="hljs-string">"wait for incoming connections"</span>)
    target := flag.String(<span class="hljs-string">"d"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"target peer to dial"</span>)
    secio := flag.Bool(<span class="hljs-string">"secio"</span>, <span class="hljs-constant">false</span>, <span class="hljs-string">"enable secio"</span>)
    seed := flag.Int64(<span class="hljs-string">"seed"</span>,<span class="hljs-number"> 0</span>, <span class="hljs-string">"set random seed for id generation"</span>)
    flag.Parse()

    <span class="hljs-keyword">if</span> *listenF ==<span class="hljs-number"> 0</span> {
        log.Fatal(<span class="hljs-string">"Please provide a port to bind on with -l"</span>)
    }

    <span class="hljs-comment">// Make a host that listens on the given multiaddress</span>
    ha, err := makeBasicHost(*listenF, *secio, *seed)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Fatal(err)
    }

    <span class="hljs-keyword">if</span> *target == <span class="hljs-string">""</span> {
        log.Println(<span class="hljs-string">"listening for connections"</span>)
        <span class="hljs-comment">// Set a stream handler on host A. /p2p/1.0.0 is</span>
        <span class="hljs-comment">// a user-defined protocol name.</span>
        ha.SetStreamHandler(<span class="hljs-string">"/p2p/1.0.0"</span>, handleStream)

        <span class="hljs-keyword">select</span> {} <span class="hljs-comment">// hang forever</span>
        <span class="hljs-comment">/**** This is where the listener code ends ****/</span>
    } <span class="hljs-keyword">else</span> {
        ha.SetStreamHandler(<span class="hljs-string">"/p2p/1.0.0"</span>, handleStream)

        <span class="hljs-comment">// The following code extracts target's peer ID from the</span>
        <span class="hljs-comment">// given multiaddress</span>
        ipfsaddr, err := ma.NewMultiaddr(*target)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatalln(err)
        }

        pid, err := ipfsaddr.ValueForProtocol(ma.P_IPFS)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatalln(err)
        }

        peerid, err := peer.IDB58Decode(pid)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatalln(err)
        }

        <span class="hljs-comment">// Decapsulate the /ipfs/&lt;peerID&gt; part from the target</span>
        <span class="hljs-comment">// /ip4/&lt;a.b.c.d&gt;/ipfs/&lt;peer&gt; becomes /ip4/&lt;a.b.c.d&gt;</span>
        targetPeerAddr, _ := ma.NewMultiaddr(
            fmt.Sprintf(<span class="hljs-string">"/ipfs/%s"</span>, peer.IDB58Encode(peerid)))
        targetAddr := ipfsaddr.Decapsulate(targetPeerAddr)

        <span class="hljs-comment">// We have a peer ID and a targetAddr so we add it to the peerstore</span>
        <span class="hljs-comment">// so LibP2P knows how to contact it</span>
        ha.Peerstore().AddAddr(peerid, targetAddr, pstore.PermanentAddrTTL)

        log.Println(<span class="hljs-string">"opening stream"</span>)
        <span class="hljs-comment">// make a new stream from host B to host A</span>
        <span class="hljs-comment">// it should be handled on host A by the handler we set above because</span>
        <span class="hljs-comment">// we use the same /p2p/1.0.0 protocol</span>
        s, err := ha.NewStream(context.Background(), peerid, <span class="hljs-string">"/p2p/1.0.0"</span>)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Fatalln(err)
        }
        <span class="hljs-comment">// Create a buffered stream so that read and writes are non blocking.</span>
        rw := bufio.NewReadWriter(bufio.NewReader(s), bufio.NewWriter(s))

        <span class="hljs-comment">// Create a thread to read and write data.</span>
        <span class="hljs-keyword">go</span> writeData(rw)
        <span class="hljs-keyword">go</span> readData(rw)

        <span class="hljs-keyword">select</span> {} <span class="hljs-comment">// hang forever</span>

    }
}</code></pre> 
  <p>首先是创建一个创世区块（如果你读了<a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" rel="nofollow">200行Go代码实现你的区块链</a>,这里就不会陌生)。</p> 
  <p>其次我们使用<code>go-libp2p</code>的<code>SetAllLoggers</code>日志函数来记录日志。</p> 
  <p>接着，设置了所有的命令行标识：</p> 
  <ul> 
   <li><code>secio</code>之前有提到，是用来加密数据流的。在我们的程序中，一定要打开该标识</li> 
   <li><code>target</code>指明当前节点要连接到的主机地址</li> 
   <li><code>listenF</code>是当前节点的监听主机地址，这样其它节点就可以连接进来，记住，每个节点都有两个身份：主机和客户端， 毕竟P2P不是白叫的</li> 
   <li><code>seed</code>是随机数种子，用来创建主机地址时使用</li> 
  </ul> 
  <p>然后，使用<code>makeBasicHost</code>函数来创建一个新的主机地址，如果我们只想做主机不想做客户端（连接其它的主机)，就使用<code>if *target == “”</code>。</p> 
  <p>接下来的几行，会从<code>target</code>解析出我们要连接到的主机地址。然后把<code>peerID</code>和主机目标地址<code>targetAddr</code>添加到”store”中，这样就可以持续跟踪我们跟其它主机的连接信息，这里使用的是<code>ha.Peerstore().AddAddr</code>函数。</p> 
  <p>接着我们使用<code>ha.NewStream</code>连接到想要连接的节点上，同时为了能接收和发送最新的区块链信息，创建了<code>ReadWriter</code>，同时使用一个Go协程来进行<code>readData</code>和<code>writeData</code>。</p> 
  <h4 id="哇哦">哇哦</h4> 
  <p>终于完成了，写文章远比写代码累！我知道之前的内容有点难，但是相比P2P的复杂性来说，你能通过一个库来完成P2P网络，已经很牛逼了，所以继续加油！</p> 
  <h2 id="完整代码">完整代码</h2> 
  <p><a href="https://github.com/mycoralhealth/blockchain-tutorial/blob/master/p2p/main.go" rel="nofollow">mycoralhealth/blockchain-tutorial</a></p> 
  <h2 id="运行结果">运行结果</h2> 
  <p>现在让我们来试验一下，首先打开3个独立的终端窗口做为独立节点。</p> 
  <p>开始之前，请再次进入<code>go-libp2p</code>的根目录运行一下<code>make deps</code>，确保所有依赖都正常安装。</p> 
  <p>回到你的工作目录<code>examples/p2p</code>，打开第一个终端窗口，输入 <br> <code>go run main.go -l 10000 -secio</code> <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-a949bc72e0b744c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端1" title=""></p> 
  <p>细心的读者会发现有一段话”Now run…”，那还等啥，继续跟着做吧，打开第二个终端窗口运行：<code>go run main.go -l 10001 -d &lt;given address in the instructions&gt; -secio</code> <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-d2fd73a1a2a997ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端2" title=""></p> 
  <p>这是你会发现第一个终端窗口检测到了新连接!<img src="https://upload-images.jianshu.io/upload_images/8245841-37394c2d6052a2dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端1" title=""></p> 
  <p>接着打开第三个终端窗口，运行：<code>go run main.go -l 10002 -d &lt;given address in the instructions&gt; -secio</code></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-0c24d728db8898b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端3" title=""></p> 
  <p>检查第二终端，又发现了新连接 <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-e01d9181e48123cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端2" title=""></p> 
  <p>接着，该我们输入BPM数据了，在第一个终端窗口中输入”70”，等几秒中，观察各个窗口的打印输出。 <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-772afd9f729e40f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端1" title=""></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-4ff201eddaed3390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端2" title=""></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-0571659c2ecdbdd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端3" title=""></p> 
  <p>来看看发生了什么： <br> - 终端1向本地的区块链添加了一个新的区块Block <br> - 终端1向终端2广播该信息 <br> - 终端2将新的区块链跟本地的对比，发现终端1的更长，因此使用新的区块链替代了本地的区块链，然后将新的区块链广播给终端3 <br> - 同上，终端3也进行更新</p> 
  <p>所有的3个终端节点都把区块链更新到了最新版本，同时没有使用任何外部的中心化服务，这就是P2P网络的力量！</p> 
  <p>我们再往终端2的区块链中添加一个区块试试看，在终端2中输入”80”</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-89dcdce816d8120d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端2" title=""></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-62633aa803feed03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端1" title=""></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/8245841-d2795256e23f1a09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端3" title=""></p> 
  <p>结果忠诚的记录了我们的正确性，再一次欢呼吧！</p> 
  <h2 id="下一步">下一步</h2> 
  <p>先享受一下自己的工作，你刚用了区区几百行代码就实现了一个全功能的P2P网络！这不是开玩笑，P2P编程时非常复杂的，为什么之前没有相关的教程，就是因为太难了。</p> 
  <p>但是，这里也有几个可以改进的地方，你可以挑战一下自己：</p> 
  <ul> 
   <li>之前提到过,<code>go-libp2p</code>是存在数据竞争的Bug的，因此如果你要在生产环境使用，需要格外小心。一旦发现Bug，请反馈给作者团队知道</li> 
   <li>尝试将本文的P2P网络跟之前的共识协议结合，例如之前的文章<a href="https://medium.com/@mycoralhealth/code-your-own-proof-of-stake-blockchain-in-go-610cd99aa658" rel="nofollow">PoW</a> 和<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDIzMDU5OA==&amp;mid=2247483653&amp;idx=1&amp;sn=7fd3e3c9838e9fb6e83d24d1616daf6c&amp;chksm=9f03bf2ca874363ac4cecc0a45f209f5783a53ff078bf8d7294db224d137d17350d589a23df1#rd" rel="nofollow">PoS</a> (PoS是中文译文)</li> 
   <li>添加持久化存储。截止目前，为了简化实现，我们没有实现持久化存储，因此节点关闭，数据就丢失了</li> 
   <li>本文的代码没有在大量节点的环境下测试过，试着写一个脚本运行大量节点，看看性能会怎么变化。如果发现Bug记得给我们[提交]((<a href="https://github.com/mycoralhealth/blockchain-tutorial/tree/master/p2p" rel="nofollow">https://github.com/mycoralhealth/blockchain-tutorial/tree/master/p2p</a>)</li> 
   <li>学习一下节点发现技术。新节点是怎么发现已经存在的节点的？这篇文章是一个<a href="https://bitcoin.stackexchange.com/questions/3536/how-do-bitcoin-clients-find-each-other" rel="nofollow">很好的起点</a></li> 
  </ul> 
  <blockquote> 
   <p>如果我写的任何文章曾在你的心里荡起涟漪，那至少说明在逝去的岁月里，我们在某一刻，共同经历着一样的技术探索之路。 <br> 有时候，虽然素未谋面，却已相识很久，很微妙也很知足。</p> 
  </blockquote> 
  <p>想学习区块链技术，可以搜索公众号<strong>优优区块链课堂</strong>或者添加公众微信号<strong>uulesson</strong> <br> <img src="https://upload-images.jianshu.io/upload_images/8245841-b0f3cacfa19ea443.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优优区块链课堂" title=""></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/erlib/article/details/79953019,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/erlib/article/details/79953019,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
