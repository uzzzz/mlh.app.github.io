<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>超级账本学习之三：创建超级账本网络 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="超级账本学习之三：创建超级账本网络" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="超级账本网络的创建主要包含四个步骤： 创建网络拓扑结构，创建MSP相关资料并签名 创建通道配置信息 启动网络，并创建通道 安装并实例化链码 超级账本的学习资料Build Your First Network详细讲述了上面几个步骤是怎么完成的。在示例代码中，更多的是使用已经写好的脚本来完成上面的步骤。在这里我们将完全脱离脚本，手动的创建一个超级账本网络。 特别注意：在需要重新执行下面步骤以前，先执行一下[docker-compose -f $COMPOSE_FILE down --volumes]，以确保前次执行结果被清空。否则可能出现权限不正确的问题。 创建网络拓扑结构，初始化MSP信息并签名 工具cryptogen用来创建网络的拓扑结构，初始化MSP信息，并对所有组织和节点进行签名。cryptogen位于fabric/build/bin目录下，它使用了crypto-config.yaml作为配置文件，我们可以使用[cryptogen showtemplate]查看配置文件模板。实际上，示例代码的crypto-config.yaml就是基于这个模板修改的。具体的配置方法参加模板说明。示例配置文件生产力如下所在的拓扑网络： 如果，包含了两种类型的组织：OrdererOrgs和PeerOrgs。一个Orderer组织下面有一个节点；而Peers有两个组织，每个组织通过Template创建了两个Peers。因此，根据该配置文件，cryptogen将会生成5个节点： -&nbsp;&nbsp;&nbsp;&nbsp;orderer.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org2.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org2.example.com 可以使用下面的命令来创建拓扑网络： cd /opt/gopath/src/github.com/hyperledger/fabric-samples/first-network ../../fabric/build/bin/cryptogen generate --config=./crypto-config.yaml 命令将会在在当前目录下生成crypto-config目录。使用命令[tree crypto-config]命令可以查看目录的整体结构。简单的说，cryptogen完成了以下工作： 为每个组织生成了签名，包括orderer组织和peer组织。 为每个组织生成了MSP信息，包括orderer组织和peer组织。 为组织内的每个成员生成了签名。 为每个组织定了用一个管理员和一个用户。 至此，网络的拓扑结构生成完毕。MSP模块将使用这些内容对节点进行安全管理和认证。 创建通道配置信息 通道配置信息包括三个方面的内容：创世区块、通道配置信息和各个组织的Anchor Peer。使用configtxgen来完成通道配置信息的创建。可以使用[configtxgen --help]查看工具的使用方法。和cryptogen不同，configtxgen指定使用configtx.yaml。 configtx.yaml主要定义了两个profile：TwoOrgsOrdererGenesis和TwoOrgsChannel。 TwoOrgsOrdererGenesis主要用于Orderer节点的定义；TwoOrgsChannel主要用于Peer节点的定义。 每个profile都定义了capability和组织的内部信息； 组织信息都包括Name（节点名字）；ID（用来标识该节点）；MSPDir（指定msp信息地址，有上面cryptogen工具生成）。 对于Peer节点，还需要定义Anchor Peer的信息。 从这个意义来说，超级账本的分布式更像是基于组织的分布式，这和我们通常理解的分布式和去中心化有很大不同。 创建创世块 创世块的创建可以使用下面的命令完成 export FABRIC_CFG_PATH=$PWD ../../fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 它使用了TwoOrgsOrdererGenesis的profile，生成了genesis.block区块，因此区块应该是一个和排序服务相关的概念。需要注意的是，这里不能修改区块的名字，在我们创建好通道后区块名字会被修改成为[通道名].block。 创建通道配置信息 通道配置信息可以通过下面的命令创建： export CHANNEL_NAME=shimzhaochnl configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 它使用了TwoOrgsChannel的profile，生成了名外shimzhaochnl的通道。通道配置信息保存在了channel.tx文件中。 配置Anchor Peer Anchor Peer是一个组织内负责与其他组织打交道的门户节点，通常情况它也是背书节点。一个组织可以有多个节点加入到区块链网络，但是必须有至少一个Anchor Peer。Anchor Peer的配置可以使用下面的命令完成： configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 由于Anchor Peer定义在TwoOrgsChannelprofile中，上面分别的命令用到了TwoOrgsChannel profile。上面分别为Org1MSP和OrgMSP定义了Anchor Peer。 至此，通道配置信息创建完毕。生成的文件保存在了当前目录的[channel-artifacts]下面。可以使用下面的命令查看创建的区块信息： ../../fabric/build/bin/configtxgen -inspectBlock ./channel-artifacts/genesis.block 也可以使用下面的信息查看通道信息： ../../fabric/build/bin/configtxgen -inspectChannelCreateTx ./channel-artifacts/channel.tx 除此之外，还可以查看组织信息： ../../fabric/build/bin/configtxgen -printOrg Org1MSP 启动网络，创建通道 通道交易信息和创世块准备完毕后就可以启动区块链网络了。在这里我们使用docker-compose-cli.yaml文件启动网络： vagrant@ubuntu-xenial:first-network$ docker-compose -f docker-compose-cli.yaml up -d Creating network &quot;net_byfn&quot; with the default driver Creating peer1.org1.example.com ... Creating orderer.example.com ... Creating peer0.org2.example.com ... Creating peer1.org2.example.com ... Creating peer0.org1.example.com ... Creating orderer.example.com Creating peer1.org1.example.com Creating peer0.org2.example.com Creating peer1.org2.example.com Creating peer1.org2.example.com ... done Creating cli ... Creating cli ... done 去掉[-d]可以查看更多的log信息，启动完成后可以使用[docker ps -a]查看所有节点是否正确启动。 网络启动后我们还需要创建通道、加入通道、更新通道的Anchor Peer配置。 创建通道 创建通道以前我们需要进入到cli节点，cli相当于超级账本的一个application，每次在操作peer的时候它都会去读取下面的环境变量以确定要操作哪一个Peer。cli是通过读取下面的配置文件来确定它连接的是哪个Peer节点。当操作的Peer发送变化的时候都需要重新备注这些环境变量，以确保操作的是正确的Peer节点。这些环境变量包括： CORE_PEER_MSPCONFIGPATH：用来指定MSP信息路径，有cryptogen生成 CORE_PEER_ADDRESS：用来指定节点的网络地址 CORE_PEER_TLS_ROOTCERT_FILE：用来指定数字签名文件路径 CORE_PEER_LOCALMSPID：用来指定组织MSPID 因此，首先我们要指定peer0.org1.example.com节点作为cli的连接节点，然后进入cli docker： vagrant@ubuntu-xenial: first-network$ export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp vagrant@ubuntu-xenial: first-network$ export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 vagrant@ubuntu-xenial: first-network$ export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; vagrant@ubuntu-xenial: first-network$ export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt vagrant@ubuntu-xenial: first-network$ docker exec -it cli bash root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 注意，接下来我们的操作就会在cli docker内部进行了。为了使用方便，先定义一个全局变量: root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#export CHANNEL_NAME=shimzhaochnl 然后，使用下面的命令创建通道： root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 需要说明的是，创建通道本身也是超级账本的一个交易，因此首先交易信息会被发送到Orderder排序节点，Orderer排序服务会将交易信息广播到整个网络的所有节点。上面的命令中指定的channel.tx来自configtxgen创建的通道配置信息；而公钥则是排序节点的公钥。 通道创建完成后我们还需要将每个Peer节点加入到通道中。 加入通道 加入通道需要借助cli容器。比如下面的操作允许我们将peer0.org1.example.com加入到通道： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #下面的代码在容器内执行，将当期Peer加入通道 peer channel join -b shimzhaochnl.block #注意通道名 #退出 exit 依次将其余的三个Peer都加入到通道中。可以使用[peer channel list]查看当前Peer加入了哪些通道。 更新通道的Anchor Peer配置 接下来需要制定每个Org的Anchor Peer。这个过程也是通过cli容器来实现的： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置当前连接的Peer为组织的Anchor Peer peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem #退出 exit 通过上面的命令设置了peer0.org1.example.com为Org1的Anchor Peer。可以使用同样的方法设置peer0.Org2.example.com为Org2的Anchor Peer。 在进入容器[docker exec -it cli bash]后，可以使用peer命令查看当前链接节点的各种信息。参看[peer --help]了解更多。 安装并实例化链码 链码(即智能合约)是超级账本的重要组成部分。所有的外部程序(application)对账本的访问都是通过链码实现的。对链码的操作包括安装、实例化、查询和更新。 安装链码 链码的安装也需要进入到cli容易，连接到需要安装的Peer节点，然后执行安装命令。下面的命令用于为peer0.org1.example.com安装链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #为当前Peer安装链码 peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/ #退出 exit 链码安装完成后可以使用[peer chaincode list --installed]的命令查看是否已经安装成功。接下来，还需要为其它Peer安装链码，通常我们只需要为Anchor Peer安装链码即可。 实例化链码 链码在安装完成后还需要实例化才能起作用，可以使用下面的方法实例化链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #实例化链码 peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; #退出 exit 需要注意的是： [-p]参数用来指定背书策略。比如[-P &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]只需要一个节点背书即可；而[-P &quot;AND(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]则需要两个节点都背书才可以。 链码的实例化主要是给超级账本的区块付初值。 链码的实例化只需要在任意一个节点完成即可。不需要所有节点都实例化。 查询链码 链码的查询首先需要制定Peer，然后进入cli，再执行查询语句： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码查询 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; #退出 exit 更新链码 同理，链码的更新操作类似如下： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码更新账本 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; #退出 exit 逻辑上来说，所有Peer保存的账本应该是一致的。可以通过切换Peer来验证所有账本是不是同步更新了。 阅读更多" />
<meta property="og:description" content="超级账本网络的创建主要包含四个步骤： 创建网络拓扑结构，创建MSP相关资料并签名 创建通道配置信息 启动网络，并创建通道 安装并实例化链码 超级账本的学习资料Build Your First Network详细讲述了上面几个步骤是怎么完成的。在示例代码中，更多的是使用已经写好的脚本来完成上面的步骤。在这里我们将完全脱离脚本，手动的创建一个超级账本网络。 特别注意：在需要重新执行下面步骤以前，先执行一下[docker-compose -f $COMPOSE_FILE down --volumes]，以确保前次执行结果被清空。否则可能出现权限不正确的问题。 创建网络拓扑结构，初始化MSP信息并签名 工具cryptogen用来创建网络的拓扑结构，初始化MSP信息，并对所有组织和节点进行签名。cryptogen位于fabric/build/bin目录下，它使用了crypto-config.yaml作为配置文件，我们可以使用[cryptogen showtemplate]查看配置文件模板。实际上，示例代码的crypto-config.yaml就是基于这个模板修改的。具体的配置方法参加模板说明。示例配置文件生产力如下所在的拓扑网络： 如果，包含了两种类型的组织：OrdererOrgs和PeerOrgs。一个Orderer组织下面有一个节点；而Peers有两个组织，每个组织通过Template创建了两个Peers。因此，根据该配置文件，cryptogen将会生成5个节点： -&nbsp;&nbsp;&nbsp;&nbsp;orderer.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org2.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org2.example.com 可以使用下面的命令来创建拓扑网络： cd /opt/gopath/src/github.com/hyperledger/fabric-samples/first-network ../../fabric/build/bin/cryptogen generate --config=./crypto-config.yaml 命令将会在在当前目录下生成crypto-config目录。使用命令[tree crypto-config]命令可以查看目录的整体结构。简单的说，cryptogen完成了以下工作： 为每个组织生成了签名，包括orderer组织和peer组织。 为每个组织生成了MSP信息，包括orderer组织和peer组织。 为组织内的每个成员生成了签名。 为每个组织定了用一个管理员和一个用户。 至此，网络的拓扑结构生成完毕。MSP模块将使用这些内容对节点进行安全管理和认证。 创建通道配置信息 通道配置信息包括三个方面的内容：创世区块、通道配置信息和各个组织的Anchor Peer。使用configtxgen来完成通道配置信息的创建。可以使用[configtxgen --help]查看工具的使用方法。和cryptogen不同，configtxgen指定使用configtx.yaml。 configtx.yaml主要定义了两个profile：TwoOrgsOrdererGenesis和TwoOrgsChannel。 TwoOrgsOrdererGenesis主要用于Orderer节点的定义；TwoOrgsChannel主要用于Peer节点的定义。 每个profile都定义了capability和组织的内部信息； 组织信息都包括Name（节点名字）；ID（用来标识该节点）；MSPDir（指定msp信息地址，有上面cryptogen工具生成）。 对于Peer节点，还需要定义Anchor Peer的信息。 从这个意义来说，超级账本的分布式更像是基于组织的分布式，这和我们通常理解的分布式和去中心化有很大不同。 创建创世块 创世块的创建可以使用下面的命令完成 export FABRIC_CFG_PATH=$PWD ../../fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 它使用了TwoOrgsOrdererGenesis的profile，生成了genesis.block区块，因此区块应该是一个和排序服务相关的概念。需要注意的是，这里不能修改区块的名字，在我们创建好通道后区块名字会被修改成为[通道名].block。 创建通道配置信息 通道配置信息可以通过下面的命令创建： export CHANNEL_NAME=shimzhaochnl configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 它使用了TwoOrgsChannel的profile，生成了名外shimzhaochnl的通道。通道配置信息保存在了channel.tx文件中。 配置Anchor Peer Anchor Peer是一个组织内负责与其他组织打交道的门户节点，通常情况它也是背书节点。一个组织可以有多个节点加入到区块链网络，但是必须有至少一个Anchor Peer。Anchor Peer的配置可以使用下面的命令完成： configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 由于Anchor Peer定义在TwoOrgsChannelprofile中，上面分别的命令用到了TwoOrgsChannel profile。上面分别为Org1MSP和OrgMSP定义了Anchor Peer。 至此，通道配置信息创建完毕。生成的文件保存在了当前目录的[channel-artifacts]下面。可以使用下面的命令查看创建的区块信息： ../../fabric/build/bin/configtxgen -inspectBlock ./channel-artifacts/genesis.block 也可以使用下面的信息查看通道信息： ../../fabric/build/bin/configtxgen -inspectChannelCreateTx ./channel-artifacts/channel.tx 除此之外，还可以查看组织信息： ../../fabric/build/bin/configtxgen -printOrg Org1MSP 启动网络，创建通道 通道交易信息和创世块准备完毕后就可以启动区块链网络了。在这里我们使用docker-compose-cli.yaml文件启动网络： vagrant@ubuntu-xenial:first-network$ docker-compose -f docker-compose-cli.yaml up -d Creating network &quot;net_byfn&quot; with the default driver Creating peer1.org1.example.com ... Creating orderer.example.com ... Creating peer0.org2.example.com ... Creating peer1.org2.example.com ... Creating peer0.org1.example.com ... Creating orderer.example.com Creating peer1.org1.example.com Creating peer0.org2.example.com Creating peer1.org2.example.com Creating peer1.org2.example.com ... done Creating cli ... Creating cli ... done 去掉[-d]可以查看更多的log信息，启动完成后可以使用[docker ps -a]查看所有节点是否正确启动。 网络启动后我们还需要创建通道、加入通道、更新通道的Anchor Peer配置。 创建通道 创建通道以前我们需要进入到cli节点，cli相当于超级账本的一个application，每次在操作peer的时候它都会去读取下面的环境变量以确定要操作哪一个Peer。cli是通过读取下面的配置文件来确定它连接的是哪个Peer节点。当操作的Peer发送变化的时候都需要重新备注这些环境变量，以确保操作的是正确的Peer节点。这些环境变量包括： CORE_PEER_MSPCONFIGPATH：用来指定MSP信息路径，有cryptogen生成 CORE_PEER_ADDRESS：用来指定节点的网络地址 CORE_PEER_TLS_ROOTCERT_FILE：用来指定数字签名文件路径 CORE_PEER_LOCALMSPID：用来指定组织MSPID 因此，首先我们要指定peer0.org1.example.com节点作为cli的连接节点，然后进入cli docker： vagrant@ubuntu-xenial: first-network$ export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp vagrant@ubuntu-xenial: first-network$ export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 vagrant@ubuntu-xenial: first-network$ export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; vagrant@ubuntu-xenial: first-network$ export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt vagrant@ubuntu-xenial: first-network$ docker exec -it cli bash root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 注意，接下来我们的操作就会在cli docker内部进行了。为了使用方便，先定义一个全局变量: root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#export CHANNEL_NAME=shimzhaochnl 然后，使用下面的命令创建通道： root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 需要说明的是，创建通道本身也是超级账本的一个交易，因此首先交易信息会被发送到Orderder排序节点，Orderer排序服务会将交易信息广播到整个网络的所有节点。上面的命令中指定的channel.tx来自configtxgen创建的通道配置信息；而公钥则是排序节点的公钥。 通道创建完成后我们还需要将每个Peer节点加入到通道中。 加入通道 加入通道需要借助cli容器。比如下面的操作允许我们将peer0.org1.example.com加入到通道： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #下面的代码在容器内执行，将当期Peer加入通道 peer channel join -b shimzhaochnl.block #注意通道名 #退出 exit 依次将其余的三个Peer都加入到通道中。可以使用[peer channel list]查看当前Peer加入了哪些通道。 更新通道的Anchor Peer配置 接下来需要制定每个Org的Anchor Peer。这个过程也是通过cli容器来实现的： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置当前连接的Peer为组织的Anchor Peer peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem #退出 exit 通过上面的命令设置了peer0.org1.example.com为Org1的Anchor Peer。可以使用同样的方法设置peer0.Org2.example.com为Org2的Anchor Peer。 在进入容器[docker exec -it cli bash]后，可以使用peer命令查看当前链接节点的各种信息。参看[peer --help]了解更多。 安装并实例化链码 链码(即智能合约)是超级账本的重要组成部分。所有的外部程序(application)对账本的访问都是通过链码实现的。对链码的操作包括安装、实例化、查询和更新。 安装链码 链码的安装也需要进入到cli容易，连接到需要安装的Peer节点，然后执行安装命令。下面的命令用于为peer0.org1.example.com安装链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #为当前Peer安装链码 peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/ #退出 exit 链码安装完成后可以使用[peer chaincode list --installed]的命令查看是否已经安装成功。接下来，还需要为其它Peer安装链码，通常我们只需要为Anchor Peer安装链码即可。 实例化链码 链码在安装完成后还需要实例化才能起作用，可以使用下面的方法实例化链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #实例化链码 peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; #退出 exit 需要注意的是： [-p]参数用来指定背书策略。比如[-P &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]只需要一个节点背书即可；而[-P &quot;AND(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]则需要两个节点都背书才可以。 链码的实例化主要是给超级账本的区块付初值。 链码的实例化只需要在任意一个节点完成即可。不需要所有节点都实例化。 查询链码 链码的查询首先需要制定Peer，然后进入cli，再执行查询语句： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码查询 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; #退出 exit 更新链码 同理，链码的更新操作类似如下： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码更新账本 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; #退出 exit 逻辑上来说，所有Peer保存的账本应该是一致的。可以通过切换Peer来验证所有账本是不是同步更新了。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"超级账本网络的创建主要包含四个步骤： 创建网络拓扑结构，创建MSP相关资料并签名 创建通道配置信息 启动网络，并创建通道 安装并实例化链码 超级账本的学习资料Build Your First Network详细讲述了上面几个步骤是怎么完成的。在示例代码中，更多的是使用已经写好的脚本来完成上面的步骤。在这里我们将完全脱离脚本，手动的创建一个超级账本网络。 特别注意：在需要重新执行下面步骤以前，先执行一下[docker-compose -f $COMPOSE_FILE down --volumes]，以确保前次执行结果被清空。否则可能出现权限不正确的问题。 创建网络拓扑结构，初始化MSP信息并签名 工具cryptogen用来创建网络的拓扑结构，初始化MSP信息，并对所有组织和节点进行签名。cryptogen位于fabric/build/bin目录下，它使用了crypto-config.yaml作为配置文件，我们可以使用[cryptogen showtemplate]查看配置文件模板。实际上，示例代码的crypto-config.yaml就是基于这个模板修改的。具体的配置方法参加模板说明。示例配置文件生产力如下所在的拓扑网络： 如果，包含了两种类型的组织：OrdererOrgs和PeerOrgs。一个Orderer组织下面有一个节点；而Peers有两个组织，每个组织通过Template创建了两个Peers。因此，根据该配置文件，cryptogen将会生成5个节点： -&nbsp;&nbsp;&nbsp;&nbsp;orderer.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org1.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer0.org2.example.com -&nbsp;&nbsp;&nbsp;&nbsp;peer1.org2.example.com 可以使用下面的命令来创建拓扑网络： cd /opt/gopath/src/github.com/hyperledger/fabric-samples/first-network ../../fabric/build/bin/cryptogen generate --config=./crypto-config.yaml 命令将会在在当前目录下生成crypto-config目录。使用命令[tree crypto-config]命令可以查看目录的整体结构。简单的说，cryptogen完成了以下工作： 为每个组织生成了签名，包括orderer组织和peer组织。 为每个组织生成了MSP信息，包括orderer组织和peer组织。 为组织内的每个成员生成了签名。 为每个组织定了用一个管理员和一个用户。 至此，网络的拓扑结构生成完毕。MSP模块将使用这些内容对节点进行安全管理和认证。 创建通道配置信息 通道配置信息包括三个方面的内容：创世区块、通道配置信息和各个组织的Anchor Peer。使用configtxgen来完成通道配置信息的创建。可以使用[configtxgen --help]查看工具的使用方法。和cryptogen不同，configtxgen指定使用configtx.yaml。 configtx.yaml主要定义了两个profile：TwoOrgsOrdererGenesis和TwoOrgsChannel。 TwoOrgsOrdererGenesis主要用于Orderer节点的定义；TwoOrgsChannel主要用于Peer节点的定义。 每个profile都定义了capability和组织的内部信息； 组织信息都包括Name（节点名字）；ID（用来标识该节点）；MSPDir（指定msp信息地址，有上面cryptogen工具生成）。 对于Peer节点，还需要定义Anchor Peer的信息。 从这个意义来说，超级账本的分布式更像是基于组织的分布式，这和我们通常理解的分布式和去中心化有很大不同。 创建创世块 创世块的创建可以使用下面的命令完成 export FABRIC_CFG_PATH=$PWD ../../fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 它使用了TwoOrgsOrdererGenesis的profile，生成了genesis.block区块，因此区块应该是一个和排序服务相关的概念。需要注意的是，这里不能修改区块的名字，在我们创建好通道后区块名字会被修改成为[通道名].block。 创建通道配置信息 通道配置信息可以通过下面的命令创建： export CHANNEL_NAME=shimzhaochnl configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 它使用了TwoOrgsChannel的profile，生成了名外shimzhaochnl的通道。通道配置信息保存在了channel.tx文件中。 配置Anchor Peer Anchor Peer是一个组织内负责与其他组织打交道的门户节点，通常情况它也是背书节点。一个组织可以有多个节点加入到区块链网络，但是必须有至少一个Anchor Peer。Anchor Peer的配置可以使用下面的命令完成： configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 由于Anchor Peer定义在TwoOrgsChannelprofile中，上面分别的命令用到了TwoOrgsChannel profile。上面分别为Org1MSP和OrgMSP定义了Anchor Peer。 至此，通道配置信息创建完毕。生成的文件保存在了当前目录的[channel-artifacts]下面。可以使用下面的命令查看创建的区块信息： ../../fabric/build/bin/configtxgen -inspectBlock ./channel-artifacts/genesis.block 也可以使用下面的信息查看通道信息： ../../fabric/build/bin/configtxgen -inspectChannelCreateTx ./channel-artifacts/channel.tx 除此之外，还可以查看组织信息： ../../fabric/build/bin/configtxgen -printOrg Org1MSP 启动网络，创建通道 通道交易信息和创世块准备完毕后就可以启动区块链网络了。在这里我们使用docker-compose-cli.yaml文件启动网络： vagrant@ubuntu-xenial:first-network$ docker-compose -f docker-compose-cli.yaml up -d Creating network &quot;net_byfn&quot; with the default driver Creating peer1.org1.example.com ... Creating orderer.example.com ... Creating peer0.org2.example.com ... Creating peer1.org2.example.com ... Creating peer0.org1.example.com ... Creating orderer.example.com Creating peer1.org1.example.com Creating peer0.org2.example.com Creating peer1.org2.example.com Creating peer1.org2.example.com ... done Creating cli ... Creating cli ... done 去掉[-d]可以查看更多的log信息，启动完成后可以使用[docker ps -a]查看所有节点是否正确启动。 网络启动后我们还需要创建通道、加入通道、更新通道的Anchor Peer配置。 创建通道 创建通道以前我们需要进入到cli节点，cli相当于超级账本的一个application，每次在操作peer的时候它都会去读取下面的环境变量以确定要操作哪一个Peer。cli是通过读取下面的配置文件来确定它连接的是哪个Peer节点。当操作的Peer发送变化的时候都需要重新备注这些环境变量，以确保操作的是正确的Peer节点。这些环境变量包括： CORE_PEER_MSPCONFIGPATH：用来指定MSP信息路径，有cryptogen生成 CORE_PEER_ADDRESS：用来指定节点的网络地址 CORE_PEER_TLS_ROOTCERT_FILE：用来指定数字签名文件路径 CORE_PEER_LOCALMSPID：用来指定组织MSPID 因此，首先我们要指定peer0.org1.example.com节点作为cli的连接节点，然后进入cli docker： vagrant@ubuntu-xenial: first-network$ export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp vagrant@ubuntu-xenial: first-network$ export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 vagrant@ubuntu-xenial: first-network$ export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; vagrant@ubuntu-xenial: first-network$ export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt vagrant@ubuntu-xenial: first-network$ docker exec -it cli bash root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer# 注意，接下来我们的操作就会在cli docker内部进行了。为了使用方便，先定义一个全局变量: root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#export CHANNEL_NAME=shimzhaochnl 然后，使用下面的命令创建通道： root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 需要说明的是，创建通道本身也是超级账本的一个交易，因此首先交易信息会被发送到Orderder排序节点，Orderer排序服务会将交易信息广播到整个网络的所有节点。上面的命令中指定的channel.tx来自configtxgen创建的通道配置信息；而公钥则是排序节点的公钥。 通道创建完成后我们还需要将每个Peer节点加入到通道中。 加入通道 加入通道需要借助cli容器。比如下面的操作允许我们将peer0.org1.example.com加入到通道： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #下面的代码在容器内执行，将当期Peer加入通道 peer channel join -b shimzhaochnl.block #注意通道名 #退出 exit 依次将其余的三个Peer都加入到通道中。可以使用[peer channel list]查看当前Peer加入了哪些通道。 更新通道的Anchor Peer配置 接下来需要制定每个Org的Anchor Peer。这个过程也是通过cli容器来实现的： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置当前连接的Peer为组织的Anchor Peer peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem #退出 exit 通过上面的命令设置了peer0.org1.example.com为Org1的Anchor Peer。可以使用同样的方法设置peer0.Org2.example.com为Org2的Anchor Peer。 在进入容器[docker exec -it cli bash]后，可以使用peer命令查看当前链接节点的各种信息。参看[peer --help]了解更多。 安装并实例化链码 链码(即智能合约)是超级账本的重要组成部分。所有的外部程序(application)对账本的访问都是通过链码实现的。对链码的操作包括安装、实例化、查询和更新。 安装链码 链码的安装也需要进入到cli容易，连接到需要安装的Peer节点，然后执行安装命令。下面的命令用于为peer0.org1.example.com安装链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #为当前Peer安装链码 peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/ #退出 exit 链码安装完成后可以使用[peer chaincode list --installed]的命令查看是否已经安装成功。接下来，还需要为其它Peer安装链码，通常我们只需要为Anchor Peer安装链码即可。 实例化链码 链码在安装完成后还需要实例化才能起作用，可以使用下面的方法实例化链码： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #实例化链码 peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; #退出 exit 需要注意的是： [-p]参数用来指定背书策略。比如[-P &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]只需要一个节点背书即可；而[-P &quot;AND(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;]则需要两个节点都背书才可以。 链码的实例化主要是给超级账本的区块付初值。 链码的实例化只需要在任意一个节点完成即可。不需要所有节点都实例化。 查询链码 链码的查询首先需要制定Peer，然后进入cli，再执行查询语句： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码查询 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; #退出 exit 更新链码 同理，链码的更新操作类似如下： #设置环境变量 export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt #设置通道名 export CHANNEL_NAME=shimzhaochnl #调用链码更新账本 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; #退出 exit 逻辑上来说，所有Peer保存的账本应该是一致的。可以通过切换Peer来验证所有账本是不是同步更新了。 阅读更多","@type":"BlogPosting","url":"/2018/04/24/9559a03d224299413d07db7dd33268ea.html","headline":"超级账本学习之三：创建超级账本网络","dateModified":"2018-04-24T00:00:00+08:00","datePublished":"2018-04-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/04/24/9559a03d224299413d07db7dd33268ea.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>超级账本学习之三：创建超级账本网络</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="font-family:'FangSong_GB2312';font-size:12px;">超级账本网络的创建主要包含四个步骤：</span></p>
  <ul>
   <li><span style="font-family:'FangSong_GB2312';font-size:12px;">创建网络拓扑结构，创建MSP相关资料并签名</span></li>
   <li><span style="font-family:'FangSong_GB2312';font-size:12px;">创建通道配置信息</span></li>
   <li><span style="font-family:'FangSong_GB2312';font-size:12px;">启动网络，并创建通道</span></li>
   <li><span style="font-family:'FangSong_GB2312';font-size:12px;">安装并实例化链码</span></li>
  </ul>
  <div>
   <span style="font-family:'FangSong_GB2312';font-size:12px;">超级账本的学习资料<a href="http://hyperledger-fabric.readthedocs.io/en/release-1.1/build_network.html#install-prerequisites" rel="nofollow">Build Your First Network</a>详细讲述了上面几个步骤是怎么完成的。在示例代码中，更多的是使用已经写好的脚本来完成上面的步骤。在这里我们将完全脱离脚本，手动的创建一个超级账本网络。</span>
  </div>
  <div>
   <span style="font-family:'FangSong_GB2312';font-size:12px;"><br></span>
  </div>
  <p><span style="font-family:SimSun;font-size:12px;color:#ff0000;">特别注意：在需要重新执行下面步骤以前，先执行一下[docker-compose -f $COMPOSE_FILE down --volumes]，以确保前次执行结果被清空。否则可能出现权限不正确的问题。</span></p>
  <p><span style="font-family:SimSun;font-size:12px;color:#ff0000;"><br></span></p>
  <h1></h1>
  <h1><span style="font-family:SimSun;font-size:18px;">创建网络拓扑结构，初始化MSP信息并签名</span></h1>
  <p><span style="font-family:SimSun;font-size:12px;">工具cryptogen用来创建网络的拓扑结构，初始化MSP信息，并对所有组织和节点进行签名。cryptogen位于fabric/build/bin目录下，它使用了crypto-config.yaml作为配置文件，我们可以使用[cryptogen showtemplate]查看配置文件模板。实际上，示例代码的crypto-config.yaml就是基于这个模板修改的。具体的配置方法参加模板说明。示例配置文件生产力如下所在的拓扑网络：</span></p>
  <p><span style="font-family:SimSun;font-size:12px;"><img src="https://img-blog.csdn.net/2018042410113212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1ZUppbmdaaGlLZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p><span style="font-family:SimSun;font-size:12px;">如果，包含了两种类型的组织：OrdererOrgs和PeerOrgs。一个Orderer组织下面有一个节点；而Peers有两个组织，每个组织通过Template创建了两个Peers。因此，根据该配置文件，cryptogen将会生成5个节点：</span></p>
  <p><span style="font-size:12px;"></span></p>
  <p><span style="font-family:'Courier New';font-size:12px;">-&nbsp;&nbsp;&nbsp;&nbsp;orderer.example.com</span></p>
  <p><span style="font-family:'Courier New';font-size:12px;">-&nbsp;&nbsp;&nbsp;&nbsp;peer0.org1.example.com</span></p>
  <p><span style="font-family:'Courier New';font-size:12px;">-&nbsp;&nbsp;&nbsp;&nbsp;peer1.org1.example.com</span></p>
  <p><span style="font-family:'Courier New';font-size:12px;">-&nbsp;&nbsp;&nbsp;&nbsp;peer0.org2.example.com</span></p>
  <p><span style="font-family:'Courier New';font-size:12px;">-&nbsp;&nbsp;&nbsp;&nbsp;peer1.org2.example.com</span></p>
  <p><span style="font-family:SimSun;font-size:12px;">可以使用下面的命令来创建拓扑网络：</span></p>
  <pre><code class="language-plain">cd /opt/gopath/src/github.com/hyperledger/fabric-samples/first-network
../../fabric/build/bin/cryptogen generate --config=./crypto-config.yaml</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">命令将会在在当前目录下生成crypto-config目录。使用命令[tree crypto-config]命令可以查看目录的整体结构。简单的说，cryptogen完成了以下工作：</span></p>
  <p></p>
  <ul>
   <li><span style="font-family:SimSun;font-size:12px;">为每个组织生成了签名，包括orderer组织和peer组织。</span></li>
   <li><span style="font-family:SimSun;font-size:12px;">为每个组织生成了MSP信息，<span style="font-family:SimSun;font-size:12px;">包括orderer组织和peer组织。</span></span></li>
   <li><span style="font-family:SimSun;font-size:12px;">为组织内的每个成员生成了签名。</span></li>
   <li><span style="font-family:SimSun;font-size:12px;">为每个组织定了用一个管理员和一个用户。</span></li>
  </ul>
  <p><span style="font-family:SimSun;font-size:12px;">至此，网络的拓扑结构生成完毕。MSP模块将使用这些内容对节点进行安全管理和认证。</span></p>
  <h1><span style="font-family:SimSun;font-size:18px;">创建通道配置信息</span></h1>
  <p><span style="font-family:SimSun;font-size:12px;">通道配置信息包括三个方面的内容：创世区块、通道配置信息和各个组织的Anchor Peer。使用configtxgen来完成通道配置信息的创建。可以使用[configtxgen --help]查看工具的使用方法。和cryptogen不同，configtxgen指定使用configtx.yaml。</span></p>
  <ul>
   <li><span style="font-family:SimSun;font-size:12px;">configtx.yaml主要定义了两个</span><span style="font-size:12px;"><span style="font-family:'Courier New';">profile：</span><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span style="font-family:'Courier New';font-size:9pt;">TwoOrgsOrdererGenesis</span><span style="font-family:SimSun;font-size:9pt;">和</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span style="font-family:'Courier New';">TwoOrgsChannel。</span></span></span></span></li>
   <li><span style="font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span lang="en-us" xml:lang="en-us"><span style="font-family:'Courier New';font-size:9pt;">TwoOrgsOrdererGenesis</span><span style="font-size:9pt;"><span style="font-family:SimSun;">主要用于Orderer节点的定义；<span style="font-family:'Courier New';">TwoOrgsChannel</span>主要用于Peer节点的定义。</span></span></span></span></span></span></li>
   <li><span style="font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" xml:lang="en-us"><span style="font-family:SimSun;">每个profile都定义了capability和组织的内部信息；</span></span></span></span></li>
   <li><span style="font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" xml:lang="en-us"><span style="font-family:SimSun;">组织信息都包括Name（节点名字）；ID（用来标识该节点）；MSPDir（指定msp信息地址，有上面cryptogen工具生成）。</span></span></span></span></li>
   <li><span style="font-family:SimSun;font-size:12px;color:#000000;"><span>对于Peer节点，还需要定义Anchor Peer的信息。</span></span></li>
  </ul>
  <p><span style="font-family:SimSun;font-size:12px;">从这个意义来说，超级账本的分布式更像是基于组织的分布式，这和我们通常理解的分布式和去中心化有很大不同。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">创建创世块</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">创世块的创建可以使用下面的命令完成</span></p>
  <pre><code class="language-plain">export FABRIC_CFG_PATH=$PWD
../../fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">它使用了<span style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">TwoOrgsOrdererGenesis</span>的profile，生成了genesis.block区块，因此区块应该是一个和排序服务相关的概念。需要注意的是，这里不能修改区块的名字，在我们创建好通道后区块名字会被修改成为[通道名].block。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">创建通道配置信息</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">通道配置信息可以通过下面的命令创建：</span></p>
  <pre><code class="language-plain">export CHANNEL_NAME=shimzhaochnl
configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">它使用了</span><span style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"><span style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">TwoOrgsChannel</span></span><span style="font-family:SimSun;font-size:12px;">的profile，生成了名外shimzhaochnl的通道。通道配置信息保存在了channel.tx文件中。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">配置Anchor Peer</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">Anchor Peer是一个组织内负责与其他组织打交道的门户节点，通常情况它也是背书节点。一个组织可以有多个节点加入到区块链网络，但是必须有至少一个Anchor Peer。Anchor Peer的配置可以使用下面的命令完成：</span></p>
  <pre><code class="language-plain">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</code></pre>
  <pre><code class="language-plain">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</code></pre>
  <span style="font-family:SimSun;font-size:12px;">由于Anchor Peer定义在<span style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">TwoOrgsChannelprofile</span><span style="color:rgb(0,0,0);font-size:12px;">中，</span>上面分别的命令用到了<span style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">TwoOrgsChannel profile</span><span style="color:rgb(0,0,0);font-size:12px;">。上面分别为Org1MSP和OrgMSP定义了Anchor Peer。</span></span>
  <br>
  <p><br></p>
  <p><span style="font-family:SimSun;font-size:12px;">至此，通道配置信息创建完毕。生成的文件保存在了当前目录的[channel-artifacts]下面。可以使用下面的命令查看创建的区块信息：</span></p>
  <pre><code class="language-plain">../../fabric/build/bin/configtxgen -inspectBlock ./channel-artifacts/genesis.block</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">也可以使用下面的信息查看通道信息：</span></p>
  <pre><code class="language-plain">../../fabric/build/bin/configtxgen -inspectChannelCreateTx ./channel-artifacts/channel.tx</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">除此之外，还可以查看组织信息：</span></p>
  <pre><code class="language-plain">../../fabric/build/bin/configtxgen -printOrg Org1MSP</code></pre>
  <br>
  <h1><span style="font-family:SimSun;font-size:18px;">启动网络，创建通道</span></h1>
  <p><span style="color:rgb(0,0,0);"><span style="font-family:SimSun;font-size:12px;">通道交易信息和创世块准备完毕后就可以启动区块链网络了。</span></span><span style="font-family:SimSun;font-size:12px;color:rgb(0,0,0);">在这里我们使用</span><span lang="en-us" style="font-family:SimSun;color:rgb(0,0,0);" xml:lang="en-us">docker-compose-cli.yaml</span><span style="font-family:SimSun;font-size:12px;color:rgb(0,0,0);">文件启动网络：</span></p>
  <pre><code class="language-plain">vagrant@ubuntu-xenial:first-network$ docker-compose -f docker-compose-cli.yaml up -d
Creating network "net_byfn" with the default driver
Creating peer1.org1.example.com ... 
Creating orderer.example.com ... 
Creating peer0.org2.example.com ... 
Creating peer1.org2.example.com ... 
Creating peer0.org1.example.com ... 
Creating orderer.example.com
Creating peer1.org1.example.com
Creating peer0.org2.example.com
Creating peer1.org2.example.com
Creating peer1.org2.example.com ... done
Creating cli ... 
Creating cli ... done</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">去掉[-d]可以查看更多的log信息，启动完成后可以使用[docker ps -a]查看所有节点是否正确启动。</span></p>
  <p><span style="font-family:SimSun;font-size:12px;">网络启动后我们还需要创建通道、加入通道、更新通道的Anchor Peer配置。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">创建通道</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">创建通道以前我们需要进入到cli节点，cli相当于超级账本的一个application，每次在操作peer的时候它都会去读取下面的环境变量以确定要操作哪一个Peer。cli是通过读取下面的配置文件来确定它连接的是哪个Peer节点。<span style="font-family:SimSun;font-size:12px;">当操作的Peer发送变化的时候都需要重新备注这些环境变量，以确保操作的是正确的Peer节点。</span>这些环境变量包括：</span></p>
  <ul>
   <li><span style="font-family:SimSun;font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us">CORE_PEER_MSPCONFIGPATH：用来指定MSP信息路径，有cryptogen生成</span><br></span></li>
   <li><span style="font-family:SimSun;font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us">CORE_PEER_ADDRESS：用来指定节点的网络地址</span><br></span></span></li>
   <li><span style="font-family:SimSun;font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us">CORE_PEER_TLS_ROOTCERT_FILE：用来指定数字签名文件路径</span><br></span></span></span></li>
   <li><span style="font-family:SimSun;font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us"><span lang="en-us" style="color:rgb(0,0,0);" xml:lang="en-us">CORE_PEER_LOCALMSPID：用来指定组织MSPID</span><br></span></span></span></span></li>
  </ul>
  <p><span style="font-family:SimSun;font-size:12px;">因此，首先我们要指定peer0.org1.example.com节点作为cli的连接节点，然后进入cli docker：</span></p>
  <pre><code class="language-html">vagrant@ubuntu-xenial: first-network$ export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
vagrant@ubuntu-xenial: first-network$ export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
vagrant@ubuntu-xenial: first-network$ export CORE_PEER_LOCALMSPID="Org1MSP"
vagrant@ubuntu-xenial: first-network$ export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

vagrant@ubuntu-xenial: first-network$ docker exec -it cli bash
root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">注意，接下来我们的操作就会在cli docker内部进行了。为了使用方便，先定义一个全局变量:</span></p>
  <pre><code class="language-plain">root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#export CHANNEL_NAME=shimzhaochnl</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">然后，使用下面的命令创建通道：</span></p>
  <pre><code class="language-plain">root@bfe07b081e03:/opt/gopath/src/github.com/hyperledger/fabric/peer#peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">需要说明的是，创建通道本身也是超级账本的一个交易，因此首先交易信息会被发送到Orderder排序节点，Orderer排序服务会将交易信息广播到整个网络的所有节点。上面的命令中指定的channel.tx来自configtxgen创建的通道配置信息；而公钥则是排序节点的公钥。</span></p>
  <p><span style="font-family:SimSun;"><span style="font-size:12px;">通道创建完成后我们还需要将每个Peer节点加入到通道中。</span></span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">加入通道</span></h2>
  <p><span style="font-family:SimSun;"><span style="font-size:12px;">加入通道需要借助cli容器。比如下面的操作允许我们将peer0.org1.example.com加入到通道：</span></span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#下面的代码在容器内执行，将当期Peer加入通道
peer channel join -b shimzhaochnl.block   #注意通道名

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">依次将其余的三个Peer都加入到通道中。<span style="font-family:SimSun;font-size:12px;">可以使用[peer channel list]查看当前Peer加入了哪些通道。</span></span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">更新通道的Anchor Peer配置</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">接下来需要制定每个Org的Anchor Peer。这个过程也是通过cli容器来实现的：</span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#设置当前连接的Peer为组织的Anchor Peer
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">通过上面的命令设置了peer0.org1.example.com为Org1的Anchor Peer。可以使用同样的方法设置peer0.Org2.example.com为Org2的Anchor Peer。</span></p>
  <p><span style="font-family:SimSun;font-size:12px;">在进入容器[docker exec -it cli bash]后，可以使用peer命令查看当前链接节点的各种信息。参看[peer --help]了解更多。</span></p>
  <h1><span style="font-family:SimSun;font-size:18px;">安装并实例化链码</span></h1>
  <p><span style="font-family:SimSun;font-size:12px;">链码(即智能合约)是超级账本的重要组成部分。所有的外部程序(application)对账本的访问都是通过链码实现的。对链码的操作包括安装、实例化、查询和更新。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">安装链码</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">链码的安装也需要进入到cli容易，连接到需要安装的Peer节点，然后执行安装命令。下面的命令用于为peer0.org1.example.com安装链码：</span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#为当前Peer安装链码
peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">链码安装完成后可以使用[peer chaincode list --installed]的命令查看是否已经安装成功。接下来，还需要为其它Peer安装链码，通常我们只需要为Anchor Peer安装链码即可。</span></p>
  <h2><span style="font-family:SimSun;font-size:16px;">实例化链码</span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">链码在安装完成后还需要实例化才能起作用，可以使用下面的方法实例化链码：</span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#实例化链码
peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.peer','Org2MSP.peer')"

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">需要注意的是：</span></p>
  <ul>
   <li><span style="font-family:SimSun;font-size:12px;"><span lang="en-us" style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';" xml:lang="en-us">[-p]</span><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">参数用来指定背书策略。比如<span lang="en-us" xml:lang="en-us">[</span></span><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:rgb(64,64,64);letter-spacing:.25pt;" xml:lang="en-us">-P "</span><span style="color:rgb(0,0,0);font-family:'-webkit-standard';"><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:#FF0000;letter-spacing:.25pt;" xml:lang="en-us">OR</span></span><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:rgb(64,64,64);letter-spacing:.25pt;" xml:lang="en-us">('Org1MSP.peer','Org2MSP.peer')"</span><span lang="en-us" style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';" xml:lang="en-us">]</span><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">只需要一个节点背书即可；</span></span><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">而<span lang="en-us" xml:lang="en-us">[</span></span><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:rgb(64,64,64);letter-spacing:.25pt;" xml:lang="en-us">-P "</span><span style="color:rgb(0,0,0);font-family:'-webkit-standard';"><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:#FF0000;letter-spacing:.25pt;" xml:lang="en-us">AND</span></span><span lang="en-us" style="font-size:7.5pt;font-family:'Courier New';color:rgb(64,64,64);letter-spacing:.25pt;" xml:lang="en-us">('Org1MSP.peer','Org2MSP.peer')"</span><span lang="en-us" style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';" xml:lang="en-us">]</span><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">则需要两个节点都背书才可以。</span></li>
   <li><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';"><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">链码的实例化主要是给超级账本的区块付初值。</span><br></span></li>
   <li><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';"><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';"><span style="color:rgb(0,0,0);font-size:9pt;font-family:'宋体';">链码的实例化只需要在任意一个节点完成即可。不需要所有节点都实例化。</span></span></span></li>
  </ul>
  <h2><span style="font-family:SimSun;font-size:16px;color:#000000;"><span>查询链码</span></span></h2>
  <p><span style="font-family:SimSun;font-size:12px;">链码的查询首先需要制定Peer，然后进入cli，再执行查询语句：</span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#设置通道名
export CHANNEL_NAME=shimzhaochnl

#调用链码查询
peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;"><strong>更新链码</strong></span></p>
  <p><span style="font-family:SimSun;font-size:12px;">同理，链码的更新操作类似如下：</span></p>
  <pre><code class="language-html">#设置环境变量
export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#设置通道名
export CHANNEL_NAME=shimzhaochnl

#调用链码更新账本
peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}'

#退出
exit</code></pre>
  <p><span style="font-family:SimSun;font-size:12px;">逻辑上来说，所有Peer保存的账本应该是一致的。可以通过切换Peer来验证所有账本是不是同步更新了。</span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JueJingZhiKe/article/details/80060090,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JueJingZhiKe/article/details/80060090,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
