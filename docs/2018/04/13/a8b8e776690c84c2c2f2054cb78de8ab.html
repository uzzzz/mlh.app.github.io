<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊智能合约学习笔记（二） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊智能合约学习笔记（二）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在上一篇文章中，我们通过一个实例了解了一个以太坊智能合约的基本结构、语法与一些概念，接下来我们将对其进行补充。 Gas： 当你激活一个智能合约的时候，你在要求整个网络内的每个矿工个体分别执行里面的运算。这会花费他们的时间和精力，Gas是你为这项服务向矿工们支付的机制。报酬是小额的以太币，想要运行智能合约的人的需要支付报酬来使合约工作。让智能合约花费Gas/以太币/钱可以防止人们随意激活合约，解决了垃圾交易以及相关问题，如果运行智能合约免费，此类问题会发生。 ​ 那么为什么不用ether直接支付费用呢，举个例子：现在执行一条语句需要0.0001ether，此后这个语句的调用一直保持0.0001ether，那么当之后ether涨了1000倍以后，执行成本就增加了1000倍，这就很不合理。现在我们就用gas这个概念把函数调用的消耗与ETH本身的价值相互结藕。我们此时再引入Gas price这个概念，付款款项（单位以太币）＝ Gas数量（单位Gas） x Gas price（单位以太币／Gas） 智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。 另外，任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定，而Gas价格由想运行合约的人规定，在他们提交运行合约请求的时候（有点类似于比特币的交易费）。每个矿工会根据Gas的价格的高低来决定他们是否想作为区块的一部分去运行此合约。如果你希望矿工运行你的合约，你最好提供高一点的Gas价格。 在某种程度是这是一场基于合约运行有多愿意付费驱动下的竞价。 如果你已经用remix测试过上一篇文中的合约，那么你就会发现Gas cost分为transaction cost和execution cost，如下图。 那么这两种cost以什么区别呢？ Execution cost包括存储全局变量以及方法调用相关的运行环境的开销。同一个函数，每次调用时的execution cost有可能是不同的。（比如全局变量发生了变化导致） 而transaction cost和编译后的合约代码长度相关，也和execution cost相关。同一个合约，每次执行时transaction cost - execution cost的值应该是不变的。 详情可以参见以太坊黄皮书附录G，以及这个链接：https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so Contract调用时的Gas的支付方是谁？ Gas是由一开始发起transaction的地址进行支付。详细可以参http://ethfans.org/posts/797 solidity类型系统： solidity是一个静态类型系统，也就是每个变量是什么类型的都要声明，这与C/C++类似，而与Python有所不同。 数据类型： bool：false&nbsp;/&nbsp;true 操作符：!&nbsp;,&nbsp;&amp;&amp;&nbsp;,&nbsp;||&nbsp;,&nbsp;==&nbsp;,&nbsp;!= uint / int：无符整型、有符整型 操作符： 比较：&lt;=&nbsp;,&nbsp;&lt;&nbsp;,&nbsp;==&nbsp;,&nbsp;&gt;=&nbsp;,&nbsp;&gt; 位计算：&amp;&nbsp;,&nbsp;|&nbsp;,&nbsp;^&nbsp;,&nbsp;~ 计算：+&nbsp;,&nbsp;-&nbsp;,&nbsp;*&nbsp;,&nbsp;/&nbsp;,&nbsp;%&nbsp;,&nbsp;** 注意：solidity中没有浮点数，只有定点数，但是即使是定点数，在solidity目前版本的编译器中也是不支持的。 address：以太坊账户地址，是solidity中一种原生的比较复杂的类型(类比python中的dictionary、list)其中地址又可以分为两种类型： 普通账户：仅存储ETH的账户。 合约账户：既存储ETH，同时也有可以运行的代码，即智能合约。这些智能合约可以通过一个交易发送ETH的到账户里。一旦智能合约被上传，它就在那里等待被激活。 以太坊的地址是20字节的十六进制的bigNumber，范围在2^256以内，可以通过一下函数监测是否有效。 address x = 0xca35b7d915458ef540ade6068dfe2f4438fa733c; function isValidAddress (address) { &nbsp;&nbsp;&nbsp;&nbsp;return /^0x[0-9a-fA-F]{40}$/.test(address); } isValidAddress(x); address的成员变量与函数： address.balance：地址余额，单位 Wei。balance 的值是&nbsp;read only&nbsp;的，调用&nbsp;payable&nbsp;函数入账，调用&nbsp;address.transfer()&nbsp;等出账，以太坊自动计算新的余额。 address.transfer(uint256 value)&nbsp;：给 address 转账 value(Wei)，且调用异常会抛出。实践中转钱推荐使用transfer。 address.send(value)：和 transfer 类似，但调用后的异常将不会被返回，只会返回一个布尔值。 address.call,&nbsp;address.callcode,&nbsp;address.delegatecall：用于智能合约之间调用彼此的函数。 全局变量： ETHER单位：1 wei就等于integer中的1，其余类似快捷方式，当我们不想写1后面有18个0的时候写成1 ether就可以了。所以1 ether仍然代表一个数字而不代表钱。 wei&nbsp;== 1 szabo&nbsp;== 10^12&nbsp;wei finney&nbsp;== 10^15&nbsp;wei ether&nbsp;== 10^18&nbsp;wei 时间单位：1 seconds 代表数字 1，而不是时间的单位。与上面的ETHER类似，为了起到方便的作用。 1&nbsp;seconds&nbsp;== 1 1&nbsp;minutes&nbsp;== 60&nbsp;seconds 1&nbsp;hours&nbsp;== 60&nbsp;minutes 1&nbsp;days&nbsp;== 24&nbsp;hours 1&nbsp;weeks&nbsp;== 7&nbsp;days 1&nbsp;years&nbsp;== 365&nbsp;days block：块，类比一下的话，block比较类似于singleton，它在整个程序中是唯一的，所有人都可以access。还可以类比为静态变量，它有自己的函数、方法、成员变量。 block.blockhash(uint blockNumber) returns (bytes32): 传入 blockNumber，返回块的哈希值。 block.coinbase&nbsp;(address): 挖到当前块矿工的地址 block.difficulty&nbsp;(uint): 当前块的难度 block.gaslimit&nbsp;(uint): 目前block总的最多的gas是多少 block.number&nbsp;(uint): 当前块是第几个 block.timestamp&nbsp;(uint): 当前块创建的时间戳，传进来的unit是unix timestamp的基准(从1970-01-01开始) now&nbsp;(uint): block.timestamp 的快捷方式 msg: 多用于当执行某一个函数的时候，这个函数的内部想要知道调用函数的数据信息。 msg.data&nbsp;(bytes): 包括函数名字等一些raw的信息，一些没有经过parse的信息 msg.gas&nbsp;(uint): 函数调用方携带的 gas到这个函数调用的call里面 msg.sender&nbsp;(address): 函数调用方的地址 msg.sig&nbsp;(bytes4): 整个&nbsp;msg.data&nbsp;的前 4 个&nbsp;byte msg.value&nbsp;(uint): 函数调用方携带的&nbsp;gas，以&nbsp;wei&nbsp;为单位计价。 补充： constant关键字： 在目前的版本中，constant可以修饰变量和函数，但是在修饰函数时，是完全没有效果的，只能起到视觉上的警示，编译器并不会对函数是否改变成员变量做任何检查。尤其是在合作编程时，一定要注意这一点。可用以下例子测试： pragma solidity ^0.4.0 contract simpleStorage(){ &nbsp;&nbsp;&nbsp;&nbsp;uint storedData; &nbsp;&nbsp;&nbsp;&nbsp;function set(uint x) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storedData = x; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;function get() constant returns (uint) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedData = 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return storedData; &nbsp;&nbsp;&nbsp;&nbsp;} } 被动调用的编程模式： 具体来说就是，在ethereum中调用一个函数，这个函数一定是执行完成的，而不会等待一段时间之后自发再去进行一系列操作，一定是每一个函数都在一个区块中就完成了。因此原生定时器在ethereum是无法实现的，想要实现只能通过一些外部的服务。 因此在上一篇文章中，我们无法用原生定时器实现工资的个按时发放，要实现给员工发工资的功能就要把一个智能合约作为一个中介，这就是在区块链上一个很常见的设计范式。 调用节省gas的小技巧： 在调用自己合约中的函数时，可以用reference调用，形如this.func()，但是最后把this去掉。因为this这种调用，在evm底层中是通过message实现的，这种情况下代价比较高，需要支付高昂的gas费用。用非this调用的话，是evm上的一个jump操作，这种方式的gas就会低很多。 尽量避免重复的语句，因为ethereum编译器比较低级，并不会把相同的语句只编译一次放到栈上，而它的每一个语句都是花费真金白银的，所以一定要注意节省gas。 变量的作用域： 与Javascript很像，和C++，JAVA不同。只要在函数中定义了局部变量，作用域为整个函数。比如，在if内定义一个变量，在if内肯定有效，但在if外面也有效。 调试小技巧： 变量可以设置为public，这样在部署以后会有一个同名变量的按钮可以调用查看变量属性。 例如我将上一篇文章的代码中的owner加上public修饰： 另外remix下半部的debug按钮或者右边栏的debugger选项都可以帮助我们进行debug。 参考资料： 第一课问题整理 阅读更多" />
<meta property="og:description" content="在上一篇文章中，我们通过一个实例了解了一个以太坊智能合约的基本结构、语法与一些概念，接下来我们将对其进行补充。 Gas： 当你激活一个智能合约的时候，你在要求整个网络内的每个矿工个体分别执行里面的运算。这会花费他们的时间和精力，Gas是你为这项服务向矿工们支付的机制。报酬是小额的以太币，想要运行智能合约的人的需要支付报酬来使合约工作。让智能合约花费Gas/以太币/钱可以防止人们随意激活合约，解决了垃圾交易以及相关问题，如果运行智能合约免费，此类问题会发生。 ​ 那么为什么不用ether直接支付费用呢，举个例子：现在执行一条语句需要0.0001ether，此后这个语句的调用一直保持0.0001ether，那么当之后ether涨了1000倍以后，执行成本就增加了1000倍，这就很不合理。现在我们就用gas这个概念把函数调用的消耗与ETH本身的价值相互结藕。我们此时再引入Gas price这个概念，付款款项（单位以太币）＝ Gas数量（单位Gas） x Gas price（单位以太币／Gas） 智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。 另外，任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定，而Gas价格由想运行合约的人规定，在他们提交运行合约请求的时候（有点类似于比特币的交易费）。每个矿工会根据Gas的价格的高低来决定他们是否想作为区块的一部分去运行此合约。如果你希望矿工运行你的合约，你最好提供高一点的Gas价格。 在某种程度是这是一场基于合约运行有多愿意付费驱动下的竞价。 如果你已经用remix测试过上一篇文中的合约，那么你就会发现Gas cost分为transaction cost和execution cost，如下图。 那么这两种cost以什么区别呢？ Execution cost包括存储全局变量以及方法调用相关的运行环境的开销。同一个函数，每次调用时的execution cost有可能是不同的。（比如全局变量发生了变化导致） 而transaction cost和编译后的合约代码长度相关，也和execution cost相关。同一个合约，每次执行时transaction cost - execution cost的值应该是不变的。 详情可以参见以太坊黄皮书附录G，以及这个链接：https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so Contract调用时的Gas的支付方是谁？ Gas是由一开始发起transaction的地址进行支付。详细可以参http://ethfans.org/posts/797 solidity类型系统： solidity是一个静态类型系统，也就是每个变量是什么类型的都要声明，这与C/C++类似，而与Python有所不同。 数据类型： bool：false&nbsp;/&nbsp;true 操作符：!&nbsp;,&nbsp;&amp;&amp;&nbsp;,&nbsp;||&nbsp;,&nbsp;==&nbsp;,&nbsp;!= uint / int：无符整型、有符整型 操作符： 比较：&lt;=&nbsp;,&nbsp;&lt;&nbsp;,&nbsp;==&nbsp;,&nbsp;&gt;=&nbsp;,&nbsp;&gt; 位计算：&amp;&nbsp;,&nbsp;|&nbsp;,&nbsp;^&nbsp;,&nbsp;~ 计算：+&nbsp;,&nbsp;-&nbsp;,&nbsp;*&nbsp;,&nbsp;/&nbsp;,&nbsp;%&nbsp;,&nbsp;** 注意：solidity中没有浮点数，只有定点数，但是即使是定点数，在solidity目前版本的编译器中也是不支持的。 address：以太坊账户地址，是solidity中一种原生的比较复杂的类型(类比python中的dictionary、list)其中地址又可以分为两种类型： 普通账户：仅存储ETH的账户。 合约账户：既存储ETH，同时也有可以运行的代码，即智能合约。这些智能合约可以通过一个交易发送ETH的到账户里。一旦智能合约被上传，它就在那里等待被激活。 以太坊的地址是20字节的十六进制的bigNumber，范围在2^256以内，可以通过一下函数监测是否有效。 address x = 0xca35b7d915458ef540ade6068dfe2f4438fa733c; function isValidAddress (address) { &nbsp;&nbsp;&nbsp;&nbsp;return /^0x[0-9a-fA-F]{40}$/.test(address); } isValidAddress(x); address的成员变量与函数： address.balance：地址余额，单位 Wei。balance 的值是&nbsp;read only&nbsp;的，调用&nbsp;payable&nbsp;函数入账，调用&nbsp;address.transfer()&nbsp;等出账，以太坊自动计算新的余额。 address.transfer(uint256 value)&nbsp;：给 address 转账 value(Wei)，且调用异常会抛出。实践中转钱推荐使用transfer。 address.send(value)：和 transfer 类似，但调用后的异常将不会被返回，只会返回一个布尔值。 address.call,&nbsp;address.callcode,&nbsp;address.delegatecall：用于智能合约之间调用彼此的函数。 全局变量： ETHER单位：1 wei就等于integer中的1，其余类似快捷方式，当我们不想写1后面有18个0的时候写成1 ether就可以了。所以1 ether仍然代表一个数字而不代表钱。 wei&nbsp;== 1 szabo&nbsp;== 10^12&nbsp;wei finney&nbsp;== 10^15&nbsp;wei ether&nbsp;== 10^18&nbsp;wei 时间单位：1 seconds 代表数字 1，而不是时间的单位。与上面的ETHER类似，为了起到方便的作用。 1&nbsp;seconds&nbsp;== 1 1&nbsp;minutes&nbsp;== 60&nbsp;seconds 1&nbsp;hours&nbsp;== 60&nbsp;minutes 1&nbsp;days&nbsp;== 24&nbsp;hours 1&nbsp;weeks&nbsp;== 7&nbsp;days 1&nbsp;years&nbsp;== 365&nbsp;days block：块，类比一下的话，block比较类似于singleton，它在整个程序中是唯一的，所有人都可以access。还可以类比为静态变量，它有自己的函数、方法、成员变量。 block.blockhash(uint blockNumber) returns (bytes32): 传入 blockNumber，返回块的哈希值。 block.coinbase&nbsp;(address): 挖到当前块矿工的地址 block.difficulty&nbsp;(uint): 当前块的难度 block.gaslimit&nbsp;(uint): 目前block总的最多的gas是多少 block.number&nbsp;(uint): 当前块是第几个 block.timestamp&nbsp;(uint): 当前块创建的时间戳，传进来的unit是unix timestamp的基准(从1970-01-01开始) now&nbsp;(uint): block.timestamp 的快捷方式 msg: 多用于当执行某一个函数的时候，这个函数的内部想要知道调用函数的数据信息。 msg.data&nbsp;(bytes): 包括函数名字等一些raw的信息，一些没有经过parse的信息 msg.gas&nbsp;(uint): 函数调用方携带的 gas到这个函数调用的call里面 msg.sender&nbsp;(address): 函数调用方的地址 msg.sig&nbsp;(bytes4): 整个&nbsp;msg.data&nbsp;的前 4 个&nbsp;byte msg.value&nbsp;(uint): 函数调用方携带的&nbsp;gas，以&nbsp;wei&nbsp;为单位计价。 补充： constant关键字： 在目前的版本中，constant可以修饰变量和函数，但是在修饰函数时，是完全没有效果的，只能起到视觉上的警示，编译器并不会对函数是否改变成员变量做任何检查。尤其是在合作编程时，一定要注意这一点。可用以下例子测试： pragma solidity ^0.4.0 contract simpleStorage(){ &nbsp;&nbsp;&nbsp;&nbsp;uint storedData; &nbsp;&nbsp;&nbsp;&nbsp;function set(uint x) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storedData = x; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;function get() constant returns (uint) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedData = 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return storedData; &nbsp;&nbsp;&nbsp;&nbsp;} } 被动调用的编程模式： 具体来说就是，在ethereum中调用一个函数，这个函数一定是执行完成的，而不会等待一段时间之后自发再去进行一系列操作，一定是每一个函数都在一个区块中就完成了。因此原生定时器在ethereum是无法实现的，想要实现只能通过一些外部的服务。 因此在上一篇文章中，我们无法用原生定时器实现工资的个按时发放，要实现给员工发工资的功能就要把一个智能合约作为一个中介，这就是在区块链上一个很常见的设计范式。 调用节省gas的小技巧： 在调用自己合约中的函数时，可以用reference调用，形如this.func()，但是最后把this去掉。因为this这种调用，在evm底层中是通过message实现的，这种情况下代价比较高，需要支付高昂的gas费用。用非this调用的话，是evm上的一个jump操作，这种方式的gas就会低很多。 尽量避免重复的语句，因为ethereum编译器比较低级，并不会把相同的语句只编译一次放到栈上，而它的每一个语句都是花费真金白银的，所以一定要注意节省gas。 变量的作用域： 与Javascript很像，和C++，JAVA不同。只要在函数中定义了局部变量，作用域为整个函数。比如，在if内定义一个变量，在if内肯定有效，但在if外面也有效。 调试小技巧： 变量可以设置为public，这样在部署以后会有一个同名变量的按钮可以调用查看变量属性。 例如我将上一篇文章的代码中的owner加上public修饰： 另外remix下半部的debug按钮或者右边栏的debugger选项都可以帮助我们进行debug。 参考资料： 第一课问题整理 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/04/13/a8b8e776690c84c2c2f2054cb78de8ab.html" />
<meta property="og:url" content="https://mlh.app/2018/04/13/a8b8e776690c84c2c2f2054cb78de8ab.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在上一篇文章中，我们通过一个实例了解了一个以太坊智能合约的基本结构、语法与一些概念，接下来我们将对其进行补充。 Gas： 当你激活一个智能合约的时候，你在要求整个网络内的每个矿工个体分别执行里面的运算。这会花费他们的时间和精力，Gas是你为这项服务向矿工们支付的机制。报酬是小额的以太币，想要运行智能合约的人的需要支付报酬来使合约工作。让智能合约花费Gas/以太币/钱可以防止人们随意激活合约，解决了垃圾交易以及相关问题，如果运行智能合约免费，此类问题会发生。 ​ 那么为什么不用ether直接支付费用呢，举个例子：现在执行一条语句需要0.0001ether，此后这个语句的调用一直保持0.0001ether，那么当之后ether涨了1000倍以后，执行成本就增加了1000倍，这就很不合理。现在我们就用gas这个概念把函数调用的消耗与ETH本身的价值相互结藕。我们此时再引入Gas price这个概念，付款款项（单位以太币）＝ Gas数量（单位Gas） x Gas price（单位以太币／Gas） 智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。 另外，任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定，而Gas价格由想运行合约的人规定，在他们提交运行合约请求的时候（有点类似于比特币的交易费）。每个矿工会根据Gas的价格的高低来决定他们是否想作为区块的一部分去运行此合约。如果你希望矿工运行你的合约，你最好提供高一点的Gas价格。 在某种程度是这是一场基于合约运行有多愿意付费驱动下的竞价。 如果你已经用remix测试过上一篇文中的合约，那么你就会发现Gas cost分为transaction cost和execution cost，如下图。 那么这两种cost以什么区别呢？ Execution cost包括存储全局变量以及方法调用相关的运行环境的开销。同一个函数，每次调用时的execution cost有可能是不同的。（比如全局变量发生了变化导致） 而transaction cost和编译后的合约代码长度相关，也和execution cost相关。同一个合约，每次执行时transaction cost - execution cost的值应该是不变的。 详情可以参见以太坊黄皮书附录G，以及这个链接：https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so Contract调用时的Gas的支付方是谁？ Gas是由一开始发起transaction的地址进行支付。详细可以参http://ethfans.org/posts/797 solidity类型系统： solidity是一个静态类型系统，也就是每个变量是什么类型的都要声明，这与C/C++类似，而与Python有所不同。 数据类型： bool：false&nbsp;/&nbsp;true 操作符：!&nbsp;,&nbsp;&amp;&amp;&nbsp;,&nbsp;||&nbsp;,&nbsp;==&nbsp;,&nbsp;!= uint / int：无符整型、有符整型 操作符： 比较：&lt;=&nbsp;,&nbsp;&lt;&nbsp;,&nbsp;==&nbsp;,&nbsp;&gt;=&nbsp;,&nbsp;&gt; 位计算：&amp;&nbsp;,&nbsp;|&nbsp;,&nbsp;^&nbsp;,&nbsp;~ 计算：+&nbsp;,&nbsp;-&nbsp;,&nbsp;*&nbsp;,&nbsp;/&nbsp;,&nbsp;%&nbsp;,&nbsp;** 注意：solidity中没有浮点数，只有定点数，但是即使是定点数，在solidity目前版本的编译器中也是不支持的。 address：以太坊账户地址，是solidity中一种原生的比较复杂的类型(类比python中的dictionary、list)其中地址又可以分为两种类型： 普通账户：仅存储ETH的账户。 合约账户：既存储ETH，同时也有可以运行的代码，即智能合约。这些智能合约可以通过一个交易发送ETH的到账户里。一旦智能合约被上传，它就在那里等待被激活。 以太坊的地址是20字节的十六进制的bigNumber，范围在2^256以内，可以通过一下函数监测是否有效。 address x = 0xca35b7d915458ef540ade6068dfe2f4438fa733c; function isValidAddress (address) { &nbsp;&nbsp;&nbsp;&nbsp;return /^0x[0-9a-fA-F]{40}$/.test(address); } isValidAddress(x); address的成员变量与函数： address.balance：地址余额，单位 Wei。balance 的值是&nbsp;read only&nbsp;的，调用&nbsp;payable&nbsp;函数入账，调用&nbsp;address.transfer()&nbsp;等出账，以太坊自动计算新的余额。 address.transfer(uint256 value)&nbsp;：给 address 转账 value(Wei)，且调用异常会抛出。实践中转钱推荐使用transfer。 address.send(value)：和 transfer 类似，但调用后的异常将不会被返回，只会返回一个布尔值。 address.call,&nbsp;address.callcode,&nbsp;address.delegatecall：用于智能合约之间调用彼此的函数。 全局变量： ETHER单位：1 wei就等于integer中的1，其余类似快捷方式，当我们不想写1后面有18个0的时候写成1 ether就可以了。所以1 ether仍然代表一个数字而不代表钱。 wei&nbsp;== 1 szabo&nbsp;== 10^12&nbsp;wei finney&nbsp;== 10^15&nbsp;wei ether&nbsp;== 10^18&nbsp;wei 时间单位：1 seconds 代表数字 1，而不是时间的单位。与上面的ETHER类似，为了起到方便的作用。 1&nbsp;seconds&nbsp;== 1 1&nbsp;minutes&nbsp;== 60&nbsp;seconds 1&nbsp;hours&nbsp;== 60&nbsp;minutes 1&nbsp;days&nbsp;== 24&nbsp;hours 1&nbsp;weeks&nbsp;== 7&nbsp;days 1&nbsp;years&nbsp;== 365&nbsp;days block：块，类比一下的话，block比较类似于singleton，它在整个程序中是唯一的，所有人都可以access。还可以类比为静态变量，它有自己的函数、方法、成员变量。 block.blockhash(uint blockNumber) returns (bytes32): 传入 blockNumber，返回块的哈希值。 block.coinbase&nbsp;(address): 挖到当前块矿工的地址 block.difficulty&nbsp;(uint): 当前块的难度 block.gaslimit&nbsp;(uint): 目前block总的最多的gas是多少 block.number&nbsp;(uint): 当前块是第几个 block.timestamp&nbsp;(uint): 当前块创建的时间戳，传进来的unit是unix timestamp的基准(从1970-01-01开始) now&nbsp;(uint): block.timestamp 的快捷方式 msg: 多用于当执行某一个函数的时候，这个函数的内部想要知道调用函数的数据信息。 msg.data&nbsp;(bytes): 包括函数名字等一些raw的信息，一些没有经过parse的信息 msg.gas&nbsp;(uint): 函数调用方携带的 gas到这个函数调用的call里面 msg.sender&nbsp;(address): 函数调用方的地址 msg.sig&nbsp;(bytes4): 整个&nbsp;msg.data&nbsp;的前 4 个&nbsp;byte msg.value&nbsp;(uint): 函数调用方携带的&nbsp;gas，以&nbsp;wei&nbsp;为单位计价。 补充： constant关键字： 在目前的版本中，constant可以修饰变量和函数，但是在修饰函数时，是完全没有效果的，只能起到视觉上的警示，编译器并不会对函数是否改变成员变量做任何检查。尤其是在合作编程时，一定要注意这一点。可用以下例子测试： pragma solidity ^0.4.0 contract simpleStorage(){ &nbsp;&nbsp;&nbsp;&nbsp;uint storedData; &nbsp;&nbsp;&nbsp;&nbsp;function set(uint x) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storedData = x; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;function get() constant returns (uint) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedData = 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return storedData; &nbsp;&nbsp;&nbsp;&nbsp;} } 被动调用的编程模式： 具体来说就是，在ethereum中调用一个函数，这个函数一定是执行完成的，而不会等待一段时间之后自发再去进行一系列操作，一定是每一个函数都在一个区块中就完成了。因此原生定时器在ethereum是无法实现的，想要实现只能通过一些外部的服务。 因此在上一篇文章中，我们无法用原生定时器实现工资的个按时发放，要实现给员工发工资的功能就要把一个智能合约作为一个中介，这就是在区块链上一个很常见的设计范式。 调用节省gas的小技巧： 在调用自己合约中的函数时，可以用reference调用，形如this.func()，但是最后把this去掉。因为this这种调用，在evm底层中是通过message实现的，这种情况下代价比较高，需要支付高昂的gas费用。用非this调用的话，是evm上的一个jump操作，这种方式的gas就会低很多。 尽量避免重复的语句，因为ethereum编译器比较低级，并不会把相同的语句只编译一次放到栈上，而它的每一个语句都是花费真金白银的，所以一定要注意节省gas。 变量的作用域： 与Javascript很像，和C++，JAVA不同。只要在函数中定义了局部变量，作用域为整个函数。比如，在if内定义一个变量，在if内肯定有效，但在if外面也有效。 调试小技巧： 变量可以设置为public，这样在部署以后会有一个同名变量的按钮可以调用查看变量属性。 例如我将上一篇文章的代码中的owner加上public修饰： 另外remix下半部的debug按钮或者右边栏的debugger选项都可以帮助我们进行debug。 参考资料： 第一课问题整理 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/04/13/a8b8e776690c84c2c2f2054cb78de8ab.html","headline":"以太坊智能合约学习笔记（二）","dateModified":"2018-04-13T00:00:00+08:00","datePublished":"2018-04-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/04/13/a8b8e776690c84c2c2f2054cb78de8ab.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊智能合约学习笔记（二）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>在上一篇文章中，我们通过一个实例了解了一个以太坊智能合约的基本结构、语法与一些概念，接下来我们将对其进行补充。</p> 
  <p><br></p> 
  <p><strong>Gas</strong>：</p> 
  <p>当你激活一个智能合约的时候，你在要求整个网络内的每个矿工个体分别执行里面的运算。这会花费他们的时间和精力，Gas是你为这项服务向矿工们支付的机制。报酬是小额的以太币，想要运行智能合约的人的需要支付报酬来使合约工作。让智能合约花费Gas/以太币/钱可以防止人们随意激活合约，解决了垃圾交易以及相关问题，如果运行智能合约免费，此类问题会发生。 ​<br></p> 
  <p>那么为什么不用ether直接支付费用呢，举个例子：现在执行一条语句需要0.0001ether，此后这个语句的调用一直保持0.0001ether，那么当之后ether涨了1000倍以后，执行成本就增加了1000倍，这就很不合理。现在我们就用gas这个概念把函数调用的消耗与ETH本身的价值相互结藕。我们此时再引入Gas price这个概念，付款款项（单位以太币）＝ Gas数量（单位Gas） x Gas price（单位以太币／Gas） 智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。</p> 
  <p>另外，任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定，而Gas价格由想运行合约的人规定，在他们提交运行合约请求的时候（有点类似于比特币的交易费）。每个矿工会根据Gas的价格的高低来决定他们是否想作为区块的一部分去运行此合约。如果你希望矿工运行你的合约，你最好提供高一点的Gas价格。</p> 
  <p>在某种程度是这是一场基于合约运行有多愿意付费驱动下的竞价。</p> 
  <p><br></p> 
  <p>如果你已经用remix测试过上一篇文中的合约，那么你就会发现Gas cost分为transaction cost和execution cost，如下图。</p> 
  <p><img src="https://img-blog.csdn.net/20180410212327724?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NobG92ZXJK/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p> 
  <p><br></p> 
  <p style="color:rgb(36,41,46);font-family:'-apple-system', 'system-ui', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;"> 那么这两种cost以什么区别呢？</p> 
  <p style="color:rgb(36,41,46);font-family:'-apple-system', 'system-ui', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;"> Execution cost包括存储全局变量以及方法调用相关的运行环境的开销。同一个函数，每次调用时的execution cost有可能是不同的。（比如全局变量发生了变化导致）</p> 
  <p></p> 
  <p style="color:rgb(36,41,46);font-family:'-apple-system', 'system-ui', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;"> 而transaction cost和编译后的合约代码长度相关，也和execution cost相关。同一个合约，每次执行时transaction cost - execution cost的值应该是不变的。</p> 
  <p>详情可以参见以太坊黄皮书附录G，以及这个链接：<a href="https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so%EF%BC%88%E6%B3%A8%E6%84%8F%E8%B4%B4%E5%AD%90%E8%A6%81%E7%9C%8B%E5%88%B0%E5%BA%95%E5%93%A6%EF%BC%81%EF%BC%89" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(3,102,214);text-decoration:none;font-family:'-apple-system', 'system-ui', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;">https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so</a></p> 
  <p><img src="https://img-blog.csdn.net/20180413070133249?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NobG92ZXJK/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><br></p> 
  <p><br></p> 
  <p><strong>Contract调用时的Gas的支付方是谁？</strong></p> 
  <p>Gas是由一开始发起transaction的地址进行支付。详细可以参<a href="https://ethereum.stackexchange.com/questions/5812/what-is-the-difference-between-transaction-cost-and-execution-cost-in-browser-so%EF%BC%88%E6%B3%A8%E6%84%8F%E8%B4%B4%E5%AD%90%E8%A6%81%E7%9C%8B%E5%88%B0%E5%BA%95%E5%93%A6%EF%BC%81%EF%BC%89" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(3,102,214);text-decoration:none;font-family:'-apple-system', 'system-ui', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;">http://ethfans.org/posts/797</a><br></p> 
  <p><br></p> 
  <p><strong>solidity类型系统：</strong></p> 
  <p>solidity是一个静态类型系统，也就是每个变量是什么类型的都要声明，这与C/C++类似，而与Python有所不同。</p> 
  <p><br></p> 
  <p><strong>数据类型：</strong></p> 
  <p></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong style="font-weight:bold;">bool</strong>：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">false</code><span>&nbsp;</span>/<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">true</code></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> 操作符：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">!</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&amp;&amp;</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">||</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">==</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">!=</code></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong style="font-weight:bold;">uint / int</strong>：无符整型、有符整型</p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> 操作符：</p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li>比较：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&lt;=</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&lt;</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">==</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&gt;=</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&gt;</code></li>
   <li>位计算：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">&amp;</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">|</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">^</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">~</code></li>
   <li>计算：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">+</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">-</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">*</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">/</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">%</code><span>&nbsp;</span>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">**</code></li>
  </ul>
  <p>注意：solidity中没有浮点数，只有定点数，但是即使是定点数，在solidity目前版本的编译器中也是不支持的。</p> 
  <p><br></p> 
  <p><strong>address</strong>：以太坊账户地址，是solidity中一种原生的比较复杂的类型(类比python中的dictionary、list)其中地址又可以分为两种类型：</p> 
  <p>普通账户：仅存储ETH的账户。</p> 
  <p>合约账户：既存储ETH，同时也有可以运行的代码，即智能合约。这些智能合约可以通过一个交易发送ETH的到账户里。一旦智能合约被上传，它就在那里等待被激活。<br></p> 
  <p>以太坊的地址是20字节的十六进制的bigNumber，范围在2^256以内，可以通过一下函数监测是否有效。<br></p> 
  <p></p> 
  <pre><code class="language-plain">address x = 0xca35b7d915458ef540ade6068dfe2f4438fa733c;
function isValidAddress (address) {
&nbsp;&nbsp;&nbsp;&nbsp;return /^0x[0-9a-fA-F]{40}$/.test(address);
}

isValidAddress(x);
</code></pre> 
  <p>address的成员变量与函数：</p> 
  <p></p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.balance</code><span></span>：地址余额，单位 Wei。balance 的值是<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">read only</code><span>&nbsp;</span>的，调用<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">payable</code><span>&nbsp;</span>函数入账，调用<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.transfer()</code><span>&nbsp;</span>等出账，以太坊自动计算新的余额。</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.transfer(uint256 value)</code><span>&nbsp;</span>：给 address 转账 value(Wei)，且调用异常会抛出。实践中转钱推荐使用<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">transfer</code>。</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.send(value)</code>：和 transfer 类似，但调用后的异常将不会被返回，只会返回一个布尔值。</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.call</code>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.callcode</code>,<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address.delegatecall</code>：用于智能合约之间调用彼此的函数。</li>
  </ul>
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
  <p><strong>全局变量：</strong></p> 
  <p></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong>ETHER单位</strong>：<code></code><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">1 wei</code><span></span>就等于integer中的1，其余类似快捷方式，当我们不想写1后面有18个0的时候写成<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">1 ether</code>就可以了。所以<code></code><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">1 ether</code>仍然代表一个数字而不代表钱。<code></code><span></span><br></p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">wei</code><span>&nbsp;</span>== 1</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">szabo</code><span>&nbsp;</span>== 10^12<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">wei</code></li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">finney</code><span>&nbsp;</span>== 10^15<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">wei</code></li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">ether</code><span>&nbsp;</span>== 10^18<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">wei</code></li>
  </ul>
  <p><br></p> 
  <p></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong style="font-weight:bold;">时间单位</strong>：1 seconds 代表数字 1，而不是时间的单位。与上面的ETHER类似，为了起到方便的作用。</p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">seconds</code><span>&nbsp;</span>== 1</li>
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">minutes</code><span>&nbsp;</span>== 60<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">seconds</code></li>
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">hours</code><span>&nbsp;</span>== 60<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">minutes</code></li>
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">days</code><span>&nbsp;</span>== 24<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">hours</code></li>
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">weeks</code><span>&nbsp;</span>== 7<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">days</code></li>
   <li>1<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">years</code><span>&nbsp;</span>== 365<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">days</code></li>
   <li><br></li>
  </ul>
  <p></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong style="font-weight:bold;">block</strong>：块，类比一下的话，block比较类似于singleton，它在整个程序中是唯一的，所有人都可以access。还可以类比为静态变量，它有自己的函数、方法、成员变量。</p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.blockhash(uint blockNumber) returns (bytes32)</code>: 传入 blockNumber，返回块的哈希值。</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.coinbase</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address</code>): 挖到当前块矿工的地址</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.difficulty</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 当前块的难度</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.gaslimit</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 目前block总的最多的gas是多少<br></li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.number</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 当前块是第几个</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">block.timestamp</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 当前块创建的时间戳，传进来的unit是unix timestamp的基准(从1970-01-01开始)<br></li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">now</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): block.timestamp 的快捷方式</li>
  </ul>
  <p><br></p> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);"> <strong style="font-weight:bold;">msg</strong>: 多用于当执行某一个函数的时候，这个函数的内部想要知道调用函数的数据信息。</p> 
  <ul style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;background-color:rgb(255,255,255);">
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.data</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">bytes</code>): 包括函数名字等一些raw的信息，一些没有经过parse的信息</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.gas</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 函数调用方携带的 gas到这个函数调用的call里面</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.sender</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">address</code>): 函数调用方的地址</li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.sig</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">bytes4</code>): 整个<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.data</code><span>&nbsp;</span>的前 4 个<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">byte</code></li>
   <li><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">msg.value</code><span>&nbsp;</span>(<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">uint</code>): 函数调用方携带的<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">gas</code>，以<span>&nbsp;</span><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">wei</code><span>&nbsp;</span>为单位计价。</li>
  </ul>
  <p><br></p> 
  <p><br></p> 
  <p><strong>补充：</strong></p> 
  <p><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">constant</code><strong><span></span>关键字：</strong></p> 
  <p></p> 
  <p>在目前的版本中，<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">constant</code>可以修饰变量和函数，<span style="color:#FF0000;">但是在修饰函数时，是完全没有效果的</span>，只能起到视觉上的警示，编译器并不会对函数是否改变成员变量做任何检查。尤其是在合作编程时，一定要注意这一点。可用以下例子测试：</p> 
  <pre><code class="language-plain">pragma solidity ^0.4.0
contract simpleStorage(){
&nbsp;&nbsp;&nbsp;&nbsp;uint storedData;

&nbsp;&nbsp;&nbsp;&nbsp;function set(uint x) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storedData = x;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;function get() constant returns (uint) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedData = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return storedData;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre> 
  <br>
  <p><strong>被动调用的编程模式：</strong></p> 
  <p>具体来说就是，在ethereum中调用一个函数，这个函数一定是执行完成的，而不会等待一段时间之后自发再去进行一系列操作，一定是每一个函数都在一个区块中就完成了。因此原生定时器在ethereum是无法实现的，想要实现只能通过一些外部的服务。</p> 
  <p>因此在上一篇文章中，我们无法用原生定时器实现工资的个按时发放，要实现给员工发工资的功能就要把一个智能合约作为一个中介，这就是在区块链上一个很常见的设计范式。</p> 
  <p><br></p> 
  <p><strong>调用节省gas的小技巧</strong>：<br></p> 
  <ol>
   <li>在调用自己合约中的函数时，可以用reference调用，形如<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">this.func()</code>，但是最后把this去掉。因为<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;color:rgb(199,37,78);background-color:rgb(249,242,244);">this</code>这种调用，在evm底层中是通过message实现的，这种情况下代价比较高，需要支付高昂的gas费用。用非this调用的话，是evm上的一个jump操作，这种方式的gas就会低很多。</li>
   <li>尽量避免重复的语句，因为ethereum编译器比较低级，并不会把相同的语句只编译一次放到栈上，而它的每一个语句都是花费真金白银的，所以一定要注意节省gas。<br></li>
  </ol>
  <p><br></p> 
  <p><strong>变量的作用域：</strong></p> 
  <p>与Javascript很像，和C++，JAVA不同。只要在函数中定义了局部变量，作用域为整个函数。比如，在if内定义一个变量，在if内肯定有效，但在if外面也有效。</p> 
  <p><br></p> 
  <p><strong>调试小技巧：</strong></p> 
  <p>变量可以设置为public，这样在部署以后会有一个同名变量的按钮可以调用查看变量属性。</p> 
  <p>例如我将上一篇文章的代码中的owner加上public修饰：</p> 
  <p><img src="https://img-blog.csdn.net/20180413074301373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NobG92ZXJK/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p> 
  <p><br></p> 
  <p>另外remix下半部的debug按钮或者右边栏的debugger选项都可以帮助我们进行debug。</p> 
  <p><br></p> 
  <p>参考资料：</p> 
  <p><a href="https://github.com/Guigulive/Wiki/blob/master/FAQ/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91FAQ-1.md" rel="nofollow">第一课问题整理</a><br></p> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ChloverJ/article/details/79887599,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ChloverJ/article/details/79887599,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
