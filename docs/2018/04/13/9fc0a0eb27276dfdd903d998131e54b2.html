<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hyperledger系列（十三）开发Chaincode | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Hyperledger系列（十三）开发Chaincode" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chaincode简介 chaincode通常处理由网络成员赞同的业务逻辑，因此它类似于“智能合约”。 可以调用chaincode来更新或查询提案交易中的ledger。 如果有适当的许可，chaincode可以调用另一个chaincode，以访问其状态，无论是在同一个Channel还是在不同的Channel中。 请注意，如果被调用的chaincode与调用chaincode位于不同的通道上，则只允许读取查询。 Chaincode API 每个chaincode程序必须实现Chaincode interface,其方法被调用以回应收到的交易。 特别是当Chaincode接收实例化或升级transaction时，将调用Init方法，以便Chaincode可以执行任何必要的初始化，包括应用程序状态的初始化。 调用Invoke方法是为了响应接收调用transaction来处理transaction提议。 chaincode “shim”API中的另一个接口是ChaincodeStubInterface,用于访问和修改ledger，并在chaincode之间进行调用。 在本文中，我们将通过实现一个管理“资产”的简单chaincode应用程序来演示如何使用这些API。 简单的资产Chaincode 我们的应用程序是一个基本样本chaincode，用于在ledger上创建资产（key-value对）。 选择代码的位置 现在，需要为chaincode应用程序创建一个目录作为$GOPATH/src/的子目录。 为了简单起见，我们使用下面的命令： mkdir -p $GOPATH/src/sacc &amp;&amp; cd $GOPATH/src/sacc 现在，创建将用代码填充的源文件： touch sacc.go Housekeeping 首先，我们从一些Housekeeping开始。与每个chaincode一样，它实现了Chaincode接口，即Init和Invoke函数。 因此，让我们添加go import语句以获取chaincode的必要依赖关系。 我们将导入chaincode shim包和peer protobuf包。 接下来，让我们添加一个结构SimpleAsset作为Chaincode shim函数的接收器。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // SimpleAsset 实现管理asset的一个简单chaincode type SimpleAsset struct { } Initializing the Chaincode 下面，我们实现 Init 函数. // chaincode 实例化的时候，调用Init来初始化数据 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { } 请注意，chaincode升级也会调用此函数。在编写将升级现有chaincode的代码时，请确保适当地修改Init函数。 特别是，如果没有“migration”(迁移)，或没有任何东西需要作为升级的一部分进行初始化时，请提供一个空的“Init”方法。 接下来，我们将使用ChaincodeStubInterface.GetStringArgs函数检索Init调用的参数，并检查其有效性。 在我们的例子中，我们期待一个key-value对。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } } 接下来，已经确定该调用是有效的，我们将把初始状态存储在ledger中。 要做到这一点，我们将调用ChaincodeStubInterface.PutState，并将key和value作为参数传入。 假设一切顺利，会返回一个指示初始化成功的peer.Response对象。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // 通过调用 stub.PutState()，设置任何 variables或assets // 我们把 key 和 value 存储在ledger上 err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } Invoking the Chaincode 首先，我们加入Invoke函数的signature（签名）。 //每个transaction都调用`Invoke`。每个 transactio是&#39;get&#39; //或者 &#39;set&#39; asset 。 &#39;set&#39;方法可以， //通过提供一个新的key-value对，创建一个新的asset。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { } 与上面的Init函数一样，我们需要从ChaincodeStubInterface中提取参数。 Invoke函数的参数，将是要调用的chaincode应用程序函数的名称。 在我们的例子中，我们的应用程序只有两个函数：set和get，它们允许设置资产的value或检索当前状态。 我们首先调用ChaincodeStubInterface.GetFunctionAndParameters来提取该chaincode应用函数的函数名称和参数。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() } 接下来，我们将验证函数名称是set还是get，并调用这些chaincode应用函数，通过shim返回相应的响应。shim.Success或shim.Error函数将响应序列化为gRPC protobuf消息。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } 实现Chaincode应用程序 如前所述，我们的chaincode应用程序实现了，两个可以通过Invoke函数调用的函数。 现在我们来实现这些功能。 请注意，正如我们上面提到的，为了访问ledger的状态，我们将利用chaincode shim API的ChaincodeStubInterface.PutState和ChaincodeStubInterface.GetState函数。 // 在ledger上，存储 asset (both key and value)，如果key 存在,会用新的value覆盖. func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } // 获取指定asset key的value func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } 完整代码 最后, 加入 main 函数, 它调用 shim.Start 函数。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) type SimpleAsset struct { } func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } // main函数，启动container中的chaincode（在实例化的时候）。 main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) } } Building Chaincode 现在让我们编译chaincode。 go get -u --tags nopkcs11 github.com/hyperledger/fabric/core/chaincode/shim go build --tags nopkcs11 假设没有错误，可以继续下一步，测试chaincode。 使用Dev模式测试 通常，chaincodes由peer启动和维护。 然而，在“Dev模式”下，链chaincodes由用户构建并启动。 在快速code/build/run/debug周期迭代的开发阶段，此模式非常有用。 我们通过利用，为样例dev网络，预先生成的orderer和channel artifacts，来开始“Dev模式”。 因此，用户可以立即跳到编辑chaincode和调用的过程中。 安装 Hyperledger Fabric Samples 如果之前没有做过，请安装Hyperledger Fabric Samples。 到fabric-samples目录的chaincode-docker-devmode 目录下: cd chaincode-docker-devmode 下载 Docker images 我们需要四个Docker镜像，才能使“dev模式”按照提供的docker compose script运行。 如果您安装了fabric-samples repo clone，并按照说明下载平台特定的二进制文件，那么你应该，已经在本地安装了必要的Docker镜像。 使用docker images命令，查看本地的Docker Registry。应该如下“ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hyperledger/fabric-tools latest b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-tools x86_64-1.1.0 b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-orderer latest ce0c810df36a About an hour ago 180MB hyperledger/fabric-orderer x86_64-1.1.0 ce0c810df36a About an hour ago 180MB hyperledger/fabric-peer latest b023f9be0771 About an hour ago 187MB hyperledger/fabric-peer x86_64-1.1.0 b023f9be0771 About an hour ago 187MB hyperledger/fabric-javaenv latest 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-javaenv x86_64-1.1.0 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-ccenv latest c8b4909d8d46 About an hour ago 1.39GB hyperledger/fabric-ccenv x86_64-1.1.0 c8b4909d8d46 About an hour ago 1.39GB 现在打开3个终端，并切换到chaincode-docker-devmode目录 Terminal 1 - Start the network docker-compose -f docker-compose-simple.yaml up 上面的命令使用SingleSampleMSPSoloorderer profile启动网络，并以“dev模式”启动peer。 它还启动了两个额外的容器 - 一个用于chaincode环境，一个用于与chaincode交互的CLI。 创建和加入Channel的命令被嵌入到CLI容器中，因此我们可以立即跳转到chaincode的调用。 Terminal 2 - Build &amp; start the chaincode docker exec -it chaincode bash 应该看到如下信息： root@d2629980e76b:/opt/gopath/src/chaincode# 现在编译你的chaincode: cd sacc go build 现在运行chaincode: CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc chaincode，以peer和chaincode日志开始，表示与peer注册成功。 请注意，在此阶段chaincode不与任何Channel关联。与Channel的关联，是在后续步骤中使用实例化命令完成的。 Terminal 3 - Use the chaincode 尽管你在 --peer-chaincodedev 模式中, 也需要install chaincode，这样 life-cycle system chaincode 可以正常通过它的检查。 当在 --peer-chaincodedev 模式中，这个需求可以在后续的版本中被移除掉。 启动 CLI container 来进行调用docker exec -it cli bash peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 现在发起一个invoke 把 “a” 的值改成“20”。 peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 再查询一下”a“的值 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; -C myc Chaincode加密 在某些情况下，加密与key相关的value（全部加密或者部分加密）可能是有用的。例如，如果一个人的社会安全号码，或地址正在写入ledger，那么你可能不希望这些数据以明文形式出现。 Chaincode加密，通过利用实体扩展实现，该BCCSP包装，执行诸如加密和椭圆曲线数字签名的加密操作。例如，为了加密，Chaincode的调用者通过transient字段传递加密密钥。然后可以将相同的密钥用于随后的查询操作，从而允许对加密的状态值进行适当的解密。 有关更多信息和示例，请参阅fabric/examples目录中的Encc示例。特别注意utils.go帮手程序。此实用工具加载Chaincode shim API和实体扩展，并构建样本加密Chaincode，随后利用新类函数（例如，encryptAndPutState＆getStateAndDecrypt）。因此，chaincode现在可以结合Get和Put的基本shim API（填充API）以及Encrypt和Decrypt的附加功能。 管理用Go编写的chaincode的外部依赖关系 如果你的chaincode需要非Go标准库提供的软件包，则需要将这些软件包包含在您的chaincode中。 有许多工具可用于管理这些依赖关系。 以下演示如何使用govendor： govendor init govendor add + external //添加所有外部包，或者 govendor add github.com/external/pkg //添加特定的外部软件包 这将外部依赖关系导入本地vendor目录。这样 peer chaincode包和peer chaincode安装操作，将会包含与chaincode包相关的代码。 阅读更多" />
<meta property="og:description" content="Chaincode简介 chaincode通常处理由网络成员赞同的业务逻辑，因此它类似于“智能合约”。 可以调用chaincode来更新或查询提案交易中的ledger。 如果有适当的许可，chaincode可以调用另一个chaincode，以访问其状态，无论是在同一个Channel还是在不同的Channel中。 请注意，如果被调用的chaincode与调用chaincode位于不同的通道上，则只允许读取查询。 Chaincode API 每个chaincode程序必须实现Chaincode interface,其方法被调用以回应收到的交易。 特别是当Chaincode接收实例化或升级transaction时，将调用Init方法，以便Chaincode可以执行任何必要的初始化，包括应用程序状态的初始化。 调用Invoke方法是为了响应接收调用transaction来处理transaction提议。 chaincode “shim”API中的另一个接口是ChaincodeStubInterface,用于访问和修改ledger，并在chaincode之间进行调用。 在本文中，我们将通过实现一个管理“资产”的简单chaincode应用程序来演示如何使用这些API。 简单的资产Chaincode 我们的应用程序是一个基本样本chaincode，用于在ledger上创建资产（key-value对）。 选择代码的位置 现在，需要为chaincode应用程序创建一个目录作为$GOPATH/src/的子目录。 为了简单起见，我们使用下面的命令： mkdir -p $GOPATH/src/sacc &amp;&amp; cd $GOPATH/src/sacc 现在，创建将用代码填充的源文件： touch sacc.go Housekeeping 首先，我们从一些Housekeeping开始。与每个chaincode一样，它实现了Chaincode接口，即Init和Invoke函数。 因此，让我们添加go import语句以获取chaincode的必要依赖关系。 我们将导入chaincode shim包和peer protobuf包。 接下来，让我们添加一个结构SimpleAsset作为Chaincode shim函数的接收器。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // SimpleAsset 实现管理asset的一个简单chaincode type SimpleAsset struct { } Initializing the Chaincode 下面，我们实现 Init 函数. // chaincode 实例化的时候，调用Init来初始化数据 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { } 请注意，chaincode升级也会调用此函数。在编写将升级现有chaincode的代码时，请确保适当地修改Init函数。 特别是，如果没有“migration”(迁移)，或没有任何东西需要作为升级的一部分进行初始化时，请提供一个空的“Init”方法。 接下来，我们将使用ChaincodeStubInterface.GetStringArgs函数检索Init调用的参数，并检查其有效性。 在我们的例子中，我们期待一个key-value对。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } } 接下来，已经确定该调用是有效的，我们将把初始状态存储在ledger中。 要做到这一点，我们将调用ChaincodeStubInterface.PutState，并将key和value作为参数传入。 假设一切顺利，会返回一个指示初始化成功的peer.Response对象。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // 通过调用 stub.PutState()，设置任何 variables或assets // 我们把 key 和 value 存储在ledger上 err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } Invoking the Chaincode 首先，我们加入Invoke函数的signature（签名）。 //每个transaction都调用`Invoke`。每个 transactio是&#39;get&#39; //或者 &#39;set&#39; asset 。 &#39;set&#39;方法可以， //通过提供一个新的key-value对，创建一个新的asset。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { } 与上面的Init函数一样，我们需要从ChaincodeStubInterface中提取参数。 Invoke函数的参数，将是要调用的chaincode应用程序函数的名称。 在我们的例子中，我们的应用程序只有两个函数：set和get，它们允许设置资产的value或检索当前状态。 我们首先调用ChaincodeStubInterface.GetFunctionAndParameters来提取该chaincode应用函数的函数名称和参数。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() } 接下来，我们将验证函数名称是set还是get，并调用这些chaincode应用函数，通过shim返回相应的响应。shim.Success或shim.Error函数将响应序列化为gRPC protobuf消息。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } 实现Chaincode应用程序 如前所述，我们的chaincode应用程序实现了，两个可以通过Invoke函数调用的函数。 现在我们来实现这些功能。 请注意，正如我们上面提到的，为了访问ledger的状态，我们将利用chaincode shim API的ChaincodeStubInterface.PutState和ChaincodeStubInterface.GetState函数。 // 在ledger上，存储 asset (both key and value)，如果key 存在,会用新的value覆盖. func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } // 获取指定asset key的value func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } 完整代码 最后, 加入 main 函数, 它调用 shim.Start 函数。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) type SimpleAsset struct { } func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } // main函数，启动container中的chaincode（在实例化的时候）。 main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) } } Building Chaincode 现在让我们编译chaincode。 go get -u --tags nopkcs11 github.com/hyperledger/fabric/core/chaincode/shim go build --tags nopkcs11 假设没有错误，可以继续下一步，测试chaincode。 使用Dev模式测试 通常，chaincodes由peer启动和维护。 然而，在“Dev模式”下，链chaincodes由用户构建并启动。 在快速code/build/run/debug周期迭代的开发阶段，此模式非常有用。 我们通过利用，为样例dev网络，预先生成的orderer和channel artifacts，来开始“Dev模式”。 因此，用户可以立即跳到编辑chaincode和调用的过程中。 安装 Hyperledger Fabric Samples 如果之前没有做过，请安装Hyperledger Fabric Samples。 到fabric-samples目录的chaincode-docker-devmode 目录下: cd chaincode-docker-devmode 下载 Docker images 我们需要四个Docker镜像，才能使“dev模式”按照提供的docker compose script运行。 如果您安装了fabric-samples repo clone，并按照说明下载平台特定的二进制文件，那么你应该，已经在本地安装了必要的Docker镜像。 使用docker images命令，查看本地的Docker Registry。应该如下“ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hyperledger/fabric-tools latest b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-tools x86_64-1.1.0 b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-orderer latest ce0c810df36a About an hour ago 180MB hyperledger/fabric-orderer x86_64-1.1.0 ce0c810df36a About an hour ago 180MB hyperledger/fabric-peer latest b023f9be0771 About an hour ago 187MB hyperledger/fabric-peer x86_64-1.1.0 b023f9be0771 About an hour ago 187MB hyperledger/fabric-javaenv latest 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-javaenv x86_64-1.1.0 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-ccenv latest c8b4909d8d46 About an hour ago 1.39GB hyperledger/fabric-ccenv x86_64-1.1.0 c8b4909d8d46 About an hour ago 1.39GB 现在打开3个终端，并切换到chaincode-docker-devmode目录 Terminal 1 - Start the network docker-compose -f docker-compose-simple.yaml up 上面的命令使用SingleSampleMSPSoloorderer profile启动网络，并以“dev模式”启动peer。 它还启动了两个额外的容器 - 一个用于chaincode环境，一个用于与chaincode交互的CLI。 创建和加入Channel的命令被嵌入到CLI容器中，因此我们可以立即跳转到chaincode的调用。 Terminal 2 - Build &amp; start the chaincode docker exec -it chaincode bash 应该看到如下信息： root@d2629980e76b:/opt/gopath/src/chaincode# 现在编译你的chaincode: cd sacc go build 现在运行chaincode: CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc chaincode，以peer和chaincode日志开始，表示与peer注册成功。 请注意，在此阶段chaincode不与任何Channel关联。与Channel的关联，是在后续步骤中使用实例化命令完成的。 Terminal 3 - Use the chaincode 尽管你在 --peer-chaincodedev 模式中, 也需要install chaincode，这样 life-cycle system chaincode 可以正常通过它的检查。 当在 --peer-chaincodedev 模式中，这个需求可以在后续的版本中被移除掉。 启动 CLI container 来进行调用docker exec -it cli bash peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 现在发起一个invoke 把 “a” 的值改成“20”。 peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 再查询一下”a“的值 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; -C myc Chaincode加密 在某些情况下，加密与key相关的value（全部加密或者部分加密）可能是有用的。例如，如果一个人的社会安全号码，或地址正在写入ledger，那么你可能不希望这些数据以明文形式出现。 Chaincode加密，通过利用实体扩展实现，该BCCSP包装，执行诸如加密和椭圆曲线数字签名的加密操作。例如，为了加密，Chaincode的调用者通过transient字段传递加密密钥。然后可以将相同的密钥用于随后的查询操作，从而允许对加密的状态值进行适当的解密。 有关更多信息和示例，请参阅fabric/examples目录中的Encc示例。特别注意utils.go帮手程序。此实用工具加载Chaincode shim API和实体扩展，并构建样本加密Chaincode，随后利用新类函数（例如，encryptAndPutState＆getStateAndDecrypt）。因此，chaincode现在可以结合Get和Put的基本shim API（填充API）以及Encrypt和Decrypt的附加功能。 管理用Go编写的chaincode的外部依赖关系 如果你的chaincode需要非Go标准库提供的软件包，则需要将这些软件包包含在您的chaincode中。 有许多工具可用于管理这些依赖关系。 以下演示如何使用govendor： govendor init govendor add + external //添加所有外部包，或者 govendor add github.com/external/pkg //添加特定的外部软件包 这将外部依赖关系导入本地vendor目录。这样 peer chaincode包和peer chaincode安装操作，将会包含与chaincode包相关的代码。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/04/13/9fc0a0eb27276dfdd903d998131e54b2.html" />
<meta property="og:url" content="https://mlh.app/2018/04/13/9fc0a0eb27276dfdd903d998131e54b2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Chaincode简介 chaincode通常处理由网络成员赞同的业务逻辑，因此它类似于“智能合约”。 可以调用chaincode来更新或查询提案交易中的ledger。 如果有适当的许可，chaincode可以调用另一个chaincode，以访问其状态，无论是在同一个Channel还是在不同的Channel中。 请注意，如果被调用的chaincode与调用chaincode位于不同的通道上，则只允许读取查询。 Chaincode API 每个chaincode程序必须实现Chaincode interface,其方法被调用以回应收到的交易。 特别是当Chaincode接收实例化或升级transaction时，将调用Init方法，以便Chaincode可以执行任何必要的初始化，包括应用程序状态的初始化。 调用Invoke方法是为了响应接收调用transaction来处理transaction提议。 chaincode “shim”API中的另一个接口是ChaincodeStubInterface,用于访问和修改ledger，并在chaincode之间进行调用。 在本文中，我们将通过实现一个管理“资产”的简单chaincode应用程序来演示如何使用这些API。 简单的资产Chaincode 我们的应用程序是一个基本样本chaincode，用于在ledger上创建资产（key-value对）。 选择代码的位置 现在，需要为chaincode应用程序创建一个目录作为$GOPATH/src/的子目录。 为了简单起见，我们使用下面的命令： mkdir -p $GOPATH/src/sacc &amp;&amp; cd $GOPATH/src/sacc 现在，创建将用代码填充的源文件： touch sacc.go Housekeeping 首先，我们从一些Housekeeping开始。与每个chaincode一样，它实现了Chaincode接口，即Init和Invoke函数。 因此，让我们添加go import语句以获取chaincode的必要依赖关系。 我们将导入chaincode shim包和peer protobuf包。 接下来，让我们添加一个结构SimpleAsset作为Chaincode shim函数的接收器。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // SimpleAsset 实现管理asset的一个简单chaincode type SimpleAsset struct { } Initializing the Chaincode 下面，我们实现 Init 函数. // chaincode 实例化的时候，调用Init来初始化数据 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { } 请注意，chaincode升级也会调用此函数。在编写将升级现有chaincode的代码时，请确保适当地修改Init函数。 特别是，如果没有“migration”(迁移)，或没有任何东西需要作为升级的一部分进行初始化时，请提供一个空的“Init”方法。 接下来，我们将使用ChaincodeStubInterface.GetStringArgs函数检索Init调用的参数，并检查其有效性。 在我们的例子中，我们期待一个key-value对。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } } 接下来，已经确定该调用是有效的，我们将把初始状态存储在ledger中。 要做到这一点，我们将调用ChaincodeStubInterface.PutState，并将key和value作为参数传入。 假设一切顺利，会返回一个指示初始化成功的peer.Response对象。 func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // 从 transaction proposal 获取参数 args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // 通过调用 stub.PutState()，设置任何 variables或assets // 我们把 key 和 value 存储在ledger上 err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } Invoking the Chaincode 首先，我们加入Invoke函数的signature（签名）。 //每个transaction都调用`Invoke`。每个 transactio是&#39;get&#39; //或者 &#39;set&#39; asset 。 &#39;set&#39;方法可以， //通过提供一个新的key-value对，创建一个新的asset。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { } 与上面的Init函数一样，我们需要从ChaincodeStubInterface中提取参数。 Invoke函数的参数，将是要调用的chaincode应用程序函数的名称。 在我们的例子中，我们的应用程序只有两个函数：set和get，它们允许设置资产的value或检索当前状态。 我们首先调用ChaincodeStubInterface.GetFunctionAndParameters来提取该chaincode应用函数的函数名称和参数。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() } 接下来，我们将验证函数名称是set还是get，并调用这些chaincode应用函数，通过shim返回相应的响应。shim.Success或shim.Error函数将响应序列化为gRPC protobuf消息。 func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // 从transaction proposal中抽取 function和 args fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } 实现Chaincode应用程序 如前所述，我们的chaincode应用程序实现了，两个可以通过Invoke函数调用的函数。 现在我们来实现这些功能。 请注意，正如我们上面提到的，为了访问ledger的状态，我们将利用chaincode shim API的ChaincodeStubInterface.PutState和ChaincodeStubInterface.GetState函数。 // 在ledger上，存储 asset (both key and value)，如果key 存在,会用新的value覆盖. func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } // 获取指定asset key的value func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } 完整代码 最后, 加入 main 函数, 它调用 shim.Start 函数。 package main import ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; &quot;github.com/hyperledger/fabric/protos/peer&quot; ) type SimpleAsset struct { } func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil) } func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } return shim.Success([]byte(result)) } func set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil } func get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil } // main函数，启动container中的chaincode（在实例化的时候）。 main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) } } Building Chaincode 现在让我们编译chaincode。 go get -u --tags nopkcs11 github.com/hyperledger/fabric/core/chaincode/shim go build --tags nopkcs11 假设没有错误，可以继续下一步，测试chaincode。 使用Dev模式测试 通常，chaincodes由peer启动和维护。 然而，在“Dev模式”下，链chaincodes由用户构建并启动。 在快速code/build/run/debug周期迭代的开发阶段，此模式非常有用。 我们通过利用，为样例dev网络，预先生成的orderer和channel artifacts，来开始“Dev模式”。 因此，用户可以立即跳到编辑chaincode和调用的过程中。 安装 Hyperledger Fabric Samples 如果之前没有做过，请安装Hyperledger Fabric Samples。 到fabric-samples目录的chaincode-docker-devmode 目录下: cd chaincode-docker-devmode 下载 Docker images 我们需要四个Docker镜像，才能使“dev模式”按照提供的docker compose script运行。 如果您安装了fabric-samples repo clone，并按照说明下载平台特定的二进制文件，那么你应该，已经在本地安装了必要的Docker镜像。 使用docker images命令，查看本地的Docker Registry。应该如下“ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hyperledger/fabric-tools latest b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-tools x86_64-1.1.0 b7bfddf508bc About an hour ago 1.46GB hyperledger/fabric-orderer latest ce0c810df36a About an hour ago 180MB hyperledger/fabric-orderer x86_64-1.1.0 ce0c810df36a About an hour ago 180MB hyperledger/fabric-peer latest b023f9be0771 About an hour ago 187MB hyperledger/fabric-peer x86_64-1.1.0 b023f9be0771 About an hour ago 187MB hyperledger/fabric-javaenv latest 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-javaenv x86_64-1.1.0 82098abb1a17 About an hour ago 1.52GB hyperledger/fabric-ccenv latest c8b4909d8d46 About an hour ago 1.39GB hyperledger/fabric-ccenv x86_64-1.1.0 c8b4909d8d46 About an hour ago 1.39GB 现在打开3个终端，并切换到chaincode-docker-devmode目录 Terminal 1 - Start the network docker-compose -f docker-compose-simple.yaml up 上面的命令使用SingleSampleMSPSoloorderer profile启动网络，并以“dev模式”启动peer。 它还启动了两个额外的容器 - 一个用于chaincode环境，一个用于与chaincode交互的CLI。 创建和加入Channel的命令被嵌入到CLI容器中，因此我们可以立即跳转到chaincode的调用。 Terminal 2 - Build &amp; start the chaincode docker exec -it chaincode bash 应该看到如下信息： root@d2629980e76b:/opt/gopath/src/chaincode# 现在编译你的chaincode: cd sacc go build 现在运行chaincode: CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc chaincode，以peer和chaincode日志开始，表示与peer注册成功。 请注意，在此阶段chaincode不与任何Channel关联。与Channel的关联，是在后续步骤中使用实例化命令完成的。 Terminal 3 - Use the chaincode 尽管你在 --peer-chaincodedev 模式中, 也需要install chaincode，这样 life-cycle system chaincode 可以正常通过它的检查。 当在 --peer-chaincodedev 模式中，这个需求可以在后续的版本中被移除掉。 启动 CLI container 来进行调用docker exec -it cli bash peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 现在发起一个invoke 把 “a” 的值改成“20”。 peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 再查询一下”a“的值 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; -C myc Chaincode加密 在某些情况下，加密与key相关的value（全部加密或者部分加密）可能是有用的。例如，如果一个人的社会安全号码，或地址正在写入ledger，那么你可能不希望这些数据以明文形式出现。 Chaincode加密，通过利用实体扩展实现，该BCCSP包装，执行诸如加密和椭圆曲线数字签名的加密操作。例如，为了加密，Chaincode的调用者通过transient字段传递加密密钥。然后可以将相同的密钥用于随后的查询操作，从而允许对加密的状态值进行适当的解密。 有关更多信息和示例，请参阅fabric/examples目录中的Encc示例。特别注意utils.go帮手程序。此实用工具加载Chaincode shim API和实体扩展，并构建样本加密Chaincode，随后利用新类函数（例如，encryptAndPutState＆getStateAndDecrypt）。因此，chaincode现在可以结合Get和Put的基本shim API（填充API）以及Encrypt和Decrypt的附加功能。 管理用Go编写的chaincode的外部依赖关系 如果你的chaincode需要非Go标准库提供的软件包，则需要将这些软件包包含在您的chaincode中。 有许多工具可用于管理这些依赖关系。 以下演示如何使用govendor： govendor init govendor add + external //添加所有外部包，或者 govendor add github.com/external/pkg //添加特定的外部软件包 这将外部依赖关系导入本地vendor目录。这样 peer chaincode包和peer chaincode安装操作，将会包含与chaincode包相关的代码。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/04/13/9fc0a0eb27276dfdd903d998131e54b2.html","headline":"Hyperledger系列（十三）开发Chaincode","dateModified":"2018-04-13T00:00:00+08:00","datePublished":"2018-04-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/04/13/9fc0a0eb27276dfdd903d998131e54b2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Hyperledger系列（十三）开发Chaincode</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2>Chaincode简介</h2>
  <p>chaincode通常处理由网络成员赞同的业务逻辑，因此它类似于“智能合约”。 可以调用chaincode来更新或查询提案交易中的ledger。 </p>
  <p>如果有适当的许可，chaincode可以调用另一个chaincode，以访问其状态，无论是在同一个Channel还是在不同的Channel中。 请注意，如果被调用的chaincode与调用chaincode位于不同的通道上，则只允许读取查询。</p>
  <h2>Chaincode API</h2>
  <p>每个chaincode程序必须实现<code>Chaincode interface</code>,其方法被调用以回应收到的交易。</p>
  <p>特别是当Chaincode接收实例化或升级transaction时，将调用Init方法，以便Chaincode可以执行任何必要的初始化，包括应用程序状态的初始化。 调用Invoke方法是为了响应接收调用transaction来处理transaction提议。</p>
  <p>chaincode “shim”API中的另一个接口是<code>ChaincodeStubInterface</code>,用于访问和修改ledger，并在chaincode之间进行调用。</p>
  <p>在本文中，我们将通过实现一个管理“资产”的简单chaincode应用程序来演示如何使用这些API。</p>
  <h2>简单的资产Chaincode</h2>
  <p>我们的应用程序是一个基本样本chaincode，用于在ledger上创建资产（key-value对）。</p>
  <h3>选择代码的位置</h3>
  <p>现在，需要为chaincode应用程序创建一个目录作为<code>$GOPATH/src/</code>的子目录。</p>
  <p>为了简单起见，我们使用下面的命令：</p>
  <pre><code class="language-c">mkdir -p $GOPATH/src/sacc &amp;&amp; cd $GOPATH/src/sacc
</code></pre>
  <p>现在，创建将用代码填充的源文件：</p>
  <p><code>touch sacc.go</code></p>
  <h3>Housekeeping</h3>
  <p>首先，我们从一些Housekeeping开始。<strong>与每个chaincode一样，它实现了Chaincode接口，即<code>Init</code>和<code>Invoke</code>函数。</strong> 因此，让我们添加go import语句以获取chaincode的必要依赖关系。 我们将导入chaincode shim包和peer protobuf包。 接下来，让我们添加一个结构<code>SimpleAsset</code>作为Chaincode shim函数的接收器。</p>
  <pre><code class="language-c">package main

import (
    "fmt"

    "github.com/hyperledger/fabric/core/chaincode/shim"
    "github.com/hyperledger/fabric/protos/peer"
)

// SimpleAsset 实现管理asset的一个简单chaincode
type SimpleAsset struct {
}
</code></pre>
  <h3>Initializing the Chaincode</h3>
  <p>下面，我们实现 <code>Init</code> 函数.</p>
  <pre><code class="language-c">// chaincode 实例化的时候，调用Init来初始化数据
func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {

}
</code></pre>
  <p>请注意，chaincode升级也会调用此函数。在编写将升级现有chaincode的代码时，请确保适当地修改<code>Init</code>函数。 特别是，如果没有“migration”(迁移)，或没有任何东西需要作为升级的一部分进行初始化时，请提供一个空的<code>“Init”</code>方法。</p>
  <p>接下来，我们将使用<code>ChaincodeStubInterface.GetStringArgs</code>函数检索<code>Init</code>调用的参数，并检查其有效性。 在我们的例子中，我们期待一个key-value对。</p>
  <pre><code class="language-c">func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
  // 从 transaction proposal 获取参数
  args := stub.GetStringArgs()
  if len(args) != 2 {
    return shim.Error("Incorrect arguments. Expecting a key and a value")
  }
}
</code></pre>
  <p>接下来，已经确定该调用是有效的，我们将把初始状态存储在ledger中。 要做到这一点，我们将调用<code>ChaincodeStubInterface.PutState</code>，并将key和value作为参数传入。 假设一切顺利，会返回一个指示初始化成功的<code>peer.Response</code>对象。</p>
  <pre><code class="language-c">func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
  // 从 transaction proposal 获取参数
  args := stub.GetStringArgs()
  if len(args) != 2 {
    return shim.Error("Incorrect arguments. Expecting a key and a value")
  }

  // 通过调用 stub.PutState()，设置任何 variables或assets 
// 我们把 key 和 value 存储在ledger上
  err := stub.PutState(args[0], []byte(args[1]))
  if err != nil {
    return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
  }
  return shim.Success(nil)
}
</code></pre>
  <h3>Invoking the Chaincode</h3>
  <p>首先，我们加入<code>Invoke</code>函数的signature（签名）。</p>
  <pre><code class="language-c">//每个transaction都调用`Invoke`。每个 transactio是'get' 
//或者 'set' asset 。 'set'方法可以，
//通过提供一个新的key-value对，创建一个新的asset。
func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {

}
</code></pre>
  <p>与上面的<code>Init</code>函数一样，我们需要从<code>ChaincodeStubInterface</code>中提取参数。 <code>Invoke</code>函数的参数，将是要调用的chaincode应用程序函数的名称。 </p>
  <p>在我们的例子中，我们的应用程序只有两个函数：<code>set</code>和<code>get</code>，它们允许设置资产的value或检索当前状态。 我们首先调用<code>ChaincodeStubInterface.GetFunctionAndParameters</code>来提取该chaincode应用函数的函数名称和参数。</p>
  <pre><code class="language-c">func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
    // 从transaction proposal中抽取 function和 args 
    fn, args := stub.GetFunctionAndParameters()

}
</code></pre>
  <p>接下来，我们将验证函数名称是<code>set</code>还是<code>get</code>，并调用这些chaincode应用函数，通过shim返回相应的响应。shim.Success或shim.Error函数将响应序列化为gRPC protobuf消息。</p>
  <pre><code class="language-c">func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
    // 从transaction proposal中抽取 function和 args 
    fn, args := stub.GetFunctionAndParameters()

    var result string
    var err error
    if fn == "set" {
            result, err = set(stub, args)
    } else {
            result, err = get(stub, args)
    }
    if err != nil {
            return shim.Error(err.Error())
    }

    return shim.Success([]byte(result))
}
</code></pre>
  <h3>实现Chaincode应用程序</h3>
  <p>如前所述，我们的chaincode应用程序实现了，两个可以通过<code>Invoke</code>函数调用的函数。 现在我们来实现这些功能。 </p>
  <p>请注意，正如我们上面提到的，为了访问ledger的状态，我们将利用<code>chaincode shim API</code>的<code>ChaincodeStubInterface.PutState</code>和<code>ChaincodeStubInterface.GetState</code>函数。</p>
  <pre><code class="language-c">//  在ledger上，存储 asset (both key and value)，如果key 存在,会用新的value覆盖.
func set(stub shim.ChaincodeStubInterface, args []string) (string, error) {
    if len(args) != 2 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key and a value")
    }

    err := stub.PutState(args[0], []byte(args[1]))
    if err != nil {
            return "", fmt.Errorf("Failed to set asset: %s", args[0])
    }
    return args[1], nil
}

// 获取指定asset key的value
func get(stub shim.ChaincodeStubInterface, args []string) (string, error) {
    if len(args) != 1 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key")
    }

    value, err := stub.GetState(args[0])
    if err != nil {
            return "", fmt.Errorf("Failed to get asset: %s with error: %s", args[0], err)
    }
    if value == nil {
            return "", fmt.Errorf("Asset not found: %s", args[0])
    }
    return string(value), nil
}
</code></pre>
  <h3>完整代码</h3>
  <p>最后, 加入 <code>main</code> 函数, 它调用 <code>shim.Start</code> 函数。</p>
  <pre><code class="language-c">package main

import (
    "fmt"

    "github.com/hyperledger/fabric/core/chaincode/shim"
    "github.com/hyperledger/fabric/protos/peer"
)

type SimpleAsset struct {
}

func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
    args := stub.GetStringArgs()
    if len(args) != 2 {
            return shim.Error("Incorrect arguments. Expecting a key and a value")
    }

    err := stub.PutState(args[0], []byte(args[1]))
    if err != nil {
            return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
    }
    return shim.Success(nil)
}


func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {

    fn, args := stub.GetFunctionAndParameters()

    var result string
    var err error
    if fn == "set" {
            result, err = set(stub, args)
    } else {
            result, err = get(stub, args)
    }
    if err != nil {
            return shim.Error(err.Error())
    }
    return shim.Success([]byte(result))
}

func set(stub shim.ChaincodeStubInterface, args []string) (string, error) {
    if len(args) != 2 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key and a value")
    }

    err := stub.PutState(args[0], []byte(args[1]))
    if err != nil {
            return "", fmt.Errorf("Failed to set asset: %s", args[0])
    }
    return args[1], nil
}

func get(stub shim.ChaincodeStubInterface, args []string) (string, error) {
    if len(args) != 1 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key")
    }

    value, err := stub.GetState(args[0])
    if err != nil {
            return "", fmt.Errorf("Failed to get asset: %s with error: %s", args[0], err)
    }
    if value == nil {
            return "", fmt.Errorf("Asset not found: %s", args[0])
    }
    return string(value), nil
}

// main函数，启动container中的chaincode（在实例化的时候）。
main() {
    if err := shim.Start(new(SimpleAsset)); err != nil {
            fmt.Printf("Error starting SimpleAsset chaincode: %s", err)
    }
}
</code></pre>
  <h3>Building Chaincode</h3>
  <p>现在让我们编译chaincode。</p>
  <pre><code class="language-c">go get -u --tags nopkcs11 github.com/hyperledger/fabric/core/chaincode/shim
go build --tags nopkcs11
</code></pre>
  <p>假设没有错误，可以继续下一步，测试chaincode。</p>
  <h3>使用Dev模式测试</h3>
  <p>通常，chaincodes由peer启动和维护。 然而，在“Dev模式”下，链chaincodes由用户构建并启动。 在快速code/build/run/debug周期迭代的开发阶段，此模式非常有用。</p>
  <p>我们通过利用，为样例dev网络，预先生成的orderer和channel artifacts，来开始“Dev模式”。 因此，用户可以立即跳到编辑chaincode和调用的过程中。</p>
  <h2>安装 Hyperledger Fabric Samples</h2>
  <p>如果之前没有做过，请安装Hyperledger Fabric Samples。</p>
  <p>到<code>fabric-samples</code>目录的<code>chaincode-docker-devmode</code> 目录下:</p>
  <p><code>cd chaincode-docker-devmode</code></p>
  <h2>下载 Docker images</h2>
  <p>我们需要四个Docker镜像，才能使“dev模式”按照提供的docker compose script运行。 <br>如果您安装了<code>fabric-samples</code> repo clone，并按照说明下载平台特定的二进制文件，那么你应该，已经在本地安装了必要的Docker镜像。</p>
  <p>使用<code>docker images</code>命令，查看本地的Docker Registry。应该如下“</p>
  <pre><code class="language-c">docker images
REPOSITORY                     TAG                                  IMAGE ID            CREATED             SIZE
hyperledger/fabric-tools       latest                           b7bfddf508bc        About an hour ago   1.46GB
hyperledger/fabric-tools       x86_64-1.1.0                     b7bfddf508bc        About an hour ago   1.46GB
hyperledger/fabric-orderer     latest                           ce0c810df36a        About an hour ago   180MB
hyperledger/fabric-orderer     x86_64-1.1.0                     ce0c810df36a        About an hour ago   180MB
hyperledger/fabric-peer        latest                           b023f9be0771        About an hour ago   187MB
hyperledger/fabric-peer        x86_64-1.1.0                     b023f9be0771        About an hour ago   187MB
hyperledger/fabric-javaenv     latest                           82098abb1a17        About an hour ago   1.52GB
hyperledger/fabric-javaenv     x86_64-1.1.0                     82098abb1a17        About an hour ago   1.52GB
hyperledger/fabric-ccenv       latest                           c8b4909d8d46        About an hour ago   1.39GB
hyperledger/fabric-ccenv       x86_64-1.1.0                     c8b4909d8d46        About an hour ago   1.39GB
</code></pre>
  <p>现在打开3个终端，并切换到<code>chaincode-docker-devmode</code>目录</p>
  <h2>Terminal 1 - Start the network</h2>
  <p><code>docker-compose -f docker-compose-simple.yaml up</code></p>
  <p>上面的命令使用<code>SingleSampleMSPSolo</code>orderer profile启动网络，并以“dev模式”启动peer。 </p>
  <p>它还启动了两个额外的容器 - 一个用于chaincode环境，一个用于与chaincode交互的CLI。 创建和加入Channel的命令被嵌入到CLI容器中，因此我们可以立即跳转到chaincode的调用。</p>
  <h2>Terminal 2 - Build &amp; start the chaincode</h2>
  <p><code>docker exec -it chaincode bash</code></p>
  <p>应该看到如下信息：</p>
  <pre><code class="language-c">root@d2629980e76b:/opt/gopath/src/chaincode#
</code></pre>
  <p>现在编译你的chaincode:</p>
  <pre><code class="language-c">cd sacc
go build
</code></pre>
  <p>现在运行chaincode:</p>
  <pre><code class="language-c">CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc
</code></pre>
  <p>chaincode，以peer和chaincode日志开始，表示与peer注册成功。 请注意，在此阶段chaincode不与任何Channel关联。与Channel的关联，是在后续步骤中使用实例化命令完成的。</p>
  <h2>Terminal 3 - Use the chaincode</h2>
  <p>尽管你在 <code>--peer-chaincodedev</code> 模式中, 也需要install chaincode，这样 life-cycle system chaincode 可以正常通过它的检查。 当在 <code>--peer-chaincodedev</code> 模式中，这个需求可以在后续的版本中被移除掉。</p>
  <p>启动 CLI container 来进行调用<br><code>docker exec -it cli bash</code></p>
  <pre><code class="language-c">peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0
peer chaincode instantiate -n mycc -v 0 -c '{"Args":["a","10"]}' -C myc
</code></pre>
  <p>现在发起一个<code>invoke</code> 把 “a” 的值改成“20”。</p>
  <pre><code class="language-c">peer chaincode invoke -n mycc -c '{"Args":["set", "a", "20"]}' -C myc
</code></pre>
  <p>再查询一下”a“的值</p>
  <pre><code class="language-c">peer chaincode query -n mycc -c '{"Args":["query","a"]}' -C myc
</code></pre>
  <h2>Chaincode加密</h2>
  <p>在某些情况下，加密与key相关的value（全部加密或者部分加密）可能是有用的。例如，如果一个人的社会安全号码，或地址正在写入ledger，那么你可能不希望这些数据以明文形式出现。 Chaincode加密，通过利用实体扩展实现，该BCCSP包装，执行诸如加密和椭圆曲线数字签名的加密操作。例如，为了加密，Chaincode的调用者通过transient字段传递加密密钥。然后可以将相同的密钥用于随后的查询操作，从而允许对加密的状态值进行适当的解密。</p>
  <p>有关更多信息和示例，请参阅<code>fabric/examples</code>目录中的<code>Encc</code>示例。特别注意<code>utils.go</code>帮手程序。此实用工具加载Chaincode shim API和实体扩展，并构建样本加密Chaincode，随后利用新类函数（例如，encryptAndPutState＆getStateAndDecrypt）。因此，chaincode现在可以结合Get和Put的基本shim API（填充API）以及Encrypt和Decrypt的附加功能。</p>
  <h2>管理用Go编写的chaincode的外部依赖关系</h2>
  <p>如果你的chaincode需要非Go标准库提供的软件包，则需要将这些软件包包含在您的chaincode中。 有许多工具可用于管理这些依赖关系。 以下演示如何使用govendor：</p>
  <pre><code class="language-c">govendor init
govendor add + external //添加所有外部包，或者
govendor add github.com/external/pkg //添加特定的外部软件包
</code></pre>
  <p>这将外部依赖关系导入本地vendor目录。这样 peer chaincode包和peer chaincode安装操作，将会包含与chaincode包相关的代码。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/maixia24/article/details/79932777,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/maixia24/article/details/79932777,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
