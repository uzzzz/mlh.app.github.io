<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码情景分析之script脚本验证(2) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码情景分析之script脚本验证(2)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; &nbsp; 通过上一篇的分析，我们应该已经对script有了一定的理解，这章节我们以源码分析的方式来了解下脚本验证执行流程 &nbsp;&nbsp; &nbsp;bitcoin节点在处理一条交易时就需要验证交易的txin，由于一条交易可能包含多个txin,因而需要执行多个脚本验证，自然需要并行化，因而系统允许定义多个脚本执行线程以加速验证过程。有了这个思考，我们从脚本执行线程出发 剥茧抽丝掀开脚本执行的面纱。 &nbsp; &nbsp; 先看脚本执行线程的初始化，这个在init.cpp的AppInitMain里 脚本验证执行线程 &nbsp;&nbsp;&nbsp;&nbsp;LogPrintf(&quot;Using %u threads for script verification\n&quot;, nScriptCheckThreads); &nbsp;&nbsp;&nbsp;&nbsp;if (nScriptCheckThreads) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//根据参数创建对应数量的脚本执行线程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nScriptCheckThreads-1; i++) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadGroup.create_thread(&amp;ThreadScriptCheck); &nbsp;&nbsp;&nbsp;&nbsp;} 线程的具体实现函数在 validataion.cpp static CCheckQueue&lt;CScriptCheck&gt; scriptcheckqueue (128); void ThreadScriptCheck () { &nbsp;&nbsp;&nbsp;&nbsp;RenameThread(&quot;bitcoin-scriptch&quot;); &nbsp;&nbsp;&nbsp;&nbsp;scriptcheckqueue.Thread(); } class CCheckQueue { &nbsp;&nbsp;//! Worker thread &nbsp; void Thread() &nbsp; &nbsp;// CCheckQueue.Thread() &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loop(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; bool Loop(bool fMaster = false) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::condition_variable&amp; cond = fMaster ? condMaster : condWorker; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;T&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.reserve(nBatchSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nNow = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fOk = true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;…………….. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Decide how many work units to process now. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Do not try to do everything at once, but aim for increasingly smaller batches so &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;all workers finish approximately simultaneously. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Try to account for idle jobs which will instantly start helping. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Don&#39;t do batches smaller than 1 (duh), or larger than nBatchSize. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1))); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.resize(nNow); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; nNow; i++) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We want the lock on the mutex to be as short as possible, so swap jobs from the global &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// queue to the local batch vector instead of copying. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 该线程选取一定量的脚本待执行对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks[i].swap( queue.back ()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.pop_back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check whether we need to do work at all &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = fAllOk; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// execute work &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (T&amp; check : vChecks) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fOk) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //check()函数就是 CScriptCheck::operator()() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = check(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while (true); &nbsp;&nbsp;&nbsp;&nbsp;} 添加脚本验证对象 &nbsp;&nbsp;//发现新块并处理交易时会验证脚本 bool CChainState:: ConnectBlock (const CBlock&amp; block, CValidationState&amp; state, CBlockIndex* pindex, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewCache&amp; view, const CChainParams&amp; chainparams, bool fJustCheck) { &nbsp;&nbsp;&nbsp;&nbsp;AssertLockHeld(cs_main); &nbsp;&nbsp; &nbsp; CCheckQueueControl&lt;CScriptCheck&gt; control (fScriptChecks &amp;&amp; nScriptCheckThreads ? &amp;scriptcheckqueue : nullptr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CScriptCheck&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fCacheResults = fJustCheck; /* Don&#39;t cache results if we&#39;re actually connecting blocks (still consult the cache, though) */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &amp;vChecks : nullptr)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;ConnectBlock(): CheckInputs on %s failed with %s&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.GetHash().ToString(), FormatStateMessage(state)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //control负责将某一个具体的验证执行对象添加到队列中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.Add(vChecks); } class CCheckQueueControl { &nbsp;&nbsp;&nbsp;&nbsp;void Add(std::vector&lt;T&gt;&amp; vChecks) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pqueue != nullptr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pqueue-&gt;Add(vChecks); &nbsp;&nbsp;&nbsp;&nbsp;} } 脚本验证执行函数 上面可知脚本验证线程最终会执行 CScriptCheck::operator bool CScriptCheck::operator()() { &nbsp;&nbsp;&nbsp;&nbsp;const CScript &amp;scriptSig = ptxTo-&gt;vin[nIn].scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;const CScriptWitness *witness = &amp;ptxTo-&gt;vin[nIn].scriptWitness; &nbsp;&nbsp;&nbsp;&nbsp;return VerifyScript (scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &amp;error); } P2SH脚本验证源码分析 为了更完整的分析该过程，我以最复杂的脚本模板P2SH为例分析，从上一章接的介绍我们知道，P2SH的脚本如下： &lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &gt; OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL 这里的 scriptSig是&nbsp;&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;，&nbsp;scriptPubKey是 OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL bool VerifyScript(const CScript&amp; scriptSig, const CScript&amp; scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker&amp; checker, ScriptError* serror) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::vector&lt;unsigned char&gt; &gt; stack, stackCopy; &nbsp; &nbsp; //执行解锁脚本，执行完后stack中有了&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp; &nbsp; //这三个数据对象 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //解锁脚本执行后 &nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; SCRIPT_VERIFY_P2SH ) &nbsp; &nbsp; &nbsp; &nbsp; //由于下面EvalScript会破坏stack,而再后面仍然需要stack当前的数据，因而需要做一次拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackCopy = stack; &nbsp; &nbsp; //执行锁定脚本&nbsp;OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL &nbsp; &nbsp; //就是将&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;数据做hash160,然后和锁定脚本中的hash比较 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //这一步结束后，hash160被验证通过了，此时栈只剩下&lt;Sig1&gt; &lt;Sig2&gt; &nbsp;&nbsp;&nbsp;&nbsp;// Additional validation for spend-to-script-hash transactions: &nbsp; &nbsp; //上一章节我们提到过，P2SH需要执行两次脚本验证，即还有子锁定脚本，下面就是在做这个事 &nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; SCRIPT_VERIFY_P2SH) &amp;&amp; scriptPubKey.IsPayToScriptHash()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// scriptSig must be literals-only or validation fails &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!scriptSig.IsPushOnly()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Restore stack. &nbsp; &nbsp; &nbsp; &nbsp; // hash160验证后，堆栈只剩下subscript.scriptSig了，我们换需要subscript.scriptPubKey &nbsp; &nbsp; &nbsp; &nbsp; // 恢复前面保存下来的栈可以做到这一点，恢复后的栈结构. subscript.scriptSig + subscript.scriptPubKey_(_代表被序列化了，文本化了)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//即&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(stack, stackCopy); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stack cannot be empty here, because if it was the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// P2SH&nbsp;&nbsp;HASH &lt;&gt; EQUAL&nbsp;&nbsp;scriptPubKey would be evaluated with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an empty stack and the EvalScript above would return false. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!stack.empty()); &nbsp; &nbsp; &nbsp; &nbsp; //从栈顶拿出subscript.scriptPubKey的脚本文本，并构建CScript对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const valtype&amp; pubKeySerialized = stack.back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end()); &nbsp; &nbsp; &nbsp; &nbsp; //到这里后，已经恢复出完整多签名子脚本了&lt;Sig1&gt; &lt;Sig2&gt;&nbsp;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp; &nbsp; &nbsp; &nbsp; //将subscript.scriptPubKey_文本弹出 &nbsp; &nbsp; &nbsp; &nbsp; //这一步相当于执行evalScript(subscript.scriptSig) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popstack(stack); &nbsp; &nbsp; &nbsp; &nbsp; //然后evalScript(subscript.scriptPubKey) &nbsp; &nbsp; &nbsp; &nbsp; //验证给的pubkey是否能够被解锁 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return set_success(serror); } bool EvalScript (std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror) { &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pend = script.end(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pbegincodehash = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode; &nbsp;&nbsp;&nbsp;&nbsp;valtype vchPushValue; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;bool&gt; vfExec; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; altstack; &nbsp;&nbsp;&nbsp;&nbsp;try &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (pc &lt; pend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fExec = !count(vfExec.begin(), vfExec.end(), false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//脚本执行就是不停GetOp然后case处理的过程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script.GetOp(pc, opcode, vchPushValue)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_BAD_OPCODE); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note how OP_RESERVED does not count towards the opcode limit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &gt; OP_16 &amp;&amp; ++nOpCount &gt; MAX_OPS_PER_SCRIPT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_OP_COUNT); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( opcode == OP_CAT || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_SUBSTR || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_RSHIFT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fExec &amp;&amp; 0 &lt;= opcode &amp;&amp; opcode &lt;= OP_PUSHDATA4) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fRequireMinimal &amp;&amp; !CheckMinimalPush(vchPushValue, opcode)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_MINIMALDATA); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(vchPushValue); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (fExec || (OP_IF &lt;= opcode &amp;&amp; opcode &lt;= OP_ENDIF)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (opcode) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Push value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;case OP_1NEGATE: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_15: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_16: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ( -- value) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScriptNum bn((int)opcode - (int)(OP_1 - 1)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(bn.getvch()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The result of these opcodes should always be the minimal way to push the data &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// they push, so no need for a CheckMinimalPush here. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;….. &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;catch (...) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR); &nbsp;&nbsp;&nbsp;&nbsp;} } 从上可知，目前实现的执行多次脚本验证不是一个通用方案，而是通过检测脚本类型(P2SH)而做的特殊处理,只支持P2SH这个类型的脚本类型 P2SH锁定脚本scriptSig生成 下面来看看p2sh的scriptSig怎么生成的 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; result; &nbsp;&nbsp;&nbsp;&nbsp;txnouttype whichType; &nbsp; &nbsp; //这里会检测出fromPubKey是P2SH脚本，然后就会返回对应的Redeemscript给result当做scriptSig &nbsp;&nbsp;&nbsp;&nbsp;bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE); &nbsp;&nbsp;&nbsp;&nbsp;bool P2SH = false; &nbsp;&nbsp;&nbsp;&nbsp;CScript subscript; &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptWitness.stack.clear(); &nbsp; &nbsp; //第一次SignStep执行后 whichType == TX_SCRIPTHASH &nbsp; &nbsp; //得到的result为 Redeemscript的序列化文本 &nbsp;&nbsp;&nbsp;&nbsp;if (solved &amp;&amp; whichType == TX_SCRIPTHASH) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Solver returns the subscript that needs to be evaluated; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the final scriptSig is the signatures from that &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and then the serialized subscript: &nbsp; &nbsp; &nbsp; &nbsp; //这里将Redeemscript文本反序列化为多签名锁定脚本 &nbsp; &nbsp; &nbsp; &nbsp; //2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subscript = CScript(result[0].begin(), result[0].end()); &nbsp; &nbsp; &nbsp; &nbsp; //第二次SignStep会将作为pubKey的 subscript解释为multsig脚本，然后会返回 &lt; Sig1 &gt; &nbsp; &lt; Sig2 &gt; 数据 到result当做scriptSig &nbsp; &nbsp; &nbsp; &nbsp; solved = solved &amp;&amp; SignStep(creator, subscript, result, whichType, SigVersion::BASE) &amp;&amp; whichType != TX_SCRIPTHASH; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2SH = true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //上面result里不是已经有subscript了啊，为啥要再次push_back呢 &nbsp; &nbsp; //因为SignStep函数每次都会清空result数据，所以需要再次push_back subscript数据 &nbsp;&nbsp;&nbsp;&nbsp;if (P2SH) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //将真正的scriptSig返回 &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptSig = PushAll(result); } static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //这里会返回 Redeemscript作为scriptSig解锁脚本 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; } } bool CBasicKeyStore::GetCScript(const CScriptID &amp;hash, CScript&amp; redeemScriptOut) const { &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;ScriptMap::const_iterator mi = mapScripts.find(hash); &nbsp;&nbsp;&nbsp;&nbsp;if (mi != mapScripts.end()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redeemScriptOut = (*mi).second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return false; } 其实，还有一个疑问点，就是怎么根据P2SH的锁定脚本数据找到解锁脚本Redeemscript脚本的呢? P2SH的锁定脚本数据有用的数据只有hash值，也即是如何通过hash找到Redeemscript脚本的呢？ 仔细看的话，应该能看出一些端倪，就是mapScripts维护了一个hash和具体Redeemscript类型的scriptSig脚本的map关系.那你可能会说，整个链上这么多P2SH交易，hash就会很多，那这个mapScripts得多大啊。由于P2SH这个hash是&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;生成的，所以只有属于本地节点多账号签名生成的P2SH才需要添加到mapScripts.且肯定是先有多签名账号才有P2SH交易，因此只需要在创建多账号签名的点创建对应的Redeemscript并保存在mapScripts即可，事实上确实如此，流程如下。 UniValue addmultisigaddress(const JSONRPCRequest&amp; request) &nbsp;&nbsp;&nbsp;&nbsp;// Construct using pay-to-script-hash: &nbsp;&nbsp;&nbsp;&nbsp;CScript inner = CreateMultisigRedeemscript(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;pwallet-&gt;AddCScript(inner); } // Creates a multisig redeemscript from a given list of public keys and number required. CScript CreateMultisigRedeemscript(const int required, const std::vector&lt;CPubKey&gt;&amp; pubkeys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript result = GetScriptForMultisig(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;return result; } CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript script; &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(nRequired); &nbsp;&nbsp;&nbsp;&nbsp;for (const CPubKey&amp; key : keys) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; ToByteVector(key); &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; &nbsp;&nbsp;&nbsp;&nbsp;return script; } bool CBasicKeyStore::AddCScript(const CScript&amp; redeemScript) { &nbsp;&nbsp;&nbsp;&nbsp;if (redeemScript.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;CBasicKeyStore::AddCScript(): redeemScripts &gt; %i bytes are invalid&quot;, MAX_SCRIPT_ELEMENT_SIZE); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;mapScripts[CScriptID(redeemScript)] = redeemScript; &nbsp;&nbsp;&nbsp;&nbsp;return true; } Solver函数 &nbsp;&nbsp; &nbsp;上面在分析P2SH的scriptSig就提到过Resolver，那Solver函数究竟做啥用的，它是用来解释scriptPubKey的，比如解释出scriptPubKey是什么类型的脚本，比如分析出判断一个scriptPubKey是否是P2SH,检验数据的合法性并取出 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) { &nbsp;&nbsp;&nbsp;&nbsp;// Templates &nbsp;&nbsp;&nbsp;&nbsp;static std::multimap&lt;txnouttype, CScript&gt; mTemplates; &nbsp;&nbsp;&nbsp;&nbsp;if (mTemplates.empty()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Standard tx, sender provides pubkey, receiver adds signature &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sender provides N pubkeys, receivers provides M signatures &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp; &nbsp; //解释scriptPubkey的过程就是将scriptPubkey和模板对比，同时取出里面的数据比如 &nbsp;&nbsp;&nbsp;&nbsp;// Scan templates &nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script1 = scriptPubKey; &nbsp;&nbsp;&nbsp;&nbsp;for (const std::pair&lt;txnouttype, CScript&gt;&amp; tplate : mTemplates) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script2 = tplate.second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode1, opcode2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned char&gt; vch1, vch2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compare &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc1 = script1.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc2 = script2.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc1 == script1.end() &amp;&amp; pc2 == script2.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Found a match &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeRet = tplate.first; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeRet == TX_MULTISIG) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Additional checks for TX_MULTISIG: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char m = vSolutionsRet.front()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char n = vSolutionsRet.back()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m &lt; 1 || n &lt; 1 || m &gt; n || vSolutionsRet.size()-2 != n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Template matching opcodes: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEYS) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (vch1.size() &gt;= 33 &amp;&amp; vch1.size() &lt;= 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normal situation is to fall through &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to other if/else statements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEY) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() &lt; 33 || vch1.size() &gt; 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode2 == OP_PUBKEYHASH) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() != sizeof(uint160)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode1 != opcode2 || vch1 != vch2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Others must match exactly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;typeRet = TX_NONSTANDARD; &nbsp;&nbsp;&nbsp;&nbsp;return false; } 附录: 脚本指令解释过程分析 &nbsp;上面在分析道evalScript执行函数时提到 脚本执行就是不停GetOp然后case处理的过程，下面就来分析下GetOp &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp(const_iterator&amp; pc, opcodetype&amp; opcodeRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return GetOp2(pc, opcodeRet, nullptr); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp2(const_iterator&amp; pc, opcodetype&amp; opcodeRet, std::vector&lt;unsigned char&gt;* pvchRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = OP_INVALIDOPCODE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc &gt;= end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; //第一字节为指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int opcode = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Immediate operand &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt;= OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nSize = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //[0x4] sig, 这类指令,&nbsp;opcode就是size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt; OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = opcode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = ReadLE16(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//进一步读取数据size数值, OP_PUSHDATA4 [xx][xx][xx][xx] &lt;largedata&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = ReadLE32(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 0 || (unsigned int)(end() - pc) &lt; nSize) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //读取真正的数据内容 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;assign(pc, pc + nSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += nSize; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = static_cast&lt;opcodetype&gt;(opcode); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} 其他脚本的scriptSig生成 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_NONSTANDARD: &nbsp;&nbsp;&nbsp;&nbsp;case TX_NULL_DATA: &nbsp;&nbsp;&nbsp;&nbsp;case TX_WITNESS_UNKNOWN: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEY: &nbsp; &nbsp; &nbsp; &nbsp; //P2PK模板 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyID = CPubKey(vSolutions[0]).GetID(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Sign1(keyID, creator, scriptPubKey, ret, sigversion); &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEYHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2PKH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyID = CKeyID(uint160(vSolutions[0])); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPubKey vch; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creator.Provider().GetPubKey(keyID, vch); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(ToByteVector(vch)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2SH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_MULTISIG: &nbsp; &nbsp; &nbsp; &nbsp; //MS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(valtype()); // workaround CHECKMULTISIG bug &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<meta property="og:description" content="&nbsp; &nbsp; 通过上一篇的分析，我们应该已经对script有了一定的理解，这章节我们以源码分析的方式来了解下脚本验证执行流程 &nbsp;&nbsp; &nbsp;bitcoin节点在处理一条交易时就需要验证交易的txin，由于一条交易可能包含多个txin,因而需要执行多个脚本验证，自然需要并行化，因而系统允许定义多个脚本执行线程以加速验证过程。有了这个思考，我们从脚本执行线程出发 剥茧抽丝掀开脚本执行的面纱。 &nbsp; &nbsp; 先看脚本执行线程的初始化，这个在init.cpp的AppInitMain里 脚本验证执行线程 &nbsp;&nbsp;&nbsp;&nbsp;LogPrintf(&quot;Using %u threads for script verification\n&quot;, nScriptCheckThreads); &nbsp;&nbsp;&nbsp;&nbsp;if (nScriptCheckThreads) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//根据参数创建对应数量的脚本执行线程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nScriptCheckThreads-1; i++) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadGroup.create_thread(&amp;ThreadScriptCheck); &nbsp;&nbsp;&nbsp;&nbsp;} 线程的具体实现函数在 validataion.cpp static CCheckQueue&lt;CScriptCheck&gt; scriptcheckqueue (128); void ThreadScriptCheck () { &nbsp;&nbsp;&nbsp;&nbsp;RenameThread(&quot;bitcoin-scriptch&quot;); &nbsp;&nbsp;&nbsp;&nbsp;scriptcheckqueue.Thread(); } class CCheckQueue { &nbsp;&nbsp;//! Worker thread &nbsp; void Thread() &nbsp; &nbsp;// CCheckQueue.Thread() &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loop(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; bool Loop(bool fMaster = false) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::condition_variable&amp; cond = fMaster ? condMaster : condWorker; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;T&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.reserve(nBatchSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nNow = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fOk = true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;…………….. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Decide how many work units to process now. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Do not try to do everything at once, but aim for increasingly smaller batches so &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;all workers finish approximately simultaneously. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Try to account for idle jobs which will instantly start helping. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Don&#39;t do batches smaller than 1 (duh), or larger than nBatchSize. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1))); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.resize(nNow); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; nNow; i++) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We want the lock on the mutex to be as short as possible, so swap jobs from the global &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// queue to the local batch vector instead of copying. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 该线程选取一定量的脚本待执行对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks[i].swap( queue.back ()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.pop_back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check whether we need to do work at all &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = fAllOk; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// execute work &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (T&amp; check : vChecks) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fOk) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //check()函数就是 CScriptCheck::operator()() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = check(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while (true); &nbsp;&nbsp;&nbsp;&nbsp;} 添加脚本验证对象 &nbsp;&nbsp;//发现新块并处理交易时会验证脚本 bool CChainState:: ConnectBlock (const CBlock&amp; block, CValidationState&amp; state, CBlockIndex* pindex, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewCache&amp; view, const CChainParams&amp; chainparams, bool fJustCheck) { &nbsp;&nbsp;&nbsp;&nbsp;AssertLockHeld(cs_main); &nbsp;&nbsp; &nbsp; CCheckQueueControl&lt;CScriptCheck&gt; control (fScriptChecks &amp;&amp; nScriptCheckThreads ? &amp;scriptcheckqueue : nullptr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CScriptCheck&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fCacheResults = fJustCheck; /* Don&#39;t cache results if we&#39;re actually connecting blocks (still consult the cache, though) */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &amp;vChecks : nullptr)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;ConnectBlock(): CheckInputs on %s failed with %s&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.GetHash().ToString(), FormatStateMessage(state)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //control负责将某一个具体的验证执行对象添加到队列中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.Add(vChecks); } class CCheckQueueControl { &nbsp;&nbsp;&nbsp;&nbsp;void Add(std::vector&lt;T&gt;&amp; vChecks) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pqueue != nullptr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pqueue-&gt;Add(vChecks); &nbsp;&nbsp;&nbsp;&nbsp;} } 脚本验证执行函数 上面可知脚本验证线程最终会执行 CScriptCheck::operator bool CScriptCheck::operator()() { &nbsp;&nbsp;&nbsp;&nbsp;const CScript &amp;scriptSig = ptxTo-&gt;vin[nIn].scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;const CScriptWitness *witness = &amp;ptxTo-&gt;vin[nIn].scriptWitness; &nbsp;&nbsp;&nbsp;&nbsp;return VerifyScript (scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &amp;error); } P2SH脚本验证源码分析 为了更完整的分析该过程，我以最复杂的脚本模板P2SH为例分析，从上一章接的介绍我们知道，P2SH的脚本如下： &lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &gt; OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL 这里的 scriptSig是&nbsp;&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;，&nbsp;scriptPubKey是 OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL bool VerifyScript(const CScript&amp; scriptSig, const CScript&amp; scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker&amp; checker, ScriptError* serror) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::vector&lt;unsigned char&gt; &gt; stack, stackCopy; &nbsp; &nbsp; //执行解锁脚本，执行完后stack中有了&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp; &nbsp; //这三个数据对象 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //解锁脚本执行后 &nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; SCRIPT_VERIFY_P2SH ) &nbsp; &nbsp; &nbsp; &nbsp; //由于下面EvalScript会破坏stack,而再后面仍然需要stack当前的数据，因而需要做一次拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackCopy = stack; &nbsp; &nbsp; //执行锁定脚本&nbsp;OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL &nbsp; &nbsp; //就是将&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;数据做hash160,然后和锁定脚本中的hash比较 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //这一步结束后，hash160被验证通过了，此时栈只剩下&lt;Sig1&gt; &lt;Sig2&gt; &nbsp;&nbsp;&nbsp;&nbsp;// Additional validation for spend-to-script-hash transactions: &nbsp; &nbsp; //上一章节我们提到过，P2SH需要执行两次脚本验证，即还有子锁定脚本，下面就是在做这个事 &nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; SCRIPT_VERIFY_P2SH) &amp;&amp; scriptPubKey.IsPayToScriptHash()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// scriptSig must be literals-only or validation fails &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!scriptSig.IsPushOnly()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Restore stack. &nbsp; &nbsp; &nbsp; &nbsp; // hash160验证后，堆栈只剩下subscript.scriptSig了，我们换需要subscript.scriptPubKey &nbsp; &nbsp; &nbsp; &nbsp; // 恢复前面保存下来的栈可以做到这一点，恢复后的栈结构. subscript.scriptSig + subscript.scriptPubKey_(_代表被序列化了，文本化了)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//即&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(stack, stackCopy); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stack cannot be empty here, because if it was the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// P2SH&nbsp;&nbsp;HASH &lt;&gt; EQUAL&nbsp;&nbsp;scriptPubKey would be evaluated with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an empty stack and the EvalScript above would return false. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!stack.empty()); &nbsp; &nbsp; &nbsp; &nbsp; //从栈顶拿出subscript.scriptPubKey的脚本文本，并构建CScript对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const valtype&amp; pubKeySerialized = stack.back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end()); &nbsp; &nbsp; &nbsp; &nbsp; //到这里后，已经恢复出完整多签名子脚本了&lt;Sig1&gt; &lt;Sig2&gt;&nbsp;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp; &nbsp; &nbsp; &nbsp; //将subscript.scriptPubKey_文本弹出 &nbsp; &nbsp; &nbsp; &nbsp; //这一步相当于执行evalScript(subscript.scriptSig) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popstack(stack); &nbsp; &nbsp; &nbsp; &nbsp; //然后evalScript(subscript.scriptPubKey) &nbsp; &nbsp; &nbsp; &nbsp; //验证给的pubkey是否能够被解锁 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return set_success(serror); } bool EvalScript (std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror) { &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pend = script.end(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pbegincodehash = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode; &nbsp;&nbsp;&nbsp;&nbsp;valtype vchPushValue; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;bool&gt; vfExec; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; altstack; &nbsp;&nbsp;&nbsp;&nbsp;try &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (pc &lt; pend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fExec = !count(vfExec.begin(), vfExec.end(), false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//脚本执行就是不停GetOp然后case处理的过程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script.GetOp(pc, opcode, vchPushValue)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_BAD_OPCODE); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note how OP_RESERVED does not count towards the opcode limit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &gt; OP_16 &amp;&amp; ++nOpCount &gt; MAX_OPS_PER_SCRIPT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_OP_COUNT); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( opcode == OP_CAT || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_SUBSTR || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_RSHIFT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fExec &amp;&amp; 0 &lt;= opcode &amp;&amp; opcode &lt;= OP_PUSHDATA4) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fRequireMinimal &amp;&amp; !CheckMinimalPush(vchPushValue, opcode)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_MINIMALDATA); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(vchPushValue); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (fExec || (OP_IF &lt;= opcode &amp;&amp; opcode &lt;= OP_ENDIF)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (opcode) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Push value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;case OP_1NEGATE: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_15: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_16: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ( -- value) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScriptNum bn((int)opcode - (int)(OP_1 - 1)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(bn.getvch()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The result of these opcodes should always be the minimal way to push the data &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// they push, so no need for a CheckMinimalPush here. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;….. &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;catch (...) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR); &nbsp;&nbsp;&nbsp;&nbsp;} } 从上可知，目前实现的执行多次脚本验证不是一个通用方案，而是通过检测脚本类型(P2SH)而做的特殊处理,只支持P2SH这个类型的脚本类型 P2SH锁定脚本scriptSig生成 下面来看看p2sh的scriptSig怎么生成的 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; result; &nbsp;&nbsp;&nbsp;&nbsp;txnouttype whichType; &nbsp; &nbsp; //这里会检测出fromPubKey是P2SH脚本，然后就会返回对应的Redeemscript给result当做scriptSig &nbsp;&nbsp;&nbsp;&nbsp;bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE); &nbsp;&nbsp;&nbsp;&nbsp;bool P2SH = false; &nbsp;&nbsp;&nbsp;&nbsp;CScript subscript; &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptWitness.stack.clear(); &nbsp; &nbsp; //第一次SignStep执行后 whichType == TX_SCRIPTHASH &nbsp; &nbsp; //得到的result为 Redeemscript的序列化文本 &nbsp;&nbsp;&nbsp;&nbsp;if (solved &amp;&amp; whichType == TX_SCRIPTHASH) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Solver returns the subscript that needs to be evaluated; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the final scriptSig is the signatures from that &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and then the serialized subscript: &nbsp; &nbsp; &nbsp; &nbsp; //这里将Redeemscript文本反序列化为多签名锁定脚本 &nbsp; &nbsp; &nbsp; &nbsp; //2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subscript = CScript(result[0].begin(), result[0].end()); &nbsp; &nbsp; &nbsp; &nbsp; //第二次SignStep会将作为pubKey的 subscript解释为multsig脚本，然后会返回 &lt; Sig1 &gt; &nbsp; &lt; Sig2 &gt; 数据 到result当做scriptSig &nbsp; &nbsp; &nbsp; &nbsp; solved = solved &amp;&amp; SignStep(creator, subscript, result, whichType, SigVersion::BASE) &amp;&amp; whichType != TX_SCRIPTHASH; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2SH = true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //上面result里不是已经有subscript了啊，为啥要再次push_back呢 &nbsp; &nbsp; //因为SignStep函数每次都会清空result数据，所以需要再次push_back subscript数据 &nbsp;&nbsp;&nbsp;&nbsp;if (P2SH) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //将真正的scriptSig返回 &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptSig = PushAll(result); } static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //这里会返回 Redeemscript作为scriptSig解锁脚本 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; } } bool CBasicKeyStore::GetCScript(const CScriptID &amp;hash, CScript&amp; redeemScriptOut) const { &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;ScriptMap::const_iterator mi = mapScripts.find(hash); &nbsp;&nbsp;&nbsp;&nbsp;if (mi != mapScripts.end()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redeemScriptOut = (*mi).second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return false; } 其实，还有一个疑问点，就是怎么根据P2SH的锁定脚本数据找到解锁脚本Redeemscript脚本的呢? P2SH的锁定脚本数据有用的数据只有hash值，也即是如何通过hash找到Redeemscript脚本的呢？ 仔细看的话，应该能看出一些端倪，就是mapScripts维护了一个hash和具体Redeemscript类型的scriptSig脚本的map关系.那你可能会说，整个链上这么多P2SH交易，hash就会很多，那这个mapScripts得多大啊。由于P2SH这个hash是&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;生成的，所以只有属于本地节点多账号签名生成的P2SH才需要添加到mapScripts.且肯定是先有多签名账号才有P2SH交易，因此只需要在创建多账号签名的点创建对应的Redeemscript并保存在mapScripts即可，事实上确实如此，流程如下。 UniValue addmultisigaddress(const JSONRPCRequest&amp; request) &nbsp;&nbsp;&nbsp;&nbsp;// Construct using pay-to-script-hash: &nbsp;&nbsp;&nbsp;&nbsp;CScript inner = CreateMultisigRedeemscript(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;pwallet-&gt;AddCScript(inner); } // Creates a multisig redeemscript from a given list of public keys and number required. CScript CreateMultisigRedeemscript(const int required, const std::vector&lt;CPubKey&gt;&amp; pubkeys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript result = GetScriptForMultisig(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;return result; } CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript script; &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(nRequired); &nbsp;&nbsp;&nbsp;&nbsp;for (const CPubKey&amp; key : keys) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; ToByteVector(key); &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; &nbsp;&nbsp;&nbsp;&nbsp;return script; } bool CBasicKeyStore::AddCScript(const CScript&amp; redeemScript) { &nbsp;&nbsp;&nbsp;&nbsp;if (redeemScript.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;CBasicKeyStore::AddCScript(): redeemScripts &gt; %i bytes are invalid&quot;, MAX_SCRIPT_ELEMENT_SIZE); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;mapScripts[CScriptID(redeemScript)] = redeemScript; &nbsp;&nbsp;&nbsp;&nbsp;return true; } Solver函数 &nbsp;&nbsp; &nbsp;上面在分析P2SH的scriptSig就提到过Resolver，那Solver函数究竟做啥用的，它是用来解释scriptPubKey的，比如解释出scriptPubKey是什么类型的脚本，比如分析出判断一个scriptPubKey是否是P2SH,检验数据的合法性并取出 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) { &nbsp;&nbsp;&nbsp;&nbsp;// Templates &nbsp;&nbsp;&nbsp;&nbsp;static std::multimap&lt;txnouttype, CScript&gt; mTemplates; &nbsp;&nbsp;&nbsp;&nbsp;if (mTemplates.empty()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Standard tx, sender provides pubkey, receiver adds signature &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sender provides N pubkeys, receivers provides M signatures &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp; &nbsp; //解释scriptPubkey的过程就是将scriptPubkey和模板对比，同时取出里面的数据比如 &nbsp;&nbsp;&nbsp;&nbsp;// Scan templates &nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script1 = scriptPubKey; &nbsp;&nbsp;&nbsp;&nbsp;for (const std::pair&lt;txnouttype, CScript&gt;&amp; tplate : mTemplates) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script2 = tplate.second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode1, opcode2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned char&gt; vch1, vch2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compare &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc1 = script1.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc2 = script2.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc1 == script1.end() &amp;&amp; pc2 == script2.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Found a match &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeRet = tplate.first; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeRet == TX_MULTISIG) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Additional checks for TX_MULTISIG: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char m = vSolutionsRet.front()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char n = vSolutionsRet.back()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m &lt; 1 || n &lt; 1 || m &gt; n || vSolutionsRet.size()-2 != n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Template matching opcodes: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEYS) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (vch1.size() &gt;= 33 &amp;&amp; vch1.size() &lt;= 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normal situation is to fall through &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to other if/else statements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEY) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() &lt; 33 || vch1.size() &gt; 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode2 == OP_PUBKEYHASH) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() != sizeof(uint160)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode1 != opcode2 || vch1 != vch2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Others must match exactly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;typeRet = TX_NONSTANDARD; &nbsp;&nbsp;&nbsp;&nbsp;return false; } 附录: 脚本指令解释过程分析 &nbsp;上面在分析道evalScript执行函数时提到 脚本执行就是不停GetOp然后case处理的过程，下面就来分析下GetOp &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp(const_iterator&amp; pc, opcodetype&amp; opcodeRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return GetOp2(pc, opcodeRet, nullptr); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp2(const_iterator&amp; pc, opcodetype&amp; opcodeRet, std::vector&lt;unsigned char&gt;* pvchRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = OP_INVALIDOPCODE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc &gt;= end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; //第一字节为指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int opcode = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Immediate operand &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt;= OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nSize = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //[0x4] sig, 这类指令,&nbsp;opcode就是size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt; OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = opcode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = ReadLE16(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//进一步读取数据size数值, OP_PUSHDATA4 [xx][xx][xx][xx] &lt;largedata&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = ReadLE32(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 0 || (unsigned int)(end() - pc) &lt; nSize) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //读取真正的数据内容 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;assign(pc, pc + nSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += nSize; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = static_cast&lt;opcodetype&gt;(opcode); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} 其他脚本的scriptSig生成 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_NONSTANDARD: &nbsp;&nbsp;&nbsp;&nbsp;case TX_NULL_DATA: &nbsp;&nbsp;&nbsp;&nbsp;case TX_WITNESS_UNKNOWN: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEY: &nbsp; &nbsp; &nbsp; &nbsp; //P2PK模板 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyID = CPubKey(vSolutions[0]).GetID(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Sign1(keyID, creator, scriptPubKey, ret, sigversion); &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEYHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2PKH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyID = CKeyID(uint160(vSolutions[0])); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPubKey vch; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creator.Provider().GetPubKey(keyID, vch); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(ToByteVector(vch)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2SH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_MULTISIG: &nbsp; &nbsp; &nbsp; &nbsp; //MS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(valtype()); // workaround CHECKMULTISIG bug &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; &nbsp; 通过上一篇的分析，我们应该已经对script有了一定的理解，这章节我们以源码分析的方式来了解下脚本验证执行流程 &nbsp;&nbsp; &nbsp;bitcoin节点在处理一条交易时就需要验证交易的txin，由于一条交易可能包含多个txin,因而需要执行多个脚本验证，自然需要并行化，因而系统允许定义多个脚本执行线程以加速验证过程。有了这个思考，我们从脚本执行线程出发 剥茧抽丝掀开脚本执行的面纱。 &nbsp; &nbsp; 先看脚本执行线程的初始化，这个在init.cpp的AppInitMain里 脚本验证执行线程 &nbsp;&nbsp;&nbsp;&nbsp;LogPrintf(&quot;Using %u threads for script verification\\n&quot;, nScriptCheckThreads); &nbsp;&nbsp;&nbsp;&nbsp;if (nScriptCheckThreads) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//根据参数创建对应数量的脚本执行线程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nScriptCheckThreads-1; i++) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadGroup.create_thread(&amp;ThreadScriptCheck); &nbsp;&nbsp;&nbsp;&nbsp;} 线程的具体实现函数在 validataion.cpp static CCheckQueue&lt;CScriptCheck&gt; scriptcheckqueue (128); void ThreadScriptCheck () { &nbsp;&nbsp;&nbsp;&nbsp;RenameThread(&quot;bitcoin-scriptch&quot;); &nbsp;&nbsp;&nbsp;&nbsp;scriptcheckqueue.Thread(); } class CCheckQueue { &nbsp;&nbsp;//! Worker thread &nbsp; void Thread() &nbsp; &nbsp;// CCheckQueue.Thread() &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loop(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; bool Loop(bool fMaster = false) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::condition_variable&amp; cond = fMaster ? condMaster : condWorker; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;T&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.reserve(nBatchSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nNow = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fOk = true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;…………….. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Decide how many work units to process now. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Do not try to do everything at once, but aim for increasingly smaller batches so &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;all workers finish approximately simultaneously. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Try to account for idle jobs which will instantly start helping. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Don&#39;t do batches smaller than 1 (duh), or larger than nBatchSize. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1))); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.resize(nNow); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; nNow; i++) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We want the lock on the mutex to be as short as possible, so swap jobs from the global &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// queue to the local batch vector instead of copying. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 该线程选取一定量的脚本待执行对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks[i].swap( queue.back ()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.pop_back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check whether we need to do work at all &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = fAllOk; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// execute work &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (T&amp; check : vChecks) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fOk) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //check()函数就是 CScriptCheck::operator()() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = check(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while (true); &nbsp;&nbsp;&nbsp;&nbsp;} 添加脚本验证对象 &nbsp;&nbsp;//发现新块并处理交易时会验证脚本 bool CChainState:: ConnectBlock (const CBlock&amp; block, CValidationState&amp; state, CBlockIndex* pindex, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewCache&amp; view, const CChainParams&amp; chainparams, bool fJustCheck) { &nbsp;&nbsp;&nbsp;&nbsp;AssertLockHeld(cs_main); &nbsp;&nbsp; &nbsp; CCheckQueueControl&lt;CScriptCheck&gt; control (fScriptChecks &amp;&amp; nScriptCheckThreads ? &amp;scriptcheckqueue : nullptr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CScriptCheck&gt; vChecks; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fCacheResults = fJustCheck; /* Don&#39;t cache results if we&#39;re actually connecting blocks (still consult the cache, though) */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &amp;vChecks : nullptr)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;ConnectBlock(): CheckInputs on %s failed with %s&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.GetHash().ToString(), FormatStateMessage(state)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //control负责将某一个具体的验证执行对象添加到队列中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.Add(vChecks); } class CCheckQueueControl { &nbsp;&nbsp;&nbsp;&nbsp;void Add(std::vector&lt;T&gt;&amp; vChecks) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pqueue != nullptr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pqueue-&gt;Add(vChecks); &nbsp;&nbsp;&nbsp;&nbsp;} } 脚本验证执行函数 上面可知脚本验证线程最终会执行 CScriptCheck::operator bool CScriptCheck::operator()() { &nbsp;&nbsp;&nbsp;&nbsp;const CScript &amp;scriptSig = ptxTo-&gt;vin[nIn].scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;const CScriptWitness *witness = &amp;ptxTo-&gt;vin[nIn].scriptWitness; &nbsp;&nbsp;&nbsp;&nbsp;return VerifyScript (scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &amp;error); } P2SH脚本验证源码分析 为了更完整的分析该过程，我以最复杂的脚本模板P2SH为例分析，从上一章接的介绍我们知道，P2SH的脚本如下： &lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &gt; OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL 这里的 scriptSig是&nbsp;&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;，&nbsp;scriptPubKey是 OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL bool VerifyScript(const CScript&amp; scriptSig, const CScript&amp; scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker&amp; checker, ScriptError* serror) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::vector&lt;unsigned char&gt; &gt; stack, stackCopy; &nbsp; &nbsp; //执行解锁脚本，执行完后stack中有了&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp; &nbsp; //这三个数据对象 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //解锁脚本执行后 &nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; SCRIPT_VERIFY_P2SH ) &nbsp; &nbsp; &nbsp; &nbsp; //由于下面EvalScript会破坏stack,而再后面仍然需要stack当前的数据，因而需要做一次拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackCopy = stack; &nbsp; &nbsp; //执行锁定脚本&nbsp;OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL &nbsp; &nbsp; //就是将&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;数据做hash160,然后和锁定脚本中的hash比较 &nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; //这一步结束后，hash160被验证通过了，此时栈只剩下&lt;Sig1&gt; &lt;Sig2&gt; &nbsp;&nbsp;&nbsp;&nbsp;// Additional validation for spend-to-script-hash transactions: &nbsp; &nbsp; //上一章节我们提到过，P2SH需要执行两次脚本验证，即还有子锁定脚本，下面就是在做这个事 &nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; SCRIPT_VERIFY_P2SH) &amp;&amp; scriptPubKey.IsPayToScriptHash()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// scriptSig must be literals-only or validation fails &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!scriptSig.IsPushOnly()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Restore stack. &nbsp; &nbsp; &nbsp; &nbsp; // hash160验证后，堆栈只剩下subscript.scriptSig了，我们换需要subscript.scriptPubKey &nbsp; &nbsp; &nbsp; &nbsp; // 恢复前面保存下来的栈可以做到这一点，恢复后的栈结构. subscript.scriptSig + subscript.scriptPubKey_(_代表被序列化了，文本化了)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//即&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(stack, stackCopy); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stack cannot be empty here, because if it was the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// P2SH&nbsp;&nbsp;HASH &lt;&gt; EQUAL&nbsp;&nbsp;scriptPubKey would be evaluated with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an empty stack and the EvalScript above would return false. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!stack.empty()); &nbsp; &nbsp; &nbsp; &nbsp; //从栈顶拿出subscript.scriptPubKey的脚本文本，并构建CScript对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const valtype&amp; pubKeySerialized = stack.back(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end()); &nbsp; &nbsp; &nbsp; &nbsp; //到这里后，已经恢复出完整多签名子脚本了&lt;Sig1&gt; &lt;Sig2&gt;&nbsp;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp; &nbsp; &nbsp; &nbsp; //将subscript.scriptPubKey_文本弹出 &nbsp; &nbsp; &nbsp; &nbsp; //这一步相当于执行evalScript(subscript.scriptSig) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popstack(stack); &nbsp; &nbsp; &nbsp; &nbsp; //然后evalScript(subscript.scriptPubKey) &nbsp; &nbsp; &nbsp; &nbsp; //验证给的pubkey是否能够被解锁 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return set_success(serror); } bool EvalScript (std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror) { &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pend = script.end(); &nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pbegincodehash = script.begin(); &nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode; &nbsp;&nbsp;&nbsp;&nbsp;valtype vchPushValue; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;bool&gt; vfExec; &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; altstack; &nbsp;&nbsp;&nbsp;&nbsp;try &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (pc &lt; pend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fExec = !count(vfExec.begin(), vfExec.end(), false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//脚本执行就是不停GetOp然后case处理的过程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script.GetOp(pc, opcode, vchPushValue)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_BAD_OPCODE); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note how OP_RESERVED does not count towards the opcode limit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &gt; OP_16 &amp;&amp; ++nOpCount &gt; MAX_OPS_PER_SCRIPT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_OP_COUNT); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( opcode == OP_CAT || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_SUBSTR || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_RSHIFT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fExec &amp;&amp; 0 &lt;= opcode &amp;&amp; opcode &lt;= OP_PUSHDATA4) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fRequireMinimal &amp;&amp; !CheckMinimalPush(vchPushValue, opcode)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_MINIMALDATA); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(vchPushValue); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (fExec || (OP_IF &lt;= opcode &amp;&amp; opcode &lt;= OP_ENDIF)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (opcode) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Push value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;case OP_1NEGATE: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_15: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_16: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ( -- value) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScriptNum bn((int)opcode - (int)(OP_1 - 1)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(bn.getvch()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The result of these opcodes should always be the minimal way to push the data &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// they push, so no need for a CheckMinimalPush here. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;….. &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;catch (...) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR); &nbsp;&nbsp;&nbsp;&nbsp;} } 从上可知，目前实现的执行多次脚本验证不是一个通用方案，而是通过检测脚本类型(P2SH)而做的特殊处理,只支持P2SH这个类型的脚本类型 P2SH锁定脚本scriptSig生成 下面来看看p2sh的scriptSig怎么生成的 bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata) { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; result; &nbsp;&nbsp;&nbsp;&nbsp;txnouttype whichType; &nbsp; &nbsp; //这里会检测出fromPubKey是P2SH脚本，然后就会返回对应的Redeemscript给result当做scriptSig &nbsp;&nbsp;&nbsp;&nbsp;bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE); &nbsp;&nbsp;&nbsp;&nbsp;bool P2SH = false; &nbsp;&nbsp;&nbsp;&nbsp;CScript subscript; &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptWitness.stack.clear(); &nbsp; &nbsp; //第一次SignStep执行后 whichType == TX_SCRIPTHASH &nbsp; &nbsp; //得到的result为 Redeemscript的序列化文本 &nbsp;&nbsp;&nbsp;&nbsp;if (solved &amp;&amp; whichType == TX_SCRIPTHASH) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Solver returns the subscript that needs to be evaluated; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the final scriptSig is the signatures from that &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and then the serialized subscript: &nbsp; &nbsp; &nbsp; &nbsp; //这里将Redeemscript文本反序列化为多签名锁定脚本 &nbsp; &nbsp; &nbsp; &nbsp; //2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subscript = CScript(result[0].begin(), result[0].end()); &nbsp; &nbsp; &nbsp; &nbsp; //第二次SignStep会将作为pubKey的 subscript解释为multsig脚本，然后会返回 &lt; Sig1 &gt; &nbsp; &lt; Sig2 &gt; 数据 到result当做scriptSig &nbsp; &nbsp; &nbsp; &nbsp; solved = solved &amp;&amp; SignStep(creator, subscript, result, whichType, SigVersion::BASE) &amp;&amp; whichType != TX_SCRIPTHASH; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2SH = true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //上面result里不是已经有subscript了啊，为啥要再次push_back呢 &nbsp; &nbsp; //因为SignStep函数每次都会清空result数据，所以需要再次push_back subscript数据 &nbsp;&nbsp;&nbsp;&nbsp;if (P2SH) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end())); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; //将真正的scriptSig返回 &nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptSig = PushAll(result); } static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //这里会返回 Redeemscript作为scriptSig解锁脚本 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; } } bool CBasicKeyStore::GetCScript(const CScriptID &amp;hash, CScript&amp; redeemScriptOut) const { &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;ScriptMap::const_iterator mi = mapScripts.find(hash); &nbsp;&nbsp;&nbsp;&nbsp;if (mi != mapScripts.end()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redeemScriptOut = (*mi).second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return false; } 其实，还有一个疑问点，就是怎么根据P2SH的锁定脚本数据找到解锁脚本Redeemscript脚本的呢? P2SH的锁定脚本数据有用的数据只有hash值，也即是如何通过hash找到Redeemscript脚本的呢？ 仔细看的话，应该能看出一些端倪，就是mapScripts维护了一个hash和具体Redeemscript类型的scriptSig脚本的map关系.那你可能会说，整个链上这么多P2SH交易，hash就会很多，那这个mapScripts得多大啊。由于P2SH这个hash是&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;生成的，所以只有属于本地节点多账号签名生成的P2SH才需要添加到mapScripts.且肯定是先有多签名账号才有P2SH交易，因此只需要在创建多账号签名的点创建对应的Redeemscript并保存在mapScripts即可，事实上确实如此，流程如下。 UniValue addmultisigaddress(const JSONRPCRequest&amp; request) &nbsp;&nbsp;&nbsp;&nbsp;// Construct using pay-to-script-hash: &nbsp;&nbsp;&nbsp;&nbsp;CScript inner = CreateMultisigRedeemscript(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;pwallet-&gt;AddCScript(inner); } // Creates a multisig redeemscript from a given list of public keys and number required. CScript CreateMultisigRedeemscript(const int required, const std::vector&lt;CPubKey&gt;&amp; pubkeys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript result = GetScriptForMultisig(required, pubkeys); &nbsp;&nbsp;&nbsp;&nbsp;return result; } CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys) { &nbsp;&nbsp;&nbsp;&nbsp;CScript script; &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(nRequired); &nbsp;&nbsp;&nbsp;&nbsp;for (const CPubKey&amp; key : keys) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; ToByteVector(key); &nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG; &nbsp;&nbsp;&nbsp;&nbsp;return script; } bool CBasicKeyStore::AddCScript(const CScript&amp; redeemScript) { &nbsp;&nbsp;&nbsp;&nbsp;if (redeemScript.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error(&quot;CBasicKeyStore::AddCScript(): redeemScripts &gt; %i bytes are invalid&quot;, MAX_SCRIPT_ELEMENT_SIZE); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore); &nbsp;&nbsp;&nbsp;&nbsp;mapScripts[CScriptID(redeemScript)] = redeemScript; &nbsp;&nbsp;&nbsp;&nbsp;return true; } Solver函数 &nbsp;&nbsp; &nbsp;上面在分析P2SH的scriptSig就提到过Resolver，那Solver函数究竟做啥用的，它是用来解释scriptPubKey的，比如解释出scriptPubKey是什么类型的脚本，比如分析出判断一个scriptPubKey是否是P2SH,检验数据的合法性并取出 bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet) { &nbsp;&nbsp;&nbsp;&nbsp;// Templates &nbsp;&nbsp;&nbsp;&nbsp;static std::multimap&lt;txnouttype, CScript&gt; mTemplates; &nbsp;&nbsp;&nbsp;&nbsp;if (mTemplates.empty()) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Standard tx, sender provides pubkey, receiver adds signature &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sender provides N pubkeys, receivers provides M signatures &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp; &nbsp; //解释scriptPubkey的过程就是将scriptPubkey和模板对比，同时取出里面的数据比如 &nbsp;&nbsp;&nbsp;&nbsp;// Scan templates &nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script1 = scriptPubKey; &nbsp;&nbsp;&nbsp;&nbsp;for (const std::pair&lt;txnouttype, CScript&gt;&amp; tplate : mTemplates) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script2 = tplate.second; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode1, opcode2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned char&gt; vch1, vch2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compare &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc1 = script1.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc2 = script2.begin(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc1 == script1.end() &amp;&amp; pc2 == script2.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Found a match &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeRet = tplate.first; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeRet == TX_MULTISIG) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Additional checks for TX_MULTISIG: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char m = vSolutionsRet.front()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char n = vSolutionsRet.back()[0]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m &lt; 1 || n &lt; 1 || m &gt; n || vSolutionsRet.size()-2 != n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Template matching opcodes: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEYS) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (vch1.size() &gt;= 33 &amp;&amp; vch1.size() &lt;= 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normal situation is to fall through &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to other if/else statements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEY) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() &lt; 33 || vch1.size() &gt; 65) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode2 == OP_PUBKEYHASH) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() != sizeof(uint160)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode1 != opcode2 || vch1 != vch2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Others must match exactly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear(); &nbsp;&nbsp;&nbsp;&nbsp;typeRet = TX_NONSTANDARD; &nbsp;&nbsp;&nbsp;&nbsp;return false; } 附录: 脚本指令解释过程分析 &nbsp;上面在分析道evalScript执行函数时提到 脚本执行就是不停GetOp然后case处理的过程，下面就来分析下GetOp &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp(const_iterator&amp; pc, opcodetype&amp; opcodeRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return GetOp2(pc, opcodeRet, nullptr); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool GetOp2(const_iterator&amp; pc, opcodetype&amp; opcodeRet, std::vector&lt;unsigned char&gt;* pvchRet) const &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = OP_INVALIDOPCODE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc &gt;= end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; //第一字节为指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int opcode = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Immediate operand &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt;= OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nSize = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //[0x4] sig, 这类指令,&nbsp;opcode就是size &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt; OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = opcode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = *pc++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = ReadLE16(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//进一步读取数据size数值, OP_PUSHDATA4 [xx][xx][xx][xx] &lt;largedata&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = ReadLE32(&amp;pc[0]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 0 || (unsigned int)(end() - pc) &lt; nSize) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //读取真正的数据内容 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;assign(pc, pc + nSize); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += nSize; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = static_cast&lt;opcodetype&gt;(opcode); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;} 其他脚本的scriptSig生成 static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion) { &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet; &nbsp;&nbsp;&nbsp;&nbsp;uint160 h160; &nbsp;&nbsp;&nbsp;&nbsp;ret.clear(); &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions; &nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID; &nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case TX_NONSTANDARD: &nbsp;&nbsp;&nbsp;&nbsp;case TX_NULL_DATA: &nbsp;&nbsp;&nbsp;&nbsp;case TX_WITNESS_UNKNOWN: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEY: &nbsp; &nbsp; &nbsp; &nbsp; //P2PK模板 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyID = CPubKey(vSolutions[0]).GetID(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Sign1(keyID, creator, scriptPubKey, ret, sigversion); &nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEYHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2PKH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyID = CKeyID(uint160(vSolutions[0])); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPubKey vch; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creator.Provider().GetPubKey(keyID, vch); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(ToByteVector(vch)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH: &nbsp; &nbsp; &nbsp; &nbsp; //P2SH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end())); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;case TX_MULTISIG: &nbsp; &nbsp; &nbsp; &nbsp; //MS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(valtype()); // workaround CHECKMULTISIG bug &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion)); &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;} /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多","@type":"BlogPosting","url":"/2018/04/13/9264e51c2f0da726a2219fbe8598a390.html","headline":"比特币源码情景分析之script脚本验证(2)","dateModified":"2018-04-13T00:00:00+08:00","datePublished":"2018-04-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/04/13/9264e51c2f0da726a2219fbe8598a390.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码情景分析之script脚本验证(2)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div>
   &nbsp; &nbsp; 通过上一篇的分析，我们应该已经对script有了一定的理解，这章节我们以源码分析的方式来了解下脚本验证执行流程
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;bitcoin节点在处理一条交易时就需要验证交易的txin，由于一条交易可能包含多个txin,因而需要执行多个脚本验证，自然需要并行化，因而系统允许定义多个脚本执行线程以加速验证过程。有了这个思考，我们从脚本执行线程出发
   <span style="font-size:14px;font-family:arial;"><em>剥茧抽丝掀开脚本执行的面纱。</em></span>
  </div>
  <div>
   <span style="font-size:14px;font-family:arial;"><em>&nbsp; &nbsp; 先看脚本执行线程的初始化，这个在init.cpp的AppInitMain里</em></span>
  </div>
  <div>
   <span style="font-size:14px;font-family:arial;"><em><br></em></span>
  </div>
  <div>
   <div>
    <span style="font-size:24px;"><strong>脚本验证执行线程</strong></span>
   </div>
   <div>
    <span style="font-size:24px;"><br></span>
   </div>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;"><em>&nbsp;&nbsp;&nbsp;&nbsp;LogPrintf("Using %u threads for script verification\n", nScriptCheckThreads);</em></span>
    </div>
    <div style="font-size:14px;">
     <span style="font-family:Monaco;font-size:12px;"><em>&nbsp;&nbsp;&nbsp;&nbsp;if (nScriptCheckThreads) {</em></span>
    </div>
    <div style="font-size:14px;">
     <span style="font-family:Monaco;font-size:12px;"><em><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//根据参数创建对应数量的脚本执行线程</span></em></span>
    </div>
    <div style="font-size:14px;">
     <span style="font-family:Monaco;font-size:12px;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nScriptCheckThreads-1; i++)</em></span>
    </div>
    <div style="font-size:14px;">
     <span style="font-family:Monaco;font-size:12px;"><em><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadGroup.create_thread(&amp;ThreadScriptCheck);</span></em></span>
    </div>
    <div style="font-size:14px;">
     <span style="font-family:Monaco;font-size:12px;"><em>&nbsp;&nbsp;&nbsp;&nbsp;}</em></span>
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-family:arial;"><em>线程的具体实现函数在 validataion.cpp</em></span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">static CCheckQueue&lt;CScriptCheck&gt; </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">scriptcheckqueue</span></span>
    <span style="font-family:Monaco;">(128);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">void </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">ThreadScriptCheck</span></span>
    <span style="font-family:Monaco;">() {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;RenameThread("bitcoin-scriptch");</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;scriptcheckqueue.Thread();</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br>
   </div>
   <div>
    <span style="font-family:Monaco;">class </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">CCheckQueue</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;//! Worker thread</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp; void Thread() &nbsp; &nbsp;//</span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">CCheckQueue.Thread()</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loop();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp; bool Loop(bool fMaster = false)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::condition_variable&amp; cond = fMaster ? condMaster : condWorker;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;T&gt; vChecks;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.reserve(nBatchSize);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nNow = 0;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fOk = true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;……………..</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Decide how many work units to process now.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Do not try to do everything at once, but aim for increasingly smaller batches so</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;all workers finish approximately simultaneously.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Try to account for idle jobs which will instantly start helping.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// * Don't do batches smaller than 1 (duh), or larger than nBatchSize.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.resize(nNow);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; nNow; i++) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We want the lock on the mutex to be as short as possible, so swap jobs from the global</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// queue to the local batch vector instead of copying.</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 该线程选取一定量的脚本待执行对象</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks[i].swap(</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">queue.back</span></span>
    <span style="font-family:Monaco;">());</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.pop_back();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check whether we need to do work at all</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = fAllOk;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// execute work</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (T&amp; check : vChecks)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fOk)</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //check()函数就是</span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">CScriptCheck::operator()() </span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fOk = check();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vChecks.clear();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while (true);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:24px;"><strong>添加脚本验证对象</strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><br></span>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;<span style="color:rgb(148,33,146);">//发现新块并处理交易时会验证脚本</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">bool CChainState::</span>
     <span style="font-family:Monaco;color:rgb(4,51,255);">ConnectBlock</span>
     <span style="font-family:Monaco;">(const CBlock&amp; block, CValidationState&amp; state, CBlockIndex* pindex,</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewCache&amp; view, const CChainParams&amp; chainparams, bool fJustCheck)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;AssertLockHeld(cs_main);</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp; &nbsp;</span>
     <span style="font-family:Monaco;">CCheckQueueControl&lt;CScriptCheck&gt; </span>
     <span style="font-family:Monaco;color:rgb(4,51,255);">control</span>
     <span style="font-family:Monaco;">(fScriptChecks &amp;&amp; nScriptCheckThreads ? &amp;scriptcheckqueue : nullptr);</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CScriptCheck&gt; vChecks;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &amp;vChecks : nullptr))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error("ConnectBlock(): CheckInputs on %s failed with %s",</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.GetHash().ToString(), FormatStateMessage(state));</span>
    </div>
    <div>
     <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //control负责将某一个具体的验证执行对象添加到队列中</span>
    </div>
    <div>
     <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.Add(vChecks);</span>
    </div>
    <div>
     <span style="font-family:Monaco;"></span>
     <span style="font-family:Monaco;color:rgb(0,0,0);">}</span>
    </div>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(0,0,0);"><br></span>
   </div>
   <div>
    <span style="font-family:Monaco;">class CCheckQueueControl</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;void Add(std::vector&lt;T&gt;&amp; vChecks)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pqueue != nullptr)</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pqueue-&gt;Add(vChecks);</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:24px;"><strong>脚本验证执行函数</strong></span>
  </div>
  <div>
   <br>
  </div>
  <div>
   上面可知脚本验证线程最终会执行
   <span style="font-family:Monaco;">CScriptCheck::operator</span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">bool <span style="color:#0433ff;">CScriptCheck::operator</span>()() {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const CScript &amp;scriptSig = ptxTo-&gt;vin[nIn].scriptSig;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const CScriptWitness *witness = &amp;ptxTo-&gt;vin[nIn].scriptWitness;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return </span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">VerifyScript</span>
    <span style="font-family:Monaco;">(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &amp;error);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:24px;"><strong>P2SH脚本验证源码分析</strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   为了更完整的分析该过程，我以最复杂的脚本模板P2SH为例分析，从上一章接的介绍我们知道，P2SH的脚本如下：
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <span style="color:rgb(148,33,146);font-family:Monaco;"><u>&lt;Sig1&gt; &lt;Sig2&gt;</u></span>
   <span style="color:rgb(4,51,255);font-family:Monaco;"><u> &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</u></span>
   <span style="color:rgb(0,0,0);font-family:Monaco;">&gt;</span>
   <span style="font-family:Monaco;"> </span>
   <span style="color:rgb(255,38,0);font-family:Monaco;">OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL</span>
  </div>
  <div>
   <br>
  </div>
  <div>
   这里的
   <span style="font-family:Monaco;">scriptSig是&nbsp;<span style="font-size:12px;color:rgb(148,33,146);"><u>&lt;Sig1&gt; &lt;Sig2&gt;</u></span><span style="font-size:12px;color:rgb(4,51,255);"><u> &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</u></span><span style="font-size:12px;color:rgb(0,0,0);">&gt;，&nbsp;scriptPubKey是</span></span>
  </div>
  <div>
   <span style="font-size:12px;color:rgb(255,38,0);font-family:Monaco;">OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL</span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">bool VerifyScript(const CScript&amp; scriptSig, const CScript&amp; scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker&amp; checker, ScriptError* serror)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::vector&lt;unsigned char&gt; &gt; stack, stackCopy;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; </span><span style="color:rgb(148,33,146);">//执行解锁脚本，执行完后stack中有了<span style="text-decoration:underline;">&lt;Sig1&gt; &lt;Sig2&gt;</span><span style="text-decoration:underline;"> &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</span>&gt;</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //这三个数据对象</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp; &nbsp; //解锁脚本执行后</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">SCRIPT_VERIFY_P2SH</span></span>
    <span style="font-family:Monaco;">)</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(147,62,98);">&nbsp; &nbsp; &nbsp; &nbsp; //由于下面EvalScript会破坏stack,而再后面仍然需要stack当前的数据，因而需要做一次拷贝</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackCopy = stack;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:#942192;">&nbsp; &nbsp; //执行锁定脚本&nbsp;OP_HASH160 8ac1d7a2fa204a16dc984fa81cfdf86a2a4e1731 OP_EQUAL</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:#942192;">&nbsp; &nbsp; //就是将&lt;<span style="text-decoration:underline;">2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;数据做hash160,然后和锁定脚本中的hash比较</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //这一步结束后，hash160被验证通过了，此时栈只剩下<span style="text-decoration:underline;">&lt;Sig1&gt; &lt;Sig2&gt;</span></span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Additional validation for spend-to-script-hash transactions:</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //上一章节我们提到过，P2SH需要执行两次脚本验证，即还有子锁定脚本，下面就是在做这个事</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; SCRIPT_VERIFY_P2SH) &amp;&amp; </span>
    <span style="font-family:Monaco;"><span style="color:#ff9300;">scriptPubKey.IsPayToScriptHash())</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// scriptSig must be literals-only or validation fails</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!scriptSig.IsPushOnly())</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Restore stack.</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(147,53,59);">&nbsp; &nbsp; &nbsp; &nbsp; </span>
    <span style="font-family:Monaco;"><span style="color:#942192;">// hash160验证后，堆栈只剩下subscript.scriptSig了，我们换需要subscript.scriptPubKey</span></span>
   </div>
   <div>
    <span style="color:#942192;"><span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="font-family:Monaco;">// 恢复前面保存下来的栈可以做到这一点，恢复后的栈结构. subscript.scriptSig + subscript.scriptPubKey_(_代表被序列化了，文本化了)</span><span style="font-family:Monaco;">&nbsp;</span></span>
   </div>
   <div>
    <span style="color:#942192;"><span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp;//即<span style="text-decoration:underline;">&lt;Sig1&gt; &lt;Sig2&gt;</span><span style="text-decoration:underline;"> &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</span>&gt;</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(stack, stackCopy);</span></span>
   </div>
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stack cannot be empty here, because if it was the</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// P2SH&nbsp;&nbsp;HASH &lt;&gt; EQUAL&nbsp;&nbsp;scriptPubKey would be evaluated with</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an empty stack and the EvalScript above would return false.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!stack.empty());</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //从栈顶拿出subscript.scriptPubKey的脚本文本，并构建CScript对象</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">const valtype&amp; pubKeySerialized = stack.back();</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:rgb(170,121,66);">&nbsp; &nbsp; &nbsp; &nbsp; //到这里后，已经恢复出完整多签名子脚本了<span style="text-decoration:underline;">&lt;Sig1&gt; &lt;Sig2&gt;</span><span style="text-decoration:underline;">&nbsp;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</span></span></span>
   </div>
   <div>
    <span style="color:#942192;"><span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; //将</span><span style="font-family:Monaco;">subscript.scriptPubKey_文本弹出</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //这一步相当于执行evalScript(subscript.scriptSig)</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popstack(stack);</span>
   </div>
   <div>
    <span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //然后evalScript(<span style="font-family:Monaco;">subscript.scriptPubKey)</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //验证给的pubkey是否能够被解锁</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// serror is set</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return set_success(serror);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><br></span>
   </div>
   <div>
    <span style="font-family:Monaco;">bool </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">EvalScript</span></span>
    <span style="font-family:Monaco;">(std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; stack, const CScript&amp; script, unsigned int flags, const BaseSignatureChecker&amp; checker, SigVersion sigversion, ScriptError* serror)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp; &nbsp;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc = script.begin();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pend = script.end();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pbegincodehash = script.begin();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;valtype vchPushValue;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;bool&gt; vfExec;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; altstack;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;try</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (pc &lt; pend)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool fExec = !count(vfExec.begin(), vfExec.end(), false);</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//脚本执行就是不停GetOp然后case处理的过程</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script.GetOp(pc, opcode, vchPushValue))</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_BAD_OPCODE);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note how OP_RESERVED does not count towards the opcode limit.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &gt; OP_16 &amp;&amp; ++nOpCount &gt; MAX_OPS_PER_SCRIPT)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_OP_COUNT);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">opcode == OP_CAT ||</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_SUBSTR ||</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ......</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcode == OP_RSHIFT)</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes.</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fExec &amp;&amp; 0 &lt;= opcode &amp;&amp; opcode &lt;= OP_PUSHDATA4) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fRequireMinimal &amp;&amp; !CheckMinimalPush(vchPushValue, opcode)) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_MINIMALDATA);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(vchPushValue);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (fExec || (OP_IF &lt;= opcode &amp;&amp; opcode &lt;= OP_ENDIF))</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (opcode)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Push value</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;case OP_1NEGATE:</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_1:</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_2:</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .....</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_15:</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OP_16:</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ( -- value)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScriptNum bn((int)opcode - (int)(OP_1 - 1));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push_back(bn.getvch());</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The result of these opcodes should always be the minimal way to push the data</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// they push, so no need for a CheckMinimalPush here.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;…..</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;catch (...)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   从上可知，目前实现的执行多次脚本验证不是一个通用方案，而是通过检测脚本类型(P2SH)而做的特殊处理,只支持P2SH这个类型的脚本类型
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:24px;"><strong>P2SH锁定脚本scriptSig生成</strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   下面来看看p2sh的scriptSig怎么生成的
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; result;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;txnouttype whichType;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //这里会检测出fromPubKey是P2SH脚本，然后就会返回对应的Redeemscript给result当做scriptSig</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(251,57,36);">&nbsp;&nbsp;&nbsp;&nbsp;bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool P2SH = false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript subscript;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptWitness.stack.clear();</span>
   </div>
   <div>
    &nbsp; &nbsp;
    <span style="color:rgb(96,51,240);"> //第一次SignStep执行后</span>
    <span style="color:rgb(96,51,240);font-family:Monaco;">whichType == TX_SCRIPTHASH</span>
   </div>
   <div>
    <span style="color:rgb(84,63,240);font-family:Monaco;">&nbsp; &nbsp; //得到的result为</span>
    <span style="color:rgb(84,63,240);font-family:Monaco;">Redeemscript的序列化文本</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(96,51,240);">&nbsp;&nbsp;&nbsp;&nbsp;if (solved &amp;&amp; whichType == TX_SCRIPTHASH)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Solver returns the subscript that needs to be evaluated;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the final scriptSig is the signatures from that</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and then the serialized subscript:</span>
   </div>
   <div>
    <span style="color:rgb(148,33,146);"><span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; //这里将</span><span style="font-family:Monaco;">Redeemscript文本反序列化为多签名锁定脚本</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:rgb(148,33,146);">&nbsp; &nbsp; &nbsp; &nbsp; //<span style="text-decoration:underline;">2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</span></span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subscript = CScript(result[0].begin(), result[0].end());</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(242,41,238);">&nbsp; &nbsp; &nbsp; &nbsp; </span>
    <span style="font-family:Monaco;color:rgb(170,121,66);">//第二次SignStep会将作为pubKey的</span>
    <span style="font-family:Monaco;color:rgb(170,121,66);">subscript解释为multsig脚本，然后会返回</span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;background-color:rgb(255,255,255);"><strong>&lt;</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>Sig1</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;background-color:rgb(255,255,255);"><strong>&gt;</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;">&nbsp;</span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>&lt;</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>Sig2</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>&gt;</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>数据</strong></span>
    <span style="font-family:Consolas, 'Courier New', Courier, mono, serif;color:rgb(170,121,66);border:none;"><strong>到result当做scriptSig</strong></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; solved = solved &amp;&amp; SignStep(creator, subscript, result, whichType, SigVersion::BASE) &amp;&amp; whichType != TX_SCRIPTHASH;</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2SH = true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="color:rgb(170,121,66);">&nbsp; &nbsp; //上面result里不是已经有subscript了啊，为啥要再次push_back呢</span>
   </div>
   <div>
    <span style="color:rgb(170,121,66);">&nbsp; &nbsp; //因为SignStep函数每次都会清空<span style="font-family:Monaco;">result</span>数据，所以需要再次push_back subscript数据</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (P2SH) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(170,121,66);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(std::vector&lt;unsigned char&gt;(subscript.begin(), subscript.end()));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //将真正的scriptSig返回</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;sigdata.scriptSig = PushAll(result);</span></span>
   </div>
   <div>
    }
   </div>
   <div>
    <br>
   </div>
   <div>
    <span style="font-family:Monaco;">static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey,</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint160 h160;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(255,38,0);">&nbsp;&nbsp;&nbsp;&nbsp;ret.clear();</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions))</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH:</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(255,64,255);">&nbsp; &nbsp; &nbsp; &nbsp; //这里会返回</span>
    <span style="font-family:Monaco;color:rgb(255,64,255);">Redeemscript作为scriptSig解锁脚本</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(255,147,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end()));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp; &nbsp; }</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br>
   </div>
   <div>
    <span style="font-family:Monaco;">bool CBasicKeyStore::GetCScript(const CScriptID &amp;hash, CScript&amp; redeemScriptOut) const</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore);</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(255,147,0);">&nbsp;&nbsp;&nbsp;&nbsp;ScriptMap::const_iterator mi = mapScripts.find(hash);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (mi != mapScripts.end())</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redeemScriptOut = (*mi).second;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:14px;">其实，还有一个疑问点，就是怎么根据P2SH的锁定脚本数据找到解锁脚本<span style="font-family:Monaco;">Redeemscript脚本的呢?</span></span>
  </div>
  <div>
   <span style="font-size:14px;"><span style="font-family:Monaco;">P2SH的锁定脚本数据有用的数据只有hash值，也即是如何通过hash找到</span><span style="font-family:Monaco;">Redeemscript脚本的呢？</span></span>
  </div>
  <div>
   <span style="font-size:14px;"><span style="font-family:Monaco;">仔细看的话，应该能看出一些端倪，就是</span><span style="font-family:Monaco;">mapScripts维护了一个hash和具体Redeemscript类型的scriptSig脚本的map关系.</span><span style="font-family:Monaco;">那你可能会说，整个链上这么多P2SH交易，hash就会很多，那这个</span><span style="font-family:Monaco;">mapScripts得多大啊。由于P2SH这个hash是&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;生成的，所以只有属于本地节点多账号签名生成的P2SH才需要添加到mapScripts.且肯定是先有多签名账号才有P2SH交易，因此只需要在创建多账号签名的点创建对应的Redeemscript并保存在mapScripts即可，事实上确实如此，流程如下。</span></span>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:12px;"><span style="font-size:14px;"></span></span>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">UniValue addmultisigaddress(const JSONRPCRequest&amp; request)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Construct using pay-to-script-hash:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;CScript inner = CreateMultisigRedeemscript(required, pubkeys);</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;color:rgb(53,64,240);">&nbsp;&nbsp;&nbsp;&nbsp;pwallet-&gt;AddCScript(inner);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">// Creates a multisig redeemscript from a given list of public keys and number required.</span>
    </div>
    <div>
     <span style="font-family:Monaco;">CScript CreateMultisigRedeemscript(const int required, const std::vector&lt;CPubKey&gt;&amp; pubkeys)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;color:rgb(47,58,240);">&nbsp;&nbsp;&nbsp;&nbsp;CScript result = GetScriptForMultisig(required, pubkeys);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return result;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">CScript GetScriptForMultisig(int nRequired, const std::vector&lt;CPubKey&gt;&amp; keys)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript script;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(nRequired);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;for (const CPubKey&amp; key : keys)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; ToByteVector(key);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;script &lt;&lt; CScript::EncodeOP_N(keys.size()) &lt;&lt; OP_CHECKMULTISIG;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return script;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><br></span>
    </div>
    <div>
     <span style="font-family:Monaco;">bool CBasicKeyStore::AddCScript(const CScript&amp; redeemScript)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (redeemScript.size() &gt; MAX_SCRIPT_ELEMENT_SIZE)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error("CBasicKeyStore::AddCScript(): redeemScripts &gt; %i bytes are invalid", MAX_SCRIPT_ELEMENT_SIZE);</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_KeyStore);</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;mapScripts[CScriptID(redeemScript)] = redeemScript;</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
   </div>
  </div>
  <div>
   <div>
    <span style="font-size:24px;"><br></span>
   </div>
   <div>
    <span style="font-size:24px;">Solver函数</span>
    <br>
   </div>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   <span style="font-size:14px;">&nbsp;&nbsp; &nbsp;上面在分析P2SH的scriptSig就提到过Resolver，那Solver函数究竟做啥用的，它是用来解释scriptPubKey的，比如解释出scriptPubKey是什么类型的脚本，比如分析出判断一个scriptPubKey是否是P2SH,检验数据的合法性并取出</span>
  </div>
  <div>
   <span style="font-size:14px;"><br></span>
  </div>
  <div>
   <span style="font-size:24px;"></span>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">bool Solver(const CScript&amp; scriptPubKey, txnouttype&amp; typeRet, std::vector&lt;std::vector&lt;unsigned char&gt; &gt;&amp; vSolutionsRet)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Templates</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;static std::multimap&lt;txnouttype, CScript&gt; mTemplates;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (mTemplates.empty())</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Standard tx, sender provides pubkey, receiver adds signature</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() &lt;&lt; OP_PUBKEY &lt;&lt; OP_CHECKSIG));</span></span>
    </div>
    <div>
     <span style="color:#0433ff;"><br style="font-family:Monaco;"></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; OP_PUBKEYHASH &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG));</span></span>
    </div>
    <div>
     <span style="color:#0433ff;"><br style="font-family:Monaco;"></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sender provides N pubkeys, receivers provides M signatures</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_PUBKEYS &lt;&lt; OP_SMALLINTEGER &lt;&lt; OP_CHECKMULTISIG));</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear();</span>
    </div>
    <div>
     <span style="color:#942192;">&nbsp; &nbsp; //解释scriptPubkey的过程就是将scriptPubkey和模板对比，同时取出里面的数据比如</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Scan templates</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script1 = scriptPubKey;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;for (const std::pair&lt;txnouttype, CScript&gt;&amp; tplate : mTemplates)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CScript&amp; script2 = tplate.second;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear();</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodetype opcode1, opcode2;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned char&gt; vch1, vch2;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compare</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc1 = script1.begin();</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CScript::const_iterator pc2 = script2.begin();</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc1 == script1.end() &amp;&amp; pc2 == script2.end())</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Found a match</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeRet = tplate.first;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeRet == TX_MULTISIG)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Additional checks for TX_MULTISIG:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char m = vSolutionsRet.front()[0];</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned char n = vSolutionsRet.back()[0];</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m &lt; 1 || n &lt; 1 || m &gt; n || vSolutionsRet.size()-2 != n)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Template matching opcodes:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEYS)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (vch1.size() &gt;= 33 &amp;&amp; vch1.size() &lt;= 65)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1);</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script1.GetOp(pc1, opcode1, vch1))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!script2.GetOp(pc2, opcode2, vch2))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normal situation is to fall through</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to other if/else statements</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode2 == OP_PUBKEY)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() &lt; 33 || vch1.size() &gt; 65)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode2 == OP_PUBKEYHASH)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vch1.size() != sizeof(uint160))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.push_back(vch1);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode1 != opcode2 || vch1 != vch2)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Others must match exactly</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;vSolutionsRet.clear();</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;typeRet = TX_NONSTANDARD;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
   </div>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong>附录:</strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong>脚本指令解释过程分析</strong></span>
  </div>
  <div>
   <span style="font-size:24px;"><strong><br></strong></span>
  </div>
  <div>
   <span style="font-family:Monaco;font-size:12px;"><strong>&nbsp;上面在分析道evalScript执行函数时提到</strong></span>
   <span style="font-family:Monaco;font-size:12px;"><strong>脚本执行就是不停GetOp然后case处理的过程，下面就来分析下GetOp</strong></span>
  </div>
  <div>
   <span style="font-family:Monaco;font-size:12px;"><strong><br></strong></span>
  </div>
  <div>
   <span style="font-size:24px;"></span>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool GetOp(const_iterator&amp; pc, opcodetype&amp; opcodeRet) const</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return GetOp2(pc, opcodeRet, nullptr);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool GetOp2(const_iterator&amp; pc, opcodetype&amp; opcodeRet, std::vector&lt;unsigned char&gt;* pvchRet) const</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = OP_INVALIDOPCODE;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;clear();</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pc &gt;= end())</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read instruction</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; //第一字节为指令</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int opcode = *pc++;</span></span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Immediate operand</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt;= OP_PUSHDATA4)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nSize = 0;</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //[0x4] sig, 这类指令,&nbsp;opcode就是size</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opcode &lt; OP_PUSHDATA1)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = opcode;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA1)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 1)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="color:rgb(4,51,255);font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = *pc++;</span>
     <br>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA2)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 2)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nSize = ReadLE16(&amp;pc[0]);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 2;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (opcode == OP_PUSHDATA4)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 4)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="color:rgb(148,33,146);">//进一步读取数据size数值, OP_PUSHDATA4 [xx][xx][xx][xx] &lt;largedata&gt;</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize = ReadLE32(&amp;pc[0]);</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += 4;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (end() - pc &lt; 0 || (unsigned int)(end() - pc) &lt; nSize)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pvchRet)</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //读取真正的数据内容</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvchRet-&gt;assign(pc, pc + nSize);</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc += nSize;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opcodeRet = static_cast&lt;opcodetype&gt;(opcode);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <strong><span style="font-size:24px;">其他脚本的scriptSig生成</span></strong>
  </div>
  <div>
   <strong><span style="font-size:24px;"><br></span></strong>
  </div>
  <div>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">static bool SignStep(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey,</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt;&amp; ret, txnouttype&amp; whichTypeRet, SigVersion sigversion)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CScript scriptRet;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint160 h160;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ret.clear();</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;valtype&gt; vSolutions;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (!Solver(scriptPubKey, whichTypeRet, vSolutions))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CKeyID keyID;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;switch (whichTypeRet)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_NONSTANDARD:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_NULL_DATA:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_WITNESS_UNKNOWN:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEY:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //P2PK模板</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">keyID = CPubKey(vSolutions[0]).GetID();</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Sign1(keyID, creator, scriptPubKey, ret, sigversion);</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_PUBKEYHASH:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp; &nbsp; &nbsp; &nbsp; </span>
     <span style="font-family:Monaco;"><span style="color:#942192;">//P2PKH</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyID = CKeyID(uint160(vSolutions[0]));</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion))</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPubKey vch;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creator.Provider().GetPubKey(keyID, vch);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(ToByteVector(vch));</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_SCRIPTHASH:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //P2SH</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) {</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(std::vector&lt;unsigned char&gt;(scriptRet.begin(), scriptRet.end()));</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;case TX_MULTISIG:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; &nbsp; &nbsp; //MS</span></span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.push_back(valtype()); // workaround CHECKMULTISIG bug</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion));</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;default:</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
   </div>
  </div>
  <blockquote style="border:none;">
   <blockquote style="border:none;">
    <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
     <span style="font-family:Monaco;"><br></span>
    </div>
   </blockquote>
  </blockquote>
  <div></div>
  <p></p>
  <div style="color:rgb(69,69,69);">
   <div>
    <span style="font-size:18px;font-family:SimSun;">/********************************</span>
   </div>
   <div>
    <span style="font-size:18px;"><span style="line-height:19px;font-family:'Courier New';">* 本文来自CSDN博主"爱踢门"</span></span>
   </div>
   <div>
    <span style="font-size:18px;font-family:'Courier New';line-height:19px;">* 转载请标明出处</span>
    <span style="font-size:18px;background-color:rgb(255,255,255);font-family:'Courier New';line-height:19px;">:</span>
    <a href="http://blog.csdn.net/itleaks" rel="nofollow" style="font-size:18px;font-family:'Courier New';line-height:19px;">http://blog.csdn.net/itleaks</a>
   </div>
   <div>
    <span style="font-size:14px;font-family:SimSun;line-height:19px;">******************************************/</span>
   </div>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180415143239928" alt="" style="border:0px;">
   <br>
  </div>
  <div>
   <br>
  </div>
  <div style="color:rgb(69,69,69);"></div>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/79922497,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/79922497,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
