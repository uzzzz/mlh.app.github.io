<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊私有链搭建节点集群 到 简单helloworld智能合约编写 操作流程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊私有链搭建节点集群 到 简单helloworld智能合约编写 操作流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1.选择一种以太坊客户端 Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择 geth工具来进行开发。 Mac 中安装geth如下： brew tap ethereum/ethereum brew install ethereum 检查是否安装成功： geth --help 如果输出一些帮助命令，则安装成功。 2.搭建私有链 以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。 json文件内容如下: { &quot;config&quot;: { &nbsp; &nbsp; &nbsp; &quot;chainId&quot;: 10, &nbsp; &nbsp; &nbsp; &quot;homesteadBlock&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip155Block&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip158Block&quot;: 0 &nbsp; }, &quot;alloc&quot; &nbsp; &nbsp; : {}, &quot;coinbase&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x20000&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; &nbsp; : &quot;0x2fefd8&quot;, &quot;nonce&quot; &nbsp; &nbsp; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot; } 2.1初始化：写入创世区块 准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： 接下来进入privatechain目录中，执行初始化命令： cd privatechain geth --datadir data0 init genesis.json 上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有Successfully wrote genesis state字样，说明初始化成功。 初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 2.2启动私有链节点 初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点： geth --datadir data0 --networkid 1008 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1008，表示指定这个私有链的网络id为1008。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console： 这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法 net：包含以下查看p2p网络状态的方法 admin：包含一些与管理节点相关的方法 miner：包含启动&amp;停止挖矿的一些方法 personal：主要包含一些管理账户的方法 txpool：包含一些查看交易内存池的方法 web3：包含了以上对象，还包含一些单位换算的方法 2.3 Javascript Console 进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 创建账户 前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证： &gt; eth.accounts [] 此时没有账户，接下来使用personal对象来创建一个账户： &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令: &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot; 这时候再去看账户，就有两个了。 &gt; eth.accounts [&quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot;, &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot;] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 查看账户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 ​ 启动、停止挖矿 &gt; miner.start(10) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入 &gt; miner.stop() 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户： &gt; eth.coinbase &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币： &gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#39;ether&#39;) 发送一笔交易 &gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount}) 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0： &gt; personal.unlockAccount(eth.accounts[0]) 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易。 我们去查看账户1中的余额，发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证： &gt; txpool.status { pending: 1, queued: 0 } 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿： &gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了： &gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;) 10 查看交易 eth对象封装了查看交易和区块信息的方法。 查看当前区块总数： &gt; eth.blockNumber 3.建立节点集群 在私有网络中建立多个节点组成的集群,并互相发现,产生交易。 如果是为了在本地网络运行多个以太坊节点的实例,必须确保一下几点:1. 每个实例都有独立的数据目录(--datadir)2. 每个实例运行都有独立的端口.(eth和rpc两者都是)(--port 和 --rpcprot)3. 在集群的情况下, 实例之间都必须要知道彼此. 4. 唯一的ipc通信端点,或者禁用ipc. 在这里，我们选择在不同的电脑上分别建立节点组成集群，互相发现，产生交易。 在第一台电脑上启动节点 geth --datadir data0 --networkid 1008 console 在第二台电脑上初始化并启动节点，注意网络ID要相同，确保节点都在一个私有网络中。 geth --datadir ./data/01 init ./genesis.json 初始化 注意和第一个节点使用相同的创始快json文件 geth --datadir data0 --networkid 1008 --bootnodes &quot;enode://b86d51f0737672b80c9000caa706955b2a94286f8593774aab40c86cbb4fc871ce6853172871eef24bced4e6fa4576fb9d8fadfd0893b3f0873eddb9eb2072f2@192.168.6.150:30303&quot; console bootnodes后边的参数是第一台电脑上节点的enode url 可以在第一台电脑上通过 &gt;admin.nodeInfo.enode 来获取。 @192.168.6.150:30303 是第一台电脑的IP地址：192.168.150 以及ports：30303 本节点的ports可以通过 admin.nodeInfo 来获取。 至此两个节点应该就链接成功了。 3.1节点间发送以太币 &gt; eth.sendTransaction({from: &quot;0x5fba50fce50baf0b8a7314200ba46336958ac97e&quot;, to: &quot;0x0a8c35653d8b229c16f0c9ce6f63cffb877cfdcf&quot;, value: web3.toWei(1, &quot;ether&quot;)}) from中填当前节点的账号地址，to中填要发送给的节点的账号地址。 执行以上命令发送一个以太币。注意发送交易操作前要先解锁账号： &gt; personal.unlockAccount(eth.accounts[0], &quot;passwoed&quot;) 然后执行挖矿太能让交易生效。 &gt; miner.start() 4.编写helloworld智能合约&nbsp; &nbsp;让我们开始你的第一个严肃的合约。前沿是一个很大的开放领土，有时候你可能会感到孤独，所以我们的第一步就是创造一个自动伴侣，在你感到孤独时迎接你。我们会称他为“Greeter”。 &nbsp; &nbsp;Greeter是一个智能数字化实体，它存在于区块链中，并能够根据其输入与任何与之交互的人进行对话。它可能不是一个说话者，但它是一个很好的倾听者。这是它的代码： contract Mortal { /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() { owner = msg.sender; } /* Function to recover the funds on the contract */ function kill() { if (msg.sender == owner) selfdestruct(owner); } } contract Greeter is Mortal { /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public { greeting = _greeting; } /* Main function */ function greet() constant returns (string) { return greeting; } }&nbsp; &nbsp;你会注意到这个代码中有两个不同的合约：“Mortal”和“Greeter”。这是因为Solidity（我们使用的高级合同语言）具有继承性，这意味着一个合约可以继承另一个合约的特征。这对简化编码非常有用，因为合约的通用特征不需要每次重写，并且所有合约都可以用更小，更易读的块编写。所以通过只声明Greeter是Mortal的，你就继承了来自“Mortal”合约的所有特征，并使Greeter代码简单易读。 &nbsp; 继承特征的“Mortal”仅仅意味着Greeter合同可以被其所有者杀死，以清理区块链并在不再需要合同时收回锁定在其中的资金。以太坊中的契约默认为不朽，并且没有所有者，这意味着一旦部署，作者就没有特殊的特权了。部署前请考虑这一点。 &nbsp; 在部署合同前，需要准备两样东西： 1.编译后的代码。 2.应用程序二进制接口（ABI），它是一个定义如何与合约进行交互的JavaScript对象 &nbsp; 我们可以通过使用Solidity编译器来获得这两者。（在线编译器remix的地址：点击打开链接） 4.1获得编译后的代码 &nbsp; &nbsp;将源代码（位于本页顶部）复制到Remix，它应该自动编译您的代码。 您可以放心地忽略右侧任何黄色警告框。 &nbsp; 要访问已编译的代码，请确保右窗格中的下拉菜单已选中Greeter。 然后直接点击下拉菜单右边的details按钮。 在弹出窗口中，向下滚动并复制WEB3DEPLOY文本框中的所有代码。 &nbsp; 在计算机上创建一个临时文本文件并粘贴该代码。 确保将第一行更改为如下所示： var _greeting = &quot;Hello World!&quot; &nbsp; 现在，可以将结果文本粘贴到geth窗口中，或者使用loadScript（“yourFilename.js”）导入文件。 &nbsp;然后执行挖矿。 &nbsp; &nbsp;等待一会终端中会看到类似这样的消息： 您可能必须先使用您在开始时选择的密码来“解锁”发送交易的帐户，因为您需要支付部署合同的GAS费用。&nbsp; personal.unlockAccount（web3.eth.accounts [0]，“yourPassword”） 您可以使用以下命令来验证已部署的代码（将被编译）： eth.getCode(greeter.address) 如果它返回“0x”以外的任何内容，那么恭喜！ 你的小家伙活着！ 如果再次创建合同（通过执行另一个eth.sendTransaction），它将发布到新地址。 4.2 执行Greeter 为了召唤你的机器人，只需在终端上输入以下命令： greeter.greet(); 由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何燃气费用。 你应该看到它返回你的问候语： &#39;Hello World!&#39; 4.3&nbsp;让其他人与您的代码交互 为了让其他人来执行你的合同，他们需要两个东西： 1.合同所在地址 2. ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台 &nbsp; &nbsp; 想要获取地址，请运行以下命令： greeter.address; &nbsp; &nbsp; 得到类似下图的一个合约地址： &nbsp; &nbsp;为了得到ABI，您需要直接从Remix复制ABI，类似于复制WEB3DEPLOY编译代码的方式。 在右侧窗格中，单击详细信息按钮并向下滚动到ABI文本框。 点击复制按钮复制整个ABI，然后将其粘贴到临时文本文档中。 然后，您可以实例化一个可用于在连接到网络的任何计算机上调用合同的JavaScript对象。 在以下行中，替换ABI（一个数组）和Address（一个字符串）以在JavaScript中创建合同对象： var greeter = eth.contract(ABI).at(Address);这样别的节点就也可以通过 greeter.greet(); 调用你的机器人了。结果显示： &#39;Hello World!&#39; &nbsp;&nbsp; 阅读更多" />
<meta property="og:description" content="1.选择一种以太坊客户端 Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择 geth工具来进行开发。 Mac 中安装geth如下： brew tap ethereum/ethereum brew install ethereum 检查是否安装成功： geth --help 如果输出一些帮助命令，则安装成功。 2.搭建私有链 以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。 json文件内容如下: { &quot;config&quot;: { &nbsp; &nbsp; &nbsp; &quot;chainId&quot;: 10, &nbsp; &nbsp; &nbsp; &quot;homesteadBlock&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip155Block&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip158Block&quot;: 0 &nbsp; }, &quot;alloc&quot; &nbsp; &nbsp; : {}, &quot;coinbase&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x20000&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; &nbsp; : &quot;0x2fefd8&quot;, &quot;nonce&quot; &nbsp; &nbsp; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot; } 2.1初始化：写入创世区块 准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： 接下来进入privatechain目录中，执行初始化命令： cd privatechain geth --datadir data0 init genesis.json 上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有Successfully wrote genesis state字样，说明初始化成功。 初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 2.2启动私有链节点 初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点： geth --datadir data0 --networkid 1008 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1008，表示指定这个私有链的网络id为1008。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console： 这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法 net：包含以下查看p2p网络状态的方法 admin：包含一些与管理节点相关的方法 miner：包含启动&amp;停止挖矿的一些方法 personal：主要包含一些管理账户的方法 txpool：包含一些查看交易内存池的方法 web3：包含了以上对象，还包含一些单位换算的方法 2.3 Javascript Console 进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 创建账户 前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证： &gt; eth.accounts [] 此时没有账户，接下来使用personal对象来创建一个账户： &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令: &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot; 这时候再去看账户，就有两个了。 &gt; eth.accounts [&quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot;, &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot;] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 查看账户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 ​ 启动、停止挖矿 &gt; miner.start(10) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入 &gt; miner.stop() 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户： &gt; eth.coinbase &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币： &gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#39;ether&#39;) 发送一笔交易 &gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount}) 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0： &gt; personal.unlockAccount(eth.accounts[0]) 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易。 我们去查看账户1中的余额，发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证： &gt; txpool.status { pending: 1, queued: 0 } 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿： &gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了： &gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;) 10 查看交易 eth对象封装了查看交易和区块信息的方法。 查看当前区块总数： &gt; eth.blockNumber 3.建立节点集群 在私有网络中建立多个节点组成的集群,并互相发现,产生交易。 如果是为了在本地网络运行多个以太坊节点的实例,必须确保一下几点:1. 每个实例都有独立的数据目录(--datadir)2. 每个实例运行都有独立的端口.(eth和rpc两者都是)(--port 和 --rpcprot)3. 在集群的情况下, 实例之间都必须要知道彼此. 4. 唯一的ipc通信端点,或者禁用ipc. 在这里，我们选择在不同的电脑上分别建立节点组成集群，互相发现，产生交易。 在第一台电脑上启动节点 geth --datadir data0 --networkid 1008 console 在第二台电脑上初始化并启动节点，注意网络ID要相同，确保节点都在一个私有网络中。 geth --datadir ./data/01 init ./genesis.json 初始化 注意和第一个节点使用相同的创始快json文件 geth --datadir data0 --networkid 1008 --bootnodes &quot;enode://b86d51f0737672b80c9000caa706955b2a94286f8593774aab40c86cbb4fc871ce6853172871eef24bced4e6fa4576fb9d8fadfd0893b3f0873eddb9eb2072f2@192.168.6.150:30303&quot; console bootnodes后边的参数是第一台电脑上节点的enode url 可以在第一台电脑上通过 &gt;admin.nodeInfo.enode 来获取。 @192.168.6.150:30303 是第一台电脑的IP地址：192.168.150 以及ports：30303 本节点的ports可以通过 admin.nodeInfo 来获取。 至此两个节点应该就链接成功了。 3.1节点间发送以太币 &gt; eth.sendTransaction({from: &quot;0x5fba50fce50baf0b8a7314200ba46336958ac97e&quot;, to: &quot;0x0a8c35653d8b229c16f0c9ce6f63cffb877cfdcf&quot;, value: web3.toWei(1, &quot;ether&quot;)}) from中填当前节点的账号地址，to中填要发送给的节点的账号地址。 执行以上命令发送一个以太币。注意发送交易操作前要先解锁账号： &gt; personal.unlockAccount(eth.accounts[0], &quot;passwoed&quot;) 然后执行挖矿太能让交易生效。 &gt; miner.start() 4.编写helloworld智能合约&nbsp; &nbsp;让我们开始你的第一个严肃的合约。前沿是一个很大的开放领土，有时候你可能会感到孤独，所以我们的第一步就是创造一个自动伴侣，在你感到孤独时迎接你。我们会称他为“Greeter”。 &nbsp; &nbsp;Greeter是一个智能数字化实体，它存在于区块链中，并能够根据其输入与任何与之交互的人进行对话。它可能不是一个说话者，但它是一个很好的倾听者。这是它的代码： contract Mortal { /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() { owner = msg.sender; } /* Function to recover the funds on the contract */ function kill() { if (msg.sender == owner) selfdestruct(owner); } } contract Greeter is Mortal { /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public { greeting = _greeting; } /* Main function */ function greet() constant returns (string) { return greeting; } }&nbsp; &nbsp;你会注意到这个代码中有两个不同的合约：“Mortal”和“Greeter”。这是因为Solidity（我们使用的高级合同语言）具有继承性，这意味着一个合约可以继承另一个合约的特征。这对简化编码非常有用，因为合约的通用特征不需要每次重写，并且所有合约都可以用更小，更易读的块编写。所以通过只声明Greeter是Mortal的，你就继承了来自“Mortal”合约的所有特征，并使Greeter代码简单易读。 &nbsp; 继承特征的“Mortal”仅仅意味着Greeter合同可以被其所有者杀死，以清理区块链并在不再需要合同时收回锁定在其中的资金。以太坊中的契约默认为不朽，并且没有所有者，这意味着一旦部署，作者就没有特殊的特权了。部署前请考虑这一点。 &nbsp; 在部署合同前，需要准备两样东西： 1.编译后的代码。 2.应用程序二进制接口（ABI），它是一个定义如何与合约进行交互的JavaScript对象 &nbsp; 我们可以通过使用Solidity编译器来获得这两者。（在线编译器remix的地址：点击打开链接） 4.1获得编译后的代码 &nbsp; &nbsp;将源代码（位于本页顶部）复制到Remix，它应该自动编译您的代码。 您可以放心地忽略右侧任何黄色警告框。 &nbsp; 要访问已编译的代码，请确保右窗格中的下拉菜单已选中Greeter。 然后直接点击下拉菜单右边的details按钮。 在弹出窗口中，向下滚动并复制WEB3DEPLOY文本框中的所有代码。 &nbsp; 在计算机上创建一个临时文本文件并粘贴该代码。 确保将第一行更改为如下所示： var _greeting = &quot;Hello World!&quot; &nbsp; 现在，可以将结果文本粘贴到geth窗口中，或者使用loadScript（“yourFilename.js”）导入文件。 &nbsp;然后执行挖矿。 &nbsp; &nbsp;等待一会终端中会看到类似这样的消息： 您可能必须先使用您在开始时选择的密码来“解锁”发送交易的帐户，因为您需要支付部署合同的GAS费用。&nbsp; personal.unlockAccount（web3.eth.accounts [0]，“yourPassword”） 您可以使用以下命令来验证已部署的代码（将被编译）： eth.getCode(greeter.address) 如果它返回“0x”以外的任何内容，那么恭喜！ 你的小家伙活着！ 如果再次创建合同（通过执行另一个eth.sendTransaction），它将发布到新地址。 4.2 执行Greeter 为了召唤你的机器人，只需在终端上输入以下命令： greeter.greet(); 由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何燃气费用。 你应该看到它返回你的问候语： &#39;Hello World!&#39; 4.3&nbsp;让其他人与您的代码交互 为了让其他人来执行你的合同，他们需要两个东西： 1.合同所在地址 2. ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台 &nbsp; &nbsp; 想要获取地址，请运行以下命令： greeter.address; &nbsp; &nbsp; 得到类似下图的一个合约地址： &nbsp; &nbsp;为了得到ABI，您需要直接从Remix复制ABI，类似于复制WEB3DEPLOY编译代码的方式。 在右侧窗格中，单击详细信息按钮并向下滚动到ABI文本框。 点击复制按钮复制整个ABI，然后将其粘贴到临时文本文档中。 然后，您可以实例化一个可用于在连接到网络的任何计算机上调用合同的JavaScript对象。 在以下行中，替换ABI（一个数组）和Address（一个字符串）以在JavaScript中创建合同对象： var greeter = eth.contract(ABI).at(Address);这样别的节点就也可以通过 greeter.greet(); 调用你的机器人了。结果显示： &#39;Hello World!&#39; &nbsp;&nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/04/23/d1226bce7ebdcdbf592d32e6b2020d91.html" />
<meta property="og:url" content="https://mlh.app/2018/04/23/d1226bce7ebdcdbf592d32e6b2020d91.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-23T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1.选择一种以太坊客户端 Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择 geth工具来进行开发。 Mac 中安装geth如下： brew tap ethereum/ethereum brew install ethereum 检查是否安装成功： geth --help 如果输出一些帮助命令，则安装成功。 2.搭建私有链 以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。 json文件内容如下: { &quot;config&quot;: { &nbsp; &nbsp; &nbsp; &quot;chainId&quot;: 10, &nbsp; &nbsp; &nbsp; &quot;homesteadBlock&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip155Block&quot;: 0, &nbsp; &nbsp; &nbsp; &quot;eip158Block&quot;: 0 &nbsp; }, &quot;alloc&quot; &nbsp; &nbsp; : {}, &quot;coinbase&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot; : &quot;0x20000&quot;, &quot;extraData&quot; : &quot;&quot;, &quot;gasLimit&quot; &nbsp; : &quot;0x2fefd8&quot;, &quot;nonce&quot; &nbsp; &nbsp; : &quot;0x0000000000000042&quot;, &quot;mixhash&quot; &nbsp; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot; : &quot;0x00&quot; } 2.1初始化：写入创世区块 准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： 接下来进入privatechain目录中，执行初始化命令： cd privatechain geth --datadir data0 init genesis.json 上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有Successfully wrote genesis state字样，说明初始化成功。 初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 2.2启动私有链节点 初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点： geth --datadir data0 --networkid 1008 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1008，表示指定这个私有链的网络id为1008。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console： 这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法 net：包含以下查看p2p网络状态的方法 admin：包含一些与管理节点相关的方法 miner：包含启动&amp;停止挖矿的一些方法 personal：主要包含一些管理账户的方法 txpool：包含一些查看交易内存池的方法 web3：包含了以上对象，还包含一些单位换算的方法 2.3 Javascript Console 进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 创建账户 前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证： &gt; eth.accounts [] 此时没有账户，接下来使用personal对象来创建一个账户： &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令: &gt; personal.newAccount() &gt; Passphrase: &gt; Repeat passphrase: &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot; 这时候再去看账户，就有两个了。 &gt; eth.accounts [&quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot;, &quot;0xa48dba91281ee727c2424c85400f51f7a22716de&quot;] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 查看账户余额 &gt; eth.getBalance(eth.accounts[0]) 0 &gt; eth.getBalance(eth.accounts[1]) 0 ​ 启动、停止挖矿 &gt; miner.start(10) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入 &gt; miner.stop() 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户： &gt; eth.coinbase &quot;0x67346d5619ae5747eb69629c8b1c8cbae71111c3&quot; getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币： &gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#39;ether&#39;) 发送一笔交易 &gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount}) 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0： &gt; personal.unlockAccount(eth.accounts[0]) 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易。 我们去查看账户1中的余额，发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证： &gt; txpool.status { pending: 1, queued: 0 } 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿： &gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了： &gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;) 10 查看交易 eth对象封装了查看交易和区块信息的方法。 查看当前区块总数： &gt; eth.blockNumber 3.建立节点集群 在私有网络中建立多个节点组成的集群,并互相发现,产生交易。 如果是为了在本地网络运行多个以太坊节点的实例,必须确保一下几点:1. 每个实例都有独立的数据目录(--datadir)2. 每个实例运行都有独立的端口.(eth和rpc两者都是)(--port 和 --rpcprot)3. 在集群的情况下, 实例之间都必须要知道彼此. 4. 唯一的ipc通信端点,或者禁用ipc. 在这里，我们选择在不同的电脑上分别建立节点组成集群，互相发现，产生交易。 在第一台电脑上启动节点 geth --datadir data0 --networkid 1008 console 在第二台电脑上初始化并启动节点，注意网络ID要相同，确保节点都在一个私有网络中。 geth --datadir ./data/01 init ./genesis.json 初始化 注意和第一个节点使用相同的创始快json文件 geth --datadir data0 --networkid 1008 --bootnodes &quot;enode://b86d51f0737672b80c9000caa706955b2a94286f8593774aab40c86cbb4fc871ce6853172871eef24bced4e6fa4576fb9d8fadfd0893b3f0873eddb9eb2072f2@192.168.6.150:30303&quot; console bootnodes后边的参数是第一台电脑上节点的enode url 可以在第一台电脑上通过 &gt;admin.nodeInfo.enode 来获取。 @192.168.6.150:30303 是第一台电脑的IP地址：192.168.150 以及ports：30303 本节点的ports可以通过 admin.nodeInfo 来获取。 至此两个节点应该就链接成功了。 3.1节点间发送以太币 &gt; eth.sendTransaction({from: &quot;0x5fba50fce50baf0b8a7314200ba46336958ac97e&quot;, to: &quot;0x0a8c35653d8b229c16f0c9ce6f63cffb877cfdcf&quot;, value: web3.toWei(1, &quot;ether&quot;)}) from中填当前节点的账号地址，to中填要发送给的节点的账号地址。 执行以上命令发送一个以太币。注意发送交易操作前要先解锁账号： &gt; personal.unlockAccount(eth.accounts[0], &quot;passwoed&quot;) 然后执行挖矿太能让交易生效。 &gt; miner.start() 4.编写helloworld智能合约&nbsp; &nbsp;让我们开始你的第一个严肃的合约。前沿是一个很大的开放领土，有时候你可能会感到孤独，所以我们的第一步就是创造一个自动伴侣，在你感到孤独时迎接你。我们会称他为“Greeter”。 &nbsp; &nbsp;Greeter是一个智能数字化实体，它存在于区块链中，并能够根据其输入与任何与之交互的人进行对话。它可能不是一个说话者，但它是一个很好的倾听者。这是它的代码： contract Mortal { /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() { owner = msg.sender; } /* Function to recover the funds on the contract */ function kill() { if (msg.sender == owner) selfdestruct(owner); } } contract Greeter is Mortal { /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public { greeting = _greeting; } /* Main function */ function greet() constant returns (string) { return greeting; } }&nbsp; &nbsp;你会注意到这个代码中有两个不同的合约：“Mortal”和“Greeter”。这是因为Solidity（我们使用的高级合同语言）具有继承性，这意味着一个合约可以继承另一个合约的特征。这对简化编码非常有用，因为合约的通用特征不需要每次重写，并且所有合约都可以用更小，更易读的块编写。所以通过只声明Greeter是Mortal的，你就继承了来自“Mortal”合约的所有特征，并使Greeter代码简单易读。 &nbsp; 继承特征的“Mortal”仅仅意味着Greeter合同可以被其所有者杀死，以清理区块链并在不再需要合同时收回锁定在其中的资金。以太坊中的契约默认为不朽，并且没有所有者，这意味着一旦部署，作者就没有特殊的特权了。部署前请考虑这一点。 &nbsp; 在部署合同前，需要准备两样东西： 1.编译后的代码。 2.应用程序二进制接口（ABI），它是一个定义如何与合约进行交互的JavaScript对象 &nbsp; 我们可以通过使用Solidity编译器来获得这两者。（在线编译器remix的地址：点击打开链接） 4.1获得编译后的代码 &nbsp; &nbsp;将源代码（位于本页顶部）复制到Remix，它应该自动编译您的代码。 您可以放心地忽略右侧任何黄色警告框。 &nbsp; 要访问已编译的代码，请确保右窗格中的下拉菜单已选中Greeter。 然后直接点击下拉菜单右边的details按钮。 在弹出窗口中，向下滚动并复制WEB3DEPLOY文本框中的所有代码。 &nbsp; 在计算机上创建一个临时文本文件并粘贴该代码。 确保将第一行更改为如下所示： var _greeting = &quot;Hello World!&quot; &nbsp; 现在，可以将结果文本粘贴到geth窗口中，或者使用loadScript（“yourFilename.js”）导入文件。 &nbsp;然后执行挖矿。 &nbsp; &nbsp;等待一会终端中会看到类似这样的消息： 您可能必须先使用您在开始时选择的密码来“解锁”发送交易的帐户，因为您需要支付部署合同的GAS费用。&nbsp; personal.unlockAccount（web3.eth.accounts [0]，“yourPassword”） 您可以使用以下命令来验证已部署的代码（将被编译）： eth.getCode(greeter.address) 如果它返回“0x”以外的任何内容，那么恭喜！ 你的小家伙活着！ 如果再次创建合同（通过执行另一个eth.sendTransaction），它将发布到新地址。 4.2 执行Greeter 为了召唤你的机器人，只需在终端上输入以下命令： greeter.greet(); 由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何燃气费用。 你应该看到它返回你的问候语： &#39;Hello World!&#39; 4.3&nbsp;让其他人与您的代码交互 为了让其他人来执行你的合同，他们需要两个东西： 1.合同所在地址 2. ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台 &nbsp; &nbsp; 想要获取地址，请运行以下命令： greeter.address; &nbsp; &nbsp; 得到类似下图的一个合约地址： &nbsp; &nbsp;为了得到ABI，您需要直接从Remix复制ABI，类似于复制WEB3DEPLOY编译代码的方式。 在右侧窗格中，单击详细信息按钮并向下滚动到ABI文本框。 点击复制按钮复制整个ABI，然后将其粘贴到临时文本文档中。 然后，您可以实例化一个可用于在连接到网络的任何计算机上调用合同的JavaScript对象。 在以下行中，替换ABI（一个数组）和Address（一个字符串）以在JavaScript中创建合同对象： var greeter = eth.contract(ABI).at(Address);这样别的节点就也可以通过 greeter.greet(); 调用你的机器人了。结果显示： &#39;Hello World!&#39; &nbsp;&nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/04/23/d1226bce7ebdcdbf592d32e6b2020d91.html","headline":"以太坊私有链搭建节点集群 到 简单helloworld智能合约编写 操作流程","dateModified":"2018-04-23T00:00:00+08:00","datePublished":"2018-04-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/04/23/d1226bce7ebdcdbf592d32e6b2020d91.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊私有链搭建节点集群 到 简单helloworld智能合约编写 操作流程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h6><span style="color:rgb(79,79,79);font-size:2.25em;font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;">1.选择一种以太坊客户端</span></h6>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择 geth工具来进行开发。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>Mac 中安装geth如下：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>brew tap ethereum/ethereum</span>
<span>brew install ethereum</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>检查是否安装成功：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>geth --help</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>如果输出一些帮助命令，则安装成功。</span></span></p>
  <h1 class="md-end-block md-heading" style="font-size:2.25em;line-height:1.2;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(238,238,238);width:inherit;"><span>2.搭建私有链</span></h1>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>json文件内容如下:</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>{</span>
<span>  "config": {</span>
<span> &nbsp; &nbsp; &nbsp;  "chainId": 10, </span>
<span> &nbsp; &nbsp; &nbsp;  "homesteadBlock": 0,</span>
<span> &nbsp; &nbsp; &nbsp;  "eip155Block": 0,</span>
<span> &nbsp; &nbsp; &nbsp;  "eip158Block": 0</span>
<span> &nbsp;  },</span>
<span>  "alloc" &nbsp; &nbsp;  : {},</span>
<span>  "coinbase" &nbsp; : "0x0000000000000000000000000000000000000000",</span>
<span>  "difficulty" : "0x20000",</span>
<span>  "extraData"  : "",</span>
<span>  "gasLimit" &nbsp; : "0x2fefd8",</span>
<span>  "nonce" &nbsp; &nbsp;  : "0x0000000000000042",</span>
<span>  "mixhash" &nbsp;  : "0x0000000000000000000000000000000000000000000000000000000000000000",</span>
<span>  "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000",</span>
<span>  "timestamp"  : "0x00"</span>
<span>}</span></pre>
  <h2 class="md-end-block md-heading" style="font-size:1.75em;line-height:1.225;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(238,238,238);width:inherit;"><span>2.1初始化：写入创世区块</span></h2>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： </span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;width:590px;text-align:center;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180422195854703" style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" alt=""></span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>接下来进入privatechain目录中，执行初始化命令：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>cd privatechain</span>
<span>geth --datadir data0 init genesis.json</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有</span><span><code style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;border:1px solid rgb(221,221,221);background-color:rgb(248,248,248);">Successfully wrote genesis state</code></span><span>字样，说明初始化成功。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>初始化成功后的目录如下： </span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;width:590px;text-align:center;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180422200141205" style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" alt=""></span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。</span></span></p>
  <h2 class="md-end-block md-heading" style="font-size:1.75em;line-height:1.225;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(238,238,238);width:inherit;"><span>2.2启动私有链节点</span></h2>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>geth --datadir data0 --networkid 1008 console</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1008，表示指定这个私有链的网络id为1008。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;width:590px;text-align:center;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180422201050622" style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" alt=""></span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>eth：包含一些跟操作区块链相关的方法 </span></span><span class="md-line md-end-block"><span>net：包含以下查看p2p网络状态的方法 </span></span><span class="md-line md-end-block"><span>admin：包含一些与管理节点相关的方法 </span></span><span class="md-line md-end-block"><span>miner：包含启动&amp;停止挖矿的一些方法 </span></span><span class="md-line md-end-block"><span>personal：主要包含一些管理账户的方法 </span></span><span class="md-line md-end-block"><span>txpool：包含一些查看交易内存池的方法 </span></span><span class="md-line md-end-block md-focus"><span class="md-expand">web3：包含了以上对象，还包含一些单位换算的方法</span></span></p>
  <h2 class="md-end-block md-heading" style="font-size:1.75em;line-height:1.225;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(238,238,238);width:inherit;"><span>2.3 Javascript Console</span></h2>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</span></span></p>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"><span>创建账户</span></h3>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; eth.accounts</span>
<span>[]</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>此时没有账户，接下来使用personal对象来创建一个账户：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; personal.newAccount()</span>
<span>&gt; Passphrase:</span>
<span>&gt; Repeat passphrase:</span>
<span>"0x67346d5619ae5747eb69629c8b1c8cbae71111c3"</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令:</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; personal.newAccount()</span>
<span>&gt; Passphrase:</span>
<span>&gt; Repeat passphrase:</span>
<span>"0xa48dba91281ee727c2424c85400f51f7a22716de"</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>这时候再去看账户，就有两个了。</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; eth.accounts</span>
<span>["0x67346d5619ae5747eb69629c8b1c8cbae71111c3", "0xa48dba91281ee727c2424c85400f51f7a22716de"]</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 </span></span></p>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"><span>查看账户余额</span></h3>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; eth.getBalance(eth.accounts[0])</span>
<span>0</span>
<span>&gt; eth.getBalance(eth.accounts[1])</span>
<span>0</span>
<span><span>​</span></span></pre>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"><span>启动、停止挖矿</span></h3>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; miner.start(10)</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; miner.stop()</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; eth.coinbase</span>
<span>"0x67346d5619ae5747eb69629c8b1c8cbae71111c3"</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),'ether')</span></pre>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"></h3>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"><span>发送一笔交易</span></h3>
  <p style="width:inherit;"><span class="md-line md-end-block"><span><code style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;border:1px solid rgb(221,221,221);background-color:rgb(248,248,248);">&gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})</code></span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; personal.unlockAccount(eth.accounts[0])</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>我们去查看账户1中的余额，发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; txpool.status</span>
<span>{</span>
<span>  pending: 1,</span>
<span>  queued: 0</span>
<span>}</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span></pre>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')</span>
<span>10</span></pre>
  <h3 class="md-end-block md-heading" style="font-size:1.5em;line-height:1.43;width:inherit;"><span>查看交易</span></h3>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>eth对象封装了查看交易和区块信息的方法。</span></span></p>
  <p style="width:inherit;"><span class="md-line md-end-block"><span>查看当前区块总数：</span></span></p>
  <pre class="md-fences md-end-block" style="font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;text-align:left;background-color:rgb(248,248,248);border:1px solid rgb(221,221,221);width:inherit;"><span>&gt; eth.blockNumber</span></pre>
  <h1>3.建立节点集群</h1>
  <p><span style="color:rgb(0,0,0);font-family:SimSun;background-color:rgb(255,255,255);"><span style="font-size:16px;">在私有网络中建立多个节点组成的集群,并互相发现,产生交易。</span></span></p>
  <p><span style="font-family:SimSun;background-color:rgb(255,255,255);"><span style="font-size:16px;"><span style="color:#000000;"><span style="font-family:'comic sans ms', sans-serif;">如果是为了在本地网络运行多个以太坊节点的实例,必须确保一下几点:</span><br style="font-family:verdana, arial, helvetica, sans-serif;"><span style="font-family:'comic sans ms', sans-serif;">1. 每个实例都有独立的数据目录(--datadir)</span><br style="font-family:verdana, arial, helvetica, sans-serif;"><span style="font-family:'comic sans ms', sans-serif;">2. 每个实例运行都有独立的端口.(eth和rpc两者都是)(--port 和 --rpcprot)</span><br style="font-family:verdana, arial, helvetica, sans-serif;"><span style="font-family:'comic sans ms', sans-serif;">3. 在集群的情况下, 实例之间都必须要知道彼此.</span><br style="font-family:verdana, arial, helvetica, sans-serif;"></span></span></span></p>
  <p><span style="font-family:SimSun;background-color:rgb(255,255,255);"><span style="font-size:16px;"><span style="color:#000000;"><span style="font-family:'comic sans ms', sans-serif;">4. 唯一的ipc通信端点,或者禁用ipc.</span></span></span></span></p>
  <p><span style="font-family:'comic sans ms', sans-serif;font-size:16px;color:#000000;"><span style="background-color:rgb(255,255,255);">在这里，我们选择在不同的电脑上分别建立节点组成集群，互相发现，产生交易。</span></span></p>
  <p><span style="font-family:'comic sans ms', sans-serif;font-size:16px;color:#000000;"><span style="background-color:rgb(255,255,255);">在第一台电脑上启动节点</span></span></p>
  <pre><code class="language-plain">geth --datadir data0 --networkid 1008 console</code></pre>
  <p><span style="font-family:'comic sans ms', sans-serif;font-size:16px;color:#000000;"><span style="background-color:rgb(255,255,255);">在第二台电脑上初始化并启动节点，注意网络ID要相同，确保节点都在一个私有网络中。</span></span></p>
  <pre><code class="language-plain">geth --datadir ./data/01 init ./genesis.json  初始化 注意和第一个节点使用相同的创始快json文件</code></pre>
  <br>
  <pre><code class="language-plain">geth --datadir data0 --networkid 1008 --bootnodes "enode://b86d51f0737672b80c9000caa706955b2a94286f8593774aab40c86cbb4fc871ce6853172871eef24bced4e6fa4576fb9d8fadfd0893b3f0873eddb9eb2072f2@192.168.6.150:30303" console</code></pre>
  <p>bootnodes后边的参数是第一台电脑上节点的enode url 可以在第一台电脑上通过</p>
  <pre><code class="language-plain"></code></pre>
  <p style="line-height:normal;font-family:'Monaco for Powerline';color:rgb(255,255,255);background-color:rgba(13,13,13,.8);"></p>
  <p style="line-height:normal;font-family:'Monaco for Powerline';color:rgb(255,255,255);background-color:rgba(13,13,13,.8);"><code class="language-plain"><span style="color:rgb(185,189,182);font-family:Consolas, 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace;text-align:left;background-color:rgb(27,36,38);"><span style="font-size:16px;">&gt;admin.nodeInfo.enode</span></span><span style="font-size:16px;"></span></code></p>
  <p><code class="language-plain">来获取。</code></p>
  <p></p>
  <pre class="plain"><code class="language-plain">@192.168.6.150:30303  是第一台电脑的IP地址：192.168.150 以及ports：30303</code></pre>
  <p>本节点的ports可以通过</p>
  <pre><code class="language-plain">admin.nodeInfo</code></pre>
  <p>来获取。</p>
  <p>至此两个节点应该就链接成功了。</p>
  <h2>3.1节点间发送以太币</h2>
  <pre><code class="language-plain">&gt; eth.sendTransaction({from: "0x5fba50fce50baf0b8a7314200ba46336958ac97e", to: "0x0a8c35653d8b229c16f0c9ce6f63cffb877cfdcf", value: web3.toWei(1, "ether")})</code></pre>
  <p>from中填当前节点的账号地址，to中填要发送给的节点的账号地址。</p>
  <p>执行以上命令发送一个以太币。注意发送交易操作前要先解锁账号：</p>
  <pre><code class="language-plain">&gt; personal.unlockAccount(eth.accounts[0], "passwoed")</code></pre>
  <p>然后执行挖矿太能让交易生效。</p>
  <pre><code class="language-plain">&gt; miner.start()</code></pre>
  <h1>4.编写helloworld智能合约</h1>&nbsp; &nbsp;让我们开始你的第一个严肃的合约。前沿是一个很大的开放领土，有时候你可能会感到孤独，所以我们的第一步就是创造一个自动伴侣，在你感到孤独时迎接你。我们会称他为“Greeter”。
  <br>
  <p>&nbsp; &nbsp;Greeter是一个智能数字化实体，它存在于区块链中，并能够根据其输入与任何与之交互的人进行对话。它可能不是一个说话者，但它是一个很好的倾听者。这是它的代码：</p>
  <pre><code class="language-plain">contract Mortal {
    /* Define variable owner of the type address */
    address owner;

    /* This function is executed at initialization and sets the owner of the contract */
    function Mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

contract Greeter is Mortal {
    /* Define variable greeting of the type string */
    string greeting;

    /* This runs when the contract is executed */
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    /* Main function */
    function greet() constant returns (string) {
        return greeting;
    }
}</code></pre>&nbsp; &nbsp;你会注意到这个代码中有两个不同的合约：“Mortal”和“Greeter”。这是因为Solidity（我们使用的高级合同语言）具有继承性，这意味着一个合约可以继承另一个合约的特征。这对简化编码非常有用，因为合约的通用特征不需要每次重写，并且所有合约都可以用更小，更易读的块编写。所以通过只声明Greeter是Mortal的，你就继承了来自“Mortal”合约的所有特征，并使Greeter代码简单易读。
  <br>
  <p>&nbsp; 继承特征的“Mortal”仅仅意味着Greeter合同可以被其所有者杀死，以清理区块链并在不再需要合同时收回锁定在其中的资金。以太坊中的契约默认为不朽，并且没有所有者，这意味着一旦部署，作者就没有特殊的特权了。部署前请考虑这一点。</p>
  <p>&nbsp; 在部署合同前，需要准备两样东西：</p>
  <p>1.编译后的代码。</p>
  <p>2.应用程序二进制接口（ABI），它是一个定义如何与合约进行交互的JavaScript对象</p>
  <p>&nbsp; 我们可以通过使用Solidity编译器来获得这两者。（在线编译器remix的地址：<a href="http://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.21+commit.dfe3193c.js" rel="nofollow">点击打开链接</a>）</p>
  <p></p>
  <h2>4.1获得编译后的代码</h2>
  <p>&nbsp; &nbsp;将源代码（位于本页顶部）复制到Remix，它应该自动编译您的代码。 您可以放心地忽略右侧任何黄色警告框。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180423173716765" alt=""><br></p>
  <p>&nbsp; 要访问已编译的代码，请确保右窗格中的下拉菜单已选中Greeter。 然后直接点击下拉菜单右边的details按钮。 在弹出窗口中，向下滚动并复制WEB3DEPLOY文本框中的所有代码。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018042317381640" alt=""><br></p>
  <br>
  <p>&nbsp; 在计算机上创建一个临时文本文件并粘贴该代码。 确保将第一行更改为如下所示：</p>
  <pre><code class="language-javascript">var _greeting = "Hello World!"</code></pre>
  <p>&nbsp; 现在，可以将结果文本粘贴到geth窗口中，或者使用loadScript（“yourFilename.js”）导入文件。</p>
  <p>&nbsp;然后执行挖矿。 &nbsp;</p>
  <p>&nbsp;等待一会终端中会看到类似这样的消息：</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180423183325522" alt=""><br></p>
  <p>您可能必须先使用您在开始时选择的密码来“解锁”发送交易的帐户，因为您需要支付部署合同的GAS费用。&nbsp;<br></p>
  <pre><code class="language-javascript">personal.unlockAccount（web3.eth.accounts [0]，“yourPassword”）</code></pre>
  <p>您可以使用以下命令来验证已部署的代码（将被编译）：</p>
  <pre><code class="language-javascript">eth.getCode(greeter.address)</code></pre>
  <p>如果它返回“0x”以外的任何内容，那么恭喜！ 你的小家伙活着！ 如果再次创建合同（通过执行另一个eth.sendTransaction），它将发布到新地址。</p>
  <h2>4.2 执行Greeter</h2>
  <p>为了召唤你的机器人，只需在终端上输入以下命令：</p>
  <pre><code class="language-javascript">greeter.greet();</code></pre>
  <p>由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何燃气费用。 你应该看到它返回你的问候语：<br></p>
  <pre><code class="language-javascript">'Hello World!'</code></pre>
  <h2>4.3&nbsp;让其他人与您的代码交互</h2>
  <div>
   为了让其他人来执行你的合同，他们需要两个东西：
   <br>1.合同所在地址
   <br>2. ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台
   <br>&nbsp; &nbsp; 想要获取地址，请运行以下命令：
  </div>
  <pre><code class="language-javascript">greeter.address;</code></pre>
  <p>&nbsp; &nbsp; 得到类似下图的一个合约地址：</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180423185237152" alt=""><br></p>
  <p>&nbsp; &nbsp;为了得到ABI，您需要直接从Remix复制ABI，类似于复制WEB3DEPLOY编译代码的方式。 在右侧窗格中，单击详细信息按钮并向下滚动到ABI文本框。 点击复制按钮复制整个ABI，然后将其粘贴到临时文本文档中。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018042319005121" alt=""><br></p>
  <br>
  <br>
  <p>然后，您可以实例化一个可用于在连接到网络的任何计算机上调用合同的JavaScript对象。 在以下行中，替换ABI（一个数组）和Address（一个字符串）以在JavaScript中创建合同对象：</p>
  <pre><code class="language-javascript">var greeter = eth.contract(ABI).at(Address);</code></pre>这样别的节点就也可以通过
  <br>
  <pre><code class="language-javascript">greeter.greet();</code></pre>
  <p>调用你的机器人了。结果显示：</p>
  <pre><code class="language-javascript">'Hello World!'</code></pre>
  <p>&nbsp;&nbsp;<br></p>
  <p><br></p>
  <br>
  <p><br></p>
  <br>
  <p><span style="font-family:'comic sans ms', sans-serif;font-size:16px;color:#000000;"><span style="background-color:rgb(255,255,255);"><br></span></span></p>
  <br style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif;">
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Jade0214/article/details/80043776,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Jade0214/article/details/80043776,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
