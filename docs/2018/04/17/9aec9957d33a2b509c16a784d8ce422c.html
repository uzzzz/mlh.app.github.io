<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码情景分析之区块数据结构 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码情景分析之区块数据结构" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="磁盘中区块(block)数据结构 区块由区块头+交易数据构成, 所以CBlock是继承CBlockHeader的 class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// network and disk &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;// memory only &nbsp;&nbsp;&nbsp;&nbsp;mutable bool fChecked; } class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; } 交易数据 class CTransaction { public: &nbsp;&nbsp;&nbsp;&nbsp;// Default transaction version. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t CURRENT_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// Changing the default transaction version requires a two step process: first &nbsp;&nbsp;&nbsp;&nbsp;// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date &nbsp;&nbsp;&nbsp;&nbsp;// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and &nbsp;&nbsp;&nbsp;&nbsp;// MAX_STANDARD_VERSION will be equal. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t MAX_STANDARD_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// The local variables are made const to prevent unintended modification &nbsp;&nbsp;&nbsp;&nbsp;// without updating the cached hash value. However, CTransaction is not &nbsp;&nbsp;&nbsp;&nbsp;// actually immutable; deserialization and assignment are implemented, &nbsp;&nbsp;&nbsp;&nbsp;// and bypass the constness. This is safe, as they update the entire &nbsp;&nbsp;&nbsp;&nbsp;// structure, including the hash. &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxIn&gt; vin; &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxOut&gt; vout; &nbsp;&nbsp;&nbsp;&nbsp;const int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;const uint32_t nLockTime; private: &nbsp;&nbsp;&nbsp;&nbsp;/** Memory only. */ &nbsp;&nbsp;&nbsp;&nbsp;const uint256 hash; } 一个交易有多个输入txin和多个输出txout构成 class CTxIn { public: &nbsp;&nbsp; &nbsp;&nbsp;COutPoint prevout; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nSequence; &nbsp;&nbsp;&nbsp;&nbsp;CScriptWitness scriptWitness; //! Only serialized through CTransaction } 交易输出txout,也就是UTXO(Unspent Transaction Output) class CTxOut { public: &nbsp;&nbsp;&nbsp;&nbsp;CAmount nValue; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptPubKey; } 上面的数据结构以文件的形式顺序存在~/.bitcoin/block/xxx.data 运行时区块(block)数据结构 &nbsp;&nbsp; &nbsp;上面的区块占用空间太大，运行时从磁盘读取出来保存在内存中不现实，因此系统运行时只加载blockheader, block的交易内容数据是动态按需加载.运行时的block对象是CBlockIndex，它的nFile(哪个文件)和mDataPos(文件的位置)字段指明区块内容的储存信息。 class CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex &nbsp;&nbsp;&nbsp;&nbsp;const uint256* phashBlock; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of the predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pprev; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of some further predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pskip; &nbsp;&nbsp;&nbsp;&nbsp;//! height of the entry in the chain. The genesis block has height 0 &nbsp;&nbsp;&nbsp;&nbsp;int nHeight; &nbsp;&nbsp;&nbsp;&nbsp;//! Which # file this block is stored in (blk?????.dat) &nbsp;&nbsp;&nbsp;&nbsp; int nFile; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within blk?????.dat where this block&#39;s data is stored &nbsp;&nbsp;&nbsp;&nbsp; unsigned int nDataPos; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within rev?????.dat where this block&#39;s undo data is stored &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nUndoPos; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block &nbsp;&nbsp;&nbsp;&nbsp;arith_uint256 nChainWork; &nbsp;&nbsp;&nbsp;&nbsp;//! Number of transactions in this block. &nbsp;&nbsp;&nbsp;&nbsp;//! Note: in a potential headers-first mode, this number cannot be relied upon &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTx; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Number of transactions in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;//! This value will be non-zero only if and only if transactions for this block and all its parents are available. &nbsp;&nbsp;&nbsp;&nbsp;//! Change to 64-bit type when necessary; won&#39;t happen before 2030 &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nChainTx; &nbsp;&nbsp;&nbsp;&nbsp;//! Verification status of this block. See enum BlockStatus &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nStatus; &nbsp;&nbsp;&nbsp;&nbsp;//! block header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Sequential id assigned to distinguish order in which blocks are received. &nbsp;&nbsp;&nbsp;&nbsp;int32_t nSequenceId; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Maximum nTime in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTimeMax; } &nbsp;&nbsp; &nbsp;CBlockIndex只包含区块头信息，同时新增pprev信息来维护链表结构.同时通过nFile，nDataPos间接引用区块交易数据，当需要交易信息的时候通过DataPos, nFile信息就可以从对应文件读取出来。CBlockIndex对应的存储结构是CDiskBlockIndex,多一个hashPrev字段, 这个字段对应CBlockIndex里的pprev,由于对象指针pprev存在数据库没有意义，只能存储hash（hashPrev） class CDiskBlockIndex : public CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrev; } CBlockIndex对象会通过pblocktree对象写入到数据库中，pblocktree将CBlockIndex转化为CDiskBlockIndex存储在leveldb等数据库里，数据库文件为~/.bitcoin/blocks/index/***.ldb std::unique_ptr&lt;CBlockTreeDB&gt; pblocktree bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &amp;info) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(std::make_pair(DB_BLOCK_FILES, nFile), info); } bool CBlockTreeDB::WriteReindexing(bool fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;if (fReindexing) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Write(DB_REINDEX_FLAG, &#39;1&#39;); &nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Erase(DB_REINDEX_FLAG); } bool CBlockTreeDB::ReadReindexing(bool &amp;fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;fReindexing = Exists(DB_REINDEX_FLAG); &nbsp;&nbsp;&nbsp;&nbsp;return true; } bool CBlockTreeDB::ReadLastBlockFile(int &amp;nFile) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(DB_LAST_BLOCK, nFile); } 比特币Coin相关数据结构 &nbsp;&nbsp; &nbsp;用户的资金是由utxo构成，一个utxo相当于一个coin,&nbsp; 一个coin的对象是Coin。 &nbsp;&nbsp; &nbsp;Coin也是存储在数据库中，以&lt;key, coin&gt;的方式存储，key是CoinEntry(CTxout)对象Serialize化后的值 class Coin { public: &nbsp;&nbsp;&nbsp;&nbsp;//! unspent transaction output &nbsp;&nbsp;&nbsp;&nbsp;CTxOut out; &nbsp;&nbsp;&nbsp;&nbsp;//! whether containing transaction was a coinbase &nbsp;&nbsp;&nbsp;&nbsp;unsigned int fCoinBase : 1; &nbsp;&nbsp;&nbsp;&nbsp;//! at which height this containing transaction was included in the active block chain &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nHeight : 31; &nbsp;&nbsp;&nbsp;&nbsp;//! construct a Coin from a CTxOut and height/coinbase information. &nbsp;&nbsp;&nbsp;&nbsp;Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;void Clear() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.SetNull(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = 0; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//! empty constructor &nbsp;&nbsp;&nbsp;&nbsp;Coin() : fCoinBase(false), nHeight(0) { } &nbsp;&nbsp;&nbsp;&nbsp;bool IsCoinBase() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; &nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!IsSpent()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = nHeight * 2 + fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, CTxOutCompressor(REF(out))); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp;void Unserialize(Stream &amp;s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = code &gt;&gt; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = code &amp; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, CTxOutCompressor(out)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool IsSpent() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return out.IsNull(); &nbsp;&nbsp;&nbsp;&nbsp;} }; struct CoinEntry { &nbsp;&nbsp;&nbsp;&nbsp;COutPoint* outpoint; &nbsp;&nbsp;&nbsp;&nbsp;char key; &nbsp;&nbsp;&nbsp;&nbsp;explicit CoinEntry(const COutPoint* ptr) : outpoint(const_cast&lt;COutPoint*&gt;(ptr)), key(DB_COIN)&nbsp;&nbsp;{} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; //key是DB_COIN+hash+n &nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;}w &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp; void Unserialize(Stream&amp; s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;} }; } Coin存取接口抽象类CCoinsView &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView保存和维护所有Coin的信息，它抽象出了Coin存取和查询的接口。具体实现是CCoinsViewDB class CCoinsView { public: &nbsp;&nbsp;&nbsp;&nbsp;/** Retrieve the Coin (unspent transaction output) for a given outpoint. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Returns true only when an unspent coin was found, which is returned in coin. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;When false is returned, coin&#39;s value is unspecified. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Just check whether a given outpoint is unspent. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool HaveCoin(const COutPoint &amp;outpoint) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the block hash whose state this CCoinsView currently represents &nbsp;&nbsp;&nbsp;&nbsp;virtual uint256 GetBestBlock() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the range of blocks that may have been only partially written. &nbsp;&nbsp;&nbsp;&nbsp;//! If the database is in a consistent state, the result is the empty vector. &nbsp;&nbsp;&nbsp;&nbsp;//! Otherwise, a two-element vector is returned consisting of the new and &nbsp;&nbsp;&nbsp;&nbsp;//! the old block hash, in that order. &nbsp;&nbsp;&nbsp;&nbsp;virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Do a bulk modification (multiple Coin changes + BestBlock change). &nbsp;&nbsp;&nbsp;&nbsp;//! The passed mapCoins can be modified. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;//! Get a cursor to iterate over the whole state &nbsp;&nbsp;&nbsp;&nbsp;virtual CCoinsViewCursor *Cursor() const; &nbsp;&nbsp;&nbsp;&nbsp;//! As we use CCoinsViews polymorphically, have a virtual destructor &nbsp;&nbsp;&nbsp;&nbsp;virtual ~CCoinsView() {} &nbsp;&nbsp;&nbsp;&nbsp;//! Estimate database size (0 if not implemented) &nbsp;&nbsp;&nbsp;&nbsp;virtual size_t EstimateSize() const { return 0; } }; class CCoinsViewDB final : public CCoinsView { } /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView *base; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewBacked(CCoinsView *viewIn); } class CCoinsViewCache : public CCoinsViewBacked { } //CCoinsViewMemPool即可以访问coin,又可以访问coin class CCoinsViewMemPool : public CCoinsViewBacked { protected: &nbsp;&nbsp;&nbsp;&nbsp;const CTxMemPool&amp; mempool; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool&amp; mempoolIn); &nbsp;&nbsp;&nbsp;&nbsp;bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; }; Coin存取实现类CCoinsViewDB bool CCoinsViewDB::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Read(CoinEntry(&amp;outpoint), coin); } bool CCoinsViewDB::HaveCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Exists(CoinEntry(&amp;outpoint)); } uint256 CCoinsViewDB::GetBestBlock() const { &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashBestChain; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_BEST_BLOCK, hashBestChain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return uint256(); &nbsp;&nbsp;&nbsp;&nbsp;return hashBestChain } std::vector&lt;uint256&gt; CCoinsViewDB::GetHeadBlocks() const { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint256&gt; vhashHeadBlocks; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::vector&lt;uint256&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return vhashHeadBlocks; } CCoinsViewDB根据CoinEntry从数据库读取指定的Coin, db是key-value数据库 Coin缓存管理类CCoinsViewCache CCoinsView之上又实现了一个Coin Cache对象:&nbsp;CCoinsViewCache&nbsp; CCoinsViewCache是coin的cache,它通过base(CCoinsViewDB)获取Coin并缓存 CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator it = cacheCoins.find(outpoint); &nbsp;&nbsp;&nbsp;&nbsp;if (it != cacheCoins.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return it; &nbsp;&nbsp;&nbsp;&nbsp;Coin tmp; &nbsp;&nbsp;&nbsp;&nbsp;if (!base-&gt;GetCoin(outpoint, tmp)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cacheCoins.end(); &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first; &nbsp;&nbsp;&nbsp;&nbsp;if (ret-&gt;second.coin.IsSpent()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The parent only has an empty entry for this outpoint; we can consider our &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// version as fresh. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret-&gt;second.flags = CCoinsCacheEntry::FRESH; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage += ret-&gt;second.coin.DynamicMemoryUsage(); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } CoinViewCache的base其实就是CCoinsViewDB bool CCoinsViewMemPool::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;// If an entry in the mempool exists, always return that one, as it&#39;s guaranteed to never &nbsp;&nbsp;&nbsp;&nbsp;// conflict with the underlying cache, and it cannot have pruned entries (as it contains full) &nbsp;&nbsp;&nbsp;&nbsp;// transactions. First checking the underlying cache risks returning a pruned entry instead. &nbsp;&nbsp;&nbsp;&nbsp;CTransactionRef ptx = mempool.get(outpoint.hash); &nbsp;&nbsp;&nbsp;&nbsp;if (ptx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (outpoint.n &lt; ptx-&gt;vout.size()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coin = Coin(ptx-&gt;vout[outpoint.n], MEMPOOL_HEIGHT, false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return base-&gt;GetCoin(outpoint, coin); } CCoinsViewDB,&nbsp;CCoinsViewCache初始化 std::unique_ptr&lt;CCoinsViewDB&gt; pcoinsdbview; std::unique_ptr&lt;CCoinsViewCache&gt; pcoinsTip; int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 &lt;&lt; 23)); // use 25%-50% of the remainder for disk cache pcoinsdbview .reset(new CCoinsViewDB( nCoinDBCache , false, fReset || fReindexChainState)); pcoinscatcher.reset (new CCoinsViewErrorCatcher( pcoinsdbview.get()) ); //CoinViewCache的base其实就是CCoinsViewDB pcoinsTip.reset(new CCoinsViewCache( pcoinscatcher.get ())); &nbsp; CBlockPolicyEstimator feeEstimator; CTxMemPool mempool(&amp;feeEstimator); CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool); 查询Coin RPC命令行可以通过gettxout命令查询coin UniValue gettxout(const JSONRPCRequest&amp; request) { &nbsp;&nbsp;&nbsp;&nbsp;if (request.fHelp || request.params.size() &lt; 2 || request.params.size() &gt; 3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gettxout \&quot;txid\&quot; n ( include_mempool )\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nReturns details about an unspent transaction output.\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nArguments:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;1. \&quot;txid\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string, required) The transaction id\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;2. \&quot;n\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric, required) vout number\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;3. \&quot;include_mempool\&quot;&nbsp;&nbsp;(boolean, optional) Whether to include the mempool. Default: true.&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that an unspent output that is spent in the mempool won&#39;t appear.\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nResult:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;bestblock\&quot; : \&quot;hash\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;(string) the block hash\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;confirmations\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The number of confirmations\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;value\&quot; : x.xxx,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The transaction value in &quot; + CURRENCY_UNIT + &quot;\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;scriptPubKey\&quot; : {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(json object)\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;asm\&quot; : \&quot;code\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;hex\&quot; : \&quot;hex\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;reqSigs\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) Number of required signatures\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;type\&quot; : \&quot;pubkeyhash\&quot;, (string) The type, eg pubkeyhash\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;addresses\&quot; : [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(array of string) array of bitcoin addresses\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;address\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) bitcoin address\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,...\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;},\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;coinbase\&quot; : true|false&nbsp;&nbsp;&nbsp;(boolean) Coinbase or not\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;}\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nExamples:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nGet unspent transactions\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;listunspent&quot;, &quot;&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nView the details\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;gettxout&quot;, &quot;\&quot;txid\&quot; 1&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nAs a json rpc call\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleRpc(&quot;gettxout&quot;, &quot;\&quot;txid\&quot;, 1&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_main); &nbsp;&nbsp;&nbsp;&nbsp;UniValue ret(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;std::string strHash = request.params[0].get_str(); &nbsp; &nbsp; //txid &nbsp;&nbsp;&nbsp;&nbsp;uint256 hash(uint256S(strHash)); &nbsp; &nbsp; //index &nbsp;&nbsp;&nbsp;&nbsp;int n = request.params[1].get_int(); &nbsp;&nbsp;&nbsp;&nbsp;COutPoint out(hash, n); &nbsp;&nbsp;&nbsp;&nbsp;bool fMempool = true; &nbsp;&nbsp;&nbsp;&nbsp;if (!request.params[2].isNull()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fMempool = request.params[2].get_bool(); &nbsp;&nbsp;&nbsp;&nbsp;Coin coin; &nbsp;&nbsp;&nbsp;&nbsp;if (fMempool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK(mempool.cs); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool view(pcoinsTip.get(), mempool); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!pcoinsTip-&gt;GetCoin(out, coin)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip-&gt;GetBestBlock()); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;bestblock&quot;, pindex-&gt;GetBlockHash().GetHex()); &nbsp;&nbsp;&nbsp;&nbsp;if (coin.nHeight == MEMPOOL_HEIGHT) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, 0); &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, (int64_t)(pindex-&gt;nHeight - coin.nHeight + 1)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;value&quot;, ValueFromAmount(coin.out.nValue)); &nbsp;&nbsp;&nbsp;&nbsp;UniValue o(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;scriptPubKey&quot;, o); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;coinbase&quot;, (bool)coin.fCoinBase); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } Coin对象的生成 &nbsp;&nbsp;&nbsp;&nbsp;节点收到新区块数据时会调用ConnectBlock，然后就会添加区块里的交易中的Coin &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectBlock-&gt;UpdateCoins-&gt;AddCoins void AddCoins(CCoinsViewCache&amp; cache, const CTransaction &amp;tx, int nHeight, bool check) { &nbsp;&nbsp;&nbsp;&nbsp;bool fCoinbase = tx.IsCoinBase(); &nbsp;&nbsp;&nbsp;&nbsp;const uint256&amp; txid = tx.GetHash(); &nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; tx.vout.size(); ++i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// deal with the pre-BIP30 occurrences of duplicate coinbase transactions. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite); &nbsp;&nbsp;&nbsp;&nbsp;} } FlushStateToDisk-&gt;cache.flush bool CCoinsViewCache::Flush() { &nbsp;&nbsp;&nbsp;&nbsp;bool fOk = base-&gt;BatchWrite(cacheCoins, hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;cacheCoins.clear(); &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage = 0; &nbsp;&nbsp;&nbsp;&nbsp;return fOk; } /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<meta property="og:description" content="磁盘中区块(block)数据结构 区块由区块头+交易数据构成, 所以CBlock是继承CBlockHeader的 class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// network and disk &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;// memory only &nbsp;&nbsp;&nbsp;&nbsp;mutable bool fChecked; } class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; } 交易数据 class CTransaction { public: &nbsp;&nbsp;&nbsp;&nbsp;// Default transaction version. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t CURRENT_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// Changing the default transaction version requires a two step process: first &nbsp;&nbsp;&nbsp;&nbsp;// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date &nbsp;&nbsp;&nbsp;&nbsp;// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and &nbsp;&nbsp;&nbsp;&nbsp;// MAX_STANDARD_VERSION will be equal. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t MAX_STANDARD_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// The local variables are made const to prevent unintended modification &nbsp;&nbsp;&nbsp;&nbsp;// without updating the cached hash value. However, CTransaction is not &nbsp;&nbsp;&nbsp;&nbsp;// actually immutable; deserialization and assignment are implemented, &nbsp;&nbsp;&nbsp;&nbsp;// and bypass the constness. This is safe, as they update the entire &nbsp;&nbsp;&nbsp;&nbsp;// structure, including the hash. &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxIn&gt; vin; &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxOut&gt; vout; &nbsp;&nbsp;&nbsp;&nbsp;const int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;const uint32_t nLockTime; private: &nbsp;&nbsp;&nbsp;&nbsp;/** Memory only. */ &nbsp;&nbsp;&nbsp;&nbsp;const uint256 hash; } 一个交易有多个输入txin和多个输出txout构成 class CTxIn { public: &nbsp;&nbsp; &nbsp;&nbsp;COutPoint prevout; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nSequence; &nbsp;&nbsp;&nbsp;&nbsp;CScriptWitness scriptWitness; //! Only serialized through CTransaction } 交易输出txout,也就是UTXO(Unspent Transaction Output) class CTxOut { public: &nbsp;&nbsp;&nbsp;&nbsp;CAmount nValue; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptPubKey; } 上面的数据结构以文件的形式顺序存在~/.bitcoin/block/xxx.data 运行时区块(block)数据结构 &nbsp;&nbsp; &nbsp;上面的区块占用空间太大，运行时从磁盘读取出来保存在内存中不现实，因此系统运行时只加载blockheader, block的交易内容数据是动态按需加载.运行时的block对象是CBlockIndex，它的nFile(哪个文件)和mDataPos(文件的位置)字段指明区块内容的储存信息。 class CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex &nbsp;&nbsp;&nbsp;&nbsp;const uint256* phashBlock; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of the predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pprev; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of some further predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pskip; &nbsp;&nbsp;&nbsp;&nbsp;//! height of the entry in the chain. The genesis block has height 0 &nbsp;&nbsp;&nbsp;&nbsp;int nHeight; &nbsp;&nbsp;&nbsp;&nbsp;//! Which # file this block is stored in (blk?????.dat) &nbsp;&nbsp;&nbsp;&nbsp; int nFile; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within blk?????.dat where this block&#39;s data is stored &nbsp;&nbsp;&nbsp;&nbsp; unsigned int nDataPos; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within rev?????.dat where this block&#39;s undo data is stored &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nUndoPos; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block &nbsp;&nbsp;&nbsp;&nbsp;arith_uint256 nChainWork; &nbsp;&nbsp;&nbsp;&nbsp;//! Number of transactions in this block. &nbsp;&nbsp;&nbsp;&nbsp;//! Note: in a potential headers-first mode, this number cannot be relied upon &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTx; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Number of transactions in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;//! This value will be non-zero only if and only if transactions for this block and all its parents are available. &nbsp;&nbsp;&nbsp;&nbsp;//! Change to 64-bit type when necessary; won&#39;t happen before 2030 &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nChainTx; &nbsp;&nbsp;&nbsp;&nbsp;//! Verification status of this block. See enum BlockStatus &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nStatus; &nbsp;&nbsp;&nbsp;&nbsp;//! block header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Sequential id assigned to distinguish order in which blocks are received. &nbsp;&nbsp;&nbsp;&nbsp;int32_t nSequenceId; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Maximum nTime in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTimeMax; } &nbsp;&nbsp; &nbsp;CBlockIndex只包含区块头信息，同时新增pprev信息来维护链表结构.同时通过nFile，nDataPos间接引用区块交易数据，当需要交易信息的时候通过DataPos, nFile信息就可以从对应文件读取出来。CBlockIndex对应的存储结构是CDiskBlockIndex,多一个hashPrev字段, 这个字段对应CBlockIndex里的pprev,由于对象指针pprev存在数据库没有意义，只能存储hash（hashPrev） class CDiskBlockIndex : public CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrev; } CBlockIndex对象会通过pblocktree对象写入到数据库中，pblocktree将CBlockIndex转化为CDiskBlockIndex存储在leveldb等数据库里，数据库文件为~/.bitcoin/blocks/index/***.ldb std::unique_ptr&lt;CBlockTreeDB&gt; pblocktree bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &amp;info) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(std::make_pair(DB_BLOCK_FILES, nFile), info); } bool CBlockTreeDB::WriteReindexing(bool fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;if (fReindexing) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Write(DB_REINDEX_FLAG, &#39;1&#39;); &nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Erase(DB_REINDEX_FLAG); } bool CBlockTreeDB::ReadReindexing(bool &amp;fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;fReindexing = Exists(DB_REINDEX_FLAG); &nbsp;&nbsp;&nbsp;&nbsp;return true; } bool CBlockTreeDB::ReadLastBlockFile(int &amp;nFile) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(DB_LAST_BLOCK, nFile); } 比特币Coin相关数据结构 &nbsp;&nbsp; &nbsp;用户的资金是由utxo构成，一个utxo相当于一个coin,&nbsp; 一个coin的对象是Coin。 &nbsp;&nbsp; &nbsp;Coin也是存储在数据库中，以&lt;key, coin&gt;的方式存储，key是CoinEntry(CTxout)对象Serialize化后的值 class Coin { public: &nbsp;&nbsp;&nbsp;&nbsp;//! unspent transaction output &nbsp;&nbsp;&nbsp;&nbsp;CTxOut out; &nbsp;&nbsp;&nbsp;&nbsp;//! whether containing transaction was a coinbase &nbsp;&nbsp;&nbsp;&nbsp;unsigned int fCoinBase : 1; &nbsp;&nbsp;&nbsp;&nbsp;//! at which height this containing transaction was included in the active block chain &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nHeight : 31; &nbsp;&nbsp;&nbsp;&nbsp;//! construct a Coin from a CTxOut and height/coinbase information. &nbsp;&nbsp;&nbsp;&nbsp;Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;void Clear() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.SetNull(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = 0; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//! empty constructor &nbsp;&nbsp;&nbsp;&nbsp;Coin() : fCoinBase(false), nHeight(0) { } &nbsp;&nbsp;&nbsp;&nbsp;bool IsCoinBase() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; &nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!IsSpent()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = nHeight * 2 + fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, CTxOutCompressor(REF(out))); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp;void Unserialize(Stream &amp;s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = code &gt;&gt; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = code &amp; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, CTxOutCompressor(out)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool IsSpent() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return out.IsNull(); &nbsp;&nbsp;&nbsp;&nbsp;} }; struct CoinEntry { &nbsp;&nbsp;&nbsp;&nbsp;COutPoint* outpoint; &nbsp;&nbsp;&nbsp;&nbsp;char key; &nbsp;&nbsp;&nbsp;&nbsp;explicit CoinEntry(const COutPoint* ptr) : outpoint(const_cast&lt;COutPoint*&gt;(ptr)), key(DB_COIN)&nbsp;&nbsp;{} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; //key是DB_COIN+hash+n &nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;}w &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp; void Unserialize(Stream&amp; s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;} }; } Coin存取接口抽象类CCoinsView &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView保存和维护所有Coin的信息，它抽象出了Coin存取和查询的接口。具体实现是CCoinsViewDB class CCoinsView { public: &nbsp;&nbsp;&nbsp;&nbsp;/** Retrieve the Coin (unspent transaction output) for a given outpoint. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Returns true only when an unspent coin was found, which is returned in coin. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;When false is returned, coin&#39;s value is unspecified. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Just check whether a given outpoint is unspent. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool HaveCoin(const COutPoint &amp;outpoint) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the block hash whose state this CCoinsView currently represents &nbsp;&nbsp;&nbsp;&nbsp;virtual uint256 GetBestBlock() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the range of blocks that may have been only partially written. &nbsp;&nbsp;&nbsp;&nbsp;//! If the database is in a consistent state, the result is the empty vector. &nbsp;&nbsp;&nbsp;&nbsp;//! Otherwise, a two-element vector is returned consisting of the new and &nbsp;&nbsp;&nbsp;&nbsp;//! the old block hash, in that order. &nbsp;&nbsp;&nbsp;&nbsp;virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Do a bulk modification (multiple Coin changes + BestBlock change). &nbsp;&nbsp;&nbsp;&nbsp;//! The passed mapCoins can be modified. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;//! Get a cursor to iterate over the whole state &nbsp;&nbsp;&nbsp;&nbsp;virtual CCoinsViewCursor *Cursor() const; &nbsp;&nbsp;&nbsp;&nbsp;//! As we use CCoinsViews polymorphically, have a virtual destructor &nbsp;&nbsp;&nbsp;&nbsp;virtual ~CCoinsView() {} &nbsp;&nbsp;&nbsp;&nbsp;//! Estimate database size (0 if not implemented) &nbsp;&nbsp;&nbsp;&nbsp;virtual size_t EstimateSize() const { return 0; } }; class CCoinsViewDB final : public CCoinsView { } /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView *base; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewBacked(CCoinsView *viewIn); } class CCoinsViewCache : public CCoinsViewBacked { } //CCoinsViewMemPool即可以访问coin,又可以访问coin class CCoinsViewMemPool : public CCoinsViewBacked { protected: &nbsp;&nbsp;&nbsp;&nbsp;const CTxMemPool&amp; mempool; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool&amp; mempoolIn); &nbsp;&nbsp;&nbsp;&nbsp;bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; }; Coin存取实现类CCoinsViewDB bool CCoinsViewDB::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Read(CoinEntry(&amp;outpoint), coin); } bool CCoinsViewDB::HaveCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Exists(CoinEntry(&amp;outpoint)); } uint256 CCoinsViewDB::GetBestBlock() const { &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashBestChain; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_BEST_BLOCK, hashBestChain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return uint256(); &nbsp;&nbsp;&nbsp;&nbsp;return hashBestChain } std::vector&lt;uint256&gt; CCoinsViewDB::GetHeadBlocks() const { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint256&gt; vhashHeadBlocks; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::vector&lt;uint256&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return vhashHeadBlocks; } CCoinsViewDB根据CoinEntry从数据库读取指定的Coin, db是key-value数据库 Coin缓存管理类CCoinsViewCache CCoinsView之上又实现了一个Coin Cache对象:&nbsp;CCoinsViewCache&nbsp; CCoinsViewCache是coin的cache,它通过base(CCoinsViewDB)获取Coin并缓存 CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator it = cacheCoins.find(outpoint); &nbsp;&nbsp;&nbsp;&nbsp;if (it != cacheCoins.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return it; &nbsp;&nbsp;&nbsp;&nbsp;Coin tmp; &nbsp;&nbsp;&nbsp;&nbsp;if (!base-&gt;GetCoin(outpoint, tmp)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cacheCoins.end(); &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first; &nbsp;&nbsp;&nbsp;&nbsp;if (ret-&gt;second.coin.IsSpent()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The parent only has an empty entry for this outpoint; we can consider our &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// version as fresh. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret-&gt;second.flags = CCoinsCacheEntry::FRESH; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage += ret-&gt;second.coin.DynamicMemoryUsage(); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } CoinViewCache的base其实就是CCoinsViewDB bool CCoinsViewMemPool::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;// If an entry in the mempool exists, always return that one, as it&#39;s guaranteed to never &nbsp;&nbsp;&nbsp;&nbsp;// conflict with the underlying cache, and it cannot have pruned entries (as it contains full) &nbsp;&nbsp;&nbsp;&nbsp;// transactions. First checking the underlying cache risks returning a pruned entry instead. &nbsp;&nbsp;&nbsp;&nbsp;CTransactionRef ptx = mempool.get(outpoint.hash); &nbsp;&nbsp;&nbsp;&nbsp;if (ptx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (outpoint.n &lt; ptx-&gt;vout.size()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coin = Coin(ptx-&gt;vout[outpoint.n], MEMPOOL_HEIGHT, false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return base-&gt;GetCoin(outpoint, coin); } CCoinsViewDB,&nbsp;CCoinsViewCache初始化 std::unique_ptr&lt;CCoinsViewDB&gt; pcoinsdbview; std::unique_ptr&lt;CCoinsViewCache&gt; pcoinsTip; int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 &lt;&lt; 23)); // use 25%-50% of the remainder for disk cache pcoinsdbview .reset(new CCoinsViewDB( nCoinDBCache , false, fReset || fReindexChainState)); pcoinscatcher.reset (new CCoinsViewErrorCatcher( pcoinsdbview.get()) ); //CoinViewCache的base其实就是CCoinsViewDB pcoinsTip.reset(new CCoinsViewCache( pcoinscatcher.get ())); &nbsp; CBlockPolicyEstimator feeEstimator; CTxMemPool mempool(&amp;feeEstimator); CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool); 查询Coin RPC命令行可以通过gettxout命令查询coin UniValue gettxout(const JSONRPCRequest&amp; request) { &nbsp;&nbsp;&nbsp;&nbsp;if (request.fHelp || request.params.size() &lt; 2 || request.params.size() &gt; 3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gettxout \&quot;txid\&quot; n ( include_mempool )\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nReturns details about an unspent transaction output.\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nArguments:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;1. \&quot;txid\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string, required) The transaction id\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;2. \&quot;n\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric, required) vout number\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;3. \&quot;include_mempool\&quot;&nbsp;&nbsp;(boolean, optional) Whether to include the mempool. Default: true.&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that an unspent output that is spent in the mempool won&#39;t appear.\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nResult:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;bestblock\&quot; : \&quot;hash\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;(string) the block hash\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;confirmations\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The number of confirmations\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;value\&quot; : x.xxx,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The transaction value in &quot; + CURRENCY_UNIT + &quot;\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;scriptPubKey\&quot; : {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(json object)\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;asm\&quot; : \&quot;code\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;hex\&quot; : \&quot;hex\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;reqSigs\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) Number of required signatures\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;type\&quot; : \&quot;pubkeyhash\&quot;, (string) The type, eg pubkeyhash\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;addresses\&quot; : [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(array of string) array of bitcoin addresses\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;address\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) bitcoin address\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,...\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;},\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\&quot;coinbase\&quot; : true|false&nbsp;&nbsp;&nbsp;(boolean) Coinbase or not\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;}\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nExamples:\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nGet unspent transactions\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;listunspent&quot;, &quot;&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nView the details\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;gettxout&quot;, &quot;\&quot;txid\&quot; 1&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nAs a json rpc call\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleRpc(&quot;gettxout&quot;, &quot;\&quot;txid\&quot;, 1&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_main); &nbsp;&nbsp;&nbsp;&nbsp;UniValue ret(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;std::string strHash = request.params[0].get_str(); &nbsp; &nbsp; //txid &nbsp;&nbsp;&nbsp;&nbsp;uint256 hash(uint256S(strHash)); &nbsp; &nbsp; //index &nbsp;&nbsp;&nbsp;&nbsp;int n = request.params[1].get_int(); &nbsp;&nbsp;&nbsp;&nbsp;COutPoint out(hash, n); &nbsp;&nbsp;&nbsp;&nbsp;bool fMempool = true; &nbsp;&nbsp;&nbsp;&nbsp;if (!request.params[2].isNull()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fMempool = request.params[2].get_bool(); &nbsp;&nbsp;&nbsp;&nbsp;Coin coin; &nbsp;&nbsp;&nbsp;&nbsp;if (fMempool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK(mempool.cs); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool view(pcoinsTip.get(), mempool); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!pcoinsTip-&gt;GetCoin(out, coin)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip-&gt;GetBestBlock()); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;bestblock&quot;, pindex-&gt;GetBlockHash().GetHex()); &nbsp;&nbsp;&nbsp;&nbsp;if (coin.nHeight == MEMPOOL_HEIGHT) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, 0); &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, (int64_t)(pindex-&gt;nHeight - coin.nHeight + 1)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;value&quot;, ValueFromAmount(coin.out.nValue)); &nbsp;&nbsp;&nbsp;&nbsp;UniValue o(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;scriptPubKey&quot;, o); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;coinbase&quot;, (bool)coin.fCoinBase); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } Coin对象的生成 &nbsp;&nbsp;&nbsp;&nbsp;节点收到新区块数据时会调用ConnectBlock，然后就会添加区块里的交易中的Coin &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectBlock-&gt;UpdateCoins-&gt;AddCoins void AddCoins(CCoinsViewCache&amp; cache, const CTransaction &amp;tx, int nHeight, bool check) { &nbsp;&nbsp;&nbsp;&nbsp;bool fCoinbase = tx.IsCoinBase(); &nbsp;&nbsp;&nbsp;&nbsp;const uint256&amp; txid = tx.GetHash(); &nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; tx.vout.size(); ++i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// deal with the pre-BIP30 occurrences of duplicate coinbase transactions. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite); &nbsp;&nbsp;&nbsp;&nbsp;} } FlushStateToDisk-&gt;cache.flush bool CCoinsViewCache::Flush() { &nbsp;&nbsp;&nbsp;&nbsp;bool fOk = base-&gt;BatchWrite(cacheCoins, hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;cacheCoins.clear(); &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage = 0; &nbsp;&nbsp;&nbsp;&nbsp;return fOk; } /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"磁盘中区块(block)数据结构 区块由区块头+交易数据构成, 所以CBlock是继承CBlockHeader的 class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// network and disk &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;// memory only &nbsp;&nbsp;&nbsp;&nbsp;mutable bool fChecked; } class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;// header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; } 交易数据 class CTransaction { public: &nbsp;&nbsp;&nbsp;&nbsp;// Default transaction version. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t CURRENT_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// Changing the default transaction version requires a two step process: first &nbsp;&nbsp;&nbsp;&nbsp;// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date &nbsp;&nbsp;&nbsp;&nbsp;// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and &nbsp;&nbsp;&nbsp;&nbsp;// MAX_STANDARD_VERSION will be equal. &nbsp;&nbsp;&nbsp;&nbsp;static const int32_t MAX_STANDARD_VERSION=2; &nbsp;&nbsp;&nbsp;&nbsp;// The local variables are made const to prevent unintended modification &nbsp;&nbsp;&nbsp;&nbsp;// without updating the cached hash value. However, CTransaction is not &nbsp;&nbsp;&nbsp;&nbsp;// actually immutable; deserialization and assignment are implemented, &nbsp;&nbsp;&nbsp;&nbsp;// and bypass the constness. This is safe, as they update the entire &nbsp;&nbsp;&nbsp;&nbsp;// structure, including the hash. &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxIn&gt; vin; &nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxOut&gt; vout; &nbsp;&nbsp;&nbsp;&nbsp;const int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;const uint32_t nLockTime; private: &nbsp;&nbsp;&nbsp;&nbsp;/** Memory only. */ &nbsp;&nbsp;&nbsp;&nbsp;const uint256 hash; } 一个交易有多个输入txin和多个输出txout构成 class CTxIn { public: &nbsp;&nbsp; &nbsp;&nbsp;COutPoint prevout; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptSig; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nSequence; &nbsp;&nbsp;&nbsp;&nbsp;CScriptWitness scriptWitness; //! Only serialized through CTransaction } 交易输出txout,也就是UTXO(Unspent Transaction Output) class CTxOut { public: &nbsp;&nbsp;&nbsp;&nbsp;CAmount nValue; &nbsp;&nbsp;&nbsp;&nbsp;CScript scriptPubKey; } 上面的数据结构以文件的形式顺序存在~/.bitcoin/block/xxx.data 运行时区块(block)数据结构 &nbsp;&nbsp; &nbsp;上面的区块占用空间太大，运行时从磁盘读取出来保存在内存中不现实，因此系统运行时只加载blockheader, block的交易内容数据是动态按需加载.运行时的block对象是CBlockIndex，它的nFile(哪个文件)和mDataPos(文件的位置)字段指明区块内容的储存信息。 class CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex &nbsp;&nbsp;&nbsp;&nbsp;const uint256* phashBlock; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of the predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pprev; &nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of some further predecessor of this block &nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pskip; &nbsp;&nbsp;&nbsp;&nbsp;//! height of the entry in the chain. The genesis block has height 0 &nbsp;&nbsp;&nbsp;&nbsp;int nHeight; &nbsp;&nbsp;&nbsp;&nbsp;//! Which # file this block is stored in (blk?????.dat) &nbsp;&nbsp;&nbsp;&nbsp; int nFile; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within blk?????.dat where this block&#39;s data is stored &nbsp;&nbsp;&nbsp;&nbsp; unsigned int nDataPos; &nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within rev?????.dat where this block&#39;s undo data is stored &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nUndoPos; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block &nbsp;&nbsp;&nbsp;&nbsp;arith_uint256 nChainWork; &nbsp;&nbsp;&nbsp;&nbsp;//! Number of transactions in this block. &nbsp;&nbsp;&nbsp;&nbsp;//! Note: in a potential headers-first mode, this number cannot be relied upon &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTx; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Number of transactions in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;//! This value will be non-zero only if and only if transactions for this block and all its parents are available. &nbsp;&nbsp;&nbsp;&nbsp;//! Change to 64-bit type when necessary; won&#39;t happen before 2030 &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nChainTx; &nbsp;&nbsp;&nbsp;&nbsp;//! Verification status of this block. See enum BlockStatus &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nStatus; &nbsp;&nbsp;&nbsp;&nbsp;//! block header &nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Sequential id assigned to distinguish order in which blocks are received. &nbsp;&nbsp;&nbsp;&nbsp;int32_t nSequenceId; &nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Maximum nTime in the chain up to and including this block. &nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTimeMax; } &nbsp;&nbsp; &nbsp;CBlockIndex只包含区块头信息，同时新增pprev信息来维护链表结构.同时通过nFile，nDataPos间接引用区块交易数据，当需要交易信息的时候通过DataPos, nFile信息就可以从对应文件读取出来。CBlockIndex对应的存储结构是CDiskBlockIndex,多一个hashPrev字段, 这个字段对应CBlockIndex里的pprev,由于对象指针pprev存在数据库没有意义，只能存储hash（hashPrev） class CDiskBlockIndex : public CBlockIndex { public: &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrev; } CBlockIndex对象会通过pblocktree对象写入到数据库中，pblocktree将CBlockIndex转化为CDiskBlockIndex存储在leveldb等数据库里，数据库文件为~/.bitcoin/blocks/index/***.ldb std::unique_ptr&lt;CBlockTreeDB&gt; pblocktree bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &amp;info) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(std::make_pair(DB_BLOCK_FILES, nFile), info); } bool CBlockTreeDB::WriteReindexing(bool fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;if (fReindexing) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Write(DB_REINDEX_FLAG, &#39;1&#39;); &nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Erase(DB_REINDEX_FLAG); } bool CBlockTreeDB::ReadReindexing(bool &amp;fReindexing) { &nbsp;&nbsp;&nbsp;&nbsp;fReindexing = Exists(DB_REINDEX_FLAG); &nbsp;&nbsp;&nbsp;&nbsp;return true; } bool CBlockTreeDB::ReadLastBlockFile(int &amp;nFile) { &nbsp;&nbsp;&nbsp;&nbsp;return Read(DB_LAST_BLOCK, nFile); } 比特币Coin相关数据结构 &nbsp;&nbsp; &nbsp;用户的资金是由utxo构成，一个utxo相当于一个coin,&nbsp; 一个coin的对象是Coin。 &nbsp;&nbsp; &nbsp;Coin也是存储在数据库中，以&lt;key, coin&gt;的方式存储，key是CoinEntry(CTxout)对象Serialize化后的值 class Coin { public: &nbsp;&nbsp;&nbsp;&nbsp;//! unspent transaction output &nbsp;&nbsp;&nbsp;&nbsp;CTxOut out; &nbsp;&nbsp;&nbsp;&nbsp;//! whether containing transaction was a coinbase &nbsp;&nbsp;&nbsp;&nbsp;unsigned int fCoinBase : 1; &nbsp;&nbsp;&nbsp;&nbsp;//! at which height this containing transaction was included in the active block chain &nbsp;&nbsp;&nbsp;&nbsp;uint32_t nHeight : 31; &nbsp;&nbsp;&nbsp;&nbsp;//! construct a Coin from a CTxOut and height/coinbase information. &nbsp;&nbsp;&nbsp;&nbsp;Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} &nbsp;&nbsp;&nbsp;&nbsp;void Clear() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.SetNull(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = 0; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//! empty constructor &nbsp;&nbsp;&nbsp;&nbsp;Coin() : fCoinBase(false), nHeight(0) { } &nbsp;&nbsp;&nbsp;&nbsp;bool IsCoinBase() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; &nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!IsSpent()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = nHeight * 2 + fCoinBase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, CTxOutCompressor(REF(out))); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp;void Unserialize(Stream &amp;s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, VARINT(code)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = code &gt;&gt; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = code &amp; 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, CTxOutCompressor(out)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bool IsSpent() const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return out.IsNull(); &nbsp;&nbsp;&nbsp;&nbsp;} }; struct CoinEntry { &nbsp;&nbsp;&nbsp;&nbsp;COutPoint* outpoint; &nbsp;&nbsp;&nbsp;&nbsp;char key; &nbsp;&nbsp;&nbsp;&nbsp;explicit CoinEntry(const COutPoint* ptr) : outpoint(const_cast&lt;COutPoint*&gt;(ptr)), key(DB_COIN)&nbsp;&nbsp;{} &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp; &nbsp; //key是DB_COIN+hash+n &nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream &amp;s) const { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;}w &nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt; &nbsp;&nbsp;&nbsp;&nbsp; void Unserialize(Stream&amp; s) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; key; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; outpoint-&gt;hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; VARINT(outpoint-&gt;n); &nbsp;&nbsp;&nbsp;&nbsp;} }; } Coin存取接口抽象类CCoinsView &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView保存和维护所有Coin的信息，它抽象出了Coin存取和查询的接口。具体实现是CCoinsViewDB class CCoinsView { public: &nbsp;&nbsp;&nbsp;&nbsp;/** Retrieve the Coin (unspent transaction output) for a given outpoint. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Returns true only when an unspent coin was found, which is returned in coin. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;When false is returned, coin&#39;s value is unspecified. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Just check whether a given outpoint is unspent. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool HaveCoin(const COutPoint &amp;outpoint) const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the block hash whose state this CCoinsView currently represents &nbsp;&nbsp;&nbsp;&nbsp;virtual uint256 GetBestBlock() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the range of blocks that may have been only partially written. &nbsp;&nbsp;&nbsp;&nbsp;//! If the database is in a consistent state, the result is the empty vector. &nbsp;&nbsp;&nbsp;&nbsp;//! Otherwise, a two-element vector is returned consisting of the new and &nbsp;&nbsp;&nbsp;&nbsp;//! the old block hash, in that order. &nbsp;&nbsp;&nbsp;&nbsp;virtual std::vector&lt;uint256&gt; GetHeadBlocks() const; &nbsp;&nbsp;&nbsp;&nbsp;//! Do a bulk modification (multiple Coin changes + BestBlock change). &nbsp;&nbsp;&nbsp;&nbsp;//! The passed mapCoins can be modified. &nbsp;&nbsp;&nbsp;&nbsp;virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;//! Get a cursor to iterate over the whole state &nbsp;&nbsp;&nbsp;&nbsp;virtual CCoinsViewCursor *Cursor() const; &nbsp;&nbsp;&nbsp;&nbsp;//! As we use CCoinsViews polymorphically, have a virtual destructor &nbsp;&nbsp;&nbsp;&nbsp;virtual ~CCoinsView() {} &nbsp;&nbsp;&nbsp;&nbsp;//! Estimate database size (0 if not implemented) &nbsp;&nbsp;&nbsp;&nbsp;virtual size_t EstimateSize() const { return 0; } }; class CCoinsViewDB final : public CCoinsView { } /** CCoinsView backed by another CCoinsView */ class CCoinsViewBacked : public CCoinsView { protected: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsView *base; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewBacked(CCoinsView *viewIn); } class CCoinsViewCache : public CCoinsViewBacked { } //CCoinsViewMemPool即可以访问coin,又可以访问coin class CCoinsViewMemPool : public CCoinsViewBacked { protected: &nbsp;&nbsp;&nbsp;&nbsp;const CTxMemPool&amp; mempool; public: &nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool&amp; mempoolIn); &nbsp;&nbsp;&nbsp;&nbsp;bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override; }; Coin存取实现类CCoinsViewDB bool CCoinsViewDB::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Read(CoinEntry(&amp;outpoint), coin); } bool CCoinsViewDB::HaveCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;return db.Exists(CoinEntry(&amp;outpoint)); } uint256 CCoinsViewDB::GetBestBlock() const { &nbsp;&nbsp;&nbsp;&nbsp;uint256 hashBestChain; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_BEST_BLOCK, hashBestChain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return uint256(); &nbsp;&nbsp;&nbsp;&nbsp;return hashBestChain } std::vector&lt;uint256&gt; CCoinsViewDB::GetHeadBlocks() const { &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint256&gt; vhashHeadBlocks; &nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::vector&lt;uint256&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return vhashHeadBlocks; } CCoinsViewDB根据CoinEntry从数据库读取指定的Coin, db是key-value数据库 Coin缓存管理类CCoinsViewCache CCoinsView之上又实现了一个Coin Cache对象:&nbsp;CCoinsViewCache&nbsp; CCoinsViewCache是coin的cache,它通过base(CCoinsViewDB)获取Coin并缓存 CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &amp;outpoint) const { &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator it = cacheCoins.find(outpoint); &nbsp;&nbsp;&nbsp;&nbsp;if (it != cacheCoins.end()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return it; &nbsp;&nbsp;&nbsp;&nbsp;Coin tmp; &nbsp;&nbsp;&nbsp;&nbsp;if (!base-&gt;GetCoin(outpoint, tmp)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cacheCoins.end(); &nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first; &nbsp;&nbsp;&nbsp;&nbsp;if (ret-&gt;second.coin.IsSpent()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The parent only has an empty entry for this outpoint; we can consider our &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// version as fresh. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret-&gt;second.flags = CCoinsCacheEntry::FRESH; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage += ret-&gt;second.coin.DynamicMemoryUsage(); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } CoinViewCache的base其实就是CCoinsViewDB bool CCoinsViewMemPool::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const { &nbsp;&nbsp;&nbsp;&nbsp;// If an entry in the mempool exists, always return that one, as it&#39;s guaranteed to never &nbsp;&nbsp;&nbsp;&nbsp;// conflict with the underlying cache, and it cannot have pruned entries (as it contains full) &nbsp;&nbsp;&nbsp;&nbsp;// transactions. First checking the underlying cache risks returning a pruned entry instead. &nbsp;&nbsp;&nbsp;&nbsp;CTransactionRef ptx = mempool.get(outpoint.hash); &nbsp;&nbsp;&nbsp;&nbsp;if (ptx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (outpoint.n &lt; ptx-&gt;vout.size()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coin = Coin(ptx-&gt;vout[outpoint.n], MEMPOOL_HEIGHT, false); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return base-&gt;GetCoin(outpoint, coin); } CCoinsViewDB,&nbsp;CCoinsViewCache初始化 std::unique_ptr&lt;CCoinsViewDB&gt; pcoinsdbview; std::unique_ptr&lt;CCoinsViewCache&gt; pcoinsTip; int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 &lt;&lt; 23)); // use 25%-50% of the remainder for disk cache pcoinsdbview .reset(new CCoinsViewDB( nCoinDBCache , false, fReset || fReindexChainState)); pcoinscatcher.reset (new CCoinsViewErrorCatcher( pcoinsdbview.get()) ); //CoinViewCache的base其实就是CCoinsViewDB pcoinsTip.reset(new CCoinsViewCache( pcoinscatcher.get ())); &nbsp; CBlockPolicyEstimator feeEstimator; CTxMemPool mempool(&amp;feeEstimator); CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool); 查询Coin RPC命令行可以通过gettxout命令查询coin UniValue gettxout(const JSONRPCRequest&amp; request) { &nbsp;&nbsp;&nbsp;&nbsp;if (request.fHelp || request.params.size() &lt; 2 || request.params.size() &gt; 3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gettxout \\&quot;txid\\&quot; n ( include_mempool )\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nReturns details about an unspent transaction output.\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nArguments:\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;1. \\&quot;txid\\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string, required) The transaction id\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;2. \\&quot;n\\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric, required) vout number\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;3. \\&quot;include_mempool\\&quot;&nbsp;&nbsp;(boolean, optional) Whether to include the mempool. Default: true.&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that an unspent output that is spent in the mempool won&#39;t appear.\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nResult:\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\\&quot;bestblock\\&quot; : \\&quot;hash\\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;(string) the block hash\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\\&quot;confirmations\\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The number of confirmations\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\\&quot;value\\&quot; : x.xxx,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The transaction value in &quot; + CURRENCY_UNIT + &quot;\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\\&quot;scriptPubKey\\&quot; : {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(json object)\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;asm\\&quot; : \\&quot;code\\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;hex\\&quot; : \\&quot;hex\\&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;reqSigs\\&quot; : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) Number of required signatures\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;type\\&quot; : \\&quot;pubkeyhash\\&quot;, (string) The type, eg pubkeyhash\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;addresses\\&quot; : [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(array of string) array of bitcoin addresses\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&quot;address\\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) bitcoin address\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,...\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;},\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;\\&quot;coinbase\\&quot; : true|false&nbsp;&nbsp;&nbsp;(boolean) Coinbase or not\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;}\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nExamples:\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nGet unspent transactions\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;listunspent&quot;, &quot;&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nView the details\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli(&quot;gettxout&quot;, &quot;\\&quot;txid\\&quot; 1&quot;) + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\\nAs a json rpc call\\n&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleRpc(&quot;gettxout&quot;, &quot;\\&quot;txid\\&quot;, 1&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_main); &nbsp;&nbsp;&nbsp;&nbsp;UniValue ret(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;std::string strHash = request.params[0].get_str(); &nbsp; &nbsp; //txid &nbsp;&nbsp;&nbsp;&nbsp;uint256 hash(uint256S(strHash)); &nbsp; &nbsp; //index &nbsp;&nbsp;&nbsp;&nbsp;int n = request.params[1].get_int(); &nbsp;&nbsp;&nbsp;&nbsp;COutPoint out(hash, n); &nbsp;&nbsp;&nbsp;&nbsp;bool fMempool = true; &nbsp;&nbsp;&nbsp;&nbsp;if (!request.params[2].isNull()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fMempool = request.params[2].get_bool(); &nbsp;&nbsp;&nbsp;&nbsp;Coin coin; &nbsp;&nbsp;&nbsp;&nbsp;if (fMempool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK(mempool.cs); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool view(pcoinsTip.get(), mempool); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!pcoinsTip-&gt;GetCoin(out, coin)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip-&gt;GetBestBlock()); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;bestblock&quot;, pindex-&gt;GetBlockHash().GetHex()); &nbsp;&nbsp;&nbsp;&nbsp;if (coin.nHeight == MEMPOOL_HEIGHT) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, 0); &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;confirmations&quot;, (int64_t)(pindex-&gt;nHeight - coin.nHeight + 1)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;value&quot;, ValueFromAmount(coin.out.nValue)); &nbsp;&nbsp;&nbsp;&nbsp;UniValue o(UniValue::VOBJ); &nbsp;&nbsp;&nbsp;&nbsp;ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;scriptPubKey&quot;, o); &nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV(&quot;coinbase&quot;, (bool)coin.fCoinBase); &nbsp;&nbsp;&nbsp;&nbsp;return ret; } Coin对象的生成 &nbsp;&nbsp;&nbsp;&nbsp;节点收到新区块数据时会调用ConnectBlock，然后就会添加区块里的交易中的Coin &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectBlock-&gt;UpdateCoins-&gt;AddCoins void AddCoins(CCoinsViewCache&amp; cache, const CTransaction &amp;tx, int nHeight, bool check) { &nbsp;&nbsp;&nbsp;&nbsp;bool fCoinbase = tx.IsCoinBase(); &nbsp;&nbsp;&nbsp;&nbsp;const uint256&amp; txid = tx.GetHash(); &nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; tx.vout.size(); ++i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// deal with the pre-BIP30 occurrences of duplicate coinbase transactions. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite); &nbsp;&nbsp;&nbsp;&nbsp;} } FlushStateToDisk-&gt;cache.flush bool CCoinsViewCache::Flush() { &nbsp;&nbsp;&nbsp;&nbsp;bool fOk = base-&gt;BatchWrite(cacheCoins, hashBlock); &nbsp;&nbsp;&nbsp;&nbsp;cacheCoins.clear(); &nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage = 0; &nbsp;&nbsp;&nbsp;&nbsp;return fOk; } /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多","@type":"BlogPosting","url":"/2018/04/17/9aec9957d33a2b509c16a784d8ce422c.html","headline":"比特币源码情景分析之区块数据结构","dateModified":"2018-04-17T00:00:00+08:00","datePublished":"2018-04-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/04/17/9aec9957d33a2b509c16a784d8ce422c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码情景分析之区块数据结构</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2><span style="font-size:24px;"><strong>磁盘中区块(block)数据结构</strong></span></h2>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">区块由区块头+交易数据构成, <span style="font-size:18px;">所以</span><span style="font-family:Monaco;color:rgb(51,51,51);">CBlock是继承CBlockHeader的</span></span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">class CBlock : public </span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">CBlockHeader</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// network and disk</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;CTransactionRef&gt; vtx;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// memory only</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;mutable bool fChecked;</span>
   </div>
   <div>
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CBlockHeader</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// header</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrevBlock;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce;</span>
   </div>
   <div>
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">交易数据</span>
  </div>
  <p></p>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CTransaction</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Default transaction version.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;static const int32_t CURRENT_VERSION=2;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// Changing the default transaction version requires a two step process: first</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// MAX_STANDARD_VERSION will be equal.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;static const int32_t MAX_STANDARD_VERSION=2;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// The local variables are made const to prevent unintended modification</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// without updating the cached hash value. However, CTransaction is not</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// actually immutable; deserialization and assignment are implemented,</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// and bypass the constness. This is safe, as they update the entire</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// structure, including the hash.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxIn&gt; vin;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;CTxOut&gt; vout;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;const int32_t nVersion;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;const uint32_t nLockTime;</span></span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">private:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;/** Memory only. */</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const uint256 hash;</span>
   </div>
   <div style="font-size:12px;">
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <p><span style="font-weight:normal;"><span style="font-size:16px;">一个交易有多个输入txin和多个输出txout构成</span></span></p>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CTxIn</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;COutPoint prevout;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;CScript scriptSig;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nSequence;</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;CScriptWitness scriptWitness; //! Only serialized through CTransaction</span></span>
   </div>
   <div style="font-size:12px;">
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">交易输出txout,也就是UTXO(<span style="color:rgb(51,51,51);font-family:arial;">Unspent Transaction Output</span>)</span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CTxOut</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;CAmount nValue;</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;CScript scriptPubKey;</span></span>
   </div>
   <div>
    }
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">上面的数据结构以文件的形式顺序存在~/.bitcoin/block/xxx.data</span>
  </div>
  <div>
   <span style="font-size:24px;"><span style="font-weight:bold;"><br></span></span>
  </div>
  <h2><span style="font-size:24px;"><span style="font-weight:bold;">运行时</span></span>区块(block)数据结构</h2>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;上面的区块占用空间太大，运行时从磁盘读取出来保存在内存中不现实，因此系统运行时只加载blockheader, block的交易内容数据是动态按需加载.运行时的block对象是CBlockIndex，它的<span style="font-family:Monaco;">nFile(哪个文件)和mDataPos(文件的位置)字段指明区块内容的储存信息</span><span style="font-family:Monaco;color:rgb(148,33,146);">。</span></span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CBlockIndex</span>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const uint256* phashBlock;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of the predecessor of this block</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pprev;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! pointer to the index of some further predecessor of this block</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CBlockIndex* pskip;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! height of the entry in the chain. The genesis block has height 0</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;int nHeight;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Which # file this block is stored in (blk?????.dat)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;"><span style="color:rgb(148,33,146);">int nFile;</span></span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within blk?????.dat where this block's data is stored</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;"><span style="color:rgb(148,33,146);">unsigned int nDataPos;</span></span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Byte offset within rev?????.dat where this block's undo data is stored</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nUndoPos;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;arith_uint256 nChainWork;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Number of transactions in this block.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Note: in a potential headers-first mode, this number cannot be relied upon</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTx;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Number of transactions in the chain up to and including this block.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! This value will be non-zero only if and only if transactions for this block and all its parents are available.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Change to 64-bit type when necessary; won't happen before 2030</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nChainTx;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Verification status of this block. See enum BlockStatus</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nStatus;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! block header</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;int32_t nVersion;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hashMerkleRoot;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nTime;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nBits;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nNonce;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Sequential id assigned to distinguish order in which blocks are received.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;int32_t nSequenceId;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! (memory only) Maximum nTime in the chain up to and including this block.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nTimeMax;</span>
   </div>
   <div>
    }
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;CBlockIndex只包含区块头信息，同时新增pprev信息来维护链表结构.同时通过<span style="font-family:Monaco;">nFile，nDataPos间接引用区块交易数据，当需要交易信息的时候通过DataPos, nFile信息就可以从对应文件读取出来。CBlockIndex对应的存储结构是CDiskBlockIndex,多一个hashPrev字段, 这个字段对应CBlockIndex里的pprev,由于对象指针pprev存在数据库没有意义，只能存储hash（<span style="font-family:Monaco;">hashPrev</span>）</span></span>
  </div>
  <div>
   <span style="font-size:16px;"><span style="font-family:Monaco;"><br></span></span>
  </div>
  <div>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div style="color:rgb(148,33,146);">
     <span style="font-family:Monaco;color:rgb(51,51,51);">class CDiskBlockIndex : public CBlockIndex</span>
    </div>
    <div style="color:rgb(148,33,146);">
     <span style="font-family:Monaco;color:rgb(51,51,51);">{</span>
    </div>
    <div style="color:rgb(148,33,146);">
     <span style="font-family:Monaco;color:rgb(51,51,51);">public:</span>
    </div>
    <div>
     <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hashPrev;</span></span>
    </div>
    <div style="color:rgb(148,33,146);">
     }
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">CBlockIndex对象会通过<span style="font-family:Monaco;">pblocktree对象写入到数据库中，pblocktree将CBlockIndex转化为CDiskBlockIndex存储在leveldb等数据库里，数据库文件为~/.bitcoin/blocks/index/***.ldb</span></span>
  </div>
  <div>
   <br>
  </div>
  <div>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <span style="font-family:Monaco;color:rgb(148,33,146);">std::unique_ptr&lt;CBlockTreeDB&gt; pblocktree</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:12px;"></span>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &amp;info) {</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return Read(std::make_pair(DB_BLOCK_FILES, nFile), info);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">bool CBlockTreeDB::WriteReindexing(bool fReindexing) {</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (fReindexing)</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Write(DB_REINDEX_FLAG, '1');</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;else</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Erase(DB_REINDEX_FLAG);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">bool CBlockTreeDB::ReadReindexing(bool &amp;fReindexing) {</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;fReindexing = Exists(DB_REINDEX_FLAG);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
    <div>
     <span style="font-family:Monaco;">bool CBlockTreeDB::ReadLastBlockFile(int &amp;nFile) {</span>
    </div>
    <div>
     <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return Read(DB_LAST_BLOCK, nFile);</span>
    </div>
    <div>
     <span style="font-family:Monaco;">}</span>
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <h2><span style="font-size:24px;font-family:Monaco;">比特币Coin相关数据结构</span></h2>
  <div>
   <span style="font-family:Monaco;"><span style="font-size:14px;">&nbsp;</span><span style="font-size:16px;">&nbsp; &nbsp;用户的资金是由utxo构成，一个utxo相当于一个coin,&nbsp;</span></span>
   <span style="font-family:Monaco;"><span style="font-size:16px;">一个coin的对象是Coin。</span></span>
  </div>
  <div>
   <span style="font-size:16px;"><span style="font-family:Monaco;">&nbsp;&nbsp; &nbsp;Coin也是存储在数据库中，以&lt;key, coin&gt;的方式存储，key是</span><span style="font-family:Monaco;">CoinEntry(CTxout)对象</span><span style="font-family:Monaco;">Serialize化后的值</span></span>
  </div>
  <div>
   <br style="font-family:Monaco;font-size:12px;color:rgb(148,33,146);">
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">class Coin</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! unspent transaction output</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#ff0000;">&nbsp;&nbsp;&nbsp;&nbsp;CTxOut out;</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! whether containing transaction was a coinbase</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;unsigned int fCoinBase : 1;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! at which height this containing transaction was included in the active block chain</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint32_t nHeight : 31;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! construct a Coin from a CTxOut and height/coinbase information.</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;void Clear() {</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.SetNull();</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = false;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = 0;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! empty constructor</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coin() : fCoinBase(false), nHeight(0) { }</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool IsCoinBase() const {</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fCoinBase;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp; &nbsp;</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;void Serialize(Stream &amp;s) const {</span></span>
    <br>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!IsSpent());</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = nHeight * 2 + fCoinBase;</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, VARINT(code));</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Serialize(s, CTxOutCompressor(REF(out)));</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;void Unserialize(Stream &amp;s) {</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t code = 0;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, VARINT(code));</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHeight = code &gt;&gt; 1;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fCoinBase = code &amp; 1;</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::Unserialize(s, CTxOutCompressor(out));</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <br style="font-family:Monaco;">
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool IsSpent() const {</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return out.IsNull();</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div style="color:rgb(51,51,51);">
    <span style="font-family:Monaco;">};</span>
   </div>
  </div>
  <div>
   <br style="font-family:Monaco;font-size:12px;color:rgb(148,33,146);">
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">struct CoinEntry {</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;COutPoint* outpoint;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;char key;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;explicit CoinEntry(const COutPoint* ptr) : outpoint(const_cast&lt;COutPoint*&gt;(ptr)), key(DB_COIN)&nbsp;&nbsp;{}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //key是DB_COIN+hash+n</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream &amp;s) const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; key;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; outpoint-&gt;hash;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; VARINT(outpoint-&gt;n);</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;}w</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;template&lt;typename Stream&gt;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">void Unserialize(Stream&amp; s) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; key;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; outpoint-&gt;hash;</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; VARINT(outpoint-&gt;n);</span>
   </div>
   <div>
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">};</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <span style="color:rgb(51,51,51);font-family:Monaco;font-size:18px;"><br></span>
  </div>
  <h3><span style="color:rgb(51,51,51);font-family:Monaco;font-size:18px;">Coin存取接口抽象类CCoinsView</span></h3>
  <p><span style="color:rgb(51,51,51);font-family:Monaco;"><span style="font-size:16px;">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsView保存和维护所有Coin的信息，它抽象出了Coin存取和查询的接口。具体实现是CCoinsViewDB</span></span></p>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">class CCoinsView</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;/** Retrieve the Coin (unspent transaction output) for a given outpoint.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Returns true only when an unspent coin was found, which is returned in coin.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;When false is returned, coin's value is unspecified.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;virtual bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const;</span></span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Just check whether a given outpoint is unspent.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual bool HaveCoin(const COutPoint &amp;outpoint) const;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the block hash whose state this CCoinsView currently represents</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual uint256 GetBestBlock() const;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Retrieve the range of blocks that may have been only partially written.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! If the database is in a consistent state, the result is the empty vector.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Otherwise, a two-element vector is returned consisting of the new and</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! the old block hash, in that order.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual std::vector&lt;uint256&gt; GetHeadBlocks() const;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Do a bulk modification (multiple Coin changes + BestBlock change).</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! The passed mapCoins can be modified.</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual bool BatchWrite(CCoinsMap &amp;mapCoins, const uint256 &amp;hashBlock);</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Get a cursor to iterate over the whole state</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual CCoinsViewCursor *Cursor() const;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! As we use CCoinsViews polymorphically, have a virtual destructor</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual ~CCoinsView() {}</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;//! Estimate database size (0 if not implemented)</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;virtual size_t EstimateSize() const { return 0; }</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">};</span>
   </div>
   <div style="font-size:12px;">
    <br>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">class CCoinsViewDB final : public CCoinsView {</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">}</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">/** CCoinsView backed by another CCoinsView */</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">class CCoinsViewBacked : public CCoinsView</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">protected:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsView *base;</span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(4,51,255);font-family:Monaco;">public:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;color:rgb(4,51,255);">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewBacked(CCoinsView *viewIn);</span>
   </div>
   <div style="font-size:12px;">
    }
   </div>
   <div style="font-size:12px;">
    <br>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">class CCoinsViewCache : public CCoinsViewBacked {</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">}</span>
   </div>
   <div style="font-size:12px;">
    <br>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;"><span style="color:#942192;">//CCoinsViewMemPool即可以访问coin,又可以访问coin</span></span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">class CCoinsViewMemPool : public CCoinsViewBacked</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">{</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">protected:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const CTxMemPool&amp; mempool;</span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">public:</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool&amp; mempoolIn);</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const override;</span>
   </div>
   <div style="font-size:12px;">
    <span style="font-family:Monaco;">};</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <h3><span style="color:rgb(51,51,51);font-family:Monaco;"><span style="font-size:16px;"></span></span></h3>
  <h3><span style="font-size:16px;"><span style="color:rgb(51,51,51);font-family:Monaco;">Coin存取实现类</span><span style="color:rgb(51,51,51);">CCoinsViewDB</span></span></h3>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(4,51,255);font-family:Monaco;">bool CCoinsViewDB::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return db.Read(CoinEntry(&amp;outpoint), coin);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">bool CCoinsViewDB::HaveCoin(const COutPoint &amp;outpoint) const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return db.Exists(CoinEntry(&amp;outpoint));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">uint256 CCoinsViewDB::GetBestBlock() const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hashBestChain;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_BEST_BLOCK, hashBestChain))</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return uint256();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return hashBestChain</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">std::vector&lt;uint256&gt; CCoinsViewDB::GetHeadBlocks() const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;uint256&gt; vhashHeadBlocks;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::vector&lt;uint256&gt;();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return vhashHeadBlocks;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;"><span style="color:rgb(51,51,51);font-family:Monaco;">CCoinsViewDB根据</span><span style="color:rgb(51,51,51);font-family:Monaco;">CoinEntry</span><span style="color:rgb(51,51,51);font-family:Monaco;">从数据库读取指定的Coin, db是key-value数据库</span></span>
  </div>
  <div>
   <span style="font-size:16px;"><span style="color:rgb(51,51,51);font-family:Monaco;"><br></span></span>
  </div>
  <h3><span style="font-size:16px;">Coin缓存管理类<span style="color:rgb(51,51,51);font-family:Monaco;">CCoinsViewCache</span></span></h3>
  <div>
   <span style="font-size:16px;">CCoinsView之上又实现了一个Coin Cache对象:&nbsp;<span style="color:rgb(51,51,51);font-family:Monaco;">CCoinsViewCache</span><span style="color:rgb(51,51,51);font-family:Monaco;">&nbsp;</span></span>
  </div>
  <div>
   <span style="color:rgb(51,51,51);font-family:Monaco;"><span style="font-size:16px;">CCoinsViewCache是coin的cache,它通过base(CCoinsViewDB)获取Coin并缓存</span></span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &amp;outpoint) const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator it = cacheCoins.find(outpoint);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (it != cacheCoins.end())</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return it;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coin tmp;</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;if (!base-&gt;GetCoin(outpoint, tmp))</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cacheCoins.end();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (ret-&gt;second.coin.IsSpent()) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The parent only has an empty entry for this outpoint; we can consider our</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// version as fresh.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret-&gt;second.flags = CCoinsCacheEntry::FRESH;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage += ret-&gt;second.coin.DynamicMemoryUsage();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return ret;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">CoinViewCache的base其实就是<span style="color:rgb(51,51,51);font-family:Monaco;">CCoinsViewDB</span></span>
  </div>
  <div>
   <br style="font-family:Monaco;font-size:12px;color:rgb(51,51,51);">
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">bool CCoinsViewMemPool::GetCoin(const COutPoint &amp;outpoint, Coin &amp;coin) const {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// If an entry in the mempool exists, always return that one, as it's guaranteed to never</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// conflict with the underlying cache, and it cannot have pruned entries (as it contains full)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;// transactions. First checking the underlying cache risks returning a pruned entry instead.</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CTransactionRef ptx = mempool.get(outpoint.hash);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (ptx) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (outpoint.n &lt; ptx-&gt;vout.size()) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coin = Coin(ptx-&gt;vout[outpoint.n], MEMPOOL_HEIGHT, false);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return base-&gt;GetCoin(outpoint, coin);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <h3><span style="font-size:16px;"><span style="color:rgb(4,51,255);font-family:Monaco;background-color:rgb(251,250,248);"><span style="color:rgb(51,51,51);font-family:Monaco;background-color:rgb(251,250,248);">CCoinsViewDB,&nbsp;</span><span style="color:rgb(51,51,51);font-family:Monaco;background-color:rgb(251,250,248);">CCoinsViewCache</span></span>初始化</span></h3>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">std::unique_ptr&lt;CCoinsViewDB&gt; pcoinsdbview;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">std::unique_ptr&lt;CCoinsViewCache&gt; pcoinsTip;</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">int64_t </span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">nCoinDBCache</span>
    <span style="font-family:Monaco;"> = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 &lt;&lt; 23)); // use 25%-50% of the remainder for disk cache</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">pcoinsdbview</span></span>
    <span style="font-family:Monaco;">.reset(new CCoinsViewDB(</span>
    <span style="font-family:Monaco;color:rgb(4,51,255);">nCoinDBCache</span>
    <span style="font-family:Monaco;">, false, fReset || fReindexChainState));</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">pcoinscatcher.reset</span></span>
    <span style="font-family:Monaco;">(new CCoinsViewErrorCatcher(</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">pcoinsdbview.get())</span></span>
    <span style="font-family:Monaco;">);</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">//CoinViewCache的base其实就是CCoinsViewDB</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">pcoinsTip.reset(new CCoinsViewCache(</span>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">pcoinscatcher.get</span></span>
    <span style="font-family:Monaco;">()));</span>
    <span style="color:rgb(148,33,146);font-family:Monaco;">&nbsp;</span>
   </div>
   <div>
    <br style="font-family:Monaco;color:rgb(148,33,146);">
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#000000;">CBlockPolicyEstimator feeEstimator;</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#000000;">CTxMemPool mempool(&amp;feeEstimator);</span></span>
   </div>
   <div>
    <br>
   </div>
   <div>
    <span style="color:rgb(148,33,146);font-family:Monaco;">CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <h3><span style="font-size:24px;"><span style="font-weight:bold;">查询Coin</span></span></h3>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">RPC命令行可以通过gettxout命令查询coin</span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">UniValue gettxout(const JSONRPCRequest&amp; request)</span>
    <br>
   </div>
   <div>
    <span style="font-family:Monaco;">{</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (request.fHelp || request.params.size() &lt; 2 || request.params.size() &gt; 3)</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error(</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"gettxout \"txid\" n ( include_mempool )\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nReturns details about an unspent transaction output.\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nArguments:\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1. \"txid\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string, required) The transaction id\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"2. \"n\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric, required) vout number\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3. \"include_mempool\"&nbsp;&nbsp;(boolean, optional) Whether to include the mempool. Default: true."</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that an unspent output that is spent in the mempool won't appear.\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nResult:\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;\"bestblock\" : \"hash\",&nbsp;&nbsp;&nbsp;&nbsp;(string) the block hash\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;\"confirmations\" : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The number of confirmations\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;\"value\" : x.xxx,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) The transaction value in " + CURRENCY_UNIT + "\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;\"scriptPubKey\" : {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(json object)\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"asm\" : \"code\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"hex\" : \"hex\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) \n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"reqSigs\" : n,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numeric) Number of required signatures\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"type\" : \"pubkeyhash\", (string) The type, eg pubkeyhash\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"addresses\" : [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(array of string) array of bitcoin addresses\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"address\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string) bitcoin address\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,...\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;},\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;\"coinbase\" : true|false&nbsp;&nbsp;&nbsp;(boolean) Coinbase or not\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"}\n"</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nExamples:\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nGet unspent transactions\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli("listunspent", "") +</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nView the details\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleCli("gettxout", "\"txid\" 1") +</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"\nAs a json rpc call\n"</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ HelpExampleRpc("gettxout", "\"txid\", 1")</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;LOCK(cs_main);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;UniValue ret(UniValue::VOBJ);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;std::string strHash = request.params[0].get_str();</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; //txid</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;uint256 hash(uint256S(strHash));</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp; &nbsp; //index</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;int n = request.params[1].get_int();</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;COutPoint out(hash, n);</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool fMempool = true;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (!request.params[2].isNull())</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fMempool = request.params[2].get_bool();</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coin coin;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (fMempool) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK(mempool.cs);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCoinsViewMemPool view(pcoinsTip.get(), mempool);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;} else {</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#0433ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!pcoinsTip-&gt;GetCoin(out, coin)) {</span></span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NullUniValue;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip-&gt;GetBestBlock());</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("bestblock", pindex-&gt;GetBlockHash().GetHex());</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;if (coin.nHeight == MEMPOOL_HEIGHT) {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("confirmations", 0);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;} else {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("confirmations", (int64_t)(pindex-&gt;nHeight - coin.nHeight + 1));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("value", ValueFromAmount(coin.out.nValue));</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;UniValue o(UniValue::VOBJ);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("scriptPubKey", o);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ret.pushKV("coinbase", (bool)coin.fCoinBase);</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return ret;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <h3><span style="font-size:24px;"><span style="font-weight:bold;">Coin对象的生成</span></span></h3>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp;&nbsp;&nbsp;节点收到新区块数据时会调用ConnectBlock，然后就会添加区块里的交易中的Coin</span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectBlock-&gt;UpdateCoins-&gt;AddCoins</span>
  </div>
  <div>
   <span style="font-size:14px;"><br></span>
  </div>
  <div>
   <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
    <div>
     <span style="font-family:Monaco;">void AddCoins(CCoinsViewCache&amp; cache, const CTransaction &amp;tx, int nHeight, bool check) {</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;bool fCoinbase = tx.IsCoinBase();</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;const uint256&amp; txid = tx.GetHash();</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; tx.vout.size(); ++i) {</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// deal with the pre-BIP30 occurrences of duplicate coinbase transactions.</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    </div>
    <div style="font-size:24px;">
     <span style="font-family:Monaco;font-size:12px;">}</span>
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;">FlushStateToDisk-&gt;cache.flush</span>
  </div>
  <div>
   <br>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="font-family:Monaco;">bool CCoinsViewCache::Flush() {</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;bool fOk = base-&gt;BatchWrite(cacheCoins, hashBlock);</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;cacheCoins.clear();</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;cachedCoinsUsage = 0;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;return fOk;</span>
   </div>
   <div>
    <span style="font-family:Monaco;">}</span>
   </div>
  </div>
  <div></div>
  <p><br></p>
  <div style="color:rgb(69,69,69);">
   <span style="font-size:18px;font-family:SimSun;">/********************************</span>
  </div>
  <div style="color:rgb(69,69,69);">
   <span style="font-size:18px;"><span style="line-height:19px;font-family:'Courier New';">* 本文来自CSDN博主"爱踢门"</span></span>
  </div>
  <div style="color:rgb(69,69,69);">
   <span style="font-size:18px;font-family:'Courier New';line-height:19px;">* 转载请标明出处</span>
   <span style="font-size:18px;background-color:rgb(255,255,255);font-family:'Courier New';line-height:19px;">:</span>
   <a href="http://blog.csdn.net/itleaks" rel="nofollow" style="font-size:18px;font-family:'Courier New';line-height:19px;">http://blog.csdn.net/itleaks</a>
  </div>
  <div style="color:rgb(69,69,69);">
   <span style="font-size:14px;font-family:SimSun;line-height:19px;">******************************************/</span>
  </div>
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180415143239928" alt="" style="border:0px;color:rgb(69,69,69);">
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/79974364,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/79974364,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
