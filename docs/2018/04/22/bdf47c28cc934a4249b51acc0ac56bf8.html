<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链技术之-非对称加密 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链技术之-非对称加密" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链技术不是一个新发明的技术，而是一个集成了多方面基础技术的综合性技术系统，是几个之前就有的基础技术的优雅组合而成。我认为，其中有四项必不可缺的核心技术，分别是：共识机制、密码学原理、链式哈希结构和分布式数据存储（多节点）。 密码学原理在区块链中，信息的传播按照公钥、私钥这种非对称数字加密技术实现交易双方的互相信任。非对称加密技术是区块链技术体系很重要的一部分。 公钥私钥的原则： 一个公钥对应一个私钥，公钥私钥成对出现。 密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。 公钥用来加密和验证数字签名；私钥用来解密和生成数字签名。生成数字签名本质上是用私钥进行加密，验证数字签名是用公钥对私钥加密密文进行解密。可以归纳为：如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。&nbsp; 如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 为什么用非对称加密？ &nbsp;一个网站要对传输进行加密，如果用对称加密，则有以下几种情况： 1 &nbsp;每个访问用户的秘钥相同。这种情况，服务器只要保存一个秘钥。除非你的网站用户是特定的内部用户，否则用户拿到秘钥就能对密文进行解密。 2 &nbsp;每个访问用户的秘钥不一样。这种情况，服务器需要保存大量秘钥。如果网站有上亿用户，则需要存储上亿的秘钥，维护成本巨大。 如果是非对称加密，网站只需要保存自己的私钥，用户可以随意下载网站公钥。 数字签名：就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。 数字签名了的文件的 完整性 是很容易验证的&nbsp; &nbsp;流程： （1） 被发送文件用密码散列函数（MD5,SHA,SM3）产生的摘要（2） 发送方用自己的私用密钥对摘要再加密，这就形成了数字签名。 （3） 将原文和加密的摘要同时传给对方。 （4） 对方用发送方的公共密钥对摘要解密，获取发送方生成的摘要，同时对收到的文件用SHA编码加密产生又一摘要。 （5） 将解密后的摘要和收到的文件在接收方重新加密产生的摘要相互对比。如两者一致，则说明传送过程中信息没有被破坏或篡改过。否则不然。 数字签名，可以保证收到的文件没有被篡改，也可以保证发送者的身份。因为私钥生产了数字签名，私钥是不公开的。 说了这么多，还是写段代码来试试看。 /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; import javax.crypto.Cipher; /** * * @author huyajun * @version $Id: RSAsecurityTest.java, v 0.1 2018年3月14日 下午6:09:53 huyajun Exp $ */ public class RSAsecurityTest { public static String PUBLIC_KEY = &quot;pub_key&quot;; public static String PRIVATE_KEY = &quot;pri_key&quot;; /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /////////////////////////////////////////////////////////////////////// /** * 公钥处理，返回base64编码的字符串 * @param file * @param rsaPublicKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 公钥处理后的字符串，base64编码 */ public static String publicKeyDeal(String file, String rsaPublicKeyStr, int model) { try { X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec( decryptBASE64(rsaPublicKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(model, publicKey); byte[] result = cipher.doFinal(decryptBASE64(file)); // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 私钥 处理，返回base64编码的字符串 * @param file * @param rsaPrivateKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 私钥处理后的字符串，base64编码 */ public static String privateKeyDeal(String file, String rsaPrivateKeyStr, int model) { try { //生成私钥 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec( decryptBASE64(rsaPrivateKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); //初始化加密 cipher.init(model, privateKey); byte[] result = cipher.doFinal(decryptBASE64(file)); //不能返回， new String(result) ,会出现乱码，导致没法解码 // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } public static String EncoderByMd5(String str) { try { MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] result = md5.digest(str.getBytes(&quot;utf-8&quot;)); return toHex(result); } catch (Exception e) { e.printStackTrace(); } return null; } private static String toHex(byte[] bytes) { final char[] HEX_DIGITS = &quot;0123456789ABCDEF&quot;.toCharArray(); StringBuilder ret = new StringBuilder(bytes.length * 2); for (int i = 0; i &lt; bytes.length; i++) { ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; 4) &amp; 0x0f]); ret.append(HEX_DIGITS[bytes[i] &amp; 0x0f]); } return ret.toString(); } public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String file = &quot;甜橙金融，互联网金融行业第三&quot;; // 公钥加密，私钥解密，常规用法； if (keyMap != null) { String str = publicKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PUBLIC_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;公钥对明文加密：&quot; + str); String str2 = privateKeyDeal(str, keyMap.get(PRIVATE_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;私钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); // 私钥加密，公钥解密，得到明文；-- 数字签名 用这个道理 if (keyMap != null) { String str = privateKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;私钥对明文加密：&quot; + str); String str2 = publicKeyDeal(str, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;公钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); ///////////////////////////////////////// // 数字签名 // 生产摘要 String md5Str = EncoderByMd5(file); System.out.println(&quot;发送方生成摘要：&quot; + md5Str); //2用私钥 对摘要进行加密 String signStr = privateKeyDeal(encryptBASE64(md5Str.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;发送方用私钥对摘要加密：&quot; + signStr); //3 发送原文+摘要密文（数字签名） 给接收方 System.out.println(&quot;接收方收到原文和摘要&quot;); //4 接收方用公钥解密摘要 String md5Str_Decrypt = new String(decryptBASE64(publicKeyDeal(signStr, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE))); System.out.println(&quot;接收方用公钥对摘要解密：&quot; + md5Str_Decrypt); //5 用同样的算法对原文生成摘要 String md5Str2 = EncoderByMd5(file); System.out.println(&quot;接收方生成的摘要：&quot; + md5Str2); //6 对比公钥解密的摘要和用原文生成的摘要 if (md5Str2.equals(md5Str_Decrypt)) { System.out.println(&quot;数字签名验证成功！&quot;); } else { System.out.println(&quot;数字签名验证失败！&quot;); } } } 代码可以看出来：用公钥加密后，用对应的私钥可以解密；反过来，私钥加密后，用对应的公钥也可以解密。 整个数字签名的流程稍微有点复杂。Java 还提供了专门的签名类，省去了这些繁琐的步骤。 代码如下： /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.Signature; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; /** * * @author huyajun * @version $Id: SignTest.java, v 0.1 2018年4月22日 下午7:29:08 huyajun Exp $ */ public class SignTest { private static final String PUBLIC_KEY = &quot;PUBLIC_KEY&quot;; private static final String PRIVATE_KEY = &quot;PRIVATE_KEY&quot;; /** * * @param args */ public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String content = &quot;123&quot;; String sign = null; try { sign = sign(content.getBytes(), keyMap.get(PRIVATE_KEY)); System.out.println(&quot;私钥签名结果：&quot; + sign); } catch (Exception e) { e.printStackTrace(); } //5.公钥验签 try { boolean flag = verify(content.getBytes(), keyMap.get(PUBLIC_KEY), sign); System.out.println(&quot;公钥验证数字签名：&quot; + flag); } catch (Exception e) { e.printStackTrace(); } } //////////////////////////////////////////////////////// /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /** * 私钥签名 * * @param data 原文件 * @param privateKey * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception { //构造PKCS8EncodedKeySpec对象 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(decryptBASE64(privateKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //取私钥匙对象 PrivateKey privateKeyObj = keyFactory.generatePrivate(pkcs8EncodedKeySpec); //用私钥对信息生成数字签名 Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initSign(privateKeyObj); signature.update(data); return encryptBASE64(signature.sign()); } /** * 校验数字签名 * @param data 加密数据 * @param publicKey 公钥 * @param sign 数字签名 * @return * @throws Exception */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception { //构造X509EncodedKeySpec对象 X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(decryptBASE64(publicKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //生成公钥匙对象 PublicKey publicKeyObj = keyFactory.generatePublic(x509EncodedKeySpec); Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initVerify(publicKeyObj); signature.update(data); //验证签名是否正常 return signature.verify(decryptBASE64(sign)); } } Signature 类帮我们实现了生成数字签名和校验数字签名的方法，直接用，比自己去实现方便的多。 Signature.getInstance(&quot;MD5withRSA&quot;); &nbsp; 表示用MD5做摘要，用RSA做加解密。同理你还可以选择SHA1withRSA 。 &nbsp;注意生成签名和验签的方法要相同。 今天就讲到这里，下一篇文章，我们介绍区块链知识点之--共识算法。敬请期待 作者简介：甜橙金融技术部技术总监，负责公司核心平台设计与开发，新技术预研与落地。10年代码和架构设计经验，之前在国内知名一线互联网公司从事核心系统的开发和设计。 阅读更多" />
<meta property="og:description" content="区块链技术不是一个新发明的技术，而是一个集成了多方面基础技术的综合性技术系统，是几个之前就有的基础技术的优雅组合而成。我认为，其中有四项必不可缺的核心技术，分别是：共识机制、密码学原理、链式哈希结构和分布式数据存储（多节点）。 密码学原理在区块链中，信息的传播按照公钥、私钥这种非对称数字加密技术实现交易双方的互相信任。非对称加密技术是区块链技术体系很重要的一部分。 公钥私钥的原则： 一个公钥对应一个私钥，公钥私钥成对出现。 密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。 公钥用来加密和验证数字签名；私钥用来解密和生成数字签名。生成数字签名本质上是用私钥进行加密，验证数字签名是用公钥对私钥加密密文进行解密。可以归纳为：如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。&nbsp; 如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 为什么用非对称加密？ &nbsp;一个网站要对传输进行加密，如果用对称加密，则有以下几种情况： 1 &nbsp;每个访问用户的秘钥相同。这种情况，服务器只要保存一个秘钥。除非你的网站用户是特定的内部用户，否则用户拿到秘钥就能对密文进行解密。 2 &nbsp;每个访问用户的秘钥不一样。这种情况，服务器需要保存大量秘钥。如果网站有上亿用户，则需要存储上亿的秘钥，维护成本巨大。 如果是非对称加密，网站只需要保存自己的私钥，用户可以随意下载网站公钥。 数字签名：就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。 数字签名了的文件的 完整性 是很容易验证的&nbsp; &nbsp;流程： （1） 被发送文件用密码散列函数（MD5,SHA,SM3）产生的摘要（2） 发送方用自己的私用密钥对摘要再加密，这就形成了数字签名。 （3） 将原文和加密的摘要同时传给对方。 （4） 对方用发送方的公共密钥对摘要解密，获取发送方生成的摘要，同时对收到的文件用SHA编码加密产生又一摘要。 （5） 将解密后的摘要和收到的文件在接收方重新加密产生的摘要相互对比。如两者一致，则说明传送过程中信息没有被破坏或篡改过。否则不然。 数字签名，可以保证收到的文件没有被篡改，也可以保证发送者的身份。因为私钥生产了数字签名，私钥是不公开的。 说了这么多，还是写段代码来试试看。 /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; import javax.crypto.Cipher; /** * * @author huyajun * @version $Id: RSAsecurityTest.java, v 0.1 2018年3月14日 下午6:09:53 huyajun Exp $ */ public class RSAsecurityTest { public static String PUBLIC_KEY = &quot;pub_key&quot;; public static String PRIVATE_KEY = &quot;pri_key&quot;; /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /////////////////////////////////////////////////////////////////////// /** * 公钥处理，返回base64编码的字符串 * @param file * @param rsaPublicKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 公钥处理后的字符串，base64编码 */ public static String publicKeyDeal(String file, String rsaPublicKeyStr, int model) { try { X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec( decryptBASE64(rsaPublicKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(model, publicKey); byte[] result = cipher.doFinal(decryptBASE64(file)); // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 私钥 处理，返回base64编码的字符串 * @param file * @param rsaPrivateKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 私钥处理后的字符串，base64编码 */ public static String privateKeyDeal(String file, String rsaPrivateKeyStr, int model) { try { //生成私钥 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec( decryptBASE64(rsaPrivateKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); //初始化加密 cipher.init(model, privateKey); byte[] result = cipher.doFinal(decryptBASE64(file)); //不能返回， new String(result) ,会出现乱码，导致没法解码 // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } public static String EncoderByMd5(String str) { try { MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] result = md5.digest(str.getBytes(&quot;utf-8&quot;)); return toHex(result); } catch (Exception e) { e.printStackTrace(); } return null; } private static String toHex(byte[] bytes) { final char[] HEX_DIGITS = &quot;0123456789ABCDEF&quot;.toCharArray(); StringBuilder ret = new StringBuilder(bytes.length * 2); for (int i = 0; i &lt; bytes.length; i++) { ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; 4) &amp; 0x0f]); ret.append(HEX_DIGITS[bytes[i] &amp; 0x0f]); } return ret.toString(); } public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String file = &quot;甜橙金融，互联网金融行业第三&quot;; // 公钥加密，私钥解密，常规用法； if (keyMap != null) { String str = publicKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PUBLIC_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;公钥对明文加密：&quot; + str); String str2 = privateKeyDeal(str, keyMap.get(PRIVATE_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;私钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); // 私钥加密，公钥解密，得到明文；-- 数字签名 用这个道理 if (keyMap != null) { String str = privateKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;私钥对明文加密：&quot; + str); String str2 = publicKeyDeal(str, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;公钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); ///////////////////////////////////////// // 数字签名 // 生产摘要 String md5Str = EncoderByMd5(file); System.out.println(&quot;发送方生成摘要：&quot; + md5Str); //2用私钥 对摘要进行加密 String signStr = privateKeyDeal(encryptBASE64(md5Str.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;发送方用私钥对摘要加密：&quot; + signStr); //3 发送原文+摘要密文（数字签名） 给接收方 System.out.println(&quot;接收方收到原文和摘要&quot;); //4 接收方用公钥解密摘要 String md5Str_Decrypt = new String(decryptBASE64(publicKeyDeal(signStr, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE))); System.out.println(&quot;接收方用公钥对摘要解密：&quot; + md5Str_Decrypt); //5 用同样的算法对原文生成摘要 String md5Str2 = EncoderByMd5(file); System.out.println(&quot;接收方生成的摘要：&quot; + md5Str2); //6 对比公钥解密的摘要和用原文生成的摘要 if (md5Str2.equals(md5Str_Decrypt)) { System.out.println(&quot;数字签名验证成功！&quot;); } else { System.out.println(&quot;数字签名验证失败！&quot;); } } } 代码可以看出来：用公钥加密后，用对应的私钥可以解密；反过来，私钥加密后，用对应的公钥也可以解密。 整个数字签名的流程稍微有点复杂。Java 还提供了专门的签名类，省去了这些繁琐的步骤。 代码如下： /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.Signature; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; /** * * @author huyajun * @version $Id: SignTest.java, v 0.1 2018年4月22日 下午7:29:08 huyajun Exp $ */ public class SignTest { private static final String PUBLIC_KEY = &quot;PUBLIC_KEY&quot;; private static final String PRIVATE_KEY = &quot;PRIVATE_KEY&quot;; /** * * @param args */ public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String content = &quot;123&quot;; String sign = null; try { sign = sign(content.getBytes(), keyMap.get(PRIVATE_KEY)); System.out.println(&quot;私钥签名结果：&quot; + sign); } catch (Exception e) { e.printStackTrace(); } //5.公钥验签 try { boolean flag = verify(content.getBytes(), keyMap.get(PUBLIC_KEY), sign); System.out.println(&quot;公钥验证数字签名：&quot; + flag); } catch (Exception e) { e.printStackTrace(); } } //////////////////////////////////////////////////////// /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /** * 私钥签名 * * @param data 原文件 * @param privateKey * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception { //构造PKCS8EncodedKeySpec对象 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(decryptBASE64(privateKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //取私钥匙对象 PrivateKey privateKeyObj = keyFactory.generatePrivate(pkcs8EncodedKeySpec); //用私钥对信息生成数字签名 Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initSign(privateKeyObj); signature.update(data); return encryptBASE64(signature.sign()); } /** * 校验数字签名 * @param data 加密数据 * @param publicKey 公钥 * @param sign 数字签名 * @return * @throws Exception */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception { //构造X509EncodedKeySpec对象 X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(decryptBASE64(publicKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //生成公钥匙对象 PublicKey publicKeyObj = keyFactory.generatePublic(x509EncodedKeySpec); Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initVerify(publicKeyObj); signature.update(data); //验证签名是否正常 return signature.verify(decryptBASE64(sign)); } } Signature 类帮我们实现了生成数字签名和校验数字签名的方法，直接用，比自己去实现方便的多。 Signature.getInstance(&quot;MD5withRSA&quot;); &nbsp; 表示用MD5做摘要，用RSA做加解密。同理你还可以选择SHA1withRSA 。 &nbsp;注意生成签名和验签的方法要相同。 今天就讲到这里，下一篇文章，我们介绍区块链知识点之--共识算法。敬请期待 作者简介：甜橙金融技术部技术总监，负责公司核心平台设计与开发，新技术预研与落地。10年代码和架构设计经验，之前在国内知名一线互联网公司从事核心系统的开发和设计。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/04/22/bdf47c28cc934a4249b51acc0ac56bf8.html" />
<meta property="og:url" content="https://mlh.app/2018/04/22/bdf47c28cc934a4249b51acc0ac56bf8.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链技术不是一个新发明的技术，而是一个集成了多方面基础技术的综合性技术系统，是几个之前就有的基础技术的优雅组合而成。我认为，其中有四项必不可缺的核心技术，分别是：共识机制、密码学原理、链式哈希结构和分布式数据存储（多节点）。 密码学原理在区块链中，信息的传播按照公钥、私钥这种非对称数字加密技术实现交易双方的互相信任。非对称加密技术是区块链技术体系很重要的一部分。 公钥私钥的原则： 一个公钥对应一个私钥，公钥私钥成对出现。 密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。 公钥用来加密和验证数字签名；私钥用来解密和生成数字签名。生成数字签名本质上是用私钥进行加密，验证数字签名是用公钥对私钥加密密文进行解密。可以归纳为：如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。&nbsp; 如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 为什么用非对称加密？ &nbsp;一个网站要对传输进行加密，如果用对称加密，则有以下几种情况： 1 &nbsp;每个访问用户的秘钥相同。这种情况，服务器只要保存一个秘钥。除非你的网站用户是特定的内部用户，否则用户拿到秘钥就能对密文进行解密。 2 &nbsp;每个访问用户的秘钥不一样。这种情况，服务器需要保存大量秘钥。如果网站有上亿用户，则需要存储上亿的秘钥，维护成本巨大。 如果是非对称加密，网站只需要保存自己的私钥，用户可以随意下载网站公钥。 数字签名：就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。 数字签名了的文件的 完整性 是很容易验证的&nbsp; &nbsp;流程： （1） 被发送文件用密码散列函数（MD5,SHA,SM3）产生的摘要（2） 发送方用自己的私用密钥对摘要再加密，这就形成了数字签名。 （3） 将原文和加密的摘要同时传给对方。 （4） 对方用发送方的公共密钥对摘要解密，获取发送方生成的摘要，同时对收到的文件用SHA编码加密产生又一摘要。 （5） 将解密后的摘要和收到的文件在接收方重新加密产生的摘要相互对比。如两者一致，则说明传送过程中信息没有被破坏或篡改过。否则不然。 数字签名，可以保证收到的文件没有被篡改，也可以保证发送者的身份。因为私钥生产了数字签名，私钥是不公开的。 说了这么多，还是写段代码来试试看。 /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; import javax.crypto.Cipher; /** * * @author huyajun * @version $Id: RSAsecurityTest.java, v 0.1 2018年3月14日 下午6:09:53 huyajun Exp $ */ public class RSAsecurityTest { public static String PUBLIC_KEY = &quot;pub_key&quot;; public static String PRIVATE_KEY = &quot;pri_key&quot;; /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /////////////////////////////////////////////////////////////////////// /** * 公钥处理，返回base64编码的字符串 * @param file * @param rsaPublicKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 公钥处理后的字符串，base64编码 */ public static String publicKeyDeal(String file, String rsaPublicKeyStr, int model) { try { X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec( decryptBASE64(rsaPublicKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(model, publicKey); byte[] result = cipher.doFinal(decryptBASE64(file)); // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 私钥 处理，返回base64编码的字符串 * @param file * @param rsaPrivateKeyStr * @param model 加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE * @return 私钥处理后的字符串，base64编码 */ public static String privateKeyDeal(String file, String rsaPrivateKeyStr, int model) { try { //生成私钥 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec( decryptBASE64(rsaPrivateKeyStr)); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); //初始化加密 cipher.init(model, privateKey); byte[] result = cipher.doFinal(decryptBASE64(file)); //不能返回， new String(result) ,会出现乱码，导致没法解码 // 必须用base64 进行编解码 return encryptBASE64(result); } catch (Exception e) { e.printStackTrace(); } return null; } public static String EncoderByMd5(String str) { try { MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] result = md5.digest(str.getBytes(&quot;utf-8&quot;)); return toHex(result); } catch (Exception e) { e.printStackTrace(); } return null; } private static String toHex(byte[] bytes) { final char[] HEX_DIGITS = &quot;0123456789ABCDEF&quot;.toCharArray(); StringBuilder ret = new StringBuilder(bytes.length * 2); for (int i = 0; i &lt; bytes.length; i++) { ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; 4) &amp; 0x0f]); ret.append(HEX_DIGITS[bytes[i] &amp; 0x0f]); } return ret.toString(); } public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String file = &quot;甜橙金融，互联网金融行业第三&quot;; // 公钥加密，私钥解密，常规用法； if (keyMap != null) { String str = publicKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PUBLIC_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;公钥对明文加密：&quot; + str); String str2 = privateKeyDeal(str, keyMap.get(PRIVATE_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;私钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); // 私钥加密，公钥解密，得到明文；-- 数字签名 用这个道理 if (keyMap != null) { String str = privateKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;私钥对明文加密：&quot; + str); String str2 = publicKeyDeal(str, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE); System.out.println(&quot;公钥对密文解密：&quot; + new String(decryptBASE64(str2))); } System.out.println(&quot;&quot;); ///////////////////////////////////////// // 数字签名 // 生产摘要 String md5Str = EncoderByMd5(file); System.out.println(&quot;发送方生成摘要：&quot; + md5Str); //2用私钥 对摘要进行加密 String signStr = privateKeyDeal(encryptBASE64(md5Str.getBytes()), keyMap.get(PRIVATE_KEY), Cipher.ENCRYPT_MODE); System.out.println(&quot;发送方用私钥对摘要加密：&quot; + signStr); //3 发送原文+摘要密文（数字签名） 给接收方 System.out.println(&quot;接收方收到原文和摘要&quot;); //4 接收方用公钥解密摘要 String md5Str_Decrypt = new String(decryptBASE64(publicKeyDeal(signStr, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE))); System.out.println(&quot;接收方用公钥对摘要解密：&quot; + md5Str_Decrypt); //5 用同样的算法对原文生成摘要 String md5Str2 = EncoderByMd5(file); System.out.println(&quot;接收方生成的摘要：&quot; + md5Str2); //6 对比公钥解密的摘要和用原文生成的摘要 if (md5Str2.equals(md5Str_Decrypt)) { System.out.println(&quot;数字签名验证成功！&quot;); } else { System.out.println(&quot;数字签名验证失败！&quot;); } } } 代码可以看出来：用公钥加密后，用对应的私钥可以解密；反过来，私钥加密后，用对应的公钥也可以解密。 整个数字签名的流程稍微有点复杂。Java 还提供了专门的签名类，省去了这些繁琐的步骤。 代码如下： /** * Bestpay.com.cn Inc. * Copyright (c) 2011-2018 All Rights Reserved. */ package rsa; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.Signature; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; import java.util.HashMap; import java.util.Map; /** * * @author huyajun * @version $Id: SignTest.java, v 0.1 2018年4月22日 下午7:29:08 huyajun Exp $ */ public class SignTest { private static final String PUBLIC_KEY = &quot;PUBLIC_KEY&quot;; private static final String PRIVATE_KEY = &quot;PRIVATE_KEY&quot;; /** * * @param args */ public static void main(String[] args) { Map&lt;String, String&gt; keyMap = initRsaKey(); String content = &quot;123&quot;; String sign = null; try { sign = sign(content.getBytes(), keyMap.get(PRIVATE_KEY)); System.out.println(&quot;私钥签名结果：&quot; + sign); } catch (Exception e) { e.printStackTrace(); } //5.公钥验签 try { boolean flag = verify(content.getBytes(), keyMap.get(PUBLIC_KEY), sign); System.out.println(&quot;公钥验证数字签名：&quot; + flag); } catch (Exception e) { e.printStackTrace(); } } //////////////////////////////////////////////////////// /** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) { return Base64.getDecoder().decode(key); } /** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) { return Base64.getEncoder().encodeToString(key); } /** * 初始化密钥对 * * @return */ public static Map&lt;String, String&gt; initRsaKey() { //1.初始化秘钥 KeyPairGenerator keyPairGenerator; try { //1.初始化秘钥 keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); //秘钥长度 keyPairGenerator.initialize(512); //初始化秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); //公钥 RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic(); //私钥 RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2); keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded())); keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded())); return keyMap; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } /** * 私钥签名 * * @param data 原文件 * @param privateKey * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception { //构造PKCS8EncodedKeySpec对象 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(decryptBASE64(privateKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //取私钥匙对象 PrivateKey privateKeyObj = keyFactory.generatePrivate(pkcs8EncodedKeySpec); //用私钥对信息生成数字签名 Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initSign(privateKeyObj); signature.update(data); return encryptBASE64(signature.sign()); } /** * 校验数字签名 * @param data 加密数据 * @param publicKey 公钥 * @param sign 数字签名 * @return * @throws Exception */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception { //构造X509EncodedKeySpec对象 X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(decryptBASE64(publicKey)); //指定加密算法 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); //生成公钥匙对象 PublicKey publicKeyObj = keyFactory.generatePublic(x509EncodedKeySpec); Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);// MD2withRSA SHA1withRSA MD5withRSA signature.initVerify(publicKeyObj); signature.update(data); //验证签名是否正常 return signature.verify(decryptBASE64(sign)); } } Signature 类帮我们实现了生成数字签名和校验数字签名的方法，直接用，比自己去实现方便的多。 Signature.getInstance(&quot;MD5withRSA&quot;); &nbsp; 表示用MD5做摘要，用RSA做加解密。同理你还可以选择SHA1withRSA 。 &nbsp;注意生成签名和验签的方法要相同。 今天就讲到这里，下一篇文章，我们介绍区块链知识点之--共识算法。敬请期待 作者简介：甜橙金融技术部技术总监，负责公司核心平台设计与开发，新技术预研与落地。10年代码和架构设计经验，之前在国内知名一线互联网公司从事核心系统的开发和设计。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/04/22/bdf47c28cc934a4249b51acc0ac56bf8.html","headline":"区块链技术之-非对称加密","dateModified":"2018-04-22T00:00:00+08:00","datePublished":"2018-04-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/04/22/bdf47c28cc934a4249b51acc0ac56bf8.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链技术之-非对称加密</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <p></p>
  <div style="text-align:left;line-height:1.75;">
   <span style="font-size:16px;">区块链技术不是一个<span style="background-color:rgb(250,226,32);">新发明的技术</span>，而是<span style="background-color:rgb(250,226,32);">一个集成了多方面基础技术的综合性技术系统，是几个之前就有的基础技术的优雅组合而成</span>。我认为，其中有四项必不可缺的核心技术，分别是：共识机制、密码学原理、链式哈希结构和分布式数据存储（多节点）。</span>
  </div>
  <div style="text-align:left;line-height:1.75;">
   <span style="font-size:16px;"><br></span>
  </div>
  <span style="font-size:16px;"></span>
  <div style="text-align:left;line-height:1.75;">
   <span style="font-size:16px;">密码学原理在区块链中，信息的传播按照<span style="color:#df402a;">公钥、私钥这种非对称数字加密技术实现交易双方的互相信任</span>。<span style="text-align:justify;">非对称加密技术是区块链技术体系很重要的一部分。</span></span>
  </div>
  <p></p>
  <p style="font-family:'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif;color:rgb(0,0,0);line-height:20px;background-color:rgb(255,255,255);"><span style="font-size:16px;">公钥私钥的原则：</span></p>
  <ol style="line-height:20px;color:rgb(0,0,0);font-family:tahoma, Arial, '微软雅黑';background-color:rgb(255,255,255);">
   <li style="margin-left:30px;"><span style="font-size:16px;">一个公钥对应一个私钥，公钥私钥成对出现。</span></li>
   <li style="margin-left:30px;"><span style="font-size:16px;">密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。</span></li>
   <li style="margin-left:30px;"><span style="font-size:16px;"><span style="font-family:'微软雅黑';color:#000000;line-height:21px;text-align:left;background-color:rgb(255,255,255);">公钥用来加密和验证数字签名；<span style="font-family:'微软雅黑';color:#000000;line-height:21px;text-align:left;background-color:rgb(255,255,255);">私钥用来解密和生成数字签名。生成数字签名本质上是用私钥进行加密，验证数字签名是用公钥对私钥加密密文进行解密。可以归纳为：</span></span>如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。&nbsp;<span style="font-family:'微软雅黑';color:#000000;line-height:21px;text-align:left;background-color:rgb(255,255,255);"></span></span></li>
   <li style="margin-left:30px;"><span style="font-size:16px;">如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。</span></li>
  </ol>
  <p><span style="font-size:16px;">为什么用非对称加密？</span></p>
  <p><span style="font-size:16px;">&nbsp;一个网站要对传输进行加密，如果用对称加密，则有以下几种情况：</span></p>
  <p><span style="font-size:16px;">1 &nbsp;每个访问用户的秘钥相同。这种情况，服务器只要保存一个秘钥。除非你的网站用户是特定的内部用户，否则用户拿到秘钥就能对密文进行解密。</span></p>
  <p><span style="font-size:16px;">2 &nbsp;每个访问用户的秘钥不一样。这种情况，服务器需要保存大量秘钥。如果网站有上亿用户，则需要存储上亿的秘钥，维护成本巨大。</span></p>
  <p><span style="font-size:16px;">如果是非对称加密，网站只需要保存自己的私钥，用户可以随意下载网站公钥。</span></p>
  <p><span style="font-size:16px;"><br></span></p>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;"><span style="background-color:inherit;">数字签名：</span>就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</span>
   <span style="font-size:18px;">数字签名了的文件的</span>
   <span style="font-size:18px;background-color:inherit;">完整性</span>
   <span style="font-size:18px;">是很容易验证的&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;"><br></span>
  </div>
  <span style="font-size:16px;"><span style="font-family:'微软雅黑';color:#000000;line-height:21px;text-align:left;background-color:rgb(255,255,255);">&nbsp;流程：</span><br style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);"></span>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;">（1） 被发送文件用<span style="font-family:arial, '宋体', sans-serif;color:#333333;font-weight:700;line-height:24px;text-indent:28px;background-color:rgb(255,255,255);">密码散列函数（MD5,SHA,SM3）产生</span>的<span style="color:#e60013;background-color:inherit;">摘要</span><br style="background-color:inherit;">（2） 发送方用自己的私用密钥对摘要再加密，这就形成了数字签名。</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;">（3） 将原文和加密的摘要同时传给对方。</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;">（4） 对方用发送方的<span style="color:#e60013;background-color:inherit;">公共密钥对摘要解密，获取发送方生成的摘要</span>，同时对收到的文件用SHA编码加密产生又一<span style="color:#e60013;background-color:inherit;">摘要</span>。</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;">（5） 将解密后的<span style="color:#e60013;background-color:inherit;">摘要</span>和收到的文件在接收方重新加密产生的<span style="color:#e60013;background-color:inherit;">摘要</span>相互对比。如两者一致，则说明传送过程中信息没有被破坏或篡改过。否则不然。</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:'微软雅黑';line-height:21px;text-align:left;background-color:rgb(255,255,255);">
   <span style="font-size:16px;"><br></span>
  </div>
  <p><span style="font-size:16px;">数字签名，可以保证收到的文件没有被篡改，也可以保证发送者的身份。因为私钥生产了数字签名，私钥是不公开的。</span></p>
  <p><span style="font-size:16px;">说了这么多，还是写段代码来试试看。</span></p>
  <pre><code class="language-java"></code></pre>
  <pre class="java"><code class="language-java">/**
 * Bestpay.com.cn Inc.
 * Copyright (c) 2011-2018 All Rights Reserved.
 */
package rsa;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import javax.crypto.Cipher;

/**
 * 
 * @author huyajun
 * @version $Id: RSAsecurityTest.java, v 0.1 2018年3月14日 下午6:09:53 huyajun Exp $
 */
public class RSAsecurityTest {

    public static String PUBLIC_KEY  = "pub_key";
    public static String PRIVATE_KEY = "pri_key";

    /**
     * BASE64解密
     * @param key
     * @return
     * @throws Exception
     */
    public static byte[] decryptBASE64(String key) {
        return Base64.getDecoder().decode(key);
    }

    /**
     * BASE64加密
     * @param key
     * @return
     * @throws Exception
     */
    public static String encryptBASE64(byte[] key) {
        return Base64.getEncoder().encodeToString(key);
    }

    /**
     * 初始化密钥对
     * 
     * @return
     */
    public static Map&lt;String, String&gt; initRsaKey() {
        //1.初始化秘钥
        KeyPairGenerator keyPairGenerator;
        try {
            //1.初始化秘钥
            keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            //秘钥长度
            keyPairGenerator.initialize(512);
            //初始化秘钥对
            KeyPair keyPair = keyPairGenerator.generateKeyPair();
            //公钥
            RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
            //私钥
            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();

            Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2);
            keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded()));
            keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded()));
            return keyMap;

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }

    ///////////////////////////////////////////////////////////////////////

    /**
     * 公钥处理，返回base64编码的字符串
     * @param file
     * @param rsaPublicKeyStr
     * @param model  加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE
     * @return  公钥处理后的字符串，base64编码
     */
    public static String publicKeyDeal(String file, String rsaPublicKeyStr, int model) {

        try {
            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(
                decryptBASE64(rsaPublicKeyStr));
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec);
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(model, publicKey);
            byte[] result = cipher.doFinal(decryptBASE64(file));
            // 必须用base64 进行编解码
            return encryptBASE64(result);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;

    }

    /**
     * 私钥 处理，返回base64编码的字符串
     * @param file
     * @param rsaPrivateKeyStr
     * @param model   加密：Cipher.ENCRYPT_MODE；解密：Cipher.DECRYPT_MODE
     * @return 私钥处理后的字符串，base64编码
     */
    public static String privateKeyDeal(String file, String rsaPrivateKeyStr, int model) {
        try {
            //生成私钥

            PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(
                decryptBASE64(rsaPrivateKeyStr));
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);
            Cipher cipher = Cipher.getInstance("RSA");
            //初始化加密
            cipher.init(model, privateKey);
            byte[] result = cipher.doFinal(decryptBASE64(file));

            //不能返回，  new String(result) ,会出现乱码，导致没法解码
            // 必须用base64 进行编解码
            return encryptBASE64(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String EncoderByMd5(String str) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            byte[] result = md5.digest(str.getBytes("utf-8"));
            return toHex(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private static String toHex(byte[] bytes) {

        final char[] HEX_DIGITS = "0123456789ABCDEF".toCharArray();
        StringBuilder ret = new StringBuilder(bytes.length * 2);
        for (int i = 0; i &lt; bytes.length; i++) {
            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; 4) &amp; 0x0f]);
            ret.append(HEX_DIGITS[bytes[i] &amp; 0x0f]);
        }
        return ret.toString();
    }

    public static void main(String[] args) {
        Map&lt;String, String&gt; keyMap = initRsaKey();
        String file = "甜橙金融，互联网金融行业第三";

        // 公钥加密，私钥解密，常规用法；
        if (keyMap != null) {

            String str = publicKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PUBLIC_KEY),
                Cipher.ENCRYPT_MODE);
            System.out.println("公钥对明文加密：" + str);
            String str2 = privateKeyDeal(str, keyMap.get(PRIVATE_KEY), Cipher.DECRYPT_MODE);
            System.out.println("私钥对密文解密：" + new String(decryptBASE64(str2)));

        }
        System.out.println("");

        // 私钥加密，公钥解密，得到明文；-- 数字签名 用这个道理
        if (keyMap != null) {

            String str = privateKeyDeal(encryptBASE64(file.getBytes()), keyMap.get(PRIVATE_KEY),
                Cipher.ENCRYPT_MODE);
            System.out.println("私钥对明文加密：" + str);

            String str2 = publicKeyDeal(str, keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE);
            System.out.println("公钥对密文解密：" + new String(decryptBASE64(str2)));

        }
        System.out.println("");
        /////////////////////////////////////////
        // 数字签名
        // 生产摘要
        String md5Str = EncoderByMd5(file);
        System.out.println("发送方生成摘要：" + md5Str);
        //2用私钥 对摘要进行加密
        String signStr = privateKeyDeal(encryptBASE64(md5Str.getBytes()), keyMap.get(PRIVATE_KEY),
            Cipher.ENCRYPT_MODE);
        System.out.println("发送方用私钥对摘要加密：" + signStr);

        //3 发送原文+摘要密文（数字签名） 给接收方
        System.out.println("接收方收到原文和摘要");

        //4 接收方用公钥解密摘要
        String md5Str_Decrypt = new String(decryptBASE64(publicKeyDeal(signStr,
            keyMap.get(PUBLIC_KEY), Cipher.DECRYPT_MODE)));
        System.out.println("接收方用公钥对摘要解密：" + md5Str_Decrypt);

        //5 用同样的算法对原文生成摘要
        String md5Str2 = EncoderByMd5(file);
        System.out.println("接收方生成的摘要：" + md5Str2);

        //6 对比公钥解密的摘要和用原文生成的摘要
        if (md5Str2.equals(md5Str_Decrypt)) {
            System.out.println("数字签名验证成功！");
        } else {
            System.out.println("数字签名验证失败！");
        }
    }
}
</code></pre>
  <br>
  <p>代码可以看出来：用公钥加密后，用对应的私钥可以解密；反过来，私钥加密后，用对应的公钥也可以解密。</p>
  <p>整个数字签名的流程稍微有点复杂。Java 还提供了专门的签名类，省去了这些繁琐的步骤。</p>
  <p>代码如下：</p>
  <pre><code class="language-java">/**
 * Bestpay.com.cn Inc.
 * Copyright (c) 2011-2018 All Rights Reserved.
 */
package rsa;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

/**
 * 
 * @author huyajun
 * @version $Id: SignTest.java, v 0.1 2018年4月22日 下午7:29:08 huyajun Exp $
 */
public class SignTest {

    private static final String PUBLIC_KEY  = "PUBLIC_KEY";
    private static final String PRIVATE_KEY = "PRIVATE_KEY";

    /**
     * 
     * @param args
     */
    public static void main(String[] args) {
        Map&lt;String, String&gt; keyMap = initRsaKey();
        String content = "123";
        String sign = null;
        try {
            sign = sign(content.getBytes(), keyMap.get(PRIVATE_KEY));
            System.out.println("私钥签名结果：" + sign);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //5.公钥验签
        try {
            boolean flag = verify(content.getBytes(), keyMap.get(PUBLIC_KEY), sign);
            System.out.println("公钥验证数字签名：" + flag);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    ////////////////////////////////////////////////////////
    /**
     * BASE64解密
     * @param key
     * @return
     * @throws Exception
     */
    public static byte[] decryptBASE64(String key) {
        return Base64.getDecoder().decode(key);
    }

    /**
     * BASE64加密
     * @param key
     * @return
     * @throws Exception
     */
    public static String encryptBASE64(byte[] key) {
        return Base64.getEncoder().encodeToString(key);
    }

    /**
     * 初始化密钥对
     * 
     * @return
     */
    public static Map&lt;String, String&gt; initRsaKey() {
        //1.初始化秘钥
        KeyPairGenerator keyPairGenerator;
        try {
            //1.初始化秘钥
            keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            //秘钥长度
            keyPairGenerator.initialize(512);
            //初始化秘钥对
            KeyPair keyPair = keyPairGenerator.generateKeyPair();
            //公钥
            RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
            //私钥
            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();

            Map&lt;String, String&gt; keyMap = new HashMap&lt;String, String&gt;(2);
            keyMap.put(PUBLIC_KEY, encryptBASE64(rsaPublicKey.getEncoded()));
            keyMap.put(PRIVATE_KEY, encryptBASE64(rsaPrivateKey.getEncoded()));
            return keyMap;

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 私钥签名
     * 
     * @param data   原文件
     * @param privateKey
     * @return
     * @throws Exception
     */
    public static String sign(byte[] data, String privateKey) throws Exception {
        //构造PKCS8EncodedKeySpec对象
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(decryptBASE64(privateKey));
        //指定加密算法
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        //取私钥匙对象
        PrivateKey privateKeyObj = keyFactory.generatePrivate(pkcs8EncodedKeySpec);
        //用私钥对信息生成数字签名
        Signature signature = Signature.getInstance("MD5withRSA");// MD2withRSA  SHA1withRSA  MD5withRSA
        signature.initSign(privateKeyObj);
        signature.update(data);

        return encryptBASE64(signature.sign());
    }

    /**
     * 校验数字签名
     * @param data  加密数据
     * @param publicKey 公钥
     * @param sign  数字签名
     * @return
     * @throws Exception
     */
    public static boolean verify(byte[] data, String publicKey, String sign) throws Exception {
        //构造X509EncodedKeySpec对象
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(decryptBASE64(publicKey));
        //指定加密算法
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        //生成公钥匙对象
        PublicKey publicKeyObj = keyFactory.generatePublic(x509EncodedKeySpec);

        Signature signature = Signature.getInstance("MD5withRSA");// MD2withRSA  SHA1withRSA  MD5withRSA
        signature.initVerify(publicKeyObj);
        signature.update(data);
        //验证签名是否正常
        return signature.verify(decryptBASE64(sign));

    }
}</code></pre>
  <p>Signature 类帮我们实现了生成数字签名和校验数字签名的方法，直接用，比自己去实现方便的多。</p>
  <p>Signature.getInstance("MD5withRSA"); &nbsp; 表示用MD5做摘要，用RSA做加解密。同理你还可以选择SHA1withRSA 。 &nbsp;注意生成签名和验签的方法要相同。<br></p>
  <p><br></p>
  <p>今天就讲到这里，下一篇文章，我们介绍区块链知识点之--共识算法。敬请期待</p>
  <p><br></p>
  <p>作者简介：甜橙金融技术部技术总监，负责公司核心平台设计与开发，新技术预研与落地。10年代码和架构设计经验，之前在国内知名一线互联网公司从事核心系统的开发和设计。<br></p>
  <p><br></p>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_24813315/article/details/79955459,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_24813315/article/details/79955459,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
