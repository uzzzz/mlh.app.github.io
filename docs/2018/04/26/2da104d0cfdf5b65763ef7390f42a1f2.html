<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码情景分析之数据结构 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码情景分析之数据结构" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="数据结构关系图 &nbsp;&nbsp; &nbsp; 以太坊采用账号系统，因而相比比特币，它除了区块数据外还有账号数据。同时它有图灵完备的智能合约虚拟机，因而又多了一个状态数据，同时为了保留执行记录，又多了一个receipt数据 Block: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;由header和body构成，header里有三个trie的rootHash &lt;hash, receipt&gt;数据构造的receipt trie, header.receiptHash=这个trie的rootHash &lt;hash, transaction&gt;数据构造的transaction trie,&nbsp;header.txHahs=这个trie的rootHash &lt;address, StateObject&gt;数据构造的state trie, header.root=这个trie的rootHash StateObject: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;是一个账号(地址)的状态信息 &nbsp; &nbsp; 对于普通账号，这个对象保存了balance, nonce等信息 &nbsp; &nbsp; 对于智能合约账号，还额外保留了智能合约的状态，这个状态就是智能合约里的定义的各种变量的值。以太坊虚拟机的变量是以&lt;k, v&gt;存储的，所以这个状态就是大量&lt;k, v&gt;对象。 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 比如一般的ICO智能合约里，都会定义一个balance的变量，用来保存各个地址的代币持有量 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;mapping(address =&gt; uint256) balances; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 那这个值就会以&lt;k, v&gt;的形式存储在leveldb中，运行时会以trie的数据结构加载到StateObject对象里 LevelDb: &nbsp; &nbsp; &nbsp; &nbsp;以太坊所有的数据都是以&lt;k, v&gt;的方式存储，方便检索，最终都是通过LevelDB写入持久化存储的数据库文件。 &nbsp; &nbsp; &nbsp; &nbsp;除了上面提到的&lt;k, v&gt;数据对，还有&lt;trie.nodehash, trie.noderawrpl&gt;, &lt;header.hash, header&gt;等,核心&lt;k ,v&gt;数据对格式详情如下 key value &#39;h&#39; + num + hash header&#39;s RLP raw data &#39;h&#39; + num + hash + &#39;t&#39; td &#39;h&#39; + num + &#39;n&#39; hash &#39;H&#39; + hash num &#39;b&#39; + num + hash body&#39;s RLP raw data &#39;r&#39; + num + hash receipts RLP &#39;l&#39; + hash tx/receipt lookup metadata 数据结构详细 Header &nbsp; &nbsp; type Header struct { &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash `json:&quot;parentHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash `json:&quot;sha3Uncles&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address `json:&quot;miner&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash `json:&quot;stateRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash `json:&quot;receiptsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Difficulty * big.Int `json:&quot;difficulty&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Number * big.Int `json:&quot;number&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gasLimit&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Time * big.Int `json:&quot;timestamp&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte `json:&quot;extraData&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash `json:&quot;mixHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce `json:&quot;nonce&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp;Header是Block的核心，它的成员变量都很重要，需要仔细分析 ParentHash：父区块(parentBlock)的hash, 通过这个hash可进一步找到parentBlock。除了创世块(Genesis Block)外，每个区块有且只有一个父区块 UncleHash：Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组。以太坊引入叔块还是很合理的，相比比特币10分钟出一个区块，以太坊9s出一个区块，因而区块分叉的概率高很多，从而会出现大量新块不被采纳的情况，为了增加矿工的积极性，系统会将部分无用的区块打包进区块并给这些无用块(叔块)创造者一小份收益。 Coinbase：区块的作者的地址。在每次执行交易时系统会给与作者一定的奖励Ether Root：“state Trie”的根节点的RLP哈希值 TxHash: “tx Trie”的根节点的RLP哈希值 ReceiptHash：&quot;Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，最后形成&quot;Receipt Trie&quot; Bloom：Bloom过滤器(Filter)，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。 Difficulty：区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，并会动态调整 Number：区块的高度(即index)。Block的Number等于其父区块Number +1。 Time：区块“应该”被创建的时间。由共识算法确定，其一般等于parentBlock.Time + 9s，也可能等于当前系统时间 GasLimit：区块内所有Gas消耗的上限。该数值在区块创建时赋值，与父区块的数据相关。具体来说，根据父区块的GasUsed同创世块的GasLimit * 2/3的大小关系来计算得出。 GasUsed：执行区块内所有Transaction实际消耗的Gas总和 Nonce：一个64bit的哈希数，它被用于POW等挖块算法，暴力碰撞得出。 mixDigest: 区块头除去Nonce, mixDigest数据的hash+nonce的RLP的hash值 Block &nbsp;&nbsp; &nbsp; type Block struct { &nbsp;&nbsp;&nbsp;&nbsp;header *Header &nbsp;&nbsp;&nbsp;&nbsp;uncles [] * Header &nbsp;&nbsp;&nbsp;&nbsp;transactions Transactions &nbsp;&nbsp;&nbsp;&nbsp; // caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp; // Td is used by package core to store the total difficulty &nbsp;&nbsp;&nbsp;&nbsp; // of the chain up to and including the block. &nbsp;&nbsp;&nbsp;&nbsp;td * big.Int &nbsp;&nbsp;&nbsp;&nbsp; // These fields are used by package eth to track &nbsp;&nbsp;&nbsp;&nbsp; // inter-peer block relay. &nbsp;&nbsp;&nbsp;&nbsp;ReceivedAt time.Time &nbsp;&nbsp;&nbsp;&nbsp;ReceivedFrom interface {} } &nbsp; &nbsp; Block的大部分功能都由header代劳，只是多一些transaction数据 func (b * Block) Number () * big.Int { return new ( big.Int ). Set (b.header.Number) } func (b * Block) GasLimit () uint64 { return b.header.GasLimit } func (b * Block) GasUsed () uint64 { return b.header.GasUsed } func (b * Block) Difficulty () * big.Int { return new ( big.Int ). Set (b.header.Difficulty) } func (b * Block) Time () * big.Int { return new ( big.Int ). Set (b.header.Time) } func (b * Block) NumberU64 () uint64 { return b.header.Number. Uint64 () } func (b * Block) MixDigest () common.Hash { return b.header.MixDigest } func (b * Block) Nonce () uint64 { return binary.BigEndian. Uint64 (b.header.Nonce[:]) } func (b * Block) Bloom () Bloom { return b.header.Bloom } func (b * Block) Coinbase () common.Address { return b.header.Coinbase } func (b * Block) Root () common.Hash { return b.header.Root } func (b * Block) ParentHash () common.Hash { return b.header.ParentHash } func (b * Block) TxHash () common.Hash { return b.header.TxHash } func (b * Block) ReceiptHash () common.Hash { return b.header.ReceiptHash } func (b * Block) UncleHash () common.Hash { return b.header.UncleHash } func (b * Block) Extra () [] byte { return common. CopyBytes (b.header.Extra) } &nbsp; &nbsp; 那为啥还要设计两个对象，主要是header是轻量级数据，而block数据可能很大，因而对于网络传输的时候，先传输header数据验证重复性及合法性可以节省大量带宽。同时对于SPV的支持也是很有用的。 &nbsp; &nbsp;Block的hash和header的hash是一样，都是header中除nonce和mixDigest数据外的rlp的hash，这样相同的交易内容的相同该区块hash是一样，哪怕是由不同的节点创建出来的。 &nbsp; &nbsp; 一个block的还原就是根据H+hash=&gt;header, B+hash=&gt;body,也就是一个block的数据时分为两个&lt;k, v&gt;储存的，尽管hash相同，但是前缀不一样，导致key不一样 StateDB &nbsp; &nbsp; 一个block通过root字段可以构造加载一个StateDB对象，也就是每个block有一个StateDB实例 type StateDB struct { &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db Database &nbsp; &nbsp; // &lt;address, stateObject&gt;生成的trie &nbsp;&nbsp;&nbsp;&nbsp;trie Trie &nbsp;&nbsp;&nbsp;&nbsp; // This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp; &nbsp; // &lt;address, stateObject&gt;数据cache &nbsp;&nbsp;&nbsp;&nbsp;stateObjects map [common.Address] * stateObject &nbsp;&nbsp;&nbsp;&nbsp;stateObjectsDirty map [common.Address] struct {} &nbsp; &nbsp;&nbsp;…. } &nbsp; &nbsp; StateDB保存的是所有的账号信息即stateObject, 因而&lt;address, stateObject&gt;是一个巨量的&lt;k, v&gt;数据集，通过map[common.Address]*stateObject来加载所有的账号信息是不可能的，因而需要“分级”缓存机制： 第一缓存stateObjects，这里保留了近期活跃的账号信息 第二级缓存trie,以trie的方式维护&lt;address, stateObject&gt;信息，也能快速访问 第三级存储leveldb，从leveldb数据库中根据address获取对应的stateObject &nbsp;&nbsp; &nbsp;我们知道设计缓存的目的是解决速度和容量的平衡。比如上面的应该第一级缓存空间小，速度快，后面的缓存应该空间大，速度小。这几级缓存设计咋一看很合理也没什么疑惑。但是仔细看了代码觉得不对啊。第一级缓存map保存某一block交易涉及到stateObject(数量有限的)。但是map从二级缓存trie读取数据却从来没删除过，这样map和trie的空间是一样的，这样看来trie这级缓存并没有卵用。然而，以太坊发展了这么久，如果这个设计有这么明显的错误肯定应该早就发现了。因此还得从自身的理解找问题，经过仔细的代码阅读和深入的思考，我个人认为trie这一模块不应该被称作为缓存，但是trie是要有的，且大有用处。 &lt;address, stateObject&gt;数据有分片验证的需求，即需要一个merkle tree, 即检验某一个address的stateObject数据是否真的存在某个block 需要实现&lt;address, stateObject&gt;私有，我们知道底层的leveldb的&lt;k, v&gt;是全局共享的，即对一个address，只会保存一个stateObject, 而每个block都需要记录当前区块的所有address的stateObject信息，因而不同区块肯定会存在一个address对应不同stateObject情况。因而需要一种新的编码方式，将&lt;k, v&gt;转成&lt;encode(k+v), v&gt;存储到leveldb中，这样对于相同的address，如果其在不同的block里的stateObject不一样，其在leveldb中对应的key也不一样。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;这两个功能的结合就是MPT树，更详细的信息可以查看MPT这篇博文 &nbsp; &nbsp; &nbsp; StateDB的map和trie随着交易的相关操作肯定会不断扩展变大，那这么多的数据何时回收呢？这个由go的自动gc实现。StateDB一般都是在进行block的相关过程中临时创建的，因而很快就被gc释放掉了，对应的map,trie自然也自动回收了 &nbsp; &nbsp; &nbsp; 每个block的stateDB都是在parentBlock的stateDB的基础上执行交易更新而来的 stateObject &nbsp;&nbsp; &nbsp; type stateObject struct { &nbsp;&nbsp;&nbsp;&nbsp;address common.Address &nbsp;&nbsp;&nbsp;&nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp; &nbsp; //普通账号的信息 &nbsp;&nbsp;&nbsp;&nbsp;data Account &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db * StateDB &nbsp;&nbsp;&nbsp;&nbsp; // Write caches. &nbsp; &nbsp; // &lt;k, v&gt;状态数据生成的MPT &nbsp;&nbsp;&nbsp;&nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp;&nbsp;&nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp; &nbsp; //最近使用的&lt;k, v&gt;缓存 &nbsp;&nbsp;&nbsp;&nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp;&nbsp;&nbsp;dirtyStorage Storage // Storage entries that need to be flushed to disk } type Storage map [common.Hash]common.Hash Receipt type Receipt struct { &nbsp;&nbsp;&nbsp;&nbsp; // Consensus fields &nbsp;&nbsp;&nbsp;&nbsp;PostState [] byte `json:&quot;root&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Status uint `json:&quot;status&quot;` &nbsp;&nbsp;&nbsp;&nbsp;CumulativeGasUsed uint64 `json:&quot;cumulativeGasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Logs []*Log `json:&quot;logs&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp; // Implementation fields (don&#39;t reorder!) &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ContractAddress common.Address `json:&quot;contractAddress&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Receipt里的核心数据时Logs，智能合约允许开发人员通过event定义一些事件并广播到全网，这些event就是记录在Logs里面的 /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<meta property="og:description" content="数据结构关系图 &nbsp;&nbsp; &nbsp; 以太坊采用账号系统，因而相比比特币，它除了区块数据外还有账号数据。同时它有图灵完备的智能合约虚拟机，因而又多了一个状态数据，同时为了保留执行记录，又多了一个receipt数据 Block: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;由header和body构成，header里有三个trie的rootHash &lt;hash, receipt&gt;数据构造的receipt trie, header.receiptHash=这个trie的rootHash &lt;hash, transaction&gt;数据构造的transaction trie,&nbsp;header.txHahs=这个trie的rootHash &lt;address, StateObject&gt;数据构造的state trie, header.root=这个trie的rootHash StateObject: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;是一个账号(地址)的状态信息 &nbsp; &nbsp; 对于普通账号，这个对象保存了balance, nonce等信息 &nbsp; &nbsp; 对于智能合约账号，还额外保留了智能合约的状态，这个状态就是智能合约里的定义的各种变量的值。以太坊虚拟机的变量是以&lt;k, v&gt;存储的，所以这个状态就是大量&lt;k, v&gt;对象。 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 比如一般的ICO智能合约里，都会定义一个balance的变量，用来保存各个地址的代币持有量 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;mapping(address =&gt; uint256) balances; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 那这个值就会以&lt;k, v&gt;的形式存储在leveldb中，运行时会以trie的数据结构加载到StateObject对象里 LevelDb: &nbsp; &nbsp; &nbsp; &nbsp;以太坊所有的数据都是以&lt;k, v&gt;的方式存储，方便检索，最终都是通过LevelDB写入持久化存储的数据库文件。 &nbsp; &nbsp; &nbsp; &nbsp;除了上面提到的&lt;k, v&gt;数据对，还有&lt;trie.nodehash, trie.noderawrpl&gt;, &lt;header.hash, header&gt;等,核心&lt;k ,v&gt;数据对格式详情如下 key value &#39;h&#39; + num + hash header&#39;s RLP raw data &#39;h&#39; + num + hash + &#39;t&#39; td &#39;h&#39; + num + &#39;n&#39; hash &#39;H&#39; + hash num &#39;b&#39; + num + hash body&#39;s RLP raw data &#39;r&#39; + num + hash receipts RLP &#39;l&#39; + hash tx/receipt lookup metadata 数据结构详细 Header &nbsp; &nbsp; type Header struct { &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash `json:&quot;parentHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash `json:&quot;sha3Uncles&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address `json:&quot;miner&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash `json:&quot;stateRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash `json:&quot;receiptsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Difficulty * big.Int `json:&quot;difficulty&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Number * big.Int `json:&quot;number&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gasLimit&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Time * big.Int `json:&quot;timestamp&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte `json:&quot;extraData&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash `json:&quot;mixHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce `json:&quot;nonce&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp;Header是Block的核心，它的成员变量都很重要，需要仔细分析 ParentHash：父区块(parentBlock)的hash, 通过这个hash可进一步找到parentBlock。除了创世块(Genesis Block)外，每个区块有且只有一个父区块 UncleHash：Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组。以太坊引入叔块还是很合理的，相比比特币10分钟出一个区块，以太坊9s出一个区块，因而区块分叉的概率高很多，从而会出现大量新块不被采纳的情况，为了增加矿工的积极性，系统会将部分无用的区块打包进区块并给这些无用块(叔块)创造者一小份收益。 Coinbase：区块的作者的地址。在每次执行交易时系统会给与作者一定的奖励Ether Root：“state Trie”的根节点的RLP哈希值 TxHash: “tx Trie”的根节点的RLP哈希值 ReceiptHash：&quot;Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，最后形成&quot;Receipt Trie&quot; Bloom：Bloom过滤器(Filter)，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。 Difficulty：区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，并会动态调整 Number：区块的高度(即index)。Block的Number等于其父区块Number +1。 Time：区块“应该”被创建的时间。由共识算法确定，其一般等于parentBlock.Time + 9s，也可能等于当前系统时间 GasLimit：区块内所有Gas消耗的上限。该数值在区块创建时赋值，与父区块的数据相关。具体来说，根据父区块的GasUsed同创世块的GasLimit * 2/3的大小关系来计算得出。 GasUsed：执行区块内所有Transaction实际消耗的Gas总和 Nonce：一个64bit的哈希数，它被用于POW等挖块算法，暴力碰撞得出。 mixDigest: 区块头除去Nonce, mixDigest数据的hash+nonce的RLP的hash值 Block &nbsp;&nbsp; &nbsp; type Block struct { &nbsp;&nbsp;&nbsp;&nbsp;header *Header &nbsp;&nbsp;&nbsp;&nbsp;uncles [] * Header &nbsp;&nbsp;&nbsp;&nbsp;transactions Transactions &nbsp;&nbsp;&nbsp;&nbsp; // caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp; // Td is used by package core to store the total difficulty &nbsp;&nbsp;&nbsp;&nbsp; // of the chain up to and including the block. &nbsp;&nbsp;&nbsp;&nbsp;td * big.Int &nbsp;&nbsp;&nbsp;&nbsp; // These fields are used by package eth to track &nbsp;&nbsp;&nbsp;&nbsp; // inter-peer block relay. &nbsp;&nbsp;&nbsp;&nbsp;ReceivedAt time.Time &nbsp;&nbsp;&nbsp;&nbsp;ReceivedFrom interface {} } &nbsp; &nbsp; Block的大部分功能都由header代劳，只是多一些transaction数据 func (b * Block) Number () * big.Int { return new ( big.Int ). Set (b.header.Number) } func (b * Block) GasLimit () uint64 { return b.header.GasLimit } func (b * Block) GasUsed () uint64 { return b.header.GasUsed } func (b * Block) Difficulty () * big.Int { return new ( big.Int ). Set (b.header.Difficulty) } func (b * Block) Time () * big.Int { return new ( big.Int ). Set (b.header.Time) } func (b * Block) NumberU64 () uint64 { return b.header.Number. Uint64 () } func (b * Block) MixDigest () common.Hash { return b.header.MixDigest } func (b * Block) Nonce () uint64 { return binary.BigEndian. Uint64 (b.header.Nonce[:]) } func (b * Block) Bloom () Bloom { return b.header.Bloom } func (b * Block) Coinbase () common.Address { return b.header.Coinbase } func (b * Block) Root () common.Hash { return b.header.Root } func (b * Block) ParentHash () common.Hash { return b.header.ParentHash } func (b * Block) TxHash () common.Hash { return b.header.TxHash } func (b * Block) ReceiptHash () common.Hash { return b.header.ReceiptHash } func (b * Block) UncleHash () common.Hash { return b.header.UncleHash } func (b * Block) Extra () [] byte { return common. CopyBytes (b.header.Extra) } &nbsp; &nbsp; 那为啥还要设计两个对象，主要是header是轻量级数据，而block数据可能很大，因而对于网络传输的时候，先传输header数据验证重复性及合法性可以节省大量带宽。同时对于SPV的支持也是很有用的。 &nbsp; &nbsp;Block的hash和header的hash是一样，都是header中除nonce和mixDigest数据外的rlp的hash，这样相同的交易内容的相同该区块hash是一样，哪怕是由不同的节点创建出来的。 &nbsp; &nbsp; 一个block的还原就是根据H+hash=&gt;header, B+hash=&gt;body,也就是一个block的数据时分为两个&lt;k, v&gt;储存的，尽管hash相同，但是前缀不一样，导致key不一样 StateDB &nbsp; &nbsp; 一个block通过root字段可以构造加载一个StateDB对象，也就是每个block有一个StateDB实例 type StateDB struct { &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db Database &nbsp; &nbsp; // &lt;address, stateObject&gt;生成的trie &nbsp;&nbsp;&nbsp;&nbsp;trie Trie &nbsp;&nbsp;&nbsp;&nbsp; // This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp; &nbsp; // &lt;address, stateObject&gt;数据cache &nbsp;&nbsp;&nbsp;&nbsp;stateObjects map [common.Address] * stateObject &nbsp;&nbsp;&nbsp;&nbsp;stateObjectsDirty map [common.Address] struct {} &nbsp; &nbsp;&nbsp;…. } &nbsp; &nbsp; StateDB保存的是所有的账号信息即stateObject, 因而&lt;address, stateObject&gt;是一个巨量的&lt;k, v&gt;数据集，通过map[common.Address]*stateObject来加载所有的账号信息是不可能的，因而需要“分级”缓存机制： 第一缓存stateObjects，这里保留了近期活跃的账号信息 第二级缓存trie,以trie的方式维护&lt;address, stateObject&gt;信息，也能快速访问 第三级存储leveldb，从leveldb数据库中根据address获取对应的stateObject &nbsp;&nbsp; &nbsp;我们知道设计缓存的目的是解决速度和容量的平衡。比如上面的应该第一级缓存空间小，速度快，后面的缓存应该空间大，速度小。这几级缓存设计咋一看很合理也没什么疑惑。但是仔细看了代码觉得不对啊。第一级缓存map保存某一block交易涉及到stateObject(数量有限的)。但是map从二级缓存trie读取数据却从来没删除过，这样map和trie的空间是一样的，这样看来trie这级缓存并没有卵用。然而，以太坊发展了这么久，如果这个设计有这么明显的错误肯定应该早就发现了。因此还得从自身的理解找问题，经过仔细的代码阅读和深入的思考，我个人认为trie这一模块不应该被称作为缓存，但是trie是要有的，且大有用处。 &lt;address, stateObject&gt;数据有分片验证的需求，即需要一个merkle tree, 即检验某一个address的stateObject数据是否真的存在某个block 需要实现&lt;address, stateObject&gt;私有，我们知道底层的leveldb的&lt;k, v&gt;是全局共享的，即对一个address，只会保存一个stateObject, 而每个block都需要记录当前区块的所有address的stateObject信息，因而不同区块肯定会存在一个address对应不同stateObject情况。因而需要一种新的编码方式，将&lt;k, v&gt;转成&lt;encode(k+v), v&gt;存储到leveldb中，这样对于相同的address，如果其在不同的block里的stateObject不一样，其在leveldb中对应的key也不一样。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;这两个功能的结合就是MPT树，更详细的信息可以查看MPT这篇博文 &nbsp; &nbsp; &nbsp; StateDB的map和trie随着交易的相关操作肯定会不断扩展变大，那这么多的数据何时回收呢？这个由go的自动gc实现。StateDB一般都是在进行block的相关过程中临时创建的，因而很快就被gc释放掉了，对应的map,trie自然也自动回收了 &nbsp; &nbsp; &nbsp; 每个block的stateDB都是在parentBlock的stateDB的基础上执行交易更新而来的 stateObject &nbsp;&nbsp; &nbsp; type stateObject struct { &nbsp;&nbsp;&nbsp;&nbsp;address common.Address &nbsp;&nbsp;&nbsp;&nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp; &nbsp; //普通账号的信息 &nbsp;&nbsp;&nbsp;&nbsp;data Account &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db * StateDB &nbsp;&nbsp;&nbsp;&nbsp; // Write caches. &nbsp; &nbsp; // &lt;k, v&gt;状态数据生成的MPT &nbsp;&nbsp;&nbsp;&nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp;&nbsp;&nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp; &nbsp; //最近使用的&lt;k, v&gt;缓存 &nbsp;&nbsp;&nbsp;&nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp;&nbsp;&nbsp;dirtyStorage Storage // Storage entries that need to be flushed to disk } type Storage map [common.Hash]common.Hash Receipt type Receipt struct { &nbsp;&nbsp;&nbsp;&nbsp; // Consensus fields &nbsp;&nbsp;&nbsp;&nbsp;PostState [] byte `json:&quot;root&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Status uint `json:&quot;status&quot;` &nbsp;&nbsp;&nbsp;&nbsp;CumulativeGasUsed uint64 `json:&quot;cumulativeGasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Logs []*Log `json:&quot;logs&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp; // Implementation fields (don&#39;t reorder!) &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ContractAddress common.Address `json:&quot;contractAddress&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Receipt里的核心数据时Logs，智能合约允许开发人员通过event定义一些事件并广播到全网，这些event就是记录在Logs里面的 /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/04/26/2da104d0cfdf5b65763ef7390f42a1f2.html" />
<meta property="og:url" content="https://mlh.app/2018/04/26/2da104d0cfdf5b65763ef7390f42a1f2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"数据结构关系图 &nbsp;&nbsp; &nbsp; 以太坊采用账号系统，因而相比比特币，它除了区块数据外还有账号数据。同时它有图灵完备的智能合约虚拟机，因而又多了一个状态数据，同时为了保留执行记录，又多了一个receipt数据 Block: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;由header和body构成，header里有三个trie的rootHash &lt;hash, receipt&gt;数据构造的receipt trie, header.receiptHash=这个trie的rootHash &lt;hash, transaction&gt;数据构造的transaction trie,&nbsp;header.txHahs=这个trie的rootHash &lt;address, StateObject&gt;数据构造的state trie, header.root=这个trie的rootHash StateObject: &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;是一个账号(地址)的状态信息 &nbsp; &nbsp; 对于普通账号，这个对象保存了balance, nonce等信息 &nbsp; &nbsp; 对于智能合约账号，还额外保留了智能合约的状态，这个状态就是智能合约里的定义的各种变量的值。以太坊虚拟机的变量是以&lt;k, v&gt;存储的，所以这个状态就是大量&lt;k, v&gt;对象。 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 比如一般的ICO智能合约里，都会定义一个balance的变量，用来保存各个地址的代币持有量 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;mapping(address =&gt; uint256) balances; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 那这个值就会以&lt;k, v&gt;的形式存储在leveldb中，运行时会以trie的数据结构加载到StateObject对象里 LevelDb: &nbsp; &nbsp; &nbsp; &nbsp;以太坊所有的数据都是以&lt;k, v&gt;的方式存储，方便检索，最终都是通过LevelDB写入持久化存储的数据库文件。 &nbsp; &nbsp; &nbsp; &nbsp;除了上面提到的&lt;k, v&gt;数据对，还有&lt;trie.nodehash, trie.noderawrpl&gt;, &lt;header.hash, header&gt;等,核心&lt;k ,v&gt;数据对格式详情如下 key value &#39;h&#39; + num + hash header&#39;s RLP raw data &#39;h&#39; + num + hash + &#39;t&#39; td &#39;h&#39; + num + &#39;n&#39; hash &#39;H&#39; + hash num &#39;b&#39; + num + hash body&#39;s RLP raw data &#39;r&#39; + num + hash receipts RLP &#39;l&#39; + hash tx/receipt lookup metadata 数据结构详细 Header &nbsp; &nbsp; type Header struct { &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash `json:&quot;parentHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash `json:&quot;sha3Uncles&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address `json:&quot;miner&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash `json:&quot;stateRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash `json:&quot;receiptsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Difficulty * big.Int `json:&quot;difficulty&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Number * big.Int `json:&quot;number&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gasLimit&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Time * big.Int `json:&quot;timestamp&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte `json:&quot;extraData&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash `json:&quot;mixHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce `json:&quot;nonce&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp;Header是Block的核心，它的成员变量都很重要，需要仔细分析 ParentHash：父区块(parentBlock)的hash, 通过这个hash可进一步找到parentBlock。除了创世块(Genesis Block)外，每个区块有且只有一个父区块 UncleHash：Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组。以太坊引入叔块还是很合理的，相比比特币10分钟出一个区块，以太坊9s出一个区块，因而区块分叉的概率高很多，从而会出现大量新块不被采纳的情况，为了增加矿工的积极性，系统会将部分无用的区块打包进区块并给这些无用块(叔块)创造者一小份收益。 Coinbase：区块的作者的地址。在每次执行交易时系统会给与作者一定的奖励Ether Root：“state Trie”的根节点的RLP哈希值 TxHash: “tx Trie”的根节点的RLP哈希值 ReceiptHash：&quot;Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，最后形成&quot;Receipt Trie&quot; Bloom：Bloom过滤器(Filter)，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。 Difficulty：区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，并会动态调整 Number：区块的高度(即index)。Block的Number等于其父区块Number +1。 Time：区块“应该”被创建的时间。由共识算法确定，其一般等于parentBlock.Time + 9s，也可能等于当前系统时间 GasLimit：区块内所有Gas消耗的上限。该数值在区块创建时赋值，与父区块的数据相关。具体来说，根据父区块的GasUsed同创世块的GasLimit * 2/3的大小关系来计算得出。 GasUsed：执行区块内所有Transaction实际消耗的Gas总和 Nonce：一个64bit的哈希数，它被用于POW等挖块算法，暴力碰撞得出。 mixDigest: 区块头除去Nonce, mixDigest数据的hash+nonce的RLP的hash值 Block &nbsp;&nbsp; &nbsp; type Block struct { &nbsp;&nbsp;&nbsp;&nbsp;header *Header &nbsp;&nbsp;&nbsp;&nbsp;uncles [] * Header &nbsp;&nbsp;&nbsp;&nbsp;transactions Transactions &nbsp;&nbsp;&nbsp;&nbsp; // caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp; // Td is used by package core to store the total difficulty &nbsp;&nbsp;&nbsp;&nbsp; // of the chain up to and including the block. &nbsp;&nbsp;&nbsp;&nbsp;td * big.Int &nbsp;&nbsp;&nbsp;&nbsp; // These fields are used by package eth to track &nbsp;&nbsp;&nbsp;&nbsp; // inter-peer block relay. &nbsp;&nbsp;&nbsp;&nbsp;ReceivedAt time.Time &nbsp;&nbsp;&nbsp;&nbsp;ReceivedFrom interface {} } &nbsp; &nbsp; Block的大部分功能都由header代劳，只是多一些transaction数据 func (b * Block) Number () * big.Int { return new ( big.Int ). Set (b.header.Number) } func (b * Block) GasLimit () uint64 { return b.header.GasLimit } func (b * Block) GasUsed () uint64 { return b.header.GasUsed } func (b * Block) Difficulty () * big.Int { return new ( big.Int ). Set (b.header.Difficulty) } func (b * Block) Time () * big.Int { return new ( big.Int ). Set (b.header.Time) } func (b * Block) NumberU64 () uint64 { return b.header.Number. Uint64 () } func (b * Block) MixDigest () common.Hash { return b.header.MixDigest } func (b * Block) Nonce () uint64 { return binary.BigEndian. Uint64 (b.header.Nonce[:]) } func (b * Block) Bloom () Bloom { return b.header.Bloom } func (b * Block) Coinbase () common.Address { return b.header.Coinbase } func (b * Block) Root () common.Hash { return b.header.Root } func (b * Block) ParentHash () common.Hash { return b.header.ParentHash } func (b * Block) TxHash () common.Hash { return b.header.TxHash } func (b * Block) ReceiptHash () common.Hash { return b.header.ReceiptHash } func (b * Block) UncleHash () common.Hash { return b.header.UncleHash } func (b * Block) Extra () [] byte { return common. CopyBytes (b.header.Extra) } &nbsp; &nbsp; 那为啥还要设计两个对象，主要是header是轻量级数据，而block数据可能很大，因而对于网络传输的时候，先传输header数据验证重复性及合法性可以节省大量带宽。同时对于SPV的支持也是很有用的。 &nbsp; &nbsp;Block的hash和header的hash是一样，都是header中除nonce和mixDigest数据外的rlp的hash，这样相同的交易内容的相同该区块hash是一样，哪怕是由不同的节点创建出来的。 &nbsp; &nbsp; 一个block的还原就是根据H+hash=&gt;header, B+hash=&gt;body,也就是一个block的数据时分为两个&lt;k, v&gt;储存的，尽管hash相同，但是前缀不一样，导致key不一样 StateDB &nbsp; &nbsp; 一个block通过root字段可以构造加载一个StateDB对象，也就是每个block有一个StateDB实例 type StateDB struct { &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db Database &nbsp; &nbsp; // &lt;address, stateObject&gt;生成的trie &nbsp;&nbsp;&nbsp;&nbsp;trie Trie &nbsp;&nbsp;&nbsp;&nbsp; // This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp; &nbsp; // &lt;address, stateObject&gt;数据cache &nbsp;&nbsp;&nbsp;&nbsp;stateObjects map [common.Address] * stateObject &nbsp;&nbsp;&nbsp;&nbsp;stateObjectsDirty map [common.Address] struct {} &nbsp; &nbsp;&nbsp;…. } &nbsp; &nbsp; StateDB保存的是所有的账号信息即stateObject, 因而&lt;address, stateObject&gt;是一个巨量的&lt;k, v&gt;数据集，通过map[common.Address]*stateObject来加载所有的账号信息是不可能的，因而需要“分级”缓存机制： 第一缓存stateObjects，这里保留了近期活跃的账号信息 第二级缓存trie,以trie的方式维护&lt;address, stateObject&gt;信息，也能快速访问 第三级存储leveldb，从leveldb数据库中根据address获取对应的stateObject &nbsp;&nbsp; &nbsp;我们知道设计缓存的目的是解决速度和容量的平衡。比如上面的应该第一级缓存空间小，速度快，后面的缓存应该空间大，速度小。这几级缓存设计咋一看很合理也没什么疑惑。但是仔细看了代码觉得不对啊。第一级缓存map保存某一block交易涉及到stateObject(数量有限的)。但是map从二级缓存trie读取数据却从来没删除过，这样map和trie的空间是一样的，这样看来trie这级缓存并没有卵用。然而，以太坊发展了这么久，如果这个设计有这么明显的错误肯定应该早就发现了。因此还得从自身的理解找问题，经过仔细的代码阅读和深入的思考，我个人认为trie这一模块不应该被称作为缓存，但是trie是要有的，且大有用处。 &lt;address, stateObject&gt;数据有分片验证的需求，即需要一个merkle tree, 即检验某一个address的stateObject数据是否真的存在某个block 需要实现&lt;address, stateObject&gt;私有，我们知道底层的leveldb的&lt;k, v&gt;是全局共享的，即对一个address，只会保存一个stateObject, 而每个block都需要记录当前区块的所有address的stateObject信息，因而不同区块肯定会存在一个address对应不同stateObject情况。因而需要一种新的编码方式，将&lt;k, v&gt;转成&lt;encode(k+v), v&gt;存储到leveldb中，这样对于相同的address，如果其在不同的block里的stateObject不一样，其在leveldb中对应的key也不一样。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;这两个功能的结合就是MPT树，更详细的信息可以查看MPT这篇博文 &nbsp; &nbsp; &nbsp; StateDB的map和trie随着交易的相关操作肯定会不断扩展变大，那这么多的数据何时回收呢？这个由go的自动gc实现。StateDB一般都是在进行block的相关过程中临时创建的，因而很快就被gc释放掉了，对应的map,trie自然也自动回收了 &nbsp; &nbsp; &nbsp; 每个block的stateDB都是在parentBlock的stateDB的基础上执行交易更新而来的 stateObject &nbsp;&nbsp; &nbsp; type stateObject struct { &nbsp;&nbsp;&nbsp;&nbsp;address common.Address &nbsp;&nbsp;&nbsp;&nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp; &nbsp; //普通账号的信息 &nbsp;&nbsp;&nbsp;&nbsp;data Account &nbsp; &nbsp; //leveldb操作接口 &nbsp;&nbsp;&nbsp;&nbsp;db * StateDB &nbsp;&nbsp;&nbsp;&nbsp; // Write caches. &nbsp; &nbsp; // &lt;k, v&gt;状态数据生成的MPT &nbsp;&nbsp;&nbsp;&nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp;&nbsp;&nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp; &nbsp; //最近使用的&lt;k, v&gt;缓存 &nbsp;&nbsp;&nbsp;&nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp;&nbsp;&nbsp;dirtyStorage Storage // Storage entries that need to be flushed to disk } type Storage map [common.Hash]common.Hash Receipt type Receipt struct { &nbsp;&nbsp;&nbsp;&nbsp; // Consensus fields &nbsp;&nbsp;&nbsp;&nbsp;PostState [] byte `json:&quot;root&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Status uint `json:&quot;status&quot;` &nbsp;&nbsp;&nbsp;&nbsp;CumulativeGasUsed uint64 `json:&quot;cumulativeGasUsed&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom `json:&quot;logsBloom&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Logs []*Log `json:&quot;logs&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp; // Implementation fields (don&#39;t reorder!) &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash `json:&quot;transactionHash&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;ContractAddress common.Address `json:&quot;contractAddress&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasUsed uint64 `json:&quot;gasUsed&quot; gencodec:&quot;required&quot;` } &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Receipt里的核心数据时Logs，智能合约允许开发人员通过event定义一些事件并广播到全网，这些event就是记录在Logs里面的 /******************************** * 本文来自CSDN博主&quot;爱踢门&quot; * 转载请标明出处 : http://blog.csdn.net/itleaks ******************************************/ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/04/26/2da104d0cfdf5b65763ef7390f42a1f2.html","headline":"以太坊源码情景分析之数据结构","dateModified":"2018-04-26T00:00:00+08:00","datePublished":"2018-04-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/04/26/2da104d0cfdf5b65763ef7390f42a1f2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码情景分析之数据结构</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2><span style="font-size:24px;"><strong>数据结构关系图</strong></span></h2>
  <div>
   &nbsp;&nbsp; &nbsp;
   <span style="font-size:16px;">以太坊采用账号系统，因而相比比特币，它除了区块数据外还有账号数据。同时它有图灵完备的智能合约虚拟机，因而又多了一个状态数据，同时为了保留执行记录，又多了一个receipt数据</span>
  </div>
  <div>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180426150743986?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L0lUbGVha3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="color:rgb(0,0,0);font-family:Arial, Helvetica, sans-serif;font-size:12px;" alt="">
   <br>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-weight:bold;"><span style="font-size:16px;">Block:</span></span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;由header和body构成，header里有三个trie的rootHash</span>
  </div>
  <ul>
   <li><span style="font-size:16px;">&lt;hash, receipt&gt;数据构造的receipt trie, header.receiptHash=这个trie的rootHash</span></li>
   <li><span style="font-size:16px;">&lt;hash, transaction&gt;数据构造的transaction trie,&nbsp;header.txHahs=这个trie的rootHash</span></li>
   <li><span style="font-size:16px;">&lt;address, StateObject&gt;数据构造的state trie, header.root=这个trie的rootHash</span></li>
  </ul>
  <div>
   <span style="font-weight:bold;"><span style="font-size:16px;">StateObject:</span></span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;是一个账号(地址)的状态信息</span>
  </div>
  <ul>
   <li><span style="font-size:16px;">&nbsp; &nbsp; 对于普通账号，这个对象保存了balance, nonce等信息</span></li>
   <li><span style="font-size:16px;">&nbsp; &nbsp; 对于智能合约账号，还额外保留了智能合约的状态，这个状态就是智能合约里的定义的各种变量的值。以太坊虚拟机的变量是以&lt;k, v&gt;存储的，所以这个状态就是大量&lt;k, v&gt;对象。</span></li>
  </ul>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 比如一般的ICO智能合约里，都会定义一个balance的变量，用来保存各个地址的代币持有量</span>
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <span style="font-family:Monaco;">&nbsp;&nbsp;mapping(address =&gt; uint256) balances;</span>
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 
   <span style="font-size:16px;">那这个值就会以&lt;k, v&gt;的形式存储在leveldb中，运行时会以trie的数据结构加载到StateObject对象里</span>
  </div>
  <div>
   <span style="font-weight:bold;"><span style="font-size:16px;">LevelDb:</span></span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; &nbsp; &nbsp;以太坊所有的数据都是以&lt;k, v&gt;的方式存储，方便检索，最终都是通过LevelDB写入持久化存储的数据库文件。</span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; &nbsp; &nbsp;除了上面提到的&lt;k, v&gt;数据对，还有&lt;trie.nodehash, trie.noderawrpl&gt;, &lt;header.hash, header&gt;等,核心&lt;k ,v&gt;数据对格式详情如下</span>
  </div>
  <table style="font-size:16px;" border="1">
   <colgroup>
    <col style="width:158px;">
    <col style="width:158px;">
   </colgroup>
   <tbody>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;"><strong>key</strong></span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;"><strong>value</strong></span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'h' + num + hash</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">header's RLP raw data</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'h' + num + hash + 't'</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">td</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'h' + num + 'n'</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">hash</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'H' + hash</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">num</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'b' + num + hash</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">body's RLP raw data</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'r' + num + hash</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">receipts RLP</span></td>
    </tr>
    <tr>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">'l' + hash</span></td>
     <td align="center"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:22px;">tx/receipt lookup metadata</span></td>
    </tr>
   </tbody>
  </table>
  <h2><span style="font-size:24px;"><span style="font-weight:bold;">数据结构详细</span></span></h2>
  <div>
   <span style="line-height:26px;"><span style="font-size:18px;"><strong>Header</strong></span></span>
  </div>
  <div>
   <span style="font-size:14px;line-height:26px;">&nbsp; &nbsp;</span>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">Header</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"parentHash" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"sha3Uncles" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"miner" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"stateRoot" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"transactionsRoot" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"receiptsRoot" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"logsBloom" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Difficulty</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"difficulty" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Number</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"number" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;GasLimit</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"gasLimit" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;GasUsed</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"gasUsed" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Time</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"timestamp" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Extra []</span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">byte</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"extraData" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"mixHash" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"nonce" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:16px;"><span style="line-height:26px;">&nbsp;&nbsp;</span><span style="line-height:26px;">Header是Block的核心，它的成员变量都很重要，需要仔细分析</span></span>
  </div>
  <ul>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">ParentHash</span>：父区块(parentBlock)的hash, 通过这个hash可进一步找到parentBlock。除了创世块(Genesis Block)外，每个区块有且只有一个父区块</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">UncleHash</span>：Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组。以太坊引入叔块还是很合理的，相比比特币10分钟出一个区块，以太坊9s出一个区块，因而区块分叉的概率高很多，从而会出现大量新块不被采纳的情况，为了增加矿工的积极性，系统会将部分无用的区块打包进区块并给这些无用块(叔块)创造者一小份收益。</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">Coinbase</span>：区块的作者的地址。在每次执行交易时系统会给与作者一定的奖励Ether</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">Root</span>：“state Trie”的根节点的RLP哈希值</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">TxHash</span>: “tx Trie”的根节点的RLP哈希值</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">ReceiptHash</span>："Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，最后形成"Receipt Trie"</span>
    </div></li>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">Bloom</span>：Bloom过滤器(Filter)，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。</span>
    </div></li>
  </ul>
  <div style="list-style:disc;">
   <ul>
    <li><span style="font-size:16px;"><span style="font-weight:bold;">Difficulty</span>：区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，并会动态调整</span></li>
   </ul>
  </div>
  <ul>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">Number</span>：区块的高度(即index)。Block的Number等于其父区块Number +1。</span>
    </div></li>
  </ul>
  <div style="list-style:disc;">
   <ul>
    <li><span style="font-size:16px;"><span style="font-weight:bold;">Time</span>：区块“应该”被创建的时间。由共识算法确定，其一般等于parentBlock.Time + 9s，也可能等于当前系统时间</span></li>
   </ul>
  </div>
  <ul>
   <li>
    <div style="list-style:disc;">
     <span style="font-size:16px;"><span style="font-weight:bold;">GasLimit</span>：区块内所有Gas消耗的上限。该数值在区块创建时赋值，与父区块的数据相关。具体来说，根据父区块的GasUsed同创世块的GasLimit * 2/3的大小关系来计算得出。</span>
    </div></li>
  </ul>
  <div style="list-style:disc;">
   <ul>
    <li><span style="font-size:16px;"><span style="font-weight:bold;">GasUsed</span>：执行区块内所有Transaction实际消耗的Gas总和</span></li>
   </ul>
  </div>
  <ul>
   <li><span style="font-size:16px;"><span style="font-weight:bold;">Nonce</span>：一个64bit的哈希数，它被用于POW等挖块算法，暴力碰撞得出。</span></li>
   <li><span style="font-size:16px;"><span style="font-weight:bold;">mixDigest</span>: 区块头除去Nonce, mixDigest数据的hash+nonce的RLP的hash值</span></li>
  </ul>
  <div>
   <br>
  </div>
  <div>
   <strong><span style="font-size:18px;">Block</span></strong>
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">Block</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="background-color:rgb(255,250,165);"><span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;header</span><span style="font-family:Monaco;"> </span><span style="color:rgb(0,0,0);font-family:Monaco;">*</span><span style="color:rgb(0,0,0);font-family:Monaco;">Header</span><span style="font-family:Monaco;"></span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;uncles []</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Header</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;background-color:rgb(255,250,165);">&nbsp;&nbsp;&nbsp;&nbsp;transactions Transactions</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// caches</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Td is used by package core to store the total difficulty</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// of the chain up to and including the block.</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;td</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// These fields are used by package eth to track</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// inter-peer block relay.</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ReceivedAt time.Time</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ReceivedFrom</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">interface</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{}</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; Block的大部分功能都由header代劳，只是多一些transaction数据</span>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Number</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;"> {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">new</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;">).</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Set</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b.header.Number) }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">GasLimit</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.GasLimit }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">GasUsed</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.GasUsed }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Difficulty</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;"> {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">new</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;">).</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Set</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b.header.Difficulty) }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Time</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;"> {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">new</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(</span>
    <a href="http://big.int/" rel="nofollow" style="color:rgb(0,0,0);font-family:Monaco;">big.Int</a>
    <span style="color:rgb(0,0,0);font-family:Monaco;">).</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Set</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b.header.Time) }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">NumberU64</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.Number.</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Uint64</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">MixDigest</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.MixDigest }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Nonce</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">()</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">binary.BigEndian.</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Uint64</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b.header.Nonce[:]) }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Bloom</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() Bloom {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.Bloom }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Coinbase</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Address {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.Coinbase }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Root</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.Root }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">ParentHash</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.ParentHash }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">TxHash</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.TxHash }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">ReceiptHash</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.ReceiptHash }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">UncleHash</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() common.Hash {</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">b.header.UncleHash }</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,255);font-family:Monaco;">func</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">Block)</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">Extra</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">() []</span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">byte</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(175,0,219);font-family:Monaco;">return</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">common.</span>
    <span style="color:rgb(121,94,38);font-family:Monaco;">CopyBytes</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">(b.header.Extra) }</span>
    <span style="font-family:Monaco;"></span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   &nbsp; &nbsp; 
   <span style="font-size:16px;">那为啥还要设计两个对象，主要是header是轻量级数据，而block数据可能很大，因而对于网络传输的时候，先传输header数据验证重复性及合法性可以节省大量带宽。同时对于SPV的支持也是很有用的。</span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp;Block的hash和header的hash是一样，都是header中除nonce和mixDigest数据外的rlp的hash，这样相同的交易内容的相同该区块hash是一样，哪怕是由不同的节点创建出来的。</span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; 一个block的还原就是根据H+hash=&gt;header, B+hash=&gt;body,也就是一个block的数据时分为两个&lt;k, v&gt;储存的，尽管hash相同，但是前缀不一样，导致key不一样</span>
  </div>
  <p></p>
  <div>
   <span style="font-size:18px;"><strong>StateDB</strong></span>
  </div>
  <p></p>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; 一个block通过root字段可以构造加载一个StateDB对象，也就是每个block有一个StateDB实例</span>
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">StateDB</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //leveldb操作接口</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;db Database</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; // &lt;address, stateObject&gt;生成的trie</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;trie Trie</span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// This map holds 'live' objects, which will get modified while processing a state transition.</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; // &lt;address, stateObject&gt;数据cache</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;stateObjects</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">map</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">[common.Address]</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">stateObject</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;stateObjectsDirty</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">map</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">[common.Address]</span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{}</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="font-family:Monaco;color:#000000;">&nbsp; &nbsp;&nbsp;….</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   &nbsp; &nbsp;
   <span style="font-size:14px;"> </span>
   <span style="font-size:16px;">StateDB保存的是所有的账号信息即stateObject, 因而&lt;address, stateObject&gt;是一个巨量的&lt;k, v&gt;数据集，通过<span style="color:rgb(0,0,255);font-family:Monaco;">map</span><span style="color:rgb(0,0,0);font-family:Monaco;">[common.Address]</span><span style="color:rgb(0,0,0);font-family:Monaco;">*</span><span style="color:rgb(0,0,0);font-family:Monaco;">stateObject来加载所有的账号信息是不可能的，因而需要“分级”缓存机制：</span></span>
  </div>
  <ul>
   <li><span style="font-size:16px;"><span style="color:rgb(0,0,0);font-family:Monaco;">第一缓存</span><span style="font-family:Monaco;">stateObjects，这里保留了近期活跃的账号信息</span></span></li>
   <li>
    <div>
     <span style="font-size:16px;"><span style="color:rgb(145,78,126);font-family:Monaco;"><em>第二级缓存trie,以trie的方式维护&lt;</em></span><span style="color:rgb(145,78,126);font-family:Monaco;"><em>address, stateObject&gt;信息，也能快速访问</em></span></span>
    </div></li>
   <li><span style="font-family:Monaco;"><span style="font-size:16px;">第三级存储leveldb，从leveldb数据库中根据address获取对应的stateObject</span></span></li>
  </ul>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp; &nbsp;我们知道设计缓存的目的是解决速度和容量的平衡。比如上面的应该第一级缓存空间小，速度快，后面的缓存应该空间大，速度小。这几级缓存设计咋一看很合理也没什么疑惑。但是仔细看了代码觉得不对啊。第一级缓存map保存某一block交易涉及到stateObject(数量有限的)。但是map从二级缓存trie读取数据却从来没删除过，这样map和trie的空间是一样的，这样看来trie这级缓存并没有卵用。然而，以太坊发展了这么久，如果这个设计有这么明显的错误肯定应该早就发现了。因此还得从自身的理解找问题，经过仔细的代码阅读和深入的思考，我个人认为trie这一模块不应该被称作为缓存，但是trie是要有的，且大有用处。</span>
  </div>
  <ul>
   <li><span style="font-size:16px;">&lt;<span style="color:rgb(145,78,126);font-family:Monaco;"><em>address, stateObject</em></span>&gt;数据有分片验证的需求，即需要一个merkle tree, 即检验某一个address的stateObject数据是否真的存在某个block</span></li>
   <li><span style="font-size:16px;">需要实现&lt;<span style="color:rgb(145,78,126);font-family:Monaco;"><em>address, stateObject</em></span>&gt;私有，我们知道底层的leveldb的&lt;k, v&gt;是全局共享的，即对一个address，只会保存一个stateObject, 而每个block都需要记录当前区块的所有address的stateObject信息，因而不同区块肯定会存在一个address对应不同stateObject情况。因而需要一种新的编码方式，将&lt;k, v&gt;转成&lt;encode(k+v), v&gt;存储到leveldb中，这样对于相同的address，如果其在不同的block里的stateObject不一样，其在leveldb中对应的key也不一样。</span></li>
  </ul>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;这两个功能的结合就是MPT树，更详细的信息可以查看<a href="https://blog.csdn.net/ITleaks/article/details/79992072" rel="nofollow"><span style="background-color:rgb(255,250,165);">MPT</span>这篇博文</a></span>
  </div>
  <div>
   <span style="font-size:16px;">&nbsp; &nbsp; &nbsp; StateDB的map和trie随着交易的相关操作肯定会不断扩展变大，那这么多的数据何时回收呢？这个由go的自动gc实现。StateDB一般都是在进行block的相关过程中临时创建的，因而很快就被gc释放掉了，对应的map,trie自然也自动回收了</span>
  </div>
  <div>
   <div>
    <span style="font-size:16px;">&nbsp; &nbsp; &nbsp; 每个block的stateDB都是在parentBlock的stateDB的基础上执行交易更新而来的<br></span>
   </div>
   <div></div>
   <br>
  </div>
  <div>
   <span style="font-size:18px;">stateObject</span>
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;
  </div>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">stateObject</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;address common.Address</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;addrHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// hash of ethereum address of the account</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //普通账号的信息</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;data Account</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; //leveldb操作接口</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;db</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">*</span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">StateDB</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Write caches.</span>
   </div>
   <div>
    <span style="font-family:Monaco;"><span style="color:#942192;">&nbsp; &nbsp; // &lt;k, v&gt;状态数据生成的MPT</span></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;trie Trie</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// storage trie, which becomes non-nil on first access</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;code Code</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// contract bytecode, which gets set when code is loaded</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <br style="font-family:Monaco;">
   </div>
   <div>
    <span style="color:#942192;">&nbsp; &nbsp; //最近使用的&lt;k, v&gt;缓存</span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;cachedStorage Storage</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Storage entry cache to avoid duplicate reads</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;dirtyStorage Storage</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Storage entries that need to be flushed to disk</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div>
    <span style="color:rgb(0,0,0);font-family:Monaco;">}</span>
   </div>
   <div>
    <br>
   </div>
   <div>
    <div>
     <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
     <span style="font-family:Monaco;"> </span>
     <span style="color:rgb(38,127,153);font-family:Monaco;">Storage</span>
     <span style="font-family:Monaco;"> </span>
     <span style="color:rgb(0,0,255);font-family:Monaco;">map</span>
     <span style="color:rgb(0,0,0);font-family:Monaco;">[common.Hash]common.Hash</span>
     <span style="font-family:Monaco;"></span>
    </div>
    <div>
     <br style="font-family:Monaco;">
    </div>
   </div>
  </div>
  <div>
   <br>
  </div>
  <div>
   <span style="font-size:18px;"><strong>Receipt</strong></span>
  </div>
  <p></p>
  <div style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);">
   <div>
    <span style="color:rgb(0,0,255);font-family:Monaco;">type</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">Receipt</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,255);font-family:Monaco;">struct</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(0,0,0);font-family:Monaco;">{</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Consensus fields</span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;PostState []</span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">byte</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"root"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Status</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"status"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;CumulativeGasUsed</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"cumulativeGasUsed" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"logsBloom" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="background-color:rgb(255,250,165);"><span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;Logs []</span><span style="color:rgb(0,0,0);font-family:Monaco;">*</span><span style="color:rgb(0,0,0);font-family:Monaco;">Log</span><span style="font-family:Monaco;"> </span><span style="color:rgb(163,21,21);font-family:Monaco;">`json:"logs" gencodec:"required"`</span><span style="font-family:Monaco;"></span></span>
   </div>
   <div style="font-size:12px;">
    <br style="font-family:Monaco;">
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;</span>
    <span style="color:rgb(0,128,0);font-family:Monaco;">// Implementation fields (don't reorder!)</span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"transactionHash" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;ContractAddress common.Address</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"contractAddress"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">&nbsp;&nbsp;&nbsp;&nbsp;GasUsed</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(38,127,153);font-family:Monaco;">uint64</span>
    <span style="font-family:Monaco;"> </span>
    <span style="color:rgb(163,21,21);font-family:Monaco;">`json:"gasUsed" gencodec:"required"`</span>
    <span style="font-family:Monaco;"></span>
   </div>
   <div style="font-size:12px;">
    <span style="color:rgb(0,0,0);font-family:Monaco;">}</span>
   </div>
  </div>
  <div>
   &nbsp;&nbsp; &nbsp;
  </div>
  <div>
   <span style="font-size:16px;">&nbsp;&nbsp;&nbsp;&nbsp;Receipt里的核心数据时Logs，智能合约允许开发人员通过event定义一些事件并广播到全网，这些event就是记录在Logs里面的</span>
  </div>
  <p></p>
  <div style="font-size:14px;color:rgb(69,69,69);">
   <span style="font-size:18px;font-family:SimSun;">/********************************</span>
  </div>
  <div style="font-size:14px;color:rgb(69,69,69);">
   <span style="font-size:18px;"><span style="line-height:19px;font-family:'Courier New';">* 本文来自CSDN博主"爱踢门"</span></span>
  </div>
  <div style="font-size:14px;color:rgb(69,69,69);">
   <span style="font-size:18px;font-family:'Courier New';line-height:19px;">* 转载请标明出处</span>
   <span style="font-size:18px;background-color:rgb(255,255,255);font-family:'Courier New';line-height:19px;">:</span>
   <a href="http://blog.csdn.net/itleaks" rel="nofollow" style="font-size:18px;font-family:'Courier New';line-height:19px;">http://blog.csdn.net/itleaks</a>
  </div>
  <div style="font-size:14px;color:rgb(69,69,69);">
   <span style="font-family:SimSun;line-height:19px;">******************************************/</span>
  </div>
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018050716414962" alt="">
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/80094294,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ITleaks/article/details/80094294,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
