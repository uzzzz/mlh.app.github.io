<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊白皮书解读 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊白皮书解读" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="背景比特币开创了去中心化密码货币的先河，五年多的时间充分检验了区块链技术的可行性和安全性。比特币的区块链事实上是一套分布式的数据库，如果再在其中加进一个符号——比特币，并规定一套协议使得这个符号可以在数据库上安全地转移，并且无需信任第三方，这些特征的组合完美地构造了一个货币传输体系——比特币网络。然而比特币作为一次密码货币的伟大尝试，她并不完美，其中，协议的扩展性是一项不足，例如比特币网络里只有一种符号——比特币，用户无法自定义另外的符号，这些符号可以是代表公司的股票，或者是债务凭证等，这就损失了一些功能。另外，比特币协议里使用了一套基于堆栈的脚本语言，这语言虽然具有一定灵活性，使得像多重签名这样的功能得以实现，然而却不足以构建更高级的应用，例如去中心化交易所等。 &nbsp; &nbsp;最新P3D新盘 chunchou.com 为了解决这个问题，社区的Mastercoin团队和Countparty团队都试图在比特币之上创建另外一套协议，同时也创建一种新币，这些币可以统称为Metacoin。具体的方式是通过在比特币的交易里添加额外的信息，再用另外的客户端来解析这些信息，他们把Meatcoin这种方式自比“在TCP/IP协议之上构建HTTP协议”。但问题来了，首先，这种方式的效率不高，例如在利用Metacoin系统构建的去中心化交易所里，当用户发出指令要买入某种资产时候，挟带这条指令的那笔比特币交易必须要被加入到区块之后，指令才能生效。高效的做法应该是这条指令直接保存在矿工的内存里，如果买入指令跟已有的卖单匹配，矿工则撮合交易，并写入下一个区块。而现在的情况是，比特币矿工根本不知道交易中嵌入的额外信息是什么意思，这样看起来“TCP/IP协议”和“HTTP协议”之间其实并不怎么配合，正如以太坊白皮书里所说，这倒更像是在SMTP协议上建立HTTP协议。以太坊的白皮书还指出，Metacoin不可能实现完全安全的轻钱包，也就是说客户端需要保留Metacoin创世区块后的所有比特币区块，这对用户来说是一件多么头大的事情啊！以太坊是什么？以太坊从设计上就是为了解决比特币扩展性不足的问题。总的来说，以太坊是一个平台，她上面提供各种模块让用户来搭建应用，如果将搭建应用比作造房子，那么以太坊就提供了墙面、屋顶、地板等模块，用户只需像搭积木一样把房子搭起来，因此在以太坊上建立应用的成本和速度都大大改善。具体来说，以太坊通过一套图灵完备的脚本语言（Ethereum Virtual Machine code，简称EVM语言）来建立应用，它类似于汇编语言，我们知道，直接用汇编语言编程是非常痛苦的，但以太坊里的编程并不需要直接使用EVM语言，而是类似C语言、Python、Lisp等高级语言，再通过编译器转成EVM语言。上面所说的平台之上的应用，其实就是合约，这是以太坊的核心。合约是一个活在以太坊系统里的自动代理人，他有一个自己的以太币地址，当用户向合约的地址里发送一笔交易后，该合约就被激活，然后根据交易中的额外信息，合约会运行自身的代码，最后返回一个结果，这个结果可能是从合约的地址发出另外一笔交易。需要指出的是，以太坊中的交易，不单只是发送以太币而已，它还可以嵌入相当多的额外信息。如果一笔交易是发送给合约的，那么这些信息就非常重要，因为合约将根据这些信息来完成自身的业务逻辑。合约所能提供的业务，几乎是无穷无尽的，它的边界就是你的想象力，因为图灵完备的语言提供了完整的自由度，让用户搭建各种应用。白皮书举了几个例子，如储蓄账户、用户自定义的子货币等，这里再列举几个笔者想到的例子：1）去中心化交易所，2）各种金融衍生合约，3）彩票，4）基于预测未来事件的打赌，5）投票/仲裁系统，6）去中心化自治组织（DAO），例如基金。这些合约之间可以互动，例如4）打赌合约可以访问5）仲裁合约，而仲裁合约可能是一个基于POS的投票系统，投票的结果作为外部事件的结果返回给打赌合约，作为最后的裁定。合约示例对于希望了解如何建立合约、以及合约如何运转的读者，以下两个例子应该能提供一些帮助，但最好结合白皮书中的交易格式、费用组成、数据存储结构等知识进行理解。以下的例子采用类似C的语言编写。Name Registration[1] if tx.value &lt; block.basefee * 200:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] if contract.storage[tx.data[0]] or tx.data[0] &lt; 100:[4]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[5] contract.storage[tx.data[0]] = tx.data[1]第1行：如果手续费不够，退出。第3行：contract.storage[tx.data[0]] 是为了检查tx.data[0]所代表的名称是不是已经被注册了，例如www.bitfarm.io。因为所有contract.storage的项的初始值都是0，所以如果contract.storage[tx.data[0]]不为0，说明之前已经注册过了，而如果if从句返回一个非0的值，则执行stop。tx.data[0]&lt;100是检查需要注册的名称翻译成数字时，是否小于100，这里100是一个估计值，它需要比这个合约编译后生成的机器代码的字节数大才行，以免注册的名称把合约本身覆盖了，因为合约本身编译后的存储也是在contract.storage里面 。这个合约不会超过100个字节，但对于更多字节数的合约则可能需要使用500来作为保护值，这个值估计需要保守一点。第5行：把tx.data[1]的值写进contract.storage[tx.data[0]]，这里tx.data[1]可能是一个ip地址，来对www.bitfarm.io进行DNS注册。Sub-currency[1] if tx.value &lt; 100 * block.basefee:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] elif contract.storage[1000]:[4]&nbsp; &nbsp;&nbsp; &nbsp;from = tx.sender[5]&nbsp; &nbsp;&nbsp; &nbsp;to = tx.data[0][6]&nbsp; &nbsp;&nbsp; &nbsp;value = tx.data[1][7]&nbsp; &nbsp;&nbsp; &nbsp;if to &lt;= 1000:[8]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; stop[9]&nbsp; &nbsp;&nbsp; &nbsp;if contract.storage[from] &lt; value:[10]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;stop[11]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[from] = contract.storage[from] - value[12]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[to] = contract.storage[to] + value[13]else:[14]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[MYCREATOR] = 10^18[15]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[1000] = 1&nbsp;第1行：如果手续费不够，退出。第3行：因为所有的contract.storage的项的初始值都是0，所以跳过3-12行，来到第13行。第14行：MYCREATOR是contract的创建者自己可以定义的，可能是他自己的某个Ether的地址，这样，他就给自己分配了10^18个子货币，例如这个子货币是他公司的股票。第15行：把contract.storage[1000]的值从0改为1。至此，合约的初始化完毕。第3行：现在合约的创建者可以给其他人发送子货币（股票）了。因为已经初始化了，contract.storage[1000] = 1，所以执行第4行。第4行：定义局部变量from，并赋值tx.sender给它。这里，tx.sender是合约创始人的地址MYCREATOR。第5行：定义局部变量to，并赋值tx.data[0]给它。tx.data[0]是发送交易激活合约时，发送者输入的子货币接收地址。第6行：定义局部变量value，并赋值tx.data[1]给它。tx.data[1]是发送交易激活合约时，发送者输入的子货币发送量。第7行：检查to是不是小于1000，防止覆盖合约本身的代码。具体细节请见上一个例子。第9行：检查发送者拥有的子货币数量是否小于要发送的子货币数量。第11、12行：把子货币的发送量从发送者的账户减掉，加到接受者的账户。总结 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 比特币网络事实上是一套分布式的数据库，而以太坊则更进一步，她可以看作是一台分布式的计算机：区块链是计算机的ROM，合约是程序，而以太坊的矿工们则负责计算，担任CPU的角色。这台计算机不是、也不可能是免费使用的，不然任何人都可以往里面存储各种垃圾信息和执行各种鸡毛蒜皮的计算，白皮书有说明，使用它至少需要支付计算费和存储费，当然还有其它一些费用。这台分布式计算机，配以图灵完备的语言，再加上你的聪明才智，将怎样撬动密码货币、分布式应用领域？我们拭目以待。大时代来临，你准备好了吗？ 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多" />
<meta property="og:description" content="背景比特币开创了去中心化密码货币的先河，五年多的时间充分检验了区块链技术的可行性和安全性。比特币的区块链事实上是一套分布式的数据库，如果再在其中加进一个符号——比特币，并规定一套协议使得这个符号可以在数据库上安全地转移，并且无需信任第三方，这些特征的组合完美地构造了一个货币传输体系——比特币网络。然而比特币作为一次密码货币的伟大尝试，她并不完美，其中，协议的扩展性是一项不足，例如比特币网络里只有一种符号——比特币，用户无法自定义另外的符号，这些符号可以是代表公司的股票，或者是债务凭证等，这就损失了一些功能。另外，比特币协议里使用了一套基于堆栈的脚本语言，这语言虽然具有一定灵活性，使得像多重签名这样的功能得以实现，然而却不足以构建更高级的应用，例如去中心化交易所等。 &nbsp; &nbsp;最新P3D新盘 chunchou.com 为了解决这个问题，社区的Mastercoin团队和Countparty团队都试图在比特币之上创建另外一套协议，同时也创建一种新币，这些币可以统称为Metacoin。具体的方式是通过在比特币的交易里添加额外的信息，再用另外的客户端来解析这些信息，他们把Meatcoin这种方式自比“在TCP/IP协议之上构建HTTP协议”。但问题来了，首先，这种方式的效率不高，例如在利用Metacoin系统构建的去中心化交易所里，当用户发出指令要买入某种资产时候，挟带这条指令的那笔比特币交易必须要被加入到区块之后，指令才能生效。高效的做法应该是这条指令直接保存在矿工的内存里，如果买入指令跟已有的卖单匹配，矿工则撮合交易，并写入下一个区块。而现在的情况是，比特币矿工根本不知道交易中嵌入的额外信息是什么意思，这样看起来“TCP/IP协议”和“HTTP协议”之间其实并不怎么配合，正如以太坊白皮书里所说，这倒更像是在SMTP协议上建立HTTP协议。以太坊的白皮书还指出，Metacoin不可能实现完全安全的轻钱包，也就是说客户端需要保留Metacoin创世区块后的所有比特币区块，这对用户来说是一件多么头大的事情啊！以太坊是什么？以太坊从设计上就是为了解决比特币扩展性不足的问题。总的来说，以太坊是一个平台，她上面提供各种模块让用户来搭建应用，如果将搭建应用比作造房子，那么以太坊就提供了墙面、屋顶、地板等模块，用户只需像搭积木一样把房子搭起来，因此在以太坊上建立应用的成本和速度都大大改善。具体来说，以太坊通过一套图灵完备的脚本语言（Ethereum Virtual Machine code，简称EVM语言）来建立应用，它类似于汇编语言，我们知道，直接用汇编语言编程是非常痛苦的，但以太坊里的编程并不需要直接使用EVM语言，而是类似C语言、Python、Lisp等高级语言，再通过编译器转成EVM语言。上面所说的平台之上的应用，其实就是合约，这是以太坊的核心。合约是一个活在以太坊系统里的自动代理人，他有一个自己的以太币地址，当用户向合约的地址里发送一笔交易后，该合约就被激活，然后根据交易中的额外信息，合约会运行自身的代码，最后返回一个结果，这个结果可能是从合约的地址发出另外一笔交易。需要指出的是，以太坊中的交易，不单只是发送以太币而已，它还可以嵌入相当多的额外信息。如果一笔交易是发送给合约的，那么这些信息就非常重要，因为合约将根据这些信息来完成自身的业务逻辑。合约所能提供的业务，几乎是无穷无尽的，它的边界就是你的想象力，因为图灵完备的语言提供了完整的自由度，让用户搭建各种应用。白皮书举了几个例子，如储蓄账户、用户自定义的子货币等，这里再列举几个笔者想到的例子：1）去中心化交易所，2）各种金融衍生合约，3）彩票，4）基于预测未来事件的打赌，5）投票/仲裁系统，6）去中心化自治组织（DAO），例如基金。这些合约之间可以互动，例如4）打赌合约可以访问5）仲裁合约，而仲裁合约可能是一个基于POS的投票系统，投票的结果作为外部事件的结果返回给打赌合约，作为最后的裁定。合约示例对于希望了解如何建立合约、以及合约如何运转的读者，以下两个例子应该能提供一些帮助，但最好结合白皮书中的交易格式、费用组成、数据存储结构等知识进行理解。以下的例子采用类似C的语言编写。Name Registration[1] if tx.value &lt; block.basefee * 200:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] if contract.storage[tx.data[0]] or tx.data[0] &lt; 100:[4]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[5] contract.storage[tx.data[0]] = tx.data[1]第1行：如果手续费不够，退出。第3行：contract.storage[tx.data[0]] 是为了检查tx.data[0]所代表的名称是不是已经被注册了，例如www.bitfarm.io。因为所有contract.storage的项的初始值都是0，所以如果contract.storage[tx.data[0]]不为0，说明之前已经注册过了，而如果if从句返回一个非0的值，则执行stop。tx.data[0]&lt;100是检查需要注册的名称翻译成数字时，是否小于100，这里100是一个估计值，它需要比这个合约编译后生成的机器代码的字节数大才行，以免注册的名称把合约本身覆盖了，因为合约本身编译后的存储也是在contract.storage里面 。这个合约不会超过100个字节，但对于更多字节数的合约则可能需要使用500来作为保护值，这个值估计需要保守一点。第5行：把tx.data[1]的值写进contract.storage[tx.data[0]]，这里tx.data[1]可能是一个ip地址，来对www.bitfarm.io进行DNS注册。Sub-currency[1] if tx.value &lt; 100 * block.basefee:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] elif contract.storage[1000]:[4]&nbsp; &nbsp;&nbsp; &nbsp;from = tx.sender[5]&nbsp; &nbsp;&nbsp; &nbsp;to = tx.data[0][6]&nbsp; &nbsp;&nbsp; &nbsp;value = tx.data[1][7]&nbsp; &nbsp;&nbsp; &nbsp;if to &lt;= 1000:[8]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; stop[9]&nbsp; &nbsp;&nbsp; &nbsp;if contract.storage[from] &lt; value:[10]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;stop[11]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[from] = contract.storage[from] - value[12]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[to] = contract.storage[to] + value[13]else:[14]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[MYCREATOR] = 10^18[15]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[1000] = 1&nbsp;第1行：如果手续费不够，退出。第3行：因为所有的contract.storage的项的初始值都是0，所以跳过3-12行，来到第13行。第14行：MYCREATOR是contract的创建者自己可以定义的，可能是他自己的某个Ether的地址，这样，他就给自己分配了10^18个子货币，例如这个子货币是他公司的股票。第15行：把contract.storage[1000]的值从0改为1。至此，合约的初始化完毕。第3行：现在合约的创建者可以给其他人发送子货币（股票）了。因为已经初始化了，contract.storage[1000] = 1，所以执行第4行。第4行：定义局部变量from，并赋值tx.sender给它。这里，tx.sender是合约创始人的地址MYCREATOR。第5行：定义局部变量to，并赋值tx.data[0]给它。tx.data[0]是发送交易激活合约时，发送者输入的子货币接收地址。第6行：定义局部变量value，并赋值tx.data[1]给它。tx.data[1]是发送交易激活合约时，发送者输入的子货币发送量。第7行：检查to是不是小于1000，防止覆盖合约本身的代码。具体细节请见上一个例子。第9行：检查发送者拥有的子货币数量是否小于要发送的子货币数量。第11、12行：把子货币的发送量从发送者的账户减掉，加到接受者的账户。总结 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 比特币网络事实上是一套分布式的数据库，而以太坊则更进一步，她可以看作是一台分布式的计算机：区块链是计算机的ROM，合约是程序，而以太坊的矿工们则负责计算，担任CPU的角色。这台计算机不是、也不可能是免费使用的，不然任何人都可以往里面存储各种垃圾信息和执行各种鸡毛蒜皮的计算，白皮书有说明，使用它至少需要支付计算费和存储费，当然还有其它一些费用。这台分布式计算机，配以图灵完备的语言，再加上你的聪明才智，将怎样撬动密码货币、分布式应用领域？我们拭目以待。大时代来临，你准备好了吗？ 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"背景比特币开创了去中心化密码货币的先河，五年多的时间充分检验了区块链技术的可行性和安全性。比特币的区块链事实上是一套分布式的数据库，如果再在其中加进一个符号——比特币，并规定一套协议使得这个符号可以在数据库上安全地转移，并且无需信任第三方，这些特征的组合完美地构造了一个货币传输体系——比特币网络。然而比特币作为一次密码货币的伟大尝试，她并不完美，其中，协议的扩展性是一项不足，例如比特币网络里只有一种符号——比特币，用户无法自定义另外的符号，这些符号可以是代表公司的股票，或者是债务凭证等，这就损失了一些功能。另外，比特币协议里使用了一套基于堆栈的脚本语言，这语言虽然具有一定灵活性，使得像多重签名这样的功能得以实现，然而却不足以构建更高级的应用，例如去中心化交易所等。 &nbsp; &nbsp;最新P3D新盘 chunchou.com 为了解决这个问题，社区的Mastercoin团队和Countparty团队都试图在比特币之上创建另外一套协议，同时也创建一种新币，这些币可以统称为Metacoin。具体的方式是通过在比特币的交易里添加额外的信息，再用另外的客户端来解析这些信息，他们把Meatcoin这种方式自比“在TCP/IP协议之上构建HTTP协议”。但问题来了，首先，这种方式的效率不高，例如在利用Metacoin系统构建的去中心化交易所里，当用户发出指令要买入某种资产时候，挟带这条指令的那笔比特币交易必须要被加入到区块之后，指令才能生效。高效的做法应该是这条指令直接保存在矿工的内存里，如果买入指令跟已有的卖单匹配，矿工则撮合交易，并写入下一个区块。而现在的情况是，比特币矿工根本不知道交易中嵌入的额外信息是什么意思，这样看起来“TCP/IP协议”和“HTTP协议”之间其实并不怎么配合，正如以太坊白皮书里所说，这倒更像是在SMTP协议上建立HTTP协议。以太坊的白皮书还指出，Metacoin不可能实现完全安全的轻钱包，也就是说客户端需要保留Metacoin创世区块后的所有比特币区块，这对用户来说是一件多么头大的事情啊！以太坊是什么？以太坊从设计上就是为了解决比特币扩展性不足的问题。总的来说，以太坊是一个平台，她上面提供各种模块让用户来搭建应用，如果将搭建应用比作造房子，那么以太坊就提供了墙面、屋顶、地板等模块，用户只需像搭积木一样把房子搭起来，因此在以太坊上建立应用的成本和速度都大大改善。具体来说，以太坊通过一套图灵完备的脚本语言（Ethereum Virtual Machine code，简称EVM语言）来建立应用，它类似于汇编语言，我们知道，直接用汇编语言编程是非常痛苦的，但以太坊里的编程并不需要直接使用EVM语言，而是类似C语言、Python、Lisp等高级语言，再通过编译器转成EVM语言。上面所说的平台之上的应用，其实就是合约，这是以太坊的核心。合约是一个活在以太坊系统里的自动代理人，他有一个自己的以太币地址，当用户向合约的地址里发送一笔交易后，该合约就被激活，然后根据交易中的额外信息，合约会运行自身的代码，最后返回一个结果，这个结果可能是从合约的地址发出另外一笔交易。需要指出的是，以太坊中的交易，不单只是发送以太币而已，它还可以嵌入相当多的额外信息。如果一笔交易是发送给合约的，那么这些信息就非常重要，因为合约将根据这些信息来完成自身的业务逻辑。合约所能提供的业务，几乎是无穷无尽的，它的边界就是你的想象力，因为图灵完备的语言提供了完整的自由度，让用户搭建各种应用。白皮书举了几个例子，如储蓄账户、用户自定义的子货币等，这里再列举几个笔者想到的例子：1）去中心化交易所，2）各种金融衍生合约，3）彩票，4）基于预测未来事件的打赌，5）投票/仲裁系统，6）去中心化自治组织（DAO），例如基金。这些合约之间可以互动，例如4）打赌合约可以访问5）仲裁合约，而仲裁合约可能是一个基于POS的投票系统，投票的结果作为外部事件的结果返回给打赌合约，作为最后的裁定。合约示例对于希望了解如何建立合约、以及合约如何运转的读者，以下两个例子应该能提供一些帮助，但最好结合白皮书中的交易格式、费用组成、数据存储结构等知识进行理解。以下的例子采用类似C的语言编写。Name Registration[1] if tx.value &lt; block.basefee * 200:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] if contract.storage[tx.data[0]] or tx.data[0] &lt; 100:[4]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[5] contract.storage[tx.data[0]] = tx.data[1]第1行：如果手续费不够，退出。第3行：contract.storage[tx.data[0]] 是为了检查tx.data[0]所代表的名称是不是已经被注册了，例如www.bitfarm.io。因为所有contract.storage的项的初始值都是0，所以如果contract.storage[tx.data[0]]不为0，说明之前已经注册过了，而如果if从句返回一个非0的值，则执行stop。tx.data[0]&lt;100是检查需要注册的名称翻译成数字时，是否小于100，这里100是一个估计值，它需要比这个合约编译后生成的机器代码的字节数大才行，以免注册的名称把合约本身覆盖了，因为合约本身编译后的存储也是在contract.storage里面 。这个合约不会超过100个字节，但对于更多字节数的合约则可能需要使用500来作为保护值，这个值估计需要保守一点。第5行：把tx.data[1]的值写进contract.storage[tx.data[0]]，这里tx.data[1]可能是一个ip地址，来对www.bitfarm.io进行DNS注册。Sub-currency[1] if tx.value &lt; 100 * block.basefee:[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;[3] elif contract.storage[1000]:[4]&nbsp; &nbsp;&nbsp; &nbsp;from = tx.sender[5]&nbsp; &nbsp;&nbsp; &nbsp;to = tx.data[0][6]&nbsp; &nbsp;&nbsp; &nbsp;value = tx.data[1][7]&nbsp; &nbsp;&nbsp; &nbsp;if to &lt;= 1000:[8]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; stop[9]&nbsp; &nbsp;&nbsp; &nbsp;if contract.storage[from] &lt; value:[10]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;stop[11]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[from] = contract.storage[from] - value[12]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[to] = contract.storage[to] + value[13]else:[14]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[MYCREATOR] = 10^18[15]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[1000] = 1&nbsp;第1行：如果手续费不够，退出。第3行：因为所有的contract.storage的项的初始值都是0，所以跳过3-12行，来到第13行。第14行：MYCREATOR是contract的创建者自己可以定义的，可能是他自己的某个Ether的地址，这样，他就给自己分配了10^18个子货币，例如这个子货币是他公司的股票。第15行：把contract.storage[1000]的值从0改为1。至此，合约的初始化完毕。第3行：现在合约的创建者可以给其他人发送子货币（股票）了。因为已经初始化了，contract.storage[1000] = 1，所以执行第4行。第4行：定义局部变量from，并赋值tx.sender给它。这里，tx.sender是合约创始人的地址MYCREATOR。第5行：定义局部变量to，并赋值tx.data[0]给它。tx.data[0]是发送交易激活合约时，发送者输入的子货币接收地址。第6行：定义局部变量value，并赋值tx.data[1]给它。tx.data[1]是发送交易激活合约时，发送者输入的子货币发送量。第7行：检查to是不是小于1000，防止覆盖合约本身的代码。具体细节请见上一个例子。第9行：检查发送者拥有的子货币数量是否小于要发送的子货币数量。第11、12行：把子货币的发送量从发送者的账户减掉，加到接受者的账户。总结 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 比特币网络事实上是一套分布式的数据库，而以太坊则更进一步，她可以看作是一台分布式的计算机：区块链是计算机的ROM，合约是程序，而以太坊的矿工们则负责计算，担任CPU的角色。这台计算机不是、也不可能是免费使用的，不然任何人都可以往里面存储各种垃圾信息和执行各种鸡毛蒜皮的计算，白皮书有说明，使用它至少需要支付计算费和存储费，当然还有其它一些费用。这台分布式计算机，配以图灵完备的语言，再加上你的聪明才智，将怎样撬动密码货币、分布式应用领域？我们拭目以待。大时代来临，你准备好了吗？ 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多","@type":"BlogPosting","url":"/2018/06/20/35cb7c41ce4b931dc134a71edd7b34f4.html","headline":"以太坊白皮书解读","dateModified":"2018-06-20T00:00:00+08:00","datePublished":"2018-06-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/06/20/35cb7c41ce4b931dc134a71edd7b34f4.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊白皮书解读</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong><span style="color:#444444;">背景</span></strong><br><span style="color:#444444;">比特币开创了去中心化密码货币的先河，五年多的时间充分检验了区块链技术的可行性和安全性。比特币的区块链事实上是一套分布式的数据库，如果再在其中加进一个符号——比特币，并规定一套协议使得这个符号可以在数据库上安全地转移，并且无需信任第三方，这些特征的组合完美地构造了一个货币传输体系——比特币网络。然而比特币作为一次密码货币的伟大尝试，她并不完美，其中，协议的扩展性是一项不足，例如比特币网络里只有一种符号——比特币，用户无法自定义另外的符号，这些符号可以是代表公司的股票，或者是债务凭证等，这就损失了一些功能。另外，比特币协议里使用了一套基于堆栈的脚本语言，这语言虽然具有一定灵活性，使得像多重签名这样的功能得以实现，然而却不足以构建更高级的应用，例如去中心化交易所等。</span></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;最新P3D新盘 chunchou.com</p> 
  <p><br><br><span style="color:#444444;">为了解决这个问题，社区的Mastercoin团队和Countparty团队都试图在比特币之上创建另外一套协议，同时也创建一种新币，这些币可以统称为Metacoin。具体的方式是通过在比特币的交易里添加额外的信息，再用另外的客户端来解析这些信息，他们把Meatcoin这种方式自比“在TCP/IP协议之上构建HTTP协议”。但问题来了，首先，这种方式的效率不高，例如在利用Metacoin系统构建的去中心化交易所里，当用户发出指令要买入某种资产时候，挟带这条指令的那笔比特币交易必须要被加入到区块之后，指令才能生效。高效的做法应该是这条指令直接保存在矿工的内存里，如果买入指令跟已有的卖单匹配，矿工则撮合交易，并写入下一个区块。而现在的情况是，比特币矿工根本不知道交易中嵌入的额外信息是什么意思，这样看起来“TCP/IP协议”和“HTTP协议”之间其实并不怎么配合，正如以太坊白皮书里所说，这倒更像是在SMTP协议上建立HTTP协议。以太坊的白皮书还指出，Metacoin不可能实现完全安全的轻钱包，也就是说客户端需要保留Metacoin创世区块后的所有比特币区块，这对用户来说是一件多么头大的事情啊！</span><br><br><strong><span style="color:#444444;">以太坊是什么？</span></strong><br><span style="color:#444444;">以太坊从设计上就是为了解决比特币扩展性不足的问题。总的来说，以太坊是一个平台，她上面提供各种模块让用户来搭建应用，如果将搭建应用比作造房子，那么以太坊就提供了墙面、屋顶、地板等模块，用户只需像搭积木一样把房子搭起来，因此在以太坊上建立应用的成本和速度都大大改善。具体来说，以太坊通过一套图灵完备的脚本语言（Ethereum Virtual Machine code，简称EVM语言）来建立应用，它类似于汇编语言，我们知道，直接用汇编语言编程是非常痛苦的，但以太坊里的编程并不需要直接使用EVM语言，而是类似C语言、Python、Lisp等高级语言，再通过编译器转成EVM语言。</span><br><br><span style="color:#444444;">上面所说的平台之上的应用，其实就是合约，这是以太坊的核心。合约是一个活在以太坊系统里的自动代理人，他有一个自己的以太币地址，当用户向合约的地址里发送一笔交易后，该合约就被激活，然后根据交易中的额外信息，合约会运行自身的代码，最后返回一个结果，这个结果可能是从合约的地址发出另外一笔交易。需要指出的是，以太坊中的交易，不单只是发送以太币而已，它还可以嵌入相当多的额外信息。如果一笔交易是发送给合约的，那么这些信息就非常重要，因为合约将根据这些信息来完成自身的业务逻辑。</span><br><br><span style="color:#444444;">合约所能提供的业务，几乎是无穷无尽的，它的边界就是你的想象力，因为图灵完备的语言提供了完整的自由度，让用户搭建各种应用。白皮书举了几个例子，如储蓄账户、用户自定义的子货币等，这里再列举几个笔者想到的例子：1）去中心化交易所，2）各种金融衍生合约，3）彩票，4）基于预测未来事件的打赌，5）投票/仲裁系统，6）去中心化自治组织（DAO），例如基金。这些合约之间可以互动，例如4）打赌合约可以访问5）仲裁合约，而仲裁合约可能是一个基于POS的投票系统，投票的结果作为外部事件的结果返回给打赌合约，作为最后的裁定。</span><br><br><strong><span style="color:#444444;">合约示例</span></strong><br><span style="color:#444444;">对于希望了解如何建立合约、以及合约如何运转的读者，以下两个例子应该能提供一些帮助，但最好结合白皮书中的交易格式、费用组成、数据存储结构等知识进行理解。以下的例子采用类似C的语言编写。</span><br><br><em><span style="color:#444444;">Name Registration</span></em><br><span style="color:#444444;">[1] if tx.value &lt; block.basefee * 200:</span><br><span style="color:#444444;">[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;</span><br><span style="color:#444444;">[3] if contract.storage[tx.data[0]] or tx.data[0] &lt; 100:</span><br><span style="color:#444444;">[4]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;</span><br><span style="color:#444444;">[5] contract.storage[tx.data[0]] = tx.data[1]</span><br><br><span style="color:#444444;">第1行：如果手续费不够，退出。</span><br><span style="color:#444444;">第3行：contract.storage[tx.data[0]] 是为了检查tx.data[0]所代表的名称是不是已经被注册了，例如</span><a href="http://www.bitfarm.io/" rel="nofollow"><u><span style="color:#336699;">www.bitfarm.io</span></u></a><span style="color:#444444;">。因为所有contract.storage的项的初始值都是0，所以如果contract.storage[tx.data[0]]不为0，说明之前已经注册过了，而如果if从句返回一个非0的值，则执行stop。tx.data[0]&lt;100是检查需要注册的名称翻译成数字时，是否小于100，这里100是一个估计值，它需要比这个合约编译后生成的机器代码的字节数大才行，以免注册的名称把合约本身覆盖了，因为合约本身编译后的存储也是在contract.storage里面 。这个合约不会超过100个字节，但对于更多字节数的合约则可能需要使用500来作为保护值，这个值估计需要保守一点。</span><br><span style="color:#444444;">第5行：把tx.data[1]的值写进contract.storage[tx.data[0]]，这里tx.data[1]可能是一个ip地址，来对</span><a href="http://www.bitfarm.io/" rel="nofollow"><u><span style="color:#336699;">www.bitfarm.io</span></u></a><span style="color:#444444;">进行DNS注册。</span><br><br><br><em><span style="color:#444444;">Sub-currency</span></em><br><span style="color:#444444;">[1] if tx.value &lt; 100 * block.basefee:</span><br><span style="color:#444444;">[2]&nbsp; &nbsp;&nbsp; &nbsp;stop&nbsp;</span><br><span style="color:#444444;">[3] elif contract.storage[1000]:</span><br><span style="color:#444444;">[4]&nbsp; &nbsp;&nbsp; &nbsp;from = tx.sender</span><br><span style="color:#444444;">[5]&nbsp; &nbsp;&nbsp; &nbsp;to = tx.data[0]</span><br><span style="color:#444444;">[6]&nbsp; &nbsp;&nbsp; &nbsp;value = tx.data[1]</span><br><span style="color:#444444;">[7]&nbsp; &nbsp;&nbsp; &nbsp;if to &lt;= 1000:</span><br><span style="color:#444444;">[8]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; stop</span><br><span style="color:#444444;">[9]&nbsp; &nbsp;&nbsp; &nbsp;if contract.storage[from] &lt; value:</span><br><span style="color:#444444;">[10]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;stop</span><br><span style="color:#444444;">[11]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[from] = contract.storage[from] - value</span><br><span style="color:#444444;">[12]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[to] = contract.storage[to] + value</span><br><span style="color:#444444;">[13]else:</span><br><span style="color:#444444;">[14]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[MYCREATOR] = 10^18</span><br><span style="color:#444444;">[15]&nbsp; &nbsp;&nbsp;&nbsp;contract.storage[1000] = 1&nbsp;</span><br><br><span style="color:#444444;">第1行：如果手续费不够，退出。</span><br><span style="color:#444444;">第3行：因为所有的contract.storage的项的初始值都是0，所以跳过3-12行，来到第13行。</span><br><span style="color:#444444;">第14行：MYCREATOR是contract的创建者自己可以定义的，可能是他自己的某个Ether的地址，这样，他就给自己分配了10^18个子货币，例如这个子货币是他公司的股票。</span><br><span style="color:#444444;">第15行：把contract.storage[1000]的值从0改为1。至此，合约的初始化完毕。</span><br><span style="color:#444444;">第3行：现在合约的创建者可以给其他人发送子货币（股票）了。因为已经初始化了，contract.storage[1000] = 1，所以执行第4行。</span><br><span style="color:#444444;">第4行：定义局部变量from，并赋值tx.sender给它。这里，tx.sender是合约创始人的地址MYCREATOR。</span><br><span style="color:#444444;">第5行：定义局部变量to，并赋值tx.data[0]给它。tx.data[0]是发送交易激活合约时，发送者输入的子货币接收地址。</span><br><span style="color:#444444;">第6行：定义局部变量value，并赋值tx.data[1]给它。tx.data[1]是发送交易激活合约时，发送者输入的子货币发送量。</span><br><span style="color:#444444;">第7行：检查to是不是小于1000，防止覆盖合约本身的代码。具体细节请见上一个例子。</span><br><span style="color:#444444;">第9行：检查发送者拥有的子货币数量是否小于要发送的子货币数量。</span><br><span style="color:#444444;">第11、12行：把子货币的发送量从发送者的账户减掉，加到接受者的账户。</span><br><br><br><strong><span style="color:#444444;">总结</span></strong></p> 
  <p><span style="color:#444444;">打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。</span></p> 
  <p><br><span style="color:#444444;">比特币网络事实上是一套分布式的数据库，而以太坊则更进一步，她可以看作是一台分布式的计算机：区块链是计算机的ROM，合约是程序，而以太坊的矿工们则负责计算，担任CPU的角色。这台计算机不是、也不可能是免费使用的，不然任何人都可以往里面存储各种垃圾信息和执行各种鸡毛蒜皮的计算，白皮书有说明，使用它至少需要支付计算费和存储费，当然还有其它一些费用。</span><br><br><span style="color:#444444;">这台分布式计算机，配以图灵完备的语言，再加上你的聪明才智，将怎样撬动密码货币、分布式应用领域？我们拭目以待。</span><br><br><span style="color:#444444;">大时代来临，你准备好了吗？</span></p> 
  <p>360浏览器版MetaMask中文版下载地址<br><a href="https://ext.se.360.cn/webstore/detail/cickkggoijngnjkmbmkibdhmklahopfi" rel="nofollow">https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi</a><br><br> 360极速浏览器版MetaMask中文版下载地址<br><a href="https://ext.chrome.360.cn/webstore/detail/cickkggoijngnjkmbmkibdhmklahopfi" rel="nofollow">https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi</a><br><br> 百度云下载地址<br><a href="https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA" rel="nofollow">https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA</a><br><br> MetaMask中文版谷歌下载地址<br><a href="https://chrome.google.com/webstore/search/metamask%20%E4%B8%AD%E6%96%87?hl=zh-CN" rel="nofollow">https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN</a></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/niumenglong1/article/details/80741562,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/niumenglong1/article/details/80741562,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
