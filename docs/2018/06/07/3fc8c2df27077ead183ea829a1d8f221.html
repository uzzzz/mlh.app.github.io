<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>geth源码阅读——创建外部账号的流程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="geth源码阅读——创建外部账号的流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文探究&nbsp;geth account new&nbsp;命令的代码执行流程 一、寻找命令入口 1.1. go-ethereum工程/cmd/geth/main.go func init() { &nbsp;&nbsp; // Initialize the CLI app and start Geth &nbsp;&nbsp; app.Action = geth &nbsp;&nbsp; app.HideVersion = true // we have a commandto print the version &nbsp;&nbsp; app.Copyright = &quot;Copyright 2013-2018The go-ethereum Authors&quot; &nbsp;&nbsp; app.Commands = []cli.Command{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........................ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See accountcmd.go: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accountCommand,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从这里知道，与account命令相关的代码在accountCommand.go文件中 } 1.2. 打开 cms/geth/accountcmd.go Subcommands:[]cli.Command{ ................... { &nbsp;&nbsp; Name:&nbsp;&nbsp;&quot;new&quot;, &nbsp;&nbsp; Usage:&nbsp;&quot;Create a new account&quot;, &nbsp;&nbsp; Action: utils.MigrateFlags(accountCreate),&nbsp;&nbsp;&nbsp;&nbsp;//从这里可以知道 new 命令的执行函数在accountCreate函数中 &nbsp;&nbsp; Flags: []cli.Flag{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.DataDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.KeyStoreDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.PasswordFileFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.LightKDFFlag, &nbsp;&nbsp; }, ................ 二、accountCreate函数执行流程 // accountcmd.go funcaccountCreate(ctx *cli.Context) error { &nbsp;&nbsp; …… 加载配置文件, 获取keydir，scryptN, scryptP &nbsp;&nbsp; //提示输入密码 &nbsp;&nbsp; password := getPassPhrase(&quot;Your newaccount is locked with a password. Please give a password. Do not forget thispassword.&quot;, true, 0, utils.MakePasswordList(ctx)) &nbsp;&nbsp; //这里创建地址，生成公钥和私钥 &nbsp;&nbsp; address, err := keystore.StoreKey(keydir,password, scryptN, scryptP) &nbsp;&nbsp; //打印地址 &nbsp;&nbsp; fmt.Printf(&quot;Address: {%x}\n&quot;,address) &nbsp;&nbsp; return nil } ///////////////////////////////////////////////////////////////////////// //accounts/keystore/keystore_passphrase.go //具体表现为生成一对公私钥，再由私钥算出地址并构建一个自定义的Key // StoreKey generatesa key, encrypts with &#39;auth&#39; and stores in the given directoryfunc StoreKey(dir, auth string, scryptN, scryptPint) (common.Address, error) {&nbsp;&nbsp; _, a, err := storeNewKey(&amp;keyStorePassphrase{dir,scryptN, scryptP}, crand.Reader, auth)&nbsp;&nbsp; return a.Address,err} ///////////////////////////////////////////////////////////////////////////// //accounts/keystore/key.go func storeNewKey(ks keyStore, rand io.Reader, authstring) (*Key, accounts.Account, error) {&nbsp;&nbsp; key, err := newKey(rand)&nbsp;&nbsp;&nbsp; //生成密钥对&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, accounts.Account{},err&nbsp;&nbsp; }&nbsp;&nbsp; a := accounts.Account{Address:key.Address, URL: accounts.URL{Scheme: KeyStoreScheme, Path:ks.JoinPath(keyFileName(key.Address))}} &nbsp; //私钥被保存到磁盘，保存前使用密码加密，密钥文件存储在你的以太坊客户端keystore 子目录中&nbsp;&nbsp; if err :=ks.StoreKey(a.URL.Path, key, auth); err != nil {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroKey(key.PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,a, err&nbsp;&nbsp; }&nbsp;&nbsp; return key,a, err} ---------------------------------------------- func newKey(rand io.Reader) (*Key, error) { // ecdsa是椭圆曲线数字签名算法，这里使用ecdsa生成一对公私钥，并选择的是secp256k1曲线。&nbsp;&nbsp; privateKeyECDSA, err :=ecdsa.GenerateKey(crypto.S256(), rand)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; return newKeyFromECDSA(privateKeyECDSA),nil} --------------------------------------------------- // GenerateKeygenerates a public and private key pair.func GenerateKey(c elliptic.Curve, rand io.Reader)(*PrivateKey, error) {&nbsp;&nbsp; k, err := randFieldElement(c, rand)&nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; priv := new(PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成私钥&nbsp;&nbsp; priv.PublicKey.Curve = c&nbsp;&nbsp; priv.D = k&nbsp;&nbsp; priv.PublicKey.X, priv.PublicKey.Y =c.ScalarBaseMult(k.Bytes())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成公钥&nbsp;&nbsp; return priv,nil} --------------------------------------------------------------------------------------- func newKeyFromECDSA(privateKeyECDSA*ecdsa.PrivateKey) *Key {&nbsp;&nbsp; id := uuid.NewRandom()&nbsp;&nbsp; key := &amp;Key{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Address:&nbsp;&nbsp;&nbsp;crypto.PubkeyToAddress(privateKeyECDSA.PublicKey),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //地址是公钥转过来的，仅20字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrivateKey: privateKeyECDSA,&nbsp;&nbsp; }&nbsp;&nbsp; return key} ------------------------------------------------------------------------------------- func PubkeyToAddress(p ecdsa.PublicKey)common.Address {&nbsp;&nbsp; pubBytes := FromECDSAPub(&amp;p)&nbsp;&nbsp; return common.BytesToAddress(Keccak256(pubBytes[1:])[12:])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //公钥经过Keccak-256单向散列函数变成了256bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ------------------------------------------------------------------------------------- func BytesToAddress(b []byte) Address {&nbsp;&nbsp; var aAddress&nbsp;&nbsp; a.SetBytes(b)&nbsp;&nbsp; return a} -------------------------------------------------------------------------------------------- func (a *Address) SetBytes(b []byte) {&nbsp;&nbsp; if len(b)&gt; len(a) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = b[len(b)-AddressLength:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressLength等于20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; }&nbsp;&nbsp; copy(a[AddressLength-len(b):], b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取后20字节(160bit, 即40个16进制字符)作为地址} &nbsp; 三、总结 每个账户都由一对钥匙定义，一个私钥（PrivateKey）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里（Keystore）。 地址的生成的流程是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步： 1、&nbsp;由secp256k1曲线生成私钥，是由随机的256bit组成（32字节） 2、采用椭圆曲线数字签名算法（ECDSA）将私钥映射成公钥（64字节） 3、公钥经过Keccak-256单向散列函数变成了256bit，然后取160bit作为地址（20字节） 注意：私钥极其重要，用户输入的密码用来对私钥加密，加密后的密钥文件被保存到keystore目录下。密钥文件最好经常换密码，并以多种形式存放最为妥当。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="本文探究&nbsp;geth account new&nbsp;命令的代码执行流程 一、寻找命令入口 1.1. go-ethereum工程/cmd/geth/main.go func init() { &nbsp;&nbsp; // Initialize the CLI app and start Geth &nbsp;&nbsp; app.Action = geth &nbsp;&nbsp; app.HideVersion = true // we have a commandto print the version &nbsp;&nbsp; app.Copyright = &quot;Copyright 2013-2018The go-ethereum Authors&quot; &nbsp;&nbsp; app.Commands = []cli.Command{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........................ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See accountcmd.go: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accountCommand,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从这里知道，与account命令相关的代码在accountCommand.go文件中 } 1.2. 打开 cms/geth/accountcmd.go Subcommands:[]cli.Command{ ................... { &nbsp;&nbsp; Name:&nbsp;&nbsp;&quot;new&quot;, &nbsp;&nbsp; Usage:&nbsp;&quot;Create a new account&quot;, &nbsp;&nbsp; Action: utils.MigrateFlags(accountCreate),&nbsp;&nbsp;&nbsp;&nbsp;//从这里可以知道 new 命令的执行函数在accountCreate函数中 &nbsp;&nbsp; Flags: []cli.Flag{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.DataDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.KeyStoreDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.PasswordFileFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.LightKDFFlag, &nbsp;&nbsp; }, ................ 二、accountCreate函数执行流程 // accountcmd.go funcaccountCreate(ctx *cli.Context) error { &nbsp;&nbsp; …… 加载配置文件, 获取keydir，scryptN, scryptP &nbsp;&nbsp; //提示输入密码 &nbsp;&nbsp; password := getPassPhrase(&quot;Your newaccount is locked with a password. Please give a password. Do not forget thispassword.&quot;, true, 0, utils.MakePasswordList(ctx)) &nbsp;&nbsp; //这里创建地址，生成公钥和私钥 &nbsp;&nbsp; address, err := keystore.StoreKey(keydir,password, scryptN, scryptP) &nbsp;&nbsp; //打印地址 &nbsp;&nbsp; fmt.Printf(&quot;Address: {%x}\n&quot;,address) &nbsp;&nbsp; return nil } ///////////////////////////////////////////////////////////////////////// //accounts/keystore/keystore_passphrase.go //具体表现为生成一对公私钥，再由私钥算出地址并构建一个自定义的Key // StoreKey generatesa key, encrypts with &#39;auth&#39; and stores in the given directoryfunc StoreKey(dir, auth string, scryptN, scryptPint) (common.Address, error) {&nbsp;&nbsp; _, a, err := storeNewKey(&amp;keyStorePassphrase{dir,scryptN, scryptP}, crand.Reader, auth)&nbsp;&nbsp; return a.Address,err} ///////////////////////////////////////////////////////////////////////////// //accounts/keystore/key.go func storeNewKey(ks keyStore, rand io.Reader, authstring) (*Key, accounts.Account, error) {&nbsp;&nbsp; key, err := newKey(rand)&nbsp;&nbsp;&nbsp; //生成密钥对&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, accounts.Account{},err&nbsp;&nbsp; }&nbsp;&nbsp; a := accounts.Account{Address:key.Address, URL: accounts.URL{Scheme: KeyStoreScheme, Path:ks.JoinPath(keyFileName(key.Address))}} &nbsp; //私钥被保存到磁盘，保存前使用密码加密，密钥文件存储在你的以太坊客户端keystore 子目录中&nbsp;&nbsp; if err :=ks.StoreKey(a.URL.Path, key, auth); err != nil {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroKey(key.PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,a, err&nbsp;&nbsp; }&nbsp;&nbsp; return key,a, err} ---------------------------------------------- func newKey(rand io.Reader) (*Key, error) { // ecdsa是椭圆曲线数字签名算法，这里使用ecdsa生成一对公私钥，并选择的是secp256k1曲线。&nbsp;&nbsp; privateKeyECDSA, err :=ecdsa.GenerateKey(crypto.S256(), rand)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; return newKeyFromECDSA(privateKeyECDSA),nil} --------------------------------------------------- // GenerateKeygenerates a public and private key pair.func GenerateKey(c elliptic.Curve, rand io.Reader)(*PrivateKey, error) {&nbsp;&nbsp; k, err := randFieldElement(c, rand)&nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; priv := new(PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成私钥&nbsp;&nbsp; priv.PublicKey.Curve = c&nbsp;&nbsp; priv.D = k&nbsp;&nbsp; priv.PublicKey.X, priv.PublicKey.Y =c.ScalarBaseMult(k.Bytes())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成公钥&nbsp;&nbsp; return priv,nil} --------------------------------------------------------------------------------------- func newKeyFromECDSA(privateKeyECDSA*ecdsa.PrivateKey) *Key {&nbsp;&nbsp; id := uuid.NewRandom()&nbsp;&nbsp; key := &amp;Key{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Address:&nbsp;&nbsp;&nbsp;crypto.PubkeyToAddress(privateKeyECDSA.PublicKey),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //地址是公钥转过来的，仅20字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrivateKey: privateKeyECDSA,&nbsp;&nbsp; }&nbsp;&nbsp; return key} ------------------------------------------------------------------------------------- func PubkeyToAddress(p ecdsa.PublicKey)common.Address {&nbsp;&nbsp; pubBytes := FromECDSAPub(&amp;p)&nbsp;&nbsp; return common.BytesToAddress(Keccak256(pubBytes[1:])[12:])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //公钥经过Keccak-256单向散列函数变成了256bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ------------------------------------------------------------------------------------- func BytesToAddress(b []byte) Address {&nbsp;&nbsp; var aAddress&nbsp;&nbsp; a.SetBytes(b)&nbsp;&nbsp; return a} -------------------------------------------------------------------------------------------- func (a *Address) SetBytes(b []byte) {&nbsp;&nbsp; if len(b)&gt; len(a) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = b[len(b)-AddressLength:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressLength等于20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; }&nbsp;&nbsp; copy(a[AddressLength-len(b):], b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取后20字节(160bit, 即40个16进制字符)作为地址} &nbsp; 三、总结 每个账户都由一对钥匙定义，一个私钥（PrivateKey）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里（Keystore）。 地址的生成的流程是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步： 1、&nbsp;由secp256k1曲线生成私钥，是由随机的256bit组成（32字节） 2、采用椭圆曲线数字签名算法（ECDSA）将私钥映射成公钥（64字节） 3、公钥经过Keccak-256单向散列函数变成了256bit，然后取160bit作为地址（20字节） 注意：私钥极其重要，用户输入的密码用来对私钥加密，加密后的密钥文件被保存到keystore目录下。密钥文件最好经常换密码，并以多种形式存放最为妥当。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/07/3fc8c2df27077ead183ea829a1d8f221.html" />
<meta property="og:url" content="https://mlh.app/2018/06/07/3fc8c2df27077ead183ea829a1d8f221.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文探究&nbsp;geth account new&nbsp;命令的代码执行流程 一、寻找命令入口 1.1. go-ethereum工程/cmd/geth/main.go func init() { &nbsp;&nbsp; // Initialize the CLI app and start Geth &nbsp;&nbsp; app.Action = geth &nbsp;&nbsp; app.HideVersion = true // we have a commandto print the version &nbsp;&nbsp; app.Copyright = &quot;Copyright 2013-2018The go-ethereum Authors&quot; &nbsp;&nbsp; app.Commands = []cli.Command{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........................ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See accountcmd.go: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accountCommand,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从这里知道，与account命令相关的代码在accountCommand.go文件中 } 1.2. 打开 cms/geth/accountcmd.go Subcommands:[]cli.Command{ ................... { &nbsp;&nbsp; Name:&nbsp;&nbsp;&quot;new&quot;, &nbsp;&nbsp; Usage:&nbsp;&quot;Create a new account&quot;, &nbsp;&nbsp; Action: utils.MigrateFlags(accountCreate),&nbsp;&nbsp;&nbsp;&nbsp;//从这里可以知道 new 命令的执行函数在accountCreate函数中 &nbsp;&nbsp; Flags: []cli.Flag{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.DataDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.KeyStoreDirFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.PasswordFileFlag, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.LightKDFFlag, &nbsp;&nbsp; }, ................ 二、accountCreate函数执行流程 // accountcmd.go funcaccountCreate(ctx *cli.Context) error { &nbsp;&nbsp; …… 加载配置文件, 获取keydir，scryptN, scryptP &nbsp;&nbsp; //提示输入密码 &nbsp;&nbsp; password := getPassPhrase(&quot;Your newaccount is locked with a password. Please give a password. Do not forget thispassword.&quot;, true, 0, utils.MakePasswordList(ctx)) &nbsp;&nbsp; //这里创建地址，生成公钥和私钥 &nbsp;&nbsp; address, err := keystore.StoreKey(keydir,password, scryptN, scryptP) &nbsp;&nbsp; //打印地址 &nbsp;&nbsp; fmt.Printf(&quot;Address: {%x}\\n&quot;,address) &nbsp;&nbsp; return nil } ///////////////////////////////////////////////////////////////////////// //accounts/keystore/keystore_passphrase.go //具体表现为生成一对公私钥，再由私钥算出地址并构建一个自定义的Key // StoreKey generatesa key, encrypts with &#39;auth&#39; and stores in the given directoryfunc StoreKey(dir, auth string, scryptN, scryptPint) (common.Address, error) {&nbsp;&nbsp; _, a, err := storeNewKey(&amp;keyStorePassphrase{dir,scryptN, scryptP}, crand.Reader, auth)&nbsp;&nbsp; return a.Address,err} ///////////////////////////////////////////////////////////////////////////// //accounts/keystore/key.go func storeNewKey(ks keyStore, rand io.Reader, authstring) (*Key, accounts.Account, error) {&nbsp;&nbsp; key, err := newKey(rand)&nbsp;&nbsp;&nbsp; //生成密钥对&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, accounts.Account{},err&nbsp;&nbsp; }&nbsp;&nbsp; a := accounts.Account{Address:key.Address, URL: accounts.URL{Scheme: KeyStoreScheme, Path:ks.JoinPath(keyFileName(key.Address))}} &nbsp; //私钥被保存到磁盘，保存前使用密码加密，密钥文件存储在你的以太坊客户端keystore 子目录中&nbsp;&nbsp; if err :=ks.StoreKey(a.URL.Path, key, auth); err != nil {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroKey(key.PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,a, err&nbsp;&nbsp; }&nbsp;&nbsp; return key,a, err} ---------------------------------------------- func newKey(rand io.Reader) (*Key, error) { // ecdsa是椭圆曲线数字签名算法，这里使用ecdsa生成一对公私钥，并选择的是secp256k1曲线。&nbsp;&nbsp; privateKeyECDSA, err :=ecdsa.GenerateKey(crypto.S256(), rand)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; return newKeyFromECDSA(privateKeyECDSA),nil} --------------------------------------------------- // GenerateKeygenerates a public and private key pair.func GenerateKey(c elliptic.Curve, rand io.Reader)(*PrivateKey, error) {&nbsp;&nbsp; k, err := randFieldElement(c, rand)&nbsp;&nbsp; if err !=nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil,err&nbsp;&nbsp; }&nbsp;&nbsp; priv := new(PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成私钥&nbsp;&nbsp; priv.PublicKey.Curve = c&nbsp;&nbsp; priv.D = k&nbsp;&nbsp; priv.PublicKey.X, priv.PublicKey.Y =c.ScalarBaseMult(k.Bytes())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成公钥&nbsp;&nbsp; return priv,nil} --------------------------------------------------------------------------------------- func newKeyFromECDSA(privateKeyECDSA*ecdsa.PrivateKey) *Key {&nbsp;&nbsp; id := uuid.NewRandom()&nbsp;&nbsp; key := &amp;Key{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Address:&nbsp;&nbsp;&nbsp;crypto.PubkeyToAddress(privateKeyECDSA.PublicKey),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //地址是公钥转过来的，仅20字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrivateKey: privateKeyECDSA,&nbsp;&nbsp; }&nbsp;&nbsp; return key} ------------------------------------------------------------------------------------- func PubkeyToAddress(p ecdsa.PublicKey)common.Address {&nbsp;&nbsp; pubBytes := FromECDSAPub(&amp;p)&nbsp;&nbsp; return common.BytesToAddress(Keccak256(pubBytes[1:])[12:])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //公钥经过Keccak-256单向散列函数变成了256bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ------------------------------------------------------------------------------------- func BytesToAddress(b []byte) Address {&nbsp;&nbsp; var aAddress&nbsp;&nbsp; a.SetBytes(b)&nbsp;&nbsp; return a} -------------------------------------------------------------------------------------------- func (a *Address) SetBytes(b []byte) {&nbsp;&nbsp; if len(b)&gt; len(a) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = b[len(b)-AddressLength:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressLength等于20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; }&nbsp;&nbsp; copy(a[AddressLength-len(b):], b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取后20字节(160bit, 即40个16进制字符)作为地址} &nbsp; 三、总结 每个账户都由一对钥匙定义，一个私钥（PrivateKey）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里（Keystore）。 地址的生成的流程是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步： 1、&nbsp;由secp256k1曲线生成私钥，是由随机的256bit组成（32字节） 2、采用椭圆曲线数字签名算法（ECDSA）将私钥映射成公钥（64字节） 3、公钥经过Keccak-256单向散列函数变成了256bit，然后取160bit作为地址（20字节） 注意：私钥极其重要，用户输入的密码用来对私钥加密，加密后的密钥文件被保存到keystore目录下。密钥文件最好经常换密码，并以多种形式存放最为妥当。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/07/3fc8c2df27077ead183ea829a1d8f221.html","headline":"geth源码阅读——创建外部账号的流程","dateModified":"2018-06-07T00:00:00+08:00","datePublished":"2018-06-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/07/3fc8c2df27077ead183ea829a1d8f221.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>geth源码阅读——创建外部账号的流程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="color:#000000;">本文探究&nbsp;</span><span style="color:#000000;">geth account new&nbsp;</span><span style="color:#000000;">命令的代码执行流程</span></p>
  <p><span style="color:#0000FF;">一、寻找命令入口</span></p>
  <p><span style="color:#0000FF;">1.1. go-ethereum</span><span style="color:#0000FF;">工程/cmd/geth/main.go</span></p>
  <p><span style="color:#000000;">func init() {</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; // Initialize the CLI app and start Geth</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; app.Action = geth</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; app.HideVersion = true // we have a commandto print the version</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; app.Copyright = "Copyright 2013-2018The go-ethereum Authors"</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; app.Commands = []cli.Command{</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........................</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See accountcmd.go:</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accountCommand,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">从这里知道，与account</span>命令相关的代码在accountCommand.go文件中</p>
  <p><span style="color:#000000;">}</span></p>
  <p><span style="color:#0000FF;">1.2. </span><span style="color:#0000FF;">打开 cms/geth/accountcmd.go</span></p>
  <p><span style="color:#000000;">Subcommands:[]cli.Command{</span></p>
  <p><span style="color:#000000;">...................</span></p>
  <p><span style="color:#000000;">{</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; Name:&nbsp;&nbsp;"new",</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; Usage:&nbsp;"Create a new account",</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; Action: utils.MigrateFlags(accountCreate),&nbsp;&nbsp;&nbsp;</span><span style="color:#FF0000;">&nbsp;//</span><span style="color:#FF0000;">从这里可以知道 new </span>命令的执行函数在accountCreate函数中</p>
  <p><span style="color:#000000;">&nbsp;&nbsp; Flags: []cli.Flag{</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.DataDirFlag,</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.KeyStoreDirFlag,</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.PasswordFileFlag,</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils.LightKDFFlag,</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; },</span></p>
  <p><span style="color:#000000;">................</span></p>
  <p><span style="color:#0000FF;">二、accountCreate</span>函数执行流程</p>
  <p><span style="color:#000000;">//</span><span style="color:#0000FF;"> accountcmd.go</span></p>
  <p><strong><span style="color:#000080;">func</span><span style="color:#FF0000;">accountCreate</span></strong><span style="color:#000000;">(ctx *cli.Context) error {</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; …… </span><span style="color:#000000;">加载配置文件, </span>获取keydir，scryptN, scryptP</p>
  <p><span style="color:#FF0000;">&nbsp;&nbsp; //</span><span style="color:#FF0000;">提示输入密码</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; password := getPassPhrase("Your newaccount is locked with a password. Please give a password. Do not forget thispassword.", true, 0, utils.MakePasswordList(ctx))</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">这里创建地址，生成公钥和私钥</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; address, err := keystore.StoreKey(keydir,password, scryptN, scryptP)</span></p>
  <p><span style="color:#FF0000;">&nbsp;&nbsp; //</span><span style="color:#FF0000;">打印地址</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; fmt.Printf("Address: {%x}\n",address)</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp; return nil</span></p>
  <p><span style="color:#000000;">}</span></p>
  <p><span style="color:#000000;">/////////////////////////////////////////////////////////////////////////</span></p>
  <p><span style="color:#000000;">//accounts/keystore/keystore_passphrase.go</span></p>
  <p><span style="color:#000000;">//</span><span style="color:#FF0000;">具体表现为生成一对公私钥，再由私钥算出地址并构建一个自定义的Ke</span><span style="color:#000000;">y</span></p>
  <p align="left" style="background:#FFFFFF;"><em><span style="color:#808080;">// StoreKey generatesa key, encrypts with 'auth' and stores in the given directory<br></span></em><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">StoreKey(dir, auth string, scryptN, scryptPint) (common.Address, error) {<br>&nbsp;&nbsp; _, a, err := </span><span style="color:#FF0000;">storeNewKey</span><span style="color:#000000;">(&amp;keyStorePassphrase{dir,scryptN, scryptP}, crand.Reader, auth)<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">a.Address,err<br>}</span></p>
  <p><span style="color:#000000;">/////////////////////////////////////////////////////////////////////////////</span></p>
  <p><span style="color:#000000;">//accounts/keystore/key.go</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">storeNewKey(ks keyStore, rand io.Reader, </span><span style="color:#FF0000;">auth</span><span style="color:#000000;">string) (*Key, accounts.Account, error) {<br>&nbsp;&nbsp; key, err := </span><span style="color:#FF0000;">newKey</span><span style="color:#000000;">(rand)&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">生成密钥对</span><span style="color:#000000;">&nbsp;&nbsp; <br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">if </span></strong><span style="color:#000000;">err !=nil {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">nil, accounts.Account{},err<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; a := accounts.Account{Address:key.Address, URL: accounts.URL{Scheme: KeyStoreScheme, Path:ks.JoinPath(keyFileName(key.Address))}}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">&nbsp;</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#0000FF;">//</span><span style="color:#0000FF;">私钥被保存到磁盘，保存前使用密码加密，密钥文件存储在你的以太坊客户端keystore </span>子目录中<span style="color:#000000;"><br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">if </span></strong><span style="color:#000000;">err :=</span><span style="color:#FF0000;">ks.StoreKey(a.URL.Path, key, auth)</span><span style="color:#000000;">; err != nil {&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zeroKey(key.PrivateKey)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">nil,a, err<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">key,a, err<br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">----------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">newKey(rand io.Reader) (*Key, error) {</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#FF0000;">// ecdsa</span><span style="color:#FF0000;">是</span><span style="color:#FF0000;">椭圆曲线数字签名算法，这里使用</span><span style="color:#FF0000;">ecdsa</span><span style="color:#FF0000;">生成一对公私钥，并选择的是</span><span style="color:#FF0000;">secp256k1</span><span style="color:#FF0000;">曲线。</span><span style="color:#000000;"><br>&nbsp;&nbsp; privateKeyECDSA, err :=ecdsa.GenerateKey(crypto.S256(), rand)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">if </span></strong><span style="color:#000000;">err !=nil {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">nil,err<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">newKeyFromECDSA(privateKeyECDSA),nil<br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">---------------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><em><span style="color:#808080;">// GenerateKeygenerates a public and private key pair.<br></span></em><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">GenerateKey(c elliptic.Curve, rand io.Reader)(*PrivateKey, error) {<br>&nbsp;&nbsp; k, err := randFieldElement(c, rand)<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">if </span></strong><span style="color:#000000;">err !=nil {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">nil,err<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; priv := new(PrivateKey)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">生成私钥<br></span><span style="color:#000000;">&nbsp;&nbsp; priv.PublicKey.Curve = c<br>&nbsp;&nbsp; priv.D = k<br>&nbsp;&nbsp; priv.PublicKey.X, priv.PublicKey.Y =c.ScalarBaseMult(k.Bytes())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">生成公钥</span><span style="color:#000000;"><br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">priv,nil<br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">---------------------------------------------------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">newKeyFromECDSA(privateKeyECDSA*ecdsa.PrivateKey) *Key {<br>&nbsp;&nbsp; id := uuid.NewRandom()<br>&nbsp;&nbsp; key := &amp;Key{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Address:&nbsp;&nbsp;&nbsp;crypto.PubkeyToAddress(privateKeyECDSA.PublicKey),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">地址是公钥转过来的，仅20</span>字节<span style="color:#000000;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrivateKey: privateKeyECDSA,<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">key<br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">-------------------------------------------------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">PubkeyToAddress(p ecdsa.PublicKey)common.Address {<br>&nbsp;&nbsp; pubBytes := FromECDSAPub(&amp;p)<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">common.BytesToAddress(Keccak256(pubBytes[</span><span style="color:#0000FF;">1</span><span style="color:#000000;">:])[</span><span style="color:#0000FF;">12</span><span style="color:#000000;">:])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">公钥经过Keccak-256</span>单向散列函数变成了256bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">-------------------------------------------------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">BytesToAddress(b []byte) Address {<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">var </span></strong><span style="color:#000000;">aAddress<br>&nbsp;&nbsp; a.SetBytes(b)<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">return </span></strong><span style="color:#000000;">a<br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">--------------------------------------------------------------------------------------------</span></p>
  <p align="left" style="background:#FFFFFF;"><strong><span style="color:#000080;">func </span></strong><span style="color:#000000;">(a *Address) SetBytes(b []byte) {<br>&nbsp;&nbsp; </span><strong><span style="color:#000080;">if </span></strong><span style="color:#000000;">len(b)&gt; len(a) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = b[len(b)-</span><strong><em><span style="color:#660E7A;">AddressLength</span></em></strong><span style="color:#000000;">:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#FF0000;">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressLength</span><span style="color:#FF0000;">等于20</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; copy(a[</span><strong><em><span style="color:#660E7A;">AddressLength</span></em></strong><span style="color:#000000;">-len(b):], b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#FF0000;">//</span><span style="color:#FF0000;">取后20</span>字节(160bit, 即40个16进制字符)作为地址<span style="color:#000000;"><br>}</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">&nbsp;</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">三、总结</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">每个账户都由一对钥匙定义，一个私钥（PrivateKey</span>）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里（Keystore）。</p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">地址的生成的流程是：私钥 -&gt; </span>公钥 -&gt; 地址。因此地址的生成需要三步：</p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;"></span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、&nbsp;</span>由secp256k1曲线生成私钥，是由随机的256bit组成（32字节）</p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、采用椭圆曲线数字签名算法（ECDSA</span>）将私钥映射成公钥（64字节）</p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">3</span><span style="color:#000000;">、公钥经过Keccak-256</span>单向散列函数变成了256bit，然后取160bit作为地址（20字节）</p>
  <p align="left" style="background:#FFFFFF;"><br></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">注意：私钥极其重要，用户输入的密码用来对私钥加密，加密后的密钥文件被保存到keystore</span>目录下。密钥文件最好经常换密码，并以多种形式存放最为妥当。</p>
  <p align="left" style="background:#FFFFFF;"></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">&nbsp;</span></p>
  <p><span style="color:#000000;">&nbsp;</span></p>
  <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">&nbsp;</span></p>
  <p><span style="color:#000000;">&nbsp;</span></p>
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36391986/article/details/80609764,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36391986/article/details/80609764,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
