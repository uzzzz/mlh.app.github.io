<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊教程：入门学习开发以太坊dapp | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊教程：入门学习开发以太坊dapp" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、区块链 1. 分布式去中心化 比特币设计的初衷就是要避免依赖中心化的机构，没有发行机构，也不可能操纵发行数量。既然没有中心化的信用机构，在电子货币运行的过程中，也势必需要一种机制来认可运行在区块链上的行为(包括比特币的运营，亦或是运行在区块链上的其他业务)，这种机制就是共识机制。在完全去中心化的区块链上运行的比特币，采用的是PoW(Proof of Work，工作量证明)，该机制完美的解决了拜占庭将军问题（存在异常的情况下仍能达成一致）。因为基础网络架构为分布式，对单独一个节点是无法控制或破坏整个网络，掌握网内51%的运算能力(非节点数)才有可能操作交易，而这个代价大概要超过270亿美元。 2. 无须信任 整个区块链网络中的数据是公开透明的，每个节点(参与者)都可自由加入该网络中，下载到所有的数据。任意两个节点间的数据交换无需互相信任，完全依靠区块链中的交易历史和数据的可追溯，以及共识机制来保证数据交换的正确且不可逆的执行。 3. 不可篡改和加密安全性 跟当前银行网银系统(特别是公司网银系统)的加密机制类似，区块链的数据结构和交易流程中大量的使用了公私钥来加解密，保证数据的安全性。基于该技术基础，甚至可以应用群组签名来保证共有数据的安全性。任何事物既然有优点，也同时会存在不足之处。根源于分布式网络架构和共识机制，在区块链上运行的交易确认时间会比较长(比特币的确认时间大概是15分钟)，交易并发数受限(比特币的每秒交易数为7笔，而淘宝的每秒并发数能达到10万左右)，区块的容量限制(当前为1M，区块链的扩容一直在讨论中)，监管难以介入，基于工作量证明的共识机制存在浪费系统资源和带宽的问题。 4. 区块链技术 a. 区块 区块是一个包含在区块链(公开账簿)里的聚合了交易信息的容器。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。 区块结构如下图 交易(Tx)详情中的结构如下图 b. 区块链 当一个节点从网络接受到传入的区块时，它会验证这些区块，然后链接到现有的区块链上，链接的形态如下图： 由于每个区块包含前一个区块的HASH值，这就使得从创世块到当前块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后，因为如果不知道前一块区块的HASH值就没法生成当前区块。要改变一个已经在块链中存在一段时间的区块，从计算上来说是不可行的，因为如果它被改变，它之后的每个区块必须随之改变。这些特性使得双花比特币非常困难，区块链是比特币的最大创新。 5. 比特币钱包 a. 比特币钱包的生成 首先使用随机数发生器生成一个 私钥 。一般来说这是一个256bits的数，拥有了这串数字就可以对相应 钱包地址 中的比特币进行操作，所以必须被安全地保存起来。 私钥经过SECP256K1算法处理生成了公钥。SECP256K1是一种椭圆曲线算法，通过一个已知私钥时可以算得公钥，而公钥已知时却无法反向计算出私钥。这是保障比特币安全的算法基础。 同SHA256一样，RIPEMD160也是一种Hash算法，由公钥可以计算得到公钥哈希，而反过来是行不通的。 将一个字节的地址版本号连接到公钥哈希头部（对于比特币网络的pubkey地址，这一字节为“0”），然后对其进行两次SHA256运算，将结果的前4字节作为公钥哈希的校验值，连接在其尾部。 将上一步结果使用BASE58进行编码(比特币定制版本)，就得到了钱包地址。 流程图如下 b .转账 比特币钱包间的转账是通过交易（Transaction）实现的。交易数据是由转出钱包私钥的所有者生成，也就是说有了私钥就可以花费该钱包的比特币余额。生成交易的过程如下： 交易的原始数据包括“转账数额”和“转入钱包地址”，但是仅有这些是不够的，因为无法证明交易的生成者对“转出钱包地址”余额有动用的权利。所以需要用私钥对原始数据进行签名。 生成“转出钱包公钥”，这一过程与生成钱包地址的第2步是一样的。 将“转出签名”和“转出公钥”添加到原始交易数据中，生成了正式的交易数据，这样它就可以被广播到比特币网络进行转账了。 二、以太坊Ethereum 1. 概念 a. 什么是以太坊 简单来说，以太坊是一种新的法律形式。现行法律的本质是一种合约。它是由（生活于某一社群的）人和他们的领导者之间所缔结的，一种关于彼此该如何行动的共识。个体之间也存在着一些合约，这些合约可以理解为一种私法，相应的，这种私法仅对合约的参与者生效。 例如，你和一个人订立合约，借给他一笔钱，但他最后毁约了，不打算还这笔钱。此时你多半会将对方告上法庭。在现实生活中，打官司这种事情常常混乱不堪并且充满了不确定性。将对方告上法庭，也通常意味着你需要支付高昂的费用聘请律师，来帮你在法庭上针对法律条文展开辩论，而且这一过程一般都旷日持久。而且，即使你最终赢了官司，你依然可能会遇到问题（比如，对方拒不执行法庭判决）。 令人欣慰的是，当初你和借款人把条款写了下来，订立了合约。但法律的制定者和合约的起草者们都必须面对一个不容忽视的挑战：那就是，理想情况下，法律或者合约的内容应该是明确而没有歧义的，但现行的法律和合约都是由语句构成的，而语句，则是出了名的充满歧义。 因此，一直以来，现行的法律体系都存在着两个巨大的问题：首先，合约或法律是由充满歧义的语句定义的，第二，强制执行合约或法律的代价非常大。 而以太坊，通过数字货币和编程语言的结合，解决了现行法律体系的这两大问题。 以太坊系统自身带有一种叫做以太币（Ether）的数字货币。以太币和著名的数字货币比特币（Bitcoin）有着非常多的相似之处。两者均为数字储值货币，且无法伪造，都以去中心化的方式运行来保证货币供应不被某一方所控制。两者都可以像电子邮件一样，作为货币自由地在全世界流通。而且，由于它们可以做到传统货币做不到的事情，因此用户对它们未来的价值充满期待 。 另外： 1.详情请阅读以太坊白皮书 （中文， 英文）。 2.以太坊教程 b. 基本知识 公钥加密系统。 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的0xdf…5f地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。 点对点网络。 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。 区块链。 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。 以太坊虚拟机(EVM)。 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。 节点。 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。 矿工。 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：stats.ethdev.com。 工作量证明。 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。) 以太币。 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的走势图。在写这篇文章的时候，1个以太币价值65美分。 Gas. 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。 DApp. 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。这里分享一个以太坊DApp教程，可以高效的学习如何开发一个DApp，很适合入门。 2. 工作流程 a. 环境搭建 建议使用Mac OS环境，不然可能会出现各种坑。 安装NodeJS，安装Python。 安装testrpc（测试环境中使用），安装go-ethereum（真实环境中使用）。 安装solc。 安装truffle。 如果是windows的话建议用工具ethbox可以一键安装以太坊开发环境的工具： ethbox b. Solidity语言简介 下面是官网上面的一段关于智能投票合约的示例代码 contract Ballot { //一个选民的构造体 struct Voter { uint weight; // 权重（即他可以投几票） bool voted; //是否已经投过票 address delegate; // 代表地址（他可以代表某个人进行投票） uint vote; // index of the voted proposal } // 投票的提案的构造体 struct Proposal { bytes32 name; // 提案名称 uint voteCount; //获得的票数 } address public chairperson;//会议主席 //地址 -选民 的map mapping(address =&gt; Voter) public voters; // 投票种类的动态数组 Proposal[] public proposals; ///构造函数 function Ballot(bytes32[] proposalNames) { chairperson = msg.sender;//初始化会议主席 voters[chairperson].weight = 1; //初始化所有的提案 for (uint i = 0; i &lt; proposalNames.length; i++) { proposals.push(Proposal({ name: proposalNames[i], voteCount: 0 })); } } // 给予投票权 function giveRightToVote(address voter) returns (bool b) { if (msg.sender != chairperson || voters[voter].voted) { //对于会议主席和已经投过票的选民这里不处理 return false;; } voters[voter].weight = 1; return true; } /// 投票权转移函数 function delegate(address to) { // 投票权转移的发起人 Voter sender = voters[msg.sender]; if (sender.voted) throw; //递归找到没有转移投票权的 选民 while ( voters[to].delegate != address(0) &amp;&amp; voters[to].delegate != msg.sender ) { to = voters[to].delegate; } if (to == msg.sender) { throw; } //将发起人设置为已经投过票的状态 sender.voted = true; //将代表设置为刚才递归获取的选民 sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) { //如果代表已经投过票就在他投票的提案的票数增加 proposals[delegate.vote].voteCount += sender.weight; } else { //将代表的的票数增加 delegate.weight += sender.weight; } } /// 投票函数 function vote(uint proposal) { Voter sender = voters[msg.sender]; if (sender.voted) throw; sender.voted = true; sender.vote = proposal; //将投的提案票数增加 proposals[proposal].voteCount += sender.weight; } ///获得票数最多的提案 function winningProposal() constant returns (uint winningProposal) { uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) { if (proposals[p].voteCount &gt; winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal = p; } } } } 解读 address. 地址类型。chairperson是会议主席的钱包地址。这个地址会在合约的构造函数function Ballot()中被赋值。很多时候也称呼这种地址为’owner’（所有人）。 public. 这个关键字表明变量可以被合约之外的对象使用。private修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为public。 Mapping或数组。mapping(address =&gt; Voter)为选民钱包地址和选民构造体的键值对。Proposal[] public proposals是一个提案构造体的数组。 有特殊的变量和函数总是在全局命名空间存在，主要用于提供有关blockchain信息，例如msg，block，tx，其中msg.sender为发起人的地址。 solidity语言更深入的理解可以阅读官方文档。 c. 使用geth部署合约 启动一个测试节点 geth –testnet –fast –cache=512 –genesis CustomGenesis.json console 这里的CustomGenesis.json是为了给测试的账户分配以太币 { &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x20000&quot;, &quot;extraData&quot;: &quot;&quot;, &quot;gasLimit&quot;: &quot;0x2fefd8&quot;, &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;alloc&quot;: { &quot;0xe49c283bc6bf92c5833cc981b97679238dd3b5da&quot;: { &quot;balance&quot;: &quot;111111111000000000000000000000000000&quot; }, &quot;0xd8927c296b3ebe454a6409770a0c323ec4ed23ba&quot;: { &quot;balance&quot;: &quot;222222222000000000000000000000000000&quot; } } } solc下的内容要替换成你的测试账户地址。具体geth的用法请查看官方文档和源码介绍。 使用solc编译智能合约，获得二进制代码 例如以下代码 contract test { function multiply(uint a) returns(uint d) { return a * 7; } } 在geth中输入 source = “contract test { function multiply(uint a) returns(uint d) { return a * 7; } }” clientContract = eth.compile.solidity(source).test 编译返回的结果的JSON格式如下 其中， code：编译后的EVM字节码 info：编译器返回的metadata abiDefination:Application Binary Interface定义。具体接口规则参见这里 compilerVersion：编译此代码的solidity编译器版本 developerDoc：针对开发者的Natural Specification Format，类似于Doxygen language：合约语言 languageVersion：合约语言版本 source：源代码 userDoc：针对用户的Ethereum的Natural Specification Format。 编译器返回的JSON结构反映了合约部署的两种不同的路径。info信息真实的存在于区中心化的云中，作为metadata信息来公开验证Blockchain中合约代码的实现。而code信息通过创建交易的方式部署到区块链中。 使用solc编译智能合约，获得二进制代码 部署合约前，确保你有一个解锁的账户并且账户中有余额，因为部署合约得过程中会消耗以太币。输入web3.fromWei(eth.getBalance(eth.accounts[0]),”ether”)可以查看账户余额。 解锁一个账户 personal.unlockAccount(eth.accounts[0]) 获得账户 primaryAddress = eth.accounts[0] 定义一个abi （abi是个js的数组，否则不成功） abi = [{ constant: false, inputs: [{ name: ‘a’, type: ‘uint256’ } ]}] 创建智能合约 MyContract = eth.contract(abi) 发送交易部署合约 contract = MyContract.new({from: primaryAddress, data:”0x6060604052602a8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b6007600435026060908152602090f3”}) 如果交易被pending，如图说明你的miner没有在挖矿 启动一个矿工 miner.setEtherbase(eth.primaryAddress) //设定开采账户 miner.start(8) eth.getBlock(“pending”, true).transactions 这时候发现交易已经在区块中 不过会发现，交易还是pending，这是因为该交易区块没有人协助进行运算验证，这时候只需要再启动一个矿工就行了 miner.start(8) 与合约进行交互 Multiply7 = eth.contract(clientContract.info.abiDefinition); var myMultiply7 = Multiply7.at(contract.address); myMultiply7.multiply.call(3) 或 myMultiply7.multiply.sendTransaction(3, {from: contract.address}) d. 使用truffle框架 使用truffle部署智能合约的步骤： truffle init (在新目录中) =&gt; 创建truffle项目目录结构， 编写合约代码，保存到contracts/YourContractName.sol文件。 例如Ballot .sol，此时要找到migrations文件夹，在deploy_contracts.js文件中添加deployer.deploy(Ballot); truffile compile 编译合约代码。 启动以太坊节点（例如在另一个终端里面运行testrpc）。 truffle migrate（在truffle项目目录中)。 1. 编写单元测试 在test文件夹中新建ballot.js文件 contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var meta = Ballot.deployed(); return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); } 在项目根目录下运行truffle test，你应该看到测试通过，如果使用自己构造的ballot对象，可以这样写： contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var proposals = []; proposals.push(&quot;proposal0&quot;); Ballot.new(proposals).then(function(meta){ return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); }); } 合约中发送以太币。 this是合约实例的地址，以变接下来检查这个地址的余额（或者直接使用this.balance） 当你通过web3.js调用交易函数时（使用web3.eth.sendTransaction），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。 Gas. （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在{ from: , value: , gas: _ } 对象内设置Gas参数。Web3.js提供了web3.eth.gasPrice调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：solc –gas YouContract.sol. 2. 为合约创建一个界面 在app目录中，可以编写自己的html和js文件，js与智能合约的交互与单元测试基本一致，例如一个界面上有一个输入框和一个按钮，获得选民的投票权。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Ballot App&lt;/title&gt; &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans:400,700&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;link href=&quot;./app.css&quot; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ballot&lt;/h1&gt; &lt;h2&gt;Example Truffle Dapp&lt;/h2&gt; &lt;br&gt; &lt;h1&gt;Send&lt;/h1&gt; &lt;br&gt;&lt;label for=&quot;amount&quot;&gt;Account:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;account&quot; placeholder=&quot;e.g., 0x453468394hdfg84858345348&quot;&gt;&lt;/input&gt; &lt;br&gt;&lt;br&gt;&lt;button id=&quot;getRightVote&quot; onclick=&quot;getRight()&quot;&gt;Get Right Vote&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;span id=&quot;status&quot;&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; app.js中的代码为 function getRight() { var account = document.getElementById(&quot;account&quot;).value; var meta = Ballot.deployed(); meta.giveRightToVote(account).then(function(b){ if(Boolean(b)){ setStatus(&quot;Get Right Vote Success&quot;); }else{ setStatus(&quot;Get Right Vote Error&quot;); } }).catch(function(e){ setStatus(&quot;Get Right Vote Error&quot;); console.log(e); }); }; 另外分享几个教程给大家： python以太坊，主要是针对python围绕web3.py进行区块链以太坊应用开发的讲解。 web3j，主要是针对java和android程序员围绕web3j库进行区块链以太坊开发的讲解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 阅读更多" />
<meta property="og:description" content="一、区块链 1. 分布式去中心化 比特币设计的初衷就是要避免依赖中心化的机构，没有发行机构，也不可能操纵发行数量。既然没有中心化的信用机构，在电子货币运行的过程中，也势必需要一种机制来认可运行在区块链上的行为(包括比特币的运营，亦或是运行在区块链上的其他业务)，这种机制就是共识机制。在完全去中心化的区块链上运行的比特币，采用的是PoW(Proof of Work，工作量证明)，该机制完美的解决了拜占庭将军问题（存在异常的情况下仍能达成一致）。因为基础网络架构为分布式，对单独一个节点是无法控制或破坏整个网络，掌握网内51%的运算能力(非节点数)才有可能操作交易，而这个代价大概要超过270亿美元。 2. 无须信任 整个区块链网络中的数据是公开透明的，每个节点(参与者)都可自由加入该网络中，下载到所有的数据。任意两个节点间的数据交换无需互相信任，完全依靠区块链中的交易历史和数据的可追溯，以及共识机制来保证数据交换的正确且不可逆的执行。 3. 不可篡改和加密安全性 跟当前银行网银系统(特别是公司网银系统)的加密机制类似，区块链的数据结构和交易流程中大量的使用了公私钥来加解密，保证数据的安全性。基于该技术基础，甚至可以应用群组签名来保证共有数据的安全性。任何事物既然有优点，也同时会存在不足之处。根源于分布式网络架构和共识机制，在区块链上运行的交易确认时间会比较长(比特币的确认时间大概是15分钟)，交易并发数受限(比特币的每秒交易数为7笔，而淘宝的每秒并发数能达到10万左右)，区块的容量限制(当前为1M，区块链的扩容一直在讨论中)，监管难以介入，基于工作量证明的共识机制存在浪费系统资源和带宽的问题。 4. 区块链技术 a. 区块 区块是一个包含在区块链(公开账簿)里的聚合了交易信息的容器。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。 区块结构如下图 交易(Tx)详情中的结构如下图 b. 区块链 当一个节点从网络接受到传入的区块时，它会验证这些区块，然后链接到现有的区块链上，链接的形态如下图： 由于每个区块包含前一个区块的HASH值，这就使得从创世块到当前块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后，因为如果不知道前一块区块的HASH值就没法生成当前区块。要改变一个已经在块链中存在一段时间的区块，从计算上来说是不可行的，因为如果它被改变，它之后的每个区块必须随之改变。这些特性使得双花比特币非常困难，区块链是比特币的最大创新。 5. 比特币钱包 a. 比特币钱包的生成 首先使用随机数发生器生成一个 私钥 。一般来说这是一个256bits的数，拥有了这串数字就可以对相应 钱包地址 中的比特币进行操作，所以必须被安全地保存起来。 私钥经过SECP256K1算法处理生成了公钥。SECP256K1是一种椭圆曲线算法，通过一个已知私钥时可以算得公钥，而公钥已知时却无法反向计算出私钥。这是保障比特币安全的算法基础。 同SHA256一样，RIPEMD160也是一种Hash算法，由公钥可以计算得到公钥哈希，而反过来是行不通的。 将一个字节的地址版本号连接到公钥哈希头部（对于比特币网络的pubkey地址，这一字节为“0”），然后对其进行两次SHA256运算，将结果的前4字节作为公钥哈希的校验值，连接在其尾部。 将上一步结果使用BASE58进行编码(比特币定制版本)，就得到了钱包地址。 流程图如下 b .转账 比特币钱包间的转账是通过交易（Transaction）实现的。交易数据是由转出钱包私钥的所有者生成，也就是说有了私钥就可以花费该钱包的比特币余额。生成交易的过程如下： 交易的原始数据包括“转账数额”和“转入钱包地址”，但是仅有这些是不够的，因为无法证明交易的生成者对“转出钱包地址”余额有动用的权利。所以需要用私钥对原始数据进行签名。 生成“转出钱包公钥”，这一过程与生成钱包地址的第2步是一样的。 将“转出签名”和“转出公钥”添加到原始交易数据中，生成了正式的交易数据，这样它就可以被广播到比特币网络进行转账了。 二、以太坊Ethereum 1. 概念 a. 什么是以太坊 简单来说，以太坊是一种新的法律形式。现行法律的本质是一种合约。它是由（生活于某一社群的）人和他们的领导者之间所缔结的，一种关于彼此该如何行动的共识。个体之间也存在着一些合约，这些合约可以理解为一种私法，相应的，这种私法仅对合约的参与者生效。 例如，你和一个人订立合约，借给他一笔钱，但他最后毁约了，不打算还这笔钱。此时你多半会将对方告上法庭。在现实生活中，打官司这种事情常常混乱不堪并且充满了不确定性。将对方告上法庭，也通常意味着你需要支付高昂的费用聘请律师，来帮你在法庭上针对法律条文展开辩论，而且这一过程一般都旷日持久。而且，即使你最终赢了官司，你依然可能会遇到问题（比如，对方拒不执行法庭判决）。 令人欣慰的是，当初你和借款人把条款写了下来，订立了合约。但法律的制定者和合约的起草者们都必须面对一个不容忽视的挑战：那就是，理想情况下，法律或者合约的内容应该是明确而没有歧义的，但现行的法律和合约都是由语句构成的，而语句，则是出了名的充满歧义。 因此，一直以来，现行的法律体系都存在着两个巨大的问题：首先，合约或法律是由充满歧义的语句定义的，第二，强制执行合约或法律的代价非常大。 而以太坊，通过数字货币和编程语言的结合，解决了现行法律体系的这两大问题。 以太坊系统自身带有一种叫做以太币（Ether）的数字货币。以太币和著名的数字货币比特币（Bitcoin）有着非常多的相似之处。两者均为数字储值货币，且无法伪造，都以去中心化的方式运行来保证货币供应不被某一方所控制。两者都可以像电子邮件一样，作为货币自由地在全世界流通。而且，由于它们可以做到传统货币做不到的事情，因此用户对它们未来的价值充满期待 。 另外： 1.详情请阅读以太坊白皮书 （中文， 英文）。 2.以太坊教程 b. 基本知识 公钥加密系统。 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的0xdf…5f地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。 点对点网络。 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。 区块链。 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。 以太坊虚拟机(EVM)。 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。 节点。 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。 矿工。 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：stats.ethdev.com。 工作量证明。 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。) 以太币。 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的走势图。在写这篇文章的时候，1个以太币价值65美分。 Gas. 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。 DApp. 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。这里分享一个以太坊DApp教程，可以高效的学习如何开发一个DApp，很适合入门。 2. 工作流程 a. 环境搭建 建议使用Mac OS环境，不然可能会出现各种坑。 安装NodeJS，安装Python。 安装testrpc（测试环境中使用），安装go-ethereum（真实环境中使用）。 安装solc。 安装truffle。 如果是windows的话建议用工具ethbox可以一键安装以太坊开发环境的工具： ethbox b. Solidity语言简介 下面是官网上面的一段关于智能投票合约的示例代码 contract Ballot { //一个选民的构造体 struct Voter { uint weight; // 权重（即他可以投几票） bool voted; //是否已经投过票 address delegate; // 代表地址（他可以代表某个人进行投票） uint vote; // index of the voted proposal } // 投票的提案的构造体 struct Proposal { bytes32 name; // 提案名称 uint voteCount; //获得的票数 } address public chairperson;//会议主席 //地址 -选民 的map mapping(address =&gt; Voter) public voters; // 投票种类的动态数组 Proposal[] public proposals; ///构造函数 function Ballot(bytes32[] proposalNames) { chairperson = msg.sender;//初始化会议主席 voters[chairperson].weight = 1; //初始化所有的提案 for (uint i = 0; i &lt; proposalNames.length; i++) { proposals.push(Proposal({ name: proposalNames[i], voteCount: 0 })); } } // 给予投票权 function giveRightToVote(address voter) returns (bool b) { if (msg.sender != chairperson || voters[voter].voted) { //对于会议主席和已经投过票的选民这里不处理 return false;; } voters[voter].weight = 1; return true; } /// 投票权转移函数 function delegate(address to) { // 投票权转移的发起人 Voter sender = voters[msg.sender]; if (sender.voted) throw; //递归找到没有转移投票权的 选民 while ( voters[to].delegate != address(0) &amp;&amp; voters[to].delegate != msg.sender ) { to = voters[to].delegate; } if (to == msg.sender) { throw; } //将发起人设置为已经投过票的状态 sender.voted = true; //将代表设置为刚才递归获取的选民 sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) { //如果代表已经投过票就在他投票的提案的票数增加 proposals[delegate.vote].voteCount += sender.weight; } else { //将代表的的票数增加 delegate.weight += sender.weight; } } /// 投票函数 function vote(uint proposal) { Voter sender = voters[msg.sender]; if (sender.voted) throw; sender.voted = true; sender.vote = proposal; //将投的提案票数增加 proposals[proposal].voteCount += sender.weight; } ///获得票数最多的提案 function winningProposal() constant returns (uint winningProposal) { uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) { if (proposals[p].voteCount &gt; winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal = p; } } } } 解读 address. 地址类型。chairperson是会议主席的钱包地址。这个地址会在合约的构造函数function Ballot()中被赋值。很多时候也称呼这种地址为’owner’（所有人）。 public. 这个关键字表明变量可以被合约之外的对象使用。private修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为public。 Mapping或数组。mapping(address =&gt; Voter)为选民钱包地址和选民构造体的键值对。Proposal[] public proposals是一个提案构造体的数组。 有特殊的变量和函数总是在全局命名空间存在，主要用于提供有关blockchain信息，例如msg，block，tx，其中msg.sender为发起人的地址。 solidity语言更深入的理解可以阅读官方文档。 c. 使用geth部署合约 启动一个测试节点 geth –testnet –fast –cache=512 –genesis CustomGenesis.json console 这里的CustomGenesis.json是为了给测试的账户分配以太币 { &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x20000&quot;, &quot;extraData&quot;: &quot;&quot;, &quot;gasLimit&quot;: &quot;0x2fefd8&quot;, &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;alloc&quot;: { &quot;0xe49c283bc6bf92c5833cc981b97679238dd3b5da&quot;: { &quot;balance&quot;: &quot;111111111000000000000000000000000000&quot; }, &quot;0xd8927c296b3ebe454a6409770a0c323ec4ed23ba&quot;: { &quot;balance&quot;: &quot;222222222000000000000000000000000000&quot; } } } solc下的内容要替换成你的测试账户地址。具体geth的用法请查看官方文档和源码介绍。 使用solc编译智能合约，获得二进制代码 例如以下代码 contract test { function multiply(uint a) returns(uint d) { return a * 7; } } 在geth中输入 source = “contract test { function multiply(uint a) returns(uint d) { return a * 7; } }” clientContract = eth.compile.solidity(source).test 编译返回的结果的JSON格式如下 其中， code：编译后的EVM字节码 info：编译器返回的metadata abiDefination:Application Binary Interface定义。具体接口规则参见这里 compilerVersion：编译此代码的solidity编译器版本 developerDoc：针对开发者的Natural Specification Format，类似于Doxygen language：合约语言 languageVersion：合约语言版本 source：源代码 userDoc：针对用户的Ethereum的Natural Specification Format。 编译器返回的JSON结构反映了合约部署的两种不同的路径。info信息真实的存在于区中心化的云中，作为metadata信息来公开验证Blockchain中合约代码的实现。而code信息通过创建交易的方式部署到区块链中。 使用solc编译智能合约，获得二进制代码 部署合约前，确保你有一个解锁的账户并且账户中有余额，因为部署合约得过程中会消耗以太币。输入web3.fromWei(eth.getBalance(eth.accounts[0]),”ether”)可以查看账户余额。 解锁一个账户 personal.unlockAccount(eth.accounts[0]) 获得账户 primaryAddress = eth.accounts[0] 定义一个abi （abi是个js的数组，否则不成功） abi = [{ constant: false, inputs: [{ name: ‘a’, type: ‘uint256’ } ]}] 创建智能合约 MyContract = eth.contract(abi) 发送交易部署合约 contract = MyContract.new({from: primaryAddress, data:”0x6060604052602a8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b6007600435026060908152602090f3”}) 如果交易被pending，如图说明你的miner没有在挖矿 启动一个矿工 miner.setEtherbase(eth.primaryAddress) //设定开采账户 miner.start(8) eth.getBlock(“pending”, true).transactions 这时候发现交易已经在区块中 不过会发现，交易还是pending，这是因为该交易区块没有人协助进行运算验证，这时候只需要再启动一个矿工就行了 miner.start(8) 与合约进行交互 Multiply7 = eth.contract(clientContract.info.abiDefinition); var myMultiply7 = Multiply7.at(contract.address); myMultiply7.multiply.call(3) 或 myMultiply7.multiply.sendTransaction(3, {from: contract.address}) d. 使用truffle框架 使用truffle部署智能合约的步骤： truffle init (在新目录中) =&gt; 创建truffle项目目录结构， 编写合约代码，保存到contracts/YourContractName.sol文件。 例如Ballot .sol，此时要找到migrations文件夹，在deploy_contracts.js文件中添加deployer.deploy(Ballot); truffile compile 编译合约代码。 启动以太坊节点（例如在另一个终端里面运行testrpc）。 truffle migrate（在truffle项目目录中)。 1. 编写单元测试 在test文件夹中新建ballot.js文件 contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var meta = Ballot.deployed(); return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); } 在项目根目录下运行truffle test，你应该看到测试通过，如果使用自己构造的ballot对象，可以这样写： contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var proposals = []; proposals.push(&quot;proposal0&quot;); Ballot.new(proposals).then(function(meta){ return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); }); } 合约中发送以太币。 this是合约实例的地址，以变接下来检查这个地址的余额（或者直接使用this.balance） 当你通过web3.js调用交易函数时（使用web3.eth.sendTransaction），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。 Gas. （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在{ from: , value: , gas: _ } 对象内设置Gas参数。Web3.js提供了web3.eth.gasPrice调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：solc –gas YouContract.sol. 2. 为合约创建一个界面 在app目录中，可以编写自己的html和js文件，js与智能合约的交互与单元测试基本一致，例如一个界面上有一个输入框和一个按钮，获得选民的投票权。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Ballot App&lt;/title&gt; &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans:400,700&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;link href=&quot;./app.css&quot; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ballot&lt;/h1&gt; &lt;h2&gt;Example Truffle Dapp&lt;/h2&gt; &lt;br&gt; &lt;h1&gt;Send&lt;/h1&gt; &lt;br&gt;&lt;label for=&quot;amount&quot;&gt;Account:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;account&quot; placeholder=&quot;e.g., 0x453468394hdfg84858345348&quot;&gt;&lt;/input&gt; &lt;br&gt;&lt;br&gt;&lt;button id=&quot;getRightVote&quot; onclick=&quot;getRight()&quot;&gt;Get Right Vote&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;span id=&quot;status&quot;&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; app.js中的代码为 function getRight() { var account = document.getElementById(&quot;account&quot;).value; var meta = Ballot.deployed(); meta.giveRightToVote(account).then(function(b){ if(Boolean(b)){ setStatus(&quot;Get Right Vote Success&quot;); }else{ setStatus(&quot;Get Right Vote Error&quot;); } }).catch(function(e){ setStatus(&quot;Get Right Vote Error&quot;); console.log(e); }); }; 另外分享几个教程给大家： python以太坊，主要是针对python围绕web3.py进行区块链以太坊应用开发的讲解。 web3j，主要是针对java和android程序员围绕web3j库进行区块链以太坊开发的讲解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/12/cb503a2284bf4d08302cfb99df19a83d.html" />
<meta property="og:url" content="https://mlh.app/2018/06/12/cb503a2284bf4d08302cfb99df19a83d.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、区块链 1. 分布式去中心化 比特币设计的初衷就是要避免依赖中心化的机构，没有发行机构，也不可能操纵发行数量。既然没有中心化的信用机构，在电子货币运行的过程中，也势必需要一种机制来认可运行在区块链上的行为(包括比特币的运营，亦或是运行在区块链上的其他业务)，这种机制就是共识机制。在完全去中心化的区块链上运行的比特币，采用的是PoW(Proof of Work，工作量证明)，该机制完美的解决了拜占庭将军问题（存在异常的情况下仍能达成一致）。因为基础网络架构为分布式，对单独一个节点是无法控制或破坏整个网络，掌握网内51%的运算能力(非节点数)才有可能操作交易，而这个代价大概要超过270亿美元。 2. 无须信任 整个区块链网络中的数据是公开透明的，每个节点(参与者)都可自由加入该网络中，下载到所有的数据。任意两个节点间的数据交换无需互相信任，完全依靠区块链中的交易历史和数据的可追溯，以及共识机制来保证数据交换的正确且不可逆的执行。 3. 不可篡改和加密安全性 跟当前银行网银系统(特别是公司网银系统)的加密机制类似，区块链的数据结构和交易流程中大量的使用了公私钥来加解密，保证数据的安全性。基于该技术基础，甚至可以应用群组签名来保证共有数据的安全性。任何事物既然有优点，也同时会存在不足之处。根源于分布式网络架构和共识机制，在区块链上运行的交易确认时间会比较长(比特币的确认时间大概是15分钟)，交易并发数受限(比特币的每秒交易数为7笔，而淘宝的每秒并发数能达到10万左右)，区块的容量限制(当前为1M，区块链的扩容一直在讨论中)，监管难以介入，基于工作量证明的共识机制存在浪费系统资源和带宽的问题。 4. 区块链技术 a. 区块 区块是一个包含在区块链(公开账簿)里的聚合了交易信息的容器。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。 区块结构如下图 交易(Tx)详情中的结构如下图 b. 区块链 当一个节点从网络接受到传入的区块时，它会验证这些区块，然后链接到现有的区块链上，链接的形态如下图： 由于每个区块包含前一个区块的HASH值，这就使得从创世块到当前块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后，因为如果不知道前一块区块的HASH值就没法生成当前区块。要改变一个已经在块链中存在一段时间的区块，从计算上来说是不可行的，因为如果它被改变，它之后的每个区块必须随之改变。这些特性使得双花比特币非常困难，区块链是比特币的最大创新。 5. 比特币钱包 a. 比特币钱包的生成 首先使用随机数发生器生成一个 私钥 。一般来说这是一个256bits的数，拥有了这串数字就可以对相应 钱包地址 中的比特币进行操作，所以必须被安全地保存起来。 私钥经过SECP256K1算法处理生成了公钥。SECP256K1是一种椭圆曲线算法，通过一个已知私钥时可以算得公钥，而公钥已知时却无法反向计算出私钥。这是保障比特币安全的算法基础。 同SHA256一样，RIPEMD160也是一种Hash算法，由公钥可以计算得到公钥哈希，而反过来是行不通的。 将一个字节的地址版本号连接到公钥哈希头部（对于比特币网络的pubkey地址，这一字节为“0”），然后对其进行两次SHA256运算，将结果的前4字节作为公钥哈希的校验值，连接在其尾部。 将上一步结果使用BASE58进行编码(比特币定制版本)，就得到了钱包地址。 流程图如下 b .转账 比特币钱包间的转账是通过交易（Transaction）实现的。交易数据是由转出钱包私钥的所有者生成，也就是说有了私钥就可以花费该钱包的比特币余额。生成交易的过程如下： 交易的原始数据包括“转账数额”和“转入钱包地址”，但是仅有这些是不够的，因为无法证明交易的生成者对“转出钱包地址”余额有动用的权利。所以需要用私钥对原始数据进行签名。 生成“转出钱包公钥”，这一过程与生成钱包地址的第2步是一样的。 将“转出签名”和“转出公钥”添加到原始交易数据中，生成了正式的交易数据，这样它就可以被广播到比特币网络进行转账了。 二、以太坊Ethereum 1. 概念 a. 什么是以太坊 简单来说，以太坊是一种新的法律形式。现行法律的本质是一种合约。它是由（生活于某一社群的）人和他们的领导者之间所缔结的，一种关于彼此该如何行动的共识。个体之间也存在着一些合约，这些合约可以理解为一种私法，相应的，这种私法仅对合约的参与者生效。 例如，你和一个人订立合约，借给他一笔钱，但他最后毁约了，不打算还这笔钱。此时你多半会将对方告上法庭。在现实生活中，打官司这种事情常常混乱不堪并且充满了不确定性。将对方告上法庭，也通常意味着你需要支付高昂的费用聘请律师，来帮你在法庭上针对法律条文展开辩论，而且这一过程一般都旷日持久。而且，即使你最终赢了官司，你依然可能会遇到问题（比如，对方拒不执行法庭判决）。 令人欣慰的是，当初你和借款人把条款写了下来，订立了合约。但法律的制定者和合约的起草者们都必须面对一个不容忽视的挑战：那就是，理想情况下，法律或者合约的内容应该是明确而没有歧义的，但现行的法律和合约都是由语句构成的，而语句，则是出了名的充满歧义。 因此，一直以来，现行的法律体系都存在着两个巨大的问题：首先，合约或法律是由充满歧义的语句定义的，第二，强制执行合约或法律的代价非常大。 而以太坊，通过数字货币和编程语言的结合，解决了现行法律体系的这两大问题。 以太坊系统自身带有一种叫做以太币（Ether）的数字货币。以太币和著名的数字货币比特币（Bitcoin）有着非常多的相似之处。两者均为数字储值货币，且无法伪造，都以去中心化的方式运行来保证货币供应不被某一方所控制。两者都可以像电子邮件一样，作为货币自由地在全世界流通。而且，由于它们可以做到传统货币做不到的事情，因此用户对它们未来的价值充满期待 。 另外： 1.详情请阅读以太坊白皮书 （中文， 英文）。 2.以太坊教程 b. 基本知识 公钥加密系统。 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的0xdf…5f地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。 点对点网络。 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。 区块链。 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。 以太坊虚拟机(EVM)。 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。 节点。 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。 矿工。 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：stats.ethdev.com。 工作量证明。 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。) 以太币。 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的走势图。在写这篇文章的时候，1个以太币价值65美分。 Gas. 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。 DApp. 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。这里分享一个以太坊DApp教程，可以高效的学习如何开发一个DApp，很适合入门。 2. 工作流程 a. 环境搭建 建议使用Mac OS环境，不然可能会出现各种坑。 安装NodeJS，安装Python。 安装testrpc（测试环境中使用），安装go-ethereum（真实环境中使用）。 安装solc。 安装truffle。 如果是windows的话建议用工具ethbox可以一键安装以太坊开发环境的工具： ethbox b. Solidity语言简介 下面是官网上面的一段关于智能投票合约的示例代码 contract Ballot { //一个选民的构造体 struct Voter { uint weight; // 权重（即他可以投几票） bool voted; //是否已经投过票 address delegate; // 代表地址（他可以代表某个人进行投票） uint vote; // index of the voted proposal } // 投票的提案的构造体 struct Proposal { bytes32 name; // 提案名称 uint voteCount; //获得的票数 } address public chairperson;//会议主席 //地址 -选民 的map mapping(address =&gt; Voter) public voters; // 投票种类的动态数组 Proposal[] public proposals; ///构造函数 function Ballot(bytes32[] proposalNames) { chairperson = msg.sender;//初始化会议主席 voters[chairperson].weight = 1; //初始化所有的提案 for (uint i = 0; i &lt; proposalNames.length; i++) { proposals.push(Proposal({ name: proposalNames[i], voteCount: 0 })); } } // 给予投票权 function giveRightToVote(address voter) returns (bool b) { if (msg.sender != chairperson || voters[voter].voted) { //对于会议主席和已经投过票的选民这里不处理 return false;; } voters[voter].weight = 1; return true; } /// 投票权转移函数 function delegate(address to) { // 投票权转移的发起人 Voter sender = voters[msg.sender]; if (sender.voted) throw; //递归找到没有转移投票权的 选民 while ( voters[to].delegate != address(0) &amp;&amp; voters[to].delegate != msg.sender ) { to = voters[to].delegate; } if (to == msg.sender) { throw; } //将发起人设置为已经投过票的状态 sender.voted = true; //将代表设置为刚才递归获取的选民 sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) { //如果代表已经投过票就在他投票的提案的票数增加 proposals[delegate.vote].voteCount += sender.weight; } else { //将代表的的票数增加 delegate.weight += sender.weight; } } /// 投票函数 function vote(uint proposal) { Voter sender = voters[msg.sender]; if (sender.voted) throw; sender.voted = true; sender.vote = proposal; //将投的提案票数增加 proposals[proposal].voteCount += sender.weight; } ///获得票数最多的提案 function winningProposal() constant returns (uint winningProposal) { uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) { if (proposals[p].voteCount &gt; winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal = p; } } } } 解读 address. 地址类型。chairperson是会议主席的钱包地址。这个地址会在合约的构造函数function Ballot()中被赋值。很多时候也称呼这种地址为’owner’（所有人）。 public. 这个关键字表明变量可以被合约之外的对象使用。private修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为public。 Mapping或数组。mapping(address =&gt; Voter)为选民钱包地址和选民构造体的键值对。Proposal[] public proposals是一个提案构造体的数组。 有特殊的变量和函数总是在全局命名空间存在，主要用于提供有关blockchain信息，例如msg，block，tx，其中msg.sender为发起人的地址。 solidity语言更深入的理解可以阅读官方文档。 c. 使用geth部署合约 启动一个测试节点 geth –testnet –fast –cache=512 –genesis CustomGenesis.json console 这里的CustomGenesis.json是为了给测试的账户分配以太币 { &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x20000&quot;, &quot;extraData&quot;: &quot;&quot;, &quot;gasLimit&quot;: &quot;0x2fefd8&quot;, &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;alloc&quot;: { &quot;0xe49c283bc6bf92c5833cc981b97679238dd3b5da&quot;: { &quot;balance&quot;: &quot;111111111000000000000000000000000000&quot; }, &quot;0xd8927c296b3ebe454a6409770a0c323ec4ed23ba&quot;: { &quot;balance&quot;: &quot;222222222000000000000000000000000000&quot; } } } solc下的内容要替换成你的测试账户地址。具体geth的用法请查看官方文档和源码介绍。 使用solc编译智能合约，获得二进制代码 例如以下代码 contract test { function multiply(uint a) returns(uint d) { return a * 7; } } 在geth中输入 source = “contract test { function multiply(uint a) returns(uint d) { return a * 7; } }” clientContract = eth.compile.solidity(source).test 编译返回的结果的JSON格式如下 其中， code：编译后的EVM字节码 info：编译器返回的metadata abiDefination:Application Binary Interface定义。具体接口规则参见这里 compilerVersion：编译此代码的solidity编译器版本 developerDoc：针对开发者的Natural Specification Format，类似于Doxygen language：合约语言 languageVersion：合约语言版本 source：源代码 userDoc：针对用户的Ethereum的Natural Specification Format。 编译器返回的JSON结构反映了合约部署的两种不同的路径。info信息真实的存在于区中心化的云中，作为metadata信息来公开验证Blockchain中合约代码的实现。而code信息通过创建交易的方式部署到区块链中。 使用solc编译智能合约，获得二进制代码 部署合约前，确保你有一个解锁的账户并且账户中有余额，因为部署合约得过程中会消耗以太币。输入web3.fromWei(eth.getBalance(eth.accounts[0]),”ether”)可以查看账户余额。 解锁一个账户 personal.unlockAccount(eth.accounts[0]) 获得账户 primaryAddress = eth.accounts[0] 定义一个abi （abi是个js的数组，否则不成功） abi = [{ constant: false, inputs: [{ name: ‘a’, type: ‘uint256’ } ]}] 创建智能合约 MyContract = eth.contract(abi) 发送交易部署合约 contract = MyContract.new({from: primaryAddress, data:”0x6060604052602a8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b6007600435026060908152602090f3”}) 如果交易被pending，如图说明你的miner没有在挖矿 启动一个矿工 miner.setEtherbase(eth.primaryAddress) //设定开采账户 miner.start(8) eth.getBlock(“pending”, true).transactions 这时候发现交易已经在区块中 不过会发现，交易还是pending，这是因为该交易区块没有人协助进行运算验证，这时候只需要再启动一个矿工就行了 miner.start(8) 与合约进行交互 Multiply7 = eth.contract(clientContract.info.abiDefinition); var myMultiply7 = Multiply7.at(contract.address); myMultiply7.multiply.call(3) 或 myMultiply7.multiply.sendTransaction(3, {from: contract.address}) d. 使用truffle框架 使用truffle部署智能合约的步骤： truffle init (在新目录中) =&gt; 创建truffle项目目录结构， 编写合约代码，保存到contracts/YourContractName.sol文件。 例如Ballot .sol，此时要找到migrations文件夹，在deploy_contracts.js文件中添加deployer.deploy(Ballot); truffile compile 编译合约代码。 启动以太坊节点（例如在另一个终端里面运行testrpc）。 truffle migrate（在truffle项目目录中)。 1. 编写单元测试 在test文件夹中新建ballot.js文件 contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var meta = Ballot.deployed(); return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); } 在项目根目录下运行truffle test，你应该看到测试通过，如果使用自己构造的ballot对象，可以这样写： contract(&#39;Ballot&#39;，function(accounts)){ //accounts是所以账户得数值 it(&quot;获取投票权&quot;，function(){ var proposals = []; proposals.push(&quot;proposal0&quot;); Ballot.new(proposals).then(function(meta){ return meta.giveRightToVote(accounts[1]).then(function(b){ assert.equal(Boolean(b),true,&quot;获取投票权失败&quot;); }); }); }); } 合约中发送以太币。 this是合约实例的地址，以变接下来检查这个地址的余额（或者直接使用this.balance） 当你通过web3.js调用交易函数时（使用web3.eth.sendTransaction），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。 Gas. （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在{ from: , value: , gas: _ } 对象内设置Gas参数。Web3.js提供了web3.eth.gasPrice调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：solc –gas YouContract.sol. 2. 为合约创建一个界面 在app目录中，可以编写自己的html和js文件，js与智能合约的交互与单元测试基本一致，例如一个界面上有一个输入框和一个按钮，获得选民的投票权。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Ballot App&lt;/title&gt; &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans:400,700&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;link href=&quot;./app.css&quot; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ballot&lt;/h1&gt; &lt;h2&gt;Example Truffle Dapp&lt;/h2&gt; &lt;br&gt; &lt;h1&gt;Send&lt;/h1&gt; &lt;br&gt;&lt;label for=&quot;amount&quot;&gt;Account:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;account&quot; placeholder=&quot;e.g., 0x453468394hdfg84858345348&quot;&gt;&lt;/input&gt; &lt;br&gt;&lt;br&gt;&lt;button id=&quot;getRightVote&quot; onclick=&quot;getRight()&quot;&gt;Get Right Vote&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;span id=&quot;status&quot;&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; app.js中的代码为 function getRight() { var account = document.getElementById(&quot;account&quot;).value; var meta = Ballot.deployed(); meta.giveRightToVote(account).then(function(b){ if(Boolean(b)){ setStatus(&quot;Get Right Vote Success&quot;); }else{ setStatus(&quot;Get Right Vote Error&quot;); } }).catch(function(e){ setStatus(&quot;Get Right Vote Error&quot;); console.log(e); }); }; 另外分享几个教程给大家： python以太坊，主要是针对python围绕web3.py进行区块链以太坊应用开发的讲解。 web3j，主要是针对java和android程序员围绕web3j库进行区块链以太坊开发的讲解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/12/cb503a2284bf4d08302cfb99df19a83d.html","headline":"以太坊教程：入门学习开发以太坊dapp","dateModified":"2018-06-12T00:00:00+08:00","datePublished":"2018-06-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/12/cb503a2284bf4d08302cfb99df19a83d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊教程：入门学习开发以太坊dapp</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="一区块链">一、区块链</h1> 
  <h2 id="1-分布式去中心化">1. 分布式去中心化</h2> 
  <p>比特币设计的初衷就是要避免依赖中心化的机构，没有发行机构，也不可能操纵发行数量。既然没有中心化的信用机构，在电子货币运行的过程中，也势必需要一种机制来认可运行在区块链上的行为(包括比特币的运营，亦或是运行在区块链上的其他业务)，这种机制就是共识机制。在完全去中心化的区块链上运行的比特币，采用的是PoW(Proof of Work，工作量证明)，该机制完美的解决了拜占庭将军问题（存在异常的情况下仍能达成一致）。因为基础网络架构为分布式，对单独一个节点是无法控制或破坏整个网络，掌握网内51%的运算能力(非节点数)才有可能操作交易，而这个代价大概要超过270亿美元。</p> 
  <h2 id="2-无须信任">2. 无须信任</h2> 
  <p>整个区块链网络中的数据是公开透明的，每个节点(参与者)都可自由加入该网络中，下载到所有的数据。任意两个节点间的数据交换无需互相信任，完全依靠区块链中的交易历史和数据的可追溯，以及共识机制来保证数据交换的正确且不可逆的执行。</p> 
  <h2 id="3-不可篡改和加密安全性">3. 不可篡改和加密安全性</h2> 
  <p>跟当前银行网银系统(特别是公司网银系统)的加密机制类似，区块链的数据结构和交易流程中大量的使用了公私钥来加解密，保证数据的安全性。基于该技术基础，甚至可以应用群组签名来保证共有数据的安全性。任何事物既然有优点，也同时会存在不足之处。根源于分布式网络架构和共识机制，在区块链上运行的交易确认时间会比较长(比特币的确认时间大概是15分钟)，交易并发数受限(比特币的每秒交易数为7笔，而淘宝的每秒并发数能达到10万左右)，区块的容量限制(当前为1M，区块链的扩容一直在讨论中)，监管难以介入，基于工作量证明的共识机制存在浪费系统资源和带宽的问题。</p> 
  <h2 id="4-区块链技术">4. 区块链技术</h2> 
  <h3 id="a-区块">a. 区块</h3> 
  <p>区块是一个包含在区块链(公开账簿)里的聚合了交易信息的容器。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。 <br> 区块结构如下图</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-e5a47f7be3987877.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/561" alt="" title=""></p> 
  <p>交易(Tx)详情中的结构如下图</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-992330c6708c69dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/603" alt="" title=""></p> 
  <h3 id="b-区块链">b. 区块链</h3> 
  <p>当一个节点从网络接受到传入的区块时，它会验证这些区块，然后链接到现有的区块链上，链接的形态如下图：</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-396fbb91bba68cfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/459" alt="" title=""></p> 
  <p>由于每个区块包含前一个区块的HASH值，这就使得从创世块到当前块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后，因为如果不知道前一块区块的HASH值就没法生成当前区块。要改变一个已经在块链中存在一段时间的区块，从计算上来说是不可行的，因为如果它被改变，它之后的每个区块必须随之改变。这些特性使得双花比特币非常困难，区块链是比特币的最大创新。</p> 
  <h2 id="5-比特币钱包">5. 比特币钱包</h2> 
  <h3 id="a-比特币钱包的生成">a. 比特币钱包的生成</h3> 
  <ol> 
   <li>首先使用随机数发生器生成一个 私钥 。一般来说这是一个256bits的数，拥有了这串数字就可以对相应 钱包地址 中的比特币进行操作，所以必须被安全地保存起来。</li> 
   <li>私钥经过SECP256K1算法处理生成了公钥。SECP256K1是一种椭圆曲线算法，通过一个已知私钥时可以算得公钥，而公钥已知时却无法反向计算出私钥。这是保障比特币安全的算法基础。</li> 
   <li>同SHA256一样，RIPEMD160也是一种Hash算法，由公钥可以计算得到公钥哈希，而反过来是行不通的。</li> 
   <li>将一个字节的地址版本号连接到公钥哈希头部（对于比特币网络的pubkey地址，这一字节为“0”），然后对其进行两次SHA256运算，将结果的前4字节作为公钥哈希的校验值，连接在其尾部。</li> 
   <li>将上一步结果使用BASE58进行编码(比特币定制版本)，就得到了钱包地址。</li> 
  </ol> 
  <blockquote> 
   <p>流程图如下</p> 
   <p><img src="https://upload-images.jianshu.io/upload_images/874510-5573cb169706f2c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570" alt="" title=""></p> 
  </blockquote> 
  <h3 id="b-转账">b .转账</h3> 
  <p>比特币钱包间的转账是通过交易（Transaction）实现的。交易数据是由转出钱包私钥的所有者生成，也就是说有了私钥就可以花费该钱包的比特币余额。生成交易的过程如下：</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-43d93f54232fed9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570" alt="" title=""></p> 
  <ol> 
   <li>交易的原始数据包括“转账数额”和“转入钱包地址”，但是仅有这些是不够的，因为无法证明交易的生成者对“转出钱包地址”余额有动用的权利。所以需要用私钥对原始数据进行签名。</li> 
   <li>生成“转出钱包公钥”，这一过程与生成钱包地址的第2步是一样的。</li> 
   <li>将“转出签名”和“转出公钥”添加到原始交易数据中，生成了正式的交易数据，这样它就可以被广播到比特币网络进行转账了。</li> 
  </ol> 
  <h1 id="二以太坊ethereum">二、以太坊Ethereum</h1> 
  <h2 id="1-概念">1. 概念</h2> 
  <h3 id="a-什么是以太坊">a. 什么是以太坊</h3> 
  <p>简单来说，以太坊是一种新的法律形式。现行法律的本质是一种合约。它是由（生活于某一社群的）人和他们的领导者之间所缔结的，一种关于彼此该如何行动的共识。个体之间也存在着一些合约，这些合约可以理解为一种私法，相应的，这种私法仅对合约的参与者生效。</p> 
  <p>例如，你和一个人订立合约，借给他一笔钱，但他最后毁约了，不打算还这笔钱。此时你多半会将对方告上法庭。在现实生活中，打官司这种事情常常混乱不堪并且充满了不确定性。将对方告上法庭，也通常意味着你需要支付高昂的费用聘请律师，来帮你在法庭上针对法律条文展开辩论，而且这一过程一般都旷日持久。而且，即使你最终赢了官司，你依然可能会遇到问题（比如，对方拒不执行法庭判决）。 <br> 令人欣慰的是，当初你和借款人把条款写了下来，订立了合约。但法律的制定者和合约的起草者们都必须面对一个不容忽视的挑战：那就是，理想情况下，法律或者合约的内容应该是明确而没有歧义的，但现行的法律和合约都是由语句构成的，而语句，则是出了名的充满歧义。 <br> 因此，一直以来，现行的法律体系都存在着两个巨大的问题：首先，合约或法律是由充满歧义的语句定义的，第二，强制执行合约或法律的代价非常大。 <br> 而以太坊，通过数字货币和编程语言的结合，解决了现行法律体系的这两大问题。 <br> 以太坊系统自身带有一种叫做以太币（Ether）的数字货币。以太币和著名的数字货币比特币（Bitcoin）有着非常多的相似之处。两者均为数字储值货币，且无法伪造，都以去中心化的方式运行来保证货币供应不被某一方所控制。两者都可以像电子邮件一样，作为货币自由地在全世界流通。而且，由于它们可以做到传统货币做不到的事情，因此用户对它们未来的价值充满期待 。</p> 
  <p><strong>另外</strong>： <br> 1.详情请阅读以太坊白皮书 （<a href="https://pan.baidu.com/s/1bzAFnzJ35hlQxJ2J4Oj-Ow" rel="nofollow">中文</a>， <a href="https://github.com/ethereum/wiki/wiki/White-Paper" rel="nofollow">英文</a>）。 <br> 2.<a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1" rel="nofollow">以太坊教程</a></p> 
  <h3 id="b-基本知识">b. 基本知识</h3> 
  <ul> 
   <li>公钥加密系统。 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的0xdf…5f地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。</li> 
   <li>点对点网络。 就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。</li> 
   <li>区块链。 区块链就像是一个全球唯一的帐簿，或者说是数据库，记录了网络中所有交易历史。</li> 
   <li>以太坊虚拟机(EVM)。 它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。</li> 
   <li>节点。 你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。</li> 
   <li>矿工。 挖矿，也就是处理区块链上的区块的节点。这个网页可以看到当前活跃的一部分以太坊矿工：stats.ethdev.com。</li> 
   <li>工作量证明。 矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。(注意：以太坊正计划转向没有矿工的权益证明系统(POS)，不过那不在本文讨论范围之内。)</li> 
   <li>以太币。 缩写ETH。一种你可以购买和使用的真正的数字货币。这里是可以交易以太币的其中一家交易所的走势图。在写这篇文章的时候，1个以太币价值65美分。</li> 
   <li>Gas. 在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。</li> 
   <li>DApp. 以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。这里分享一个<a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1" rel="nofollow">以太坊DApp</a>教程，可以高效的学习如何开发一个DApp，很适合入门。</li> 
  </ul> 
  <h2 id="2-工作流程">2. 工作流程</h2> 
  <h3 id="a-环境搭建">a. 环境搭建</h3> 
  <blockquote> 
   <p>建议使用Mac OS环境，不然可能会出现各种坑。</p> 
  </blockquote> 
  <ol> 
   <li>安装<a href="https://nodejs.org/en/" rel="nofollow">NodeJS</a>，安装<a href="https://www.python.org/" rel="nofollow">Python</a>。</li> 
   <li>安装<a href="https://github.com/ethereumjs/testrpc" rel="nofollow">testrpc</a>（测试环境中使用），安装<a href="https://github.com/ethereum/go-ethereum" rel="nofollow">go-ethereum</a>（真实环境中使用）。</li> 
   <li>安装<a href="http://solidity.readthedocs.io/en/latest/installing-solidity.html" rel="nofollow">solc</a>。</li> 
   <li>安装<a href="https://github.com/ConsenSys/truffle" rel="nofollow">truffle</a>。</li> 
  </ol> 
  <p>如果是windows的话建议用工具ethbox可以一键安装以太坊开发环境的工具： <a href="http://blog.hubwiz.com/2018/06/07/ethbox-readme/" rel="nofollow">ethbox</a></p> 
  <h3 id="b-solidity语言简介">b. Solidity语言简介</h3> 
  <blockquote> 
   <p>下面是官网上面的一段关于智能投票合约的示例代码</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cs">  contract Ballot {
   <span class="hljs-comment">//一个选民的构造体</span>
    <span class="hljs-keyword">struct</span> Voter {
        <span class="hljs-keyword">uint</span> weight; <span class="hljs-comment">// 权重（即他可以投几票）</span>
        <span class="hljs-keyword">bool</span> voted;  <span class="hljs-comment">//是否已经投过票</span>
        address <span class="hljs-keyword">delegate</span>; <span class="hljs-comment">// 代表地址（他可以代表某个人进行投票）</span>
        <span class="hljs-keyword">uint</span> vote;   <span class="hljs-comment">// index of the voted proposal</span>
    }

    <span class="hljs-comment">// 投票的提案的构造体</span>
    <span class="hljs-keyword">struct</span> Proposal
    {
        bytes32 name;   <span class="hljs-comment">// 提案名称</span>
        <span class="hljs-keyword">uint</span> voteCount; <span class="hljs-comment">//获得的票数</span>
    }

    address <span class="hljs-keyword">public</span> chairperson;<span class="hljs-comment">//会议主席</span>

    <span class="hljs-comment">//地址 -选民 的map</span>
    mapping(address =&gt; Voter) <span class="hljs-keyword">public</span> voters;

    <span class="hljs-comment">// 投票种类的动态数组</span>
    Proposal[] <span class="hljs-keyword">public</span> proposals;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span>构造函数</span>
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;<span class="hljs-comment">//初始化会议主席</span>
        voters[chairperson].weight = <span class="hljs-number">1</span>;

       <span class="hljs-comment">//初始化所有的提案</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; proposalNames.length; i++) {

            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: <span class="hljs-number">0</span>
            }));
        }
    }

    <span class="hljs-comment">// 给予投票权</span>
    function giveRightToVote(address voter) returns (<span class="hljs-keyword">bool</span> b) {
        <span class="hljs-keyword">if</span> (msg.sender != chairperson || voters[voter].voted) {
            <span class="hljs-comment">//对于会议主席和已经投过票的选民这里不处理</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;;
        }
        voters[voter].weight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 投票权转移函数</span>
    function <span class="hljs-keyword">delegate</span>(address to) {
        <span class="hljs-comment">// 投票权转移的发起人</span>
        Voter sender = voters[msg.sender];
        <span class="hljs-keyword">if</span> (sender.voted)
            <span class="hljs-keyword">throw</span>;

      <span class="hljs-comment">//递归找到没有转移投票权的 选民</span>
        <span class="hljs-keyword">while</span> (
            voters[to].<span class="hljs-keyword">delegate</span> != address(<span class="hljs-number">0</span>) &amp;&amp;
            voters[to].<span class="hljs-keyword">delegate</span> != msg.sender
        ) {
            to = voters[to].<span class="hljs-keyword">delegate</span>;
        }

        <span class="hljs-keyword">if</span> (to == msg.sender) {
            <span class="hljs-keyword">throw</span>;
        }

       <span class="hljs-comment">//将发起人设置为已经投过票的状态</span>
        sender.voted = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//将代表设置为刚才递归获取的选民</span>
        sender.<span class="hljs-keyword">delegate</span> = to;
        Voter <span class="hljs-keyword">delegate</span> = voters[to];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">delegate</span>.voted) {
            <span class="hljs-comment">//如果代表已经投过票就在他投票的提案的票数增加</span>
            proposals[<span class="hljs-keyword">delegate</span>.vote].voteCount += sender.weight;
        }
        <span class="hljs-keyword">else</span> {
           <span class="hljs-comment">//将代表的的票数增加</span>
            <span class="hljs-keyword">delegate</span>.weight += sender.weight;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 投票函数</span>
    function vote(<span class="hljs-keyword">uint</span> proposal) {
        Voter sender = voters[msg.sender];
        <span class="hljs-keyword">if</span> (sender.voted)
            <span class="hljs-keyword">throw</span>;
        sender.voted = <span class="hljs-keyword">true</span>;
        sender.vote = proposal;

        <span class="hljs-comment">//将投的提案票数增加</span>
        proposals[proposal].voteCount += sender.weight;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span>获得票数最多的提案</span>
    function winningProposal() constant
            returns (<span class="hljs-keyword">uint</span> winningProposal)
    {
        <span class="hljs-keyword">uint</span> winningVoteCount = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> p = <span class="hljs-number">0</span>; p &lt; proposals.length; p++) {
            <span class="hljs-keyword">if</span> (proposals[p].voteCount &gt; winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal = p;
            }
        }
    }
}
</code></pre> 
  <p>解读</p> 
  <ul> 
   <li>address. 地址类型。chairperson是会议主席的钱包地址。这个地址会在合约的构造函数function Ballot()中被赋值。很多时候也称呼这种地址为’owner’（所有人）。</li> 
   <li>public. 这个关键字表明变量可以被合约之外的对象使用。private修饰符则表示变量只能被本合约(或者衍生合约)内的对象使用。如果你想要在测试中通过web3.js使用合约中的某个变量，记得把它声明为public。</li> 
   <li>Mapping或数组。mapping(address =&gt; Voter)为选民钱包地址和选民构造体的键值对。Proposal[] public proposals是一个提案构造体的数组。</li> 
   <li>有特殊的变量和函数总是在全局命名空间存在，主要用于提供有关blockchain信息，例如msg，block，tx，其中msg.sender为发起人的地址。</li> 
  </ul> 
  <p>solidity语言更深入的理解可以阅读<a href="https://solidity.readthedocs.io/en/latest/solidity-in-depth.html" rel="nofollow">官方文档</a>。</p> 
  <h3 id="c-使用geth部署合约">c. 使用geth部署合约</h3> 
  <ol> 
   <li>启动一个测试节点</li> 
  </ol> 
  <blockquote> 
   <p>geth –testnet –fast –cache=512 –genesis CustomGenesis.json console</p> 
  </blockquote> 
  <p>这里的CustomGenesis.json是为了给测试的账户分配以太币</p> 
  <pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">coinbase</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000000000000000000000000000000"</span></span>,
    "<span class="hljs-attribute">difficulty</span>": <span class="hljs-value"><span class="hljs-string">"0x20000"</span></span>,
    "<span class="hljs-attribute">extraData</span>": <span class="hljs-value"><span class="hljs-string">""</span></span>,
    "<span class="hljs-attribute">gasLimit</span>": <span class="hljs-value"><span class="hljs-string">"0x2fefd8"</span></span>,
    "<span class="hljs-attribute">nonce</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000042"</span></span>,
    "<span class="hljs-attribute">mixhash</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span></span>,
    "<span class="hljs-attribute">parentHash</span>": <span class="hljs-value"><span class="hljs-string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span></span>,
    "<span class="hljs-attribute">timestamp</span>": <span class="hljs-value"><span class="hljs-string">"0x00"</span></span>,
    "<span class="hljs-attribute">alloc</span>": <span class="hljs-value">{ "<span class="hljs-attribute">0xe49c283bc6bf92c5833cc981b97679238dd3b5da</span>": <span class="hljs-value">{ "<span class="hljs-attribute">balance</span>": <span class="hljs-value"><span class="hljs-string">"111111111000000000000000000000000000"</span> </span>}</span>, "<span class="hljs-attribute">0xd8927c296b3ebe454a6409770a0c323ec4ed23ba</span>": <span class="hljs-value">{ "<span class="hljs-attribute">balance</span>": <span class="hljs-value"><span class="hljs-string">"222222222000000000000000000000000000"</span> </span>} </span>} </span>}
</code></pre> 
  <p>solc下的内容要替换成你的测试账户地址。具体geth的用法请查看<a href="http://ethdocs.org/en/latest/network/test-networks.html" rel="nofollow">官方文档</a>和<a href="https://github.com/ethereum/go-ethereum" rel="nofollow">源码介绍</a>。</p> 
  <ol> 
   <li>使用solc编译智能合约，获得二进制代码 <br> 例如以下代码</li> 
  </ol> 
  <pre class="prettyprint"><code class=" hljs javascript">contract test { 
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(uint a)</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint d)</span> {</span> 
             <span class="hljs-keyword">return</span> a * <span class="hljs-number">7</span>; 
      }
}
</code></pre> 
  <p>在geth中输入</p> 
  <blockquote> 
   <p>source = “contract test { function multiply(uint a) returns(uint d) { return a * 7; } }”</p> 
   <p>clientContract = eth.compile.solidity(source).test</p> 
  </blockquote> 
  <p>编译返回的结果的JSON格式如下</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-033ffc5e1683ee94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" title=""></p> 
  <p>其中，</p> 
  <ul> 
   <li>code：编译后的EVM字节码</li> 
   <li>info：编译器返回的metadata</li> 
   <li>abiDefination:Application Binary Interface定义。具体接口规则参见这里</li> 
   <li>compilerVersion：编译此代码的solidity编译器版本</li> 
   <li>developerDoc：针对开发者的Natural Specification Format，类似于Doxygen</li> 
   <li>language：合约语言</li> 
   <li>languageVersion：合约语言版本</li> 
   <li>source：源代码</li> 
   <li>userDoc：针对用户的Ethereum的Natural Specification Format。</li> 
  </ul> 
  <p>编译器返回的JSON结构反映了合约部署的两种不同的路径。info信息真实的存在于区中心化的云中，作为metadata信息来公开验证Blockchain中合约代码的实现。而code信息通过创建交易的方式部署到区块链中。</p> 
  <ol> 
   <li>使用solc编译智能合约，获得二进制代码 <br> 部署合约前，确保你有一个解锁的账户并且账户中有余额，因为部署合约得过程中会消耗以太币。输入web3.fromWei(eth.getBalance(eth.accounts[0]),”ether”)可以查看账户余额。 <br> 解锁一个账户</li> 
  </ol> 
  <blockquote> 
   <p>personal.unlockAccount(eth.accounts[0])</p> 
  </blockquote> 
  <p>获得账户</p> 
  <blockquote> 
   <p>primaryAddress = eth.accounts[0]</p> 
  </blockquote> 
  <p>定义一个abi （abi是个js的数组，否则不成功）</p> 
  <blockquote> 
   <p>abi = [{ constant: false, inputs: [{ name: ‘a’, type: ‘uint256’ } ]}]</p> 
  </blockquote> 
  <p>创建智能合约</p> 
  <blockquote> 
   <p>MyContract = eth.contract(abi)</p> 
  </blockquote> 
  <p>发送交易部署合约</p> 
  <blockquote> 
   <p>contract = MyContract.new({from: primaryAddress, data:”0x6060604052602a8060106000396000f3606060405260e060020a6000350463c6888fa18114601a575b005b6007600435026060908152602090f3”})</p> 
  </blockquote> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-6d36d7b6abedf44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" title=""></p> 
  <p>如果交易被pending，如图说明你的miner没有在挖矿</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/874510-4e58444510ce0647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507" alt="" title=""></p> 
  <blockquote> 
   <p>启动一个矿工 <br> miner.setEtherbase(eth.primaryAddress) //设定开采账户 <br> miner.start(8)</p> 
   <p>eth.getBlock(“pending”, true).transactions <br> 这时候发现交易已经在区块中</p> 
   <p><img src="https://upload-images.jianshu.io/upload_images/874510-fe32ac59691f74f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" title=""></p> 
   <p>不过会发现，交易还是pending，这是因为该交易区块没有人协助进行运算验证，这时候只需要再启动一个矿工就行了 <br> miner.start(8)</p> 
  </blockquote> 
  <ol> 
   <li>与合约进行交互</li> 
  </ol> 
  <blockquote> 
   <p>Multiply7 = eth.contract(clientContract.info.abiDefinition); <br> var myMultiply7 = Multiply7.at(contract.address); <br> myMultiply7.multiply.call(3) <br> 或 <br> myMultiply7.multiply.sendTransaction(3, {from: contract.address})</p> 
  </blockquote> 
  <h3 id="d-使用truffle框架">d. 使用truffle框架</h3> 
  <p>使用truffle部署智能合约的步骤：</p> 
  <ol> 
   <li>truffle init (在新目录中) =&gt; 创建truffle项目目录结构，</li> 
   <li>编写合约代码，保存到contracts/YourContractName.sol文件。 <br> 例如Ballot .sol，此时要找到migrations文件夹，在deploy_contracts.js文件中添加<strong>deployer.deploy(Ballot);</strong></li> 
   <li>truffile compile 编译合约代码。</li> 
   <li>启动以太坊节点（例如在另一个终端里面运行testrpc）。</li> 
   <li>truffle migrate（在truffle项目目录中)。</li> 
  </ol> 
  <h4 id="1-编写单元测试">1. 编写单元测试</h4> 
  <p>在<em>test</em>文件夹中新建ballot.js文件</p> 
  <pre class="prettyprint"><code class=" hljs javascript">contract(<span class="hljs-string">'Ballot'</span>，<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(accounts)</span>){</span>
    <span class="hljs-comment">//accounts是所以账户得数值</span>
    it(<span class="hljs-string">"获取投票权"</span>，<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> meta = Ballot.deployed();
        <span class="hljs-keyword">return</span> meta.giveRightToVote(accounts[<span class="hljs-number">1</span>]).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span>{</span>
           assert.equal(<span class="hljs-built_in">Boolean</span>(b),<span class="hljs-literal">true</span>,<span class="hljs-string">"获取投票权失败"</span>);
        });
    });

}
</code></pre> 
  <p>在项目根目录下运行truffle test，你应该看到测试通过，如果使用自己构造的ballot对象，可以这样写：</p> 
  <pre class="prettyprint"><code class=" hljs javascript">contract(<span class="hljs-string">'Ballot'</span>，<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(accounts)</span>){</span>
    <span class="hljs-comment">//accounts是所以账户得数值</span>
    it(<span class="hljs-string">"获取投票权"</span>，<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
       <span class="hljs-keyword">var</span> proposals = [];
       proposals.push(<span class="hljs-string">"proposal0"</span>);
       Ballot.new(proposals).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(meta)</span>{</span>
           <span class="hljs-keyword">return</span> meta.giveRightToVote(accounts[<span class="hljs-number">1</span>]).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span>{</span>
               assert.equal(<span class="hljs-built_in">Boolean</span>(b),<span class="hljs-literal">true</span>,<span class="hljs-string">"获取投票权失败"</span>);
            });
       });

    });

}
</code></pre> 
  <ul> 
   <li>合约中发送以太币。 this是合约实例的地址，以变接下来检查这个地址的余额（或者直接使用this.balance）</li> 
   <li>当你通过web3.js调用交易函数时（使用web3.eth.sendTransaction），交易并不会立即执行。事实上交易会被提交到矿工网络中，交易代码直到其中一位矿工产生一个新区块把交易记录进区块链之后才执行。因此你必须等交易进入区块链并且同步回本地节点之后才能验证交易执行的结果。用testrpc的时候可能看上去是实时的，因为测试环境很快，但是正式网络会比较慢。</li> 
   <li>Gas. （译注：以太坊上的燃料，因为代码的执行必须消耗Gas。直译为汽油比较突兀，故保留原文做专有名词。）直到现在我们都没有涉及Gas的概念，因为在使用testrpc时通常不需要显式的设置。当你转向geth和正式网络时会需要。在交易函数调用中可以在{ from: <em>, value: </em>, gas: _ } 对象内设置Gas参数。Web3.js提供了web3.eth.gasPrice调用来获取当前Gas的价格，Solidity编译器也提供了一个参数让你可以从命令行获取合约的Gas开销概要：solc –gas YouContract.sol.</li> 
  </ul> 
  <h4 id="2-为合约创建一个界面">2. 为合约创建一个界面</h4> 
  <p>在<em>app</em>目录中，可以编写自己的html和js文件，js与智能合约的交互与单元测试基本一致，例如一个界面上有一个输入框和一个按钮，获得选民的投票权。</p> 
  <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Ballot App<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">'https://fonts.googleapis.com/css?family=Open+Sans:400,700'</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">'stylesheet'</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">'text/css'</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"./app.css"</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">'stylesheet'</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">'text/css'</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"./app.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Ballot<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>Example Truffle Dapp<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Send<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">label</span> <span class="hljs-attribute">for</span>=<span class="hljs-value">"amount"</span>&gt;</span>Account:<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"account"</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"e.g., 0x453468394hdfg84858345348"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">input</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"getRightVote"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"getRight()"</span>&gt;</span>Get Right Vote<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"status"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre> 
  <p>app.js中的代码为</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRight</span><span class="hljs-params">()</span> {</span>
 <span class="hljs-keyword">var</span> account = document.getElementById(<span class="hljs-string">"account"</span>).value;
  <span class="hljs-keyword">var</span> meta = Ballot.deployed();

   meta.giveRightToVote(account).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span>{</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Boolean</span>(b)){
          setStatus(<span class="hljs-string">"Get Right Vote Success"</span>);
        }<span class="hljs-keyword">else</span>{
          setStatus(<span class="hljs-string">"Get Right Vote Error"</span>);
        }
  }).catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span>{</span>
    setStatus(<span class="hljs-string">"Get Right Vote Error"</span>);
    console.log(e);
  });

};
</code></pre> 
  <p>另外分享几个教程给大家：</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=81csdn" rel="nofollow">python以太坊</a>，主要是针对python围绕web3.py进行区块链以太坊应用开发的讲解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=81csdn" rel="nofollow">web3j</a>，主要是针对java和android程序员围绕web3j库进行区块链以太坊开发的讲解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=81csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=81csdn" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=81csdn" rel="nofollow">以太坊教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=81blog" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。</li> 
   </ul> 
  </blockquote> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80660120,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80660120,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
