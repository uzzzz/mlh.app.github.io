<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>java类库web3j开发以太坊智能合约快速入门 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="java类库web3j开发以太坊智能合约快速入门" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="web3j简介 web3j是一个轻量级、高度模块化、响应式、类型安全的Java和Android类库提供丰富API，用于处理以太坊智能合约及与以太坊网络上的客户端(节点)进行集成。 可以通过它进行以太坊区块链的开发，而无需为你的java应用平台编写集成代码。 快速启动 想要快速启动的话，有一个Web3j demo示例项目可用，演示了通过Web3j开发以太坊的许多核心特征，其中包括： 连接到以太网网络上的节点 加载一个以太坊钱包文件 将以太币从一个地址发送到另一个地址 向网络部署智能合约 从部署的智能合约中读取值 更新部署的智能合约中的值 查看由智能合约记录的事件 也有一个快速进入学习的交互式课程web3j教程可以尝试。 web3j入门 首先将最新版本的web3j安装到项目中。 Maven Java 8: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; Android: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.1-android&lt;/version&gt; &lt;/dependency&gt; Gradle Java 8: compile (&#39;org.web3j:core:3.4.0&#39;) Android: compile (&#39;org.web3j:core:3.3.1-android&#39;) 启动客户端 需要启动一个以太坊客户端，当然如果你已经启动了就不需要再次启动。 如果是geth的话这么启动： $ geth --rpcapi personal,db,eth,net,web3 --rpc --rinkeby 如果是Parity启动： $ parity --chain testnet 如果使用Infura客户端提供的免费的云端服务，这么启动： Web3j web3 = Web3j.build(new HttpService(&quot;https://morden.infura.io/your-token&quot;)); 如果想进一步的了解infura，请参阅Using Infura with web3j。 在网络上如何获得以太币的相关文档可以看这个：testnet section of the docs。 当不需要Web3j实例时，需要调用shutdown方法来释放它所使用的资源。 web3.shutdown() 发送请求 发送同步请求 Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); * 使用CompletableFuture (Future on Android) 发送异步请求* Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().sendAsync().get(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); *使用RxJava的Observable Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ web3.web3ClientVersion().observable().subscribe(x -&gt; { String clientVersion = x.getWeb3ClientVersion(); ... }); 注意Android使用方式 Web3j web3 = Web3jFactory.build(new HttpService()); // defaults to http://localhost:8545/ ... IPC Web3j还支持通过文件套接字快速运行进程间通信（IPC），支持客户端在相同的主机上同时运行Web3j。在创建服务时，使用相关的IPCService就可以实现而不需要通过HTTPService。 // OS X/Linux/Unix: Web3j web3 = Web3j.build(new UnixIpcService(&quot;/path/to/socketfile&quot;)); ... // Windows Web3j web3 = Web3j.build(new WindowsIpcService(&quot;/path/to/namedpipefile&quot;)); ... 需要注意：IPC通信在web3j-android中不可用。 通过java打包以太坊智能合约 Web3j可以自动打包智能合同代码，以便在不脱离JVM的情况下进行以太坊智能合同部署和交互。 要打包代码，需要先编译智能合同： $ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/ 然后用web3j的命令行工具打包代码： web3j solidity generate /path/to/&lt;smart-contract&gt;.bin /path/to/&lt;smart-contract&gt;.abi -o /path/to/src/main/java -p com.your.organisation.name 接下来就可以新建和部署智能合约了： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); YourSmartContract contract = YourSmartContract.deploy( &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT, &lt;param1&gt;, ..., &lt;paramN&gt;).send(); // constructor params 或者使用一个现有的智能合约： YourSmartContract contract = YourSmartContract.load( &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT); 然后就可以进行智能合约的交互了： TransactionReceipt transactionReceipt = contract.someMethod( &lt;param1&gt;, ...).send(); 调用智能合约： Type result = contract.someMethod(&lt;param1&gt;, ...).send(); 更多关于打包的资料可以看这里：Solidity smart contract wrappers Filters web3j的响应式函数可以使观察者通过事件去通知消息订阅者变得很简单，并能够记录在区块链中。接收所有新的区块并把它们添加到区块链中： Subscription subscription = web3j.blockObservable(false).subscribe(block -&gt; { ... }); 接收所有新的交易并把它们添加到区块链中： Subscription subscription = web3j.transactionObservable().subscribe(tx -&gt; { ... }); 接收所有已经提交到网络中等待处理的交易。(他们被统一的分配到一个区块之前。) Subscription subscription = web3j.pendingTransactionObservable().subscribe(tx -&gt; { ... }); 或者你重置所有的区块到最新的位置，那么当有新建区块的时候会通知你。 Subscription subscription = catchUpToLatestAndSubscribeToNewBlocksObservable( &lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;) .subscribe(block -&gt; { ... }); 主题过滤也被支持： EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST, &lt;contract-address&gt;) .addSingleTopic(...)|.addOptionalTopics(..., ...)|...; web3j.ethLogObservable(filter).subscribe(log -&gt; { ... }); 当不再需要时，订阅也应该被取消： subscription.unsubscribe(); 注意：Infura中不支持filters。 需要了解更多有关过滤器和事件的信息可以查看Filters and Events和Web3jRx的接口。 交易 Web3j支持使用以太坊钱包文件（推荐的）和用于发送事务的以太坊客户端管理命令。 使用以太钱包文件发送以太币给其他人： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); TransactionReceipt transactionReceipt = Transfer.sendFunds( web3, credentials, &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, BigDecimal.valueOf(1.0), Convert.Unit.ETHER) .send(); 或者你希望建立你自己定制的交易： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); // get the next available nonce EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount( address, DefaultBlockParameterName.LATEST).send(); BigInteger nonce = ethGetTransactionCount.getTransactionCount(); // create our transaction RawTransaction rawTransaction = RawTransaction.createEtherTransaction( nonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;); // sign &amp; send our transaction byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials); String hexValue = Numeric.toHexString(signedMessage); EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send(); // ... 使用Web3j的Transfer进行以太币交易要简单得多。 使用以太坊客户端的管理命令（如果你的钱包密钥已经在客户端存储）： Admin web3j = Admin.build(new HttpService()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(&quot;0x000...&quot;, &quot;a password&quot;).sendAsync().get(); if (personalUnlockAccount.accountUnlocked()) { // send a transaction } 如果你想使用 Parity’s Personal 或者 Trace 功能, 或者 Geth’s Personal 客户端 APIs，可以使用org.web3j:parity和org.web3j:geth模块。 命令行工具 web3j的jar包为每一个版本都提供命令行工具。命令行工具允许你直接通过一些命令使用web3j的一些功能： 钱包创建 钱包密码管理 资金从钱包转移到另一个 solidity编写的智能合同功能打包 请参阅文档以获得命令行相关的进一步的信息。 其他的细节 java8 bulid： Web3j提供对所有响应类型的安全访问。可选的或null响应java 8都支持。 异步请求包在一个java 8的CompletableFutures。Web3j提供了围绕所有异步请求的打包工具，以确保在执行期间可以捕获任何异常，而不只是丢弃。由于在完全检查中会有很多缺少支持的异常情况，这些异常通常被确定为未检测到的异常，导致检测过程出现问题。有关详细信息，请参见 Async.run()及其关联 test。 在java 8的Android版本： 包数量作为 BigIntegers返回。对于简单的结果，可以通过Response.getResult()获取字符串类型的数量结果。 还可以通过在 HttpService和IpcService类中存在的includeRawResponse参数将原生的JSON包放置在响应中。 原文请访问：web3js开发以太坊智能合约快速入门 安利两个教程： 1.web3j教程，java和android app开发以太坊区块链类库web3j开发详解。 2.以太坊dapp，主要介绍智能合约与dapp应用开发，适合入门。 3.以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多" />
<meta property="og:description" content="web3j简介 web3j是一个轻量级、高度模块化、响应式、类型安全的Java和Android类库提供丰富API，用于处理以太坊智能合约及与以太坊网络上的客户端(节点)进行集成。 可以通过它进行以太坊区块链的开发，而无需为你的java应用平台编写集成代码。 快速启动 想要快速启动的话，有一个Web3j demo示例项目可用，演示了通过Web3j开发以太坊的许多核心特征，其中包括： 连接到以太网网络上的节点 加载一个以太坊钱包文件 将以太币从一个地址发送到另一个地址 向网络部署智能合约 从部署的智能合约中读取值 更新部署的智能合约中的值 查看由智能合约记录的事件 也有一个快速进入学习的交互式课程web3j教程可以尝试。 web3j入门 首先将最新版本的web3j安装到项目中。 Maven Java 8: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; Android: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.1-android&lt;/version&gt; &lt;/dependency&gt; Gradle Java 8: compile (&#39;org.web3j:core:3.4.0&#39;) Android: compile (&#39;org.web3j:core:3.3.1-android&#39;) 启动客户端 需要启动一个以太坊客户端，当然如果你已经启动了就不需要再次启动。 如果是geth的话这么启动： $ geth --rpcapi personal,db,eth,net,web3 --rpc --rinkeby 如果是Parity启动： $ parity --chain testnet 如果使用Infura客户端提供的免费的云端服务，这么启动： Web3j web3 = Web3j.build(new HttpService(&quot;https://morden.infura.io/your-token&quot;)); 如果想进一步的了解infura，请参阅Using Infura with web3j。 在网络上如何获得以太币的相关文档可以看这个：testnet section of the docs。 当不需要Web3j实例时，需要调用shutdown方法来释放它所使用的资源。 web3.shutdown() 发送请求 发送同步请求 Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); * 使用CompletableFuture (Future on Android) 发送异步请求* Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().sendAsync().get(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); *使用RxJava的Observable Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ web3.web3ClientVersion().observable().subscribe(x -&gt; { String clientVersion = x.getWeb3ClientVersion(); ... }); 注意Android使用方式 Web3j web3 = Web3jFactory.build(new HttpService()); // defaults to http://localhost:8545/ ... IPC Web3j还支持通过文件套接字快速运行进程间通信（IPC），支持客户端在相同的主机上同时运行Web3j。在创建服务时，使用相关的IPCService就可以实现而不需要通过HTTPService。 // OS X/Linux/Unix: Web3j web3 = Web3j.build(new UnixIpcService(&quot;/path/to/socketfile&quot;)); ... // Windows Web3j web3 = Web3j.build(new WindowsIpcService(&quot;/path/to/namedpipefile&quot;)); ... 需要注意：IPC通信在web3j-android中不可用。 通过java打包以太坊智能合约 Web3j可以自动打包智能合同代码，以便在不脱离JVM的情况下进行以太坊智能合同部署和交互。 要打包代码，需要先编译智能合同： $ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/ 然后用web3j的命令行工具打包代码： web3j solidity generate /path/to/&lt;smart-contract&gt;.bin /path/to/&lt;smart-contract&gt;.abi -o /path/to/src/main/java -p com.your.organisation.name 接下来就可以新建和部署智能合约了： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); YourSmartContract contract = YourSmartContract.deploy( &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT, &lt;param1&gt;, ..., &lt;paramN&gt;).send(); // constructor params 或者使用一个现有的智能合约： YourSmartContract contract = YourSmartContract.load( &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT); 然后就可以进行智能合约的交互了： TransactionReceipt transactionReceipt = contract.someMethod( &lt;param1&gt;, ...).send(); 调用智能合约： Type result = contract.someMethod(&lt;param1&gt;, ...).send(); 更多关于打包的资料可以看这里：Solidity smart contract wrappers Filters web3j的响应式函数可以使观察者通过事件去通知消息订阅者变得很简单，并能够记录在区块链中。接收所有新的区块并把它们添加到区块链中： Subscription subscription = web3j.blockObservable(false).subscribe(block -&gt; { ... }); 接收所有新的交易并把它们添加到区块链中： Subscription subscription = web3j.transactionObservable().subscribe(tx -&gt; { ... }); 接收所有已经提交到网络中等待处理的交易。(他们被统一的分配到一个区块之前。) Subscription subscription = web3j.pendingTransactionObservable().subscribe(tx -&gt; { ... }); 或者你重置所有的区块到最新的位置，那么当有新建区块的时候会通知你。 Subscription subscription = catchUpToLatestAndSubscribeToNewBlocksObservable( &lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;) .subscribe(block -&gt; { ... }); 主题过滤也被支持： EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST, &lt;contract-address&gt;) .addSingleTopic(...)|.addOptionalTopics(..., ...)|...; web3j.ethLogObservable(filter).subscribe(log -&gt; { ... }); 当不再需要时，订阅也应该被取消： subscription.unsubscribe(); 注意：Infura中不支持filters。 需要了解更多有关过滤器和事件的信息可以查看Filters and Events和Web3jRx的接口。 交易 Web3j支持使用以太坊钱包文件（推荐的）和用于发送事务的以太坊客户端管理命令。 使用以太钱包文件发送以太币给其他人： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); TransactionReceipt transactionReceipt = Transfer.sendFunds( web3, credentials, &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, BigDecimal.valueOf(1.0), Convert.Unit.ETHER) .send(); 或者你希望建立你自己定制的交易： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); // get the next available nonce EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount( address, DefaultBlockParameterName.LATEST).send(); BigInteger nonce = ethGetTransactionCount.getTransactionCount(); // create our transaction RawTransaction rawTransaction = RawTransaction.createEtherTransaction( nonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;); // sign &amp; send our transaction byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials); String hexValue = Numeric.toHexString(signedMessage); EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send(); // ... 使用Web3j的Transfer进行以太币交易要简单得多。 使用以太坊客户端的管理命令（如果你的钱包密钥已经在客户端存储）： Admin web3j = Admin.build(new HttpService()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(&quot;0x000...&quot;, &quot;a password&quot;).sendAsync().get(); if (personalUnlockAccount.accountUnlocked()) { // send a transaction } 如果你想使用 Parity’s Personal 或者 Trace 功能, 或者 Geth’s Personal 客户端 APIs，可以使用org.web3j:parity和org.web3j:geth模块。 命令行工具 web3j的jar包为每一个版本都提供命令行工具。命令行工具允许你直接通过一些命令使用web3j的一些功能： 钱包创建 钱包密码管理 资金从钱包转移到另一个 solidity编写的智能合同功能打包 请参阅文档以获得命令行相关的进一步的信息。 其他的细节 java8 bulid： Web3j提供对所有响应类型的安全访问。可选的或null响应java 8都支持。 异步请求包在一个java 8的CompletableFutures。Web3j提供了围绕所有异步请求的打包工具，以确保在执行期间可以捕获任何异常，而不只是丢弃。由于在完全检查中会有很多缺少支持的异常情况，这些异常通常被确定为未检测到的异常，导致检测过程出现问题。有关详细信息，请参见 Async.run()及其关联 test。 在java 8的Android版本： 包数量作为 BigIntegers返回。对于简单的结果，可以通过Response.getResult()获取字符串类型的数量结果。 还可以通过在 HttpService和IpcService类中存在的includeRawResponse参数将原生的JSON包放置在响应中。 原文请访问：web3js开发以太坊智能合约快速入门 安利两个教程： 1.web3j教程，java和android app开发以太坊区块链类库web3j开发详解。 2.以太坊dapp，主要介绍智能合约与dapp应用开发，适合入门。 3.以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/18/2ae8e9905fbb9827e99ba751b9a67ad1.html" />
<meta property="og:url" content="https://mlh.app/2018/06/18/2ae8e9905fbb9827e99ba751b9a67ad1.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"web3j简介 web3j是一个轻量级、高度模块化、响应式、类型安全的Java和Android类库提供丰富API，用于处理以太坊智能合约及与以太坊网络上的客户端(节点)进行集成。 可以通过它进行以太坊区块链的开发，而无需为你的java应用平台编写集成代码。 快速启动 想要快速启动的话，有一个Web3j demo示例项目可用，演示了通过Web3j开发以太坊的许多核心特征，其中包括： 连接到以太网网络上的节点 加载一个以太坊钱包文件 将以太币从一个地址发送到另一个地址 向网络部署智能合约 从部署的智能合约中读取值 更新部署的智能合约中的值 查看由智能合约记录的事件 也有一个快速进入学习的交互式课程web3j教程可以尝试。 web3j入门 首先将最新版本的web3j安装到项目中。 Maven Java 8: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; Android: &lt;dependency&gt; &lt;groupId&gt;org.web3j&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.1-android&lt;/version&gt; &lt;/dependency&gt; Gradle Java 8: compile (&#39;org.web3j:core:3.4.0&#39;) Android: compile (&#39;org.web3j:core:3.3.1-android&#39;) 启动客户端 需要启动一个以太坊客户端，当然如果你已经启动了就不需要再次启动。 如果是geth的话这么启动： $ geth --rpcapi personal,db,eth,net,web3 --rpc --rinkeby 如果是Parity启动： $ parity --chain testnet 如果使用Infura客户端提供的免费的云端服务，这么启动： Web3j web3 = Web3j.build(new HttpService(&quot;https://morden.infura.io/your-token&quot;)); 如果想进一步的了解infura，请参阅Using Infura with web3j。 在网络上如何获得以太币的相关文档可以看这个：testnet section of the docs。 当不需要Web3j实例时，需要调用shutdown方法来释放它所使用的资源。 web3.shutdown() 发送请求 发送同步请求 Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); * 使用CompletableFuture (Future on Android) 发送异步请求* Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().sendAsync().get(); String clientVersion = web3ClientVersion.getWeb3ClientVersion(); *使用RxJava的Observable Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ web3.web3ClientVersion().observable().subscribe(x -&gt; { String clientVersion = x.getWeb3ClientVersion(); ... }); 注意Android使用方式 Web3j web3 = Web3jFactory.build(new HttpService()); // defaults to http://localhost:8545/ ... IPC Web3j还支持通过文件套接字快速运行进程间通信（IPC），支持客户端在相同的主机上同时运行Web3j。在创建服务时，使用相关的IPCService就可以实现而不需要通过HTTPService。 // OS X/Linux/Unix: Web3j web3 = Web3j.build(new UnixIpcService(&quot;/path/to/socketfile&quot;)); ... // Windows Web3j web3 = Web3j.build(new WindowsIpcService(&quot;/path/to/namedpipefile&quot;)); ... 需要注意：IPC通信在web3j-android中不可用。 通过java打包以太坊智能合约 Web3j可以自动打包智能合同代码，以便在不脱离JVM的情况下进行以太坊智能合同部署和交互。 要打包代码，需要先编译智能合同： $ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/ 然后用web3j的命令行工具打包代码： web3j solidity generate /path/to/&lt;smart-contract&gt;.bin /path/to/&lt;smart-contract&gt;.abi -o /path/to/src/main/java -p com.your.organisation.name 接下来就可以新建和部署智能合约了： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); YourSmartContract contract = YourSmartContract.deploy( &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT, &lt;param1&gt;, ..., &lt;paramN&gt;).send(); // constructor params 或者使用一个现有的智能合约： YourSmartContract contract = YourSmartContract.load( &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, &lt;web3j&gt;, &lt;credentials&gt;, GAS_PRICE, GAS_LIMIT); 然后就可以进行智能合约的交互了： TransactionReceipt transactionReceipt = contract.someMethod( &lt;param1&gt;, ...).send(); 调用智能合约： Type result = contract.someMethod(&lt;param1&gt;, ...).send(); 更多关于打包的资料可以看这里：Solidity smart contract wrappers Filters web3j的响应式函数可以使观察者通过事件去通知消息订阅者变得很简单，并能够记录在区块链中。接收所有新的区块并把它们添加到区块链中： Subscription subscription = web3j.blockObservable(false).subscribe(block -&gt; { ... }); 接收所有新的交易并把它们添加到区块链中： Subscription subscription = web3j.transactionObservable().subscribe(tx -&gt; { ... }); 接收所有已经提交到网络中等待处理的交易。(他们被统一的分配到一个区块之前。) Subscription subscription = web3j.pendingTransactionObservable().subscribe(tx -&gt; { ... }); 或者你重置所有的区块到最新的位置，那么当有新建区块的时候会通知你。 Subscription subscription = catchUpToLatestAndSubscribeToNewBlocksObservable( &lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;) .subscribe(block -&gt; { ... }); 主题过滤也被支持： EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST, &lt;contract-address&gt;) .addSingleTopic(...)|.addOptionalTopics(..., ...)|...; web3j.ethLogObservable(filter).subscribe(log -&gt; { ... }); 当不再需要时，订阅也应该被取消： subscription.unsubscribe(); 注意：Infura中不支持filters。 需要了解更多有关过滤器和事件的信息可以查看Filters and Events和Web3jRx的接口。 交易 Web3j支持使用以太坊钱包文件（推荐的）和用于发送事务的以太坊客户端管理命令。 使用以太钱包文件发送以太币给其他人： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); TransactionReceipt transactionReceipt = Transfer.sendFunds( web3, credentials, &quot;0x&lt;address&gt;|&lt;ensName&gt;&quot;, BigDecimal.valueOf(1.0), Convert.Unit.ETHER) .send(); 或者你希望建立你自己定制的交易： Web3j web3 = Web3j.build(new HttpService()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils.loadCredentials(&quot;password&quot;, &quot;/path/to/walletfile&quot;); // get the next available nonce EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount( address, DefaultBlockParameterName.LATEST).send(); BigInteger nonce = ethGetTransactionCount.getTransactionCount(); // create our transaction RawTransaction rawTransaction = RawTransaction.createEtherTransaction( nonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;); // sign &amp; send our transaction byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials); String hexValue = Numeric.toHexString(signedMessage); EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send(); // ... 使用Web3j的Transfer进行以太币交易要简单得多。 使用以太坊客户端的管理命令（如果你的钱包密钥已经在客户端存储）： Admin web3j = Admin.build(new HttpService()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(&quot;0x000...&quot;, &quot;a password&quot;).sendAsync().get(); if (personalUnlockAccount.accountUnlocked()) { // send a transaction } 如果你想使用 Parity’s Personal 或者 Trace 功能, 或者 Geth’s Personal 客户端 APIs，可以使用org.web3j:parity和org.web3j:geth模块。 命令行工具 web3j的jar包为每一个版本都提供命令行工具。命令行工具允许你直接通过一些命令使用web3j的一些功能： 钱包创建 钱包密码管理 资金从钱包转移到另一个 solidity编写的智能合同功能打包 请参阅文档以获得命令行相关的进一步的信息。 其他的细节 java8 bulid： Web3j提供对所有响应类型的安全访问。可选的或null响应java 8都支持。 异步请求包在一个java 8的CompletableFutures。Web3j提供了围绕所有异步请求的打包工具，以确保在执行期间可以捕获任何异常，而不只是丢弃。由于在完全检查中会有很多缺少支持的异常情况，这些异常通常被确定为未检测到的异常，导致检测过程出现问题。有关详细信息，请参见 Async.run()及其关联 test。 在java 8的Android版本： 包数量作为 BigIntegers返回。对于简单的结果，可以通过Response.getResult()获取字符串类型的数量结果。 还可以通过在 HttpService和IpcService类中存在的includeRawResponse参数将原生的JSON包放置在响应中。 原文请访问：web3js开发以太坊智能合约快速入门 安利两个教程： 1.web3j教程，java和android app开发以太坊区块链类库web3j开发详解。 2.以太坊dapp，主要介绍智能合约与dapp应用开发，适合入门。 3.以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/18/2ae8e9905fbb9827e99ba751b9a67ad1.html","headline":"java类库web3j开发以太坊智能合约快速入门","dateModified":"2018-06-18T00:00:00+08:00","datePublished":"2018-06-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/18/2ae8e9905fbb9827e99ba751b9a67ad1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>java类库web3j开发以太坊智能合约快速入门</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1 id="web3j简介">web3j简介</h1> 
  <p>web3j是一个轻量级、高度模块化、响应式、类型安全的Java和Android类库提供丰富API，用于处理以太坊智能合约及与以太坊网络上的客户端(节点)进行集成。</p> 
  <p>可以通过它进行以太坊区块链的开发，而无需为你的java应用平台编写集成代码。</p> 
  <h1 id="快速启动">快速启动</h1> 
  <p>想要快速启动的话，有一个<a href="https://github.com/web3j/sample-project-gradle" rel="nofollow">Web3j demo示例项目</a>可用，演示了通过Web3j开发以太坊的许多核心特征，其中包括：</p> 
  <ul> 
   <li>连接到以太网网络上的节点</li> 
   <li>加载一个以太坊钱包文件</li> 
   <li>将以太币从一个地址发送到另一个地址</li> 
   <li>向网络部署智能合约</li> 
   <li>从部署的智能合约中读取值</li> 
   <li>更新部署的智能合约中的值</li> 
   <li>查看由智能合约记录的事件</li> 
  </ul> 
  <p>也有一个快速进入学习的交互式课程<a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=814csdn" rel="nofollow">web3j教程</a>可以尝试。</p> 
  <h1 id="web3j入门">web3j入门</h1> 
  <p>首先将最新版本的web3j安装到项目中。</p> 
  <h2 id="maven">Maven</h2> 
  <p><strong>Java 8:</strong></p> 
  <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.web3j<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>core<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.4.0<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre> 
  <p><strong>Android:</strong></p> 
  <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.web3j<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>core<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.3.1-android<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre> 
  <h2 id="gradle">Gradle</h2> 
  <p><strong>Java 8:</strong></p> 
  <pre class="prettyprint"><code class=" hljs bash">compile (<span class="hljs-string">'org.web3j:core:3.4.0'</span>)</code></pre> 
  <p><strong>Android:</strong></p> 
  <pre class="prettyprint"><code class=" hljs bash">compile (<span class="hljs-string">'org.web3j:core:3.3.1-android'</span>)</code></pre> 
  <h2 id="启动客户端">启动客户端</h2> 
  <p>需要启动一个以太坊客户端，当然如果你已经启动了就不需要再次启动。</p> 
  <p>如果是<a href="https://github.com/ethereum/go-ethereum/wiki/geth" rel="nofollow">geth</a>的话这么启动：</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">geth</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpcapi</span> <span class="hljs-comment">personal</span><span class="hljs-string">,</span><span class="hljs-comment">db</span><span class="hljs-string">,</span><span class="hljs-comment">eth</span><span class="hljs-string">,</span><span class="hljs-comment">net</span><span class="hljs-string">,</span><span class="hljs-comment">web3</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rpc</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rinkeby</span></code></pre> 
  <p>如果是<a href="https://github.com/paritytech/parity" rel="nofollow">Parity</a>启动：</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">parity</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">chain</span> <span class="hljs-comment">testnet</span></code></pre> 
  <p>如果使用<a href="https://infura.io/" rel="nofollow">Infura</a>客户端提供的免费的云端服务，这么启动：</p> 
  <pre class="prettyprint"><code class=" hljs cs">Web3j web3 = Web3j.build(<span class="hljs-keyword">new</span> HttpService(<span class="hljs-string">"https://morden.infura.io/your-token"</span>));</code></pre> 
  <p>如果想进一步的了解infura，请参阅<a href="https://docs.web3j.io/infura.html" rel="nofollow">Using Infura with web3j</a>。</p> 
  <p>在网络上如何获得以太币的相关文档可以看这个：<a href="https://docs.web3j.io/transactions.html#ethereum-testnets" rel="nofollow">testnet section of the docs</a>。</p> 
  <p>当不需要Web3j实例时，需要调用<code>shutdown</code>方法来释放它所使用的资源。</p> 
  <pre class="prettyprint"><code class=" hljs perl">web3.<span class="hljs-keyword">shutdown</span>()</code></pre> 
  <h2 id="发送请求">发送请求</h2> 
  <p><strong>发送同步请求</strong></p> 
  <pre class="prettyprint"><code class=" hljs avrasm">Web3j web3 = Web3j<span class="hljs-preprocessor">.build</span>(new HttpService())<span class="hljs-comment">; // defaults to http://localhost:8545/</span>
Web3ClientVersion web3ClientVersion = web3<span class="hljs-preprocessor">.web</span>3ClientVersion()<span class="hljs-preprocessor">.send</span>()<span class="hljs-comment">;</span>
String clientVersion = web3ClientVersion<span class="hljs-preprocessor">.getWeb</span>3ClientVersion()<span class="hljs-comment">;</span></code></pre> 
  <p><em>* 使用CompletableFuture (Future on Android) 发送异步请求*</em></p> 
  <pre class="prettyprint"><code class=" hljs avrasm">Web3j web3 = Web3j<span class="hljs-preprocessor">.build</span>(new HttpService())<span class="hljs-comment">; // defaults to http://localhost:8545/</span>
Web3ClientVersion web3ClientVersion = web3<span class="hljs-preprocessor">.web</span>3ClientVersion()<span class="hljs-preprocessor">.sendAsync</span>()<span class="hljs-preprocessor">.get</span>()<span class="hljs-comment">;</span>
String clientVersion = web3ClientVersion<span class="hljs-preprocessor">.getWeb</span>3ClientVersion()<span class="hljs-comment">;</span></code></pre> 
  <p><strong>*使用RxJava的Observable</strong></p> 
  <pre class="prettyprint"><code class=" hljs r">Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:<span class="hljs-number">8545</span>/
web3.web3ClientVersion().observable().subscribe(x -&gt; {
    String clientVersion = x.getWeb3ClientVersion();
    <span class="hljs-keyword">...</span>
});</code></pre> 
  <p><strong>注意Android使用方式</strong></p> 
  <pre class="prettyprint"><code class=" hljs r">Web3j web3 = Web3jFactory.build(new HttpService());  // defaults to http://localhost:<span class="hljs-number">8545</span>/
<span class="hljs-keyword">...</span></code></pre> 
  <h2 id="ipc">IPC</h2> 
  <p>Web3j还支持通过文件套接字快速运行进程间通信（IPC），支持客户端在相同的主机上同时运行Web3j。在创建服务时，使用相关的<code>IPCService</code>就可以实现而不需要通过<code>HTTPService</code>。</p> 
  <pre class="prettyprint"><code class=" hljs r">// OS X/Linux/Unix:
Web3j web3 = Web3j.build(new UnixIpcService(<span class="hljs-string">"/path/to/socketfile"</span>));
<span class="hljs-keyword">...</span>

// Windows
Web3j web3 = Web3j.build(new WindowsIpcService(<span class="hljs-string">"/path/to/namedpipefile"</span>));
<span class="hljs-keyword">...</span></code></pre> 
  <p><strong>需要注意：IPC通信在web3j-android中不可用。</strong></p> 
  <h2 id="通过java打包以太坊智能合约">通过java打包以太坊智能合约</h2> 
  <p>Web3j可以自动打包智能合同代码，以便在不脱离JVM的情况下进行以太坊智能合同部署和交互。</p> 
  <p>要打包代码，需要先编译智能合同：</p> 
  <pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">solc</span> &lt;<span class="hljs-comment">contract</span>&gt;<span class="hljs-string">.</span><span class="hljs-comment">sol</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">bin</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">abi</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">optimize</span> <span class="hljs-literal">-</span><span class="hljs-comment">o</span> &lt;<span class="hljs-comment">output</span><span class="hljs-literal">-</span><span class="hljs-comment">dir</span>&gt;<span class="hljs-comment">/</span></code></pre> 
  <p>然后用<a href="https://docs.web3j.io/command_line.html" rel="nofollow">web3j的命令行工具</a>打包代码：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">web3j solidity generate /path/<span class="hljs-keyword">to</span><span class="hljs-subst">/</span><span class="hljs-subst">&lt;</span>smart<span class="hljs-attribute">-contract</span><span class="hljs-subst">&gt;</span><span class="hljs-built_in">.</span>bin /path/<span class="hljs-keyword">to</span><span class="hljs-subst">/</span><span class="hljs-subst">&lt;</span>smart<span class="hljs-attribute">-contract</span><span class="hljs-subst">&gt;</span><span class="hljs-built_in">.</span>abi <span class="hljs-attribute">-o</span> /path/<span class="hljs-keyword">to</span>/src/main/java <span class="hljs-attribute">-p</span> com<span class="hljs-built_in">.</span>your<span class="hljs-built_in">.</span>organisation<span class="hljs-built_in">.</span>name</code></pre> 
  <p>接下来就可以新建和部署智能合约了：</p> 
  <pre class="prettyprint"><code class=" hljs r">Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:<span class="hljs-number">8545</span>/
Credentials credentials = WalletUtils.loadCredentials(<span class="hljs-string">"password"</span>, <span class="hljs-string">"/path/to/walletfile"</span>);

YourSmartContract contract = YourSmartContract.deploy(
        &lt;web3j&gt;, &lt;credentials&gt;,
        GAS_PRICE, GAS_LIMIT,
        &lt;param1&gt;, <span class="hljs-keyword">...</span>, &lt;paramN&gt;).send();  // constructor params</code></pre> 
  <p>或者使用一个现有的智能合约：</p> 
  <pre class="prettyprint"><code class=" hljs xml">YourSmartContract contract = YourSmartContract.load(
        "0x<span class="hljs-tag">&lt;<span class="hljs-title">address</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-title">ensName</span>&gt;</span>", <span class="hljs-tag">&lt;<span class="hljs-title">web3j</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-title">credentials</span>&gt;</span>, GAS_PRICE, GAS_LIMIT);</code></pre> 
  <p>然后就可以进行智能合约的交互了：</p> 
  <pre class="prettyprint"><code class=" hljs r">TransactionReceipt transactionReceipt = contract.someMethod(
             &lt;param1&gt;,
             <span class="hljs-keyword">...</span>).send();</code></pre> 
  <p>调用智能合约：</p> 
  <pre class="prettyprint"><code class=" hljs r">Type result = contract.someMethod(&lt;param1&gt;, <span class="hljs-keyword">...</span>).send();</code></pre> 
  <p>更多关于打包的资料可以看这里：<a href="https://docs.web3j.io/smart_contracts.html#smart-contract-wrappers" rel="nofollow">Solidity smart contract wrappers</a></p> 
  <h2 id="filters">Filters</h2> 
  <p>web3j的响应式函数可以使观察者通过事件去通知消息订阅者变得很简单，并能够记录在区块链中。接收所有新的区块并把它们添加到区块链中：</p> 
  <pre class="prettyprint"><code class=" hljs r">Subscription subscription = web3j.blockObservable(false).subscribe(block -&gt; {
    <span class="hljs-keyword">...</span>
});</code></pre> 
  <p>接收所有新的交易并把它们添加到区块链中：</p> 
  <pre class="prettyprint"><code class=" hljs r">Subscription subscription = web3j.transactionObservable().subscribe(tx -&gt; {
    <span class="hljs-keyword">...</span>
});</code></pre> 
  <p>接收所有已经提交到网络中等待处理的交易。(他们被统一的分配到一个区块之前。)</p> 
  <pre class="prettyprint"><code class=" hljs r">Subscription subscription = web3j.pendingTransactionObservable().subscribe(tx -&gt; {
    <span class="hljs-keyword">...</span>
});</code></pre> 
  <p>或者你重置所有的区块到最新的位置，那么当有新建区块的时候会通知你。</p> 
  <pre class="prettyprint"><code class=" hljs r">Subscription subscription = catchUpToLatestAndSubscribeToNewBlocksObservable(
        &lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;)
        .subscribe(block -&gt; {
            <span class="hljs-keyword">...</span>
});</code></pre> 
  <p><strong>主题过滤</strong>也被支持：</p> 
  <pre class="prettyprint"><code class=" hljs r">EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
        DefaultBlockParameterName.LATEST, &lt;contract-address&gt;)
             .addSingleTopic(<span class="hljs-keyword">...</span>)|.addOptionalTopics(<span class="hljs-keyword">...</span>, <span class="hljs-keyword">...</span>)|<span class="hljs-keyword">...</span>;
web3j.ethLogObservable(filter).subscribe(log -&gt; {
    <span class="hljs-keyword">...</span>
});</code></pre> 
  <p>当不再需要时，订阅也应该被取消：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">subscription<span class="hljs-preprocessor">.unsubscribe</span>()<span class="hljs-comment">;</span></code></pre> 
  <p><strong>注意：Infura中不支持filters。 </strong></p> 
  <p>需要了解更多有关过滤器和事件的信息可以查看<a href="https://docs.web3j.io/filters.html" rel="nofollow">Filters and Events</a>和<a href="https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/rx/Web3jRx.java" rel="nofollow">Web3jRx</a>的接口。</p> 
  <h2 id="交易">交易</h2> 
  <p>Web3j支持使用以太坊钱包文件（推荐的）和用于发送事务的以太坊客户端管理命令。</p> 
  <p>使用以太钱包文件发送以太币给其他人：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">Web3j web3 = Web3j<span class="hljs-preprocessor">.build</span>(new HttpService())<span class="hljs-comment">; // defaults to http://localhost:8545/</span>
Credentials credentials = WalletUtils<span class="hljs-preprocessor">.loadCredentials</span>(<span class="hljs-string">"password"</span>, <span class="hljs-string">"/path/to/walletfile"</span>)<span class="hljs-comment">;</span>
TransactionReceipt transactionReceipt = Transfer<span class="hljs-preprocessor">.sendFunds</span>(
        web3, credentials, <span class="hljs-string">"0x&lt;address&gt;|&lt;ensName&gt;"</span>,
        BigDecimal<span class="hljs-preprocessor">.valueOf</span>(<span class="hljs-number">1.0</span>), Convert<span class="hljs-preprocessor">.Unit</span><span class="hljs-preprocessor">.ETHER</span>)
        <span class="hljs-preprocessor">.send</span>()<span class="hljs-comment">;</span></code></pre> 
  <p>或者你希望建立你自己定制的交易：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">Web3j web3 = Web3j<span class="hljs-preprocessor">.build</span>(new HttpService())<span class="hljs-comment">; // defaults to http://localhost:8545/</span>
Credentials credentials = WalletUtils<span class="hljs-preprocessor">.loadCredentials</span>(<span class="hljs-string">"password"</span>, <span class="hljs-string">"/path/to/walletfile"</span>)<span class="hljs-comment">;</span>

// get the next available nonce
EthGetTransactionCount ethGetTransactionCount = web3j<span class="hljs-preprocessor">.ethGetTransactionCount</span>(
             address, DefaultBlockParameterName<span class="hljs-preprocessor">.LATEST</span>)<span class="hljs-preprocessor">.send</span>()<span class="hljs-comment">;</span>
BigInteger nonce = ethGetTransactionCount<span class="hljs-preprocessor">.getTransactionCount</span>()<span class="hljs-comment">;</span>

// create our transaction
RawTransaction rawTransaction  = RawTransaction<span class="hljs-preprocessor">.createEtherTransaction</span>(
             nonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;)<span class="hljs-comment">;</span>

// sign &amp; send our transaction
byte[] signedMessage = TransactionEncoder<span class="hljs-preprocessor">.signMessage</span>(rawTransaction, credentials)<span class="hljs-comment">;</span>
String hexValue = Numeric<span class="hljs-preprocessor">.toHexString</span>(signedMessage)<span class="hljs-comment">;</span>
EthSendTransaction ethSendTransaction = web3j<span class="hljs-preprocessor">.ethSendRawTransaction</span>(hexValue)<span class="hljs-preprocessor">.send</span>()<span class="hljs-comment">;</span>
// ...</code></pre> 
  <p>使用Web3j的<a href="https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/Transfer.java" rel="nofollow">Transfer</a>进行以太币交易要简单得多。</p> 
  <p>使用以太坊客户端的管理命令（如果你的钱包密钥已经在客户端存储）：</p> 
  <pre class="prettyprint"><code class=" hljs cs">Admin web3j = Admin.build(<span class="hljs-keyword">new</span> HttpService());  <span class="hljs-comment">// defaults to http://localhost:8545/</span>
PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(<span class="hljs-string">"0x000..."</span>, <span class="hljs-string">"a password"</span>).sendAsync().<span class="hljs-keyword">get</span>();
<span class="hljs-keyword">if</span> (personalUnlockAccount.accountUnlocked()) {
    <span class="hljs-comment">// send a transaction</span>
}</code></pre> 
  <p>如果你想使用 <a href="https://github.com/paritytech/parity/wiki/JSONRPC-personal-module" rel="nofollow">Parity’s Personal</a> 或者 <a href="https://github.com/paritytech/parity/wiki/JSONRPC-trace-module" rel="nofollow">Trace</a> 功能, 或者 Geth’s <a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal" rel="nofollow">Personal</a> 客户端 APIs，可以使用<code>org.web3j:parity</code>和<code>org.web3j:geth</code>模块。</p> 
  <h2 id="命令行工具">命令行工具</h2> 
  <p>web3j的jar包为每一个版本都提供命令行工具。命令行工具允许你直接通过一些命令使用web3j的一些功能：</p> 
  <ul> 
   <li>钱包创建</li> 
   <li>钱包密码管理</li> 
   <li>资金从钱包转移到另一个</li> 
   <li>solidity编写的智能合同功能打包</li> 
  </ul> 
  <p>请参阅<a href="https://docs.web3j.io/command_line.html" rel="nofollow">文档</a>以获得命令行相关的进一步的信息。</p> 
  <h2 id="其他的细节">其他的细节</h2> 
  <p><strong>java8 bulid：</strong></p> 
  <ul> 
   <li>Web3j提供对所有响应类型的安全访问。可选的或null响应java 8都支持。</li> 
   <li>异步请求包在一个java 8的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="nofollow">CompletableFutures</a>。Web3j提供了围绕所有异步请求的打包工具，以确保在执行期间可以捕获任何异常，而不只是丢弃。由于在完全检查中会有很多缺少支持的异常情况，这些异常通常被确定为未检测到的异常，导致检测过程出现问题。有关详细信息，请参见 <a href="https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/utils/Async.java" rel="nofollow">Async.run()</a>及其关联 <a href="https://github.com/web3j/web3j/blob/master/core/src/test/java/org/web3j/utils/AsyncTest.java" rel="nofollow">test</a>。</li> 
  </ul> 
  <p><strong>在java 8的Android版本：</strong></p> 
  <ul> 
   <li>包数量作为 <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html" rel="nofollow">BigIntegers</a>返回。对于简单的结果，可以通过<code>Response.getResult()</code>获取字符串类型的数量结果。</li> 
   <li>还可以通过在 HttpService和IpcService类中存在的<code>includeRawResponse</code>参数将原生的JSON包放置在响应中。</li> 
  </ul> 
  <p>原文请访问：<a href="http://blog.hubwiz.com/2018/06/17/web3j-Getting-Started/" rel="nofollow">web3js</a>开发以太坊智能合约快速入门</p> 
  <p>安利两个教程： <br> 1.<a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=626csdn" rel="nofollow">web3j教程</a>，java和android app开发以太坊区块链类库web3j开发详解。 <br> 2.<a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=618csdn" rel="nofollow">以太坊dapp</a>，主要介绍智能合约与dapp应用开发，适合入门。 <br> 3.<a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=618csdn" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-f77b6af6fd.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80721342,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80721342,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
