<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链系列（四）之比特币密钥和地址 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链系列（四）之比特币密钥和地址" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文个人博客地址：http://www.huweihuang.com/article/blockchain/blockchain-keys&amp;addresses/ 1. 比特币密钥 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥不存在网络中，而由用户生成，存储在一个文件或简单的数据库中，一般称之为钱包。 比特币交易都需要一个有效的签名才会被存储到区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有密钥副本就拥有了该账户的比特币控制权。 密钥是成对出现的，由公钥和私钥组成。公钥类似银行账号，私钥类似支票签名。在比特币交易环节， 收款人的公钥是通过数字指纹代表的，称之为比特币地址，类似支票上的收款方。一般情况，比特币地址由一个公钥生成并对应于这个公钥。 1.1. 公钥加密和加密货币 比特币使用椭圆曲线算法作为公钥加密的基础，椭圆曲线算法是一个不可逆的函数，即可以由A生成B，但不能由B推导出A。 在比特币系统中，用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥和由其衍生的唯一公钥。公钥用于接收比特币，私钥用于比特币支付时的交易签名。由私钥生产的签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名，比特币的所有人都可以通过提交的公钥和签名验证该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 1.2. 私钥和公钥 比特币包含一系列密钥对，每个密钥对包含一个公钥和私钥。私钥是一个随机数，私钥通过椭圆曲线算法生成公钥，公钥再通过单向加密哈希函数生成比特币地址。比特币使用非对称加密，使得签名只能由私钥产生，且在不泄露私钥情况下所有人都可以验证该签名p。 1.3. 私钥 私钥可以理解为一个随机数，比特币地址中资金的控制取决于相应私钥的控制权，比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。 从随机数生成私钥 选择随机性来源（熵源），生成一个比特币私钥在本质上与“在1到 2256 2 256 之间选一个数字”无异。建议使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。 1.4.公钥 通过椭圆曲线算法可以由私钥生成公钥，该过程是不可逆的过程：K（公钥）=k（私钥）*G（常数点）。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是极其困难的。 1.5. 椭圆曲线算法 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。 secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2 = (x3 + 7)} over (F*p*) 或 y2 mod p = (x3 + 7) mod p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作F*p*，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1，这是一个非常大的素数。 在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 1.6. 生成公钥 以一个随机生成的私钥k为起点，将其与曲线上已定义的生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的，所以一个私钥k对应唯一的一个公钥K，只能单向运算，即不能由公钥K得出私钥k。 {K = k * G} 示例： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 2. 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以公开，由公钥生成的比特币地址一般以数字1开头。 例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在比特币交易中，比特币地址一般用来表示收款方。 比特币地址由公钥经过单向加密哈希算法得到，哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。由公钥生成比特币地址时使用的算法如下： Secure Hash Algorithm (SHA) the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)， 特别是SHA256和RIPEMD160。 示例： # K是公钥，A是生成的比特币地址。 A = RIPEMD160(SHA256(K)) 通常用户见到的比特币地址是经过Base58Check编码的，该编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。 由公钥生成比特币地址的过程： 2.1. Base58和Base58Check编码 2.1.1. Base58 Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。 特点： 数据压缩 易读性 错误诊断功能 Base58是Base64编码格式的子集，使用大小写字母和10个数字，舍弃了一些容易错读和在特定字体中容易混淆的字符。Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。 即Base58就是由不包括（0，O，l，I）的大小写字母和数字组成（26+26+10-4=58）。 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 2.1.2. Base58Check Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式。 Base58Check编码增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。 示例： checksum = SHA256(SHA256(prefix+data)) 结果由三部分组成：前缀、数据和校验码。 Base58Check编码的过程 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 2.2. 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 2.2.1. 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。 1）私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 2）同样的私钥，不同的格式 以下展示了用这三种格式所生成的私钥。 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 3）不同编码格式的转换 将Base58Check编码解码为十六进制 $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 将十六进制转换为Base58Check编码 $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 2.2.2. 公钥的格式 公钥也可以用不同的格式来表示，主要分为非压缩格式和压缩格式两种形式。 公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 公钥的组成格式：04&lt;x&gt;&lt;y&gt; 示例： # x,y值 x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB # 公钥K K=04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 1）压缩格式公钥 压缩格式公钥主要为了减少比特币交易的字节数，节省运行区块链数据库节点的磁盘空间。原先公钥有520比特（包括前缀，x坐标，y坐标）。公钥是椭圆曲线上（y2mod p = (x3 + 7) mod p）的一个点（x,y），已知x坐标，可以解方程得出y，即可省去y坐标的存储，可以减少一半字节数的存储。 压缩格式公钥的前缀是02和03，因为解方程的y值有正数和负数两个值，当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。 示例： # 前缀03，表示y坐标是奇数 K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 公钥压缩示意图： 2）压缩格式私钥 压缩的私钥实际上只是表示“用于生成压缩格式公钥的私钥”，而非压缩格式私钥用来表明“用于生成非压缩格式公钥的私钥”。当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。 同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD*01* WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc 阅读更多" />
<meta property="og:description" content="本文个人博客地址：http://www.huweihuang.com/article/blockchain/blockchain-keys&amp;addresses/ 1. 比特币密钥 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥不存在网络中，而由用户生成，存储在一个文件或简单的数据库中，一般称之为钱包。 比特币交易都需要一个有效的签名才会被存储到区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有密钥副本就拥有了该账户的比特币控制权。 密钥是成对出现的，由公钥和私钥组成。公钥类似银行账号，私钥类似支票签名。在比特币交易环节， 收款人的公钥是通过数字指纹代表的，称之为比特币地址，类似支票上的收款方。一般情况，比特币地址由一个公钥生成并对应于这个公钥。 1.1. 公钥加密和加密货币 比特币使用椭圆曲线算法作为公钥加密的基础，椭圆曲线算法是一个不可逆的函数，即可以由A生成B，但不能由B推导出A。 在比特币系统中，用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥和由其衍生的唯一公钥。公钥用于接收比特币，私钥用于比特币支付时的交易签名。由私钥生产的签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名，比特币的所有人都可以通过提交的公钥和签名验证该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 1.2. 私钥和公钥 比特币包含一系列密钥对，每个密钥对包含一个公钥和私钥。私钥是一个随机数，私钥通过椭圆曲线算法生成公钥，公钥再通过单向加密哈希函数生成比特币地址。比特币使用非对称加密，使得签名只能由私钥产生，且在不泄露私钥情况下所有人都可以验证该签名p。 1.3. 私钥 私钥可以理解为一个随机数，比特币地址中资金的控制取决于相应私钥的控制权，比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。 从随机数生成私钥 选择随机性来源（熵源），生成一个比特币私钥在本质上与“在1到 2256 2 256 之间选一个数字”无异。建议使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。 1.4.公钥 通过椭圆曲线算法可以由私钥生成公钥，该过程是不可逆的过程：K（公钥）=k（私钥）*G（常数点）。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是极其困难的。 1.5. 椭圆曲线算法 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。 secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2 = (x3 + 7)} over (F*p*) 或 y2 mod p = (x3 + 7) mod p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作F*p*，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1，这是一个非常大的素数。 在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 1.6. 生成公钥 以一个随机生成的私钥k为起点，将其与曲线上已定义的生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的，所以一个私钥k对应唯一的一个公钥K，只能单向运算，即不能由公钥K得出私钥k。 {K = k * G} 示例： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 2. 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以公开，由公钥生成的比特币地址一般以数字1开头。 例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在比特币交易中，比特币地址一般用来表示收款方。 比特币地址由公钥经过单向加密哈希算法得到，哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。由公钥生成比特币地址时使用的算法如下： Secure Hash Algorithm (SHA) the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)， 特别是SHA256和RIPEMD160。 示例： # K是公钥，A是生成的比特币地址。 A = RIPEMD160(SHA256(K)) 通常用户见到的比特币地址是经过Base58Check编码的，该编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。 由公钥生成比特币地址的过程： 2.1. Base58和Base58Check编码 2.1.1. Base58 Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。 特点： 数据压缩 易读性 错误诊断功能 Base58是Base64编码格式的子集，使用大小写字母和10个数字，舍弃了一些容易错读和在特定字体中容易混淆的字符。Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。 即Base58就是由不包括（0，O，l，I）的大小写字母和数字组成（26+26+10-4=58）。 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 2.1.2. Base58Check Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式。 Base58Check编码增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。 示例： checksum = SHA256(SHA256(prefix+data)) 结果由三部分组成：前缀、数据和校验码。 Base58Check编码的过程 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 2.2. 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 2.2.1. 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。 1）私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 2）同样的私钥，不同的格式 以下展示了用这三种格式所生成的私钥。 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 3）不同编码格式的转换 将Base58Check编码解码为十六进制 $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 将十六进制转换为Base58Check编码 $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 2.2.2. 公钥的格式 公钥也可以用不同的格式来表示，主要分为非压缩格式和压缩格式两种形式。 公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 公钥的组成格式：04&lt;x&gt;&lt;y&gt; 示例： # x,y值 x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB # 公钥K K=04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 1）压缩格式公钥 压缩格式公钥主要为了减少比特币交易的字节数，节省运行区块链数据库节点的磁盘空间。原先公钥有520比特（包括前缀，x坐标，y坐标）。公钥是椭圆曲线上（y2mod p = (x3 + 7) mod p）的一个点（x,y），已知x坐标，可以解方程得出y，即可省去y坐标的存储，可以减少一半字节数的存储。 压缩格式公钥的前缀是02和03，因为解方程的y值有正数和负数两个值，当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。 示例： # 前缀03，表示y坐标是奇数 K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 公钥压缩示意图： 2）压缩格式私钥 压缩的私钥实际上只是表示“用于生成压缩格式公钥的私钥”，而非压缩格式私钥用来表明“用于生成非压缩格式公钥的私钥”。当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。 同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD*01* WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文个人博客地址：http://www.huweihuang.com/article/blockchain/blockchain-keys&amp;addresses/ 1. 比特币密钥 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥不存在网络中，而由用户生成，存储在一个文件或简单的数据库中，一般称之为钱包。 比特币交易都需要一个有效的签名才会被存储到区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有密钥副本就拥有了该账户的比特币控制权。 密钥是成对出现的，由公钥和私钥组成。公钥类似银行账号，私钥类似支票签名。在比特币交易环节， 收款人的公钥是通过数字指纹代表的，称之为比特币地址，类似支票上的收款方。一般情况，比特币地址由一个公钥生成并对应于这个公钥。 1.1. 公钥加密和加密货币 比特币使用椭圆曲线算法作为公钥加密的基础，椭圆曲线算法是一个不可逆的函数，即可以由A生成B，但不能由B推导出A。 在比特币系统中，用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥和由其衍生的唯一公钥。公钥用于接收比特币，私钥用于比特币支付时的交易签名。由私钥生产的签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名，比特币的所有人都可以通过提交的公钥和签名验证该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 1.2. 私钥和公钥 比特币包含一系列密钥对，每个密钥对包含一个公钥和私钥。私钥是一个随机数，私钥通过椭圆曲线算法生成公钥，公钥再通过单向加密哈希函数生成比特币地址。比特币使用非对称加密，使得签名只能由私钥产生，且在不泄露私钥情况下所有人都可以验证该签名p。 1.3. 私钥 私钥可以理解为一个随机数，比特币地址中资金的控制取决于相应私钥的控制权，比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。 从随机数生成私钥 选择随机性来源（熵源），生成一个比特币私钥在本质上与“在1到 2256 2 256 之间选一个数字”无异。建议使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。 1.4.公钥 通过椭圆曲线算法可以由私钥生成公钥，该过程是不可逆的过程：K（公钥）=k（私钥）*G（常数点）。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是极其困难的。 1.5. 椭圆曲线算法 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。 secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2 = (x3 + 7)} over (F*p*) 或 y2 mod p = (x3 + 7) mod p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作F*p*，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1，这是一个非常大的素数。 在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 1.6. 生成公钥 以一个随机生成的私钥k为起点，将其与曲线上已定义的生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的，所以一个私钥k对应唯一的一个公钥K，只能单向运算，即不能由公钥K得出私钥k。 {K = k * G} 示例： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 2. 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以公开，由公钥生成的比特币地址一般以数字1开头。 例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在比特币交易中，比特币地址一般用来表示收款方。 比特币地址由公钥经过单向加密哈希算法得到，哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。由公钥生成比特币地址时使用的算法如下： Secure Hash Algorithm (SHA) the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)， 特别是SHA256和RIPEMD160。 示例： # K是公钥，A是生成的比特币地址。 A = RIPEMD160(SHA256(K)) 通常用户见到的比特币地址是经过Base58Check编码的，该编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。 由公钥生成比特币地址的过程： 2.1. Base58和Base58Check编码 2.1.1. Base58 Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。 特点： 数据压缩 易读性 错误诊断功能 Base58是Base64编码格式的子集，使用大小写字母和10个数字，舍弃了一些容易错读和在特定字体中容易混淆的字符。Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。 即Base58就是由不包括（0，O，l，I）的大小写字母和数字组成（26+26+10-4=58）。 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 2.1.2. Base58Check Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式。 Base58Check编码增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。 示例： checksum = SHA256(SHA256(prefix+data)) 结果由三部分组成：前缀、数据和校验码。 Base58Check编码的过程 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 2.2. 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 2.2.1. 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。 1）私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 2）同样的私钥，不同的格式 以下展示了用这三种格式所生成的私钥。 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 3）不同编码格式的转换 将Base58Check编码解码为十六进制 $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 将十六进制转换为Base58Check编码 $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 2.2.2. 公钥的格式 公钥也可以用不同的格式来表示，主要分为非压缩格式和压缩格式两种形式。 公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 公钥的组成格式：04&lt;x&gt;&lt;y&gt; 示例： # x,y值 x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB # 公钥K K=04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 1）压缩格式公钥 压缩格式公钥主要为了减少比特币交易的字节数，节省运行区块链数据库节点的磁盘空间。原先公钥有520比特（包括前缀，x坐标，y坐标）。公钥是椭圆曲线上（y2mod p = (x3 + 7) mod p）的一个点（x,y），已知x坐标，可以解方程得出y，即可省去y坐标的存储，可以减少一半字节数的存储。 压缩格式公钥的前缀是02和03，因为解方程的y值有正数和负数两个值，当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。 示例： # 前缀03，表示y坐标是奇数 K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 公钥压缩示意图： 2）压缩格式私钥 压缩的私钥实际上只是表示“用于生成压缩格式公钥的私钥”，而非压缩格式私钥用来表明“用于生成非压缩格式公钥的私钥”。当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。 同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD*01* WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc 阅读更多","@type":"BlogPosting","url":"/2018/06/22/5ba096bea6266279d7ee3f82f20c1ee7.html","headline":"区块链系列（四）之比特币密钥和地址","dateModified":"2018-06-22T00:00:00+08:00","datePublished":"2018-06-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/06/22/5ba096bea6266279d7ee3f82f20c1ee7.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链系列（四）之比特币密钥和地址</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p>本文个人博客地址：<a href="http://www.huweihuang.com/article/blockchain/blockchain-keys&amp;addresses/" rel="nofollow">http://www.huweihuang.com/article/blockchain/blockchain-keys&amp;addresses/</a></p> 
  </blockquote> 
  <h2 id="1-比特币密钥">1. 比特币密钥</h2> 
  <p>比特币的所有权是通过<code>数字密钥</code>、<code>比特币地址</code>和<code>数字签名</code>来确定的，数字密钥不存在网络中，而由用户生成，存储在一个文件或简单的数据库中，一般称之为<code>钱包</code>。</p> 
  <p>比特币交易都需要一个有效的签名才会被存储到区块链中，只有有效的密钥才能产生有效的数字签名，因此<code>拥有密钥副本就拥有了该账户的比特币控制权</code>。</p> 
  <p>密钥是成对出现的，由<code>公钥</code>和<code>私钥</code>组成。公钥类似银行账号，私钥类似支票签名。在比特币交易环节， 收款人的公钥是通过数字指纹代表的，称之为<code>比特币地址</code>，类似支票上的收款方。一般情况，比特币地址由一个公钥生成并对应于这个公钥。</p> 
  <h3 id="11-公钥加密和加密货币">1.1. 公钥加密和加密货币</h3> 
  <p>比特币使用<code>椭圆曲线算法</code>作为公钥加密的基础，椭圆曲线算法是一个<code>不可逆</code>的函数，即可以由A生成B，但不能由B推导出A。</p> 
  <p>在比特币系统中，用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥和由其衍生的唯一公钥。公钥用于接收比特币，私钥用于比特币支付时的交易签名。由私钥生产的签名可以在不泄露私钥的同时对公钥进行验证。</p> 
  <p>支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名，比特币的所有人都可以通过提交的公钥和签名验证该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。</p> 
  <h3 id="12-私钥和公钥">1.2. 私钥和公钥</h3> 
  <p>比特币包含一系列密钥对，每个密钥对包含一个公钥和私钥。<code>私钥</code>是一个随机数，私钥通过椭圆曲线算法生成<code>公钥</code>，<code>公钥</code>再通过单向加密哈希函数生成<code>比特币地址</code>。比特币使用非对称加密，使得签名只能由私钥产生，且在不泄露私钥情况下所有人都可以验证该签名p。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180622184625721?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1d2hf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="100%"></p> 
  <h3 id="13-私钥">1.3. 私钥</h3> 
  <p>私钥可以理解为一个<code>随机数</code>，<code>比特币地址中资金的控制取决于相应私钥的控制权</code>，比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。</p> 
  <p><strong>从随机数生成私钥</strong></p> 
  <p>选择随机性来源（<code>熵源</code>），生成一个比特币私钥在本质上与“在1到<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>256</mn></mrow></msup></math>" role="presentation">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-1" style="width: 1.982em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.617em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.096em, 1001.62em, 2.294em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="msubsup" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 1.617em; height: 0px;"><span style="position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mn" id="MathJax-Span-4" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -4.424em; left: 0.523em;"><span class="texatom" id="MathJax-Span-5"><span class="mrow" id="MathJax-Span-6"><span class="mn" id="MathJax-Span-7" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">256</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.191em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msup>
       <mn>
        2
       </mn>
       <mrow class="MJX-TeXAtom-ORD">
        <mn>
         256
        </mn>
       </mrow>
      </msup>
     </math></span></span><script type="math/tex" id="MathJax-Element-1">2^{256}</script>之间选一个数字”无异。建议使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。</p> 
  <h3 id="14公钥">1.4.公钥</h3> 
  <p>通过椭圆曲线算法可以由私钥生成公钥，该过程是<code>不可逆</code>的过程：<code>K（公钥）=k（私钥）*G（常数点）</code>。其反向运算，被称为“寻找离散对数”——已知公钥<code>K</code>来求出私钥<code>k</code>——是极其困难的。</p> 
  <h3 id="15-椭圆曲线算法">1.5. 椭圆曲线算法</h3> 
  <p><code>椭圆曲线加密法</code>是一种基于离散对数问题的<code>非对称</code>（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180622184726625?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1d2hf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%"></p> 
  <p>比特币使用了<code>secp256k1</code>标准所定义的一条特殊的椭圆曲线和一系列数学常数。</p> 
  <p><code>secp256k1</code>曲线由下述函数定义，该函数可产生一条椭圆曲线：</p> 
  <p>y2 = (x3 + 7)} over (F*p*)</p> 
  <p>或</p> 
  <p>y2 mod <em>p</em> = (x3 + 7) mod <em>p</em></p> 
  <p>上述<em>mod p</em>（素数p取模）表明该曲线是在素数阶<em>p</em>的有限域内，也写作F*p*，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1，这是一个非常大的素数。</p> 
  <p>在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。</p> 
  <h3 id="16-生成公钥">1.6. 生成公钥</h3> 
  <p>以一个随机生成的<code>私钥k</code>为起点，将其与曲线上已定义的<code>生成点G</code>相乘以获得曲线上的另一点，也就是相应的<code>公钥K</code>。生成点是<code>secp256k1标准</code>的一部分，<code>比特币密钥的生成点都是相同的</code>，所以一个<code>私钥k</code>对应唯一的一个<code>公钥K</code>，只能单向运算，即不能由<code>公钥K</code>得出<code>私钥k</code>。</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">{K </span>=<span class="hljs-string"> k * G}</span></code></pre> 
  <p>示例：</p> 
  <pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-constant">K</span> = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G

<span class="hljs-constant">K</span> = (x, y)
其中，
<span class="hljs-constant">x</span> = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
<span class="hljs-constant">y</span> = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code></pre> 
  <h2 id="2-比特币地址">2. 比特币地址</h2> 
  <p><code>比特币地址</code>是一个由数字和字母组成的<code>字符串</code>，可以公开，由公钥生成的比特币地址一般以数字<code>1</code>开头。</p> 
  <p>例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p> 
  <p>在比特币交易中，<code>比特币地址</code>一般用来表示<code>收款方</code>。</p> 
  <p>比特币地址由公钥经过<code>单向加密哈希算法</code>得到，哈希算法是一种<code>单向函数</code>，接收任意长度的输入产生指纹摘要。由公钥生成比特币地址时使用的算法如下：</p> 
  <ul> 
   <li><p>Secure Hash Algorithm (SHA)</p></li> 
   <li><p>the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，</p></li> 
  </ul> 
  <p>特别是<code>SHA256</code>和<code>RIPEMD160</code>。</p> 
  <p><strong>示例：</strong></p> 
  <pre class="prettyprint"><code class="language-shell hljs mathematica"># <span class="hljs-keyword">K</span>是公钥，A是生成的比特币地址。
A = RIPEMD160(SHA256(<span class="hljs-keyword">K</span>))</code></pre> 
  <p>通常用户见到的比特币地址是经过<code>Base58Check</code>编码的，该编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。</p> 
  <p><strong>由公钥生成比特币地址的过程：</strong></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180622184820652?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1d2hf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="60%"></p> 
  <h3 id="21-base58和base58check编码">2.1. Base58和Base58Check编码</h3> 
  <h4 id="211-base58">2.1.1. Base58</h4> 
  <p><code>Base58</code>是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。</p> 
  <p>特点：</p> 
  <ul> 
   <li>数据压缩</li> 
   <li>易读性</li> 
   <li>错误诊断功能</li> 
  </ul> 
  <p>Base58是Base64编码格式的子集，使用大小写字母和10个数字，舍弃了一些容易错读和在特定字体中容易混淆的字符。Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。</p> 
  <p>即<code>Base58就是由不包括（0，O，l，I）的大小写字母和数字组成</code>（26+26+10-4=58）。</p> 
  <p><strong>比特币的Base58字母表</strong></p> 
  <pre class="prettyprint"><code class=" hljs ">123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</code></pre> 
  <h4 id="212-base58check">2.1.2. Base58Check</h4> 
  <p><code>Base58Check</code>编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式。</p> 
  <p><code>Base58Check</code>编码增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。</p> 
  <p><strong>示例：</strong></p> 
  <pre class="prettyprint"><code class=" hljs haskell"> checksum = <span class="hljs-type">SHA256</span>(<span class="hljs-type">SHA256</span>(prefix+<span class="hljs-typedef"><span class="hljs-keyword">data</span>))</span></code></pre> 
  <p>结果由三部分组成：前缀、数据和校验码。</p> 
  <p><strong>Base58Check编码的过程</strong></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180622184930419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1d2hf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="70%"></p> 
  <p><strong>Base58Check版本前缀和编码后的结果</strong></p> 
  <table> 
   <thead> 
    <tr> 
     <th>种类</th> 
     <th>版本前缀 (hex)</th> 
     <th>Base58格式</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>Bitcoin Address</td> 
     <td>0x00</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>Pay-to-Script-Hash Address</td> 
     <td>0x05</td> 
     <td>3</td> 
    </tr> 
    <tr> 
     <td>Bitcoin Testnet Address</td> 
     <td>0x6F</td> 
     <td>m or n</td> 
    </tr> 
    <tr> 
     <td>Private Key WIF</td> 
     <td>0x80</td> 
     <td>5, K or L</td> 
    </tr> 
    <tr> 
     <td>BIP38 Encrypted Private Key</td> 
     <td>0x0142</td> 
     <td>6P</td> 
    </tr> 
    <tr> 
     <td>BIP32 Extended Public Key</td> 
     <td>0x0488B21E</td> 
     <td>xpub</td> 
    </tr> 
   </tbody>
  </table> 
  <h3 id="22-密钥的格式">2.2. 密钥的格式</h3> 
  <p>公钥和私钥的都可以有多种<code>编码格式</code>。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。</p> 
  <h4 id="221-私钥的格式">2.2.1. 私钥的格式</h4> 
  <p>私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。</p> 
  <p><strong>1）私钥表示法（编码格式）</strong></p> 
  <table> 
   <thead> 
    <tr> 
     <th>种类</th> 
     <th>版本</th> 
     <th>描述</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>Hex</td> 
     <td>None</td> 
     <td>64 hexadecimal digits</td> 
    </tr> 
    <tr> 
     <td>WIF</td> 
     <td>5</td> 
     <td>Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum</td> 
    </tr> 
    <tr> 
     <td>WIF-compressed</td> 
     <td>K or L</td> 
     <td>As above, with added suffix 0x01 before encoding</td> 
    </tr> 
   </tbody>
  </table> 
  <p><strong>2）同样的私钥，不同的格式</strong></p> 
  <p>以下展示了用这三种格式所生成的私钥。</p> 
  <table> 
   <thead> 
    <tr> 
     <th>格式</th> 
     <th>私钥</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>Hex</td> 
     <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</td> 
    </tr> 
    <tr> 
     <td>WIF</td> 
     <td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td> 
    </tr> 
    <tr> 
     <td>WIF-compressed</td> 
     <td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td> 
    </tr> 
   </tbody>
  </table> 
  <p>这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。</p> 
  <p><strong>3）不同编码格式的转换</strong></p> 
  <ol> 
   <li><p>将Base58Check编码解码为十六进制</p> <pre class="prettyprint"><code class="language-shell hljs ruby"><span class="hljs-variable">$ </span>sx base58check-decode <span class="hljs-number">5</span>J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
<span class="hljs-number">1</span>e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd <span class="hljs-number">128</span></code></pre></li> 
   <li><p>将十六进制转换为Base58Check编码</p> <pre class="prettyprint"><code class="language-shell hljs lasso"><span class="hljs-variable">$sx</span> base58check<span class="hljs-attribute">-encode</span> <span class="hljs-number">1e99423</span>a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd <span class="hljs-number">128</span> 
<span class="hljs-number">5</span>J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</code></pre></li> 
   <li><p>将十六进制（压缩格式密钥）转换为Base58Check编码</p> <pre class="prettyprint"><code class="language-shell hljs ruby"><span class="hljs-variable">$ </span>sx base58check-encode <span class="hljs-number">1</span>e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 <span class="hljs-number">128</span>
<span class="hljs-constant">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</span></code></pre></li> 
  </ol> 
  <h4 id="222-公钥的格式">2.2.2. 公钥的格式</h4> 
  <p>公钥也可以用不同的格式来表示，主要分为<code>非压缩格式</code>和<code>压缩格式</code>两种形式。</p> 
  <p>公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀<code>04</code>是用来区分<code>非压缩格式</code>公钥，<code>压缩格式</code>公钥是以<code>02</code>或者<code>03</code>开头。</p> 
  <p>公钥的组成格式：<code>04&lt;x&gt;&lt;y&gt;</code></p> 
  <p>示例：</p> 
  <pre class="prettyprint"><code class="language-shell hljs makefile"><span class="hljs-comment"># x,y值</span>
<span class="hljs-constant">x</span> = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
<span class="hljs-constant">y</span> = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB

<span class="hljs-comment"># 公钥K</span>
<span class="hljs-constant">K</span>=04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code></pre> 
  <p><strong>1）压缩格式公钥</strong></p> 
  <p>压缩格式公钥主要为了减少比特币交易的字节数，节省运行区块链数据库节点的磁盘空间。原先公钥有520比特（包括前缀，x坐标，y坐标）。公钥是椭圆曲线上（<code>y2mod p = (x3 + 7) mod p</code>）的一个点<code>（x,y）</code>，已知x坐标，可以解方程得出y，即可省去y坐标的存储，可以减少一半字节数的存储。</p> 
  <p>压缩格式公钥的前缀是<code>02</code>和<code>03</code>，因为解方程的y值有正数和负数两个值，当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。</p> 
  <p><strong>示例：</strong></p> 
  <pre class="prettyprint"><code class="language-shell hljs vala"><span class="hljs-preprocessor"># 前缀03，表示y坐标是奇数</span>
K = <span class="hljs-number">03</span>F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</code></pre> 
  <p><strong>公钥压缩示意图：</strong></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180622185020649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1d2hf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%"></p> 
  <p><strong>2）压缩格式私钥</strong></p> 
  <p><code>压缩的私钥</code>实际上只是表示“用于生成压缩格式公钥的私钥”，而<code>非压缩格式私钥</code>用来表明“用于生成非压缩格式公钥的私钥”。当一个私钥被使用<code>WIF压缩格式</code>导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。</p> 
  <p><strong>同样的私钥，不同的格式</strong></p> 
  <table> 
   <thead> 
    <tr> 
     <th>格式</th> 
     <th>私钥</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>Hex</td> 
     <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</td> 
    </tr> 
    <tr> 
     <td>WIF</td> 
     <td>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</td> 
    </tr> 
    <tr> 
     <td>Hex-compressed</td> 
     <td>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD*01*</td> 
    </tr> 
    <tr> 
     <td>WIF-compressed</td> 
     <td>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</td> 
    </tr> 
   </tbody>
  </table> 
  <p>参考：</p> 
  <ul> 
   <li><a href="https://bitcoinbook.info/" rel="nofollow">Mastering Bitcoin</a></li> 
   <li><a href="https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc" rel="nofollow">https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc</a></li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/huwh_/article/details/80777511,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/huwh_/article/details/80777511,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
