<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>geth源码阅读——交易流程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="geth源码阅读——交易流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、流程简介 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 二、源码分析 以太坊系列（ETH&amp;ETC）在发送交易有三个对应的RPC接口，分别是eth_sendTransaction、eth_sendRawTransaction和personal_sendTransaction。personal_sendTransaction很少听说，暂时不管。eth_sendRawTransaction接口必须附上已经计算好的签名，eth_sendTransaction不需要提前计算好签名，用法： eth.sendTransaction({from:acc0,to:acc1,value: web3.toWei(1)})&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //用于本地的两个账户eth.sendTransaction({from:&quot;0x51c641e9b2e9693d0f3c94e4cd804ae4eb9c8900&quot;,to: &quot;0x573dc3f3bdd9b9b579ee507412483cf43d9e7b08&quot;, value: amount}) 2.1 发起交易 //internal/ethapi/api/go // SendTransaction creates a transaction for the given argument, sign it and submit it to the transaction pool. func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { // Look up the wallet containing the requested signer account := accounts.Account{Address: args.From} wallet, err := s.b.AccountManager().Find(account) if err != nil { return common.Hash{}, err } if args.Nonce == nil { // Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of // the same nonce to multiple accounts. s.nonceLock.LockAddr(args.From) defer s.nonceLock.UnlockAddr(args.From) } // Set some sanity defaults and terminate on failure if err := args.setDefaults(ctx, s.b); err != nil { return common.Hash{}, err } // Assemble the transaction and sign with the wallet，封装一个transaction对象 tx := args.toTransaction() var chainID *big.Int if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { chainID = config.ChainID } signed, err := wallet.SignTx(account, tx, chainID) //签名 if err != nil { return common.Hash{}, err } return submitTransaction(ctx, s.b, signed) //提交Transaction对象到txpool } // SendRawTransaction will add the signed transaction to the transaction pool. // The sender is responsible for signing the transaction and using the correct nonce. func (s *PublicTransactionPoolAPI) SendRawTransaction(ctx context.Context, encodedTx hexutil.Bytes) (common.Hash, error) { tx := new(types.Transaction) //封装一个Transaction对象 if err := rlp.DecodeBytes(encodedTx, tx); err != nil { //对tx做rlpI编码 return common.Hash{}, err } return submitTransaction(ctx, s.b, tx) //提交交易到txpool }------------------------------------------------------------------- // submitTransaction is a helper function that submits tx to txPool and logs a message. func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { //发送交易，注意：Backend使用了多态，sendTx是txPool的接口，txPool根据light和full两种启动模式有两种类型，本文研究full模式的交易 if err := b. SendTx(ctx, tx); err != nil { return common.Hash{}, err } if tx.To() == nil { //to是空的，说明是部署合约 signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) from, err := types.Sender(signer, tx) if err != nil { return common.Hash{}, err } addr := crypto. CreateAddress(from, tx.Nonce()) //创建合约的地址 log.Info( &quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) } else { log.Info( &quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) } return tx.Hash(), nil}---------------------------------------------------------------------- func (b *EthAPIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { return b.eth.txPool.AddLocal(signedTx) }------------------------------------------------------------------------- // AddLocal enqueues a single transaction into the pool if it is valid, marking the sender as a local one in the mean time, // ensuring it goes around the local pricing constraint // 开始入池 func (pool *TxPool) AddLocal(tx *types.Transaction) error { return pool.addTx(tx, !pool.config.NoLocals) }--------------------------------------------------------------------------- // addTx enqueues a single transaction into the pool if it is valid. func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { pool.mu.Lock() defer pool.mu.Unlock() // Try to inject the transaction and update any state replace, err := pool.add(tx, local) if err != nil { return err } // If we added a new transaction, run promotion checks and return，如果是新交易，直接提交到可执行状态 if !replace { from, _ := types.Sender(pool.signer, tx) // already validated pool.promoteExecutables([]common.Address{from}) //提交到可执行队列 } return nil }----------------------------------------------------------------------------- // add validates a transaction and inserts it into the non-executable queue for add验证交易合法性并插入到非稳定队列 // later pending promotion and execution. If the transaction is a replacement for 如果是一个覆盖交易， // an already pending or queued one, it overwrites the previous and returns this 那么覆盖之前的交易 // so outer code doesn&#39;t uselessly call promote. // // If a newly added transaction is marked as local, its sending account will be 如果是新交易则标记为local // whitelisted, preventing any associated transaction from being dropped out of 则将发送账户列入白名单， // the pool due to pricing constraints. 防止任何关联的交易由于价格约束从池中退出 func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) { // If the transaction is already known, discard it hash := tx.Hash() if pool.all.Get(hash) != nil { //防止重复提交 log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) } // If the transaction fails basic validation, discard it，验证交易合法性 if err := pool.validateTx(tx, local); err != nil { log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) invalidTxCounter.Inc(1) return false, err } // If the transaction pool is full, discard underpriced transactions， 交易池已满，限制定价过低的交易入池 if uint64(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { // If the new transaction is underpriced, don&#39;t accept it if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) return false, ErrUnderpriced } // New transaction is better than our worse ones, make room for it drop := pool.priced.Discard(pool.all.Count()-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) for _, tx := range drop { log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) pool.removeTx(tx.Hash(), false) } } // If the transaction is replacing an already pending one, do directly， 交易是用来替换旧交易的，覆盖它 from, _ := types.Sender(pool.signer, tx) // already validated ，根据签名获取from地址 //pendding队列不为空，并且当前交易已经存在（需要覆盖） if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { // Nonce already pending, check if required price bump is met inserted, old := list.Add(tx, pool.config.PriceBump) //添加到pengding队列 if !inserted { pendingDiscardCounter.Inc(1) return false, ErrReplaceUnderpriced } // New transaction is better, replace old one if old != nil { pool.all.Remove(old.Hash()) //从all队列移除旧的 pool.priced.Removed() pendingReplaceCounter.Inc(1) } pool.all.Add(tx) //添加到all队列 pool.priced.Put(tx) pool.journalTx(from, tx) log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) // We&#39;ve directly injected a replacement transaction, notify subsystems，由于注入了一个replacement交易，通知所有子系统 go pool.txFeed.Send(NewTxsEvent{types.Transactions{tx}}) return old != nil, nil } // New transaction isn&#39;t replacing a pending one, push into queue，插入新交易到pool replace, err := pool.enqueueTx(hash, tx) if err != nil { return false, err } // Mark local addresses and journal local transactions if local { pool.locals.add(from) //插入到local队列 } pool.journalTx(from, tx) //将交易记录到pool的Jorunal中，Jorunal用来把本地交易写到磁盘来备份 log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) return replace, nil }----------------------------------------------------------------------------------- // validateTx checks whether a transaction is valid according to the consensus // rules and adheres to some heuristic limits of the local node (price and size). func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error { // Heuristic（启发式） limit, reject transactions over 32KB to prevent DOS attacks if tx.Size() &gt; 32*1024 { //超大的交易 return ErrOversizedData } // Transactions can&#39;t be negative. This may never happen using RLP decoded // transactions but may occur if you create a transaction using the RPC. if tx.Value().Sign() &lt; 0 { //签名不能是负的 return ErrNegativeValue } // Ensure the transaction doesn&#39;t exceed the current block limit gas. if pool.currentMaxGas &lt; tx.Gas() { //交易的最大汽油限制（GasLimit）不能超过池中汽油的最大值 return ErrGasLimit } // Make sure the transaction is signed properly from, err := types.Sender(pool.signer, tx) //根据签名获取from的地址 if err != nil { return ErrInvalidSender } // Drop non-local transactions under our own minimal accepted gas price local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 { //交易的汽油价格不能小于pool指定的汽油价格 return ErrUnderpriced } // Ensure the transaction adheres to nonce ordering if pool.currentState.GetNonce(from) &gt; tx.Nonce() { //nonce不能小于当前的nonce return ErrNonceTooLow } // Transactor should have enough funds to cover the costs // cost == V + GP * GL if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 { //汽油需要的量（amount+gasPrice*gasLimit）不能大于当前的余额 return ErrInsufficientFunds } //gasLimit一定要大于intrinsic gas, intrinsic gas 包括交易预定义费用 + 发送数据费用 + 创建合约费用 intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead) if err != nil { return err } if tx.Gas() &lt; intrGas { return ErrIntrinsicGas } return nil } ----------------------------------------------------------------------- promoteExecutables方法把 已经变得可以执行的交易从future queue 插入到pending queue。通过这个处理过程，所有的无效的交易(nonce太低，余额不足)会被删除。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // promoteExecutables moves transactions that have become processable from the &nbsp; &nbsp; // future queue to the set of pending transactions. During this process, all &nbsp; &nbsp; // invalidated transactions (low nonce, low balance) are deleted. &nbsp; &nbsp; func (pool *TxPool) promoteExecutables(accounts []common.Address) { &nbsp; &nbsp; &nbsp; &nbsp; // Gather all the accounts potentially needing updates &nbsp; &nbsp; &nbsp; &nbsp; // accounts存储了所有潜在需要更新的账户。 如果账户传入为nil，代表所有已知的账户。 &nbsp; &nbsp; &nbsp; &nbsp; if accounts == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = make([]common.Address, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, _ := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = append(accounts, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range accounts { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue // Just in case someone calls with a non existing account &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are deemed too old (low nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有的nonce太低的交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed old queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are too costly (low balance or out of gas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有余额不足的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range drops { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed unpayable queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedNofundsCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gather all executable transactions and promote them &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 得到所有的可以执行的交易，并promoteTx加入pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Promoting queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.promoteTx(addr, hash, tx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions over the allowed limit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有超过限制的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(int(pool.config.AccountQueue)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed cap-exceeding queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Delete the entire queue entry if it became empty. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.queue, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // If the pending limit is overflown, start equalizing allowances &nbsp; &nbsp; &nbsp; &nbsp; pending := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // 如果pending的总数超过系统的配置。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingBeforeCap := pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Assemble a spam order to penalize large transactors first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers := prque.New() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Only evict transactions from high rollers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先把所有大于AccountSlots最小值的账户记录下来， 会从这些账户里面剔除一些交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 注意spammers是一个优先级队列，也就是说是按照交易的多少从大到小排序的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers.Push(addr, float32(list.Len())) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gradually drop transactions from offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders := []common.Address{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Retrieve the next offender if not local address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offender, _ := spammers.Pop() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders = append(offenders, offender.(common.Address)) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Equalize balances until all the same or below threshold &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if len(offenders) &gt; 1 { // 第一次进入这个循环的时候， offenders队列里面有交易数量最大的两个账户 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Calculate the equalization threshold for all current offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 把最后加入的账户的交易数量当成本次的阈值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold := pool.pending[offender.(common.Address)].Len() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Iteratively reduce all offenders until below limit or threshold reached &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历直到pending有效，或者是倒数第二个的交易数量等于最后一个的交易数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历除了最后一个账户以外的所有账户， 把他们的交易数量减去1. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := 0; i &lt; len(offenders)-1; i++ { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[offenders[i]] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(offenders[i], nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If still above threshold, reduce to limit or min allowance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 经过上面的循环，所有的超过AccountSlots的账户的交易数量都变成了之前的最小值。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果还是超过阈值，那么在继续从offenders里面每次删除一个。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range offenders { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(addr, nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending)) &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; //end if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; // If we&#39;ve queued more transactions than the hard limit, drop oldest ones &nbsp; &nbsp; &nbsp; &nbsp; // 我们处理了pending的限制， 下面需要处理future queue的限制了。 &nbsp; &nbsp; &nbsp; &nbsp; queued := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queued += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if queued &gt; pool.config.GlobalQueue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sort all accounts with queued transactions by heartbeat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses := make(addresssByHeartbeat, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { // don&#39;t drop locals &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]}) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort.Sort(addresses) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop transactions until the total is below the limit or only locals remain &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从后往前，也就是心跳越新的就越会被删除。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr := addresses[len(addresses)-1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr.address] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = addresses[:len(addresses)-1] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions if they are less than the overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if size := uint64(list.Len()); size &lt;= drop { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Flatten() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(tx.Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop -= size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(int64(size)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Otherwise drop only last few transactions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txs := list.Flatten() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(txs[i].Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } Nonce使用规则 为了防止交易重播，ETH（ETC）节点要求每笔交易必须有一个nonce数值。 每一个账户从同一个节点发起交易时，这个nonce值从0开始计数，发送一笔nonce对应加1。 当前面的nonce处理完成之后才会处理后面的nonce。 注意这里的前提条件是相同的地址在相同的节点发送交易。 1.当nonce太小（小于之前已经有交易使用的nonce值），交易会被直接拒绝。 2.当nonce太大,交易会一直处于队列之中,这也就是导致我们上面描述的问题的原因； 3.当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。 4.当交易处于queue中时停止geth客户端，那么交易queue中的交易会被清除掉。 txPool 在创建的时候，开启了一个阻塞式线程，用于响应外部区块链事件，各种报告，或者交易回收 // loop is the transaction pool&#39;s main event loop, waiting for and reacting to // outside blockchain events as well as for various reporting and transaction // eviction events. func (pool *TxPool) loop() { defer pool.wg.Done() // Start the stats reporting and transaction eviction tickers var prevPending, prevQueued, prevStales int report := time.NewTicker(statsReportInterval) defer report.Stop() evict := time.NewTicker(evictionInterval) defer evict.Stop() journal := time.NewTicker(pool.config.Rejournal) defer journal.Stop() // Track the previous head headers for transaction reorgs head := pool.chain.CurrentBlock() // Keep waiting for and reacting to the various events for { select { // Handle ChainHeadEvent 区块链 head 事件 handle case ev := &lt;-pool.chainHeadCh: if ev.Block != nil { pool.mu.Lock() if pool.chainconfig.IsHomestead(ev.Block.Number()) { pool.homestead = true } pool.reset(head.Header(), ev.Block.Header()) head = ev.Block pool.mu.Unlock() } // Be unsubscribed due to system stopped，系统停止导致的注销 case &lt;-pool.chainHeadSub.Err(): return // Handle stats reporting ticks，统计报告时钟的handle case &lt;-report.C: pool.mu.RLock() pending, queued := pool.stats() stales := pool.priced.stales pool.mu.RUnlock() if pending != prevPending || queued != prevQueued || stales != prevStales { log.Debug(&quot;Transaction pool status report&quot;, &quot;executable&quot;, pending, &quot;queued&quot;, queued, &quot;stales&quot;, stales) prevPending, prevQueued, prevStales = pending, queued, stales } // Handle inactive account transaction eviction，不活跃的账户的交易回收handle case &lt;-evict.C: pool.mu.Lock() for addr := range pool.queue { // Skip local transactions from the eviction mechanism if pool.locals.contains(addr) { continue } // Any non-locals old enough should be removed if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime { for _, tx := range pool.queue[addr].Flatten() { pool.removeTx(tx.Hash(), true) } } } pool.mu.Unlock() // Handle local transaction journal rotation，本地交易journal轮询handle case &lt;-journal.C: if pool.journal != nil { pool.mu.Lock() if err := pool.journal.rotate(pool.local()); err != nil { log.Warn(&quot;Failed to rotate local tx journal&quot;, &quot;err&quot;, err) } pool.mu.Unlock() } } } } 阅读更多" />
<meta property="og:description" content="一、流程简介 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 二、源码分析 以太坊系列（ETH&amp;ETC）在发送交易有三个对应的RPC接口，分别是eth_sendTransaction、eth_sendRawTransaction和personal_sendTransaction。personal_sendTransaction很少听说，暂时不管。eth_sendRawTransaction接口必须附上已经计算好的签名，eth_sendTransaction不需要提前计算好签名，用法： eth.sendTransaction({from:acc0,to:acc1,value: web3.toWei(1)})&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //用于本地的两个账户eth.sendTransaction({from:&quot;0x51c641e9b2e9693d0f3c94e4cd804ae4eb9c8900&quot;,to: &quot;0x573dc3f3bdd9b9b579ee507412483cf43d9e7b08&quot;, value: amount}) 2.1 发起交易 //internal/ethapi/api/go // SendTransaction creates a transaction for the given argument, sign it and submit it to the transaction pool. func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { // Look up the wallet containing the requested signer account := accounts.Account{Address: args.From} wallet, err := s.b.AccountManager().Find(account) if err != nil { return common.Hash{}, err } if args.Nonce == nil { // Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of // the same nonce to multiple accounts. s.nonceLock.LockAddr(args.From) defer s.nonceLock.UnlockAddr(args.From) } // Set some sanity defaults and terminate on failure if err := args.setDefaults(ctx, s.b); err != nil { return common.Hash{}, err } // Assemble the transaction and sign with the wallet，封装一个transaction对象 tx := args.toTransaction() var chainID *big.Int if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { chainID = config.ChainID } signed, err := wallet.SignTx(account, tx, chainID) //签名 if err != nil { return common.Hash{}, err } return submitTransaction(ctx, s.b, signed) //提交Transaction对象到txpool } // SendRawTransaction will add the signed transaction to the transaction pool. // The sender is responsible for signing the transaction and using the correct nonce. func (s *PublicTransactionPoolAPI) SendRawTransaction(ctx context.Context, encodedTx hexutil.Bytes) (common.Hash, error) { tx := new(types.Transaction) //封装一个Transaction对象 if err := rlp.DecodeBytes(encodedTx, tx); err != nil { //对tx做rlpI编码 return common.Hash{}, err } return submitTransaction(ctx, s.b, tx) //提交交易到txpool }------------------------------------------------------------------- // submitTransaction is a helper function that submits tx to txPool and logs a message. func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { //发送交易，注意：Backend使用了多态，sendTx是txPool的接口，txPool根据light和full两种启动模式有两种类型，本文研究full模式的交易 if err := b. SendTx(ctx, tx); err != nil { return common.Hash{}, err } if tx.To() == nil { //to是空的，说明是部署合约 signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) from, err := types.Sender(signer, tx) if err != nil { return common.Hash{}, err } addr := crypto. CreateAddress(from, tx.Nonce()) //创建合约的地址 log.Info( &quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) } else { log.Info( &quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) } return tx.Hash(), nil}---------------------------------------------------------------------- func (b *EthAPIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { return b.eth.txPool.AddLocal(signedTx) }------------------------------------------------------------------------- // AddLocal enqueues a single transaction into the pool if it is valid, marking the sender as a local one in the mean time, // ensuring it goes around the local pricing constraint // 开始入池 func (pool *TxPool) AddLocal(tx *types.Transaction) error { return pool.addTx(tx, !pool.config.NoLocals) }--------------------------------------------------------------------------- // addTx enqueues a single transaction into the pool if it is valid. func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { pool.mu.Lock() defer pool.mu.Unlock() // Try to inject the transaction and update any state replace, err := pool.add(tx, local) if err != nil { return err } // If we added a new transaction, run promotion checks and return，如果是新交易，直接提交到可执行状态 if !replace { from, _ := types.Sender(pool.signer, tx) // already validated pool.promoteExecutables([]common.Address{from}) //提交到可执行队列 } return nil }----------------------------------------------------------------------------- // add validates a transaction and inserts it into the non-executable queue for add验证交易合法性并插入到非稳定队列 // later pending promotion and execution. If the transaction is a replacement for 如果是一个覆盖交易， // an already pending or queued one, it overwrites the previous and returns this 那么覆盖之前的交易 // so outer code doesn&#39;t uselessly call promote. // // If a newly added transaction is marked as local, its sending account will be 如果是新交易则标记为local // whitelisted, preventing any associated transaction from being dropped out of 则将发送账户列入白名单， // the pool due to pricing constraints. 防止任何关联的交易由于价格约束从池中退出 func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) { // If the transaction is already known, discard it hash := tx.Hash() if pool.all.Get(hash) != nil { //防止重复提交 log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) } // If the transaction fails basic validation, discard it，验证交易合法性 if err := pool.validateTx(tx, local); err != nil { log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) invalidTxCounter.Inc(1) return false, err } // If the transaction pool is full, discard underpriced transactions， 交易池已满，限制定价过低的交易入池 if uint64(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { // If the new transaction is underpriced, don&#39;t accept it if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) return false, ErrUnderpriced } // New transaction is better than our worse ones, make room for it drop := pool.priced.Discard(pool.all.Count()-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) for _, tx := range drop { log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) pool.removeTx(tx.Hash(), false) } } // If the transaction is replacing an already pending one, do directly， 交易是用来替换旧交易的，覆盖它 from, _ := types.Sender(pool.signer, tx) // already validated ，根据签名获取from地址 //pendding队列不为空，并且当前交易已经存在（需要覆盖） if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { // Nonce already pending, check if required price bump is met inserted, old := list.Add(tx, pool.config.PriceBump) //添加到pengding队列 if !inserted { pendingDiscardCounter.Inc(1) return false, ErrReplaceUnderpriced } // New transaction is better, replace old one if old != nil { pool.all.Remove(old.Hash()) //从all队列移除旧的 pool.priced.Removed() pendingReplaceCounter.Inc(1) } pool.all.Add(tx) //添加到all队列 pool.priced.Put(tx) pool.journalTx(from, tx) log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) // We&#39;ve directly injected a replacement transaction, notify subsystems，由于注入了一个replacement交易，通知所有子系统 go pool.txFeed.Send(NewTxsEvent{types.Transactions{tx}}) return old != nil, nil } // New transaction isn&#39;t replacing a pending one, push into queue，插入新交易到pool replace, err := pool.enqueueTx(hash, tx) if err != nil { return false, err } // Mark local addresses and journal local transactions if local { pool.locals.add(from) //插入到local队列 } pool.journalTx(from, tx) //将交易记录到pool的Jorunal中，Jorunal用来把本地交易写到磁盘来备份 log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) return replace, nil }----------------------------------------------------------------------------------- // validateTx checks whether a transaction is valid according to the consensus // rules and adheres to some heuristic limits of the local node (price and size). func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error { // Heuristic（启发式） limit, reject transactions over 32KB to prevent DOS attacks if tx.Size() &gt; 32*1024 { //超大的交易 return ErrOversizedData } // Transactions can&#39;t be negative. This may never happen using RLP decoded // transactions but may occur if you create a transaction using the RPC. if tx.Value().Sign() &lt; 0 { //签名不能是负的 return ErrNegativeValue } // Ensure the transaction doesn&#39;t exceed the current block limit gas. if pool.currentMaxGas &lt; tx.Gas() { //交易的最大汽油限制（GasLimit）不能超过池中汽油的最大值 return ErrGasLimit } // Make sure the transaction is signed properly from, err := types.Sender(pool.signer, tx) //根据签名获取from的地址 if err != nil { return ErrInvalidSender } // Drop non-local transactions under our own minimal accepted gas price local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 { //交易的汽油价格不能小于pool指定的汽油价格 return ErrUnderpriced } // Ensure the transaction adheres to nonce ordering if pool.currentState.GetNonce(from) &gt; tx.Nonce() { //nonce不能小于当前的nonce return ErrNonceTooLow } // Transactor should have enough funds to cover the costs // cost == V + GP * GL if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 { //汽油需要的量（amount+gasPrice*gasLimit）不能大于当前的余额 return ErrInsufficientFunds } //gasLimit一定要大于intrinsic gas, intrinsic gas 包括交易预定义费用 + 发送数据费用 + 创建合约费用 intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead) if err != nil { return err } if tx.Gas() &lt; intrGas { return ErrIntrinsicGas } return nil } ----------------------------------------------------------------------- promoteExecutables方法把 已经变得可以执行的交易从future queue 插入到pending queue。通过这个处理过程，所有的无效的交易(nonce太低，余额不足)会被删除。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // promoteExecutables moves transactions that have become processable from the &nbsp; &nbsp; // future queue to the set of pending transactions. During this process, all &nbsp; &nbsp; // invalidated transactions (low nonce, low balance) are deleted. &nbsp; &nbsp; func (pool *TxPool) promoteExecutables(accounts []common.Address) { &nbsp; &nbsp; &nbsp; &nbsp; // Gather all the accounts potentially needing updates &nbsp; &nbsp; &nbsp; &nbsp; // accounts存储了所有潜在需要更新的账户。 如果账户传入为nil，代表所有已知的账户。 &nbsp; &nbsp; &nbsp; &nbsp; if accounts == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = make([]common.Address, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, _ := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = append(accounts, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range accounts { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue // Just in case someone calls with a non existing account &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are deemed too old (low nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有的nonce太低的交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed old queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are too costly (low balance or out of gas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有余额不足的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range drops { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed unpayable queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedNofundsCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gather all executable transactions and promote them &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 得到所有的可以执行的交易，并promoteTx加入pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Promoting queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.promoteTx(addr, hash, tx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions over the allowed limit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有超过限制的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(int(pool.config.AccountQueue)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed cap-exceeding queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Delete the entire queue entry if it became empty. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.queue, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // If the pending limit is overflown, start equalizing allowances &nbsp; &nbsp; &nbsp; &nbsp; pending := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // 如果pending的总数超过系统的配置。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingBeforeCap := pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Assemble a spam order to penalize large transactors first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers := prque.New() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Only evict transactions from high rollers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先把所有大于AccountSlots最小值的账户记录下来， 会从这些账户里面剔除一些交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 注意spammers是一个优先级队列，也就是说是按照交易的多少从大到小排序的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers.Push(addr, float32(list.Len())) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gradually drop transactions from offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders := []common.Address{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Retrieve the next offender if not local address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offender, _ := spammers.Pop() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders = append(offenders, offender.(common.Address)) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Equalize balances until all the same or below threshold &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if len(offenders) &gt; 1 { // 第一次进入这个循环的时候， offenders队列里面有交易数量最大的两个账户 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Calculate the equalization threshold for all current offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 把最后加入的账户的交易数量当成本次的阈值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold := pool.pending[offender.(common.Address)].Len() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Iteratively reduce all offenders until below limit or threshold reached &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历直到pending有效，或者是倒数第二个的交易数量等于最后一个的交易数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历除了最后一个账户以外的所有账户， 把他们的交易数量减去1. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := 0; i &lt; len(offenders)-1; i++ { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[offenders[i]] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(offenders[i], nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If still above threshold, reduce to limit or min allowance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 经过上面的循环，所有的超过AccountSlots的账户的交易数量都变成了之前的最小值。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果还是超过阈值，那么在继续从offenders里面每次删除一个。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range offenders { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(addr, nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending)) &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; //end if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; // If we&#39;ve queued more transactions than the hard limit, drop oldest ones &nbsp; &nbsp; &nbsp; &nbsp; // 我们处理了pending的限制， 下面需要处理future queue的限制了。 &nbsp; &nbsp; &nbsp; &nbsp; queued := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queued += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if queued &gt; pool.config.GlobalQueue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sort all accounts with queued transactions by heartbeat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses := make(addresssByHeartbeat, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { // don&#39;t drop locals &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]}) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort.Sort(addresses) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop transactions until the total is below the limit or only locals remain &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从后往前，也就是心跳越新的就越会被删除。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr := addresses[len(addresses)-1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr.address] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = addresses[:len(addresses)-1] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions if they are less than the overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if size := uint64(list.Len()); size &lt;= drop { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Flatten() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(tx.Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop -= size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(int64(size)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Otherwise drop only last few transactions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txs := list.Flatten() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(txs[i].Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } Nonce使用规则 为了防止交易重播，ETH（ETC）节点要求每笔交易必须有一个nonce数值。 每一个账户从同一个节点发起交易时，这个nonce值从0开始计数，发送一笔nonce对应加1。 当前面的nonce处理完成之后才会处理后面的nonce。 注意这里的前提条件是相同的地址在相同的节点发送交易。 1.当nonce太小（小于之前已经有交易使用的nonce值），交易会被直接拒绝。 2.当nonce太大,交易会一直处于队列之中,这也就是导致我们上面描述的问题的原因； 3.当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。 4.当交易处于queue中时停止geth客户端，那么交易queue中的交易会被清除掉。 txPool 在创建的时候，开启了一个阻塞式线程，用于响应外部区块链事件，各种报告，或者交易回收 // loop is the transaction pool&#39;s main event loop, waiting for and reacting to // outside blockchain events as well as for various reporting and transaction // eviction events. func (pool *TxPool) loop() { defer pool.wg.Done() // Start the stats reporting and transaction eviction tickers var prevPending, prevQueued, prevStales int report := time.NewTicker(statsReportInterval) defer report.Stop() evict := time.NewTicker(evictionInterval) defer evict.Stop() journal := time.NewTicker(pool.config.Rejournal) defer journal.Stop() // Track the previous head headers for transaction reorgs head := pool.chain.CurrentBlock() // Keep waiting for and reacting to the various events for { select { // Handle ChainHeadEvent 区块链 head 事件 handle case ev := &lt;-pool.chainHeadCh: if ev.Block != nil { pool.mu.Lock() if pool.chainconfig.IsHomestead(ev.Block.Number()) { pool.homestead = true } pool.reset(head.Header(), ev.Block.Header()) head = ev.Block pool.mu.Unlock() } // Be unsubscribed due to system stopped，系统停止导致的注销 case &lt;-pool.chainHeadSub.Err(): return // Handle stats reporting ticks，统计报告时钟的handle case &lt;-report.C: pool.mu.RLock() pending, queued := pool.stats() stales := pool.priced.stales pool.mu.RUnlock() if pending != prevPending || queued != prevQueued || stales != prevStales { log.Debug(&quot;Transaction pool status report&quot;, &quot;executable&quot;, pending, &quot;queued&quot;, queued, &quot;stales&quot;, stales) prevPending, prevQueued, prevStales = pending, queued, stales } // Handle inactive account transaction eviction，不活跃的账户的交易回收handle case &lt;-evict.C: pool.mu.Lock() for addr := range pool.queue { // Skip local transactions from the eviction mechanism if pool.locals.contains(addr) { continue } // Any non-locals old enough should be removed if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime { for _, tx := range pool.queue[addr].Flatten() { pool.removeTx(tx.Hash(), true) } } } pool.mu.Unlock() // Handle local transaction journal rotation，本地交易journal轮询handle case &lt;-journal.C: if pool.journal != nil { pool.mu.Lock() if err := pool.journal.rotate(pool.local()); err != nil { log.Warn(&quot;Failed to rotate local tx journal&quot;, &quot;err&quot;, err) } pool.mu.Unlock() } } } } 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/11/10b26f4cfa09230edf8623f08d723e85.html" />
<meta property="og:url" content="https://mlh.app/2018/06/11/10b26f4cfa09230edf8623f08d723e85.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、流程简介 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 二、源码分析 以太坊系列（ETH&amp;ETC）在发送交易有三个对应的RPC接口，分别是eth_sendTransaction、eth_sendRawTransaction和personal_sendTransaction。personal_sendTransaction很少听说，暂时不管。eth_sendRawTransaction接口必须附上已经计算好的签名，eth_sendTransaction不需要提前计算好签名，用法： eth.sendTransaction({from:acc0,to:acc1,value: web3.toWei(1)})&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //用于本地的两个账户eth.sendTransaction({from:&quot;0x51c641e9b2e9693d0f3c94e4cd804ae4eb9c8900&quot;,to: &quot;0x573dc3f3bdd9b9b579ee507412483cf43d9e7b08&quot;, value: amount}) 2.1 发起交易 //internal/ethapi/api/go // SendTransaction creates a transaction for the given argument, sign it and submit it to the transaction pool. func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { // Look up the wallet containing the requested signer account := accounts.Account{Address: args.From} wallet, err := s.b.AccountManager().Find(account) if err != nil { return common.Hash{}, err } if args.Nonce == nil { // Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of // the same nonce to multiple accounts. s.nonceLock.LockAddr(args.From) defer s.nonceLock.UnlockAddr(args.From) } // Set some sanity defaults and terminate on failure if err := args.setDefaults(ctx, s.b); err != nil { return common.Hash{}, err } // Assemble the transaction and sign with the wallet，封装一个transaction对象 tx := args.toTransaction() var chainID *big.Int if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { chainID = config.ChainID } signed, err := wallet.SignTx(account, tx, chainID) //签名 if err != nil { return common.Hash{}, err } return submitTransaction(ctx, s.b, signed) //提交Transaction对象到txpool } // SendRawTransaction will add the signed transaction to the transaction pool. // The sender is responsible for signing the transaction and using the correct nonce. func (s *PublicTransactionPoolAPI) SendRawTransaction(ctx context.Context, encodedTx hexutil.Bytes) (common.Hash, error) { tx := new(types.Transaction) //封装一个Transaction对象 if err := rlp.DecodeBytes(encodedTx, tx); err != nil { //对tx做rlpI编码 return common.Hash{}, err } return submitTransaction(ctx, s.b, tx) //提交交易到txpool }------------------------------------------------------------------- // submitTransaction is a helper function that submits tx to txPool and logs a message. func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { //发送交易，注意：Backend使用了多态，sendTx是txPool的接口，txPool根据light和full两种启动模式有两种类型，本文研究full模式的交易 if err := b. SendTx(ctx, tx); err != nil { return common.Hash{}, err } if tx.To() == nil { //to是空的，说明是部署合约 signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) from, err := types.Sender(signer, tx) if err != nil { return common.Hash{}, err } addr := crypto. CreateAddress(from, tx.Nonce()) //创建合约的地址 log.Info( &quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) } else { log.Info( &quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) } return tx.Hash(), nil}---------------------------------------------------------------------- func (b *EthAPIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { return b.eth.txPool.AddLocal(signedTx) }------------------------------------------------------------------------- // AddLocal enqueues a single transaction into the pool if it is valid, marking the sender as a local one in the mean time, // ensuring it goes around the local pricing constraint // 开始入池 func (pool *TxPool) AddLocal(tx *types.Transaction) error { return pool.addTx(tx, !pool.config.NoLocals) }--------------------------------------------------------------------------- // addTx enqueues a single transaction into the pool if it is valid. func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { pool.mu.Lock() defer pool.mu.Unlock() // Try to inject the transaction and update any state replace, err := pool.add(tx, local) if err != nil { return err } // If we added a new transaction, run promotion checks and return，如果是新交易，直接提交到可执行状态 if !replace { from, _ := types.Sender(pool.signer, tx) // already validated pool.promoteExecutables([]common.Address{from}) //提交到可执行队列 } return nil }----------------------------------------------------------------------------- // add validates a transaction and inserts it into the non-executable queue for add验证交易合法性并插入到非稳定队列 // later pending promotion and execution. If the transaction is a replacement for 如果是一个覆盖交易， // an already pending or queued one, it overwrites the previous and returns this 那么覆盖之前的交易 // so outer code doesn&#39;t uselessly call promote. // // If a newly added transaction is marked as local, its sending account will be 如果是新交易则标记为local // whitelisted, preventing any associated transaction from being dropped out of 则将发送账户列入白名单， // the pool due to pricing constraints. 防止任何关联的交易由于价格约束从池中退出 func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) { // If the transaction is already known, discard it hash := tx.Hash() if pool.all.Get(hash) != nil { //防止重复提交 log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) } // If the transaction fails basic validation, discard it，验证交易合法性 if err := pool.validateTx(tx, local); err != nil { log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) invalidTxCounter.Inc(1) return false, err } // If the transaction pool is full, discard underpriced transactions， 交易池已满，限制定价过低的交易入池 if uint64(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { // If the new transaction is underpriced, don&#39;t accept it if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) return false, ErrUnderpriced } // New transaction is better than our worse ones, make room for it drop := pool.priced.Discard(pool.all.Count()-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) for _, tx := range drop { log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) pool.removeTx(tx.Hash(), false) } } // If the transaction is replacing an already pending one, do directly， 交易是用来替换旧交易的，覆盖它 from, _ := types.Sender(pool.signer, tx) // already validated ，根据签名获取from地址 //pendding队列不为空，并且当前交易已经存在（需要覆盖） if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { // Nonce already pending, check if required price bump is met inserted, old := list.Add(tx, pool.config.PriceBump) //添加到pengding队列 if !inserted { pendingDiscardCounter.Inc(1) return false, ErrReplaceUnderpriced } // New transaction is better, replace old one if old != nil { pool.all.Remove(old.Hash()) //从all队列移除旧的 pool.priced.Removed() pendingReplaceCounter.Inc(1) } pool.all.Add(tx) //添加到all队列 pool.priced.Put(tx) pool.journalTx(from, tx) log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) // We&#39;ve directly injected a replacement transaction, notify subsystems，由于注入了一个replacement交易，通知所有子系统 go pool.txFeed.Send(NewTxsEvent{types.Transactions{tx}}) return old != nil, nil } // New transaction isn&#39;t replacing a pending one, push into queue，插入新交易到pool replace, err := pool.enqueueTx(hash, tx) if err != nil { return false, err } // Mark local addresses and journal local transactions if local { pool.locals.add(from) //插入到local队列 } pool.journalTx(from, tx) //将交易记录到pool的Jorunal中，Jorunal用来把本地交易写到磁盘来备份 log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) return replace, nil }----------------------------------------------------------------------------------- // validateTx checks whether a transaction is valid according to the consensus // rules and adheres to some heuristic limits of the local node (price and size). func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error { // Heuristic（启发式） limit, reject transactions over 32KB to prevent DOS attacks if tx.Size() &gt; 32*1024 { //超大的交易 return ErrOversizedData } // Transactions can&#39;t be negative. This may never happen using RLP decoded // transactions but may occur if you create a transaction using the RPC. if tx.Value().Sign() &lt; 0 { //签名不能是负的 return ErrNegativeValue } // Ensure the transaction doesn&#39;t exceed the current block limit gas. if pool.currentMaxGas &lt; tx.Gas() { //交易的最大汽油限制（GasLimit）不能超过池中汽油的最大值 return ErrGasLimit } // Make sure the transaction is signed properly from, err := types.Sender(pool.signer, tx) //根据签名获取from的地址 if err != nil { return ErrInvalidSender } // Drop non-local transactions under our own minimal accepted gas price local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 { //交易的汽油价格不能小于pool指定的汽油价格 return ErrUnderpriced } // Ensure the transaction adheres to nonce ordering if pool.currentState.GetNonce(from) &gt; tx.Nonce() { //nonce不能小于当前的nonce return ErrNonceTooLow } // Transactor should have enough funds to cover the costs // cost == V + GP * GL if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 { //汽油需要的量（amount+gasPrice*gasLimit）不能大于当前的余额 return ErrInsufficientFunds } //gasLimit一定要大于intrinsic gas, intrinsic gas 包括交易预定义费用 + 发送数据费用 + 创建合约费用 intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead) if err != nil { return err } if tx.Gas() &lt; intrGas { return ErrIntrinsicGas } return nil } ----------------------------------------------------------------------- promoteExecutables方法把 已经变得可以执行的交易从future queue 插入到pending queue。通过这个处理过程，所有的无效的交易(nonce太低，余额不足)会被删除。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // promoteExecutables moves transactions that have become processable from the &nbsp; &nbsp; // future queue to the set of pending transactions. During this process, all &nbsp; &nbsp; // invalidated transactions (low nonce, low balance) are deleted. &nbsp; &nbsp; func (pool *TxPool) promoteExecutables(accounts []common.Address) { &nbsp; &nbsp; &nbsp; &nbsp; // Gather all the accounts potentially needing updates &nbsp; &nbsp; &nbsp; &nbsp; // accounts存储了所有潜在需要更新的账户。 如果账户传入为nil，代表所有已知的账户。 &nbsp; &nbsp; &nbsp; &nbsp; if accounts == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = make([]common.Address, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, _ := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = append(accounts, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range accounts { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list == nil { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue // Just in case someone calls with a non existing account &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are deemed too old (low nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有的nonce太低的交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed old queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are too costly (low balance or out of gas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有余额不足的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range drops { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed unpayable queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedNofundsCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gather all executable transactions and promote them &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 得到所有的可以执行的交易，并promoteTx加入pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Promoting queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.promoteTx(addr, hash, tx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions over the allowed limit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 删除所有超过限制的交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(int(pool.config.AccountQueue)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed cap-exceeding queued transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Delete the entire queue entry if it became empty. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.queue, addr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // If the pending limit is overflown, start equalizing allowances &nbsp; &nbsp; &nbsp; &nbsp; pending := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; // 如果pending的总数超过系统的配置。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingBeforeCap := pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Assemble a spam order to penalize large transactors first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers := prque.New() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, list := range pool.pending { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Only evict transactions from high rollers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先把所有大于AccountSlots最小值的账户记录下来， 会从这些账户里面剔除一些交易。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 注意spammers是一个优先级队列，也就是说是按照交易的多少从大到小排序的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers.Push(addr, float32(list.Len())) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gradually drop transactions from offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders := []common.Address{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Retrieve the next offender if not local address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offender, _ := spammers.Pop() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders = append(offenders, offender.(common.Address)) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Equalize balances until all the same or below threshold &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if len(offenders) &gt; 1 { // 第一次进入这个循环的时候， offenders队列里面有交易数量最大的两个账户 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Calculate the equalization threshold for all current offenders &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 把最后加入的账户的交易数量当成本次的阈值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold := pool.pending[offender.(common.Address)].Len() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Iteratively reduce all offenders until below limit or threshold reached &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历直到pending有效，或者是倒数第二个的交易数量等于最后一个的交易数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 遍历除了最后一个账户以外的所有账户， 把他们的交易数量减去1. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := 0; i &lt; len(offenders)-1; i++ { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[offenders[i]] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(offenders[i], nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If still above threshold, reduce to limit or min allowance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 经过上面的循环，所有的超过AccountSlots的账户的交易数量都变成了之前的最小值。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果还是超过阈值，那么在继续从offenders里面每次删除一个。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range offenders { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[addr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed() &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(addr, nonce) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending)) &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; //end if pending &gt; pool.config.GlobalSlots { &nbsp; &nbsp; &nbsp; &nbsp; // If we&#39;ve queued more transactions than the hard limit, drop oldest ones &nbsp; &nbsp; &nbsp; &nbsp; // 我们处理了pending的限制， 下面需要处理future queue的限制了。 &nbsp; &nbsp; &nbsp; &nbsp; queued := uint64(0) &nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queued += uint64(list.Len()) &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if queued &gt; pool.config.GlobalQueue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sort all accounts with queued transactions by heartbeat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses := make(addresssByHeartbeat, 0, len(pool.queue)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr := range pool.queue { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { // don&#39;t drop locals &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]}) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort.Sort(addresses) &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop transactions until the total is below the limit or only locals remain &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从后往前，也就是心跳越新的就越会被删除。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr := addresses[len(addresses)-1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr.address] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = addresses[:len(addresses)-1] &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions if they are less than the overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if size := uint64(list.Len()); size &lt;= drop { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Flatten() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(tx.Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop -= size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(int64(size)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Otherwise drop only last few transactions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txs := list.Flatten() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(txs[i].Hash()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } Nonce使用规则 为了防止交易重播，ETH（ETC）节点要求每笔交易必须有一个nonce数值。 每一个账户从同一个节点发起交易时，这个nonce值从0开始计数，发送一笔nonce对应加1。 当前面的nonce处理完成之后才会处理后面的nonce。 注意这里的前提条件是相同的地址在相同的节点发送交易。 1.当nonce太小（小于之前已经有交易使用的nonce值），交易会被直接拒绝。 2.当nonce太大,交易会一直处于队列之中,这也就是导致我们上面描述的问题的原因； 3.当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。 4.当交易处于queue中时停止geth客户端，那么交易queue中的交易会被清除掉。 txPool 在创建的时候，开启了一个阻塞式线程，用于响应外部区块链事件，各种报告，或者交易回收 // loop is the transaction pool&#39;s main event loop, waiting for and reacting to // outside blockchain events as well as for various reporting and transaction // eviction events. func (pool *TxPool) loop() { defer pool.wg.Done() // Start the stats reporting and transaction eviction tickers var prevPending, prevQueued, prevStales int report := time.NewTicker(statsReportInterval) defer report.Stop() evict := time.NewTicker(evictionInterval) defer evict.Stop() journal := time.NewTicker(pool.config.Rejournal) defer journal.Stop() // Track the previous head headers for transaction reorgs head := pool.chain.CurrentBlock() // Keep waiting for and reacting to the various events for { select { // Handle ChainHeadEvent 区块链 head 事件 handle case ev := &lt;-pool.chainHeadCh: if ev.Block != nil { pool.mu.Lock() if pool.chainconfig.IsHomestead(ev.Block.Number()) { pool.homestead = true } pool.reset(head.Header(), ev.Block.Header()) head = ev.Block pool.mu.Unlock() } // Be unsubscribed due to system stopped，系统停止导致的注销 case &lt;-pool.chainHeadSub.Err(): return // Handle stats reporting ticks，统计报告时钟的handle case &lt;-report.C: pool.mu.RLock() pending, queued := pool.stats() stales := pool.priced.stales pool.mu.RUnlock() if pending != prevPending || queued != prevQueued || stales != prevStales { log.Debug(&quot;Transaction pool status report&quot;, &quot;executable&quot;, pending, &quot;queued&quot;, queued, &quot;stales&quot;, stales) prevPending, prevQueued, prevStales = pending, queued, stales } // Handle inactive account transaction eviction，不活跃的账户的交易回收handle case &lt;-evict.C: pool.mu.Lock() for addr := range pool.queue { // Skip local transactions from the eviction mechanism if pool.locals.contains(addr) { continue } // Any non-locals old enough should be removed if time.Since(pool.beats[addr]) &gt; pool.config.Lifetime { for _, tx := range pool.queue[addr].Flatten() { pool.removeTx(tx.Hash(), true) } } } pool.mu.Unlock() // Handle local transaction journal rotation，本地交易journal轮询handle case &lt;-journal.C: if pool.journal != nil { pool.mu.Lock() if err := pool.journal.rotate(pool.local()); err != nil { log.Warn(&quot;Failed to rotate local tx journal&quot;, &quot;err&quot;, err) } pool.mu.Unlock() } } } } 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/11/10b26f4cfa09230edf8623f08d723e85.html","headline":"geth源码阅读——交易流程","dateModified":"2018-06-11T00:00:00+08:00","datePublished":"2018-06-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/11/10b26f4cfa09230edf8623f08d723e85.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>geth源码阅读——交易流程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>一、流程简介</p>
  <ul style="list-style:none;color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;background-color:rgb(255,255,255);">
   <li>发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit</li>
   <li>交易签名：使用账户私钥对交易进行签名</li>
   <li>提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证）</li>
   <li>广播交易：通知EVM执行，同时把交易信息广播给其他结点</li>
  </ul>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180611100037141?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzkxOTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p>二、源码分析</p>
  <p>以太坊系列（ETH&amp;ETC）在发送交易有三个对应的RPC接口，分别是eth_sendTransaction、eth_sendRawTransaction和personal_sendTransaction。personal_sendTransaction很少听说，暂时不管。eth_sendRawTransaction接口必须附上已经计算好的签名，eth_sendTransaction不需要提前计算好签名，用法：</p>
  <p></p>
  <p>eth.sendTransaction({from:acc0,to:acc1,value: web3.toWei(1)})&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //用于本地的两个账户</p>eth.sendTransaction({from:"0x51c641e9b2e9693d0f3c94e4cd804ae4eb9c8900",to: "0x573dc3f3bdd9b9b579ee507412483cf43d9e7b08", value: amount})
  <br>
  <p>2.1 发起交易</p>
  <p>//internal/ethapi/api/go</p>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em></em></span></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// S</em></span><span style="color:#ff0000;"><em>endTransaction creates a transaction for the given argument, sign it and submit it to the transaction pool</em></span><span style="color:#808080;"><em>. </em></span><span style="color:#000080;"><strong>func </strong></span>(s *PublicTransactionPoolAPI) <span style="color:#ff0000;"><strong>SendTransaction</strong></span>(ctx context.Context, args SendTxArgs) (common.Hash, error) {

   <span style="color:#808080;"><em>// Look up the wallet containing the requested signer </em></span><span style="color:#808080;"><em> </em></span>account := accounts.Account{Address: args.From}

   wallet, err := s.b.AccountManager().Find(account)
   <span style="color:#000080;"><strong>if </strong></span>err != nil {
      <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err
   }

   <span style="color:#000080;"><strong>if </strong></span>args.Nonce == nil {
      <span style="color:#808080;"><em>// Hold the addresse's mutex around signing to prevent concurrent assignment of </em></span><span style="color:#808080;"><em> // the same nonce to multiple accounts. </em></span><span style="color:#808080;"><em> </em></span>s.nonceLock.LockAddr(args.From)
      <span style="color:#000080;"><strong>defer </strong></span>s.nonceLock.UnlockAddr(args.From)
   }

   <span style="color:#808080;"><em>// Set some sanity defaults and terminate on failure </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>err := args.setDefaults(ctx, s.b); err != nil {
      <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err
   }
   <span style="color:#808080;"><em>// </em></span><em><span style="color:#ff0000;">Assemble the transaction and sign with the wallet，封装一个transaction对象</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span>tx := args.toTransaction()

   <span style="color:#000080;"><strong>var </strong></span>chainID *big.Int
   <span style="color:#000080;"><strong>if </strong></span>config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) {
      chainID = config.ChainID
   }
   <span style="color:#ff0000;">signed, err := wallet.SignTx(account, tx, chainID)     //签名</span>
   <span style="color:#000080;"><strong>if </strong></span>err != nil {
      <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err
   }
   <span style="color:#000080;"><strong>return </strong></span><span style="color:#ff6666;">submitTransaction</span>(ctx, s.b, signed)             <span style="color:#ff0000;">//提交Transaction对象到txpool</span>
}</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// SendRawTransaction will add the signed transaction to the transaction pool. </em></span><span style="color:#808080;"><em>// The sender is responsible for signing the transaction and using the correct nonce. </em></span><span style="color:#000080;"><strong>func </strong></span>(s *PublicTransactionPoolAPI) <span style="color:#ff0000;"><strong>SendRawTransaction</strong></span>(ctx context.Context, encodedTx hexutil.Bytes) (common.Hash, error) {
   tx := new(types.Transaction)    <span style="color:#ff0000;"> //封装一个Transaction对象</span>
   <span style="color:#000080;"><strong>if </strong></span>err := rlp.DecodeBytes(encodedTx, tx); err != nil {       <span style="color:#ff0000;">//对tx做rlpI编码</span>
      <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err
   }
   <span style="color:#000080;"><strong>return </strong></span>submitTransaction(ctx, s.b, tx)              <span style="color:#ff0000;">//提交交易到txpool</span>
}</pre>-------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// submitTransaction is a helper function that submits tx to txPool and logs a message. </em></span><span style="color:#000080;"><strong>func </strong></span><span style="color:#ff0000;"><strong>submitTransaction</strong></span>(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) {</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;">   </pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;">//发送交易，注意：Backend使用了多态，sendTx是txPool的接口，txPool根据light和full两种启动模式有两种类型，本文研究full模式的交易</span></pre> 
  <span style="color:#000080;"><strong>if </strong></span>err := b.
  <span style="color:#ff0000;">SendTx</span>(ctx, tx); err != nil { 
  <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err } 
  <span style="color:#000080;"><strong>if </strong></span>tx.To() == nil { 
  <span style="color:#ff0000;">//to是空的，说明是部署合约</span> signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) from, err := types.Sender(signer, tx) 
  <span style="color:#000080;"><strong>if </strong></span>err != nil { 
  <span style="color:#000080;"><strong>return </strong></span>common.Hash{}, err } addr := crypto.
  <span style="color:#ff0000;">CreateAddress</span>(from, tx.Nonce()) 
  <span style="color:#ff0000;">//创建合约的地址</span> log.Info(
  <span style="color:#008000;"><strong>"Submitted contract creation"</strong></span>, 
  <span style="color:#008000;"><strong>"fullhash"</strong></span>, tx.Hash().Hex(), 
  <span style="color:#008000;"><strong>"contract"</strong></span>, addr.Hex()) } 
  <span style="color:#000080;"><strong>else </strong></span>{ log.Info(
  <span style="color:#008000;"><strong>"Submitted transaction"</strong></span>, 
  <span style="color:#008000;"><strong>"fullhash"</strong></span>, tx.Hash().Hex(), 
  <span style="color:#008000;"><strong>"recipient"</strong></span>, tx.To()) } 
  <span style="color:#000080;"><strong>return </strong></span>tx.Hash(), nil}----------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#000080;"><strong>func </strong></span>(b *EthAPIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error {
   <span style="color:#000080;"><strong>return </strong></span>b.eth.txPool.AddLocal(signedTx)
}</pre>-------------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;"><em>// AddLocal enqueues a single transaction into the pool if it is valid, marking the sender as a local one in the mean time, // ensuring it goes around the local pricing constraint // 开始入池</em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>func </strong></span>(pool *TxPool) AddLocal(tx *types.Transaction) error {
   <span style="color:#000080;"><strong>return </strong></span>pool.addTx(tx, !pool.config.NoLocals)
}</pre>---------------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// addTx enqueues a single transaction into the pool if it is valid. </em></span><span style="color:#000080;"><strong>func </strong></span>(pool *TxPool) <span style="color:#ff0000;"><strong>addTx</strong></span>(tx *types.Transaction, local bool) error {
   pool.mu.Lock()
   <span style="color:#000080;"><strong>defer </strong></span>pool.mu.Unlock()

   <span style="color:#808080;"><em>// Try to inject the transaction and update any state </em></span><span style="color:#808080;"><em> </em></span>replace, err := pool.<span style="color:#ff0000;">add</span>(tx, local)
   <span style="color:#000080;"><strong>if </strong></span>err != nil {
      <span style="color:#000080;"><strong>return </strong></span>err
   }
<span style="color:#ff0000;">   <em>// If we added a new transaction, run promotion checks and return，如果是新交易，直接提交到可执行状态</em></span><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>!replace {
      from, _ := types.Sender(pool.signer, tx) <span style="color:#808080;"><em>// already validated </em></span><span style="color:#808080;"><em> </em></span><span style="color:#ff0000;">pool.promoteExecutables([]common.Address{from})              //提交到可执行队列</span>
   }
   <span style="color:#000080;"><strong>return </strong></span>nil
}</pre>-----------------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;"><em>// add validates a transaction and inserts it into the non-executable queue for add验证交易合法性并插入到非稳定队列 // later pending promotion and execution. If the transaction is a replacement for 如果是一个覆盖交易， // an already pending or queued one, it overwrites the previous and returns this 那么覆盖之前的交易 // so outer code doesn't uselessly call promote. // // If a newly added transaction is marked as local, its sending account will be 如果是新交易则标记为local // whitelisted, preventing any associated transaction from being dropped out of 则将发送账户列入白名单， // the pool due to pricing constraints. 防止任何关联的交易由于价格约束从池中退出</em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>func </strong></span>(pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) {
   <span style="color:#808080;"><em>// If the transaction is already known, discard it </em></span><span style="color:#808080;"><em> </em></span>hash := tx.Hash()
   <span style="color:#000080;"><strong>if </strong></span>pool.all.Get(hash) != nil {            <span style="color:#ff0000;">//防止重复提交</span>
      log.Trace(<span style="color:#008000;"><strong>"Discarding already known transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, hash)
      <span style="color:#000080;"><strong>return </strong></span><span style="color:#660e7a;"><strong><em>false</em></strong></span>, fmt.Errorf(<span style="color:#008000;"><strong>"known transaction: %x"</strong></span>, hash)
   }
   <span style="color:#808080;"><em>// If the transaction fails basic validation, discard it，</em></span><em><span style="color:#ff0000;">验证交易合法性</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>err := pool.validateTx(tx, local); err != nil {
      log.Trace(<span style="color:#008000;"><strong>"Discarding invalid transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, hash, <span style="color:#008000;"><strong>"err"</strong></span>, err)
      invalidTxCounter.Inc(<span style="color:#0000ff;">1</span>)
      <span style="color:#000080;"><strong>return </strong></span><span style="color:#660e7a;"><strong><em>false</em></strong></span>, err
   }
   <span style="color:#808080;"><em>// If the transaction pool is full, discard underpriced transactions， </em></span><em><span style="color:#ff0000;">交易池已满，限制定价过低的交易入池</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>uint64(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue {
      <span style="color:#808080;"><em>// If the new transaction is underpriced, don't accept it </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>!local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) {
         log.Trace(<span style="color:#008000;"><strong>"Discarding underpriced transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, hash, <span style="color:#008000;"><strong>"price"</strong></span>, tx.GasPrice())
         underpricedTxCounter.Inc(<span style="color:#0000ff;">1</span>)
         <span style="color:#000080;"><strong>return </strong></span><span style="color:#660e7a;"><strong><em>false</em></strong></span>, ErrUnderpriced
      }
      <span style="color:#808080;"><em>// New transaction is better than our worse ones, make room for it </em></span><span style="color:#808080;"><em> </em></span>drop := pool.priced.Discard(pool.all.Count()-int(pool.config.GlobalSlots+pool.config.GlobalQueue-<span style="color:#0000ff;">1</span>), pool.locals)
      <span style="color:#000080;"><strong>for </strong></span>_, tx := <span style="color:#000080;"><strong>range </strong></span>drop {
         log.Trace(<span style="color:#008000;"><strong>"Discarding freshly underpriced transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, tx.Hash(), <span style="color:#008000;"><strong>"price"</strong></span>, tx.GasPrice())
         underpricedTxCounter.Inc(<span style="color:#0000ff;">1</span>)
         pool.removeTx(tx.Hash(), <span style="color:#660e7a;"><strong><em>false</em></strong></span>)
      }
   }
   <span style="color:#808080;"><em>// If the transaction is replacing an already pending one, do directly， </em></span><em><span style="color:#ff0000;">交易是用来替换旧交易的，覆盖它</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span>from, _ := types.Sender(pool.signer, tx) <span style="color:#808080;"><em>// already validated ，</em></span><em><span style="color:#ff0000;">根据签名获取from地址</span></em></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><em>   <span style="color:#ff0000;">//pendding队列不为空，并且当前交易已经存在（需要覆盖）</span>
</em><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) {
      <span style="color:#808080;"><em>// Nonce already pending, check if required price bump is met </em></span><span style="color:#808080;"><em> </em></span>inserted, old := list.Add(tx, pool.config.PriceBump)              <span style="color:#ff0000;">//添加到pengding队列</span>
      <span style="color:#000080;"><strong>if </strong></span>!inserted {
         pendingDiscardCounter.Inc(<span style="color:#0000ff;">1</span>)
         <span style="color:#000080;"><strong>return </strong></span><span style="color:#660e7a;"><strong><em>false</em></strong></span>, ErrReplaceUnderpriced
      }
      <span style="color:#808080;"><em>// New transaction is better, replace old one </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>old != nil {
         pool.all.Remove(old.Hash())     <span style="color:#ff0000;">//从all队列移除旧的</span>
         pool.priced.Removed()
         pendingReplaceCounter.Inc(<span style="color:#0000ff;">1</span>)
      }
      pool.all.Add(tx)                   <span style="color:#ff0000;">//添加到all队列</span>
      pool.priced.Put(tx)
      pool.journalTx(from, tx)

      log.Trace(<span style="color:#008000;"><strong>"Pooled new executable transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, hash, <span style="color:#008000;"><strong>"from"</strong></span>, from, <span style="color:#008000;"><strong>"to"</strong></span>, tx.To())

      <span style="color:#808080;"><em>// We've directly injected a replacement transaction, notify subsystems，由于注入了一个replacement交易，通知所有子系统 </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>go </strong></span>pool.txFeed.Send(NewTxsEvent{types.Transactions{tx}})

      <span style="color:#000080;"><strong>return </strong></span>old != nil, nil
   }
   <span style="color:#808080;"><em>// New transaction isn't replacing a pending one, push into queue，</em></span><em><span style="color:#ff0000;">插入新交易到pool</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span>replace, err := pool.enqueueTx(hash, tx)
   <span style="color:#000080;"><strong>if </strong></span>err != nil {
      <span style="color:#000080;"><strong>return </strong></span><span style="color:#660e7a;"><strong><em>false</em></strong></span>, err
   }
   <span style="color:#808080;"><em>// Mark local addresses and journal local transactions </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>local {
      pool.locals.add(from)       <span style="color:#ff0000;">//插入到local队列</span>
   }
   pool.journalTx(from, tx)      <span style="color:#ff0000;"> //将交易记录到pool的Jorunal中，Jorunal用来把本地交易写到磁盘来备份
</span>
   log.Trace(<span style="color:#008000;"><strong>"Pooled new future transaction"</strong></span>, <span style="color:#008000;"><strong>"hash"</strong></span>, hash, <span style="color:#008000;"><strong>"from"</strong></span>, from, <span style="color:#008000;"><strong>"to"</strong></span>, tx.To())
   <span style="color:#000080;"><strong>return </strong></span>replace, nil
}</pre>-----------------------------------------------------------------------------------
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// validateTx checks whether a transaction is valid according to the consensus </em></span><span style="color:#808080;"><em>// rules and adheres to some heuristic limits of the local node (price and size). </em></span><span style="color:#000080;"><strong>func </strong></span>(pool *TxPool) <span style="color:#ff0000;">validateTx</span>(tx *types.Transaction, local bool) error {
   <span style="color:#808080;"><em>// Heuristic（启发式） limit, reject transactions over 32KB to prevent DOS attacks </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>tx.Size() &gt; <span style="color:#0000ff;">32</span>*<span style="color:#0000ff;">1024 </span>{        <span style="color:#ff0000;">//超大的交易</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrOversizedData
   }
   <span style="color:#808080;"><em>// Transactions can't be negative. This may never happen using RLP decoded </em></span><span style="color:#808080;"><em> // transactions but may occur if you create a transaction using the RPC. </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>tx.Value().Sign() &lt; <span style="color:#0000ff;">0 </span>{     <span style="color:#ff0000;">//签名不能是负的</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrNegativeValue
   }
   <span style="color:#808080;"><em>// Ensure the transaction doesn't exceed the current block limit gas. </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>pool.currentMaxGas &lt; tx.Gas() {   <span style="color:#ff0000;">//交易的最大汽油限制（GasLimit）不能超过池中汽油的最大值</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrGasLimit
   }
   <span style="color:#808080;"><em>// Make sure the transaction is signed properly </em></span><span style="color:#808080;"><em> </em></span>from, err := types.Sender(pool.signer, tx)    <span style="color:#ff6666;">//根据签名获取from的地址</span>
   <span style="color:#000080;"><strong>if </strong></span>err != nil {  
      <span style="color:#000080;"><strong>return </strong></span>ErrInvalidSender
   }
   <span style="color:#808080;"><em>// Drop non-local transactions under our own minimal accepted gas price </em></span><span style="color:#808080;"><em> </em></span>local = local || pool.locals.contains(from) <span style="color:#808080;"><em>// account may be local even if the transaction arrived from the network </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>!local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; <span style="color:#0000ff;">0 </span>{    <span style="color:#ff0000;">//交易的汽油价格不能小于pool指定的汽油价格</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrUnderpriced
   }
   <span style="color:#808080;"><em>// Ensure the transaction adheres to nonce ordering </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>pool.currentState.GetNonce(from) &gt; tx.Nonce() {      <span style="color:#ff0000;">//nonce不能小于当前的nonce</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrNonceTooLow
   }
   <span style="color:#808080;"><em>// Transactor should have enough funds to cover the costs </em></span><span style="color:#808080;"><em> // cost == V + GP * GL </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; <span style="color:#0000ff;">0 </span>{   <span style="color:#ff0000;">//汽油需要的量（amount+gasPrice*gasLimit）不能大于当前的余额</span>
      <span style="color:#000080;"><strong>return </strong></span>ErrInsufficientFunds
   }</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;">   //gasLimit一定要大于intrinsic gas, intrinsic gas 包括交易预定义费用 + 发送数据费用 + 创建合约费用</span>
   intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead)
   <span style="color:#000080;"><strong>if </strong></span>err != nil {
      <span style="color:#000080;"><strong>return </strong></span>err
   }
   <span style="color:#000080;"><strong>if </strong></span>tx.Gas() &lt; intrGas {
      <span style="color:#000080;"><strong>return </strong></span>ErrIntrinsicGas
   }
   <span style="color:#000080;"><strong>return </strong></span>nil
}</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;">-----------------------------------------------------------------------</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;">promoteExecutables方法把 已经变得可以执行的交易从future queue 插入到pending queue。通过这个处理过程，所有的无效的交易(nonce太低，余额不足)会被删除。</span>
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; // promoteExecutables moves transactions that have become processable from the
&nbsp; &nbsp; // future queue to the set of pending transactions. During this process, all
&nbsp; &nbsp; // invalidated transactions (low nonce, low balance) are deleted.
&nbsp; &nbsp; func (pool *TxPool) promoteExecutables(accounts []common.Address) {
&nbsp; &nbsp; &nbsp; &nbsp; // Gather all the accounts potentially needing updates
&nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">accounts存储了所有潜在需要更新的账户。 如果账户传入为nil，代表所有已知的账户。</span>
&nbsp; &nbsp; &nbsp; &nbsp; if accounts == nil {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = make([]common.Address, 0, len(pool.queue))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, _ := range pool.queue {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accounts = append(accounts, addr)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions
&nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range accounts {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list == nil {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue // Just in case someone calls with a non existing account
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are deemed too old (low nonce)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">删除所有的nonce太低的交易</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Removed old queued transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions that are too costly (low balance or out of gas)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">删除所有余额不足的交易。</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range drops {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Removed unpayable queued transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedNofundsCounter.Inc(1)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gather all executable transactions and promote them
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">得到所有的可以执行的交易，并promoteTx加入pending</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Promoting queued transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.promoteTx(addr, hash, tx)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions over the allowed limit
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">删除所有超过限制的交易。</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(int(pool.config.AccountQueue)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Removed cap-exceeding queued transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Delete the entire queue entry if it became empty.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if list.Empty() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.queue, addr)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; // If the pending limit is overflown, start equalizing allowances
&nbsp; &nbsp; &nbsp; &nbsp; pending := uint64(0)
&nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.pending {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending += uint64(list.Len())
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; //<span style="color:#ff0000;"> 如果pending的总数超过系统的配置。&nbsp;</span>
&nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingBeforeCap := pending
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Assemble a spam order to penalize large transactors first
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers := prque.New()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr, list := range pool.pending {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Only evict transactions from high rollers
<span style="color:#ff0000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先把所有大于AccountSlots最小值的账户记录下来， 会从这些账户里面剔除一些交易。
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 注意spammers是一个优先级队列，也就是说是按照交易的多少从大到小排序的。</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spammers.Push(addr, float32(list.Len()))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Gradually drop transactions from offenders
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders := []common.Address{}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Retrieve the next offender if not local address
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offender, _ := spammers.Pop()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offenders = append(offenders, offender.(common.Address))
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Equalize balances until all the same or below threshold
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if len(offenders) &gt; 1 { //<span style="color:#ff0000;"> 第一次进入这个循环的时候， offenders队列里面有交易数量最大的两个账户</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Calculate the equalization threshold for all current offenders
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<span style="color:#ff0000;"> 把最后加入的账户的交易数量当成本次的阈值</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold := pool.pending[offender.(common.Address)].Len()
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Iteratively reduce all offenders until below limit or threshold reached
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">遍历直到pending有效，或者是倒数第二个的交易数量等于最后一个的交易数量</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // <span style="color:#ff0000;">遍历除了最后一个账户以外的所有账户， 把他们的交易数量减去1.</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := 0; i &lt; len(offenders)-1; i++ {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[offenders[i]]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed()
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(offenders[i], nonce)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Removed fairness-exceeding pending transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending--
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
<span style="color:#ff0000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If still above threshold, reduce to limit or min allowance
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 经过上面的循环，所有的超过AccountSlots的账户的交易数量都变成了之前的最小值。
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果还是超过阈值，那么在继续从offenders里面每次删除一个。</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, addr := range offenders {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.pending[addr]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Cap(list.Len() - 1) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop the transaction from the global pools too
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash := tx.Hash()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete(pool.all, hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.priced.Removed()
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update the account nonce to the dropped transaction
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.pendingState.SetNonce(addr, nonce)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.Trace("Removed fairness-exceeding pending transaction", "hash", hash)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending--
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending))
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; //end if pending &gt; pool.config.GlobalSlots {
&nbsp; &nbsp; &nbsp; &nbsp; // If we've queued more transactions than the hard limit, drop oldest ones
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#ff0000;">// 我们处理了pending的限制， 下面需要处理future queue的限制了。</span>
&nbsp; &nbsp; &nbsp; &nbsp; queued := uint64(0)
&nbsp; &nbsp; &nbsp; &nbsp; for _, list := range pool.queue {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queued += uint64(list.Len())
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; if queued &gt; pool.config.GlobalQueue {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Sort all accounts with queued transactions by heartbeat
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses := make(addresssByHeartbeat, 0, len(pool.queue))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for addr := range pool.queue {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if !pool.locals.contains(addr) { // don't drop locals
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = append(addresses, addressByHeartbeat{addr, pool.beats[addr]})
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort.Sort(addresses)
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop transactions until the total is below the limit or only locals remain
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#ff0000;"> // 从后往前，也就是心跳越新的就越会被删除。</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr := addresses[len(addresses)-1]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list := pool.queue[addr.address]
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addresses = addresses[:len(addresses)-1]
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Drop all transactions if they are less than the overflow
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if size := uint64(list.Len()); size &lt;= drop {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for _, tx := range list.Flatten() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(tx.Hash())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop -= size
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(int64(size))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Otherwise drop only last few transactions
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txs := list.Flatten()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool.removeTx(txs[i].Hash())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drop--
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queuedRateLimitCounter.Inc(1)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff6666;"><strong>Nonce使用规则</strong></span>

为了防止交易重播，ETH（ETC）节点要求每笔交易必须有一个nonce数值。
每一个账户从同一个节点发起交易时，这个nonce值从0开始计数，发送一笔nonce对应加1。
当前面的nonce处理完成之后才会处理后面的nonce。

注意这里的前提条件是相同的地址在相同的节点发送交易。

1.当nonce太小（小于之前已经有交易使用的nonce值），交易会被直接拒绝。
2.当nonce太大,交易会一直处于队列之中,这也就是导致我们上面描述的问题的原因；
3.当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。
4.当交易处于queue中时停止geth客户端，那么交易queue中的交易会被清除掉。
</pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#ff0000;"><strong>txPool 在创建的时候，开启了一个阻塞式线程，用于响应外部区块链事件，各种报告，或者交易回收</strong></span></pre>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"><span style="color:#808080;"><em>// loop is the transaction pool's main event loop, waiting for and reacting to </em></span><span style="color:#808080;"><em>// outside blockchain events as well as for various reporting and transaction </em></span><span style="color:#808080;"><em>// eviction events. </em></span><span style="color:#000080;"><strong>func </strong></span>(pool *TxPool) <span style="color:#ff0000;"><strong>loop</strong></span>() {
   <span style="color:#000080;"><strong>defer </strong></span>pool.wg.Done()

   <span style="color:#808080;"><em>// Start the stats reporting and transaction eviction tickers </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>var </strong></span>prevPending, prevQueued, prevStales int

   report := time.NewTicker(statsReportInterval)
   <span style="color:#000080;"><strong>defer </strong></span>report.Stop()

   evict := time.NewTicker(evictionInterval)
   <span style="color:#000080;"><strong>defer </strong></span>evict.Stop()

   journal := time.NewTicker(pool.config.Rejournal)
   <span style="color:#000080;"><strong>defer </strong></span>journal.Stop()

   <span style="color:#808080;"><em>// Track the previous head headers for transaction reorgs </em></span><span style="color:#808080;"><em> </em></span>head := pool.chain.CurrentBlock()

   <span style="color:#808080;"><em>// Keep waiting for and reacting to the various events </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>for </strong></span>{
      <span style="color:#000080;"><strong>select </strong></span>{
      <span style="color:#808080;"><em>// Handle ChainHeadEvent </em></span><em><span style="color:#ff0000;">区块链 head 事件 handle</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>case </strong></span>ev := &lt;-pool.chainHeadCh:
         <span style="color:#000080;"><strong>if </strong></span>ev.Block != nil {
            pool.mu.Lock()
            <span style="color:#000080;"><strong>if </strong></span>pool.chainconfig.IsHomestead(ev.Block.Number()) {
               pool.homestead = <span style="color:#660e7a;"><strong><em>true </em></strong></span><span style="color:#660e7a;"><strong><em> </em></strong></span>}
            pool.reset(head.Header(), ev.Block.Header())
            head = ev.Block

            pool.mu.Unlock()
         }
      <span style="color:#808080;"><em>// Be unsubscribed due to system stopped，</em></span><em><span style="color:#ff0000;">系统停止导致的注销</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>case </strong></span>&lt;-pool.chainHeadSub.Err():
         <span style="color:#000080;"><strong>return </strong></span><span style="color:#000080;"><strong> </strong></span><span style="color:#000080;"><strong> </strong></span><span style="color:#808080;"><em>// Handle stats reporting ticks，</em></span><em><span style="color:#ff0000;">统计报告时钟的handle</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>case </strong></span>&lt;-report.C:
         pool.mu.RLock()
         pending, queued := pool.stats()
         stales := pool.priced.stales
         pool.mu.RUnlock()

         <span style="color:#000080;"><strong>if </strong></span>pending != prevPending || queued != prevQueued || stales != prevStales {
            log.Debug(<span style="color:#008000;"><strong>"Transaction pool status report"</strong></span>, <span style="color:#008000;"><strong>"executable"</strong></span>, pending, <span style="color:#008000;"><strong>"queued"</strong></span>, queued, <span style="color:#008000;"><strong>"stales"</strong></span>, stales)
            prevPending, prevQueued, prevStales = pending, queued, stales
         }

      <span style="color:#808080;"><em>// Handle inactive account transaction eviction，</em></span><em><span style="color:#ff0000;">不活跃的账户的交易回收handle</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>case </strong></span>&lt;-evict.C:
         pool.mu.Lock()
         <span style="color:#000080;"><strong>for </strong></span>addr := <span style="color:#000080;"><strong>range </strong></span>pool.queue {
            <span style="color:#808080;"><em>// Skip local transactions from the eviction mechanism </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>pool.locals.contains(addr) {
               <span style="color:#000080;"><strong>continue </strong></span><span style="color:#000080;"><strong> </strong></span>}
            <span style="color:#808080;"><em>// Any non-locals old enough should be removed </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>if </strong></span>time.Since(pool.beats[addr]) &gt; pool.config.Lifetime {
               <span style="color:#000080;"><strong>for </strong></span>_, tx := <span style="color:#000080;"><strong>range </strong></span>pool.queue[addr].Flatten() {
                  pool.removeTx(tx.Hash(), <span style="color:#660e7a;"><strong><em>true</em></strong></span>)
               }
            }
         }
         pool.mu.Unlock()

      <span style="color:#808080;"><em>// Handle local transaction journal rotation，</em></span><em><span style="color:#ff0000;">本地交易journal轮询handle</span></em><span style="color:#808080;"><em> </em></span><span style="color:#808080;"><em> </em></span><span style="color:#000080;"><strong>case </strong></span>&lt;-journal.C:
         <span style="color:#000080;"><strong>if </strong></span>pool.journal != nil {
            pool.mu.Lock()
            <span style="color:#000080;"><strong>if </strong></span>err := pool.journal.rotate(pool.local()); err != nil {
               log.Warn(<span style="color:#008000;"><strong>"Failed to rotate local tx journal"</strong></span>, <span style="color:#008000;"><strong>"err"</strong></span>, err)
            }
            pool.mu.Unlock()
         }
      }
   }
}</pre>
  <p></p>
  <pre style="background-color:rgb(255,255,255);font-family:'宋体';font-size:9pt;"></pre> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36391986/article/details/80615950,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_36391986/article/details/80615950,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
