<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>智能合约最佳实践 之 Solidity 编码规范 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="智能合约最佳实践 之 Solidity 编码规范" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。 &nbsp;最新P3D新盘 chunchou.com 命名规范 避免使用 小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。 合约、库、事件、枚举及结构体命名 合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。 函数、参数、变量及修饰器 函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如： 函数名应该如：getBalance，transfer，verifyOwner，addMember。 参数和变量应该如：initialSupply，senderAddress，account，isPreSale。 修饰器应该如：onlyAfter，onlyOwner。 代码格式相关 缩进 使用空格（spaces）而不是Tab, 缩进应该是4个空格 空行 合约之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 contract A { ... } contract B { ... } contract C { ... } 而不是使用： 1 2 3 4 5 6 7 8 9 10 contract A { ... } contract B { ... } contract C { ... } 函数之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 contract A { function spam() public { ... } function ham() public { ... } } 没有实现的话，空行可以省去，如： 1 2 3 4 contract A { function spam() public; function ham() public; } 而不是： 1 2 3 4 5 6 7 8 contract A { function spam() public { ... } function ham() public { ... } } 左括号应该跟定义在一行 定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用： 1 2 3 4 5 6 contract Coin { struct Bank { address owner; uint balance; } } 而不是： 1 2 3 4 5 6 7 contract Coin { struct Bank { address owner; uint balance; } } 左括号应该跟条件控制在一行 在使用if, else, while, for 时，推荐的写法是： 1 2 3 4 5 6 7 if (...) { ... } for (...) { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 if (...) { ... } while(...){ } for (...) { ...;} 如果控制语句内只有一行，括号可省略，如： 1 2 if (x &lt; 10) x += 1; 但像下面一个语句有多方就不能省略，如： 1 2 3 4 5 if (x &lt; 10) someArray.push(Coin({ name: &#39;spam&#39;, value: 42 })); 表达式内的空格 一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用： 1 spam(ham[1], Coin({name: &quot;ham&quot;})); 而不是： 1 spam( ham[ 1 ], Coin( { name: &quot;ham&quot; } ) ); 有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的： 1 function singleLine() public { spam(); } 分号；前不应该有空格，例如推荐使用： 1 function spam(uint i, Coin coin) public; 而不是： 1 function spam(uint i , Coin coin) public ; 不要为对齐添加不必要的空格，例如推荐使用： 1 2 3 x = 1; y = 2; long_variable = 3; 而不是： 1 2 3 x = 1; y = 2; long_variable = 3; 回退函数不应该有空格，例如推荐使用： 1 2 3 4 5 6 7 8 9 10 11 12 function() public { ... } ``` 而不是： ```js function () public { ... } 控制每一行长度 每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是： 1 2 3 4 5 thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3); 对应的赋值语句应该是这样写： 1 2 3 4 5 6 thisIsALongNestedMapping[being][set][to_some_value] = someFunction( argument1, argument2, argument3, argument4 ); 而不是： 1 2 3 4 thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1, argument2, argument3, argument4); 事件定义也应该遵循同样的原则，例如应该使用： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 event LongAndLotsOfArgs( adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options ); LongAndLotsOfArgs( sender, recipient, publicKey, amount, options ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 event LongAndLotsOfArgs(adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options); LongAndLotsOfArgs(sender, recipient, publicKey, amount, options); 文件编码格式 推荐使用utf-8 及 ASCII 编码 引入文件应该在最上方 建议使用： 1 2 3 4 5 6 7 8 9 10 11 import &quot;owned&quot;; contract A { ... } contract B is owned { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 11 contract A { ... } import &quot;owned&quot;; contract B is owned { ... } 函数编写规范 函数的顺序 在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是： 构造函数 回退函数 (如果有) 外部函数（external） 公有函数(public) 内部函数(internal) 私有函数（private） 同一类函数时，constant函数放在后面， 例如推荐方式为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 contract A { // 构造函数 function A() public { ... } // 回退函数 function() public { ... } // 外部函数 // ... // 带有constant 外部函数 // ... // 公有函数 // ... // 内部函数 // ... // 私有函数 // ... } 而不是下面的函数顺序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 contract A { // 外部函数 // ... // 公有函数 // ... // 内部函数 // ... function A() public { ... } function() public { ... } // 私有函数 // ... } 明确函数的可见性 所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用： 1 2 3 function explicitlyPublic(uint val) public { doSomething(); } 而不是 1 2 3 function implicitlyPublic(uint val) { doSomething(); } 可见性应该在修饰符前面 函数的可见性应该写在自定义的函数修饰符前面，例如： 1 2 3 function kill() public onlyowner { selfdestruct(owner); } 而不是 1 2 3 function kill() onlyowner public { selfdestruct(owner); } 区分函数和事件 为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。 1 2 3 4 5 6 7 // 不建议 event Transfer() {} function transfer() {} // 建议 event LogTransfer() {} function transfer() external {} &nbsp; 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 &nbsp; &nbsp; 需要交流的朋友扫描二维码 &nbsp; &nbsp; &nbsp; 常量 常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。 参考文献 Solidity style-guide 深入浅出区块链&nbsp;- 系统学习区块链，打造最好的区块链技术博客。 如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多" />
<meta property="og:description" content="每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。 &nbsp;最新P3D新盘 chunchou.com 命名规范 避免使用 小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。 合约、库、事件、枚举及结构体命名 合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。 函数、参数、变量及修饰器 函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如： 函数名应该如：getBalance，transfer，verifyOwner，addMember。 参数和变量应该如：initialSupply，senderAddress，account，isPreSale。 修饰器应该如：onlyAfter，onlyOwner。 代码格式相关 缩进 使用空格（spaces）而不是Tab, 缩进应该是4个空格 空行 合约之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 contract A { ... } contract B { ... } contract C { ... } 而不是使用： 1 2 3 4 5 6 7 8 9 10 contract A { ... } contract B { ... } contract C { ... } 函数之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 contract A { function spam() public { ... } function ham() public { ... } } 没有实现的话，空行可以省去，如： 1 2 3 4 contract A { function spam() public; function ham() public; } 而不是： 1 2 3 4 5 6 7 8 contract A { function spam() public { ... } function ham() public { ... } } 左括号应该跟定义在一行 定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用： 1 2 3 4 5 6 contract Coin { struct Bank { address owner; uint balance; } } 而不是： 1 2 3 4 5 6 7 contract Coin { struct Bank { address owner; uint balance; } } 左括号应该跟条件控制在一行 在使用if, else, while, for 时，推荐的写法是： 1 2 3 4 5 6 7 if (...) { ... } for (...) { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 if (...) { ... } while(...){ } for (...) { ...;} 如果控制语句内只有一行，括号可省略，如： 1 2 if (x &lt; 10) x += 1; 但像下面一个语句有多方就不能省略，如： 1 2 3 4 5 if (x &lt; 10) someArray.push(Coin({ name: &#39;spam&#39;, value: 42 })); 表达式内的空格 一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用： 1 spam(ham[1], Coin({name: &quot;ham&quot;})); 而不是： 1 spam( ham[ 1 ], Coin( { name: &quot;ham&quot; } ) ); 有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的： 1 function singleLine() public { spam(); } 分号；前不应该有空格，例如推荐使用： 1 function spam(uint i, Coin coin) public; 而不是： 1 function spam(uint i , Coin coin) public ; 不要为对齐添加不必要的空格，例如推荐使用： 1 2 3 x = 1; y = 2; long_variable = 3; 而不是： 1 2 3 x = 1; y = 2; long_variable = 3; 回退函数不应该有空格，例如推荐使用： 1 2 3 4 5 6 7 8 9 10 11 12 function() public { ... } ``` 而不是： ```js function () public { ... } 控制每一行长度 每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是： 1 2 3 4 5 thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3); 对应的赋值语句应该是这样写： 1 2 3 4 5 6 thisIsALongNestedMapping[being][set][to_some_value] = someFunction( argument1, argument2, argument3, argument4 ); 而不是： 1 2 3 4 thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1, argument2, argument3, argument4); 事件定义也应该遵循同样的原则，例如应该使用： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 event LongAndLotsOfArgs( adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options ); LongAndLotsOfArgs( sender, recipient, publicKey, amount, options ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 event LongAndLotsOfArgs(adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options); LongAndLotsOfArgs(sender, recipient, publicKey, amount, options); 文件编码格式 推荐使用utf-8 及 ASCII 编码 引入文件应该在最上方 建议使用： 1 2 3 4 5 6 7 8 9 10 11 import &quot;owned&quot;; contract A { ... } contract B is owned { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 11 contract A { ... } import &quot;owned&quot;; contract B is owned { ... } 函数编写规范 函数的顺序 在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是： 构造函数 回退函数 (如果有) 外部函数（external） 公有函数(public) 内部函数(internal) 私有函数（private） 同一类函数时，constant函数放在后面， 例如推荐方式为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 contract A { // 构造函数 function A() public { ... } // 回退函数 function() public { ... } // 外部函数 // ... // 带有constant 外部函数 // ... // 公有函数 // ... // 内部函数 // ... // 私有函数 // ... } 而不是下面的函数顺序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 contract A { // 外部函数 // ... // 公有函数 // ... // 内部函数 // ... function A() public { ... } function() public { ... } // 私有函数 // ... } 明确函数的可见性 所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用： 1 2 3 function explicitlyPublic(uint val) public { doSomething(); } 而不是 1 2 3 function implicitlyPublic(uint val) { doSomething(); } 可见性应该在修饰符前面 函数的可见性应该写在自定义的函数修饰符前面，例如： 1 2 3 function kill() public onlyowner { selfdestruct(owner); } 而不是 1 2 3 function kill() onlyowner public { selfdestruct(owner); } 区分函数和事件 为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。 1 2 3 4 5 6 7 // 不建议 event Transfer() {} function transfer() {} // 建议 event LogTransfer() {} function transfer() external {} &nbsp; 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 &nbsp; &nbsp; 需要交流的朋友扫描二维码 &nbsp; &nbsp; &nbsp; 常量 常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。 参考文献 Solidity style-guide 深入浅出区块链&nbsp;- 系统学习区块链，打造最好的区块链技术博客。 如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/21/da56284b907a7e3d9653c72df09fee2b.html" />
<meta property="og:url" content="https://mlh.app/2018/06/21/da56284b907a7e3d9653c72df09fee2b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。 &nbsp;最新P3D新盘 chunchou.com 命名规范 避免使用 小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。 合约、库、事件、枚举及结构体命名 合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。 函数、参数、变量及修饰器 函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如： 函数名应该如：getBalance，transfer，verifyOwner，addMember。 参数和变量应该如：initialSupply，senderAddress，account，isPreSale。 修饰器应该如：onlyAfter，onlyOwner。 代码格式相关 缩进 使用空格（spaces）而不是Tab, 缩进应该是4个空格 空行 合约之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 contract A { ... } contract B { ... } contract C { ... } 而不是使用： 1 2 3 4 5 6 7 8 9 10 contract A { ... } contract B { ... } contract C { ... } 函数之间应该有空行，例如： 1 2 3 4 5 6 7 8 9 contract A { function spam() public { ... } function ham() public { ... } } 没有实现的话，空行可以省去，如： 1 2 3 4 contract A { function spam() public; function ham() public; } 而不是： 1 2 3 4 5 6 7 8 contract A { function spam() public { ... } function ham() public { ... } } 左括号应该跟定义在一行 定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用： 1 2 3 4 5 6 contract Coin { struct Bank { address owner; uint balance; } } 而不是： 1 2 3 4 5 6 7 contract Coin { struct Bank { address owner; uint balance; } } 左括号应该跟条件控制在一行 在使用if, else, while, for 时，推荐的写法是： 1 2 3 4 5 6 7 if (...) { ... } for (...) { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 if (...) { ... } while(...){ } for (...) { ...;} 如果控制语句内只有一行，括号可省略，如： 1 2 if (x &lt; 10) x += 1; 但像下面一个语句有多方就不能省略，如： 1 2 3 4 5 if (x &lt; 10) someArray.push(Coin({ name: &#39;spam&#39;, value: 42 })); 表达式内的空格 一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用： 1 spam(ham[1], Coin({name: &quot;ham&quot;})); 而不是： 1 spam( ham[ 1 ], Coin( { name: &quot;ham&quot; } ) ); 有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的： 1 function singleLine() public { spam(); } 分号；前不应该有空格，例如推荐使用： 1 function spam(uint i, Coin coin) public; 而不是： 1 function spam(uint i , Coin coin) public ; 不要为对齐添加不必要的空格，例如推荐使用： 1 2 3 x = 1; y = 2; long_variable = 3; 而不是： 1 2 3 x = 1; y = 2; long_variable = 3; 回退函数不应该有空格，例如推荐使用： 1 2 3 4 5 6 7 8 9 10 11 12 function() public { ... } ``` 而不是： ```js function () public { ... } 控制每一行长度 每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是： 1 2 3 4 5 thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong(longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3 ); thisFunctionCallIsReallyLong( longArgument1, longArgument2, longArgument3); 对应的赋值语句应该是这样写： 1 2 3 4 5 6 thisIsALongNestedMapping[being][set][to_some_value] = someFunction( argument1, argument2, argument3, argument4 ); 而不是： 1 2 3 4 thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1, argument2, argument3, argument4); 事件定义也应该遵循同样的原则，例如应该使用： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 event LongAndLotsOfArgs( adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options ); LongAndLotsOfArgs( sender, recipient, publicKey, amount, options ); 而不是： 1 2 3 4 5 6 7 8 9 10 11 event LongAndLotsOfArgs(adress sender, adress recipient, uint256 publicKey, uint256 amount, bytes32[] options); LongAndLotsOfArgs(sender, recipient, publicKey, amount, options); 文件编码格式 推荐使用utf-8 及 ASCII 编码 引入文件应该在最上方 建议使用： 1 2 3 4 5 6 7 8 9 10 11 import &quot;owned&quot;; contract A { ... } contract B is owned { ... } 而不是： 1 2 3 4 5 6 7 8 9 10 11 contract A { ... } import &quot;owned&quot;; contract B is owned { ... } 函数编写规范 函数的顺序 在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是： 构造函数 回退函数 (如果有) 外部函数（external） 公有函数(public) 内部函数(internal) 私有函数（private） 同一类函数时，constant函数放在后面， 例如推荐方式为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 contract A { // 构造函数 function A() public { ... } // 回退函数 function() public { ... } // 外部函数 // ... // 带有constant 外部函数 // ... // 公有函数 // ... // 内部函数 // ... // 私有函数 // ... } 而不是下面的函数顺序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 contract A { // 外部函数 // ... // 公有函数 // ... // 内部函数 // ... function A() public { ... } function() public { ... } // 私有函数 // ... } 明确函数的可见性 所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用： 1 2 3 function explicitlyPublic(uint val) public { doSomething(); } 而不是 1 2 3 function implicitlyPublic(uint val) { doSomething(); } 可见性应该在修饰符前面 函数的可见性应该写在自定义的函数修饰符前面，例如： 1 2 3 function kill() public onlyowner { selfdestruct(owner); } 而不是 1 2 3 function kill() onlyowner public { selfdestruct(owner); } 区分函数和事件 为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。 1 2 3 4 5 6 7 // 不建议 event Transfer() {} function transfer() {} // 建议 event LogTransfer() {} function transfer() external {} &nbsp; 打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。 &nbsp; &nbsp; 需要交流的朋友扫描二维码 &nbsp; &nbsp; &nbsp; 常量 常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。 参考文献 Solidity style-guide 深入浅出区块链&nbsp;- 系统学习区块链，打造最好的区块链技术博客。 如果你想和我有密切的联系，欢迎加入知识星球深入浅出区块链，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。 360浏览器版MetaMask中文版下载地址https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi 360极速浏览器版MetaMask中文版下载地址https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi 百度云下载地址https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA MetaMask中文版谷歌下载地址https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/21/da56284b907a7e3d9653c72df09fee2b.html","headline":"智能合约最佳实践 之 Solidity 编码规范","dateModified":"2018-06-21T00:00:00+08:00","datePublished":"2018-06-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/21/da56284b907a7e3d9653c72df09fee2b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>智能合约最佳实践 之 Solidity 编码规范</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>每一门语言都有其相应的编码规范， Solidity 也一样， 下面官方推荐的规范及我的总结，供大家参考，希望可以帮助大家写出更好规范的智能合约。</p> 
  <p>&nbsp;最新P3D新盘 chunchou.com</p> 
  <h2>命名规范</h2> 
  <h3>避免使用</h3> 
  <p>小写的l，大写的I，大写的O 应该避免在命名中单独出现，因为很容易产生混淆。</p> 
  <h3>合约、库、事件、枚举及结构体命名</h3> 
  <p>合约、库、事件及结构体命名应该使用单词首字母大写的方式，这个方式也称为：帕斯卡命名法或大驼峰式命名法，比如：SimpleToken， SmartBank， CertificateHashRepository，Player。</p> 
  <h3>函数、参数、变量及修饰器</h3> 
  <p>函数、参数、变量及修饰器应该使用首单词小写后面单词大写的方式，这个方式也称为：（小）驼峰式命名法，是一种混合大小写的方式，如：</p> 
  <ul>
   <li>函数名应该如：getBalance，transfer，verifyOwner，addMember。</li> 
   <li>参数和变量应该如：initialSupply，senderAddress，account，isPreSale。</li> 
   <li>修饰器应该如：onlyAfter，onlyOwner。</li> 
  </ul>
  <h2>代码格式相关</h2> 
  <h3>缩进</h3> 
  <p>使用空格（spaces）而不是Tab, 缩进应该是4个空格</p> 
  <h3>空行</h3> 
  <p>合约之间应该有空行，例如：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
13
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    ...
}
    
    
contract B {
    ...
}
    
    
contract C {
    ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是使用：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    ...
}
contract B {
    ...
}
    
contract C {
    ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <ul>
   <li>函数之间应该有空行，例如：</li> 
  </ul>
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    function spam() public {
        ...
    }
    
    function ham() public {
        ...
    }
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>没有实现的话，空行可以省去，如：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    function spam() public;
    function ham() public;
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    function spam() public {
        ...
    }
    function ham() public {
        ...
    }
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>左括号应该跟定义在一行</h3> 
  <p>定义包括合约定义、函数定义、库定义、结构体定义等等，例如推荐使用：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html"> contract Coin {
    struct Bank {
        address owner;
        uint balance;
    }
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract Coin
{
    struct Bank {
        address owner;
        uint balance;
    }
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>左括号应该跟条件控制在一行</h3> 
  <p>在使用if, else, while, for 时，推荐的写法是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">if (...) {
    ...
}

for (...) {
    ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">if (...)
{
    ...
}

while(...){
}

for (...) {
    ...;}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>如果控制语句内只有一行，括号可省略，如：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">if (x &lt; 10)
    x += 1;
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>但像下面一个语句有多方就不能省略，如：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">if (x &lt; 10)
    someArray.push(Coin({
        name: 'spam',
        value: 42
    }));
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>表达式内的空格</h3> 
  <ul>
   <li> <p>一个单行的表达里，在小括号、中括号、大括号里应该避免不必要的空格，例如推荐使用：</p> 
    <table>
     <tbody>
      <tr>
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
</code></pre> </td> 
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">spam(ham[1], Coin({name: "ham"}));
</code></pre> </td> 
      </tr>
     </tbody>
    </table></li> 
  </ul>
  <pre class="has">
<code>而不是：

</code></pre> 
  <pre class="has">
<code>1
</code></pre> 
  <pre>
<code>spam( ham[ <span style="color:#718c00;">1</span> ], Coin( { name: <span style="color:#718c00;">"ham"</span> } ) );
</code></pre> 
  <p><code>有一种例外是，结尾的括号跟在结束的分号后面， 应该加一个空格，如下面的方式也是推荐的：</code></p> 
  <pre class="has">
<code>1
</code></pre> 
  <pre>
<code><span style="color:#4271ae;"><span style="color:#8959a8;">function</span> <span style="color:#3e999f;">singleLine</span>() <span style="color:#3e999f;">public</span> </span>{ spam(); }
</code></pre> 
  <ul>
   <li> <p>分号；前不应该有空格，例如推荐使用：</p> 
    <table>
     <tbody>
      <tr>
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
</code></pre> </td> 
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function spam(uint i, Coin coin) public;
</code></pre> </td> 
      </tr>
     </tbody>
    </table></li> 
  </ul>
  <pre class="has">
<code>而不是：

</code></pre> 
  <pre class="has">
<code>1
</code></pre> 
  <pre>
<code><span style="color:#4271ae;"><span style="color:#8959a8;">function</span> <span style="color:#3e999f;">spam</span>(<span style="color:#f5871f;">uint i , Coin coin</span>) <span style="color:#3e999f;">public</span> ;</span>
</code></pre> 
  <ul>
   <li> <p>不要为对齐添加不必要的空格，例如推荐使用：</p> 
    <table>
     <tbody>
      <tr>
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
</code></pre> </td> 
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">x = 1;
y = 2;
long_variable = 3;
</code></pre> </td> 
      </tr>
     </tbody>
    </table></li> 
  </ul>
  <pre class="has">
<code>而不是：

</code></pre> 
  <pre class="has">
<code>1
2
3
</code></pre> 
  <pre>
<code>x             = <span style="color:#718c00;">1</span>;
y             = <span style="color:#718c00;">2</span>;
long_variable = <span style="color:#718c00;">3</span>;
</code></pre> 
  <ul>
   <li> <p>回退函数不应该有空格，例如推荐使用：</p> 
    <table>
     <tbody>
      <tr>
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
</code></pre> </td> 
       <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function() public {
    ...
}

``` 

而不是：

```js
function () public {
    ...
}
</code></pre> </td> 
      </tr>
     </tbody>
    </table></li> 
  </ul>
  <h3>控制每一行长度</h3> 
  <p>每行不应该太长，最好在79（或99）个字符以内，函数的参数应该是单独的行，且只有一个缩进，例如推荐的方式是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">thisFunctionCallIsReallyLong(
    longArgument1,
    longArgument2,
    longArgument3
);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">thisFunctionCallIsReallyLong(longArgument1,
                              longArgument2,
                              longArgument3
);

thisFunctionCallIsReallyLong(longArgument1,
    longArgument2,
    longArgument3
);

thisFunctionCallIsReallyLong(
    longArgument1, longArgument2,
    longArgument3
);

thisFunctionCallIsReallyLong(
longArgument1,
longArgument2,
longArgument3
);

thisFunctionCallIsReallyLong(
    longArgument1,
    longArgument2,
    longArgument3);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>对应的赋值语句应该是这样写：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html"> thisIsALongNestedMapping[being][set][to_some_value] = someFunction(
    argument1,
    argument2,
    argument3,
    argument4
);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,
                                                                   argument2,
                                                                   argument3,
                                                                   argument4);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>事件定义也应该遵循同样的原则，例如应该使用：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">event LongAndLotsOfArgs(
    adress sender,
    adress recipient,
    uint256 publicKey,
    uint256 amount,
    bytes32[] options
);

LongAndLotsOfArgs(
    sender,
    recipient,
    publicKey,
    amount,
    options
);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">event LongAndLotsOfArgs(adress sender,
                        adress recipient,
                        uint256 publicKey,
                        uint256 amount,
                        bytes32[] options);

LongAndLotsOfArgs(sender,
                  recipient,
                  publicKey,
                  amount,
                  options);
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>文件编码格式</h3> 
  <p>推荐使用utf-8 及 ASCII 编码</p> 
  <h3>引入文件应该在最上方</h3> 
  <p>建议使用：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">import "owned";


contract A {
    ...
}


contract B is owned {
    ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">contract A {
    ...
}


import "owned";


contract B is owned {
    ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h2>函数编写规范</h2> 
  <h3>函数的顺序</h3> 
  <p>在编写函数的时候，应该让大家容易找到构造函数，回退函数，官方推荐的的函数顺序是：</p> 
  <ol>
   <li>构造函数</li> 
   <li>回退函数 (如果有)</li> 
   <li>外部函数（external）</li> 
   <li>公有函数(public)</li> 
   <li>内部函数(internal)</li> 
   <li>私有函数（private）</li> 
  </ol>
  <p>同一类函数时，constant函数放在后面， 例如推荐方式为：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html"> contract A {
    // 构造函数
    function A() public {
        ...
    }

    // 回退函数
    function() public {
        ...
    }

    // 外部函数
    // ...

    // 带有constant 外部函数 
    // ...

    // 公有函数
    // ...

    // 内部函数
    // ...

    // 私有函数
    // ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是下面的函数顺序：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html"> contract A {


    // 外部函数
    // ...

    // 公有函数
    // ...

    // 内部函数
    // ...
    
    function A() public {
        ...
    }

    function() public {
        ...
    }

    // 私有函数
    // ...
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>明确函数的可见性</h3> 
  <p>所有的函数（包括构造函数）应该在定义的时候明确函数的可见性，例如应该使用：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function explicitlyPublic(uint val) public {
    doSomething();
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function implicitlyPublic(uint val) {
    doSomething();
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>可见性应该在修饰符前面</h3> 
  <p>函数的可见性应该写在自定义的函数修饰符前面，例如：</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function kill() public onlyowner {
    selfdestruct(owner);
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <p>而不是</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">function kill() onlyowner public {
    selfdestruct(owner);
}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>区分函数和事件</h3> 
  <p>为了防止函数和事件（Event）产生混淆，声明一个事件使用大写并加入前缀（可使用LOG）。对于函数， 始终以小写字母开头，构造函数除外。</p> 
  <table>
   <tbody>
    <tr>
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">1
2
3
4
5
6
7
</code></pre> </td> 
     <td style="vertical-align:middle;"> <pre class="has">
<code class="language-html">// 不建议
event Transfer() {}
function transfer() {}

// 建议
event LogTransfer() {}
function transfer() external {}
</code></pre> </td> 
    </tr>
   </tbody>
  </table>
  <h3>&nbsp;</h3> 
  <p><span style="color:#3e3e3e;">打个小广告，imtoken搜索HL，领取10万枚hotlove真爱链，可以在云加密交易所yunjiami.github.io/直接交易哦。</span></p> 
  <p><span style="color:#3e3e3e;">&nbsp;</span></p> 
  <p><span style="color:#3e3e3e;">&nbsp;</span></p> 
  <p><span style="color:#3e3e3e;">需要交流的朋友扫描二维码</span></p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180621162025974?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pdW1lbmdsb25nMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <h3>&nbsp;</h3> 
  <p>&nbsp;</p> 
  <h3>常量</h3> 
  <p>常量应该使用全大写及下划线分割大词的方式，如：MAX_BLOCKS，TOKEN_NAME， CONTRACT_VERSION。</p> 
  <h2>参考文献</h2> 
  <p><a href="https://solidity.readthedocs.io/en/v0.4.23/style-guide.html" rel="nofollow">Solidity style-guide</a></p> 
  <p><a href="https://learnblockchain.cn/" rel="nofollow">深入浅出区块链</a>&nbsp;- 系统学习区块链，打造最好的区块链技术博客。<br> 如果你想和我有密切的联系，欢迎加入知识星球<a href="https://t.xiaomiquan.com/RfAu7uj" rel="nofollow">深入浅出区块链</a>，我会在星球为大家解答技术问题，作为星友福利，星友可加入我创建的区块链技术群，群内已经聚集了200多位区块链技术牛人和爱好者。</p> 
  <p>360浏览器版MetaMask中文版下载地址<br><a href="https://ext.se.360.cn/webstore/detail/cickkggoijngnjkmbmkibdhmklahopfi" rel="nofollow">https://ext.se.360.cn/webstore/d ... jkmbmkibdhmklahopfi</a><br><br> 360极速浏览器版MetaMask中文版下载地址<br><a href="https://ext.chrome.360.cn/webstore/detail/cickkggoijngnjkmbmkibdhmklahopfi" rel="nofollow">https://ext.chrome.360.cn/websto ... jkmbmkibdhmklahopfi</a><br><br> 百度云下载地址<br><a href="https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA" rel="nofollow">https://pan.baidu.com/s/17gPqvtGA_rF6ujwElZchgA</a><br><br> MetaMask中文版谷歌下载地址<br><a href="https://chrome.google.com/webstore/search/metamask%20%E4%B8%AD%E6%96%87?hl=zh-CN" rel="nofollow">https://chrome.google.com/websto ... D%E6%96%87?hl=zh-CN</a></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/niumenglong1/article/details/80762320,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/niumenglong1/article/details/80762320,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
