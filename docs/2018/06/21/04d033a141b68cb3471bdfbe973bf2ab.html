<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解） 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 （ps:这是本博主撰写的第二部系列作品，第一部是写的java入门教程，受到了不少读者的喜欢，如果你也喜欢的话，欢迎关注哟!) 本教程主要面向区块链新手，用通俗易懂的方式讲解区块链技术。 这一小节，我们主要讲以太访、智能合约、web3三者之间的关系，以及智能合约(solidity)的基本特性。为了方便开发，理解这些是非常有必要的。 以太访、web3、智能合约 什么是以太访，到这里我想大家大概都已经明白了。那什么是web3（泛指web3.js、web3.py等）呢？前面也提到过，它就相当于是以太访区块链的接口（api），我们是通过web3，把智能合约部署在区块链上的，我们是通过web3获取到的区块链相关信息以及进行一些交易。更多细节请参考：web3.js API中文文档 web3 其实web3无非是封装的以太访的JSON-RPC，其JSON-RPC针对不同版本的以太访客户端支持以下请求方式： cpp-ethereum go-ethereum py-ethereum parity JSON-RPC 1.0 ✓ JSON-RPC 2.0 ✓ ✓ ✓ Batch requests ✓ ✓ ✓ HTTP ✓ ✓ ✓ IPC ✓ ✓ WS ✓ 更多请参考： JSON-RPC Management APIs 智能合约，Solidity的特性介绍 以太访中，开发智能合约有很多种语言： Solidity：这是一种类似于js的语言，并且这个语言被称为开发智能合约的旗舰语言。 Serpent：这是一种类似于Python的语言。 LLL：这是一种类似于汇编的低级语言。 Mutan：这是一种类似于C的语言，目前已被放弃。 而目前官方的最流行的就是solidity。 Solidity的合约其实就类似于面向对象里所说的类（从某种意义来说，其实就是！），但是和传统的类又有所不同，其不同点主要在以下几点（仅对代码而言）： 1. 调用机制不同 2. 成员类型不同 3. 构造函数不能重载 cankao我们将详细讲解以上几点： Solidity的调用机制 Solidity的函数调用机制是消息调用的模式，什么是消息调用呢？ 其实可以简单的把它理解成交易（ps:可以把智能合约的所有的函数调用都理解成交易，这也是为什么说智能合约是通过用户的交易行为触发的。），交易即要有发起交易的人，发送目标是什么，发送的数额是多少等。也就是说，每次的函数调用，也得有这些数据。 我们在合约函数内部可以用msg.sender获取调用函数的人（即上面提到的发起交易的人），msg.value获取用户发生的金额（可无），有没有发生目标根据函数实现的具体功能来确定。 而通过web3调用函数时，也得在函数参数后面加一个：{from:web3.eth.accounts[0], gas:44000000} 类似这样的一个参数。 调用函数的gas费 我们前面提到，调用合约函数是需要Gas费的，具体的说是，调用涉及写操作的函数是需要Gas费的，如果只是读操作，比如说读状态变量等，可以通过call()的方式调，这样是不需要消耗Gas费的，关于Gas费的计费方式我们前面已经讲到过，这里就不一一阐述了。 成员类型 像java、c++等面向对象的语言一般只有public、protected、private这三种类型，而solidity里有:public、private、internal、external四种类型，其中分别表示的意义是： public: 默认是public属性，即内部和外部都可以访问 private：仅当前合约内可以访问 internal: 仅当前合约以及所继承的合约可以访问 external: 仅合约外部可以访问 需要注意的是，不像传统语言那样，成员变量的外部调用可以更改变量的值，solidity的成员外部调用是不可以修改变量值的，任何类型都不能修改。 需要注意的另一个点：不同的类型的gas花费是不同的，能少用public尽量少用public，为什么呢？下面我们来看实例： pragma solidity^0.4.18; contract Test { uint[10] x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; function test(uint[10] a) public returns (uint){ return a[9]*2; } function test2(uint[10] a) external returns (uint){ return a[9]*2; } function calltest() { test(x); } function calltest2() { this.test2(x); //test2(x); //不能在内部调用一个外部函数，会报编译错误。 } } 打开Remix - Solidity IDE,帖入代码，创建合约。 然后，我们分别调用test及test2，对比执行花费的gas。 可以看到调用pubic函数花销更大，这是为什么呢？ 当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。 那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。 对于external函数不允许内部调用，它直接从calldata读取数据，省去了复制的过程。 所以，如果确认一个函数仅仅在外部访问，请用external。 同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过this.f()模式调用，会有一个大开销的CALL调用，并且它传参的方式也比内部传递开销更大。 因此，极不建议用this.function()的方式在内部调用external的函数，如果需要内外部都能访问，还是老实用public吧。 同理，我们把external改成private或者internal，我们会发现external、private会比public的花费更少，因此，当成员变量只需要内部访问时，尽量用private或者internal。 总之，当我们确定好成员的使用范围时，用其相应的类型就好，不要一位的使用public。 Solidity函数中view,constant,pure,payable的使用 contant: 函数有返回值，且返回的是状态变量。 pure:函数有返回值，且返回的不是变量，返回的是一个具体的值。 view:函数有返回值，返回的既不是具体的值也不是状态变量，例如：局部变量、msg.sender等。 payable: 可以通过这个函数发送以太币给合约。 ​ Solidity的数据类型 Solidity 类型分为两类：值类型(Value Type) 及 引用类型(Reference Types)。 值类型(Value Type) 值类型包含: 布尔类型(Booleans) 整型(Integers) 定长浮点型(Fixed Point Numbers) 定长字节数组(Fixed-size byte arrays) 有理数和整型常量(Rational and Integer Literals) 字符串常量（String literals） 十六进制常量（Hexadecimal literals） 枚举(Enums) 函数(Function Types) 地址(Address) 地址常量(Address Literals) 布尔类型(Booleans) 布尔(bool):可能的取值为常量值true和false。 布尔类型支持的运算符有： ！逻辑非 &amp;&amp; 逻辑与 || 逻辑或 == 等于 != 不等于 注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。 cankao 整型(Integers) int/uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)， uint 和 int 默认对应的是 uint256 和 int256。 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 位操作符： &amp;，|，^(异或)，~（位取反） 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位) 说明： 整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。 整数除0会抛异常。 移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x * 2***y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。 不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。 注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。 定长浮点型（Fixed Point Numbers） 注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。 fixed/ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。 M表示这个类型要占用的位数，以8步进，可为8到256位。 N表示小数点的个数，可为0到80之前 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 算术操作符：+，-，一元运算-，一元运算+，*，/, %(取余数) 注意：它和大多数语言的float和double不一样，M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。 定长字节数组(Fixed-size byte arrays) 关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增） byte代表bytes1。 支持的运算符： 比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool） 位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位) 索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。 移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。 成员变量： .length：表示这个字节数组的长度（只读）。 cankao 变长（动态分配大小）字节数组（Dynamically-sized byte array） bytes:动态分配大小字节数组, 参见Arrays,不是值类型! string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型! 根据经验： bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。 如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。 有理数和整型常量(Rational and Integer Literals) 也有人把Literals翻译为字面量 整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。 10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3. 科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。 数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。 如：(2**800 + 1) - 2**800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。 只要操作数是整形，整型支持的运算符都适用于整型常量表达式。 如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。 注意： Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3 警告： 整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5 注意： 数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数： uint128 a = 1; uint128 b = 2.5 + a + 0.5; cankao上述代码编译不能通过，因为b会被编译器认为是小数型。 字符串常量 字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。 字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。 十六进制常量（Hexadecimal literals） 十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。cankao 它的值会用二进制来表示。 十六进制常量和字符串常量类似，也可以转换为字节数组。 枚举（Enums） 在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子： pragma solidity ^0.4.0; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() { choice = ActionChoices.GoStraight; } // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot; // will automatically be changed to &quot;getChoice() returns (uint8)&quot; // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) { return choice; } function getDefaultChoice() returns (uint) { return uint(defaultChoice); } } 引用类型 引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存贮在区块链中） 所有的复杂类型如数组(arrays)和数据结构(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。 根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。 函数参数（包含返回的参数）默认是memory。 局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。 局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量 还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。 数据位置指定非常重要，因为他们影响着赋值行为。 在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。 而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。 另一方面，将一个 memory 的引用类型赋值给另一个 memory 的引用，不会创建拷贝（即：memory 之间是引用传递）。 注意：不能将 memory 赋值给局部变量。 对于值类型，总是会进行拷贝。 下面看一段代码： pragma solidity ^0.4.0; contract C { uint[] x; // x的存储位置是storage // memoryArray的存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 从 memory 复制到 storage var y = x; // storage 引用传递局部变量y（y 是一个 storage 引用） y[7]; // 返回第8个元素 y.length = 2; // x同样会被修改 delete x; // y同样会被修改 // 错误， 不能将memory赋值给局部变量 // y = memoryArray; // 错误，不能通过引用销毁storage // delete y; g(x); // 引用传递， g可以改变x的内容 h(x); // 拷贝到memory， h无法改变x的内容 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } 总结 强制的数据位置(Forced data location) 外部函数(External function)的参数(不包括返回参数)强制为：calldata 状态变量(State variables)强制为: storage 默认数据位置（Default data location） 函数参数及返回参数：memory 复杂类型的局部变量：storage 深入分析 storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。 Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。 memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。 storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组 关于栈（stack） EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 值类型的局部变量是存储在栈上。 不同存储的消耗（gas消耗） storage 会永久保存合约状态变量，开销最大 memory 仅保存临时变量，函数调用之后释放，开销很小 stack 保存很小的局部变量，几乎免费使用，但有数量限制。 参考：Solidity官方文档-类型之data-location 捐助地址： BTC: 36Q4ivp2bJer9fUQ6uyj4a4yLuTpp28D1T ETH: 0x786fda245ff497ce18e53618369a3e730a18fc1b ENS: alextan.eth 阅读更多" />
<meta property="og:description" content="区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解） 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 （ps:这是本博主撰写的第二部系列作品，第一部是写的java入门教程，受到了不少读者的喜欢，如果你也喜欢的话，欢迎关注哟!) 本教程主要面向区块链新手，用通俗易懂的方式讲解区块链技术。 这一小节，我们主要讲以太访、智能合约、web3三者之间的关系，以及智能合约(solidity)的基本特性。为了方便开发，理解这些是非常有必要的。 以太访、web3、智能合约 什么是以太访，到这里我想大家大概都已经明白了。那什么是web3（泛指web3.js、web3.py等）呢？前面也提到过，它就相当于是以太访区块链的接口（api），我们是通过web3，把智能合约部署在区块链上的，我们是通过web3获取到的区块链相关信息以及进行一些交易。更多细节请参考：web3.js API中文文档 web3 其实web3无非是封装的以太访的JSON-RPC，其JSON-RPC针对不同版本的以太访客户端支持以下请求方式： cpp-ethereum go-ethereum py-ethereum parity JSON-RPC 1.0 ✓ JSON-RPC 2.0 ✓ ✓ ✓ Batch requests ✓ ✓ ✓ HTTP ✓ ✓ ✓ IPC ✓ ✓ WS ✓ 更多请参考： JSON-RPC Management APIs 智能合约，Solidity的特性介绍 以太访中，开发智能合约有很多种语言： Solidity：这是一种类似于js的语言，并且这个语言被称为开发智能合约的旗舰语言。 Serpent：这是一种类似于Python的语言。 LLL：这是一种类似于汇编的低级语言。 Mutan：这是一种类似于C的语言，目前已被放弃。 而目前官方的最流行的就是solidity。 Solidity的合约其实就类似于面向对象里所说的类（从某种意义来说，其实就是！），但是和传统的类又有所不同，其不同点主要在以下几点（仅对代码而言）： 1. 调用机制不同 2. 成员类型不同 3. 构造函数不能重载 cankao我们将详细讲解以上几点： Solidity的调用机制 Solidity的函数调用机制是消息调用的模式，什么是消息调用呢？ 其实可以简单的把它理解成交易（ps:可以把智能合约的所有的函数调用都理解成交易，这也是为什么说智能合约是通过用户的交易行为触发的。），交易即要有发起交易的人，发送目标是什么，发送的数额是多少等。也就是说，每次的函数调用，也得有这些数据。 我们在合约函数内部可以用msg.sender获取调用函数的人（即上面提到的发起交易的人），msg.value获取用户发生的金额（可无），有没有发生目标根据函数实现的具体功能来确定。 而通过web3调用函数时，也得在函数参数后面加一个：{from:web3.eth.accounts[0], gas:44000000} 类似这样的一个参数。 调用函数的gas费 我们前面提到，调用合约函数是需要Gas费的，具体的说是，调用涉及写操作的函数是需要Gas费的，如果只是读操作，比如说读状态变量等，可以通过call()的方式调，这样是不需要消耗Gas费的，关于Gas费的计费方式我们前面已经讲到过，这里就不一一阐述了。 成员类型 像java、c++等面向对象的语言一般只有public、protected、private这三种类型，而solidity里有:public、private、internal、external四种类型，其中分别表示的意义是： public: 默认是public属性，即内部和外部都可以访问 private：仅当前合约内可以访问 internal: 仅当前合约以及所继承的合约可以访问 external: 仅合约外部可以访问 需要注意的是，不像传统语言那样，成员变量的外部调用可以更改变量的值，solidity的成员外部调用是不可以修改变量值的，任何类型都不能修改。 需要注意的另一个点：不同的类型的gas花费是不同的，能少用public尽量少用public，为什么呢？下面我们来看实例： pragma solidity^0.4.18; contract Test { uint[10] x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; function test(uint[10] a) public returns (uint){ return a[9]*2; } function test2(uint[10] a) external returns (uint){ return a[9]*2; } function calltest() { test(x); } function calltest2() { this.test2(x); //test2(x); //不能在内部调用一个外部函数，会报编译错误。 } } 打开Remix - Solidity IDE,帖入代码，创建合约。 然后，我们分别调用test及test2，对比执行花费的gas。 可以看到调用pubic函数花销更大，这是为什么呢？ 当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。 那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。 对于external函数不允许内部调用，它直接从calldata读取数据，省去了复制的过程。 所以，如果确认一个函数仅仅在外部访问，请用external。 同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过this.f()模式调用，会有一个大开销的CALL调用，并且它传参的方式也比内部传递开销更大。 因此，极不建议用this.function()的方式在内部调用external的函数，如果需要内外部都能访问，还是老实用public吧。 同理，我们把external改成private或者internal，我们会发现external、private会比public的花费更少，因此，当成员变量只需要内部访问时，尽量用private或者internal。 总之，当我们确定好成员的使用范围时，用其相应的类型就好，不要一位的使用public。 Solidity函数中view,constant,pure,payable的使用 contant: 函数有返回值，且返回的是状态变量。 pure:函数有返回值，且返回的不是变量，返回的是一个具体的值。 view:函数有返回值，返回的既不是具体的值也不是状态变量，例如：局部变量、msg.sender等。 payable: 可以通过这个函数发送以太币给合约。 ​ Solidity的数据类型 Solidity 类型分为两类：值类型(Value Type) 及 引用类型(Reference Types)。 值类型(Value Type) 值类型包含: 布尔类型(Booleans) 整型(Integers) 定长浮点型(Fixed Point Numbers) 定长字节数组(Fixed-size byte arrays) 有理数和整型常量(Rational and Integer Literals) 字符串常量（String literals） 十六进制常量（Hexadecimal literals） 枚举(Enums) 函数(Function Types) 地址(Address) 地址常量(Address Literals) 布尔类型(Booleans) 布尔(bool):可能的取值为常量值true和false。 布尔类型支持的运算符有： ！逻辑非 &amp;&amp; 逻辑与 || 逻辑或 == 等于 != 不等于 注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。 cankao 整型(Integers) int/uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)， uint 和 int 默认对应的是 uint256 和 int256。 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 位操作符： &amp;，|，^(异或)，~（位取反） 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位) 说明： 整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。 整数除0会抛异常。 移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x * 2***y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。 不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。 注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。 定长浮点型（Fixed Point Numbers） 注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。 fixed/ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。 M表示这个类型要占用的位数，以8步进，可为8到256位。 N表示小数点的个数，可为0到80之前 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 算术操作符：+，-，一元运算-，一元运算+，*，/, %(取余数) 注意：它和大多数语言的float和double不一样，M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。 定长字节数组(Fixed-size byte arrays) 关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增） byte代表bytes1。 支持的运算符： 比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool） 位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位) 索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。 移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。 成员变量： .length：表示这个字节数组的长度（只读）。 cankao 变长（动态分配大小）字节数组（Dynamically-sized byte array） bytes:动态分配大小字节数组, 参见Arrays,不是值类型! string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型! 根据经验： bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。 如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。 有理数和整型常量(Rational and Integer Literals) 也有人把Literals翻译为字面量 整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。 10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3. 科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。 数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。 如：(2**800 + 1) - 2**800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。 只要操作数是整形，整型支持的运算符都适用于整型常量表达式。 如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。 注意： Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3 警告： 整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5 注意： 数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数： uint128 a = 1; uint128 b = 2.5 + a + 0.5; cankao上述代码编译不能通过，因为b会被编译器认为是小数型。 字符串常量 字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。 字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。 十六进制常量（Hexadecimal literals） 十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。cankao 它的值会用二进制来表示。 十六进制常量和字符串常量类似，也可以转换为字节数组。 枚举（Enums） 在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子： pragma solidity ^0.4.0; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() { choice = ActionChoices.GoStraight; } // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot; // will automatically be changed to &quot;getChoice() returns (uint8)&quot; // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) { return choice; } function getDefaultChoice() returns (uint) { return uint(defaultChoice); } } 引用类型 引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存贮在区块链中） 所有的复杂类型如数组(arrays)和数据结构(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。 根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。 函数参数（包含返回的参数）默认是memory。 局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。 局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量 还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。 数据位置指定非常重要，因为他们影响着赋值行为。 在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。 而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。 另一方面，将一个 memory 的引用类型赋值给另一个 memory 的引用，不会创建拷贝（即：memory 之间是引用传递）。 注意：不能将 memory 赋值给局部变量。 对于值类型，总是会进行拷贝。 下面看一段代码： pragma solidity ^0.4.0; contract C { uint[] x; // x的存储位置是storage // memoryArray的存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 从 memory 复制到 storage var y = x; // storage 引用传递局部变量y（y 是一个 storage 引用） y[7]; // 返回第8个元素 y.length = 2; // x同样会被修改 delete x; // y同样会被修改 // 错误， 不能将memory赋值给局部变量 // y = memoryArray; // 错误，不能通过引用销毁storage // delete y; g(x); // 引用传递， g可以改变x的内容 h(x); // 拷贝到memory， h无法改变x的内容 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } 总结 强制的数据位置(Forced data location) 外部函数(External function)的参数(不包括返回参数)强制为：calldata 状态变量(State variables)强制为: storage 默认数据位置（Default data location） 函数参数及返回参数：memory 复杂类型的局部变量：storage 深入分析 storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。 Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。 memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。 storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组 关于栈（stack） EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 值类型的局部变量是存储在栈上。 不同存储的消耗（gas消耗） storage 会永久保存合约状态变量，开销最大 memory 仅保存临时变量，函数调用之后释放，开销很小 stack 保存很小的局部变量，几乎免费使用，但有数量限制。 参考：Solidity官方文档-类型之data-location 捐助地址： BTC: 36Q4ivp2bJer9fUQ6uyj4a4yLuTpp28D1T ETH: 0x786fda245ff497ce18e53618369a3e730a18fc1b ENS: alextan.eth 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/21/04d033a141b68cb3471bdfbe973bf2ab.html" />
<meta property="og:url" content="https://mlh.app/2018/06/21/04d033a141b68cb3471bdfbe973bf2ab.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解） 作者: AlexTan CSDN: http://blog.csdn.net/alextan_ Github: https://github.com/AlexTan-b-z e-mail: alextanbz@gmail.com 前言 （ps:这是本博主撰写的第二部系列作品，第一部是写的java入门教程，受到了不少读者的喜欢，如果你也喜欢的话，欢迎关注哟!) 本教程主要面向区块链新手，用通俗易懂的方式讲解区块链技术。 这一小节，我们主要讲以太访、智能合约、web3三者之间的关系，以及智能合约(solidity)的基本特性。为了方便开发，理解这些是非常有必要的。 以太访、web3、智能合约 什么是以太访，到这里我想大家大概都已经明白了。那什么是web3（泛指web3.js、web3.py等）呢？前面也提到过，它就相当于是以太访区块链的接口（api），我们是通过web3，把智能合约部署在区块链上的，我们是通过web3获取到的区块链相关信息以及进行一些交易。更多细节请参考：web3.js API中文文档 web3 其实web3无非是封装的以太访的JSON-RPC，其JSON-RPC针对不同版本的以太访客户端支持以下请求方式： cpp-ethereum go-ethereum py-ethereum parity JSON-RPC 1.0 ✓ JSON-RPC 2.0 ✓ ✓ ✓ Batch requests ✓ ✓ ✓ HTTP ✓ ✓ ✓ IPC ✓ ✓ WS ✓ 更多请参考： JSON-RPC Management APIs 智能合约，Solidity的特性介绍 以太访中，开发智能合约有很多种语言： Solidity：这是一种类似于js的语言，并且这个语言被称为开发智能合约的旗舰语言。 Serpent：这是一种类似于Python的语言。 LLL：这是一种类似于汇编的低级语言。 Mutan：这是一种类似于C的语言，目前已被放弃。 而目前官方的最流行的就是solidity。 Solidity的合约其实就类似于面向对象里所说的类（从某种意义来说，其实就是！），但是和传统的类又有所不同，其不同点主要在以下几点（仅对代码而言）： 1. 调用机制不同 2. 成员类型不同 3. 构造函数不能重载 cankao我们将详细讲解以上几点： Solidity的调用机制 Solidity的函数调用机制是消息调用的模式，什么是消息调用呢？ 其实可以简单的把它理解成交易（ps:可以把智能合约的所有的函数调用都理解成交易，这也是为什么说智能合约是通过用户的交易行为触发的。），交易即要有发起交易的人，发送目标是什么，发送的数额是多少等。也就是说，每次的函数调用，也得有这些数据。 我们在合约函数内部可以用msg.sender获取调用函数的人（即上面提到的发起交易的人），msg.value获取用户发生的金额（可无），有没有发生目标根据函数实现的具体功能来确定。 而通过web3调用函数时，也得在函数参数后面加一个：{from:web3.eth.accounts[0], gas:44000000} 类似这样的一个参数。 调用函数的gas费 我们前面提到，调用合约函数是需要Gas费的，具体的说是，调用涉及写操作的函数是需要Gas费的，如果只是读操作，比如说读状态变量等，可以通过call()的方式调，这样是不需要消耗Gas费的，关于Gas费的计费方式我们前面已经讲到过，这里就不一一阐述了。 成员类型 像java、c++等面向对象的语言一般只有public、protected、private这三种类型，而solidity里有:public、private、internal、external四种类型，其中分别表示的意义是： public: 默认是public属性，即内部和外部都可以访问 private：仅当前合约内可以访问 internal: 仅当前合约以及所继承的合约可以访问 external: 仅合约外部可以访问 需要注意的是，不像传统语言那样，成员变量的外部调用可以更改变量的值，solidity的成员外部调用是不可以修改变量值的，任何类型都不能修改。 需要注意的另一个点：不同的类型的gas花费是不同的，能少用public尽量少用public，为什么呢？下面我们来看实例： pragma solidity^0.4.18; contract Test { uint[10] x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; function test(uint[10] a) public returns (uint){ return a[9]*2; } function test2(uint[10] a) external returns (uint){ return a[9]*2; } function calltest() { test(x); } function calltest2() { this.test2(x); //test2(x); //不能在内部调用一个外部函数，会报编译错误。 } } 打开Remix - Solidity IDE,帖入代码，创建合约。 然后，我们分别调用test及test2，对比执行花费的gas。 可以看到调用pubic函数花销更大，这是为什么呢？ 当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。 那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。 对于external函数不允许内部调用，它直接从calldata读取数据，省去了复制的过程。 所以，如果确认一个函数仅仅在外部访问，请用external。 同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过this.f()模式调用，会有一个大开销的CALL调用，并且它传参的方式也比内部传递开销更大。 因此，极不建议用this.function()的方式在内部调用external的函数，如果需要内外部都能访问，还是老实用public吧。 同理，我们把external改成private或者internal，我们会发现external、private会比public的花费更少，因此，当成员变量只需要内部访问时，尽量用private或者internal。 总之，当我们确定好成员的使用范围时，用其相应的类型就好，不要一位的使用public。 Solidity函数中view,constant,pure,payable的使用 contant: 函数有返回值，且返回的是状态变量。 pure:函数有返回值，且返回的不是变量，返回的是一个具体的值。 view:函数有返回值，返回的既不是具体的值也不是状态变量，例如：局部变量、msg.sender等。 payable: 可以通过这个函数发送以太币给合约。 ​ Solidity的数据类型 Solidity 类型分为两类：值类型(Value Type) 及 引用类型(Reference Types)。 值类型(Value Type) 值类型包含: 布尔类型(Booleans) 整型(Integers) 定长浮点型(Fixed Point Numbers) 定长字节数组(Fixed-size byte arrays) 有理数和整型常量(Rational and Integer Literals) 字符串常量（String literals） 十六进制常量（Hexadecimal literals） 枚举(Enums) 函数(Function Types) 地址(Address) 地址常量(Address Literals) 布尔类型(Booleans) 布尔(bool):可能的取值为常量值true和false。 布尔类型支持的运算符有： ！逻辑非 &amp;&amp; 逻辑与 || 逻辑或 == 等于 != 不等于 注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。 cankao 整型(Integers) int/uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)， uint 和 int 默认对应的是 uint256 和 int256。 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 位操作符： &amp;，|，^(异或)，~（位取反） 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位) 说明： 整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。 整数除0会抛异常。 移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x * 2***y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。 不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。 注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。 定长浮点型（Fixed Point Numbers） 注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。 fixed/ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。 M表示这个类型要占用的位数，以8步进，可为8到256位。 N表示小数点的个数，可为0到80之前 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 算术操作符：+，-，一元运算-，一元运算+，*，/, %(取余数) 注意：它和大多数语言的float和double不一样，M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。 定长字节数组(Fixed-size byte arrays) 关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增） byte代表bytes1。 支持的运算符： 比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool） 位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位) 索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。 移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。 成员变量： .length：表示这个字节数组的长度（只读）。 cankao 变长（动态分配大小）字节数组（Dynamically-sized byte array） bytes:动态分配大小字节数组, 参见Arrays,不是值类型! string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型! 根据经验： bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。 如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。 有理数和整型常量(Rational and Integer Literals) 也有人把Literals翻译为字面量 整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。 10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3. 科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。 数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。 如：(2**800 + 1) - 2**800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。 只要操作数是整形，整型支持的运算符都适用于整型常量表达式。 如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。 注意： Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3 警告： 整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5 注意： 数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数： uint128 a = 1; uint128 b = 2.5 + a + 0.5; cankao上述代码编译不能通过，因为b会被编译器认为是小数型。 字符串常量 字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。 字符串常量支持转义字符，比如\\n，\\xNN，\\uNNNN。其中\\xNN表示16进制值，最终转换合适的字节。而\\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。 十六进制常量（Hexadecimal literals） 十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。cankao 它的值会用二进制来表示。 十六进制常量和字符串常量类似，也可以转换为字节数组。 枚举（Enums） 在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子： pragma solidity ^0.4.0; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() { choice = ActionChoices.GoStraight; } // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot; // will automatically be changed to &quot;getChoice() returns (uint8)&quot; // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) { return choice; } function getDefaultChoice() returns (uint) { return uint(defaultChoice); } } 引用类型 引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存贮在区块链中） 所有的复杂类型如数组(arrays)和数据结构(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。 根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。 函数参数（包含返回的参数）默认是memory。 局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。 局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量 还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。 数据位置指定非常重要，因为他们影响着赋值行为。 在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。 而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。 另一方面，将一个 memory 的引用类型赋值给另一个 memory 的引用，不会创建拷贝（即：memory 之间是引用传递）。 注意：不能将 memory 赋值给局部变量。 对于值类型，总是会进行拷贝。 下面看一段代码： pragma solidity ^0.4.0; contract C { uint[] x; // x的存储位置是storage // memoryArray的存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 从 memory 复制到 storage var y = x; // storage 引用传递局部变量y（y 是一个 storage 引用） y[7]; // 返回第8个元素 y.length = 2; // x同样会被修改 delete x; // y同样会被修改 // 错误， 不能将memory赋值给局部变量 // y = memoryArray; // 错误，不能通过引用销毁storage // delete y; g(x); // 引用传递， g可以改变x的内容 h(x); // 拷贝到memory， h无法改变x的内容 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } 总结 强制的数据位置(Forced data location) 外部函数(External function)的参数(不包括返回参数)强制为：calldata 状态变量(State variables)强制为: storage 默认数据位置（Default data location） 函数参数及返回参数：memory 复杂类型的局部变量：storage 深入分析 storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。 Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。 memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。 storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组 关于栈（stack） EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 值类型的局部变量是存储在栈上。 不同存储的消耗（gas消耗） storage 会永久保存合约状态变量，开销最大 memory 仅保存临时变量，函数调用之后释放，开销很小 stack 保存很小的局部变量，几乎免费使用，但有数量限制。 参考：Solidity官方文档-类型之data-location 捐助地址： BTC: 36Q4ivp2bJer9fUQ6uyj4a4yLuTpp28D1T ETH: 0x786fda245ff497ce18e53618369a3e730a18fc1b ENS: alextan.eth 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/21/04d033a141b68cb3471bdfbe973bf2ab.html","headline":"区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解）","dateModified":"2018-06-21T00:00:00+08:00","datePublished":"2018-06-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/21/04d033a141b68cb3471bdfbe973bf2ab.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战dapp四以太访web3智能合约三者之间的关系及智能合约基本讲解">区块链入门教程之从比特币到以太访再到智能合约从架构概念到应用实战(DAPP)（四、以太访、web3、智能合约三者之间的关系及智能合约基本讲解）</h1> 
  <p><em>作者: AlexTan</em> <br> <em>CSDN: <a href="http://blog.csdn.net/alextan_" rel="nofollow">http://blog.csdn.net/alextan_</a></em> <br> <em>Github: <a href="https://github.com/AlexTan-b-z" rel="nofollow">https://github.com/AlexTan-b-z</a></em> <br> <em>e-mail: alextanbz@gmail.com</em></p> 
  <h2 id="前言">前言</h2> 
  <p><em>（ps:这是本博主撰写的第二部系列作品，第一部是写的<a href="https://blog.csdn.net/alextan_/article/details/65447446" rel="nofollow">java入门教程</a>，受到了不少读者的喜欢，如果你也喜欢的话，欢迎关注哟!)</em> </p> 
  <p>本教程主要面向区块链新手，用通俗易懂的方式讲解区块链技术。</p> 
  <p>这一小节，我们主要讲以太访、智能合约、web3三者之间的关系，以及智能合约(solidity)的基本特性。为了方便开发，理解这些是非常有必要的。</p> 
  <h2 id="以太访web3智能合约">以太访、web3、智能合约</h2> 
  <p>什么是以太访，到这里我想大家大概都已经明白了。那什么是web3（泛指web3.js、web3.py等）呢？前面也提到过，它就相当于是以太访区块链的接口（api），我们是通过web3，把智能合约部署在区块链上的，我们是通过web3获取到的区块链相关信息以及进行一些交易。更多细节请参考：<a href="http://web3.tryblockchain.org/Web3.js-api-refrence.html" rel="nofollow">web3.js API中文文档</a> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180621215145912?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhUYW5f/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h4 id="web3">web3</h4> 
  <p>其实web3无非是封装的以太访的JSON-RPC，其JSON-RPC针对不同版本的以太访客户端支持以下请求方式：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>cpp-ethereum</th> 
     <th>go-ethereum</th> 
     <th>py-ethereum</th> 
     <th>parity</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>JSON-RPC 1.0</td> 
     <td>✓</td> 
     <td></td> 
     <td></td> 
    </tr> 
    <tr> 
     <td>JSON-RPC 2.0</td> 
     <td>✓</td> 
     <td>✓</td> 
     <td>✓</td> 
    </tr> 
    <tr> 
     <td>Batch requests</td> 
     <td>✓</td> 
     <td>✓</td> 
     <td>✓</td> 
    </tr> 
    <tr> 
     <td>HTTP</td> 
     <td>✓</td> 
     <td>✓</td> 
     <td>✓</td> 
    </tr> 
    <tr> 
     <td>IPC</td> 
     <td>✓</td> 
     <td>✓</td> 
     <td></td> 
    </tr> 
    <tr> 
     <td>WS</td> 
     <td></td> 
     <td>✓</td> 
     <td></td> 
    </tr> 
   </tbody>
  </table> 
  <p>更多请参考：</p> 
  <ul> 
   <li><a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" rel="nofollow">JSON-RPC</a></li> 
   <li><a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs" rel="nofollow">Management APIs</a></li> 
  </ul> 
  <h2 id="智能合约solidity的特性介绍">智能合约，Solidity的特性介绍</h2> 
  <p>以太访中，开发智能合约有很多种语言：</p> 
  <ul> 
   <li><a href="http://solidity.readthedocs.io/en/latest/#" rel="nofollow">Solidity</a>：这是一种类似于js的语言，并且这个语言被称为开发智能合约的旗舰语言。</li> 
   <li>Serpent：这是一种类似于Python的语言。</li> 
   <li>LLL：这是一种类似于汇编的低级语言。</li> 
   <li>Mutan：这是一种类似于C的语言，目前已被放弃。</li> 
  </ul> 
  <p>而目前官方的最流行的就是solidity。</p> 
  <p>Solidity的合约其实就类似于面向对象里所说的类（从某种意义来说，其实就是！），但是和传统的类又有所不同，其不同点主要在以下几点（仅对代码而言）：</p> 
  <pre><code>    1.  调用机制不同
        2.  成员类型不同
        3.  构造函数不能重载
</code></pre> 
  <p>cankao我们将详细讲解以上几点：</p> 
  <h4 id="solidity的调用机制">Solidity的调用机制</h4> 
  <p>Solidity的函数调用机制是消息调用的模式，什么是消息调用呢？</p> 
  <p>其实可以简单的把它理解成交易（ps:可以把智能合约的所有的函数调用都理解成交易，这也是为什么说智能合约是通过用户的交易行为触发的。），交易即要有发起交易的人，发送目标是什么，发送的数额是多少等。也就是说，每次的函数调用，也得有这些数据。</p> 
  <p>我们在合约函数内部可以用<code>msg.sender</code>获取调用函数的人（即上面提到的发起交易的人），<code>msg.value</code>获取用户发生的金额（可无），有没有发生目标根据函数实现的具体功能来确定。</p> 
  <p>而通过web3调用函数时，也得在函数参数后面加一个：<code>{from:web3.eth.accounts[0], gas:44000000}</code> 类似这样的一个参数。</p> 
  <h4 id="调用函数的gas费">调用函数的gas费</h4> 
  <p>我们前面提到，调用合约函数是需要Gas费的，具体的说是，调用涉及写操作的函数是需要Gas费的，如果只是读操作，比如说读状态变量等，可以通过<code>call()</code>的方式调，这样是不需要消耗Gas费的，关于Gas费的计费方式我们前面已经讲到过，这里就不一一阐述了。</p> 
  <h4 id="成员类型">成员类型</h4> 
  <p>像java、c++等面向对象的语言一般只有<code>public、protected、private</code>这三种类型，而solidity里有:<code>public、private、internal、external</code>四种类型，其中分别表示的意义是：</p> 
  <ul> 
   <li>public: 默认是public属性，即内部和外部都可以访问</li> 
   <li>private：仅当前合约内可以访问</li> 
   <li>internal: 仅当前合约以及所继承的合约可以访问</li> 
   <li>external: 仅合约外部可以访问</li> 
  </ul> 
  <p>需要注意的是，不像传统语言那样，成员变量的外部调用可以更改变量的值，solidity的成员外部调用是不可以修改变量值的，<strong>任何类型都不能修改</strong>。</p> 
  <p>需要注意的另一个点：不同的类型的gas花费是不同的，能少用public尽量少用public，为什么呢？下面我们来看实例：</p> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity^<span class="hljs-number">0.4</span><span class="hljs-number">.18</span>;



contract Test {

    uint[<span class="hljs-number">10</span>] x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">(uint[10] a)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>{</span>

         <span class="hljs-keyword">return</span> a[<span class="hljs-number">9</span>]*<span class="hljs-number">2</span>;

    }



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span><span class="hljs-params">(uint[10] a)</span> <span class="hljs-title">external</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>{</span>

         <span class="hljs-keyword">return</span> a[<span class="hljs-number">9</span>]*<span class="hljs-number">2</span>;

    }



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calltest</span><span class="hljs-params">()</span> {</span>

        test(x);

    }



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calltest2</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">this</span>.test2(x);

        <span class="hljs-comment">//test2(x); //不能在内部调用一个外部函数，会报编译错误。</span>

    }  



}
</code></pre> 
  <p>打开<a href="https://ethereum.github.io/browser-solidity" rel="nofollow">Remix - Solidity IDE</a>,帖入代码，创建合约。 <br> 然后，我们分别调用test及test2，对比执行花费的gas。 <br> <img src="https://diycode.b0.upaiyun.com/photo/2017/94b78eb052b30877ebb569047d2493c7.jpg" alt="img" title=""> <br> <img src="https://diycode.b0.upaiyun.com/photo/2017/dc4b2d8d88a549da32cea567136e58ed.jpg" alt="img" title=""> <br> 可以看到调用pubic函数花销更大，这是为什么呢？</p> 
  <p>当使用public 函数时，Solidity会立即复制数组参数数据到内存， 而external函数则是从calldata读取，而分配内存开销比直接从calldata读取要大的多。 <br> 那为什么public函数要复制数组参数数据到内存呢？是因为public函数可能会被内部调用，而内部调用数组的参数是当做指向一块内存的指针。 <br> 对于external函数不允许内部调用，它直接从<strong>calldata</strong>读取数据，省去了复制的过程。</p> 
  <p>所以，如果确认一个函数仅仅在外部访问，请用<strong>external</strong>。</p> 
  <p>同样，我们接着对比calltest()及calltest2()，这里不截图了，大家自己运行对比一下，可以发现：calltest2的开销比calltest的开销大很多，这是因为通过<strong>this.f()</strong>模式调用，会有一个大开销的<strong>CALL</strong>调用，并且它传参的方式也比内部传递开销更大。</p> 
  <p>因此，极不建议用<code>this.function()</code>的方式在内部调用external的函数，如果需要内外部都能访问，还是老实用public吧。</p> 
  <p>同理，我们把external改成private或者internal，我们会发现external、private会比public的花费更少，因此，当成员变量只需要内部访问时，尽量用<strong>private</strong>或者<strong>internal</strong>。</p> 
  <p>总之，当我们确定好成员的使用范围时，用其相应的类型就好，不要一位的使用public。</p> 
  <h4 id="solidity函数中viewconstantpurepayable的使用">Solidity函数中view,constant,pure,payable的使用</h4> 
  <ul> 
   <li><p><strong>contant:</strong> 函数有返回值，且返回的是状态变量。</p></li> 
   <li><p><strong>pure:</strong>函数有返回值，且返回的不是变量，返回的是一个具体的值。</p></li> 
   <li><p><strong>view:</strong>函数有返回值，返回的既不是具体的值也不是状态变量，例如：局部变量、msg.sender等。</p></li> 
   <li><p><strong>payable:</strong> 可以通过这个函数发送以太币给合约。</p> <p>​</p></li> 
  </ul> 
  <h2 id="solidity的数据类型">Solidity的数据类型</h2> 
  <p>Solidity 类型分为两类：<strong>值类型(Value Type)</strong> 及 <strong>引用类型(Reference Types)</strong>。</p> 
  <h3 id="值类型value-type">值类型(Value Type)</h3> 
  <p><strong>值类型</strong>包含:</p> 
  <ul> 
   <li>布尔类型(Booleans)</li> 
   <li>整型(Integers)</li> 
   <li>定长浮点型(Fixed Point Numbers)</li> 
   <li>定长字节数组(Fixed-size byte arrays)</li> 
   <li>有理数和整型常量(Rational and Integer Literals)</li> 
   <li>字符串常量（String literals）</li> 
   <li>十六进制常量（Hexadecimal literals）</li> 
   <li>枚举(Enums)</li> 
   <li>函数(Function Types)</li> 
   <li>地址(Address)</li> 
   <li>地址常量(Address Literals)</li> 
  </ul> 
  <h4 id="布尔类型booleans">布尔类型(Booleans)</h4> 
  <p><strong>布尔(bool)</strong>:可能的取值为常量值<strong>true</strong>和<strong>false</strong>。</p> 
  <p>布尔类型支持的运算符有：</p> 
  <ul> 
   <li>！逻辑非</li> 
   <li>&amp;&amp; 逻辑与</li> 
   <li>|| 逻辑或</li> 
   <li>== 等于</li> 
   <li>!= 不等于</li> 
  </ul> 
  <p>注意：运算符<strong>&amp;&amp;</strong>和<strong>||</strong>是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。</p> 
  <p>cankao</p> 
  <h4 id="整型integers">整型(Integers)</h4> 
  <p><strong>int</strong>/<strong>uint</strong>: 表示有符号和无符号不同位数整数。支持关键字<strong>uint8</strong> 到 <strong>uint256</strong> (以8步进)， <br> <strong>uint</strong> 和 <strong>int</strong> 默认对应的是 <strong>uint256</strong> 和 <strong>int256</strong>。</p> 
  <p>支持的运算符：</p> 
  <ul> 
   <li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li> 
   <li>位操作符： &amp;，|，^(异或)，~（位取反）</li> 
   <li>算术操作符：+，-，一元运算-，一元运算+，<em>，/, %(取余数), **</em>（幂）, &lt;&lt; (左移位), &gt;&gt;(右移位)</li> 
  </ul> 
  <p>说明：</p> 
  <ol> 
   <li>整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。</li> 
   <li>整数除0会抛异常。</li> 
   <li>移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x * 2***y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。</li> 
   <li>不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。</li> 
  </ol> 
  <p>注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。</p> 
  <h4 id="定长浮点型fixed-point-numbers">定长浮点型（Fixed Point Numbers）</h4> 
  <p>注意：定长浮点型 Solidity（发文时）还不完全支持，它可以用来声明变量，但不可以用来赋值。 <br> <strong>fixed</strong>/<strong>ufixed</strong>: 表示有符号和无符号的固定位浮点数。关键字为<strong>ufixedMxN</strong> 和 <strong>ufixedMxN</strong>。 <br> <strong>M</strong>表示这个类型要占用的位数，以8步进，可为8到256位。 <br> <strong>N</strong>表示小数点的个数，可为0到80之前</p> 
  <p>支持的运算符：</p> 
  <ul> 
   <li>比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false)</li> 
   <li>算术操作符：+，-，一元运算-，一元运算+，*，/, %(取余数) <br> 注意：它和大多数语言的float和double不一样，<strong>M</strong>是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。</li> 
  </ul> 
  <h4 id="定长字节数组fixed-size-byte-arrays">定长字节数组(Fixed-size byte arrays)</h4> 
  <p>关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增） <br> byte代表bytes1。</p> 
  <p>支持的运算符：</p> 
  <ul> 
   <li>比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool）</li> 
   <li>位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位)</li> 
   <li>索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。</li> 
  </ul> 
  <p>移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。</p> 
  <p>成员变量： <br> <strong>.length</strong>：表示这个字节数组的长度（只读）。</p> 
  <p>cankao</p> 
  <h4 id="变长动态分配大小字节数组dynamically-sized-byte-array">变长（动态分配大小）字节数组（Dynamically-sized byte array）</h4> 
  <ul> 
   <li>bytes:动态分配大小字节数组, 参见<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" rel="nofollow">Arrays</a>,不是值类型!</li> 
   <li>string:动态分配大小UTF8编码的字符类型,参看<a href="http://solidity.readthedocs.io/en/latest/types.html#arrays" rel="nofollow">Arrays</a>。不是值类型!</li> 
  </ul> 
  <p>根据经验： <br> bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。 <br> 如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。</p> 
  <h4 id="有理数和整型常量rational-and-integer-literals">有理数和整型常量(Rational and Integer Literals)</h4> 
  <blockquote> 
   <p>也有人把Literals翻译为字面量</p> 
  </blockquote> 
  <p>整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。</p> 
  <p>10进制小数常量（Decimal fraction literals）带了一个<strong>.</strong>， 在<strong>.</strong>的两边至少有一个数字，有效的表示如:<strong>1.</strong>, <strong>.1</strong> 和 <strong>1.3</strong>.</p> 
  <p>科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: <strong>2e10</strong>, <strong>-2e10</strong>, <strong>2e-10</strong>, <strong>2.5e1</strong>。</p> 
  <p>数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。 <br> 如：(2**800 + 1) - 2**800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：<strong>.5 * 8</strong>的结果是4，尽管有非整形参与了运算。</p> 
  <p>只要操作数是整形，整型支持的运算符都适用于整型常量表达式。 <br> 如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。</p> 
  <p>注意： <br> Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3</p> 
  <p>警告： <br> 整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5</p> 
  <p>注意： <br> 数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数：</p> 
  <pre class="prettyprint"><code class=" hljs autohotkey">uint128 <span class="hljs-literal">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>

uint128 b = <span class="hljs-number">2.5</span> + <span class="hljs-literal">a</span> + <span class="hljs-number">0.5</span><span class="hljs-comment">;</span>
</code></pre> 
  <p>cankao上述代码编译不能通过，因为b会被编译器认为是小数型。</p> 
  <h4 id="字符串常量">字符串常量</h4> 
  <p>字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。</p> 
  <p>字符串常量支持转义字符，比如\n，\xNN，\uNNNN。其中\xNN表示16进制值，最终转换合适的字节。而\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。</p> 
  <h4 id="十六进制常量hexadecimal-literals">十六进制常量（Hexadecimal literals）</h4> 
  <p>十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。cankao <br> 它的值会用二进制来表示。</p> 
  <p>十六进制常量和字符串常量类似，也可以转换为字节数组。</p> 
  <h4 id="枚举enums">枚举（Enums）</h4> 
  <p>在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子：</p> 
  <pre class="prettyprint"><code class=" hljs coffeescript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;



contract test {

    <span class="hljs-reserved">enum</span> ActionChoices { GoLeft, GoRight, GoStraight, SitStill }

    ActionChoices choice;

    ActionChoices constant defaultChoice = ActionChoices.GoStraight;



    <span class="hljs-reserved">function</span> setGoStraight() {

        choice = ActionChoices.GoStraight;

    }



    <span class="hljs-regexp">//</span> Since <span class="hljs-reserved">enum</span> types are <span class="hljs-keyword">not</span> part <span class="hljs-keyword">of</span> the ABI, the signature <span class="hljs-keyword">of</span> <span class="hljs-string">"getChoice"</span>

    <span class="hljs-regexp">//</span> will automatically be changed to <span class="hljs-string">"getChoice() returns (uint8)"</span>

    <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> all matters external to Solidity. The integer type used <span class="hljs-keyword">is</span> just

    <span class="hljs-regexp">//</span> large enough to hold all <span class="hljs-reserved">enum</span> values, i.e. <span class="hljs-keyword">if</span> you have more values,

    <span class="hljs-regexp">//</span> `<span class="javascript">uint16</span>` will be used <span class="hljs-keyword">and</span> so <span class="hljs-literal">on</span>.

    <span class="hljs-reserved">function</span> getChoice() returns (ActionChoices) {

        <span class="hljs-keyword">return</span> choice;

    }



    <span class="hljs-reserved">function</span> getDefaultChoice() returns (uint) {

        <span class="hljs-keyword">return</span> uint(defaultChoice);

    }

}</code></pre> 
  <h3 id="引用类型">引用类型</h3> 
  <p>引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是<strong>memory</strong>（内存中，数据不是永久存在）还是<strong>storage</strong>（永久存贮在区块链中） <br> 所有的复杂类型如数组(arrays)和数据结构(struct)有一个额外的属性：<strong>数据的存储位置（data location）</strong>。可为<strong>memory</strong>和<strong>storage</strong>。</p> 
  <p>根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。</p> 
  <p>函数参数（包含返回的参数）默认是<strong>memory</strong>。 <br> 局部复杂类型变量（local variables）和 状态变量（state variables） 默认是<strong>storage</strong>。</p> 
  <blockquote> 
   <p>局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量</p> 
  </blockquote> 
  <p>还有一个存储位置是：<strong>calldata</strong>，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p> 
  <p>数据位置指定非常重要，因为他们影响着赋值行为。 <br> 在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。 <br> 而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。 <br> 另一方面，将一个 memory 的引用类型赋值给另一个 memory 的引用，不会创建拷贝（即：memory 之间是引用传递）。</p> 
  <blockquote> 
   <ol> 
    <li>注意：不能将 memory 赋值给局部变量。</li> 
    <li>对于值类型，总是会进行拷贝。</li> 
   </ol> 
  </blockquote> 
  <p>下面看一段代码：</p> 
  <pre class="prettyprint"><code class=" hljs cs">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;



contract C {

    <span class="hljs-keyword">uint</span>[] x; <span class="hljs-comment">// x的存储位置是storage</span>



    <span class="hljs-comment">// memoryArray的存储位置是 memory</span>

    function f(<span class="hljs-keyword">uint</span>[] memoryArray) <span class="hljs-keyword">public</span> {

        x = memoryArray;    <span class="hljs-comment">// 从 memory 复制到 storage</span>

        <span class="hljs-keyword">var</span> y = x;          <span class="hljs-comment">// storage 引用传递局部变量y（y 是一个 storage 引用）</span>

        y[<span class="hljs-number">7</span>];               <span class="hljs-comment">// 返回第8个元素</span>

        y.length = <span class="hljs-number">2</span>;       <span class="hljs-comment">// x同样会被修改</span>

        delete x;           <span class="hljs-comment">// y同样会被修改</span>



        <span class="hljs-comment">// 错误， 不能将memory赋值给局部变量</span>

        <span class="hljs-comment">// y = memoryArray; </span>



        <span class="hljs-comment">// 错误，不能通过引用销毁storage</span>

        <span class="hljs-comment">// delete y; </span>



        g(x);               <span class="hljs-comment">// 引用传递， g可以改变x的内容</span>

        h(x);               <span class="hljs-comment">// 拷贝到memory， h无法改变x的内容</span>

    }



    function g(<span class="hljs-keyword">uint</span>[] storage storageArray) <span class="hljs-keyword">internal</span> {}

    function h(<span class="hljs-keyword">uint</span>[] memoryArray) <span class="hljs-keyword">public</span> {}

}
</code></pre> 
  <h3 id="总结">总结</h3> 
  <h4 id="强制的数据位置forced-data-location">强制的数据位置(Forced data location)</h4> 
  <ul> 
   <li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li> 
   <li>状态变量(State variables)强制为: storage</li> 
  </ul> 
  <h4 id="默认数据位置default-data-location">默认数据位置（Default data location）</h4> 
  <ul> 
   <li>函数参数及返回参数：memory</li> 
   <li>复杂类型的局部变量：storage</li> 
  </ul> 
  <h3 id="深入分析">深入分析</h3> 
  <p>storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。</p> 
  <blockquote> 
   <p>Solidity 称这个为状态改变，这也是合约级变量称为<strong>状态变量</strong>的原因。也可以更好的理解为什么状态变量都是storage存储。</p> 
  </blockquote> 
  <p>memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。</p> 
  <blockquote> 
   <p>storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组</p> 
  </blockquote> 
  <h3 id="关于栈stack">关于栈（stack）</h3> 
  <p>EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 <br> 值类型的局部变量是存储在栈上。</p> 
  <h3 id="不同存储的消耗gas消耗">不同存储的消耗（gas消耗）</h3> 
  <ul> 
   <li>storage 会永久保存合约状态变量，开销最大</li> 
   <li>memory 仅保存临时变量，函数调用之后释放，开销很小</li> 
   <li>stack 保存很小的局部变量，几乎免费使用，但有数量限制。</li> 
  </ul> 
  <p>参考：<a href="https://solidity.readthedocs.io/en/develop/types.html#data-location" rel="nofollow">Solidity官方文档-类型之data-location</a></p> 
  <p>捐助地址： <br> BTC: <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018062121422722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhUYW5f/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>36Q4ivp2bJer9fUQ6uyj4a4yLuTpp28D1T</p> 
  <p>ETH: <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180621214245766?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhUYW5f/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>0x786fda245ff497ce18e53618369a3e730a18fc1b</p> 
  <p>ENS: alextan.eth</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AlexTan_/article/details/80766791,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AlexTan_/article/details/80766791,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
