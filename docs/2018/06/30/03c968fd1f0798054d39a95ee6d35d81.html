<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>fabric-node-sdk 编写第一个应用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="fabric-node-sdk 编写第一个应用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文参考官网示例:https://hyperledgercn.github.io/hyperledgerDocs/write_first_app_zh/ 测试环境linux 一、准备条件 准备条件与上篇相同。 本文用到的例子是fabric-simples中的fabcar，是一个与汽车属性相关的测试项目，后面的chaincode部分会讲。 二、启动网络 在fabcar目录下有个startFabric.sh脚本，这个脚本是用来启动网络和部署链码等一些准备条件，具体分为以下几步： 1）启动peer节点、Ordering节点、证书颁发机构以及CLI容器 2）创建一个通道，并将peer加入该通道 3）将智能合约（即链码）安装到peer节点的文件系统上，并在通道上实例化该链码；实例化会启动链码容器 4）调用initLedger功能来向通道账本写入10个不同的汽车 分析一下脚本的内容， #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error set -e # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 starttime=$(date +%s) LANGUAGE=${1:-&quot;golang&quot;} CC_SRC_PATH=github.com/fabcar/go if [ &quot;$LANGUAGE&quot; = &quot;node&quot; -o &quot;$LANGUAGE&quot; = &quot;NODE&quot; ]; then CC_SRC_PATH=/opt/gopath/src/github.com/fabcar/node fi # clean the keystore rm -rf ./hfc-key-store # launch network; create channel and join peer to channel cd ../basic-network ./start.sh # Now launch the CLI container in order to install, instantiate chaincode # and prime the ledger with our 10 cars docker-compose -f ./docker-compose.yml up -d cli docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode install -n fabcar -v 1.0 -p &quot;$CC_SRC_PATH&quot; -l &quot;$LANGUAGE&quot; docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -l &quot;$LANGUAGE&quot; -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; sleep 10 docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c &#39;{&quot;function&quot;:&quot;initLedger&quot;,&quot;Args&quot;:[&quot;&quot;]}&#39; printf &quot;\nTotal setup execution time : $(($(date +%s) - starttime)) secs ...\n\n\n&quot; printf &quot;Start by installing required packages run &#39;npm install&#39;\n&quot; printf &quot;Then run &#39;node enrollAdmin.js&#39;, then &#39;node registerUser&#39;\n\n&quot; printf &quot;The &#39;node invoke.js&#39; will fail until it has been updated with valid arguments\n&quot; printf &quot;The &#39;node query.js&#39; may be run at anytime once the user has been registered\n\n&quot; 首先启动网络，第23行，调用了另外一个脚本start.sh，在basic-network文件夹中，内容如下： #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error, print all commands. set -ev # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 docker-compose -f docker-compose.yml down docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb # wait for Hyperledger Fabric to start # incase of errors when running later commands, issue export FABRIC_START_TIMEOUT=&lt;larger number&gt; export FABRIC_START_TIMEOUT=10 #echo ${FABRIC_START_TIMEOUT} sleep ${FABRIC_START_TIMEOUT} # Create the channel docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx # Join peer0.org1.example.com to the channel. docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel join -b mychannel.block 其中第13行是关闭正在运行的docker容器（如果之前这个项目开启过，或者还有残留的话） 第15行根据docker-compose.yaml配置文件启动多个容器，启动-d后面的选项指定要开启的容器，包括一个ca证书颁发机构、一个排序节点、一个peer节点，使用的数据库是couchdb。 第24行，这里是在peer节点根据通道配置文件channel.tx（这个是示例下载后自带的，也可以自己生成，见上篇文章）来创建一个通道。如果进入peer节点的容器中（docker exec -it peer0.org1.example.com bash），会发现多了一个mychannel.block，这是通道的创世区块。 第26行，将peer节点加入通道中。 现在start.sh执行完了，回到startFabric.sh中继续： 第28行，启动cli容器，这相当于一个客户端，可以和peer节点相连，将命令发送给peer节点。 第30行，在cli容器中，使用peer节点安装链码（其中链码的位置在容器中的github.com/fabcar/go文件夹中，由本地fabric-samples/chaincode映射过去，在docker-compose.yaml的cli的volumes配置中有，后面会有链码的主要内容） 第31行，在cli容器中，使用peer节点将链码在通道实例化，指定初始化参数，背书策略。 第32行，在cli容器中，使用peer节点对链码初始化。注意这一步的初始化和上一步的初始化不同，上一步是在将链码在通道上初始化，调用的是链码的Init方法；这一步是链码中实际的变量值等进行初始化，调用的是Invode方法。 目前为止，网络已经启动起来，并且链码已经部署好，后面可以使用nodejs和Fabric的链码进行交互了。 下面看一下chaincode的内容fabcar.go： package main /* Imports * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation * 2 specific Hyperledger Fabric specific libraries for Smart Contracts */ import ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;strconv&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; sc &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // Define the Smart Contract structure type SmartContract struct { } // Define the car structure, with 4 properties. Structure tags are used by encoding/json library type Car struct { Make string `json:&quot;make&quot;` Model string `json:&quot;model&quot;` Colour string `json:&quot;colour&quot;` Owner string `json:&quot;owner&quot;` } /* * The Init method is called when the Smart Contract &quot;fabcar&quot; is instantiated by the blockchain network * Best practice is to have any Ledger initialization in separate function -- see initLedger() */ func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response { return shim.Success(nil) } /* * The Invoke method is called as a result of an application request to run the Smart Contract &quot;fabcar&quot; * The calling application program has also specified the particular smart contract function to be called, with arguments */ func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response { // Retrieve the requested Smart Contract function and arguments function, args := APIstub.GetFunctionAndParameters() // Route to the appropriate handler function to interact with the ledger appropriately if function == &quot;queryCar&quot; { return s.queryCar(APIstub, args) } else if function == &quot;initLedger&quot; { return s.initLedger(APIstub) } else if function == &quot;createCar&quot; { return s.createCar(APIstub, args) } else if function == &quot;queryAllCars&quot; { return s.queryAllCars(APIstub) } else if function == &quot;changeCarOwner&quot; { return s.changeCarOwner(APIstub, args) } return shim.Error(&quot;Invalid Smart Contract function name.&quot;) } func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 1 { return shim.Error(&quot;Incorrect number of arguments. Expecting 1&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) return shim.Success(carAsBytes) } func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response { cars := []Car{ Car{Make: &quot;Toyota&quot;, Model: &quot;Prius&quot;, Colour: &quot;blue&quot;, Owner: &quot;Tomoko&quot;}, Car{Make: &quot;Ford&quot;, Model: &quot;Mustang&quot;, Colour: &quot;red&quot;, Owner: &quot;Brad&quot;}, Car{Make: &quot;Hyundai&quot;, Model: &quot;Tucson&quot;, Colour: &quot;green&quot;, Owner: &quot;Jin Soo&quot;}, Car{Make: &quot;Volkswagen&quot;, Model: &quot;Passat&quot;, Colour: &quot;yellow&quot;, Owner: &quot;Max&quot;}, Car{Make: &quot;Tesla&quot;, Model: &quot;S&quot;, Colour: &quot;black&quot;, Owner: &quot;Adriana&quot;}, Car{Make: &quot;Peugeot&quot;, Model: &quot;205&quot;, Colour: &quot;purple&quot;, Owner: &quot;Michel&quot;}, Car{Make: &quot;Chery&quot;, Model: &quot;S22L&quot;, Colour: &quot;white&quot;, Owner: &quot;Aarav&quot;}, Car{Make: &quot;Fiat&quot;, Model: &quot;Punto&quot;, Colour: &quot;violet&quot;, Owner: &quot;Pari&quot;}, Car{Make: &quot;Tata&quot;, Model: &quot;Nano&quot;, Colour: &quot;indigo&quot;, Owner: &quot;Valeria&quot;}, Car{Make: &quot;Holden&quot;, Model: &quot;Barina&quot;, Colour: &quot;brown&quot;, Owner: &quot;Shotaro&quot;}, } i := 0 for i &lt; len(cars) { fmt.Println(&quot;i is &quot;, i) carAsBytes, _ := json.Marshal(cars[i]) APIstub.PutState(&quot;CAR&quot;+strconv.Itoa(i), carAsBytes) fmt.Println(&quot;Added&quot;, cars[i]) i = i + 1 } return shim.Success(nil) } func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 5 { return shim.Error(&quot;Incorrect number of arguments. Expecting 5&quot;) } var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]} carAsBytes, _ := json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) if err != nil { return shim.Error(err.Error()) } defer resultsIterator.Close() // buffer is a JSON array containing QueryResults var buffer bytes.Buffer buffer.WriteString(&quot;[&quot;) bArrayMemberAlreadyWritten := false for resultsIterator.HasNext() { queryResponse, err := resultsIterator.Next() if err != nil { return shim.Error(err.Error()) } // Add a comma before array members, suppress it for the first array member if bArrayMemberAlreadyWritten == true { buffer.WriteString(&quot;,&quot;) } buffer.WriteString(&quot;{\&quot;Key\&quot;:&quot;) buffer.WriteString(&quot;\&quot;&quot;) buffer.WriteString(queryResponse.Key) buffer.WriteString(&quot;\&quot;&quot;) buffer.WriteString(&quot;, \&quot;Record\&quot;:&quot;) // Record is a JSON object, so we write as-is buffer.WriteString(string(queryResponse.Value)) buffer.WriteString(&quot;}&quot;) bArrayMemberAlreadyWritten = true } buffer.WriteString(&quot;]&quot;) fmt.Printf(&quot;- queryAllCars:\n%s\n&quot;, buffer.String()) return shim.Success(buffer.Bytes()) } func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 2 { return shim.Error(&quot;Incorrect number of arguments. Expecting 2&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) car := Car{} json.Unmarshal(carAsBytes, &amp;car) car.Owner = args[1] carAsBytes, _ = json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } // The main function is only relevant in unit test mode. Only included here for completeness. func main() { // Create a new Smart Contract err := shim.Start(new(SmartContract)) if err != nil { fmt.Printf(&quot;Error creating new Smart Contract: %s&quot;, err) } } 每个chaincode程序都必须实现 chiancode接口 ，接口中的方法会在响应传来的交易时被调用。特别地，Init（初始化）方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作，包括初始化应用的状态；Invoke（调用）方法会在响应invoke（调用）交易时被调用以执行交易。 其他chaincode shim APIs中的接口被称为chaincode存根接口，用于访问及修改账本，并实现chaincode之间的互相调用。 从上面的代码中可以看到，对账本的操作主要有以下几个方法： 初始化账本，创建汽车、查询汽车、查询所有汽车、变更汽车主人。这些方法都是通过Invoke方法来调用的。 三、使用nodejs与链码交互 1、安装node依赖关系 npm install 会根据package.json文件中的配置自动将依赖下载并安装到本地目录中。 2、注册用户 node enrollAdmin.js node registerUser.js 这两步解释后续再补充，应该是用ca颁布证书之类。。。。 3、查询账本 1）运行查询及结果： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius&quot;,&quot;owner&quot;:&quot;Tomoko&quot;}},{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;:&quot;Brad&quot;}},{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;:&quot;Jin Soo&quot;}},{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner&quot;:&quot;Max&quot;}},{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;}},{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;:&quot;Michel&quot;}},{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}},{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari&quot;}},{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;:&quot;Valeria&quot;}},{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;:&quot;Shotaro&quot;}}] 查询返回了所有的汽车的信息。分析一下： query.js中的关于查询的参数： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, fcn: &#39;queryAllCars&#39;, args: [&#39;&#39;] }; 可以看到其调用chaincode里面的queryAllCars方法(截取部分代码)： func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) . . &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. .&nbsp;&nbsp;&nbsp;&nbsp; } 可以看到其调用了Fabric的range查询。 2）现在进行修改query，查询一辆汽车的信息，将request参数改为下面： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, // txId: transaction_id, fcn: &#39;queryCar&#39;, args: [&#39;CAR4&#39;] }; 再次执行查询： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} 可以看到只返回了一辆车的信息。 4、更新账本 账本更新是从生成交易提案的应用程序开始的。就像查询一样，我们将会构造一个请求，用来识别要进行交易的通道ID、函数以及智能合约。该程序然后调用channel.SendTransactionProposalAPI将交易建议发送给peer(s)进行认证。 网络（即endorsing peer）返回一个提案答复，应用程序以此来创建和签署交易请求。该请求通过调用channel.sendTransaction&nbsp;API发送到排序服务器。排序服务器将把交易打包进区块，然后将区块“发送”到通道上的所有peers进行认证。（在我们的例子中，我们只有一个endorsing peer。） 最后，应用程序使用eh.setPeerAddr&nbsp;API连接到peer的事务监听端口，并调用eh.registerTxEvent注册与特定交易ID相关联的事务。该API使得应用程序获得事务的结果（即成功提交或不成功）。把它当作一个通知机制。 下面进行在账本登记一辆新汽车： 在invoke.js中可以看到新汽车的参数： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;createCar&#39;, args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 进行创建： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: e41e97f2647d899f8741dc568e731a01f05f725c83531ad7da711c1a282c702f Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 创建成功，然后下一步将这辆车的主人更换，将invoke.js的参数配置改为： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;changeCarOwner&#39;, args: [&#39;CAR10&#39;, &#39;Barry&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 然后执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: 5c37d72abe8b2ba49a1e00ebf5b4258c6189aaf96c06aff53a30cb03555b6523 Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 现在再查询这辆车的车主： 修改query.js，将args中的CAR4改为CAR10，执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} 可以看到车主已经改变了。 所有操作都已执行完。除了nodejs外，Fabric还提供了和Java进行交互的sdk。 阅读更多" />
<meta property="og:description" content="本文参考官网示例:https://hyperledgercn.github.io/hyperledgerDocs/write_first_app_zh/ 测试环境linux 一、准备条件 准备条件与上篇相同。 本文用到的例子是fabric-simples中的fabcar，是一个与汽车属性相关的测试项目，后面的chaincode部分会讲。 二、启动网络 在fabcar目录下有个startFabric.sh脚本，这个脚本是用来启动网络和部署链码等一些准备条件，具体分为以下几步： 1）启动peer节点、Ordering节点、证书颁发机构以及CLI容器 2）创建一个通道，并将peer加入该通道 3）将智能合约（即链码）安装到peer节点的文件系统上，并在通道上实例化该链码；实例化会启动链码容器 4）调用initLedger功能来向通道账本写入10个不同的汽车 分析一下脚本的内容， #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error set -e # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 starttime=$(date +%s) LANGUAGE=${1:-&quot;golang&quot;} CC_SRC_PATH=github.com/fabcar/go if [ &quot;$LANGUAGE&quot; = &quot;node&quot; -o &quot;$LANGUAGE&quot; = &quot;NODE&quot; ]; then CC_SRC_PATH=/opt/gopath/src/github.com/fabcar/node fi # clean the keystore rm -rf ./hfc-key-store # launch network; create channel and join peer to channel cd ../basic-network ./start.sh # Now launch the CLI container in order to install, instantiate chaincode # and prime the ledger with our 10 cars docker-compose -f ./docker-compose.yml up -d cli docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode install -n fabcar -v 1.0 -p &quot;$CC_SRC_PATH&quot; -l &quot;$LANGUAGE&quot; docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -l &quot;$LANGUAGE&quot; -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; sleep 10 docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c &#39;{&quot;function&quot;:&quot;initLedger&quot;,&quot;Args&quot;:[&quot;&quot;]}&#39; printf &quot;\nTotal setup execution time : $(($(date +%s) - starttime)) secs ...\n\n\n&quot; printf &quot;Start by installing required packages run &#39;npm install&#39;\n&quot; printf &quot;Then run &#39;node enrollAdmin.js&#39;, then &#39;node registerUser&#39;\n\n&quot; printf &quot;The &#39;node invoke.js&#39; will fail until it has been updated with valid arguments\n&quot; printf &quot;The &#39;node query.js&#39; may be run at anytime once the user has been registered\n\n&quot; 首先启动网络，第23行，调用了另外一个脚本start.sh，在basic-network文件夹中，内容如下： #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error, print all commands. set -ev # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 docker-compose -f docker-compose.yml down docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb # wait for Hyperledger Fabric to start # incase of errors when running later commands, issue export FABRIC_START_TIMEOUT=&lt;larger number&gt; export FABRIC_START_TIMEOUT=10 #echo ${FABRIC_START_TIMEOUT} sleep ${FABRIC_START_TIMEOUT} # Create the channel docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx # Join peer0.org1.example.com to the channel. docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel join -b mychannel.block 其中第13行是关闭正在运行的docker容器（如果之前这个项目开启过，或者还有残留的话） 第15行根据docker-compose.yaml配置文件启动多个容器，启动-d后面的选项指定要开启的容器，包括一个ca证书颁发机构、一个排序节点、一个peer节点，使用的数据库是couchdb。 第24行，这里是在peer节点根据通道配置文件channel.tx（这个是示例下载后自带的，也可以自己生成，见上篇文章）来创建一个通道。如果进入peer节点的容器中（docker exec -it peer0.org1.example.com bash），会发现多了一个mychannel.block，这是通道的创世区块。 第26行，将peer节点加入通道中。 现在start.sh执行完了，回到startFabric.sh中继续： 第28行，启动cli容器，这相当于一个客户端，可以和peer节点相连，将命令发送给peer节点。 第30行，在cli容器中，使用peer节点安装链码（其中链码的位置在容器中的github.com/fabcar/go文件夹中，由本地fabric-samples/chaincode映射过去，在docker-compose.yaml的cli的volumes配置中有，后面会有链码的主要内容） 第31行，在cli容器中，使用peer节点将链码在通道实例化，指定初始化参数，背书策略。 第32行，在cli容器中，使用peer节点对链码初始化。注意这一步的初始化和上一步的初始化不同，上一步是在将链码在通道上初始化，调用的是链码的Init方法；这一步是链码中实际的变量值等进行初始化，调用的是Invode方法。 目前为止，网络已经启动起来，并且链码已经部署好，后面可以使用nodejs和Fabric的链码进行交互了。 下面看一下chaincode的内容fabcar.go： package main /* Imports * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation * 2 specific Hyperledger Fabric specific libraries for Smart Contracts */ import ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;strconv&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; sc &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // Define the Smart Contract structure type SmartContract struct { } // Define the car structure, with 4 properties. Structure tags are used by encoding/json library type Car struct { Make string `json:&quot;make&quot;` Model string `json:&quot;model&quot;` Colour string `json:&quot;colour&quot;` Owner string `json:&quot;owner&quot;` } /* * The Init method is called when the Smart Contract &quot;fabcar&quot; is instantiated by the blockchain network * Best practice is to have any Ledger initialization in separate function -- see initLedger() */ func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response { return shim.Success(nil) } /* * The Invoke method is called as a result of an application request to run the Smart Contract &quot;fabcar&quot; * The calling application program has also specified the particular smart contract function to be called, with arguments */ func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response { // Retrieve the requested Smart Contract function and arguments function, args := APIstub.GetFunctionAndParameters() // Route to the appropriate handler function to interact with the ledger appropriately if function == &quot;queryCar&quot; { return s.queryCar(APIstub, args) } else if function == &quot;initLedger&quot; { return s.initLedger(APIstub) } else if function == &quot;createCar&quot; { return s.createCar(APIstub, args) } else if function == &quot;queryAllCars&quot; { return s.queryAllCars(APIstub) } else if function == &quot;changeCarOwner&quot; { return s.changeCarOwner(APIstub, args) } return shim.Error(&quot;Invalid Smart Contract function name.&quot;) } func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 1 { return shim.Error(&quot;Incorrect number of arguments. Expecting 1&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) return shim.Success(carAsBytes) } func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response { cars := []Car{ Car{Make: &quot;Toyota&quot;, Model: &quot;Prius&quot;, Colour: &quot;blue&quot;, Owner: &quot;Tomoko&quot;}, Car{Make: &quot;Ford&quot;, Model: &quot;Mustang&quot;, Colour: &quot;red&quot;, Owner: &quot;Brad&quot;}, Car{Make: &quot;Hyundai&quot;, Model: &quot;Tucson&quot;, Colour: &quot;green&quot;, Owner: &quot;Jin Soo&quot;}, Car{Make: &quot;Volkswagen&quot;, Model: &quot;Passat&quot;, Colour: &quot;yellow&quot;, Owner: &quot;Max&quot;}, Car{Make: &quot;Tesla&quot;, Model: &quot;S&quot;, Colour: &quot;black&quot;, Owner: &quot;Adriana&quot;}, Car{Make: &quot;Peugeot&quot;, Model: &quot;205&quot;, Colour: &quot;purple&quot;, Owner: &quot;Michel&quot;}, Car{Make: &quot;Chery&quot;, Model: &quot;S22L&quot;, Colour: &quot;white&quot;, Owner: &quot;Aarav&quot;}, Car{Make: &quot;Fiat&quot;, Model: &quot;Punto&quot;, Colour: &quot;violet&quot;, Owner: &quot;Pari&quot;}, Car{Make: &quot;Tata&quot;, Model: &quot;Nano&quot;, Colour: &quot;indigo&quot;, Owner: &quot;Valeria&quot;}, Car{Make: &quot;Holden&quot;, Model: &quot;Barina&quot;, Colour: &quot;brown&quot;, Owner: &quot;Shotaro&quot;}, } i := 0 for i &lt; len(cars) { fmt.Println(&quot;i is &quot;, i) carAsBytes, _ := json.Marshal(cars[i]) APIstub.PutState(&quot;CAR&quot;+strconv.Itoa(i), carAsBytes) fmt.Println(&quot;Added&quot;, cars[i]) i = i + 1 } return shim.Success(nil) } func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 5 { return shim.Error(&quot;Incorrect number of arguments. Expecting 5&quot;) } var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]} carAsBytes, _ := json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) if err != nil { return shim.Error(err.Error()) } defer resultsIterator.Close() // buffer is a JSON array containing QueryResults var buffer bytes.Buffer buffer.WriteString(&quot;[&quot;) bArrayMemberAlreadyWritten := false for resultsIterator.HasNext() { queryResponse, err := resultsIterator.Next() if err != nil { return shim.Error(err.Error()) } // Add a comma before array members, suppress it for the first array member if bArrayMemberAlreadyWritten == true { buffer.WriteString(&quot;,&quot;) } buffer.WriteString(&quot;{\&quot;Key\&quot;:&quot;) buffer.WriteString(&quot;\&quot;&quot;) buffer.WriteString(queryResponse.Key) buffer.WriteString(&quot;\&quot;&quot;) buffer.WriteString(&quot;, \&quot;Record\&quot;:&quot;) // Record is a JSON object, so we write as-is buffer.WriteString(string(queryResponse.Value)) buffer.WriteString(&quot;}&quot;) bArrayMemberAlreadyWritten = true } buffer.WriteString(&quot;]&quot;) fmt.Printf(&quot;- queryAllCars:\n%s\n&quot;, buffer.String()) return shim.Success(buffer.Bytes()) } func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 2 { return shim.Error(&quot;Incorrect number of arguments. Expecting 2&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) car := Car{} json.Unmarshal(carAsBytes, &amp;car) car.Owner = args[1] carAsBytes, _ = json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } // The main function is only relevant in unit test mode. Only included here for completeness. func main() { // Create a new Smart Contract err := shim.Start(new(SmartContract)) if err != nil { fmt.Printf(&quot;Error creating new Smart Contract: %s&quot;, err) } } 每个chaincode程序都必须实现 chiancode接口 ，接口中的方法会在响应传来的交易时被调用。特别地，Init（初始化）方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作，包括初始化应用的状态；Invoke（调用）方法会在响应invoke（调用）交易时被调用以执行交易。 其他chaincode shim APIs中的接口被称为chaincode存根接口，用于访问及修改账本，并实现chaincode之间的互相调用。 从上面的代码中可以看到，对账本的操作主要有以下几个方法： 初始化账本，创建汽车、查询汽车、查询所有汽车、变更汽车主人。这些方法都是通过Invoke方法来调用的。 三、使用nodejs与链码交互 1、安装node依赖关系 npm install 会根据package.json文件中的配置自动将依赖下载并安装到本地目录中。 2、注册用户 node enrollAdmin.js node registerUser.js 这两步解释后续再补充，应该是用ca颁布证书之类。。。。 3、查询账本 1）运行查询及结果： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius&quot;,&quot;owner&quot;:&quot;Tomoko&quot;}},{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;:&quot;Brad&quot;}},{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;:&quot;Jin Soo&quot;}},{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner&quot;:&quot;Max&quot;}},{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;}},{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;:&quot;Michel&quot;}},{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}},{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari&quot;}},{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;:&quot;Valeria&quot;}},{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;:&quot;Shotaro&quot;}}] 查询返回了所有的汽车的信息。分析一下： query.js中的关于查询的参数： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, fcn: &#39;queryAllCars&#39;, args: [&#39;&#39;] }; 可以看到其调用chaincode里面的queryAllCars方法(截取部分代码)： func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) . . &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. .&nbsp;&nbsp;&nbsp;&nbsp; } 可以看到其调用了Fabric的range查询。 2）现在进行修改query，查询一辆汽车的信息，将request参数改为下面： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, // txId: transaction_id, fcn: &#39;queryCar&#39;, args: [&#39;CAR4&#39;] }; 再次执行查询： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} 可以看到只返回了一辆车的信息。 4、更新账本 账本更新是从生成交易提案的应用程序开始的。就像查询一样，我们将会构造一个请求，用来识别要进行交易的通道ID、函数以及智能合约。该程序然后调用channel.SendTransactionProposalAPI将交易建议发送给peer(s)进行认证。 网络（即endorsing peer）返回一个提案答复，应用程序以此来创建和签署交易请求。该请求通过调用channel.sendTransaction&nbsp;API发送到排序服务器。排序服务器将把交易打包进区块，然后将区块“发送”到通道上的所有peers进行认证。（在我们的例子中，我们只有一个endorsing peer。） 最后，应用程序使用eh.setPeerAddr&nbsp;API连接到peer的事务监听端口，并调用eh.registerTxEvent注册与特定交易ID相关联的事务。该API使得应用程序获得事务的结果（即成功提交或不成功）。把它当作一个通知机制。 下面进行在账本登记一辆新汽车： 在invoke.js中可以看到新汽车的参数： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;createCar&#39;, args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 进行创建： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: e41e97f2647d899f8741dc568e731a01f05f725c83531ad7da711c1a282c702f Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 创建成功，然后下一步将这辆车的主人更换，将invoke.js的参数配置改为： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;changeCarOwner&#39;, args: [&#39;CAR10&#39;, &#39;Barry&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 然后执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: 5c37d72abe8b2ba49a1e00ebf5b4258c6189aaf96c06aff53a30cb03555b6523 Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 现在再查询这辆车的车主： 修改query.js，将args中的CAR4改为CAR10，执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} 可以看到车主已经改变了。 所有操作都已执行完。除了nodejs外，Fabric还提供了和Java进行交互的sdk。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文参考官网示例:https://hyperledgercn.github.io/hyperledgerDocs/write_first_app_zh/ 测试环境linux 一、准备条件 准备条件与上篇相同。 本文用到的例子是fabric-simples中的fabcar，是一个与汽车属性相关的测试项目，后面的chaincode部分会讲。 二、启动网络 在fabcar目录下有个startFabric.sh脚本，这个脚本是用来启动网络和部署链码等一些准备条件，具体分为以下几步： 1）启动peer节点、Ordering节点、证书颁发机构以及CLI容器 2）创建一个通道，并将peer加入该通道 3）将智能合约（即链码）安装到peer节点的文件系统上，并在通道上实例化该链码；实例化会启动链码容器 4）调用initLedger功能来向通道账本写入10个不同的汽车 分析一下脚本的内容， #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error set -e # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 starttime=$(date +%s) LANGUAGE=${1:-&quot;golang&quot;} CC_SRC_PATH=github.com/fabcar/go if [ &quot;$LANGUAGE&quot; = &quot;node&quot; -o &quot;$LANGUAGE&quot; = &quot;NODE&quot; ]; then CC_SRC_PATH=/opt/gopath/src/github.com/fabcar/node fi # clean the keystore rm -rf ./hfc-key-store # launch network; create channel and join peer to channel cd ../basic-network ./start.sh # Now launch the CLI container in order to install, instantiate chaincode # and prime the ledger with our 10 cars docker-compose -f ./docker-compose.yml up -d cli docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode install -n fabcar -v 1.0 -p &quot;$CC_SRC_PATH&quot; -l &quot;$LANGUAGE&quot; docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -l &quot;$LANGUAGE&quot; -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; sleep 10 docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c &#39;{&quot;function&quot;:&quot;initLedger&quot;,&quot;Args&quot;:[&quot;&quot;]}&#39; printf &quot;\\nTotal setup execution time : $(($(date +%s) - starttime)) secs ...\\n\\n\\n&quot; printf &quot;Start by installing required packages run &#39;npm install&#39;\\n&quot; printf &quot;Then run &#39;node enrollAdmin.js&#39;, then &#39;node registerUser&#39;\\n\\n&quot; printf &quot;The &#39;node invoke.js&#39; will fail until it has been updated with valid arguments\\n&quot; printf &quot;The &#39;node query.js&#39; may be run at anytime once the user has been registered\\n\\n&quot; 首先启动网络，第23行，调用了另外一个脚本start.sh，在basic-network文件夹中，内容如下： #!/bin/bash # # Copyright IBM Corp All Rights Reserved # # SPDX-License-Identifier: Apache-2.0 # # Exit on first error, print all commands. set -ev # don&#39;t rewrite paths for Windows Git Bash users export MSYS_NO_PATHCONV=1 docker-compose -f docker-compose.yml down docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb # wait for Hyperledger Fabric to start # incase of errors when running later commands, issue export FABRIC_START_TIMEOUT=&lt;larger number&gt; export FABRIC_START_TIMEOUT=10 #echo ${FABRIC_START_TIMEOUT} sleep ${FABRIC_START_TIMEOUT} # Create the channel docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx # Join peer0.org1.example.com to the channel. docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp&quot; peer0.org1.example.com peer channel join -b mychannel.block 其中第13行是关闭正在运行的docker容器（如果之前这个项目开启过，或者还有残留的话） 第15行根据docker-compose.yaml配置文件启动多个容器，启动-d后面的选项指定要开启的容器，包括一个ca证书颁发机构、一个排序节点、一个peer节点，使用的数据库是couchdb。 第24行，这里是在peer节点根据通道配置文件channel.tx（这个是示例下载后自带的，也可以自己生成，见上篇文章）来创建一个通道。如果进入peer节点的容器中（docker exec -it peer0.org1.example.com bash），会发现多了一个mychannel.block，这是通道的创世区块。 第26行，将peer节点加入通道中。 现在start.sh执行完了，回到startFabric.sh中继续： 第28行，启动cli容器，这相当于一个客户端，可以和peer节点相连，将命令发送给peer节点。 第30行，在cli容器中，使用peer节点安装链码（其中链码的位置在容器中的github.com/fabcar/go文件夹中，由本地fabric-samples/chaincode映射过去，在docker-compose.yaml的cli的volumes配置中有，后面会有链码的主要内容） 第31行，在cli容器中，使用peer节点将链码在通道实例化，指定初始化参数，背书策略。 第32行，在cli容器中，使用peer节点对链码初始化。注意这一步的初始化和上一步的初始化不同，上一步是在将链码在通道上初始化，调用的是链码的Init方法；这一步是链码中实际的变量值等进行初始化，调用的是Invode方法。 目前为止，网络已经启动起来，并且链码已经部署好，后面可以使用nodejs和Fabric的链码进行交互了。 下面看一下chaincode的内容fabcar.go： package main /* Imports * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation * 2 specific Hyperledger Fabric specific libraries for Smart Contracts */ import ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;strconv&quot; &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; sc &quot;github.com/hyperledger/fabric/protos/peer&quot; ) // Define the Smart Contract structure type SmartContract struct { } // Define the car structure, with 4 properties. Structure tags are used by encoding/json library type Car struct { Make string `json:&quot;make&quot;` Model string `json:&quot;model&quot;` Colour string `json:&quot;colour&quot;` Owner string `json:&quot;owner&quot;` } /* * The Init method is called when the Smart Contract &quot;fabcar&quot; is instantiated by the blockchain network * Best practice is to have any Ledger initialization in separate function -- see initLedger() */ func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response { return shim.Success(nil) } /* * The Invoke method is called as a result of an application request to run the Smart Contract &quot;fabcar&quot; * The calling application program has also specified the particular smart contract function to be called, with arguments */ func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response { // Retrieve the requested Smart Contract function and arguments function, args := APIstub.GetFunctionAndParameters() // Route to the appropriate handler function to interact with the ledger appropriately if function == &quot;queryCar&quot; { return s.queryCar(APIstub, args) } else if function == &quot;initLedger&quot; { return s.initLedger(APIstub) } else if function == &quot;createCar&quot; { return s.createCar(APIstub, args) } else if function == &quot;queryAllCars&quot; { return s.queryAllCars(APIstub) } else if function == &quot;changeCarOwner&quot; { return s.changeCarOwner(APIstub, args) } return shim.Error(&quot;Invalid Smart Contract function name.&quot;) } func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 1 { return shim.Error(&quot;Incorrect number of arguments. Expecting 1&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) return shim.Success(carAsBytes) } func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response { cars := []Car{ Car{Make: &quot;Toyota&quot;, Model: &quot;Prius&quot;, Colour: &quot;blue&quot;, Owner: &quot;Tomoko&quot;}, Car{Make: &quot;Ford&quot;, Model: &quot;Mustang&quot;, Colour: &quot;red&quot;, Owner: &quot;Brad&quot;}, Car{Make: &quot;Hyundai&quot;, Model: &quot;Tucson&quot;, Colour: &quot;green&quot;, Owner: &quot;Jin Soo&quot;}, Car{Make: &quot;Volkswagen&quot;, Model: &quot;Passat&quot;, Colour: &quot;yellow&quot;, Owner: &quot;Max&quot;}, Car{Make: &quot;Tesla&quot;, Model: &quot;S&quot;, Colour: &quot;black&quot;, Owner: &quot;Adriana&quot;}, Car{Make: &quot;Peugeot&quot;, Model: &quot;205&quot;, Colour: &quot;purple&quot;, Owner: &quot;Michel&quot;}, Car{Make: &quot;Chery&quot;, Model: &quot;S22L&quot;, Colour: &quot;white&quot;, Owner: &quot;Aarav&quot;}, Car{Make: &quot;Fiat&quot;, Model: &quot;Punto&quot;, Colour: &quot;violet&quot;, Owner: &quot;Pari&quot;}, Car{Make: &quot;Tata&quot;, Model: &quot;Nano&quot;, Colour: &quot;indigo&quot;, Owner: &quot;Valeria&quot;}, Car{Make: &quot;Holden&quot;, Model: &quot;Barina&quot;, Colour: &quot;brown&quot;, Owner: &quot;Shotaro&quot;}, } i := 0 for i &lt; len(cars) { fmt.Println(&quot;i is &quot;, i) carAsBytes, _ := json.Marshal(cars[i]) APIstub.PutState(&quot;CAR&quot;+strconv.Itoa(i), carAsBytes) fmt.Println(&quot;Added&quot;, cars[i]) i = i + 1 } return shim.Success(nil) } func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 5 { return shim.Error(&quot;Incorrect number of arguments. Expecting 5&quot;) } var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]} carAsBytes, _ := json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) if err != nil { return shim.Error(err.Error()) } defer resultsIterator.Close() // buffer is a JSON array containing QueryResults var buffer bytes.Buffer buffer.WriteString(&quot;[&quot;) bArrayMemberAlreadyWritten := false for resultsIterator.HasNext() { queryResponse, err := resultsIterator.Next() if err != nil { return shim.Error(err.Error()) } // Add a comma before array members, suppress it for the first array member if bArrayMemberAlreadyWritten == true { buffer.WriteString(&quot;,&quot;) } buffer.WriteString(&quot;{\\&quot;Key\\&quot;:&quot;) buffer.WriteString(&quot;\\&quot;&quot;) buffer.WriteString(queryResponse.Key) buffer.WriteString(&quot;\\&quot;&quot;) buffer.WriteString(&quot;, \\&quot;Record\\&quot;:&quot;) // Record is a JSON object, so we write as-is buffer.WriteString(string(queryResponse.Value)) buffer.WriteString(&quot;}&quot;) bArrayMemberAlreadyWritten = true } buffer.WriteString(&quot;]&quot;) fmt.Printf(&quot;- queryAllCars:\\n%s\\n&quot;, buffer.String()) return shim.Success(buffer.Bytes()) } func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response { if len(args) != 2 { return shim.Error(&quot;Incorrect number of arguments. Expecting 2&quot;) } carAsBytes, _ := APIstub.GetState(args[0]) car := Car{} json.Unmarshal(carAsBytes, &amp;car) car.Owner = args[1] carAsBytes, _ = json.Marshal(car) APIstub.PutState(args[0], carAsBytes) return shim.Success(nil) } // The main function is only relevant in unit test mode. Only included here for completeness. func main() { // Create a new Smart Contract err := shim.Start(new(SmartContract)) if err != nil { fmt.Printf(&quot;Error creating new Smart Contract: %s&quot;, err) } } 每个chaincode程序都必须实现 chiancode接口 ，接口中的方法会在响应传来的交易时被调用。特别地，Init（初始化）方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作，包括初始化应用的状态；Invoke（调用）方法会在响应invoke（调用）交易时被调用以执行交易。 其他chaincode shim APIs中的接口被称为chaincode存根接口，用于访问及修改账本，并实现chaincode之间的互相调用。 从上面的代码中可以看到，对账本的操作主要有以下几个方法： 初始化账本，创建汽车、查询汽车、查询所有汽车、变更汽车主人。这些方法都是通过Invoke方法来调用的。 三、使用nodejs与链码交互 1、安装node依赖关系 npm install 会根据package.json文件中的配置自动将依赖下载并安装到本地目录中。 2、注册用户 node enrollAdmin.js node registerUser.js 这两步解释后续再补充，应该是用ca颁布证书之类。。。。 3、查询账本 1）运行查询及结果： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is [{&quot;Key&quot;:&quot;CAR0&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;blue&quot;,&quot;make&quot;:&quot;Toyota&quot;,&quot;model&quot;:&quot;Prius&quot;,&quot;owner&quot;:&quot;Tomoko&quot;}},{&quot;Key&quot;:&quot;CAR1&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;red&quot;,&quot;make&quot;:&quot;Ford&quot;,&quot;model&quot;:&quot;Mustang&quot;,&quot;owner&quot;:&quot;Brad&quot;}},{&quot;Key&quot;:&quot;CAR2&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;green&quot;,&quot;make&quot;:&quot;Hyundai&quot;,&quot;model&quot;:&quot;Tucson&quot;,&quot;owner&quot;:&quot;Jin Soo&quot;}},{&quot;Key&quot;:&quot;CAR3&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;yellow&quot;,&quot;make&quot;:&quot;Volkswagen&quot;,&quot;model&quot;:&quot;Passat&quot;,&quot;owner&quot;:&quot;Max&quot;}},{&quot;Key&quot;:&quot;CAR4&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;}},{&quot;Key&quot;:&quot;CAR5&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;purple&quot;,&quot;make&quot;:&quot;Peugeot&quot;,&quot;model&quot;:&quot;205&quot;,&quot;owner&quot;:&quot;Michel&quot;}},{&quot;Key&quot;:&quot;CAR6&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;white&quot;,&quot;make&quot;:&quot;Chery&quot;,&quot;model&quot;:&quot;S22L&quot;,&quot;owner&quot;:&quot;Aarav&quot;}},{&quot;Key&quot;:&quot;CAR7&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;violet&quot;,&quot;make&quot;:&quot;Fiat&quot;,&quot;model&quot;:&quot;Punto&quot;,&quot;owner&quot;:&quot;Pari&quot;}},{&quot;Key&quot;:&quot;CAR8&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;indigo&quot;,&quot;make&quot;:&quot;Tata&quot;,&quot;model&quot;:&quot;Nano&quot;,&quot;owner&quot;:&quot;Valeria&quot;}},{&quot;Key&quot;:&quot;CAR9&quot;, &quot;Record&quot;:{&quot;colour&quot;:&quot;brown&quot;,&quot;make&quot;:&quot;Holden&quot;,&quot;model&quot;:&quot;Barina&quot;,&quot;owner&quot;:&quot;Shotaro&quot;}}] 查询返回了所有的汽车的信息。分析一下： query.js中的关于查询的参数： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, fcn: &#39;queryAllCars&#39;, args: [&#39;&#39;] }; 可以看到其调用chaincode里面的queryAllCars方法(截取部分代码)： func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response { startKey := &quot;CAR0&quot; endKey := &quot;CAR999&quot; resultsIterator, err := APIstub.GetStateByRange(startKey, endKey) . . &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. .&nbsp;&nbsp;&nbsp;&nbsp; } 可以看到其调用了Fabric的range查询。 2）现在进行修改query，查询一辆汽车的信息，将request参数改为下面： const request = { //targets : --- letting this default to the peers assigned to the channel chaincodeId: &#39;fabcar&#39;, // txId: transaction_id, fcn: &#39;queryCar&#39;, args: [&#39;CAR4&#39;] }; 再次执行查询： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;black&quot;,&quot;make&quot;:&quot;Tesla&quot;,&quot;model&quot;:&quot;S&quot;,&quot;owner&quot;:&quot;Adriana&quot;} 可以看到只返回了一辆车的信息。 4、更新账本 账本更新是从生成交易提案的应用程序开始的。就像查询一样，我们将会构造一个请求，用来识别要进行交易的通道ID、函数以及智能合约。该程序然后调用channel.SendTransactionProposalAPI将交易建议发送给peer(s)进行认证。 网络（即endorsing peer）返回一个提案答复，应用程序以此来创建和签署交易请求。该请求通过调用channel.sendTransaction&nbsp;API发送到排序服务器。排序服务器将把交易打包进区块，然后将区块“发送”到通道上的所有peers进行认证。（在我们的例子中，我们只有一个endorsing peer。） 最后，应用程序使用eh.setPeerAddr&nbsp;API连接到peer的事务监听端口，并调用eh.registerTxEvent注册与特定交易ID相关联的事务。该API使得应用程序获得事务的结果（即成功提交或不成功）。把它当作一个通知机制。 下面进行在账本登记一辆新汽车： 在invoke.js中可以看到新汽车的参数： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;createCar&#39;, args: [&#39;CAR10&#39;, &#39;Chevy&#39;, &#39;Volt&#39;, &#39;Red&#39;, &#39;Nick&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 进行创建： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: e41e97f2647d899f8741dc568e731a01f05f725c83531ad7da711c1a282c702f Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 创建成功，然后下一步将这辆车的主人更换，将invoke.js的参数配置改为： var request = { //targets: let default to the peer assigned to the client chaincodeId: &#39;fabcar&#39;, fcn: &#39;changeCarOwner&#39;, args: [&#39;CAR10&#39;, &#39;Barry&#39;], chainId: &#39;mychannel&#39;, txId: tx_id }; 然后执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Assigning transaction_id: 5c37d72abe8b2ba49a1e00ebf5b4258c6189aaf96c06aff53a30cb03555b6523 Transaction proposal was good Successfully sent Proposal and received ProposalResponse: Status - 200, message - &quot;OK&quot; The transaction has been committed on peer localhost:7053 Send transaction promise and event listener promise have completed Successfully sent transaction to the orderer. Successfully committed the change to the ledger by the peer 现在再查询这辆车的车主： 修改query.js，将args中的CAR4改为CAR10，执行： zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store Successfully loaded user1 from persistence Query has completed, checking results Response is {&quot;colour&quot;:&quot;Red&quot;,&quot;make&quot;:&quot;Chevy&quot;,&quot;model&quot;:&quot;Volt&quot;,&quot;owner&quot;:&quot;Barry&quot;} 可以看到车主已经改变了。 所有操作都已执行完。除了nodejs外，Fabric还提供了和Java进行交互的sdk。 阅读更多","@type":"BlogPosting","url":"/2018/06/30/03c968fd1f0798054d39a95ee6d35d81.html","headline":"fabric-node-sdk 编写第一个应用","dateModified":"2018-06-30T00:00:00+08:00","datePublished":"2018-06-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/06/30/03c968fd1f0798054d39a95ee6d35d81.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>fabric-node-sdk 编写第一个应用</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>本文参考官网示例:<a href="https://hyperledgercn.github.io/hyperledgerDocs/write_first_app_zh/" rel="nofollow">https://hyperledgercn.github.io/hyperledgerDocs/write_first_app_zh/</a></p>
  <p>测试环境linux</p>
  <h1>一、准备条件</h1>
  <p>准备条件与<a href="https://blog.csdn.net/zhj_fly/article/details/80700596" rel="nofollow">上篇</a>相同。</p>
  <p>本文用到的例子是<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">fabric-simples中的fabcar，是一个与汽车属性相关的测试项目，后面的chaincode部分会讲。</span></p>
  <h1><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">二、启动网络</span></span></h1>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">在fabcar目录下有个startFabric.sh脚本，这个脚本是用来启动网络和部署链码等一些准备条件，具体分为以下几步：</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">1）启动peer节点、Ordering节点、证书颁发机构以及CLI容器</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">2）创建一个通道，并将peer加入该通道</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">3）将智能合约（即链码）安装到peer节点的文件系统上，并在通道上实例化该链码；实例化会启动链码容器</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">4）调用initLedger功能来向通道账本写入10个不同的汽车</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">分析一下脚本的内容，</span></span></p>
  <pre><code class="language-javascript">#!/bin/bash
#
# Copyright IBM Corp All Rights Reserved
#
# SPDX-License-Identifier: Apache-2.0
#
# Exit on first error
set -e

# don't rewrite paths for Windows Git Bash users
export MSYS_NO_PATHCONV=1
starttime=$(date +%s)
LANGUAGE=${1:-"golang"}
CC_SRC_PATH=github.com/fabcar/go
if [ "$LANGUAGE" = "node" -o "$LANGUAGE" = "NODE" ]; then
	CC_SRC_PATH=/opt/gopath/src/github.com/fabcar/node
fi

# clean the keystore
rm -rf ./hfc-key-store

# launch network; create channel and join peer to channel
cd ../basic-network
./start.sh

# Now launch the CLI container in order to install, instantiate chaincode
# and prime the ledger with our 10 cars
docker-compose -f ./docker-compose.yml up -d cli

docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode install -n fabcar -v 1.0 -p "$CC_SRC_PATH" -l "$LANGUAGE"
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -l "$LANGUAGE" -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"
sleep 10
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"initLedger","Args":[""]}'

printf "\nTotal setup execution time : $(($(date +%s) - starttime)) secs ...\n\n\n"
printf "Start by installing required packages run 'npm install'\n"
printf "Then run 'node enrollAdmin.js', then 'node registerUser'\n\n"
printf "The 'node invoke.js' will fail until it has been updated with valid arguments\n"
printf "The 'node query.js' may be run at anytime once the user has been registered\n\n"
</code></pre>
  <br>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">首先启动网络，第23行，调用了另外一个脚本start.sh，在basic-network文件夹中，内容如下：</span></span></p>
  <pre><code class="language-javascript">#!/bin/bash
#
# Copyright IBM Corp All Rights Reserved
#
# SPDX-License-Identifier: Apache-2.0
#
# Exit on first error, print all commands.
set -ev

# don't rewrite paths for Windows Git Bash users
export MSYS_NO_PATHCONV=1

docker-compose -f docker-compose.yml down

docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb

# wait for Hyperledger Fabric to start
# incase of errors when running later commands, issue export FABRIC_START_TIMEOUT=&lt;larger number&gt;
export FABRIC_START_TIMEOUT=10
#echo ${FABRIC_START_TIMEOUT}
sleep ${FABRIC_START_TIMEOUT}

# Create the channel
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp" peer0.org1.example.com peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx
# Join peer0.org1.example.com to the channel.
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp" peer0.org1.example.com peer channel join -b mychannel.block
</code></pre>
  <br>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">其中第13行是关闭正在运行的docker容器（如果之前这个项目开启过，或者还有残留的话）</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第15行根据docker-compose.yaml配置文件启动多个容器，启动-d后面的选项指定要开启的容器，包括一个ca证书颁发机构、一个排序节点、一个peer节点，使用的数据库是couchdb。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第24行，这里是在peer节点根据通道配置文件channel.tx（这个是示例下载后自带的，也可以自己生成，见<a href="https://blog.csdn.net/zhj_fly/article/details/80700596" rel="nofollow">上篇</a>文章）来创建一个通道。如果进入peer节点的容器中（docker exec -it peer0.org1.example.com bash），会发现多了一个mychannel.block，这是通道的创世区块。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第26行，将peer节点加入通道中。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">现在start.sh执行完了，回到startFabric.sh中继续：</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第28行，启动cli容器，这相当于一个客户端，可以和peer节点相连，将命令发送给peer节点。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第30行，在cli容器中，使用peer节点安装链码（其中链码的位置在容器中的github.com/fabcar/go文件夹中，由本地fabric-samples/chaincode映射过去，在docker-compose.yaml的cli的volumes配置中有，后面会有链码的主要内容）</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第31行，在cli容器中，使用peer节点将链码在通道实例化，指定初始化参数，背书策略。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">第32行，在cli容器中，使用peer节点对链码初始化。注意这一步的初始化和上一步的初始化不同，上一步是在将链码在通道上初始化，调用的是链码的Init方法；这一步是链码中实际的变量值等进行初始化，调用的是Invode方法。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">目前为止，网络已经启动起来，并且链码已经部署好，后面可以使用nodejs和Fabric的链码进行交互了。</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">下面看一下chaincode的内容fabcar.go：</span></span></p>
  <pre><code class="language-javascript">package main

/* Imports
 * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation
 * 2 specific Hyperledger Fabric specific libraries for Smart Contracts
 */
import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"
)

// Define the Smart Contract structure
type SmartContract struct {
}

// Define the car structure, with 4 properties.  Structure tags are used by encoding/json library
type Car struct {
	Make   string `json:"make"`
	Model  string `json:"model"`
	Colour string `json:"colour"`
	Owner  string `json:"owner"`
}

/*
 * The Init method is called when the Smart Contract "fabcar" is instantiated by the blockchain network
 * Best practice is to have any Ledger initialization in separate function -- see initLedger()
 */
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

/*
 * The Invoke method is called as a result of an application request to run the Smart Contract "fabcar"
 * The calling application program has also specified the particular smart contract function to be called, with arguments
 */
func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "queryCar" {
		return s.queryCar(APIstub, args)
	} else if function == "initLedger" {
		return s.initLedger(APIstub)
	} else if function == "createCar" {
		return s.createCar(APIstub, args)
	} else if function == "queryAllCars" {
		return s.queryAllCars(APIstub)
	} else if function == "changeCarOwner" {
		return s.changeCarOwner(APIstub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	return shim.Success(carAsBytes)
}

func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response {
	cars := []Car{
		Car{Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
		Car{Make: "Ford", Model: "Mustang", Colour: "red", Owner: "Brad"},
		Car{Make: "Hyundai", Model: "Tucson", Colour: "green", Owner: "Jin Soo"},
		Car{Make: "Volkswagen", Model: "Passat", Colour: "yellow", Owner: "Max"},
		Car{Make: "Tesla", Model: "S", Colour: "black", Owner: "Adriana"},
		Car{Make: "Peugeot", Model: "205", Colour: "purple", Owner: "Michel"},
		Car{Make: "Chery", Model: "S22L", Colour: "white", Owner: "Aarav"},
		Car{Make: "Fiat", Model: "Punto", Colour: "violet", Owner: "Pari"},
		Car{Make: "Tata", Model: "Nano", Colour: "indigo", Owner: "Valeria"},
		Car{Make: "Holden", Model: "Barina", Colour: "brown", Owner: "Shotaro"},
	}

	i := 0
	for i &lt; len(cars) {
		fmt.Println("i is ", i)
		carAsBytes, _ := json.Marshal(cars[i])
		APIstub.PutState("CAR"+strconv.Itoa(i), carAsBytes)
		fmt.Println("Added", cars[i])
		i = i + 1
	}

	return shim.Success(nil)
}

func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 5 {
		return shim.Error("Incorrect number of arguments. Expecting 5")
	}

	var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]}

	carAsBytes, _ := json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "CAR0"
	endKey := "CAR999"

	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add a comma before array members, suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- queryAllCars:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	car := Car{}

	json.Unmarshal(carAsBytes, &amp;car)
	car.Owner = args[1]

	carAsBytes, _ = json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}
</code></pre>
  <br>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">每个chaincode程序都必须实现 chiancode接口 ，接口中的方法会在响应传来的交易时被调用。特别地，Init（初始化）方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作，包括初始化应用的状态；Invoke（调用）方法会在响应invoke（调用）交易时被调用以执行交易。<br></span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">其他chaincode shim APIs中的接口被称为chaincode存根接口，用于访问及修改账本，并实现chaincode之间的互相调用。<br></span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">从上面的代码中可以看到，对账本的操作主要有以下几个方法：</span></span></p>
  <p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">初始化账本，创建汽车、查询汽车、查询所有汽车、变更汽车主人。这些方法都是通过Invoke方法来调用的。</span></span></p>
  <h1><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">三、使用nodejs与链码交互</span></span></h1>
  <h2><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">1、安装node依赖关系</span></span></h2>
  <pre><code class="language-javascript">npm install</code></pre>
  <p>会根据package.json文件中的配置自动将依赖下载并安装到本地目录中。</p>
  <h2>2、注册用户</h2>
  <pre><code class="language-javascript">node enrollAdmin.js 
node registerUser.js</code></pre>
  <p>这两步解释后续再补充，应该是用ca颁布证书之类。。。。</p>
  <h2>3、查询账本</h2>
  <p>1）运行查询及结果：</p>
  <pre><code class="language-javascript">zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js 
Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  [{"Key":"CAR0", "Record":{"colour":"blue","make":"Toyota","model":"Prius","owner":"Tomoko"}},{"Key":"CAR1", "Record":{"colour":"red","make":"Ford","model":"Mustang","owner":"Brad"}},{"Key":"CAR2", "Record":{"colour":"green","make":"Hyundai","model":"Tucson","owner":"Jin Soo"}},{"Key":"CAR3", "Record":{"colour":"yellow","make":"Volkswagen","model":"Passat","owner":"Max"}},{"Key":"CAR4", "Record":{"colour":"black","make":"Tesla","model":"S","owner":"Adriana"}},{"Key":"CAR5", "Record":{"colour":"purple","make":"Peugeot","model":"205","owner":"Michel"}},{"Key":"CAR6", "Record":{"colour":"white","make":"Chery","model":"S22L","owner":"Aarav"}},{"Key":"CAR7", "Record":{"colour":"violet","make":"Fiat","model":"Punto","owner":"Pari"}},{"Key":"CAR8", "Record":{"colour":"indigo","make":"Tata","model":"Nano","owner":"Valeria"}},{"Key":"CAR9", "Record":{"colour":"brown","make":"Holden","model":"Barina","owner":"Shotaro"}}]</code></pre>
  <p>查询返回了所有的汽车的信息。分析一下：</p>
  <p>query.js中的关于查询的参数：</p>
  <pre><code class="language-javascript">const request = {
		//targets : --- letting this default to the peers assigned to the channel
		chaincodeId: 'fabcar',
		fcn: 'queryAllCars',
		args: ['']
	};</code></pre>
  <p>可以看到其调用chaincode里面的queryAllCars方法(截取部分代码)：</p>
  <pre><code class="language-javascript">func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "CAR0"
	endKey := "CAR999"

	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
	.
	.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.
	.&nbsp;&nbsp;&nbsp;&nbsp;
}</code></pre>
  <p>可以看到其调用了Fabric的range查询。</p>
  <p>2）现在进行修改query，查询一辆汽车的信息，将request参数改为下面：</p>
  <pre><code class="language-javascript">const request = {
		//targets : --- letting this default to the peers assigned to the channel
		chaincodeId: 'fabcar',
		// txId: transaction_id,
		fcn: 'queryCar',
		args: ['CAR4']
	};</code></pre>
  <p>再次执行查询：</p>
  <pre><code class="language-javascript">zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js 
Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"colour":"black","make":"Tesla","model":"S","owner":"Adriana"}</code></pre>
  <p>可以看到只返回了一辆车的信息。</p>
  <h2>4、更新账本</h2>
  <p><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">账本更新是从生成交易提案的应用程序开始的。就像查询一样，我们将会构造一个请求，用来识别要进行交易的通道ID、函数以及智能合约。该程序然后调用</span><code style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);">channel.SendTransactionProposal</code><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">API将交易建议发送给peer(s)进行认证。</span><br></p>
  <p><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);"><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">网络（即endorsing peer）返回一个提案答复，应用程序以此来创建和签署交易请求。该请求通过调用</span><code style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);">channel.sendTransaction</code><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">&nbsp;API发送到排序服务器。排序服务器将把交易打包进区块，然后将区块“发送”到通道上的所有peers进行认证。（在我们的例子中，我们只有一个endorsing peer。）</span><br></span></p>
  <p><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);"><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);"><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">最后，应用程序使用</span><code style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);">eh.setPeerAddr</code><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">&nbsp;API连接到peer的事务监听端口，并调用</span><code style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);">eh.registerTxEvent</code><span style="color:rgb(64,64,64);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(252,252,252);">注册与特定交易ID相关联的事务。该API使得应用程序获得事务的结果（即成功提交或不成功）。把它当作一个通知机制。</span><br></span></span></p>
  <p><span style="font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;color:#404040;"><span style="background-color:rgb(252,252,252);">下面进行在账本登记一辆新汽车：</span></span></p>
  <p><span style="font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;color:#404040;"><span style="background-color:rgb(252,252,252);">在invoke.js中可以看到新汽车的参数：</span></span></p>
  <pre><code class="language-javascript">var request = {
		//targets: let default to the peer assigned to the client
		chaincodeId: 'fabcar',
		fcn: 'createCar',
		args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
		chainId: 'mychannel',
		txId: tx_id
	};</code></pre>
  <p>进行创建：</p>
  <pre><code class="language-javascript">zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js 
Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Assigning transaction_id:  e41e97f2647d899f8741dc568e731a01f05f725c83531ad7da711c1a282c702f
Transaction proposal was good
Successfully sent Proposal and received ProposalResponse: Status - 200, message - "OK"
The transaction has been committed on peer localhost:7053
Send transaction promise and event listener promise have completed
Successfully sent transaction to the orderer.
Successfully committed the change to the ledger by the peer</code></pre>
  <p>创建成功，然后下一步将这辆车的主人更换，将invoke.js的参数配置改为：</p>
  <pre><code class="language-javascript">var request = {
		//targets: let default to the peer assigned to the client
		chaincodeId: 'fabcar',
		fcn: 'changeCarOwner',
		args: ['CAR10', 'Barry'],
		chainId: 'mychannel',
		txId: tx_id
	};</code></pre>
  <p>然后执行：</p>
  <pre><code class="language-javascript">zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node invoke.js 
Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Assigning transaction_id:  5c37d72abe8b2ba49a1e00ebf5b4258c6189aaf96c06aff53a30cb03555b6523
Transaction proposal was good
Successfully sent Proposal and received ProposalResponse: Status - 200, message - "OK"
The transaction has been committed on peer localhost:7053
Send transaction promise and event listener promise have completed
Successfully sent transaction to the orderer.
Successfully committed the change to the ledger by the peer</code></pre>
  <p>现在再查询这辆车的车主：</p>
  <p>修改query.js，将args中的CAR4改为CAR10，执行：</p>
  <pre><code class="language-javascript">zhj@zhj-HP:~/project/test_fabric/fabric-samples/fabcar$ node query.js 
Store path:/home/zhj/project/test_fabric/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"colour":"Red","make":"Chevy","model":"Volt","owner":"Barry"}</code></pre>
  <p>可以看到车主已经改变了。</p>
  <p>所有操作都已执行完。除了nodejs外，Fabric还提供了和Java进行交互的sdk。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhj_fly/article/details/80863882,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhj_fly/article/details/80863882,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
