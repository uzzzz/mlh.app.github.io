<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>如何通过solc编译solidity编写的以太坊智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="如何通过solc编译solidity编写的以太坊智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="solc：solidity的编译器 solidity编写的以太坊智能合约可通过命令行编译工具solc来进行编译，成为以太坊虚拟机中的代码。solc编译后最终部署到链上形成我们所见到的各种智能合约。 作为一个solidity命令行编译工具，我们来看看官网都怎么说solc。 solc的安装很简单： npm install -g solc //或者 npm install -g solc-cli //或者 sudo apt-get install solc 安装完成后我们来看，solc --help，solc –help命令显示所有的solc命令选项。编译器可以生成各种输出，比如最终的二进制合约文件、语法树的汇编或者需要预计的要花费的gas等。solc --bin sourceFile.sol，可以编译后输出一个名为sourceFile.sol的智能合约文件。如果你想从solc获得更丰富的一些输出变量，你可以使用solc -o outputDirectory --bin --ast --asm sourceFile.sol。 你在部署以太坊智能合约之前可以用solc --optimize --bin sourceFile.sol优化一下。默认情况下solc编译器会帮你优化200次。你也可以设置 --runs=1，这样就按照最小化的方式进行编译，如果你希望多次交易不太在乎成本，那你可以设置成你想要的次数:)。 命令行编译器会自动读取需要导入的文件，也可以通过使用prefix = path来指定路径，例如： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这样编译器就会从指定目录github.com/ethereum/dapp-bin/下的/usr/local/lib/dapp-bin/目录开始搜索，如果没有找到文件，它将查看/usr/local/lib/fallback。solc将只读取你指定的这两个路径的，因此像import &quot;/etc/passwd&quot;;必须要通过/=重新映射才起作用。如果有多个匹配，则选择具有最长公共前缀的进行匹配。 出于安全上的考虑，编译器限制了它可以访问的一些目录。在命令行中指定的源文件的路径（及其子目录）和命令行指定的路径外其他所有内容都会被拒绝。--allow-paths /sample/path,/another/sample/path来切换。 如果智能合约使用了libraries，你会注意到字节码包含了__LibraryName______的子字符串。您可以使用solc作为链接器，这意味着它将在这些点为您插入库地址。 可以通过添加库--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;到您的命令，以提供每个库的地址，或者使用文件中的说明字符串（每行一个库），并使用--libraries fileName运行solc。 如果用选项--link调用Solc，则所有输入文件都被解释为未链接的二进制文件（HEX编码），在上面给出的__LibraryName____格式中，将其链接到适当地址（如果从stdin读取输入，则将其写入stdout）。在这种情况下，除了库外，所有选项都被忽略（包括-o）。 如果用--standard-json调用SOLC，它就将标准的JSON输入（如下所述），并返回JSON输出。 solc编译器输入输出JSON描述 这些JSON格式通过编译器API使用，可以通过SOLC获得。内容都是可以修改的，一些对象是可选的（如前所述），其目的是向后兼容。 编译器的API需要一个JSON格式的输入，然后以JSON格式输出编译结果。 注意不允许注释。下面示例中的注释，是官网为了学习者更好的理解标注的。 输入格式说明： { // Required: Source code language, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // Required sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings optimizer: { // disabled by default enabled: true, // Optimize for how many times you intend to run the code. // Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage. runs: 200 }, evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. Additionally, `*` can be used as a wildcard to request everything. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出格式说明 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc. // See below for complete list of types. type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 错误类型说明： JSONError：JSON错误，JSON输入不符合要求的格式，例如输入不是JSON对象，不支持语言，等等。 IOError：IO错误，IO和导入处理错误，如提供的源中的不可解析URL或hash不匹配。 ParserError：语法f分析错误，源代码不符合语言规则。 DocstringParsingError：文档解析错误，无法解析注释块中的NATSPEC标记。 SytRealError：语法错误，如continue在for循环之外使用。 DeclarationError：声明错误，无效、不可解析或冲突的标识符名称。例如未找到标识符 TypeError：类型错误，如无效类型转换、无效赋值等。 UnimplementedFeatureError：编译器不支持该特性，但希望在将来的版本中得到支持。 InternalCompilerError：编译器中触发内部错误，这应该作为一个问题来反馈。 Exception：例外，编译过程中未知的故障，这应该作为一个问题反馈。 CompilerError：编译错误，编译器堆栈的使用无效，这应该作为一个问题来反馈。 FatalError：致命错误，这应该作为一个问题来反馈。 Warning：警告并没有停止编译，但如果可能的话，应该加以处理。 原文请访问：solc 如果你希望马上开始学习以太坊DApp开发，推荐访问一个在线教程： * 以太坊智能合约，主要介绍智能合约与dapp应用开发，适合入门。 * 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多" />
<meta property="og:description" content="solc：solidity的编译器 solidity编写的以太坊智能合约可通过命令行编译工具solc来进行编译，成为以太坊虚拟机中的代码。solc编译后最终部署到链上形成我们所见到的各种智能合约。 作为一个solidity命令行编译工具，我们来看看官网都怎么说solc。 solc的安装很简单： npm install -g solc //或者 npm install -g solc-cli //或者 sudo apt-get install solc 安装完成后我们来看，solc --help，solc –help命令显示所有的solc命令选项。编译器可以生成各种输出，比如最终的二进制合约文件、语法树的汇编或者需要预计的要花费的gas等。solc --bin sourceFile.sol，可以编译后输出一个名为sourceFile.sol的智能合约文件。如果你想从solc获得更丰富的一些输出变量，你可以使用solc -o outputDirectory --bin --ast --asm sourceFile.sol。 你在部署以太坊智能合约之前可以用solc --optimize --bin sourceFile.sol优化一下。默认情况下solc编译器会帮你优化200次。你也可以设置 --runs=1，这样就按照最小化的方式进行编译，如果你希望多次交易不太在乎成本，那你可以设置成你想要的次数:)。 命令行编译器会自动读取需要导入的文件，也可以通过使用prefix = path来指定路径，例如： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这样编译器就会从指定目录github.com/ethereum/dapp-bin/下的/usr/local/lib/dapp-bin/目录开始搜索，如果没有找到文件，它将查看/usr/local/lib/fallback。solc将只读取你指定的这两个路径的，因此像import &quot;/etc/passwd&quot;;必须要通过/=重新映射才起作用。如果有多个匹配，则选择具有最长公共前缀的进行匹配。 出于安全上的考虑，编译器限制了它可以访问的一些目录。在命令行中指定的源文件的路径（及其子目录）和命令行指定的路径外其他所有内容都会被拒绝。--allow-paths /sample/path,/another/sample/path来切换。 如果智能合约使用了libraries，你会注意到字节码包含了__LibraryName______的子字符串。您可以使用solc作为链接器，这意味着它将在这些点为您插入库地址。 可以通过添加库--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;到您的命令，以提供每个库的地址，或者使用文件中的说明字符串（每行一个库），并使用--libraries fileName运行solc。 如果用选项--link调用Solc，则所有输入文件都被解释为未链接的二进制文件（HEX编码），在上面给出的__LibraryName____格式中，将其链接到适当地址（如果从stdin读取输入，则将其写入stdout）。在这种情况下，除了库外，所有选项都被忽略（包括-o）。 如果用--standard-json调用SOLC，它就将标准的JSON输入（如下所述），并返回JSON输出。 solc编译器输入输出JSON描述 这些JSON格式通过编译器API使用，可以通过SOLC获得。内容都是可以修改的，一些对象是可选的（如前所述），其目的是向后兼容。 编译器的API需要一个JSON格式的输入，然后以JSON格式输出编译结果。 注意不允许注释。下面示例中的注释，是官网为了学习者更好的理解标注的。 输入格式说明： { // Required: Source code language, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // Required sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings optimizer: { // disabled by default enabled: true, // Optimize for how many times you intend to run the code. // Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage. runs: 200 }, evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. Additionally, `*` can be used as a wildcard to request everything. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出格式说明 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc. // See below for complete list of types. type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 错误类型说明： JSONError：JSON错误，JSON输入不符合要求的格式，例如输入不是JSON对象，不支持语言，等等。 IOError：IO错误，IO和导入处理错误，如提供的源中的不可解析URL或hash不匹配。 ParserError：语法f分析错误，源代码不符合语言规则。 DocstringParsingError：文档解析错误，无法解析注释块中的NATSPEC标记。 SytRealError：语法错误，如continue在for循环之外使用。 DeclarationError：声明错误，无效、不可解析或冲突的标识符名称。例如未找到标识符 TypeError：类型错误，如无效类型转换、无效赋值等。 UnimplementedFeatureError：编译器不支持该特性，但希望在将来的版本中得到支持。 InternalCompilerError：编译器中触发内部错误，这应该作为一个问题来反馈。 Exception：例外，编译过程中未知的故障，这应该作为一个问题反馈。 CompilerError：编译错误，编译器堆栈的使用无效，这应该作为一个问题来反馈。 FatalError：致命错误，这应该作为一个问题来反馈。 Warning：警告并没有停止编译，但如果可能的话，应该加以处理。 原文请访问：solc 如果你希望马上开始学习以太坊DApp开发，推荐访问一个在线教程： * 以太坊智能合约，主要介绍智能合约与dapp应用开发，适合入门。 * 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/06/16/2445f2c78dc7bed28f4f575aa59f444d.html" />
<meta property="og:url" content="https://mlh.app/2018/06/16/2445f2c78dc7bed28f4f575aa59f444d.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"solc：solidity的编译器 solidity编写的以太坊智能合约可通过命令行编译工具solc来进行编译，成为以太坊虚拟机中的代码。solc编译后最终部署到链上形成我们所见到的各种智能合约。 作为一个solidity命令行编译工具，我们来看看官网都怎么说solc。 solc的安装很简单： npm install -g solc //或者 npm install -g solc-cli //或者 sudo apt-get install solc 安装完成后我们来看，solc --help，solc –help命令显示所有的solc命令选项。编译器可以生成各种输出，比如最终的二进制合约文件、语法树的汇编或者需要预计的要花费的gas等。solc --bin sourceFile.sol，可以编译后输出一个名为sourceFile.sol的智能合约文件。如果你想从solc获得更丰富的一些输出变量，你可以使用solc -o outputDirectory --bin --ast --asm sourceFile.sol。 你在部署以太坊智能合约之前可以用solc --optimize --bin sourceFile.sol优化一下。默认情况下solc编译器会帮你优化200次。你也可以设置 --runs=1，这样就按照最小化的方式进行编译，如果你希望多次交易不太在乎成本，那你可以设置成你想要的次数:)。 命令行编译器会自动读取需要导入的文件，也可以通过使用prefix = path来指定路径，例如： solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol 这样编译器就会从指定目录github.com/ethereum/dapp-bin/下的/usr/local/lib/dapp-bin/目录开始搜索，如果没有找到文件，它将查看/usr/local/lib/fallback。solc将只读取你指定的这两个路径的，因此像import &quot;/etc/passwd&quot;;必须要通过/=重新映射才起作用。如果有多个匹配，则选择具有最长公共前缀的进行匹配。 出于安全上的考虑，编译器限制了它可以访问的一些目录。在命令行中指定的源文件的路径（及其子目录）和命令行指定的路径外其他所有内容都会被拒绝。--allow-paths /sample/path,/another/sample/path来切换。 如果智能合约使用了libraries，你会注意到字节码包含了__LibraryName______的子字符串。您可以使用solc作为链接器，这意味着它将在这些点为您插入库地址。 可以通过添加库--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;到您的命令，以提供每个库的地址，或者使用文件中的说明字符串（每行一个库），并使用--libraries fileName运行solc。 如果用选项--link调用Solc，则所有输入文件都被解释为未链接的二进制文件（HEX编码），在上面给出的__LibraryName____格式中，将其链接到适当地址（如果从stdin读取输入，则将其写入stdout）。在这种情况下，除了库外，所有选项都被忽略（包括-o）。 如果用--standard-json调用SOLC，它就将标准的JSON输入（如下所述），并返回JSON输出。 solc编译器输入输出JSON描述 这些JSON格式通过编译器API使用，可以通过SOLC获得。内容都是可以修改的，一些对象是可选的（如前所述），其目的是向后兼容。 编译器的API需要一个JSON格式的输入，然后以JSON格式输出编译结果。 注意不允许注释。下面示例中的注释，是官网为了学习者更好的理解标注的。 输入格式说明： { // Required: Source code language, such as &quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc. language: &quot;Solidity&quot;, // Required sources: { // The keys here are the &quot;global&quot; names of the source files, // imports can use other files via remappings (see below). &quot;myFile.sol&quot;: { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. &quot;keccak256&quot;: &quot;0x123...&quot;, // Required (unless &quot;content&quot; is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn&#39;t match or none of the // URL(s) result in success, an error should be raised. &quot;urls&quot;: [ &quot;bzzr://56ab...&quot;, &quot;ipfs://Qma...&quot;, &quot;file:///tmp/path/to/file.sol&quot; ] }, &quot;mortal&quot;: { // Optional: keccak256 hash of the source file &quot;keccak256&quot;: &quot;0x234...&quot;, // Required (unless &quot;urls&quot; is used): literal contents of the source file &quot;content&quot;: &quot;contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }&quot; } }, // Optional settings: { // Optional: Sorted list of remappings remappings: [ &quot;:g/dir&quot; ], // Optional: Optimizer settings optimizer: { // disabled by default enabled: true, // Optimize for how many times you intend to run the code. // Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage. runs: 200 }, evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople // Metadata settings (optional) metadata: { // Use only literal content and not URLs (false by default) useLiteralContent: true }, // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different. libraries: { // The top level key is the the name of the source file where the library is used. // If remappings are used, this source file should match the global path after remappings were applied. // If this key is an empty string, that refers to a global level. &quot;myFile.sol&quot;: { &quot;MyLib&quot;: &quot;0x123123...&quot; } } // The following can be used to select desired outputs. // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors. // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself, // while the star refers to all of the contracts. // // The available output types are as follows: // abi - ABI // ast - AST of all source files // legacyAST - legacy AST of all source files // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - New assembly format before desugaring // evm.assembly - New assembly format after desugaring // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode) // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // ewasm.wast - eWASM S-expressions format (not supported atm) // ewasm.wasm - eWASM binary format (not supported atm) // // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every // target part of that output. Additionally, `*` can be used as a wildcard to request everything. // outputSelection: { // Enable the metadata and bytecode outputs of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ] }, // Enable the abi and opcodes output of MyContract defined in file def. &quot;def&quot;: { &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ] }, // Enable the source map output of every single contract. &quot;*&quot;: { &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ] }, // Enable the legacy AST output of every single file. &quot;*&quot;: { &quot;&quot;: [ &quot;legacyAST&quot; ] } } } } 输出格式说明 { // Optional: not present if no errors/warnings were encountered errors: [ { // Optional: Location within the source file. sourceLocation: { file: &quot;sourceFile.sol&quot;, start: 0, end: 100 ], // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc. // See below for complete list of types. type: &quot;TypeError&quot;, // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc. component: &quot;general&quot;, // Mandatory (&quot;error&quot; or &quot;warning&quot;) severity: &quot;error&quot;, // Mandatory message: &quot;Invalid keyword&quot; // Optional: the message formatted with source location formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot; } ], // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings. sources: { &quot;sourceFile.sol&quot;: { // Identifier (used in source maps) id: 1, // The AST object ast: {}, // The legacy AST object legacyAST: {} } }, // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings. contracts: { &quot;sourceFile.sol&quot;: { // If the language used has no contract names, this field should equal to an empty string. &quot;ContractName&quot;: { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI abi: [], // See the Metadata Output documentation (serialised JSON string) metadata: &quot;{...}&quot;, // User documentation (natspec) userdoc: {}, // Developer documentation (natspec) devdoc: {}, // Intermediate representation (string) ir: &quot;&quot;, // EVM-related outputs evm: { // Assembly (string) assembly: &quot;&quot;, // Old-style assembly (object) legacyAssembly: {}, // Bytecode and related details. bytecode: { // The bytecode as a hex string. object: &quot;00fe&quot;, // Opcodes list (string) opcodes: &quot;&quot;, // The source mapping as a string. See the source mapping definition. sourceMap: &quot;&quot;, // If given, this is an unlinked object. linkReferences: { &quot;libraryFile.sol&quot;: { // Byte offsets into the bytecode. Linking replaces the 20 bytes located there. &quot;Library1&quot;: [ { start: 0, length: 20 }, { start: 200, length: 20 } ] } } }, // The same layout as above. deployedBytecode: { }, // The list of function hashes methodIdentifiers: { &quot;delegate(address)&quot;: &quot;5c19a95c&quot; }, // Function gas estimates gasEstimates: { creation: { codeDepositCost: &quot;420000&quot;, executionCost: &quot;infinite&quot;, totalCost: &quot;infinite&quot; }, external: { &quot;delegate(address)&quot;: &quot;25000&quot; }, internal: { &quot;heavyLifting()&quot;: &quot;infinite&quot; } } }, // eWASM related outputs ewasm: { // S-expressions format wast: &quot;&quot;, // Binary format (hex string) wasm: &quot;&quot; } } } } } 错误类型说明： JSONError：JSON错误，JSON输入不符合要求的格式，例如输入不是JSON对象，不支持语言，等等。 IOError：IO错误，IO和导入处理错误，如提供的源中的不可解析URL或hash不匹配。 ParserError：语法f分析错误，源代码不符合语言规则。 DocstringParsingError：文档解析错误，无法解析注释块中的NATSPEC标记。 SytRealError：语法错误，如continue在for循环之外使用。 DeclarationError：声明错误，无效、不可解析或冲突的标识符名称。例如未找到标识符 TypeError：类型错误，如无效类型转换、无效赋值等。 UnimplementedFeatureError：编译器不支持该特性，但希望在将来的版本中得到支持。 InternalCompilerError：编译器中触发内部错误，这应该作为一个问题来反馈。 Exception：例外，编译过程中未知的故障，这应该作为一个问题反馈。 CompilerError：编译错误，编译器堆栈的使用无效，这应该作为一个问题来反馈。 FatalError：致命错误，这应该作为一个问题来反馈。 Warning：警告并没有停止编译，但如果可能的话，应该加以处理。 原文请访问：solc 如果你希望马上开始学习以太坊DApp开发，推荐访问一个在线教程： * 以太坊智能合约，主要介绍智能合约与dapp应用开发，适合入门。 * 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/06/16/2445f2c78dc7bed28f4f575aa59f444d.html","headline":"如何通过solc编译solidity编写的以太坊智能合约","dateModified":"2018-06-16T00:00:00+08:00","datePublished":"2018-06-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/06/16/2445f2c78dc7bed28f4f575aa59f444d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>如何通过solc编译solidity编写的以太坊智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="solcsolidity的编译器">solc：solidity的编译器</h1> 
  <p>solidity编写的以太坊智能合约可通过命令行编译工具solc来进行编译，成为以太坊虚拟机中的代码。solc编译后最终部署到链上形成我们所见到的各种智能合约。</p> 
  <p>作为一个solidity命令行编译工具，我们来看看官网都怎么说solc。</p> 
  <p>solc的安装很简单：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">npm install <span class="hljs-attribute">-g</span> solc
<span class="hljs-comment">//或者</span>
npm install <span class="hljs-attribute">-g</span> solc<span class="hljs-attribute">-cli</span>
<span class="hljs-comment">//或者</span>
sudo apt<span class="hljs-attribute">-get</span> install solc</code></pre> 
  <p>安装完成后我们来看，<code>solc --help</code>，solc –help命令显示所有的solc命令选项。编译器可以生成各种输出，比如最终的二进制合约文件、语法树的汇编或者需要预计的要花费的gas等。<code>solc --bin sourceFile.sol</code>，可以编译后输出一个名为sourceFile.sol的智能合约文件。如果你想从<code>solc</code>获得更丰富的一些输出变量，你可以使用<code>solc -o outputDirectory --bin --ast --asm sourceFile.sol</code>。</p> 
  <p>你在部署<a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1" rel="nofollow">以太坊智能合约</a>之前可以用<code>solc --optimize --bin sourceFile.sol</code>优化一下。默认情况下solc编译器会帮你优化200次。你也可以设置 <code>--runs=1</code>，这样就按照最小化的方式进行编译，如果你希望多次交易不太在乎成本，那你可以设置成你想要的次数:)。</p> 
  <p>命令行编译器会自动读取需要导入的文件，也可以通过使用<code>prefix = path</code>来指定路径，例如：</p> 
  <blockquote> 
   <p><code>solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol</code></p> 
  </blockquote> 
  <p>这样编译器就会从指定目录<code>github.com/ethereum/dapp-bin/</code>下的<code>/usr/local/lib/dapp-bin/</code>目录开始搜索，如果没有找到文件，它将查看<code>/usr/local/lib/fallback</code>。solc将只读取你指定的这两个路径的，因此像<code>import "/etc/passwd";</code>必须要通过<code>/=</code>重新映射才起作用。如果有多个匹配，则选择具有最长公共前缀的进行匹配。</p> 
  <p>出于安全上的考虑，编译器限制了它可以访问的一些目录。在命令行中指定的源文件的路径（及其子目录）和命令行指定的路径外其他所有内容都会被拒绝。<code>--allow-paths /sample/path,/another/sample/path</code>来切换。</p> 
  <p>如果智能合约使用了<a href="https://solidity.readthedocs.io/en/v0.4.24/contracts.html#libraries" rel="nofollow">libraries</a>，你会注意到字节码包含了<code>__LibraryName______</code>的子字符串。您可以使用solc作为链接器，这意味着它将在这些点为您插入库地址。</p> 
  <p>可以通过添加库<code>--libraries "Math:0x12345678901234567890 Heap:0xabcdef0123456"</code>到您的命令，以提供每个库的地址，或者使用文件中的说明字符串（每行一个库），并使用<code>--libraries fileName</code>运行solc。</p> 
  <p>如果用选项<code>--link</code>调用Solc，则所有输入文件都被解释为未链接的二进制文件（HEX编码），在上面给出的<code>__LibraryName____</code>格式中，将其链接到适当地址（如果从stdin读取输入，则将其写入stdout）。在这种情况下，除了库外，所有选项都被忽略（包括<code>-o</code>）。</p> 
  <p>如果用<code>--standard-json</code>调用SOLC，它就将标准的JSON输入（如下所述），并返回JSON输出。</p> 
  <h1 id="solc编译器输入输出json描述">solc编译器输入输出JSON描述</h1> 
  <p>这些JSON格式通过编译器API使用，可以通过SOLC获得。内容都是可以修改的，一些对象是可选的（如前所述），其目的是向后兼容。</p> 
  <p>编译器的API需要一个JSON格式的输入，然后以JSON格式输出编译结果。</p> 
  <p><strong>注意不允许注释</strong>。下面示例中的注释，是官网为了学习者更好的理解标注的。</p> 
  <ul> 
   <li>输入格式说明：</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs cs">{
  <span class="hljs-comment">// Required: Source code language, such as "Solidity", "serpent", "lll", "assembly", etc.</span>
  language: <span class="hljs-string">"Solidity"</span>,
  <span class="hljs-comment">// Required</span>
  sources:
  {
    <span class="hljs-comment">// The keys here are the "global" names of the source files,</span>
    <span class="hljs-comment">// imports can use other files via remappings (see below).</span>
    <span class="hljs-string">"myFile.sol"</span>:
    {
      <span class="hljs-comment">// Optional: keccak256 hash of the source file</span>
      <span class="hljs-comment">// It is used to verify the retrieved content if imported via URLs.</span>
      <span class="hljs-string">"keccak256"</span>: <span class="hljs-string">"0x123..."</span>,
      <span class="hljs-comment">// Required (unless "content" is used, see below): URL(s) to the source file.</span>
      <span class="hljs-comment">// URL(s) should be imported in this order and the result checked against the</span>
      <span class="hljs-comment">// keccak256 hash (if available). If the hash doesn't match or none of the</span>
      <span class="hljs-comment">// URL(s) result in success, an error should be raised.</span>
      <span class="hljs-string">"urls"</span>:
      [
        <span class="hljs-string">"bzzr://56ab..."</span>,
        <span class="hljs-string">"ipfs://Qma..."</span>,
        <span class="hljs-string">"file:///tmp/path/to/file.sol"</span>
      ]
    },
    <span class="hljs-string">"mortal"</span>:
    {
      <span class="hljs-comment">// Optional: keccak256 hash of the source file</span>
      <span class="hljs-string">"keccak256"</span>: <span class="hljs-string">"0x234..."</span>,
      <span class="hljs-comment">// Required (unless "urls" is used): literal contents of the source file</span>
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }"</span>
    }
  },
  <span class="hljs-comment">// Optional</span>
  settings:
  {
    <span class="hljs-comment">// Optional: Sorted list of remappings</span>
    remappings: [ <span class="hljs-string">":g/dir"</span> ],
    <span class="hljs-comment">// Optional: Optimizer settings</span>
    optimizer: {
      <span class="hljs-comment">// disabled by default</span>
      enabled: <span class="hljs-keyword">true</span>,
      <span class="hljs-comment">// Optimize for how many times you intend to run the code.</span>
      <span class="hljs-comment">// Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage.</span>
      runs: <span class="hljs-number">200</span>
    },
    evmVersion: <span class="hljs-string">"byzantium"</span>, <span class="hljs-comment">// Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople</span>
    <span class="hljs-comment">// Metadata settings (optional)</span>
    metadata: {
      <span class="hljs-comment">// Use only literal content and not URLs (false by default)</span>
      useLiteralContent: <span class="hljs-keyword">true</span>
    },
    <span class="hljs-comment">// Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.</span>
    libraries: {
      <span class="hljs-comment">// The top level key is the the name of the source file where the library is used.</span>
      <span class="hljs-comment">// If remappings are used, this source file should match the global path after remappings were applied.</span>
      <span class="hljs-comment">// If this key is an empty string, that refers to a global level.</span>
      <span class="hljs-string">"myFile.sol"</span>: {
        <span class="hljs-string">"MyLib"</span>: <span class="hljs-string">"0x123123..."</span>
      }
    }
    <span class="hljs-comment">// The following can be used to select desired outputs.</span>
    <span class="hljs-comment">// If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.</span>
    <span class="hljs-comment">// The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,</span>
    <span class="hljs-comment">// while the star refers to all of the contracts.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The available output types are as follows:</span>
    <span class="hljs-comment">// abi - ABI</span>
    <span class="hljs-comment">// ast - AST of all source files</span>
    <span class="hljs-comment">// legacyAST - legacy AST of all source files</span>
    <span class="hljs-comment">// devdoc - Developer documentation (natspec)</span>
    <span class="hljs-comment">// userdoc - User documentation (natspec)</span>
    <span class="hljs-comment">// metadata - Metadata</span>
    <span class="hljs-comment">// ir - New assembly format before desugaring</span>
    <span class="hljs-comment">// evm.assembly - New assembly format after desugaring</span>
    <span class="hljs-comment">// evm.legacyAssembly - Old-style assembly format in JSON</span>
    <span class="hljs-comment">// evm.bytecode.object - Bytecode object</span>
    <span class="hljs-comment">// evm.bytecode.opcodes - Opcodes list</span>
    <span class="hljs-comment">// evm.bytecode.sourceMap - Source mapping (useful for debugging)</span>
    <span class="hljs-comment">// evm.bytecode.linkReferences - Link references (if unlinked object)</span>
    <span class="hljs-comment">// evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)</span>
    <span class="hljs-comment">// evm.methodIdentifiers - The list of function hashes</span>
    <span class="hljs-comment">// evm.gasEstimates - Function gas estimates</span>
    <span class="hljs-comment">// ewasm.wast - eWASM S-expressions format (not supported atm)</span>
    <span class="hljs-comment">// ewasm.wasm - eWASM binary format (not supported atm)</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every</span>
    <span class="hljs-comment">// target part of that output. Additionally, `*` can be used as a wildcard to request everything.</span>
    <span class="hljs-comment">//</span>
    outputSelection: {
      <span class="hljs-comment">// Enable the metadata and bytecode outputs of every single contract.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">"*"</span>: [ <span class="hljs-string">"metadata"</span>, <span class="hljs-string">"evm.bytecode"</span> ]
      },
      <span class="hljs-comment">// Enable the abi and opcodes output of MyContract defined in file def.</span>
      <span class="hljs-string">"def"</span>: {
        <span class="hljs-string">"MyContract"</span>: [ <span class="hljs-string">"abi"</span>, <span class="hljs-string">"evm.bytecode.opcodes"</span> ]
      },
      <span class="hljs-comment">// Enable the source map output of every single contract.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">"*"</span>: [ <span class="hljs-string">"evm.bytecode.sourceMap"</span> ]
      },
      <span class="hljs-comment">// Enable the legacy AST output of every single file.</span>
      <span class="hljs-string">"*"</span>: {
        <span class="hljs-string">""</span>: [ <span class="hljs-string">"legacyAST"</span> ]
      }
    }
  }
}</code></pre> 
  <ul> 
   <li>输出格式说明</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">{
 <span class="hljs-comment"> // Optional: not present if no errors/warnings were encountered</span>
  errors: [
    {
     <span class="hljs-comment"> // Optional: Location within the source file.</span>
      sourceLocation: {
        <span class="hljs-built_in">file</span>: <span class="hljs-string">"sourceFile.sol"</span>,
        start: <span class="hljs-number">0</span>,
        <span class="hljs-function"><span class="hljs-keyword">end</span>: <span class="hljs-title">100</span></span>
      ],
     <span class="hljs-comment"> // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.</span>
     <span class="hljs-comment"> // See below for complete list of types.</span>
      type: <span class="hljs-string">"TypeError"</span>,
     <span class="hljs-comment"> // Mandatory: Component where the error originated, such as "general", "ewasm", etc.</span>
      component: <span class="hljs-string">"general"</span>,
     <span class="hljs-comment"> // Mandatory ("error" or "warning")</span>
      severity: <span class="hljs-string">"error"</span>,
     <span class="hljs-comment"> // Mandatory</span>
      message: <span class="hljs-string">"Invalid keyword"</span>
     <span class="hljs-comment"> // Optional: the message formatted with source location</span>
      formattedMessage: <span class="hljs-string">"sourceFile.sol:100: Invalid keyword"</span>
    }
  ],
 <span class="hljs-comment"> // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.</span>
  sources: {
    <span class="hljs-string">"sourceFile.sol"</span>: {
     <span class="hljs-comment"> // Identifier (used in source maps)</span>
      id: <span class="hljs-number">1</span>,
     <span class="hljs-comment"> // The AST object</span>
      ast: {},
     <span class="hljs-comment"> // The legacy AST object</span>
      legacyAST: {}
    }
  },
 <span class="hljs-comment"> // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.</span>
  contracts: {
    <span class="hljs-string">"sourceFile.sol"</span>: {
     <span class="hljs-comment"> // If the language used has no contract names, this field should equal to an empty string.</span>
      <span class="hljs-string">"ContractName"</span>: {
       <span class="hljs-comment"> // The Ethereum Contract ABI. If empty, it is represented as an empty array.</span>
       <span class="hljs-comment"> // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</span>
        abi: [],
       <span class="hljs-comment"> // See the Metadata Output documentation (serialised JSON string)</span>
        metadata: <span class="hljs-string">"{...}"</span>,
       <span class="hljs-comment"> // User documentation (natspec)</span>
        userdoc: {},
       <span class="hljs-comment"> // Developer documentation (natspec)</span>
        devdoc: {},
       <span class="hljs-comment"> // Intermediate representation (string)</span>
        ir: <span class="hljs-string">""</span>,
       <span class="hljs-comment"> // EVM-related outputs</span>
        evm: {
         <span class="hljs-comment"> // Assembly (string)</span>
          assembly: <span class="hljs-string">""</span>,
         <span class="hljs-comment"> // Old-style assembly (object)</span>
          legacyAssembly: {},
         <span class="hljs-comment"> // Bytecode and related details.</span>
          bytecode: {
           <span class="hljs-comment"> // The bytecode as a hex string.</span>
            object: <span class="hljs-string">"00fe"</span>,
           <span class="hljs-comment"> // Opcodes list (string)</span>
            opcodes: <span class="hljs-string">""</span>,
           <span class="hljs-comment"> // The source mapping as a string. See the source mapping definition.</span>
            sourceMap: <span class="hljs-string">""</span>,
           <span class="hljs-comment"> // If given, this is an unlinked object.</span>
            linkReferences: {
              <span class="hljs-string">"libraryFile.sol"</span>: {
               <span class="hljs-comment"> // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.</span>
                <span class="hljs-string">"Library1"</span>: [
                  { start: <span class="hljs-number">0</span>, <span class="hljs-built_in">length</span>: <span class="hljs-number">20</span> },
                  { start: <span class="hljs-number">200</span>, <span class="hljs-built_in">length</span>: <span class="hljs-number">20</span> }
                ]
              }
            }
          },
         <span class="hljs-comment"> // The same layout as above.</span>
          deployedBytecode: { },
         <span class="hljs-comment"> // The list of function hashes</span>
          methodIdentifiers: {
            <span class="hljs-string">"delegate(address)"</span>: <span class="hljs-string">"5c19a95c"</span>
          },
         <span class="hljs-comment"> // Function gas estimates</span>
          gasEstimates: {
            creation: {
              codeDepositCost: <span class="hljs-string">"420000"</span>,
              executionCost: <span class="hljs-string">"infinite"</span>,
              totalCost: <span class="hljs-string">"infinite"</span>
            },
            external: {
              <span class="hljs-string">"delegate(address)"</span>: <span class="hljs-string">"25000"</span>
            },
            internal: {
              <span class="hljs-string">"heavyLifting()"</span>: <span class="hljs-string">"infinite"</span>
            }
          }
        },
       <span class="hljs-comment"> // eWASM related outputs</span>
        ewasm: {
         <span class="hljs-comment"> // S-expressions format</span>
          wast: <span class="hljs-string">""</span>,
         <span class="hljs-comment"> // Binary format (hex string)</span>
          wasm: <span class="hljs-string">""</span>
        }
      }
    }
  }
}</code></pre> 
  <ul> 
   <li>错误类型说明： <br> 
    <ol>
     <li>JSONError：JSON错误，JSON输入不符合要求的格式，例如输入不是JSON对象，不支持语言，等等。</li> 
     <li>IOError：IO错误，IO和导入处理错误，如提供的源中的不可解析URL或hash不匹配。</li> 
     <li>ParserError：语法f分析错误，源代码不符合语言规则。</li> 
     <li>DocstringParsingError：文档解析错误，无法解析注释块中的NATSPEC标记。</li> 
     <li>SytRealError：语法错误，如<code>continue</code>在<code>for</code>循环之外使用。</li> 
     <li>DeclarationError：声明错误，无效、不可解析或冲突的标识符名称。例如未找到标识符</li> 
     <li>TypeError：类型错误，如无效类型转换、无效赋值等。</li> 
     <li>UnimplementedFeatureError：编译器不支持该特性，但希望在将来的版本中得到支持。</li> 
     <li>InternalCompilerError：编译器中触发内部错误，这应该作为一个问题来反馈。</li> 
     <li>Exception：例外，编译过程中未知的故障，这应该作为一个问题反馈。</li> 
     <li>CompilerError：编译错误，编译器堆栈的使用无效，这应该作为一个问题来反馈。</li> 
     <li>FatalError：致命错误，这应该作为一个问题来反馈。</li> 
     <li>Warning：警告并没有停止编译，但如果可能的话，应该加以处理。</li>
    </ol></li> 
  </ul> 
  <p>原文请访问：<a href="http://blog.hubwiz.com/2018/06/14/solc-compiler/" rel="nofollow">solc</a></p> 
  <blockquote> 
   <p>如果你希望马上开始学习以太坊DApp开发，推荐访问一个在线教程： <br> * <a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=csdn616" rel="nofollow">以太坊智能合约</a>，主要介绍智能合约与dapp应用开发，适合入门。 <br> * <a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=csdn616" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</p> 
  </blockquote> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80712051,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/80712051,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
