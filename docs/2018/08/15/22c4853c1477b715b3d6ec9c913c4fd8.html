<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13-数据结构-交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13-数据结构-交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81624052 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿(比特币区块链)。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 首先来看src/primitives/transaction.h 参考https://blog.csdn.net/pure_lady/article/details/77771392 COutPoint CTxIn CTxOut CTransaction 画了类图，大概的来看下这几个类的关系 COutPoint 字段尺寸 描述 数据类型 说明 32 hash uint256 交易的哈希 4 n uint32_t 指定tx输出的索引，第一笔输出的索引是0，以此类推 /** An outpoint - a combination of a transaction hash and an index n into its vout */ /* COutPoint主要用于在交易的输入CTxIn中，用来确定当前输出的来源， *包括前一笔交易的hash,以及对应前一笔交易中的第几个输出的序列号*/ class COutPoint { public: uint256 hash; //交易的哈希 uint32_t n; //对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } /*在类的主体中添加ADD_SERIALIZE_METHODS，可以使包装器作为成员，有三种方法，具体内容查看定义*/ ADD_SERIALIZE_METHODS; //用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载符号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; CTxIn 字段尺寸 描述 数据类型 说明 36 prevout COutPoint 对前一输出的引用，即需要出示那个账单的txid,也就是说，你花费的任何一笔钱都应该有人转给你过 ？ scriptSig CScript 用于确认交易授权的计算脚本，对这笔交易的签名 4 nSequence uint32_t 发送者定义的交易版本，用于在交易被写入block之前更改交易 ？ scriptWitness CScriptWitness 隔离见证脚本 explicit避免够高函数的参数自动转换为类对象的标识符，explicit关键字只对有一个参数的类构造函数有效，如果类的构造函数参数大于或等于2个时，是不会发生隐式转换的，explicit关键字也就无效了，存在一个例外，当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效参考https://www.cnblogs.com/ymy124/p/3632634.html /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ /*交易的输入,包含当前输入对应的前一笔交易输出的位置，以及花费前一笔输出需要的签名脚本*/ class CTxIn { public: COutPoint prevout; //前一笔交易输出的位置 CScript scriptSig; //解锁脚本 uint32_t nSequence; //序列号 /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ //如果一笔交易中的所有输入的nSequence都被设置为SEQUENCE_FINAL，那么禁用nLockTime static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ //这个标志应用于bip68的上下文中如果设置了这个变量，nSequence设置就与lock-time无关 static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ //如果nSequence与lock-time相关并且设置了这个变量，那么相关的锁定时间就为512秒， //或者1个区块的时间。 static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ //如果nSequence与lock-time相关，那么这个变量就用来从序列字段中提取锁定时间 static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ //这里是为了保证等长的数据位 static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } //禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS;//序列化 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; CTxOut 字段尺寸 描述 数据类型 说明 8 nValue CAmount(int64_t) 交易的比特币数量，单位聪（0.00000001） ？ scriptPubKey CScript 锁定脚本，一般为对方的公钥，有一系列与交易相关的信息和操作组成 /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ //交易的输出，包含金额和锁定脚本 class CTxOut { public: CAmount nValue;//输出金额 CScript scriptPubKey;//锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; //内联方式提供见证数据（脚本） template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } uint256 GetHash() const; //获取dust阈值，一笔交易如果交易费大于dust阈值，就会被认为是dust tx CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /*&quot;Dust&quot;是从CTransaction::minRelayTxFee来定义的，单位是satoshis/千字节， *如果在一笔交易中交易费占了1/3以上，那么我们认为该交易是&quot;Dust&quot;交易。 *一个典型的可花费的非隔离见证的txout是34字节大小，CTxIn至少需要148字节， *因此dust交易的可花费支出少于546*minRelayTxFee/1000聪 *典型的隔离见证中dust交易的可花费支出少于294*minRelayTxFee/1000*/ if (scriptPubKey.IsUnspendable())//判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; //判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 关于隔离见证，参考了《精通比特币》附录四 隔离见证 在引入“隔离见证”之前，每一个交易输入后面都跟着用来对其解锁的见证数据， 见证数据作为输入的一部分被内嵌其中。术语“隔离见证”( segregated witness)， 或简称为“segwit”，简单理解就是将某个特定输出的签名分离开，或将某个特定输 入的脚本进行解锁。用最简单的形式来理解就是“分离解锁脚本”(separate scriptSig)，或“分离签名”(separate signature) 因此，隔离见证就是比特币的一种结构性调整，旨在将见证数据部分从一笔交易 的 scriptSig(解锁脚本)字段移出至一个伴随交易的单独的见证数据结构。客户 端请求交易数据时可以选择要或不要该部分伴随的见证数据。 CTransaction 字段尺寸 描述 数据类型 说明 4 nVersion int32_t 交易数据格式版本 41+ vin std::vector&lt;CTxIn&gt; 交易的输入 9+ vout std::vector&lt;CTxOut&gt; 交易的输出 4 nLockTime uint32_t nLockTime应该理解为锁定交易的期限或者block数目，若该交易的所有输入CTxIn的nSequence字段为uint32_t的最大值（0xffffffff），则忽略该字段的逻辑检查。 当nSequence&lt;0xffffffff,且nLockTime==0，该交易可以立即被打包 当nSequence&lt;0xffffffff,且nLockTime！=0时： // Threshold for nLockTime: below this value it is interpreted as block number, // otherwise as UNIX timestamp. static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov 5 00:53:20 1985 UTC 若nLockTime&lt;500000000,则nLockTime代表区块数，该交易只能被打包进高度大于等于nLockTime的区块； 若nLockTime&gt;500000000，则nLockTime代表unix时间戳，该交易只能等到当前时间大于等于nLockTime才能被打包进区块 /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. *在网络中被广播并打包进区块的基本交易。一个交易可以包含多个输入和输出 */ class CTransaction { private: /** Memory only. */ const uint256 hash; public: // Default transaction version.默认交易版本 static const int32_t CURRENT_VERSION=1; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /*本地变量被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值， *但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容*/ const int32_t nVersion;//版本 const std::vector&lt;CTxIn&gt; vin;//交易输入 const std::vector&lt;CTxOut&gt; vout;//交易输出 CTxWitness wit; // Not const: can change without invalidating the txid cache 可以更改 const uint32_t nLockTime; /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction&amp; operator=(const CTransaction&amp; tx); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { SerializeTransaction(*this, s, ser_action, nType, nVersion); if (ser_action.ForRead()) { UpdateHash(); } } bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts.返回交易输出金额之和 CAmount GetValueOut() const; // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. // Compute priority, given priority of inputs and (optionally) tx size 计算优先级 double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const; // Compute modified tx size for priority calculation (optionally given tx size) 为优先级的估算计算修改的交易大小 unsigned int CalculateModifiedSize(unsigned int nTxSize=0) const; bool IsCoinBase() const//判断是否CoinBase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; void UpdateHash() const; }; 还定义了class CTxWitness以及struct CMutableTransaction，CMutableTransaction是* A mutable version of CTransaction.*,其变量内容都可以修改，最后广播和网络中传输的类型都是CTransaction. 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81624052 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿(比特币区块链)。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 首先来看src/primitives/transaction.h 参考https://blog.csdn.net/pure_lady/article/details/77771392 COutPoint CTxIn CTxOut CTransaction 画了类图，大概的来看下这几个类的关系 COutPoint 字段尺寸 描述 数据类型 说明 32 hash uint256 交易的哈希 4 n uint32_t 指定tx输出的索引，第一笔输出的索引是0，以此类推 /** An outpoint - a combination of a transaction hash and an index n into its vout */ /* COutPoint主要用于在交易的输入CTxIn中，用来确定当前输出的来源， *包括前一笔交易的hash,以及对应前一笔交易中的第几个输出的序列号*/ class COutPoint { public: uint256 hash; //交易的哈希 uint32_t n; //对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } /*在类的主体中添加ADD_SERIALIZE_METHODS，可以使包装器作为成员，有三种方法，具体内容查看定义*/ ADD_SERIALIZE_METHODS; //用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载符号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; CTxIn 字段尺寸 描述 数据类型 说明 36 prevout COutPoint 对前一输出的引用，即需要出示那个账单的txid,也就是说，你花费的任何一笔钱都应该有人转给你过 ？ scriptSig CScript 用于确认交易授权的计算脚本，对这笔交易的签名 4 nSequence uint32_t 发送者定义的交易版本，用于在交易被写入block之前更改交易 ？ scriptWitness CScriptWitness 隔离见证脚本 explicit避免够高函数的参数自动转换为类对象的标识符，explicit关键字只对有一个参数的类构造函数有效，如果类的构造函数参数大于或等于2个时，是不会发生隐式转换的，explicit关键字也就无效了，存在一个例外，当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效参考https://www.cnblogs.com/ymy124/p/3632634.html /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ /*交易的输入,包含当前输入对应的前一笔交易输出的位置，以及花费前一笔输出需要的签名脚本*/ class CTxIn { public: COutPoint prevout; //前一笔交易输出的位置 CScript scriptSig; //解锁脚本 uint32_t nSequence; //序列号 /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ //如果一笔交易中的所有输入的nSequence都被设置为SEQUENCE_FINAL，那么禁用nLockTime static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ //这个标志应用于bip68的上下文中如果设置了这个变量，nSequence设置就与lock-time无关 static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ //如果nSequence与lock-time相关并且设置了这个变量，那么相关的锁定时间就为512秒， //或者1个区块的时间。 static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ //如果nSequence与lock-time相关，那么这个变量就用来从序列字段中提取锁定时间 static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ //这里是为了保证等长的数据位 static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } //禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS;//序列化 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; CTxOut 字段尺寸 描述 数据类型 说明 8 nValue CAmount(int64_t) 交易的比特币数量，单位聪（0.00000001） ？ scriptPubKey CScript 锁定脚本，一般为对方的公钥，有一系列与交易相关的信息和操作组成 /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ //交易的输出，包含金额和锁定脚本 class CTxOut { public: CAmount nValue;//输出金额 CScript scriptPubKey;//锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; //内联方式提供见证数据（脚本） template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } uint256 GetHash() const; //获取dust阈值，一笔交易如果交易费大于dust阈值，就会被认为是dust tx CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /*&quot;Dust&quot;是从CTransaction::minRelayTxFee来定义的，单位是satoshis/千字节， *如果在一笔交易中交易费占了1/3以上，那么我们认为该交易是&quot;Dust&quot;交易。 *一个典型的可花费的非隔离见证的txout是34字节大小，CTxIn至少需要148字节， *因此dust交易的可花费支出少于546*minRelayTxFee/1000聪 *典型的隔离见证中dust交易的可花费支出少于294*minRelayTxFee/1000*/ if (scriptPubKey.IsUnspendable())//判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; //判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 关于隔离见证，参考了《精通比特币》附录四 隔离见证 在引入“隔离见证”之前，每一个交易输入后面都跟着用来对其解锁的见证数据， 见证数据作为输入的一部分被内嵌其中。术语“隔离见证”( segregated witness)， 或简称为“segwit”，简单理解就是将某个特定输出的签名分离开，或将某个特定输 入的脚本进行解锁。用最简单的形式来理解就是“分离解锁脚本”(separate scriptSig)，或“分离签名”(separate signature) 因此，隔离见证就是比特币的一种结构性调整，旨在将见证数据部分从一笔交易 的 scriptSig(解锁脚本)字段移出至一个伴随交易的单独的见证数据结构。客户 端请求交易数据时可以选择要或不要该部分伴随的见证数据。 CTransaction 字段尺寸 描述 数据类型 说明 4 nVersion int32_t 交易数据格式版本 41+ vin std::vector&lt;CTxIn&gt; 交易的输入 9+ vout std::vector&lt;CTxOut&gt; 交易的输出 4 nLockTime uint32_t nLockTime应该理解为锁定交易的期限或者block数目，若该交易的所有输入CTxIn的nSequence字段为uint32_t的最大值（0xffffffff），则忽略该字段的逻辑检查。 当nSequence&lt;0xffffffff,且nLockTime==0，该交易可以立即被打包 当nSequence&lt;0xffffffff,且nLockTime！=0时： // Threshold for nLockTime: below this value it is interpreted as block number, // otherwise as UNIX timestamp. static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov 5 00:53:20 1985 UTC 若nLockTime&lt;500000000,则nLockTime代表区块数，该交易只能被打包进高度大于等于nLockTime的区块； 若nLockTime&gt;500000000，则nLockTime代表unix时间戳，该交易只能等到当前时间大于等于nLockTime才能被打包进区块 /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. *在网络中被广播并打包进区块的基本交易。一个交易可以包含多个输入和输出 */ class CTransaction { private: /** Memory only. */ const uint256 hash; public: // Default transaction version.默认交易版本 static const int32_t CURRENT_VERSION=1; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /*本地变量被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值， *但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容*/ const int32_t nVersion;//版本 const std::vector&lt;CTxIn&gt; vin;//交易输入 const std::vector&lt;CTxOut&gt; vout;//交易输出 CTxWitness wit; // Not const: can change without invalidating the txid cache 可以更改 const uint32_t nLockTime; /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction&amp; operator=(const CTransaction&amp; tx); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { SerializeTransaction(*this, s, ser_action, nType, nVersion); if (ser_action.ForRead()) { UpdateHash(); } } bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts.返回交易输出金额之和 CAmount GetValueOut() const; // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. // Compute priority, given priority of inputs and (optionally) tx size 计算优先级 double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const; // Compute modified tx size for priority calculation (optionally given tx size) 为优先级的估算计算修改的交易大小 unsigned int CalculateModifiedSize(unsigned int nTxSize=0) const; bool IsCoinBase() const//判断是否CoinBase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; void UpdateHash() const; }; 还定义了class CTxWitness以及struct CMutableTransaction，CMutableTransaction是* A mutable version of CTransaction.*,其变量内容都可以修改，最后广播和网络中传输的类型都是CTransaction. 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/08/15/22c4853c1477b715b3d6ec9c913c4fd8.html" />
<meta property="og:url" content="https://mlh.app/2018/08/15/22c4853c1477b715b3d6ec9c913c4fd8.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81624052 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿(比特币区块链)。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 首先来看src/primitives/transaction.h 参考https://blog.csdn.net/pure_lady/article/details/77771392 COutPoint CTxIn CTxOut CTransaction 画了类图，大概的来看下这几个类的关系 COutPoint 字段尺寸 描述 数据类型 说明 32 hash uint256 交易的哈希 4 n uint32_t 指定tx输出的索引，第一笔输出的索引是0，以此类推 /** An outpoint - a combination of a transaction hash and an index n into its vout */ /* COutPoint主要用于在交易的输入CTxIn中，用来确定当前输出的来源， *包括前一笔交易的hash,以及对应前一笔交易中的第几个输出的序列号*/ class COutPoint { public: uint256 hash; //交易的哈希 uint32_t n; //对应的序列号 COutPoint() { SetNull(); } COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; } /*在类的主体中添加ADD_SERIALIZE_METHODS，可以使包装器作为成员，有三种方法，具体内容查看定义*/ ADD_SERIALIZE_METHODS; //用来序列化数据结构，方便存储和传输 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(hash); READWRITE(n); } void SetNull() { hash.SetNull(); n = (uint32_t) -1; } bool IsNull() const { return (hash.IsNull() &amp;&amp; n == (uint32_t) -1); } //重载符号 friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b) { int cmp = a.hash.Compare(b.hash); return cmp &lt; 0 || (cmp == 0 &amp;&amp; a.n &lt; b.n); } friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b) { return (a.hash == b.hash &amp;&amp; a.n == b.n); } friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b) { return !(a == b); } std::string ToString() const; }; CTxIn 字段尺寸 描述 数据类型 说明 36 prevout COutPoint 对前一输出的引用，即需要出示那个账单的txid,也就是说，你花费的任何一笔钱都应该有人转给你过 ？ scriptSig CScript 用于确认交易授权的计算脚本，对这笔交易的签名 4 nSequence uint32_t 发送者定义的交易版本，用于在交易被写入block之前更改交易 ？ scriptWitness CScriptWitness 隔离见证脚本 explicit避免够高函数的参数自动转换为类对象的标识符，explicit关键字只对有一个参数的类构造函数有效，如果类的构造函数参数大于或等于2个时，是不会发生隐式转换的，explicit关键字也就无效了，存在一个例外，当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效参考https://www.cnblogs.com/ymy124/p/3632634.html /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ /*交易的输入,包含当前输入对应的前一笔交易输出的位置，以及花费前一笔输出需要的签名脚本*/ class CTxIn { public: COutPoint prevout; //前一笔交易输出的位置 CScript scriptSig; //解锁脚本 uint32_t nSequence; //序列号 /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ //如果一笔交易中的所有输入的nSequence都被设置为SEQUENCE_FINAL，那么禁用nLockTime static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ //这个标志应用于bip68的上下文中如果设置了这个变量，nSequence设置就与lock-time无关 static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ //如果nSequence与lock-time相关并且设置了这个变量，那么相关的锁定时间就为512秒， //或者1个区块的时间。 static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ //如果nSequence与lock-time相关，那么这个变量就用来从序列字段中提取锁定时间 static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ //这里是为了保证等长的数据位 static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } //禁用隐式转换，构造函数必须明确使用当前形式 explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS;//序列化 template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(prevout); READWRITE(*(CScriptBase*)(&amp;scriptSig)); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; CTxOut 字段尺寸 描述 数据类型 说明 8 nValue CAmount(int64_t) 交易的比特币数量，单位聪（0.00000001） ？ scriptPubKey CScript 锁定脚本，一般为对方的公钥，有一系列与交易相关的信息和操作组成 /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ //交易的输出，包含金额和锁定脚本 class CTxOut { public: CAmount nValue;//输出金额 CScript scriptPubKey;//锁定脚本 CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; //内联方式提供见证数据（脚本） template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(nValue); READWRITE(*(CScriptBase*)(&amp;scriptPubKey)); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } uint256 GetHash() const; //获取dust阈值，一笔交易如果交易费大于dust阈值，就会被认为是dust tx CAmount GetDustThreshold(const CFeeRate &amp;minRelayTxFee) const { // &quot;Dust&quot; is defined in terms of CTransaction::minRelayTxFee, // which has units satoshis-per-kilobyte. // If you&#39;d pay more than 1/3 in fees // to spend something, then we consider it dust. // A typical spendable non-segwit txout is 34 bytes big, and will // need a CTxIn of at least 148 bytes to spend: // so dust is a spendable txout less than // 546*minRelayTxFee/1000 (in satoshis). // A typical spendable segwit txout is 31 bytes big, and will // need a CTxIn of at least 67 bytes to spend: // so dust is a spendable txout less than // 294*minRelayTxFee/1000 (in satoshis). /*&quot;Dust&quot;是从CTransaction::minRelayTxFee来定义的，单位是satoshis/千字节， *如果在一笔交易中交易费占了1/3以上，那么我们认为该交易是&quot;Dust&quot;交易。 *一个典型的可花费的非隔离见证的txout是34字节大小，CTxIn至少需要148字节， *因此dust交易的可花费支出少于546*minRelayTxFee/1000聪 *典型的隔离见证中dust交易的可花费支出少于294*minRelayTxFee/1000*/ if (scriptPubKey.IsUnspendable())//判断脚本格式是否正确 return 0; size_t nSize = GetSerializeSize(SER_DISK, 0); int witnessversion = 0; std::vector&lt;unsigned char&gt; witnessprogram; //判断是否支持隔离见证 if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) { // sum the sizes of the parts of a transaction input // with 75% segwit discount applied to the script size. nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4); } else { nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above } return 3 * minRelayTxFee.GetFee(nSize); } bool IsDust(const CFeeRate &amp;minRelayTxFee) const { return (nValue &lt; GetDustThreshold(minRelayTxFee)); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 关于隔离见证，参考了《精通比特币》附录四 隔离见证 在引入“隔离见证”之前，每一个交易输入后面都跟着用来对其解锁的见证数据， 见证数据作为输入的一部分被内嵌其中。术语“隔离见证”( segregated witness)， 或简称为“segwit”，简单理解就是将某个特定输出的签名分离开，或将某个特定输 入的脚本进行解锁。用最简单的形式来理解就是“分离解锁脚本”(separate scriptSig)，或“分离签名”(separate signature) 因此，隔离见证就是比特币的一种结构性调整，旨在将见证数据部分从一笔交易 的 scriptSig(解锁脚本)字段移出至一个伴随交易的单独的见证数据结构。客户 端请求交易数据时可以选择要或不要该部分伴随的见证数据。 CTransaction 字段尺寸 描述 数据类型 说明 4 nVersion int32_t 交易数据格式版本 41+ vin std::vector&lt;CTxIn&gt; 交易的输入 9+ vout std::vector&lt;CTxOut&gt; 交易的输出 4 nLockTime uint32_t nLockTime应该理解为锁定交易的期限或者block数目，若该交易的所有输入CTxIn的nSequence字段为uint32_t的最大值（0xffffffff），则忽略该字段的逻辑检查。 当nSequence&lt;0xffffffff,且nLockTime==0，该交易可以立即被打包 当nSequence&lt;0xffffffff,且nLockTime！=0时： // Threshold for nLockTime: below this value it is interpreted as block number, // otherwise as UNIX timestamp. static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov 5 00:53:20 1985 UTC 若nLockTime&lt;500000000,则nLockTime代表区块数，该交易只能被打包进高度大于等于nLockTime的区块； 若nLockTime&gt;500000000，则nLockTime代表unix时间戳，该交易只能等到当前时间大于等于nLockTime才能被打包进区块 /** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. *在网络中被广播并打包进区块的基本交易。一个交易可以包含多个输入和输出 */ class CTransaction { private: /** Memory only. */ const uint256 hash; public: // Default transaction version.默认交易版本 static const int32_t CURRENT_VERSION=1; // Changing the default transaction version requires a two step process: first // adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date // bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and // MAX_STANDARD_VERSION will be equal. static const int32_t MAX_STANDARD_VERSION=2; // The local variables are made const to prevent unintended modification // without updating the cached hash value. However, CTransaction is not // actually immutable; deserialization and assignment are implemented, // and bypass the constness. This is safe, as they update the entire // structure, including the hash. /*本地变量被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值， *但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容*/ const int32_t nVersion;//版本 const std::vector&lt;CTxIn&gt; vin;//交易输入 const std::vector&lt;CTxOut&gt; vout;//交易输出 CTxWitness wit; // Not const: can change without invalidating the txid cache 可以更改 const uint32_t nLockTime; /** Construct a CTransaction that qualifies as IsNull() */ CTransaction(); /** Convert a CMutableTransaction into a CTransaction. */ CTransaction(const CMutableTransaction &amp;tx); CTransaction&amp; operator=(const CTransaction&amp; tx); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { SerializeTransaction(*this, s, ser_action, nType, nVersion); if (ser_action.ForRead()) { UpdateHash(); } } bool IsNull() const { return vin.empty() &amp;&amp; vout.empty(); } const uint256&amp; GetHash() const { return hash; } // Compute a hash that includes both transaction and witness data uint256 GetWitnessHash() const; // Return sum of txouts.返回交易输出金额之和 CAmount GetValueOut() const; // GetValueIn() is a method on CCoinsViewCache, because // inputs must be known to compute value in. // Compute priority, given priority of inputs and (optionally) tx size 计算优先级 double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const; // Compute modified tx size for priority calculation (optionally given tx size) 为优先级的估算计算修改的交易大小 unsigned int CalculateModifiedSize(unsigned int nTxSize=0) const; bool IsCoinBase() const//判断是否CoinBase交易 { return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull()); } friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash == b.hash; } friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b) { return a.hash != b.hash; } std::string ToString() const; void UpdateHash() const; }; 还定义了class CTxWitness以及struct CMutableTransaction，CMutableTransaction是* A mutable version of CTransaction.*,其变量内容都可以修改，最后广播和网络中传输的类型都是CTransaction. 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/08/15/22c4853c1477b715b3d6ec9c913c4fd8.html","headline":"比特币源码学习0.13-数据结构-交易","dateModified":"2018-08-15T00:00:00+08:00","datePublished":"2018-08-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/15/22c4853c1477b715b3d6ec9c913c4fd8.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13-数据结构-交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81624052 
 </div> 
 <div class="markdown_views"> 
  <p>比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿(比特币区块链)。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 <br> 首先来看src/primitives/transaction.h <br> 参考<a href="https://blog.csdn.net/pure_lady/article/details/77771392" rel="nofollow">https://blog.csdn.net/pure_lady/article/details/77771392</a></p> 
  <hr> 
  <p></p>
  <div class="toc"> 
   <ul> 
    <li><a href="#coutpoint" rel="nofollow">COutPoint</a></li> 
    <li><a href="#ctxin" rel="nofollow">CTxIn</a></li> 
    <li><a href="#ctxout" rel="nofollow">CTxOut</a></li> 
    <li><a href="#ctransaction" rel="nofollow">CTransaction</a></li> 
   </ul> 
  </div> 
  <p></p> 
  <hr> 
  <p>画了类图，大概的来看下这几个类的关系 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829144830895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h1 id="coutpoint">COutPoint</h1> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="center">描述</th> 
     <th align="right">数据类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>32</td> 
     <td align="center">hash</td> 
     <td align="right">uint256</td> 
     <td>交易的哈希</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">n</td> 
     <td align="right">uint32_t</td> 
     <td>指定tx输出的索引，第一笔输出的索引是0，以此类推</td> 
    </tr> 
   </tbody>
  </table> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/** An outpoint - a combination of a transaction hash and an index n into its vout */</span>
<span class="hljs-comment">/* COutPoint主要用于在交易的输入CTxIn中，用来确定当前输出的来源， *包括前一笔交易的hash,以及对应前一笔交易中的第几个输出的序列号*/</span>
<span class="hljs-keyword">class</span> COutPoint
{
<span class="hljs-keyword">public</span>:
    uint256 hash;  <span class="hljs-comment">//交易的哈希</span>
    uint32_t n;    <span class="hljs-comment">//对应的序列号</span>

    COutPoint() { SetNull(); }
    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }
<span class="hljs-comment">/*在类的主体中添加ADD_SERIALIZE_METHODS，可以使包装器作为成员，有三种方法，具体内容查看定义*/</span>
    ADD_SERIALIZE_METHODS;  <span class="hljs-comment">//用来序列化数据结构，方便存储和传输</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action, <span class="hljs-keyword">int</span> nType, <span class="hljs-keyword">int</span> nVersion) {
        READWRITE(hash);
        READWRITE(n);
    }

    <span class="hljs-keyword">void</span> SetNull() { hash.SetNull(); n = (uint32_t) -<span class="hljs-number">1</span>; }
    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> (hash.IsNull() &amp;&amp; n == (uint32_t) -<span class="hljs-number">1</span>); }
<span class="hljs-comment">//重载符号</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">int</span> cmp = a.hash.Compare(b.hash);
        <span class="hljs-keyword">return</span> cmp &lt; <span class="hljs-number">0</span> || (cmp == <span class="hljs-number">0</span> &amp;&amp; a.n &lt; b.n);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.hash == b.hash &amp;&amp; a.n == b.n);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> COutPoint&amp; a, <span class="hljs-keyword">const</span> COutPoint&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <h1 id="ctxin">CTxIn</h1> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="center">描述</th> 
     <th align="right">数据类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>36</td> 
     <td align="center">prevout</td> 
     <td align="right">COutPoint</td> 
     <td>对前一输出的引用，即需要出示那个账单的txid,也就是说，你花费的任何一笔钱都应该有人转给你过</td> 
    </tr> 
    <tr> 
     <td>？</td> 
     <td align="center">scriptSig</td> 
     <td align="right">CScript</td> 
     <td>用于确认交易授权的计算脚本，对这笔交易的签名</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">nSequence</td> 
     <td align="right">uint32_t</td> 
     <td>发送者定义的交易版本，用于在交易被写入block之前更改交易</td> 
    </tr> 
    <tr> 
     <td>？</td> 
     <td align="center">scriptWitness</td> 
     <td align="right">CScriptWitness</td> 
     <td>隔离见证脚本</td> 
    </tr> 
   </tbody>
  </table> 
  <p><code>explicit</code>避免够高函数的参数自动转换为类对象的标识符，explicit关键字只对有一个参数的类构造函数有效，如果类的构造函数参数大于或等于2个时，是不会发生隐式转换的，explicit关键字也就无效了，存在一个例外，当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效参考<a href="https://www.cnblogs.com/ymy124/p/3632634.html" rel="nofollow">https://www.cnblogs.com/ymy124/p/3632634.html</a></p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/** An input of a transaction. It contains the location of the previous * transaction's output that it claims and a signature that matches the * output's public key. */</span>
<span class="hljs-comment">/*交易的输入,包含当前输入对应的前一笔交易输出的位置，以及花费前一笔输出需要的签名脚本*/</span>
<span class="hljs-keyword">class</span> CTxIn
{
<span class="hljs-keyword">public</span>:
    COutPoint prevout; <span class="hljs-comment">//前一笔交易输出的位置</span>
    CScript scriptSig; <span class="hljs-comment">//解锁脚本</span>
    uint32_t nSequence; <span class="hljs-comment">//序列号</span>

    <span class="hljs-comment">/* Setting nSequence to this value for every input in a transaction * disables nLockTime. */</span>
    <span class="hljs-comment">//如果一笔交易中的所有输入的nSequence都被设置为SEQUENCE_FINAL，那么禁用nLockTime</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_FINAL = <span class="hljs-number">0xffffffff</span>;

    <span class="hljs-comment">/* Below flags apply in the context of BIP 68*/</span>
    <span class="hljs-comment">/* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */</span>
    <span class="hljs-comment">//这个标志应用于bip68的上下文中如果设置了这个变量，nSequence设置就与lock-time无关</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);

    <span class="hljs-comment">/* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */</span>
   <span class="hljs-comment">//如果nSequence与lock-time相关并且设置了这个变量，那么相关的锁定时间就为512秒，</span>
   <span class="hljs-comment">//或者1个区块的时间。</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">22</span>);

    <span class="hljs-comment">/* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */</span>
    <span class="hljs-comment">//如果nSequence与lock-time相关，那么这个变量就用来从序列字段中提取锁定时间</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint32_t SEQUENCE_LOCKTIME_MASK = <span class="hljs-number">0x0000ffff</span>;

    <span class="hljs-comment">/* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */</span>
     <span class="hljs-comment">//这里是为了保证等长的数据位</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SEQUENCE_LOCKTIME_GRANULARITY = <span class="hljs-number">9</span>;

    CTxIn()
    {
        nSequence = SEQUENCE_FINAL;
    }
<span class="hljs-comment">//禁用隐式转换，构造函数必须明确使用当前形式</span>
    <span class="hljs-keyword">explicit</span> CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);
    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);

    ADD_SERIALIZE_METHODS;<span class="hljs-comment">//序列化</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action, <span class="hljs-keyword">int</span> nType, <span class="hljs-keyword">int</span> nVersion) {
        READWRITE(prevout);
        READWRITE(*(CScriptBase*)(&amp;scriptSig));
        READWRITE(nSequence);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTxIn&amp; a, <span class="hljs-keyword">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.prevout   == b.prevout &amp;&amp;
                a.scriptSig == b.scriptSig &amp;&amp;
                a.nSequence == b.nSequence);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTxIn&amp; a, <span class="hljs-keyword">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <h1 id="ctxout">CTxOut</h1> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="center">描述</th> 
     <th align="right">数据类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>8</td> 
     <td align="center">nValue</td> 
     <td align="right">CAmount(int64_t)</td> 
     <td>交易的比特币数量，单位聪（0.00000001）</td> 
    </tr> 
    <tr> 
     <td>？</td> 
     <td align="center">scriptPubKey</td> 
     <td align="right">CScript</td> 
     <td>锁定脚本，一般为对方的公钥，有一系列与交易相关的信息和操作组成</td> 
    </tr> 
   </tbody>
  </table> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */</span>
 <span class="hljs-comment">//交易的输出，包含金额和锁定脚本</span>
<span class="hljs-keyword">class</span> CTxOut
{
<span class="hljs-keyword">public</span>:
    CAmount nValue;<span class="hljs-comment">//输出金额</span>
    CScript scriptPubKey;<span class="hljs-comment">//锁定脚本</span>

    CTxOut()
    {
        SetNull();
    }

    CTxOut(<span class="hljs-keyword">const</span> CAmount&amp; nValueIn, CScript scriptPubKeyIn);

    ADD_SERIALIZE_METHODS;
<span class="hljs-comment">//内联方式提供见证数据（脚本）</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action, <span class="hljs-keyword">int</span> nType, <span class="hljs-keyword">int</span> nVersion) {
        READWRITE(nValue);
        READWRITE(*(CScriptBase*)(&amp;scriptPubKey));
    }

    <span class="hljs-keyword">void</span> SetNull()
    {
        nValue = -<span class="hljs-number">1</span>;
        scriptPubKey.clear();
    }

    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (nValue == -<span class="hljs-number">1</span>);
    }

    uint256 GetHash() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">//获取dust阈值，一笔交易如果交易费大于dust阈值，就会被认为是dust tx</span>
    CAmount GetDustThreshold(<span class="hljs-keyword">const</span> CFeeRate &amp;minRelayTxFee) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-comment">// "Dust" is defined in terms of CTransaction::minRelayTxFee,</span>
        <span class="hljs-comment">// which has units satoshis-per-kilobyte.</span>
        <span class="hljs-comment">// If you'd pay more than 1/3 in fees</span>
        <span class="hljs-comment">// to spend something, then we consider it dust.</span>
        <span class="hljs-comment">// A typical spendable non-segwit txout is 34 bytes big, and will</span>
        <span class="hljs-comment">// need a CTxIn of at least 148 bytes to spend:</span>
        <span class="hljs-comment">// so dust is a spendable txout less than</span>
        <span class="hljs-comment">// 546*minRelayTxFee/1000 (in satoshis).</span>
        <span class="hljs-comment">// A typical spendable segwit txout is 31 bytes big, and will</span>
        <span class="hljs-comment">// need a CTxIn of at least 67 bytes to spend:</span>
        <span class="hljs-comment">// so dust is a spendable txout less than</span>
        <span class="hljs-comment">// 294*minRelayTxFee/1000 (in satoshis).</span>
        <span class="hljs-comment">/*"Dust"是从CTransaction::minRelayTxFee来定义的，单位是satoshis/千字节， *如果在一笔交易中交易费占了1/3以上，那么我们认为该交易是"Dust"交易。 *一个典型的可花费的非隔离见证的txout是34字节大小，CTxIn至少需要148字节， *因此dust交易的可花费支出少于546*minRelayTxFee/1000聪 *典型的隔离见证中dust交易的可花费支出少于294*minRelayTxFee/1000*/</span>
        <span class="hljs-keyword">if</span> (scriptPubKey.IsUnspendable())<span class="hljs-comment">//判断脚本格式是否正确</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        size_t nSize = GetSerializeSize(SER_DISK, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> witnessversion = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> witnessprogram;
<span class="hljs-comment">//判断是否支持隔离见证</span>
        <span class="hljs-keyword">if</span> (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {
            <span class="hljs-comment">// sum the sizes of the parts of a transaction input</span>
            <span class="hljs-comment">// with 75% segwit discount applied to the script size.</span>
            nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + (<span class="hljs-number">107</span> / WITNESS_SCALE_FACTOR) + <span class="hljs-number">4</span>);
        } <span class="hljs-keyword">else</span> {
            nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + <span class="hljs-number">107</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// the 148 mentioned above</span>
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * minRelayTxFee.GetFee(nSize);
    }

    <span class="hljs-keyword">bool</span> IsDust(<span class="hljs-keyword">const</span> CFeeRate &amp;minRelayTxFee) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (nValue &lt; GetDustThreshold(minRelayTxFee));
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.nValue       == b.nValue &amp;&amp;
                a.scriptPubKey == b.scriptPubKey);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <p>关于隔离见证，参考了《精通比特币》附录四 隔离见证</p> 
  <blockquote> 
   <p>在引入“隔离见证”之前，每一个交易输入后面都跟着用来对其解锁的见证数据， 见证数据作为输入的一部分被内嵌其中。术语“隔离见证”( segregated witness)， 或简称为“segwit”，简单理解就是将某个特定输出的签名分离开，或将某个特定输 入的脚本进行解锁。用最简单的形式来理解就是“分离解锁脚本”(separate scriptSig)，或“分离签名”(separate signature) <br> 因此，隔离见证就是比特币的一种结构性调整，旨在将见证数据部分从一笔交易 的 scriptSig(解锁脚本)字段移出至一个伴随交易的单独的见证数据结构。客户 端请求交易数据时可以选择要或不要该部分伴随的见证数据。</p> 
  </blockquote> 
  <h1 id="ctransaction">CTransaction</h1> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="center">描述</th> 
     <th align="right">数据类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>4</td> 
     <td align="center">nVersion</td> 
     <td align="right">int32_t</td> 
     <td>交易数据格式版本</td> 
    </tr> 
    <tr> 
     <td>41+</td> 
     <td align="center">vin</td> 
     <td align="right">std::vector<code>&lt;CTxIn&gt;</code></td> 
     <td>交易的输入</td> 
    </tr> 
    <tr> 
     <td>9+</td> 
     <td align="center">vout</td> 
     <td align="right">std::vector<code>&lt;CTxOut&gt;</code></td> 
     <td>交易的输出</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">nLockTime</td> 
     <td align="right">uint32_t</td> 
     <td></td> 
    </tr> 
   </tbody>
  </table> 
  <p>nLockTime应该理解为锁定交易的期限或者block数目，若该交易的所有输入CTxIn的nSequence字段为uint32_t的最大值（0xffffffff），则忽略该字段的逻辑检查。 <br> 当nSequence&lt;0xffffffff,且nLockTime==0，该交易可以立即被打包 <br> 当nSequence&lt;0xffffffff,且nLockTime！=0时：</p> 
  <blockquote> 
   <p>// Threshold for nLockTime: below this value it is interpreted as block number, <br> // otherwise as UNIX timestamp. <br> static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov 5 00:53:20 1985 UTC</p> 
  </blockquote> 
  <p>若nLockTime&lt;500000000,则nLockTime代表区块数，该交易只能被打包进高度大于等于nLockTime的区块； <br> 若nLockTime&gt;500000000，则nLockTime代表unix时间戳，该交易只能等到当前时间大于等于nLockTime才能被打包进区块</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/** The basic transaction that is broadcasted on the network and contained in * blocks. A transaction can contain multiple inputs and outputs. *在网络中被广播并打包进区块的基本交易。一个交易可以包含多个输入和输出 */</span>
<span class="hljs-keyword">class</span> CTransaction
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">/** Memory only. */</span>
    <span class="hljs-keyword">const</span> uint256 hash;

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Default transaction version.默认交易版本</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> int32_t CURRENT_VERSION=<span class="hljs-number">1</span>;

    <span class="hljs-comment">// Changing the default transaction version requires a two step process: first</span>
    <span class="hljs-comment">// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date</span>
    <span class="hljs-comment">// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and</span>
    <span class="hljs-comment">// MAX_STANDARD_VERSION will be equal.</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> int32_t MAX_STANDARD_VERSION=<span class="hljs-number">2</span>;

    <span class="hljs-comment">// The local variables are made const to prevent unintended modification</span>
    <span class="hljs-comment">// without updating the cached hash value. However, CTransaction is not</span>
    <span class="hljs-comment">// actually immutable; deserialization and assignment are implemented,</span>
    <span class="hljs-comment">// and bypass the constness. This is safe, as they update the entire</span>
    <span class="hljs-comment">// structure, including the hash.</span>
    <span class="hljs-comment">/*本地变量被定义为常量类型，从而避免无意识的修改了交易而没有更新缓存的hash值， *但还是可以通过重新构造一个交易然后赋值给当前交易来进行修改，这样就更新了交易的所有内容*/</span>
    <span class="hljs-keyword">const</span> int32_t nVersion;<span class="hljs-comment">//版本</span>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CTxIn&gt;</span> vin;<span class="hljs-comment">//交易输入</span>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CTxOut&gt;</span> vout;<span class="hljs-comment">//交易输出</span>
    CTxWitness wit; <span class="hljs-comment">// Not const: can change without invalidating the txid cache 可以更改</span>
    <span class="hljs-keyword">const</span> uint32_t nLockTime;

    <span class="hljs-comment">/** Construct a CTransaction that qualifies as IsNull() */</span>
    CTransaction();

    <span class="hljs-comment">/** Convert a CMutableTransaction into a CTransaction. */</span>
    CTransaction(<span class="hljs-keyword">const</span> CMutableTransaction &amp;tx);

    CTransaction&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CTransaction&amp; tx);

    ADD_SERIALIZE_METHODS;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action, <span class="hljs-keyword">int</span> nType, <span class="hljs-keyword">int</span> nVersion) {
        SerializeTransaction(*<span class="hljs-keyword">this</span>, s, ser_action, nType, nVersion);
        <span class="hljs-keyword">if</span> (ser_action.ForRead()) {
            UpdateHash();
        }
    }

    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> vin.empty() &amp;&amp; vout.empty();
    }

    <span class="hljs-keyword">const</span> uint256&amp; GetHash() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> hash;
    }

    <span class="hljs-comment">// Compute a hash that includes both transaction and witness data</span>
    uint256 GetWitnessHash() <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// Return sum of txouts.返回交易输出金额之和</span>
    CAmount GetValueOut() <span class="hljs-keyword">const</span>;
    <span class="hljs-comment">// GetValueIn() is a method on CCoinsViewCache, because</span>
    <span class="hljs-comment">// inputs must be known to compute value in.</span>

    <span class="hljs-comment">// Compute priority, given priority of inputs and (optionally) tx size 计算优先级</span>
    <span class="hljs-keyword">double</span> ComputePriority(<span class="hljs-keyword">double</span> dPriorityInputs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nTxSize=<span class="hljs-number">0</span>) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// Compute modified tx size for priority calculation (optionally given tx size) 为优先级的估算计算修改的交易大小</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> CalculateModifiedSize(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nTxSize=<span class="hljs-number">0</span>) <span class="hljs-keyword">const</span>;

    <span class="hljs-keyword">bool</span> IsCoinBase() <span class="hljs-keyword">const</span><span class="hljs-comment">//判断是否CoinBase交易</span>
    {
        <span class="hljs-keyword">return</span> (vin.size() == <span class="hljs-number">1</span> &amp;&amp; vin[<span class="hljs-number">0</span>].prevout.IsNull());
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTransaction&amp; a, <span class="hljs-keyword">const</span> CTransaction&amp; b)
    {
        <span class="hljs-keyword">return</span> a.hash == b.hash;
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTransaction&amp; a, <span class="hljs-keyword">const</span> CTransaction&amp; b)
    {
        <span class="hljs-keyword">return</span> a.hash != b.hash;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;

    <span class="hljs-keyword">void</span> UpdateHash() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <p>还定义了<code>class CTxWitness</code>以及<code>struct CMutableTransaction</code>，<code>CMutableTransaction</code>是<em>* A mutable version of CTransaction.*</em>,其变量内容都可以修改，最后广播和网络中传输的类型都是<code>CTransaction</code>.</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81624052,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81624052,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81624052,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81624052,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
