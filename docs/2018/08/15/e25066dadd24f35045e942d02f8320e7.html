<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS添加多索引表table到智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS添加多索引表table到智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在本教程中，我们将在你的智能合约中按步骤创建和使用多索引表。 建多索引表是一种为了在RAM快速访问的方法，主要用来来缓存状态和数据。多索引表支持创建、读取、更新和删除(CRUD) 业务，区块链不行（它只支持创建和读取）。 多索引表提供了快速访问数据存储接口，是一种存储智能合同中使用的数据的实用的方法。在区块链记录交易信息，你应该使用多索引表存储应用程序数据。 使用多索引表，因为他们支持为使用的数据建立多个索引，主索引必须是uint64_t类型和唯一的，但其他的索引，可以有重复的，你可以使用多达16个，类型可以是uint64_t, uint128_t, uint256_t, double or long double。 如果你想你需要使用一个字符串做索引，需要转换成一个整数型，将结果存储在随后索引的字段中。 1.创建一个结构 创建一个可以存储在多索引表中的结构，并在要索引的字段上定义getter。 请记住，这些getter中必须有一个命名为primary_key()，如果没有这个，编译器eosiocpp将产生一个错误…”it can’t find the field to use as the primary key”即它找不到任何一个字段被作为主键。 如果你想要有一个以上的索引，（最多允许16个），然后为你想要索引的任何字段定义一个getter，这时这个名称就不那么重要了，因为你会把getter名称传递给typedef。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; std::string name; std::string account; uint64_t primary_key() const { return key; } // getter for primary key uint64_t by_id() const {return secondid; } // getter for additional key }; 这里还要注意两件事： 1.注释： /// @abi table 编译器需要使用eosiocpp来识别要通过ABI公开该表并使其在智能合约之外可见。 2.结构名称少于12个字符，而且所有的字符都要小写字母。 2.多索引表和定义索引 定义多索引表将使用mystruct，告诉它要索引什么，以及如何获取正在索引的数据。主键将自动创建的，所以使用struct后，如果我想要一个只有一个主键的多索引表，我可以定义它为： typedef eosio::multi_index&lt;N(mystruct), mystruct&gt; datastore; 这定义了多个索引通过表名N(mystruct)和结构名mystruct。N(mystruct)会对结构名编译转换到uint64_t，使用uint64_t来标识属于多索引表的数据。 若要添加附加索引或辅助索引，则使用indexed_by模板作为参数，因此定义变为: typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;&gt; datastore; 注意： indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt; 参数: 字段的名称转换为整数，N(secondid) 一个用户定义的密钥调用接口，const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt; 来看看有三个索引的情况。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; uint64_t anotherid; std::string name; std::string account; uint64_t primary_key() const { return key; } uint64_t by_id() const {return secondid; } uint64_t by_anotherid() const {return anotherid; } }; typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;, indexed_by&lt;N(anotherid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_anotherid&gt;&gt;&gt; datastore; 更多的就不列了。 这里要注意的一个重要事项是，结构名与表名的匹配，并且将出现在ABI文件中的名称遵循规则（12个字符，所有都是小写的字母）。如果它们没有遵循这个规则，则表不会通过ABI可见（当然可以通过编辑ABI文件来绕过这一点）。 3.创建定义类型的局部变量 // local instances of the multi indexes pollstable _polls; votes _votes; 现在我已经定义了一个带有两个索引的多索引表，我可以在我的智能合约中使用它。 如下是一个智能合约使用两个索引的多索引表的例子。在这里你可以看到如何遍历表，如何在同一合约中使用两个表，我们未来将增加额外的教程，利用多索引表。 #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class youvote : public contract { public: youvote(account_name s):contract(s), _polls(s, s), _votes(s, s) {} // public methods exposed via the ABI // on pollsTable /// @abi action void version() { print(&quot;YouVote version 0.01&quot;); }; /// @abi action void addpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Add poll &quot;, pollName); // update the table to include a new poll _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = _polls.available_primary_key(); p.pollName = pollName; p.pollStatus = 0; p.option = &quot;&quot;; p.count = 0; }); }; /// @abi action void rmpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Remove poll &quot;, pollName); std::vector&lt;uint64_t&gt; keysForDeletion; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.erase(itr); } } // add remove votes ... don&#39;t need it the actions are permanently stored on the block chain std::vector&lt;uint64_t&gt; keysForDeletionFromVotes; // find items which are for the named poll for(auto&amp; item : _votes) { if (item.pollName == pollName) { keysForDeletionFromVotes.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletionFromVotes) { print(&quot;remove from _votes &quot;, key); auto itr = _votes.find(key); if (itr != _votes.end()) { _votes.erase(itr); } } }; /// @abi action void status(std::string pollName) { print(&quot;Change poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // now get each item and modify the status for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = p.pollStatus + 1; }); } } }; /// @abi action void statusreset(std::string pollName) { print(&quot;Reset poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find all poll items for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // update the status in each poll item for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = 0; }); } } }; /// @abi action void addpollopt(std::string pollName, std::string option) { print(&quot;Add poll option &quot;, pollName, &quot;option &quot;, option); // find the pollId, from _polls, use this to update the _polls with a new option for(auto&amp; item : _polls) { if (item.pollName == pollName) { // can only add if the poll is not started or finished if(item.pollStatus == 0) { _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = item.pollId; p.pollName = item.pollName; p.pollStatus = 0; p.option = option; p.count = 0; }); } else { print(&quot;Can not add poll option &quot;, pollName, &quot;option &quot;, option, &quot; Poll has started or is finished.&quot;); } break; // so you only add it once } } }; /// @abi action void rmpollopt(std::string pollName, std::string option) { print(&quot;Remove poll option &quot;, pollName, &quot;option &quot;, option); std::vector&lt;uint64_t&gt; keysForDeletion; // find and remove the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { if (itr-&gt;option == option) { _polls.erase(itr); } } } }; /// @abi action void vote(std::string pollName, std::string option, std::string accountName) { print(&quot;vote for &quot;, option, &quot; in poll &quot;, pollName, &quot; by &quot;, accountName); // is the poll open for(auto&amp; item : _polls) { if (item.pollName == pollName) { if (item.pollStatus != 1) { print(&quot;Poll &quot;,pollName, &quot; is not open&quot;); return; } break; // only need to check status once } } // has account name already voted? for(auto&amp; vote : _votes) { if (vote.pollName == pollName &amp;&amp; vote.account == accountName) { print(accountName, &quot; has already voted in poll &quot;, pollName); //eosio_assert(true, &quot;Already Voted&quot;); return; } } uint64_t pollId =99999; // get the pollId for the _votes table // find the poll and the option and increment the count for(auto&amp; item : _polls) { if (item.pollName == pollName &amp;&amp; item.option == option) { pollId = item.pollId; // for recording vote in this poll _polls.modify(item, get_self(), [&amp;](auto&amp; p) { p.count = p.count + 1; }); } } // record that accountName has voted _votes.emplace(get_self(), [&amp;](auto&amp; pv) { pv.key = _votes.available_primary_key(); pv.pollId = pollId; pv.pollName = pollName; pv.account = accountName; }); }; private: // create the multi index tables to store the data /// @abi table struct poll { uint64_t key; // primary key uint64_t pollId; // second key, non-unique, this table will have dup rows for each poll because of option std::string pollName; // name of poll uint8_t pollStatus =0; // staus where 0 = closed, 1 = open, 2 = finished std::string option; // the item you can vote for uint32_t count =0; // the number of votes for each itme -- this to be pulled out to separte table. uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(poll), poll, indexed_by&lt;N(pollId), const_mem_fun&lt;poll, uint64_t, &amp;poll::by_pollId&gt;&gt;&gt; pollstable; /// @abi table struct pollvotes { uint64_t key; uint64_t pollId; std::string pollName; // name of poll std::string account; //this account has voted, use this to make sure noone votes &gt; 1 uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(pollvotes), pollvotes, indexed_by&lt;N(pollId), const_mem_fun&lt;pollvotes, uint64_t, &amp;pollvotes::by_pollId&gt;&gt;&gt; votes; // local instances of the multi indexes pollstable _polls; votes _votes; }; EOSIO_ABI( youvote, (version)(addpoll)(rmpoll)(status)(statusreset)(addpollopt)(rmpollopt)(vote)) 注意EOSIO_ABI调用，它通过ABI公开函数，重要的是函数名与ABI函数名规则一定要匹配。 ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<meta property="og:description" content="在本教程中，我们将在你的智能合约中按步骤创建和使用多索引表。 建多索引表是一种为了在RAM快速访问的方法，主要用来来缓存状态和数据。多索引表支持创建、读取、更新和删除(CRUD) 业务，区块链不行（它只支持创建和读取）。 多索引表提供了快速访问数据存储接口，是一种存储智能合同中使用的数据的实用的方法。在区块链记录交易信息，你应该使用多索引表存储应用程序数据。 使用多索引表，因为他们支持为使用的数据建立多个索引，主索引必须是uint64_t类型和唯一的，但其他的索引，可以有重复的，你可以使用多达16个，类型可以是uint64_t, uint128_t, uint256_t, double or long double。 如果你想你需要使用一个字符串做索引，需要转换成一个整数型，将结果存储在随后索引的字段中。 1.创建一个结构 创建一个可以存储在多索引表中的结构，并在要索引的字段上定义getter。 请记住，这些getter中必须有一个命名为primary_key()，如果没有这个，编译器eosiocpp将产生一个错误…”it can’t find the field to use as the primary key”即它找不到任何一个字段被作为主键。 如果你想要有一个以上的索引，（最多允许16个），然后为你想要索引的任何字段定义一个getter，这时这个名称就不那么重要了，因为你会把getter名称传递给typedef。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; std::string name; std::string account; uint64_t primary_key() const { return key; } // getter for primary key uint64_t by_id() const {return secondid; } // getter for additional key }; 这里还要注意两件事： 1.注释： /// @abi table 编译器需要使用eosiocpp来识别要通过ABI公开该表并使其在智能合约之外可见。 2.结构名称少于12个字符，而且所有的字符都要小写字母。 2.多索引表和定义索引 定义多索引表将使用mystruct，告诉它要索引什么，以及如何获取正在索引的数据。主键将自动创建的，所以使用struct后，如果我想要一个只有一个主键的多索引表，我可以定义它为： typedef eosio::multi_index&lt;N(mystruct), mystruct&gt; datastore; 这定义了多个索引通过表名N(mystruct)和结构名mystruct。N(mystruct)会对结构名编译转换到uint64_t，使用uint64_t来标识属于多索引表的数据。 若要添加附加索引或辅助索引，则使用indexed_by模板作为参数，因此定义变为: typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;&gt; datastore; 注意： indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt; 参数: 字段的名称转换为整数，N(secondid) 一个用户定义的密钥调用接口，const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt; 来看看有三个索引的情况。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; uint64_t anotherid; std::string name; std::string account; uint64_t primary_key() const { return key; } uint64_t by_id() const {return secondid; } uint64_t by_anotherid() const {return anotherid; } }; typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;, indexed_by&lt;N(anotherid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_anotherid&gt;&gt;&gt; datastore; 更多的就不列了。 这里要注意的一个重要事项是，结构名与表名的匹配，并且将出现在ABI文件中的名称遵循规则（12个字符，所有都是小写的字母）。如果它们没有遵循这个规则，则表不会通过ABI可见（当然可以通过编辑ABI文件来绕过这一点）。 3.创建定义类型的局部变量 // local instances of the multi indexes pollstable _polls; votes _votes; 现在我已经定义了一个带有两个索引的多索引表，我可以在我的智能合约中使用它。 如下是一个智能合约使用两个索引的多索引表的例子。在这里你可以看到如何遍历表，如何在同一合约中使用两个表，我们未来将增加额外的教程，利用多索引表。 #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class youvote : public contract { public: youvote(account_name s):contract(s), _polls(s, s), _votes(s, s) {} // public methods exposed via the ABI // on pollsTable /// @abi action void version() { print(&quot;YouVote version 0.01&quot;); }; /// @abi action void addpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Add poll &quot;, pollName); // update the table to include a new poll _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = _polls.available_primary_key(); p.pollName = pollName; p.pollStatus = 0; p.option = &quot;&quot;; p.count = 0; }); }; /// @abi action void rmpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Remove poll &quot;, pollName); std::vector&lt;uint64_t&gt; keysForDeletion; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.erase(itr); } } // add remove votes ... don&#39;t need it the actions are permanently stored on the block chain std::vector&lt;uint64_t&gt; keysForDeletionFromVotes; // find items which are for the named poll for(auto&amp; item : _votes) { if (item.pollName == pollName) { keysForDeletionFromVotes.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletionFromVotes) { print(&quot;remove from _votes &quot;, key); auto itr = _votes.find(key); if (itr != _votes.end()) { _votes.erase(itr); } } }; /// @abi action void status(std::string pollName) { print(&quot;Change poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // now get each item and modify the status for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = p.pollStatus + 1; }); } } }; /// @abi action void statusreset(std::string pollName) { print(&quot;Reset poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find all poll items for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // update the status in each poll item for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = 0; }); } } }; /// @abi action void addpollopt(std::string pollName, std::string option) { print(&quot;Add poll option &quot;, pollName, &quot;option &quot;, option); // find the pollId, from _polls, use this to update the _polls with a new option for(auto&amp; item : _polls) { if (item.pollName == pollName) { // can only add if the poll is not started or finished if(item.pollStatus == 0) { _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = item.pollId; p.pollName = item.pollName; p.pollStatus = 0; p.option = option; p.count = 0; }); } else { print(&quot;Can not add poll option &quot;, pollName, &quot;option &quot;, option, &quot; Poll has started or is finished.&quot;); } break; // so you only add it once } } }; /// @abi action void rmpollopt(std::string pollName, std::string option) { print(&quot;Remove poll option &quot;, pollName, &quot;option &quot;, option); std::vector&lt;uint64_t&gt; keysForDeletion; // find and remove the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { if (itr-&gt;option == option) { _polls.erase(itr); } } } }; /// @abi action void vote(std::string pollName, std::string option, std::string accountName) { print(&quot;vote for &quot;, option, &quot; in poll &quot;, pollName, &quot; by &quot;, accountName); // is the poll open for(auto&amp; item : _polls) { if (item.pollName == pollName) { if (item.pollStatus != 1) { print(&quot;Poll &quot;,pollName, &quot; is not open&quot;); return; } break; // only need to check status once } } // has account name already voted? for(auto&amp; vote : _votes) { if (vote.pollName == pollName &amp;&amp; vote.account == accountName) { print(accountName, &quot; has already voted in poll &quot;, pollName); //eosio_assert(true, &quot;Already Voted&quot;); return; } } uint64_t pollId =99999; // get the pollId for the _votes table // find the poll and the option and increment the count for(auto&amp; item : _polls) { if (item.pollName == pollName &amp;&amp; item.option == option) { pollId = item.pollId; // for recording vote in this poll _polls.modify(item, get_self(), [&amp;](auto&amp; p) { p.count = p.count + 1; }); } } // record that accountName has voted _votes.emplace(get_self(), [&amp;](auto&amp; pv) { pv.key = _votes.available_primary_key(); pv.pollId = pollId; pv.pollName = pollName; pv.account = accountName; }); }; private: // create the multi index tables to store the data /// @abi table struct poll { uint64_t key; // primary key uint64_t pollId; // second key, non-unique, this table will have dup rows for each poll because of option std::string pollName; // name of poll uint8_t pollStatus =0; // staus where 0 = closed, 1 = open, 2 = finished std::string option; // the item you can vote for uint32_t count =0; // the number of votes for each itme -- this to be pulled out to separte table. uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(poll), poll, indexed_by&lt;N(pollId), const_mem_fun&lt;poll, uint64_t, &amp;poll::by_pollId&gt;&gt;&gt; pollstable; /// @abi table struct pollvotes { uint64_t key; uint64_t pollId; std::string pollName; // name of poll std::string account; //this account has voted, use this to make sure noone votes &gt; 1 uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(pollvotes), pollvotes, indexed_by&lt;N(pollId), const_mem_fun&lt;pollvotes, uint64_t, &amp;pollvotes::by_pollId&gt;&gt;&gt; votes; // local instances of the multi indexes pollstable _polls; votes _votes; }; EOSIO_ABI( youvote, (version)(addpoll)(rmpoll)(status)(statusreset)(addpollopt)(rmpollopt)(vote)) 注意EOSIO_ABI调用，它通过ABI公开函数，重要的是函数名与ABI函数名规则一定要匹配。 ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在本教程中，我们将在你的智能合约中按步骤创建和使用多索引表。 建多索引表是一种为了在RAM快速访问的方法，主要用来来缓存状态和数据。多索引表支持创建、读取、更新和删除(CRUD) 业务，区块链不行（它只支持创建和读取）。 多索引表提供了快速访问数据存储接口，是一种存储智能合同中使用的数据的实用的方法。在区块链记录交易信息，你应该使用多索引表存储应用程序数据。 使用多索引表，因为他们支持为使用的数据建立多个索引，主索引必须是uint64_t类型和唯一的，但其他的索引，可以有重复的，你可以使用多达16个，类型可以是uint64_t, uint128_t, uint256_t, double or long double。 如果你想你需要使用一个字符串做索引，需要转换成一个整数型，将结果存储在随后索引的字段中。 1.创建一个结构 创建一个可以存储在多索引表中的结构，并在要索引的字段上定义getter。 请记住，这些getter中必须有一个命名为primary_key()，如果没有这个，编译器eosiocpp将产生一个错误…”it can’t find the field to use as the primary key”即它找不到任何一个字段被作为主键。 如果你想要有一个以上的索引，（最多允许16个），然后为你想要索引的任何字段定义一个getter，这时这个名称就不那么重要了，因为你会把getter名称传递给typedef。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; std::string name; std::string account; uint64_t primary_key() const { return key; } // getter for primary key uint64_t by_id() const {return secondid; } // getter for additional key }; 这里还要注意两件事： 1.注释： /// @abi table 编译器需要使用eosiocpp来识别要通过ABI公开该表并使其在智能合约之外可见。 2.结构名称少于12个字符，而且所有的字符都要小写字母。 2.多索引表和定义索引 定义多索引表将使用mystruct，告诉它要索引什么，以及如何获取正在索引的数据。主键将自动创建的，所以使用struct后，如果我想要一个只有一个主键的多索引表，我可以定义它为： typedef eosio::multi_index&lt;N(mystruct), mystruct&gt; datastore; 这定义了多个索引通过表名N(mystruct)和结构名mystruct。N(mystruct)会对结构名编译转换到uint64_t，使用uint64_t来标识属于多索引表的数据。 若要添加附加索引或辅助索引，则使用indexed_by模板作为参数，因此定义变为: typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;&gt; datastore; 注意： indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt; 参数: 字段的名称转换为整数，N(secondid) 一个用户定义的密钥调用接口，const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt; 来看看有三个索引的情况。 /// @abi table struct mystruct { uint64_t key; uint64_t secondid; uint64_t anotherid; std::string name; std::string account; uint64_t primary_key() const { return key; } uint64_t by_id() const {return secondid; } uint64_t by_anotherid() const {return anotherid; } }; typedef eosio::multi_index&lt;N(mystruct), mystruct, indexed_by&lt;N(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;&gt;, indexed_by&lt;N(anotherid), const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_anotherid&gt;&gt;&gt; datastore; 更多的就不列了。 这里要注意的一个重要事项是，结构名与表名的匹配，并且将出现在ABI文件中的名称遵循规则（12个字符，所有都是小写的字母）。如果它们没有遵循这个规则，则表不会通过ABI可见（当然可以通过编辑ABI文件来绕过这一点）。 3.创建定义类型的局部变量 // local instances of the multi indexes pollstable _polls; votes _votes; 现在我已经定义了一个带有两个索引的多索引表，我可以在我的智能合约中使用它。 如下是一个智能合约使用两个索引的多索引表的例子。在这里你可以看到如何遍历表，如何在同一合约中使用两个表，我们未来将增加额外的教程，利用多索引表。 #include &lt;eosiolib/eosio.hpp&gt; using namespace eosio; class youvote : public contract { public: youvote(account_name s):contract(s), _polls(s, s), _votes(s, s) {} // public methods exposed via the ABI // on pollsTable /// @abi action void version() { print(&quot;YouVote version 0.01&quot;); }; /// @abi action void addpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Add poll &quot;, pollName); // update the table to include a new poll _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = _polls.available_primary_key(); p.pollName = pollName; p.pollStatus = 0; p.option = &quot;&quot;; p.count = 0; }); }; /// @abi action void rmpoll(account_name s, std::string pollName) { //require_auth(s); print(&quot;Remove poll &quot;, pollName); std::vector&lt;uint64_t&gt; keysForDeletion; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.erase(itr); } } // add remove votes ... don&#39;t need it the actions are permanently stored on the block chain std::vector&lt;uint64_t&gt; keysForDeletionFromVotes; // find items which are for the named poll for(auto&amp; item : _votes) { if (item.pollName == pollName) { keysForDeletionFromVotes.push_back(item.key); } } // now delete each item for that poll for (uint64_t key : keysForDeletionFromVotes) { print(&quot;remove from _votes &quot;, key); auto itr = _votes.find(key); if (itr != _votes.end()) { _votes.erase(itr); } } }; /// @abi action void status(std::string pollName) { print(&quot;Change poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find items which are for the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // now get each item and modify the status for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = p.pollStatus + 1; }); } } }; /// @abi action void statusreset(std::string pollName) { print(&quot;Reset poll status &quot;, pollName); std::vector&lt;uint64_t&gt; keysForModify; // find all poll items for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForModify.push_back(item.key); } } // update the status in each poll item for (uint64_t key : keysForModify) { print(&quot;modify _polls status&quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { _polls.modify(itr, get_self(), [&amp;](auto&amp; p) { p.pollStatus = 0; }); } } }; /// @abi action void addpollopt(std::string pollName, std::string option) { print(&quot;Add poll option &quot;, pollName, &quot;option &quot;, option); // find the pollId, from _polls, use this to update the _polls with a new option for(auto&amp; item : _polls) { if (item.pollName == pollName) { // can only add if the poll is not started or finished if(item.pollStatus == 0) { _polls.emplace(get_self(), [&amp;](auto&amp; p) { p.key = _polls.available_primary_key(); p.pollId = item.pollId; p.pollName = item.pollName; p.pollStatus = 0; p.option = option; p.count = 0; }); } else { print(&quot;Can not add poll option &quot;, pollName, &quot;option &quot;, option, &quot; Poll has started or is finished.&quot;); } break; // so you only add it once } } }; /// @abi action void rmpollopt(std::string pollName, std::string option) { print(&quot;Remove poll option &quot;, pollName, &quot;option &quot;, option); std::vector&lt;uint64_t&gt; keysForDeletion; // find and remove the named poll for(auto&amp; item : _polls) { if (item.pollName == pollName) { keysForDeletion.push_back(item.key); } } for (uint64_t key : keysForDeletion) { print(&quot;remove from _polls &quot;, key); auto itr = _polls.find(key); if (itr != _polls.end()) { if (itr-&gt;option == option) { _polls.erase(itr); } } } }; /// @abi action void vote(std::string pollName, std::string option, std::string accountName) { print(&quot;vote for &quot;, option, &quot; in poll &quot;, pollName, &quot; by &quot;, accountName); // is the poll open for(auto&amp; item : _polls) { if (item.pollName == pollName) { if (item.pollStatus != 1) { print(&quot;Poll &quot;,pollName, &quot; is not open&quot;); return; } break; // only need to check status once } } // has account name already voted? for(auto&amp; vote : _votes) { if (vote.pollName == pollName &amp;&amp; vote.account == accountName) { print(accountName, &quot; has already voted in poll &quot;, pollName); //eosio_assert(true, &quot;Already Voted&quot;); return; } } uint64_t pollId =99999; // get the pollId for the _votes table // find the poll and the option and increment the count for(auto&amp; item : _polls) { if (item.pollName == pollName &amp;&amp; item.option == option) { pollId = item.pollId; // for recording vote in this poll _polls.modify(item, get_self(), [&amp;](auto&amp; p) { p.count = p.count + 1; }); } } // record that accountName has voted _votes.emplace(get_self(), [&amp;](auto&amp; pv) { pv.key = _votes.available_primary_key(); pv.pollId = pollId; pv.pollName = pollName; pv.account = accountName; }); }; private: // create the multi index tables to store the data /// @abi table struct poll { uint64_t key; // primary key uint64_t pollId; // second key, non-unique, this table will have dup rows for each poll because of option std::string pollName; // name of poll uint8_t pollStatus =0; // staus where 0 = closed, 1 = open, 2 = finished std::string option; // the item you can vote for uint32_t count =0; // the number of votes for each itme -- this to be pulled out to separte table. uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(poll), poll, indexed_by&lt;N(pollId), const_mem_fun&lt;poll, uint64_t, &amp;poll::by_pollId&gt;&gt;&gt; pollstable; /// @abi table struct pollvotes { uint64_t key; uint64_t pollId; std::string pollName; // name of poll std::string account; //this account has voted, use this to make sure noone votes &gt; 1 uint64_t primary_key() const { return key; } uint64_t by_pollId() const {return pollId; } }; typedef eosio::multi_index&lt;N(pollvotes), pollvotes, indexed_by&lt;N(pollId), const_mem_fun&lt;pollvotes, uint64_t, &amp;pollvotes::by_pollId&gt;&gt;&gt; votes; // local instances of the multi indexes pollstable _polls; votes _votes; }; EOSIO_ABI( youvote, (version)(addpoll)(rmpoll)(status)(statusreset)(addpollopt)(rmpollopt)(vote)) 注意EOSIO_ABI调用，它通过ABI公开函数，重要的是函数名与ABI函数名规则一定要匹配。 ====================================================================== 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多","@type":"BlogPosting","url":"/2018/08/15/e25066dadd24f35045e942d02f8320e7.html","headline":"EOS添加多索引表table到智能合约","dateModified":"2018-08-15T00:00:00+08:00","datePublished":"2018-08-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/15/e25066dadd24f35045e942d02f8320e7.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS添加多索引表table到智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>在本教程中，我们将在你的智能合约中按步骤创建和使用多索引表。</p> 
  <p>建多索引表是一种为了在RAM快速访问的方法，主要用来来缓存状态和数据。多索引表支持创建、读取、更新和删除(CRUD) 业务，区块链不行（它只支持创建和读取）。</p> 
  <p>多索引表提供了快速访问数据存储接口，是一种存储智能合同中使用的数据的实用的方法。在区块链记录交易信息，你应该使用多索引表存储应用程序数据。</p> 
  <p>使用多索引表，因为他们支持为使用的数据建立多个索引，主索引必须是uint64_t类型和唯一的，但其他的索引，可以有重复的，你可以使用多达16个，类型可以是<code>uint64_t, uint128_t, uint256_t, double or long double</code>。</p> 
  <p>如果你想你需要使用一个字符串做索引，需要转换成一个整数型，将结果存储在随后索引的字段中。</p> 
  <h3 id="1创建一个结构">1.创建一个结构</h3> 
  <p>创建一个可以存储在多索引表中的结构，并在要索引的字段上定义<code>getter</code>。</p> 
  <p>请记住，这些<code>getter</code>中必须有一个命名为<code>primary_key()</code>，如果没有这个，编译器<code>eosiocpp</code>将产生一个错误…”it can’t find the field to use as the primary key”即它找不到任何一个字段被作为主键。</p> 
  <p>如果你想要有一个以上的索引，（最多允许16个），然后为你想要索引的任何字段定义一个<code>getter</code>，这时这个名称就不那么重要了，因为你会把<code>getter</code>名称传递给<code>typedef</code>。</p> 
  <pre class="prettyprint"><code class=" hljs cpp">     <span class="hljs-comment">/// @abi table</span>
      <span class="hljs-keyword">struct</span> mystruct 
      {
         uint64_t     key; 
         uint64_t     secondid;
         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>  name; 
         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>  account; 

         uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> key; } <span class="hljs-comment">// getter for primary key</span>
         uint64_t by_id() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> secondid; } <span class="hljs-comment">// getter for additional key</span>
      };</code></pre> 
  <p>这里还要注意两件事：</p> 
  <p>1.注释：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> @abi table</span></code></pre> 
  <p>编译器需要使用<code>eosiocpp</code>来识别要通过ABI公开该表并使其在智能合约之外可见。</p> 
  <p>2.结构名称少于12个字符，而且所有的字符都要小写字母。</p> 
  <h3 id="2多索引表和定义索引">2.多索引表和定义索引</h3> 
  <p>定义多索引表将使用<code>mystruct</code>，告诉它要索引什么，以及如何获取正在索引的数据。主键将自动创建的，所以使用struct后，如果我想要一个只有一个主键的多索引表，我可以定义它为：</p> 
  <pre class="prettyprint"><code class=" hljs ruby">typedef <span class="hljs-symbol">eosio:</span><span class="hljs-symbol">:multi_index&lt;N</span>(mystruct), mystruct&gt; datastore;</code></pre> 
  <p>这定义了多个索引通过表名<code>N(mystruct)</code>和结构名<code>mystruct</code>。<code>N(mystruct)</code>会对结构名编译转换到<code>uint64_t</code>，使用<code>uint64_t</code>来标识属于多索引表的数据。</p> 
  <p>若要添加附加索引或辅助索引，则使用<code>indexed_by</code>模板作为参数，因此定义变为:</p> 
  <pre class="prettyprint"><code class=" hljs ruby">typedef <span class="hljs-symbol">eosio:</span><span class="hljs-symbol">:multi_index&lt;N</span>(mystruct), mystruct, indexed_by&lt;<span class="hljs-constant">N</span>(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;<span class="hljs-symbol">mystruct:</span><span class="hljs-symbol">:by_id&gt;&gt;&gt;</span> datastore;</code></pre> 
  <p>注意：</p> 
  <pre class="prettyprint"><code class=" hljs ruby">indexed_by&lt;<span class="hljs-constant">N</span>(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;<span class="hljs-symbol">mystruct:</span><span class="hljs-symbol">:by_id&gt;&gt;</span></code></pre> 
  <p>参数:</p> 
  <ul> 
   <li>字段的名称转换为整数，<code>N(secondid)</code></li> 
   <li>一个用户定义的密钥调用接口，<code>const_mem_fun&lt;mystruct, uint64_t, &amp;mystruct::by_id&gt;</code></li> 
  </ul> 
  <p>来看看有三个索引的情况。</p> 
  <pre class="prettyprint"><code class=" hljs ruby">/<span class="hljs-regexp">//</span> <span class="hljs-variable">@abi</span> table
      struct mystruct 
      {
         uint64_t     key; 
         uint64_t     secondid;
         uint64_t           anotherid;
         <span class="hljs-symbol">std:</span><span class="hljs-symbol">:string</span>  name; 
         <span class="hljs-symbol">std:</span><span class="hljs-symbol">:string</span>  account; 

         uint64_t primary_key() const { <span class="hljs-keyword">return</span> key; }
         uint64_t by_id() const {<span class="hljs-keyword">return</span> secondid; }
         uint64_t by_anotherid() const {<span class="hljs-keyword">return</span> anotherid; }
      };

typedef <span class="hljs-symbol">eosio:</span><span class="hljs-symbol">:multi_index&lt;N</span>(mystruct), mystruct, indexed_by&lt;<span class="hljs-constant">N</span>(secondid), const_mem_fun&lt;mystruct, uint64_t, &amp;<span class="hljs-symbol">mystruct:</span><span class="hljs-symbol">:by_id&gt;&gt;</span>, indexed_by&lt;<span class="hljs-constant">N</span>(anotherid), const_mem_fun&lt;mystruct, uint64_t, &amp;<span class="hljs-symbol">mystruct:</span><span class="hljs-symbol">:by_anotherid&gt;&gt;&gt;</span> datastore;</code></pre> 
  <p>更多的就不列了。</p> 
  <p>这里要注意的一个重要事项是，结构名与表名的匹配，并且将出现在ABI文件中的名称遵循规则（12个字符，所有都是小写的字母）。如果它们没有遵循这个规则，则表不会通过ABI可见（当然可以通过编辑ABI文件来绕过这一点）。</p> 
  <h3 id="3创建定义类型的局部变量">3.创建定义类型的局部变量</h3> 
  <pre class="prettyprint"><code class=" hljs erlang">   // local instances <span class="hljs-keyword">of</span> the multi indexes
      pollstable <span class="hljs-variable">_</span>polls;
      votes <span class="hljs-variable">_</span>votes;</code></pre> 
  <p>现在我已经定义了一个带有两个索引的多索引表，我可以在我的智能合约中使用它。</p> 
  <p>如下是一个智能合约使用两个索引的多索引表的例子。在这里你可以看到如何遍历表，如何在同一合约中使用两个表，我们未来将增加额外的教程，利用多索引表。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;eosiolib/eosio.hpp&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;

<span class="hljs-keyword">class</span> youvote : <span class="hljs-keyword">public</span> contract {
  <span class="hljs-keyword">public</span>:
      youvote(account_name s):contract(s), _polls(s, s), _votes(s, s)
      {}

      <span class="hljs-comment">// public methods exposed via the ABI</span>
      <span class="hljs-comment">// on pollsTable</span>

      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> version()
      {
          print(<span class="hljs-string">"YouVote version 0.01"</span>); 

      };

      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> addpoll(account_name s, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName)
      {
          <span class="hljs-comment">//require_auth(s);</span>

          print(<span class="hljs-string">"Add poll "</span>, pollName); 

          <span class="hljs-comment">// update the table to include a new poll</span>
          _polls.emplace(get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p)
                                      {
                                        p.key = _polls.available_primary_key();
                                        p.pollId = _polls.available_primary_key();
                                        p.pollName = pollName;
                                        p.pollStatus = <span class="hljs-number">0</span>;
                                        p.option = <span class="hljs-string">""</span>;
                                        p.count = <span class="hljs-number">0</span>;
                                      });
      };


      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> rmpoll(account_name s, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName)
      {
          <span class="hljs-comment">//require_auth(s);</span>

          print(<span class="hljs-string">"Remove poll "</span>, pollName); 

          <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForDeletion;
          <span class="hljs-comment">// find items which are for the named poll</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  keysForDeletion.push_back(item.key);   
              }
          }

          <span class="hljs-comment">// now delete each item for that poll</span>
          <span class="hljs-keyword">for</span> (uint64_t key : keysForDeletion)
          {
              print(<span class="hljs-string">"remove from _polls "</span>, key);
              <span class="hljs-keyword">auto</span> itr = _polls.find(key);
              <span class="hljs-keyword">if</span> (itr != _polls.end())
              {
                _polls.erase(itr);
              }
          }


          <span class="hljs-comment">// add remove votes ... don't need it the actions are permanently stored on the block chain</span>

          <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForDeletionFromVotes;
          <span class="hljs-comment">// find items which are for the named poll</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _votes)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  keysForDeletionFromVotes.push_back(item.key);   
              }
          }

          <span class="hljs-comment">// now delete each item for that poll</span>
          <span class="hljs-keyword">for</span> (uint64_t key : keysForDeletionFromVotes)
          {
              print(<span class="hljs-string">"remove from _votes "</span>, key);
              <span class="hljs-keyword">auto</span> itr = _votes.find(key);
              <span class="hljs-keyword">if</span> (itr != _votes.end())
              {
                _votes.erase(itr);
              }
          }


      };

      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> status(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName)
      {
          print(<span class="hljs-string">"Change poll status "</span>, pollName);

          <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForModify;
          <span class="hljs-comment">// find items which are for the named poll</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  keysForModify.push_back(item.key);   
              }
          }

          <span class="hljs-comment">// now get each item and modify the status</span>
          <span class="hljs-keyword">for</span> (uint64_t key : keysForModify)
          {

            print(<span class="hljs-string">"modify _polls status"</span>, key);
            <span class="hljs-keyword">auto</span> itr = _polls.find(key);
            <span class="hljs-keyword">if</span> (itr != _polls.end())
            {
              _polls.modify(itr, get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p)
                                              {
                                                p.pollStatus = p.pollStatus + <span class="hljs-number">1</span>;
                                              });
            }
          }
      };

      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> statusreset(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName)
      {
          print(<span class="hljs-string">"Reset poll status "</span>, pollName); 

          <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForModify;
          <span class="hljs-comment">// find all poll items</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  keysForModify.push_back(item.key);   
              }
          }

          <span class="hljs-comment">// update the status in each poll item</span>
          <span class="hljs-keyword">for</span> (uint64_t key : keysForModify)
          {
              print(<span class="hljs-string">"modify _polls status"</span>, key);
              <span class="hljs-keyword">auto</span> itr = _polls.find(key);
              <span class="hljs-keyword">if</span> (itr != _polls.end())
              {
                _polls.modify(itr, get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p)
                                                {
                                                  p.pollStatus = <span class="hljs-number">0</span>;
                                                });
              }
          }
      };


      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> addpollopt(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> option)
      {
          print(<span class="hljs-string">"Add poll option "</span>, pollName, <span class="hljs-string">"option "</span>, option); 

          <span class="hljs-comment">// find the pollId, from _polls, use this to update the _polls with a new option</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                    <span class="hljs-comment">// can only add if the poll is not started or finished</span>
                    <span class="hljs-keyword">if</span>(item.pollStatus == <span class="hljs-number">0</span>)
                    {
                        _polls.emplace(get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p)
                                          {
                                            p.key = _polls.available_primary_key();
                                            p.pollId = item.pollId;
                                            p.pollName = item.pollName;
                                            p.pollStatus = <span class="hljs-number">0</span>;
                                            p.option = option;
                                            p.count = <span class="hljs-number">0</span>;
                                          });
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        print(<span class="hljs-string">"Can not add poll option "</span>, pollName, <span class="hljs-string">"option "</span>, option, <span class="hljs-string">" Poll has started or is finished."</span>);
                    }

                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// so you only add it once</span>
              }
          }
      };

      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> rmpollopt(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> option)
      {
          print(<span class="hljs-string">"Remove poll option "</span>, pollName, <span class="hljs-string">"option "</span>, option); 

          <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint64_t&gt;</span> keysForDeletion;
          <span class="hljs-comment">// find and remove the named poll</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  keysForDeletion.push_back(item.key);   
              }
          }


          <span class="hljs-keyword">for</span> (uint64_t key : keysForDeletion)
          {
              print(<span class="hljs-string">"remove from _polls "</span>, key);
              <span class="hljs-keyword">auto</span> itr = _polls.find(key);
              <span class="hljs-keyword">if</span> (itr != _polls.end())
              {
                  <span class="hljs-keyword">if</span> (itr-&gt;option == option)
                  {
                      _polls.erase(itr);
                  }
              }
          }
      };


      <span class="hljs-comment">/// @abi action</span>
      <span class="hljs-keyword">void</span> vote(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pollName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> option, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> accountName)
      {
          print(<span class="hljs-string">"vote for "</span>, option, <span class="hljs-string">" in poll "</span>, pollName, <span class="hljs-string">" by "</span>, accountName); 

          <span class="hljs-comment">// is the poll open</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName)
              {
                  <span class="hljs-keyword">if</span> (item.pollStatus != <span class="hljs-number">1</span>)
                  {
                      print(<span class="hljs-string">"Poll "</span>,pollName,  <span class="hljs-string">" is not open"</span>);
                      <span class="hljs-keyword">return</span>;
                  }

                  <span class="hljs-keyword">break</span>; <span class="hljs-comment">// only need to check status once</span>
              }
          }

          <span class="hljs-comment">// has account name already voted? </span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; vote : _votes)
          {
              <span class="hljs-keyword">if</span> (vote.pollName == pollName &amp;&amp; vote.account == accountName)
              {
                  print(accountName, <span class="hljs-string">" has already voted in poll "</span>, pollName);
                  <span class="hljs-comment">//eosio_assert(true, "Already Voted");</span>
                  <span class="hljs-keyword">return</span>;
              }
          }

          uint64_t pollId =<span class="hljs-number">99999</span>; <span class="hljs-comment">// get the pollId for the _votes table</span>

          <span class="hljs-comment">// find the poll and the option and increment the count</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; item : _polls)
          {
              <span class="hljs-keyword">if</span> (item.pollName == pollName &amp;&amp; item.option == option)
              {
                  pollId = item.pollId; <span class="hljs-comment">// for recording vote in this poll</span>

                  _polls.modify(item, get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; p)
                                                {
                                                    p.count = p.count + <span class="hljs-number">1</span>;
                                                });
              }
          }

          <span class="hljs-comment">// record that accountName has voted</span>
          _votes.emplace(get_self(), [&amp;](<span class="hljs-keyword">auto</span>&amp; pv)
                                      {
                                        pv.key = _votes.available_primary_key();
                                        pv.pollId = pollId;
                                        pv.pollName = pollName;
                                        pv.account = accountName;
                                      });        
      };

  <span class="hljs-keyword">private</span>:    

    <span class="hljs-comment">// create the multi index tables to store the data</span>

      <span class="hljs-comment">/// @abi table</span>
      <span class="hljs-keyword">struct</span> poll 
      {
        uint64_t      key; <span class="hljs-comment">// primary key</span>
        uint64_t      pollId; <span class="hljs-comment">// second key, non-unique, this table will have dup rows for each poll because of option</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>   pollName; <span class="hljs-comment">// name of poll</span>
        uint8_t      pollStatus =<span class="hljs-number">0</span>; <span class="hljs-comment">// staus where 0 = closed, 1 = open, 2 = finished</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>  option; <span class="hljs-comment">// the item you can vote for</span>
        uint32_t    count =<span class="hljs-number">0</span>; <span class="hljs-comment">// the number of votes for each itme -- this to be pulled out to separte table.</span>

        uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> key; }
        uint64_t by_pollId() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> pollId; }
      };
      <span class="hljs-keyword">typedef</span> eosio::multi_index&lt;N(poll), poll, indexed_by&lt;N(pollId), const_mem_fun&lt;poll, uint64_t, &amp;poll::by_pollId&gt;&gt;&gt; pollstable;


      <span class="hljs-comment">/// @abi table</span>
      <span class="hljs-keyword">struct</span> pollvotes 
      {
         uint64_t     key; 
         uint64_t     pollId;
         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>  pollName; <span class="hljs-comment">// name of poll</span>
         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>  account; <span class="hljs-comment">//this account has voted, use this to make sure noone votes &gt; 1</span>

         uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> key; }
         uint64_t by_pollId() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> pollId; }
      };
      <span class="hljs-keyword">typedef</span> eosio::multi_index&lt;N(pollvotes), pollvotes, indexed_by&lt;N(pollId), const_mem_fun&lt;pollvotes, uint64_t, &amp;pollvotes::by_pollId&gt;&gt;&gt; votes;

      <span class="hljs-comment">// local instances of the multi indexes</span>
      pollstable _polls;
      votes _votes;
};

EOSIO_ABI( youvote, (version)(addpoll)(rmpoll)(status)(statusreset)(addpollopt)(rmpollopt)(vote))</code></pre> 
  <p>注意<code>EOSIO_ABI</code>调用，它通过ABI公开函数，重要的是<strong>函数名</strong>与<strong>ABI函数名</strong>规则一定要匹配。</p> 
  <p>======================================================================</p> 
  <p>分享一个交互式的在线编程实战，<strong>EOS智能合约与DApp开发入门</strong>：</p> 
  <p><a href="http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=815csdn" rel="nofollow">EOS教程</a></p> 
  <p>本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=815csdn" rel="nofollow">web3j教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=815csdn" rel="nofollow">以太坊教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=815csdn" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=815csdn" rel="nofollow">python以太坊</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=815csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=815csdn" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。</li> 
   </ul> 
  </blockquote> 
  <p>汇智网原创翻译，转载请标明出处。这里是<a href="http://blog.hubwiz.com/2018/08/12/EOS-multi-index-tables/" rel="nofollow">原文</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/81700229,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/81700229,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
