<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13-数据结构-交易池 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13-数据结构-交易池" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81699796 文章目录 #交易池 参考文章https://blog.csdn.net/pure_lady/article/details/77776716 交易池 引用来自《精通比特币》8.13交易池 比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池 或交易池。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所 包含的交易。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经 接收但还未被确认的、属于该用户钱包的预支付信息。 随着交易被接收和验证，它们被添加到交易池并通知到相邻节点处，从而传播到 网络中。 交易池主要介绍两个类CTxMemPoolEntry和CTxMemPool，都位于txmempool.h中 ##CTxMemPoolEntry 交易池中每一个元素（Entry）的基本结构 首先来看注释部分 /** \class CTxMemPoolEntry * * CTxMemPoolEntry stores data about the correponding transaction, as well * as data about all in-mempool transactions that depend on the transaction * (&quot;descendant&quot; transactions). * * When a new entry is added to the mempool, we update the descendant state * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for * all ancestors of the newly added transaction. * * If updating the descendant state is skipped, we can mark the entry as * &quot;dirty&quot;, and set nSizeWithDescendants/nModFeesWithDescendants to equal nTxSize/ * nFee+feeDelta. (This can potentially happen during a reorg, where we limit the * amount of work we&#39;re willing to do to avoid consuming too much CPU.) * */ CTxMemPoolEntry存储交易和该交易的所有后代交易，当一个新的交易添加到交易池，我们更新这个新交易的所有祖先和后代交易状态。如果跳过更新后代状态，我们可以标记这个为&quot;dirty&quot;,以及相应设置（这个可能会在我们避免消耗过多cpu的从组时发生） class CTxMemPoolEntry { private: std::shared_ptr&lt;const CTransaction&gt; tx;//交易引用 CAmount nFee;//交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight;// //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nModSize;//优先级修改后大小 //!&lt; ... and modified size for priority size_t nUsageSize; //交易大小 //!&lt; ... and total memory usage int64_t nTime;//时间戳，进入交易池 //!&lt; Local time when entering the mempool double entryPriority;//进入交易池的优先级 //!&lt; Priority when entering the mempool unsigned int entryHeight;//区块高度 //!&lt; Chain height when entering the mempool bool hadNoDependencies;//没有相关联的交易 //!&lt; Not dependent on any other txs when it entered the mempool CAmount inChainInputValue; //!&lt; Sum of all txin values that are already in blockchain bool spendsCoinbase;//前一个交易是否coinbase //!&lt; keep track of transactions that spend a coinbase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; //调整交易优先级 //!&lt; Used for determining the priority of the transaction for mining in a block LockPoints lockPoints;//交易最后所在区块高度和打包时间 //!&lt; Track the height and time at which tx was final // Information about descendants of this transaction that are in the // mempool; if we remove this transaction we must remove all of these // descendants as well. if nCountWithDescendants is 0, treat this entry as // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not be // correct. /*后代交易信息，如果移除一个交易，必须移除所有它的后代交易*/ uint64_t nCountWithDescendants;//后代交易的数量 //!&lt; number of descendant transactions uint64_t nSizeWithDescendants; //大小 //!&lt; ... and size CAmount nModFeesWithDescendants; // 所有费用包括当前交易//!&lt; ... and total fees (all including us) // Analogous statistics for ancestor transactions //祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransaction&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, double _entryPriority, unsigned int _entryHeight, bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); CTxMemPoolEntry(const CTxMemPoolEntry&amp; other); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } std::shared_ptr&lt;const CTransaction&gt; GetSharedTx() const { return this-&gt;tx; } /** * Fast calculation of lower bound of current priority as update * from entry priority. Only inputs that were originally in-chain will age. */ double GetPriority(unsigned int currentHeight) const; const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } bool WasClearAtEntry() const { return hadNoDependencies; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // Adjusts the descendant state, if this entry is not dirty.更新后代交易状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // Adjusts the ancestor state 更新祖先交易状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // Updates the fee delta used for mining priority score, and the // modified fees with descendants.更新fee delta以调整优先级，修正后代交易费用 void UpdateFeeDelta(int64_t feeDelta); // Update the LockPoints after a reorg 更新LockPoints void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; ##CTxMemPool 交易池的注释比较长 /** * CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. *CTxMemPool存储可能被打包进下一个区块的在当前最长链中有效的交易 * Transactions are added when they are seen on the network * (or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. *当交易在网络上被发现后会被添加进交易池（或者是本地节点产生的交易），但不是所有交易都可以，双花或非标准交易会被抛出 * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping: * mapTx是boost::multi_index类型，用来以4个标准排序池中的交易 * mapTx is a boost::multi_index that sorts the mempool on 4 criteria: * - transaction hash 交易哈希 * - feerate [we use max(feerate of tx, feerate of tx with all descendants)] 交易费用 * - time in mempool 时间 * - mining score (feerate modified by any fee deltas from PrioritiseTransaction) 挖矿分数 *我们说指的后代和祖先交易都是指存在这个池中的交易 * Note: the term &quot;descendant&quot; refers to in-mempool transactions that depend on * this one, while &quot;ancestor&quot; refers to in-mempool transactions that a given * transaction depends on. *为了保证交易排序的正确性，我们必须在新的后代交易到达后更新 * In order for the feerate sort to remain correct, we must update transactions * in the mempool when new descendants arrive. To facilitate this, we track * the set of in-mempool direct parents and direct children in mapLinks. Within * each CTxMemPoolEntry, we track the size and fees of all descendants. *为了达到这一目的，我们跟踪池内每个交易的直系祖先和后代交易。对每个CTxMemPoolEntry我们跟踪后代交易的大小和费用。 * Usually when a new transaction is added to the mempool, it has no in-mempool * children (because any such children would be an orphan). So in * addUnchecked(), we: * - update a new entry&#39;s setMemPoolParents to include all in-mempool parents * - update the new entry&#39;s direct parents to include the new tx as a child * - update all ancestors of the transaction to include the new tx&#39;s size/fee *通常一个新交易添加到池中是没有孩子（因为这些孩子通常是孤儿），所以在addUnchecked()： *我们更新一个新的元素的setMemPoolParents包含所有池内父交易，更新这个元素的直系父交易，把这个元素作为子交易，更新这个交易的所有祖先交易包含这个交易的大小和费用 * When a transaction is removed from the mempool, we must: * - update all in-mempool parents to not track the tx in setMemPoolChildren * - update all ancestors to not include the tx&#39;s size/fees in descendant state * - update all in-mempool children to not include it as a parent *当移除一个交易，需要三步 * These happen in UpdateForRemoveFromMempool(). (Note that when removing a * transaction along with its descendants, we must calculate that set of * transactions to be removed before doing the removal, or else the mempool can * be in an inconsistent state where it&#39;s impossible to walk the ancestors of * a transaction.) *这些通常发生在UpdateForRemoveFromMempool（） * In the event of a reorg, the assumption that a newly added tx has no * in-mempool children is false. In particular, the mempool is in an * inconsistent state while new transactions are being added, because there may * be descendant transactions of a tx coming from a disconnected block that are * unreachable from just looking at transactions in the mempool (the linking * transactions may also be in the disconnected block, waiting to be added). * Because of this, there&#39;s not much benefit in trying to search for in-mempool * children in addUnchecked(). Instead, in the special case of transactions * being added from a disconnected block, we require the caller to clean up the * state, to account for in-mempool, out-of-block descendants for all the * in-block transactions by calling UpdateTransactionsFromBlock(). Note that * until this is called, the mempool state is not consistent, and in particular * mapLinks may not be correct (and therefore functions like * CalculateMemPoolAncestors() and CalculateDescendants() that rely * on them to walk the mempool are not generally safe to use). *在重组的情况下，假设新添加的tx没有in-mempool子项是错误的。特别是，在添加新事务时，mempool处于不一致状态，因为可能存在来自断开块的tx的后代事务， *这些事务无法通过查看mempool中的事务而无法访问（链接事务也可能在断开连接的块，等待添加）。 * Computational limits: * * Updating all in-mempool ancestors of a newly added transaction can be slow, * if no bound exists on how many in-mempool ancestors there may be. * CalculateMemPoolAncestors() takes configurable limits that are designed to * prevent these calculations from being too CPU intensive. * * Adding transactions from a disconnected block can be very time consuming, * because we don&#39;t have a way to limit the number of in-mempool descendants. * To bound CPU processing, we limit the amount of work we&#39;re willing to do * to properly update the descendant information for a tx being added from * a disconnected block. If we would exceed the limit, then we instead mark * the entry as &quot;dirty&quot;, and set the feerate for sorting purposes to be equal * the feerate of the transaction without any descendants. *从断开连接的块添加事务可能非常耗时，因为我们没有办法限制in-mempool后代的数量。 *为了限制CPU处理，我们限制了我们愿意为正确更新从断开连接的块添加的tx的后代信息所做的工作量。 *如果我们超过限制，那么我们将条目标记为“脏”，并将排序目的的费用设置为等于没有任何后代的交易的费用。 */ 下面来看代码部分 class CTxMemPool { private: uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check.检查次数 unsigned int nTransactionsUpdated; CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有池中交易的大小，不包括见证数据!&lt; sum of all mempool tx&#39; byte sizes uint64_t cachedInnerUsage; //map中元素使用的动态内存之和!&lt; sum of dynamic memory usage of all the map elements (NOT the maps themselves) CFeeRate minReasonableRelayFee; mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool的最小费用!&lt; minimum fee to get into the pool, decreases exponentially void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid 根据交易hash排序 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate 根据费用排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore//根据后代交易分数 &gt;, // sorted by entry time 根据进入时间排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization) 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors 祖先交易的费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //!&lt; All tx witness hashes/entries in mapTx, in random order所有交易见证的哈希，无排序 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, std::pair&lt;double, CAmount&gt; &gt; mapDeltas; /** Create a new CTxMemPool.创建新的 CTxMemPool * minReasonableRelayFee should be a feerate which is, roughly, somewhere * around what it &quot;costs&quot; to relay a transaction around the network and * below which we would reasonably say a transaction has 0-effective-fee. */ //minReasonableRelayFee应该是一个大致在网络周围转发交易的“成本”左右的费用，我们可以合理地说，交易有0-有效费用。 CTxMemPool(const CFeeRate&amp; _minReasonableRelayFee); ~CTxMemPool(); /** * If sanity-checking is turned on, check makes sure the pool is * consistent (does not contain two transactions that spend the same inputs, * all inputs are in the mapNextTx array). If sanity-checking is turned off, * check does nothing. */ //如果启用了sanity-checking ，check会确保池的一致（不包含两个使用相同输入的事务，所有输入都在mapNextTx数组中）。 如果关闭完整性检查，则check不执行任何操作。 void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } // addUnchecked must updated state for all ancestors of a given transaction, // to track size/count of descendant transactions. First version of // addUnchecked can be used to have it call CalculateMemPoolAncestors(), and // then invoke the second version. //addUnchecked必须为给定交易的所有祖先更新状态，以跟踪后代交易的大小/数量。 addUnchecked的第一个版本可用于调用CalculateMemPoolAncestors（），然后调用第二个版本。 bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool fCurrentEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool fCurrentEstimate = true); void removeRecursive(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForBlock(const std::vector&lt;CTransaction&gt;&amp; vtx, unsigned int nBlockHeight, std::list&lt;CTransaction&gt;&amp; conflicts, bool fCurrentEstimate = true); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); void pruneSpent(const uint256&amp; hash, CCoins &amp;coins); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); //检查这些交易输入都不在mempool中，因此tx不依赖于要包含在块中的其他mempool事务。 bool HasNoInputsOf(const CTransaction&amp; tx) const; /** Affect CreateNewBlock prioritisation of transactions 调整CreateNewBlock时的交易的优先级*/ void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount&amp; nFeeDelta); void ApplyDeltas(const uint256 hash, double &amp;dPriorityDelta, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants); /** When adding transactions from a disconnected block back to the mempool, * new mempool entries may have children in the mempool (which is generally * not the case when otherwise adding transactions). * UpdateTransactionsFromBlock() will find child transactions and update the * descendant state for each transaction in hashesToUpdate (excluding any * child transactions present in hashesToUpdate, which are already accounted * for). Note: hashesToUpdate should be the set of transactions from the * disconnected block that have been accepted back into the mempool. */ //将竞争失败（断开连接）的块中更新信息到池中 void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;hashesToUpdate); /** Try to calculate all in-mempool ancestors of entry. * (these are all calculated including the tx itself) * limitAncestorCount = max number of ancestors 最大祖先数量 * limitAncestorSize = max size of ancestors 最大祖先交易的大小 * limitDescendantCount = max number of descendants any ancestor can have 任意祖先的最多后代数 * limitDescendantSize = max size of descendants any ancestor can have 任意祖先的最大后代交易大小 * errString = populated with error reason if any limits are hit 超过任何限制的错误提示 * fSearchForParents = whether to search a tx&#39;s vin for in-mempool parents, or是否从交易池中搜索交易的输入 * look up parents from mapLinks. Must be true for entries not in the mempool 或者从mapLinks查找，对于不在mempool的entries必须设置为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** The minimum fee to get into the mempool, which may itself not be enough * for larger-sized transactions. * The minReasonableRelayFee constructor arg is used to bound the time it * takes the fee rate to go back down all the way to 0. When the feerate * would otherwise be half of this, it is set to 0 instead. */ //进入mempool所需要的最小费用，minReasonableRelayFee用来限制费用降到0所需的时间 CFeeRate GetMinFee(size_t sizelimit) const; /** Remove transactions from the mempool until its dynamic size is &lt;= sizelimit. * pvNoSpendsRemaining, if set, will be populated with the list of transactions * which are not in mempool which no longer have any spends in this mempool. */ //移除动态大小超过sizelimit的交易，如果设置了pvNoSpendsRemaining，则将填充不在mempool中的事务列表，该事务列表在此mempool中不再有任何支出。 void TrimToSize(size_t sizelimit, std::vector&lt;uint256&gt;* pvNoSpendsRemaining=NULL); /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */ //终止所有超过时间的交易（和他们的依赖交易），返回移除的交易数 int Expire(int64_t time); /** Returns false if the transaction is in the mempool and not within the chain limit specified. */ //如果交易存在池中但不在链限制中返回false bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } std::shared_ptr&lt;const CTransaction&gt; get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; /** Estimate fee rate needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ CFeeRate estimateSmartFee(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate fee rate needed to get into the next nBlocks 计算进入下一个区块需要的费用*/ CFeeRate estimateFee(int nBlocks) const; /** Estimate priority needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ double estimateSmartPriority(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate priority needed to get into the next nBlocks 计算进入下一个区块需要的优先级*/ double estimatePriority(int nBlocks) const; /** Write/Read estimates to disk */ bool WriteFeeEstimates(CAutoFile&amp; fileout) const; bool ReadFeeEstimates(CAutoFile&amp; filein); size_t DynamicMemoryUsage() const; private: /** UpdateTransactionsFromBlock使用UpdateForDescendants来更新已添加到mempool的单个事务的后代， *但可能在mempool中有子交易，例如在链重组期间。 setExclude是mempool中的后代交易集，不能被考虑 *（因为setExclude中的任何后代在事务更新后被添加到mempool，因此它们的状态已经反映在父状态中）。 *cachedDescendants将使用正在更新的事务的后代进行更新，以便将来的调用不需要再次遍历同一事务（如果在另一个事务链中遇到）。 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** Set ancestor state for an entry 设置一个祖先*/ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** For each transaction being removed, update ancestors and any direct children.对每个要移除的交易，更新它的祖先和直系后代 * If updateDescendants is true, then also update in-mempool descendants&#39; * ancestor state. */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个给定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry); }; 看到这里还是挺不清楚的，看得再多点有想法了再来完善吧 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81699796 文章目录 #交易池 参考文章https://blog.csdn.net/pure_lady/article/details/77776716 交易池 引用来自《精通比特币》8.13交易池 比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池 或交易池。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所 包含的交易。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经 接收但还未被确认的、属于该用户钱包的预支付信息。 随着交易被接收和验证，它们被添加到交易池并通知到相邻节点处，从而传播到 网络中。 交易池主要介绍两个类CTxMemPoolEntry和CTxMemPool，都位于txmempool.h中 ##CTxMemPoolEntry 交易池中每一个元素（Entry）的基本结构 首先来看注释部分 /** \class CTxMemPoolEntry * * CTxMemPoolEntry stores data about the correponding transaction, as well * as data about all in-mempool transactions that depend on the transaction * (&quot;descendant&quot; transactions). * * When a new entry is added to the mempool, we update the descendant state * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for * all ancestors of the newly added transaction. * * If updating the descendant state is skipped, we can mark the entry as * &quot;dirty&quot;, and set nSizeWithDescendants/nModFeesWithDescendants to equal nTxSize/ * nFee+feeDelta. (This can potentially happen during a reorg, where we limit the * amount of work we&#39;re willing to do to avoid consuming too much CPU.) * */ CTxMemPoolEntry存储交易和该交易的所有后代交易，当一个新的交易添加到交易池，我们更新这个新交易的所有祖先和后代交易状态。如果跳过更新后代状态，我们可以标记这个为&quot;dirty&quot;,以及相应设置（这个可能会在我们避免消耗过多cpu的从组时发生） class CTxMemPoolEntry { private: std::shared_ptr&lt;const CTransaction&gt; tx;//交易引用 CAmount nFee;//交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight;// //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nModSize;//优先级修改后大小 //!&lt; ... and modified size for priority size_t nUsageSize; //交易大小 //!&lt; ... and total memory usage int64_t nTime;//时间戳，进入交易池 //!&lt; Local time when entering the mempool double entryPriority;//进入交易池的优先级 //!&lt; Priority when entering the mempool unsigned int entryHeight;//区块高度 //!&lt; Chain height when entering the mempool bool hadNoDependencies;//没有相关联的交易 //!&lt; Not dependent on any other txs when it entered the mempool CAmount inChainInputValue; //!&lt; Sum of all txin values that are already in blockchain bool spendsCoinbase;//前一个交易是否coinbase //!&lt; keep track of transactions that spend a coinbase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; //调整交易优先级 //!&lt; Used for determining the priority of the transaction for mining in a block LockPoints lockPoints;//交易最后所在区块高度和打包时间 //!&lt; Track the height and time at which tx was final // Information about descendants of this transaction that are in the // mempool; if we remove this transaction we must remove all of these // descendants as well. if nCountWithDescendants is 0, treat this entry as // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not be // correct. /*后代交易信息，如果移除一个交易，必须移除所有它的后代交易*/ uint64_t nCountWithDescendants;//后代交易的数量 //!&lt; number of descendant transactions uint64_t nSizeWithDescendants; //大小 //!&lt; ... and size CAmount nModFeesWithDescendants; // 所有费用包括当前交易//!&lt; ... and total fees (all including us) // Analogous statistics for ancestor transactions //祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransaction&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, double _entryPriority, unsigned int _entryHeight, bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); CTxMemPoolEntry(const CTxMemPoolEntry&amp; other); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } std::shared_ptr&lt;const CTransaction&gt; GetSharedTx() const { return this-&gt;tx; } /** * Fast calculation of lower bound of current priority as update * from entry priority. Only inputs that were originally in-chain will age. */ double GetPriority(unsigned int currentHeight) const; const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } bool WasClearAtEntry() const { return hadNoDependencies; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // Adjusts the descendant state, if this entry is not dirty.更新后代交易状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // Adjusts the ancestor state 更新祖先交易状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // Updates the fee delta used for mining priority score, and the // modified fees with descendants.更新fee delta以调整优先级，修正后代交易费用 void UpdateFeeDelta(int64_t feeDelta); // Update the LockPoints after a reorg 更新LockPoints void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; ##CTxMemPool 交易池的注释比较长 /** * CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. *CTxMemPool存储可能被打包进下一个区块的在当前最长链中有效的交易 * Transactions are added when they are seen on the network * (or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. *当交易在网络上被发现后会被添加进交易池（或者是本地节点产生的交易），但不是所有交易都可以，双花或非标准交易会被抛出 * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping: * mapTx是boost::multi_index类型，用来以4个标准排序池中的交易 * mapTx is a boost::multi_index that sorts the mempool on 4 criteria: * - transaction hash 交易哈希 * - feerate [we use max(feerate of tx, feerate of tx with all descendants)] 交易费用 * - time in mempool 时间 * - mining score (feerate modified by any fee deltas from PrioritiseTransaction) 挖矿分数 *我们说指的后代和祖先交易都是指存在这个池中的交易 * Note: the term &quot;descendant&quot; refers to in-mempool transactions that depend on * this one, while &quot;ancestor&quot; refers to in-mempool transactions that a given * transaction depends on. *为了保证交易排序的正确性，我们必须在新的后代交易到达后更新 * In order for the feerate sort to remain correct, we must update transactions * in the mempool when new descendants arrive. To facilitate this, we track * the set of in-mempool direct parents and direct children in mapLinks. Within * each CTxMemPoolEntry, we track the size and fees of all descendants. *为了达到这一目的，我们跟踪池内每个交易的直系祖先和后代交易。对每个CTxMemPoolEntry我们跟踪后代交易的大小和费用。 * Usually when a new transaction is added to the mempool, it has no in-mempool * children (because any such children would be an orphan). So in * addUnchecked(), we: * - update a new entry&#39;s setMemPoolParents to include all in-mempool parents * - update the new entry&#39;s direct parents to include the new tx as a child * - update all ancestors of the transaction to include the new tx&#39;s size/fee *通常一个新交易添加到池中是没有孩子（因为这些孩子通常是孤儿），所以在addUnchecked()： *我们更新一个新的元素的setMemPoolParents包含所有池内父交易，更新这个元素的直系父交易，把这个元素作为子交易，更新这个交易的所有祖先交易包含这个交易的大小和费用 * When a transaction is removed from the mempool, we must: * - update all in-mempool parents to not track the tx in setMemPoolChildren * - update all ancestors to not include the tx&#39;s size/fees in descendant state * - update all in-mempool children to not include it as a parent *当移除一个交易，需要三步 * These happen in UpdateForRemoveFromMempool(). (Note that when removing a * transaction along with its descendants, we must calculate that set of * transactions to be removed before doing the removal, or else the mempool can * be in an inconsistent state where it&#39;s impossible to walk the ancestors of * a transaction.) *这些通常发生在UpdateForRemoveFromMempool（） * In the event of a reorg, the assumption that a newly added tx has no * in-mempool children is false. In particular, the mempool is in an * inconsistent state while new transactions are being added, because there may * be descendant transactions of a tx coming from a disconnected block that are * unreachable from just looking at transactions in the mempool (the linking * transactions may also be in the disconnected block, waiting to be added). * Because of this, there&#39;s not much benefit in trying to search for in-mempool * children in addUnchecked(). Instead, in the special case of transactions * being added from a disconnected block, we require the caller to clean up the * state, to account for in-mempool, out-of-block descendants for all the * in-block transactions by calling UpdateTransactionsFromBlock(). Note that * until this is called, the mempool state is not consistent, and in particular * mapLinks may not be correct (and therefore functions like * CalculateMemPoolAncestors() and CalculateDescendants() that rely * on them to walk the mempool are not generally safe to use). *在重组的情况下，假设新添加的tx没有in-mempool子项是错误的。特别是，在添加新事务时，mempool处于不一致状态，因为可能存在来自断开块的tx的后代事务， *这些事务无法通过查看mempool中的事务而无法访问（链接事务也可能在断开连接的块，等待添加）。 * Computational limits: * * Updating all in-mempool ancestors of a newly added transaction can be slow, * if no bound exists on how many in-mempool ancestors there may be. * CalculateMemPoolAncestors() takes configurable limits that are designed to * prevent these calculations from being too CPU intensive. * * Adding transactions from a disconnected block can be very time consuming, * because we don&#39;t have a way to limit the number of in-mempool descendants. * To bound CPU processing, we limit the amount of work we&#39;re willing to do * to properly update the descendant information for a tx being added from * a disconnected block. If we would exceed the limit, then we instead mark * the entry as &quot;dirty&quot;, and set the feerate for sorting purposes to be equal * the feerate of the transaction without any descendants. *从断开连接的块添加事务可能非常耗时，因为我们没有办法限制in-mempool后代的数量。 *为了限制CPU处理，我们限制了我们愿意为正确更新从断开连接的块添加的tx的后代信息所做的工作量。 *如果我们超过限制，那么我们将条目标记为“脏”，并将排序目的的费用设置为等于没有任何后代的交易的费用。 */ 下面来看代码部分 class CTxMemPool { private: uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check.检查次数 unsigned int nTransactionsUpdated; CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有池中交易的大小，不包括见证数据!&lt; sum of all mempool tx&#39; byte sizes uint64_t cachedInnerUsage; //map中元素使用的动态内存之和!&lt; sum of dynamic memory usage of all the map elements (NOT the maps themselves) CFeeRate minReasonableRelayFee; mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool的最小费用!&lt; minimum fee to get into the pool, decreases exponentially void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid 根据交易hash排序 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate 根据费用排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore//根据后代交易分数 &gt;, // sorted by entry time 根据进入时间排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization) 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors 祖先交易的费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //!&lt; All tx witness hashes/entries in mapTx, in random order所有交易见证的哈希，无排序 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, std::pair&lt;double, CAmount&gt; &gt; mapDeltas; /** Create a new CTxMemPool.创建新的 CTxMemPool * minReasonableRelayFee should be a feerate which is, roughly, somewhere * around what it &quot;costs&quot; to relay a transaction around the network and * below which we would reasonably say a transaction has 0-effective-fee. */ //minReasonableRelayFee应该是一个大致在网络周围转发交易的“成本”左右的费用，我们可以合理地说，交易有0-有效费用。 CTxMemPool(const CFeeRate&amp; _minReasonableRelayFee); ~CTxMemPool(); /** * If sanity-checking is turned on, check makes sure the pool is * consistent (does not contain two transactions that spend the same inputs, * all inputs are in the mapNextTx array). If sanity-checking is turned off, * check does nothing. */ //如果启用了sanity-checking ，check会确保池的一致（不包含两个使用相同输入的事务，所有输入都在mapNextTx数组中）。 如果关闭完整性检查，则check不执行任何操作。 void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } // addUnchecked must updated state for all ancestors of a given transaction, // to track size/count of descendant transactions. First version of // addUnchecked can be used to have it call CalculateMemPoolAncestors(), and // then invoke the second version. //addUnchecked必须为给定交易的所有祖先更新状态，以跟踪后代交易的大小/数量。 addUnchecked的第一个版本可用于调用CalculateMemPoolAncestors（），然后调用第二个版本。 bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool fCurrentEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool fCurrentEstimate = true); void removeRecursive(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForBlock(const std::vector&lt;CTransaction&gt;&amp; vtx, unsigned int nBlockHeight, std::list&lt;CTransaction&gt;&amp; conflicts, bool fCurrentEstimate = true); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); void pruneSpent(const uint256&amp; hash, CCoins &amp;coins); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); //检查这些交易输入都不在mempool中，因此tx不依赖于要包含在块中的其他mempool事务。 bool HasNoInputsOf(const CTransaction&amp; tx) const; /** Affect CreateNewBlock prioritisation of transactions 调整CreateNewBlock时的交易的优先级*/ void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount&amp; nFeeDelta); void ApplyDeltas(const uint256 hash, double &amp;dPriorityDelta, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants); /** When adding transactions from a disconnected block back to the mempool, * new mempool entries may have children in the mempool (which is generally * not the case when otherwise adding transactions). * UpdateTransactionsFromBlock() will find child transactions and update the * descendant state for each transaction in hashesToUpdate (excluding any * child transactions present in hashesToUpdate, which are already accounted * for). Note: hashesToUpdate should be the set of transactions from the * disconnected block that have been accepted back into the mempool. */ //将竞争失败（断开连接）的块中更新信息到池中 void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;hashesToUpdate); /** Try to calculate all in-mempool ancestors of entry. * (these are all calculated including the tx itself) * limitAncestorCount = max number of ancestors 最大祖先数量 * limitAncestorSize = max size of ancestors 最大祖先交易的大小 * limitDescendantCount = max number of descendants any ancestor can have 任意祖先的最多后代数 * limitDescendantSize = max size of descendants any ancestor can have 任意祖先的最大后代交易大小 * errString = populated with error reason if any limits are hit 超过任何限制的错误提示 * fSearchForParents = whether to search a tx&#39;s vin for in-mempool parents, or是否从交易池中搜索交易的输入 * look up parents from mapLinks. Must be true for entries not in the mempool 或者从mapLinks查找，对于不在mempool的entries必须设置为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** The minimum fee to get into the mempool, which may itself not be enough * for larger-sized transactions. * The minReasonableRelayFee constructor arg is used to bound the time it * takes the fee rate to go back down all the way to 0. When the feerate * would otherwise be half of this, it is set to 0 instead. */ //进入mempool所需要的最小费用，minReasonableRelayFee用来限制费用降到0所需的时间 CFeeRate GetMinFee(size_t sizelimit) const; /** Remove transactions from the mempool until its dynamic size is &lt;= sizelimit. * pvNoSpendsRemaining, if set, will be populated with the list of transactions * which are not in mempool which no longer have any spends in this mempool. */ //移除动态大小超过sizelimit的交易，如果设置了pvNoSpendsRemaining，则将填充不在mempool中的事务列表，该事务列表在此mempool中不再有任何支出。 void TrimToSize(size_t sizelimit, std::vector&lt;uint256&gt;* pvNoSpendsRemaining=NULL); /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */ //终止所有超过时间的交易（和他们的依赖交易），返回移除的交易数 int Expire(int64_t time); /** Returns false if the transaction is in the mempool and not within the chain limit specified. */ //如果交易存在池中但不在链限制中返回false bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } std::shared_ptr&lt;const CTransaction&gt; get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; /** Estimate fee rate needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ CFeeRate estimateSmartFee(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate fee rate needed to get into the next nBlocks 计算进入下一个区块需要的费用*/ CFeeRate estimateFee(int nBlocks) const; /** Estimate priority needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ double estimateSmartPriority(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate priority needed to get into the next nBlocks 计算进入下一个区块需要的优先级*/ double estimatePriority(int nBlocks) const; /** Write/Read estimates to disk */ bool WriteFeeEstimates(CAutoFile&amp; fileout) const; bool ReadFeeEstimates(CAutoFile&amp; filein); size_t DynamicMemoryUsage() const; private: /** UpdateTransactionsFromBlock使用UpdateForDescendants来更新已添加到mempool的单个事务的后代， *但可能在mempool中有子交易，例如在链重组期间。 setExclude是mempool中的后代交易集，不能被考虑 *（因为setExclude中的任何后代在事务更新后被添加到mempool，因此它们的状态已经反映在父状态中）。 *cachedDescendants将使用正在更新的事务的后代进行更新，以便将来的调用不需要再次遍历同一事务（如果在另一个事务链中遇到）。 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** Set ancestor state for an entry 设置一个祖先*/ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** For each transaction being removed, update ancestors and any direct children.对每个要移除的交易，更新它的祖先和直系后代 * If updateDescendants is true, then also update in-mempool descendants&#39; * ancestor state. */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个给定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry); }; 看到这里还是挺不清楚的，看得再多点有想法了再来完善吧 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/15/423206331f97acb1d8406e4eec0bd2c8.html" />
<meta property="og:url" content="https://mlh.app/2018/08/15/423206331f97acb1d8406e4eec0bd2c8.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81699796 文章目录 #交易池 参考文章https://blog.csdn.net/pure_lady/article/details/77776716 交易池 引用来自《精通比特币》8.13交易池 比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池 或交易池。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所 包含的交易。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经 接收但还未被确认的、属于该用户钱包的预支付信息。 随着交易被接收和验证，它们被添加到交易池并通知到相邻节点处，从而传播到 网络中。 交易池主要介绍两个类CTxMemPoolEntry和CTxMemPool，都位于txmempool.h中 ##CTxMemPoolEntry 交易池中每一个元素（Entry）的基本结构 首先来看注释部分 /** \\class CTxMemPoolEntry * * CTxMemPoolEntry stores data about the correponding transaction, as well * as data about all in-mempool transactions that depend on the transaction * (&quot;descendant&quot; transactions). * * When a new entry is added to the mempool, we update the descendant state * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for * all ancestors of the newly added transaction. * * If updating the descendant state is skipped, we can mark the entry as * &quot;dirty&quot;, and set nSizeWithDescendants/nModFeesWithDescendants to equal nTxSize/ * nFee+feeDelta. (This can potentially happen during a reorg, where we limit the * amount of work we&#39;re willing to do to avoid consuming too much CPU.) * */ CTxMemPoolEntry存储交易和该交易的所有后代交易，当一个新的交易添加到交易池，我们更新这个新交易的所有祖先和后代交易状态。如果跳过更新后代状态，我们可以标记这个为&quot;dirty&quot;,以及相应设置（这个可能会在我们避免消耗过多cpu的从组时发生） class CTxMemPoolEntry { private: std::shared_ptr&lt;const CTransaction&gt; tx;//交易引用 CAmount nFee;//交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups size_t nTxWeight;// //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize()) size_t nModSize;//优先级修改后大小 //!&lt; ... and modified size for priority size_t nUsageSize; //交易大小 //!&lt; ... and total memory usage int64_t nTime;//时间戳，进入交易池 //!&lt; Local time when entering the mempool double entryPriority;//进入交易池的优先级 //!&lt; Priority when entering the mempool unsigned int entryHeight;//区块高度 //!&lt; Chain height when entering the mempool bool hadNoDependencies;//没有相关联的交易 //!&lt; Not dependent on any other txs when it entered the mempool CAmount inChainInputValue; //!&lt; Sum of all txin values that are already in blockchain bool spendsCoinbase;//前一个交易是否coinbase //!&lt; keep track of transactions that spend a coinbase int64_t sigOpCost; //!&lt; Total sigop cost int64_t feeDelta; //调整交易优先级 //!&lt; Used for determining the priority of the transaction for mining in a block LockPoints lockPoints;//交易最后所在区块高度和打包时间 //!&lt; Track the height and time at which tx was final // Information about descendants of this transaction that are in the // mempool; if we remove this transaction we must remove all of these // descendants as well. if nCountWithDescendants is 0, treat this entry as // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not be // correct. /*后代交易信息，如果移除一个交易，必须移除所有它的后代交易*/ uint64_t nCountWithDescendants;//后代交易的数量 //!&lt; number of descendant transactions uint64_t nSizeWithDescendants; //大小 //!&lt; ... and size CAmount nModFeesWithDescendants; // 所有费用包括当前交易//!&lt; ... and total fees (all including us) // Analogous statistics for ancestor transactions //祖先交易信息 uint64_t nCountWithAncestors; uint64_t nSizeWithAncestors; CAmount nModFeesWithAncestors; int64_t nSigOpCostWithAncestors; public: CTxMemPoolEntry(const CTransaction&amp; _tx, const CAmount&amp; _nFee, int64_t _nTime, double _entryPriority, unsigned int _entryHeight, bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase, int64_t nSigOpsCost, LockPoints lp); CTxMemPoolEntry(const CTxMemPoolEntry&amp; other); const CTransaction&amp; GetTx() const { return *this-&gt;tx; } std::shared_ptr&lt;const CTransaction&gt; GetSharedTx() const { return this-&gt;tx; } /** * Fast calculation of lower bound of current priority as update * from entry priority. Only inputs that were originally in-chain will age. */ double GetPriority(unsigned int currentHeight) const; const CAmount&amp; GetFee() const { return nFee; } size_t GetTxSize() const; size_t GetTxWeight() const { return nTxWeight; } int64_t GetTime() const { return nTime; } unsigned int GetHeight() const { return entryHeight; } bool WasClearAtEntry() const { return hadNoDependencies; } int64_t GetSigOpCost() const { return sigOpCost; } int64_t GetModifiedFee() const { return nFee + feeDelta; } size_t DynamicMemoryUsage() const { return nUsageSize; } const LockPoints&amp; GetLockPoints() const { return lockPoints; } // Adjusts the descendant state, if this entry is not dirty.更新后代交易状态 void UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount); // Adjusts the ancestor state 更新祖先交易状态 void UpdateAncestorState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount, int modifySigOps); // Updates the fee delta used for mining priority score, and the // modified fees with descendants.更新fee delta以调整优先级，修正后代交易费用 void UpdateFeeDelta(int64_t feeDelta); // Update the LockPoints after a reorg 更新LockPoints void UpdateLockPoints(const LockPoints&amp; lp); uint64_t GetCountWithDescendants() const { return nCountWithDescendants; } uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; } CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; } bool GetSpendsCoinbase() const { return spendsCoinbase; } uint64_t GetCountWithAncestors() const { return nCountWithAncestors; } uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; } CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; } int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; } mutable size_t vTxHashesIdx; //!&lt; Index in mempool&#39;s vTxHashes }; ##CTxMemPool 交易池的注释比较长 /** * CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. *CTxMemPool存储可能被打包进下一个区块的在当前最长链中有效的交易 * Transactions are added when they are seen on the network * (or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. *当交易在网络上被发现后会被添加进交易池（或者是本地节点产生的交易），但不是所有交易都可以，双花或非标准交易会被抛出 * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping: * mapTx是boost::multi_index类型，用来以4个标准排序池中的交易 * mapTx is a boost::multi_index that sorts the mempool on 4 criteria: * - transaction hash 交易哈希 * - feerate [we use max(feerate of tx, feerate of tx with all descendants)] 交易费用 * - time in mempool 时间 * - mining score (feerate modified by any fee deltas from PrioritiseTransaction) 挖矿分数 *我们说指的后代和祖先交易都是指存在这个池中的交易 * Note: the term &quot;descendant&quot; refers to in-mempool transactions that depend on * this one, while &quot;ancestor&quot; refers to in-mempool transactions that a given * transaction depends on. *为了保证交易排序的正确性，我们必须在新的后代交易到达后更新 * In order for the feerate sort to remain correct, we must update transactions * in the mempool when new descendants arrive. To facilitate this, we track * the set of in-mempool direct parents and direct children in mapLinks. Within * each CTxMemPoolEntry, we track the size and fees of all descendants. *为了达到这一目的，我们跟踪池内每个交易的直系祖先和后代交易。对每个CTxMemPoolEntry我们跟踪后代交易的大小和费用。 * Usually when a new transaction is added to the mempool, it has no in-mempool * children (because any such children would be an orphan). So in * addUnchecked(), we: * - update a new entry&#39;s setMemPoolParents to include all in-mempool parents * - update the new entry&#39;s direct parents to include the new tx as a child * - update all ancestors of the transaction to include the new tx&#39;s size/fee *通常一个新交易添加到池中是没有孩子（因为这些孩子通常是孤儿），所以在addUnchecked()： *我们更新一个新的元素的setMemPoolParents包含所有池内父交易，更新这个元素的直系父交易，把这个元素作为子交易，更新这个交易的所有祖先交易包含这个交易的大小和费用 * When a transaction is removed from the mempool, we must: * - update all in-mempool parents to not track the tx in setMemPoolChildren * - update all ancestors to not include the tx&#39;s size/fees in descendant state * - update all in-mempool children to not include it as a parent *当移除一个交易，需要三步 * These happen in UpdateForRemoveFromMempool(). (Note that when removing a * transaction along with its descendants, we must calculate that set of * transactions to be removed before doing the removal, or else the mempool can * be in an inconsistent state where it&#39;s impossible to walk the ancestors of * a transaction.) *这些通常发生在UpdateForRemoveFromMempool（） * In the event of a reorg, the assumption that a newly added tx has no * in-mempool children is false. In particular, the mempool is in an * inconsistent state while new transactions are being added, because there may * be descendant transactions of a tx coming from a disconnected block that are * unreachable from just looking at transactions in the mempool (the linking * transactions may also be in the disconnected block, waiting to be added). * Because of this, there&#39;s not much benefit in trying to search for in-mempool * children in addUnchecked(). Instead, in the special case of transactions * being added from a disconnected block, we require the caller to clean up the * state, to account for in-mempool, out-of-block descendants for all the * in-block transactions by calling UpdateTransactionsFromBlock(). Note that * until this is called, the mempool state is not consistent, and in particular * mapLinks may not be correct (and therefore functions like * CalculateMemPoolAncestors() and CalculateDescendants() that rely * on them to walk the mempool are not generally safe to use). *在重组的情况下，假设新添加的tx没有in-mempool子项是错误的。特别是，在添加新事务时，mempool处于不一致状态，因为可能存在来自断开块的tx的后代事务， *这些事务无法通过查看mempool中的事务而无法访问（链接事务也可能在断开连接的块，等待添加）。 * Computational limits: * * Updating all in-mempool ancestors of a newly added transaction can be slow, * if no bound exists on how many in-mempool ancestors there may be. * CalculateMemPoolAncestors() takes configurable limits that are designed to * prevent these calculations from being too CPU intensive. * * Adding transactions from a disconnected block can be very time consuming, * because we don&#39;t have a way to limit the number of in-mempool descendants. * To bound CPU processing, we limit the amount of work we&#39;re willing to do * to properly update the descendant information for a tx being added from * a disconnected block. If we would exceed the limit, then we instead mark * the entry as &quot;dirty&quot;, and set the feerate for sorting purposes to be equal * the feerate of the transaction without any descendants. *从断开连接的块添加事务可能非常耗时，因为我们没有办法限制in-mempool后代的数量。 *为了限制CPU处理，我们限制了我们愿意为正确更新从断开连接的块添加的tx的后代信息所做的工作量。 *如果我们超过限制，那么我们将条目标记为“脏”，并将排序目的的费用设置为等于没有任何后代的交易的费用。 */ 下面来看代码部分 class CTxMemPool { private: uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check.检查次数 unsigned int nTransactionsUpdated; CBlockPolicyEstimator* minerPolicyEstimator; uint64_t totalTxSize; //所有池中交易的大小，不包括见证数据!&lt; sum of all mempool tx&#39; byte sizes uint64_t cachedInnerUsage; //map中元素使用的动态内存之和!&lt; sum of dynamic memory usage of all the map elements (NOT the maps themselves) CFeeRate minReasonableRelayFee; mutable int64_t lastRollingFeeUpdate; mutable bool blockSinceLastRollingFeeBump; mutable double rollingMinimumFeeRate; //进入pool的最小费用!&lt; minimum fee to get into the pool, decreases exponentially void trackPackageRemoved(const CFeeRate&amp; rate); public: static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing typedef boost::multi_index_container&lt; CTxMemPoolEntry, boost::multi_index::indexed_by&lt; // sorted by txid 根据交易hash排序 boost::multi_index::hashed_unique&lt;mempoolentry_txid, SaltedTxidHasher&gt;, // sorted by fee rate 根据费用排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;descendant_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByDescendantScore//根据后代交易分数 &gt;, // sorted by entry time 根据进入时间排序 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;entry_time&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByEntryTime &gt;, // sorted by score (for mining prioritization) 分数 boost::multi_index::ordered_unique&lt; boost::multi_index::tag&lt;mining_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByScore &gt;, // sorted by fee rate with ancestors 祖先交易的费用 boost::multi_index::ordered_non_unique&lt; boost::multi_index::tag&lt;ancestor_score&gt;, boost::multi_index::identity&lt;CTxMemPoolEntry&gt;, CompareTxMemPoolEntryByAncestorFee &gt; &gt; &gt; indexed_transaction_set; mutable CCriticalSection cs; indexed_transaction_set mapTx; typedef indexed_transaction_set::nth_index&lt;0&gt;::type::iterator txiter; std::vector&lt;std::pair&lt;uint256, txiter&gt; &gt; vTxHashes; //!&lt; All tx witness hashes/entries in mapTx, in random order所有交易见证的哈希，无排序 struct CompareIteratorByHash { bool operator()(const txiter &amp;a, const txiter &amp;b) const { return a-&gt;GetTx().GetHash() &lt; b-&gt;GetTx().GetHash(); } }; typedef std::set&lt;txiter, CompareIteratorByHash&gt; setEntries; const setEntries &amp; GetMemPoolParents(txiter entry) const; const setEntries &amp; GetMemPoolChildren(txiter entry) const; private: typedef std::map&lt;txiter, setEntries, CompareIteratorByHash&gt; cacheMap; struct TxLinks { setEntries parents; setEntries children; }; typedef std::map&lt;txiter, TxLinks, CompareIteratorByHash&gt; txlinksMap; txlinksMap mapLinks; void UpdateParent(txiter entry, txiter parent, bool add); void UpdateChild(txiter entry, txiter child, bool add); std::vector&lt;indexed_transaction_set::const_iterator&gt; GetSortedDepthAndScore() const; public: indirectmap&lt;COutPoint, const CTransaction*&gt; mapNextTx; std::map&lt;uint256, std::pair&lt;double, CAmount&gt; &gt; mapDeltas; /** Create a new CTxMemPool.创建新的 CTxMemPool * minReasonableRelayFee should be a feerate which is, roughly, somewhere * around what it &quot;costs&quot; to relay a transaction around the network and * below which we would reasonably say a transaction has 0-effective-fee. */ //minReasonableRelayFee应该是一个大致在网络周围转发交易的“成本”左右的费用，我们可以合理地说，交易有0-有效费用。 CTxMemPool(const CFeeRate&amp; _minReasonableRelayFee); ~CTxMemPool(); /** * If sanity-checking is turned on, check makes sure the pool is * consistent (does not contain two transactions that spend the same inputs, * all inputs are in the mapNextTx array). If sanity-checking is turned off, * check does nothing. */ //如果启用了sanity-checking ，check会确保池的一致（不包含两个使用相同输入的事务，所有输入都在mapNextTx数组中）。 如果关闭完整性检查，则check不执行任何操作。 void check(const CCoinsViewCache *pcoins) const; void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } // addUnchecked must updated state for all ancestors of a given transaction, // to track size/count of descendant transactions. First version of // addUnchecked can be used to have it call CalculateMemPoolAncestors(), and // then invoke the second version. //addUnchecked必须为给定交易的所有祖先更新状态，以跟踪后代交易的大小/数量。 addUnchecked的第一个版本可用于调用CalculateMemPoolAncestors（），然后调用第二个版本。 bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, bool fCurrentEstimate = true); bool addUnchecked(const uint256&amp; hash, const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, bool fCurrentEstimate = true); void removeRecursive(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags); void removeConflicts(const CTransaction &amp;tx, std::list&lt;CTransaction&gt;&amp; removed); void removeForBlock(const std::vector&lt;CTransaction&gt;&amp; vtx, unsigned int nBlockHeight, std::list&lt;CTransaction&gt;&amp; conflicts, bool fCurrentEstimate = true); void clear(); void _clear(); //lock free bool CompareDepthAndScore(const uint256&amp; hasha, const uint256&amp; hashb); void queryHashes(std::vector&lt;uint256&gt;&amp; vtxid); void pruneSpent(const uint256&amp; hash, CCoins &amp;coins); unsigned int GetTransactionsUpdated() const; void AddTransactionsUpdated(unsigned int n); //检查这些交易输入都不在mempool中，因此tx不依赖于要包含在块中的其他mempool事务。 bool HasNoInputsOf(const CTransaction&amp; tx) const; /** Affect CreateNewBlock prioritisation of transactions 调整CreateNewBlock时的交易的优先级*/ void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount&amp; nFeeDelta); void ApplyDeltas(const uint256 hash, double &amp;dPriorityDelta, CAmount &amp;nFeeDelta) const; void ClearPrioritisation(const uint256 hash); public: /** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */ void RemoveStaged(setEntries &amp;stage, bool updateDescendants); /** When adding transactions from a disconnected block back to the mempool, * new mempool entries may have children in the mempool (which is generally * not the case when otherwise adding transactions). * UpdateTransactionsFromBlock() will find child transactions and update the * descendant state for each transaction in hashesToUpdate (excluding any * child transactions present in hashesToUpdate, which are already accounted * for). Note: hashesToUpdate should be the set of transactions from the * disconnected block that have been accepted back into the mempool. */ //将竞争失败（断开连接）的块中更新信息到池中 void UpdateTransactionsFromBlock(const std::vector&lt;uint256&gt; &amp;hashesToUpdate); /** Try to calculate all in-mempool ancestors of entry. * (these are all calculated including the tx itself) * limitAncestorCount = max number of ancestors 最大祖先数量 * limitAncestorSize = max size of ancestors 最大祖先交易的大小 * limitDescendantCount = max number of descendants any ancestor can have 任意祖先的最多后代数 * limitDescendantSize = max size of descendants any ancestor can have 任意祖先的最大后代交易大小 * errString = populated with error reason if any limits are hit 超过任何限制的错误提示 * fSearchForParents = whether to search a tx&#39;s vin for in-mempool parents, or是否从交易池中搜索交易的输入 * look up parents from mapLinks. Must be true for entries not in the mempool 或者从mapLinks查找，对于不在mempool的entries必须设置为true */ bool CalculateMemPoolAncestors(const CTxMemPoolEntry &amp;entry, setEntries &amp;setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &amp;errString, bool fSearchForParents = true) const; /** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */ void CalculateDescendants(txiter it, setEntries &amp;setDescendants); /** The minimum fee to get into the mempool, which may itself not be enough * for larger-sized transactions. * The minReasonableRelayFee constructor arg is used to bound the time it * takes the fee rate to go back down all the way to 0. When the feerate * would otherwise be half of this, it is set to 0 instead. */ //进入mempool所需要的最小费用，minReasonableRelayFee用来限制费用降到0所需的时间 CFeeRate GetMinFee(size_t sizelimit) const; /** Remove transactions from the mempool until its dynamic size is &lt;= sizelimit. * pvNoSpendsRemaining, if set, will be populated with the list of transactions * which are not in mempool which no longer have any spends in this mempool. */ //移除动态大小超过sizelimit的交易，如果设置了pvNoSpendsRemaining，则将填充不在mempool中的事务列表，该事务列表在此mempool中不再有任何支出。 void TrimToSize(size_t sizelimit, std::vector&lt;uint256&gt;* pvNoSpendsRemaining=NULL); /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */ //终止所有超过时间的交易（和他们的依赖交易），返回移除的交易数 int Expire(int64_t time); /** Returns false if the transaction is in the mempool and not within the chain limit specified. */ //如果交易存在池中但不在链限制中返回false bool TransactionWithinChainLimit(const uint256&amp; txid, size_t chainLimit) const; unsigned long size() { LOCK(cs); return mapTx.size(); } uint64_t GetTotalTxSize() { LOCK(cs); return totalTxSize; } bool exists(uint256 hash) const { LOCK(cs); return (mapTx.count(hash) != 0); } std::shared_ptr&lt;const CTransaction&gt; get(const uint256&amp; hash) const; TxMempoolInfo info(const uint256&amp; hash) const; std::vector&lt;TxMempoolInfo&gt; infoAll() const; /** Estimate fee rate needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ CFeeRate estimateSmartFee(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate fee rate needed to get into the next nBlocks 计算进入下一个区块需要的费用*/ CFeeRate estimateFee(int nBlocks) const; /** Estimate priority needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */ double estimateSmartPriority(int nBlocks, int *answerFoundAtBlocks = NULL) const; /** Estimate priority needed to get into the next nBlocks 计算进入下一个区块需要的优先级*/ double estimatePriority(int nBlocks) const; /** Write/Read estimates to disk */ bool WriteFeeEstimates(CAutoFile&amp; fileout) const; bool ReadFeeEstimates(CAutoFile&amp; filein); size_t DynamicMemoryUsage() const; private: /** UpdateTransactionsFromBlock使用UpdateForDescendants来更新已添加到mempool的单个事务的后代， *但可能在mempool中有子交易，例如在链重组期间。 setExclude是mempool中的后代交易集，不能被考虑 *（因为setExclude中的任何后代在事务更新后被添加到mempool，因此它们的状态已经反映在父状态中）。 *cachedDescendants将使用正在更新的事务的后代进行更新，以便将来的调用不需要再次遍历同一事务（如果在另一个事务链中遇到）。 */ void UpdateForDescendants(txiter updateIt, cacheMap &amp;cachedDescendants, const std::set&lt;uint256&gt; &amp;setExclude); /** Update ancestors of hash to add/remove it as a descendant transaction. */ void UpdateAncestorsOf(bool add, txiter hash, setEntries &amp;setAncestors); /** Set ancestor state for an entry 设置一个祖先*/ void UpdateEntryForAncestors(txiter it, const setEntries &amp;setAncestors); /** For each transaction being removed, update ancestors and any direct children.对每个要移除的交易，更新它的祖先和直系后代 * If updateDescendants is true, then also update in-mempool descendants&#39; * ancestor state. */ void UpdateForRemoveFromMempool(const setEntries &amp;entriesToRemove, bool updateDescendants); /** Sever link between specified transaction and direct children. */ void UpdateChildrenForRemoval(txiter entry); /** 对于一个给定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */ void removeUnchecked(txiter entry); }; 看到这里还是挺不清楚的，看得再多点有想法了再来完善吧 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/15/423206331f97acb1d8406e4eec0bd2c8.html","headline":"比特币源码学习0.13-数据结构-交易池","dateModified":"2018-08-15T00:00:00+08:00","datePublished":"2018-08-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/15/423206331f97acb1d8406e4eec0bd2c8.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13-数据结构-交易池</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81699796 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <hr> 
  <p></p>
  <div class="toc">
   <h3>文章目录</h3>
   <br> #交易池
   <br> 参考文章https://blog.csdn.net/pure_lady/article/details/77776716
   <br> 交易池 引用来自《精通比特币》8.13交易池
  </div>
  <p></p> 
  <blockquote> 
   <p>比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池<br> 或交易池。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所<br> 包含的交易。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经<br> 接收但还未被确认的、属于该用户钱包的预支付信息。<br> 随着交易被接收和验证，它们被添加到交易池并通知到相邻节点处，从而传播到<br> 网络中。</p> 
  </blockquote> 
  <p>交易池主要介绍两个类CTxMemPoolEntry和CTxMemPool，都位于txmempool.h中</p> 
  <hr> 
  <p>##CTxMemPoolEntry<br> 交易池中每一个元素（Entry）的基本结构<br> 首先来看注释部分</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">/** \class CTxMemPoolEntry * * CTxMemPoolEntry stores data about the correponding transaction, as well * as data about all in-mempool transactions that depend on the transaction * ("descendant" transactions). * * When a new entry is added to the mempool, we update the descendant state * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for * all ancestors of the newly added transaction. * * If updating the descendant state is skipped, we can mark the entry as * "dirty", and set nSizeWithDescendants/nModFeesWithDescendants to equal nTxSize/ * nFee+feeDelta. (This can potentially happen during a reorg, where we limit the * amount of work we're willing to do to avoid consuming too much CPU.) * */</span>
</code></pre> 
  <p><code>CTxMemPoolEntry</code>存储交易和该交易的所有后代交易，当一个新的交易添加到交易池，我们更新这个新交易的所有祖先和后代交易状态。如果跳过更新后代状态，我们可以标记这个为"dirty",以及相应设置（这个可能会在我们避免消耗过多cpu的从组时发生）</p> 
  <pre class=" language-c"><code class="prism  language-c">class CTxMemPoolEntry
<span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> CTransaction<span class="token operator">&gt;</span> tx<span class="token punctuation">;</span><span class="token comment">//交易引用</span>
    CAmount nFee<span class="token punctuation">;</span><span class="token comment">//交易费用 //!&lt; Cached to avoid expensive parent-transaction lookups</span>
    size_t nTxWeight<span class="token punctuation">;</span><span class="token comment">// //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize())</span>
    size_t nModSize<span class="token punctuation">;</span><span class="token comment">//优先级修改后大小 //!&lt; ... and modified size for priority</span>
    size_t nUsageSize<span class="token punctuation">;</span> <span class="token comment">//交易大小 //!&lt; ... and total memory usage</span>
    int64_t nTime<span class="token punctuation">;</span><span class="token comment">//时间戳，进入交易池 //!&lt; Local time when entering the mempool</span>
    <span class="token keyword">double</span> entryPriority<span class="token punctuation">;</span><span class="token comment">//进入交易池的优先级 //!&lt; Priority when entering the mempool</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> entryHeight<span class="token punctuation">;</span><span class="token comment">//区块高度 //!&lt; Chain height when entering the mempool</span>
    bool hadNoDependencies<span class="token punctuation">;</span><span class="token comment">//没有相关联的交易 //!&lt; Not dependent on any other txs when it entered the mempool</span>
    CAmount inChainInputValue<span class="token punctuation">;</span> <span class="token comment">//!&lt; Sum of all txin values that are already in blockchain</span>
    bool spendsCoinbase<span class="token punctuation">;</span><span class="token comment">//前一个交易是否coinbase //!&lt; keep track of transactions that spend a coinbase</span>
    int64_t sigOpCost<span class="token punctuation">;</span>         <span class="token comment">//!&lt; Total sigop cost</span>
    int64_t feeDelta<span class="token punctuation">;</span> <span class="token comment">//调整交易优先级 //!&lt; Used for determining the priority of the transaction for mining in a block</span>
    LockPoints lockPoints<span class="token punctuation">;</span><span class="token comment">//交易最后所在区块高度和打包时间 //!&lt; Track the height and time at which tx was final</span>

    <span class="token comment">// Information about descendants of this transaction that are in the</span>
    <span class="token comment">// mempool; if we remove this transaction we must remove all of these</span>
    <span class="token comment">// descendants as well. if nCountWithDescendants is 0, treat this entry as</span>
    <span class="token comment">// dirty, and nSizeWithDescendants and nModFeesWithDescendants will not be</span>
    <span class="token comment">// correct.</span>
    <span class="token comment">/*后代交易信息，如果移除一个交易，必须移除所有它的后代交易*/</span>
    uint64_t nCountWithDescendants<span class="token punctuation">;</span><span class="token comment">//后代交易的数量 //!&lt; number of descendant transactions</span>
    uint64_t nSizeWithDescendants<span class="token punctuation">;</span>  <span class="token comment">//大小 //!&lt; ... and size</span>
    CAmount nModFeesWithDescendants<span class="token punctuation">;</span> <span class="token comment">// 所有费用包括当前交易//!&lt; ... and total fees (all including us)</span>

    <span class="token comment">// Analogous statistics for ancestor transactions</span>
    <span class="token comment">//祖先交易信息</span>
    uint64_t nCountWithAncestors<span class="token punctuation">;</span>
    uint64_t nSizeWithAncestors<span class="token punctuation">;</span>
    CAmount nModFeesWithAncestors<span class="token punctuation">;</span>
    int64_t nSigOpCostWithAncestors<span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    <span class="token function">CTxMemPoolEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> _tx<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount<span class="token operator">&amp;</span> _nFee<span class="token punctuation">,</span>
                    int64_t _nTime<span class="token punctuation">,</span> <span class="token keyword">double</span> _entryPriority<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> _entryHeight<span class="token punctuation">,</span>
                    bool poolHasNoInputsOf<span class="token punctuation">,</span> CAmount _inChainInputValue<span class="token punctuation">,</span> bool spendsCoinbase<span class="token punctuation">,</span>
                    int64_t nSigOpsCost<span class="token punctuation">,</span> LockPoints lp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CTxMemPoolEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxMemPoolEntry<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> <span class="token function">GetTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token operator">-&gt;</span>tx<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> CTransaction<span class="token operator">&gt;</span> <span class="token function">GetSharedTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> this<span class="token operator">-&gt;</span>tx<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">/** * Fast calculation of lower bound of current priority as update * from entry priority. Only inputs that were originally in-chain will age. */</span>
    <span class="token keyword">double</span> <span class="token function">GetPriority</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> currentHeight<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> CAmount<span class="token operator">&amp;</span> <span class="token function">GetFee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nFee<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    size_t <span class="token function">GetTxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    size_t <span class="token function">GetTxWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nTxWeight<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    int64_t <span class="token function">GetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nTime<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">GetHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> entryHeight<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    bool <span class="token function">WasClearAtEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> hadNoDependencies<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    int64_t <span class="token function">GetSigOpCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> sigOpCost<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    int64_t <span class="token function">GetModifiedFee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nFee <span class="token operator">+</span> feeDelta<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    size_t <span class="token function">DynamicMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nUsageSize<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">const</span> LockPoints<span class="token operator">&amp;</span> <span class="token function">GetLockPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> lockPoints<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// Adjusts the descendant state, if this entry is not dirty.更新后代交易状态</span>
    <span class="token keyword">void</span> <span class="token function">UpdateDescendantState</span><span class="token punctuation">(</span>int64_t modifySize<span class="token punctuation">,</span> CAmount modifyFee<span class="token punctuation">,</span> int64_t modifyCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Adjusts the ancestor state 更新祖先交易状态</span>
    <span class="token keyword">void</span> <span class="token function">UpdateAncestorState</span><span class="token punctuation">(</span>int64_t modifySize<span class="token punctuation">,</span> CAmount modifyFee<span class="token punctuation">,</span> int64_t modifyCount<span class="token punctuation">,</span> <span class="token keyword">int</span> modifySigOps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Updates the fee delta used for mining priority score, and the</span>
    <span class="token comment">// modified fees with descendants.更新fee delta以调整优先级，修正后代交易费用</span>
    <span class="token keyword">void</span> <span class="token function">UpdateFeeDelta</span><span class="token punctuation">(</span>int64_t feeDelta<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Update the LockPoints after a reorg 更新LockPoints</span>
    <span class="token keyword">void</span> <span class="token function">UpdateLockPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> LockPoints<span class="token operator">&amp;</span> lp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    uint64_t <span class="token function">GetCountWithDescendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nCountWithDescendants<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    uint64_t <span class="token function">GetSizeWithDescendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nSizeWithDescendants<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    CAmount <span class="token function">GetModFeesWithDescendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nModFeesWithDescendants<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    bool <span class="token function">GetSpendsCoinbase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> spendsCoinbase<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    uint64_t <span class="token function">GetCountWithAncestors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nCountWithAncestors<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    uint64_t <span class="token function">GetSizeWithAncestors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nSizeWithAncestors<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    CAmount <span class="token function">GetModFeesWithAncestors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nModFeesWithAncestors<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    int64_t <span class="token function">GetSigOpCostWithAncestors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> nSigOpCostWithAncestors<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    mutable size_t vTxHashesIdx<span class="token punctuation">;</span> <span class="token comment">//!&lt; Index in mempool's vTxHashes</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <p>##CTxMemPool<br> 交易池的注释比较长</p> 
  <pre><code>/**
 * CTxMemPool stores valid-according-to-the-current-best-chain
 * transactions that may be included in the next block.
 *CTxMemPool存储可能被打包进下一个区块的在当前最长链中有效的交易
 * Transactions are added when they are seen on the network
 * (or created by the local node), but not all transactions seen
 * are added to the pool: if a new transaction double-spends
 * an input of a transaction in the pool, it is dropped,
 * as are non-standard transactions.
 *当交易在网络上被发现后会被添加进交易池（或者是本地节点产生的交易），但不是所有交易都可以，双花或非标准交易会被抛出
 * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:
 * mapTx是boost::multi_index类型，用来以4个标准排序池中的交易
 * mapTx is a boost::multi_index that sorts the mempool on 4 criteria:
 * - transaction hash 交易哈希
 * - feerate [we use max(feerate of tx, feerate of tx with all descendants)] 交易费用
 * - time in mempool 时间
 * - mining score (feerate modified by any fee deltas from PrioritiseTransaction) 挖矿分数
 *我们说指的后代和祖先交易都是指存在这个池中的交易
 * Note: the term "descendant" refers to in-mempool transactions that depend on
 * this one, while "ancestor" refers to in-mempool transactions that a given
 * transaction depends on.
 *为了保证交易排序的正确性，我们必须在新的后代交易到达后更新
 * In order for the feerate sort to remain correct, we must update transactions
 * in the mempool when new descendants arrive.  To facilitate this, we track
 * the set of in-mempool direct parents and direct children in mapLinks.  Within
 * each CTxMemPoolEntry, we track the size and fees of all descendants.
 *为了达到这一目的，我们跟踪池内每个交易的直系祖先和后代交易。对每个CTxMemPoolEntry我们跟踪后代交易的大小和费用。
 * Usually when a new transaction is added to the mempool, it has no in-mempool
 * children (because any such children would be an orphan).  So in
 * addUnchecked(), we:
 * - update a new entry's setMemPoolParents to include all in-mempool parents
 * - update the new entry's direct parents to include the new tx as a child
 * - update all ancestors of the transaction to include the new tx's size/fee
 *通常一个新交易添加到池中是没有孩子（因为这些孩子通常是孤儿），所以在addUnchecked()：
 *我们更新一个新的元素的setMemPoolParents包含所有池内父交易，更新这个元素的直系父交易，把这个元素作为子交易，更新这个交易的所有祖先交易包含这个交易的大小和费用
 * When a transaction is removed from the mempool, we must:
 * - update all in-mempool parents to not track the tx in setMemPoolChildren
 * - update all ancestors to not include the tx's size/fees in descendant state
 * - update all in-mempool children to not include it as a parent
 *当移除一个交易，需要三步
 * These happen in UpdateForRemoveFromMempool().  (Note that when removing a
 * transaction along with its descendants, we must calculate that set of
 * transactions to be removed before doing the removal, or else the mempool can
 * be in an inconsistent state where it's impossible to walk the ancestors of
 * a transaction.)
 *这些通常发生在UpdateForRemoveFromMempool（）
 * In the event of a reorg, the assumption that a newly added tx has no
 * in-mempool children is false.  In particular, the mempool is in an
 * inconsistent state while new transactions are being added, because there may
 * be descendant transactions of a tx coming from a disconnected block that are
 * unreachable from just looking at transactions in the mempool (the linking
 * transactions may also be in the disconnected block, waiting to be added).
 * Because of this, there's not much benefit in trying to search for in-mempool
 * children in addUnchecked().  Instead, in the special case of transactions
 * being added from a disconnected block, we require the caller to clean up the
 * state, to account for in-mempool, out-of-block descendants for all the
 * in-block transactions by calling UpdateTransactionsFromBlock().  Note that
 * until this is called, the mempool state is not consistent, and in particular
 * mapLinks may not be correct (and therefore functions like
 * CalculateMemPoolAncestors() and CalculateDescendants() that rely
 * on them to walk the mempool are not generally safe to use).
 *在重组的情况下，假设新添加的tx没有in-mempool子项是错误的。特别是，在添加新事务时，mempool处于不一致状态，因为可能存在来自断开块的tx的后代事务，
 *这些事务无法通过查看mempool中的事务而无法访问（链接事务也可能在断开连接的块，等待添加）。
 * Computational limits:
 *
 * Updating all in-mempool ancestors of a newly added transaction can be slow,
 * if no bound exists on how many in-mempool ancestors there may be.
 * CalculateMemPoolAncestors() takes configurable limits that are designed to
 * prevent these calculations from being too CPU intensive.
 *
 * Adding transactions from a disconnected block can be very time consuming,
 * because we don't have a way to limit the number of in-mempool descendants.
 * To bound CPU processing, we limit the amount of work we're willing to do
 * to properly update the descendant information for a tx being added from
 * a disconnected block.  If we would exceed the limit, then we instead mark
 * the entry as "dirty", and set the feerate for sorting purposes to be equal
 * the feerate of the transaction without any descendants.
 *从断开连接的块添加事务可能非常耗时，因为我们没有办法限制in-mempool后代的数量。
 *为了限制CPU处理，我们限制了我们愿意为正确更新从断开连接的块添加的tx的后代信息所做的工作量。
 *如果我们超过限制，那么我们将条目标记为“脏”，并将排序目的的费用设置为等于没有任何后代的交易的费用。
 */
</code></pre> 
  <p>下面来看代码部分</p> 
  <pre class=" language-c"><code class="prism  language-c">class CTxMemPool
<span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
    uint32_t nCheckFrequency<span class="token punctuation">;</span> <span class="token comment">//!&lt; Value n means that n times in 2^32 we check.检查次数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTransactionsUpdated<span class="token punctuation">;</span>
    CBlockPolicyEstimator<span class="token operator">*</span> minerPolicyEstimator<span class="token punctuation">;</span>

    uint64_t totalTxSize<span class="token punctuation">;</span>      <span class="token comment">//所有池中交易的大小，不包括见证数据!&lt; sum of all mempool tx' byte sizes</span>
    uint64_t cachedInnerUsage<span class="token punctuation">;</span> <span class="token comment">//map中元素使用的动态内存之和!&lt; sum of dynamic memory usage of all the map elements (NOT the maps themselves)</span>

    CFeeRate minReasonableRelayFee<span class="token punctuation">;</span>

    mutable int64_t lastRollingFeeUpdate<span class="token punctuation">;</span>
    mutable bool blockSinceLastRollingFeeBump<span class="token punctuation">;</span>
    mutable <span class="token keyword">double</span> rollingMinimumFeeRate<span class="token punctuation">;</span> <span class="token comment">//进入pool的最小费用!&lt; minimum fee to get into the pool, decreases exponentially</span>

    <span class="token keyword">void</span> <span class="token function">trackPackageRemoved</span><span class="token punctuation">(</span><span class="token keyword">const</span> CFeeRate<span class="token operator">&amp;</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span>

public<span class="token punctuation">:</span>

    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROLLING_FEE_HALFLIFE <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// public only for testing</span>

    <span class="token keyword">typedef</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index_container<span class="token operator">&lt;</span>
        CTxMemPoolEntry<span class="token punctuation">,</span>
        boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>indexed_by<span class="token operator">&lt;</span>
            <span class="token comment">// sorted by txid 根据交易hash排序</span>
            boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>hashed_unique<span class="token operator">&lt;</span>mempoolentry_txid<span class="token punctuation">,</span> SaltedTxidHasher<span class="token operator">&gt;</span><span class="token punctuation">,</span>
            <span class="token comment">// sorted by fee rate 根据费用排序</span>
            boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>ordered_non_unique<span class="token operator">&lt;</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>tag<span class="token operator">&lt;</span>descendant_score<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>identity<span class="token operator">&lt;</span>CTxMemPoolEntry<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                CompareTxMemPoolEntryByDescendantScore<span class="token comment">//根据后代交易分数</span>
            <span class="token operator">&gt;</span><span class="token punctuation">,</span>
            <span class="token comment">// sorted by entry time 根据进入时间排序</span>
            boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>ordered_non_unique<span class="token operator">&lt;</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>tag<span class="token operator">&lt;</span>entry_time<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>identity<span class="token operator">&lt;</span>CTxMemPoolEntry<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                CompareTxMemPoolEntryByEntryTime
            <span class="token operator">&gt;</span><span class="token punctuation">,</span>
            <span class="token comment">// sorted by score (for mining prioritization) 分数</span>
            boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>ordered_unique<span class="token operator">&lt;</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>tag<span class="token operator">&lt;</span>mining_score<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>identity<span class="token operator">&lt;</span>CTxMemPoolEntry<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                CompareTxMemPoolEntryByScore
            <span class="token operator">&gt;</span><span class="token punctuation">,</span>
            <span class="token comment">// sorted by fee rate with ancestors 祖先交易的费用</span>
            boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>ordered_non_unique<span class="token operator">&lt;</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>tag<span class="token operator">&lt;</span>ancestor_score<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                boost<span class="token punctuation">:</span><span class="token punctuation">:</span>multi_index<span class="token punctuation">:</span><span class="token punctuation">:</span>identity<span class="token operator">&lt;</span>CTxMemPoolEntry<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                CompareTxMemPoolEntryByAncestorFee
            <span class="token operator">&gt;</span>
        <span class="token operator">&gt;</span>
    <span class="token operator">&gt;</span> indexed_transaction_set<span class="token punctuation">;</span>

    mutable CCriticalSection cs<span class="token punctuation">;</span>
    indexed_transaction_set mapTx<span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> indexed_transaction_set<span class="token punctuation">:</span><span class="token punctuation">:</span>nth_index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>type<span class="token punctuation">:</span><span class="token punctuation">:</span>iterator txiter<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>uint256<span class="token punctuation">,</span> txiter<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> vTxHashes<span class="token punctuation">;</span> <span class="token comment">//!&lt; All tx witness hashes/entries in mapTx, in random order所有交易见证的哈希，无排序</span>

    <span class="token keyword">struct</span> CompareIteratorByHash <span class="token punctuation">{</span>
        bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> txiter <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> txiter <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token operator">-&gt;</span><span class="token function">GetTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token operator">-&gt;</span><span class="token function">GetTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>set<span class="token operator">&lt;</span>txiter<span class="token punctuation">,</span> CompareIteratorByHash<span class="token operator">&gt;</span> setEntries<span class="token punctuation">;</span>

    <span class="token keyword">const</span> setEntries <span class="token operator">&amp;</span> <span class="token function">GetMemPoolParents</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> setEntries <span class="token operator">&amp;</span> <span class="token function">GetMemPoolChildren</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
private<span class="token punctuation">:</span>
    <span class="token keyword">typedef</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>map<span class="token operator">&lt;</span>txiter<span class="token punctuation">,</span> setEntries<span class="token punctuation">,</span> CompareIteratorByHash<span class="token operator">&gt;</span> cacheMap<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> TxLinks <span class="token punctuation">{</span>
        setEntries parents<span class="token punctuation">;</span>
        setEntries children<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>map<span class="token operator">&lt;</span>txiter<span class="token punctuation">,</span> TxLinks<span class="token punctuation">,</span> CompareIteratorByHash<span class="token operator">&gt;</span> txlinksMap<span class="token punctuation">;</span>
    txlinksMap mapLinks<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">UpdateParent</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">,</span> txiter parent<span class="token punctuation">,</span> bool add<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">UpdateChild</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">,</span> txiter child<span class="token punctuation">,</span> bool add<span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>indexed_transaction_set<span class="token punctuation">:</span><span class="token punctuation">:</span>const_iterator<span class="token operator">&gt;</span> <span class="token function">GetSortedDepthAndScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    indirectmap<span class="token operator">&lt;</span>COutPoint<span class="token punctuation">,</span> <span class="token keyword">const</span> CTransaction<span class="token operator">*</span><span class="token operator">&gt;</span> mapNextTx<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>map<span class="token operator">&lt;</span>uint256<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> CAmount<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> mapDeltas<span class="token punctuation">;</span>

    <span class="token comment">/** Create a new CTxMemPool.创建新的 CTxMemPool * minReasonableRelayFee should be a feerate which is, roughly, somewhere * around what it "costs" to relay a transaction around the network and * below which we would reasonably say a transaction has 0-effective-fee. */</span>
     <span class="token comment">//minReasonableRelayFee应该是一个大致在网络周围转发交易的“成本”左右的费用，我们可以合理地说，交易有0-有效费用。</span>
    <span class="token function">CTxMemPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> CFeeRate<span class="token operator">&amp;</span> _minReasonableRelayFee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">CTxMemPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** * If sanity-checking is turned on, check makes sure the pool is * consistent (does not contain two transactions that spend the same inputs, * all inputs are in the mapNextTx array). If sanity-checking is turned off, * check does nothing. */</span>
     <span class="token comment">//如果启用了sanity-checking ，check会确保池的一致（不包含两个使用相同输入的事务，所有输入都在mapNextTx数组中）。 如果关闭完整性检查，则check不执行任何操作。</span>
    <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">const</span> CCoinsViewCache <span class="token operator">*</span>pcoins<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">setSanityCheck</span><span class="token punctuation">(</span><span class="token keyword">double</span> dFrequency <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> nCheckFrequency <span class="token operator">=</span> dFrequency <span class="token operator">*</span> <span class="token number">4294967295.0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// addUnchecked must updated state for all ancestors of a given transaction,</span>
    <span class="token comment">// to track size/count of descendant transactions. First version of</span>
    <span class="token comment">// addUnchecked can be used to have it call CalculateMemPoolAncestors(), and</span>
    <span class="token comment">// then invoke the second version.</span>
    <span class="token comment">//addUnchecked必须为给定交易的所有祖先更新状态，以跟踪后代交易的大小/数量。 addUnchecked的第一个版本可用于调用CalculateMemPoolAncestors（），然后调用第二个版本。</span>
    bool <span class="token function">addUnchecked</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hash<span class="token punctuation">,</span> <span class="token keyword">const</span> CTxMemPoolEntry <span class="token operator">&amp;</span>entry<span class="token punctuation">,</span> bool fCurrentEstimate <span class="token operator">=</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token function">addUnchecked</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hash<span class="token punctuation">,</span> <span class="token keyword">const</span> CTxMemPoolEntry <span class="token operator">&amp;</span>entry<span class="token punctuation">,</span> setEntries <span class="token operator">&amp;</span>setAncestors<span class="token punctuation">,</span> bool fCurrentEstimate <span class="token operator">=</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">removeRecursive</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction <span class="token operator">&amp;</span>tx<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>CTransaction<span class="token operator">&gt;</span><span class="token operator">&amp;</span> removed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">removeForReorg</span><span class="token punctuation">(</span><span class="token keyword">const</span> CCoinsViewCache <span class="token operator">*</span>pcoins<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nMemPoolHeight<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">removeConflicts</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction <span class="token operator">&amp;</span>tx<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>CTransaction<span class="token operator">&gt;</span><span class="token operator">&amp;</span> removed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">removeForBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>CTransaction<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vtx<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nBlockHeight<span class="token punctuation">,</span>
                        std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>CTransaction<span class="token operator">&gt;</span><span class="token operator">&amp;</span> conflicts<span class="token punctuation">,</span> bool fCurrentEstimate <span class="token operator">=</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">_clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//lock free</span>
    bool <span class="token function">CompareDepthAndScore</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hasha<span class="token punctuation">,</span> <span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hashb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">queryHashes</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vtxid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">pruneSpent</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hash<span class="token punctuation">,</span> CCoins <span class="token operator">&amp;</span>coins<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">GetTransactionsUpdated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">AddTransactionsUpdated</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//检查这些交易输入都不在mempool中，因此tx不依赖于要包含在块中的其他mempool事务。</span>
    bool <span class="token function">HasNoInputsOf</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> tx<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Affect CreateNewBlock prioritisation of transactions 调整CreateNewBlock时的交易的优先级*/</span>
    <span class="token keyword">void</span> <span class="token function">PrioritiseTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256 hash<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string strHash<span class="token punctuation">,</span> <span class="token keyword">double</span> dPriorityDelta<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount<span class="token operator">&amp;</span> nFeeDelta<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">ApplyDeltas</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256 hash<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>dPriorityDelta<span class="token punctuation">,</span> CAmount <span class="token operator">&amp;</span>nFeeDelta<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">ClearPrioritisation</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256 hash<span class="token punctuation">)</span><span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    <span class="token comment">/** * 从mempool中移除一个交易集合， * 如果一个交易在这个集合中，那么它的所有子孙交易都必须在集合中， * 除非该交易已经被打包到区块中。 * 如果要移除一个已经被打包到区块中的交易， * 那么要把updateDescendants设为true， * 从而更新mempool中所有子孙节点的祖先信息 */</span>  
    <span class="token keyword">void</span> <span class="token function">RemoveStaged</span><span class="token punctuation">(</span>setEntries <span class="token operator">&amp;</span>stage<span class="token punctuation">,</span> bool updateDescendants<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** When adding transactions from a disconnected block back to the mempool, * new mempool entries may have children in the mempool (which is generally * not the case when otherwise adding transactions). * UpdateTransactionsFromBlock() will find child transactions and update the * descendant state for each transaction in hashesToUpdate (excluding any * child transactions present in hashesToUpdate, which are already accounted * for). Note: hashesToUpdate should be the set of transactions from the * disconnected block that have been accepted back into the mempool. */</span>
     <span class="token comment">//将竞争失败（断开连接）的块中更新信息到池中</span>
    <span class="token keyword">void</span> <span class="token function">UpdateTransactionsFromBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>hashesToUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** Try to calculate all in-mempool ancestors of entry. * (these are all calculated including the tx itself) * limitAncestorCount = max number of ancestors 最大祖先数量 * limitAncestorSize = max size of ancestors 最大祖先交易的大小 * limitDescendantCount = max number of descendants any ancestor can have 任意祖先的最多后代数 * limitDescendantSize = max size of descendants any ancestor can have 任意祖先的最大后代交易大小 * errString = populated with error reason if any limits are hit 超过任何限制的错误提示 * fSearchForParents = whether to search a tx's vin for in-mempool parents, or是否从交易池中搜索交易的输入 * look up parents from mapLinks. Must be true for entries not in the mempool 或者从mapLinks查找，对于不在mempool的entries必须设置为true */</span>
    bool <span class="token function">CalculateMemPoolAncestors</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxMemPoolEntry <span class="token operator">&amp;</span>entry<span class="token punctuation">,</span> setEntries <span class="token operator">&amp;</span>setAncestors<span class="token punctuation">,</span> uint64_t limitAncestorCount<span class="token punctuation">,</span> uint64_t limitAncestorSize<span class="token punctuation">,</span> uint64_t limitDescendantCount<span class="token punctuation">,</span> uint64_t limitDescendantSize<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token operator">&amp;</span>errString<span class="token punctuation">,</span> bool fSearchForParents <span class="token operator">=</span> true<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Populate setDescendants with all in-mempool descendants of hash. * Assumes that setDescendants includes all in-mempool descendants of anything * already in it. */</span>
    <span class="token keyword">void</span> <span class="token function">CalculateDescendants</span><span class="token punctuation">(</span>txiter it<span class="token punctuation">,</span> setEntries <span class="token operator">&amp;</span>setDescendants<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** The minimum fee to get into the mempool, which may itself not be enough * for larger-sized transactions. * The minReasonableRelayFee constructor arg is used to bound the time it * takes the fee rate to go back down all the way to 0. When the feerate * would otherwise be half of this, it is set to 0 instead. */</span>
      <span class="token comment">//进入mempool所需要的最小费用，minReasonableRelayFee用来限制费用降到0所需的时间</span>
    CFeeRate <span class="token function">GetMinFee</span><span class="token punctuation">(</span>size_t sizelimit<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Remove transactions from the mempool until its dynamic size is &lt;= sizelimit. * pvNoSpendsRemaining, if set, will be populated with the list of transactions * which are not in mempool which no longer have any spends in this mempool. */</span>
      <span class="token comment">//移除动态大小超过sizelimit的交易，如果设置了pvNoSpendsRemaining，则将填充不在mempool中的事务列表，该事务列表在此mempool中不再有任何支出。</span>
    <span class="token keyword">void</span> <span class="token function">TrimToSize</span><span class="token punctuation">(</span>size_t sizelimit<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span><span class="token operator">*</span> pvNoSpendsRemaining<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */</span>
    <span class="token comment">//终止所有超过时间的交易（和他们的依赖交易），返回移除的交易数</span>
    <span class="token keyword">int</span> <span class="token function">Expire</span><span class="token punctuation">(</span>int64_t time<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** Returns false if the transaction is in the mempool and not within the chain limit specified. */</span>
    <span class="token comment">//如果交易存在池中但不在链限制中返回false</span>
    bool <span class="token function">TransactionWithinChainLimit</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> txid<span class="token punctuation">,</span> size_t chainLimit<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> mapTx<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    uint64_t <span class="token function">GetTotalTxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> totalTxSize<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    bool <span class="token function">exists</span><span class="token punctuation">(</span>uint256 hash<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>mapTx<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> CTransaction<span class="token operator">&gt;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hash<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    TxMempoolInfo <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint256<span class="token operator">&amp;</span> hash<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>TxMempoolInfo<span class="token operator">&gt;</span> <span class="token function">infoAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Estimate fee rate needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */</span>
    CFeeRate <span class="token function">estimateSmartFee</span><span class="token punctuation">(</span><span class="token keyword">int</span> nBlocks<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>answerFoundAtBlocks <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Estimate fee rate needed to get into the next nBlocks 计算进入下一个区块需要的费用*/</span>
    CFeeRate <span class="token function">estimateFee</span><span class="token punctuation">(</span><span class="token keyword">int</span> nBlocks<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Estimate priority needed to get into the next nBlocks * If no answer can be given at nBlocks, return an estimate * at the lowest number of blocks where one can be given */</span>
    <span class="token keyword">double</span> <span class="token function">estimateSmartPriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> nBlocks<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>answerFoundAtBlocks <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Estimate priority needed to get into the next nBlocks 计算进入下一个区块需要的优先级*/</span>
    <span class="token keyword">double</span> <span class="token function">estimatePriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> nBlocks<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    
    <span class="token comment">/** Write/Read estimates to disk */</span>
    bool <span class="token function">WriteFeeEstimates</span><span class="token punctuation">(</span>CAutoFile<span class="token operator">&amp;</span> fileout<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    bool <span class="token function">ReadFeeEstimates</span><span class="token punctuation">(</span>CAutoFile<span class="token operator">&amp;</span> filein<span class="token punctuation">)</span><span class="token punctuation">;</span>

    size_t <span class="token function">DynamicMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

private<span class="token punctuation">:</span>
    <span class="token comment">/** UpdateTransactionsFromBlock使用UpdateForDescendants来更新已添加到mempool的单个事务的后代， *但可能在mempool中有子交易，例如在链重组期间。 setExclude是mempool中的后代交易集，不能被考虑 *（因为setExclude中的任何后代在事务更新后被添加到mempool，因此它们的状态已经反映在父状态中）。 *cachedDescendants将使用正在更新的事务的后代进行更新，以便将来的调用不需要再次遍历同一事务（如果在另一个事务链中遇到）。 */</span>
    <span class="token keyword">void</span> <span class="token function">UpdateForDescendants</span><span class="token punctuation">(</span>txiter updateIt<span class="token punctuation">,</span>
            cacheMap <span class="token operator">&amp;</span>cachedDescendants<span class="token punctuation">,</span>
            <span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>set<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>setExclude<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/** Update ancestors of hash to add/remove it as a descendant transaction. */</span>
    <span class="token keyword">void</span> <span class="token function">UpdateAncestorsOf</span><span class="token punctuation">(</span>bool add<span class="token punctuation">,</span> txiter hash<span class="token punctuation">,</span> setEntries <span class="token operator">&amp;</span>setAncestors<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/** Set ancestor state for an entry 设置一个祖先*/</span>
    <span class="token keyword">void</span> <span class="token function">UpdateEntryForAncestors</span><span class="token punctuation">(</span>txiter it<span class="token punctuation">,</span> <span class="token keyword">const</span> setEntries <span class="token operator">&amp;</span>setAncestors<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/** For each transaction being removed, update ancestors and any direct children.对每个要移除的交易，更新它的祖先和直系后代 * If updateDescendants is true, then also update in-mempool descendants' * ancestor state. */</span>
    <span class="token keyword">void</span> <span class="token function">UpdateForRemoveFromMempool</span><span class="token punctuation">(</span><span class="token keyword">const</span> setEntries <span class="token operator">&amp;</span>entriesToRemove<span class="token punctuation">,</span> bool updateDescendants<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/** Sever link between specified transaction and direct children. */</span>
    <span class="token keyword">void</span> <span class="token function">UpdateChildrenForRemoval</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** 对于一个给定的交易，调用 removeUnchecked 之前， * 必须为同时为要移除的交易集合调用UpdateForRemoveFromMempool。 * 我们使用每个CTxMemPoolEntry中的setMemPoolParents来遍历 * 要移除交易的祖先，这样能保证我们更新的正确性。 */</span>
    <span class="token keyword">void</span> <span class="token function">removeUnchecked</span><span class="token punctuation">(</span>txiter entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>看到这里还是挺不清楚的，看得再多点有想法了再来完善吧</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81699796,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81699796,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81699796,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81699796,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
