<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码分析之九区块 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码分析之九区块" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/fpcc/article/details/81583064 以太坊源码分析之九区块 终于到了区块链中最和区块链搭界的部分，毕竟它们只差一个字。区块是区块链的基础，区块通过HASH链接在一起就成为了区块链。 一、区块的相关数据结构 不当嘴炮党，看源码： 链数据结构： type BlockChain struct { &nbsp;&nbsp; &nbsp;chainConfig *params.ChainConfig // Chain &amp; network configuration &nbsp;&nbsp; &nbsp;cacheConfig *CacheConfig &nbsp; &nbsp; &nbsp; &nbsp;// Cache configuration for pruning &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; ethdb.Database // Low level persistent database to store final content in &nbsp;&nbsp; &nbsp;triegc *prque.Prque &nbsp; // Priority queue mapping block numbers to tries to gc &nbsp;&nbsp; &nbsp;gcproc time.Duration &nbsp;// Accumulates canonical block processing for trie dumping &nbsp;&nbsp; &nbsp;hc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*HeaderChain &nbsp;//只有头的链，用于验证和快速下载 &nbsp;&nbsp; &nbsp;//其下为消息订阅的一系列事件 rmLogsFeed &nbsp; &nbsp;event.Feed &nbsp; &nbsp;//其下为消息订阅的一系列事件，删除日志 &nbsp;&nbsp; &nbsp;chainFeed &nbsp; &nbsp; event.Feed &nbsp; &nbsp;//主链事件 &nbsp;&nbsp; &nbsp;chainSideFeed event.Feed &nbsp; &nbsp; &nbsp;//侧链事件 &nbsp;&nbsp; &nbsp;chainHeadFeed event.Feed &nbsp; &nbsp; // 主链头事件 &nbsp;&nbsp; &nbsp;logsFeed &nbsp; &nbsp; &nbsp;event.Feed &nbsp;&nbsp; &nbsp;scope &nbsp; &nbsp; &nbsp; &nbsp; event.SubscriptionScope &nbsp;&nbsp; &nbsp;genesisBlock &nbsp;*types.Block &nbsp; //创世块 &nbsp;&nbsp; &nbsp;mu &nbsp; &nbsp; &nbsp;sync.RWMutex // global mutex for locking chain operations &nbsp;&nbsp; &nbsp;chainmu sync.RWMutex // blockchain insertion lock &nbsp;&nbsp; &nbsp;procmu &nbsp;sync.RWMutex // block processor lock &nbsp;&nbsp; &nbsp;checkpoint &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// checkpoint counts towards the new checkpoint &nbsp;&nbsp; &nbsp;currentBlock &nbsp; &nbsp; *types.Block // Current head of the block chain &nbsp;&nbsp; &nbsp;currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) &nbsp;&nbsp; &nbsp;stateCache &nbsp; state.Database // State database to reuse between imports (contains state cache) &nbsp;&nbsp; &nbsp;bodyCache &nbsp; &nbsp;*lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies &nbsp;&nbsp; &nbsp;bodyRLPCache *lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies in RLP encoded format &nbsp;&nbsp; &nbsp;blockCache &nbsp; *lru.Cache &nbsp; &nbsp; // Cache for the most recent entire blocks &nbsp;&nbsp; &nbsp;futureBlocks *lru.Cache &nbsp; &nbsp; // future blocks are blocks added for later processing &nbsp;&nbsp; &nbsp;quit &nbsp; &nbsp;chan struct{} // blockchain quit channel &nbsp;&nbsp; &nbsp;running int32 &nbsp; &nbsp; &nbsp; &nbsp; // running must be called atomically &nbsp;&nbsp; &nbsp;// procInterrupt must be atomically called &nbsp;&nbsp; &nbsp;procInterrupt int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// interrupt signaler for block processing &nbsp;&nbsp; &nbsp;wg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sync.WaitGroup // chain processing wait group for shutting down &nbsp;&nbsp; &nbsp;engine &nbsp; &nbsp;consensus.Engine &nbsp;&nbsp; &nbsp;processor Processor // block processor interface &nbsp;&nbsp; &nbsp;validator Validator // block and state validator interface &nbsp;&nbsp; &nbsp;vmConfig &nbsp;vm.Config &nbsp;&nbsp; &nbsp;badBlocks *lru.Cache // Bad block cache } 块数据结构： // Block represents an entire block in the Ethereum blockchain. type Block struct { &nbsp;&nbsp; &nbsp;header &nbsp; &nbsp; &nbsp; *Header &nbsp;&nbsp; &nbsp;uncles &nbsp; &nbsp; &nbsp; []*Header &nbsp;//叔块的头，叔块最多有两个 &nbsp;&nbsp; &nbsp;transactions Transactions &nbsp;&nbsp; &nbsp;// caches &nbsp;&nbsp; &nbsp;hash atomic.Value &nbsp;&nbsp; &nbsp;size atomic.Value &nbsp;&nbsp; &nbsp;// Td is used by package core to store the total difficulty &nbsp;&nbsp; &nbsp;// of the chain up to and including the block. &nbsp;&nbsp; &nbsp;td *big.Int &nbsp; //难度 &nbsp;&nbsp; &nbsp;// These fields are used by package eth to track &nbsp;&nbsp; &nbsp;// inter-peer block relay. &nbsp;&nbsp; &nbsp;ReceivedAt &nbsp; time.Time &nbsp;&nbsp; &nbsp;ReceivedFrom interface{} } 区块头数据结构： type Header struct { //指向父区块(parentBlock)的hash。除了创世块(Genesis Block)没有父区块，每个区块有且//只有一个父区块。 &nbsp;&nbsp; &nbsp;ParentHash &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;parentHash&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//叔块地址。 UncleHash &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;sha3Uncles&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//出块地址。挖矿和交易都发给这个地址。 Coinbase &nbsp; &nbsp;common.Address `json:&quot;miner&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` //世界状态，状态树的根哈希值—三大树 &nbsp;&nbsp; &nbsp;Root &nbsp; &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;stateRoot&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易树根哈希值&nbsp; &nbsp;&nbsp; &nbsp;TxHash &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//接收者树的的根哈希值 &nbsp;&nbsp; &nbsp;ReceiptHash common.Hash &nbsp; &nbsp;`json:&quot;receiptsRoot&quot; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易收据日志组成的布隆过滤器 &nbsp;&nbsp; &nbsp;Bloom &nbsp; &nbsp; &nbsp; Bloom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`json:&quot;logsBloom&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块难度 &nbsp;&nbsp; &nbsp;Difficulty &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;difficulty&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//块号 &nbsp;&nbsp; &nbsp;Number &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;number&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块Gas上限 &nbsp;&nbsp; &nbsp;GasLimit &nbsp; &nbsp;uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasLimit&quot; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//Gas使用量 &nbsp;&nbsp; &nbsp;GasUsed &nbsp; &nbsp; uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasUsed&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块的产生时间戳 &nbsp;&nbsp; &nbsp;Time &nbsp; &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;timestamp&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//附加数据 &nbsp;&nbsp; &nbsp;Extra &nbsp; &nbsp; &nbsp; []byte &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;extraData&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//一个哈希值，用NONCE组合用于计算工作量 &nbsp;&nbsp; &nbsp;MixDigest &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;mixHash&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//区块产生的随机值，每个用户必须单调步长为1递增 &nbsp;&nbsp; &nbsp;Nonce &nbsp; &nbsp; &nbsp; BlockNonce &nbsp; &nbsp; `json:&quot;nonce&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` } 三者的关系非常明晰，BlockChain 由Block组成，而Header是后者的重要组成部分。 在BlockChain的注释中指出：它是一个标准的以太坊的链数据结构，其内部包含了创世区块及相关数据库的配置,以太坊通过它管理链的插入,恢复,重组等操作. 通过由一系列规则组成的两阶段的验证器来插入一个区块。利用交易处理器对区块中的交易进行处理并利用验证器进行验证，一旦错误将导致上链的失败。 需要注意的是GetBlock函数可能得到任何当前链中的块,但是使用GetBlockByNumber函数却一直得到当前主链中的区块。 二、以太坊的存储模型 以太坊的存储分三层： 上层：业务数据 中层：MPT缓存 底层：LEVELDB 结合到实际的代码中： type StateDB struct { &nbsp;&nbsp; &nbsp;db &nbsp; Database&nbsp; &nbsp;&nbsp; &nbsp;trie Trie &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp;&nbsp; &nbsp;stateObjects &nbsp; &nbsp; &nbsp;map[common.Address]*stateObject &nbsp; //顶层业务 &nbsp;&nbsp; &nbsp;stateObjectsDirty map[common.Address]struct{} …… } type stateObject struct { &nbsp;&nbsp; &nbsp;address &nbsp;common.Address &nbsp;&nbsp; &nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp;&nbsp; &nbsp;data &nbsp; &nbsp; Account &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp; *StateDB &nbsp;&nbsp; &nbsp;// DB error. &nbsp;&nbsp; &nbsp;// State objects are used by the consensus core and VM which are &nbsp;&nbsp; &nbsp;// unable to deal with database-level errors. Any error that occurs &nbsp;&nbsp; &nbsp;// during a database read is memoized here and will eventually be returned &nbsp;&nbsp; &nbsp;// by StateDB.Commit. &nbsp;&nbsp; &nbsp;dbErr error &nbsp;&nbsp; &nbsp;// Write caches.缓存 &nbsp;&nbsp; &nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp; &nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp;&nbsp; &nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp; &nbsp;dirtyStorage &nbsp;Storage // Storage entries that need to be flushed to disk &nbsp;&nbsp; &nbsp;// Cache flags. &nbsp;&nbsp; &nbsp;// When an object is marked suicided it will be delete from the trie &nbsp;&nbsp; &nbsp;// during the &quot;update&quot; phase of the state transition. &nbsp;&nbsp; &nbsp;dirtyCode bool // true if the code was updated &nbsp;&nbsp; &nbsp;suicided &nbsp;bool &nbsp;&nbsp; &nbsp;touched &nbsp; bool &nbsp;&nbsp; &nbsp;deleted &nbsp; bool &nbsp;&nbsp; &nbsp;onDirty &nbsp; func(addr common.Address) // Callback method to mark a state object newly dirty } 最终在 CommitTire实现写入数据LEVELDB。 三、区块的存储 区块的存储在以太坊中是通过leveldb实现的，leveldb是一个kv型数据库，支持高速写入。 在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。 头（Header）的存储格式为： &nbsp; &nbsp; headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) key是由header的前缀，Number和区块hash构成。value是header的RLP编码。 区块体（Body）的存储格式为： &nbsp; &nbsp; bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) key是由body前缀，Number和区块hash构成。value是区块体的RLP编码。 看一下database_util.go中的定义的变量： var ( &nbsp;&nbsp; &nbsp;headHeaderKey = []byte(&quot;LastHeader&quot;) &nbsp;&nbsp; &nbsp;headBlockKey &nbsp;= []byte(&quot;LastBlock&quot;) &nbsp;&nbsp; &nbsp;headFastKey &nbsp; = []byte(&quot;LastFast&quot;) &nbsp;&nbsp; &nbsp;// Data item prefixes (use single byte to avoid mixing data types, avoid `i`). &nbsp;&nbsp; &nbsp;headerPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;h&quot;) // headerPrefix + num (uint64 big endian) + hash -&gt; header &nbsp;&nbsp; &nbsp;tdSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;t&quot;) // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td &nbsp;&nbsp; &nbsp;numSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = []byte(&quot;n&quot;) // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash &nbsp;&nbsp; &nbsp;blockHashPrefix &nbsp; &nbsp; = []byte(&quot;H&quot;) // blockHashPrefix + hash -&gt; num (uint64 big endian) &nbsp;&nbsp; &nbsp;bodyPrefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;b&quot;) // bodyPrefix + num (uint64 big endian) + hash -&gt; block body &nbsp;&nbsp; &nbsp;blockReceiptsPrefix = []byte(&quot;r&quot;) // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts &nbsp;&nbsp; &nbsp;lookupPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;l&quot;) // lookupPrefix + hash -&gt; transaction/receipt lookup metadata &nbsp;&nbsp; &nbsp;bloomBitsPrefix &nbsp; &nbsp; = []byte(&quot;B&quot;) // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits &nbsp;&nbsp; &nbsp;preimagePrefix = &quot;secure-key-&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// preimagePrefix + hash -&gt; preimage &nbsp;&nbsp; &nbsp;configPrefix &nbsp; = []byte(&quot;ethereum-config-&quot;) // config prefix for the db &nbsp;&nbsp; &nbsp;// Chain index prefixes (use `i` + single byte to avoid mixing data types). &nbsp;&nbsp; &nbsp;BloomBitsIndexPrefix = []byte(&quot;iB&quot;) // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress &nbsp;&nbsp; &nbsp;// used by old db, now only used for conversion &nbsp;&nbsp; &nbsp;oldReceiptsPrefix = []byte(&quot;receipts-&quot;) &nbsp;&nbsp; &nbsp;oldTxMetaSuffix &nbsp; = []byte{0x01} &nbsp;&nbsp; &nbsp;ErrChainConfigNotFound = errors.New(&quot;ChainConfig not found&quot;) // general config not found error &nbsp;&nbsp; &nbsp;preimageCounter &nbsp; &nbsp;= metrics.NewCounter(&quot;db/preimage/total&quot;) &nbsp;&nbsp; &nbsp;preimageHitCounter = metrics.NewCounter(&quot;db/preimage/hits&quot;) ) 这些前缀用来表明是什么样的数据类型。下面看一下具体的存储，在core/database_util.go中封装了区块存储和读取相关的代码。 // DatabaseReader wraps the Get method of a backing data store. type DatabaseReader interface { &nbsp;&nbsp; &nbsp;Get(key []byte) (value []byte, err error) } // DatabaseDeleter wraps the Delete method of a backing data store. type DatabaseDeleter interface { &nbsp;&nbsp; &nbsp;Delete(key []byte) error } 写入区块： // WriteBlock serializes a block into the database, header and body separately. func WriteBlock(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Store the body first to retain database consistency &nbsp;&nbsp; &nbsp;if err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Store the header too, signaling full block ownership &nbsp;&nbsp; &nbsp;if err := WriteHeader(db, block.Header()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 下面是写区块调用的两个函数： // WriteHeader serializes a block header into the database. func WriteHeader(db ethdb.Putter, header *types.Header) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(header) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;hash := header.Hash().Bytes() &nbsp;&nbsp; &nbsp;num := header.Number.Uint64() &nbsp;&nbsp; &nbsp;encNum := encodeBlockNumber(num) &nbsp;&nbsp; &nbsp;key := append(blockHashPrefix, hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store hash to number mapping&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store header&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } // WriteBody serializes the body of a block into the database. func WriteBody(db ethdb.Putter, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(body) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return WriteBodyRLP(db, hash, number, data) } 分为了写头和写区块体两部分。首先对区块头进行了RLP编码，然后将Number转换成为byte格式，然后拼装key。 这个过程中要先存储了hash-&gt;Number的值，然后才将区块头的数据写入数据库。 区块体类似，RLP编码，拼装KEY。 再分析一下交易的存储： 目前的以太坊交易在数据库中仅存储交易的元数据： // TxLookupEntry is a positional metadata to help looking up the data content of // a transaction or receipt given only its hash. type TxLookupEntry struct { &nbsp;&nbsp; &nbsp;BlockHash &nbsp;common.Hash &nbsp;&nbsp; &nbsp;BlockIndex uint64 &nbsp;&nbsp; &nbsp;Index &nbsp; &nbsp; &nbsp;uint64 } 存储的KV对应为： txHash(交易哈希)+txMetaSuffix(前缀)-&gt;rlpEncode(txMeta)(元数据编码) 写入函数： // WriteTxLookupEntries stores a positional metadata for every transaction from // a block, enabling hash based transaction and receipt lookups. func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Iterate over each transaction and encode its metadata &nbsp;&nbsp; &nbsp;for i, tx := range block.Transactions() { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entry := TxLookupEntry{ &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockHash: &nbsp;block.Hash(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Index: &nbsp; &nbsp; &nbsp;uint64(i), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(entry) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 遍历交易，构造元数据，RLP编码，然后就可以入库了。 读取代码如下： // GetTransaction retrieves a specific transaction from the database, along with // its added positional metadata. func GetTransaction(db DatabaseReader, hash common.Hash) (*types.Transaction, common.Hash, uint64, uint64) { &nbsp;&nbsp; &nbsp;// Retrieve the lookup metadata and resolve the transaction from the body &nbsp;&nbsp; &nbsp;blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash) &nbsp;&nbsp; &nbsp;if blockHash != (common.Hash{}) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;body := GetBody(db, blockHash, blockNumber) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if body == nil || len(body.Transactions) &lt;= int(txIndex) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Error(&quot;Transaction referenced missing&quot;, &quot;number&quot;, blockNumber, &quot;hash&quot;, blockHash, &quot;index&quot;, txIndex) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return body.Transactions[txIndex], blockHash, blockNumber, txIndex &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Old transaction representation, load the transaction and it&#39;s metadata separately &nbsp;&nbsp; &nbsp;data, _ := db.Get(hash.Bytes()) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var tx types.Transaction &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;tx); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Retrieve the blockchain positional metadata &nbsp;&nbsp; &nbsp;data, _ = db.Get(append(hash.Bytes(), oldTxMetaSuffix...)) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var entry TxLookupEntry &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;entry); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return &amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index } 先通过交易哈希得到元数据入口，再查找块哈希，然后从块上找到交易的具体信息返回，或者如果是老的版本，则处理一下再返回。 也就是说，这个函数支持新旧两个版本的交易查询。 这样区块也就基本分析完成了。 如果对区块链和c++感兴趣，欢迎关注： 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/fpcc/article/details/81583064 以太坊源码分析之九区块 终于到了区块链中最和区块链搭界的部分，毕竟它们只差一个字。区块是区块链的基础，区块通过HASH链接在一起就成为了区块链。 一、区块的相关数据结构 不当嘴炮党，看源码： 链数据结构： type BlockChain struct { &nbsp;&nbsp; &nbsp;chainConfig *params.ChainConfig // Chain &amp; network configuration &nbsp;&nbsp; &nbsp;cacheConfig *CacheConfig &nbsp; &nbsp; &nbsp; &nbsp;// Cache configuration for pruning &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; ethdb.Database // Low level persistent database to store final content in &nbsp;&nbsp; &nbsp;triegc *prque.Prque &nbsp; // Priority queue mapping block numbers to tries to gc &nbsp;&nbsp; &nbsp;gcproc time.Duration &nbsp;// Accumulates canonical block processing for trie dumping &nbsp;&nbsp; &nbsp;hc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*HeaderChain &nbsp;//只有头的链，用于验证和快速下载 &nbsp;&nbsp; &nbsp;//其下为消息订阅的一系列事件 rmLogsFeed &nbsp; &nbsp;event.Feed &nbsp; &nbsp;//其下为消息订阅的一系列事件，删除日志 &nbsp;&nbsp; &nbsp;chainFeed &nbsp; &nbsp; event.Feed &nbsp; &nbsp;//主链事件 &nbsp;&nbsp; &nbsp;chainSideFeed event.Feed &nbsp; &nbsp; &nbsp;//侧链事件 &nbsp;&nbsp; &nbsp;chainHeadFeed event.Feed &nbsp; &nbsp; // 主链头事件 &nbsp;&nbsp; &nbsp;logsFeed &nbsp; &nbsp; &nbsp;event.Feed &nbsp;&nbsp; &nbsp;scope &nbsp; &nbsp; &nbsp; &nbsp; event.SubscriptionScope &nbsp;&nbsp; &nbsp;genesisBlock &nbsp;*types.Block &nbsp; //创世块 &nbsp;&nbsp; &nbsp;mu &nbsp; &nbsp; &nbsp;sync.RWMutex // global mutex for locking chain operations &nbsp;&nbsp; &nbsp;chainmu sync.RWMutex // blockchain insertion lock &nbsp;&nbsp; &nbsp;procmu &nbsp;sync.RWMutex // block processor lock &nbsp;&nbsp; &nbsp;checkpoint &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// checkpoint counts towards the new checkpoint &nbsp;&nbsp; &nbsp;currentBlock &nbsp; &nbsp; *types.Block // Current head of the block chain &nbsp;&nbsp; &nbsp;currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) &nbsp;&nbsp; &nbsp;stateCache &nbsp; state.Database // State database to reuse between imports (contains state cache) &nbsp;&nbsp; &nbsp;bodyCache &nbsp; &nbsp;*lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies &nbsp;&nbsp; &nbsp;bodyRLPCache *lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies in RLP encoded format &nbsp;&nbsp; &nbsp;blockCache &nbsp; *lru.Cache &nbsp; &nbsp; // Cache for the most recent entire blocks &nbsp;&nbsp; &nbsp;futureBlocks *lru.Cache &nbsp; &nbsp; // future blocks are blocks added for later processing &nbsp;&nbsp; &nbsp;quit &nbsp; &nbsp;chan struct{} // blockchain quit channel &nbsp;&nbsp; &nbsp;running int32 &nbsp; &nbsp; &nbsp; &nbsp; // running must be called atomically &nbsp;&nbsp; &nbsp;// procInterrupt must be atomically called &nbsp;&nbsp; &nbsp;procInterrupt int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// interrupt signaler for block processing &nbsp;&nbsp; &nbsp;wg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sync.WaitGroup // chain processing wait group for shutting down &nbsp;&nbsp; &nbsp;engine &nbsp; &nbsp;consensus.Engine &nbsp;&nbsp; &nbsp;processor Processor // block processor interface &nbsp;&nbsp; &nbsp;validator Validator // block and state validator interface &nbsp;&nbsp; &nbsp;vmConfig &nbsp;vm.Config &nbsp;&nbsp; &nbsp;badBlocks *lru.Cache // Bad block cache } 块数据结构： // Block represents an entire block in the Ethereum blockchain. type Block struct { &nbsp;&nbsp; &nbsp;header &nbsp; &nbsp; &nbsp; *Header &nbsp;&nbsp; &nbsp;uncles &nbsp; &nbsp; &nbsp; []*Header &nbsp;//叔块的头，叔块最多有两个 &nbsp;&nbsp; &nbsp;transactions Transactions &nbsp;&nbsp; &nbsp;// caches &nbsp;&nbsp; &nbsp;hash atomic.Value &nbsp;&nbsp; &nbsp;size atomic.Value &nbsp;&nbsp; &nbsp;// Td is used by package core to store the total difficulty &nbsp;&nbsp; &nbsp;// of the chain up to and including the block. &nbsp;&nbsp; &nbsp;td *big.Int &nbsp; //难度 &nbsp;&nbsp; &nbsp;// These fields are used by package eth to track &nbsp;&nbsp; &nbsp;// inter-peer block relay. &nbsp;&nbsp; &nbsp;ReceivedAt &nbsp; time.Time &nbsp;&nbsp; &nbsp;ReceivedFrom interface{} } 区块头数据结构： type Header struct { //指向父区块(parentBlock)的hash。除了创世块(Genesis Block)没有父区块，每个区块有且//只有一个父区块。 &nbsp;&nbsp; &nbsp;ParentHash &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;parentHash&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//叔块地址。 UncleHash &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;sha3Uncles&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//出块地址。挖矿和交易都发给这个地址。 Coinbase &nbsp; &nbsp;common.Address `json:&quot;miner&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` //世界状态，状态树的根哈希值—三大树 &nbsp;&nbsp; &nbsp;Root &nbsp; &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;stateRoot&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易树根哈希值&nbsp; &nbsp;&nbsp; &nbsp;TxHash &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//接收者树的的根哈希值 &nbsp;&nbsp; &nbsp;ReceiptHash common.Hash &nbsp; &nbsp;`json:&quot;receiptsRoot&quot; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易收据日志组成的布隆过滤器 &nbsp;&nbsp; &nbsp;Bloom &nbsp; &nbsp; &nbsp; Bloom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`json:&quot;logsBloom&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块难度 &nbsp;&nbsp; &nbsp;Difficulty &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;difficulty&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//块号 &nbsp;&nbsp; &nbsp;Number &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;number&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块Gas上限 &nbsp;&nbsp; &nbsp;GasLimit &nbsp; &nbsp;uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasLimit&quot; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//Gas使用量 &nbsp;&nbsp; &nbsp;GasUsed &nbsp; &nbsp; uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasUsed&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块的产生时间戳 &nbsp;&nbsp; &nbsp;Time &nbsp; &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;timestamp&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//附加数据 &nbsp;&nbsp; &nbsp;Extra &nbsp; &nbsp; &nbsp; []byte &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;extraData&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//一个哈希值，用NONCE组合用于计算工作量 &nbsp;&nbsp; &nbsp;MixDigest &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;mixHash&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//区块产生的随机值，每个用户必须单调步长为1递增 &nbsp;&nbsp; &nbsp;Nonce &nbsp; &nbsp; &nbsp; BlockNonce &nbsp; &nbsp; `json:&quot;nonce&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` } 三者的关系非常明晰，BlockChain 由Block组成，而Header是后者的重要组成部分。 在BlockChain的注释中指出：它是一个标准的以太坊的链数据结构，其内部包含了创世区块及相关数据库的配置,以太坊通过它管理链的插入,恢复,重组等操作. 通过由一系列规则组成的两阶段的验证器来插入一个区块。利用交易处理器对区块中的交易进行处理并利用验证器进行验证，一旦错误将导致上链的失败。 需要注意的是GetBlock函数可能得到任何当前链中的块,但是使用GetBlockByNumber函数却一直得到当前主链中的区块。 二、以太坊的存储模型 以太坊的存储分三层： 上层：业务数据 中层：MPT缓存 底层：LEVELDB 结合到实际的代码中： type StateDB struct { &nbsp;&nbsp; &nbsp;db &nbsp; Database&nbsp; &nbsp;&nbsp; &nbsp;trie Trie &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp;&nbsp; &nbsp;stateObjects &nbsp; &nbsp; &nbsp;map[common.Address]*stateObject &nbsp; //顶层业务 &nbsp;&nbsp; &nbsp;stateObjectsDirty map[common.Address]struct{} …… } type stateObject struct { &nbsp;&nbsp; &nbsp;address &nbsp;common.Address &nbsp;&nbsp; &nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp;&nbsp; &nbsp;data &nbsp; &nbsp; Account &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp; *StateDB &nbsp;&nbsp; &nbsp;// DB error. &nbsp;&nbsp; &nbsp;// State objects are used by the consensus core and VM which are &nbsp;&nbsp; &nbsp;// unable to deal with database-level errors. Any error that occurs &nbsp;&nbsp; &nbsp;// during a database read is memoized here and will eventually be returned &nbsp;&nbsp; &nbsp;// by StateDB.Commit. &nbsp;&nbsp; &nbsp;dbErr error &nbsp;&nbsp; &nbsp;// Write caches.缓存 &nbsp;&nbsp; &nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp; &nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp;&nbsp; &nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp; &nbsp;dirtyStorage &nbsp;Storage // Storage entries that need to be flushed to disk &nbsp;&nbsp; &nbsp;// Cache flags. &nbsp;&nbsp; &nbsp;// When an object is marked suicided it will be delete from the trie &nbsp;&nbsp; &nbsp;// during the &quot;update&quot; phase of the state transition. &nbsp;&nbsp; &nbsp;dirtyCode bool // true if the code was updated &nbsp;&nbsp; &nbsp;suicided &nbsp;bool &nbsp;&nbsp; &nbsp;touched &nbsp; bool &nbsp;&nbsp; &nbsp;deleted &nbsp; bool &nbsp;&nbsp; &nbsp;onDirty &nbsp; func(addr common.Address) // Callback method to mark a state object newly dirty } 最终在 CommitTire实现写入数据LEVELDB。 三、区块的存储 区块的存储在以太坊中是通过leveldb实现的，leveldb是一个kv型数据库，支持高速写入。 在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。 头（Header）的存储格式为： &nbsp; &nbsp; headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) key是由header的前缀，Number和区块hash构成。value是header的RLP编码。 区块体（Body）的存储格式为： &nbsp; &nbsp; bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) key是由body前缀，Number和区块hash构成。value是区块体的RLP编码。 看一下database_util.go中的定义的变量： var ( &nbsp;&nbsp; &nbsp;headHeaderKey = []byte(&quot;LastHeader&quot;) &nbsp;&nbsp; &nbsp;headBlockKey &nbsp;= []byte(&quot;LastBlock&quot;) &nbsp;&nbsp; &nbsp;headFastKey &nbsp; = []byte(&quot;LastFast&quot;) &nbsp;&nbsp; &nbsp;// Data item prefixes (use single byte to avoid mixing data types, avoid `i`). &nbsp;&nbsp; &nbsp;headerPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;h&quot;) // headerPrefix + num (uint64 big endian) + hash -&gt; header &nbsp;&nbsp; &nbsp;tdSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;t&quot;) // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td &nbsp;&nbsp; &nbsp;numSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = []byte(&quot;n&quot;) // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash &nbsp;&nbsp; &nbsp;blockHashPrefix &nbsp; &nbsp; = []byte(&quot;H&quot;) // blockHashPrefix + hash -&gt; num (uint64 big endian) &nbsp;&nbsp; &nbsp;bodyPrefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;b&quot;) // bodyPrefix + num (uint64 big endian) + hash -&gt; block body &nbsp;&nbsp; &nbsp;blockReceiptsPrefix = []byte(&quot;r&quot;) // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts &nbsp;&nbsp; &nbsp;lookupPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;l&quot;) // lookupPrefix + hash -&gt; transaction/receipt lookup metadata &nbsp;&nbsp; &nbsp;bloomBitsPrefix &nbsp; &nbsp; = []byte(&quot;B&quot;) // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits &nbsp;&nbsp; &nbsp;preimagePrefix = &quot;secure-key-&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// preimagePrefix + hash -&gt; preimage &nbsp;&nbsp; &nbsp;configPrefix &nbsp; = []byte(&quot;ethereum-config-&quot;) // config prefix for the db &nbsp;&nbsp; &nbsp;// Chain index prefixes (use `i` + single byte to avoid mixing data types). &nbsp;&nbsp; &nbsp;BloomBitsIndexPrefix = []byte(&quot;iB&quot;) // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress &nbsp;&nbsp; &nbsp;// used by old db, now only used for conversion &nbsp;&nbsp; &nbsp;oldReceiptsPrefix = []byte(&quot;receipts-&quot;) &nbsp;&nbsp; &nbsp;oldTxMetaSuffix &nbsp; = []byte{0x01} &nbsp;&nbsp; &nbsp;ErrChainConfigNotFound = errors.New(&quot;ChainConfig not found&quot;) // general config not found error &nbsp;&nbsp; &nbsp;preimageCounter &nbsp; &nbsp;= metrics.NewCounter(&quot;db/preimage/total&quot;) &nbsp;&nbsp; &nbsp;preimageHitCounter = metrics.NewCounter(&quot;db/preimage/hits&quot;) ) 这些前缀用来表明是什么样的数据类型。下面看一下具体的存储，在core/database_util.go中封装了区块存储和读取相关的代码。 // DatabaseReader wraps the Get method of a backing data store. type DatabaseReader interface { &nbsp;&nbsp; &nbsp;Get(key []byte) (value []byte, err error) } // DatabaseDeleter wraps the Delete method of a backing data store. type DatabaseDeleter interface { &nbsp;&nbsp; &nbsp;Delete(key []byte) error } 写入区块： // WriteBlock serializes a block into the database, header and body separately. func WriteBlock(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Store the body first to retain database consistency &nbsp;&nbsp; &nbsp;if err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Store the header too, signaling full block ownership &nbsp;&nbsp; &nbsp;if err := WriteHeader(db, block.Header()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 下面是写区块调用的两个函数： // WriteHeader serializes a block header into the database. func WriteHeader(db ethdb.Putter, header *types.Header) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(header) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;hash := header.Hash().Bytes() &nbsp;&nbsp; &nbsp;num := header.Number.Uint64() &nbsp;&nbsp; &nbsp;encNum := encodeBlockNumber(num) &nbsp;&nbsp; &nbsp;key := append(blockHashPrefix, hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store hash to number mapping&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store header&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } // WriteBody serializes the body of a block into the database. func WriteBody(db ethdb.Putter, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(body) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return WriteBodyRLP(db, hash, number, data) } 分为了写头和写区块体两部分。首先对区块头进行了RLP编码，然后将Number转换成为byte格式，然后拼装key。 这个过程中要先存储了hash-&gt;Number的值，然后才将区块头的数据写入数据库。 区块体类似，RLP编码，拼装KEY。 再分析一下交易的存储： 目前的以太坊交易在数据库中仅存储交易的元数据： // TxLookupEntry is a positional metadata to help looking up the data content of // a transaction or receipt given only its hash. type TxLookupEntry struct { &nbsp;&nbsp; &nbsp;BlockHash &nbsp;common.Hash &nbsp;&nbsp; &nbsp;BlockIndex uint64 &nbsp;&nbsp; &nbsp;Index &nbsp; &nbsp; &nbsp;uint64 } 存储的KV对应为： txHash(交易哈希)+txMetaSuffix(前缀)-&gt;rlpEncode(txMeta)(元数据编码) 写入函数： // WriteTxLookupEntries stores a positional metadata for every transaction from // a block, enabling hash based transaction and receipt lookups. func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Iterate over each transaction and encode its metadata &nbsp;&nbsp; &nbsp;for i, tx := range block.Transactions() { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entry := TxLookupEntry{ &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockHash: &nbsp;block.Hash(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Index: &nbsp; &nbsp; &nbsp;uint64(i), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(entry) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 遍历交易，构造元数据，RLP编码，然后就可以入库了。 读取代码如下： // GetTransaction retrieves a specific transaction from the database, along with // its added positional metadata. func GetTransaction(db DatabaseReader, hash common.Hash) (*types.Transaction, common.Hash, uint64, uint64) { &nbsp;&nbsp; &nbsp;// Retrieve the lookup metadata and resolve the transaction from the body &nbsp;&nbsp; &nbsp;blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash) &nbsp;&nbsp; &nbsp;if blockHash != (common.Hash{}) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;body := GetBody(db, blockHash, blockNumber) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if body == nil || len(body.Transactions) &lt;= int(txIndex) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Error(&quot;Transaction referenced missing&quot;, &quot;number&quot;, blockNumber, &quot;hash&quot;, blockHash, &quot;index&quot;, txIndex) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return body.Transactions[txIndex], blockHash, blockNumber, txIndex &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Old transaction representation, load the transaction and it&#39;s metadata separately &nbsp;&nbsp; &nbsp;data, _ := db.Get(hash.Bytes()) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var tx types.Transaction &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;tx); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Retrieve the blockchain positional metadata &nbsp;&nbsp; &nbsp;data, _ = db.Get(append(hash.Bytes(), oldTxMetaSuffix...)) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var entry TxLookupEntry &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;entry); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return &amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index } 先通过交易哈希得到元数据入口，再查找块哈希，然后从块上找到交易的具体信息返回，或者如果是老的版本，则处理一下再返回。 也就是说，这个函数支持新旧两个版本的交易查询。 这样区块也就基本分析完成了。 如果对区块链和c++感兴趣，欢迎关注： 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/fpcc/article/details/81583064 以太坊源码分析之九区块 终于到了区块链中最和区块链搭界的部分，毕竟它们只差一个字。区块是区块链的基础，区块通过HASH链接在一起就成为了区块链。 一、区块的相关数据结构 不当嘴炮党，看源码： 链数据结构： type BlockChain struct { &nbsp;&nbsp; &nbsp;chainConfig *params.ChainConfig // Chain &amp; network configuration &nbsp;&nbsp; &nbsp;cacheConfig *CacheConfig &nbsp; &nbsp; &nbsp; &nbsp;// Cache configuration for pruning &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; ethdb.Database // Low level persistent database to store final content in &nbsp;&nbsp; &nbsp;triegc *prque.Prque &nbsp; // Priority queue mapping block numbers to tries to gc &nbsp;&nbsp; &nbsp;gcproc time.Duration &nbsp;// Accumulates canonical block processing for trie dumping &nbsp;&nbsp; &nbsp;hc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*HeaderChain &nbsp;//只有头的链，用于验证和快速下载 &nbsp;&nbsp; &nbsp;//其下为消息订阅的一系列事件 rmLogsFeed &nbsp; &nbsp;event.Feed &nbsp; &nbsp;//其下为消息订阅的一系列事件，删除日志 &nbsp;&nbsp; &nbsp;chainFeed &nbsp; &nbsp; event.Feed &nbsp; &nbsp;//主链事件 &nbsp;&nbsp; &nbsp;chainSideFeed event.Feed &nbsp; &nbsp; &nbsp;//侧链事件 &nbsp;&nbsp; &nbsp;chainHeadFeed event.Feed &nbsp; &nbsp; // 主链头事件 &nbsp;&nbsp; &nbsp;logsFeed &nbsp; &nbsp; &nbsp;event.Feed &nbsp;&nbsp; &nbsp;scope &nbsp; &nbsp; &nbsp; &nbsp; event.SubscriptionScope &nbsp;&nbsp; &nbsp;genesisBlock &nbsp;*types.Block &nbsp; //创世块 &nbsp;&nbsp; &nbsp;mu &nbsp; &nbsp; &nbsp;sync.RWMutex // global mutex for locking chain operations &nbsp;&nbsp; &nbsp;chainmu sync.RWMutex // blockchain insertion lock &nbsp;&nbsp; &nbsp;procmu &nbsp;sync.RWMutex // block processor lock &nbsp;&nbsp; &nbsp;checkpoint &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// checkpoint counts towards the new checkpoint &nbsp;&nbsp; &nbsp;currentBlock &nbsp; &nbsp; *types.Block // Current head of the block chain &nbsp;&nbsp; &nbsp;currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) &nbsp;&nbsp; &nbsp;stateCache &nbsp; state.Database // State database to reuse between imports (contains state cache) &nbsp;&nbsp; &nbsp;bodyCache &nbsp; &nbsp;*lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies &nbsp;&nbsp; &nbsp;bodyRLPCache *lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies in RLP encoded format &nbsp;&nbsp; &nbsp;blockCache &nbsp; *lru.Cache &nbsp; &nbsp; // Cache for the most recent entire blocks &nbsp;&nbsp; &nbsp;futureBlocks *lru.Cache &nbsp; &nbsp; // future blocks are blocks added for later processing &nbsp;&nbsp; &nbsp;quit &nbsp; &nbsp;chan struct{} // blockchain quit channel &nbsp;&nbsp; &nbsp;running int32 &nbsp; &nbsp; &nbsp; &nbsp; // running must be called atomically &nbsp;&nbsp; &nbsp;// procInterrupt must be atomically called &nbsp;&nbsp; &nbsp;procInterrupt int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// interrupt signaler for block processing &nbsp;&nbsp; &nbsp;wg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sync.WaitGroup // chain processing wait group for shutting down &nbsp;&nbsp; &nbsp;engine &nbsp; &nbsp;consensus.Engine &nbsp;&nbsp; &nbsp;processor Processor // block processor interface &nbsp;&nbsp; &nbsp;validator Validator // block and state validator interface &nbsp;&nbsp; &nbsp;vmConfig &nbsp;vm.Config &nbsp;&nbsp; &nbsp;badBlocks *lru.Cache // Bad block cache } 块数据结构： // Block represents an entire block in the Ethereum blockchain. type Block struct { &nbsp;&nbsp; &nbsp;header &nbsp; &nbsp; &nbsp; *Header &nbsp;&nbsp; &nbsp;uncles &nbsp; &nbsp; &nbsp; []*Header &nbsp;//叔块的头，叔块最多有两个 &nbsp;&nbsp; &nbsp;transactions Transactions &nbsp;&nbsp; &nbsp;// caches &nbsp;&nbsp; &nbsp;hash atomic.Value &nbsp;&nbsp; &nbsp;size atomic.Value &nbsp;&nbsp; &nbsp;// Td is used by package core to store the total difficulty &nbsp;&nbsp; &nbsp;// of the chain up to and including the block. &nbsp;&nbsp; &nbsp;td *big.Int &nbsp; //难度 &nbsp;&nbsp; &nbsp;// These fields are used by package eth to track &nbsp;&nbsp; &nbsp;// inter-peer block relay. &nbsp;&nbsp; &nbsp;ReceivedAt &nbsp; time.Time &nbsp;&nbsp; &nbsp;ReceivedFrom interface{} } 区块头数据结构： type Header struct { //指向父区块(parentBlock)的hash。除了创世块(Genesis Block)没有父区块，每个区块有且//只有一个父区块。 &nbsp;&nbsp; &nbsp;ParentHash &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;parentHash&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//叔块地址。 UncleHash &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;sha3Uncles&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//出块地址。挖矿和交易都发给这个地址。 Coinbase &nbsp; &nbsp;common.Address `json:&quot;miner&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` //世界状态，状态树的根哈希值—三大树 &nbsp;&nbsp; &nbsp;Root &nbsp; &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;stateRoot&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易树根哈希值&nbsp; &nbsp;&nbsp; &nbsp;TxHash &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//接收者树的的根哈希值 &nbsp;&nbsp; &nbsp;ReceiptHash common.Hash &nbsp; &nbsp;`json:&quot;receiptsRoot&quot; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//交易收据日志组成的布隆过滤器 &nbsp;&nbsp; &nbsp;Bloom &nbsp; &nbsp; &nbsp; Bloom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`json:&quot;logsBloom&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块难度 &nbsp;&nbsp; &nbsp;Difficulty &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;difficulty&quot; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//块号 &nbsp;&nbsp; &nbsp;Number &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;number&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块Gas上限 &nbsp;&nbsp; &nbsp;GasLimit &nbsp; &nbsp;uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasLimit&quot; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//Gas使用量 &nbsp;&nbsp; &nbsp;GasUsed &nbsp; &nbsp; uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;gasUsed&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//本块的产生时间戳 &nbsp;&nbsp; &nbsp;Time &nbsp; &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:&quot;timestamp&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//附加数据 &nbsp;&nbsp; &nbsp;Extra &nbsp; &nbsp; &nbsp; []byte &nbsp; &nbsp; &nbsp; &nbsp; `json:&quot;extraData&quot; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//一个哈希值，用NONCE组合用于计算工作量 &nbsp;&nbsp; &nbsp;MixDigest &nbsp; common.Hash &nbsp; &nbsp;`json:&quot;mixHash&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` &nbsp;&nbsp; &nbsp;//区块产生的随机值，每个用户必须单调步长为1递增 &nbsp;&nbsp; &nbsp;Nonce &nbsp; &nbsp; &nbsp; BlockNonce &nbsp; &nbsp; `json:&quot;nonce&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:&quot;required&quot;` } 三者的关系非常明晰，BlockChain 由Block组成，而Header是后者的重要组成部分。 在BlockChain的注释中指出：它是一个标准的以太坊的链数据结构，其内部包含了创世区块及相关数据库的配置,以太坊通过它管理链的插入,恢复,重组等操作. 通过由一系列规则组成的两阶段的验证器来插入一个区块。利用交易处理器对区块中的交易进行处理并利用验证器进行验证，一旦错误将导致上链的失败。 需要注意的是GetBlock函数可能得到任何当前链中的块,但是使用GetBlockByNumber函数却一直得到当前主链中的区块。 二、以太坊的存储模型 以太坊的存储分三层： 上层：业务数据 中层：MPT缓存 底层：LEVELDB 结合到实际的代码中： type StateDB struct { &nbsp;&nbsp; &nbsp;db &nbsp; Database&nbsp; &nbsp;&nbsp; &nbsp;trie Trie &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// This map holds &#39;live&#39; objects, which will get modified while processing a state transition. &nbsp;&nbsp; &nbsp;stateObjects &nbsp; &nbsp; &nbsp;map[common.Address]*stateObject &nbsp; //顶层业务 &nbsp;&nbsp; &nbsp;stateObjectsDirty map[common.Address]struct{} …… } type stateObject struct { &nbsp;&nbsp; &nbsp;address &nbsp;common.Address &nbsp;&nbsp; &nbsp;addrHash common.Hash // hash of ethereum address of the account &nbsp;&nbsp; &nbsp;data &nbsp; &nbsp; Account &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp; *StateDB &nbsp;&nbsp; &nbsp;// DB error. &nbsp;&nbsp; &nbsp;// State objects are used by the consensus core and VM which are &nbsp;&nbsp; &nbsp;// unable to deal with database-level errors. Any error that occurs &nbsp;&nbsp; &nbsp;// during a database read is memoized here and will eventually be returned &nbsp;&nbsp; &nbsp;// by StateDB.Commit. &nbsp;&nbsp; &nbsp;dbErr error &nbsp;&nbsp; &nbsp;// Write caches.缓存 &nbsp;&nbsp; &nbsp;trie Trie // storage trie, which becomes non-nil on first access &nbsp;&nbsp; &nbsp;code Code // contract bytecode, which gets set when code is loaded &nbsp;&nbsp; &nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads &nbsp;&nbsp; &nbsp;dirtyStorage &nbsp;Storage // Storage entries that need to be flushed to disk &nbsp;&nbsp; &nbsp;// Cache flags. &nbsp;&nbsp; &nbsp;// When an object is marked suicided it will be delete from the trie &nbsp;&nbsp; &nbsp;// during the &quot;update&quot; phase of the state transition. &nbsp;&nbsp; &nbsp;dirtyCode bool // true if the code was updated &nbsp;&nbsp; &nbsp;suicided &nbsp;bool &nbsp;&nbsp; &nbsp;touched &nbsp; bool &nbsp;&nbsp; &nbsp;deleted &nbsp; bool &nbsp;&nbsp; &nbsp;onDirty &nbsp; func(addr common.Address) // Callback method to mark a state object newly dirty } 最终在 CommitTire实现写入数据LEVELDB。 三、区块的存储 区块的存储在以太坊中是通过leveldb实现的，leveldb是一个kv型数据库，支持高速写入。 在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。 头（Header）的存储格式为： &nbsp; &nbsp; headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header) key是由header的前缀，Number和区块hash构成。value是header的RLP编码。 区块体（Body）的存储格式为： &nbsp; &nbsp; bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body) key是由body前缀，Number和区块hash构成。value是区块体的RLP编码。 看一下database_util.go中的定义的变量： var ( &nbsp;&nbsp; &nbsp;headHeaderKey = []byte(&quot;LastHeader&quot;) &nbsp;&nbsp; &nbsp;headBlockKey &nbsp;= []byte(&quot;LastBlock&quot;) &nbsp;&nbsp; &nbsp;headFastKey &nbsp; = []byte(&quot;LastFast&quot;) &nbsp;&nbsp; &nbsp;// Data item prefixes (use single byte to avoid mixing data types, avoid `i`). &nbsp;&nbsp; &nbsp;headerPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;h&quot;) // headerPrefix + num (uint64 big endian) + hash -&gt; header &nbsp;&nbsp; &nbsp;tdSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;t&quot;) // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td &nbsp;&nbsp; &nbsp;numSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = []byte(&quot;n&quot;) // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash &nbsp;&nbsp; &nbsp;blockHashPrefix &nbsp; &nbsp; = []byte(&quot;H&quot;) // blockHashPrefix + hash -&gt; num (uint64 big endian) &nbsp;&nbsp; &nbsp;bodyPrefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;b&quot;) // bodyPrefix + num (uint64 big endian) + hash -&gt; block body &nbsp;&nbsp; &nbsp;blockReceiptsPrefix = []byte(&quot;r&quot;) // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts &nbsp;&nbsp; &nbsp;lookupPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte(&quot;l&quot;) // lookupPrefix + hash -&gt; transaction/receipt lookup metadata &nbsp;&nbsp; &nbsp;bloomBitsPrefix &nbsp; &nbsp; = []byte(&quot;B&quot;) // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits &nbsp;&nbsp; &nbsp;preimagePrefix = &quot;secure-key-&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// preimagePrefix + hash -&gt; preimage &nbsp;&nbsp; &nbsp;configPrefix &nbsp; = []byte(&quot;ethereum-config-&quot;) // config prefix for the db &nbsp;&nbsp; &nbsp;// Chain index prefixes (use `i` + single byte to avoid mixing data types). &nbsp;&nbsp; &nbsp;BloomBitsIndexPrefix = []byte(&quot;iB&quot;) // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress &nbsp;&nbsp; &nbsp;// used by old db, now only used for conversion &nbsp;&nbsp; &nbsp;oldReceiptsPrefix = []byte(&quot;receipts-&quot;) &nbsp;&nbsp; &nbsp;oldTxMetaSuffix &nbsp; = []byte{0x01} &nbsp;&nbsp; &nbsp;ErrChainConfigNotFound = errors.New(&quot;ChainConfig not found&quot;) // general config not found error &nbsp;&nbsp; &nbsp;preimageCounter &nbsp; &nbsp;= metrics.NewCounter(&quot;db/preimage/total&quot;) &nbsp;&nbsp; &nbsp;preimageHitCounter = metrics.NewCounter(&quot;db/preimage/hits&quot;) ) 这些前缀用来表明是什么样的数据类型。下面看一下具体的存储，在core/database_util.go中封装了区块存储和读取相关的代码。 // DatabaseReader wraps the Get method of a backing data store. type DatabaseReader interface { &nbsp;&nbsp; &nbsp;Get(key []byte) (value []byte, err error) } // DatabaseDeleter wraps the Delete method of a backing data store. type DatabaseDeleter interface { &nbsp;&nbsp; &nbsp;Delete(key []byte) error } 写入区块： // WriteBlock serializes a block into the database, header and body separately. func WriteBlock(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Store the body first to retain database consistency &nbsp;&nbsp; &nbsp;if err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Store the header too, signaling full block ownership &nbsp;&nbsp; &nbsp;if err := WriteHeader(db, block.Header()); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 下面是写区块调用的两个函数： // WriteHeader serializes a block header into the database. func WriteHeader(db ethdb.Putter, header *types.Header) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(header) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;hash := header.Hash().Bytes() &nbsp;&nbsp; &nbsp;num := header.Number.Uint64() &nbsp;&nbsp; &nbsp;encNum := encodeBlockNumber(num) &nbsp;&nbsp; &nbsp;key := append(blockHashPrefix, hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, encNum); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store hash to number mapping&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;key = append(append(headerPrefix, encNum...), hash...) &nbsp;&nbsp; &nbsp;if err := db.Put(key, data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit(&quot;Failed to store header&quot;, &quot;err&quot;, err) &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } // WriteBody serializes the body of a block into the database. func WriteBody(db ethdb.Putter, hash common.Hash, number uint64, body *types.Body) error { &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(body) &nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return WriteBodyRLP(db, hash, number, data) } 分为了写头和写区块体两部分。首先对区块头进行了RLP编码，然后将Number转换成为byte格式，然后拼装key。 这个过程中要先存储了hash-&gt;Number的值，然后才将区块头的数据写入数据库。 区块体类似，RLP编码，拼装KEY。 再分析一下交易的存储： 目前的以太坊交易在数据库中仅存储交易的元数据： // TxLookupEntry is a positional metadata to help looking up the data content of // a transaction or receipt given only its hash. type TxLookupEntry struct { &nbsp;&nbsp; &nbsp;BlockHash &nbsp;common.Hash &nbsp;&nbsp; &nbsp;BlockIndex uint64 &nbsp;&nbsp; &nbsp;Index &nbsp; &nbsp; &nbsp;uint64 } 存储的KV对应为： txHash(交易哈希)+txMetaSuffix(前缀)-&gt;rlpEncode(txMeta)(元数据编码) 写入函数： // WriteTxLookupEntries stores a positional metadata for every transaction from // a block, enabling hash based transaction and receipt lookups. func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error { &nbsp;&nbsp; &nbsp;// Iterate over each transaction and encode its metadata &nbsp;&nbsp; &nbsp;for i, tx := range block.Transactions() { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entry := TxLookupEntry{ &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockHash: &nbsp;block.Hash(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockIndex: block.NumberU64(), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Index: &nbsp; &nbsp; &nbsp;uint64(i), &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(entry) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return nil } 遍历交易，构造元数据，RLP编码，然后就可以入库了。 读取代码如下： // GetTransaction retrieves a specific transaction from the database, along with // its added positional metadata. func GetTransaction(db DatabaseReader, hash common.Hash) (*types.Transaction, common.Hash, uint64, uint64) { &nbsp;&nbsp; &nbsp;// Retrieve the lookup metadata and resolve the transaction from the body &nbsp;&nbsp; &nbsp;blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash) &nbsp;&nbsp; &nbsp;if blockHash != (common.Hash{}) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;body := GetBody(db, blockHash, blockNumber) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if body == nil || len(body.Transactions) &lt;= int(txIndex) { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Error(&quot;Transaction referenced missing&quot;, &quot;number&quot;, blockNumber, &quot;hash&quot;, blockHash, &quot;index&quot;, txIndex) &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return body.Transactions[txIndex], blockHash, blockNumber, txIndex &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Old transaction representation, load the transaction and it&#39;s metadata separately &nbsp;&nbsp; &nbsp;data, _ := db.Get(hash.Bytes()) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var tx types.Transaction &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;tx); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;// Retrieve the blockchain positional metadata &nbsp;&nbsp; &nbsp;data, _ = db.Get(append(hash.Bytes(), oldTxMetaSuffix...)) &nbsp;&nbsp; &nbsp;if len(data) == 0 { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;var entry TxLookupEntry &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;entry); err != nil { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0 &nbsp;&nbsp; &nbsp;} &nbsp;&nbsp; &nbsp;return &amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index } 先通过交易哈希得到元数据入口，再查找块哈希，然后从块上找到交易的具体信息返回，或者如果是老的版本，则处理一下再返回。 也就是说，这个函数支持新旧两个版本的交易查询。 这样区块也就基本分析完成了。 如果对区块链和c++感兴趣，欢迎关注： 阅读更多","@type":"BlogPosting","url":"/2018/08/11/1c3f235b6641f25b4fce65fd3b07db12.html","headline":"以太坊源码分析之九区块","dateModified":"2018-08-11T00:00:00+08:00","datePublished":"2018-08-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/11/1c3f235b6641f25b4fce65fd3b07db12.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码分析之九区块</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/fpcc/article/details/81583064 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>以太坊源码分析之九区块<br> 终于到了区块链中最和区块链搭界的部分，毕竟它们只差一个字。区块是区块链的基础，区块通过HASH链接在一起就成为了区块链。<br> 一、区块的相关数据结构<br> 不当嘴炮党，看源码：<br> 链数据结构：<br> type BlockChain struct {<br> &nbsp;&nbsp; &nbsp;chainConfig *params.ChainConfig // Chain &amp; network configuration<br> &nbsp;&nbsp; &nbsp;cacheConfig *CacheConfig &nbsp; &nbsp; &nbsp; &nbsp;// Cache configuration for pruning</p> 
  <p>&nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; ethdb.Database // Low level persistent database to store final content in<br> &nbsp;&nbsp; &nbsp;triegc *prque.Prque &nbsp; // Priority queue mapping block numbers to tries to gc<br> &nbsp;&nbsp; &nbsp;gcproc time.Duration &nbsp;// Accumulates canonical block processing for trie dumping</p> 
  <p>&nbsp;&nbsp; &nbsp;hc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*HeaderChain &nbsp;//只有头的链，用于验证和快速下载<br> &nbsp;&nbsp; &nbsp;//其下为消息订阅的一系列事件<br> rmLogsFeed &nbsp; &nbsp;event.Feed &nbsp; &nbsp;//其下为消息订阅的一系列事件，删除日志<br> &nbsp;&nbsp; &nbsp;chainFeed &nbsp; &nbsp; event.Feed &nbsp; &nbsp;//主链事件<br> &nbsp;&nbsp; &nbsp;chainSideFeed event.Feed &nbsp; &nbsp; &nbsp;//侧链事件<br> &nbsp;&nbsp; &nbsp;chainHeadFeed event.Feed &nbsp; &nbsp; // 主链头事件<br> &nbsp;&nbsp; &nbsp;logsFeed &nbsp; &nbsp; &nbsp;event.Feed<br> &nbsp;&nbsp; &nbsp;scope &nbsp; &nbsp; &nbsp; &nbsp; event.SubscriptionScope<br> &nbsp;&nbsp; &nbsp;genesisBlock &nbsp;*types.Block &nbsp; //创世块</p> 
  <p>&nbsp;&nbsp; &nbsp;mu &nbsp; &nbsp; &nbsp;sync.RWMutex // global mutex for locking chain operations<br> &nbsp;&nbsp; &nbsp;chainmu sync.RWMutex // blockchain insertion lock<br> &nbsp;&nbsp; &nbsp;procmu &nbsp;sync.RWMutex // block processor lock</p> 
  <p>&nbsp;&nbsp; &nbsp;checkpoint &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// checkpoint counts towards the new checkpoint<br> &nbsp;&nbsp; &nbsp;currentBlock &nbsp; &nbsp; *types.Block // Current head of the block chain<br> &nbsp;&nbsp; &nbsp;currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!)</p> 
  <p>&nbsp;&nbsp; &nbsp;stateCache &nbsp; state.Database // State database to reuse between imports (contains state cache)<br> &nbsp;&nbsp; &nbsp;bodyCache &nbsp; &nbsp;*lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies<br> &nbsp;&nbsp; &nbsp;bodyRLPCache *lru.Cache &nbsp; &nbsp; // Cache for the most recent block bodies in RLP encoded format<br> &nbsp;&nbsp; &nbsp;blockCache &nbsp; *lru.Cache &nbsp; &nbsp; // Cache for the most recent entire blocks<br> &nbsp;&nbsp; &nbsp;futureBlocks *lru.Cache &nbsp; &nbsp; // future blocks are blocks added for later processing</p> 
  <p>&nbsp;&nbsp; &nbsp;quit &nbsp; &nbsp;chan struct{} // blockchain quit channel<br> &nbsp;&nbsp; &nbsp;running int32 &nbsp; &nbsp; &nbsp; &nbsp; // running must be called atomically<br> &nbsp;&nbsp; &nbsp;// procInterrupt must be atomically called<br> &nbsp;&nbsp; &nbsp;procInterrupt int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// interrupt signaler for block processing<br> &nbsp;&nbsp; &nbsp;wg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sync.WaitGroup // chain processing wait group for shutting down</p> 
  <p>&nbsp;&nbsp; &nbsp;engine &nbsp; &nbsp;consensus.Engine<br> &nbsp;&nbsp; &nbsp;processor Processor // block processor interface<br> &nbsp;&nbsp; &nbsp;validator Validator // block and state validator interface<br> &nbsp;&nbsp; &nbsp;vmConfig &nbsp;vm.Config</p> 
  <p>&nbsp;&nbsp; &nbsp;badBlocks *lru.Cache // Bad block cache<br> }<br> 块数据结构：<br> // Block represents an entire block in the Ethereum blockchain.<br> type Block struct {<br> &nbsp;&nbsp; &nbsp;header &nbsp; &nbsp; &nbsp; *Header<br> &nbsp;&nbsp; &nbsp;uncles &nbsp; &nbsp; &nbsp; []*Header &nbsp;//叔块的头，叔块最多有两个<br> &nbsp;&nbsp; &nbsp;transactions Transactions</p> 
  <p>&nbsp;&nbsp; &nbsp;// caches<br> &nbsp;&nbsp; &nbsp;hash atomic.Value<br> &nbsp;&nbsp; &nbsp;size atomic.Value</p> 
  <p>&nbsp;&nbsp; &nbsp;// Td is used by package core to store the total difficulty<br> &nbsp;&nbsp; &nbsp;// of the chain up to and including the block.<br> &nbsp;&nbsp; &nbsp;td *big.Int &nbsp; //难度</p> 
  <p>&nbsp;&nbsp; &nbsp;// These fields are used by package eth to track<br> &nbsp;&nbsp; &nbsp;// inter-peer block relay.<br> &nbsp;&nbsp; &nbsp;ReceivedAt &nbsp; time.Time<br> &nbsp;&nbsp; &nbsp;ReceivedFrom interface{}<br> }<br> 区块头数据结构：<br> type Header struct {<br> //指向父区块(parentBlock)的hash。除了创世块(Genesis Block)没有父区块，每个区块有且//只有一个父区块。<br> &nbsp;&nbsp; &nbsp;ParentHash &nbsp;common.Hash &nbsp; &nbsp;`json:"parentHash" &nbsp; &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//叔块地址。<br> UncleHash &nbsp; common.Hash &nbsp; &nbsp;`json:"sha3Uncles" &nbsp; &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//出块地址。挖矿和交易都发给这个地址。<br> Coinbase &nbsp; &nbsp;common.Address `json:"miner" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> //世界状态，状态树的根哈希值—三大树<br> &nbsp;&nbsp; &nbsp;Root &nbsp; &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:"stateRoot" &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//交易树根哈希值&nbsp;<br> &nbsp;&nbsp; &nbsp;TxHash &nbsp; &nbsp; &nbsp;common.Hash &nbsp; &nbsp;`json:"transactionsRoot" gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//接收者树的的根哈希值<br> &nbsp;&nbsp; &nbsp;ReceiptHash common.Hash &nbsp; &nbsp;`json:"receiptsRoot" &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//交易收据日志组成的布隆过滤器<br> &nbsp;&nbsp; &nbsp;Bloom &nbsp; &nbsp; &nbsp; Bloom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`json:"logsBloom" &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//本块难度<br> &nbsp;&nbsp; &nbsp;Difficulty &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:"difficulty" &nbsp; &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//块号<br> &nbsp;&nbsp; &nbsp;Number &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:"number" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//本块Gas上限<br> &nbsp;&nbsp; &nbsp;GasLimit &nbsp; &nbsp;uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:"gasLimit" &nbsp; &nbsp; &nbsp; &nbsp; gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//Gas使用量<br> &nbsp;&nbsp; &nbsp;GasUsed &nbsp; &nbsp; uint64 &nbsp; &nbsp; &nbsp; &nbsp; `json:"gasUsed" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//本块的产生时间戳<br> &nbsp;&nbsp; &nbsp;Time &nbsp; &nbsp; &nbsp; &nbsp;*big.Int &nbsp; &nbsp; &nbsp; `json:"timestamp" &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//附加数据<br> &nbsp;&nbsp; &nbsp;Extra &nbsp; &nbsp; &nbsp; []byte &nbsp; &nbsp; &nbsp; &nbsp; `json:"extraData" &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//一个哈希值，用NONCE组合用于计算工作量<br> &nbsp;&nbsp; &nbsp;MixDigest &nbsp; common.Hash &nbsp; &nbsp;`json:"mixHash" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> &nbsp;&nbsp; &nbsp;//区块产生的随机值，每个用户必须单调步长为1递增<br> &nbsp;&nbsp; &nbsp;Nonce &nbsp; &nbsp; &nbsp; BlockNonce &nbsp; &nbsp; `json:"nonce" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gencodec:"required"`<br> }</p> 
  <p>三者的关系非常明晰，BlockChain 由Block组成，而Header是后者的重要组成部分。<br> 在BlockChain的注释中指出：它是一个标准的以太坊的链数据结构，其内部包含了创世区块及相关数据库的配置,以太坊通过它管理链的插入,恢复,重组等操作.<br> 通过由一系列规则组成的两阶段的验证器来插入一个区块。利用交易处理器对区块中的交易进行处理并利用验证器进行验证，一旦错误将导致上链的失败。<br> 需要注意的是GetBlock函数可能得到任何当前链中的块,但是使用GetBlockByNumber函数却一直得到当前主链中的区块。<br><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180811091216966?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZwY2M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>二、以太坊的存储模型<br> 以太坊的存储分三层：<br> 上层：业务数据<br> 中层：MPT缓存<br> 底层：LEVELDB<br> 结合到实际的代码中：<br> type StateDB struct {<br> &nbsp;&nbsp; &nbsp;db &nbsp; Database&nbsp;<br> &nbsp;&nbsp; &nbsp;trie Trie &nbsp;&nbsp;</p> 
  <p>&nbsp;&nbsp; &nbsp;// This map holds 'live' objects, which will get modified while processing a state transition.<br> &nbsp;&nbsp; &nbsp;stateObjects &nbsp; &nbsp; &nbsp;map[common.Address]*stateObject &nbsp; //顶层业务<br> &nbsp;&nbsp; &nbsp;stateObjectsDirty map[common.Address]struct{}</p> 
  <p>……<br> }<br> type stateObject struct {<br> &nbsp;&nbsp; &nbsp;address &nbsp;common.Address<br> &nbsp;&nbsp; &nbsp;addrHash common.Hash // hash of ethereum address of the account<br> &nbsp;&nbsp; &nbsp;data &nbsp; &nbsp; Account<br> &nbsp;&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp; *StateDB</p> 
  <p>&nbsp;&nbsp; &nbsp;// DB error.<br> &nbsp;&nbsp; &nbsp;// State objects are used by the consensus core and VM which are<br> &nbsp;&nbsp; &nbsp;// unable to deal with database-level errors. Any error that occurs<br> &nbsp;&nbsp; &nbsp;// during a database read is memoized here and will eventually be returned<br> &nbsp;&nbsp; &nbsp;// by StateDB.Commit.<br> &nbsp;&nbsp; &nbsp;dbErr error</p> 
  <p>&nbsp;&nbsp; &nbsp;// Write caches.缓存<br> &nbsp;&nbsp; &nbsp;trie Trie // storage trie, which becomes non-nil on first access<br> &nbsp;&nbsp; &nbsp;code Code // contract bytecode, which gets set when code is loaded</p> 
  <p>&nbsp;&nbsp; &nbsp;cachedStorage Storage // Storage entry cache to avoid duplicate reads<br> &nbsp;&nbsp; &nbsp;dirtyStorage &nbsp;Storage // Storage entries that need to be flushed to disk</p> 
  <p>&nbsp;&nbsp; &nbsp;// Cache flags.<br> &nbsp;&nbsp; &nbsp;// When an object is marked suicided it will be delete from the trie<br> &nbsp;&nbsp; &nbsp;// during the "update" phase of the state transition.<br> &nbsp;&nbsp; &nbsp;dirtyCode bool // true if the code was updated<br> &nbsp;&nbsp; &nbsp;suicided &nbsp;bool<br> &nbsp;&nbsp; &nbsp;touched &nbsp; bool<br> &nbsp;&nbsp; &nbsp;deleted &nbsp; bool<br> &nbsp;&nbsp; &nbsp;onDirty &nbsp; func(addr common.Address) // Callback method to mark a state object newly dirty<br> }<br> 最终在 CommitTire实现写入数据LEVELDB。</p> 
  <p>三、区块的存储<br> 区块的存储在以太坊中是通过leveldb实现的，leveldb是一个kv型数据库，支持高速写入。<br> 在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。<br> 头（Header）的存储格式为：<br> &nbsp; &nbsp; headerPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(header)<br> key是由header的前缀，Number和区块hash构成。value是header的RLP编码。<br> 区块体（Body）的存储格式为：</p> 
  <p>&nbsp; &nbsp; bodyPrefix + num (uint64 big endian) + hash -&gt; rlpEncode(block body)<br> key是由body前缀，Number和区块hash构成。value是区块体的RLP编码。<br> 看一下database_util.go中的定义的变量：<br> var (<br> &nbsp;&nbsp; &nbsp;headHeaderKey = []byte("LastHeader")<br> &nbsp;&nbsp; &nbsp;headBlockKey &nbsp;= []byte("LastBlock")<br> &nbsp;&nbsp; &nbsp;headFastKey &nbsp; = []byte("LastFast")</p> 
  <p>&nbsp;&nbsp; &nbsp;// Data item prefixes (use single byte to avoid mixing data types, avoid `i`).<br> &nbsp;&nbsp; &nbsp;headerPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte("h") // headerPrefix + num (uint64 big endian) + hash -&gt; header<br> &nbsp;&nbsp; &nbsp;tdSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte("t") // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td<br> &nbsp;&nbsp; &nbsp;numSuffix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = []byte("n") // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash<br> &nbsp;&nbsp; &nbsp;blockHashPrefix &nbsp; &nbsp; = []byte("H") // blockHashPrefix + hash -&gt; num (uint64 big endian)<br> &nbsp;&nbsp; &nbsp;bodyPrefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= []byte("b") // bodyPrefix + num (uint64 big endian) + hash -&gt; block body<br> &nbsp;&nbsp; &nbsp;blockReceiptsPrefix = []byte("r") // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts<br> &nbsp;&nbsp; &nbsp;lookupPrefix &nbsp; &nbsp; &nbsp; &nbsp;= []byte("l") // lookupPrefix + hash -&gt; transaction/receipt lookup metadata<br> &nbsp;&nbsp; &nbsp;bloomBitsPrefix &nbsp; &nbsp; = []byte("B") // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits</p> 
  <p>&nbsp;&nbsp; &nbsp;preimagePrefix = "secure-key-" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// preimagePrefix + hash -&gt; preimage<br> &nbsp;&nbsp; &nbsp;configPrefix &nbsp; = []byte("ethereum-config-") // config prefix for the db</p> 
  <p>&nbsp;&nbsp; &nbsp;// Chain index prefixes (use `i` + single byte to avoid mixing data types).<br> &nbsp;&nbsp; &nbsp;BloomBitsIndexPrefix = []byte("iB") // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress</p> 
  <p>&nbsp;&nbsp; &nbsp;// used by old db, now only used for conversion<br> &nbsp;&nbsp; &nbsp;oldReceiptsPrefix = []byte("receipts-")<br> &nbsp;&nbsp; &nbsp;oldTxMetaSuffix &nbsp; = []byte{0x01}</p> 
  <p>&nbsp;&nbsp; &nbsp;ErrChainConfigNotFound = errors.New("ChainConfig not found") // general config not found error</p> 
  <p>&nbsp;&nbsp; &nbsp;preimageCounter &nbsp; &nbsp;= metrics.NewCounter("db/preimage/total")<br> &nbsp;&nbsp; &nbsp;preimageHitCounter = metrics.NewCounter("db/preimage/hits")<br> )</p> 
  <p>这些前缀用来表明是什么样的数据类型。下面看一下具体的存储，在core/database_util.go中封装了区块存储和读取相关的代码。<br> // DatabaseReader wraps the Get method of a backing data store.<br> type DatabaseReader interface {<br> &nbsp;&nbsp; &nbsp;Get(key []byte) (value []byte, err error)<br> }</p> 
  <p>// DatabaseDeleter wraps the Delete method of a backing data store.<br> type DatabaseDeleter interface {<br> &nbsp;&nbsp; &nbsp;Delete(key []byte) error<br> }<br> 写入区块：<br> // WriteBlock serializes a block into the database, header and body separately.<br> func WriteBlock(db ethdb.Putter, block *types.Block) error {<br> &nbsp;&nbsp; &nbsp;// Store the body first to retain database consistency<br> &nbsp;&nbsp; &nbsp;if err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;// Store the header too, signaling full block ownership<br> &nbsp;&nbsp; &nbsp;if err := WriteHeader(db, block.Header()); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;return nil<br> }<br> 下面是写区块调用的两个函数：<br> // WriteHeader serializes a block header into the database.<br> func WriteHeader(db ethdb.Putter, header *types.Header) error {<br> &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(header)<br> &nbsp;&nbsp; &nbsp;if err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;hash := header.Hash().Bytes()<br> &nbsp;&nbsp; &nbsp;num := header.Number.Uint64()<br> &nbsp;&nbsp; &nbsp;encNum := encodeBlockNumber(num)<br> &nbsp;&nbsp; &nbsp;key := append(blockHashPrefix, hash...)<br> &nbsp;&nbsp; &nbsp;if err := db.Put(key, encNum); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit("Failed to store hash to number mapping", "err", err)<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;key = append(append(headerPrefix, encNum...), hash...)<br> &nbsp;&nbsp; &nbsp;if err := db.Put(key, data); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Crit("Failed to store header", "err", err)<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;return nil<br> }</p> 
  <p>// WriteBody serializes the body of a block into the database.<br> func WriteBody(db ethdb.Putter, hash common.Hash, number uint64, body *types.Body) error {<br> &nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(body)<br> &nbsp;&nbsp; &nbsp;if err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;return WriteBodyRLP(db, hash, number, data)<br> }<br> 分为了写头和写区块体两部分。首先对区块头进行了RLP编码，然后将Number转换成为byte格式，然后拼装key。<br> 这个过程中要先存储了hash-&gt;Number的值，然后才将区块头的数据写入数据库。<br> 区块体类似，RLP编码，拼装KEY。<br> 再分析一下交易的存储：<br> 目前的以太坊交易在数据库中仅存储交易的元数据：<br> // TxLookupEntry is a positional metadata to help looking up the data content of<br> // a transaction or receipt given only its hash.<br> type TxLookupEntry struct {<br> &nbsp;&nbsp; &nbsp;BlockHash &nbsp;common.Hash<br> &nbsp;&nbsp; &nbsp;BlockIndex uint64<br> &nbsp;&nbsp; &nbsp;Index &nbsp; &nbsp; &nbsp;uint64<br> }<br> 存储的KV对应为：<br> txHash(交易哈希)+txMetaSuffix(前缀)-&gt;rlpEncode(txMeta)(元数据编码)<br> 写入函数：<br> // WriteTxLookupEntries stores a positional metadata for every transaction from<br> // a block, enabling hash based transaction and receipt lookups.<br> func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error {<br> &nbsp;&nbsp; &nbsp;// Iterate over each transaction and encode its metadata<br> &nbsp;&nbsp; &nbsp;for i, tx := range block.Transactions() {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;entry := TxLookupEntry{<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockHash: &nbsp;block.Hash(),<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BlockIndex: block.NumberU64(),<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Index: &nbsp; &nbsp; &nbsp;uint64(i),<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data, err := rlp.EncodeToBytes(entry)<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return err<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;return nil<br> }<br> 遍历交易，构造元数据，RLP编码，然后就可以入库了。<br> 读取代码如下：<br> // GetTransaction retrieves a specific transaction from the database, along with<br> // its added positional metadata.<br> func GetTransaction(db DatabaseReader, hash common.Hash) (*types.Transaction, common.Hash, uint64, uint64) {<br> &nbsp;&nbsp; &nbsp;// Retrieve the lookup metadata and resolve the transaction from the body<br> &nbsp;&nbsp; &nbsp;blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash)</p> 
  <p>&nbsp;&nbsp; &nbsp;if blockHash != (common.Hash{}) {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;body := GetBody(db, blockHash, blockNumber)<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if body == nil || len(body.Transactions) &lt;= int(txIndex) {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;log.Error("Transaction referenced missing", "number", blockNumber, "hash", blockHash, "index", txIndex)<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return body.Transactions[txIndex], blockHash, blockNumber, txIndex<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;// Old transaction representation, load the transaction and it's metadata separately<br> &nbsp;&nbsp; &nbsp;data, _ := db.Get(hash.Bytes())<br> &nbsp;&nbsp; &nbsp;if len(data) == 0 {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;var tx types.Transaction<br> &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;tx); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;// Retrieve the blockchain positional metadata<br> &nbsp;&nbsp; &nbsp;data, _ = db.Get(append(hash.Bytes(), oldTxMetaSuffix...))<br> &nbsp;&nbsp; &nbsp;if len(data) == 0 {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;var entry TxLookupEntry<br> &nbsp;&nbsp; &nbsp;if err := rlp.DecodeBytes(data, &amp;entry); err != nil {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return nil, common.Hash{}, 0, 0<br> &nbsp;&nbsp; &nbsp;}<br> &nbsp;&nbsp; &nbsp;return &amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index<br> }<br> 先通过交易哈希得到元数据入口，再查找块哈希，然后从块上找到交易的具体信息返回，或者如果是老的版本，则处理一下再返回。<br> 也就是说，这个函数支持新旧两个版本的交易查询。<br> 这样区块也就基本分析完成了。<br> 如果对区块链和c++感兴趣，欢迎关注：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180923184118113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZwY2M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/fpcc/article/details/81583064,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/fpcc/article/details/81583064,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/fpcc/article/details/81583064,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/fpcc/article/details/81583064,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
