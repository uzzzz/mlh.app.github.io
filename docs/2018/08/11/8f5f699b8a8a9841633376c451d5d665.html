<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链共识机制的演进 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链共识机制的演进" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="分布式系统的基本概念 FLP不可能原理和CAP原理 FLP 不可能原理（FLP impossibility）：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。 CAP 原理最早由 Eric Brewer 在 2000 年，ACM 组织的一个研讨会上提出猜想，后来 Lynch 等人进行了证明。 分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availability）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 弱化一致性&nbsp; 对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。&nbsp; 例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。&nbsp;弱化可用性&nbsp; 对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。&nbsp; Paxos、Raft 等算法，主要处理这种情况。&nbsp;弱化分区容忍性&nbsp; 现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。&nbsp; 实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。 什么是共识Consensus？ 当多个主机通过异步通讯方式组成网络集群时，这种异步网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，取得共识。&nbsp; 为什么认为异步网络默认是不可靠的？这是根据FLP原理。Impossibility of Distributed Consensus with One Faulty Process一文提出：在一个异步系统中我们不可能确切知道任何一台主机是否死机了，因为我们无法分清楚主机或网络的性能减慢与主机死机的区别，也就是说我们无法可靠地侦测到失败错误。但是，我们还必须确保安全可靠。 达成共识越分散的过程，其效率就越低，但满意度越高，因此也越稳定；相反，达成共识越集中的过程，效率越高，也越容易出现独裁和腐败现象。 达成共识常用的一种方法就是通过物质上的激励以对某个事件达成共识；但是这种共识存在的问题就是容易被外界其它更大的物质激励所破坏。&nbsp; 还有一种就是群体中的个体按照符合自身利益或整个群体利益的方向来对某个事件自发地达成共识；当然形成这种自发式的以维护群体利益为核心的共识过程还是需要时间和环境因素的，但是一旦达成这样的共识趋势，其共识结果也越稳定，越不容易被破坏。 CFT &amp; BFT Paxos &amp; Raft Paxos 问题是指分布式的系统中存在故障，但不存在恶意节点场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。因为最早是1990年 Leslie Lamport 用 Paxon 岛的故事模型来进行描述而命名。&nbsp; Paxos过于晦涩难懂，和难以实现，之后有出现了各种改进算法：Egalitarian Paxos、Hydra、Fast Paxos、Ios、VRR(Viewstamped Replication Revisited)、 Multi-Paxos、Raft等&nbsp; Raft 算法是Paxos 算法的一种简化实现，2013年才问世。&nbsp; Paxos是一种无领导人Leaderless算法，而Raft算法是一种强领导力Leadership的算法。 拜占庭将军问题&amp;两军问题 拜占庭将军问题是一个共识问题: 首先由Leslie Lamport与另外两人在1982年提出，被称为The Byzantine Generals Problem或者Byzantine Failure。核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算领域，发展成了一种容错理论。 Lamport的论文中讲了这样一个故事： 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。 而容易与拜占庭将军问题混为一谈的是两军问题。两军问题描述了这样一个故事： 白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。 看到这里您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同。由此可见，大量混淆了拜占庭将军问题和两军问题的文章并没有充分理解两者。 针对拜占庭将军问题，目前业界比较常用的是PBFT算法。 PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。该算法是Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。&nbsp; 这个算法在保证活性和安全性的前提下提供了(n-1)/3的容错性，也就是节点数需要达到3f+1个节点才能容错f个节点。 以4个节点组成的分布式网络为例，PBFT算法的节点间网络通信如图所示： 从上图我们可以看出，PBFT算法下，网络通信的复杂度达到了O(n²)，这也就意味着，PBFT网络节点不能太多，如果节点太多将会造成网络风暴，使得整个网络堵塞。 我们平时说的CFT就是Crash Fault Tolerant的简写，是无恶意节点的情况下的容错，常用的共识算法有： Paxos、Raft&nbsp; 而BFT就是Byzantine Fault Tolerant的简写，是有恶意节点的情况下的容错，常用的共识算法有：PBFT、POW POW工作证明 Proof of Work，工作证明相关理念最早于1993年被Cynthia Dwork和Moni Naor提出，之后的几年，该概念在是否能有效对抗拒绝服务攻击的争论中不断被人们所知。PoW机制的核心在于强迫攻击者作出一定量的工作才能进行接下来的交互操作，这样无形中就给攻击者提高了攻击的成本。自然而然的，攻击者需要完成的工作可以按消耗的计算机资源种类分为以下三大类： 消耗CPU资源。例如，反垃圾邮件的Hashcash方案以及受此启发而诞生的比特币； 消耗内存资源。例如，为了防止与比特币采用相同的共识机制所可能导致的51%攻击，以太坊目前就使用了一种需要占用大量内存资源的PoW算法； 消耗网络资源。攻击者在进行拒绝服务攻击之前，必须要获取多个远程服务器发送的命令。 POW作为数字货币的共识机制于 1998 年在 B-money 设计中提出。2008年中本聪发表比特币白皮书，比特币采用POW共识，通过计算来猜测一个数值（nonce），得以解决规定的 Hash 问题（两次SHA256）。保证在一段时间内，系统中只能出现少数合法提案。 同时，这些少量的合法提案会在网络中进行广播，收到的用户进行验证后会基于它认为的最长链上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。 Hash 问题具有不可逆的特点，因此，目前除了暴力计算外，还没有有效的算法进行解决。反之，如果获得符合要求的 nonce，则说明在概率上是付出了对应的算力。谁的算力多，谁最先解决问题的概率就越大。 当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 51% 攻击的由来。 比特币POW算法的ASIC化问题 由于比特币采用的是比较简单的SHA256哈希算法作为POW共识算法，这个算法只消耗CPU资源，对内存要求不高，所以可以很容易被制造出ASIC芯片。这是比特币挖矿芯片的更新换代图： 而现在，比特币的挖矿都变成了这样子：大量ASIC矿机组成的矿场。 这样算力就越来越集中到了大矿主手里，普通用户使用电脑根本不可能挖到矿，这与中本聪当年设想的人人都能公平记账的愿景相违背。为此，人们设计了各种反ASIC化的方案。主要思想就是将POW算法改的很复杂，需要大量的内存，这样ASIC芯片是不可能集成大量内存进去的，从而无法制造出专门的挖矿芯片。比较有代码的改进方案有： 莱特币：刚性内存哈希函数Scrypt取代SHA256 达世币：X11，11种哈希函数混合使用 以太坊：Ethash，大内存DAG搜索 但是实际上，只要利益足够大，人们总能够设计出专门POW挖矿的矿机，莱特币矿机和达世币矿机先后被制造了出来，以太坊之前也顶多是使用显卡挖矿，最近比特大陆也研发出了专门进行以太坊挖矿的专业矿机“蚂蚁矿机E3。具体可以参考这个新闻：http://t.cj.sina.com.cn/articles/view/1181714847/466f899f001007d4h 比特币POW算法的资源浪费问题 中本聪为了解决拜占庭共识问题，在比特币系统中引入竞争挖矿的机制。同时，为了保证最大可能的公平性，采用了基于哈希运算的PoW共识机制。矿工如果想要得到一个合法的区块，则必须向区块头中填入不同的随机值，然后计算出区块头的哈希值，使得得到的哈希值小于目标值。这样，矿工在不断寻找合适随机值的过程中完成了一定的工作量。可以发现，矿工完成的这个工作量对于现实社会毫无意义。唯一的意义就是保障了比特币的安全性。 这是最新的比特币历史算力曲线，现在的算力已经相当惊人，这样就意味着，后面后200多万台专业的比特币矿机在运行！！！ 有人做了个估算，其耗电量比伊朗整个国家的耗电量还大。 比特币的POW算法是没有任何实际意义的SHA256运算，那么有没有可能在挖矿的同时，把这些算力算出一些副产物？以下是几个比较有名的进行有效工作量证明的区块链： 质数币：Primecoin（质数币）发布于2013年7月。其最大的特点是将虚拟货币中浪费的算法资源利用起来。它的PoW可以搜索质数，从而计算孪生素数表。所以有一定的科学价值。 治疗币：Curecoin（治疗币）发布于2013年5月。治疗币最大的特点是将蛋白质褶皱结构的研究SHA256工作量证明算法进行了结合。因为蛋白质褶皱研究需要对蛋白质进行生化反应的模拟过程需要大量的计算资源，所以在“挖矿”的同时，还用于发现治愈疾病的新药，一举两得。 比原链：比原链重新设计一种不同于比特币的哈希运算PoW共识机制，引入了矩阵运算与卷积运算，这样就能让人工智能运算充分利用比原链的挖矿设备。在这个过程中，人工智能加入了新的硬件，其算法运行速度得到明显提高。同时，这样也能减少一定的资源浪费。在这种情况下，矿机市场巨大的经济利益能够极大地加速人工智能ASIC芯片的发展，加快人工智能的研究。反过来，人工智能的快速发展也产生了更多的ASIC矿机需求。因此，这是一种正向反馈良性发展的过程。 POS权益证明 POW算法毕竟是要靠大量资源的消耗来保证共识的达成，有没有完全不需要靠计算机资源堆砌来保证的共识机制呢？在2011年，一个名为Quantum Mechanic的数字货币爱好者在Bitcointalk论坛提出Proof-of-Stake（POS）证明机制，该机制被充分讨论之后证明具有可行性。如果说POW主要比拼算力，算力越大，挖到一个块的概率越大，POS则是比拼余额，通俗说就是自己的手里的币越多，挖到一个块的概率越大。 POS共识算法存在一个漏洞，就是鼎鼎大名的Nothing-at-Stake攻击（常写作N@S）。 假设系统中出现了两个分支链，那么对于持有币的”挖矿者“来讲，最佳的操作策略就是同时在两个分支上进行“挖矿”，这样，无论哪个分支胜出，对币种持有者来讲，都会获得本属于他的利益，即不会有利益损失。而且由于不需要算力消耗，因此PoS中在两个分支上挖矿是可行的。这导致的问题是，只要系统存在分叉，“矿工们”都会同时在这几个分支上挖矿；因此在某个情况下，发起攻击的分叉链是极有可能成功的，因为所有人也都在这个分叉链上达成了共识；而且甚至不用持有51%的币量，就可以成功发起分叉攻击。而这在PoW中是不可行的，因为挖矿需要消耗算力，矿工只能在一个分支上进行挖矿。所以在实际POS算法中，还需要加入一些惩罚机制，如果矿工被发现两个分支同时挖矿，就会进行惩罚。 第一个POS虚拟货币——点点币 Peercoin（点点币，PPC）于2012年8月发布，最大创新是其采矿方式混合了POW工作量证明及POS权益证明方式，其中POW主要用于发行货币，未来预计随着挖矿难度上升，产量降低，系统安全主要由POS维护。目前区块链中存在两种类型的区块，POW区块和POS区块。PPC的作者为同样不愿意公开身份的密码货币极客Sunny King，同时也是Primecoin的发明者。 第一个纯POS虚拟货币——未来币 2013年9月，一个名为BCNext的用户在Bitcointalk论坛发起一个帖子，宣布将发行一种全新的纯POS币种，后来取名为Nextcoin，简称NXT。Nxt是且是第一个100%的股权证明(PoS)机制的电子货币，Nxt不再通过消耗大量的资源“挖矿”产生新货币，而是通过现有账户的余额去“锻造”区块，并给与成功“锻造”区块的账户交易费用奖励。NXT的POS实现方式与PPC完全不同，合格区块判定方法为： hit &lt; baseTarget * effectiveBalance * elapseTime hit是根据最新区块和用户的私钥生成的值，用户在挖一个区块时只需要计算一次即可。而右边的值跟账户余额成正比，跟流逝的时间成正比。也就意味着，用户账户余额越多，挖到矿的几率越高，随着时间的流逝越久，越容易找到新的区块。NXT区块的生成完全摒弃了竞争的理念，有点“上帝早已安排好一切”的味道，下一个区块由谁来生成冥冥中早就注定了，全网节点能做的就是静静等待那一刻的到来。 POS的本质就是比谁的钱多，钱越多越容易挖到区块，这将会造成富者越富，资源越来越集中，从而变得更中心化。 DPOS代理权益证明 针对POW、POS的效率低和会变得越来越中心化的问题，BM在2013年8月启动的比特股BitShares项目则采用了DPOS共识算法。 比特股 比特股核心账本采用石墨稀技术，对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制——Delegated Proof-Of-Stake（DPOS），即代理股权证明。 DPOS很容易理解，类似于现代企业董事会制度，比特股系统将代币持有者称为股东，由股东投票选出101名代表，然后由这些代表负责产生区块。那么需要解决的核心问题主要有：代表如何被选出，代表如何自由退出“董事会”，代表之间如何协作产生区块等。持币者若想成为一名代表，需先拿自己的公钥去区块链注册，获得一个长度为32位的特有身份标识符，用户可以对这个标识符以交易的形式进行投票，得票数前101位被选为代表。代表们轮流产生区块，收益（交易手续费）平分。如果有代表不老实生产区块，很容易被其他代表和股东发现，他将立即被踢出“董事会”，空缺位置由票数排名102的代表自动填补。 从某种角度来说，DPOS可以理解为多中心系统，兼具去中心化和中心化优势。 EOS 另外目前最火的区块链项目之一EOS也是采用了DPOS共识。EOS通过投票的方式选举出21个超级节点作为记账节点，每个节点有3秒的时间片，轮流记账。如果轮到某节点记账而没有出块，则该节点可能被投票出局，由其他备选节点顶替。出块速度是0.5秒！ EOS.IO软件允许区块精准的以每0.5秒产生一个区块，只有一个生产者被授权在任何给定的时间点生产一个区块。如果区块在预定的时间没有被生产出来，那么，那个时间的区块将被跳过。当一个或多个区块被跳过，将会有0.5秒或更多秒的区块间隔。&nbsp; 使用EOS.IO软件，区块以126个区块为一轮（每个生产者可以生产6个，有21个生产者，二者相乘）。在每一轮的开始，21个区块生产者通过token持有者的投票被选中。选中的生产者依据商定好的顺序生产区块，这个顺序由15个或者更多的生产者商定。&nbsp; 如果一个生产者错过了一个区块，并且在24小时内没有生产任何区块，他们将会被移除。直到这些“宕机”的生产者们及时通知区块链，他们将打算再次生产区块才被重新加入。通过不安排那些不够可靠的节点，尽可能的减少错过区块创建，来让整个网络运行得更平稳。 DPOS的特殊性，也是奠定拜占庭容错能力的基础框架，是它的算力节点是固定21个人，并且由大型的机构运营节点，其信息也相对透明，例如运营节点的地点、运营的情况等等。并且DPOS的算力节点是固定出块顺序的，固定地从A到B到C······。 传统DPOS中加入了拜占庭容错算法（BFT），只要没有生产者盖上相同的时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块。一旦15个生产者签署了一个区块，该区块就被认为是不可逆转的。在这种模式下，不可逆转的共识应该在1秒内完成。&nbsp; 在这种情况下，其实DPOS是拜占庭容错的特殊解，如何理解特殊解？原来的拜占庭容错（POW工作量证明），解决的是不限数量、随机广播同步的算力节点的容错能力，DPOS解决的拜占庭容错从两个维度降低了难度：&nbsp; 1、节点数量固定只有21个。并且节点信息透明。&nbsp; 2、固定出块顺序。每个节点跟接力棒一样，一个个往下接力出块。每个节点不能还没轮到它出块的时候，就出块。都是必须轮到再出块。如果出现出块故障，会跳过这个节点。&nbsp; 在POW或者其他的POS共识里，节点不限、随机出块顺序的问题，就变成只要解决「固定数量和固定出块顺序情况下的拜占庭问题」，其难度就大大降低。 一直以来以太坊的创始人Vitalik和EOS创始人BM关于POW和DPOS谁更中心化进行互怼。Vitalik认为EOS的21个超级节点违反了区块链的去中心化原则，有失公平。而BM则认为几个几大矿池控制了比特币和以太坊的绝大部分算力，这相当于以太坊只有几个超级节点，比21个节点还要少，对手里拿着BTC和ETH的人他们对社区和整个生态，他们是没有确定的发言权的，在比特币的世界里算力就是王道，面对算力大量集中在部分矿场的现在，它真的实现了中本聪的本心了吗？同样需要挖矿POS也是一样，需要看概率来决定你能否发声，但是DPOS是有发言权的，不管持有多少，我都有发言权。这种看似由“直接民主”转为“间接民主”的机制，或许才是真正体现了去中心化精神。 以下是最新的比特币算力分布和以太坊的算力分布： 其他改进共识 以上介绍到的PBFT、POW、POS和DPOS各有各的优缺点： POW的能耗问题 POS/DPOS的中心化问题 PBFT的节点数问题 IP投票制币不够安全 有人仿照CAP不可能三角，也提出了区块链共识的不可能三角：环保节能、安全、去中心化，三者不可能同时满足，必有一方的弱化。设计一个既环保又安全的密码学货币，它必然是中心化的，比如PPcoin、Nextcoin、Ripple，它们要么本身就是中心化的架构，要么其去中心化的架构不可维持，它们本质上仍是PayPal、网银一样的中心化验证机制；设计一个既环保又去中心化的密码学货币，它必然是不安全的，比如IP投票制的P2P货币，中本聪起初就已排除了这种可能，他认为“如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，比如僵尸网络，就有可能主宰比特币网络”[vi]。设计一个安全的去中心化货币，它必然是以付出能源与计算力为代价。 有时，我们可能需要根据区块链的场景，对原有共识算法进行改进。 NEO的dBFT NEO采用的是 Delegated Byzantine Fault Tolerance (dBFT) 共识算法，由于它目前只有 7 个 代理节点，而代表节点则是通过用户投票选出。dBFT参与记账的是超级节点，普通节点可以看到共识过程，并同步账本信息，但不参与记账。总共n个超级节点分为一个议长和n-1个议员，议长会轮流当选。每次记账时，先有议长发起区块提案（拟记账的区块内容），一旦有至少（2n+1)/3个记账节点（议长加议员）同意了这个提案，那么这个提案就成为最终发布的区块，并且该区块是不可逆的，所有里面的交易都是百分之百确认的。 以太坊的下一代POS共识：Casper Casper（投注共识）是一种以太坊下一代的共识机制，属于PoS。Casper的共识是按块达成的而不是像PoS那样按链达成的。 为了防止验证人在不同的世界中提供不同的投注，我们还有一个简单严格的条款：如果你有两次投注序号一样，或者说你提交了一个无法让Casper合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临着保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。具体如下： 出块是一个独立于其它所有事件而发生的过程：验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，签名，然后发送到网络上。投注的过程更为复杂一些。目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。&nbsp; 而客户端的确认当前状态的过程如下所示： 一开始先下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见。它只要简单的按顺序在每个高度进行观察，如果一个块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后得到的状态就可以显示为区块链的“当前状态”。客户端还可以给出对于“最终确定”的主观看法：当高度k之前的每个块，意见要么高于99.999%或者低于0.001%，那么客户端就可以认为前k个块已经最终确定。 IOTA和Byteball的DAG和相关共识 IOTA和Byteball这种基于DAG结构的分布式账本技术，从概念上讲已经不能算是区块链了，因为在底层结构上，DAG中既没有区块也不是链。IOTA中使用Tangle（缠结）这种技术，使得每个交易在发出时也见证另外两个交易。Byteball采用的是11个见证人的方式，由见证人参与共识。 HyperLedger Fabric下一代共识：SBFT PBFT在Fabric0.6的时候被采用，但是由于一些说不清的原因，在Fabric1.0中并没有采用PBFT，而是使用Kafka进行排序，作为共识节点。在Fabric的提案中，打算会采用SBFT（Simple BFT），这种BFT算法会对PBFT进行简化，具体什么时候实现还没准呢。 PalletOne的陪审团共识 在英美，陪审团制度是一个使用了几百年的共识制度，关于一个案件中嫌疑人是否有罪，是由随机抽选的陪审员组成陪审团共同决定的。提到陪审团，就不得不提一部非常经典的电影《十二怒汉》： 《十二怒汉》讲述的是一个在贫民窟长大的18岁少年因为涉嫌杀害自己的父亲被告上法庭，证人言之凿凿，各方面的证据都对他极为不利。十二个不同职业的人组成了这个案件的陪审团，他们要在休息室达成一致的意见，裁定少年是否有罪，如果罪名成立，少年将会被判处死刑。&nbsp; 《十二怒汉》通过一场陪审团审判，生动演绎了美国的法律制度与文化，是美国宣传法律和法律制度的“银法槌奖”的首部获奖作品。同名电影在IMDB上排名第五，高于《阿甘正传》《辛德勒的名单》等，是一部超越时代的经典之作！其中的一段台词也很能体现陪审团制度的特点： “我们都肩负责任。我一直认为，这正是民主社会了不起的地方。我们接到邮件通知，大老远跑到这里，决定一个跟我们素昧平生的人到底有没有罪。不论作出什么样的裁决，我们都拿不到任何好处，也不会有任何损失。这正是我们国家强大的原因之一。我们不能把它当成个人的事” PalletOne提供了对各个底层链的抽象，用户使用常用的开发语言，基于对底层链的抽象接口进行操作。而合约的执行就是靠一个个的陪审团来完成的。 除了陪审团这个角色，在PalletOne中还有一个叫仲裁中介(Mediator)的角色，该角色是基于DPOS选举的，相当于现实生活中的法官的角色，在接到一个新的智能合约后，Mediator会随机选择陪审员组成陪审团，由该陪审团负责该智能合约的执行和共识。 陪审团共识与传统POW、POS等共识的不同之处在于，陪审团共识是一个并行的共识机制，在同一个时刻，有多个陪审团同时在执行不同的合约。为了配合陪审团的并行共识，PalletOne采用了DAG作为分布式存储，合约的状态数据可以并行写入DAG中。所以PalletOne使用陪审团并行共识+DAG的并行写入，可以实现极高的TPS。 总结 现在区块链上数字资产的应用越来越多来源于真实世界或金融资产，对交易的最终确认有很高的要求，需要有不同的共识机制。&nbsp; 共识机制是区块链的核心技术，现在各种区块链共识机制的选择是认为至今为止的相对的最优选择；当未来区块链技术越来越多应用于现实，未来将会不断有所改进，以切合实际的需要。 共识算法的选择与应用场景高度相关，可信环境使用Paxos或者Raft，带许可的联盟可使用PBFT，非许可链可以是POW、POS、DPOS共识等。 阅读更多" />
<meta property="og:description" content="分布式系统的基本概念 FLP不可能原理和CAP原理 FLP 不可能原理（FLP impossibility）：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。 CAP 原理最早由 Eric Brewer 在 2000 年，ACM 组织的一个研讨会上提出猜想，后来 Lynch 等人进行了证明。 分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availability）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 弱化一致性&nbsp; 对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。&nbsp; 例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。&nbsp;弱化可用性&nbsp; 对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。&nbsp; Paxos、Raft 等算法，主要处理这种情况。&nbsp;弱化分区容忍性&nbsp; 现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。&nbsp; 实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。 什么是共识Consensus？ 当多个主机通过异步通讯方式组成网络集群时，这种异步网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，取得共识。&nbsp; 为什么认为异步网络默认是不可靠的？这是根据FLP原理。Impossibility of Distributed Consensus with One Faulty Process一文提出：在一个异步系统中我们不可能确切知道任何一台主机是否死机了，因为我们无法分清楚主机或网络的性能减慢与主机死机的区别，也就是说我们无法可靠地侦测到失败错误。但是，我们还必须确保安全可靠。 达成共识越分散的过程，其效率就越低，但满意度越高，因此也越稳定；相反，达成共识越集中的过程，效率越高，也越容易出现独裁和腐败现象。 达成共识常用的一种方法就是通过物质上的激励以对某个事件达成共识；但是这种共识存在的问题就是容易被外界其它更大的物质激励所破坏。&nbsp; 还有一种就是群体中的个体按照符合自身利益或整个群体利益的方向来对某个事件自发地达成共识；当然形成这种自发式的以维护群体利益为核心的共识过程还是需要时间和环境因素的，但是一旦达成这样的共识趋势，其共识结果也越稳定，越不容易被破坏。 CFT &amp; BFT Paxos &amp; Raft Paxos 问题是指分布式的系统中存在故障，但不存在恶意节点场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。因为最早是1990年 Leslie Lamport 用 Paxon 岛的故事模型来进行描述而命名。&nbsp; Paxos过于晦涩难懂，和难以实现，之后有出现了各种改进算法：Egalitarian Paxos、Hydra、Fast Paxos、Ios、VRR(Viewstamped Replication Revisited)、 Multi-Paxos、Raft等&nbsp; Raft 算法是Paxos 算法的一种简化实现，2013年才问世。&nbsp; Paxos是一种无领导人Leaderless算法，而Raft算法是一种强领导力Leadership的算法。 拜占庭将军问题&amp;两军问题 拜占庭将军问题是一个共识问题: 首先由Leslie Lamport与另外两人在1982年提出，被称为The Byzantine Generals Problem或者Byzantine Failure。核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算领域，发展成了一种容错理论。 Lamport的论文中讲了这样一个故事： 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。 而容易与拜占庭将军问题混为一谈的是两军问题。两军问题描述了这样一个故事： 白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。 看到这里您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同。由此可见，大量混淆了拜占庭将军问题和两军问题的文章并没有充分理解两者。 针对拜占庭将军问题，目前业界比较常用的是PBFT算法。 PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。该算法是Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。&nbsp; 这个算法在保证活性和安全性的前提下提供了(n-1)/3的容错性，也就是节点数需要达到3f+1个节点才能容错f个节点。 以4个节点组成的分布式网络为例，PBFT算法的节点间网络通信如图所示： 从上图我们可以看出，PBFT算法下，网络通信的复杂度达到了O(n²)，这也就意味着，PBFT网络节点不能太多，如果节点太多将会造成网络风暴，使得整个网络堵塞。 我们平时说的CFT就是Crash Fault Tolerant的简写，是无恶意节点的情况下的容错，常用的共识算法有： Paxos、Raft&nbsp; 而BFT就是Byzantine Fault Tolerant的简写，是有恶意节点的情况下的容错，常用的共识算法有：PBFT、POW POW工作证明 Proof of Work，工作证明相关理念最早于1993年被Cynthia Dwork和Moni Naor提出，之后的几年，该概念在是否能有效对抗拒绝服务攻击的争论中不断被人们所知。PoW机制的核心在于强迫攻击者作出一定量的工作才能进行接下来的交互操作，这样无形中就给攻击者提高了攻击的成本。自然而然的，攻击者需要完成的工作可以按消耗的计算机资源种类分为以下三大类： 消耗CPU资源。例如，反垃圾邮件的Hashcash方案以及受此启发而诞生的比特币； 消耗内存资源。例如，为了防止与比特币采用相同的共识机制所可能导致的51%攻击，以太坊目前就使用了一种需要占用大量内存资源的PoW算法； 消耗网络资源。攻击者在进行拒绝服务攻击之前，必须要获取多个远程服务器发送的命令。 POW作为数字货币的共识机制于 1998 年在 B-money 设计中提出。2008年中本聪发表比特币白皮书，比特币采用POW共识，通过计算来猜测一个数值（nonce），得以解决规定的 Hash 问题（两次SHA256）。保证在一段时间内，系统中只能出现少数合法提案。 同时，这些少量的合法提案会在网络中进行广播，收到的用户进行验证后会基于它认为的最长链上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。 Hash 问题具有不可逆的特点，因此，目前除了暴力计算外，还没有有效的算法进行解决。反之，如果获得符合要求的 nonce，则说明在概率上是付出了对应的算力。谁的算力多，谁最先解决问题的概率就越大。 当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 51% 攻击的由来。 比特币POW算法的ASIC化问题 由于比特币采用的是比较简单的SHA256哈希算法作为POW共识算法，这个算法只消耗CPU资源，对内存要求不高，所以可以很容易被制造出ASIC芯片。这是比特币挖矿芯片的更新换代图： 而现在，比特币的挖矿都变成了这样子：大量ASIC矿机组成的矿场。 这样算力就越来越集中到了大矿主手里，普通用户使用电脑根本不可能挖到矿，这与中本聪当年设想的人人都能公平记账的愿景相违背。为此，人们设计了各种反ASIC化的方案。主要思想就是将POW算法改的很复杂，需要大量的内存，这样ASIC芯片是不可能集成大量内存进去的，从而无法制造出专门的挖矿芯片。比较有代码的改进方案有： 莱特币：刚性内存哈希函数Scrypt取代SHA256 达世币：X11，11种哈希函数混合使用 以太坊：Ethash，大内存DAG搜索 但是实际上，只要利益足够大，人们总能够设计出专门POW挖矿的矿机，莱特币矿机和达世币矿机先后被制造了出来，以太坊之前也顶多是使用显卡挖矿，最近比特大陆也研发出了专门进行以太坊挖矿的专业矿机“蚂蚁矿机E3。具体可以参考这个新闻：http://t.cj.sina.com.cn/articles/view/1181714847/466f899f001007d4h 比特币POW算法的资源浪费问题 中本聪为了解决拜占庭共识问题，在比特币系统中引入竞争挖矿的机制。同时，为了保证最大可能的公平性，采用了基于哈希运算的PoW共识机制。矿工如果想要得到一个合法的区块，则必须向区块头中填入不同的随机值，然后计算出区块头的哈希值，使得得到的哈希值小于目标值。这样，矿工在不断寻找合适随机值的过程中完成了一定的工作量。可以发现，矿工完成的这个工作量对于现实社会毫无意义。唯一的意义就是保障了比特币的安全性。 这是最新的比特币历史算力曲线，现在的算力已经相当惊人，这样就意味着，后面后200多万台专业的比特币矿机在运行！！！ 有人做了个估算，其耗电量比伊朗整个国家的耗电量还大。 比特币的POW算法是没有任何实际意义的SHA256运算，那么有没有可能在挖矿的同时，把这些算力算出一些副产物？以下是几个比较有名的进行有效工作量证明的区块链： 质数币：Primecoin（质数币）发布于2013年7月。其最大的特点是将虚拟货币中浪费的算法资源利用起来。它的PoW可以搜索质数，从而计算孪生素数表。所以有一定的科学价值。 治疗币：Curecoin（治疗币）发布于2013年5月。治疗币最大的特点是将蛋白质褶皱结构的研究SHA256工作量证明算法进行了结合。因为蛋白质褶皱研究需要对蛋白质进行生化反应的模拟过程需要大量的计算资源，所以在“挖矿”的同时，还用于发现治愈疾病的新药，一举两得。 比原链：比原链重新设计一种不同于比特币的哈希运算PoW共识机制，引入了矩阵运算与卷积运算，这样就能让人工智能运算充分利用比原链的挖矿设备。在这个过程中，人工智能加入了新的硬件，其算法运行速度得到明显提高。同时，这样也能减少一定的资源浪费。在这种情况下，矿机市场巨大的经济利益能够极大地加速人工智能ASIC芯片的发展，加快人工智能的研究。反过来，人工智能的快速发展也产生了更多的ASIC矿机需求。因此，这是一种正向反馈良性发展的过程。 POS权益证明 POW算法毕竟是要靠大量资源的消耗来保证共识的达成，有没有完全不需要靠计算机资源堆砌来保证的共识机制呢？在2011年，一个名为Quantum Mechanic的数字货币爱好者在Bitcointalk论坛提出Proof-of-Stake（POS）证明机制，该机制被充分讨论之后证明具有可行性。如果说POW主要比拼算力，算力越大，挖到一个块的概率越大，POS则是比拼余额，通俗说就是自己的手里的币越多，挖到一个块的概率越大。 POS共识算法存在一个漏洞，就是鼎鼎大名的Nothing-at-Stake攻击（常写作N@S）。 假设系统中出现了两个分支链，那么对于持有币的”挖矿者“来讲，最佳的操作策略就是同时在两个分支上进行“挖矿”，这样，无论哪个分支胜出，对币种持有者来讲，都会获得本属于他的利益，即不会有利益损失。而且由于不需要算力消耗，因此PoS中在两个分支上挖矿是可行的。这导致的问题是，只要系统存在分叉，“矿工们”都会同时在这几个分支上挖矿；因此在某个情况下，发起攻击的分叉链是极有可能成功的，因为所有人也都在这个分叉链上达成了共识；而且甚至不用持有51%的币量，就可以成功发起分叉攻击。而这在PoW中是不可行的，因为挖矿需要消耗算力，矿工只能在一个分支上进行挖矿。所以在实际POS算法中，还需要加入一些惩罚机制，如果矿工被发现两个分支同时挖矿，就会进行惩罚。 第一个POS虚拟货币——点点币 Peercoin（点点币，PPC）于2012年8月发布，最大创新是其采矿方式混合了POW工作量证明及POS权益证明方式，其中POW主要用于发行货币，未来预计随着挖矿难度上升，产量降低，系统安全主要由POS维护。目前区块链中存在两种类型的区块，POW区块和POS区块。PPC的作者为同样不愿意公开身份的密码货币极客Sunny King，同时也是Primecoin的发明者。 第一个纯POS虚拟货币——未来币 2013年9月，一个名为BCNext的用户在Bitcointalk论坛发起一个帖子，宣布将发行一种全新的纯POS币种，后来取名为Nextcoin，简称NXT。Nxt是且是第一个100%的股权证明(PoS)机制的电子货币，Nxt不再通过消耗大量的资源“挖矿”产生新货币，而是通过现有账户的余额去“锻造”区块，并给与成功“锻造”区块的账户交易费用奖励。NXT的POS实现方式与PPC完全不同，合格区块判定方法为： hit &lt; baseTarget * effectiveBalance * elapseTime hit是根据最新区块和用户的私钥生成的值，用户在挖一个区块时只需要计算一次即可。而右边的值跟账户余额成正比，跟流逝的时间成正比。也就意味着，用户账户余额越多，挖到矿的几率越高，随着时间的流逝越久，越容易找到新的区块。NXT区块的生成完全摒弃了竞争的理念，有点“上帝早已安排好一切”的味道，下一个区块由谁来生成冥冥中早就注定了，全网节点能做的就是静静等待那一刻的到来。 POS的本质就是比谁的钱多，钱越多越容易挖到区块，这将会造成富者越富，资源越来越集中，从而变得更中心化。 DPOS代理权益证明 针对POW、POS的效率低和会变得越来越中心化的问题，BM在2013年8月启动的比特股BitShares项目则采用了DPOS共识算法。 比特股 比特股核心账本采用石墨稀技术，对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制——Delegated Proof-Of-Stake（DPOS），即代理股权证明。 DPOS很容易理解，类似于现代企业董事会制度，比特股系统将代币持有者称为股东，由股东投票选出101名代表，然后由这些代表负责产生区块。那么需要解决的核心问题主要有：代表如何被选出，代表如何自由退出“董事会”，代表之间如何协作产生区块等。持币者若想成为一名代表，需先拿自己的公钥去区块链注册，获得一个长度为32位的特有身份标识符，用户可以对这个标识符以交易的形式进行投票，得票数前101位被选为代表。代表们轮流产生区块，收益（交易手续费）平分。如果有代表不老实生产区块，很容易被其他代表和股东发现，他将立即被踢出“董事会”，空缺位置由票数排名102的代表自动填补。 从某种角度来说，DPOS可以理解为多中心系统，兼具去中心化和中心化优势。 EOS 另外目前最火的区块链项目之一EOS也是采用了DPOS共识。EOS通过投票的方式选举出21个超级节点作为记账节点，每个节点有3秒的时间片，轮流记账。如果轮到某节点记账而没有出块，则该节点可能被投票出局，由其他备选节点顶替。出块速度是0.5秒！ EOS.IO软件允许区块精准的以每0.5秒产生一个区块，只有一个生产者被授权在任何给定的时间点生产一个区块。如果区块在预定的时间没有被生产出来，那么，那个时间的区块将被跳过。当一个或多个区块被跳过，将会有0.5秒或更多秒的区块间隔。&nbsp; 使用EOS.IO软件，区块以126个区块为一轮（每个生产者可以生产6个，有21个生产者，二者相乘）。在每一轮的开始，21个区块生产者通过token持有者的投票被选中。选中的生产者依据商定好的顺序生产区块，这个顺序由15个或者更多的生产者商定。&nbsp; 如果一个生产者错过了一个区块，并且在24小时内没有生产任何区块，他们将会被移除。直到这些“宕机”的生产者们及时通知区块链，他们将打算再次生产区块才被重新加入。通过不安排那些不够可靠的节点，尽可能的减少错过区块创建，来让整个网络运行得更平稳。 DPOS的特殊性，也是奠定拜占庭容错能力的基础框架，是它的算力节点是固定21个人，并且由大型的机构运营节点，其信息也相对透明，例如运营节点的地点、运营的情况等等。并且DPOS的算力节点是固定出块顺序的，固定地从A到B到C······。 传统DPOS中加入了拜占庭容错算法（BFT），只要没有生产者盖上相同的时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块。一旦15个生产者签署了一个区块，该区块就被认为是不可逆转的。在这种模式下，不可逆转的共识应该在1秒内完成。&nbsp; 在这种情况下，其实DPOS是拜占庭容错的特殊解，如何理解特殊解？原来的拜占庭容错（POW工作量证明），解决的是不限数量、随机广播同步的算力节点的容错能力，DPOS解决的拜占庭容错从两个维度降低了难度：&nbsp; 1、节点数量固定只有21个。并且节点信息透明。&nbsp; 2、固定出块顺序。每个节点跟接力棒一样，一个个往下接力出块。每个节点不能还没轮到它出块的时候，就出块。都是必须轮到再出块。如果出现出块故障，会跳过这个节点。&nbsp; 在POW或者其他的POS共识里，节点不限、随机出块顺序的问题，就变成只要解决「固定数量和固定出块顺序情况下的拜占庭问题」，其难度就大大降低。 一直以来以太坊的创始人Vitalik和EOS创始人BM关于POW和DPOS谁更中心化进行互怼。Vitalik认为EOS的21个超级节点违反了区块链的去中心化原则，有失公平。而BM则认为几个几大矿池控制了比特币和以太坊的绝大部分算力，这相当于以太坊只有几个超级节点，比21个节点还要少，对手里拿着BTC和ETH的人他们对社区和整个生态，他们是没有确定的发言权的，在比特币的世界里算力就是王道，面对算力大量集中在部分矿场的现在，它真的实现了中本聪的本心了吗？同样需要挖矿POS也是一样，需要看概率来决定你能否发声，但是DPOS是有发言权的，不管持有多少，我都有发言权。这种看似由“直接民主”转为“间接民主”的机制，或许才是真正体现了去中心化精神。 以下是最新的比特币算力分布和以太坊的算力分布： 其他改进共识 以上介绍到的PBFT、POW、POS和DPOS各有各的优缺点： POW的能耗问题 POS/DPOS的中心化问题 PBFT的节点数问题 IP投票制币不够安全 有人仿照CAP不可能三角，也提出了区块链共识的不可能三角：环保节能、安全、去中心化，三者不可能同时满足，必有一方的弱化。设计一个既环保又安全的密码学货币，它必然是中心化的，比如PPcoin、Nextcoin、Ripple，它们要么本身就是中心化的架构，要么其去中心化的架构不可维持，它们本质上仍是PayPal、网银一样的中心化验证机制；设计一个既环保又去中心化的密码学货币，它必然是不安全的，比如IP投票制的P2P货币，中本聪起初就已排除了这种可能，他认为“如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，比如僵尸网络，就有可能主宰比特币网络”[vi]。设计一个安全的去中心化货币，它必然是以付出能源与计算力为代价。 有时，我们可能需要根据区块链的场景，对原有共识算法进行改进。 NEO的dBFT NEO采用的是 Delegated Byzantine Fault Tolerance (dBFT) 共识算法，由于它目前只有 7 个 代理节点，而代表节点则是通过用户投票选出。dBFT参与记账的是超级节点，普通节点可以看到共识过程，并同步账本信息，但不参与记账。总共n个超级节点分为一个议长和n-1个议员，议长会轮流当选。每次记账时，先有议长发起区块提案（拟记账的区块内容），一旦有至少（2n+1)/3个记账节点（议长加议员）同意了这个提案，那么这个提案就成为最终发布的区块，并且该区块是不可逆的，所有里面的交易都是百分之百确认的。 以太坊的下一代POS共识：Casper Casper（投注共识）是一种以太坊下一代的共识机制，属于PoS。Casper的共识是按块达成的而不是像PoS那样按链达成的。 为了防止验证人在不同的世界中提供不同的投注，我们还有一个简单严格的条款：如果你有两次投注序号一样，或者说你提交了一个无法让Casper合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临着保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。具体如下： 出块是一个独立于其它所有事件而发生的过程：验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，签名，然后发送到网络上。投注的过程更为复杂一些。目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。&nbsp; 而客户端的确认当前状态的过程如下所示： 一开始先下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见。它只要简单的按顺序在每个高度进行观察，如果一个块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后得到的状态就可以显示为区块链的“当前状态”。客户端还可以给出对于“最终确定”的主观看法：当高度k之前的每个块，意见要么高于99.999%或者低于0.001%，那么客户端就可以认为前k个块已经最终确定。 IOTA和Byteball的DAG和相关共识 IOTA和Byteball这种基于DAG结构的分布式账本技术，从概念上讲已经不能算是区块链了，因为在底层结构上，DAG中既没有区块也不是链。IOTA中使用Tangle（缠结）这种技术，使得每个交易在发出时也见证另外两个交易。Byteball采用的是11个见证人的方式，由见证人参与共识。 HyperLedger Fabric下一代共识：SBFT PBFT在Fabric0.6的时候被采用，但是由于一些说不清的原因，在Fabric1.0中并没有采用PBFT，而是使用Kafka进行排序，作为共识节点。在Fabric的提案中，打算会采用SBFT（Simple BFT），这种BFT算法会对PBFT进行简化，具体什么时候实现还没准呢。 PalletOne的陪审团共识 在英美，陪审团制度是一个使用了几百年的共识制度，关于一个案件中嫌疑人是否有罪，是由随机抽选的陪审员组成陪审团共同决定的。提到陪审团，就不得不提一部非常经典的电影《十二怒汉》： 《十二怒汉》讲述的是一个在贫民窟长大的18岁少年因为涉嫌杀害自己的父亲被告上法庭，证人言之凿凿，各方面的证据都对他极为不利。十二个不同职业的人组成了这个案件的陪审团，他们要在休息室达成一致的意见，裁定少年是否有罪，如果罪名成立，少年将会被判处死刑。&nbsp; 《十二怒汉》通过一场陪审团审判，生动演绎了美国的法律制度与文化，是美国宣传法律和法律制度的“银法槌奖”的首部获奖作品。同名电影在IMDB上排名第五，高于《阿甘正传》《辛德勒的名单》等，是一部超越时代的经典之作！其中的一段台词也很能体现陪审团制度的特点： “我们都肩负责任。我一直认为，这正是民主社会了不起的地方。我们接到邮件通知，大老远跑到这里，决定一个跟我们素昧平生的人到底有没有罪。不论作出什么样的裁决，我们都拿不到任何好处，也不会有任何损失。这正是我们国家强大的原因之一。我们不能把它当成个人的事” PalletOne提供了对各个底层链的抽象，用户使用常用的开发语言，基于对底层链的抽象接口进行操作。而合约的执行就是靠一个个的陪审团来完成的。 除了陪审团这个角色，在PalletOne中还有一个叫仲裁中介(Mediator)的角色，该角色是基于DPOS选举的，相当于现实生活中的法官的角色，在接到一个新的智能合约后，Mediator会随机选择陪审员组成陪审团，由该陪审团负责该智能合约的执行和共识。 陪审团共识与传统POW、POS等共识的不同之处在于，陪审团共识是一个并行的共识机制，在同一个时刻，有多个陪审团同时在执行不同的合约。为了配合陪审团的并行共识，PalletOne采用了DAG作为分布式存储，合约的状态数据可以并行写入DAG中。所以PalletOne使用陪审团并行共识+DAG的并行写入，可以实现极高的TPS。 总结 现在区块链上数字资产的应用越来越多来源于真实世界或金融资产，对交易的最终确认有很高的要求，需要有不同的共识机制。&nbsp; 共识机制是区块链的核心技术，现在各种区块链共识机制的选择是认为至今为止的相对的最优选择；当未来区块链技术越来越多应用于现实，未来将会不断有所改进，以切合实际的需要。 共识算法的选择与应用场景高度相关，可信环境使用Paxos或者Raft，带许可的联盟可使用PBFT，非许可链可以是POW、POS、DPOS共识等。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/11/8f5f699b8a8a9841633376c451d5d665.html" />
<meta property="og:url" content="https://mlh.app/2018/08/11/8f5f699b8a8a9841633376c451d5d665.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"分布式系统的基本概念 FLP不可能原理和CAP原理 FLP 不可能原理（FLP impossibility）：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。 CAP 原理最早由 Eric Brewer 在 2000 年，ACM 组织的一个研讨会上提出猜想，后来 Lynch 等人进行了证明。 分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availability）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 弱化一致性&nbsp; 对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。&nbsp; 例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。&nbsp;弱化可用性&nbsp; 对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。&nbsp; Paxos、Raft 等算法，主要处理这种情况。&nbsp;弱化分区容忍性&nbsp; 现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。&nbsp; 实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。 什么是共识Consensus？ 当多个主机通过异步通讯方式组成网络集群时，这种异步网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，取得共识。&nbsp; 为什么认为异步网络默认是不可靠的？这是根据FLP原理。Impossibility of Distributed Consensus with One Faulty Process一文提出：在一个异步系统中我们不可能确切知道任何一台主机是否死机了，因为我们无法分清楚主机或网络的性能减慢与主机死机的区别，也就是说我们无法可靠地侦测到失败错误。但是，我们还必须确保安全可靠。 达成共识越分散的过程，其效率就越低，但满意度越高，因此也越稳定；相反，达成共识越集中的过程，效率越高，也越容易出现独裁和腐败现象。 达成共识常用的一种方法就是通过物质上的激励以对某个事件达成共识；但是这种共识存在的问题就是容易被外界其它更大的物质激励所破坏。&nbsp; 还有一种就是群体中的个体按照符合自身利益或整个群体利益的方向来对某个事件自发地达成共识；当然形成这种自发式的以维护群体利益为核心的共识过程还是需要时间和环境因素的，但是一旦达成这样的共识趋势，其共识结果也越稳定，越不容易被破坏。 CFT &amp; BFT Paxos &amp; Raft Paxos 问题是指分布式的系统中存在故障，但不存在恶意节点场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。因为最早是1990年 Leslie Lamport 用 Paxon 岛的故事模型来进行描述而命名。&nbsp; Paxos过于晦涩难懂，和难以实现，之后有出现了各种改进算法：Egalitarian Paxos、Hydra、Fast Paxos、Ios、VRR(Viewstamped Replication Revisited)、 Multi-Paxos、Raft等&nbsp; Raft 算法是Paxos 算法的一种简化实现，2013年才问世。&nbsp; Paxos是一种无领导人Leaderless算法，而Raft算法是一种强领导力Leadership的算法。 拜占庭将军问题&amp;两军问题 拜占庭将军问题是一个共识问题: 首先由Leslie Lamport与另外两人在1982年提出，被称为The Byzantine Generals Problem或者Byzantine Failure。核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算领域，发展成了一种容错理论。 Lamport的论文中讲了这样一个故事： 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。 而容易与拜占庭将军问题混为一谈的是两军问题。两军问题描述了这样一个故事： 白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。 看到这里您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同。由此可见，大量混淆了拜占庭将军问题和两军问题的文章并没有充分理解两者。 针对拜占庭将军问题，目前业界比较常用的是PBFT算法。 PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。该算法是Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。&nbsp; 这个算法在保证活性和安全性的前提下提供了(n-1)/3的容错性，也就是节点数需要达到3f+1个节点才能容错f个节点。 以4个节点组成的分布式网络为例，PBFT算法的节点间网络通信如图所示： 从上图我们可以看出，PBFT算法下，网络通信的复杂度达到了O(n²)，这也就意味着，PBFT网络节点不能太多，如果节点太多将会造成网络风暴，使得整个网络堵塞。 我们平时说的CFT就是Crash Fault Tolerant的简写，是无恶意节点的情况下的容错，常用的共识算法有： Paxos、Raft&nbsp; 而BFT就是Byzantine Fault Tolerant的简写，是有恶意节点的情况下的容错，常用的共识算法有：PBFT、POW POW工作证明 Proof of Work，工作证明相关理念最早于1993年被Cynthia Dwork和Moni Naor提出，之后的几年，该概念在是否能有效对抗拒绝服务攻击的争论中不断被人们所知。PoW机制的核心在于强迫攻击者作出一定量的工作才能进行接下来的交互操作，这样无形中就给攻击者提高了攻击的成本。自然而然的，攻击者需要完成的工作可以按消耗的计算机资源种类分为以下三大类： 消耗CPU资源。例如，反垃圾邮件的Hashcash方案以及受此启发而诞生的比特币； 消耗内存资源。例如，为了防止与比特币采用相同的共识机制所可能导致的51%攻击，以太坊目前就使用了一种需要占用大量内存资源的PoW算法； 消耗网络资源。攻击者在进行拒绝服务攻击之前，必须要获取多个远程服务器发送的命令。 POW作为数字货币的共识机制于 1998 年在 B-money 设计中提出。2008年中本聪发表比特币白皮书，比特币采用POW共识，通过计算来猜测一个数值（nonce），得以解决规定的 Hash 问题（两次SHA256）。保证在一段时间内，系统中只能出现少数合法提案。 同时，这些少量的合法提案会在网络中进行广播，收到的用户进行验证后会基于它认为的最长链上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。 Hash 问题具有不可逆的特点，因此，目前除了暴力计算外，还没有有效的算法进行解决。反之，如果获得符合要求的 nonce，则说明在概率上是付出了对应的算力。谁的算力多，谁最先解决问题的概率就越大。 当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 51% 攻击的由来。 比特币POW算法的ASIC化问题 由于比特币采用的是比较简单的SHA256哈希算法作为POW共识算法，这个算法只消耗CPU资源，对内存要求不高，所以可以很容易被制造出ASIC芯片。这是比特币挖矿芯片的更新换代图： 而现在，比特币的挖矿都变成了这样子：大量ASIC矿机组成的矿场。 这样算力就越来越集中到了大矿主手里，普通用户使用电脑根本不可能挖到矿，这与中本聪当年设想的人人都能公平记账的愿景相违背。为此，人们设计了各种反ASIC化的方案。主要思想就是将POW算法改的很复杂，需要大量的内存，这样ASIC芯片是不可能集成大量内存进去的，从而无法制造出专门的挖矿芯片。比较有代码的改进方案有： 莱特币：刚性内存哈希函数Scrypt取代SHA256 达世币：X11，11种哈希函数混合使用 以太坊：Ethash，大内存DAG搜索 但是实际上，只要利益足够大，人们总能够设计出专门POW挖矿的矿机，莱特币矿机和达世币矿机先后被制造了出来，以太坊之前也顶多是使用显卡挖矿，最近比特大陆也研发出了专门进行以太坊挖矿的专业矿机“蚂蚁矿机E3。具体可以参考这个新闻：http://t.cj.sina.com.cn/articles/view/1181714847/466f899f001007d4h 比特币POW算法的资源浪费问题 中本聪为了解决拜占庭共识问题，在比特币系统中引入竞争挖矿的机制。同时，为了保证最大可能的公平性，采用了基于哈希运算的PoW共识机制。矿工如果想要得到一个合法的区块，则必须向区块头中填入不同的随机值，然后计算出区块头的哈希值，使得得到的哈希值小于目标值。这样，矿工在不断寻找合适随机值的过程中完成了一定的工作量。可以发现，矿工完成的这个工作量对于现实社会毫无意义。唯一的意义就是保障了比特币的安全性。 这是最新的比特币历史算力曲线，现在的算力已经相当惊人，这样就意味着，后面后200多万台专业的比特币矿机在运行！！！ 有人做了个估算，其耗电量比伊朗整个国家的耗电量还大。 比特币的POW算法是没有任何实际意义的SHA256运算，那么有没有可能在挖矿的同时，把这些算力算出一些副产物？以下是几个比较有名的进行有效工作量证明的区块链： 质数币：Primecoin（质数币）发布于2013年7月。其最大的特点是将虚拟货币中浪费的算法资源利用起来。它的PoW可以搜索质数，从而计算孪生素数表。所以有一定的科学价值。 治疗币：Curecoin（治疗币）发布于2013年5月。治疗币最大的特点是将蛋白质褶皱结构的研究SHA256工作量证明算法进行了结合。因为蛋白质褶皱研究需要对蛋白质进行生化反应的模拟过程需要大量的计算资源，所以在“挖矿”的同时，还用于发现治愈疾病的新药，一举两得。 比原链：比原链重新设计一种不同于比特币的哈希运算PoW共识机制，引入了矩阵运算与卷积运算，这样就能让人工智能运算充分利用比原链的挖矿设备。在这个过程中，人工智能加入了新的硬件，其算法运行速度得到明显提高。同时，这样也能减少一定的资源浪费。在这种情况下，矿机市场巨大的经济利益能够极大地加速人工智能ASIC芯片的发展，加快人工智能的研究。反过来，人工智能的快速发展也产生了更多的ASIC矿机需求。因此，这是一种正向反馈良性发展的过程。 POS权益证明 POW算法毕竟是要靠大量资源的消耗来保证共识的达成，有没有完全不需要靠计算机资源堆砌来保证的共识机制呢？在2011年，一个名为Quantum Mechanic的数字货币爱好者在Bitcointalk论坛提出Proof-of-Stake（POS）证明机制，该机制被充分讨论之后证明具有可行性。如果说POW主要比拼算力，算力越大，挖到一个块的概率越大，POS则是比拼余额，通俗说就是自己的手里的币越多，挖到一个块的概率越大。 POS共识算法存在一个漏洞，就是鼎鼎大名的Nothing-at-Stake攻击（常写作N@S）。 假设系统中出现了两个分支链，那么对于持有币的”挖矿者“来讲，最佳的操作策略就是同时在两个分支上进行“挖矿”，这样，无论哪个分支胜出，对币种持有者来讲，都会获得本属于他的利益，即不会有利益损失。而且由于不需要算力消耗，因此PoS中在两个分支上挖矿是可行的。这导致的问题是，只要系统存在分叉，“矿工们”都会同时在这几个分支上挖矿；因此在某个情况下，发起攻击的分叉链是极有可能成功的，因为所有人也都在这个分叉链上达成了共识；而且甚至不用持有51%的币量，就可以成功发起分叉攻击。而这在PoW中是不可行的，因为挖矿需要消耗算力，矿工只能在一个分支上进行挖矿。所以在实际POS算法中，还需要加入一些惩罚机制，如果矿工被发现两个分支同时挖矿，就会进行惩罚。 第一个POS虚拟货币——点点币 Peercoin（点点币，PPC）于2012年8月发布，最大创新是其采矿方式混合了POW工作量证明及POS权益证明方式，其中POW主要用于发行货币，未来预计随着挖矿难度上升，产量降低，系统安全主要由POS维护。目前区块链中存在两种类型的区块，POW区块和POS区块。PPC的作者为同样不愿意公开身份的密码货币极客Sunny King，同时也是Primecoin的发明者。 第一个纯POS虚拟货币——未来币 2013年9月，一个名为BCNext的用户在Bitcointalk论坛发起一个帖子，宣布将发行一种全新的纯POS币种，后来取名为Nextcoin，简称NXT。Nxt是且是第一个100%的股权证明(PoS)机制的电子货币，Nxt不再通过消耗大量的资源“挖矿”产生新货币，而是通过现有账户的余额去“锻造”区块，并给与成功“锻造”区块的账户交易费用奖励。NXT的POS实现方式与PPC完全不同，合格区块判定方法为： hit &lt; baseTarget * effectiveBalance * elapseTime hit是根据最新区块和用户的私钥生成的值，用户在挖一个区块时只需要计算一次即可。而右边的值跟账户余额成正比，跟流逝的时间成正比。也就意味着，用户账户余额越多，挖到矿的几率越高，随着时间的流逝越久，越容易找到新的区块。NXT区块的生成完全摒弃了竞争的理念，有点“上帝早已安排好一切”的味道，下一个区块由谁来生成冥冥中早就注定了，全网节点能做的就是静静等待那一刻的到来。 POS的本质就是比谁的钱多，钱越多越容易挖到区块，这将会造成富者越富，资源越来越集中，从而变得更中心化。 DPOS代理权益证明 针对POW、POS的效率低和会变得越来越中心化的问题，BM在2013年8月启动的比特股BitShares项目则采用了DPOS共识算法。 比特股 比特股核心账本采用石墨稀技术，对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制——Delegated Proof-Of-Stake（DPOS），即代理股权证明。 DPOS很容易理解，类似于现代企业董事会制度，比特股系统将代币持有者称为股东，由股东投票选出101名代表，然后由这些代表负责产生区块。那么需要解决的核心问题主要有：代表如何被选出，代表如何自由退出“董事会”，代表之间如何协作产生区块等。持币者若想成为一名代表，需先拿自己的公钥去区块链注册，获得一个长度为32位的特有身份标识符，用户可以对这个标识符以交易的形式进行投票，得票数前101位被选为代表。代表们轮流产生区块，收益（交易手续费）平分。如果有代表不老实生产区块，很容易被其他代表和股东发现，他将立即被踢出“董事会”，空缺位置由票数排名102的代表自动填补。 从某种角度来说，DPOS可以理解为多中心系统，兼具去中心化和中心化优势。 EOS 另外目前最火的区块链项目之一EOS也是采用了DPOS共识。EOS通过投票的方式选举出21个超级节点作为记账节点，每个节点有3秒的时间片，轮流记账。如果轮到某节点记账而没有出块，则该节点可能被投票出局，由其他备选节点顶替。出块速度是0.5秒！ EOS.IO软件允许区块精准的以每0.5秒产生一个区块，只有一个生产者被授权在任何给定的时间点生产一个区块。如果区块在预定的时间没有被生产出来，那么，那个时间的区块将被跳过。当一个或多个区块被跳过，将会有0.5秒或更多秒的区块间隔。&nbsp; 使用EOS.IO软件，区块以126个区块为一轮（每个生产者可以生产6个，有21个生产者，二者相乘）。在每一轮的开始，21个区块生产者通过token持有者的投票被选中。选中的生产者依据商定好的顺序生产区块，这个顺序由15个或者更多的生产者商定。&nbsp; 如果一个生产者错过了一个区块，并且在24小时内没有生产任何区块，他们将会被移除。直到这些“宕机”的生产者们及时通知区块链，他们将打算再次生产区块才被重新加入。通过不安排那些不够可靠的节点，尽可能的减少错过区块创建，来让整个网络运行得更平稳。 DPOS的特殊性，也是奠定拜占庭容错能力的基础框架，是它的算力节点是固定21个人，并且由大型的机构运营节点，其信息也相对透明，例如运营节点的地点、运营的情况等等。并且DPOS的算力节点是固定出块顺序的，固定地从A到B到C······。 传统DPOS中加入了拜占庭容错算法（BFT），只要没有生产者盖上相同的时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块。一旦15个生产者签署了一个区块，该区块就被认为是不可逆转的。在这种模式下，不可逆转的共识应该在1秒内完成。&nbsp; 在这种情况下，其实DPOS是拜占庭容错的特殊解，如何理解特殊解？原来的拜占庭容错（POW工作量证明），解决的是不限数量、随机广播同步的算力节点的容错能力，DPOS解决的拜占庭容错从两个维度降低了难度：&nbsp; 1、节点数量固定只有21个。并且节点信息透明。&nbsp; 2、固定出块顺序。每个节点跟接力棒一样，一个个往下接力出块。每个节点不能还没轮到它出块的时候，就出块。都是必须轮到再出块。如果出现出块故障，会跳过这个节点。&nbsp; 在POW或者其他的POS共识里，节点不限、随机出块顺序的问题，就变成只要解决「固定数量和固定出块顺序情况下的拜占庭问题」，其难度就大大降低。 一直以来以太坊的创始人Vitalik和EOS创始人BM关于POW和DPOS谁更中心化进行互怼。Vitalik认为EOS的21个超级节点违反了区块链的去中心化原则，有失公平。而BM则认为几个几大矿池控制了比特币和以太坊的绝大部分算力，这相当于以太坊只有几个超级节点，比21个节点还要少，对手里拿着BTC和ETH的人他们对社区和整个生态，他们是没有确定的发言权的，在比特币的世界里算力就是王道，面对算力大量集中在部分矿场的现在，它真的实现了中本聪的本心了吗？同样需要挖矿POS也是一样，需要看概率来决定你能否发声，但是DPOS是有发言权的，不管持有多少，我都有发言权。这种看似由“直接民主”转为“间接民主”的机制，或许才是真正体现了去中心化精神。 以下是最新的比特币算力分布和以太坊的算力分布： 其他改进共识 以上介绍到的PBFT、POW、POS和DPOS各有各的优缺点： POW的能耗问题 POS/DPOS的中心化问题 PBFT的节点数问题 IP投票制币不够安全 有人仿照CAP不可能三角，也提出了区块链共识的不可能三角：环保节能、安全、去中心化，三者不可能同时满足，必有一方的弱化。设计一个既环保又安全的密码学货币，它必然是中心化的，比如PPcoin、Nextcoin、Ripple，它们要么本身就是中心化的架构，要么其去中心化的架构不可维持，它们本质上仍是PayPal、网银一样的中心化验证机制；设计一个既环保又去中心化的密码学货币，它必然是不安全的，比如IP投票制的P2P货币，中本聪起初就已排除了这种可能，他认为“如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，比如僵尸网络，就有可能主宰比特币网络”[vi]。设计一个安全的去中心化货币，它必然是以付出能源与计算力为代价。 有时，我们可能需要根据区块链的场景，对原有共识算法进行改进。 NEO的dBFT NEO采用的是 Delegated Byzantine Fault Tolerance (dBFT) 共识算法，由于它目前只有 7 个 代理节点，而代表节点则是通过用户投票选出。dBFT参与记账的是超级节点，普通节点可以看到共识过程，并同步账本信息，但不参与记账。总共n个超级节点分为一个议长和n-1个议员，议长会轮流当选。每次记账时，先有议长发起区块提案（拟记账的区块内容），一旦有至少（2n+1)/3个记账节点（议长加议员）同意了这个提案，那么这个提案就成为最终发布的区块，并且该区块是不可逆的，所有里面的交易都是百分之百确认的。 以太坊的下一代POS共识：Casper Casper（投注共识）是一种以太坊下一代的共识机制，属于PoS。Casper的共识是按块达成的而不是像PoS那样按链达成的。 为了防止验证人在不同的世界中提供不同的投注，我们还有一个简单严格的条款：如果你有两次投注序号一样，或者说你提交了一个无法让Casper合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临着保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。具体如下： 出块是一个独立于其它所有事件而发生的过程：验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，签名，然后发送到网络上。投注的过程更为复杂一些。目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。&nbsp; 而客户端的确认当前状态的过程如下所示： 一开始先下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见。它只要简单的按顺序在每个高度进行观察，如果一个块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后得到的状态就可以显示为区块链的“当前状态”。客户端还可以给出对于“最终确定”的主观看法：当高度k之前的每个块，意见要么高于99.999%或者低于0.001%，那么客户端就可以认为前k个块已经最终确定。 IOTA和Byteball的DAG和相关共识 IOTA和Byteball这种基于DAG结构的分布式账本技术，从概念上讲已经不能算是区块链了，因为在底层结构上，DAG中既没有区块也不是链。IOTA中使用Tangle（缠结）这种技术，使得每个交易在发出时也见证另外两个交易。Byteball采用的是11个见证人的方式，由见证人参与共识。 HyperLedger Fabric下一代共识：SBFT PBFT在Fabric0.6的时候被采用，但是由于一些说不清的原因，在Fabric1.0中并没有采用PBFT，而是使用Kafka进行排序，作为共识节点。在Fabric的提案中，打算会采用SBFT（Simple BFT），这种BFT算法会对PBFT进行简化，具体什么时候实现还没准呢。 PalletOne的陪审团共识 在英美，陪审团制度是一个使用了几百年的共识制度，关于一个案件中嫌疑人是否有罪，是由随机抽选的陪审员组成陪审团共同决定的。提到陪审团，就不得不提一部非常经典的电影《十二怒汉》： 《十二怒汉》讲述的是一个在贫民窟长大的18岁少年因为涉嫌杀害自己的父亲被告上法庭，证人言之凿凿，各方面的证据都对他极为不利。十二个不同职业的人组成了这个案件的陪审团，他们要在休息室达成一致的意见，裁定少年是否有罪，如果罪名成立，少年将会被判处死刑。&nbsp; 《十二怒汉》通过一场陪审团审判，生动演绎了美国的法律制度与文化，是美国宣传法律和法律制度的“银法槌奖”的首部获奖作品。同名电影在IMDB上排名第五，高于《阿甘正传》《辛德勒的名单》等，是一部超越时代的经典之作！其中的一段台词也很能体现陪审团制度的特点： “我们都肩负责任。我一直认为，这正是民主社会了不起的地方。我们接到邮件通知，大老远跑到这里，决定一个跟我们素昧平生的人到底有没有罪。不论作出什么样的裁决，我们都拿不到任何好处，也不会有任何损失。这正是我们国家强大的原因之一。我们不能把它当成个人的事” PalletOne提供了对各个底层链的抽象，用户使用常用的开发语言，基于对底层链的抽象接口进行操作。而合约的执行就是靠一个个的陪审团来完成的。 除了陪审团这个角色，在PalletOne中还有一个叫仲裁中介(Mediator)的角色，该角色是基于DPOS选举的，相当于现实生活中的法官的角色，在接到一个新的智能合约后，Mediator会随机选择陪审员组成陪审团，由该陪审团负责该智能合约的执行和共识。 陪审团共识与传统POW、POS等共识的不同之处在于，陪审团共识是一个并行的共识机制，在同一个时刻，有多个陪审团同时在执行不同的合约。为了配合陪审团的并行共识，PalletOne采用了DAG作为分布式存储，合约的状态数据可以并行写入DAG中。所以PalletOne使用陪审团并行共识+DAG的并行写入，可以实现极高的TPS。 总结 现在区块链上数字资产的应用越来越多来源于真实世界或金融资产，对交易的最终确认有很高的要求，需要有不同的共识机制。&nbsp; 共识机制是区块链的核心技术，现在各种区块链共识机制的选择是认为至今为止的相对的最优选择；当未来区块链技术越来越多应用于现实，未来将会不断有所改进，以切合实际的需要。 共识算法的选择与应用场景高度相关，可信环境使用Paxos或者Raft，带许可的联盟可使用PBFT，非许可链可以是POW、POS、DPOS共识等。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/11/8f5f699b8a8a9841633376c451d5d665.html","headline":"区块链共识机制的演进","dateModified":"2018-08-11T00:00:00+08:00","datePublished":"2018-08-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/11/8f5f699b8a8a9841633376c451d5d665.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链共识机制的演进</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2>分布式系统的基本概念</h2> 
  <h3>FLP不可能原理和CAP原理</h3> 
  <p>FLP 不可能原理（FLP impossibility）：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。</p> 
  <p>CAP 原理最早由 Eric Brewer 在 2000 年，ACM 组织的一个研讨会上提出猜想，后来 Lynch 等人进行了证明。</p> 
  <p>分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。</p> 
  <ul>
   <li>一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；</li> 
   <li>可用性（Availability）：在有限时间内，任何非失败节点都能应答请求；</li> 
   <li>分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。</li> 
  </ul>
  <p><strong>弱化一致性</strong>&nbsp;<br> 对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。&nbsp;<br> 例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。&nbsp;<br><strong>弱化可用性</strong>&nbsp;<br> 对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。&nbsp;<br> Paxos、Raft 等算法，主要处理这种情况。&nbsp;<br><strong>弱化分区容忍性</strong>&nbsp;<br> 现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。&nbsp;<br> 实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。</p> 
  <h3>什么是共识Consensus？</h3> 
  <p>当多个主机通过异步通讯方式组成网络集群时，这种异步网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，取得共识。&nbsp;<br> 为什么认为异步网络默认是不可靠的？这是根据FLP原理。Impossibility of Distributed Consensus with One Faulty Process一文提出：在一个异步系统中我们不可能确切知道任何一台主机是否死机了，因为我们无法分清楚主机或网络的性能减慢与主机死机的区别，也就是说我们无法可靠地侦测到失败错误。但是，我们还必须确保安全可靠。</p> 
  <p>达成共识越分散的过程，其效率就越低，但满意度越高，因此也越稳定；相反，达成共识越集中的过程，效率越高，也越容易出现独裁和腐败现象。</p> 
  <p>达成共识常用的一种方法就是通过物质上的激励以对某个事件达成共识；但是这种共识存在的问题就是容易被外界其它更大的物质激励所破坏。&nbsp;<br> 还有一种就是群体中的个体按照符合自身利益或整个群体利益的方向来对某个事件自发地达成共识；当然形成这种自发式的以维护群体利益为核心的共识过程还是需要时间和环境因素的，但是一旦达成这样的共识趋势，其共识结果也越稳定，越不容易被破坏。</p> 
  <h2>CFT &amp; BFT</h2> 
  <h3>Paxos &amp; Raft</h3> 
  <p>Paxos 问题是指分布式的系统中存在故障，但不存在恶意节点场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。因为最早是1990年 Leslie Lamport 用 Paxon 岛的故事模型来进行描述而命名。&nbsp;<br> Paxos过于晦涩难懂，和难以实现，之后有出现了各种改进算法：Egalitarian Paxos、Hydra、Fast Paxos、Ios、VRR(Viewstamped Replication Revisited)、 Multi-Paxos、Raft等&nbsp;<br> Raft 算法是Paxos 算法的一种简化实现，2013年才问世。&nbsp;<br> Paxos是一种无领导人Leaderless算法，而Raft算法是一种强领导力Leadership的算法。</p> 
  <h3>拜占庭将军问题&amp;两军问题</h3> 
  <p>拜占庭将军问题是一个共识问题: 首先由Leslie Lamport与另外两人在1982年提出，被称为The Byzantine Generals Problem或者Byzantine Failure。核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算领域，发展成了一种容错理论。</p> 
  <p>Lamport的论文中讲了这样一个故事：</p> 
  <p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221645217-1497024421.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221645576-1549161624.png"></a></p> 
  <p>而容易与拜占庭将军问题混为一谈的是两军问题。两军问题描述了这样一个故事：</p> 
  <p>白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221645931-1572183219.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221646339-11664405.png"></a></p> 
  <p>看到这里您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同。由此可见，大量混淆了拜占庭将军问题和两军问题的文章并没有充分理解两者。</p> 
  <p>针对拜占庭将军问题，目前业界比较常用的是PBFT算法。</p> 
  <p>PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。该算法是Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。&nbsp;<br> 这个算法在保证活性和安全性的前提下提供了(n-1)/3的容错性，也就是节点数需要达到3f+1个节点才能容错f个节点。</p> 
  <p>以4个节点组成的分布式网络为例，PBFT算法的节点间网络通信如图所示：</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221646754-895023397.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221647215-565887866.png"></a></p> 
  <p>从上图我们可以看出，PBFT算法下，网络通信的复杂度达到了O(n²)，这也就意味着，PBFT网络节点不能太多，如果节点太多将会造成网络风暴，使得整个网络堵塞。</p> 
  <p>我们平时说的CFT就是Crash Fault Tolerant的简写，是无恶意节点的情况下的容错，常用的共识算法有： Paxos、Raft&nbsp;<br> 而BFT就是Byzantine Fault Tolerant的简写，是有恶意节点的情况下的容错，常用的共识算法有：PBFT、POW</p> 
  <h2>POW工作证明</h2> 
  <p>Proof of Work，工作证明相关理念最早于1993年被Cynthia Dwork和Moni Naor提出，之后的几年，该概念在是否能有效对抗拒绝服务攻击的争论中不断被人们所知。PoW机制的核心在于强迫攻击者作出一定量的工作才能进行接下来的交互操作，这样无形中就给攻击者提高了攻击的成本。自然而然的，攻击者需要完成的工作可以按消耗的计算机资源种类分为以下三大类：</p> 
  <ul>
   <li>消耗CPU资源。例如，反垃圾邮件的Hashcash方案以及受此启发而诞生的比特币；</li> 
   <li>消耗内存资源。例如，为了防止与比特币采用相同的共识机制所可能导致的51%攻击，以太坊目前就使用了一种需要占用大量内存资源的PoW算法；</li> 
   <li>消耗网络资源。攻击者在进行拒绝服务攻击之前，必须要获取多个远程服务器发送的命令。</li> 
  </ul>
  <p>POW作为数字货币的共识机制于 1998 年在 B-money 设计中提出。2008年中本聪发表比特币白皮书，比特币采用POW共识，通过计算来猜测一个数值（nonce），得以解决规定的 Hash 问题（两次SHA256）。保证在一段时间内，系统中只能出现少数合法提案。 同时，这些少量的合法提案会在网络中进行广播，收到的用户进行验证后会基于它认为的最长链上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。</p> 
  <p>Hash 问题具有不可逆的特点，因此，目前除了暴力计算外，还没有有效的算法进行解决。反之，如果获得符合要求的 nonce，则说明在概率上是付出了对应的算力。谁的算力多，谁最先解决问题的概率就越大。 当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 51% 攻击的由来。</p> 
  <h3>比特币POW算法的ASIC化问题</h3> 
  <p>由于比特币采用的是比较简单的SHA256哈希算法作为POW共识算法，这个算法只消耗CPU资源，对内存要求不高，所以可以很容易被制造出ASIC芯片。这是比特币挖矿芯片的更新换代图：</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221647812-544064943.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221649606-1851610838.png"></a></p> 
  <p>而现在，比特币的挖矿都变成了这样子：大量ASIC矿机组成的矿场。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221651472-439331254.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221652415-454882799.png"></a></p> 
  <p>这样算力就越来越集中到了大矿主手里，普通用户使用电脑根本不可能挖到矿，这与中本聪当年设想的人人都能公平记账的愿景相违背。为此，人们设计了各种反ASIC化的方案。主要思想就是将POW算法改的很复杂，需要大量的内存，这样ASIC芯片是不可能集成大量内存进去的，从而无法制造出专门的挖矿芯片。比较有代码的改进方案有：</p> 
  <ul>
   <li>莱特币：刚性内存哈希函数Scrypt取代SHA256</li> 
   <li>达世币：X11，11种哈希函数混合使用</li> 
   <li>以太坊：Ethash，大内存DAG搜索</li> 
  </ul>
  <p>但是实际上，只要利益足够大，人们总能够设计出专门POW挖矿的矿机，莱特币矿机和达世币矿机先后被制造了出来，以太坊之前也顶多是使用显卡挖矿，最近比特大陆也研发出了专门进行以太坊挖矿的专业矿机“蚂蚁矿机E3。具体可以参考这个新闻：<a href="http://t.cj.sina.com.cn/articles/view/1181714847/466f899f001007d4h" rel="nofollow">http://t.cj.sina.com.cn/articles/view/1181714847/466f899f001007d4h</a></p> 
  <h3>比特币POW算法的资源浪费问题</h3> 
  <p>中本聪为了解决拜占庭共识问题，在比特币系统中引入竞争挖矿的机制。同时，为了保证最大可能的公平性，采用了基于哈希运算的PoW共识机制。矿工如果想要得到一个合法的区块，则必须向区块头中填入不同的随机值，然后计算出区块头的哈希值，使得得到的哈希值小于目标值。这样，矿工在不断寻找合适随机值的过程中完成了一定的工作量。可以发现，矿工完成的这个工作量对于现实社会毫无意义。唯一的意义就是保障了比特币的安全性。</p> 
  <p>这是最新的比特币历史算力曲线，现在的算力已经相当惊人，这样就意味着，后面后200多万台专业的比特币矿机在运行！！！</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221653613-1651377316.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221654241-2079303848.png"></a></p> 
  <p>有人做了个估算，其耗电量比伊朗整个国家的耗电量还大。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221655233-1058424797.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221658007-2130150149.png"></a></p> 
  <p>比特币的POW算法是没有任何实际意义的SHA256运算，那么有没有可能在挖矿的同时，把这些算力算出一些副产物？以下是几个比较有名的进行有效工作量证明的区块链：</p> 
  <ul>
   <li>质数币：Primecoin（质数币）发布于2013年7月。其最大的特点是将虚拟货币中浪费的算法资源利用起来。它的PoW可以搜索质数，从而计算孪生素数表。所以有一定的科学价值。</li> 
   <li>治疗币：Curecoin（治疗币）发布于2013年5月。治疗币最大的特点是将蛋白质褶皱结构的研究SHA256工作量证明算法进行了结合。因为蛋白质褶皱研究需要对蛋白质进行生化反应的模拟过程需要大量的计算资源，所以在“挖矿”的同时，还用于发现治愈疾病的新药，一举两得。</li> 
   <li>比原链：比原链重新设计一种不同于比特币的哈希运算PoW共识机制，引入了矩阵运算与卷积运算，这样就能让人工智能运算充分利用比原链的挖矿设备。在这个过程中，人工智能加入了新的硬件，其算法运行速度得到明显提高。同时，这样也能减少一定的资源浪费。在这种情况下，矿机市场巨大的经济利益能够极大地加速人工智能ASIC芯片的发展，加快人工智能的研究。反过来，人工智能的快速发展也产生了更多的ASIC矿机需求。因此，这是一种正向反馈良性发展的过程。</li> 
  </ul>
  <h2>POS权益证明</h2> 
  <p>POW算法毕竟是要靠大量资源的消耗来保证共识的达成，有没有完全不需要靠计算机资源堆砌来保证的共识机制呢？在2011年，一个名为Quantum Mechanic的数字货币爱好者在Bitcointalk论坛提出Proof-of-Stake（POS）证明机制，该机制被充分讨论之后证明具有可行性。如果说POW主要比拼算力，算力越大，挖到一个块的概率越大，POS则是比拼余额，通俗说就是自己的手里的币越多，挖到一个块的概率越大。</p> 
  <p>POS共识算法存在一个漏洞，就是鼎鼎大名的Nothing-at-Stake攻击（常写作<a href="mailto:N@S" rel="nofollow">N@S</a>）。</p> 
  <p>假设系统中出现了两个分支链，那么对于持有币的”挖矿者“来讲，最佳的操作策略就是同时在两个分支上进行“挖矿”，这样，无论哪个分支胜出，对币种持有者来讲，都会获得本属于他的利益，即不会有利益损失。而且由于不需要算力消耗，因此PoS中在两个分支上挖矿是可行的。这导致的问题是，只要系统存在分叉，“矿工们”都会同时在这几个分支上挖矿；因此在某个情况下，发起攻击的分叉链是极有可能成功的，因为所有人也都在这个分叉链上达成了共识；而且甚至不用持有51%的币量，就可以成功发起分叉攻击。而这在PoW中是不可行的，因为挖矿需要消耗算力，矿工只能在一个分支上进行挖矿。所以在实际POS算法中，还需要加入一些惩罚机制，如果矿工被发现两个分支同时挖矿，就会进行惩罚。</p> 
  <h3>第一个POS虚拟货币——点点币</h3> 
  <p>Peercoin（点点币，PPC）于2012年8月发布，最大创新是其采矿方式混合了POW工作量证明及POS权益证明方式，其中POW主要用于发行货币，未来预计随着挖矿难度上升，产量降低，系统安全主要由POS维护。目前区块链中存在两种类型的区块，POW区块和POS区块。PPC的作者为同样不愿意公开身份的密码货币极客Sunny King，同时也是Primecoin的发明者。</p> 
  <h3>第一个纯POS虚拟货币——未来币</h3> 
  <p>2013年9月，一个名为BCNext的用户在Bitcointalk论坛发起一个帖子，宣布将发行一种全新的纯POS币种，后来取名为Nextcoin，简称NXT。Nxt是且是第一个100%的股权证明(PoS)机制的电子货币，Nxt不再通过消耗大量的资源“挖矿”产生新货币，而是通过现有账户的余额去“锻造”区块，并给与成功“锻造”区块的账户交易费用奖励。NXT的POS实现方式与PPC完全不同，合格区块判定方法为：</p> 
  <p>hit &lt; baseTarget * effectiveBalance * elapseTime</p> 
  <p>hit是根据最新区块和用户的私钥生成的值，用户在挖一个区块时只需要计算一次即可。而右边的值跟账户余额成正比，跟流逝的时间成正比。也就意味着，用户账户余额越多，挖到矿的几率越高，随着时间的流逝越久，越容易找到新的区块。NXT区块的生成完全摒弃了竞争的理念，有点“上帝早已安排好一切”的味道，下一个区块由谁来生成冥冥中早就注定了，全网节点能做的就是静静等待那一刻的到来。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221700799-428265758.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221701177-996771581.png"></a></p> 
  <p>POS的本质就是比谁的钱多，钱越多越容易挖到区块，这将会造成富者越富，资源越来越集中，从而变得更中心化。</p> 
  <h2>DPOS代理权益证明</h2> 
  <p>针对POW、POS的效率低和会变得越来越中心化的问题，BM在2013年8月启动的比特股BitShares项目则采用了DPOS共识算法。</p> 
  <h3>比特股</h3> 
  <p>比特股核心账本采用石墨稀技术，对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制——Delegated Proof-Of-Stake（DPOS），即代理股权证明。</p> 
  <p>DPOS很容易理解，类似于现代企业董事会制度，比特股系统将代币持有者称为股东，由股东投票选出101名代表，然后由这些代表负责产生区块。那么需要解决的核心问题主要有：代表如何被选出，代表如何自由退出“董事会”，代表之间如何协作产生区块等。持币者若想成为一名代表，需先拿自己的公钥去区块链注册，获得一个长度为32位的特有身份标识符，用户可以对这个标识符以交易的形式进行投票，得票数前101位被选为代表。代表们轮流产生区块，收益（交易手续费）平分。如果有代表不老实生产区块，很容易被其他代表和股东发现，他将立即被踢出“董事会”，空缺位置由票数排名102的代表自动填补。</p> 
  <p>从某种角度来说，DPOS可以理解为多中心系统，兼具去中心化和中心化优势。</p> 
  <h3>EOS</h3> 
  <p>另外目前最火的区块链项目之一EOS也是采用了DPOS共识。EOS通过投票的方式选举出21个超级节点作为记账节点，每个节点有3秒的时间片，轮流记账。如果轮到某节点记账而没有出块，则该节点可能被投票出局，由其他备选节点顶替。出块速度是0.5秒！</p> 
  <p>EOS.IO软件允许区块精准的以每0.5秒产生一个区块，只有一个生产者被授权在任何给定的时间点生产一个区块。如果区块在预定的时间没有被生产出来，那么，那个时间的区块将被跳过。当一个或多个区块被跳过，将会有0.5秒或更多秒的区块间隔。&nbsp;<br> 使用EOS.IO软件，区块以126个区块为一轮（每个生产者可以生产6个，有21个生产者，二者相乘）。在每一轮的开始，21个区块生产者通过token持有者的投票被选中。选中的生产者依据商定好的顺序生产区块，这个顺序由15个或者更多的生产者商定。&nbsp;<br> 如果一个生产者错过了一个区块，并且在24小时内没有生产任何区块，他们将会被移除。直到这些“宕机”的生产者们及时通知区块链，他们将打算再次生产区块才被重新加入。通过不安排那些不够可靠的节点，尽可能的减少错过区块创建，来让整个网络运行得更平稳。</p> 
  <p>DPOS的特殊性，也是奠定拜占庭容错能力的基础框架，是它的算力节点是固定21个人，并且由大型的机构运营节点，其信息也相对透明，例如运营节点的地点、运营的情况等等。并且DPOS的算力节点是固定出块顺序的，固定地从A到B到C······。</p> 
  <p>传统DPOS中加入了拜占庭容错算法（BFT），只要没有生产者盖上相同的时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块。一旦15个生产者签署了一个区块，该区块就被认为是不可逆转的。在这种模式下，不可逆转的共识应该在1秒内完成。&nbsp;<br><br> 在这种情况下，其实DPOS是拜占庭容错的特殊解，如何理解特殊解？原来的拜占庭容错（POW工作量证明），解决的是不限数量、随机广播同步的算力节点的容错能力，DPOS解决的拜占庭容错从两个维度降低了难度：&nbsp;<br><br> 1、节点数量固定只有21个。并且节点信息透明。&nbsp;<br> 2、固定出块顺序。每个节点跟接力棒一样，一个个往下接力出块。每个节点不能还没轮到它出块的时候，就出块。都是必须轮到再出块。如果出现出块故障，会跳过这个节点。&nbsp;<br><br> 在POW或者其他的POS共识里，节点不限、随机出块顺序的问题，就变成只要解决「固定数量和固定出块顺序情况下的拜占庭问题」，其难度就大大降低。</p> 
  <p>一直以来以太坊的创始人Vitalik和EOS创始人BM关于POW和DPOS谁更中心化进行互怼。Vitalik认为EOS的21个超级节点违反了区块链的去中心化原则，有失公平。而BM则认为几个几大矿池控制了比特币和以太坊的绝大部分算力，这相当于以太坊只有几个超级节点，比21个节点还要少，对手里拿着BTC和ETH的人他们对社区和整个生态，他们是没有确定的发言权的，在比特币的世界里算力就是王道，面对算力大量集中在部分矿场的现在，它真的实现了中本聪的本心了吗？同样需要挖矿POS也是一样，需要看概率来决定你能否发声，但是DPOS是有发言权的，不管持有多少，我都有发言权。这种看似由“直接民主”转为“间接民主”的机制，或许才是真正体现了去中心化精神。</p> 
  <p>以下是最新的比特币算力分布和以太坊的算力分布：</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221701557-842996479.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221702068-1510975338.png"></a><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221702502-1855345869.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221702972-1203517040.png"></a></p> 
  <h2>其他改进共识</h2> 
  <p>以上介绍到的PBFT、POW、POS和DPOS各有各的优缺点：</p> 
  <ul>
   <li>POW的能耗问题</li> 
   <li>POS/DPOS的中心化问题</li> 
   <li>PBFT的节点数问题</li> 
   <li>IP投票制币不够安全</li> 
  </ul>
  <p>有人仿照CAP不可能三角，也提出了区块链共识的不可能三角：环保节能、安全、去中心化，三者不可能同时满足，必有一方的弱化。设计一个既环保又安全的密码学货币，它必然是中心化的，比如PPcoin、Nextcoin、Ripple，它们要么本身就是中心化的架构，要么其去中心化的架构不可维持，它们本质上仍是PayPal、网银一样的中心化验证机制；设计一个既环保又去中心化的密码学货币，它必然是不安全的，比如IP投票制的P2P货币，中本聪起初就已排除了这种可能，他认为“如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，比如僵尸网络，就有可能主宰比特币网络”[vi]。设计一个安全的去中心化货币，它必然是以付出能源与计算力为代价。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221703519-2032275252.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221704133-542691759.png"></a></p> 
  <p>有时，我们可能需要根据区块链的场景，对原有共识算法进行改进。</p> 
  <h3>NEO的dBFT</h3> 
  <p>NEO采用的是 Delegated Byzantine Fault Tolerance (dBFT) 共识算法，由于它目前只有 7 个 代理节点，而代表节点则是通过用户投票选出。dBFT参与记账的是超级节点，普通节点可以看到共识过程，并同步账本信息，但不参与记账。总共n个超级节点分为一个议长和n-1个议员，议长会轮流当选。每次记账时，先有议长发起区块提案（拟记账的区块内容），一旦有至少（2n+1)/3个记账节点（议长加议员）同意了这个提案，那么这个提案就成为最终发布的区块，并且该区块是不可逆的，所有里面的交易都是百分之百确认的。</p> 
  <h3>以太坊的下一代POS共识：Casper</h3> 
  <p>Casper（投注共识）是一种以太坊下一代的共识机制，属于PoS。Casper的共识是按块达成的而不是像PoS那样按链达成的。</p> 
  <p>为了防止验证人在不同的世界中提供不同的投注，我们还有一个简单严格的条款：如果你有两次投注序号一样，或者说你提交了一个无法让Casper合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临着保证金被没收的风险。</p> 
  <p>Casper协议下的验证人需要完成出块和投注两个活动。具体如下：</p> 
  <p>出块是一个独立于其它所有事件而发生的过程：验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，签名，然后发送到网络上。投注的过程更为复杂一些。目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。&nbsp;<br> 而客户端的确认当前状态的过程如下所示：</p> 
  <p>一开始先下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见。它只要简单的按顺序在每个高度进行观察，如果一个块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后得到的状态就可以显示为区块链的“当前状态”。客户端还可以给出对于“最终确定”的主观看法：当高度k之前的每个块，意见要么高于99.999%或者低于0.001%，那么客户端就可以认为前k个块已经最终确定。</p> 
  <h3>IOTA和Byteball的DAG和相关共识</h3> 
  <p>IOTA和Byteball这种基于DAG结构的分布式账本技术，从概念上讲已经不能算是区块链了，因为在底层结构上，DAG中既没有区块也不是链。IOTA中使用Tangle（缠结）这种技术，使得每个交易在发出时也见证另外两个交易。Byteball采用的是11个见证人的方式，由见证人参与共识。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221704548-657250659.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221704891-50648080.png"></a></p> 
  <h3>HyperLedger Fabric下一代共识：SBFT</h3> 
  <p>PBFT在Fabric0.6的时候被采用，但是由于一些说不清的原因，在Fabric1.0中并没有采用PBFT，而是使用Kafka进行排序，作为共识节点。在Fabric的提案中，打算会采用SBFT（Simple BFT），这种BFT算法会对PBFT进行简化，具体什么时候实现还没准呢。</p> 
  <h2>PalletOne的陪审团共识</h2> 
  <p>在英美，陪审团制度是一个使用了几百年的共识制度，关于一个案件中嫌疑人是否有罪，是由随机抽选的陪审员组成陪审团共同决定的。提到陪审团，就不得不提一部非常经典的电影《十二怒汉》：</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221705315-121974813.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221705795-38668838.png"></a></p> 
  <p>《十二怒汉》讲述的是一个在贫民窟长大的18岁少年因为涉嫌杀害自己的父亲被告上法庭，证人言之凿凿，各方面的证据都对他极为不利。十二个不同职业的人组成了这个案件的陪审团，他们要在休息室达成一致的意见，裁定少年是否有罪，如果罪名成立，少年将会被判处死刑。&nbsp;<br> 《十二怒汉》通过一场陪审团审判，生动演绎了美国的法律制度与文化，是美国宣传法律和法律制度的“银法槌奖”的首部获奖作品。同名电影在IMDB上排名第五，高于《阿甘正传》《辛德勒的名单》等，是一部超越时代的经典之作！其中的一段台词也很能体现陪审团制度的特点：</p> 
  <p>“我们都肩负责任。我一直认为，这正是民主社会了不起的地方。我们接到邮件通知，大老远跑到这里，决定一个跟我们素昧平生的人到底有没有罪。不论作出什么样的裁决，我们都拿不到任何好处，也不会有任何损失。这正是我们国家强大的原因之一。我们不能把它当成个人的事”</p> 
  <p><a href="http://pallet.one/" rel="nofollow">PalletOne</a>提供了对各个底层链的抽象，用户使用常用的开发语言，基于对底层链的抽象接口进行操作。而合约的执行就是靠一个个的陪审团来完成的。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221706677-119632978.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221707026-416685126.png"></a></p> 
  <p>除了陪审团这个角色，在PalletOne中还有一个叫仲裁中介(Mediator)的角色，该角色是基于DPOS选举的，相当于现实生活中的法官的角色，在接到一个新的智能合约后，Mediator会随机选择陪审员组成陪审团，由该陪审团负责该智能合约的执行和共识。</p> 
  <p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221707358-1610831322.png" rel="nofollow"><img alt="image" class="has" src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221707731-1721061432.png"></a></p> 
  <p>陪审团共识与传统POW、POS等共识的不同之处在于，陪审团共识是一个并行的共识机制，在同一个时刻，有多个陪审团同时在执行不同的合约。为了配合陪审团的并行共识，PalletOne采用了DAG作为分布式存储，合约的状态数据可以并行写入DAG中。所以<a href="http://pallet.one/" rel="nofollow">PalletOne</a>使用陪审团并行共识+DAG的并行写入，可以实现极高的TPS。</p> 
  <h2>总结</h2> 
  <p>现在区块链上数字资产的应用越来越多来源于真实世界或金融资产，对交易的最终确认有很高的要求，需要有不同的共识机制。&nbsp;<br> 共识机制是区块链的核心技术，现在各种区块链共识机制的选择是认为至今为止的相对的最优选择；当未来区块链技术越来越多应用于现实，未来将会不断有所改进，以切合实际的需要。</p> 
  <p>共识算法的选择与应用场景高度相关，可信环境使用Paxos或者Raft，带许可的联盟可使用PBFT，非许可链可以是POW、POS、DPOS共识等。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weichanghu_/article/details/81584335,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weichanghu_/article/details/81584335,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
