<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【ERC875】HiBlock黑客马拉松门票从定制到编码实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【ERC875】HiBlock黑客马拉松门票从定制到编码实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 什么是代币(token)合约 【本文目标】 通过本文，可以从一个HiBlock黑客马拉松活动门票定制，转让，出售和签到为例，说明ERC875的设计初心，ERC875的标准接口分析，也给出了官网的ERC875的代码和本地测试，便于更多项目使用ERC875解决区块链业务中遇到的实际问题。 【前置条件】 （1）体验门票受让的用户不需要有任何技术门槛； （2）做门票定制和开发的需要本地已安装好MetaMASK，在Reposton Test Net获取了几个测试ETH（免费）的，要懂Solidity语言。 不熟悉的建议参考文档开发实战|3步教你在以太坊上开一家宠物店（附流程+代码）。 2 HiBlock黑客马拉松区块链门票全体验 2.1 门票定制创建 - [辉哥] ALPHA WALLET团队已经封装好了ERC785协议实现，可以通过浏览器完成票务类ERC875的智能合约创建。对应的TOKEN工厂网址为https://alpha-wallet.github.io/ERC875-token-factory/index.html 测试使用，MetaMASK选择的测试网络为”Ropsten Test Net”。 1） “Deploy Contract” 定义名称和标识，对应的地址是以太坊钱包地址。Owner Address必须为MetaMast的当前账号地址，然后点击“Deploy Contract”按钮。[名称和标识命名跟一般使用的搞反了，将就用吧] Contract Name: HHT Ticket Symbol: Hiblock Hackathon Ticket Owner Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 Recipient Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 提交合约部署 2）“Submmit”按钮 “Gas Price”设置为30，点击“Submmit”按钮。该账号要有一定的ETH测试币，否则点击”Buy”找平台免费买点。 确认交易 3）购买成功确认 购买成功的会有弹出提示。点击“确定”按钮后，拉到下方的按钮可以查看智能合约部署链接和ABI合约信息。 合约部署成功 查看ABI信息和合约记录 4）查看部署合约成功地址 点击可知其部署成功：https://ropsten.etherscan.io/address/0x07fc44d796d30b317013cb907fadb6d738f5779e 2.2 安装APP，导入钱包，导入门票 - [辉哥] 1） 安装APP 辉哥在官网（https://awallet.io/）下载APP完成安装。 2） 导入钱包 点击配置页面，更换网络为”Ropsten(Test)”网络，导入创建门票的钱包私钥。 3）添加代币 输入之前的智能合约地址，符号和名称会自动联想出来的。 导入成功后，钱包页面可以看到对应的通证信息。如果是没有这个资产的钱包导入这个通证，钱包页面是看不到这个通证门票的。 2.3 转让门票 - [辉哥-欧阳哥哥] 通过报名渠道，辉哥知道欧阳哥哥已报名参加HiBlock黑客马拉松，所以把区块链门票转给他。 1） 辉哥点击“转让”按钮 选择HHT后，点击右下角的“转让”按钮进行票务转让。 2）点击“转让”按钮 选择“现在直接转让门票”， 获取欧阳哥哥的钱包地址，输入： 输入欧阳哥哥的钱包地址 3）确认转让 转让门票按钮 转账成功 2.4 出售门票 - [欧阳哥哥-小辉] 1）导入通证 欧阳哥哥在AlphaWallet钱包中输入HHT的合约地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）即可查看到辉哥转账过来的门票通证。 2） 出售门票 小辉同学知道了黑客马拉松的事情，也很想参加。欧阳哥哥刚好弄了2张票，就同意把一张票低价转让给小辉。双方协商好价格是0.2个ETH。 欧阳哥哥点击出售按钮，设置好价格，最后链接通过微信发给小辉。 设置价格 设置截止时间 确认出售，把链接微信发给小辉 3） 导入支付 小辉安装好APP。复制链接打开APP时，会提示导入门票。点击购买，支付了0.2个ETH后即可完成支付。 门票 确认购买 购买成功 4） 导入代币地址完成呈现 小辉在钱包导入HHT智能合约的地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）后，即可在APP上呈现购买的HHT门票一张。 2.5 兑现门票 欧阳哥哥和小辉到达HiBlock黑客马拉松现场，点击门票的“兑换”按钮，主办方Bob根据他们展示的二维码扫描完成。该门票的状态会变更为已兑换。 【后记】他们组队参加黑客马拉松，依靠其过硬的技术实力，获得了一个二等奖！ 3 ERC875设计目标 AlphaWallet团队核心成员 （左二：CEO张中南；右二：创始人兼CTO张韡武） ERC875协议是由AlphaWallet团队提出的，他们希望基于ERC875协议族，能够实现人、事、物、权token化。 在创始人张中南看来，人、事、物、权全部token化，即可以用token来替代物理世界里面的任何商品。在此其中，token替代的是一个权益，可以指代各种各样的权益。比如，「人」的token化，「跟吴亦凡今天晚上6点钟到8点钟一起吃饭的权益，可以做成一个token」，「事」的token化，「用信用卡在商店买了一瓶水，也可以做成一个token」，而「物」、「权」的token化，就更好理解了。 将人、事、物、权token化，可以有不同层级的愿景和意义。张中南介绍： 第一层级，简单的来说，就是把 人、事、物、权做成token，放到区块链上面流通，或者说放到钱包里，做成APP，能够使用token做流转。 再往上一个级别，是这些token和token之间的交互。比如，可能有一件事，可以同时调用7、8个token，不再是简单的转让或流通。 再往上一个级别，「我们能够看到最远的地方就是这些token用来指代人、事、物、权之后，它们本身可以变成一个集成点，可以在用户端集成各种各样的服务和应用。比如，租车服务、保险、信用卡公司等，当需要调用他们的服务时，不再通过微信来使用，而是直接在用户端就能集成。 现阶段，为了实现初级目标，AlphaWallet选择从一款可编程钱包切入。今年5月23日，该公司正式发布了这款筹备已久的钱包产品——AlphaWallet 1.0版。 公开资料显示，这是一款直接支持不可替代性token的钱包，可作为连接虚拟世界和真实世界的网关。基于该钱包之上，真实世界内的生活服务可利用区块链技术而具备强有力的基础技术平台，从而拥有无限想象的可能性。 通常来说，大量token广泛使用的是ERC20协议。遵循ERC20的token可以跟踪任何人在任何时候拥有多少token。在一些开源组织的推动下，目前第三方基于ERC20接口5分钟即能发行一个ERC20的token。不过，相对来说，ERC20还存在两个问题： 第一，ERC20无法代表现实世界中无法拆分、独一无二的资产； 第二，现有的打包、转账流程复杂，ERC20缺乏可扩展性，无法实现更复杂的功能。 基于此，AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 张中南向雷锋网AI金融评论介绍称，ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 首个落地应用：体育票务 或许与张中南在票务业务的经历有关，AlphaWallet选择从ERC875和钱包切入的第一个use case就是俄罗斯世界杯门票。 相较人、事而言，「票务」由于具备物理和权益属性，利用区块链技术来实现不可置换的token的流转，更具操作性和可行性。 目前 AlphaWallet 已与盛开体育达成合作。今年的俄罗斯世界杯，二者联合引入区块链技术以测试新的票务解决方案，将盛开体育世界杯票库内的部分门票转化为以太坊上的ERC875的token。由于这些token具有不可置换性，用户通过AlphaWallet钱包的动态二维码，以及线下的现场扫描，即可获得世界杯门票。考虑到进一步安全的问题，AlphaWallet钱包显示的动态二维码，每隔10s就会变一次。 AlphaWallet钱包兑换俄罗斯世界杯门票（test）流程体验 据张中南介绍，这次合作，「盛开那边做了10张票，AlphaWallet则拿了10张开幕式的VIP门票，所以一共只有20张门票」。经过雷锋网AI金融评论现场测试体验，通过AlphaWallet钱包流转一张世界杯门票，所花时间在4-7s以内。而买方从卖方手里通过支付以太坊的方式买入一张门票，所需时间则在10s左右。 「这应该是目前世界上首个不可替代通证与现实物权交互的落地案例。」团队向雷锋网AI金融评论表示。 除票务外，AlphaWallet近期还会继续考虑在「物」上面开发use case，主要专注在物理商品这一块，如 奢侈手表和限量球鞋等等。 不过，也有业内人士指出，通过不可置换协议，从token到实物的映射，可能还是难以避免实物造假的情况，这点又该如何防范？在张中南看来，给物理商品配备数字身份证，是通过经济学原理来实现防伪的。这点与溯源、防伪等又不一样。 4 ERC875标准 function name() constant returns (string name) 返回智能合约的名字，例如CarLotContract。 function symbol() constant returns (string symbol) 返回智能合约通证的标识符。 function balanceOf(address _owner) public view returns (uint256[] balance) 返回一组账户余额的数组。 function transfer(address _to, uint256[] _toke****ns) public; 通过包含通证索引的数组参数，把一组独一无二的通证转移给一个账户地址。相比ERC721一次只能转账一个通证，ERC875更显友好，它可以一次批量转账一组通证。这样既便利又能节约大量的GAS消耗。 function transferFrom(address _from, address _to, uint256[] _tokens) public; 从一个账户给另一个账户转账批量通证。这个可由一个获得特定KEY例如合同创建者的授权的账号来完成。 【以下为可选函数】 function totalSupply() constant returns (uint256 totalSupply); 返回给定合同的通证总数。这个通证总数可能是可变的。 function ownerOf(uint256 _tokenId) public view returns (address _owner); 返回特定通证的拥有者。这个函数是可选的，因为并不是每一个通证合约都需要跟踪每一个独一无二通知的拥有者，并且每次查询需要消耗GAS用于遍历和匹配token id于拥有者的关系。 function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable 该函数允许用户出售一组非同质通证而不需要支付GAS费，只需要购买者支付。这是通过签署包含要销售的代币数量，合同地址，到期时间戳，价格和包含ERC规范名称和链ID的前缀的证明来实现的。然后，买方可以通过附加适当的以太币（ether）来满足交易，从而在一次交易中支付交易。 这种设计也更有效，因为它允许订单在离线前完成，而不是在智能合约中创建订单并更新订单。到期时间戳保护卖方免受使用旧订单的人的影响。 这为点对点(p2p)原子交换(atomic swap)打开了大门，但对于这个标准应该是可选的，因为有些可能没有用它。 需要在消息中添加一些保护，例如编码链ID，合同地址和ERC规范名称，以防止重放和欺骗人们签署允许交易的消息。 5 ERC875样例代码 官方给出的ERC875代码样例如下，函数含义参考第4章。 contract ERC { event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); function name() constant public returns (string name); function symbol() constant public returns (string symbol); function balanceOf(address _owner) public view returns (uint256[] _balances); //function ownerOf(uint256 _tokenId) public view returns (address _owner); function transfer(address _to, uint256[] _tokens) public; function transferFrom(address _from, address _to, uint256[] _tokens) public; //optional //function totalSupply() public constant returns (uint256 totalSupply); function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable; } pragma solidity ^0.4.17; contract Token is ERC{ uint totalTickets; mapping(address =&gt; uint256[]) inventory; uint16 ticketIndex = 0; //to track mapping in tickets uint expiryTimeStamp; address owner; // the address that calls selfdestruct() and takes fees address admin; uint transferFee; uint numOfTransfers = 0; string public name; string public symbol; uint8 public constant decimals = 0; //no decimals as tickets cannot be split event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); event TransferFrom(address indexed _from, address indexed _to, uint _value); modifier adminOnly() { if(msg.sender != admin) revert(); else _; } function() public { revert(); } //should not send any ether directly // example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJ comeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot; function Token( uint256[] numberOfTokens, string evName, uint expiry, string eventSymbol, address adminAddr) public { totalTickets = numberOfTokens.length; //assign some tickets to event admin expiryTimeStamp = expiry; owner = msg.sender; admin = adminAddr; inventory[admin] = numberOfTokens; symbol = eventSymbol; name = evName; } function getDecimals() public pure returns(uint) { return decimals; } // price is 1 in the example and the contract address is 0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005 // example: 0, [3, 4], 27, &quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;, &quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; // price is encoded in the server and the msg.value is added to the message digest, // if the message digest is thus invalid then either the price or something else in the message is invalid function trade(uint256 expiry, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable { //checks expiry timestamp, //if fake timestamp is added then message verification will fail require(expiry &gt; block.timestamp || expiry == 0); //id 1 for mainnet bytes12 prefix = &quot;ERC800-CNID1&quot;; bytes32 message = encodeMessage(prefix, msg.value, expiry, tokenIndices); address seller = ecrecover(message, v, r, s); for(uint i = 0; i &lt; tokenIndices.length; i++) { // transfer each individual tickets in the ask order uint index = uint(tokenIndices[i]); require((inventory[seller][index] &gt; 0)); // 0 means ticket sold. inventory[msg.sender].push(inventory[seller][index]); inventory[seller][index] = 0; // 0 means ticket sold. } seller.transfer(msg.value); } //must also sign in the contractAddress //prefix must contain ERC and chain id function encodeMessage(bytes12 prefix, uint value, uint expiry, uint256[] tokenIndices) internal view returns (bytes32) { bytes memory message = new bytes(96 + tokenIndices.length * 2); address contractAddress = getContractAddress(); for (uint i = 0; i &lt; 32; i++) { // convert bytes32 to bytes[32] // this adds the price to the message message[i] = byte(bytes32(value &lt;&lt; (8 * i))); } for (i = 0; i &lt; 32; i++) { message[i + 32] = byte(bytes32(expiry &lt;&lt; (8 * i))); } for(i = 0; i &lt; 12; i++) { message[i + 64] = byte(prefix &lt;&lt; (8 * i)); } for(i = 0; i &lt; 20; i++) { message[76 + i] = byte(bytes20(bytes20(contractAddress) &lt;&lt; (8 * i))); } for (i = 0; i &lt; tokenIndices.length; i++) { // convert int[] to bytes message[96 + i * 2 ] = byte(tokenIndices[i] &gt;&gt; 8); message[96 + i * 2 + 1] = byte(tokenIndices[i]); } return keccak256(message); } function name() public view returns(string) { return name; } function symbol() public view returns(string) { return symbol; } function getAmountTransferred() public view returns (uint) { return numOfTransfers; } function isContractExpired() public view returns (bool) { if(block.timestamp &gt; expiryTimeStamp) { return true; } else return false; } function balanceOf(address _owner) public view returns (uint256[]) { return inventory[_owner]; } function myBalance() public view returns(uint256[]) { return inventory[msg.sender]; } function transfer(address _to, uint256[] tokenIndices) public { for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[msg.sender][i] != 0); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[msg.sender][index] = 0; } } function transferFrom(address _from, address _to, uint256[] tokenIndices) adminOnly public { bool isadmin = msg.sender == admin; for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[_from][i] != 0 || isadmin); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[_from][index] = 0; } } function endContract() public { if(msg.sender == owner) { selfdestruct(owner); } else revert(); } function getContractAddress() public view returns(address) { return this; } } 【函数说明】 1，trade函数是发起批量转让的智能合约函数 trade(uint256 expiry,/超时时间，以s计算/ uint256[] tokenIndices, /通证索引/ uint8 v, /v,r,s是卖家签名的3个部分，产生的方法参考文件（https://github.com/alpha-wallet/ERC875-Example/blob/master/TradeImplementationExample.java） / bytes32 r, bytes32 s ) 6 ERC875测试(REMIX+MetaMASK环境) 6.1 创建合约 [1] 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）构建函数CREATE [101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115], “DJ Family”, 1603152000, “DJ”, “0xca35b7d915458ef540ade6068dfe2f44e8fa733c” 【结果】 智能合约创建成功，得到智能合约地址：0x692a70d2e424a56d2c6c27aa97d1a86395877b3a 6.2 门票转让 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）转移2张座位号为101,102的门票给李四(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db) transfer(“0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db”, [0,1]) 【结果】：门票已转让给李四,李四并没有消耗GAS，是管理员消耗了GAS。 6.3 trade门票 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）把门票trade给赵六(0xdd870fa1b7c4700f2bd7f44238821c26f7392148) 当智能合约地址为0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005，price is 1时， trade(0, [3, 4], 27, “0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB”, “0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2”) 【结果】操作失败了，也无法触发购买。 【官方答复】 那个Trade function的功能是，在卖家发了签名信息给买家，然后买家联合卖家的签名信息和自己的签名信息一起call trade fundction来完成交易。你在现在的模式，是创建不出来卖家签名信息的， 你需要参考AlphaWallet的代码。 源码参考地址： https://github.com/alpha-wallet/AlphaWallet-Mobile-Apps 7 参考文档 1） 2018世界杯门票的一笔交易记录（https://etherscan.io/tx/0x4675bf0bddfb4a68acd224d22ca810484a82920b26365e1d39bd354fd8e76d48#decodetab） 2） 深入浅出以太坊ERC875标准（不可替代性通证标准）（http://8btc.com/article-4614-1.html） 3） AlphaWallet野心有点大：基于ERC875协议族，实现人、事、物、权token化（http://itech.ifeng.com/45021842/news.shtml） 4）ERC875 for non fungible tokens and simple atomic swaps（https://github.com/ethereum/EIPs/issues/875） 5） AlphaWallet代码（https://github.com/alpha-wallet） 6） ERC875智能合约案例 （TradeImplementationExample.java 和ERCTokenImplementation.sol）（https://github.com/alpha-wallet/ERC875-Example） 7） AlphaWallet钱包下载-支持测试网络代币（https://awallet.io/） 本文作者：HiBlock区块链技术布道群-辉哥 原文发布于简书：https://www.jianshu.com/p/ddaa0d3643ce 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<meta property="og:description" content="1 什么是代币(token)合约 【本文目标】 通过本文，可以从一个HiBlock黑客马拉松活动门票定制，转让，出售和签到为例，说明ERC875的设计初心，ERC875的标准接口分析，也给出了官网的ERC875的代码和本地测试，便于更多项目使用ERC875解决区块链业务中遇到的实际问题。 【前置条件】 （1）体验门票受让的用户不需要有任何技术门槛； （2）做门票定制和开发的需要本地已安装好MetaMASK，在Reposton Test Net获取了几个测试ETH（免费）的，要懂Solidity语言。 不熟悉的建议参考文档开发实战|3步教你在以太坊上开一家宠物店（附流程+代码）。 2 HiBlock黑客马拉松区块链门票全体验 2.1 门票定制创建 - [辉哥] ALPHA WALLET团队已经封装好了ERC785协议实现，可以通过浏览器完成票务类ERC875的智能合约创建。对应的TOKEN工厂网址为https://alpha-wallet.github.io/ERC875-token-factory/index.html 测试使用，MetaMASK选择的测试网络为”Ropsten Test Net”。 1） “Deploy Contract” 定义名称和标识，对应的地址是以太坊钱包地址。Owner Address必须为MetaMast的当前账号地址，然后点击“Deploy Contract”按钮。[名称和标识命名跟一般使用的搞反了，将就用吧] Contract Name: HHT Ticket Symbol: Hiblock Hackathon Ticket Owner Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 Recipient Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 提交合约部署 2）“Submmit”按钮 “Gas Price”设置为30，点击“Submmit”按钮。该账号要有一定的ETH测试币，否则点击”Buy”找平台免费买点。 确认交易 3）购买成功确认 购买成功的会有弹出提示。点击“确定”按钮后，拉到下方的按钮可以查看智能合约部署链接和ABI合约信息。 合约部署成功 查看ABI信息和合约记录 4）查看部署合约成功地址 点击可知其部署成功：https://ropsten.etherscan.io/address/0x07fc44d796d30b317013cb907fadb6d738f5779e 2.2 安装APP，导入钱包，导入门票 - [辉哥] 1） 安装APP 辉哥在官网（https://awallet.io/）下载APP完成安装。 2） 导入钱包 点击配置页面，更换网络为”Ropsten(Test)”网络，导入创建门票的钱包私钥。 3）添加代币 输入之前的智能合约地址，符号和名称会自动联想出来的。 导入成功后，钱包页面可以看到对应的通证信息。如果是没有这个资产的钱包导入这个通证，钱包页面是看不到这个通证门票的。 2.3 转让门票 - [辉哥-欧阳哥哥] 通过报名渠道，辉哥知道欧阳哥哥已报名参加HiBlock黑客马拉松，所以把区块链门票转给他。 1） 辉哥点击“转让”按钮 选择HHT后，点击右下角的“转让”按钮进行票务转让。 2）点击“转让”按钮 选择“现在直接转让门票”， 获取欧阳哥哥的钱包地址，输入： 输入欧阳哥哥的钱包地址 3）确认转让 转让门票按钮 转账成功 2.4 出售门票 - [欧阳哥哥-小辉] 1）导入通证 欧阳哥哥在AlphaWallet钱包中输入HHT的合约地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）即可查看到辉哥转账过来的门票通证。 2） 出售门票 小辉同学知道了黑客马拉松的事情，也很想参加。欧阳哥哥刚好弄了2张票，就同意把一张票低价转让给小辉。双方协商好价格是0.2个ETH。 欧阳哥哥点击出售按钮，设置好价格，最后链接通过微信发给小辉。 设置价格 设置截止时间 确认出售，把链接微信发给小辉 3） 导入支付 小辉安装好APP。复制链接打开APP时，会提示导入门票。点击购买，支付了0.2个ETH后即可完成支付。 门票 确认购买 购买成功 4） 导入代币地址完成呈现 小辉在钱包导入HHT智能合约的地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）后，即可在APP上呈现购买的HHT门票一张。 2.5 兑现门票 欧阳哥哥和小辉到达HiBlock黑客马拉松现场，点击门票的“兑换”按钮，主办方Bob根据他们展示的二维码扫描完成。该门票的状态会变更为已兑换。 【后记】他们组队参加黑客马拉松，依靠其过硬的技术实力，获得了一个二等奖！ 3 ERC875设计目标 AlphaWallet团队核心成员 （左二：CEO张中南；右二：创始人兼CTO张韡武） ERC875协议是由AlphaWallet团队提出的，他们希望基于ERC875协议族，能够实现人、事、物、权token化。 在创始人张中南看来，人、事、物、权全部token化，即可以用token来替代物理世界里面的任何商品。在此其中，token替代的是一个权益，可以指代各种各样的权益。比如，「人」的token化，「跟吴亦凡今天晚上6点钟到8点钟一起吃饭的权益，可以做成一个token」，「事」的token化，「用信用卡在商店买了一瓶水，也可以做成一个token」，而「物」、「权」的token化，就更好理解了。 将人、事、物、权token化，可以有不同层级的愿景和意义。张中南介绍： 第一层级，简单的来说，就是把 人、事、物、权做成token，放到区块链上面流通，或者说放到钱包里，做成APP，能够使用token做流转。 再往上一个级别，是这些token和token之间的交互。比如，可能有一件事，可以同时调用7、8个token，不再是简单的转让或流通。 再往上一个级别，「我们能够看到最远的地方就是这些token用来指代人、事、物、权之后，它们本身可以变成一个集成点，可以在用户端集成各种各样的服务和应用。比如，租车服务、保险、信用卡公司等，当需要调用他们的服务时，不再通过微信来使用，而是直接在用户端就能集成。 现阶段，为了实现初级目标，AlphaWallet选择从一款可编程钱包切入。今年5月23日，该公司正式发布了这款筹备已久的钱包产品——AlphaWallet 1.0版。 公开资料显示，这是一款直接支持不可替代性token的钱包，可作为连接虚拟世界和真实世界的网关。基于该钱包之上，真实世界内的生活服务可利用区块链技术而具备强有力的基础技术平台，从而拥有无限想象的可能性。 通常来说，大量token广泛使用的是ERC20协议。遵循ERC20的token可以跟踪任何人在任何时候拥有多少token。在一些开源组织的推动下，目前第三方基于ERC20接口5分钟即能发行一个ERC20的token。不过，相对来说，ERC20还存在两个问题： 第一，ERC20无法代表现实世界中无法拆分、独一无二的资产； 第二，现有的打包、转账流程复杂，ERC20缺乏可扩展性，无法实现更复杂的功能。 基于此，AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 张中南向雷锋网AI金融评论介绍称，ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 首个落地应用：体育票务 或许与张中南在票务业务的经历有关，AlphaWallet选择从ERC875和钱包切入的第一个use case就是俄罗斯世界杯门票。 相较人、事而言，「票务」由于具备物理和权益属性，利用区块链技术来实现不可置换的token的流转，更具操作性和可行性。 目前 AlphaWallet 已与盛开体育达成合作。今年的俄罗斯世界杯，二者联合引入区块链技术以测试新的票务解决方案，将盛开体育世界杯票库内的部分门票转化为以太坊上的ERC875的token。由于这些token具有不可置换性，用户通过AlphaWallet钱包的动态二维码，以及线下的现场扫描，即可获得世界杯门票。考虑到进一步安全的问题，AlphaWallet钱包显示的动态二维码，每隔10s就会变一次。 AlphaWallet钱包兑换俄罗斯世界杯门票（test）流程体验 据张中南介绍，这次合作，「盛开那边做了10张票，AlphaWallet则拿了10张开幕式的VIP门票，所以一共只有20张门票」。经过雷锋网AI金融评论现场测试体验，通过AlphaWallet钱包流转一张世界杯门票，所花时间在4-7s以内。而买方从卖方手里通过支付以太坊的方式买入一张门票，所需时间则在10s左右。 「这应该是目前世界上首个不可替代通证与现实物权交互的落地案例。」团队向雷锋网AI金融评论表示。 除票务外，AlphaWallet近期还会继续考虑在「物」上面开发use case，主要专注在物理商品这一块，如 奢侈手表和限量球鞋等等。 不过，也有业内人士指出，通过不可置换协议，从token到实物的映射，可能还是难以避免实物造假的情况，这点又该如何防范？在张中南看来，给物理商品配备数字身份证，是通过经济学原理来实现防伪的。这点与溯源、防伪等又不一样。 4 ERC875标准 function name() constant returns (string name) 返回智能合约的名字，例如CarLotContract。 function symbol() constant returns (string symbol) 返回智能合约通证的标识符。 function balanceOf(address _owner) public view returns (uint256[] balance) 返回一组账户余额的数组。 function transfer(address _to, uint256[] _toke****ns) public; 通过包含通证索引的数组参数，把一组独一无二的通证转移给一个账户地址。相比ERC721一次只能转账一个通证，ERC875更显友好，它可以一次批量转账一组通证。这样既便利又能节约大量的GAS消耗。 function transferFrom(address _from, address _to, uint256[] _tokens) public; 从一个账户给另一个账户转账批量通证。这个可由一个获得特定KEY例如合同创建者的授权的账号来完成。 【以下为可选函数】 function totalSupply() constant returns (uint256 totalSupply); 返回给定合同的通证总数。这个通证总数可能是可变的。 function ownerOf(uint256 _tokenId) public view returns (address _owner); 返回特定通证的拥有者。这个函数是可选的，因为并不是每一个通证合约都需要跟踪每一个独一无二通知的拥有者，并且每次查询需要消耗GAS用于遍历和匹配token id于拥有者的关系。 function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable 该函数允许用户出售一组非同质通证而不需要支付GAS费，只需要购买者支付。这是通过签署包含要销售的代币数量，合同地址，到期时间戳，价格和包含ERC规范名称和链ID的前缀的证明来实现的。然后，买方可以通过附加适当的以太币（ether）来满足交易，从而在一次交易中支付交易。 这种设计也更有效，因为它允许订单在离线前完成，而不是在智能合约中创建订单并更新订单。到期时间戳保护卖方免受使用旧订单的人的影响。 这为点对点(p2p)原子交换(atomic swap)打开了大门，但对于这个标准应该是可选的，因为有些可能没有用它。 需要在消息中添加一些保护，例如编码链ID，合同地址和ERC规范名称，以防止重放和欺骗人们签署允许交易的消息。 5 ERC875样例代码 官方给出的ERC875代码样例如下，函数含义参考第4章。 contract ERC { event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); function name() constant public returns (string name); function symbol() constant public returns (string symbol); function balanceOf(address _owner) public view returns (uint256[] _balances); //function ownerOf(uint256 _tokenId) public view returns (address _owner); function transfer(address _to, uint256[] _tokens) public; function transferFrom(address _from, address _to, uint256[] _tokens) public; //optional //function totalSupply() public constant returns (uint256 totalSupply); function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable; } pragma solidity ^0.4.17; contract Token is ERC{ uint totalTickets; mapping(address =&gt; uint256[]) inventory; uint16 ticketIndex = 0; //to track mapping in tickets uint expiryTimeStamp; address owner; // the address that calls selfdestruct() and takes fees address admin; uint transferFee; uint numOfTransfers = 0; string public name; string public symbol; uint8 public constant decimals = 0; //no decimals as tickets cannot be split event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); event TransferFrom(address indexed _from, address indexed _to, uint _value); modifier adminOnly() { if(msg.sender != admin) revert(); else _; } function() public { revert(); } //should not send any ether directly // example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJ comeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot; function Token( uint256[] numberOfTokens, string evName, uint expiry, string eventSymbol, address adminAddr) public { totalTickets = numberOfTokens.length; //assign some tickets to event admin expiryTimeStamp = expiry; owner = msg.sender; admin = adminAddr; inventory[admin] = numberOfTokens; symbol = eventSymbol; name = evName; } function getDecimals() public pure returns(uint) { return decimals; } // price is 1 in the example and the contract address is 0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005 // example: 0, [3, 4], 27, &quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;, &quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; // price is encoded in the server and the msg.value is added to the message digest, // if the message digest is thus invalid then either the price or something else in the message is invalid function trade(uint256 expiry, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable { //checks expiry timestamp, //if fake timestamp is added then message verification will fail require(expiry &gt; block.timestamp || expiry == 0); //id 1 for mainnet bytes12 prefix = &quot;ERC800-CNID1&quot;; bytes32 message = encodeMessage(prefix, msg.value, expiry, tokenIndices); address seller = ecrecover(message, v, r, s); for(uint i = 0; i &lt; tokenIndices.length; i++) { // transfer each individual tickets in the ask order uint index = uint(tokenIndices[i]); require((inventory[seller][index] &gt; 0)); // 0 means ticket sold. inventory[msg.sender].push(inventory[seller][index]); inventory[seller][index] = 0; // 0 means ticket sold. } seller.transfer(msg.value); } //must also sign in the contractAddress //prefix must contain ERC and chain id function encodeMessage(bytes12 prefix, uint value, uint expiry, uint256[] tokenIndices) internal view returns (bytes32) { bytes memory message = new bytes(96 + tokenIndices.length * 2); address contractAddress = getContractAddress(); for (uint i = 0; i &lt; 32; i++) { // convert bytes32 to bytes[32] // this adds the price to the message message[i] = byte(bytes32(value &lt;&lt; (8 * i))); } for (i = 0; i &lt; 32; i++) { message[i + 32] = byte(bytes32(expiry &lt;&lt; (8 * i))); } for(i = 0; i &lt; 12; i++) { message[i + 64] = byte(prefix &lt;&lt; (8 * i)); } for(i = 0; i &lt; 20; i++) { message[76 + i] = byte(bytes20(bytes20(contractAddress) &lt;&lt; (8 * i))); } for (i = 0; i &lt; tokenIndices.length; i++) { // convert int[] to bytes message[96 + i * 2 ] = byte(tokenIndices[i] &gt;&gt; 8); message[96 + i * 2 + 1] = byte(tokenIndices[i]); } return keccak256(message); } function name() public view returns(string) { return name; } function symbol() public view returns(string) { return symbol; } function getAmountTransferred() public view returns (uint) { return numOfTransfers; } function isContractExpired() public view returns (bool) { if(block.timestamp &gt; expiryTimeStamp) { return true; } else return false; } function balanceOf(address _owner) public view returns (uint256[]) { return inventory[_owner]; } function myBalance() public view returns(uint256[]) { return inventory[msg.sender]; } function transfer(address _to, uint256[] tokenIndices) public { for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[msg.sender][i] != 0); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[msg.sender][index] = 0; } } function transferFrom(address _from, address _to, uint256[] tokenIndices) adminOnly public { bool isadmin = msg.sender == admin; for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[_from][i] != 0 || isadmin); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[_from][index] = 0; } } function endContract() public { if(msg.sender == owner) { selfdestruct(owner); } else revert(); } function getContractAddress() public view returns(address) { return this; } } 【函数说明】 1，trade函数是发起批量转让的智能合约函数 trade(uint256 expiry,/超时时间，以s计算/ uint256[] tokenIndices, /通证索引/ uint8 v, /v,r,s是卖家签名的3个部分，产生的方法参考文件（https://github.com/alpha-wallet/ERC875-Example/blob/master/TradeImplementationExample.java） / bytes32 r, bytes32 s ) 6 ERC875测试(REMIX+MetaMASK环境) 6.1 创建合约 [1] 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）构建函数CREATE [101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115], “DJ Family”, 1603152000, “DJ”, “0xca35b7d915458ef540ade6068dfe2f44e8fa733c” 【结果】 智能合约创建成功，得到智能合约地址：0x692a70d2e424a56d2c6c27aa97d1a86395877b3a 6.2 门票转让 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）转移2张座位号为101,102的门票给李四(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db) transfer(“0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db”, [0,1]) 【结果】：门票已转让给李四,李四并没有消耗GAS，是管理员消耗了GAS。 6.3 trade门票 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）把门票trade给赵六(0xdd870fa1b7c4700f2bd7f44238821c26f7392148) 当智能合约地址为0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005，price is 1时， trade(0, [3, 4], 27, “0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB”, “0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2”) 【结果】操作失败了，也无法触发购买。 【官方答复】 那个Trade function的功能是，在卖家发了签名信息给买家，然后买家联合卖家的签名信息和自己的签名信息一起call trade fundction来完成交易。你在现在的模式，是创建不出来卖家签名信息的， 你需要参考AlphaWallet的代码。 源码参考地址： https://github.com/alpha-wallet/AlphaWallet-Mobile-Apps 7 参考文档 1） 2018世界杯门票的一笔交易记录（https://etherscan.io/tx/0x4675bf0bddfb4a68acd224d22ca810484a82920b26365e1d39bd354fd8e76d48#decodetab） 2） 深入浅出以太坊ERC875标准（不可替代性通证标准）（http://8btc.com/article-4614-1.html） 3） AlphaWallet野心有点大：基于ERC875协议族，实现人、事、物、权token化（http://itech.ifeng.com/45021842/news.shtml） 4）ERC875 for non fungible tokens and simple atomic swaps（https://github.com/ethereum/EIPs/issues/875） 5） AlphaWallet代码（https://github.com/alpha-wallet） 6） ERC875智能合约案例 （TradeImplementationExample.java 和ERCTokenImplementation.sol）（https://github.com/alpha-wallet/ERC875-Example） 7） AlphaWallet钱包下载-支持测试网络代币（https://awallet.io/） 本文作者：HiBlock区块链技术布道群-辉哥 原文发布于简书：https://www.jianshu.com/p/ddaa0d3643ce 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/09/899b77101319a89e3702058490b33759.html" />
<meta property="og:url" content="https://mlh.app/2018/08/09/899b77101319a89e3702058490b33759.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1 什么是代币(token)合约 【本文目标】 通过本文，可以从一个HiBlock黑客马拉松活动门票定制，转让，出售和签到为例，说明ERC875的设计初心，ERC875的标准接口分析，也给出了官网的ERC875的代码和本地测试，便于更多项目使用ERC875解决区块链业务中遇到的实际问题。 【前置条件】 （1）体验门票受让的用户不需要有任何技术门槛； （2）做门票定制和开发的需要本地已安装好MetaMASK，在Reposton Test Net获取了几个测试ETH（免费）的，要懂Solidity语言。 不熟悉的建议参考文档开发实战|3步教你在以太坊上开一家宠物店（附流程+代码）。 2 HiBlock黑客马拉松区块链门票全体验 2.1 门票定制创建 - [辉哥] ALPHA WALLET团队已经封装好了ERC785协议实现，可以通过浏览器完成票务类ERC875的智能合约创建。对应的TOKEN工厂网址为https://alpha-wallet.github.io/ERC875-token-factory/index.html 测试使用，MetaMASK选择的测试网络为”Ropsten Test Net”。 1） “Deploy Contract” 定义名称和标识，对应的地址是以太坊钱包地址。Owner Address必须为MetaMast的当前账号地址，然后点击“Deploy Contract”按钮。[名称和标识命名跟一般使用的搞反了，将就用吧] Contract Name: HHT Ticket Symbol: Hiblock Hackathon Ticket Owner Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 Recipient Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89 提交合约部署 2）“Submmit”按钮 “Gas Price”设置为30，点击“Submmit”按钮。该账号要有一定的ETH测试币，否则点击”Buy”找平台免费买点。 确认交易 3）购买成功确认 购买成功的会有弹出提示。点击“确定”按钮后，拉到下方的按钮可以查看智能合约部署链接和ABI合约信息。 合约部署成功 查看ABI信息和合约记录 4）查看部署合约成功地址 点击可知其部署成功：https://ropsten.etherscan.io/address/0x07fc44d796d30b317013cb907fadb6d738f5779e 2.2 安装APP，导入钱包，导入门票 - [辉哥] 1） 安装APP 辉哥在官网（https://awallet.io/）下载APP完成安装。 2） 导入钱包 点击配置页面，更换网络为”Ropsten(Test)”网络，导入创建门票的钱包私钥。 3）添加代币 输入之前的智能合约地址，符号和名称会自动联想出来的。 导入成功后，钱包页面可以看到对应的通证信息。如果是没有这个资产的钱包导入这个通证，钱包页面是看不到这个通证门票的。 2.3 转让门票 - [辉哥-欧阳哥哥] 通过报名渠道，辉哥知道欧阳哥哥已报名参加HiBlock黑客马拉松，所以把区块链门票转给他。 1） 辉哥点击“转让”按钮 选择HHT后，点击右下角的“转让”按钮进行票务转让。 2）点击“转让”按钮 选择“现在直接转让门票”， 获取欧阳哥哥的钱包地址，输入： 输入欧阳哥哥的钱包地址 3）确认转让 转让门票按钮 转账成功 2.4 出售门票 - [欧阳哥哥-小辉] 1）导入通证 欧阳哥哥在AlphaWallet钱包中输入HHT的合约地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）即可查看到辉哥转账过来的门票通证。 2） 出售门票 小辉同学知道了黑客马拉松的事情，也很想参加。欧阳哥哥刚好弄了2张票，就同意把一张票低价转让给小辉。双方协商好价格是0.2个ETH。 欧阳哥哥点击出售按钮，设置好价格，最后链接通过微信发给小辉。 设置价格 设置截止时间 确认出售，把链接微信发给小辉 3） 导入支付 小辉安装好APP。复制链接打开APP时，会提示导入门票。点击购买，支付了0.2个ETH后即可完成支付。 门票 确认购买 购买成功 4） 导入代币地址完成呈现 小辉在钱包导入HHT智能合约的地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）后，即可在APP上呈现购买的HHT门票一张。 2.5 兑现门票 欧阳哥哥和小辉到达HiBlock黑客马拉松现场，点击门票的“兑换”按钮，主办方Bob根据他们展示的二维码扫描完成。该门票的状态会变更为已兑换。 【后记】他们组队参加黑客马拉松，依靠其过硬的技术实力，获得了一个二等奖！ 3 ERC875设计目标 AlphaWallet团队核心成员 （左二：CEO张中南；右二：创始人兼CTO张韡武） ERC875协议是由AlphaWallet团队提出的，他们希望基于ERC875协议族，能够实现人、事、物、权token化。 在创始人张中南看来，人、事、物、权全部token化，即可以用token来替代物理世界里面的任何商品。在此其中，token替代的是一个权益，可以指代各种各样的权益。比如，「人」的token化，「跟吴亦凡今天晚上6点钟到8点钟一起吃饭的权益，可以做成一个token」，「事」的token化，「用信用卡在商店买了一瓶水，也可以做成一个token」，而「物」、「权」的token化，就更好理解了。 将人、事、物、权token化，可以有不同层级的愿景和意义。张中南介绍： 第一层级，简单的来说，就是把 人、事、物、权做成token，放到区块链上面流通，或者说放到钱包里，做成APP，能够使用token做流转。 再往上一个级别，是这些token和token之间的交互。比如，可能有一件事，可以同时调用7、8个token，不再是简单的转让或流通。 再往上一个级别，「我们能够看到最远的地方就是这些token用来指代人、事、物、权之后，它们本身可以变成一个集成点，可以在用户端集成各种各样的服务和应用。比如，租车服务、保险、信用卡公司等，当需要调用他们的服务时，不再通过微信来使用，而是直接在用户端就能集成。 现阶段，为了实现初级目标，AlphaWallet选择从一款可编程钱包切入。今年5月23日，该公司正式发布了这款筹备已久的钱包产品——AlphaWallet 1.0版。 公开资料显示，这是一款直接支持不可替代性token的钱包，可作为连接虚拟世界和真实世界的网关。基于该钱包之上，真实世界内的生活服务可利用区块链技术而具备强有力的基础技术平台，从而拥有无限想象的可能性。 通常来说，大量token广泛使用的是ERC20协议。遵循ERC20的token可以跟踪任何人在任何时候拥有多少token。在一些开源组织的推动下，目前第三方基于ERC20接口5分钟即能发行一个ERC20的token。不过，相对来说，ERC20还存在两个问题： 第一，ERC20无法代表现实世界中无法拆分、独一无二的资产； 第二，现有的打包、转账流程复杂，ERC20缺乏可扩展性，无法实现更复杂的功能。 基于此，AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 张中南向雷锋网AI金融评论介绍称，ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 首个落地应用：体育票务 或许与张中南在票务业务的经历有关，AlphaWallet选择从ERC875和钱包切入的第一个use case就是俄罗斯世界杯门票。 相较人、事而言，「票务」由于具备物理和权益属性，利用区块链技术来实现不可置换的token的流转，更具操作性和可行性。 目前 AlphaWallet 已与盛开体育达成合作。今年的俄罗斯世界杯，二者联合引入区块链技术以测试新的票务解决方案，将盛开体育世界杯票库内的部分门票转化为以太坊上的ERC875的token。由于这些token具有不可置换性，用户通过AlphaWallet钱包的动态二维码，以及线下的现场扫描，即可获得世界杯门票。考虑到进一步安全的问题，AlphaWallet钱包显示的动态二维码，每隔10s就会变一次。 AlphaWallet钱包兑换俄罗斯世界杯门票（test）流程体验 据张中南介绍，这次合作，「盛开那边做了10张票，AlphaWallet则拿了10张开幕式的VIP门票，所以一共只有20张门票」。经过雷锋网AI金融评论现场测试体验，通过AlphaWallet钱包流转一张世界杯门票，所花时间在4-7s以内。而买方从卖方手里通过支付以太坊的方式买入一张门票，所需时间则在10s左右。 「这应该是目前世界上首个不可替代通证与现实物权交互的落地案例。」团队向雷锋网AI金融评论表示。 除票务外，AlphaWallet近期还会继续考虑在「物」上面开发use case，主要专注在物理商品这一块，如 奢侈手表和限量球鞋等等。 不过，也有业内人士指出，通过不可置换协议，从token到实物的映射，可能还是难以避免实物造假的情况，这点又该如何防范？在张中南看来，给物理商品配备数字身份证，是通过经济学原理来实现防伪的。这点与溯源、防伪等又不一样。 4 ERC875标准 function name() constant returns (string name) 返回智能合约的名字，例如CarLotContract。 function symbol() constant returns (string symbol) 返回智能合约通证的标识符。 function balanceOf(address _owner) public view returns (uint256[] balance) 返回一组账户余额的数组。 function transfer(address _to, uint256[] _toke****ns) public; 通过包含通证索引的数组参数，把一组独一无二的通证转移给一个账户地址。相比ERC721一次只能转账一个通证，ERC875更显友好，它可以一次批量转账一组通证。这样既便利又能节约大量的GAS消耗。 function transferFrom(address _from, address _to, uint256[] _tokens) public; 从一个账户给另一个账户转账批量通证。这个可由一个获得特定KEY例如合同创建者的授权的账号来完成。 【以下为可选函数】 function totalSupply() constant returns (uint256 totalSupply); 返回给定合同的通证总数。这个通证总数可能是可变的。 function ownerOf(uint256 _tokenId) public view returns (address _owner); 返回特定通证的拥有者。这个函数是可选的，因为并不是每一个通证合约都需要跟踪每一个独一无二通知的拥有者，并且每次查询需要消耗GAS用于遍历和匹配token id于拥有者的关系。 function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable 该函数允许用户出售一组非同质通证而不需要支付GAS费，只需要购买者支付。这是通过签署包含要销售的代币数量，合同地址，到期时间戳，价格和包含ERC规范名称和链ID的前缀的证明来实现的。然后，买方可以通过附加适当的以太币（ether）来满足交易，从而在一次交易中支付交易。 这种设计也更有效，因为它允许订单在离线前完成，而不是在智能合约中创建订单并更新订单。到期时间戳保护卖方免受使用旧订单的人的影响。 这为点对点(p2p)原子交换(atomic swap)打开了大门，但对于这个标准应该是可选的，因为有些可能没有用它。 需要在消息中添加一些保护，例如编码链ID，合同地址和ERC规范名称，以防止重放和欺骗人们签署允许交易的消息。 5 ERC875样例代码 官方给出的ERC875代码样例如下，函数含义参考第4章。 contract ERC { event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); function name() constant public returns (string name); function symbol() constant public returns (string symbol); function balanceOf(address _owner) public view returns (uint256[] _balances); //function ownerOf(uint256 _tokenId) public view returns (address _owner); function transfer(address _to, uint256[] _tokens) public; function transferFrom(address _from, address _to, uint256[] _tokens) public; //optional //function totalSupply() public constant returns (uint256 totalSupply); function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable; } pragma solidity ^0.4.17; contract Token is ERC{ uint totalTickets; mapping(address =&gt; uint256[]) inventory; uint16 ticketIndex = 0; //to track mapping in tickets uint expiryTimeStamp; address owner; // the address that calls selfdestruct() and takes fees address admin; uint transferFee; uint numOfTransfers = 0; string public name; string public symbol; uint8 public constant decimals = 0; //no decimals as tickets cannot be split event Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices); event TransferFrom(address indexed _from, address indexed _to, uint _value); modifier adminOnly() { if(msg.sender != admin) revert(); else _; } function() public { revert(); } //should not send any ether directly // example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJ comeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot; function Token( uint256[] numberOfTokens, string evName, uint expiry, string eventSymbol, address adminAddr) public { totalTickets = numberOfTokens.length; //assign some tickets to event admin expiryTimeStamp = expiry; owner = msg.sender; admin = adminAddr; inventory[admin] = numberOfTokens; symbol = eventSymbol; name = evName; } function getDecimals() public pure returns(uint) { return decimals; } // price is 1 in the example and the contract address is 0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005 // example: 0, [3, 4], 27, &quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;, &quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; // price is encoded in the server and the msg.value is added to the message digest, // if the message digest is thus invalid then either the price or something else in the message is invalid function trade(uint256 expiry, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable { //checks expiry timestamp, //if fake timestamp is added then message verification will fail require(expiry &gt; block.timestamp || expiry == 0); //id 1 for mainnet bytes12 prefix = &quot;ERC800-CNID1&quot;; bytes32 message = encodeMessage(prefix, msg.value, expiry, tokenIndices); address seller = ecrecover(message, v, r, s); for(uint i = 0; i &lt; tokenIndices.length; i++) { // transfer each individual tickets in the ask order uint index = uint(tokenIndices[i]); require((inventory[seller][index] &gt; 0)); // 0 means ticket sold. inventory[msg.sender].push(inventory[seller][index]); inventory[seller][index] = 0; // 0 means ticket sold. } seller.transfer(msg.value); } //must also sign in the contractAddress //prefix must contain ERC and chain id function encodeMessage(bytes12 prefix, uint value, uint expiry, uint256[] tokenIndices) internal view returns (bytes32) { bytes memory message = new bytes(96 + tokenIndices.length * 2); address contractAddress = getContractAddress(); for (uint i = 0; i &lt; 32; i++) { // convert bytes32 to bytes[32] // this adds the price to the message message[i] = byte(bytes32(value &lt;&lt; (8 * i))); } for (i = 0; i &lt; 32; i++) { message[i + 32] = byte(bytes32(expiry &lt;&lt; (8 * i))); } for(i = 0; i &lt; 12; i++) { message[i + 64] = byte(prefix &lt;&lt; (8 * i)); } for(i = 0; i &lt; 20; i++) { message[76 + i] = byte(bytes20(bytes20(contractAddress) &lt;&lt; (8 * i))); } for (i = 0; i &lt; tokenIndices.length; i++) { // convert int[] to bytes message[96 + i * 2 ] = byte(tokenIndices[i] &gt;&gt; 8); message[96 + i * 2 + 1] = byte(tokenIndices[i]); } return keccak256(message); } function name() public view returns(string) { return name; } function symbol() public view returns(string) { return symbol; } function getAmountTransferred() public view returns (uint) { return numOfTransfers; } function isContractExpired() public view returns (bool) { if(block.timestamp &gt; expiryTimeStamp) { return true; } else return false; } function balanceOf(address _owner) public view returns (uint256[]) { return inventory[_owner]; } function myBalance() public view returns(uint256[]) { return inventory[msg.sender]; } function transfer(address _to, uint256[] tokenIndices) public { for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[msg.sender][i] != 0); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[msg.sender][index] = 0; } } function transferFrom(address _from, address _to, uint256[] tokenIndices) adminOnly public { bool isadmin = msg.sender == admin; for(uint i = 0; i &lt; tokenIndices.length; i++) { require(inventory[_from][i] != 0 || isadmin); //pushes each element with ordering uint index = uint(tokenIndices[i]); inventory[_to].push(inventory[msg.sender][index]); inventory[_from][index] = 0; } } function endContract() public { if(msg.sender == owner) { selfdestruct(owner); } else revert(); } function getContractAddress() public view returns(address) { return this; } } 【函数说明】 1，trade函数是发起批量转让的智能合约函数 trade(uint256 expiry,/超时时间，以s计算/ uint256[] tokenIndices, /通证索引/ uint8 v, /v,r,s是卖家签名的3个部分，产生的方法参考文件（https://github.com/alpha-wallet/ERC875-Example/blob/master/TradeImplementationExample.java） / bytes32 r, bytes32 s ) 6 ERC875测试(REMIX+MetaMASK环境) 6.1 创建合约 [1] 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）构建函数CREATE [101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115], “DJ Family”, 1603152000, “DJ”, “0xca35b7d915458ef540ade6068dfe2f44e8fa733c” 【结果】 智能合约创建成功，得到智能合约地址：0x692a70d2e424a56d2c6c27aa97d1a86395877b3a 6.2 门票转让 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）转移2张座位号为101,102的门票给李四(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db) transfer(“0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db”, [0,1]) 【结果】：门票已转让给李四,李四并没有消耗GAS，是管理员消耗了GAS。 6.3 trade门票 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）把门票trade给赵六(0xdd870fa1b7c4700f2bd7f44238821c26f7392148) 当智能合约地址为0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005，price is 1时， trade(0, [3, 4], 27, “0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB”, “0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2”) 【结果】操作失败了，也无法触发购买。 【官方答复】 那个Trade function的功能是，在卖家发了签名信息给买家，然后买家联合卖家的签名信息和自己的签名信息一起call trade fundction来完成交易。你在现在的模式，是创建不出来卖家签名信息的， 你需要参考AlphaWallet的代码。 源码参考地址： https://github.com/alpha-wallet/AlphaWallet-Mobile-Apps 7 参考文档 1） 2018世界杯门票的一笔交易记录（https://etherscan.io/tx/0x4675bf0bddfb4a68acd224d22ca810484a82920b26365e1d39bd354fd8e76d48#decodetab） 2） 深入浅出以太坊ERC875标准（不可替代性通证标准）（http://8btc.com/article-4614-1.html） 3） AlphaWallet野心有点大：基于ERC875协议族，实现人、事、物、权token化（http://itech.ifeng.com/45021842/news.shtml） 4）ERC875 for non fungible tokens and simple atomic swaps（https://github.com/ethereum/EIPs/issues/875） 5） AlphaWallet代码（https://github.com/alpha-wallet） 6） ERC875智能合约案例 （TradeImplementationExample.java 和ERCTokenImplementation.sol）（https://github.com/alpha-wallet/ERC875-Example） 7） AlphaWallet钱包下载-支持测试网络代币（https://awallet.io/） 本文作者：HiBlock区块链技术布道群-辉哥 原文发布于简书：https://www.jianshu.com/p/ddaa0d3643ce 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/09/899b77101319a89e3702058490b33759.html","headline":"【ERC875】HiBlock黑客马拉松门票从定制到编码实现","dateModified":"2018-08-09T00:00:00+08:00","datePublished":"2018-08-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/09/899b77101319a89e3702058490b33759.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【ERC875】HiBlock黑客马拉松门票从定制到编码实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-6eca52ff2ff4c0d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <h1 id="1">1</h1> 
  <h1 id="什么是代币token合约"><strong>什么是代币(token)合约</strong></h1> 
  <p><strong>【本文目标】</strong></p> 
  <p>通过本文，可以从一个HiBlock黑客马拉松活动门票定制，转让，出售和签到为例，说明ERC875的设计初心，ERC875的标准接口分析，也给出了官网的ERC875的代码和本地测试，便于更多项目使用ERC875解决区块链业务中遇到的实际问题。</p> 
  <p><strong>【前置条件】</strong></p> 
  <p>（1）体验门票受让的用户不需要有任何技术门槛； <br> （2）做门票定制和开发的需要本地已安装好MetaMASK，在Reposton Test Net获取了几个测试ETH（免费）的，要懂Solidity语言。</p> 
  <p>不熟悉的建议参考文档<a href="http://mp.weixin.qq.com/s?__biz=MzA5NDAxNzIzNg==&amp;mid=2450003879&amp;idx=1&amp;sn=fad4ba40a62c27fda238f03fe45c5b68&amp;chksm=87a9b41cb0de3d0a1676be78553691804068ef2c1a032aa31a9f049ceff97d52840a7a498955&amp;scene=21#wechat_redirect" rel="nofollow">开发实战|3步教你在以太坊上开一家宠物店（附流程+代码）</a>。</p> 
  <h1 id="2">2</h1> 
  <h1 id="hiblock黑客马拉松区块链门票全体验"><strong>HiBlock黑客马拉松区块链门票全体验</strong></h1> 
  <p><strong>2.1 门票定制创建 - [辉哥]</strong></p> 
  <p>ALPHA WALLET团队已经封装好了ERC785协议实现，可以通过浏览器完成票务类ERC875的智能合约创建。对应的TOKEN工厂网址为<a href="https://alpha-wallet.github.io/ERC875-token-factory/index.html" rel="nofollow">https://alpha-wallet.github.io/ERC875-token-factory/index.html</a> <br> 测试使用，MetaMASK选择的测试网络为”Ropsten Test Net”。</p> 
  <p><strong>1） “Deploy Contract”</strong> </p> 
  <p>定义名称和标识，对应的地址是以太坊钱包地址。Owner Address必须为MetaMast的当前账号地址，然后点击“Deploy Contract”按钮。[名称和标识命名跟一般使用的搞反了，将就用吧]</p> 
  <ul> 
   <li><p>Contract Name: HHT</p></li> 
   <li><p>Ticket Symbol: Hiblock Hackathon Ticket</p></li> 
   <li><p>Owner Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89</p></li> 
   <li><p>Recipient Address:0xB51Fa936B744CFEbAeD8DbB79d2060903e689F89</p></li> 
  </ul> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-bd3a4a775472bb9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>提交合约部署</p> 
  <p><strong>2）“Submmit”按钮</strong></p> 
  <p>“Gas Price”设置为30，点击“Submmit”按钮。该账号要有一定的ETH测试币，否则点击”Buy”找平台免费买点。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-7ba39b7942ff3d99?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>确认交易 </p> 
  <p><strong>3）购买成功确认</strong></p> 
  <p>购买成功的会有弹出提示。点击“确定”按钮后，拉到下方的按钮可以查看智能合约部署链接和ABI合约信息。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-ac33fe4322fd81b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>合约部署成功</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-c3ac36213b1b9711?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>查看ABI信息和合约记录</p> 
  <p><strong>4）查看部署合约成功地址</strong> </p> 
  <p>点击可知其部署成功：<a href="https://ropsten.etherscan.io/address/0x07fc44d796d30b317013cb907fadb6d738f5779e" rel="nofollow">https://ropsten.etherscan.io/address/0x07fc44d796d30b317013cb907fadb6d738f5779e</a></p> 
  <p><strong>2.2 安装APP，导入钱包，导入门票 - [辉哥]</strong></p> 
  <p><strong>1） 安装APP</strong></p> 
  <p>辉哥在官网（<a href="https://awallet.io/" rel="nofollow">https://awallet.io/</a>）下载APP完成安装。</p> 
  <p><strong>2） 导入钱包</strong> </p> 
  <p>点击配置页面，更换网络为”Ropsten(Test)”网络，导入创建门票的钱包私钥。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-dc1e176bf4247608?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>3）添加代币</strong></p> 
  <p>输入之前的智能合约地址，符号和名称会自动联想出来的。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-0bbeb2e12f5e6b61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>导入成功后，钱包页面可以看到对应的通证信息。如果是没有这个资产的钱包导入这个通证，钱包页面是看不到这个通证门票的。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-946a728ee91f7897?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>2.3 转让门票 - [辉哥-欧阳哥哥]</strong></p> 
  <p>通过报名渠道，辉哥知道欧阳哥哥已报名参加HiBlock黑客马拉松，所以把区块链门票转给他。</p> 
  <p><strong>1） 辉哥点击“转让”按钮</strong></p> 
  <p>选择HHT后，点击右下角的“转让”按钮进行票务转让。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-52900ff4b82e937b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>2）点击“转让”按钮</strong> </p> 
  <p>选择“现在直接转让门票”，</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-10bd4370229a1a28?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>获取欧阳哥哥的钱包地址，输入：</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-f9d3974a44c57d18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>输入欧阳哥哥的钱包地址 </p> 
  <p><strong>3）确认转让</strong> </p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-ab73c4f290daf261?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>转让门票按钮</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-8ef1cfe38c125b26?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>转账成功</p> 
  <p><strong>2.4 出售门票 - [欧阳哥哥-小辉]</strong></p> 
  <p><strong>1）导入通证</strong></p> 
  <p>欧阳哥哥在AlphaWallet钱包中输入HHT的合约地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）即可查看到辉哥转账过来的门票通证。</p> 
  <p><strong>2） 出售门票</strong> </p> 
  <p>小辉同学知道了黑客马拉松的事情，也很想参加。欧阳哥哥刚好弄了2张票，就同意把一张票低价转让给小辉。双方协商好价格是0.2个ETH。</p> 
  <p>欧阳哥哥点击出售按钮，设置好价格，最后链接通过微信发给小辉。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-7080d003c4a7c077?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>设置价格</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-38c352a9178bc080?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>设置截止时间</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-53a03bbe96629a87?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>确认出售，把链接微信发给小辉</p> 
  <p><strong>3） 导入支付</strong></p> 
  <p>小辉安装好APP。复制链接打开APP时，会提示导入门票。点击购买，支付了0.2个ETH后即可完成支付。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-b883c193f42bb062?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>门票</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-1c86af888f2fd05f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>确认购买</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-0d4d3b7311eb4c48?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>购买成功</p> 
  <p><strong>4） 导入代币地址完成呈现</strong></p> 
  <p>小辉在钱包导入HHT智能合约的地址（0x07fc44d796d30b317013cb907fadb6d738f5779e）后，即可在APP上呈现购买的HHT门票一张。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-0ff2bd56d58405c9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>2.5 兑现门票</strong></p> 
  <p>欧阳哥哥和小辉到达HiBlock黑客马拉松现场，点击门票的“兑换”按钮，主办方Bob根据他们展示的二维码扫描完成。该门票的状态会变更为已兑换。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-648dcd238d2afe12?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>【后记】他们组队参加黑客马拉松，依靠其过硬的技术实力，获得了一个二等奖！</p> 
  <h1 id="3">3</h1> 
  <h1 id="erc875设计目标"><strong>ERC875设计目标</strong></h1> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-ad5ab885eed5856f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>AlphaWallet团队核心成员</p> 
  <p>（左二：CEO张中南；右二：创始人兼CTO张韡武）</p> 
  <p>ERC875协议是由AlphaWallet团队提出的，他们希望基于ERC875协议族，能够实现人、事、物、权token化。</p> 
  <p>在创始人张中南看来，人、事、物、权全部token化，即可以用token来替代物理世界里面的任何商品。在此其中，token替代的是一个权益，可以指代各种各样的权益。比如，「人」的token化，「跟吴亦凡今天晚上6点钟到8点钟一起吃饭的权益，可以做成一个token」，「事」的token化，「用信用卡在商店买了一瓶水，也可以做成一个token」，而「物」、「权」的token化，就更好理解了。</p> 
  <p>将人、事、物、权token化，可以有不同层级的愿景和意义。张中南介绍：</p> 
  <ul> 
   <li><p>第一层级，简单的来说，就是把 人、事、物、权做成token，放到区块链上面流通，或者说放到钱包里，做成APP，能够使用token做流转。</p></li> 
   <li><p>再往上一个级别，是这些token和token之间的交互。比如，可能有一件事，可以同时调用7、8个token，不再是简单的转让或流通。</p></li> 
   <li><p>再往上一个级别，「我们能够看到最远的地方就是这些token用来指代人、事、物、权之后，它们本身可以变成一个集成点，可以在用户端集成各种各样的服务和应用。比如，租车服务、保险、信用卡公司等，当需要调用他们的服务时，不再通过微信来使用，而是直接在用户端就能集成。</p></li> 
  </ul> 
  <p>现阶段，为了实现初级目标，AlphaWallet选择从一款可编程钱包切入。今年5月23日，该公司正式发布了这款筹备已久的钱包产品——AlphaWallet 1.0版。</p> 
  <p>公开资料显示，这是一款直接支持不可替代性token的钱包，可作为连接虚拟世界和真实世界的网关。基于该钱包之上，真实世界内的生活服务可利用区块链技术而具备强有力的基础技术平台，从而拥有无限想象的可能性。</p> 
  <p>通常来说，大量token广泛使用的是ERC20协议。遵循ERC20的token可以跟踪任何人在任何时候拥有多少token。在一些开源组织的推动下，目前第三方基于ERC20接口5分钟即能发行一个ERC20的token。不过，相对来说，ERC20还存在两个问题：</p> 
  <ul> 
   <li><p>第一，ERC20无法代表现实世界中无法拆分、独一无二的资产；</p></li> 
   <li><p>第二，现有的打包、转账流程复杂，ERC20缺乏可扩展性，无法实现更复杂的功能。</p></li> 
  </ul> 
  <p>基于此，AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。</p> 
  <p>虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。</p> 
  <p>张中南向雷锋网AI金融评论介绍称，ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。</p> 
  <p>拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。</p> 
  <p><strong>首个落地应用：体育票务</strong></p> 
  <p>或许与张中南在票务业务的经历有关，AlphaWallet选择从ERC875和钱包切入的第一个use case就是俄罗斯世界杯门票。</p> 
  <p>相较人、事而言，「票务」由于具备物理和权益属性，利用区块链技术来实现不可置换的token的流转，更具操作性和可行性。</p> 
  <p>目前 AlphaWallet 已与盛开体育达成合作。今年的俄罗斯世界杯，二者联合引入区块链技术以测试新的票务解决方案，将盛开体育世界杯票库内的部分门票转化为以太坊上的ERC875的token。由于这些token具有不可置换性，用户通过AlphaWallet钱包的动态二维码，以及线下的现场扫描，即可获得世界杯门票。考虑到进一步安全的问题，AlphaWallet钱包显示的动态二维码，每隔10s就会变一次。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-c3dcfa437bb4d413?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>AlphaWallet钱包兑换俄罗斯世界杯门票（test）流程体验</p> 
  <p>据张中南介绍，这次合作，「盛开那边做了10张票，AlphaWallet则拿了10张开幕式的VIP门票，所以一共只有20张门票」。经过雷锋网AI金融评论现场测试体验，通过AlphaWallet钱包流转一张世界杯门票，所花时间在4-7s以内。而买方从卖方手里通过支付以太坊的方式买入一张门票，所需时间则在10s左右。</p> 
  <p>「这应该是目前世界上首个不可替代通证与现实物权交互的落地案例。」团队向雷锋网AI金融评论表示。</p> 
  <p>除票务外，AlphaWallet近期还会继续考虑在「物」上面开发use case，主要专注在物理商品这一块，如 奢侈手表和限量球鞋等等。</p> 
  <p>不过，也有业内人士指出，通过不可置换协议，从token到实物的映射，可能还是难以避免实物造假的情况，这点又该如何防范？在张中南看来，给物理商品配备数字身份证，是通过经济学原理来实现防伪的。这点与溯源、防伪等又不一样。</p> 
  <h1 id="4">4</h1> 
  <h1 id="erc875标准"><strong>ERC875标准</strong></h1> 
  <p><strong>function name() constant returns (string name)</strong></p> 
  <p>返回智能合约的名字，例如CarLotContract。</p> 
  <p><strong>function symbol() constant returns (string symbol)</strong></p> 
  <p>返回智能合约通证的标识符。</p> 
  <p><strong>function balanceOf(address _owner) public view returns (uint256[] balance)</strong></p> 
  <p>返回一组账户余额的数组。</p> 
  <p><strong>function transfer(address _to, uint256[] _toke****ns) public;</strong></p> 
  <p>通过包含通证索引的数组参数，把一组独一无二的通证转移给一个账户地址。相比ERC721一次只能转账一个通证，ERC875更显友好，它可以一次批量转账一组通证。这样既便利又能节约大量的GAS消耗。</p> 
  <p><strong>function transferFrom(address _from, address _to, uint256[] _tokens) public;</strong></p> 
  <p>从一个账户给另一个账户转账批量通证。这个可由一个获得特定KEY例如合同创建者的授权的账号来完成。</p> 
  <p>【以下为可选函数】</p> 
  <p><strong>function totalSupply() constant returns (uint256 totalSupply);</strong></p> 
  <p>返回给定合同的通证总数。这个通证总数可能是可变的。</p> 
  <p><strong>function ownerOf(uint256 _tokenId) public view returns (address _owner);</strong></p> 
  <p>返回特定通证的拥有者。这个函数是可选的，因为并不是每一个通证合约都需要跟踪每一个独一无二通知的拥有者，并且每次查询需要消耗GAS用于遍历和匹配token id于拥有者的关系。</p> 
  <p><strong>function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable</strong></p> 
  <p>该函数允许用户出售一组非同质通证而不需要支付GAS费，只需要购买者支付。这是通过签署包含要销售的代币数量，合同地址，到期时间戳，价格和包含ERC规范名称和链ID的前缀的证明来实现的。然后，买方可以通过附加适当的以太币（ether）来满足交易，从而在一次交易中支付交易。</p> 
  <p>这种设计也更有效，因为它允许订单在离线前完成，而不是在智能合约中创建订单并更新订单。到期时间戳保护卖方免受使用旧订单的人的影响。</p> 
  <p>这为点对点(p2p)原子交换(atomic swap)打开了大门，但对于这个标准应该是可选的，因为有些可能没有用它。</p> 
  <p>需要在消息中添加一些保护，例如编码链ID，合同地址和ERC规范名称，以防止重放和欺骗人们签署允许交易的消息。</p> 
  <h1 id="5">5</h1> 
  <h1 id="erc875样例代码"><strong>ERC875样例代码</strong></h1> 
  <p>官方给出的ERC875代码样例如下，函数含义参考第4章。</p> 
  <pre class="prettyprint"><code class=" hljs cs">contract ERC

{

  <span class="hljs-keyword">event</span> Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices);

   function name() constant <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-keyword">string</span> name);

  function symbol() constant <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-keyword">string</span> symbol);

  function balanceOf(address _owner) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256[] _balances);

  <span class="hljs-comment">//function ownerOf(uint256 _tokenId) public view returns (address _owner);</span>

  function transfer(address _to, uint256[] _tokens) <span class="hljs-keyword">public</span>;

  function transferFrom(address _from, address _to, uint256[] _tokens) <span class="hljs-keyword">public</span>;

   <span class="hljs-comment">//optional</span>

  <span class="hljs-comment">//function totalSupply() public constant returns (uint256 totalSupply);</span>

  function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) <span class="hljs-keyword">public</span> payable;

}

pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.17</span>;

contract Token <span class="hljs-keyword">is</span> ERC{

    <span class="hljs-keyword">uint</span> totalTickets;

    mapping(address =&gt; uint256[]) inventory;

    uint16 ticketIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">//to track mapping in tickets</span>

    <span class="hljs-keyword">uint</span> expiryTimeStamp;

    address owner;   <span class="hljs-comment">// the address that calls selfdestruct() and takes fees</span>

    address admin;

    <span class="hljs-keyword">uint</span> transferFee;

    <span class="hljs-keyword">uint</span> numOfTransfers = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">string</span> <span class="hljs-keyword">public</span> name;

    <span class="hljs-keyword">string</span> <span class="hljs-keyword">public</span> symbol;

    uint8 <span class="hljs-keyword">public</span> constant decimals = <span class="hljs-number">0</span>; <span class="hljs-comment">//no decimals as tickets cannot be split</span>

    <span class="hljs-keyword">event</span> Transfer(address indexed _from, address indexed _to, uint256[] tokenIndices);

    <span class="hljs-keyword">event</span> TransferFrom(address indexed _from, address indexed _to, <span class="hljs-keyword">uint</span> _value);

        modifier adminOnly()

    {

        <span class="hljs-keyword">if</span>(msg.sender != admin) revert(); 

       <span class="hljs-keyword">else</span> _;

    }

    function() <span class="hljs-keyword">public</span> { revert(); } <span class="hljs-comment">//should not send any ether directly</span>

    <span class="hljs-comment">// example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "MJ comeback", 1603152000, "MJC", "0x007bEe82BDd9e866b2bd114780a47f2261C684E3"</span>

    function Token(

        uint256[] numberOfTokens,

        <span class="hljs-keyword">string</span> evName,

        <span class="hljs-keyword">uint</span> expiry,

        <span class="hljs-keyword">string</span> eventSymbol, 

       address adminAddr) <span class="hljs-keyword">public</span>

    {

        totalTickets = numberOfTokens.length;

        <span class="hljs-comment">//assign some tickets to event admin</span>

        expiryTimeStamp = expiry;

        owner = msg.sender;

        admin = adminAddr;

        inventory[admin] = numberOfTokens;

        symbol = eventSymbol;

        name = evName;

    }

    function getDecimals() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span>(<span class="hljs-keyword">uint</span>)

    {

        <span class="hljs-keyword">return</span> decimals;

    }

        <span class="hljs-comment">// price is 1 in the example and the contract address is 0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005</span>

    <span class="hljs-comment">// example: 0, [3, 4], 27, "0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB", "0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2"</span>

    <span class="hljs-comment">// price is encoded in the server and the msg.value is added to the message digest,</span>

    <span class="hljs-comment">// if the message digest is thus invalid then either the price or something else in the message is invalid</span>

    function trade(uint256 expiry,

                   uint256[] tokenIndices,

                   uint8 v, 

                  bytes32 r,

                   bytes32 s) <span class="hljs-keyword">public</span> payable

    {

        <span class="hljs-comment">//checks expiry timestamp,</span>

        <span class="hljs-comment">//if fake timestamp is added then message verification will fail</span>

        require(expiry &gt; block.timestamp || expiry == <span class="hljs-number">0</span>);

        <span class="hljs-comment">//id 1 for mainnet</span>

        bytes12 prefix = <span class="hljs-string">"ERC800-CNID1"</span>;

        bytes32 message = encodeMessage(prefix, msg.<span class="hljs-keyword">value</span>, expiry, tokenIndices);

        address seller = ecrecover(message, v, r, s);

                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; tokenIndices.length; i++)

        { <span class="hljs-comment">// transfer each individual tickets in the ask order</span>

            <span class="hljs-keyword">uint</span> index = <span class="hljs-keyword">uint</span>(tokenIndices[i]);

            require((inventory[seller][index] &gt; <span class="hljs-number">0</span>)); <span class="hljs-comment">// 0 means ticket sold. </span>

           inventory[msg.sender].push(inventory[seller][index]); 

           inventory[seller][index] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0 means ticket sold.</span>

        } 

       seller.transfer(msg.<span class="hljs-keyword">value</span>);

    }

    <span class="hljs-comment">//must also sign in the contractAddress</span>

    <span class="hljs-comment">//prefix must contain ERC and chain id</span>

    function encodeMessage(bytes12 prefix, <span class="hljs-keyword">uint</span> <span class="hljs-keyword">value</span>,

         <span class="hljs-keyword">uint</span> expiry, uint256[] tokenIndices)

        <span class="hljs-keyword">internal</span> view <span class="hljs-title">returns</span> (bytes32)

    {
        bytes memory message = <span class="hljs-keyword">new</span> bytes(<span class="hljs-number">96</span> + tokenIndices.length * <span class="hljs-number">2</span>);

        address contractAddress = getContractAddress(); 

       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)

        {   <span class="hljs-comment">// convert bytes32 to bytes[32]</span>

            <span class="hljs-comment">// this adds the price to the message</span>

            message[i] = <span class="hljs-keyword">byte</span>(bytes32(<span class="hljs-keyword">value</span> &lt;&lt; (<span class="hljs-number">8</span> * i)));

        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)

        {

            message[i + <span class="hljs-number">32</span>] = <span class="hljs-keyword">byte</span>(bytes32(expiry &lt;&lt; (<span class="hljs-number">8</span> * i)));

        }

                <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++)

        {

            message[i + <span class="hljs-number">64</span>] = <span class="hljs-keyword">byte</span>(prefix &lt;&lt; (<span class="hljs-number">8</span> * i));

            }

        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)

        {

            message[<span class="hljs-number">76</span> + i] = <span class="hljs-keyword">byte</span>(bytes20(bytes20(contractAddress) &lt;&lt; (<span class="hljs-number">8</span> * i)));

        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tokenIndices.length; i++)

        {

            <span class="hljs-comment">// convert int[] to bytes</span>

            message[<span class="hljs-number">96</span> + i * <span class="hljs-number">2</span> ] = <span class="hljs-keyword">byte</span>(tokenIndices[i] &gt;&gt; <span class="hljs-number">8</span>);

            message[<span class="hljs-number">96</span> + i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = <span class="hljs-keyword">byte</span>(tokenIndices[i]);
        }

        <span class="hljs-keyword">return</span> keccak256(message);

    }

    function name() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-keyword">string</span>)

    {

        <span class="hljs-keyword">return</span> name;

    }

    function symbol() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-keyword">string</span>)

    {

        <span class="hljs-keyword">return</span> symbol;

    }

    function getAmountTransferred() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-keyword">uint</span>)

    {

        <span class="hljs-keyword">return</span> numOfTransfers;

    }

    function isContractExpired() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-keyword">bool</span>)

    {

        <span class="hljs-keyword">if</span>(block.timestamp &gt; expiryTimeStamp)

        {

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;

        }

        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    }

    function balanceOf(address _owner) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256[])

    {

        <span class="hljs-keyword">return</span> inventory[_owner];

    }

    function myBalance() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(uint256[])

    {

        <span class="hljs-keyword">return</span> inventory[msg.sender];

    }

    function transfer(address _to, uint256[] tokenIndices) <span class="hljs-keyword">public</span>

    {

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; tokenIndices.length; i++)

        {

            require(inventory[msg.sender][i] != <span class="hljs-number">0</span>);

            <span class="hljs-comment">//pushes each element with ordering</span>

            <span class="hljs-keyword">uint</span> index = <span class="hljs-keyword">uint</span>(tokenIndices[i]);

            inventory[_to].push(inventory[msg.sender][index]); 

           inventory[msg.sender][index] = <span class="hljs-number">0</span>;

        }

    }

    function transferFrom(address _from, address _to, uint256[] tokenIndices)

        adminOnly <span class="hljs-keyword">public</span>

    {

        <span class="hljs-keyword">bool</span> isadmin = msg.sender == admin;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; tokenIndices.length; i++)

        {

            require(inventory[_from][i] != <span class="hljs-number">0</span> || isadmin);

            <span class="hljs-comment">//pushes each element with ordering</span>

            <span class="hljs-keyword">uint</span> index = <span class="hljs-keyword">uint</span>(tokenIndices[i]);

            inventory[_to].push(inventory[msg.sender][index]);

            inventory[_from][index] = <span class="hljs-number">0</span>;

        }

    }

    function endContract() <span class="hljs-keyword">public</span>

    {

        <span class="hljs-keyword">if</span>(msg.sender == owner)

        {

            selfdestruct(owner);

        }

        <span class="hljs-keyword">else</span> revert();

    }

    function getContractAddress() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(address)

    {

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

    }

}</code></pre> 
  <p><strong>【函数说明】</strong> <br> 1，trade函数是发起批量转让的智能合约函数 <br> trade(uint256 expiry,/超时时间，以s计算/ <br> uint256[] tokenIndices, /通证索引/ <br> uint8 v, /<em>v,r,s是卖家签名的3个部分，产生的方法参考文件（<a href="https://github.com/alpha-wallet/ERC875-Example/blob/master/TradeImplementationExample.java" rel="nofollow">https://github.com/alpha-wallet/ERC875-Example/blob/master/TradeImplementationExample.java</a>） </em>/ <br> bytes32 r, <br> bytes32 s )</p> 
  <h1 id="6">6</h1> 
  <h1 id="erc875测试remixmetamask环境"><strong>ERC875测试(REMIX+MetaMASK环境)</strong></h1> 
  <p><strong>6.1 创建合约</strong></p> 
  <p>[1] 管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）构建函数CREATE</p> 
  <p>[101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115], “DJ Family”, 1603152000, “DJ”, “0xca35b7d915458ef540ade6068dfe2f44e8fa733c”</p> 
  <p>【结果】 <br> 智能合约创建成功，得到智能合约地址：0x692a70d2e424a56d2c6c27aa97d1a86395877b3a</p> 
  <p><strong>6.2 门票转让</strong></p> 
  <p>管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）转移2张座位号为101,102的门票给李四(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db)</p> 
  <p>transfer(“0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db”, [0,1])</p> 
  <p>【结果】：门票已转让给李四,李四并没有消耗GAS，是管理员消耗了GAS。</p> 
  <p><strong>6.3 trade门票</strong></p> 
  <p>管理员（0xca35b7d915458ef540ade6068dfe2f44e8fa733c）把门票trade给赵六(0xdd870fa1b7c4700f2bd7f44238821c26f7392148) <br> 当智能合约地址为0xfFAB5Ce7C012bc942F5CA0cd42c3C2e1AE5F0005，price is 1时，</p> 
  <p>trade(0, [3, 4], 27, “0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB”, “0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2”)</p> 
  <p>【结果】操作失败了，也无法触发购买。</p> 
  <p>【官方答复】</p> 
  <p>那个Trade function的功能是，在卖家发了签名信息给买家，然后买家联合卖家的签名信息和自己的签名信息一起call trade fundction来完成交易。你在现在的模式，是创建不出来卖家签名信息的， 你需要参考AlphaWallet的代码。 <br> 源码参考地址： <br> <a href="https://github.com/alpha-wallet/AlphaWallet-Mobile-Apps" rel="nofollow">https://github.com/alpha-wallet/AlphaWallet-Mobile-Apps</a></p> 
  <h1 id="7">7</h1> 
  <h1 id="参考文档"><strong>参考文档</strong></h1> 
  <p>1） 2018世界杯门票的一笔交易记录（<a href="https://etherscan.io/tx/0x4675bf0bddfb4a68acd224d22ca810484a82920b26365e1d39bd354fd8e76d48#decodetab" rel="nofollow">https://etherscan.io/tx/0x4675bf0bddfb4a68acd224d22ca810484a82920b26365e1d39bd354fd8e76d48#decodetab</a>）</p> 
  <p>2） 深入浅出以太坊ERC875标准（不可替代性通证标准）（<a href="http://8btc.com/article-4614-1.html" rel="nofollow">http://8btc.com/article-4614-1.html</a>）</p> 
  <p>3） AlphaWallet野心有点大：基于ERC875协议族，实现人、事、物、权token化（<a href="http://itech.ifeng.com/45021842/news.shtml" rel="nofollow">http://itech.ifeng.com/45021842/news.shtml</a>）</p> 
  <p>4）ERC875 for non fungible tokens and simple atomic swaps（<a href="https://github.com/ethereum/EIPs/issues/875" rel="nofollow">https://github.com/ethereum/EIPs/issues/875</a>）</p> 
  <p>5） AlphaWallet代码（<a href="https://github.com/alpha-wallet" rel="nofollow">https://github.com/alpha-wallet</a>）</p> 
  <p>6） ERC875智能合约案例 （TradeImplementationExample.java 和ERCTokenImplementation.sol）（<a href="https://github.com/alpha-wallet/ERC875-Example" rel="nofollow">https://github.com/alpha-wallet/ERC875-Example</a>）</p> 
  <p>7） AlphaWallet钱包下载-支持测试网络代币（<a href="https://awallet.io/" rel="nofollow">https://awallet.io/</a>）</p> 
  <blockquote> 
   <p>本文作者：HiBlock区块链技术布道群-<strong>辉哥</strong></p> 
   <p>原文发布于简书：<a href="https://www.jianshu.com/p/ddaa0d3643ce" rel="nofollow">https://www.jianshu.com/p/ddaa0d3643ce</a></p> 
   <p>加微信baobaotalk_com，加入技术布道群</p> 
  </blockquote> 
  <p>以下是我们的社区介绍，欢迎各种合作、交流、学习：）</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-2731c97a92d66c7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/81545967,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/81545967,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
