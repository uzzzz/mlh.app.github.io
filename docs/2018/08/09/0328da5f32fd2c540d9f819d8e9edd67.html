<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊的挖矿和难度调整过程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊的挖矿和难度调整过程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，转载请说明出处 https://blog.csdn.net/t46414704152abc/article/details/81538361 以太坊挖矿过程 在比特币的挖矿过程中，仅仅需要较为简单的哈希运算，而不需要额外的计算资源（内存等），于是比特币的挖矿过程逐渐成为了算力的竞争，于是就出现了ASIC矿机，这种矿机相比于个人计算机，进行普通的计算，其算力是个人计算机的数千倍，刚好适用于进行比特币中的挖矿，因此，普通人要想挖矿，就得有更专业的设备，挖矿这一行业都出现了中心化的现象，这与比特币当初设计之初的去中心化理念背道而驰了。 于是，设计以太坊挖矿的时候，采用了全新的挖矿过程以做到ASIC Resistance。ASIC只能进行运算，却没有额外存储空间，于是以太坊在挖矿过程中设计了两个数据结构，分别为Cache和dataset。其中Cache是16M大小，而dataset是1G大小，对于矿工来说，每次选取一个nonce之后的挖矿操作，都要从dataset中读取数据，这就要求矿机有存储能力，挖矿过程中引入了读取内存的操作，这就极大的降低了ASIC矿机的算力，使其挖矿的优势不那么明显，而普通的个人计算机也能进行挖矿。具体的挖矿过程如下： 根据当前区块信息生成一个Seed种子。 根据Seed种子生成16M大小的Cache,Cache是一个List结构，其数据前后相关。 根据Cache来生成1G大小的Dataset（又称为Dag）。 矿机每次选取一个Nonce之后，从Dataset中读取两个数进行挖矿测试，直到找到合适的Nonce。 区块链中每30000个区块的时候，Cache和Dataset的大小都会增加 1128 1 128 ,也就是说Cache会增加128K，而Dataset会增加8M。生成Cache的算法如下： def mkcache(cache_size, seed): cache = [hash(seed)] for i in range(1,cache_size): cache.append(hash[cache[-1]]) return cache dataset的生成来源于cache，具体来说，dataset[i]个元素的生成需要cache和cache[i]的参与。dataset中第i个元素的生成代码如下： def cal_dataset_i(cahce, i):# 计算dataset[i] cache_size = cache.size mix = hash(cache[i%cache_size]^i)# cache远远小于dataset，让i也参与运算，从而使得mix不会重复 for j in range(256): cache_index = get_int(mix); mix = make_item(mix,cache[cache_index%cache_size]) return hash(mix) 上述代码是伪代码，省略了大部分细节，重点在于展示原理。 先通过cache中的第i%cache_size个元素生成初始的mix，因为两个不同的dataset元素可能对应同一个cache中的元素，为了保证每个初始的mix都不同，注意到i也参与了哈希计算。 随后循环256次，每次通过get_int来根据当前的mix值求得下一个要访问的cache元素的下标，用这个cache元素和mix通过make_item求得新的mix值。注意到由于初始的mix值都不同，所以访问cache的序列也都是不同的。 最终返回mix的哈希值，得到第i个dataset中的元素。 多次调用这个函数，就可以得到完整的dataset。 通过cache生成dataset的元素时，下一个用到的cache中的元素的位置是通过当前用到的cache的元素的值计算得到的，这样具体的访问顺序事先不可预知，满足伪随机性。生称dataset的代码如下： def calc_dataset(full_size, cache): return [calc_dataset_item(cache,i) for i in range(full_size)] 生成dataset之后矿工就可以开始挖矿，根据特定的过程计算出一个哈希值，其代码如下所示。其中的循环64次并没有额外的原因，就是想增加挖矿过程中的访问内存操作。矿工为了增加挖矿速度，就必须要将dataset存储在内存中。 # 根据nonce计算出一个哈希值 def get_hash_value(header, nonce, full_size, dataset): hash_value = hash(header, nonce); for i in range(64): dataset_index = get_int(hash_value )%full_size hash_value = make_item(hash_value , dataset[dataset_index) hash_value = make_item(hash_value , dataset[dataset_index+1]) return hash(hash_value ) 如果一个nonce不合适，就需要更换一个nonce，直到找到合适的nonce，整个挖矿过程伪代码如下： def mine(full_size, dataset, header, target): max_nonce = 2**64 nonce = random.randint(0, max_nonce ) while get_hash_value(header, nonce, full_size, dataset) &gt; target: nonce = (nonce+1)%max_nonce return nonce 为什么要挖矿中设计cache呢，貌似矿工挖矿的时候根本没有用到cache，为什么要多此一举？这是为了方便轻节点对区块进行验证。对于轻节点来说，不可能存储很大的dataset，但是轻节点可以通过存储cache，验证某个区块块头时，根据cache生成dataset中某个元素，随后验证区块的合法性。轻节点验证区块合法性的伪代码如下： def varify(header, nonce, full_size, cache): hash_value = hash(header, nonce) for i in range(64): index = get_int(hash_value)%full_size hash_value = hash(hash_value, cal_dataset_i(cache,index))# 计算生成dataset中的数据 hash_value = hash(hash_value,cal_dataset_i(cache,index+1)) return hash(hash_value) 矿工需要验证大量的nonce，若每次都要从16M的cache中重新生成，那么挖矿的效率就大打折扣，而且会有大量的重复计算：随机选取的dataset的元素中有很多是重复的，可能是之前尝试别的nonce时用过的。所以，矿工采取以空间换时间的策略，把整个dataset保存下来。而轻节点由于只验证一个nonce，验证的时候就直接生成要用到的dataset中的元素就行了。 以太坊挖矿难度调整 以太坊中的区块的难度调整公式如下图所示。 参数说明 区块链难度调整中，创始块的难度被设置为 D0=131072 D 0 = 131072 ，此后每个区块的难度都与其父区块的难度相关。D(H)是本区块的难度，由 P(H)Hd+x×ζ2 P ( H ) H d + x × ζ 2 和难度炸弹 ϵ ϵ 构成。 P(H)Hd P ( H ) H d 为父区块的难度，每个区块的难度都是在父区块难度的基础上进行调整。 x×ζ2 x × ζ 2 用于自适应调节出块难度，维持稳定的出块速度。 ϵ ϵ 表示难度炸弹。 难度有最低下限，即不能低于 D0=131072 D 0 = 131072 其中 x x 和 ϵ2 ϵ 2 的计算方式如下图所示。 x x 是父区块难度的 12048 1 2048 的取整，是调整的单位。 ϵ ϵ 是调整系数，其小只能是-99。 y的取值依赖于父区块是否包含叔父区块，如果包含，则y=2，否则y=1。 HS H S 是本区块的时间戳， P(H)Hs P ( H ) H s 是父区块的时间戳，单位为秒，并且 HS&gt;P(H)Hs H S &gt; P ( H ) H s 。 难度降低的上界设置为−99 ，主要是应对被黑客攻击或其他目前想不到的黑天鹅事件。 假设当父区块不带叔父区块的时候（y=1），调整过程如下： 出块时间在[1,8]之间，出块时间过短，难度调大一个单位。 出块时间在[9,17]之间，出块时间可以接受，难度保持不变。 出块时间在[18,26]之间，出块时间过长，难度调小一个单位。 … 这里发现，出块时间变长，区块的整体难度就会调小，假若有的矿工，故意将区块的时间戳改的比较晚，那么是不是就可以抢先发布区块呢？比如说将时间戳延迟写15秒，会怎么样呢？这样就会导致该矿工计算出来的难度比别的矿工计算的难度低，其他矿工15秒发布一个区块，而该矿工可以在10秒内发布区块，可以拿到区块奖励。但是问题在于假如刚好也有别的区块在10秒内发布了区块，此时根据POW的规则，另外一个矿工发布的区块难度更大，因此其他矿工会以最大工作量标准，选择15秒内挖出的区块所在的链作为主链，而该矿工发布的区块便成了叔父区块。 难度炸弹计算公式如下图所示。 ϵ ϵ 是2的指数函数，每十万个块扩大一倍，后期增长非常快，这就是难度“炸弹”的由来。 H′i H i ′ 称为fake block number，由真正的block number Hi H i 减少三百万得到。之所以减少三百万，是因为目前proof of stake的工作量证明方式还存在一些问题，pos协议涉及不够完善，但是难度炸弹已经导致挖矿时间变成了30秒左右，为了减小难度，就会减去三百万。 设置难度炸弹的原因是要降低迁移到PoS协议时发生fork的风险，假若矿工联合起来抵制POS的工作量证明模式，那就会导致以太坊产生硬分叉；有了难度炸弹，挖矿难度越来越大，矿工就有意愿迁移到PoS协议上了。难度炸弹的威力，可以通过下图看出。 区块数量到370万之后，挖矿难度突然递增，到430万时，难度已经非常之大了，这时候挖矿时间已经变为为30秒，但是POS协议还没有完善，于是以太坊将挖矿难度公式进行调整，使得每次计算时，当前区块号减去三百万，这样就降低了挖矿难度，并且在这个时期，对以太坊出块奖励进行了调整，从原来的5个ETH变为3个ETH。 以太坊中难度计算公式如下图所示，由于目前处于以太坊发展的Metropolis中的Byzantium阶段，所以难度计算公式的函数名称为calcDifficultyByzantium // calcDifficultyByzantium is the difficulty adjustment algorithm. It returns // the difficulty that a new block should have when created at time given the // parent block&#39;s time and difficulty. The calculation uses the Byzantium rules. func calcDifficultyByzantium(time uint64, parent *types.Header) *big.Int { // https://github.com/ethereum/EIPs/issues/100. // algorithm:这里给出了难度计算公式的整体注释 // diff = (parent_diff + // (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) // - ((timestamp - parent.timestamp) // 9), -99))) + 2^(periodCount - 2) // 获取当前时间和父区块的时间戳 bigTime := new(big.Int).SetUint64(time) bigParentTime := new(big.Int).Set(parent.Time) // holds intermediate values to make the algo easier to read &amp; audit x := new(big.Int) y := new(big.Int) //这里求出当前区块时间戳和父区块的时间戳，然后求差之后除以9 // (2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9 x.Sub(bigTime, bigParentTime) x.Div(x, big9) if parent.UncleHash == types.EmptyUncleHash { x.Sub(big1, x) } else { x.Sub(big2, x) } // max((2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9, -99) if x.Cmp(bigMinus99) &lt; 0 { x.Set(bigMinus99) } // parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - //((timestamp - parent.timestamp) // 9), -99)) y.Div(parent.Difficulty, params.DifficultyBoundDivisor) x.Mul(y, x) x.Add(parent.Difficulty, x) // minimum difficulty can ever be (before exponential factor) // MinumumDifficulty = big.NewInt(131072) if x.Cmp(params.MinimumDifficulty) &lt; 0 { x.Set(params.MinimumDifficulty) } // calculate a fake block number for the ice-age delay: // https://github.com/ethereum/EIPs/pull/669 // fake_block_number = max(0, block.number - 3_000_000) fakeBlockNumber := new(big.Int) if parent.Number.Cmp(big2999999) &gt;= 0 { // Note, parent is 1 less than the actual block number fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) } // for the exponential factor periodCount := fakeBlockNumber periodCount.Div(periodCount, expDiffPeriod) // the exponential factor, commonly referred to as &quot;the bomb&quot; // diff = diff + 2^(periodCount - 2) if periodCount.Cmp(big1) &gt; 0 { y.Sub(periodCount, big2) y.Exp(big2, y, nil) x.Add(x, y) } return x } 至此，以太坊的挖矿过程和难度调整过程告一段落。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，转载请说明出处 https://blog.csdn.net/t46414704152abc/article/details/81538361 以太坊挖矿过程 在比特币的挖矿过程中，仅仅需要较为简单的哈希运算，而不需要额外的计算资源（内存等），于是比特币的挖矿过程逐渐成为了算力的竞争，于是就出现了ASIC矿机，这种矿机相比于个人计算机，进行普通的计算，其算力是个人计算机的数千倍，刚好适用于进行比特币中的挖矿，因此，普通人要想挖矿，就得有更专业的设备，挖矿这一行业都出现了中心化的现象，这与比特币当初设计之初的去中心化理念背道而驰了。 于是，设计以太坊挖矿的时候，采用了全新的挖矿过程以做到ASIC Resistance。ASIC只能进行运算，却没有额外存储空间，于是以太坊在挖矿过程中设计了两个数据结构，分别为Cache和dataset。其中Cache是16M大小，而dataset是1G大小，对于矿工来说，每次选取一个nonce之后的挖矿操作，都要从dataset中读取数据，这就要求矿机有存储能力，挖矿过程中引入了读取内存的操作，这就极大的降低了ASIC矿机的算力，使其挖矿的优势不那么明显，而普通的个人计算机也能进行挖矿。具体的挖矿过程如下： 根据当前区块信息生成一个Seed种子。 根据Seed种子生成16M大小的Cache,Cache是一个List结构，其数据前后相关。 根据Cache来生成1G大小的Dataset（又称为Dag）。 矿机每次选取一个Nonce之后，从Dataset中读取两个数进行挖矿测试，直到找到合适的Nonce。 区块链中每30000个区块的时候，Cache和Dataset的大小都会增加 1128 1 128 ,也就是说Cache会增加128K，而Dataset会增加8M。生成Cache的算法如下： def mkcache(cache_size, seed): cache = [hash(seed)] for i in range(1,cache_size): cache.append(hash[cache[-1]]) return cache dataset的生成来源于cache，具体来说，dataset[i]个元素的生成需要cache和cache[i]的参与。dataset中第i个元素的生成代码如下： def cal_dataset_i(cahce, i):# 计算dataset[i] cache_size = cache.size mix = hash(cache[i%cache_size]^i)# cache远远小于dataset，让i也参与运算，从而使得mix不会重复 for j in range(256): cache_index = get_int(mix); mix = make_item(mix,cache[cache_index%cache_size]) return hash(mix) 上述代码是伪代码，省略了大部分细节，重点在于展示原理。 先通过cache中的第i%cache_size个元素生成初始的mix，因为两个不同的dataset元素可能对应同一个cache中的元素，为了保证每个初始的mix都不同，注意到i也参与了哈希计算。 随后循环256次，每次通过get_int来根据当前的mix值求得下一个要访问的cache元素的下标，用这个cache元素和mix通过make_item求得新的mix值。注意到由于初始的mix值都不同，所以访问cache的序列也都是不同的。 最终返回mix的哈希值，得到第i个dataset中的元素。 多次调用这个函数，就可以得到完整的dataset。 通过cache生成dataset的元素时，下一个用到的cache中的元素的位置是通过当前用到的cache的元素的值计算得到的，这样具体的访问顺序事先不可预知，满足伪随机性。生称dataset的代码如下： def calc_dataset(full_size, cache): return [calc_dataset_item(cache,i) for i in range(full_size)] 生成dataset之后矿工就可以开始挖矿，根据特定的过程计算出一个哈希值，其代码如下所示。其中的循环64次并没有额外的原因，就是想增加挖矿过程中的访问内存操作。矿工为了增加挖矿速度，就必须要将dataset存储在内存中。 # 根据nonce计算出一个哈希值 def get_hash_value(header, nonce, full_size, dataset): hash_value = hash(header, nonce); for i in range(64): dataset_index = get_int(hash_value )%full_size hash_value = make_item(hash_value , dataset[dataset_index) hash_value = make_item(hash_value , dataset[dataset_index+1]) return hash(hash_value ) 如果一个nonce不合适，就需要更换一个nonce，直到找到合适的nonce，整个挖矿过程伪代码如下： def mine(full_size, dataset, header, target): max_nonce = 2**64 nonce = random.randint(0, max_nonce ) while get_hash_value(header, nonce, full_size, dataset) &gt; target: nonce = (nonce+1)%max_nonce return nonce 为什么要挖矿中设计cache呢，貌似矿工挖矿的时候根本没有用到cache，为什么要多此一举？这是为了方便轻节点对区块进行验证。对于轻节点来说，不可能存储很大的dataset，但是轻节点可以通过存储cache，验证某个区块块头时，根据cache生成dataset中某个元素，随后验证区块的合法性。轻节点验证区块合法性的伪代码如下： def varify(header, nonce, full_size, cache): hash_value = hash(header, nonce) for i in range(64): index = get_int(hash_value)%full_size hash_value = hash(hash_value, cal_dataset_i(cache,index))# 计算生成dataset中的数据 hash_value = hash(hash_value,cal_dataset_i(cache,index+1)) return hash(hash_value) 矿工需要验证大量的nonce，若每次都要从16M的cache中重新生成，那么挖矿的效率就大打折扣，而且会有大量的重复计算：随机选取的dataset的元素中有很多是重复的，可能是之前尝试别的nonce时用过的。所以，矿工采取以空间换时间的策略，把整个dataset保存下来。而轻节点由于只验证一个nonce，验证的时候就直接生成要用到的dataset中的元素就行了。 以太坊挖矿难度调整 以太坊中的区块的难度调整公式如下图所示。 参数说明 区块链难度调整中，创始块的难度被设置为 D0=131072 D 0 = 131072 ，此后每个区块的难度都与其父区块的难度相关。D(H)是本区块的难度，由 P(H)Hd+x×ζ2 P ( H ) H d + x × ζ 2 和难度炸弹 ϵ ϵ 构成。 P(H)Hd P ( H ) H d 为父区块的难度，每个区块的难度都是在父区块难度的基础上进行调整。 x×ζ2 x × ζ 2 用于自适应调节出块难度，维持稳定的出块速度。 ϵ ϵ 表示难度炸弹。 难度有最低下限，即不能低于 D0=131072 D 0 = 131072 其中 x x 和 ϵ2 ϵ 2 的计算方式如下图所示。 x x 是父区块难度的 12048 1 2048 的取整，是调整的单位。 ϵ ϵ 是调整系数，其小只能是-99。 y的取值依赖于父区块是否包含叔父区块，如果包含，则y=2，否则y=1。 HS H S 是本区块的时间戳， P(H)Hs P ( H ) H s 是父区块的时间戳，单位为秒，并且 HS&gt;P(H)Hs H S &gt; P ( H ) H s 。 难度降低的上界设置为−99 ，主要是应对被黑客攻击或其他目前想不到的黑天鹅事件。 假设当父区块不带叔父区块的时候（y=1），调整过程如下： 出块时间在[1,8]之间，出块时间过短，难度调大一个单位。 出块时间在[9,17]之间，出块时间可以接受，难度保持不变。 出块时间在[18,26]之间，出块时间过长，难度调小一个单位。 … 这里发现，出块时间变长，区块的整体难度就会调小，假若有的矿工，故意将区块的时间戳改的比较晚，那么是不是就可以抢先发布区块呢？比如说将时间戳延迟写15秒，会怎么样呢？这样就会导致该矿工计算出来的难度比别的矿工计算的难度低，其他矿工15秒发布一个区块，而该矿工可以在10秒内发布区块，可以拿到区块奖励。但是问题在于假如刚好也有别的区块在10秒内发布了区块，此时根据POW的规则，另外一个矿工发布的区块难度更大，因此其他矿工会以最大工作量标准，选择15秒内挖出的区块所在的链作为主链，而该矿工发布的区块便成了叔父区块。 难度炸弹计算公式如下图所示。 ϵ ϵ 是2的指数函数，每十万个块扩大一倍，后期增长非常快，这就是难度“炸弹”的由来。 H′i H i ′ 称为fake block number，由真正的block number Hi H i 减少三百万得到。之所以减少三百万，是因为目前proof of stake的工作量证明方式还存在一些问题，pos协议涉及不够完善，但是难度炸弹已经导致挖矿时间变成了30秒左右，为了减小难度，就会减去三百万。 设置难度炸弹的原因是要降低迁移到PoS协议时发生fork的风险，假若矿工联合起来抵制POS的工作量证明模式，那就会导致以太坊产生硬分叉；有了难度炸弹，挖矿难度越来越大，矿工就有意愿迁移到PoS协议上了。难度炸弹的威力，可以通过下图看出。 区块数量到370万之后，挖矿难度突然递增，到430万时，难度已经非常之大了，这时候挖矿时间已经变为为30秒，但是POS协议还没有完善，于是以太坊将挖矿难度公式进行调整，使得每次计算时，当前区块号减去三百万，这样就降低了挖矿难度，并且在这个时期，对以太坊出块奖励进行了调整，从原来的5个ETH变为3个ETH。 以太坊中难度计算公式如下图所示，由于目前处于以太坊发展的Metropolis中的Byzantium阶段，所以难度计算公式的函数名称为calcDifficultyByzantium // calcDifficultyByzantium is the difficulty adjustment algorithm. It returns // the difficulty that a new block should have when created at time given the // parent block&#39;s time and difficulty. The calculation uses the Byzantium rules. func calcDifficultyByzantium(time uint64, parent *types.Header) *big.Int { // https://github.com/ethereum/EIPs/issues/100. // algorithm:这里给出了难度计算公式的整体注释 // diff = (parent_diff + // (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) // - ((timestamp - parent.timestamp) // 9), -99))) + 2^(periodCount - 2) // 获取当前时间和父区块的时间戳 bigTime := new(big.Int).SetUint64(time) bigParentTime := new(big.Int).Set(parent.Time) // holds intermediate values to make the algo easier to read &amp; audit x := new(big.Int) y := new(big.Int) //这里求出当前区块时间戳和父区块的时间戳，然后求差之后除以9 // (2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9 x.Sub(bigTime, bigParentTime) x.Div(x, big9) if parent.UncleHash == types.EmptyUncleHash { x.Sub(big1, x) } else { x.Sub(big2, x) } // max((2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9, -99) if x.Cmp(bigMinus99) &lt; 0 { x.Set(bigMinus99) } // parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - //((timestamp - parent.timestamp) // 9), -99)) y.Div(parent.Difficulty, params.DifficultyBoundDivisor) x.Mul(y, x) x.Add(parent.Difficulty, x) // minimum difficulty can ever be (before exponential factor) // MinumumDifficulty = big.NewInt(131072) if x.Cmp(params.MinimumDifficulty) &lt; 0 { x.Set(params.MinimumDifficulty) } // calculate a fake block number for the ice-age delay: // https://github.com/ethereum/EIPs/pull/669 // fake_block_number = max(0, block.number - 3_000_000) fakeBlockNumber := new(big.Int) if parent.Number.Cmp(big2999999) &gt;= 0 { // Note, parent is 1 less than the actual block number fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) } // for the exponential factor periodCount := fakeBlockNumber periodCount.Div(periodCount, expDiffPeriod) // the exponential factor, commonly referred to as &quot;the bomb&quot; // diff = diff + 2^(periodCount - 2) if periodCount.Cmp(big1) &gt; 0 { y.Sub(periodCount, big2) y.Exp(big2, y, nil) x.Add(x, y) } return x } 至此，以太坊的挖矿过程和难度调整过程告一段落。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，转载请说明出处 https://blog.csdn.net/t46414704152abc/article/details/81538361 以太坊挖矿过程 在比特币的挖矿过程中，仅仅需要较为简单的哈希运算，而不需要额外的计算资源（内存等），于是比特币的挖矿过程逐渐成为了算力的竞争，于是就出现了ASIC矿机，这种矿机相比于个人计算机，进行普通的计算，其算力是个人计算机的数千倍，刚好适用于进行比特币中的挖矿，因此，普通人要想挖矿，就得有更专业的设备，挖矿这一行业都出现了中心化的现象，这与比特币当初设计之初的去中心化理念背道而驰了。 于是，设计以太坊挖矿的时候，采用了全新的挖矿过程以做到ASIC Resistance。ASIC只能进行运算，却没有额外存储空间，于是以太坊在挖矿过程中设计了两个数据结构，分别为Cache和dataset。其中Cache是16M大小，而dataset是1G大小，对于矿工来说，每次选取一个nonce之后的挖矿操作，都要从dataset中读取数据，这就要求矿机有存储能力，挖矿过程中引入了读取内存的操作，这就极大的降低了ASIC矿机的算力，使其挖矿的优势不那么明显，而普通的个人计算机也能进行挖矿。具体的挖矿过程如下： 根据当前区块信息生成一个Seed种子。 根据Seed种子生成16M大小的Cache,Cache是一个List结构，其数据前后相关。 根据Cache来生成1G大小的Dataset（又称为Dag）。 矿机每次选取一个Nonce之后，从Dataset中读取两个数进行挖矿测试，直到找到合适的Nonce。 区块链中每30000个区块的时候，Cache和Dataset的大小都会增加 1128 1 128 ,也就是说Cache会增加128K，而Dataset会增加8M。生成Cache的算法如下： def mkcache(cache_size, seed): cache = [hash(seed)] for i in range(1,cache_size): cache.append(hash[cache[-1]]) return cache dataset的生成来源于cache，具体来说，dataset[i]个元素的生成需要cache和cache[i]的参与。dataset中第i个元素的生成代码如下： def cal_dataset_i(cahce, i):# 计算dataset[i] cache_size = cache.size mix = hash(cache[i%cache_size]^i)# cache远远小于dataset，让i也参与运算，从而使得mix不会重复 for j in range(256): cache_index = get_int(mix); mix = make_item(mix,cache[cache_index%cache_size]) return hash(mix) 上述代码是伪代码，省略了大部分细节，重点在于展示原理。 先通过cache中的第i%cache_size个元素生成初始的mix，因为两个不同的dataset元素可能对应同一个cache中的元素，为了保证每个初始的mix都不同，注意到i也参与了哈希计算。 随后循环256次，每次通过get_int来根据当前的mix值求得下一个要访问的cache元素的下标，用这个cache元素和mix通过make_item求得新的mix值。注意到由于初始的mix值都不同，所以访问cache的序列也都是不同的。 最终返回mix的哈希值，得到第i个dataset中的元素。 多次调用这个函数，就可以得到完整的dataset。 通过cache生成dataset的元素时，下一个用到的cache中的元素的位置是通过当前用到的cache的元素的值计算得到的，这样具体的访问顺序事先不可预知，满足伪随机性。生称dataset的代码如下： def calc_dataset(full_size, cache): return [calc_dataset_item(cache,i) for i in range(full_size)] 生成dataset之后矿工就可以开始挖矿，根据特定的过程计算出一个哈希值，其代码如下所示。其中的循环64次并没有额外的原因，就是想增加挖矿过程中的访问内存操作。矿工为了增加挖矿速度，就必须要将dataset存储在内存中。 # 根据nonce计算出一个哈希值 def get_hash_value(header, nonce, full_size, dataset): hash_value = hash(header, nonce); for i in range(64): dataset_index = get_int(hash_value )%full_size hash_value = make_item(hash_value , dataset[dataset_index) hash_value = make_item(hash_value , dataset[dataset_index+1]) return hash(hash_value ) 如果一个nonce不合适，就需要更换一个nonce，直到找到合适的nonce，整个挖矿过程伪代码如下： def mine(full_size, dataset, header, target): max_nonce = 2**64 nonce = random.randint(0, max_nonce ) while get_hash_value(header, nonce, full_size, dataset) &gt; target: nonce = (nonce+1)%max_nonce return nonce 为什么要挖矿中设计cache呢，貌似矿工挖矿的时候根本没有用到cache，为什么要多此一举？这是为了方便轻节点对区块进行验证。对于轻节点来说，不可能存储很大的dataset，但是轻节点可以通过存储cache，验证某个区块块头时，根据cache生成dataset中某个元素，随后验证区块的合法性。轻节点验证区块合法性的伪代码如下： def varify(header, nonce, full_size, cache): hash_value = hash(header, nonce) for i in range(64): index = get_int(hash_value)%full_size hash_value = hash(hash_value, cal_dataset_i(cache,index))# 计算生成dataset中的数据 hash_value = hash(hash_value,cal_dataset_i(cache,index+1)) return hash(hash_value) 矿工需要验证大量的nonce，若每次都要从16M的cache中重新生成，那么挖矿的效率就大打折扣，而且会有大量的重复计算：随机选取的dataset的元素中有很多是重复的，可能是之前尝试别的nonce时用过的。所以，矿工采取以空间换时间的策略，把整个dataset保存下来。而轻节点由于只验证一个nonce，验证的时候就直接生成要用到的dataset中的元素就行了。 以太坊挖矿难度调整 以太坊中的区块的难度调整公式如下图所示。 参数说明 区块链难度调整中，创始块的难度被设置为 D0=131072 D 0 = 131072 ，此后每个区块的难度都与其父区块的难度相关。D(H)是本区块的难度，由 P(H)Hd+x×ζ2 P ( H ) H d + x × ζ 2 和难度炸弹 ϵ ϵ 构成。 P(H)Hd P ( H ) H d 为父区块的难度，每个区块的难度都是在父区块难度的基础上进行调整。 x×ζ2 x × ζ 2 用于自适应调节出块难度，维持稳定的出块速度。 ϵ ϵ 表示难度炸弹。 难度有最低下限，即不能低于 D0=131072 D 0 = 131072 其中 x x 和 ϵ2 ϵ 2 的计算方式如下图所示。 x x 是父区块难度的 12048 1 2048 的取整，是调整的单位。 ϵ ϵ 是调整系数，其小只能是-99。 y的取值依赖于父区块是否包含叔父区块，如果包含，则y=2，否则y=1。 HS H S 是本区块的时间戳， P(H)Hs P ( H ) H s 是父区块的时间戳，单位为秒，并且 HS&gt;P(H)Hs H S &gt; P ( H ) H s 。 难度降低的上界设置为−99 ，主要是应对被黑客攻击或其他目前想不到的黑天鹅事件。 假设当父区块不带叔父区块的时候（y=1），调整过程如下： 出块时间在[1,8]之间，出块时间过短，难度调大一个单位。 出块时间在[9,17]之间，出块时间可以接受，难度保持不变。 出块时间在[18,26]之间，出块时间过长，难度调小一个单位。 … 这里发现，出块时间变长，区块的整体难度就会调小，假若有的矿工，故意将区块的时间戳改的比较晚，那么是不是就可以抢先发布区块呢？比如说将时间戳延迟写15秒，会怎么样呢？这样就会导致该矿工计算出来的难度比别的矿工计算的难度低，其他矿工15秒发布一个区块，而该矿工可以在10秒内发布区块，可以拿到区块奖励。但是问题在于假如刚好也有别的区块在10秒内发布了区块，此时根据POW的规则，另外一个矿工发布的区块难度更大，因此其他矿工会以最大工作量标准，选择15秒内挖出的区块所在的链作为主链，而该矿工发布的区块便成了叔父区块。 难度炸弹计算公式如下图所示。 ϵ ϵ 是2的指数函数，每十万个块扩大一倍，后期增长非常快，这就是难度“炸弹”的由来。 H′i H i ′ 称为fake block number，由真正的block number Hi H i 减少三百万得到。之所以减少三百万，是因为目前proof of stake的工作量证明方式还存在一些问题，pos协议涉及不够完善，但是难度炸弹已经导致挖矿时间变成了30秒左右，为了减小难度，就会减去三百万。 设置难度炸弹的原因是要降低迁移到PoS协议时发生fork的风险，假若矿工联合起来抵制POS的工作量证明模式，那就会导致以太坊产生硬分叉；有了难度炸弹，挖矿难度越来越大，矿工就有意愿迁移到PoS协议上了。难度炸弹的威力，可以通过下图看出。 区块数量到370万之后，挖矿难度突然递增，到430万时，难度已经非常之大了，这时候挖矿时间已经变为为30秒，但是POS协议还没有完善，于是以太坊将挖矿难度公式进行调整，使得每次计算时，当前区块号减去三百万，这样就降低了挖矿难度，并且在这个时期，对以太坊出块奖励进行了调整，从原来的5个ETH变为3个ETH。 以太坊中难度计算公式如下图所示，由于目前处于以太坊发展的Metropolis中的Byzantium阶段，所以难度计算公式的函数名称为calcDifficultyByzantium // calcDifficultyByzantium is the difficulty adjustment algorithm. It returns // the difficulty that a new block should have when created at time given the // parent block&#39;s time and difficulty. The calculation uses the Byzantium rules. func calcDifficultyByzantium(time uint64, parent *types.Header) *big.Int { // https://github.com/ethereum/EIPs/issues/100. // algorithm:这里给出了难度计算公式的整体注释 // diff = (parent_diff + // (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) // - ((timestamp - parent.timestamp) // 9), -99))) + 2^(periodCount - 2) // 获取当前时间和父区块的时间戳 bigTime := new(big.Int).SetUint64(time) bigParentTime := new(big.Int).Set(parent.Time) // holds intermediate values to make the algo easier to read &amp; audit x := new(big.Int) y := new(big.Int) //这里求出当前区块时间戳和父区块的时间戳，然后求差之后除以9 // (2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9 x.Sub(bigTime, bigParentTime) x.Div(x, big9) if parent.UncleHash == types.EmptyUncleHash { x.Sub(big1, x) } else { x.Sub(big2, x) } // max((2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9, -99) if x.Cmp(bigMinus99) &lt; 0 { x.Set(bigMinus99) } // parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - //((timestamp - parent.timestamp) // 9), -99)) y.Div(parent.Difficulty, params.DifficultyBoundDivisor) x.Mul(y, x) x.Add(parent.Difficulty, x) // minimum difficulty can ever be (before exponential factor) // MinumumDifficulty = big.NewInt(131072) if x.Cmp(params.MinimumDifficulty) &lt; 0 { x.Set(params.MinimumDifficulty) } // calculate a fake block number for the ice-age delay: // https://github.com/ethereum/EIPs/pull/669 // fake_block_number = max(0, block.number - 3_000_000) fakeBlockNumber := new(big.Int) if parent.Number.Cmp(big2999999) &gt;= 0 { // Note, parent is 1 less than the actual block number fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) } // for the exponential factor periodCount := fakeBlockNumber periodCount.Div(periodCount, expDiffPeriod) // the exponential factor, commonly referred to as &quot;the bomb&quot; // diff = diff + 2^(periodCount - 2) if periodCount.Cmp(big1) &gt; 0 { y.Sub(periodCount, big2) y.Exp(big2, y, nil) x.Add(x, y) } return x } 至此，以太坊的挖矿过程和难度调整过程告一段落。 阅读更多","@type":"BlogPosting","url":"/2018/08/09/0328da5f32fd2c540d9f819d8e9edd67.html","headline":"以太坊的挖矿和难度调整过程","dateModified":"2018-08-09T00:00:00+08:00","datePublished":"2018-08-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/09/0328da5f32fd2c540d9f819d8e9edd67.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊的挖矿和难度调整过程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，转载请说明出处 https://blog.csdn.net/t46414704152abc/article/details/81538361 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3 id="以太坊挖矿过程">以太坊挖矿过程</h3> 
  <p>在比特币的挖矿过程中，仅仅需要较为简单的哈希运算，而不需要额外的计算资源（内存等），于是比特币的挖矿过程逐渐成为了算力的竞争，于是就出现了ASIC矿机，这种矿机相比于个人计算机，进行普通的计算，其算力是个人计算机的数千倍，刚好适用于进行比特币中的挖矿，因此，普通人要想挖矿，就得有更专业的设备，挖矿这一行业都出现了中心化的现象，这与比特币当初设计之初的去中心化理念背道而驰了。</p> 
  <p>于是，设计以太坊挖矿的时候，采用了全新的挖矿过程以做到ASIC Resistance。ASIC只能进行运算，却没有额外存储空间，于是以太坊在挖矿过程中设计了两个数据结构，分别为Cache和dataset。其中Cache是16M大小，而dataset是1G大小，对于矿工来说，每次选取一个nonce之后的挖矿操作，都要从dataset中读取数据，这就要求矿机有存储能力，挖矿过程中引入了读取内存的操作，这就极大的降低了ASIC矿机的算力，使其挖矿的优势不那么明显，而普通的个人计算机也能进行挖矿。具体的挖矿过程如下：</p> 
  <ol> 
   <li>根据当前区块信息生成一个Seed种子。</li> 
   <li>根据Seed种子生成16M大小的Cache,Cache是一个List结构，其数据前后相关。</li> 
   <li>根据Cache来生成1G大小的Dataset（又称为Dag）。</li> 
   <li>矿机每次选取一个Nonce之后，从Dataset中读取两个数进行挖矿测试，直到找到合适的Nonce。</li> 
  </ol> 
  <p>区块链中每30000个区块的时候，Cache和Dataset的大小都会增加<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-17-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mfrac><mn>1</mn><mn>128</mn></mfrac></math>" role="presentation">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-1" style="width: 1.721em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.409em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.096em, 1001.41em, 2.711em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mfrac" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 1.201em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;"><span style="position: absolute; clip: rect(3.388em, 1000.32em, 4.169em, -999.997em); top: -4.424em; left: 50%; margin-left: -0.154em;"><span class="mn" id="MathJax-Span-4" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.388em, 1001.04em, 4.169em, -999.997em); top: -3.643em; left: 50%; margin-left: -0.518em;"><span class="mn" id="MathJax-Span-5" style="font-size: 70.7%; font-family: MathJax_Main;">128</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(0.836em, 1001.2em, 1.201em, -999.997em); top: -1.247em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 1.201em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.044em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.559em; border-left: 0px solid; width: 0px; height: 1.628em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mfrac>
       <mn>
        1
       </mn>
       <mn>
        128
       </mn>
      </mfrac>
     </math></span></span><script type="math/tex" id="MathJax-Element-17">\frac 1 {128}</script>,也就是说Cache会增加128K，而Dataset会增加8M。生成Cache的算法如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkcache</span><span class="hljs-params">(cache_size, seed)</span>:</span>
    cache = [hash(seed)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,cache_size):
        cache.append(hash[cache[-<span class="hljs-number">1</span>]])
    <span class="hljs-keyword">return</span> cache</code></pre> 
  <p>dataset的生成来源于cache，具体来说，dataset[i]个元素的生成需要cache和cache[i]的参与。dataset中第i个元素的生成代码如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cal_dataset_i</span><span class="hljs-params">(cahce, i)</span>:</span><span class="hljs-comment"># 计算dataset[i]</span>
    cache_size = cache.size
    mix = hash(cache[i%cache_size]^i)<span class="hljs-comment"># cache远远小于dataset，让i也参与运算，从而使得mix不会重复</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">256</span>):
        cache_index = get_int(mix);
        mix = make_item(mix,cache[cache_index%cache_size])
    <span class="hljs-keyword">return</span> hash(mix)</code></pre> 
  <p>上述代码是伪代码，省略了大部分细节，重点在于展示原理。</p> 
  <ol> 
   <li>先通过cache中的第i%cache_size个元素生成初始的mix，因为两个不同的dataset元素可能对应同一个cache中的元素，为了保证每个初始的mix都不同，注意到i也参与了哈希计算。</li> 
   <li>随后循环256次，每次通过get_int来根据当前的mix值求得下一个要访问的cache元素的下标，用这个cache元素和mix通过make_item求得新的mix值。注意到由于初始的mix值都不同，所以访问cache的序列也都是不同的。 <br> 最终返回mix的哈希值，得到第i个dataset中的元素。</li> 
   <li>多次调用这个函数，就可以得到完整的dataset。</li> 
  </ol> 
  <p>通过cache生成dataset的元素时，下一个用到的cache中的元素的位置是通过当前用到的cache的元素的值计算得到的，这样具体的访问顺序事先不可预知，满足伪随机性。生称dataset的代码如下：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_dataset</span><span class="hljs-params">(full_size, cache)</span>:</span>
    <span class="hljs-keyword">return</span> [calc_dataset_item(cache,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(full_size)]</code></pre> 
  <p>生成dataset之后矿工就可以开始挖矿，根据特定的过程计算出一个哈希值，其代码如下所示。其中的循环64次并没有额外的原因，就是想增加挖矿过程中的访问内存操作。矿工为了增加挖矿速度，就必须要将dataset存储在内存中。</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment"># 根据nonce计算出一个哈希值</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_hash_value</span><span class="hljs-params">(header, nonce, full_size, dataset)</span>:</span>
    hash_value = hash(header, nonce);
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):
        dataset_index = get_int(hash_value )%full_size
        hash_value = make_item(hash_value , dataset[dataset_index)
        hash_value = make_item(hash_value , dataset[dataset_index+<span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> hash(hash_value )</code></pre> 
  <p>如果一个nonce不合适，就需要更换一个nonce，直到找到合适的nonce，整个挖矿过程伪代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">(full_size, dataset, header, target)</span>:</span>
    max_nonce = <span class="hljs-number">2</span>**<span class="hljs-number">64</span>
    nonce = random.randint(<span class="hljs-number">0</span>, max_nonce )
    <span class="hljs-keyword">while</span> get_hash_value(header, nonce, full_size, dataset) &gt; target:
        nonce = (nonce+<span class="hljs-number">1</span>)%max_nonce
    <span class="hljs-keyword">return</span> nonce</code></pre> 
  <p>为什么要挖矿中设计cache呢，貌似矿工挖矿的时候根本没有用到cache，为什么要多此一举？这是为了方便轻节点对区块进行验证。对于轻节点来说，不可能存储很大的dataset，但是轻节点可以通过存储cache，验证某个区块块头时，根据cache生成dataset中某个元素，随后验证区块的合法性。轻节点验证区块合法性的伪代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">varify</span><span class="hljs-params">(header, nonce, full_size, cache)</span>:</span>
    hash_value = hash(header, nonce)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):
        index = get_int(hash_value)%full_size
        hash_value = hash(hash_value, cal_dataset_i(cache,index))<span class="hljs-comment"># 计算生成dataset中的数据</span>
        hash_value = hash(hash_value,cal_dataset_i(cache,index+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> hash(hash_value)</code></pre> 
  <p>矿工需要验证大量的nonce，若每次都要从16M的cache中重新生成，那么挖矿的效率就大打折扣，而且会有大量的重复计算：随机选取的dataset的元素中有很多是重复的，可能是之前尝试别的nonce时用过的。所以，矿工采取以空间换时间的策略，把整个dataset保存下来。而轻节点由于只验证一个nonce，验证的时候就直接生成要用到的dataset中的元素就行了。</p> 
  <h3 id="以太坊挖矿难度调整">以太坊挖矿难度调整</h3> 
  <p>以太坊中的区块的难度调整公式如下图所示。 <br> </p>
  <center> 
   <br> 
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180809173053942?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%">
  </center>
  <p></p> 
  <h4 id="参数说明">参数说明</h4> 
  <ol> 
   <li><p>区块链难度调整中，创始块的难度被设置为<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5039-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>D</mi><mn>0</mn></msub><mo>=</mo><mn>131072</mn></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37783" style="width: 6.721em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.576em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.305em, 1005.52em, 2.451em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37784"><span class="msubsup" id="MathJax-Span-37785"><span style="display: inline-block; position: relative; width: 1.253em; height: 0px;"><span style="position: absolute; clip: rect(3.18em, 1000.78em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37786" style="font-family: MathJax_Math-italic;">D</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.836em;"><span class="mn" id="MathJax-Span-37787" style="font-size: 70.7%; font-family: MathJax_Main;">0</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-37788" style="font-family: MathJax_Main; padding-left: 0.263em;">=</span><span class="mn" id="MathJax-Span-37789" style="font-family: MathJax_Main; padding-left: 0.263em;">131072</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub>
         <mi>
          D
         </mi>
         <mn>
          0
         </mn>
        </msub>
        <mo>
         =
        </mo>
        <mn>
         131072
        </mn>
       </math></span></span><script type="math/tex" id="MathJax-Element-5039">D_0 = 131072</script> ，此后每个区块的难度都与其父区块的难度相关。D(H)是本区块的难度，由<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5040-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>H</mi><msub><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>d</mi></mrow></msub></mrow></msub><mo>+</mo><mi>x</mi><mo>&amp;#x00D7;</mo><msub><mi>&amp;#x03B6;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37790" style="width: 8.701em; display: inline-block;"><span style="display: inline-block; position: relative; width: 7.242em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.253em, 1007.24em, 2.555em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37791"><span class="mi" id="MathJax-Span-37792" style="font-family: MathJax_Math-italic;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.107em;"></span></span><span class="mo" id="MathJax-Span-37793" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-37794" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span class="msubsup" id="MathJax-Span-37795"><span style="display: inline-block; position: relative; width: 1.357em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.32em, 4.43em, -999.997em); top: -4.008em; left: 0em;"><span class="mo" id="MathJax-Span-37796" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.367em;"><span class="texatom" id="MathJax-Span-37797"><span class="mrow" id="MathJax-Span-37798"><span class="msubsup" id="MathJax-Span-37799"><span style="display: inline-block; position: relative; width: 0.888em; height: 0px;"><span style="position: absolute; clip: rect(3.388em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37800" style="font-size: 70.7%; font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.904em; left: 0.576em;"><span class="texatom" id="MathJax-Span-37801"><span class="mrow" id="MathJax-Span-37802"><span class="mi" id="MathJax-Span-37803" style="font-size: 50%; font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-37804" style="font-family: MathJax_Main; padding-left: 0.211em;">+</span><span class="mi" id="MathJax-Span-37805" style="font-family: MathJax_Math-italic; padding-left: 0.211em;">x</span><span class="mo" id="MathJax-Span-37806" style="font-family: MathJax_Main; padding-left: 0.211em;">×</span><span class="msubsup" id="MathJax-Span-37807" style="padding-left: 0.211em;"><span style="display: inline-block; position: relative; width: 0.888em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37808" style="font-family: MathJax_Math-italic;">ζ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.419em;"><span class="texatom" id="MathJax-Span-37809"><span class="mrow" id="MathJax-Span-37810"><span class="mn" id="MathJax-Span-37811" style="font-size: 70.7%; font-family: MathJax_Main;">2</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>
         P
        </mi>
        <mo stretchy="false">
         (
        </mo>
        <mi>
         H
        </mi>
        <msub>
         <mo stretchy="false">
          )
         </mo>
         <mrow class="MJX-TeXAtom-ORD">
          <msub>
           <mi>
            H
           </mi>
           <mrow class="MJX-TeXAtom-ORD">
            <mi>
             d
            </mi>
           </mrow>
          </msub>
         </mrow>
        </msub>
        <mo>
         +
        </mo>
        <mi>
         x
        </mi>
        <mo>
         ×
        </mo>
        <msub>
         <mi>
          ζ
         </mi>
         <mrow class="MJX-TeXAtom-ORD">
          <mn>
           2
          </mn>
         </mrow>
        </msub>
       </math></span></span><script type="math/tex" id="MathJax-Element-5040">P(H)_{H_{d}}+x \times \zeta_{2} </script>和难度炸弹<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5041-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03F5;</mi></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37812" style="width: 0.523em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.419em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em, 1000.42em, 2.294em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37813"><span class="mi" id="MathJax-Span-37814" style="font-family: MathJax_Math-italic;">ϵ</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>
         ϵ
        </mi>
       </math></span></span><script type="math/tex" id="MathJax-Element-5041">\epsilon</script>构成。</p></li> 
   <li><p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5042-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>H</mi><msub><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>d</mi></mrow></msub></mrow></msub></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37815" style="width: 4.065em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.388em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.253em, 1003.39em, 2.555em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37816"><span class="mi" id="MathJax-Span-37817" style="font-family: MathJax_Math-italic;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.107em;"></span></span><span class="mo" id="MathJax-Span-37818" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-37819" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span class="msubsup" id="MathJax-Span-37820"><span style="display: inline-block; position: relative; width: 1.357em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.32em, 4.43em, -999.997em); top: -4.008em; left: 0em;"><span class="mo" id="MathJax-Span-37821" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.367em;"><span class="texatom" id="MathJax-Span-37822"><span class="mrow" id="MathJax-Span-37823"><span class="msubsup" id="MathJax-Span-37824"><span style="display: inline-block; position: relative; width: 0.888em; height: 0px;"><span style="position: absolute; clip: rect(3.388em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37825" style="font-size: 70.7%; font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.904em; left: 0.576em;"><span class="texatom" id="MathJax-Span-37826"><span class="mrow" id="MathJax-Span-37827"><span class="mi" id="MathJax-Span-37828" style="font-size: 50%; font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>
         P
        </mi>
        <mo stretchy="false">
         (
        </mo>
        <mi>
         H
        </mi>
        <msub>
         <mo stretchy="false">
          )
         </mo>
         <mrow class="MJX-TeXAtom-ORD">
          <msub>
           <mi>
            H
           </mi>
           <mrow class="MJX-TeXAtom-ORD">
            <mi>
             d
            </mi>
           </mrow>
          </msub>
         </mrow>
        </msub>
       </math></span></span><script type="math/tex" id="MathJax-Element-5042">P(H)_{H_{d}}</script>为父区块的难度，每个区块的难度都是在父区块难度的基础上进行调整。</p></li> 
   <li><p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5043-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi><mo>&amp;#x00D7;</mo><msub><mi>&amp;#x03B6;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37829" style="width: 3.232em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.659em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.253em, 1002.66em, 2.503em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37830"><span class="mi" id="MathJax-Span-37831" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-37832" style="font-family: MathJax_Main; padding-left: 0.211em;">×</span><span class="msubsup" id="MathJax-Span-37833" style="padding-left: 0.211em;"><span style="display: inline-block; position: relative; width: 0.888em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37834" style="font-family: MathJax_Math-italic;">ζ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.419em;"><span class="texatom" id="MathJax-Span-37835"><span class="mrow" id="MathJax-Span-37836"><span class="mn" id="MathJax-Span-37837" style="font-size: 70.7%; font-family: MathJax_Main;">2</span></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>
         x
        </mi>
        <mo>
         ×
        </mo>
        <msub>
         <mi>
          ζ
         </mi>
         <mrow class="MJX-TeXAtom-ORD">
          <mn>
           2
          </mn>
         </mrow>
        </msub>
       </math></span></span><script type="math/tex" id="MathJax-Element-5043">x \times \zeta_{2} </script>用于自适应调节出块难度，维持稳定的出块速度。</p></li> 
   <li><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5044-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03F5;</mi></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37838" style="width: 0.503em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.392em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.558em, 1000.39em, 2.336em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37839"><span class="mi" id="MathJax-Span-37840" style="font-family: MathJax_Math-italic;">ϵ</span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 0.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        ϵ
       </mi>
      </math></span></span><script type="math/tex" id="MathJax-Element-5044">\epsilon</script>表示难度炸弹。</li> 
   <li>难度有最低下限，即不能低于<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5045-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>D</mi><mn>0</mn></msub><mo>=</mo><mn>131072</mn></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37841" style="width: 6.781em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.614em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.336em, 1005.56em, 2.503em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37842"><span class="msubsup" id="MathJax-Span-37843"><span style="display: inline-block; position: relative; width: 1.281em; height: 0px;"><span style="position: absolute; clip: rect(3.169em, 1000.78em, 4.169em, -999.997em); top: -3.997em; left: 0em;"><span class="mi" id="MathJax-Span-37844" style="font-family: MathJax_Math-italic;">D</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.831em; left: 0.836em;"><span class="mn" id="MathJax-Span-37845" style="font-size: 70.7%; font-family: MathJax_Main;">0</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span><span class="mo" id="MathJax-Span-37846" style="font-family: MathJax_Main; padding-left: 0.281em;">=</span><span class="mn" id="MathJax-Span-37847" style="font-family: MathJax_Main; padding-left: 0.281em;">131072</span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.263em; border-left: 0px solid; width: 0px; height: 1.137em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <msub>
        <mi>
         D
        </mi>
        <mn>
         0
        </mn>
       </msub>
       <mo>
        =
       </mo>
       <mn>
        131072
       </mn>
      </math></span></span><script type="math/tex" id="MathJax-Element-5045">D_0 = 131072</script></li> 
  </ol> 
  <p>其中<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5046-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-37848" style="width: 0.732em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em, 1000.52em, 2.294em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37849"><span class="mi" id="MathJax-Span-37850" style="font-family: MathJax_Math-italic;">x</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       x
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-5046">x</script>和<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5047-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03F5;</mi><mn>2</mn></msub></math>" role="presentation">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-37851" style="width: 1.044em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37852"><span class="msubsup" id="MathJax-Span-37853"><span style="display: inline-block; position: relative; width: 0.836em; height: 0px;"><span style="position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37854" style="font-family: MathJax_Math-italic;">ϵ</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.419em;"><span class="mn" id="MathJax-Span-37855" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <msub>
       <mi>
        ϵ
       </mi>
       <mn>
        2
       </mn>
      </msub>
     </math></span></span><script type="math/tex" id="MathJax-Element-5047">\epsilon_2</script>的计算方式如下图所示。 <br> </p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180809155330758?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%">
  </center>
  <p></p> 
  <ul> 
   <li><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5048-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37856" style="width: 0.669em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.558em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.558em, 1000.5em, 2.336em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37857"><span class="mi" id="MathJax-Span-37858" style="font-family: MathJax_Math-italic;">x</span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 0.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        x
       </mi>
      </math></span></span><script type="math/tex" id="MathJax-Element-5048">x</script> 是父区块难度的<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5049-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mfrac><mn>1</mn><mn>2048</mn></mfrac></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37859" style="width: 2.169em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.781em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.114em, 1001.78em, 2.725em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37860"><span class="mfrac" id="MathJax-Span-37861"><span style="display: inline-block; position: relative; width: 1.558em; height: 0px; margin-right: 0.114em; margin-left: 0.114em;"><span style="position: absolute; clip: rect(3.392em, 1000.28em, 4.169em, -999.997em); top: -4.386em; left: 50%; margin-left: -0.164em;"><span class="mn" id="MathJax-Span-37862" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.336em, 1001.39em, 4.169em, -999.997em); top: -3.608em; left: 50%; margin-left: -0.719em;"><span class="mn" id="MathJax-Span-37863" style="font-size: 70.7%; font-family: MathJax_Main;">2048</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(0.836em, 1001.56em, 1.225em, -999.997em); top: -1.275em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 1.558em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.058em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.53em; border-left: 0px solid; width: 0px; height: 1.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mfrac>
        <mn>
         1
        </mn>
        <mn>
         2048
        </mn>
       </mfrac>
      </math></span></span><script type="math/tex" id="MathJax-Element-5049">\frac 1 {2048}</script>的取整，是调整的<strong>单位</strong>。</li> 
   <li><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5050-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03F5;</mi></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37864" style="width: 0.503em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.392em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.558em, 1000.39em, 2.336em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37865"><span class="mi" id="MathJax-Span-37866" style="font-family: MathJax_Math-italic;">ϵ</span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 0.67em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        ϵ
       </mi>
      </math></span></span><script type="math/tex" id="MathJax-Element-5050">\epsilon</script>是<strong>调整系数</strong>，其小只能是-99。</li> 
   <li>y的取值依赖于父区块是否包含叔父区块，如果包含，则y=2，否则y=1。</li> 
   <li><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5051-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>H</mi><mi>S</mi></msub></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37867" style="width: 1.669em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.392em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.336em, 1001.39em, 2.503em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37868"><span class="msubsup" id="MathJax-Span-37869"><span style="display: inline-block; position: relative; width: 1.392em; height: 0px;"><span style="position: absolute; clip: rect(3.169em, 1000.89em, 4.169em, -999.997em); top: -3.997em; left: 0em;"><span class="mi" id="MathJax-Span-37870" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.831em; left: 0.836em;"><span class="mi" id="MathJax-Span-37871" style="font-size: 70.7%; font-family: MathJax_Math-italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.263em; border-left: 0px solid; width: 0px; height: 1.137em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <msub>
        <mi>
         H
        </mi>
        <mi>
         S
        </mi>
       </msub>
      </math></span></span><script type="math/tex" id="MathJax-Element-5051">H_S</script>是本区块的时间戳，<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5052-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>H</mi><msub><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>s</mi></mrow></msub></mrow></msub></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37872" style="width: 4.114em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.392em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.225em, 1003.39em, 2.614em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37873"><span class="mi" id="MathJax-Span-37874" style="font-family: MathJax_Math-italic;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.114em;"></span></span><span class="mo" id="MathJax-Span-37875" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-37876" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span class="msubsup" id="MathJax-Span-37877"><span style="display: inline-block; position: relative; width: 1.336em; height: 0px;"><span style="position: absolute; clip: rect(3.114em, 1000.28em, 4.447em, -999.997em); top: -3.997em; left: 0em;"><span class="mo" id="MathJax-Span-37878" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.831em; left: 0.392em;"><span class="texatom" id="MathJax-Span-37879"><span class="mrow" id="MathJax-Span-37880"><span class="msubsup" id="MathJax-Span-37881"><span style="display: inline-block; position: relative; width: 0.892em; height: 0px;"><span style="position: absolute; clip: rect(3.336em, 1000.61em, 4.169em, -999.997em); top: -3.997em; left: 0em;"><span class="mi" id="MathJax-Span-37882" style="font-size: 70.7%; font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.886em; left: 0.614em;"><span class="texatom" id="MathJax-Span-37883"><span class="mrow" id="MathJax-Span-37884"><span class="mi" id="MathJax-Span-37885" style="font-size: 50%; font-family: MathJax_Math-italic;">s</span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.397em; border-left: 0px solid; width: 0px; height: 1.337em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>
        P
       </mi>
       <mo stretchy="false">
        (
       </mo>
       <mi>
        H
       </mi>
       <msub>
        <mo stretchy="false">
         )
        </mo>
        <mrow class="MJX-TeXAtom-ORD">
         <msub>
          <mi>
           H
          </mi>
          <mrow class="MJX-TeXAtom-ORD">
           <mi>
            s
           </mi>
          </mrow>
         </msub>
        </mrow>
       </msub>
      </math></span></span><script type="math/tex" id="MathJax-Element-5052">P(H)_{H_{s}}</script>是父区块的时间戳，单位为秒，并且<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5053-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>H</mi><mi>S</mi></msub><mo>&amp;gt;</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>H</mi><msub><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>s</mi></mrow></msub></mrow></msub></math>" role="presentation">
     <nobr aria-hidden="true">
      <span class="math" id="MathJax-Span-37886" style="width: 7.336em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.114em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.225em, 1006.11em, 2.614em, -999.997em); top: -2.164em; left: 0em;"><span class="mrow" id="MathJax-Span-37887"><span class="msubsup" id="MathJax-Span-37888"><span style="display: inline-block; position: relative; width: 1.392em; height: 0px;"><span style="position: absolute; clip: rect(3.169em, 1000.89em, 4.169em, -999.997em); top: -3.997em; left: 0em;"><span class="mi" id="MathJax-Span-37889" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.831em; left: 0.836em;"><span class="mi" id="MathJax-Span-37890" style="font-size: 70.7%; font-family: MathJax_Math-italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span><span class="mo" id="MathJax-Span-37891" style="font-family: MathJax_Main; padding-left: 0.281em;">&gt;</span><span class="mi" id="MathJax-Span-37892" style="font-family: MathJax_Math-italic; padding-left: 0.281em;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.114em;"></span></span><span class="mo" id="MathJax-Span-37893" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-37894" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span class="msubsup" id="MathJax-Span-37895"><span style="display: inline-block; position: relative; width: 1.336em; height: 0px;"><span style="position: absolute; clip: rect(3.114em, 1000.28em, 4.447em, -999.997em); top: -3.997em; left: 0em;"><span class="mo" id="MathJax-Span-37896" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.831em; left: 0.392em;"><span class="texatom" id="MathJax-Span-37897"><span class="mrow" id="MathJax-Span-37898"><span class="msubsup" id="MathJax-Span-37899"><span style="display: inline-block; position: relative; width: 0.892em; height: 0px;"><span style="position: absolute; clip: rect(3.336em, 1000.61em, 4.169em, -999.997em); top: -3.997em; left: 0em;"><span class="mi" id="MathJax-Span-37900" style="font-size: 70.7%; font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.058em;"></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; top: -3.886em; left: 0.614em;"><span class="texatom" id="MathJax-Span-37901"><span class="mrow" id="MathJax-Span-37902"><span class="mi" id="MathJax-Span-37903" style="font-size: 50%; font-family: MathJax_Math-italic;">s</span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.169em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.397em; border-left: 0px solid; width: 0px; height: 1.337em;"></span></span>
     </nobr><span class="MJX_Assistive_MathML" role="presentation">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
       <msub>
        <mi>
         H
        </mi>
        <mi>
         S
        </mi>
       </msub>
       <mo>
        &gt;
       </mo>
       <mi>
        P
       </mi>
       <mo stretchy="false">
        (
       </mo>
       <mi>
        H
       </mi>
       <msub>
        <mo stretchy="false">
         )
        </mo>
        <mrow class="MJX-TeXAtom-ORD">
         <msub>
          <mi>
           H
          </mi>
          <mrow class="MJX-TeXAtom-ORD">
           <mi>
            s
           </mi>
          </mrow>
         </msub>
        </mrow>
       </msub>
      </math></span></span><script type="math/tex" id="MathJax-Element-5053">H_S>P(H)_{H_{s}}</script>。</li> 
   <li>难度降低的上界设置为−99 ，主要是应对被黑客攻击或其他目前想不到的黑天鹅事件。</li> 
  </ul> 
  <p>假设当父区块不带叔父区块的时候（y=1），调整过程如下：</p> 
  <ul> 
   <li>出块时间在[1,8]之间，出块时间过短，难度调大一个<strong>单位</strong>。</li> 
   <li>出块时间在[9,17]之间，出块时间可以接受，难度保持<strong>不变</strong>。</li> 
   <li>出块时间在[18,26]之间，出块时间过长，难度调小一个<strong>单位</strong>。</li> 
   <li>… <br> 这里发现，出块时间变长，区块的整体难度就会调小，假若有的矿工，故意将区块的时间戳改的比较晚，那么是不是就可以抢先发布区块呢？比如说将时间戳延迟写15秒，会怎么样呢？这样就会导致该矿工计算出来的难度比别的矿工计算的难度低，其他矿工15秒发布一个区块，而该矿工可以在10秒内发布区块，可以拿到区块奖励。但是问题在于假如刚好也有别的区块在10秒内发布了区块，此时根据POW的规则，另外一个矿工发布的区块难度更大，因此其他矿工会以最大工作量标准，选择15秒内挖出的区块所在的链作为主链，而该矿工发布的区块便成了叔父区块。</li> 
  </ul> 
  <p>难度炸弹计算公式如下图所示。 <br> </p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180809172523970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%">
  </center>
  <p></p> 
  <ul> 
   <li><p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5054-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03F5;</mi></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37904" style="width: 0.523em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.419em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em, 1000.42em, 2.294em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37905"><span class="mi" id="MathJax-Span-37906" style="font-family: MathJax_Math-italic;">ϵ</span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>
         ϵ
        </mi>
       </math></span></span><script type="math/tex" id="MathJax-Element-5054">\epsilon</script>是2的指数函数，每十万个块扩大一倍，后期增长非常快，这就是难度“炸弹”的由来。</p></li> 
   <li><p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5055-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>H</mi><mi>i</mi><mo>&amp;#x2032;</mo></msubsup></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37907" style="width: 1.513em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.253em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.253em, 1001.25em, 2.607em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37908"><span class="msubsup" id="MathJax-Span-37909"><span style="display: inline-block; position: relative; width: 1.253em; height: 0px;"><span style="position: absolute; clip: rect(3.18em, 1000.89em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37910" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.44em, 1000.26em, 4.117em, -999.997em); top: -4.32em; left: 0.94em;"><span class="mo" id="MathJax-Span-37911" style="font-size: 70.7%; font-family: MathJax_Main;">′</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.388em, 1000.32em, 4.169em, -999.997em); top: -3.695em; left: 0.836em;"><span class="mi" id="MathJax-Span-37912" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msubsup>
         <mi>
          H
         </mi>
         <mi>
          i
         </mi>
         <mo>
          ′
         </mo>
        </msubsup>
       </math></span></span><script type="math/tex" id="MathJax-Element-5055">H'_i</script>称为fake block number，由真正的block number <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5056-Frame" tabindex="0" style="position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>H</mi><mi>i</mi></msub></math>" role="presentation">
      <nobr aria-hidden="true">
       <span class="math" id="MathJax-Span-37913" style="width: 1.409em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.148em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.305em, 1001.15em, 2.451em, -999.997em); top: -2.133em; left: 0em;"><span class="mrow" id="MathJax-Span-37914"><span class="msubsup" id="MathJax-Span-37915"><span style="display: inline-block; position: relative; width: 1.148em; height: 0px;"><span style="position: absolute; clip: rect(3.18em, 1000.89em, 4.169em, -999.997em); top: -4.008em; left: 0em;"><span class="mi" id="MathJax-Span-37916" style="font-family: MathJax_Math-italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.055em;"></span></span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.836em;"><span class="mi" id="MathJax-Span-37917" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.138em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span>
      </nobr><span class="MJX_Assistive_MathML" role="presentation">
       <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub>
         <mi>
          H
         </mi>
         <mi>
          i
         </mi>
        </msub>
       </math></span></span><script type="math/tex" id="MathJax-Element-5056">H_i</script>减少三百万得到。之所以减少三百万，是因为目前proof of stake的工作量证明方式还存在一些问题，pos协议涉及不够完善，但是难度炸弹已经导致挖矿时间变成了30秒左右，为了减小难度，就会减去三百万。</p></li> 
  </ul> 
  <p>设置难度炸弹的原因是要降低迁移到PoS协议时发生fork的风险，假若矿工联合起来抵制POS的工作量证明模式，那就会导致以太坊产生硬分叉；有了难度炸弹，挖矿难度越来越大，矿工就有意愿迁移到PoS协议上了。难度炸弹的威力，可以通过下图看出。 <br> </p>
  <center>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018080919445716?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%">
  </center>
  <p></p> 
  <p>区块数量到370万之后，挖矿难度突然递增，到430万时，难度已经非常之大了，这时候挖矿时间已经变为为30秒，但是POS协议还没有完善，于是以太坊将挖矿难度公式进行调整，使得每次计算时，当前区块号减去三百万，这样就降低了挖矿难度，并且在这个时期，对以太坊出块奖励进行了调整，从原来的5个ETH变为3个ETH。</p> 
  <p>以太坊中难度计算公式如下图所示，由于目前处于以太坊发展的Metropolis中的Byzantium阶段，所以难度计算公式的函数名称为calcDifficultyByzantium</p> 
  <pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// calcDifficultyByzantium is the difficulty adjustment algorithm. It returns</span>
<span class="hljs-comment">// the difficulty that a new block should have when created at time given the</span>
<span class="hljs-comment">// parent block's time and difficulty. The calculation uses the Byzantium rules.</span>
<span class="hljs-keyword">func</span> calcDifficultyByzantium(time <span class="hljs-typename">uint64</span>, parent *types.Header) *big.Int {
    <span class="hljs-comment">// https://github.com/ethereum/EIPs/issues/100.</span>
    <span class="hljs-comment">// algorithm:这里给出了难度计算公式的整体注释</span>
    <span class="hljs-comment">// diff = (parent_diff +</span>
    <span class="hljs-comment">// (parent_diff / 2048 * max((2 if len(parent.uncles) else 1)</span>
    <span class="hljs-comment">// - ((timestamp - parent.timestamp) // 9), -99))) + 2^(periodCount - 2)</span>
    <span class="hljs-comment">// 获取当前时间和父区块的时间戳</span>
    bigTime := <span class="hljs-built_in">new</span>(big.Int).SetUint64(time)
    bigParentTime := <span class="hljs-built_in">new</span>(big.Int).Set(parent.Time)

    <span class="hljs-comment">// holds intermediate values to make the algo easier to read &amp; audit</span>
    x := <span class="hljs-built_in">new</span>(big.Int)
    y := <span class="hljs-built_in">new</span>(big.Int)

    <span class="hljs-comment">//这里求出当前区块时间戳和父区块的时间戳，然后求差之后除以9</span>
    <span class="hljs-comment">// (2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9</span>
    x.Sub(bigTime, bigParentTime)
    x.Div(x, big9)
    <span class="hljs-keyword">if</span> parent.UncleHash == types.EmptyUncleHash {
        x.Sub(big1, x)
    } <span class="hljs-keyword">else</span> {
        x.Sub(big2, x)
    }

    <span class="hljs-comment">// max((2 if len(parent_uncles) else 1)-(block_timestamp - parent_timestamp) // 9, -99)</span>
    <span class="hljs-keyword">if</span> x.Cmp(bigMinus99) &lt;<span class="hljs-number"> 0</span> {
        x.Set(bigMinus99)
    }
    <span class="hljs-comment">// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - </span>
    <span class="hljs-comment">//((timestamp - parent.timestamp) // 9), -99))</span>
    y.Div(parent.Difficulty, params.DifficultyBoundDivisor)
    x.Mul(y, x)
    x.Add(parent.Difficulty, x)

    <span class="hljs-comment">// minimum difficulty can ever be (before exponential factor)</span>
    <span class="hljs-comment">// MinumumDifficulty = big.NewInt(131072)</span>
    <span class="hljs-keyword">if</span> x.Cmp(params.MinimumDifficulty) &lt;<span class="hljs-number"> 0</span> {
        x.Set(params.MinimumDifficulty)
    }
    <span class="hljs-comment">// calculate a fake block number for the ice-age delay:</span>
    <span class="hljs-comment">// https://github.com/ethereum/EIPs/pull/669</span>
    <span class="hljs-comment">// fake_block_number = max(0, block.number - 3_000_000)</span>
    fakeBlockNumber := <span class="hljs-built_in">new</span>(big.Int)
    <span class="hljs-keyword">if</span> parent.Number.Cmp(big2999999) &gt;=<span class="hljs-number"> 0</span> {
        <span class="hljs-comment">// Note, parent is 1 less than the actual block number</span>
        fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) 
    }
    <span class="hljs-comment">// for the exponential factor</span>
    periodCount := fakeBlockNumber
    periodCount.Div(periodCount, expDiffPeriod)

    <span class="hljs-comment">// the exponential factor, commonly referred to as "the bomb"</span>
    <span class="hljs-comment">// diff = diff + 2^(periodCount - 2)</span>
    <span class="hljs-keyword">if</span> periodCount.Cmp(big1) &gt;<span class="hljs-number"> 0</span> {
        y.Sub(periodCount, big2)
        y.Exp(big2, y, <span class="hljs-constant">nil</span>)
        x.Add(x, y)
    }
    <span class="hljs-keyword">return</span> x
}</code></pre> 
  <p>至此，以太坊的挖矿过程和难度调整过程告一段落。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/t46414704152abc/article/details/81538361,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/t46414704152abc/article/details/81538361,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
