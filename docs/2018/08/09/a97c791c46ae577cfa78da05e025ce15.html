<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>通过构建一个区块链来学习区块链(Learn Blockchains by Building One) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="通过构建一个区块链来学习区块链(Learn Blockchains by Building One)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="通过构建一个区块链来学习区块链 最快的学习区块链的方法就是学习怎么构建区块链 你在这里的原因可能和我一样，对 加密数字货币(Cryptocurrencies) 非常感兴趣。并且你想要知道 区块链(Blockchains) 是怎么工作的—它们背后的技术 但是理解区块链不是那么简单—-或者不适合我。我在浩瀚的视频里找寻，在满目疮痍的指南里追随，还被几个破例子所挫败 我喜欢通过做来学习。这能让我集中精力去处理代码层面上的主要问题。如果你跟随我这样做，在本文的最后你将得到一个可以正常工作的区块链 开始之前 请记住区块链是不可更改的，顺序的记录链我们称为块（Blocks） 这些块可以包含了交易（transactions），文件或者其他你喜欢的数据。但是最重要的是通过哈希(hash) 把这些块链在一起，就像海上有一群毫不相关的孤岛（块）,有人通过桥（哈希）把这些岛连接在一起。 如果你不知道哈希是什么，这里有解释 本文的受众群体 你应该可以轻松阅读和编写基本的python代码，并且理解HTTP的request是怎么工作的，因为我们通过HTTP与我们的区块链交互。 你需要准备什么？ 确保python3.6+已经安装，并且你需要安装Flask和Rquests 两个库 pip install Flask==0.12.2 requests==2.18.4 对了，你还需要一个HTTP客户端，比如 Postman 或者curl 。任何可以完成相同工作的工具都可以。 哪里能找到最终代码 源代码在github上，点击这里 Step 1：建立一个区块链 打开一个你最爱的文本编辑器或者IDE,个人喜好PyCharm.创建一个新文件blockchain.py 我们只会用一个文件，如果你有点迷糊了，可以参考源代码 表示一个区块链 我们创建一个 Blockchain 类，它的构造函数的功能是创建一个空的list（来存储我们的区块链）和一个存储交易信息的list。我们类的蓝图： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们的 Blockchain类的职责就是管理这些链。这些链能存储交易并且有一些可以添加区块到链的辅助方法。让我们丰满这些方法吧 区块到底长什么样 每一个区块都有一个索引(index)，一个时间戳(timestamp)(Unix时间)，一个交易集合(transaction)，一个证明(proof)（后面会解释），还有最重要的前一个区块的哈希(hash of previous Block) 下面有一个简单的区块样子: # Example of a Block in our Blockchain block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 此时，区块链的思路就是这样：每一个新的区块都包含它自身和前一个区块的哈希。这是最重要的特性，保证了区块链的不可更改的特性：如果有攻击者破坏了早先的区块，会导致该区块的后续子链都会包含错误的哈希。 可以理解吗？如果不理解，花点时间理解这个概念，因为这是区块链的核心概念。 添加交易(transactions)到区块上 我们需要一个添加交易到区块的方式。我们的 new_transaction()方法将会帮助我们处理这个问题： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction()添加一个交易到list（current_transactions）,它返回交易被添加的那个区块的索引，也就是下一个要被挖矿的区块的索引。这将会在后面非常有用，用户通过这种方式提交交易。 创建新的区块 当我们的Blockchain 被实例化的时候，我们需要给它发送一个创世区块(genesis block)–一个没有生产者的区块。我们也需要添加一个证明(proof)到我们的创世区块中，说明这是挖矿的结果(可能这不是很好理解，就是初始化一个block，手动的，但告诉计算机这是我们挖矿的结果是有效的)。我们会在后面详细说明这个。 此外我们需要在我们的构造器里创建 创世区块，我们丰富了new_block()，new_transaction() ，hash()这些方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 上面的代码是非常直观的，我添加了一些注释让它可以更清晰。我们已经完成了区块链的整体架构。但在这里，我们必须思考区块链是怎么创建，锻造或者挖矿的 理解工作证明(Proof of Work ) 工作证明算法（Proof of Work algorithm PoW）描述了怎么在区块链上创建或者挖掘新的区块。PoW的目标就是发现一个可以解决问题的数字。从计算机角度来讲，这个数字对于整个网络上的每个人，必须很难被发现但很容易验证。这就是PoW背后的核心思想。 我们看一个简单例子来帮助理解！ 我们决定一个整数x乘上一个整数y的结果的哈希值必须0结尾。所以，hash(x*y)=ac23dc...0。为了简化说明，我们假定x=5，python实现: from hashlib import sha256 x = 5 y = 0 # 我们不知道y是多少 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1]!=&quot;0&quot;: y+=1 print(f&#39;The solution is y = {y}&#39;) this solution is y=21 ,因为此时的计算出的hash才是0结尾 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash。大体上，与我们上面这个例子差不多。这个算法就是矿工们为了创建一个新的区块，一起竞争解决这个问题(就是算一个数字)。通常来说，计算的困难度取决于字符串中搜索到字符个数。然后，矿工们通过交易得到一个币作为解决方案(solution)的奖励。 网络必须能够轻松验证这个解决方案。 基本的工作证明算法实现 让我们在我们的区块链上实现一个相似的算法。我们的规则将和上面例子很相似： 找到一个数字p ，当p与前一个区块的solution(也就是上一个hash)进行hash时，计算出的hash结果已4个0开头 import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 为了调节算法的难度，我们修改了开头数字的个数。4个开头数字是非常有效的。你会发现增加一个开头0会对找到解决方案花费的时间产生巨大的影响。 我们的类几乎快完成了，要开始准备通过HTTP请求进行交互了 Step 2:区块链API 我们将使用Python的Flask框架进行开发。这是一个微框架并且很轻易就完成endpoints到python函数的映射。这允许我们可以在网络上通过HTTP请求与我们的区块链进行交互。 我们将创建三个方法： /transactions/new来在链上创建一个新交易 /mine 告诉我们的服务器挖到了新的区块 /chain返回全部的区块链 搭建Flask 我们的“服务器”将会将会在区块链网络上形成一个单节点。让我们创建一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__)#实例化节点 # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;)#为节点创建一个随机的名字 # Instantiate the Blockchain blockchain = Blockchain()#实例化区块链类 #定义/mine的endpoint，get请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; #定义了/transactions/new，post请求，原因是我们将会发送一些数据给他 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; # 定义了/chain ，返回整个区块链 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 更多阅读Flask 交易endpoint 这就是交易请求的样子。这是用户向服务器发送的具体内容。 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 因为我们已经添加交易到区块上的类方法，剩下的工作就很简单了。让我们编写添加交易的函数吧 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖掘endpoint 我们挖矿的endpoints就是魔法发生的地方，而且非常容易。只需要做三件事: 1. 计算工作证明(PoW) 2. 奖励矿工通过添加交易给予矿工1个币 3. 通过将新的区块添加到链中来伪造(创造)新块 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 ``` **注意** 挖掘区块的接收者(recipient)是我们节点的地址。 我们在这里完成的大部分工作只是与Blockchain类中的方法进行交互。到这里，我们已经完成了区块链，可以开始与之交互了。 # Step 3：区块链交互 你可以用简单的`cURL`或者`Postman` 在网上与我们的API进行交互。 开启我们的服务： python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 我们先尝试通过GET请求挖一个矿（block）出来： `http://127.0.0.1:5000/mine`： ![Postman的GET请求](https://img-blog.csdn.net/2018022416102868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 我们用POST请求到`http://localhost:5000/transactions/new`创建一个新交易,发送内容如下（注意勾选json格式）： ![Postman Post请求](https://img-blog.csdn.net/20180224161324446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 如果您不使用Postman，那么您可以使用cURL进行等效请求： ```linux $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 我重启了服务，然后挖了两个block，总共3个（包括genesis block）。我们通过http://localhost:5000/chain检查我们完整的区块链 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1519459719.95761, &quot;transaction&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;f8c11eb5715c313053155a374e51ae1973e491d90739042c033927ce6722e26e&quot;, &quot;proof&quot;: 10682, &quot;timestamp&quot;: 1519459743.3767612, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;e8d16958b5edc364c53ff35e374ee3e27d464f052705ef362ff8c9aa9101ffce&quot;, &quot;proof&quot;: 99647, &quot;timestamp&quot;: 1519459782.6483908, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; Step 4:一致性 这个就非常酷了。我们有了一个可以接收交易并且允许挖矿的基本区块链了。但是整个区块链的观点是它们应该去中心化(decentralized) 。如果它们是去中心化的，我们怎么才能保证他们反映都是一条区块链呢？我们把这个问题称之为一致性问题，如果我们的网络有多个节点，我们就必须实现一致性算法（Consensus Algorithm） 注册新节点 在我们实现一致性算法之前，我们需要一种让节点知道网络上的相邻节点。我们在网络上的每一个节点都应该保留其他节点的注册表(Set)。因此，我们需要一些其他的endpoint： /nodes/register接收以URL形式的节点列表 /nodes/resolve 实现了我们的一致性算法，它可以解决任何冲突，确保节点具有正确的链。 我们需要修改Blockchain类的构造器，给注册节点提供一个方法: ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 注意这里我们用 set() 来持有节点列表。这是一个比较廉价的方法来确保节点的添加是幂等的，这意味着无论我们添加特定节点多少次，它都只会出现一次。 实现一致性算法 综上所述，当一个节点与另一个节点有不同的链时，就会产生冲突。为了解决这个问题，我们指定最长的有效链为权威链。换句话来说，网络上最长的链是实际上唯一链。通过这个算法，我们可以实现网络上所以节点都维护同一条链。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 第一个方法valid_chain() 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 resolve_conflicts() 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 第一个方法`valid_chain()` 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 `resolve_conflicts()` 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。**如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。** 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 ```python @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 好像没翻完= =，观众老爷对不住了 阅读更多" />
<meta property="og:description" content="通过构建一个区块链来学习区块链 最快的学习区块链的方法就是学习怎么构建区块链 你在这里的原因可能和我一样，对 加密数字货币(Cryptocurrencies) 非常感兴趣。并且你想要知道 区块链(Blockchains) 是怎么工作的—它们背后的技术 但是理解区块链不是那么简单—-或者不适合我。我在浩瀚的视频里找寻，在满目疮痍的指南里追随，还被几个破例子所挫败 我喜欢通过做来学习。这能让我集中精力去处理代码层面上的主要问题。如果你跟随我这样做，在本文的最后你将得到一个可以正常工作的区块链 开始之前 请记住区块链是不可更改的，顺序的记录链我们称为块（Blocks） 这些块可以包含了交易（transactions），文件或者其他你喜欢的数据。但是最重要的是通过哈希(hash) 把这些块链在一起，就像海上有一群毫不相关的孤岛（块）,有人通过桥（哈希）把这些岛连接在一起。 如果你不知道哈希是什么，这里有解释 本文的受众群体 你应该可以轻松阅读和编写基本的python代码，并且理解HTTP的request是怎么工作的，因为我们通过HTTP与我们的区块链交互。 你需要准备什么？ 确保python3.6+已经安装，并且你需要安装Flask和Rquests 两个库 pip install Flask==0.12.2 requests==2.18.4 对了，你还需要一个HTTP客户端，比如 Postman 或者curl 。任何可以完成相同工作的工具都可以。 哪里能找到最终代码 源代码在github上，点击这里 Step 1：建立一个区块链 打开一个你最爱的文本编辑器或者IDE,个人喜好PyCharm.创建一个新文件blockchain.py 我们只会用一个文件，如果你有点迷糊了，可以参考源代码 表示一个区块链 我们创建一个 Blockchain 类，它的构造函数的功能是创建一个空的list（来存储我们的区块链）和一个存储交易信息的list。我们类的蓝图： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们的 Blockchain类的职责就是管理这些链。这些链能存储交易并且有一些可以添加区块到链的辅助方法。让我们丰满这些方法吧 区块到底长什么样 每一个区块都有一个索引(index)，一个时间戳(timestamp)(Unix时间)，一个交易集合(transaction)，一个证明(proof)（后面会解释），还有最重要的前一个区块的哈希(hash of previous Block) 下面有一个简单的区块样子: # Example of a Block in our Blockchain block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 此时，区块链的思路就是这样：每一个新的区块都包含它自身和前一个区块的哈希。这是最重要的特性，保证了区块链的不可更改的特性：如果有攻击者破坏了早先的区块，会导致该区块的后续子链都会包含错误的哈希。 可以理解吗？如果不理解，花点时间理解这个概念，因为这是区块链的核心概念。 添加交易(transactions)到区块上 我们需要一个添加交易到区块的方式。我们的 new_transaction()方法将会帮助我们处理这个问题： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction()添加一个交易到list（current_transactions）,它返回交易被添加的那个区块的索引，也就是下一个要被挖矿的区块的索引。这将会在后面非常有用，用户通过这种方式提交交易。 创建新的区块 当我们的Blockchain 被实例化的时候，我们需要给它发送一个创世区块(genesis block)–一个没有生产者的区块。我们也需要添加一个证明(proof)到我们的创世区块中，说明这是挖矿的结果(可能这不是很好理解，就是初始化一个block，手动的，但告诉计算机这是我们挖矿的结果是有效的)。我们会在后面详细说明这个。 此外我们需要在我们的构造器里创建 创世区块，我们丰富了new_block()，new_transaction() ，hash()这些方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 上面的代码是非常直观的，我添加了一些注释让它可以更清晰。我们已经完成了区块链的整体架构。但在这里，我们必须思考区块链是怎么创建，锻造或者挖矿的 理解工作证明(Proof of Work ) 工作证明算法（Proof of Work algorithm PoW）描述了怎么在区块链上创建或者挖掘新的区块。PoW的目标就是发现一个可以解决问题的数字。从计算机角度来讲，这个数字对于整个网络上的每个人，必须很难被发现但很容易验证。这就是PoW背后的核心思想。 我们看一个简单例子来帮助理解！ 我们决定一个整数x乘上一个整数y的结果的哈希值必须0结尾。所以，hash(x*y)=ac23dc...0。为了简化说明，我们假定x=5，python实现: from hashlib import sha256 x = 5 y = 0 # 我们不知道y是多少 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1]!=&quot;0&quot;: y+=1 print(f&#39;The solution is y = {y}&#39;) this solution is y=21 ,因为此时的计算出的hash才是0结尾 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash。大体上，与我们上面这个例子差不多。这个算法就是矿工们为了创建一个新的区块，一起竞争解决这个问题(就是算一个数字)。通常来说，计算的困难度取决于字符串中搜索到字符个数。然后，矿工们通过交易得到一个币作为解决方案(solution)的奖励。 网络必须能够轻松验证这个解决方案。 基本的工作证明算法实现 让我们在我们的区块链上实现一个相似的算法。我们的规则将和上面例子很相似： 找到一个数字p ，当p与前一个区块的solution(也就是上一个hash)进行hash时，计算出的hash结果已4个0开头 import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 为了调节算法的难度，我们修改了开头数字的个数。4个开头数字是非常有效的。你会发现增加一个开头0会对找到解决方案花费的时间产生巨大的影响。 我们的类几乎快完成了，要开始准备通过HTTP请求进行交互了 Step 2:区块链API 我们将使用Python的Flask框架进行开发。这是一个微框架并且很轻易就完成endpoints到python函数的映射。这允许我们可以在网络上通过HTTP请求与我们的区块链进行交互。 我们将创建三个方法： /transactions/new来在链上创建一个新交易 /mine 告诉我们的服务器挖到了新的区块 /chain返回全部的区块链 搭建Flask 我们的“服务器”将会将会在区块链网络上形成一个单节点。让我们创建一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__)#实例化节点 # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;)#为节点创建一个随机的名字 # Instantiate the Blockchain blockchain = Blockchain()#实例化区块链类 #定义/mine的endpoint，get请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; #定义了/transactions/new，post请求，原因是我们将会发送一些数据给他 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; # 定义了/chain ，返回整个区块链 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 更多阅读Flask 交易endpoint 这就是交易请求的样子。这是用户向服务器发送的具体内容。 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 因为我们已经添加交易到区块上的类方法，剩下的工作就很简单了。让我们编写添加交易的函数吧 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖掘endpoint 我们挖矿的endpoints就是魔法发生的地方，而且非常容易。只需要做三件事: 1. 计算工作证明(PoW) 2. 奖励矿工通过添加交易给予矿工1个币 3. 通过将新的区块添加到链中来伪造(创造)新块 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 ``` **注意** 挖掘区块的接收者(recipient)是我们节点的地址。 我们在这里完成的大部分工作只是与Blockchain类中的方法进行交互。到这里，我们已经完成了区块链，可以开始与之交互了。 # Step 3：区块链交互 你可以用简单的`cURL`或者`Postman` 在网上与我们的API进行交互。 开启我们的服务： python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 我们先尝试通过GET请求挖一个矿（block）出来： `http://127.0.0.1:5000/mine`： ![Postman的GET请求](https://img-blog.csdn.net/2018022416102868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 我们用POST请求到`http://localhost:5000/transactions/new`创建一个新交易,发送内容如下（注意勾选json格式）： ![Postman Post请求](https://img-blog.csdn.net/20180224161324446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 如果您不使用Postman，那么您可以使用cURL进行等效请求： ```linux $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 我重启了服务，然后挖了两个block，总共3个（包括genesis block）。我们通过http://localhost:5000/chain检查我们完整的区块链 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1519459719.95761, &quot;transaction&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;f8c11eb5715c313053155a374e51ae1973e491d90739042c033927ce6722e26e&quot;, &quot;proof&quot;: 10682, &quot;timestamp&quot;: 1519459743.3767612, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;e8d16958b5edc364c53ff35e374ee3e27d464f052705ef362ff8c9aa9101ffce&quot;, &quot;proof&quot;: 99647, &quot;timestamp&quot;: 1519459782.6483908, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; Step 4:一致性 这个就非常酷了。我们有了一个可以接收交易并且允许挖矿的基本区块链了。但是整个区块链的观点是它们应该去中心化(decentralized) 。如果它们是去中心化的，我们怎么才能保证他们反映都是一条区块链呢？我们把这个问题称之为一致性问题，如果我们的网络有多个节点，我们就必须实现一致性算法（Consensus Algorithm） 注册新节点 在我们实现一致性算法之前，我们需要一种让节点知道网络上的相邻节点。我们在网络上的每一个节点都应该保留其他节点的注册表(Set)。因此，我们需要一些其他的endpoint： /nodes/register接收以URL形式的节点列表 /nodes/resolve 实现了我们的一致性算法，它可以解决任何冲突，确保节点具有正确的链。 我们需要修改Blockchain类的构造器，给注册节点提供一个方法: ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 注意这里我们用 set() 来持有节点列表。这是一个比较廉价的方法来确保节点的添加是幂等的，这意味着无论我们添加特定节点多少次，它都只会出现一次。 实现一致性算法 综上所述，当一个节点与另一个节点有不同的链时，就会产生冲突。为了解决这个问题，我们指定最长的有效链为权威链。换句话来说，网络上最长的链是实际上唯一链。通过这个算法，我们可以实现网络上所以节点都维护同一条链。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 第一个方法valid_chain() 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 resolve_conflicts() 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 第一个方法`valid_chain()` 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 `resolve_conflicts()` 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。**如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。** 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 ```python @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 好像没翻完= =，观众老爷对不住了 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"通过构建一个区块链来学习区块链 最快的学习区块链的方法就是学习怎么构建区块链 你在这里的原因可能和我一样，对 加密数字货币(Cryptocurrencies) 非常感兴趣。并且你想要知道 区块链(Blockchains) 是怎么工作的—它们背后的技术 但是理解区块链不是那么简单—-或者不适合我。我在浩瀚的视频里找寻，在满目疮痍的指南里追随，还被几个破例子所挫败 我喜欢通过做来学习。这能让我集中精力去处理代码层面上的主要问题。如果你跟随我这样做，在本文的最后你将得到一个可以正常工作的区块链 开始之前 请记住区块链是不可更改的，顺序的记录链我们称为块（Blocks） 这些块可以包含了交易（transactions），文件或者其他你喜欢的数据。但是最重要的是通过哈希(hash) 把这些块链在一起，就像海上有一群毫不相关的孤岛（块）,有人通过桥（哈希）把这些岛连接在一起。 如果你不知道哈希是什么，这里有解释 本文的受众群体 你应该可以轻松阅读和编写基本的python代码，并且理解HTTP的request是怎么工作的，因为我们通过HTTP与我们的区块链交互。 你需要准备什么？ 确保python3.6+已经安装，并且你需要安装Flask和Rquests 两个库 pip install Flask==0.12.2 requests==2.18.4 对了，你还需要一个HTTP客户端，比如 Postman 或者curl 。任何可以完成相同工作的工具都可以。 哪里能找到最终代码 源代码在github上，点击这里 Step 1：建立一个区块链 打开一个你最爱的文本编辑器或者IDE,个人喜好PyCharm.创建一个新文件blockchain.py 我们只会用一个文件，如果你有点迷糊了，可以参考源代码 表示一个区块链 我们创建一个 Blockchain 类，它的构造函数的功能是创建一个空的list（来存储我们的区块链）和一个存储交易信息的list。我们类的蓝图： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们的 Blockchain类的职责就是管理这些链。这些链能存储交易并且有一些可以添加区块到链的辅助方法。让我们丰满这些方法吧 区块到底长什么样 每一个区块都有一个索引(index)，一个时间戳(timestamp)(Unix时间)，一个交易集合(transaction)，一个证明(proof)（后面会解释），还有最重要的前一个区块的哈希(hash of previous Block) 下面有一个简单的区块样子: # Example of a Block in our Blockchain block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 此时，区块链的思路就是这样：每一个新的区块都包含它自身和前一个区块的哈希。这是最重要的特性，保证了区块链的不可更改的特性：如果有攻击者破坏了早先的区块，会导致该区块的后续子链都会包含错误的哈希。 可以理解吗？如果不理解，花点时间理解这个概念，因为这是区块链的核心概念。 添加交易(transactions)到区块上 我们需要一个添加交易到区块的方式。我们的 new_transaction()方法将会帮助我们处理这个问题： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction()添加一个交易到list（current_transactions）,它返回交易被添加的那个区块的索引，也就是下一个要被挖矿的区块的索引。这将会在后面非常有用，用户通过这种方式提交交易。 创建新的区块 当我们的Blockchain 被实例化的时候，我们需要给它发送一个创世区块(genesis block)–一个没有生产者的区块。我们也需要添加一个证明(proof)到我们的创世区块中，说明这是挖矿的结果(可能这不是很好理解，就是初始化一个block，手动的，但告诉计算机这是我们挖矿的结果是有效的)。我们会在后面详细说明这个。 此外我们需要在我们的构造器里创建 创世区块，我们丰富了new_block()，new_transaction() ，hash()这些方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 上面的代码是非常直观的，我添加了一些注释让它可以更清晰。我们已经完成了区块链的整体架构。但在这里，我们必须思考区块链是怎么创建，锻造或者挖矿的 理解工作证明(Proof of Work ) 工作证明算法（Proof of Work algorithm PoW）描述了怎么在区块链上创建或者挖掘新的区块。PoW的目标就是发现一个可以解决问题的数字。从计算机角度来讲，这个数字对于整个网络上的每个人，必须很难被发现但很容易验证。这就是PoW背后的核心思想。 我们看一个简单例子来帮助理解！ 我们决定一个整数x乘上一个整数y的结果的哈希值必须0结尾。所以，hash(x*y)=ac23dc...0。为了简化说明，我们假定x=5，python实现: from hashlib import sha256 x = 5 y = 0 # 我们不知道y是多少 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1]!=&quot;0&quot;: y+=1 print(f&#39;The solution is y = {y}&#39;) this solution is y=21 ,因为此时的计算出的hash才是0结尾 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash。大体上，与我们上面这个例子差不多。这个算法就是矿工们为了创建一个新的区块，一起竞争解决这个问题(就是算一个数字)。通常来说，计算的困难度取决于字符串中搜索到字符个数。然后，矿工们通过交易得到一个币作为解决方案(solution)的奖励。 网络必须能够轻松验证这个解决方案。 基本的工作证明算法实现 让我们在我们的区块链上实现一个相似的算法。我们的规则将和上面例子很相似： 找到一个数字p ，当p与前一个区块的solution(也就是上一个hash)进行hash时，计算出的hash结果已4个0开头 import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 为了调节算法的难度，我们修改了开头数字的个数。4个开头数字是非常有效的。你会发现增加一个开头0会对找到解决方案花费的时间产生巨大的影响。 我们的类几乎快完成了，要开始准备通过HTTP请求进行交互了 Step 2:区块链API 我们将使用Python的Flask框架进行开发。这是一个微框架并且很轻易就完成endpoints到python函数的映射。这允许我们可以在网络上通过HTTP请求与我们的区块链进行交互。 我们将创建三个方法： /transactions/new来在链上创建一个新交易 /mine 告诉我们的服务器挖到了新的区块 /chain返回全部的区块链 搭建Flask 我们的“服务器”将会将会在区块链网络上形成一个单节点。让我们创建一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__)#实例化节点 # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;)#为节点创建一个随机的名字 # Instantiate the Blockchain blockchain = Blockchain()#实例化区块链类 #定义/mine的endpoint，get请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; #定义了/transactions/new，post请求，原因是我们将会发送一些数据给他 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; # 定义了/chain ，返回整个区块链 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 更多阅读Flask 交易endpoint 这就是交易请求的样子。这是用户向服务器发送的具体内容。 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 因为我们已经添加交易到区块上的类方法，剩下的工作就很简单了。让我们编写添加交易的函数吧 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖掘endpoint 我们挖矿的endpoints就是魔法发生的地方，而且非常容易。只需要做三件事: 1. 计算工作证明(PoW) 2. 奖励矿工通过添加交易给予矿工1个币 3. 通过将新的区块添加到链中来伪造(创造)新块 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 ``` **注意** 挖掘区块的接收者(recipient)是我们节点的地址。 我们在这里完成的大部分工作只是与Blockchain类中的方法进行交互。到这里，我们已经完成了区块链，可以开始与之交互了。 # Step 3：区块链交互 你可以用简单的`cURL`或者`Postman` 在网上与我们的API进行交互。 开启我们的服务： python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 我们先尝试通过GET请求挖一个矿（block）出来： `http://127.0.0.1:5000/mine`： ![Postman的GET请求](https://img-blog.csdn.net/2018022416102868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 我们用POST请求到`http://localhost:5000/transactions/new`创建一个新交易,发送内容如下（注意勾选json格式）： ![Postman Post请求](https://img-blog.csdn.net/20180224161324446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 如果您不使用Postman，那么您可以使用cURL进行等效请求： ```linux $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 我重启了服务，然后挖了两个block，总共3个（包括genesis block）。我们通过http://localhost:5000/chain检查我们完整的区块链 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1519459719.95761, &quot;transaction&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;f8c11eb5715c313053155a374e51ae1973e491d90739042c033927ce6722e26e&quot;, &quot;proof&quot;: 10682, &quot;timestamp&quot;: 1519459743.3767612, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;e8d16958b5edc364c53ff35e374ee3e27d464f052705ef362ff8c9aa9101ffce&quot;, &quot;proof&quot;: 99647, &quot;timestamp&quot;: 1519459782.6483908, &quot;transaction&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;59bae469f9fd40839184460aa27a4961&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; Step 4:一致性 这个就非常酷了。我们有了一个可以接收交易并且允许挖矿的基本区块链了。但是整个区块链的观点是它们应该去中心化(decentralized) 。如果它们是去中心化的，我们怎么才能保证他们反映都是一条区块链呢？我们把这个问题称之为一致性问题，如果我们的网络有多个节点，我们就必须实现一致性算法（Consensus Algorithm） 注册新节点 在我们实现一致性算法之前，我们需要一种让节点知道网络上的相邻节点。我们在网络上的每一个节点都应该保留其他节点的注册表(Set)。因此，我们需要一些其他的endpoint： /nodes/register接收以URL形式的节点列表 /nodes/resolve 实现了我们的一致性算法，它可以解决任何冲突，确保节点具有正确的链。 我们需要修改Blockchain类的构造器，给注册节点提供一个方法: ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 注意这里我们用 set() 来持有节点列表。这是一个比较廉价的方法来确保节点的添加是幂等的，这意味着无论我们添加特定节点多少次，它都只会出现一次。 实现一致性算法 综上所述，当一个节点与另一个节点有不同的链时，就会产生冲突。为了解决这个问题，我们指定最长的有效链为权威链。换句话来说，网络上最长的链是实际上唯一链。通过这个算法，我们可以实现网络上所以节点都维护同一条链。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\\n-----------\\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False &lt;div class=&quot;se-preview-section-delimiter&quot;&gt;&lt;/div&gt; 第一个方法valid_chain() 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 resolve_conflicts() 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 第一个方法`valid_chain()` 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。 `resolve_conflicts()` 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。**如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。** 让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。 ```python @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如节点1 http://localhost:5000 和节点2 http://localhost:5001 然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 GET /nodes/resolve ，节点1的链就会被一致性算法替换掉。 好像没翻完= =，观众老爷对不住了 阅读更多","@type":"BlogPosting","url":"/2018/08/09/a97c791c46ae577cfa78da05e025ce15.html","headline":"通过构建一个区块链来学习区块链(Learn Blockchains by Building One)","dateModified":"2018-08-09T00:00:00+08:00","datePublished":"2018-08-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/09/a97c791c46ae577cfa78da05e025ce15.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>通过构建一个区块链来学习区块链(Learn Blockchains by Building One)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="通过构建一个区块链来学习区块链">通过构建一个区块链来学习区块链</h1> 
  <p>最快的学习区块链的方法就是学习怎么构建区块链 <br> <img src="https://cdn-images-1.medium.com/max/2000/1*zutLn_-fZZhy7Ari-x-JWQ.jpeg" alt="这里写图片描述" title=""> <br> 你在这里的原因可能和我一样，对 <strong>加密数字货币(Cryptocurrencies)</strong> 非常感兴趣。并且你想要知道 <strong>区块链(Blockchains)</strong> 是怎么工作的—它们背后的技术</p> 
  <p>但是理解区块链不是那么简单—-或者不适合我。我在浩瀚的视频里找寻，在满目疮痍的指南里追随，还被几个破例子所挫败</p> 
  <p>我喜欢通过做来学习。这能让我集中精力去处理代码层面上的主要问题。如果你跟随我这样做，在本文的最后你将得到一个可以正常工作的<strong>区块链</strong></p> 
  <h2 id="开始之前">开始之前</h2> 
  <p>请记住区块链是不可更改的，顺序的记录链我们称为<strong>块（Blocks）</strong> 这些块可以包含了交易（transactions），文件或者其他你喜欢的数据。但是最重要的是通过<strong>哈希(hash)</strong> 把这些块链在一起，就像海上有一群毫不相关的孤岛（块）,有人通过桥（哈希）把这些岛连接在一起。</p> 
  <p>如果你不知道哈希是什么，这里有<a href="https://learncryptography.com/hash-functions/what-are-hash-functions" rel="nofollow">解释</a></p> 
  <p><strong>本文的受众群体</strong> 你应该可以轻松阅读和编写基本的python代码，并且理解HTTP的request是怎么工作的，因为我们通过HTTP与我们的区块链交互。</p> 
  <p><strong>你需要准备什么？</strong> 确保python3.6+已经安装，并且你需要安装Flask和Rquests 两个库</p> 
  <pre class="prettyprint"><code class="language-python hljs ">pip install Flask==<span class="hljs-number">0.12</span><span class="hljs-number">.2</span> requests==<span class="hljs-number">2.18</span><span class="hljs-number">.4</span></code></pre> 
  <p>对了，你还需要一个HTTP客户端，比如 <a href="https://www.getpostman.com/" rel="nofollow">Postman</a> 或者curl 。任何可以完成相同工作的工具都可以。</p> 
  <p><strong>哪里能找到最终代码</strong> 源代码在github上，<a href="https://github.com/dvf/blockchain" rel="nofollow">点击这里</a></p> 
  <h1 id="step-1建立一个区块链">Step 1：建立一个区块链</h1> 
  <p>打开一个你最爱的文本编辑器或者IDE,个人喜好PyCharm.创建一个新文件<code>blockchain.py</code> 我们只会用一个文件，如果你有点迷糊了，可以参考<a href="https://github.com/dvf/blockchain" rel="nofollow">源代码</a></p> 
  <h3 id="表示一个区块链">表示一个区块链</h3> 
  <p>我们创建一个 <code>Blockchain</code> 类，它的构造函数的功能是创建一个空的list（来存储我们的区块链）和一个存储交易信息的list。我们类的蓝图：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.chain = []
        self.current_transactions = []

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Creates a new Block and adds it to the chain</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Adds a new transaction to the list of transactions</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span><span class="hljs-params">(block)</span>:</span>
        <span class="hljs-comment"># Hashes a Block</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-decorator">@property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Returns the last Block in the chain</span>
        <span class="hljs-keyword">pass</span></code></pre> 
  <p>我们的 <code>Blockchain</code>类的职责就是管理这些链。这些链能存储交易并且有一些可以添加区块到链的辅助方法。让我们丰满这些方法吧 </p> 
  <h3 id="区块到底长什么样">区块到底长什么样</h3> 
  <p>每一个区块都有一个索引(index)，一个时间戳(timestamp)(Unix时间)，一个交易集合(transaction)，一个证明(proof)（后面会解释），还有最重要的前一个区块的哈希(hash of previous Block)</p> 
  <p>下面有一个简单的区块样子:</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># Example of a Block in our Blockchain</span>
block = {
    <span class="hljs-string">'index'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'timestamp'</span>: <span class="hljs-number">1506057125.900785</span>,
    <span class="hljs-string">'transactions'</span>: [
        {
            <span class="hljs-string">'sender'</span>: <span class="hljs-string">"8527147fe1f5426f9dd545de4b27ee00"</span>,
            <span class="hljs-string">'recipient'</span>: <span class="hljs-string">"a77f5cdfa2934df3954a5c7c7da5df1f"</span>,
            <span class="hljs-string">'amount'</span>: <span class="hljs-number">5</span>,
        }
    ],
    <span class="hljs-string">'proof'</span>: <span class="hljs-number">324984774000</span>,
    <span class="hljs-string">'previous_hash'</span>: <span class="hljs-string">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span>
}</code></pre> 
  <p>此时，区块链的思路就是这样：每一个新的区块都包含它自身和前一个区块的哈希。这是最重要的特性，保证了区块链的不可更改的特性：如果有攻击者破坏了早先的区块，会导致该区块的后续子链都会包含错误的哈希。</p> 
  <p>可以理解吗？如果不理解，花点时间理解这个概念，因为这是区块链的核心概念。</p> 
  <h3 id="添加交易transactions到区块上">添加交易(transactions)到区块上</h3> 
  <p>我们需要一个添加交易到区块的方式。我们的 <code>new_transaction()</code>方法将会帮助我们处理这个问题：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">(self, sender, recipient, amount)</span>:</span>
        <span class="hljs-string">""" Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """</span>

        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })

        <span class="hljs-keyword">return</span> self.last_block[<span class="hljs-string">'index'</span>] + <span class="hljs-number">1</span></code></pre> 
  <p>在<code>new_transaction()</code>添加一个交易到list（current_transactions）,它返回交易被添加的那个区块的索引，也就是下一个要被挖矿的区块的索引。这将会在后面非常有用，用户通过这种方式提交交易。</p> 
  <h3 id="创建新的区块">创建新的区块</h3> 
  <p>当我们的<code>Blockchain</code> 被实例化的时候，我们需要给它发送一个<strong>创世区块(genesis block)</strong>–一个没有生产者的区块。我们也需要添加一个<strong>证明(proof)</strong>到我们的创世区块中，说明这是挖矿的结果(可能这不是很好理解，就是初始化一个block，手动的，但告诉计算机这是我们挖矿的结果是有效的)。我们会在后面详细说明这个。</p> 
  <p>此外我们需要在我们的构造器里创建 创世区块，我们丰富了<code>new_block()</code>，<code>new_transaction()</code> ，<code>hash()</code>这些方法：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.current_transactions = []
        self.chain = []

        <span class="hljs-comment"># Create the genesis block</span>
        self.new_block(previous_hash=<span class="hljs-number">1</span>, proof=<span class="hljs-number">100</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_block</span><span class="hljs-params">(self, proof, previous_hash=None)</span>:</span>
        <span class="hljs-string">""" Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block """</span>

        block = {
            <span class="hljs-string">'index'</span>: len(self.chain) + <span class="hljs-number">1</span>,
            <span class="hljs-string">'timestamp'</span>: time(),
            <span class="hljs-string">'transactions'</span>: self.current_transactions,
            <span class="hljs-string">'proof'</span>: proof,
            <span class="hljs-string">'previous_hash'</span>: previous_hash <span class="hljs-keyword">or</span> self.hash(self.chain[-<span class="hljs-number">1</span>]),
        }

        <span class="hljs-comment"># Reset the current list of transactions</span>
        self.current_transactions = []

        self.chain.append(block)
        <span class="hljs-keyword">return</span> block

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">(self, sender, recipient, amount)</span>:</span>
        <span class="hljs-string">""" Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """</span>
        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })

        <span class="hljs-keyword">return</span> self.last_block[<span class="hljs-string">'index'</span>] + <span class="hljs-number">1</span>

    <span class="hljs-decorator">@property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.chain[-<span class="hljs-number">1</span>]

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span><span class="hljs-params">(block)</span>:</span>
        <span class="hljs-string">""" Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; """</span>

        <span class="hljs-comment"># We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes</span>
        block_string = json.dumps(block, sort_keys=<span class="hljs-keyword">True</span>).encode()
        <span class="hljs-keyword">return</span> hashlib.sha256(block_string).hexdigest()</code></pre> 
  <p>上面的代码是非常直观的，我添加了一些注释让它可以更清晰。我们已经完成了区块链的整体架构。但在这里，我们必须思考区块链是怎么创建，锻造或者挖矿的</p> 
  <h3 id="理解工作证明proof-of-work">理解工作证明(Proof of Work )</h3> 
  <p>工作证明算法（Proof of Work algorithm PoW）描述了怎么在区块链上创建或者挖掘新的区块。PoW的目标就是发现一个可以解决问题的数字。从计算机角度来讲，这个数字对于整个网络上的每个人，必须很难被发现但很容易验证。这就是PoW背后的核心思想。</p> 
  <p>我们看一个简单例子来帮助理解！</p> 
  <p>我们决定一个整数x乘上一个整数y的结果的哈希值必须0结尾。所以，<code>hash(x*y)=ac23dc...0</code>。为了简化说明，我们假定<code>x=5</code>，python实现:</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256

x = <span class="hljs-number">5</span>
y = <span class="hljs-number">0</span> <span class="hljs-comment"># 我们不知道y是多少</span>

<span class="hljs-keyword">while</span> sha256(f<span class="hljs-string">'{x*y}'</span>.encode()).hexdigest()[-<span class="hljs-number">1</span>]!=<span class="hljs-string">"0"</span>:
    y+=<span class="hljs-number">1</span>
print(f<span class="hljs-string">'The solution is y = {y}'</span>)</code></pre> 
  <p>this solution is <code>y=21</code> ,因为此时的计算出的hash才是0结尾 <br> <code>hash(5 * 21) = 1253e9373e...5e3600155e860</code></p> 
  <p>在比特币中，工作证明算法被称为<strong>Hashcash</strong>。大体上，与我们上面这个例子差不多。这个算法就是矿工们为了创建一个新的区块，一起竞争解决这个问题(就是算一个数字)。通常来说，计算的困难度取决于字符串中搜索到字符个数。然后，矿工们通过交易得到一个币作为解决方案(solution)的奖励。</p> 
  <p>网络必须能够轻松验证这个解决方案。</p> 
  <h3 id="基本的工作证明算法实现">基本的工作证明算法实现</h3> 
  <p>让我们在我们的区块链上实现一个相似的算法。我们的规则将和上面例子很相似：</p> 
  <blockquote> 
   <p>找到一个数字p ，当p与前一个区块的solution(也就是上一个hash)进行hash时，计算出的hash结果已4个0开头</p> 
  </blockquote> 
  <pre class="prettyprint"><code class="language-import hashlib hljs python"><span class="hljs-keyword">import</span> json

<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proof_of_work</span><span class="hljs-params">(self, last_proof)</span>:</span>
        <span class="hljs-string">""" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; """</span>

        proof = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> self.valid_proof(last_proof, proof) <span class="hljs-keyword">is</span> <span class="hljs-keyword">False</span>:
            proof += <span class="hljs-number">1</span>

        <span class="hljs-keyword">return</span> proof

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_proof</span><span class="hljs-params">(last_proof, proof)</span>:</span>
        <span class="hljs-string">""" Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. """</span>

        guess = f<span class="hljs-string">'{last_proof}{proof}'</span>.encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        <span class="hljs-keyword">return</span> guess_hash[:<span class="hljs-number">4</span>] == <span class="hljs-string">"0000"</span>
</code></pre> 
  <p>为了调节算法的难度，我们修改了开头数字的个数。4个开头数字是非常有效的。你会发现增加一个开头0会对找到解决方案花费的时间产生巨大的影响。</p> 
  <p>我们的类几乎快完成了，要开始准备通过HTTP请求进行交互了</p> 
  <h1 id="step-2区块链api">Step 2:区块链API</h1> 
  <p>我们将使用Python的Flask框架进行开发。这是一个微框架并且很轻易就完成endpoints到python函数的映射。这允许我们可以在网络上通过HTTP请求与我们的区块链进行交互。 <br> 我们将创建三个方法：</p> 
  <ul> 
   <li><code>/transactions/new</code>来在链上创建一个新交易</li> 
   <li><code>/mine</code> 告诉我们的服务器挖到了新的区块</li> 
   <li><code>/chain</code>返回全部的区块链</li> 
  </ul> 
  <h3 id="搭建flask">搭建Flask</h3> 
  <p>我们的“服务器”将会将会在区块链网络上形成一个单节点。让我们创建一些模板代码：</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> textwrap <span class="hljs-keyword">import</span> dedent
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4

<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    ...


<span class="hljs-comment"># Instantiate our Node</span>
app = Flask(__name__)<span class="hljs-comment">#实例化节点</span>

<span class="hljs-comment"># Generate a globally unique address for this node</span>
node_identifier = str(uuid4()).replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">''</span>)<span class="hljs-comment">#为节点创建一个随机的名字</span>

<span class="hljs-comment"># Instantiate the Blockchain</span>
blockchain = Blockchain()<span class="hljs-comment">#实例化区块链类</span>

<span class="hljs-comment">#定义/mine的endpoint，get请求</span>
<span class="hljs-decorator">@app.route('/mine', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"We'll mine a new Block"</span>

<span class="hljs-comment">#定义了/transactions/new，post请求，原因是我们将会发送一些数据给他 </span>
<span class="hljs-decorator">@app.route('/transactions/new', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"We'll add a new transaction"</span>
<span class="hljs-comment"># 定义了/chain ，返回整个区块链</span>
<span class="hljs-decorator">@app.route('/chain', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">full_chain</span><span class="hljs-params">()</span>:</span>
    response = {
        <span class="hljs-string">'chain'</span>: blockchain.chain,
        <span class="hljs-string">'length'</span>: len(blockchain.chain),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, port=<span class="hljs-number">5000</span>)</code></pre> 
  <p>更多阅读<a href="http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application" rel="nofollow">Flask</a></p> 
  <h3 id="交易endpoint">交易endpoint</h3> 
  <p>这就是交易请求的样子。这是用户向服务器发送的具体内容。</p> 
  <pre class="prettyprint"><code class="language-python hljs ">{
 <span class="hljs-string">"sender"</span>: <span class="hljs-string">"my address"</span>,
 <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"someone else's address"</span>,
 <span class="hljs-string">"amount"</span>: <span class="hljs-number">5</span>
}</code></pre> 
  <p>因为我们已经添加交易到区块上的类方法，剩下的工作就很简单了。让我们编写添加交易的函数吧</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> textwrap <span class="hljs-keyword">import</span> dedent
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4

<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, request

...

<span class="hljs-decorator">@app.route('/transactions/new', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()

    <span class="hljs-comment"># Check that the required fields are in the POST'ed data</span>
    required = [<span class="hljs-string">'sender'</span>, <span class="hljs-string">'recipient'</span>, <span class="hljs-string">'amount'</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all(k <span class="hljs-keyword">in</span> values <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> required):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Missing values'</span>, <span class="hljs-number">400</span>

    <span class="hljs-comment"># Create a new Transaction</span>
    index = blockchain.new_transaction(values[<span class="hljs-string">'sender'</span>], values[<span class="hljs-string">'recipient'</span>], values[<span class="hljs-string">'amount'</span>])

    response = {<span class="hljs-string">'message'</span>: f<span class="hljs-string">'Transaction will be added to Block {index}'</span>}
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span></code></pre> 
  <h3 id="挖掘endpoint">挖掘endpoint</h3> 
  <p>我们挖矿的endpoints就是魔法发生的地方，而且非常容易。只需要做三件事: <br> 1. 计算工作证明(PoW) <br> 2. 奖励矿工通过添加交易给予矿工1个币 <br> 3. 通过将新的区块添加到链中来伪造(创造)新块</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4

<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, request

...

<span class="hljs-decorator">@app.route('/mine', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># We run the proof of work algorithm to get the next proof...</span>
    last_block = blockchain.last_block
    last_proof = last_block[<span class="hljs-string">'proof'</span>]
    proof = blockchain.proof_of_work(last_proof)

    <span class="hljs-comment"># We must receive a reward for finding the proof.</span>
    <span class="hljs-comment"># The sender is "0" to signify that this node has mined a new coin.</span>
    blockchain.new_transaction(
        sender=<span class="hljs-string">"0"</span>,
        recipient=node_identifier,
        amount=<span class="hljs-number">1</span>,
    )

    <span class="hljs-comment"># Forge the new Block by adding it to the chain</span>
    previous_hash = blockchain.hash(last_block)
    block = blockchain.new_block(proof, previous_hash)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">"New Block Forged"</span>,
        <span class="hljs-string">'index'</span>: block[<span class="hljs-string">'index'</span>],
        <span class="hljs-string">'transactions'</span>: block[<span class="hljs-string">'transactions'</span>],
        <span class="hljs-string">'proof'</span>: block[<span class="hljs-string">'proof'</span>],
        <span class="hljs-string">'previous_hash'</span>: block[<span class="hljs-string">'previous_hash'</span>],
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>
    ```

**注意** 挖掘区块的接收者(recipient)是我们节点的地址。

我们在这里完成的大部分工作只是与Blockchain类中的方法进行交互。到这里，我们已经完成了区块链，可以开始与之交互了。


<span class="hljs-comment"># Step 3：区块链交互</span>
你可以用简单的`cURL`或者`Postman` 在网上与我们的API进行交互。

开启我们的服务：</code></pre> 
  <p>python blockchain.py <br> * Running on <a href="http://127.0.0.1:5000/" rel="nofollow">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</p> 
  <pre class="prettyprint"><code class=" hljs markdown">
我们先尝试通过GET请求挖一个矿（block）出来：
<span class="hljs-code">`http://127.0.0.1:5000/mine`</span>：
![<span class="hljs-link_label">Postman的GET请求</span>](<span class="hljs-link_url">https://img-blog.csdn.net/2018022416102868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</span>)

我们用POST请求到<span class="hljs-code">`http://localhost:5000/transactions/new`</span>创建一个新交易,发送内容如下（注意勾选json格式）：
![<span class="hljs-link_label">Postman Post请求</span>](<span class="hljs-link_url">https://img-blog.csdn.net/20180224161324446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</span>)

如果您不使用Postman，那么您可以使用cURL进行等效请求：
<span class="hljs-code">```</span>linux
$ curl -X POST -H "Content-Type: application/json" -d '{
 "sender": "d4ee26eee15148ee92c6cd394edd974e",
 "recipient": "someone-other-address",
 "amount": 5
}' "http://localhost:5000/transactions/new"




<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"se-preview-section-delimiter"</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></span>
</code></pre> 
  <p>我重启了服务，然后挖了两个block，总共3个（包括genesis block）。我们通过<code>http://localhost:5000/chain</code>检查我们完整的区块链</p> 
  <pre class="prettyprint"><code class="language-python hljs ">{
    <span class="hljs-string">"chain"</span>: [
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">100</span>,
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1519459719.95761</span>,
            <span class="hljs-string">"transaction"</span>: []
        },
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">2</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"f8c11eb5715c313053155a374e51ae1973e491d90739042c033927ce6722e26e"</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">10682</span>,
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1519459743.3767612</span>,
            <span class="hljs-string">"transaction"</span>: [
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"59bae469f9fd40839184460aa27a4961"</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>
                }
            ]
        },
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">3</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"e8d16958b5edc364c53ff35e374ee3e27d464f052705ef362ff8c9aa9101ffce"</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">99647</span>,
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1519459782.6483908</span>,
            <span class="hljs-string">"transaction"</span>: [
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"59bae469f9fd40839184460aa27a4961"</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>
                }
            ]
        }
    ],
    <span class="hljs-string">"length"</span>: <span class="hljs-number">3</span>
}




&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">se</span>-<span class="hljs-title">preview</span>-<span class="hljs-title">section</span>-<span class="hljs-title">delimiter</span>"&gt;&lt;/<span class="hljs-title">div</span>&gt; </span></code></pre> 
  <h1 id="step-4一致性">Step 4:一致性</h1> 
  <p>这个就非常酷了。我们有了一个可以接收交易并且允许挖矿的基本区块链了。但是整个区块链的观点是它们应该<strong>去中心化(decentralized)</strong> 。如果它们是去中心化的，我们怎么才能保证他们反映都是一条区块链呢？我们把这个问题称之为<strong>一致性问题</strong>，如果我们的网络有多个节点，我们就必须实现一致性算法（Consensus Algorithm）</p> 
  <h3 id="注册新节点">注册新节点</h3> 
  <p>在我们实现一致性算法之前，我们需要一种让节点知道网络上的相邻节点。我们在网络上的每一个节点都应该保留其他节点的注册表(Set)。因此，我们需要一些其他的endpoint：</p> 
  <ol> 
   <li><code>/nodes/register</code>接收以URL形式的节点列表</li> 
   <li><code>/nodes/resolve</code> 实现了我们的一致性算法，它可以解决任何冲突，确保节点具有正确的链。</li> 
  </ol> 
  <p>我们需要修改Blockchain类的构造器，给注册节点提供一个方法:</p> 
  <pre class="prettyprint"><code class="language-python hljs ">...
<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse
...


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        ...
        self.nodes = set()
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_node</span><span class="hljs-params">(self, address)</span>:</span>
        <span class="hljs-string">""" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None """</span>

        parsed_url = urlparse(address)
        self.nodes.add(parsed_url.netloc)




&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">se</span>-<span class="hljs-title">preview</span>-<span class="hljs-title">section</span>-<span class="hljs-title">delimiter</span>"&gt;&lt;/<span class="hljs-title">div</span>&gt; </span></code></pre> 
  <p>注意这里我们用 <code>set()</code> 来持有节点列表。这是一个比较廉价的方法来确保节点的添加是幂等的，这意味着无论我们添加特定节点多少次，它都只会出现一次。</p> 
  <h3 id="实现一致性算法">实现一致性算法</h3> 
  <p>综上所述，当一个节点与另一个节点有不同的链时，就会产生冲突。为了解决这个问题，我们指定最长的有效链为权威链。换句话来说，网络上最长的链是实际上唯一链。通过这个算法，我们可以实现网络上所以节点都维护同一条链。</p> 
  <pre class="prettyprint"><code class="language-python hljs ">...
<span class="hljs-keyword">import</span> requests


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span> ... <span class="hljs-title">def</span> <span class="hljs-title">valid_chain</span><span class="hljs-params">(self, chain)</span>:</span>
        <span class="hljs-string">""" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not """</span>

        last_block = chain[<span class="hljs-number">0</span>]
        current_index = <span class="hljs-number">1</span>

        <span class="hljs-keyword">while</span> current_index &lt; len(chain):
            block = chain[current_index]
            print(f<span class="hljs-string">'{last_block}'</span>)
            print(f<span class="hljs-string">'{block}'</span>)
            print(<span class="hljs-string">"\n-----------\n"</span>)
            <span class="hljs-comment"># Check that the hash of the block is correct</span>
            <span class="hljs-keyword">if</span> block[<span class="hljs-string">'previous_hash'</span>] != self.hash(last_block):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

            <span class="hljs-comment"># Check that the Proof of Work is correct</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.valid_proof(last_block[<span class="hljs-string">'proof'</span>], block[<span class="hljs-string">'proof'</span>]):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

            last_block = block
            current_index += <span class="hljs-number">1</span>

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_conflicts</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">""" This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not """</span>

        neighbours = self.nodes
        new_chain = <span class="hljs-keyword">None</span>

        <span class="hljs-comment"># We're only looking for chains longer than ours</span>
        max_length = len(self.chain)

        <span class="hljs-comment"># Grab and verify the chains from all the nodes in our network</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> neighbours:
            response = requests.get(f<span class="hljs-string">'http://{node}/chain'</span>)

            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
                length = response.json()[<span class="hljs-string">'length'</span>]
                chain = response.json()[<span class="hljs-string">'chain'</span>]

                <span class="hljs-comment"># Check if the length is longer and the chain is valid</span>
                <span class="hljs-keyword">if</span> length &gt; max_length <span class="hljs-keyword">and</span> self.valid_chain(chain):
                    max_length = length
                    new_chain = chain

        <span class="hljs-comment"># Replace our chain if we discovered a new, valid chain longer than ours</span>
        <span class="hljs-keyword">if</span> new_chain:
            self.chain = new_chain
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>




&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">se</span>-<span class="hljs-title">preview</span>-<span class="hljs-title">section</span>-<span class="hljs-title">delimiter</span>"&gt;&lt;/<span class="hljs-title">div</span>&gt; </span></code></pre> 
  <p>第一个方法<code>valid_chain()</code> 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。</p> 
  <p><code>resolve_conflicts()</code> 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。<strong>如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。</strong></p> 
  <p>让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-decorator">@app.route('/nodes/register', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_nodes</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()

    nodes = values.get(<span class="hljs-string">'nodes'</span>)
    <span class="hljs-keyword">if</span> nodes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Error: Please supply a valid list of nodes"</span>, <span class="hljs-number">400</span>

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:
        blockchain.register_node(node)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New nodes have been added'</span>,
        <span class="hljs-string">'total_nodes'</span>: list(blockchain.nodes),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-decorator">@app.route('/nodes/resolve', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consensus</span><span class="hljs-params">()</span>:</span>
    replaced = blockchain.resolve_conflicts()

    <span class="hljs-keyword">if</span> replaced:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain was replaced'</span>,
            <span class="hljs-string">'new_chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">else</span>:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain is authoritative'</span>,
            <span class="hljs-string">'chain'</span>: blockchain.chain
        }

    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span></code></pre> 
  <p>到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如<code>节点1 http://localhost:5000</code> 和<code>节点2 http://localhost:5001</code> <br> <img src="https://img-blog.csdn.net/20180224212525644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="注册新节点" title=""></p> 
  <p>然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 <code>GET /nodes/resolve</code> ，节点1的链就会被一致性算法替换掉。</p> 
  <pre class="prettyprint"><code class=" hljs python">第一个方法`valid_chain()` 负责通过循环遍历每个块并验证散列和证明来检查链是否有效。

`resolve_conflicts()` 是一种循环遍历所有邻居节点的方法，下载它们的链并使用上述方法验证它们。**如果找到一个有效的链条，其长度大于我们的链条，我们将替换我们的链条。**

让我们在我们的API中注册两个endpoint，一个负责添邻近节点，另一个负责解决冲突。
```python
<span class="hljs-decorator">@app.route('/nodes/register', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_nodes</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()

    nodes = values.get(<span class="hljs-string">'nodes'</span>)
    <span class="hljs-keyword">if</span> nodes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Error: Please supply a valid list of nodes"</span>, <span class="hljs-number">400</span>

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:
        blockchain.register_node(node)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New nodes have been added'</span>,
        <span class="hljs-string">'total_nodes'</span>: list(blockchain.nodes),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-decorator">@app.route('/nodes/resolve', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consensus</span><span class="hljs-params">()</span>:</span>
    replaced = blockchain.resolve_conflicts()

    <span class="hljs-keyword">if</span> replaced:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain was replaced'</span>,
            <span class="hljs-string">'new_chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">else</span>:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain is authoritative'</span>,
            <span class="hljs-string">'chain'</span>: blockchain.chain
        }

    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span></code></pre> 
  <p>到这里我们的程序总算是写完了。我们可以开始启动我们的程序了，嗯，多个节点。在电脑的不同端口上启动该程序。比如<code>节点1 http://localhost:5000</code> 和<code>节点2 http://localhost:5001</code> <br> <img src="https://img-blog.csdn.net/20180224212525644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzY1NDUyODU5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="注册新节点" title=""></p> 
  <p>然后我在这节点2上挖了一些新的区块，确保链式最长的。然后我在节点1进行 <code>GET /nodes/resolve</code> ，节点1的链就会被一致性算法替换掉。</p> 
  <h2 id="好像没翻完-观众老爷对不住了">好像没翻完= =，观众老爷对不住了</h2> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/c654528593/article/details/79342968,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/c654528593/article/details/79342968,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
