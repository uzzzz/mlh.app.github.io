<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>从拜占庭将军问题看：区块链「 共识算法 」 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="从拜占庭将军问题看：区块链「 共识算法 」" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="假如你是古代某个国家的将军，你们国家除了你以外，还有另外9个将军，每个将军带领着一支军队，总共10支军队，这10支军队在地域上分散驻扎。你们国家想要进攻一个强大的敌国，这个敌国也有一定的实力，足以抵御你们5支军队的同时袭击。因此你们10支军队必须要成一致意见，起码要大部分军队达成一致，才可顺利的消灭掉这个敌国。 而由于地域上特殊原因，你们这10支军队不能集合在一起单点进攻，必须在分开的状态下同时包围攻击敌国。如果是单支军队单独进攻的话是毫无胜算的，除非有至少有6支军队同时调遣一起袭击才能攻下敌国。你们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向和进攻时间。 此时困扰着你们10个将军的问题是，你们没有一个中心领导，10名将军都是平等的，且你们当中可能会有叛徒，叛徒可能擅自变更进攻意向或者进攻时间，甚至是传递假的进攻消息，在这种状态下，你们10名将军们能否找到一种分布式的协作方式，来让你们能够远程、准确无误的协商，从而赢取战斗呢？ 这就是著名的「拜占庭将军问题」。 拜占庭将军问题就是要解决去中心化的共识机制问题，而这个共识问题也是比特币中区块链网络所需要解决的。 因为拜占庭将军们是分散的，没有一个中心的领导机构，因此他们在进攻敌方的时候必须事先对进攻地点和时间进行协商，达成共识。那么在有限的时间内，要解决提案（进攻方案）的一致性且获取大部分将军的认可，才能解决拜占庭将军问题。 在区块链网络中也是类似情况。 区块链的分布式网络中可能会有多个人提出打包区块的请求，并且其中还有可能是有伪造的区块，那么只能靠分布式共识算法来解决这个问题了。 我们知道区块链的核心价值之一就是共识，这也是大家一直所追捧区块链的特性之一。那今天我们就来重点来聊一聊区块链是怎样通过「共识机制」来解决上述问题的。 其实共识机制的概念并非是由区块链兴起才有的，它早在数学领域就是长期以来在研究和攻克的方向，尤其是在计算机领域针对分布式共识机制也已经有了一些知名的解决方案，取得了非常卓越的成就。 区块链算是一个将「共识机制」充分应用的一个场景。 一、什么是共识算法？ 共识算法 顾名思义，就是通过算法手段让各参与方对某个确定的结果达成一致的方案。 在区块链里，就是指在不可靠的网络环境里，在不可信的各参与方中，寻找一个传递和验证信息的可靠策略。 不过，这里的可靠也是相对而言的，非法节点必须控制在一定的比例之内才能保证可靠性。 共识算法有很多种，目前比特币所采用的是：工作量证明的共识机制。 二、区块链为什么需要共识算法？ 拿比特币举例，在比特币的区块链网络中，因为是去中心化的，每个节点都是平等的，每个节点都会有一个账本、都可以记账，那最终就会产生很多个不同的账本。 但事实上我们是需要所有人都掌握同样一个账本，才能保证系统数据的一致性，系统才能有效运行。 那如何保证在一段时间内只有允许一个节点去生成合法账本、保证大家的账本是一致的（起码大部分人的账本是一致的），如何验证合法的账本、鉴别非法账本呢？ 这些问题是在去中心化的区块链网络中必须要解决的，不然谁都可以随意篡改账本内容，然后说自己的账本才是合法的，这样的话，比特币系统就乱套了。 比特币是怎么解决这个问题的呢，它采用的是PoW（Proof of Work）的共识算法。这个算法不仅可以保证在一段时间内网络中出现的提案（提出记账请求）的个数是有限的，同时也放弃了强一致性的要求，改为最终一致性要求（即允许链中同一时刻有多个合法区块，出现链路分叉，但最后会以工作量最大的那个链路，也就是最长的那条链为最终的合法链） 除了比特币，其它一些代币的区块链网络都是使用什么样的共识算法呢？ 三、共识算法有哪些？ 共识算法比较多，有 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波），还有 分布式一致性算法（Pasox、Raft） 等等，每种算法的玩法都不一样。 这里重点来介绍一下区块链中常用的几种： PoW （Proof of Work，工作量证明） 比特币和以太坊都是基于这种算法来实现的。简单来说，PoW 就是一份确认工作端做过一定量工作的证明。PoW 系统的主要特征是计算的不对称性，工作端需要做一定难度的工作才能得出一个结果，而验证方却很容易通过结果来检查工作端是不是做了相应的工作，哈哈，这就是俗话说的 完成工作很辛苦，检查工作很容易。 在比特币系统中，大约每10分钟就开始一轮算力的竞争工作，大家将特定的字符串+随机nonce数进行SHA256运算，期望得到一个符合系统预期的值，如果算出来的结果不满足预期，则不断的调整nonce值，重新计算，一直到满足预期值为止，所以要找到预期值还是比较难的，而且没有捷径可走，必须要不停的尝试nonce值，会消耗巨大的计算量，这也就是所谓的挖矿（这里为方便理解对工作原理介绍的比较粗略，更为具体的我会在另外一篇讲区块链哈希算法的文章中介绍）。 如果某一个节点运气好，计算的结果恰好满足预期值，那么这个节点就需要告诉全网的其它节点，让其它节点来验证它的工作是否正确，别人验证起来运算量是非常简单的，所以说PoW是一种计算力不对称性的算法。如果其它节点经过快速验证没有问题，那么这个运气好的节点就拥有了记账权，可以将自己刚才打包的区块放到区块链里。 PoW的特点是： - 完全去中心化，节点自由进出 - 只要网络中非法节点的算力不超过50%，那么这种验证方法就是可靠的 - 造成大量的计算资源的浪费（因为这种寻找随机数的挖矿行为消耗GPU等算力但不产生价值） 所以PoW的优点和缺点都挺明显的，尤其是算力空耗的问题在比特币上经常被人诟病，因此以太坊的规划目标是变更为PoS算法。 PoS （Proof of Stake，权益证明） PoS算法解决了PoW的算力空耗的问题。POS叫权益证明，也可以称为股权证明，它其实是一种要求各节点提供拥有一定数量虚拟币证明的方式来竞争区块链记账权的共识机制。 在PoS模式下，记账权不再像PoW那样由谁的算力大谁就有更高的概率来记账，而是由谁的代币多，谁就越有可能获得记账权。可以想象一下， PoW类似于多劳多得，PoS类似于有钱人多得。 单纯靠代币多少来分配记账权，很有可能会导致记账权的中心化，所以有些代币系统在记账权的竞争中，除了计算谁的代币多以外，还会计算持有代币的时间长短，例如点点币。 虽然PoS很明显的解决了算力空耗的问题，且缩短了共识的达成时间。但PoS算法也可能会导致一些新的问题，比如，由于马太效应，系统的决策权和收益会越来越集中到少数人手中，失去公正。另外，在PoS系统上容易受到「分叉攻击」导致「双重支付」等问题。 因此POS算法也有了各种变化和升级，比如DPos算法。 DPoS （Delegate Proof of Stake，委托权益证明） DPos算法称为 委托权益证明或股权委托证明。它相比较于PoW与PoS，更进一步的提高了区块链的效率。 DPoS机制不需要网络中的所有节点都参与区块的创建和校验，它会不定期的选出一小群节点，让这小群节点去做区块链的创建和校验，这样对整个网络的资源消耗进一步减少了，也提高了区块链的工作效率，例如EOS。 但这一小群节点是怎么定出来的呢？其实是由大家投票选出来的，在DPoS系统下，每个token都是一个选票，充分利用了持股人的投票，以公平的方式达成共识，大家选出N个见证人（也就是N个矿池），这N个见证人权力平等，只有见证人才可以生成和管理区块。另外，持股人可以随时通过投票来更换这些见证人。 还有一些其它共识算法就不在这里一一展开了。在区块链中，由于每个项目的场景不同，所以设计的架构和采用的共识算法都不尽相同。主要还是从 去中心化、安全、性能 三要素中根据不同的应用场景，进行不同的组合。 本文原创发布于微信公众号「 bzsikao 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。 阅读更多" />
<meta property="og:description" content="假如你是古代某个国家的将军，你们国家除了你以外，还有另外9个将军，每个将军带领着一支军队，总共10支军队，这10支军队在地域上分散驻扎。你们国家想要进攻一个强大的敌国，这个敌国也有一定的实力，足以抵御你们5支军队的同时袭击。因此你们10支军队必须要成一致意见，起码要大部分军队达成一致，才可顺利的消灭掉这个敌国。 而由于地域上特殊原因，你们这10支军队不能集合在一起单点进攻，必须在分开的状态下同时包围攻击敌国。如果是单支军队单独进攻的话是毫无胜算的，除非有至少有6支军队同时调遣一起袭击才能攻下敌国。你们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向和进攻时间。 此时困扰着你们10个将军的问题是，你们没有一个中心领导，10名将军都是平等的，且你们当中可能会有叛徒，叛徒可能擅自变更进攻意向或者进攻时间，甚至是传递假的进攻消息，在这种状态下，你们10名将军们能否找到一种分布式的协作方式，来让你们能够远程、准确无误的协商，从而赢取战斗呢？ 这就是著名的「拜占庭将军问题」。 拜占庭将军问题就是要解决去中心化的共识机制问题，而这个共识问题也是比特币中区块链网络所需要解决的。 因为拜占庭将军们是分散的，没有一个中心的领导机构，因此他们在进攻敌方的时候必须事先对进攻地点和时间进行协商，达成共识。那么在有限的时间内，要解决提案（进攻方案）的一致性且获取大部分将军的认可，才能解决拜占庭将军问题。 在区块链网络中也是类似情况。 区块链的分布式网络中可能会有多个人提出打包区块的请求，并且其中还有可能是有伪造的区块，那么只能靠分布式共识算法来解决这个问题了。 我们知道区块链的核心价值之一就是共识，这也是大家一直所追捧区块链的特性之一。那今天我们就来重点来聊一聊区块链是怎样通过「共识机制」来解决上述问题的。 其实共识机制的概念并非是由区块链兴起才有的，它早在数学领域就是长期以来在研究和攻克的方向，尤其是在计算机领域针对分布式共识机制也已经有了一些知名的解决方案，取得了非常卓越的成就。 区块链算是一个将「共识机制」充分应用的一个场景。 一、什么是共识算法？ 共识算法 顾名思义，就是通过算法手段让各参与方对某个确定的结果达成一致的方案。 在区块链里，就是指在不可靠的网络环境里，在不可信的各参与方中，寻找一个传递和验证信息的可靠策略。 不过，这里的可靠也是相对而言的，非法节点必须控制在一定的比例之内才能保证可靠性。 共识算法有很多种，目前比特币所采用的是：工作量证明的共识机制。 二、区块链为什么需要共识算法？ 拿比特币举例，在比特币的区块链网络中，因为是去中心化的，每个节点都是平等的，每个节点都会有一个账本、都可以记账，那最终就会产生很多个不同的账本。 但事实上我们是需要所有人都掌握同样一个账本，才能保证系统数据的一致性，系统才能有效运行。 那如何保证在一段时间内只有允许一个节点去生成合法账本、保证大家的账本是一致的（起码大部分人的账本是一致的），如何验证合法的账本、鉴别非法账本呢？ 这些问题是在去中心化的区块链网络中必须要解决的，不然谁都可以随意篡改账本内容，然后说自己的账本才是合法的，这样的话，比特币系统就乱套了。 比特币是怎么解决这个问题的呢，它采用的是PoW（Proof of Work）的共识算法。这个算法不仅可以保证在一段时间内网络中出现的提案（提出记账请求）的个数是有限的，同时也放弃了强一致性的要求，改为最终一致性要求（即允许链中同一时刻有多个合法区块，出现链路分叉，但最后会以工作量最大的那个链路，也就是最长的那条链为最终的合法链） 除了比特币，其它一些代币的区块链网络都是使用什么样的共识算法呢？ 三、共识算法有哪些？ 共识算法比较多，有 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波），还有 分布式一致性算法（Pasox、Raft） 等等，每种算法的玩法都不一样。 这里重点来介绍一下区块链中常用的几种： PoW （Proof of Work，工作量证明） 比特币和以太坊都是基于这种算法来实现的。简单来说，PoW 就是一份确认工作端做过一定量工作的证明。PoW 系统的主要特征是计算的不对称性，工作端需要做一定难度的工作才能得出一个结果，而验证方却很容易通过结果来检查工作端是不是做了相应的工作，哈哈，这就是俗话说的 完成工作很辛苦，检查工作很容易。 在比特币系统中，大约每10分钟就开始一轮算力的竞争工作，大家将特定的字符串+随机nonce数进行SHA256运算，期望得到一个符合系统预期的值，如果算出来的结果不满足预期，则不断的调整nonce值，重新计算，一直到满足预期值为止，所以要找到预期值还是比较难的，而且没有捷径可走，必须要不停的尝试nonce值，会消耗巨大的计算量，这也就是所谓的挖矿（这里为方便理解对工作原理介绍的比较粗略，更为具体的我会在另外一篇讲区块链哈希算法的文章中介绍）。 如果某一个节点运气好，计算的结果恰好满足预期值，那么这个节点就需要告诉全网的其它节点，让其它节点来验证它的工作是否正确，别人验证起来运算量是非常简单的，所以说PoW是一种计算力不对称性的算法。如果其它节点经过快速验证没有问题，那么这个运气好的节点就拥有了记账权，可以将自己刚才打包的区块放到区块链里。 PoW的特点是： - 完全去中心化，节点自由进出 - 只要网络中非法节点的算力不超过50%，那么这种验证方法就是可靠的 - 造成大量的计算资源的浪费（因为这种寻找随机数的挖矿行为消耗GPU等算力但不产生价值） 所以PoW的优点和缺点都挺明显的，尤其是算力空耗的问题在比特币上经常被人诟病，因此以太坊的规划目标是变更为PoS算法。 PoS （Proof of Stake，权益证明） PoS算法解决了PoW的算力空耗的问题。POS叫权益证明，也可以称为股权证明，它其实是一种要求各节点提供拥有一定数量虚拟币证明的方式来竞争区块链记账权的共识机制。 在PoS模式下，记账权不再像PoW那样由谁的算力大谁就有更高的概率来记账，而是由谁的代币多，谁就越有可能获得记账权。可以想象一下， PoW类似于多劳多得，PoS类似于有钱人多得。 单纯靠代币多少来分配记账权，很有可能会导致记账权的中心化，所以有些代币系统在记账权的竞争中，除了计算谁的代币多以外，还会计算持有代币的时间长短，例如点点币。 虽然PoS很明显的解决了算力空耗的问题，且缩短了共识的达成时间。但PoS算法也可能会导致一些新的问题，比如，由于马太效应，系统的决策权和收益会越来越集中到少数人手中，失去公正。另外，在PoS系统上容易受到「分叉攻击」导致「双重支付」等问题。 因此POS算法也有了各种变化和升级，比如DPos算法。 DPoS （Delegate Proof of Stake，委托权益证明） DPos算法称为 委托权益证明或股权委托证明。它相比较于PoW与PoS，更进一步的提高了区块链的效率。 DPoS机制不需要网络中的所有节点都参与区块的创建和校验，它会不定期的选出一小群节点，让这小群节点去做区块链的创建和校验，这样对整个网络的资源消耗进一步减少了，也提高了区块链的工作效率，例如EOS。 但这一小群节点是怎么定出来的呢？其实是由大家投票选出来的，在DPoS系统下，每个token都是一个选票，充分利用了持股人的投票，以公平的方式达成共识，大家选出N个见证人（也就是N个矿池），这N个见证人权力平等，只有见证人才可以生成和管理区块。另外，持股人可以随时通过投票来更换这些见证人。 还有一些其它共识算法就不在这里一一展开了。在区块链中，由于每个项目的场景不同，所以设计的架构和采用的共识算法都不尽相同。主要还是从 去中心化、安全、性能 三要素中根据不同的应用场景，进行不同的组合。 本文原创发布于微信公众号「 bzsikao 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"假如你是古代某个国家的将军，你们国家除了你以外，还有另外9个将军，每个将军带领着一支军队，总共10支军队，这10支军队在地域上分散驻扎。你们国家想要进攻一个强大的敌国，这个敌国也有一定的实力，足以抵御你们5支军队的同时袭击。因此你们10支军队必须要成一致意见，起码要大部分军队达成一致，才可顺利的消灭掉这个敌国。 而由于地域上特殊原因，你们这10支军队不能集合在一起单点进攻，必须在分开的状态下同时包围攻击敌国。如果是单支军队单独进攻的话是毫无胜算的，除非有至少有6支军队同时调遣一起袭击才能攻下敌国。你们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向和进攻时间。 此时困扰着你们10个将军的问题是，你们没有一个中心领导，10名将军都是平等的，且你们当中可能会有叛徒，叛徒可能擅自变更进攻意向或者进攻时间，甚至是传递假的进攻消息，在这种状态下，你们10名将军们能否找到一种分布式的协作方式，来让你们能够远程、准确无误的协商，从而赢取战斗呢？ 这就是著名的「拜占庭将军问题」。 拜占庭将军问题就是要解决去中心化的共识机制问题，而这个共识问题也是比特币中区块链网络所需要解决的。 因为拜占庭将军们是分散的，没有一个中心的领导机构，因此他们在进攻敌方的时候必须事先对进攻地点和时间进行协商，达成共识。那么在有限的时间内，要解决提案（进攻方案）的一致性且获取大部分将军的认可，才能解决拜占庭将军问题。 在区块链网络中也是类似情况。 区块链的分布式网络中可能会有多个人提出打包区块的请求，并且其中还有可能是有伪造的区块，那么只能靠分布式共识算法来解决这个问题了。 我们知道区块链的核心价值之一就是共识，这也是大家一直所追捧区块链的特性之一。那今天我们就来重点来聊一聊区块链是怎样通过「共识机制」来解决上述问题的。 其实共识机制的概念并非是由区块链兴起才有的，它早在数学领域就是长期以来在研究和攻克的方向，尤其是在计算机领域针对分布式共识机制也已经有了一些知名的解决方案，取得了非常卓越的成就。 区块链算是一个将「共识机制」充分应用的一个场景。 一、什么是共识算法？ 共识算法 顾名思义，就是通过算法手段让各参与方对某个确定的结果达成一致的方案。 在区块链里，就是指在不可靠的网络环境里，在不可信的各参与方中，寻找一个传递和验证信息的可靠策略。 不过，这里的可靠也是相对而言的，非法节点必须控制在一定的比例之内才能保证可靠性。 共识算法有很多种，目前比特币所采用的是：工作量证明的共识机制。 二、区块链为什么需要共识算法？ 拿比特币举例，在比特币的区块链网络中，因为是去中心化的，每个节点都是平等的，每个节点都会有一个账本、都可以记账，那最终就会产生很多个不同的账本。 但事实上我们是需要所有人都掌握同样一个账本，才能保证系统数据的一致性，系统才能有效运行。 那如何保证在一段时间内只有允许一个节点去生成合法账本、保证大家的账本是一致的（起码大部分人的账本是一致的），如何验证合法的账本、鉴别非法账本呢？ 这些问题是在去中心化的区块链网络中必须要解决的，不然谁都可以随意篡改账本内容，然后说自己的账本才是合法的，这样的话，比特币系统就乱套了。 比特币是怎么解决这个问题的呢，它采用的是PoW（Proof of Work）的共识算法。这个算法不仅可以保证在一段时间内网络中出现的提案（提出记账请求）的个数是有限的，同时也放弃了强一致性的要求，改为最终一致性要求（即允许链中同一时刻有多个合法区块，出现链路分叉，但最后会以工作量最大的那个链路，也就是最长的那条链为最终的合法链） 除了比特币，其它一些代币的区块链网络都是使用什么样的共识算法呢？ 三、共识算法有哪些？ 共识算法比较多，有 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波），还有 分布式一致性算法（Pasox、Raft） 等等，每种算法的玩法都不一样。 这里重点来介绍一下区块链中常用的几种： PoW （Proof of Work，工作量证明） 比特币和以太坊都是基于这种算法来实现的。简单来说，PoW 就是一份确认工作端做过一定量工作的证明。PoW 系统的主要特征是计算的不对称性，工作端需要做一定难度的工作才能得出一个结果，而验证方却很容易通过结果来检查工作端是不是做了相应的工作，哈哈，这就是俗话说的 完成工作很辛苦，检查工作很容易。 在比特币系统中，大约每10分钟就开始一轮算力的竞争工作，大家将特定的字符串+随机nonce数进行SHA256运算，期望得到一个符合系统预期的值，如果算出来的结果不满足预期，则不断的调整nonce值，重新计算，一直到满足预期值为止，所以要找到预期值还是比较难的，而且没有捷径可走，必须要不停的尝试nonce值，会消耗巨大的计算量，这也就是所谓的挖矿（这里为方便理解对工作原理介绍的比较粗略，更为具体的我会在另外一篇讲区块链哈希算法的文章中介绍）。 如果某一个节点运气好，计算的结果恰好满足预期值，那么这个节点就需要告诉全网的其它节点，让其它节点来验证它的工作是否正确，别人验证起来运算量是非常简单的，所以说PoW是一种计算力不对称性的算法。如果其它节点经过快速验证没有问题，那么这个运气好的节点就拥有了记账权，可以将自己刚才打包的区块放到区块链里。 PoW的特点是： - 完全去中心化，节点自由进出 - 只要网络中非法节点的算力不超过50%，那么这种验证方法就是可靠的 - 造成大量的计算资源的浪费（因为这种寻找随机数的挖矿行为消耗GPU等算力但不产生价值） 所以PoW的优点和缺点都挺明显的，尤其是算力空耗的问题在比特币上经常被人诟病，因此以太坊的规划目标是变更为PoS算法。 PoS （Proof of Stake，权益证明） PoS算法解决了PoW的算力空耗的问题。POS叫权益证明，也可以称为股权证明，它其实是一种要求各节点提供拥有一定数量虚拟币证明的方式来竞争区块链记账权的共识机制。 在PoS模式下，记账权不再像PoW那样由谁的算力大谁就有更高的概率来记账，而是由谁的代币多，谁就越有可能获得记账权。可以想象一下， PoW类似于多劳多得，PoS类似于有钱人多得。 单纯靠代币多少来分配记账权，很有可能会导致记账权的中心化，所以有些代币系统在记账权的竞争中，除了计算谁的代币多以外，还会计算持有代币的时间长短，例如点点币。 虽然PoS很明显的解决了算力空耗的问题，且缩短了共识的达成时间。但PoS算法也可能会导致一些新的问题，比如，由于马太效应，系统的决策权和收益会越来越集中到少数人手中，失去公正。另外，在PoS系统上容易受到「分叉攻击」导致「双重支付」等问题。 因此POS算法也有了各种变化和升级，比如DPos算法。 DPoS （Delegate Proof of Stake，委托权益证明） DPos算法称为 委托权益证明或股权委托证明。它相比较于PoW与PoS，更进一步的提高了区块链的效率。 DPoS机制不需要网络中的所有节点都参与区块的创建和校验，它会不定期的选出一小群节点，让这小群节点去做区块链的创建和校验，这样对整个网络的资源消耗进一步减少了，也提高了区块链的工作效率，例如EOS。 但这一小群节点是怎么定出来的呢？其实是由大家投票选出来的，在DPoS系统下，每个token都是一个选票，充分利用了持股人的投票，以公平的方式达成共识，大家选出N个见证人（也就是N个矿池），这N个见证人权力平等，只有见证人才可以生成和管理区块。另外，持股人可以随时通过投票来更换这些见证人。 还有一些其它共识算法就不在这里一一展开了。在区块链中，由于每个项目的场景不同，所以设计的架构和采用的共识算法都不尽相同。主要还是从 去中心化、安全、性能 三要素中根据不同的应用场景，进行不同的组合。 本文原创发布于微信公众号「 bzsikao 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。 阅读更多","@type":"BlogPosting","url":"/2018/08/07/e9690c7ee1d0105799c0ca4d54513b13.html","headline":"从拜占庭将军问题看：区块链「 共识算法 」","dateModified":"2018-08-07T00:00:00+08:00","datePublished":"2018-08-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/07/e9690c7ee1d0105799c0ca4d54513b13.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>从拜占庭将军问题看：区块链「 共识算法 」</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807113554439?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzandr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>假如你是古代某个国家的将军，你们国家除了你以外，还有另外9个将军，每个将军带领着一支军队，总共10支军队，这10支军队在地域上分散驻扎。你们国家想要进攻一个强大的敌国，这个敌国也有一定的实力，足以抵御你们5支军队的同时袭击。因此你们10支军队必须要成一致意见，起码要大部分军队达成一致，才可顺利的消灭掉这个敌国。</p> 
  <p>而由于地域上特殊原因，你们这10支军队不能集合在一起单点进攻，必须在分开的状态下同时包围攻击敌国。如果是单支军队单独进攻的话是毫无胜算的，除非有至少有6支军队同时调遣一起袭击才能攻下敌国。你们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向和进攻时间。</p> 
  <p>此时困扰着你们10个将军的问题是，你们没有一个中心领导，10名将军都是平等的，且你们当中可能会有叛徒，叛徒可能擅自变更进攻意向或者进攻时间，甚至是传递假的进攻消息，在这种状态下，你们10名将军们能否找到一种分布式的协作方式，来让你们能够远程、准确无误的协商，从而赢取战斗呢？</p> 
  <p>这就是著名的「拜占庭将军问题」。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807113604152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzandr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><strong>拜占庭将军问题就是要解决去中心化的共识机制问题，而这个共识问题也是比特币中区块链网络所需要解决的。</strong></p> 
  <p>因为拜占庭将军们是分散的，没有一个中心的领导机构，因此他们在进攻敌方的时候必须事先对进攻地点和时间进行协商，达成共识。那么在有限的时间内，要解决提案（进攻方案）的一致性且获取大部分将军的认可，才能解决拜占庭将军问题。</p> 
  <p>在区块链网络中也是类似情况。</p> 
  <p>区块链的分布式网络中可能会有多个人提出打包区块的请求，并且其中还有可能是有伪造的区块，那么只能靠分布式共识算法来解决这个问题了。</p> 
  <p>我们知道区块链的核心价值之一就是共识，这也是大家一直所追捧区块链的特性之一。那今天我们就来重点来聊一聊区块链是怎样通过「共识机制」来解决上述问题的。</p> 
  <p>其实共识机制的概念并非是由区块链兴起才有的，它早在数学领域就是长期以来在研究和攻克的方向，尤其是在计算机领域针对分布式共识机制也已经有了一些知名的解决方案，取得了非常卓越的成就。</p> 
  <p>区块链算是一个将「共识机制」充分应用的一个场景。</p> 
  <h4 id="一什么是共识算法">一、什么是共识算法？</h4> 
  <p>共识算法 顾名思义，就是通过算法手段让各参与方对某个确定的结果达成一致的方案。 <br> 在区块链里，就是指在不可靠的网络环境里，在不可信的各参与方中，寻找一个传递和验证信息的可靠策略。</p> 
  <p>不过，这里的可靠也是相对而言的，非法节点必须控制在一定的比例之内才能保证可靠性。 <br> 共识算法有很多种，目前比特币所采用的是：工作量证明的共识机制。</p> 
  <h4 id="二区块链为什么需要共识算法">二、区块链为什么需要共识算法？</h4> 
  <p>拿比特币举例，在比特币的区块链网络中，因为是去中心化的，每个节点都是平等的，每个节点都会有一个账本、都可以记账，那最终就会产生很多个不同的账本。</p> 
  <p>但事实上我们是需要所有人都掌握同样一个账本，才能保证系统数据的一致性，系统才能有效运行。</p> 
  <p>那如何保证在一段时间内只有允许一个节点去生成合法账本、保证大家的账本是一致的（起码大部分人的账本是一致的），如何验证合法的账本、鉴别非法账本呢？</p> 
  <p>这些问题是在去中心化的区块链网络中必须要解决的，不然谁都可以随意篡改账本内容，然后说自己的账本才是合法的，这样的话，比特币系统就乱套了。</p> 
  <p>比特币是怎么解决这个问题的呢，它采用的是PoW（Proof of Work）的共识算法。这个算法不仅可以保证在一段时间内网络中出现的提案（提出记账请求）的个数是有限的，同时也放弃了强一致性的要求，改为最终一致性要求（即允许链中同一时刻有多个合法区块，出现链路分叉，但最后会以工作量最大的那个链路，也就是最长的那条链为最终的合法链）</p> 
  <p>除了比特币，其它一些代币的区块链网络都是使用什么样的共识算法呢？</p> 
  <h4 id="三共识算法有哪些">三、共识算法有哪些？</h4> 
  <p>共识算法比较多，有 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波），还有 分布式一致性算法（Pasox、Raft） 等等，每种算法的玩法都不一样。</p> 
  <p>这里重点来介绍一下区块链中常用的几种：</p> 
  <ol> 
   <li><strong>PoW （Proof of Work，工作量证明）</strong> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807113615169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzandr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></li> 
  </ol> 
  <p>比特币和以太坊都是基于这种算法来实现的。简单来说，PoW 就是一份确认工作端做过一定量工作的证明。PoW 系统的主要特征是计算的不对称性，工作端需要做一定难度的工作才能得出一个结果，而验证方却很容易通过结果来检查工作端是不是做了相应的工作，哈哈，这就是俗话说的 完成工作很辛苦，检查工作很容易。</p> 
  <p>在比特币系统中，大约每10分钟就开始一轮算力的竞争工作，大家将特定的字符串+随机nonce数进行SHA256运算，期望得到一个符合系统预期的值，如果算出来的结果不满足预期，则不断的调整nonce值，重新计算，一直到满足预期值为止，所以要找到预期值还是比较难的，而且没有捷径可走，必须要不停的尝试nonce值，会消耗巨大的计算量，这也就是所谓的挖矿（这里为方便理解对工作原理介绍的比较粗略，更为具体的我会在另外一篇讲区块链哈希算法的文章中介绍）。</p> 
  <p>如果某一个节点运气好，计算的结果恰好满足预期值，那么这个节点就需要告诉全网的其它节点，让其它节点来验证它的工作是否正确，别人验证起来运算量是非常简单的，所以说PoW是一种计算力不对称性的算法。如果其它节点经过快速验证没有问题，那么这个运气好的节点就拥有了记账权，可以将自己刚才打包的区块放到区块链里。</p> 
  <p>PoW的特点是： <br> - 完全去中心化，节点自由进出 <br> - 只要网络中非法节点的算力不超过50%，那么这种验证方法就是可靠的 <br> - 造成大量的计算资源的浪费（因为这种寻找随机数的挖矿行为消耗GPU等算力但不产生价值）</p> 
  <p>所以PoW的优点和缺点都挺明显的，尤其是算力空耗的问题在比特币上经常被人诟病，因此以太坊的规划目标是变更为PoS算法。</p> 
  <ol> 
   <li><strong>PoS （Proof of Stake，权益证明）</strong> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807113623982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzandr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></li> 
  </ol> 
  <p>PoS算法解决了PoW的算力空耗的问题。POS叫权益证明，也可以称为股权证明，它其实是一种要求各节点提供拥有一定数量虚拟币证明的方式来竞争区块链记账权的共识机制。</p> 
  <p>在PoS模式下，记账权不再像PoW那样由谁的算力大谁就有更高的概率来记账，而是由谁的代币多，谁就越有可能获得记账权。可以想象一下， PoW类似于多劳多得，PoS类似于有钱人多得。</p> 
  <p>单纯靠代币多少来分配记账权，很有可能会导致记账权的中心化，所以有些代币系统在记账权的竞争中，除了计算谁的代币多以外，还会计算持有代币的时间长短，例如点点币。</p> 
  <p>虽然PoS很明显的解决了算力空耗的问题，且缩短了共识的达成时间。但PoS算法也可能会导致一些新的问题，比如，由于马太效应，系统的决策权和收益会越来越集中到少数人手中，失去公正。另外，在PoS系统上容易受到「分叉攻击」导致「双重支付」等问题。</p> 
  <p>因此POS算法也有了各种变化和升级，比如DPos算法。</p> 
  <ol> 
   <li><strong>DPoS （Delegate Proof of Stake，委托权益证明）</strong></li> 
  </ol> 
  <p>DPos算法称为 委托权益证明或股权委托证明。它相比较于PoW与PoS，更进一步的提高了区块链的效率。</p> 
  <p>DPoS机制不需要网络中的所有节点都参与区块的创建和校验，它会不定期的选出一小群节点，让这小群节点去做区块链的创建和校验，这样对整个网络的资源消耗进一步减少了，也提高了区块链的工作效率，例如EOS。</p> 
  <p>但这一小群节点是怎么定出来的呢？其实是由大家投票选出来的，在DPoS系统下，每个token都是一个选票，充分利用了持股人的投票，以公平的方式达成共识，大家选出N个见证人（也就是N个矿池），这N个见证人权力平等，只有见证人才可以生成和管理区块。另外，持股人可以随时通过投票来更换这些见证人。</p> 
  <p>还有一些其它共识算法就不在这里一一展开了。在区块链中，由于每个项目的场景不同，所以设计的架构和采用的共识算法都不尽相同。主要还是从 去中心化、安全、性能 三要素中根据不同的应用场景，进行不同的组合。</p> 
  <blockquote> 
   <p>本文原创发布于微信公众号「 bzsikao 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807113756468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzandr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  </blockquote> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jsjwk/article/details/81478572,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jsjwk/article/details/81478572,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
