<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS合约开发第七章-EOS合约简介 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS合约开发第七章-EOS合约简介" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="EOS合约简介 一、语言 &nbsp; 基于EOSIO的块链使用的是WebAssembly (WASM)来执行用户编写的智能合约。WASM是一种新兴的Web标准，广泛支持于谷歌、微软、苹果等。对编写WASM标准的智能合约来说使用clang/llvm和它的C/C++编译器是目前最为成熟的编译工具链。 其他的第三方工具链在开发中，包括：Rust, Python, and Solidity。虽然这些语言可能看起来相对简单，但它们可能会影响您所编写的智能性能。我们认为，对于开发高性能和安全的智能合约，C++是最好的语言，将来eos的智能合约也还会继续支持C++。 Linux / Mac OS Experience EOSIO 支持下面的操作系统: - Amazon 2017.09 and higher - Centos 7 - Fedora 25 and higher (Fedora 27 推荐使用) - Mint 18 - Ubuntu 16.04 (Ubuntu 16.10 推荐使用) - MacOS Darwin 10.12 and higher (MacOS 10.13.x 推荐使用) 二、Action vs Transaction &nbsp; Action表示单个操作，而transaction是一个或多个action的集合。Action是合约和账户之间进行通信的方式。Action可以单独执行，或者组合组合起来作为一个整体执行。 仅有一个action的transaction. &nbsp; { &nbsp; &quot;expiration&quot;: &quot;2018-04-01T15:20:44&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: 42580, &nbsp; &quot;ref_block_prefix&quot;: 3987474256, &nbsp; &quot;net_usage_words&quot;: 21, &nbsp; &quot;kcpu_usage&quot;: 1000, &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;eosio.token&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;issue&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;eosio&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;active&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] } 包含多个action的transaction, 这些action要么全部成功要么全部失败. { &nbsp; &quot;expiration&quot;: &quot;...&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: ..., &nbsp; &quot;ref_block_prefix&quot;: ..., &nbsp; &quot;net_usage_words&quot;: .., &nbsp; &quot;kcpu_usage&quot;: .., &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; }, { &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] &nbsp; } 三、智能合约文件 &nbsp; 从简单易用的角度出发，我们编写了一个工具eosiocpp ，它可以创建一个新的智能合约。eosiocpp也可以创建3个合约文件，它们仅仅包含了合约的框架。 $ eosiocpp -n ${contract} 上面的命令会在./${project}目录下创建一个空的项目，它包含3个文件 ${contract}.abi ${contract}.hpp ${contract}.cpp &nbsp; hpp &nbsp; ${contract}.hpp 这是合约的头文件，可以包含一些变量，常量和函数的声明。 cpp The ${contract}.cpp 这是合约的源码文件，包含合约的具体实现。 如果你用eosiocpp生成了一个 .cpp， 那它的内容大概类似如下: #include &lt;${contract}.hpp&gt; &nbsp; /** &nbsp;*&nbsp; The init() and apply() methods must have C calling convention so that the blockchain can lookup and &nbsp;*&nbsp; call these methods. &nbsp;*/ extern &quot;C&quot; { &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp;*&nbsp; This method is called once when the contract is published or updated. &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; void init()&nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Init World!\n&quot; ); // Replace with actual code &nbsp; &nbsp; } &nbsp; &nbsp; /// The apply method implements the dispatch of actions to this contract &nbsp; &nbsp; void apply( uint64_t code, uint64_t action ) { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Hello World: &quot;, eosio::name(code), &quot;-&gt;&quot;, eosio::name(action), &quot;\n&quot; ); &nbsp; &nbsp; } } // extern &quot;C&quot; 在这个例子里，我们可以看到两个函数，init和apply。它们会打印log并且不做任何检查。任何人都可以在任何时刻执行BP允许的所有action。在不需要任何签名的情况下，合约将被计入带宽消耗。（Absent any required signatures, the contract will be billed for the bandwidth consumed.） init init 仅当合约第一次被部署的时候执行。 在这个函数里可以初始化变量, 比如，在currency合约中总体的token的供应量。 apply apply 是一个中转函数, 他监听所有传入的action，并且根据action调用合约相应的函数。apply函数需要两个参数， code 和 action。 code filter 这个参数是为了对action做出回应，比如下面的apply函数，你可以构造一个通用响应去忽略code。 （In order to respond to a particular action, structure the apply function as follows. You may also construct a response to general actions by omitting the code filter.） if (code == N(${contract_name}) { &nbsp; &nbsp; // your handler to respond to particular action } 当然你也可以为每个action构造各自的一个响应。 action filter 为了响应每一个action，比如构造比如下面的apply函数。通常和code filter一起使用 if (action == N(${action_name}) { &nbsp; &nbsp; //your handler to respond to a particular action } wast 任何合约程序想要部署到EOSIO的区块链网络中都必须编译成WASM格式。这是EOS的支持唯一个的格式。 一旦你的CPP文件写好了，有就可以用eosiocpp把它编译成WASM (.wast)文件了 $ eosiocpp -o ${contract}.wast ${contract}.cpp abi ABI（ Application Binary Interface）文件是一个JSON格式的描述文件，说明了如何在他们的JSON和二进制之间转化用户的action。ABI文件也同时说明了如何转换数据库的状态。一旦你用了ABI描述了你的合约，开发人员就和用户就可以和你的合约通过JSON进行交互。 ABI可以通过.hpp文件用eosiocpp生成。 $ eosiocpp -g ${contract}.abi ${contract}.hpp 下面这个例子展示了一个ABI文件的框架： { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;balance&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;action&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;transfer&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;tables&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;table&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;index_type&quot;: &quot;i64&quot;, &nbsp; &nbsp; &nbsp; &quot;key_names&quot; : [&quot;account&quot;], &nbsp; &nbsp; &nbsp; &quot;key_types&quot; : [&quot;name&quot;] &nbsp; &nbsp; } &nbsp; ] } 你会注意到这个ABI定义了一个actoin名字是transfer，类型是transfer。这就是告诉EOSIO，当调用的action是transfer时，它的格式是transfer，定义如下： ... &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ ... &nbsp; ABI文件有很多的部分组成，比如from,to和quantity。每个部分都有自己的类型，比如account_name和uint64。account_name是一个内建类型用base32字符串表示为uint64。想要看到更多的内建类型可以点击这里 &nbsp; { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], ... &nbsp; 在上面types 数组里，我们为已经存在的account_name类型定义了一个别名name 。 四、调试智能合约 为了能够调试智能合约，你需要在你的本地环境中启动一个nodeos。这个本地的nodeos可以是一个EOS私有的测试网络或者是公网的测试网络。 当你第一次创建智能合约的时候，推荐你最好在你自己的私有测试网络中调试好，因为你对你自己的私有测试网络有完全的掌控权。这可以让你无限制的使用EOS（币）也可以随时复位它的状态。当合约调试完毕，就可以部署到公共测试网络了，本地先运行一个连接到公共测试网络的nodeos，然后连接到这个节点就可以获得log输出了。 步骤是一样的，所以下面这个手册也适用于私有测试网络中的测试。 如果你还没有一个本地的nodeos环境，可以参考这个连接。默认情况下，你的本地nodes会运行在一个私有网络中，除非你修改了config.ini文件，让他去连接公共测试网络，如何修改可以参考这里。 方法 调试最主要的方法就是用Caveman Debugging，我们增强了printing的功能，他可以去输出变量的值并且检查合约的流程。Printing可以通过下面API被合约使用： 这是c 这是 C++). C++的API是对C的封装，所以大多数我们使用C++的API。 Print Print C API 支持如下数据类型： - prints - a null terminated char array (string) - prints_l - any char array (string) with given size - printi - 64-bit unsigned integer - printi128 - 128-bit unsigned integer - printd - double encoded as 64-bit unsigned integer - printn - base32 string encoded as 64-bit unsigned integer - printhex - hex given binary of data and its size 同时 Print C++ API 对上面的C API进行了封装，所以用户不需要指定应该使用哪种类型的Print。Print C++ API 支持 - a null terminated char array (string) - integer (128-bit unsigned, 64-bit unsigned, 32-bit unsigned, signed, unsigned) - base32 string encoded as 64-bit unsigned integer - struct that has print() method 阅读更多" />
<meta property="og:description" content="EOS合约简介 一、语言 &nbsp; 基于EOSIO的块链使用的是WebAssembly (WASM)来执行用户编写的智能合约。WASM是一种新兴的Web标准，广泛支持于谷歌、微软、苹果等。对编写WASM标准的智能合约来说使用clang/llvm和它的C/C++编译器是目前最为成熟的编译工具链。 其他的第三方工具链在开发中，包括：Rust, Python, and Solidity。虽然这些语言可能看起来相对简单，但它们可能会影响您所编写的智能性能。我们认为，对于开发高性能和安全的智能合约，C++是最好的语言，将来eos的智能合约也还会继续支持C++。 Linux / Mac OS Experience EOSIO 支持下面的操作系统: - Amazon 2017.09 and higher - Centos 7 - Fedora 25 and higher (Fedora 27 推荐使用) - Mint 18 - Ubuntu 16.04 (Ubuntu 16.10 推荐使用) - MacOS Darwin 10.12 and higher (MacOS 10.13.x 推荐使用) 二、Action vs Transaction &nbsp; Action表示单个操作，而transaction是一个或多个action的集合。Action是合约和账户之间进行通信的方式。Action可以单独执行，或者组合组合起来作为一个整体执行。 仅有一个action的transaction. &nbsp; { &nbsp; &quot;expiration&quot;: &quot;2018-04-01T15:20:44&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: 42580, &nbsp; &quot;ref_block_prefix&quot;: 3987474256, &nbsp; &quot;net_usage_words&quot;: 21, &nbsp; &quot;kcpu_usage&quot;: 1000, &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;eosio.token&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;issue&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;eosio&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;active&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] } 包含多个action的transaction, 这些action要么全部成功要么全部失败. { &nbsp; &quot;expiration&quot;: &quot;...&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: ..., &nbsp; &quot;ref_block_prefix&quot;: ..., &nbsp; &quot;net_usage_words&quot;: .., &nbsp; &quot;kcpu_usage&quot;: .., &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; }, { &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] &nbsp; } 三、智能合约文件 &nbsp; 从简单易用的角度出发，我们编写了一个工具eosiocpp ，它可以创建一个新的智能合约。eosiocpp也可以创建3个合约文件，它们仅仅包含了合约的框架。 $ eosiocpp -n ${contract} 上面的命令会在./${project}目录下创建一个空的项目，它包含3个文件 ${contract}.abi ${contract}.hpp ${contract}.cpp &nbsp; hpp &nbsp; ${contract}.hpp 这是合约的头文件，可以包含一些变量，常量和函数的声明。 cpp The ${contract}.cpp 这是合约的源码文件，包含合约的具体实现。 如果你用eosiocpp生成了一个 .cpp， 那它的内容大概类似如下: #include &lt;${contract}.hpp&gt; &nbsp; /** &nbsp;*&nbsp; The init() and apply() methods must have C calling convention so that the blockchain can lookup and &nbsp;*&nbsp; call these methods. &nbsp;*/ extern &quot;C&quot; { &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp;*&nbsp; This method is called once when the contract is published or updated. &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; void init()&nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Init World!\n&quot; ); // Replace with actual code &nbsp; &nbsp; } &nbsp; &nbsp; /// The apply method implements the dispatch of actions to this contract &nbsp; &nbsp; void apply( uint64_t code, uint64_t action ) { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Hello World: &quot;, eosio::name(code), &quot;-&gt;&quot;, eosio::name(action), &quot;\n&quot; ); &nbsp; &nbsp; } } // extern &quot;C&quot; 在这个例子里，我们可以看到两个函数，init和apply。它们会打印log并且不做任何检查。任何人都可以在任何时刻执行BP允许的所有action。在不需要任何签名的情况下，合约将被计入带宽消耗。（Absent any required signatures, the contract will be billed for the bandwidth consumed.） init init 仅当合约第一次被部署的时候执行。 在这个函数里可以初始化变量, 比如，在currency合约中总体的token的供应量。 apply apply 是一个中转函数, 他监听所有传入的action，并且根据action调用合约相应的函数。apply函数需要两个参数， code 和 action。 code filter 这个参数是为了对action做出回应，比如下面的apply函数，你可以构造一个通用响应去忽略code。 （In order to respond to a particular action, structure the apply function as follows. You may also construct a response to general actions by omitting the code filter.） if (code == N(${contract_name}) { &nbsp; &nbsp; // your handler to respond to particular action } 当然你也可以为每个action构造各自的一个响应。 action filter 为了响应每一个action，比如构造比如下面的apply函数。通常和code filter一起使用 if (action == N(${action_name}) { &nbsp; &nbsp; //your handler to respond to a particular action } wast 任何合约程序想要部署到EOSIO的区块链网络中都必须编译成WASM格式。这是EOS的支持唯一个的格式。 一旦你的CPP文件写好了，有就可以用eosiocpp把它编译成WASM (.wast)文件了 $ eosiocpp -o ${contract}.wast ${contract}.cpp abi ABI（ Application Binary Interface）文件是一个JSON格式的描述文件，说明了如何在他们的JSON和二进制之间转化用户的action。ABI文件也同时说明了如何转换数据库的状态。一旦你用了ABI描述了你的合约，开发人员就和用户就可以和你的合约通过JSON进行交互。 ABI可以通过.hpp文件用eosiocpp生成。 $ eosiocpp -g ${contract}.abi ${contract}.hpp 下面这个例子展示了一个ABI文件的框架： { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;balance&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;action&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;transfer&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;tables&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;table&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;index_type&quot;: &quot;i64&quot;, &nbsp; &nbsp; &nbsp; &quot;key_names&quot; : [&quot;account&quot;], &nbsp; &nbsp; &nbsp; &quot;key_types&quot; : [&quot;name&quot;] &nbsp; &nbsp; } &nbsp; ] } 你会注意到这个ABI定义了一个actoin名字是transfer，类型是transfer。这就是告诉EOSIO，当调用的action是transfer时，它的格式是transfer，定义如下： ... &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ ... &nbsp; ABI文件有很多的部分组成，比如from,to和quantity。每个部分都有自己的类型，比如account_name和uint64。account_name是一个内建类型用base32字符串表示为uint64。想要看到更多的内建类型可以点击这里 &nbsp; { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], ... &nbsp; 在上面types 数组里，我们为已经存在的account_name类型定义了一个别名name 。 四、调试智能合约 为了能够调试智能合约，你需要在你的本地环境中启动一个nodeos。这个本地的nodeos可以是一个EOS私有的测试网络或者是公网的测试网络。 当你第一次创建智能合约的时候，推荐你最好在你自己的私有测试网络中调试好，因为你对你自己的私有测试网络有完全的掌控权。这可以让你无限制的使用EOS（币）也可以随时复位它的状态。当合约调试完毕，就可以部署到公共测试网络了，本地先运行一个连接到公共测试网络的nodeos，然后连接到这个节点就可以获得log输出了。 步骤是一样的，所以下面这个手册也适用于私有测试网络中的测试。 如果你还没有一个本地的nodeos环境，可以参考这个连接。默认情况下，你的本地nodes会运行在一个私有网络中，除非你修改了config.ini文件，让他去连接公共测试网络，如何修改可以参考这里。 方法 调试最主要的方法就是用Caveman Debugging，我们增强了printing的功能，他可以去输出变量的值并且检查合约的流程。Printing可以通过下面API被合约使用： 这是c 这是 C++). C++的API是对C的封装，所以大多数我们使用C++的API。 Print Print C API 支持如下数据类型： - prints - a null terminated char array (string) - prints_l - any char array (string) with given size - printi - 64-bit unsigned integer - printi128 - 128-bit unsigned integer - printd - double encoded as 64-bit unsigned integer - printn - base32 string encoded as 64-bit unsigned integer - printhex - hex given binary of data and its size 同时 Print C++ API 对上面的C API进行了封装，所以用户不需要指定应该使用哪种类型的Print。Print C++ API 支持 - a null terminated char array (string) - integer (128-bit unsigned, 64-bit unsigned, 32-bit unsigned, signed, unsigned) - base32 string encoded as 64-bit unsigned integer - struct that has print() method 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/07/a5d09be938940515c0df84cc187250bb.html" />
<meta property="og:url" content="https://mlh.app/2018/08/07/a5d09be938940515c0df84cc187250bb.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"EOS合约简介 一、语言 &nbsp; 基于EOSIO的块链使用的是WebAssembly (WASM)来执行用户编写的智能合约。WASM是一种新兴的Web标准，广泛支持于谷歌、微软、苹果等。对编写WASM标准的智能合约来说使用clang/llvm和它的C/C++编译器是目前最为成熟的编译工具链。 其他的第三方工具链在开发中，包括：Rust, Python, and Solidity。虽然这些语言可能看起来相对简单，但它们可能会影响您所编写的智能性能。我们认为，对于开发高性能和安全的智能合约，C++是最好的语言，将来eos的智能合约也还会继续支持C++。 Linux / Mac OS Experience EOSIO 支持下面的操作系统: - Amazon 2017.09 and higher - Centos 7 - Fedora 25 and higher (Fedora 27 推荐使用) - Mint 18 - Ubuntu 16.04 (Ubuntu 16.10 推荐使用) - MacOS Darwin 10.12 and higher (MacOS 10.13.x 推荐使用) 二、Action vs Transaction &nbsp; Action表示单个操作，而transaction是一个或多个action的集合。Action是合约和账户之间进行通信的方式。Action可以单独执行，或者组合组合起来作为一个整体执行。 仅有一个action的transaction. &nbsp; { &nbsp; &quot;expiration&quot;: &quot;2018-04-01T15:20:44&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: 42580, &nbsp; &quot;ref_block_prefix&quot;: 3987474256, &nbsp; &quot;net_usage_words&quot;: 21, &nbsp; &quot;kcpu_usage&quot;: 1000, &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;eosio.token&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;issue&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;eosio&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;active&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] } 包含多个action的transaction, 这些action要么全部成功要么全部失败. { &nbsp; &quot;expiration&quot;: &quot;...&quot;, &nbsp; &quot;region&quot;: 0, &nbsp; &quot;ref_block_num&quot;: ..., &nbsp; &quot;ref_block_prefix&quot;: ..., &nbsp; &quot;net_usage_words&quot;: .., &nbsp; &quot;kcpu_usage&quot;: .., &nbsp; &quot;delay_sec&quot;: 0, &nbsp; &quot;context_free_actions&quot;: [], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; }, { &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &quot;authorization&quot;: [{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;actor&quot;: &quot;...&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;permission&quot;: &quot;...&quot; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; ], &nbsp; &nbsp; &nbsp; &quot;data&quot;: &quot;...&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;signatures&quot;: [ &nbsp; &nbsp; &quot;&quot; &nbsp; ], &nbsp; &quot;context_free_data&quot;: [] &nbsp; } 三、智能合约文件 &nbsp; 从简单易用的角度出发，我们编写了一个工具eosiocpp ，它可以创建一个新的智能合约。eosiocpp也可以创建3个合约文件，它们仅仅包含了合约的框架。 $ eosiocpp -n ${contract} 上面的命令会在./${project}目录下创建一个空的项目，它包含3个文件 ${contract}.abi ${contract}.hpp ${contract}.cpp &nbsp; hpp &nbsp; ${contract}.hpp 这是合约的头文件，可以包含一些变量，常量和函数的声明。 cpp The ${contract}.cpp 这是合约的源码文件，包含合约的具体实现。 如果你用eosiocpp生成了一个 .cpp， 那它的内容大概类似如下: #include &lt;${contract}.hpp&gt; &nbsp; /** &nbsp;*&nbsp; The init() and apply() methods must have C calling convention so that the blockchain can lookup and &nbsp;*&nbsp; call these methods. &nbsp;*/ extern &quot;C&quot; { &nbsp; &nbsp; /** &nbsp; &nbsp; &nbsp;*&nbsp; This method is called once when the contract is published or updated. &nbsp; &nbsp; &nbsp;*/ &nbsp; &nbsp; void init()&nbsp; { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Init World!\\n&quot; ); // Replace with actual code &nbsp; &nbsp; } &nbsp; &nbsp; /// The apply method implements the dispatch of actions to this contract &nbsp; &nbsp; void apply( uint64_t code, uint64_t action ) { &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( &quot;Hello World: &quot;, eosio::name(code), &quot;-&gt;&quot;, eosio::name(action), &quot;\\n&quot; ); &nbsp; &nbsp; } } // extern &quot;C&quot; 在这个例子里，我们可以看到两个函数，init和apply。它们会打印log并且不做任何检查。任何人都可以在任何时刻执行BP允许的所有action。在不需要任何签名的情况下，合约将被计入带宽消耗。（Absent any required signatures, the contract will be billed for the bandwidth consumed.） init init 仅当合约第一次被部署的时候执行。 在这个函数里可以初始化变量, 比如，在currency合约中总体的token的供应量。 apply apply 是一个中转函数, 他监听所有传入的action，并且根据action调用合约相应的函数。apply函数需要两个参数， code 和 action。 code filter 这个参数是为了对action做出回应，比如下面的apply函数，你可以构造一个通用响应去忽略code。 （In order to respond to a particular action, structure the apply function as follows. You may also construct a response to general actions by omitting the code filter.） if (code == N(${contract_name}) { &nbsp; &nbsp; // your handler to respond to particular action } 当然你也可以为每个action构造各自的一个响应。 action filter 为了响应每一个action，比如构造比如下面的apply函数。通常和code filter一起使用 if (action == N(${action_name}) { &nbsp; &nbsp; //your handler to respond to a particular action } wast 任何合约程序想要部署到EOSIO的区块链网络中都必须编译成WASM格式。这是EOS的支持唯一个的格式。 一旦你的CPP文件写好了，有就可以用eosiocpp把它编译成WASM (.wast)文件了 $ eosiocpp -o ${contract}.wast ${contract}.cpp abi ABI（ Application Binary Interface）文件是一个JSON格式的描述文件，说明了如何在他们的JSON和二进制之间转化用户的action。ABI文件也同时说明了如何转换数据库的状态。一旦你用了ABI描述了你的合约，开发人员就和用户就可以和你的合约通过JSON进行交互。 ABI可以通过.hpp文件用eosiocpp生成。 $ eosiocpp -g ${contract}.abi ${contract}.hpp 下面这个例子展示了一个ABI文件的框架： { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;account&quot;: &quot;name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;balance&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;actions&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;action&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;transfer&quot; &nbsp; &nbsp; } &nbsp; ], &nbsp; &quot;tables&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;table&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;account&quot;, &nbsp; &nbsp; &nbsp; &quot;index_type&quot;: &quot;i64&quot;, &nbsp; &nbsp; &nbsp; &quot;key_names&quot; : [&quot;account&quot;], &nbsp; &nbsp; &nbsp; &quot;key_types&quot; : [&quot;name&quot;] &nbsp; &nbsp; } &nbsp; ] } 你会注意到这个ABI定义了一个actoin名字是transfer，类型是transfer。这就是告诉EOSIO，当调用的action是transfer时，它的格式是transfer，定义如下： ... &nbsp; &quot;structs&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;transfer&quot;, &nbsp; &nbsp; &nbsp; &quot;base&quot;: &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;fields&quot;: { &nbsp; &nbsp; &nbsp; &nbsp; &quot;from&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;to&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;quantity&quot;: &quot;uint64&quot; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; },{ ... &nbsp; ABI文件有很多的部分组成，比如from,to和quantity。每个部分都有自己的类型，比如account_name和uint64。account_name是一个内建类型用base32字符串表示为uint64。想要看到更多的内建类型可以点击这里 &nbsp; { &nbsp; &quot;types&quot;: [{ &nbsp; &nbsp; &nbsp; &quot;new_type_name&quot;: &quot;account_name&quot;, &nbsp; &nbsp; &nbsp; &quot;type&quot;: &quot;name&quot; &nbsp; &nbsp; } &nbsp; ], ... &nbsp; 在上面types 数组里，我们为已经存在的account_name类型定义了一个别名name 。 四、调试智能合约 为了能够调试智能合约，你需要在你的本地环境中启动一个nodeos。这个本地的nodeos可以是一个EOS私有的测试网络或者是公网的测试网络。 当你第一次创建智能合约的时候，推荐你最好在你自己的私有测试网络中调试好，因为你对你自己的私有测试网络有完全的掌控权。这可以让你无限制的使用EOS（币）也可以随时复位它的状态。当合约调试完毕，就可以部署到公共测试网络了，本地先运行一个连接到公共测试网络的nodeos，然后连接到这个节点就可以获得log输出了。 步骤是一样的，所以下面这个手册也适用于私有测试网络中的测试。 如果你还没有一个本地的nodeos环境，可以参考这个连接。默认情况下，你的本地nodes会运行在一个私有网络中，除非你修改了config.ini文件，让他去连接公共测试网络，如何修改可以参考这里。 方法 调试最主要的方法就是用Caveman Debugging，我们增强了printing的功能，他可以去输出变量的值并且检查合约的流程。Printing可以通过下面API被合约使用： 这是c 这是 C++). C++的API是对C的封装，所以大多数我们使用C++的API。 Print Print C API 支持如下数据类型： - prints - a null terminated char array (string) - prints_l - any char array (string) with given size - printi - 64-bit unsigned integer - printi128 - 128-bit unsigned integer - printd - double encoded as 64-bit unsigned integer - printn - base32 string encoded as 64-bit unsigned integer - printhex - hex given binary of data and its size 同时 Print C++ API 对上面的C API进行了封装，所以用户不需要指定应该使用哪种类型的Print。Print C++ API 支持 - a null terminated char array (string) - integer (128-bit unsigned, 64-bit unsigned, 32-bit unsigned, signed, unsigned) - base32 string encoded as 64-bit unsigned integer - struct that has print() method 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/07/a5d09be938940515c0df84cc187250bb.html","headline":"EOS合约开发第七章-EOS合约简介","dateModified":"2018-08-07T00:00:00+08:00","datePublished":"2018-08-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/07/a5d09be938940515c0df84cc187250bb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS合约开发第七章-EOS合约简介</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1>EOS合约简介</h1> 
  <h3>一、语言</h3> 
  <p>&nbsp;</p> 
  <p>基于EOSIO的块链使用的是WebAssembly (WASM)来执行用户编写的智能合约。WASM是一种新兴的Web标准，广泛支持于谷歌、微软、苹果等。对编写WASM标准的智能合约来说使用clang/llvm和它的C/C++编译器是目前最为成熟的编译工具链。</p> 
  <p>其他的第三方工具链在开发中，包括：Rust, Python, and Solidity。虽然这些语言可能看起来相对简单，但它们可能会影响您所编写的智能性能。我们认为，对于开发高性能和安全的智能合约，C++是最好的语言，将来eos的智能合约也还会继续支持C++。</p> 
  <p>Linux / Mac OS Experience</p> 
  <p>EOSIO 支持下面的操作系统: - Amazon 2017.09 and higher - Centos 7 - Fedora 25 and higher (Fedora 27 推荐使用) - Mint 18 - Ubuntu 16.04 (Ubuntu 16.10 推荐使用) - MacOS Darwin 10.12 and higher (MacOS 10.13.x 推荐使用)</p> 
  <h3>二、<span style="color:#404040;">Action vs Transaction</span></h3> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">Action表示单个操作，而transaction是一个或多个action的集合。Action是合约和账户之间进行通信的方式。Action可以单独执行，或者组合组合起来作为一个整体执行。</span></p> 
  <p><span style="color:#404040;">仅有一个action的transaction.</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">{<br> &nbsp; "expiration": "2018-04-01T15:20:44",<br> &nbsp; "region": 0,<br> &nbsp; "ref_block_num": 42580,<br> &nbsp; "ref_block_prefix": 3987474256,<br> &nbsp; "net_usage_words": 21,<br> &nbsp; "kcpu_usage": 1000,<br> &nbsp; "delay_sec": 0,<br> &nbsp; "context_free_actions": [],<br> &nbsp; "actions": [{<br> &nbsp; &nbsp; &nbsp; "account": "eosio.token",<br> &nbsp; &nbsp; &nbsp; "name": "issue",<br> &nbsp; &nbsp; &nbsp; "authorization": [{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "actor": "eosio",<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "permission": "active"<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; ],<br> &nbsp; &nbsp; &nbsp; "data": "00000000007015d640420f000000000004454f5300000000046d656d6f"<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> &nbsp; "signatures": [<br> &nbsp; &nbsp; ""<br> &nbsp; ],<br> &nbsp; "context_free_data": []<br> }<br> 包含多个action的transaction, 这些action要么全部成功要么全部失败.<br> {<br> &nbsp; "expiration": "...",<br> &nbsp; "region": 0,<br> &nbsp; "ref_block_num": ...,<br> &nbsp; "ref_block_prefix": ...,<br> &nbsp; "net_usage_words": ..,<br> &nbsp; "kcpu_usage": ..,<br> &nbsp; "delay_sec": 0,<br> &nbsp; "context_free_actions": [],<br> &nbsp; "actions": [{<br> &nbsp; &nbsp; &nbsp; "account": "...",<br> &nbsp; &nbsp; &nbsp; "name": "...",<br> &nbsp; &nbsp; &nbsp; "authorization": [{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "actor": "...",<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "permission": "..."<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; ],<br> &nbsp; &nbsp; &nbsp; "data": "..."<br> &nbsp; &nbsp; }, {<br> &nbsp; &nbsp; &nbsp; "account": "...",<br> &nbsp; &nbsp; &nbsp; "name": "...",<br> &nbsp; &nbsp; &nbsp; "authorization": [{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "actor": "...",<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "permission": "..."<br> &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; ],<br> &nbsp; &nbsp; &nbsp; "data": "..."<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> &nbsp; "signatures": [<br> &nbsp; &nbsp; ""<br> &nbsp; ],<br> &nbsp; "context_free_data": []</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">}</span></p> 
  <h3><span style="color:#404040;">三、智能合约文件</span></h3> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">从简单易用的角度出发，我们编写了一个工具eosiocpp ，它可以创建一个新的智能合约。eosiocpp也可以创建3个合约文件，它们仅仅包含了合约的框架。</span></p> 
  <p><span style="color:#404040;">$ eosiocpp -n ${contract}</span></p> 
  <p><span style="color:#404040;">上面的命令会在./${project}目录下创建一个空的项目，它包含3个文件</span></p> 
  <p><span style="color:#404040;">${contract}.abi ${contract}.hpp ${contract}.cpp</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">hpp</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">${contract}.hpp 这是合约的头文件，可以包含一些变量，常量和函数的声明。</span></p> 
  <p><span style="color:#404040;">cpp</span></p> 
  <p><span style="color:#404040;">The ${contract}.cpp 这是合约的源码文件，包含合约的具体实现。</span></p> 
  <p><span style="color:#404040;">如果你用eosiocpp生成了一个 .cpp， 那它的内容大概类似如下:</span></p> 
  <p><span style="color:#404040;">#include &lt;${contract}.hpp&gt;</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">/**<br> &nbsp;*&nbsp; The init() and apply() methods must have C calling convention so that the blockchain can lookup and<br> &nbsp;*&nbsp; call these methods.<br> &nbsp;*/<br> extern "C" {<br><br> &nbsp; &nbsp; /**<br> &nbsp; &nbsp; &nbsp;*&nbsp; This method is called once when the contract is published or updated.<br> &nbsp; &nbsp; &nbsp;*/<br> &nbsp; &nbsp; void init()&nbsp; {<br> &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( "Init World!\n" ); // Replace with actual code<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; /// The apply method implements the dispatch of actions to this contract<br> &nbsp; &nbsp; void apply( uint64_t code, uint64_t action ) {<br> &nbsp; &nbsp; &nbsp; &nbsp;eosio::print( "Hello World: ", eosio::name(code), "-&gt;", eosio::name(action), "\n" );<br> &nbsp; &nbsp; }<br> } // extern "C"<br> 在这个例子里，我们可以看到两个函数，init和apply。它们会打印log并且不做任何检查。任何人都可以在任何时刻执行BP允许的所有action。在不需要任何签名的情况下，合约将被计入带宽消耗。（Absent any required signatures, the contract will be billed for the bandwidth consumed.）<br> init<br> init 仅当合约第一次被部署的时候执行。 在这个函数里可以初始化变量, 比如，在currency合约中总体的token的供应量。<br> apply<br> apply 是一个中转函数, 他监听所有传入的action，并且根据action调用合约相应的函数。apply函数需要两个参数， code 和 action。<br> code filter<br><br> 这个参数是为了对action做出回应，比如下面的apply函数，你可以构造一个通用响应去忽略code。 （In order to respond to a particular action, structure the apply function as follows. You may also construct a response to general actions by omitting the code filter.）<br><br> if (code == N(${contract_name}) {<br> &nbsp; &nbsp; // your handler to respond to particular action<br> }<br> 当然你也可以为每个action构造各自的一个响应。<br><br> action filter<br><br> 为了响应每一个action，比如构造比如下面的apply函数。通常和code filter一起使用<br><br> if (action == N(${action_name}) {<br> &nbsp; &nbsp; //your handler to respond to a particular action<br> }<br> wast<br> 任何合约程序想要部署到EOSIO的区块链网络中都必须编译成WASM格式。这是EOS的支持唯一个的格式。<br><br> 一旦你的CPP文件写好了，有就可以用eosiocpp把它编译成WASM (.wast)文件了<br><br> $ eosiocpp -o ${contract}.wast ${contract}.cpp<br> abi<br> ABI（ Application Binary Interface）文件是一个JSON格式的描述文件，说明了如何在他们的JSON和二进制之间转化用户的action。ABI文件也同时说明了如何转换数据库的状态。一旦你用了ABI描述了你的合约，开发人员就和用户就可以和你的合约通过JSON进行交互。<br><br> ABI可以通过.hpp文件用eosiocpp生成。<br><br> $ eosiocpp -g ${contract}.abi ${contract}.hpp<br> 下面这个例子展示了一个ABI文件的框架：<br><br> {<br> &nbsp; "types": [{<br> &nbsp; &nbsp; &nbsp; "new_type_name": "account_name",<br> &nbsp; &nbsp; &nbsp; "type": "name"<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> &nbsp; "structs": [{<br> &nbsp; &nbsp; &nbsp; "name": "transfer",<br> &nbsp; &nbsp; &nbsp; "base": "",<br> &nbsp; &nbsp; &nbsp; "fields": {<br> &nbsp; &nbsp; &nbsp; &nbsp; "from": "account_name",<br> &nbsp; &nbsp; &nbsp; &nbsp; "to": "account_name",<br> &nbsp; &nbsp; &nbsp; &nbsp; "quantity": "uint64"<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; },{<br> &nbsp; &nbsp; &nbsp; "name": "account",<br> &nbsp; &nbsp; &nbsp; "base": "",<br> &nbsp; &nbsp; &nbsp; "fields": {<br> &nbsp; &nbsp; &nbsp; &nbsp; "account": "name",<br> &nbsp; &nbsp; &nbsp; &nbsp; "balance": "uint64"<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> &nbsp; "actions": [{<br> &nbsp; &nbsp; &nbsp; "action": "transfer",<br> &nbsp; &nbsp; &nbsp; "type": "transfer"<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> &nbsp; "tables": [{<br> &nbsp; &nbsp; &nbsp; "table": "account",<br> &nbsp; &nbsp; &nbsp; "type": "account",<br> &nbsp; &nbsp; &nbsp; "index_type": "i64",<br> &nbsp; &nbsp; &nbsp; "key_names" : ["account"],<br> &nbsp; &nbsp; &nbsp; "key_types" : ["name"]<br> &nbsp; &nbsp; }<br> &nbsp; ]<br> }<br> 你会注意到这个ABI定义了一个actoin名字是transfer，类型是transfer。这就是告诉EOSIO，当调用的action是transfer时，它的格式是transfer，定义如下：<br> ...<br> &nbsp; "structs": [{<br> &nbsp; &nbsp; &nbsp; "name": "transfer",<br> &nbsp; &nbsp; &nbsp; "base": "",<br> &nbsp; &nbsp; &nbsp; "fields": {<br> &nbsp; &nbsp; &nbsp; &nbsp; "from": "account_name",<br> &nbsp; &nbsp; &nbsp; &nbsp; "to": "account_name",<br> &nbsp; &nbsp; &nbsp; &nbsp; "quantity": "uint64"<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; },{<br> ...</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">ABI文件有很多的部分组成，比如from,to和quantity。每个部分都有自己的类型，比如account_name和uint64。account_name是一个内建类型用base32字符串表示为uint64。想要看到更多的内建类型可以点击这里</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">{<br> &nbsp; "types": [{<br> &nbsp; &nbsp; &nbsp; "new_type_name": "account_name",<br> &nbsp; &nbsp; &nbsp; "type": "name"<br> &nbsp; &nbsp; }<br> &nbsp; ],<br> ...</span></p> 
  <p>&nbsp;</p> 
  <p><span style="color:#404040;">在上面types 数组里，我们为已经存在的account_name类型定义了一个别名name 。</span></p> 
  <h3><span style="color:#404040;">四、调试智能合约</span></h3> 
  <p><span style="color:#404040;">为了能够调试智能合约，你需要在你的本地环境中启动一个nodeos。这个本地的nodeos可以是一个EOS私有的测试网络或者是公网的测试网络。<br><br> 当你第一次创建智能合约的时候，推荐你最好在你自己的私有测试网络中调试好，因为你对你自己的私有测试网络有完全的掌控权。这可以让你无限制的使用EOS（币）也可以随时复位它的状态。当合约调试完毕，就可以部署到公共测试网络了，本地先运行一个连接到公共测试网络的nodeos，然后连接到这个节点就可以获得log输出了。<br><br> 步骤是一样的，所以下面这个手册也适用于私有测试网络中的测试。<br><br> 如果你还没有一个本地的nodeos环境，可以参考这个连接。默认情况下，你的本地nodes会运行在一个私有网络中，除非你修改了config.ini文件，让他去连接公共测试网络，如何修改可以参考这里。<br><br> 方法<br> 调试最主要的方法就是用Caveman Debugging，我们增强了printing的功能，他可以去输出变量的值并且检查合约的流程。Printing可以通过下面API被合约使用： 这是c 这是 C++). C++的API是对C的封装，所以大多数我们使用C++的API。<br><br> Print<br> Print C API 支持如下数据类型： - prints - a null terminated char array (string) - prints_l - any char array (string) with given size - printi - 64-bit unsigned integer - printi128 - 128-bit unsigned integer - printd - double encoded as 64-bit unsigned integer - printn - base32 string encoded as 64-bit unsigned integer - printhex - hex given binary of data and its size<br><br> 同时 Print C++ API 对上面的C API进行了封装，所以用户不需要指定应该使用哪种类型的Print。Print C++ API 支持 - a null terminated char array (string) - integer (128-bit unsigned, 64-bit unsigned, 32-bit unsigned, signed, unsigned) - base32 string encoded as 64-bit unsigned integer - struct that has print() method</span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bedrock_stable/article/details/80425871,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bedrock_stable/article/details/80425871,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
