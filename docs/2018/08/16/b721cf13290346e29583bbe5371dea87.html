<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13（七） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13（七）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="从这里开始就我自己瞎写了 9.8 导入钱包 InitLoadWallet() -zapwallettxes 新建钱包 升级钱包 生成默认key rescan zapwallettxes 9.8 导入钱包 // ********************************************************* Step 8: load wallet #ifdef ENABLE_WALLET if (fDisableWallet) { pwalletMain = NULL; LogPrintf(&quot;Wallet disabled!\n&quot;); } else { CWallet::InitLoadWallet(); if (!pwalletMain) return false; } #else // ENABLE_WALLET LogPrintf(&quot;No wallet support compiled in!\n&quot;); #endif // !ENABLE_WALLET 如果未启用宏定义或者禁用钱包，则不加载钱包功能。CWallet是密钥库的扩展，它还维护一组交易和余额，并提供创建新事务的能力。 InitLoadWallet() //src/wallet/wallet.h /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */ static bool InitLoadWallet(); InitLoadWallet()的具体实现在wallet.cpp,比较长分段来说 -zapwallettxes 如果设置了zapwallettxes那么需要恢复钱包交易的元数据 bool CWallet::InitLoadWallet() { std::string walletFile = GetArg(&quot;-wallet&quot;, DEFAULT_WALLET_DAT); // needed to restore wallet transaction meta data after -zapwallettxes std::vector&lt;CWalletTx&gt; vWtx; if (GetBoolArg(&quot;-zapwallettxes&quot;, false)) { uiInterface.InitMessage(_(&quot;Zapping all transactions from wallet...&quot;)); CWallet *tempWallet = new CWallet(walletFile); DBErrors nZapWalletRet = tempWallet-&gt;ZapWalletTx(vWtx); if (nZapWalletRet != DB_LOAD_OK) { return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); } delete tempWallet; tempWallet = NULL; } 这里使用到函数ZapWalletTx DBErrors CWallet::ZapWalletTx(std::vector&lt;CWalletTx&gt;&amp; vWtx) { if (!fFileBacked) return DB_LOAD_OK; DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,&quot;cr+&quot;).ZapWalletTx(this, vWtx); if (nZapWalletTxRet == DB_NEED_REWRITE) { if (CDB::Rewrite(strWalletFile, &quot;\x04pool&quot;)) { LOCK(cs_wallet); setKeyPool.clear(); // Note: can&#39;t top-up keypool here, because wallet is locked. // User will be prompted to unlock wallet the next operation // that requires a new key. } } if (nZapWalletTxRet != DB_LOAD_OK) return nZapWalletTxRet; return DB_LOAD_OK; } 可以看到这个函数是通过CWalletDB类对象的ZapWalletTx()清除交易的。CWalletDB类是对钱包数据进行封装的操作类，继承自CDB，CDB是对berkeley数据库操作的封装 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 继续去看CWalletDB.ZapWalletTx() DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector&lt;CWalletTx&gt;&amp; vWtx) { // build list of wallet TXs vector&lt;uint256&gt; vTxHash; DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx); if (err != DB_LOAD_OK) return err; // erase each wallet TX BOOST_FOREACH (uint256&amp; hash, vTxHash) { if (!EraseTx(hash)) return DB_CORRUPT; } return DB_LOAD_OK; } 这个函数调用FindWalletTx()查找钱包的交易的数据并存储在vTxHash中，最后调用EraseTx()函数清除了所有的交易。 新建钱包 new CWallet新建一个钱包对象，通过调用LoadWallet下载钱包数据，如果加载失败则报相应错误。 uiInterface.InitMessage(_(&quot;Loading wallet...&quot;)); int64_t nStart = GetTimeMillis(); bool fFirstRun = true; CWallet *walletInstance = new CWallet(walletFile); DBErrors nLoadWalletRet = walletInstance-&gt;LoadWallet(fFirstRun); if (nLoadWalletRet != DB_LOAD_OK) { if (nLoadWalletRet == DB_CORRUPT) return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); else if (nLoadWalletRet == DB_NONCRITICAL_ERROR) { InitWarning(strprintf(_(&quot;Error reading %s! All keys read correctly, but transaction data&quot; &quot; or address book entries might be missing or incorrect.&quot;), walletFile)); } else if (nLoadWalletRet == DB_TOO_NEW) return InitError(strprintf(_(&quot;Error loading %s: Wallet requires newer version of %s&quot;), walletFile, _(PACKAGE_NAME))); else if (nLoadWalletRet == DB_NEED_REWRITE) { return InitError(strprintf(_(&quot;Wallet needed to be rewritten: restart %s to complete&quot;), _(PACKAGE_NAME))); } else return InitError(strprintf(_(&quot;Error loading %s&quot;), walletFile)); } 升级钱包 if (GetBoolArg(&quot;-upgradewallet&quot;, fFirstRun)) { int nMaxVersion = GetArg(&quot;-upgradewallet&quot;, 0); if (nMaxVersion == 0) // the -upgradewallet without argument case { LogPrintf(&quot;Performing wallet upgrade to %i\n&quot;, FEATURE_LATEST); nMaxVersion = CLIENT_VERSION; walletInstance-&gt;SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately } else LogPrintf(&quot;Allowing wallet upgrade up to %i\n&quot;, nMaxVersion); if (nMaxVersion &lt; walletInstance-&gt;GetVersion()) { return InitError(_(&quot;Cannot downgrade wallet&quot;)); } walletInstance-&gt;SetMaxVersion(nMaxVersion); } 根据是否设置-upgradewallet这个参数进行钱包升级，代码逻辑为首先获取-upgradewallet设置的版本参数，如果没有设置（0），那么版本设置为当前版本，低于当前版本则打印提示信息，通过调用SetMaxVersion升级。这里了解下版本号 //clientversion.h static const int CLIENT_VERSION = 1000000 * CLIENT_VERSION_MAJOR + 10000 * CLIENT_VERSION_MINOR + 100 * CLIENT_VERSION_REVISION + 1 * CLIENT_VERSION_BUILD; //! These need to be macros, as clientversion.cpp&#39;s and bitcoin*-res.rc&#39;s voodoo requires it #define CLIENT_VERSION_MAJOR 0 //主版本号 #define CLIENT_VERSION_MINOR 13 //次版本号 #define CLIENT_VERSION_REVISION 2 //修订版本号 #define CLIENT_VERSION_BUILD 0 //构建版本号 生成默认key if (fFirstRun) { // Create new keyUser and set as default key if (GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET) &amp;&amp; walletInstance-&gt;hdChain.masterKeyID.IsNull()) { // generate a new master key CPubKey masterPubKey = walletInstance-&gt;GenerateNewHDMasterKey(); if (!walletInstance-&gt;SetHDMasterKey(masterPubKey)) throw std::runtime_error(std::string(__func__) + &quot;: Storing master key failed&quot;); } CPubKey newDefaultKey; if (walletInstance-&gt;GetKeyFromPool(newDefaultKey)) { walletInstance-&gt;SetDefaultKey(newDefaultKey); if (!walletInstance-&gt;SetAddressBook(walletInstance-&gt;vchDefaultKey.GetID(), &quot;&quot;, &quot;receive&quot;)) return InitError(_(&quot;Cannot write default address&quot;) += &quot;\n&quot;); } walletInstance-&gt;SetBestChain(chainActive.GetLocator()); } else if (mapArgs.count(&quot;-usehd&quot;)) { bool useHD = GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET); if (!walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; !useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t disable HD on a already existing HD wallet&quot;), walletFile)); if (walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t enable HD on a already existing non-HD wallet&quot;), walletFile)); } -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start -usehd参数代表使用BIP32之后的分层确定性密钥生成（HD）。 仅在钱包创建/首次启动时有效 如果设置了-usehd，那么会调用GenerateNewHDMasterKey来生成master key，返回类型为公钥 CPubKey CWallet::GenerateNewHDMasterKey() { CKey key; key.MakeNewKey(true); int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // calculate the pubkey CPubKey pubkey = key.GetPubKey(); assert(key.VerifyPubKey(pubkey)); // set the hd keypath to &quot;m&quot; -&gt; Master, refers the masterkeyid to itself metadata.hdKeypath = &quot;m&quot;; metadata.hdMasterKeyID = pubkey.GetID(); { LOCK(cs_wallet); // mem store the metadata mapKeyMetadata[pubkey.GetID()] = metadata; // write the key&amp;metadata to the database if (!AddKeyPubKey(key, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKeyPubKey failed&quot;); } return pubkey; } 这个函数是调用CKey类的MakeNewKey来生成公钥，关于MakeNewKey()函数之前的代码有介绍过，后面是给这个公钥标记为Master，添加到CKey中。 若未设置分层确定性密钥方式，则从密钥池中得到一个公钥，并设置为默认的公钥，最后通过CPubkey对象的GetID()生成比特币地址并调用SetAddressBook()函数记录下来。 //! Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch + size())); } 比特币地址是使用hash160加密算法得到，hash160就是我们说的双哈希，也就是RIPEMD160(SHA256)，关于这两个单向散列函数的具体介绍参考书籍。 rescan //注册钱包接口，是signal对象实现对钱包数据的各种侦听处理 RegisterValidationInterface(walletInstance); //如果用户设置了rescan参数，则从创世区块开始获取需要重新更新钱包数据的位置 CBlockIndex *pindexRescan = chainActive.Tip(); if (GetBoolArg(&quot;-rescan&quot;, false)) pindexRescan = chainActive.Genesis(); else { CWalletDB walletdb(walletFile); CBlockLocator locator; if (walletdb.ReadBestBlock(locator)) pindexRescan = FindForkInGlobalIndex(chainActive, locator); else pindexRescan = chainActive.Genesis(); } if (chainActive.Tip() &amp;&amp; chainActive.Tip() != pindexRescan) { //We can&#39;t rescan beyond non-pruned blocks, stop and throw an error //this might happen if a user uses a old wallet within a pruned node // or if he ran -disablewallet for a longer time, then decided to re-enable /*我们无法重新扫描超出非修剪的块，如果用户在修剪的节点中使用旧钱包 *或者如果他运行-disablewallet更长时间，然后决定重新启用，则可能会发生此错误*/ if (fPruneMode) { CBlockIndex *block = chainActive.Tip(); while (block &amp;&amp; block-&gt;pprev &amp;&amp; (block-&gt;pprev-&gt;nStatus &amp; BLOCK_HAVE_DATA) &amp;&amp; block-&gt;pprev-&gt;nTx &gt; 0 &amp;&amp; pindexRescan != block) block = block-&gt;pprev; if (pindexRescan != block) return InitError(_(&quot;Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)&quot;)); } //开始Rescan钱包交易 uiInterface.InitMessage(_(&quot;Rescanning...&quot;)); LogPrintf(&quot;Rescanning last %i blocks (from block %i)...\n&quot;, chainActive.Height() - pindexRescan-&gt;nHeight, pindexRescan-&gt;nHeight); nStart = GetTimeMillis(); walletInstance-&gt;ScanForWalletTransactions(pindexRescan, true); LogPrintf(&quot; rescan %15dms\n&quot;, GetTimeMillis() - nStart); walletInstance-&gt;SetBestChain(chainActive.GetLocator()); nWalletDBUpdated++; 对钱包进行Rescan处理调用的具体函数是ScanForWalletTransactions /** * Scan the block chain (starting in pindexStart) for transactions * from or to us. If fUpdate is true, found transactions that already * exist in the wallet will be updated. */ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate) {//1.设置开始查找的区块 int ret = 0; int64_t nNow = GetTime(); const CChainParams&amp; chainParams = Params(); CBlockIndex* pindex = pindexStart; { LOCK2(cs_main, cs_wallet); // no need to read and scan block, if block was created before // our wallet birthday (as adjusted for block time variability) while (pindex &amp;&amp; nTimeFirstKey &amp;&amp; (pindex-&gt;GetBlockTime() &lt; (nTimeFirstKey - 7200))) pindex = chainActive.Next(pindex);//chainActive存储区块位置信息链 //2.开始区块和结束区块，用于计算进度 ShowProgress(_(&quot;Rescanning...&quot;), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup double dProgressStart = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false); double dProgressTip = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), chainActive.Tip(), false); while (pindex) {//3.计算扫描进度 if (pindex-&gt;nHeight % 100 == 0 &amp;&amp; dProgressTip - dProgressStart &gt; 0.0) ShowProgress(_(&quot;Rescanning...&quot;), std::max(1, std::min(99, (int)((Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false) - dProgressStart) / (dProgressTip - dProgressStart) * 100)))); //4.根据pindex读取一个区块的数据放入block中 CBlock block; ReadBlockFromDisk(block, pindex, Params().GetConsensus()); //5.遍历区块的交易数据 BOOST_FOREACH(CTransaction&amp; tx, block.vtx) { if (AddToWalletIfInvolvingMe(tx, &amp;block, fUpdate)) ret++; } pindex = chainActive.Next(pindex); //获取下一个区块 if (GetTime() &gt;= nNow + 60) { nNow = GetTime(); LogPrintf(&quot;Still rescanning. At block %d. Progress=%f\n&quot;, pindex-&gt;nHeight, Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex)); } } ShowProgress(_(&quot;Rescanning...&quot;), 100); // hide progress dialog in GUI } return ret; } zapwallettxes 这个函数的最后还是zapwallettxes参数，恢复钱包交易元数据，前面是删除了内容 // Restore wallet transaction metadata after -zapwallettxes=1 if (GetBoolArg(&quot;-zapwallettxes&quot;, false) &amp;&amp; GetArg(&quot;-zapwallettxes&quot;, &quot;1&quot;) != &quot;2&quot;) { CWalletDB walletdb(walletFile); BOOST_FOREACH(const CWalletTx&amp; wtxOld, vWtx) { uint256 hash = wtxOld.GetHash(); std::map&lt;uint256, CWalletTx&gt;::iterator mi = walletInstance-&gt;mapWallet.find(hash); if (mi != walletInstance-&gt;mapWallet.end()) { const CWalletTx* copyFrom = &amp;wtxOld; CWalletTx* copyTo = &amp;mi-&gt;second; copyTo-&gt;mapValue = copyFrom-&gt;mapValue; copyTo-&gt;vOrderForm = copyFrom-&gt;vOrderForm; copyTo-&gt;nTimeReceived = copyFrom-&gt;nTimeReceived; copyTo-&gt;nTimeSmart = copyFrom-&gt;nTimeSmart; copyTo-&gt;fFromMe = copyFrom-&gt;fFromMe; copyTo-&gt;strFromAccount = copyFrom-&gt;strFromAccount; copyTo-&gt;nOrderPos = copyFrom-&gt;nOrderPos; walletdb.WriteTx(*copyTo); } } } } walletInstance-&gt;SetBroadcastTransactions(GetBoolArg(&quot;-walletbroadcast&quot;, DEFAULT_WALLETBROADCAST)); pwalletMain = walletInstance; return true; 最后给pwalletMain赋值为钱包实例，并返回true. 云里雾里的。。。 阅读更多" />
<meta property="og:description" content="从这里开始就我自己瞎写了 9.8 导入钱包 InitLoadWallet() -zapwallettxes 新建钱包 升级钱包 生成默认key rescan zapwallettxes 9.8 导入钱包 // ********************************************************* Step 8: load wallet #ifdef ENABLE_WALLET if (fDisableWallet) { pwalletMain = NULL; LogPrintf(&quot;Wallet disabled!\n&quot;); } else { CWallet::InitLoadWallet(); if (!pwalletMain) return false; } #else // ENABLE_WALLET LogPrintf(&quot;No wallet support compiled in!\n&quot;); #endif // !ENABLE_WALLET 如果未启用宏定义或者禁用钱包，则不加载钱包功能。CWallet是密钥库的扩展，它还维护一组交易和余额，并提供创建新事务的能力。 InitLoadWallet() //src/wallet/wallet.h /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */ static bool InitLoadWallet(); InitLoadWallet()的具体实现在wallet.cpp,比较长分段来说 -zapwallettxes 如果设置了zapwallettxes那么需要恢复钱包交易的元数据 bool CWallet::InitLoadWallet() { std::string walletFile = GetArg(&quot;-wallet&quot;, DEFAULT_WALLET_DAT); // needed to restore wallet transaction meta data after -zapwallettxes std::vector&lt;CWalletTx&gt; vWtx; if (GetBoolArg(&quot;-zapwallettxes&quot;, false)) { uiInterface.InitMessage(_(&quot;Zapping all transactions from wallet...&quot;)); CWallet *tempWallet = new CWallet(walletFile); DBErrors nZapWalletRet = tempWallet-&gt;ZapWalletTx(vWtx); if (nZapWalletRet != DB_LOAD_OK) { return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); } delete tempWallet; tempWallet = NULL; } 这里使用到函数ZapWalletTx DBErrors CWallet::ZapWalletTx(std::vector&lt;CWalletTx&gt;&amp; vWtx) { if (!fFileBacked) return DB_LOAD_OK; DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,&quot;cr+&quot;).ZapWalletTx(this, vWtx); if (nZapWalletTxRet == DB_NEED_REWRITE) { if (CDB::Rewrite(strWalletFile, &quot;\x04pool&quot;)) { LOCK(cs_wallet); setKeyPool.clear(); // Note: can&#39;t top-up keypool here, because wallet is locked. // User will be prompted to unlock wallet the next operation // that requires a new key. } } if (nZapWalletTxRet != DB_LOAD_OK) return nZapWalletTxRet; return DB_LOAD_OK; } 可以看到这个函数是通过CWalletDB类对象的ZapWalletTx()清除交易的。CWalletDB类是对钱包数据进行封装的操作类，继承自CDB，CDB是对berkeley数据库操作的封装 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 继续去看CWalletDB.ZapWalletTx() DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector&lt;CWalletTx&gt;&amp; vWtx) { // build list of wallet TXs vector&lt;uint256&gt; vTxHash; DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx); if (err != DB_LOAD_OK) return err; // erase each wallet TX BOOST_FOREACH (uint256&amp; hash, vTxHash) { if (!EraseTx(hash)) return DB_CORRUPT; } return DB_LOAD_OK; } 这个函数调用FindWalletTx()查找钱包的交易的数据并存储在vTxHash中，最后调用EraseTx()函数清除了所有的交易。 新建钱包 new CWallet新建一个钱包对象，通过调用LoadWallet下载钱包数据，如果加载失败则报相应错误。 uiInterface.InitMessage(_(&quot;Loading wallet...&quot;)); int64_t nStart = GetTimeMillis(); bool fFirstRun = true; CWallet *walletInstance = new CWallet(walletFile); DBErrors nLoadWalletRet = walletInstance-&gt;LoadWallet(fFirstRun); if (nLoadWalletRet != DB_LOAD_OK) { if (nLoadWalletRet == DB_CORRUPT) return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); else if (nLoadWalletRet == DB_NONCRITICAL_ERROR) { InitWarning(strprintf(_(&quot;Error reading %s! All keys read correctly, but transaction data&quot; &quot; or address book entries might be missing or incorrect.&quot;), walletFile)); } else if (nLoadWalletRet == DB_TOO_NEW) return InitError(strprintf(_(&quot;Error loading %s: Wallet requires newer version of %s&quot;), walletFile, _(PACKAGE_NAME))); else if (nLoadWalletRet == DB_NEED_REWRITE) { return InitError(strprintf(_(&quot;Wallet needed to be rewritten: restart %s to complete&quot;), _(PACKAGE_NAME))); } else return InitError(strprintf(_(&quot;Error loading %s&quot;), walletFile)); } 升级钱包 if (GetBoolArg(&quot;-upgradewallet&quot;, fFirstRun)) { int nMaxVersion = GetArg(&quot;-upgradewallet&quot;, 0); if (nMaxVersion == 0) // the -upgradewallet without argument case { LogPrintf(&quot;Performing wallet upgrade to %i\n&quot;, FEATURE_LATEST); nMaxVersion = CLIENT_VERSION; walletInstance-&gt;SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately } else LogPrintf(&quot;Allowing wallet upgrade up to %i\n&quot;, nMaxVersion); if (nMaxVersion &lt; walletInstance-&gt;GetVersion()) { return InitError(_(&quot;Cannot downgrade wallet&quot;)); } walletInstance-&gt;SetMaxVersion(nMaxVersion); } 根据是否设置-upgradewallet这个参数进行钱包升级，代码逻辑为首先获取-upgradewallet设置的版本参数，如果没有设置（0），那么版本设置为当前版本，低于当前版本则打印提示信息，通过调用SetMaxVersion升级。这里了解下版本号 //clientversion.h static const int CLIENT_VERSION = 1000000 * CLIENT_VERSION_MAJOR + 10000 * CLIENT_VERSION_MINOR + 100 * CLIENT_VERSION_REVISION + 1 * CLIENT_VERSION_BUILD; //! These need to be macros, as clientversion.cpp&#39;s and bitcoin*-res.rc&#39;s voodoo requires it #define CLIENT_VERSION_MAJOR 0 //主版本号 #define CLIENT_VERSION_MINOR 13 //次版本号 #define CLIENT_VERSION_REVISION 2 //修订版本号 #define CLIENT_VERSION_BUILD 0 //构建版本号 生成默认key if (fFirstRun) { // Create new keyUser and set as default key if (GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET) &amp;&amp; walletInstance-&gt;hdChain.masterKeyID.IsNull()) { // generate a new master key CPubKey masterPubKey = walletInstance-&gt;GenerateNewHDMasterKey(); if (!walletInstance-&gt;SetHDMasterKey(masterPubKey)) throw std::runtime_error(std::string(__func__) + &quot;: Storing master key failed&quot;); } CPubKey newDefaultKey; if (walletInstance-&gt;GetKeyFromPool(newDefaultKey)) { walletInstance-&gt;SetDefaultKey(newDefaultKey); if (!walletInstance-&gt;SetAddressBook(walletInstance-&gt;vchDefaultKey.GetID(), &quot;&quot;, &quot;receive&quot;)) return InitError(_(&quot;Cannot write default address&quot;) += &quot;\n&quot;); } walletInstance-&gt;SetBestChain(chainActive.GetLocator()); } else if (mapArgs.count(&quot;-usehd&quot;)) { bool useHD = GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET); if (!walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; !useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t disable HD on a already existing HD wallet&quot;), walletFile)); if (walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t enable HD on a already existing non-HD wallet&quot;), walletFile)); } -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start -usehd参数代表使用BIP32之后的分层确定性密钥生成（HD）。 仅在钱包创建/首次启动时有效 如果设置了-usehd，那么会调用GenerateNewHDMasterKey来生成master key，返回类型为公钥 CPubKey CWallet::GenerateNewHDMasterKey() { CKey key; key.MakeNewKey(true); int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // calculate the pubkey CPubKey pubkey = key.GetPubKey(); assert(key.VerifyPubKey(pubkey)); // set the hd keypath to &quot;m&quot; -&gt; Master, refers the masterkeyid to itself metadata.hdKeypath = &quot;m&quot;; metadata.hdMasterKeyID = pubkey.GetID(); { LOCK(cs_wallet); // mem store the metadata mapKeyMetadata[pubkey.GetID()] = metadata; // write the key&amp;metadata to the database if (!AddKeyPubKey(key, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKeyPubKey failed&quot;); } return pubkey; } 这个函数是调用CKey类的MakeNewKey来生成公钥，关于MakeNewKey()函数之前的代码有介绍过，后面是给这个公钥标记为Master，添加到CKey中。 若未设置分层确定性密钥方式，则从密钥池中得到一个公钥，并设置为默认的公钥，最后通过CPubkey对象的GetID()生成比特币地址并调用SetAddressBook()函数记录下来。 //! Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch + size())); } 比特币地址是使用hash160加密算法得到，hash160就是我们说的双哈希，也就是RIPEMD160(SHA256)，关于这两个单向散列函数的具体介绍参考书籍。 rescan //注册钱包接口，是signal对象实现对钱包数据的各种侦听处理 RegisterValidationInterface(walletInstance); //如果用户设置了rescan参数，则从创世区块开始获取需要重新更新钱包数据的位置 CBlockIndex *pindexRescan = chainActive.Tip(); if (GetBoolArg(&quot;-rescan&quot;, false)) pindexRescan = chainActive.Genesis(); else { CWalletDB walletdb(walletFile); CBlockLocator locator; if (walletdb.ReadBestBlock(locator)) pindexRescan = FindForkInGlobalIndex(chainActive, locator); else pindexRescan = chainActive.Genesis(); } if (chainActive.Tip() &amp;&amp; chainActive.Tip() != pindexRescan) { //We can&#39;t rescan beyond non-pruned blocks, stop and throw an error //this might happen if a user uses a old wallet within a pruned node // or if he ran -disablewallet for a longer time, then decided to re-enable /*我们无法重新扫描超出非修剪的块，如果用户在修剪的节点中使用旧钱包 *或者如果他运行-disablewallet更长时间，然后决定重新启用，则可能会发生此错误*/ if (fPruneMode) { CBlockIndex *block = chainActive.Tip(); while (block &amp;&amp; block-&gt;pprev &amp;&amp; (block-&gt;pprev-&gt;nStatus &amp; BLOCK_HAVE_DATA) &amp;&amp; block-&gt;pprev-&gt;nTx &gt; 0 &amp;&amp; pindexRescan != block) block = block-&gt;pprev; if (pindexRescan != block) return InitError(_(&quot;Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)&quot;)); } //开始Rescan钱包交易 uiInterface.InitMessage(_(&quot;Rescanning...&quot;)); LogPrintf(&quot;Rescanning last %i blocks (from block %i)...\n&quot;, chainActive.Height() - pindexRescan-&gt;nHeight, pindexRescan-&gt;nHeight); nStart = GetTimeMillis(); walletInstance-&gt;ScanForWalletTransactions(pindexRescan, true); LogPrintf(&quot; rescan %15dms\n&quot;, GetTimeMillis() - nStart); walletInstance-&gt;SetBestChain(chainActive.GetLocator()); nWalletDBUpdated++; 对钱包进行Rescan处理调用的具体函数是ScanForWalletTransactions /** * Scan the block chain (starting in pindexStart) for transactions * from or to us. If fUpdate is true, found transactions that already * exist in the wallet will be updated. */ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate) {//1.设置开始查找的区块 int ret = 0; int64_t nNow = GetTime(); const CChainParams&amp; chainParams = Params(); CBlockIndex* pindex = pindexStart; { LOCK2(cs_main, cs_wallet); // no need to read and scan block, if block was created before // our wallet birthday (as adjusted for block time variability) while (pindex &amp;&amp; nTimeFirstKey &amp;&amp; (pindex-&gt;GetBlockTime() &lt; (nTimeFirstKey - 7200))) pindex = chainActive.Next(pindex);//chainActive存储区块位置信息链 //2.开始区块和结束区块，用于计算进度 ShowProgress(_(&quot;Rescanning...&quot;), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup double dProgressStart = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false); double dProgressTip = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), chainActive.Tip(), false); while (pindex) {//3.计算扫描进度 if (pindex-&gt;nHeight % 100 == 0 &amp;&amp; dProgressTip - dProgressStart &gt; 0.0) ShowProgress(_(&quot;Rescanning...&quot;), std::max(1, std::min(99, (int)((Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false) - dProgressStart) / (dProgressTip - dProgressStart) * 100)))); //4.根据pindex读取一个区块的数据放入block中 CBlock block; ReadBlockFromDisk(block, pindex, Params().GetConsensus()); //5.遍历区块的交易数据 BOOST_FOREACH(CTransaction&amp; tx, block.vtx) { if (AddToWalletIfInvolvingMe(tx, &amp;block, fUpdate)) ret++; } pindex = chainActive.Next(pindex); //获取下一个区块 if (GetTime() &gt;= nNow + 60) { nNow = GetTime(); LogPrintf(&quot;Still rescanning. At block %d. Progress=%f\n&quot;, pindex-&gt;nHeight, Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex)); } } ShowProgress(_(&quot;Rescanning...&quot;), 100); // hide progress dialog in GUI } return ret; } zapwallettxes 这个函数的最后还是zapwallettxes参数，恢复钱包交易元数据，前面是删除了内容 // Restore wallet transaction metadata after -zapwallettxes=1 if (GetBoolArg(&quot;-zapwallettxes&quot;, false) &amp;&amp; GetArg(&quot;-zapwallettxes&quot;, &quot;1&quot;) != &quot;2&quot;) { CWalletDB walletdb(walletFile); BOOST_FOREACH(const CWalletTx&amp; wtxOld, vWtx) { uint256 hash = wtxOld.GetHash(); std::map&lt;uint256, CWalletTx&gt;::iterator mi = walletInstance-&gt;mapWallet.find(hash); if (mi != walletInstance-&gt;mapWallet.end()) { const CWalletTx* copyFrom = &amp;wtxOld; CWalletTx* copyTo = &amp;mi-&gt;second; copyTo-&gt;mapValue = copyFrom-&gt;mapValue; copyTo-&gt;vOrderForm = copyFrom-&gt;vOrderForm; copyTo-&gt;nTimeReceived = copyFrom-&gt;nTimeReceived; copyTo-&gt;nTimeSmart = copyFrom-&gt;nTimeSmart; copyTo-&gt;fFromMe = copyFrom-&gt;fFromMe; copyTo-&gt;strFromAccount = copyFrom-&gt;strFromAccount; copyTo-&gt;nOrderPos = copyFrom-&gt;nOrderPos; walletdb.WriteTx(*copyTo); } } } } walletInstance-&gt;SetBroadcastTransactions(GetBoolArg(&quot;-walletbroadcast&quot;, DEFAULT_WALLETBROADCAST)); pwalletMain = walletInstance; return true; 最后给pwalletMain赋值为钱包实例，并返回true. 云里雾里的。。。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/16/b721cf13290346e29583bbe5371dea87.html" />
<meta property="og:url" content="https://mlh.app/2018/08/16/b721cf13290346e29583bbe5371dea87.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"从这里开始就我自己瞎写了 9.8 导入钱包 InitLoadWallet() -zapwallettxes 新建钱包 升级钱包 生成默认key rescan zapwallettxes 9.8 导入钱包 // ********************************************************* Step 8: load wallet #ifdef ENABLE_WALLET if (fDisableWallet) { pwalletMain = NULL; LogPrintf(&quot;Wallet disabled!\\n&quot;); } else { CWallet::InitLoadWallet(); if (!pwalletMain) return false; } #else // ENABLE_WALLET LogPrintf(&quot;No wallet support compiled in!\\n&quot;); #endif // !ENABLE_WALLET 如果未启用宏定义或者禁用钱包，则不加载钱包功能。CWallet是密钥库的扩展，它还维护一组交易和余额，并提供创建新事务的能力。 InitLoadWallet() //src/wallet/wallet.h /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */ static bool InitLoadWallet(); InitLoadWallet()的具体实现在wallet.cpp,比较长分段来说 -zapwallettxes 如果设置了zapwallettxes那么需要恢复钱包交易的元数据 bool CWallet::InitLoadWallet() { std::string walletFile = GetArg(&quot;-wallet&quot;, DEFAULT_WALLET_DAT); // needed to restore wallet transaction meta data after -zapwallettxes std::vector&lt;CWalletTx&gt; vWtx; if (GetBoolArg(&quot;-zapwallettxes&quot;, false)) { uiInterface.InitMessage(_(&quot;Zapping all transactions from wallet...&quot;)); CWallet *tempWallet = new CWallet(walletFile); DBErrors nZapWalletRet = tempWallet-&gt;ZapWalletTx(vWtx); if (nZapWalletRet != DB_LOAD_OK) { return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); } delete tempWallet; tempWallet = NULL; } 这里使用到函数ZapWalletTx DBErrors CWallet::ZapWalletTx(std::vector&lt;CWalletTx&gt;&amp; vWtx) { if (!fFileBacked) return DB_LOAD_OK; DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,&quot;cr+&quot;).ZapWalletTx(this, vWtx); if (nZapWalletTxRet == DB_NEED_REWRITE) { if (CDB::Rewrite(strWalletFile, &quot;\\x04pool&quot;)) { LOCK(cs_wallet); setKeyPool.clear(); // Note: can&#39;t top-up keypool here, because wallet is locked. // User will be prompted to unlock wallet the next operation // that requires a new key. } } if (nZapWalletTxRet != DB_LOAD_OK) return nZapWalletTxRet; return DB_LOAD_OK; } 可以看到这个函数是通过CWalletDB类对象的ZapWalletTx()清除交易的。CWalletDB类是对钱包数据进行封装的操作类，继承自CDB，CDB是对berkeley数据库操作的封装 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 继续去看CWalletDB.ZapWalletTx() DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector&lt;CWalletTx&gt;&amp; vWtx) { // build list of wallet TXs vector&lt;uint256&gt; vTxHash; DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx); if (err != DB_LOAD_OK) return err; // erase each wallet TX BOOST_FOREACH (uint256&amp; hash, vTxHash) { if (!EraseTx(hash)) return DB_CORRUPT; } return DB_LOAD_OK; } 这个函数调用FindWalletTx()查找钱包的交易的数据并存储在vTxHash中，最后调用EraseTx()函数清除了所有的交易。 新建钱包 new CWallet新建一个钱包对象，通过调用LoadWallet下载钱包数据，如果加载失败则报相应错误。 uiInterface.InitMessage(_(&quot;Loading wallet...&quot;)); int64_t nStart = GetTimeMillis(); bool fFirstRun = true; CWallet *walletInstance = new CWallet(walletFile); DBErrors nLoadWalletRet = walletInstance-&gt;LoadWallet(fFirstRun); if (nLoadWalletRet != DB_LOAD_OK) { if (nLoadWalletRet == DB_CORRUPT) return InitError(strprintf(_(&quot;Error loading %s: Wallet corrupted&quot;), walletFile)); else if (nLoadWalletRet == DB_NONCRITICAL_ERROR) { InitWarning(strprintf(_(&quot;Error reading %s! All keys read correctly, but transaction data&quot; &quot; or address book entries might be missing or incorrect.&quot;), walletFile)); } else if (nLoadWalletRet == DB_TOO_NEW) return InitError(strprintf(_(&quot;Error loading %s: Wallet requires newer version of %s&quot;), walletFile, _(PACKAGE_NAME))); else if (nLoadWalletRet == DB_NEED_REWRITE) { return InitError(strprintf(_(&quot;Wallet needed to be rewritten: restart %s to complete&quot;), _(PACKAGE_NAME))); } else return InitError(strprintf(_(&quot;Error loading %s&quot;), walletFile)); } 升级钱包 if (GetBoolArg(&quot;-upgradewallet&quot;, fFirstRun)) { int nMaxVersion = GetArg(&quot;-upgradewallet&quot;, 0); if (nMaxVersion == 0) // the -upgradewallet without argument case { LogPrintf(&quot;Performing wallet upgrade to %i\\n&quot;, FEATURE_LATEST); nMaxVersion = CLIENT_VERSION; walletInstance-&gt;SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately } else LogPrintf(&quot;Allowing wallet upgrade up to %i\\n&quot;, nMaxVersion); if (nMaxVersion &lt; walletInstance-&gt;GetVersion()) { return InitError(_(&quot;Cannot downgrade wallet&quot;)); } walletInstance-&gt;SetMaxVersion(nMaxVersion); } 根据是否设置-upgradewallet这个参数进行钱包升级，代码逻辑为首先获取-upgradewallet设置的版本参数，如果没有设置（0），那么版本设置为当前版本，低于当前版本则打印提示信息，通过调用SetMaxVersion升级。这里了解下版本号 //clientversion.h static const int CLIENT_VERSION = 1000000 * CLIENT_VERSION_MAJOR + 10000 * CLIENT_VERSION_MINOR + 100 * CLIENT_VERSION_REVISION + 1 * CLIENT_VERSION_BUILD; //! These need to be macros, as clientversion.cpp&#39;s and bitcoin*-res.rc&#39;s voodoo requires it #define CLIENT_VERSION_MAJOR 0 //主版本号 #define CLIENT_VERSION_MINOR 13 //次版本号 #define CLIENT_VERSION_REVISION 2 //修订版本号 #define CLIENT_VERSION_BUILD 0 //构建版本号 生成默认key if (fFirstRun) { // Create new keyUser and set as default key if (GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET) &amp;&amp; walletInstance-&gt;hdChain.masterKeyID.IsNull()) { // generate a new master key CPubKey masterPubKey = walletInstance-&gt;GenerateNewHDMasterKey(); if (!walletInstance-&gt;SetHDMasterKey(masterPubKey)) throw std::runtime_error(std::string(__func__) + &quot;: Storing master key failed&quot;); } CPubKey newDefaultKey; if (walletInstance-&gt;GetKeyFromPool(newDefaultKey)) { walletInstance-&gt;SetDefaultKey(newDefaultKey); if (!walletInstance-&gt;SetAddressBook(walletInstance-&gt;vchDefaultKey.GetID(), &quot;&quot;, &quot;receive&quot;)) return InitError(_(&quot;Cannot write default address&quot;) += &quot;\\n&quot;); } walletInstance-&gt;SetBestChain(chainActive.GetLocator()); } else if (mapArgs.count(&quot;-usehd&quot;)) { bool useHD = GetBoolArg(&quot;-usehd&quot;, DEFAULT_USE_HD_WALLET); if (!walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; !useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t disable HD on a already existing HD wallet&quot;), walletFile)); if (walletInstance-&gt;hdChain.masterKeyID.IsNull() &amp;&amp; useHD) return InitError(strprintf(_(&quot;Error loading %s: You can&#39;t enable HD on a already existing non-HD wallet&quot;), walletFile)); } -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start -usehd参数代表使用BIP32之后的分层确定性密钥生成（HD）。 仅在钱包创建/首次启动时有效 如果设置了-usehd，那么会调用GenerateNewHDMasterKey来生成master key，返回类型为公钥 CPubKey CWallet::GenerateNewHDMasterKey() { CKey key; key.MakeNewKey(true); int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // calculate the pubkey CPubKey pubkey = key.GetPubKey(); assert(key.VerifyPubKey(pubkey)); // set the hd keypath to &quot;m&quot; -&gt; Master, refers the masterkeyid to itself metadata.hdKeypath = &quot;m&quot;; metadata.hdMasterKeyID = pubkey.GetID(); { LOCK(cs_wallet); // mem store the metadata mapKeyMetadata[pubkey.GetID()] = metadata; // write the key&amp;metadata to the database if (!AddKeyPubKey(key, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKeyPubKey failed&quot;); } return pubkey; } 这个函数是调用CKey类的MakeNewKey来生成公钥，关于MakeNewKey()函数之前的代码有介绍过，后面是给这个公钥标记为Master，添加到CKey中。 若未设置分层确定性密钥方式，则从密钥池中得到一个公钥，并设置为默认的公钥，最后通过CPubkey对象的GetID()生成比特币地址并调用SetAddressBook()函数记录下来。 //! Get the KeyID of this public key (hash of its serialization) CKeyID GetID() const { return CKeyID(Hash160(vch, vch + size())); } 比特币地址是使用hash160加密算法得到，hash160就是我们说的双哈希，也就是RIPEMD160(SHA256)，关于这两个单向散列函数的具体介绍参考书籍。 rescan //注册钱包接口，是signal对象实现对钱包数据的各种侦听处理 RegisterValidationInterface(walletInstance); //如果用户设置了rescan参数，则从创世区块开始获取需要重新更新钱包数据的位置 CBlockIndex *pindexRescan = chainActive.Tip(); if (GetBoolArg(&quot;-rescan&quot;, false)) pindexRescan = chainActive.Genesis(); else { CWalletDB walletdb(walletFile); CBlockLocator locator; if (walletdb.ReadBestBlock(locator)) pindexRescan = FindForkInGlobalIndex(chainActive, locator); else pindexRescan = chainActive.Genesis(); } if (chainActive.Tip() &amp;&amp; chainActive.Tip() != pindexRescan) { //We can&#39;t rescan beyond non-pruned blocks, stop and throw an error //this might happen if a user uses a old wallet within a pruned node // or if he ran -disablewallet for a longer time, then decided to re-enable /*我们无法重新扫描超出非修剪的块，如果用户在修剪的节点中使用旧钱包 *或者如果他运行-disablewallet更长时间，然后决定重新启用，则可能会发生此错误*/ if (fPruneMode) { CBlockIndex *block = chainActive.Tip(); while (block &amp;&amp; block-&gt;pprev &amp;&amp; (block-&gt;pprev-&gt;nStatus &amp; BLOCK_HAVE_DATA) &amp;&amp; block-&gt;pprev-&gt;nTx &gt; 0 &amp;&amp; pindexRescan != block) block = block-&gt;pprev; if (pindexRescan != block) return InitError(_(&quot;Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)&quot;)); } //开始Rescan钱包交易 uiInterface.InitMessage(_(&quot;Rescanning...&quot;)); LogPrintf(&quot;Rescanning last %i blocks (from block %i)...\\n&quot;, chainActive.Height() - pindexRescan-&gt;nHeight, pindexRescan-&gt;nHeight); nStart = GetTimeMillis(); walletInstance-&gt;ScanForWalletTransactions(pindexRescan, true); LogPrintf(&quot; rescan %15dms\\n&quot;, GetTimeMillis() - nStart); walletInstance-&gt;SetBestChain(chainActive.GetLocator()); nWalletDBUpdated++; 对钱包进行Rescan处理调用的具体函数是ScanForWalletTransactions /** * Scan the block chain (starting in pindexStart) for transactions * from or to us. If fUpdate is true, found transactions that already * exist in the wallet will be updated. */ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate) {//1.设置开始查找的区块 int ret = 0; int64_t nNow = GetTime(); const CChainParams&amp; chainParams = Params(); CBlockIndex* pindex = pindexStart; { LOCK2(cs_main, cs_wallet); // no need to read and scan block, if block was created before // our wallet birthday (as adjusted for block time variability) while (pindex &amp;&amp; nTimeFirstKey &amp;&amp; (pindex-&gt;GetBlockTime() &lt; (nTimeFirstKey - 7200))) pindex = chainActive.Next(pindex);//chainActive存储区块位置信息链 //2.开始区块和结束区块，用于计算进度 ShowProgress(_(&quot;Rescanning...&quot;), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup double dProgressStart = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false); double dProgressTip = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), chainActive.Tip(), false); while (pindex) {//3.计算扫描进度 if (pindex-&gt;nHeight % 100 == 0 &amp;&amp; dProgressTip - dProgressStart &gt; 0.0) ShowProgress(_(&quot;Rescanning...&quot;), std::max(1, std::min(99, (int)((Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, false) - dProgressStart) / (dProgressTip - dProgressStart) * 100)))); //4.根据pindex读取一个区块的数据放入block中 CBlock block; ReadBlockFromDisk(block, pindex, Params().GetConsensus()); //5.遍历区块的交易数据 BOOST_FOREACH(CTransaction&amp; tx, block.vtx) { if (AddToWalletIfInvolvingMe(tx, &amp;block, fUpdate)) ret++; } pindex = chainActive.Next(pindex); //获取下一个区块 if (GetTime() &gt;= nNow + 60) { nNow = GetTime(); LogPrintf(&quot;Still rescanning. At block %d. Progress=%f\\n&quot;, pindex-&gt;nHeight, Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex)); } } ShowProgress(_(&quot;Rescanning...&quot;), 100); // hide progress dialog in GUI } return ret; } zapwallettxes 这个函数的最后还是zapwallettxes参数，恢复钱包交易元数据，前面是删除了内容 // Restore wallet transaction metadata after -zapwallettxes=1 if (GetBoolArg(&quot;-zapwallettxes&quot;, false) &amp;&amp; GetArg(&quot;-zapwallettxes&quot;, &quot;1&quot;) != &quot;2&quot;) { CWalletDB walletdb(walletFile); BOOST_FOREACH(const CWalletTx&amp; wtxOld, vWtx) { uint256 hash = wtxOld.GetHash(); std::map&lt;uint256, CWalletTx&gt;::iterator mi = walletInstance-&gt;mapWallet.find(hash); if (mi != walletInstance-&gt;mapWallet.end()) { const CWalletTx* copyFrom = &amp;wtxOld; CWalletTx* copyTo = &amp;mi-&gt;second; copyTo-&gt;mapValue = copyFrom-&gt;mapValue; copyTo-&gt;vOrderForm = copyFrom-&gt;vOrderForm; copyTo-&gt;nTimeReceived = copyFrom-&gt;nTimeReceived; copyTo-&gt;nTimeSmart = copyFrom-&gt;nTimeSmart; copyTo-&gt;fFromMe = copyFrom-&gt;fFromMe; copyTo-&gt;strFromAccount = copyFrom-&gt;strFromAccount; copyTo-&gt;nOrderPos = copyFrom-&gt;nOrderPos; walletdb.WriteTx(*copyTo); } } } } walletInstance-&gt;SetBroadcastTransactions(GetBoolArg(&quot;-walletbroadcast&quot;, DEFAULT_WALLETBROADCAST)); pwalletMain = walletInstance; return true; 最后给pwalletMain赋值为钱包实例，并返回true. 云里雾里的。。。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/16/b721cf13290346e29583bbe5371dea87.html","headline":"比特币源码学习0.13（七）","dateModified":"2018-08-16T00:00:00+08:00","datePublished":"2018-08-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/16/b721cf13290346e29583bbe5371dea87.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13（七）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>从这里开始就我自己瞎写了</p> 
  <hr> 
  <p></p>
  <div class="toc">
   <div class="toc"> 
    <ul> 
     <li><a href="#98-导入钱包" rel="nofollow">9.8 导入钱包</a>
      <ul> 
       <li><a href="#initloadwallet" rel="nofollow">InitLoadWallet()</a>
        <ul> 
         <li><a href="#zapwallettxes" rel="nofollow">-zapwallettxes</a></li> 
         <li><a href="#新建钱包" rel="nofollow">新建钱包</a></li> 
         <li><a href="#升级钱包" rel="nofollow">升级钱包</a></li> 
         <li><a href="#生成默认key" rel="nofollow">生成默认key</a></li> 
         <li><a href="#rescan" rel="nofollow">rescan</a></li> 
         <li><a href="#zapwallettxes-1" rel="nofollow">zapwallettxes</a></li> 
        </ul> </li> 
      </ul> </li> 
    </ul> 
   </div> 
  </div> 
  <p></p> 
  <hr> 
  <h1 id="98-导入钱包">9.8 导入钱包</h1> 
  <pre class="prettyprint"><code class=" hljs lasso"> <span class="hljs-comment">// ********************************************************* Step 8: load wallet</span>
<span class="hljs-variable">#ifdef</span> ENABLE_WALLET
    <span class="hljs-keyword">if</span> (fDisableWallet) {
        pwalletMain <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
        LogPrintf(<span class="hljs-string">"Wallet disabled!\n"</span>);
    } <span class="hljs-keyword">else</span> {
        CWallet<span class="hljs-tag">::InitLoadWallet</span>();
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>pwalletMain)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
<span class="hljs-variable">#else</span> <span class="hljs-comment">// ENABLE_WALLET</span>
    LogPrintf(<span class="hljs-string">"No wallet support compiled in!\n"</span>);
<span class="hljs-variable">#endif</span> <span class="hljs-comment">// !ENABLE_WALLET</span></code></pre> 
  <p>如果未启用宏定义或者禁用钱包，则不加载钱包功能。CWallet是密钥库的扩展，它还维护一组交易和余额，并提供创建新事务的能力。</p> 
  <hr> 
  <h2 id="initloadwallet">InitLoadWallet()</h2> 
  <pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-comment">//src/wallet/wallet.h</span>
    /* Initializes the wallet, returns a <span class="hljs-keyword">new</span> CWallet instance <span class="hljs-keyword">or</span> a <span class="hljs-keyword">null</span> pointer <span class="hljs-keyword">in</span> case <span class="hljs-keyword">of</span> an error */
    <span class="hljs-keyword">static</span> bool InitLoadWallet();</code></pre> 
  <p><code>InitLoadWallet()</code>的具体实现在<code>wallet.cpp</code>,比较长分段来说</p> 
  <hr> 
  <h3 id="zapwallettxes">-zapwallettxes</h3> 
  <p>如果设置了zapwallettxes那么需要恢复钱包交易的元数据</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CWallet::InitLoadWallet()
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> walletFile = GetArg(<span class="hljs-string">"-wallet"</span>, DEFAULT_WALLET_DAT);

    <span class="hljs-comment">// needed to restore wallet transaction meta data after -zapwallettxes</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CWalletTx&gt;</span> vWtx;

    <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-zapwallettxes"</span>, <span class="hljs-keyword">false</span>)) {
        uiInterface.InitMessage(_(<span class="hljs-string">"Zapping all transactions from wallet..."</span>));

        CWallet *tempWallet = <span class="hljs-keyword">new</span> CWallet(walletFile);
        DBErrors nZapWalletRet = tempWallet-&gt;ZapWalletTx(vWtx);
        <span class="hljs-keyword">if</span> (nZapWalletRet != DB_LOAD_OK) {
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Error loading %s: Wallet corrupted"</span>), walletFile));
        }

        <span class="hljs-keyword">delete</span> tempWallet;
        tempWallet = NULL;
    }</code></pre> 
  <p>这里使用到函数ZapWalletTx</p> 
  <pre class="prettyprint"><code class=" hljs cpp">DBErrors CWallet::ZapWalletTx(<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CWalletTx&gt;</span>&amp; vWtx)
{
    <span class="hljs-keyword">if</span> (!fFileBacked)
        <span class="hljs-keyword">return</span> DB_LOAD_OK;
    DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,<span class="hljs-string">"cr+"</span>).ZapWalletTx(<span class="hljs-keyword">this</span>, vWtx);
    <span class="hljs-keyword">if</span> (nZapWalletTxRet == DB_NEED_REWRITE)
    {
        <span class="hljs-keyword">if</span> (CDB::Rewrite(strWalletFile, <span class="hljs-string">"\x04pool"</span>))
        {
            LOCK(cs_wallet);
            setKeyPool.clear();
            <span class="hljs-comment">// Note: can't top-up keypool here, because wallet is locked.</span>
            <span class="hljs-comment">// User will be prompted to unlock wallet the next operation</span>
            <span class="hljs-comment">// that requires a new key.</span>
        }
    }

    <span class="hljs-keyword">if</span> (nZapWalletTxRet != DB_LOAD_OK)
        <span class="hljs-keyword">return</span> nZapWalletTxRet;

    <span class="hljs-keyword">return</span> DB_LOAD_OK;
}</code></pre> 
  <p>可以看到这个函数是通过<code>CWalletDB</code>类对象的<code>ZapWalletTx()</code>清除交易的。<code>CWalletDB</code>类是对钱包数据进行封装的操作类，继承自CDB，CDB是对berkeley数据库操作的封装</p> 
  <blockquote> 
   <p>Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。</p> 
  </blockquote> 
  <p>继续去看<code>CWalletDB.ZapWalletTx()</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp">DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CWalletTx&gt;</span>&amp; vWtx)
{
    <span class="hljs-comment">// build list of wallet TXs</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint256&gt;</span> vTxHash;
    DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);
    <span class="hljs-keyword">if</span> (err != DB_LOAD_OK)
        <span class="hljs-keyword">return</span> err;

    <span class="hljs-comment">// erase each wallet TX</span>
    BOOST_FOREACH (uint256&amp; hash, vTxHash) {
        <span class="hljs-keyword">if</span> (!EraseTx(hash))
            <span class="hljs-keyword">return</span> DB_CORRUPT;
    }

    <span class="hljs-keyword">return</span> DB_LOAD_OK;
}</code></pre> 
  <p>这个函数调用<code>FindWalletTx()</code>查找钱包的交易的数据并存储在<code>vTxHash</code>中，最后调用<code>EraseTx()</code>函数清除了所有的交易。</p> 
  <hr> 
  <h3 id="新建钱包">新建钱包</h3> 
  <p>new CWallet新建一个钱包对象，通过调用LoadWallet下载钱包数据，如果加载失败则报相应错误。</p> 
  <pre class="prettyprint"><code class=" hljs perl">uiInterface.InitMessage(<span class="hljs-number">_</span>(<span class="hljs-string">"Loading wallet..."</span>));

    int64_t nStart = GetTimeMillis();
    bool fFirstRun = true;
    CWallet <span class="hljs-variable">*walletInstance</span> = new CWallet(walletFile);
    DBErrors nLoadWalletRet = walletInstance-&gt;LoadWallet(fFirstRun);
    <span class="hljs-keyword">if</span> (nLoadWalletRet != DB_LOAD_OK)
    {
        <span class="hljs-keyword">if</span> (nLoadWalletRet == DB_CORRUPT)
            <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-number">_</span>(<span class="hljs-string">"Error loading <span class="hljs-variable">%s</span>: Wallet corrupted"</span>), walletFile));
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nLoadWalletRet == DB_NONCRITICAL_ERROR)
        {
            InitWarning(strprintf(<span class="hljs-number">_</span>(<span class="hljs-string">"Error reading <span class="hljs-variable">%s</span>! All keys read correctly, but transaction data"</span>
                                         <span class="hljs-string">" or address book entries might be missing or incorrect."</span>),
                walletFile));
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nLoadWalletRet == DB_TOO_NEW)
            <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-number">_</span>(<span class="hljs-string">"Error loading <span class="hljs-variable">%s</span>: Wallet requires newer version of <span class="hljs-variable">%s</span>"</span>),
                               walletFile, <span class="hljs-number">_</span>(PACKAGE_NAME)));
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nLoadWalletRet == DB_NEED_REWRITE)
        {
            <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-number">_</span>(<span class="hljs-string">"Wallet needed to be rewritten: restart <span class="hljs-variable">%s</span> to complete"</span>), <span class="hljs-number">_</span>(PACKAGE_NAME)));
        }
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-number">_</span>(<span class="hljs-string">"Error loading <span class="hljs-variable">%s</span>"</span>), walletFile));
    }</code></pre> 
  <hr> 
  <h3 id="升级钱包">升级钱包</h3> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-upgradewallet"</span>, fFirstRun))
    {
        int nMaxVersion <span class="hljs-subst">=</span> GetArg(<span class="hljs-string">"-upgradewallet"</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (nMaxVersion <span class="hljs-subst">==</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// the -upgradewallet without argument case</span>
        {
            LogPrintf(<span class="hljs-string">"Performing wallet upgrade to %i\n"</span>, FEATURE_LATEST);
            nMaxVersion <span class="hljs-subst">=</span> CLIENT_VERSION;
            walletInstance<span class="hljs-subst">-&gt;</span>SetMinVersion(FEATURE_LATEST); <span class="hljs-comment">// permanently upgrade the wallet immediately</span>
        }
        <span class="hljs-keyword">else</span>
            LogPrintf(<span class="hljs-string">"Allowing wallet upgrade up to %i\n"</span>, nMaxVersion);
        <span class="hljs-keyword">if</span> (nMaxVersion <span class="hljs-subst">&lt;</span> walletInstance<span class="hljs-subst">-&gt;</span>GetVersion())
        {
            <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Cannot downgrade wallet"</span>));
        }
        walletInstance<span class="hljs-subst">-&gt;</span>SetMaxVersion(nMaxVersion);
    }</code></pre> 
  <p>根据是否设置<code>-upgradewallet</code>这个参数进行钱包升级，代码逻辑为首先获取<code>-upgradewallet</code>设置的版本参数，如果没有设置（0），那么版本设置为当前版本，低于当前版本则打印提示信息，通过调用SetMaxVersion升级。这里了解下版本号</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//clientversion.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CLIENT_VERSION =
                           <span class="hljs-number">1000000</span> * CLIENT_VERSION_MAJOR
                         +   <span class="hljs-number">10000</span> * CLIENT_VERSION_MINOR
                         +     <span class="hljs-number">100</span> * CLIENT_VERSION_REVISION
                         +       <span class="hljs-number">1</span> * CLIENT_VERSION_BUILD;
<span class="hljs-comment">//! These need to be macros, as clientversion.cpp's and bitcoin*-res.rc's voodoo requires it</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CLIENT_VERSION_MAJOR 0 //主版本号</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CLIENT_VERSION_MINOR 13 //次版本号</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CLIENT_VERSION_REVISION 2 //修订版本号</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CLIENT_VERSION_BUILD 0 //构建版本号</span></code></pre> 
  <hr> 
  <h3 id="生成默认key">生成默认key</h3> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">if</span> (fFirstRun)
    {
        <span class="hljs-comment">// Create new keyUser and set as default key</span>
        <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-usehd"</span>, DEFAULT_USE_HD_WALLET) <span class="hljs-subst">&amp;&amp;</span> walletInstance<span class="hljs-subst">-&gt;</span>hdChain<span class="hljs-built_in">.</span>masterKeyID<span class="hljs-built_in">.</span>IsNull()) {
            <span class="hljs-comment">// generate a new master key</span>
            CPubKey masterPubKey <span class="hljs-subst">=</span> walletInstance<span class="hljs-subst">-&gt;</span>GenerateNewHDMasterKey();
            <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>walletInstance<span class="hljs-subst">-&gt;</span>SetHDMasterKey(masterPubKey))
                throw std<span class="hljs-tag">::runtime_error</span>(std<span class="hljs-tag">::string</span>(__func__) <span class="hljs-subst">+</span> <span class="hljs-string">": Storing master key failed"</span>);
        }
        CPubKey newDefaultKey;
        <span class="hljs-keyword">if</span> (walletInstance<span class="hljs-subst">-&gt;</span>GetKeyFromPool(newDefaultKey)) {
            walletInstance<span class="hljs-subst">-&gt;</span>SetDefaultKey(newDefaultKey);
            <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>walletInstance<span class="hljs-subst">-&gt;</span>SetAddressBook(walletInstance<span class="hljs-subst">-&gt;</span>vchDefaultKey<span class="hljs-built_in">.</span>GetID(), <span class="hljs-string">""</span>, <span class="hljs-string">"receive"</span>))
                <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Cannot write default address"</span>) <span class="hljs-subst">+=</span> <span class="hljs-string">"\n"</span>);
        }

        walletInstance<span class="hljs-subst">-&gt;</span>SetBestChain(chainActive<span class="hljs-built_in">.</span>GetLocator());
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mapArgs<span class="hljs-built_in">.</span>count(<span class="hljs-string">"-usehd"</span>)) {
        bool useHD <span class="hljs-subst">=</span> GetBoolArg(<span class="hljs-string">"-usehd"</span>, DEFAULT_USE_HD_WALLET);
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>walletInstance<span class="hljs-subst">-&gt;</span>hdChain<span class="hljs-built_in">.</span>masterKeyID<span class="hljs-built_in">.</span>IsNull() <span class="hljs-subst">&amp;&amp;</span> <span class="hljs-subst">!</span>useHD)
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Error loading %s: You can't disable HD on a already existing HD wallet"</span>), walletFile));
        <span class="hljs-keyword">if</span> (walletInstance<span class="hljs-subst">-&gt;</span>hdChain<span class="hljs-built_in">.</span>masterKeyID<span class="hljs-built_in">.</span>IsNull() <span class="hljs-subst">&amp;&amp;</span> useHD)
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Error loading %s: You can't enable HD on a already existing non-HD wallet"</span>), walletFile));
    }</code></pre> 
  <blockquote> 
   <p>-usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start</p> 
  </blockquote> 
  <p><code>-usehd</code>参数代表使用<code>BIP32</code>之后的分层确定性密钥生成（HD）。 仅在钱包创建/首次启动时有效 <br> 如果设置了<code>-usehd</code>，那么会调用GenerateNewHDMasterKey来生成master key，返回类型为公钥</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">CPubKey CWallet::GenerateNewHDMasterKey()
{
    CKey key<span class="hljs-comment">;</span>
    key<span class="hljs-preprocessor">.MakeNewKey</span>(true)<span class="hljs-comment">;</span>

    int64_t nCreationTime = GetTime()<span class="hljs-comment">;</span>
    CKeyMetadata metadata(nCreationTime)<span class="hljs-comment">;</span>

    // calculate the pubkey
    CPubKey pubkey = key<span class="hljs-preprocessor">.GetPubKey</span>()<span class="hljs-comment">;</span>
    assert(key<span class="hljs-preprocessor">.VerifyPubKey</span>(pubkey))<span class="hljs-comment">;</span>

    // <span class="hljs-keyword">set</span> the hd keypath to <span class="hljs-string">"m"</span> -&gt; Master, refers the masterkeyid to itself
    metadata<span class="hljs-preprocessor">.hdKeypath</span>     = <span class="hljs-string">"m"</span><span class="hljs-comment">;</span>
    metadata<span class="hljs-preprocessor">.hdMasterKeyID</span> = pubkey<span class="hljs-preprocessor">.GetID</span>()<span class="hljs-comment">;</span>

    {
        LOCK(cs_wallet)<span class="hljs-comment">;</span>

        // mem store the metadata
        mapKeyMetadata[pubkey<span class="hljs-preprocessor">.GetID</span>()] = metadata<span class="hljs-comment">;</span>

        // write the key&amp;metadata to the database
        if (!AddKeyPubKey(key, pubkey))
            throw <span class="hljs-keyword">std</span>::runtime_error(<span class="hljs-keyword">std</span>::string(__func__) + <span class="hljs-string">": AddKeyPubKey failed"</span>)<span class="hljs-comment">;</span>
    }

    return pubkey<span class="hljs-comment">;</span>
}
</code></pre> 
  <p>这个函数是调用<code>CKey</code>类的<code>MakeNewKey</code>来生成公钥，关于<a href="https://blog.csdn.net/m0_37847176/article/details/81450432#makenewkey" rel="nofollow">MakeNewKey()</a>函数之前的代码有介绍过，后面是给这个公钥标记为<code>Master</code>，添加到<code>CKey</code>中。 <br> 若未设置分层确定性密钥方式，则从密钥池中得到一个公钥，并设置为默认的公钥，最后通过<code>CPubkey</code>对象的<code>GetID()</code>生成比特币地址并调用<code>SetAddressBook()</code>函数记录下来。</p> 
  <pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-regexp">//</span>! Get the KeyID <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span> public key (hash <span class="hljs-keyword">of</span> its serialization)
    CKeyID GetID() <span class="hljs-reserved">const</span>
    {
        <span class="hljs-keyword">return</span> CKeyID(Hash160(vch, vch + size()));
    }</code></pre> 
  <p>比特币地址是使用hash160加密算法得到，hash160就是我们说的双哈希，也就是RIPEMD160(SHA256)，关于这两个单向散列函数的具体介绍参考书籍。</p> 
  <hr> 
  <h3 id="rescan">rescan</h3> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//注册钱包接口，是signal对象实现对钱包数据的各种侦听处理</span>
 RegisterValidationInterface(walletInstance);
<span class="hljs-comment">//如果用户设置了rescan参数，则从创世区块开始获取需要重新更新钱包数据的位置</span>
    CBlockIndex <span class="hljs-subst">*</span>pindexRescan <span class="hljs-subst">=</span> chainActive<span class="hljs-built_in">.</span>Tip();
    <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-rescan"</span>, <span class="hljs-literal">false</span>))
        pindexRescan <span class="hljs-subst">=</span> chainActive<span class="hljs-built_in">.</span>Genesis();
    <span class="hljs-keyword">else</span>
    {
        CWalletDB walletdb(walletFile);
        CBlockLocator locator;
        <span class="hljs-keyword">if</span> (walletdb<span class="hljs-built_in">.</span>ReadBestBlock(locator))
            pindexRescan <span class="hljs-subst">=</span> FindForkInGlobalIndex(chainActive, locator);
        <span class="hljs-keyword">else</span>
            pindexRescan <span class="hljs-subst">=</span> chainActive<span class="hljs-built_in">.</span>Genesis();
    }
    <span class="hljs-keyword">if</span> (chainActive<span class="hljs-built_in">.</span>Tip() <span class="hljs-subst">&amp;&amp;</span> chainActive<span class="hljs-built_in">.</span>Tip() <span class="hljs-subst">!=</span> pindexRescan)
    {
        <span class="hljs-comment">//We can't rescan beyond non-pruned blocks, stop and throw an error</span>
        <span class="hljs-comment">//this might happen if a user uses a old wallet within a pruned node</span>
        <span class="hljs-comment">// or if he ran -disablewallet for a longer time, then decided to re-enable</span>
  <span class="hljs-comment">/*我们无法重新扫描超出非修剪的块，如果用户在修剪的节点中使用旧钱包 *或者如果他运行-disablewallet更长时间，然后决定重新启用，则可能会发生此错误*/</span>
        <span class="hljs-keyword">if</span> (fPruneMode)
        {
            CBlockIndex <span class="hljs-subst">*</span>block <span class="hljs-subst">=</span> chainActive<span class="hljs-built_in">.</span>Tip();
            <span class="hljs-keyword">while</span> (block <span class="hljs-subst">&amp;&amp;</span> block<span class="hljs-subst">-&gt;</span>pprev <span class="hljs-subst">&amp;&amp;</span> (block<span class="hljs-subst">-&gt;</span>pprev<span class="hljs-subst">-&gt;</span>nStatus <span class="hljs-subst">&amp;</span> BLOCK_HAVE_DATA) <span class="hljs-subst">&amp;&amp;</span> block<span class="hljs-subst">-&gt;</span>pprev<span class="hljs-subst">-&gt;</span>nTx <span class="hljs-subst">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-subst">&amp;&amp;</span> pindexRescan <span class="hljs-subst">!=</span> block)
                block <span class="hljs-subst">=</span> block<span class="hljs-subst">-&gt;</span>pprev;

            <span class="hljs-keyword">if</span> (pindexRescan <span class="hljs-subst">!=</span> block)
                <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)"</span>));
        }
<span class="hljs-comment">//开始Rescan钱包交易</span>
        uiInterface<span class="hljs-built_in">.</span>InitMessage(_(<span class="hljs-string">"Rescanning..."</span>));
        LogPrintf(<span class="hljs-string">"Rescanning last %i blocks (from block %i)...\n"</span>, chainActive<span class="hljs-built_in">.</span>Height() <span class="hljs-subst">-</span> pindexRescan<span class="hljs-subst">-&gt;</span>nHeight, pindexRescan<span class="hljs-subst">-&gt;</span>nHeight);
        nStart <span class="hljs-subst">=</span> GetTimeMillis();
        walletInstance<span class="hljs-subst">-&gt;</span>ScanForWalletTransactions(pindexRescan, <span class="hljs-literal">true</span>);
        LogPrintf(<span class="hljs-string">" rescan %15dms\n"</span>, GetTimeMillis() <span class="hljs-subst">-</span> nStart);
        walletInstance<span class="hljs-subst">-&gt;</span>SetBestChain(chainActive<span class="hljs-built_in">.</span>GetLocator());
        nWalletDBUpdated<span class="hljs-subst">++</span>;
</code></pre> 
  <p>对钱包进行<code>Rescan</code>处理调用的具体函数是<code>ScanForWalletTransactions</code></p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** * Scan the block chain (starting in pindexStart) for transactions * from or to us. If fUpdate is true, found transactions that already * exist in the wallet will be updated. */</span>
<span class="hljs-keyword">int</span> CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)
{<span class="hljs-comment">//1.设置开始查找的区块</span>
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    int64_t nNow = GetTime();
    <span class="hljs-keyword">const</span> CChainParams&amp; chainParams = Params();

    CBlockIndex* pindex = pindexStart;
    {
        LOCK2(cs_main, cs_wallet);
        <span class="hljs-comment">// no need to read and scan block, if block was created before</span>
        <span class="hljs-comment">// our wallet birthday (as adjusted for block time variability)</span>
        <span class="hljs-keyword">while</span> (pindex &amp;&amp; nTimeFirstKey &amp;&amp; (pindex-&gt;GetBlockTime() &lt; (nTimeFirstKey - <span class="hljs-number">7200</span>)))
            pindex = chainActive.Next(pindex);<span class="hljs-comment">//chainActive存储区块位置信息链</span>
<span class="hljs-comment">//2.开始区块和结束区块，用于计算进度</span>
        ShowProgress(_(<span class="hljs-string">"Rescanning..."</span>), <span class="hljs-number">0</span>); <span class="hljs-comment">// show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup</span>
        <span class="hljs-keyword">double</span> dProgressStart = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">double</span> dProgressTip = Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), chainActive.Tip(), <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">while</span> (pindex)
        {<span class="hljs-comment">//3.计算扫描进度</span>
            <span class="hljs-keyword">if</span> (pindex-&gt;nHeight % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> &amp;&amp; dProgressTip - dProgressStart &gt; <span class="hljs-number">0.0</span>)
                ShowProgress(_(<span class="hljs-string">"Rescanning..."</span>), std::max(<span class="hljs-number">1</span>, std::min(<span class="hljs-number">99</span>, (<span class="hljs-keyword">int</span>)((Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex, <span class="hljs-keyword">false</span>) - dProgressStart) / (dProgressTip - dProgressStart) * <span class="hljs-number">100</span>))));
<span class="hljs-comment">//4.根据pindex读取一个区块的数据放入block中</span>
            CBlock block;
            ReadBlockFromDisk(block, pindex, Params().GetConsensus());
            <span class="hljs-comment">//5.遍历区块的交易数据</span>
            BOOST_FOREACH(CTransaction&amp; tx, block.vtx)
            {
                <span class="hljs-keyword">if</span> (AddToWalletIfInvolvingMe(tx, &amp;block, fUpdate))
                    ret++;
            }
            pindex = chainActive.Next(pindex);
            <span class="hljs-comment">//获取下一个区块</span>
            <span class="hljs-keyword">if</span> (GetTime() &gt;= nNow + <span class="hljs-number">60</span>) {
                nNow = GetTime();
                LogPrintf(<span class="hljs-string">"Still rescanning. At block %d. Progress=%f\n"</span>, pindex-&gt;nHeight, Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), pindex));
            }
        }
        ShowProgress(_(<span class="hljs-string">"Rescanning..."</span>), <span class="hljs-number">100</span>); <span class="hljs-comment">// hide progress dialog in GUI</span>
    }
       <span class="hljs-keyword">return</span> ret;
}</code></pre> 
  <hr> 
  <h3 id="zapwallettxes-1">zapwallettxes</h3> 
  <p>这个函数的最后还是zapwallettxes参数，恢复钱包交易元数据，前面是删除了内容</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">// Restore wallet transaction metadata after -zapwallettxes=1</span>
        <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-zapwallettxes"</span>, <span class="hljs-literal">false</span>) <span class="hljs-subst">&amp;&amp;</span> GetArg(<span class="hljs-string">"-zapwallettxes"</span>, <span class="hljs-string">"1"</span>) <span class="hljs-subst">!=</span> <span class="hljs-string">"2"</span>)
        {
            CWalletDB walletdb(walletFile);

            BOOST_FOREACH(const CWalletTx<span class="hljs-subst">&amp;</span> wtxOld, vWtx)
            {
                uint256 hash <span class="hljs-subst">=</span> wtxOld<span class="hljs-built_in">.</span>GetHash();
                std<span class="hljs-tag">::map</span><span class="hljs-subst">&lt;</span>uint256, CWalletTx<span class="hljs-subst">&gt;</span><span class="hljs-tag">::iterator</span> mi <span class="hljs-subst">=</span> walletInstance<span class="hljs-subst">-&gt;</span>mapWallet<span class="hljs-built_in">.</span>find(hash);
                <span class="hljs-keyword">if</span> (mi <span class="hljs-subst">!=</span> walletInstance<span class="hljs-subst">-&gt;</span>mapWallet<span class="hljs-built_in">.</span>end())
                {
                    const CWalletTx<span class="hljs-subst">*</span> copyFrom <span class="hljs-subst">=</span> <span class="hljs-subst">&amp;</span>wtxOld;
                    CWalletTx<span class="hljs-subst">*</span> copyTo <span class="hljs-subst">=</span> <span class="hljs-subst">&amp;</span>mi<span class="hljs-subst">-&gt;</span>second;
                    copyTo<span class="hljs-subst">-&gt;</span>mapValue <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>mapValue;
                    copyTo<span class="hljs-subst">-&gt;</span>vOrderForm <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>vOrderForm;
                    copyTo<span class="hljs-subst">-&gt;</span>nTimeReceived <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>nTimeReceived;
                    copyTo<span class="hljs-subst">-&gt;</span>nTimeSmart <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>nTimeSmart;
                    copyTo<span class="hljs-subst">-&gt;</span>fFromMe <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>fFromMe;
                    copyTo<span class="hljs-subst">-&gt;</span>strFromAccount <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>strFromAccount;
                    copyTo<span class="hljs-subst">-&gt;</span>nOrderPos <span class="hljs-subst">=</span> copyFrom<span class="hljs-subst">-&gt;</span>nOrderPos;
                    walletdb<span class="hljs-built_in">.</span>WriteTx(<span class="hljs-subst">*</span>copyTo);
                }
            }
        }
    }
    walletInstance<span class="hljs-subst">-&gt;</span>SetBroadcastTransactions(GetBoolArg(<span class="hljs-string">"-walletbroadcast"</span>, DEFAULT_WALLETBROADCAST));

    pwalletMain <span class="hljs-subst">=</span> walletInstance;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</code></pre> 
  <p>最后给<code>pwalletMain</code>赋值为钱包实例，并返回<code>true</code>.</p> 
  <hr> 
  <p>云里雾里的。。。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81739999,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81739999,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
