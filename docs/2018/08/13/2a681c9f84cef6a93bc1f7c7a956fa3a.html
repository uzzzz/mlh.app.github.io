<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊的共识机制 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊的共识机制" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在开始之前，我们补充一点基础知识。 &nbsp; 第一个概念是哈希。简单理解，哈希是一个函数。它的作用是将任意长度的数据作为输入，转变为固定长度的一个字符串作为输出。这个函数有两个主要特点： 过程不可逆 对输入做微小改动，输出就会完全不一样。 哈希函数有好多种，但都满足上面的特点。几乎任何加密货币都会用到哈希算法，以太坊采用的哈希算法是ethash算法。 &nbsp; 第二个补充知识是，以太坊的区块结构。一个以太坊区块包含区块头和区块内容。 区块内容就是区块所包含的交易列表。而区块头中包含了如下信息： 前一个区块的哈希、区块序号（n）、随机数（nonce）、目标值（target）、时间戳（timestamp）、难度值（difficulty）、矿工地址（address）等内容。 &nbsp; 好了，介绍完上述基础，我们正式开始本文的内容。 &nbsp; 以太坊共有四个阶段，即Frontier（前沿）、Homestead（家园）、Metropolis（大都会）、Serenity（宁静）。以太坊前三个阶段采用的是POW共识机。第四个阶段将采用自己创建的POS机制，名为Casper投注共识，这种机制增加了惩罚机制，并基于POS的思想在记账节点中选取验证人。 &nbsp; 首先介绍以太坊前三阶段使用的POW机制。我们在上节课中讲到，POW机制的基本原理是下面这个公式： 计算值&lt;目标值 &nbsp; 下面我们具体来看。在以太坊中 f(h, n) &lt;M / d &nbsp; 我们先看目标值 M / d 其中M是一个常数，数值非常非常大，取2^256-1 d是当前区块的难度值， d=pd + pd//2048*max( 1-(t-pt)//10,-99 ) + int(&nbsp; 2** (n//100000-2)&nbsp; ) 其中，pd：前一个区块的难度值 t：当前区块的时间戳 pt：前一个区块的时间戳 n：当前区块的区块序号 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，是为了使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 &nbsp; 难度系数变大，目标值M / d就越小，所以要计算出满足要求的计算值就越难，这就是难度系数的意思。 &nbsp; 再看计算值f(h, n)。f()这个函数表示一个概念函数，代表一系列的复杂运算。其中输入参数，h和n分别是，区块头Header的哈希值、以及Header中的随机数Nonce。 计算机的整个挖矿过程，大致可以认为是计算机不断调整尝试Nonce的值，再将计算出的f(h, n)与目标值比较。这就是工作量证明，证明你一直在进行计算工作。因为我们默认，只有你在不算尝试计算，才能找到那个对的nonce。虽然这其中有一定的运气成分，但我们现实生活中也有很多地方是看结果来证明你的工作量，这很好理解啊，你拿到了文凭，我就默认你花过时间学习了。 这就是以太坊的pow过程，具体的源代码，详见文末。 &nbsp; 好，我们接下来看以太坊第四阶段的共识机制casper。这就是pos的一种。但它有自己的特点： 在有些情况下，矿工的币不但不会增加，反而会减少。为什么呢，我们来看看 &nbsp; 在casper共识机制中，矿工要拿出保证金对他认为的大概率胜出的区块进行下注。如果赌对了，他们就可以拿回保证金外加区块中的交易费用，也许还会有一些新发的货币；如果下注没有迅速达成一致，他们只能拿回部分保证金，相当于损失了一些保证金。因此数个回合之后矿工的下注分布就会收敛。一旦结果出来，那些选错的矿工就会输掉他们的保证金。此外如果矿工过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，他将被严惩。如此朝三暮四的人在区块链中也是不受欢迎的啊。这条规则确保了矿工只有在非常确信其他人也认为某个块有高概率胜出时才下注。我们通过这个机制来确保不会出现下注先收敛于一个结果然后又收敛到另外一个结果的情况。（将该段的情况简单体现在一个PPT页面里）。这就是casper的大致工作机理，由于以太坊目前还没有发布第四个版本，更多细节以后有机会再交流。 &nbsp; &nbsp; &nbsp; 源代码： func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash&nbsp;&nbsp; = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number&nbsp; = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = int64(0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce&nbsp;&nbsp;&nbsp; = seed &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; logger := log.New(&quot;miner&quot;, id) &nbsp;&nbsp;&nbsp; logger.Trace(&quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don‘t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % (1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n)&nbsp; &lt;=&nbsp; M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header.MixDigest = common.BytesToHash(digest) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.Trace(&quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } } //代码位置consensus/ethash/sealer.go &nbsp; 想了解更多？关注我们就够了。 公众号：ipfscom 微信（Q）：18191727 Q群：71789361 微信扫一扫，加入知识星球 &nbsp; 阅读更多" />
<meta property="og:description" content="在开始之前，我们补充一点基础知识。 &nbsp; 第一个概念是哈希。简单理解，哈希是一个函数。它的作用是将任意长度的数据作为输入，转变为固定长度的一个字符串作为输出。这个函数有两个主要特点： 过程不可逆 对输入做微小改动，输出就会完全不一样。 哈希函数有好多种，但都满足上面的特点。几乎任何加密货币都会用到哈希算法，以太坊采用的哈希算法是ethash算法。 &nbsp; 第二个补充知识是，以太坊的区块结构。一个以太坊区块包含区块头和区块内容。 区块内容就是区块所包含的交易列表。而区块头中包含了如下信息： 前一个区块的哈希、区块序号（n）、随机数（nonce）、目标值（target）、时间戳（timestamp）、难度值（difficulty）、矿工地址（address）等内容。 &nbsp; 好了，介绍完上述基础，我们正式开始本文的内容。 &nbsp; 以太坊共有四个阶段，即Frontier（前沿）、Homestead（家园）、Metropolis（大都会）、Serenity（宁静）。以太坊前三个阶段采用的是POW共识机。第四个阶段将采用自己创建的POS机制，名为Casper投注共识，这种机制增加了惩罚机制，并基于POS的思想在记账节点中选取验证人。 &nbsp; 首先介绍以太坊前三阶段使用的POW机制。我们在上节课中讲到，POW机制的基本原理是下面这个公式： 计算值&lt;目标值 &nbsp; 下面我们具体来看。在以太坊中 f(h, n) &lt;M / d &nbsp; 我们先看目标值 M / d 其中M是一个常数，数值非常非常大，取2^256-1 d是当前区块的难度值， d=pd + pd//2048*max( 1-(t-pt)//10,-99 ) + int(&nbsp; 2** (n//100000-2)&nbsp; ) 其中，pd：前一个区块的难度值 t：当前区块的时间戳 pt：前一个区块的时间戳 n：当前区块的区块序号 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，是为了使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 &nbsp; 难度系数变大，目标值M / d就越小，所以要计算出满足要求的计算值就越难，这就是难度系数的意思。 &nbsp; 再看计算值f(h, n)。f()这个函数表示一个概念函数，代表一系列的复杂运算。其中输入参数，h和n分别是，区块头Header的哈希值、以及Header中的随机数Nonce。 计算机的整个挖矿过程，大致可以认为是计算机不断调整尝试Nonce的值，再将计算出的f(h, n)与目标值比较。这就是工作量证明，证明你一直在进行计算工作。因为我们默认，只有你在不算尝试计算，才能找到那个对的nonce。虽然这其中有一定的运气成分，但我们现实生活中也有很多地方是看结果来证明你的工作量，这很好理解啊，你拿到了文凭，我就默认你花过时间学习了。 这就是以太坊的pow过程，具体的源代码，详见文末。 &nbsp; 好，我们接下来看以太坊第四阶段的共识机制casper。这就是pos的一种。但它有自己的特点： 在有些情况下，矿工的币不但不会增加，反而会减少。为什么呢，我们来看看 &nbsp; 在casper共识机制中，矿工要拿出保证金对他认为的大概率胜出的区块进行下注。如果赌对了，他们就可以拿回保证金外加区块中的交易费用，也许还会有一些新发的货币；如果下注没有迅速达成一致，他们只能拿回部分保证金，相当于损失了一些保证金。因此数个回合之后矿工的下注分布就会收敛。一旦结果出来，那些选错的矿工就会输掉他们的保证金。此外如果矿工过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，他将被严惩。如此朝三暮四的人在区块链中也是不受欢迎的啊。这条规则确保了矿工只有在非常确信其他人也认为某个块有高概率胜出时才下注。我们通过这个机制来确保不会出现下注先收敛于一个结果然后又收敛到另外一个结果的情况。（将该段的情况简单体现在一个PPT页面里）。这就是casper的大致工作机理，由于以太坊目前还没有发布第四个版本，更多细节以后有机会再交流。 &nbsp; &nbsp; &nbsp; 源代码： func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash&nbsp;&nbsp; = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number&nbsp; = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = int64(0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce&nbsp;&nbsp;&nbsp; = seed &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; logger := log.New(&quot;miner&quot;, id) &nbsp;&nbsp;&nbsp; logger.Trace(&quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don‘t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % (1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n)&nbsp; &lt;=&nbsp; M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header.MixDigest = common.BytesToHash(digest) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.Trace(&quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } } //代码位置consensus/ethash/sealer.go &nbsp; 想了解更多？关注我们就够了。 公众号：ipfscom 微信（Q）：18191727 Q群：71789361 微信扫一扫，加入知识星球 &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/13/2a681c9f84cef6a93bc1f7c7a956fa3a.html" />
<meta property="og:url" content="https://mlh.app/2018/08/13/2a681c9f84cef6a93bc1f7c7a956fa3a.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在开始之前，我们补充一点基础知识。 &nbsp; 第一个概念是哈希。简单理解，哈希是一个函数。它的作用是将任意长度的数据作为输入，转变为固定长度的一个字符串作为输出。这个函数有两个主要特点： 过程不可逆 对输入做微小改动，输出就会完全不一样。 哈希函数有好多种，但都满足上面的特点。几乎任何加密货币都会用到哈希算法，以太坊采用的哈希算法是ethash算法。 &nbsp; 第二个补充知识是，以太坊的区块结构。一个以太坊区块包含区块头和区块内容。 区块内容就是区块所包含的交易列表。而区块头中包含了如下信息： 前一个区块的哈希、区块序号（n）、随机数（nonce）、目标值（target）、时间戳（timestamp）、难度值（difficulty）、矿工地址（address）等内容。 &nbsp; 好了，介绍完上述基础，我们正式开始本文的内容。 &nbsp; 以太坊共有四个阶段，即Frontier（前沿）、Homestead（家园）、Metropolis（大都会）、Serenity（宁静）。以太坊前三个阶段采用的是POW共识机。第四个阶段将采用自己创建的POS机制，名为Casper投注共识，这种机制增加了惩罚机制，并基于POS的思想在记账节点中选取验证人。 &nbsp; 首先介绍以太坊前三阶段使用的POW机制。我们在上节课中讲到，POW机制的基本原理是下面这个公式： 计算值&lt;目标值 &nbsp; 下面我们具体来看。在以太坊中 f(h, n) &lt;M / d &nbsp; 我们先看目标值 M / d 其中M是一个常数，数值非常非常大，取2^256-1 d是当前区块的难度值， d=pd + pd//2048*max( 1-(t-pt)//10,-99 ) + int(&nbsp; 2** (n//100000-2)&nbsp; ) 其中，pd：前一个区块的难度值 t：当前区块的时间戳 pt：前一个区块的时间戳 n：当前区块的区块序号 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，是为了使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 &nbsp; 难度系数变大，目标值M / d就越小，所以要计算出满足要求的计算值就越难，这就是难度系数的意思。 &nbsp; 再看计算值f(h, n)。f()这个函数表示一个概念函数，代表一系列的复杂运算。其中输入参数，h和n分别是，区块头Header的哈希值、以及Header中的随机数Nonce。 计算机的整个挖矿过程，大致可以认为是计算机不断调整尝试Nonce的值，再将计算出的f(h, n)与目标值比较。这就是工作量证明，证明你一直在进行计算工作。因为我们默认，只有你在不算尝试计算，才能找到那个对的nonce。虽然这其中有一定的运气成分，但我们现实生活中也有很多地方是看结果来证明你的工作量，这很好理解啊，你拿到了文凭，我就默认你花过时间学习了。 这就是以太坊的pow过程，具体的源代码，详见文末。 &nbsp; 好，我们接下来看以太坊第四阶段的共识机制casper。这就是pos的一种。但它有自己的特点： 在有些情况下，矿工的币不但不会增加，反而会减少。为什么呢，我们来看看 &nbsp; 在casper共识机制中，矿工要拿出保证金对他认为的大概率胜出的区块进行下注。如果赌对了，他们就可以拿回保证金外加区块中的交易费用，也许还会有一些新发的货币；如果下注没有迅速达成一致，他们只能拿回部分保证金，相当于损失了一些保证金。因此数个回合之后矿工的下注分布就会收敛。一旦结果出来，那些选错的矿工就会输掉他们的保证金。此外如果矿工过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，他将被严惩。如此朝三暮四的人在区块链中也是不受欢迎的啊。这条规则确保了矿工只有在非常确信其他人也认为某个块有高概率胜出时才下注。我们通过这个机制来确保不会出现下注先收敛于一个结果然后又收敛到另外一个结果的情况。（将该段的情况简单体现在一个PPT页面里）。这就是casper的大致工作机理，由于以太坊目前还没有发布第四个版本，更多细节以后有机会再交流。 &nbsp; &nbsp; &nbsp; 源代码： func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash&nbsp;&nbsp; = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number&nbsp; = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = int64(0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce&nbsp;&nbsp;&nbsp; = seed &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; logger := log.New(&quot;miner&quot;, id) &nbsp;&nbsp;&nbsp; logger.Trace(&quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don‘t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % (1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n)&nbsp; &lt;=&nbsp; M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header.MixDigest = common.BytesToHash(digest) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(&quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.Trace(&quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } } //代码位置consensus/ethash/sealer.go &nbsp; 想了解更多？关注我们就够了。 公众号：ipfscom 微信（Q）：18191727 Q群：71789361 微信扫一扫，加入知识星球 &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/13/2a681c9f84cef6a93bc1f7c7a956fa3a.html","headline":"以太坊的共识机制","dateModified":"2018-08-13T00:00:00+08:00","datePublished":"2018-08-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/13/2a681c9f84cef6a93bc1f7c7a956fa3a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊的共识机制</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="margin-left:0cm;">在开始之前，我们补充一点基础知识。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">第一个概念是哈希。简单理解，</span><span style="color:#FF0000;">哈希是一个函数</span><span style="color:#3f3f3f;">。它的作用是将</span><span style="color:#FF0000;">任意长度的数据作为输入</span><span style="color:#3f3f3f;">，转变为</span><span style="color:#FF0000;">固定长度的一个字符串作为输出</span><span style="color:#3f3f3f;">。这个函数有两个主要</span><span style="color:#FF0000;">特点</span><span style="color:#3f3f3f;">：</span></p> 
  <ol>
   <li><span style="color:#FF0000;">过程不可逆</span></li> 
   <li><span style="color:#FF0000;">对输入做微小改动，输出就会完全不一样。</span></li> 
  </ol>
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">哈希函数有好多种，但都满足上面的特点。几乎任何加密货币都会用到哈希算法，以太坊采用的哈希算法是</span><span style="color:#FF0000;">ethash</span><span style="color:#FF0000;">算法</span><span style="color:#3f3f3f;">。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">第二个补充知识是，以太坊的区块结构。一个以太坊区块包含</span><span style="color:#FF0000;">区块头和区块内容</span><span style="color:#3f3f3f;">。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#FF0000;">区块内容就是区块所包含的交易列表</span><span style="color:#3f3f3f;">。而区块头中包含了如下信息：</span></p> 
  <p style="margin-left:0cm;"><span style="color:#FF0000;">前一个区块的哈希、区块序号（</span><span style="color:#FF0000;">n</span><span style="color:#FF0000;">）、随机数（</span><span style="color:#FF0000;">nonce</span><span style="color:#FF0000;">）、目标值（</span><span style="color:#FF0000;">target</span><span style="color:#FF0000;">）、时间戳（</span><span style="color:#FF0000;">timestamp</span><span style="color:#FF0000;">）、难度值（</span><span style="color:#FF0000;">difficulty</span><span style="color:#FF0000;">）、矿工地址（</span><span style="color:#FF0000;">address</span><span style="color:#FF0000;">）等内容</span><span style="color:#3f3f3f;">。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">好了，介绍完上述基础，我们正式开始本文的内容。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">以太坊共有四个阶段，即<span style="color:#FF0000;">Frontier</span><span style="color:#FF0000;">（前沿）、</span><span style="color:#FF0000;">Homestead</span><span style="color:#FF0000;">（家园）、</span><span style="color:#FF0000;">Metropolis</span><span style="color:#FF0000;">（大都会）、</span><span style="color:#FF0000;">Serenity</span><span style="color:#FF0000;">（宁静）。以太坊前三个阶段采用的是</span><span style="color:#FF0000;">POW</span><span style="color:#FF0000;">共识机。第四个阶段将采用自己创建的</span><span style="color:#FF0000;">POS</span>机制，名为<span style="color:#FF0000;">Casper</span><span style="color:#FF0000;">投注共识</span>，这种机制增加了惩罚机制，并基于POS的思想在记账节点中选取验证人。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">首先介绍以太坊前三阶段使用的POW机制。我们在上节课中讲到，POW机制的基本原理是下面这个公式：</p> 
  <p style="margin-left:0cm;">计算值&lt;目标值</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">下面我们具体来看。<span style="color:#3f3f3f;">在以太坊中</span></p> 
  <blockquote> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">f(h, n) &lt;M / d</span></p> 
  </blockquote> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">我们先看目标值</span></p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">M / d</span></p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">其中</span><span style="color:#3f3f3f;">M</span><span style="color:#3f3f3f;">是一个常数，数值非常非常大，取</span><span style="color:#3f3f3f;">2^256-1</span></p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">d</span><span style="color:#3f3f3f;">是当前区块的难度值，</span></p> 
  <blockquote> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">d=pd + pd//2048*max( 1-(t-pt)//10,-99 ) + int(&nbsp; 2** (n//100000-2)&nbsp; )</span></p> 
  </blockquote> 
  <p style="margin-left:0cm;">其中，pd：前一个区块的难度值</p> 
  <p style="margin-left:0cm;">t：当前区块的时间戳</p> 
  <p style="margin-left:0cm;">pt：前一个区块的时间戳</p> 
  <p style="margin-left:0cm;">n：当前区块的区块序号</p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">其中</span><span style="color:#3f3f3f;">//</span><span style="color:#3f3f3f;">为整数除法运算符，</span><span style="color:#3f3f3f;">a//b</span><span style="color:#3f3f3f;">，即先计算</span><span style="color:#3f3f3f;">a/b</span><span style="color:#3f3f3f;">，然后取不大于</span><span style="color:#3f3f3f;">a/b</span><span style="color:#3f3f3f;">的最大整数。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">调整难度的目的，是为了使挖矿时间保持在</span><span style="color:#3f3f3f;">10-19s</span><span style="color:#3f3f3f;">期间内，如果低于</span><span style="color:#3f3f3f;">10s</span><span style="color:#3f3f3f;">增大挖矿难度，如果大于</span><span style="color:#3f3f3f;">19s</span><span style="color:#3f3f3f;">将减小难度。另外，计算出的当前区块难度不应低于以太坊创世区块难度，即</span><span style="color:#3f3f3f;">131072</span><span style="color:#3f3f3f;">。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">难度系数变大，目标值<span style="color:#3f3f3f;">M / d</span><span style="color:#3f3f3f;">就越小，所以要计算出满足要求的计算值就越难，这就是难度系数的意思。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">再看计算值</span><span style="color:#3f3f3f;">f(h, n)</span><span style="color:#3f3f3f;">。</span><span style="color:#3f3f3f;">f()</span><span style="color:#3f3f3f;">这个函数表示一个概念函数，代表一系列的复杂运算。</span><span style="color:#FF0000;">其中输入参数，</span><span style="color:#FF0000;">h</span><span style="color:#FF0000;">和</span><span style="color:#FF0000;">n</span><span style="color:#FF0000;">分别是，区块头</span><span style="color:#FF0000;">Header</span><span style="color:#FF0000;">的哈希值、以及</span><span style="color:#FF0000;">Header</span><span style="color:#FF0000;">中的随机数</span><span style="color:#FF0000;">Nonce</span><span style="color:#3f3f3f;">。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#3f3f3f;">计算机的整个挖矿过程，大致可以认为是计算机不断调整尝试</span><span style="color:#3f3f3f;">Nonce</span><span style="color:#3f3f3f;">的值，再将计算出的</span><span style="color:#3f3f3f;">f(h, n)</span><span style="color:#3f3f3f;">与目标值比较</span><span style="color:#3f3f3f;">。这就是</span><span style="color:#FF0000;">工作量证明</span><span style="color:#3f3f3f;">，证明你一直在进行计算工作。因为我们默认，只有你在不算尝试计算，才能找到那个对的</span><span style="color:#3f3f3f;">nonce</span><span style="color:#3f3f3f;">。虽然这其中有一定的运气成分，但我们现实生活中也有很多地方是看结果来证明你的工作量，这很好理解啊，你拿到了文凭，我就默认你花过时间学习了。</span></p> 
  <p style="margin-left:0cm;">这就是以太坊的pow过程，具体的源代码，详见文末。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">好，我们接下来看以太坊第四阶段的共识机制casper。这就是pos的一种。但它有自己的特点：</p> 
  <p style="margin-left:0cm;"><span style="color:#FF0000;">在有些情况下，矿工的币不但不会增加，反而会减少</span>。为什么呢，我们来看看</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">在casper共识机制中，矿工要拿出保证金对他认为的<span style="color:#FF0000;">大概率胜出的区块进行下注</span>。如果<span style="color:#FF0000;">赌对</span>了，他们就可以拿回保证金外加区块中的交易费用，也许还会有一些新发的货币；如果下注没有迅速达成一致，他们只能拿回部分保证金，相当于损失了一些保证金。因此数个回合之后矿工的下注分布就会收敛。一旦结果出来，那些选错的矿工就会输掉他们的保证金。此外如果矿工过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，他将被严惩。如此朝三暮四的人在区块链中也是不受欢迎的啊。这条规则确保了矿工只有在非常确信其他人也认为某个块有高概率胜出时才下注。我们通过这个机制来确保不会出现下注先收敛于一个结果然后又收敛到另外一个结果的情况。（将该段的情况简单体现在一个PPT页面里）。这就是casper的大致工作机理，由于以太坊目前还没有发布第四个版本，更多细节以后有机会再交流。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#3e3e3e;">源代码：</span></p> 
  <blockquote> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; // Extract some data from the header</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; var (</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = block.Header()</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash&nbsp;&nbsp; = header.HashNoNonce().Bytes()</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target</span><span style="color:#3f3f3f;">，即</span><span style="color:#3f3f3f;">M / d</span><span style="color:#3f3f3f;">，即</span><span style="color:#3f3f3f;">(2^256-1)/Difficulty</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target = new(big.Int).Div(maxUint256, header.Difficulty)</span></p> 
   <p style="margin-left:0cm;">&nbsp;</p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number&nbsp; = header.Number.Uint64()</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataset = ethash.dataset(number)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; )</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; var (</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = int64(0)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce&nbsp;&nbsp;&nbsp; = seed</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; )</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; logger := log.New("miner", id)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; logger.Trace("Started ethash search for new nonces", "seed", seed)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; for {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort:</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace("Ethash nonce search aborted", "attempts", nonce-seed)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</span></p> 
   <p style="margin-left:0cm;">&nbsp;</p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don‘t have to update hash rate on every nonce, so update after after 2^X nonces</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts++</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % (1 &lt;&lt; 15)) == 0 {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethash.hashrate.Mark(attempts)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts = 0</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull</span><span style="color:#3f3f3f;">即</span><span style="color:#3f3f3f;">RAND(h, n)</span><span style="color:#3f3f3f;">所代表的一系列的复杂运算</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digest, result := hashimotoFull(dataset, hash, nonce)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result</span><span style="color:#3f3f3f;">满足</span><span style="color:#3f3f3f;">RAND(h, n)&nbsp; &lt;=&nbsp; M / d</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = types.CopyHeader(header)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header.MixDigest = common.BytesToHash(digest)</span></p> 
   <p style="margin-left:0cm;">&nbsp;</p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select {</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header):</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace("Ethash nonce found and reported", "attempts", nonce-seed, "nonce", nonce)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort:</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.Trace("Ethash nonce found but discarded", "attempts", nonce-seed, "nonce", nonce)</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span style="color:#3f3f3f;">不断变更</span><span style="color:#3f3f3f;">Nonce</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonce++</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">}</span></p> 
   <p style="margin-left:0cm;"><span style="color:#3f3f3f;">//</span><span style="color:#3f3f3f;">代码位置</span><span style="color:#3f3f3f;">consensus/ethash/sealer.go</span></p> 
  </blockquote> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p><strong>想了解更多？关注我们就够了。</strong></p> 
  <p><strong>公众号：ipfscom<br> 微信（Q）：18191727<br> Q群：71789361<br> 微信扫一扫，加入知识星球</strong></p> 
  <p><br><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180807140441322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ2NpeXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/angciyu/article/details/81629508,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/angciyu/article/details/81629508,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
