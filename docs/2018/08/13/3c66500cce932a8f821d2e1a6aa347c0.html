<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【区块链】一起玩转9类共识机制 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【区块链】一起玩转9类共识机制" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="简介 目前大多数国家的现有银行系统中，所有银行都是通过中央的电子账本进行账目核对的。这是一个中心化的结构，越靠近中心的机构，权限越多，存储的数据量越多。而为了维护这个中心化系统中所有数据的准确性，银行需要付出巨大的运营成本。 而凭借去中心化的特点，区块链技术可以为银行创建一个分布式的公开可查的网络，其中的所有交易数据是透明和共享的。利用区块链技术进行分布式记账可以削减无效的银行中介，节省很多运营成本。 今天，我们主要来介绍一下区块链的共识机制。 区块链9类共识机制 工作量证明（PoW） 比特币在区块的生成过程中使用了PoW机制，一个符合要求的区块哈希值由N个前导零构成，零的个数取决于网络的难度值。要得到合理的区块哈希值，要经过大量的尝试计算，计算时间取决于机器的哈希运算速度。 当某个节点提供出一个合理的区块哈希值，说明该节点确实经过了大量的尝试计算，当然，这并不能得出计算次数的绝对值，因为寻找合理的哈希值是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n%的概率找到区块哈希值。 Pow依赖机器进行数学运算来获取记账权，资源消耗大、共识机制高、可监管性弱，同时每次达成共识需要全网共同参与运算，性能效率比较低，容错性方面允许全网50%节点出错。 - 优点：完全去中心化，节点自由进出 - 缺点：比特币已经吸引全球大部分的算力，再使用PoW共识机制的区块链应用很难获取相同的算力来保障自身安全。同时，挖矿造成大量的资源浪费；共识达成的周期较长。 权益证明（PoS） 主要理念：相比PoW，节点记账权的获得难度与节点持有的权益成反比，其在一定程度上减少了数学运算带来的资源消耗，性能也得到相应提升。PoS也是基于哈希运算，通过竞争的方式获得记账权。可以说，PoS是PoW的一种升级，其根据每个节点所占代币的比利和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。 在这个系统中，存在一个持币人集合，他们把手中的代币放入POS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块，PoS算法在验证者中随机选取一个，给其权利产生下一个区块。通常，选择验证者的权重依据他们投入的代币量，投入的越多，权重越大。 如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生，以此类推。 - 优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。 - 缺点：仍然需要通过挖矿来实现；所有的确认只是一个概率上的表达，而非一个确定性的事情，理论上仍有可能存在其他攻击影响。 股权授权证明（DPoS） 其与PoS主要区别在于节点选举若干代理人，然后由这些代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。 你可以想象成董事会投票，持币者投出一定数量的节点，进行代理验证和记账。 工作原理：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其目标是通过及时而高效的方法达到让“51%通过”。 为了达到这个目标，每个股东可以将其投票权授予一名代表。获得票数最多的前100位代表按既定时间表轮流产生区块。每位代表分配到一个时间段来产生区块。 所有的代表将收到等同于一个平均水平的区块所含交易费的10%作为报酬。如果一个平均水平的区块用100股作为交易费，一位代表将获得一股作为报酬。 DPoS的投票可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即便发生也可以在几分钟内得到解决。执行该模式的基本步骤： 1、成为代表。先在网络上注册你的公钥，该公钥是一个32位的标识符。该标识符会被每笔交易数据的“头部”引用。 2、授权投票。每个钱包有一个参数设置窗口，在该窗口里用户可以选择一位或更多的代表，并将其分级。一经设定，用户所做的每笔交易将把选票从“输入代表”转移到“输出代表”。 3、保持代表诚实。每个钱包都会配有一个状态指示器，让用户知道他们的代表表现如何。 4、抵抗攻击。每位代表都有一项平等的投票权，因此，无法通过获得超过1%的选票而将权利集中到单一代表上。由于每位代表的标识是公钥，因而攻击者很难对每位代表进行攻击。 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。 投注共识（Casper）——以太坊下一代共识机制 为了防止验证人在不同的世界中提供不同的投注，还需要一个条款：如果你两次的投注序号一样，或者说你提交了一个无法让Casper依照合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是，Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。 出块：独立于其他所有事件而发生的过程，验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，并签名，然后发生到网络上。 投注：目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。 客户端确认过程： 1、下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见； 2、简单地按顺序在每个高度进行观察，如果一个区块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后所得到的状态就可以显示为区块链的“当前状态”。 同时，客户端还可以给出对于“最终确定”的主观看法：如果高度k之前的每个区块形成的意见高于99.9999%或者低于0.001%，那么客户端就可以认为前k个区块已经最终确定。 瑞波共识机制 该算法使一组节点能够基于特殊节点列表形成共识。 初始的特殊节点列表可以看成一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。即，该共识遵循该俱乐部核心成员的“51%全力”，外部人员则没有影响力。 但是，由于该俱乐部是由中心化构成的，所以一旦它腐败，就会失去意义。 Pool（联营）验证池 Pool验证池基于传统的分布式一致性技术和数据验证机制。目前是行业内大范围使用的机制。 优点：不需要代币也能工作；在成熟的分布式一致性算法（Pasox、Raft）的基础上，实现秒级共识验证。 缺点：去中心化程度不高，不如比特币，其更适合多方参与的多中心商业模式。 帕克索斯算法 传统分布式一致性算法，基于选举领导者的共识机制。 领导者拥有绝对权限，并允许强监管节点参与。 优点：性能高，资源消耗低。 缺点：所有节点一般都有线下准入机制，但选举过程中不允许有作恶节点，不具备容错性。 实用拜占庭容错（PBFT） 有一问题：在分布式计算上，不同的计算机通过信息交换尝试达成共识，但有时候，系统中的协调计算机或成员计算机可能因系统错误交换错的信息，以至于影响最终的系统一致性。 通常我们上述这样的问题，称为“拜占庭将军”问题。 那么有什么解决方法呢？ 早在1999年，卡斯特罗和利斯夫提出的实用拜占庭算法，该算法认为只要系统中有2/3的节点是正常工作的，就可以保证一致性。 总体过程如下： 客户端向主节点发送请求调用服务操作，如&quot;&lt;REQUEST,o,t,c&gt;&quot;——客户端c请求执行操作o，时间戳t用来保证客户端请求只会执行一次。每个由副本节点发给客户端的消息都包含了当前的视图编号，使得客户端能够追踪视图编号，使得客户端能够追踪视图编号，从而进一步推算出当前主节点的编号。客户端通过点对点消息向它认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。 注： 视图编号是连续编号的整数。主节点由公式p = v mod |R| （v：视图编号，p：副本编号，|R|副本集合的个数） 副本发给客户端的响应为&quot;&lt;REPLY,v,t,c,i,r&gt;&quot;，v是视图编号，t是时间戳，i是副本编号，r是请求执行的结果。 接着，主节点广播请求给其他副本，然后就开始执行三个阶段的任务： 1、预准备阶段。主节点分配一个序列号n 给收到的请求，然后向所有备份节点群发预备消息，预备消息的格式：&quot;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;&quot;。（v：视图编号，m：客户端发送的请求消息，d：请求消息m的摘要） 2、准备阶段。如果备份节点 i 接受了预备消息，则进入准备阶段。在准备的同时，该节点向所有副本节点发送准备消息&quot;&lt;PREPARE,v,n,d,i&gt;&quot;,并且将预准备消息和准备消息写入自己的消息日志。 3、确认阶段。当&quot;（m,v,n,i）&quot;条件为真的时候，副本 i 将 &quot;&lt;COMIT,v,n,D（m）, i&gt;&quot;向其他副本节点广播，然后进入确认阶段。所哟副本都执行请求并将结果发回客户端。客户端需要等待不同副本节点发回相同的结果，作为整个操作的最终结果。 注意： 如果客户端没有在有限时间内收到回复，请求将向所有副本节点进行广播； 但是会出现几种情况： 1、如果该请求已经在副本节点处理过，副本就向客户端重发一遍执行结果； 2、如果该请求没有在副本节点处理过，该副本节点将把请求转发给主节点； 3、如果主节点没有将该请求进行广播，那么认为主节点失效； 4、如果有足够多的副本节点认为主节点失效，则会触发一次视图变更。 实用拜占庭容错机制，是一种采用”许可投票、少数服从多数“来选举领导者并进行记账的共识机制，该机制允许拜占庭容错，允许强监管节点参与，具备权限分级能力，性能更高，耗能更低，而且每轮记账都会由全网节点共同选举领导者，允许33%的节点作恶，容错性为33%。 应用场景：联盟链 授权拜占庭容错 该机制由国内的小蚁公司提出，是一种改进的拜占庭容错算法。 改进如下： 1、将C/S架构的请求响应模式改进为适合P2P网络的对等节点模式 2、将静态的共识参与节点改进为可动态进入、退出的共识参与节点； 3、为共识参与节点的产生设计一套基于持有权益比例的投票机制，通过投票决定共识参与节点（记账节点） 4、在区块链中引入数字证书，解决投票中对记账节点真实身份的认证问题 优点：专业化的记账人；可容忍任何类型的错误；记账由多人协同完成；每一个区块都有最终性，不会分叉；算法的可靠性有严格的数学证明。 缺点：当1/3及以上的记账人停止工作后，系统将无法提供服务；当1/3及以上的记账人联合作恶，且其他所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但会留下密码学证据。 应用场景：金融 同时，欢迎关注微信公众号“小智链习社”，给予小智更多原力^_^。 阅读更多" />
<meta property="og:description" content="简介 目前大多数国家的现有银行系统中，所有银行都是通过中央的电子账本进行账目核对的。这是一个中心化的结构，越靠近中心的机构，权限越多，存储的数据量越多。而为了维护这个中心化系统中所有数据的准确性，银行需要付出巨大的运营成本。 而凭借去中心化的特点，区块链技术可以为银行创建一个分布式的公开可查的网络，其中的所有交易数据是透明和共享的。利用区块链技术进行分布式记账可以削减无效的银行中介，节省很多运营成本。 今天，我们主要来介绍一下区块链的共识机制。 区块链9类共识机制 工作量证明（PoW） 比特币在区块的生成过程中使用了PoW机制，一个符合要求的区块哈希值由N个前导零构成，零的个数取决于网络的难度值。要得到合理的区块哈希值，要经过大量的尝试计算，计算时间取决于机器的哈希运算速度。 当某个节点提供出一个合理的区块哈希值，说明该节点确实经过了大量的尝试计算，当然，这并不能得出计算次数的绝对值，因为寻找合理的哈希值是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n%的概率找到区块哈希值。 Pow依赖机器进行数学运算来获取记账权，资源消耗大、共识机制高、可监管性弱，同时每次达成共识需要全网共同参与运算，性能效率比较低，容错性方面允许全网50%节点出错。 - 优点：完全去中心化，节点自由进出 - 缺点：比特币已经吸引全球大部分的算力，再使用PoW共识机制的区块链应用很难获取相同的算力来保障自身安全。同时，挖矿造成大量的资源浪费；共识达成的周期较长。 权益证明（PoS） 主要理念：相比PoW，节点记账权的获得难度与节点持有的权益成反比，其在一定程度上减少了数学运算带来的资源消耗，性能也得到相应提升。PoS也是基于哈希运算，通过竞争的方式获得记账权。可以说，PoS是PoW的一种升级，其根据每个节点所占代币的比利和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。 在这个系统中，存在一个持币人集合，他们把手中的代币放入POS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块，PoS算法在验证者中随机选取一个，给其权利产生下一个区块。通常，选择验证者的权重依据他们投入的代币量，投入的越多，权重越大。 如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生，以此类推。 - 优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。 - 缺点：仍然需要通过挖矿来实现；所有的确认只是一个概率上的表达，而非一个确定性的事情，理论上仍有可能存在其他攻击影响。 股权授权证明（DPoS） 其与PoS主要区别在于节点选举若干代理人，然后由这些代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。 你可以想象成董事会投票，持币者投出一定数量的节点，进行代理验证和记账。 工作原理：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其目标是通过及时而高效的方法达到让“51%通过”。 为了达到这个目标，每个股东可以将其投票权授予一名代表。获得票数最多的前100位代表按既定时间表轮流产生区块。每位代表分配到一个时间段来产生区块。 所有的代表将收到等同于一个平均水平的区块所含交易费的10%作为报酬。如果一个平均水平的区块用100股作为交易费，一位代表将获得一股作为报酬。 DPoS的投票可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即便发生也可以在几分钟内得到解决。执行该模式的基本步骤： 1、成为代表。先在网络上注册你的公钥，该公钥是一个32位的标识符。该标识符会被每笔交易数据的“头部”引用。 2、授权投票。每个钱包有一个参数设置窗口，在该窗口里用户可以选择一位或更多的代表，并将其分级。一经设定，用户所做的每笔交易将把选票从“输入代表”转移到“输出代表”。 3、保持代表诚实。每个钱包都会配有一个状态指示器，让用户知道他们的代表表现如何。 4、抵抗攻击。每位代表都有一项平等的投票权，因此，无法通过获得超过1%的选票而将权利集中到单一代表上。由于每位代表的标识是公钥，因而攻击者很难对每位代表进行攻击。 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。 投注共识（Casper）——以太坊下一代共识机制 为了防止验证人在不同的世界中提供不同的投注，还需要一个条款：如果你两次的投注序号一样，或者说你提交了一个无法让Casper依照合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是，Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。 出块：独立于其他所有事件而发生的过程，验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，并签名，然后发生到网络上。 投注：目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。 客户端确认过程： 1、下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见； 2、简单地按顺序在每个高度进行观察，如果一个区块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后所得到的状态就可以显示为区块链的“当前状态”。 同时，客户端还可以给出对于“最终确定”的主观看法：如果高度k之前的每个区块形成的意见高于99.9999%或者低于0.001%，那么客户端就可以认为前k个区块已经最终确定。 瑞波共识机制 该算法使一组节点能够基于特殊节点列表形成共识。 初始的特殊节点列表可以看成一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。即，该共识遵循该俱乐部核心成员的“51%全力”，外部人员则没有影响力。 但是，由于该俱乐部是由中心化构成的，所以一旦它腐败，就会失去意义。 Pool（联营）验证池 Pool验证池基于传统的分布式一致性技术和数据验证机制。目前是行业内大范围使用的机制。 优点：不需要代币也能工作；在成熟的分布式一致性算法（Pasox、Raft）的基础上，实现秒级共识验证。 缺点：去中心化程度不高，不如比特币，其更适合多方参与的多中心商业模式。 帕克索斯算法 传统分布式一致性算法，基于选举领导者的共识机制。 领导者拥有绝对权限，并允许强监管节点参与。 优点：性能高，资源消耗低。 缺点：所有节点一般都有线下准入机制，但选举过程中不允许有作恶节点，不具备容错性。 实用拜占庭容错（PBFT） 有一问题：在分布式计算上，不同的计算机通过信息交换尝试达成共识，但有时候，系统中的协调计算机或成员计算机可能因系统错误交换错的信息，以至于影响最终的系统一致性。 通常我们上述这样的问题，称为“拜占庭将军”问题。 那么有什么解决方法呢？ 早在1999年，卡斯特罗和利斯夫提出的实用拜占庭算法，该算法认为只要系统中有2/3的节点是正常工作的，就可以保证一致性。 总体过程如下： 客户端向主节点发送请求调用服务操作，如&quot;&lt;REQUEST,o,t,c&gt;&quot;——客户端c请求执行操作o，时间戳t用来保证客户端请求只会执行一次。每个由副本节点发给客户端的消息都包含了当前的视图编号，使得客户端能够追踪视图编号，使得客户端能够追踪视图编号，从而进一步推算出当前主节点的编号。客户端通过点对点消息向它认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。 注： 视图编号是连续编号的整数。主节点由公式p = v mod |R| （v：视图编号，p：副本编号，|R|副本集合的个数） 副本发给客户端的响应为&quot;&lt;REPLY,v,t,c,i,r&gt;&quot;，v是视图编号，t是时间戳，i是副本编号，r是请求执行的结果。 接着，主节点广播请求给其他副本，然后就开始执行三个阶段的任务： 1、预准备阶段。主节点分配一个序列号n 给收到的请求，然后向所有备份节点群发预备消息，预备消息的格式：&quot;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;&quot;。（v：视图编号，m：客户端发送的请求消息，d：请求消息m的摘要） 2、准备阶段。如果备份节点 i 接受了预备消息，则进入准备阶段。在准备的同时，该节点向所有副本节点发送准备消息&quot;&lt;PREPARE,v,n,d,i&gt;&quot;,并且将预准备消息和准备消息写入自己的消息日志。 3、确认阶段。当&quot;（m,v,n,i）&quot;条件为真的时候，副本 i 将 &quot;&lt;COMIT,v,n,D（m）, i&gt;&quot;向其他副本节点广播，然后进入确认阶段。所哟副本都执行请求并将结果发回客户端。客户端需要等待不同副本节点发回相同的结果，作为整个操作的最终结果。 注意： 如果客户端没有在有限时间内收到回复，请求将向所有副本节点进行广播； 但是会出现几种情况： 1、如果该请求已经在副本节点处理过，副本就向客户端重发一遍执行结果； 2、如果该请求没有在副本节点处理过，该副本节点将把请求转发给主节点； 3、如果主节点没有将该请求进行广播，那么认为主节点失效； 4、如果有足够多的副本节点认为主节点失效，则会触发一次视图变更。 实用拜占庭容错机制，是一种采用”许可投票、少数服从多数“来选举领导者并进行记账的共识机制，该机制允许拜占庭容错，允许强监管节点参与，具备权限分级能力，性能更高，耗能更低，而且每轮记账都会由全网节点共同选举领导者，允许33%的节点作恶，容错性为33%。 应用场景：联盟链 授权拜占庭容错 该机制由国内的小蚁公司提出，是一种改进的拜占庭容错算法。 改进如下： 1、将C/S架构的请求响应模式改进为适合P2P网络的对等节点模式 2、将静态的共识参与节点改进为可动态进入、退出的共识参与节点； 3、为共识参与节点的产生设计一套基于持有权益比例的投票机制，通过投票决定共识参与节点（记账节点） 4、在区块链中引入数字证书，解决投票中对记账节点真实身份的认证问题 优点：专业化的记账人；可容忍任何类型的错误；记账由多人协同完成；每一个区块都有最终性，不会分叉；算法的可靠性有严格的数学证明。 缺点：当1/3及以上的记账人停止工作后，系统将无法提供服务；当1/3及以上的记账人联合作恶，且其他所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但会留下密码学证据。 应用场景：金融 同时，欢迎关注微信公众号“小智链习社”，给予小智更多原力^_^。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/13/3c66500cce932a8f821d2e1a6aa347c0.html" />
<meta property="og:url" content="https://mlh.app/2018/08/13/3c66500cce932a8f821d2e1a6aa347c0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"简介 目前大多数国家的现有银行系统中，所有银行都是通过中央的电子账本进行账目核对的。这是一个中心化的结构，越靠近中心的机构，权限越多，存储的数据量越多。而为了维护这个中心化系统中所有数据的准确性，银行需要付出巨大的运营成本。 而凭借去中心化的特点，区块链技术可以为银行创建一个分布式的公开可查的网络，其中的所有交易数据是透明和共享的。利用区块链技术进行分布式记账可以削减无效的银行中介，节省很多运营成本。 今天，我们主要来介绍一下区块链的共识机制。 区块链9类共识机制 工作量证明（PoW） 比特币在区块的生成过程中使用了PoW机制，一个符合要求的区块哈希值由N个前导零构成，零的个数取决于网络的难度值。要得到合理的区块哈希值，要经过大量的尝试计算，计算时间取决于机器的哈希运算速度。 当某个节点提供出一个合理的区块哈希值，说明该节点确实经过了大量的尝试计算，当然，这并不能得出计算次数的绝对值，因为寻找合理的哈希值是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n%的概率找到区块哈希值。 Pow依赖机器进行数学运算来获取记账权，资源消耗大、共识机制高、可监管性弱，同时每次达成共识需要全网共同参与运算，性能效率比较低，容错性方面允许全网50%节点出错。 - 优点：完全去中心化，节点自由进出 - 缺点：比特币已经吸引全球大部分的算力，再使用PoW共识机制的区块链应用很难获取相同的算力来保障自身安全。同时，挖矿造成大量的资源浪费；共识达成的周期较长。 权益证明（PoS） 主要理念：相比PoW，节点记账权的获得难度与节点持有的权益成反比，其在一定程度上减少了数学运算带来的资源消耗，性能也得到相应提升。PoS也是基于哈希运算，通过竞争的方式获得记账权。可以说，PoS是PoW的一种升级，其根据每个节点所占代币的比利和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。 在这个系统中，存在一个持币人集合，他们把手中的代币放入POS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块，PoS算法在验证者中随机选取一个，给其权利产生下一个区块。通常，选择验证者的权重依据他们投入的代币量，投入的越多，权重越大。 如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生，以此类推。 - 优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。 - 缺点：仍然需要通过挖矿来实现；所有的确认只是一个概率上的表达，而非一个确定性的事情，理论上仍有可能存在其他攻击影响。 股权授权证明（DPoS） 其与PoS主要区别在于节点选举若干代理人，然后由这些代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。 你可以想象成董事会投票，持币者投出一定数量的节点，进行代理验证和记账。 工作原理：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其目标是通过及时而高效的方法达到让“51%通过”。 为了达到这个目标，每个股东可以将其投票权授予一名代表。获得票数最多的前100位代表按既定时间表轮流产生区块。每位代表分配到一个时间段来产生区块。 所有的代表将收到等同于一个平均水平的区块所含交易费的10%作为报酬。如果一个平均水平的区块用100股作为交易费，一位代表将获得一股作为报酬。 DPoS的投票可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即便发生也可以在几分钟内得到解决。执行该模式的基本步骤： 1、成为代表。先在网络上注册你的公钥，该公钥是一个32位的标识符。该标识符会被每笔交易数据的“头部”引用。 2、授权投票。每个钱包有一个参数设置窗口，在该窗口里用户可以选择一位或更多的代表，并将其分级。一经设定，用户所做的每笔交易将把选票从“输入代表”转移到“输出代表”。 3、保持代表诚实。每个钱包都会配有一个状态指示器，让用户知道他们的代表表现如何。 4、抵抗攻击。每位代表都有一项平等的投票权，因此，无法通过获得超过1%的选票而将权利集中到单一代表上。由于每位代表的标识是公钥，因而攻击者很难对每位代表进行攻击。 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。 投注共识（Casper）——以太坊下一代共识机制 为了防止验证人在不同的世界中提供不同的投注，还需要一个条款：如果你两次的投注序号一样，或者说你提交了一个无法让Casper依照合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是，Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临保证金被没收的风险。 Casper协议下的验证人需要完成出块和投注两个活动。 出块：独立于其他所有事件而发生的过程，验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，并签名，然后发生到网络上。 投注：目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。 客户端确认过程： 1、下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见； 2、简单地按顺序在每个高度进行观察，如果一个区块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后所得到的状态就可以显示为区块链的“当前状态”。 同时，客户端还可以给出对于“最终确定”的主观看法：如果高度k之前的每个区块形成的意见高于99.9999%或者低于0.001%，那么客户端就可以认为前k个区块已经最终确定。 瑞波共识机制 该算法使一组节点能够基于特殊节点列表形成共识。 初始的特殊节点列表可以看成一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。即，该共识遵循该俱乐部核心成员的“51%全力”，外部人员则没有影响力。 但是，由于该俱乐部是由中心化构成的，所以一旦它腐败，就会失去意义。 Pool（联营）验证池 Pool验证池基于传统的分布式一致性技术和数据验证机制。目前是行业内大范围使用的机制。 优点：不需要代币也能工作；在成熟的分布式一致性算法（Pasox、Raft）的基础上，实现秒级共识验证。 缺点：去中心化程度不高，不如比特币，其更适合多方参与的多中心商业模式。 帕克索斯算法 传统分布式一致性算法，基于选举领导者的共识机制。 领导者拥有绝对权限，并允许强监管节点参与。 优点：性能高，资源消耗低。 缺点：所有节点一般都有线下准入机制，但选举过程中不允许有作恶节点，不具备容错性。 实用拜占庭容错（PBFT） 有一问题：在分布式计算上，不同的计算机通过信息交换尝试达成共识，但有时候，系统中的协调计算机或成员计算机可能因系统错误交换错的信息，以至于影响最终的系统一致性。 通常我们上述这样的问题，称为“拜占庭将军”问题。 那么有什么解决方法呢？ 早在1999年，卡斯特罗和利斯夫提出的实用拜占庭算法，该算法认为只要系统中有2/3的节点是正常工作的，就可以保证一致性。 总体过程如下： 客户端向主节点发送请求调用服务操作，如&quot;&lt;REQUEST,o,t,c&gt;&quot;——客户端c请求执行操作o，时间戳t用来保证客户端请求只会执行一次。每个由副本节点发给客户端的消息都包含了当前的视图编号，使得客户端能够追踪视图编号，使得客户端能够追踪视图编号，从而进一步推算出当前主节点的编号。客户端通过点对点消息向它认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。 注： 视图编号是连续编号的整数。主节点由公式p = v mod |R| （v：视图编号，p：副本编号，|R|副本集合的个数） 副本发给客户端的响应为&quot;&lt;REPLY,v,t,c,i,r&gt;&quot;，v是视图编号，t是时间戳，i是副本编号，r是请求执行的结果。 接着，主节点广播请求给其他副本，然后就开始执行三个阶段的任务： 1、预准备阶段。主节点分配一个序列号n 给收到的请求，然后向所有备份节点群发预备消息，预备消息的格式：&quot;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;&quot;。（v：视图编号，m：客户端发送的请求消息，d：请求消息m的摘要） 2、准备阶段。如果备份节点 i 接受了预备消息，则进入准备阶段。在准备的同时，该节点向所有副本节点发送准备消息&quot;&lt;PREPARE,v,n,d,i&gt;&quot;,并且将预准备消息和准备消息写入自己的消息日志。 3、确认阶段。当&quot;（m,v,n,i）&quot;条件为真的时候，副本 i 将 &quot;&lt;COMIT,v,n,D（m）, i&gt;&quot;向其他副本节点广播，然后进入确认阶段。所哟副本都执行请求并将结果发回客户端。客户端需要等待不同副本节点发回相同的结果，作为整个操作的最终结果。 注意： 如果客户端没有在有限时间内收到回复，请求将向所有副本节点进行广播； 但是会出现几种情况： 1、如果该请求已经在副本节点处理过，副本就向客户端重发一遍执行结果； 2、如果该请求没有在副本节点处理过，该副本节点将把请求转发给主节点； 3、如果主节点没有将该请求进行广播，那么认为主节点失效； 4、如果有足够多的副本节点认为主节点失效，则会触发一次视图变更。 实用拜占庭容错机制，是一种采用”许可投票、少数服从多数“来选举领导者并进行记账的共识机制，该机制允许拜占庭容错，允许强监管节点参与，具备权限分级能力，性能更高，耗能更低，而且每轮记账都会由全网节点共同选举领导者，允许33%的节点作恶，容错性为33%。 应用场景：联盟链 授权拜占庭容错 该机制由国内的小蚁公司提出，是一种改进的拜占庭容错算法。 改进如下： 1、将C/S架构的请求响应模式改进为适合P2P网络的对等节点模式 2、将静态的共识参与节点改进为可动态进入、退出的共识参与节点； 3、为共识参与节点的产生设计一套基于持有权益比例的投票机制，通过投票决定共识参与节点（记账节点） 4、在区块链中引入数字证书，解决投票中对记账节点真实身份的认证问题 优点：专业化的记账人；可容忍任何类型的错误；记账由多人协同完成；每一个区块都有最终性，不会分叉；算法的可靠性有严格的数学证明。 缺点：当1/3及以上的记账人停止工作后，系统将无法提供服务；当1/3及以上的记账人联合作恶，且其他所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但会留下密码学证据。 应用场景：金融 同时，欢迎关注微信公众号“小智链习社”，给予小智更多原力^_^。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/13/3c66500cce932a8f821d2e1a6aa347c0.html","headline":"【区块链】一起玩转9类共识机制","dateModified":"2018-08-13T00:00:00+08:00","datePublished":"2018-08-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/13/3c66500cce932a8f821d2e1a6aa347c0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【区块链】一起玩转9类共识机制</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>简介</p> 
  <blockquote> 
   <p>目前大多数国家的现有银行系统中，所有银行都是通过中央的电子账本进行账目核对的。这是一个中心化的结构，越靠近中心的机构，权限越多，存储的数据量越多。而为了维护这个中心化系统中所有数据的准确性，银行需要付出巨大的运营成本。 <br> 而凭借去中心化的特点，区块链技术可以为银行创建一个分布式的公开可查的网络，其中的所有交易数据是透明和共享的。利用区块链技术进行分布式记账可以削减无效的银行中介，节省很多运营成本。</p> 
  </blockquote> 
  <p>今天，我们主要来介绍一下区块链的共识机制。</p> 
  <h2 id="区块链9类共识机制">区块链9类共识机制</h2> 
  <h3 id="工作量证明pow">工作量证明（PoW）</h3> 
  <p>比特币在区块的生成过程中使用了PoW机制，一个符合要求的区块哈希值由N个前导零构成，零的个数取决于网络的难度值。要得到合理的区块哈希值，要经过大量的尝试计算，计算时间取决于机器的哈希运算速度。 <br> 当某个节点提供出一个合理的区块哈希值，说明该节点确实经过了大量的尝试计算，当然，这并不能得出计算次数的绝对值，因为寻找合理的哈希值是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n%的概率找到区块哈希值。 <br> Pow依赖机器进行数学运算来获取记账权，资源消耗大、共识机制高、可监管性弱，同时每次达成共识需要全网共同参与运算，性能效率比较低，容错性方面允许全网50%节点出错。 <br> - 优点：完全去中心化，节点自由进出 <br> - 缺点：比特币已经吸引全球大部分的算力，再使用PoW共识机制的区块链应用很难获取相同的算力来保障自身安全。同时，挖矿造成大量的资源浪费；共识达成的周期较长。 </p> 
  <h3 id="权益证明pos">权益证明（PoS）</h3> 
  <p>主要理念：相比PoW，节点记账权的获得难度与节点持有的权益成反比，其在一定程度上减少了数学运算带来的资源消耗，性能也得到相应提升。PoS也是基于哈希运算，通过竞争的方式获得记账权。可以说，PoS是PoW的一种升级，其根据每个节点所占代币的比利和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。 <br> 在这个系统中，存在一个持币人集合，他们把手中的代币放入POS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块，PoS算法在验证者中随机选取一个，给其权利产生下一个区块。通常，选择验证者的权重依据他们投入的代币量，投入的越多，权重越大。 <br> 如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生，以此类推。 <br> - 优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。 <br> - 缺点：仍然需要通过挖矿来实现；所有的确认只是一个概率上的表达，而非一个确定性的事情，理论上仍有可能存在其他攻击影响。</p> 
  <h3 id="股权授权证明dpos">股权授权证明（DPoS）</h3> 
  <p>其与PoS主要区别在于节点选举若干代理人，然后由这些代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。 <br> 你可以想象成董事会投票，持币者投出一定数量的节点，进行代理验证和记账。 <br> 工作原理：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其目标是通过及时而高效的方法达到让“51%通过”。 <br> 为了达到这个目标，每个股东可以将其投票权授予一名代表。获得票数最多的前100位代表按既定时间表轮流产生区块。每位代表分配到一个时间段来产生区块。 <br> 所有的代表将收到等同于一个平均水平的区块所含交易费的10%作为报酬。如果一个平均水平的区块用100股作为交易费，一位代表将获得一股作为报酬。 <br> DPoS的投票可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即便发生也可以在几分钟内得到解决。执行该模式的基本步骤： <br> 1、成为代表。先在网络上注册你的公钥，该公钥是一个32位的标识符。该标识符会被每笔交易数据的“头部”引用。 <br> 2、授权投票。每个钱包有一个参数设置窗口，在该窗口里用户可以选择一位或更多的代表，并将其分级。一经设定，用户所做的每笔交易将把选票从“输入代表”转移到“输出代表”。 <br> 3、保持代表诚实。每个钱包都会配有一个状态指示器，让用户知道他们的代表表现如何。 <br> 4、抵抗攻击。每位代表都有一项平等的投票权，因此，无法通过获得超过1%的选票而将权利集中到单一代表上。由于每位代表的标识是公钥，因而攻击者很难对每位代表进行攻击。</p> 
  <ul> 
   <li>优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。</li> 
   <li>缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。</li> 
  </ul> 
  <h3 id="投注共识casper以太坊下一代共识机制">投注共识（Casper）——以太坊下一代共识机制</h3> 
  <p>为了防止验证人在不同的世界中提供不同的投注，还需要一个条款：如果你两次的投注序号一样，或者说你提交了一个无法让Casper依照合约处理的投注，你将失去所有保证金。从这一点我们可以看出，Casper与传统的PoS不同的是，Casper有惩罚机制，这样非法节点通过恶意攻击网络不仅得不到交易费，而且还面临保证金被没收的风险。 <br> Casper协议下的验证人需要完成出块和投注两个活动。 <br> 出块：独立于其他所有事件而发生的过程，验证人收集交易，当轮到他们的出块时间时，他们就制造一个区块，并签名，然后发生到网络上。 <br> 投注：目前Casper默认的验证人策略被设计为模仿传统的拜占庭容错共识：观察其他的验证人如何投注，取33%处的值，向0或者1进一步移动。</p> 
  <p>客户端确认过程： <br> 1、下载所有的区块和投注，然后用上面的算法来形成自己的意见，但是不公布意见； <br> 2、简单地按顺序在每个高度进行观察，如果一个区块的概率高于0.5就处理它，否则就跳过它。在处理所有的区块之后所得到的状态就可以显示为区块链的“当前状态”。 <br> 同时，客户端还可以给出对于“最终确定”的主观看法：如果高度k之前的每个区块形成的意见高于99.9999%或者低于0.001%，那么客户端就可以认为前k个区块已经最终确定。</p> 
  <h3 id="瑞波共识机制">瑞波共识机制</h3> 
  <p>该算法使一组节点能够基于特殊节点列表形成共识。 <br> 初始的特殊节点列表可以看成一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。即，该共识遵循该俱乐部核心成员的“51%全力”，外部人员则没有影响力。 <br> 但是，由于该俱乐部是由中心化构成的，所以一旦它腐败，就会失去意义。</p> 
  <h3 id="pool联营验证池">Pool（联营）验证池</h3> 
  <p>Pool验证池基于传统的分布式一致性技术和数据验证机制。目前是行业内大范围使用的机制。 <br> 优点：不需要代币也能工作；在成熟的分布式一致性算法（Pasox、Raft）的基础上，实现秒级共识验证。 <br> 缺点：去中心化程度不高，不如比特币，其更适合多方参与的多中心商业模式。</p> 
  <h3 id="帕克索斯算法">帕克索斯算法</h3> 
  <p>传统分布式一致性算法，基于选举领导者的共识机制。 <br> 领导者拥有绝对权限，并允许强监管节点参与。 <br> 优点：性能高，资源消耗低。 <br> 缺点：所有节点一般都有线下准入机制，但选举过程中不允许有作恶节点，不具备容错性。</p> 
  <h3 id="实用拜占庭容错pbft">实用拜占庭容错（PBFT）</h3> 
  <p>有一问题：在分布式计算上，不同的计算机通过信息交换尝试达成共识，但有时候，系统中的协调计算机或成员计算机可能因系统错误交换错的信息，以至于影响最终的系统一致性。 <br> 通常我们上述这样的问题，称为“拜占庭将军”问题。</p> 
  <p>那么有什么解决方法呢？ <br> 早在1999年，卡斯特罗和利斯夫提出的实用拜占庭算法，该算法认为只要系统中有2/3的节点是正常工作的，就可以保证一致性。 <br> 总体过程如下： <br> 客户端向主节点发送请求调用服务操作，如<code>"&lt;REQUEST,o,t,c&gt;"</code>——客户端c请求执行操作o，时间戳t用来保证客户端请求只会执行一次。每个由副本节点发给客户端的消息都包含了当前的视图编号，使得客户端能够追踪视图编号，使得客户端能够追踪视图编号，从而进一步推算出当前主节点的编号。客户端通过点对点消息向它认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。</p> 
  <p>注： <br> 视图编号是连续编号的整数。主节点由公式<code>p = v mod |R|</code> （v：视图编号，p：副本编号，|R|副本集合的个数） <br> 副本发给客户端的响应为<code>"&lt;REPLY,v,t,c,i,r&gt;"</code>，v是视图编号，t是时间戳，i是副本编号，r是请求执行的结果。</p> 
  <p>接着，主节点广播请求给其他副本，然后就开始执行三个阶段的任务： <br> 1、预准备阶段。主节点分配一个序列号n 给收到的请求，然后向所有备份节点群发预备消息，预备消息的格式：<code>"&lt;PRE-PREPARE,v,n,d&gt;,m&gt;"</code>。（v：视图编号，m：客户端发送的请求消息，d：请求消息m的摘要）</p> 
  <p>2、准备阶段。如果备份节点 i 接受了预备消息，则进入准备阶段。在准备的同时，该节点向所有副本节点发送准备消息<code>"&lt;PREPARE,v,n,d,i&gt;"</code>,并且将预准备消息和准备消息写入自己的消息日志。 <br> 3、确认阶段。当<code>"（m,v,n,i）"</code>条件为真的时候，副本 i 将 <code>"&lt;COMIT,v,n,D（m）, i&gt;"</code>向其他副本节点广播，然后进入确认阶段。所哟副本都执行请求并将结果发回客户端。客户端需要等待不同副本节点发回相同的结果，作为整个操作的最终结果。</p> 
  <p>注意： <br> 如果客户端没有在有限时间内收到回复，请求将向所有副本节点进行广播； <br> 但是会出现几种情况： <br> 1、如果该请求已经在副本节点处理过，副本就向客户端重发一遍执行结果； <br> 2、如果该请求没有在副本节点处理过，该副本节点将把请求转发给主节点； <br> 3、如果主节点没有将该请求进行广播，那么认为主节点失效； <br> 4、如果有足够多的副本节点认为主节点失效，则会触发一次视图变更。</p> 
  <p>实用拜占庭容错机制，是一种采用”许可投票、少数服从多数“来选举领导者并进行记账的共识机制，该机制允许拜占庭容错，允许强监管节点参与，具备权限分级能力，性能更高，耗能更低，而且每轮记账都会由全网节点共同选举领导者，允许33%的节点作恶，容错性为33%。</p> 
  <p>应用场景：联盟链</p> 
  <h3 id="授权拜占庭容错">授权拜占庭容错</h3> 
  <p>该机制由国内的小蚁公司提出，是一种改进的拜占庭容错算法。 <br> 改进如下： <br> 1、将C/S架构的请求响应模式改进为适合P2P网络的对等节点模式 <br> 2、将静态的共识参与节点改进为可动态进入、退出的共识参与节点； <br> 3、为共识参与节点的产生设计一套基于持有权益比例的投票机制，通过投票决定共识参与节点（记账节点） <br> 4、在区块链中引入数字证书，解决投票中对记账节点真实身份的认证问题</p> 
  <ul> 
   <li>优点：专业化的记账人；可容忍任何类型的错误；记账由多人协同完成；每一个区块都有最终性，不会分叉；算法的可靠性有严格的数学证明。</li> 
   <li>缺点：当1/3及以上的记账人停止工作后，系统将无法提供服务；当1/3及以上的记账人联合作恶，且其他所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但会留下密码学证据。</li> 
  </ul> 
  <p>应用场景：金融</p> 
  <p>同时，欢迎关注微信公众号“小智链习社”，给予小智更多原力^_^。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180813201813599?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ltYWdpbmVDb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/81636342,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/81636342,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
