<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13 (四) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13 (四)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81450432 源码0.13.2版的，在vscode中打开的 目录 源码0.13.2版的，在vscode中打开的 9）交易标准与签名字节数 10）钱包相关参数 11）交易相关参数 12）各种参数 13）mempoolreplacement 9.4 application initialization 1）椭圆加密曲线 2) initsanitycheck 3) 锁定目录结构 4）创建pid文件 5）参数设置 9）交易标准与签名字节数 非标准交易 fRequireStandard = !GetBoolArg(&quot;-acceptnonstdtxn&quot;, !Params().RequireStandard()); if (Params().RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); Params().RequireStandard()就是返回fRequireStandard //chainparams.h class CChainParams /** Policy: Filter transactions that do not match well-defined patterns */ bool RequireStandard() const { return fRequireStandard; } bool fRequireStandard; params()是在step2中定义的，CChainParams是基类，有三个子类这个之前也介绍过了，三个子类是基于不同的网络的，在主网中fRequireStandard=true,测试网和私有网都是false。也就是主网只接受标准交易，测试网与私有网可以接受非标准交易。 签名字节数 nBytesPerSigOp = GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); 默认的签名操作字节数为20 //src/policy/policy.cpp unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP; //policy.h /** Default for -bytespersigop */ static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20; 10）钱包相关参数 I 钱包开关 #ifdef ENABLE_WALLET if (!CWallet::ParameterInteraction()) return false; #endif // ENABLE_WALLET ENABLE_WALLET宏定义开关在configure.ac文件中，可以在源码编译的时候控制该宏定义的开关 //configure.ac # Enable wallet AC_ARG_ENABLE([wallet], [AS_HELP_STRING([--disable-wallet], [disable wallet (enabled by default)])], [enable_wallet=$enableval], [enable_wallet=yes]) 可以看到默认是打开钱包的，我们可以在运行比特币钱包客户端时通过disablewallet参数关闭钱包功能。 再看CWallet::ParameterInteraction()，如果设置了开启钱包，那么与钱包相关的交互参数必须设置正确，否则程序返回。CWallet::ParameterInteraction()位于src/wallet/wallet.cpp中，分析函数中的各个参数 II -mintxfee 每kb低于mintxfee的费用被视为交易创建时的未付费 if (mapArgs.count(&quot;-mintxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-mintxfee&quot;], n) &amp;&amp; n &gt; 0) CWallet::minTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;mintxfee&quot;, mapArgs[&quot;-mintxfee&quot;])); } ParseMoney()位于utilmoneystr.cpp，用于解析传入的数字，转为聪为单位的费用（包括小数的处理，数据格式正确与否）传回计算后的数值。这段的参数处理代码与minRelayTxFee参数的处理基本一致。 //amount.h static const CAmount COIN = 100000000; III -fallbackfee 当没有足够的信息用以估算费用时默认使用的费率。 代码中先解析参数是否正确，另外判断参数如果超过最高费率HIGH_TX_FEE_PER_KB会报警告⚠️ //main.h //! Discourage users to set fees higher than this amount (in satoshis) per kB static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN; 那么HIGH_TX_FEE_PER_KB为0.01BTC III -paytxfee与maxtxfee 分别代表支付交易手续费与最高交易手续费，如果高于最高费率HIGH_TX_FEE_PER_KB有警告提示，若是低于最低费率::minRelayTxFee，则报错退出程序。 IV -txconfirmtarget nTxConfirmTarget = GetArg(&quot;-txconfirmtarget&quot;, DEFAULT_TX_CONFIRM_TARGET); 从注释来看，txconfirmtarget表示如果没有设置paytxfee，则使用足够的费用，以便交易可能在平均n个块（默认值：%u）内开始确认。 //src/wallet/wallet.h //! -txconfirmtarget default static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2; 这里的默认值为2。如果设为6，你的交易获得首个确认将花费平均6个区块链验证时间。从0.14版本开始就是6个了，也就是我们说的比特币每一笔交易都需要经过6个区块确认才能算真正的交易成功。 V spendzeroconfchange 在发送交易时花费未确认的更改，也就是可以花费0确认的费用 bSpendZeroConfChange = GetBoolArg(&quot;-spendzeroconfchange&quot;, DEFAULT_SPEND_ZEROCONF_CHANGE); 在这里是默认可以的 //src/wallet/wallet.h //! Default for -spendzeroconfchange static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true; //! Default for -sendfreetransactions static const bool DEFAULT_SEND_FREE_TRANSACTIONS = false; VI fSendFreeTransactions 如果可能，发送0费用的交易 fSendFreeTransactions = GetBoolArg(&quot;-sendfreetransactions&quot;, DEFAULT_SEND_FREE_TRANSACTIONS); 默认为不可以，默认不可以发送0手续费的交易 11）交易相关参数 fIsBareMultisigStd = GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); I -permitbaremultisig 从注释来看是传递非P2SH多重签名脚本，默认是允许的 Relay non-P2SH multisig (default: %u)&quot;), DEFAULT_PERMIT_BAREMULTISIG //main.h /** Default for -permitbaremultisig */ static const bool DEFAULT_PERMIT_BAREMULTISIG = true; 也就是默认非P2SH多重签名的交易在全网传播。 II -datacarrier、-datacarriersize 在帮助信息中找到注释，-datacarrier表示传播和挖矿包含交易以外数据信息的交易，默认设置为true;再看datacarriersize表示包含数据的交易大小默认值 //src/script/standard.cpp unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY; //src/script/standard.h static const unsigned int MAX_OP_RETURN_RELAY = 83; 其默认值为83字节 12）各种参数 I mocktime 用于回归测试，从新时期（这里指1970年，从输出time” : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT) 推测）开始用n秒替换真实时间 // Option to startup with mocktime set (used for regression testing): SetMockTime(GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op 调用函数SetMockTime，执行赋值操作，一句代码。 //utlitime.cpp static int64_t nMockTime = 0; //!&lt; For unit testing void SetMockTime(int64_t nMockTimeIn) { nMockTime = nMockTimeIn; } 从注释可以看到，mocktime是用于单元测试的，默认值为0。 II peerbloomfilter if (GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); //main.h static const bool DEFAULT_PEERBLOOMFILTERS = true; Bloom滤波器支持块过滤和事务处理，默认为true,关于bloom的具体信息可以看《精通比特币（第二版）》8.9Bloom过滤器。在支持过滤器的前提下，程序中设置了当前运行节点的服务模式 //net.cpp ServiceFlags nLocalServices = NODE_NETWORK; ServiceFlags是枚举类型，nLocalServices是初始赋值为NODE_NETWORK，在上述代码中又增加赋值NODE_BLOOM，即具备全节点信息存储与bloom过滤器功能，这两者是所有客户端默认具备的。 //protocol.h /** nServices flags */ enum ServiceFlags : uint64_t { // Nothing NODE_NONE = 0, // NODE_NETWORK means that the node is capable of serving the block chain. It is currently // set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want // network services but don&#39;t provide them. NODE_NETWORK = (1 &lt;&lt; 0), // NODE_GETUTXO means the node is capable of responding to the getutxo protocol request. // Bitcoin Core does not support this but a patch set called Bitcoin XT does. // See BIP 64 for details on how this is implemented. NODE_GETUTXO = (1 &lt;&lt; 1), // NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections. // Bitcoin Core nodes used to support this by default, without advertising this bit, // but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION) NODE_BLOOM = (1 &lt;&lt; 2), // Indicates that a node can be asked for blocks and transactions including // witness data. NODE_WITNESS = (1 &lt;&lt; 3), ··· }; III -rpcserialversion 从帮助信息来看，该参数表示在非冗长模式、非隔离见证（0）或隔离见证（1）模式下原始交易或区块以16进制序列化方式呈现。默认值为1 //src/rpc/server.h static const unsigned int DEFAULT_RPC_SERIALIZE_VERSION = 1; 代码主要是对取值做判断，该值只能为0或1 if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); IV maxtipage nMaxTipAge = GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 结合帮助信息和默认值来看，该参数表示当我们运行的节点包含的区块信息落后主网最长点24小时后，比特币客户端将进行区块同步下载(initial block download)操作。 //main.h static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60; 关于initial block download(IBD)从官网的解释来看，并不是只能在刚启动时执行，而是当前节点信息落后全网最长链24小时或144个块就会执行。 13）mempoolreplacement mempoolreplacement:Enable transaction replacement in the memory pool 表示能够替换交易池的交易，这个解释有些笼统，去bitcoinwiki查找transaction replacement,所谓交易替换是指可以在拥有全节点的客户端中替换交易池的交易，即针对同一输入，可以用花费了该部分或全部该输入金额的交易替换交易池中的交易。因此交易池中的交易是可以被替换的，前提是替换的交易产生于同一输入 fEnableReplacement = GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; mapArgs.count(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } 先看下其默认值 //main.h /** Default for -mempoolreplacement */ static const bool DEFAULT_ENABLE_REPLACEMENT = true; 默认打开交易替换，解释一下boost::split,其中vstrReplacementModes是用来存储分割的结果的容器，strReplacementModeList是要分割的内容，按“，“分割，这段就是查找交易池替换模式内容，判断是否包含”fee”模式，如果包含则fEnableReplacement=true. 14)bip9params 首先查看帮助信息 -bip9params=deployment:start:end Use given start/end times for specified bip9 deployment (regtest-only) bip9params是比特币在私有网测试时使用的参数，作为执行部署、执行部署开始和部署结束时间。bip9信号与激活的相关概念可以参考《精通比特币（第二版）》10.14使用区块版本发出软分叉信号。 bip9之前BIP-34，BIP-66 和 BIP-65 使用的机制成功地激活了三个软分叉，但通过使用块版本的整数值来实现，每次只能激活一个分叉，bip9将块版本解释为bit字段而不是一个整数，以及一些其他的规范。 回到代码部分，主要是针对bip9params参数的值进行私有网络测试部署，以测试软分叉后软件是否运行正常。 从这里开始，之前参考的作者写的就不适合我继续参考了，开始参考另一位博主了–Splay– 9.4 application initialization // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log 1）椭圆加密曲线 初始化椭圆曲线 // Initialize elliptic curve code ECC_Start(); globalVerifyHandle.reset(new ECCVerifyHandle()); 先看ECC_Start()，实现在key.cpp void ECC_Start() { assert(secp256k1_context_sign == NULL); secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN); assert(ctx != NULL); { // Pass in a random blinding seed to the secp256k1 context. unsigned char seed[32]; LockObject(seed); GetRandBytes(seed, 32); bool ret = secp256k1_context_randomize(ctx, seed); assert(ret); UnlockObject(seed); } secp256k1_context_sign = ctx; } 2) initsanitycheck 可用性检测，未通过则报错 // Sanity check if (!InitSanityCheck()) return InitError(strprintf(_(&quot;Initialization sanity check failed. %s is shutting down.&quot;), _(PACKAGE_NAME))); 主要功能是确保比特币在可用的环境中运行，并提供所有必要的库支持。 //init.cpp /** Sanity checks * Ensure that Bitcoin is running in a usable environment with all * necessary library support. */ bool InitSanityCheck(void) { if(!ECC_InitSanityCheck()) { InitError(&quot;Elliptic curve cryptography sanity check failure. Aborting.&quot;); return false; } if (!glibc_sanity_test() || !glibcxx_sanity_test()) return false; return true; } 主要是三个验证，ECC_InitSanityCheck()为椭圆曲线加密结果的完整性验证，glibc_sanity_test() 和 glibcxx_sanity_test()验证当前运行环境是否支持C/C++运行环境 I ECC_nitSanityCheck 椭圆曲线加密结果验证 //key.cpp bool ECC_InitSanityCheck() { CKey key; key.MakeNewKey(true); CPubKey pubkey = key.GetPubKey(); return key.VerifyPubKey(pubkey); } //key.h /** Check that required EC support is available at runtime. */ bool ECC_InitSanityCheck(void); 首先定义私钥对象，CKey类型 //key.h /** An encapsulated private key. */ class CKey { private: //! Whether this private key is valid. We check for correctness when modifying the key //! data, so fValid should always correspond to the actual state. bool fValid; //! Whether the public key corresponding to this private key is (to be) compressed. bool fCompressed; //! The actual byte data unsigned char vch[32]; //! Check whether the 32-byte array pointed to be vch is valid keydata. bool static Check(const unsigned char* vch); 可以看到私钥是保存在长度为32的字符串vch中，我们知道私钥是256位，256/8=32字节。fValid参数用于表示私钥是否有效，该参数是在私钥发生变化时进行相应的修改，即私钥值有效为true。fCompressed表示与这个私钥相符合的公钥是否被压缩，true为压缩公钥。Check检查这32位字节是否是有效的密钥数据。 //key.h class CKey内 public: //! Construct an invalid private key. CKey() : fValid(false), fCompressed(false) { LockObject(vch); } 定义对象调用构造函数时，该私钥是无效的，对应的公钥是不压缩的。调用 LockObject锁定私钥，从注释分析这个函数 //src/support/pagelocker.h Functions for directly locking/unlocking memory objects. Intended for non-dynamically allocated structures. //用于直接锁定/解锁内存对象的函数。用于非动态分配结构。 template &lt;typename T&gt; void LockObject(const T&amp; t) { LockedPageManager::Instance().LockRange((void*)(&amp;t), sizeof(T)); } LockRange就是在所有管理范围内，会新增一个锁的计数，具体代码不再展开 之后要创建私钥，来看MakeNewKey()这个函数,传入的参数true代表与私钥相符合的公钥是压缩的 //key.h //! Generate a new private key using a cryptographic PRNG. void MakeNewKey(bool fCompressed); //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch)); } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 从注释看这个函数通过使用加密PRNG（伪随机数，可以参考《图解密码技术》第12章随机数也可以百度）生成私钥。通过GetStrongRandBytes循环获取私钥，直到满足 Check的条件为止。找到满足的私钥后，设置该密钥为有效，是否压缩赋值。 //random.cpp void GetStrongRandBytes(unsigned char* out, int num) { assert(num &lt;= 32); CSHA512 hasher; unsigned char buf[64]; // First source: OpenSSL&#39;s RNG RandAddSeedPerfmon(); GetRandBytes(buf, 32); hasher.Write(buf, 32); // Second source: OS RNG GetOSRand(buf); hasher.Write(buf, 32); // Produce output hasher.Finalize(buf); memcpy(out, buf, num); memory_cleanse(buf, 64); } 通过OpenSSL’s RNG获得随机数，然后通过OS RNG获取随机数，生成哈希值，这里使用的是SHA512哈希算法，不过私钥是256位，所以我们只需要32位，之后清除随机数的内存。 Check函数的实现 //key.cpp bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } 这个函数是调用libsecp256k1库实现随机数的验证，libsecp256k1库的源码也包含在比特币源码中，位于src/secp256k1文件夹中，在secp256k1.h中有该函数的声明 /** Verify an ECDSA secret key. * * Returns: 1: secret key is valid * 0: secret key is invalid * Args: ctx: pointer to a context object (cannot be NULL) * In: seckey: pointer to a 32-byte secret key (cannot be NULL) */ 这个函数的功能是验证基于椭圆曲线创建的密钥。 下一步，创建公钥CPubKey pubkey = key.GetPubKey();先看CPubKey类 //pubkey.h class CPubKey /** * Just store the serialized data. * Its length can very cheaply be computed from the first byte. */ unsigned char vch[65]; ··· 包含一个参数vch[65]主要用于存储序列化的公钥值，可以通过第一个字节即vch[0]获取公钥的长度，如果该值为2或3则为压缩公钥长度为33，值为4，6，7则为非压缩公钥长度为65。不是上述值，则该公钥值无效。 再看 key.GetPubKey()，该函数通过调用secp256k1库提供的函数首先通过secp256k1_ec_pubkey_create函数创建公钥值，再通过secp256k1_ec_pubkey_serialize函数实现压缩或非压缩公钥序列值的计算。 最后验证公钥 return key.VerifyPubKey(pubkey); bool CKey::VerifyPubKey(const CPubKey&amp; pubkey) const { if (pubkey.IsCompressed() != fCompressed) { return false; } unsigned char rnd[8]; std::string str = &quot;Bitcoin key verification\n&quot;; GetRandBytes(rnd, sizeof(rnd)); uint256 hash; CHash256().Write((unsigned char*)str.data(), str.size()).Write(rnd, sizeof(rnd)).Finalize(hash.begin()); std::vector&lt;unsigned char&gt; vchSig; Sign(hash, vchSig); return pubkey.Verify(hash, vchSig); } 获取8字节的随机数，把”Bitcoin key verification”和生成的随机数共同计算哈希值，在sign函数通过该哈希值基于ECADSA算法实现签名的计算，利用签名信息验证获取的公钥的有效性，验证函数为Verify(） //pubkey.h /** * Verify a DER signature (~72 bytes). * If this public key is not fully valid, the return value will be false. */ bool Verify(const uint256&amp; hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 这个验证函数是验证DER格式的签名，DER是一种编码方案 II C与C++运行环境验证 glibc_sanity_test() 、 !glibcxx_sanity_test()这两个函数就是验证运行环境中C/C++运行库的有效性，即比特币核心软件能否在当前环境中正常运行。 3) 锁定目录结构 确保只有一个比特币进程在使用数据目录 // Make sure only a single Bitcoin process is using the data directory. boost::filesystem::path pathLockFile = GetDataDir() / &quot;.lock&quot;; FILE* file = fopen(pathLockFile.string().c_str(), &quot;a&quot;); // empty lock file; created if it doesn&#39;t exist. if (file) fclose(file); try { static boost::interprocess::file_lock lock(pathLockFile.string().c_str()); if (!lock.try_lock()) return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;), strDataDir, _(PACKAGE_NAME))); } catch(const boost::interprocess::interprocess_exception&amp; e) { return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;) + &quot; %s.&quot;, strDataDir, _(PACKAGE_NAME), e.what())); } 4）创建pid文件 对于非windows系统创建进程的pid文件 #ifndef WIN32 CreatePidFile(GetPidFile(), getpid()); #endif 参考文章http://siwind.iteye.com/blog/1753517可以知道 (1) pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。 用cat命令可以看到。 (2) pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 那么这段代码创建pid文件的目的就是防止进程启动多个副本，从而打乱原有的消息传输。 5）参数设置 I 限定日志大小 if (GetBoolArg(&quot;-shrinkdebugfile&quot;, !fDebug)) ShrinkDebugFile(); -shrinkdebugfile:Shrink debug.log file on client startup (default: 1 when no -debug) 限制日志文件的大小，如果没有设置-debug参数，那么默认值为1 如果设置了这个参数，则调用函数ShrinkDebugFile //util.cpp void ShrinkDebugFile() { // Scroll debug.log if it&#39;s getting too big boost::filesystem::path pathLog = GetDataDir() / &quot;debug.log&quot;; FILE* file = fopen(pathLog.string().c_str(), &quot;r&quot;); if (file &amp;&amp; boost::filesystem::file_size(pathLog) &gt; 10 * 1000000) { // Restart the file with some of the end std::vector &lt;char&gt; vch(200000,0); fseek(file, -((long)vch.size()), SEEK_END); int nBytes = fread(begin_ptr(vch), 1, vch.size(), file); fclose(file); file = fopen(pathLog.string().c_str(), &quot;w&quot;); if (file) { fwrite(begin_ptr(vch), 1, nBytes, file); fclose(file); } } else if (file != NULL) fclose(file); } 判断debug.log文件大小超过10*1000000（10M）的话就重新读取文件最后200000字节的内容重新保存到debug.log文件中。 II deuglog显示处理 if (fPrintToDebugLog) OpenDebugLog(); 默认是打印到测试日志的 //util.cpp bool fPrintToDebugLog = true; OpenDebugLog（）函数实现如下 //util.cpp static void DebugPrintInit() { assert(mutexDebugLog == NULL); mutexDebugLog = new boost::mutex(); vMsgsBeforeOpenLog = new list&lt;string&gt;; } void OpenDebugLog() { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); assert(fileout == NULL); assert(vMsgsBeforeOpenLog); boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; fileout = fopen(pathDebug.string().c_str(), &quot;a&quot;); if (fileout) setbuf(fileout, NULL); // unbuffered // dump buffered messages from before we opened the log while (!vMsgsBeforeOpenLog-&gt;empty()) { FileWriteStr(vMsgsBeforeOpenLog-&gt;front(), fileout); vMsgsBeforeOpenLog-&gt;pop_front(); } delete vMsgsBeforeOpenLog; vMsgsBeforeOpenLog = NULL; } Boost线程库提供了boost::call_once来支持“一次实现”，并且定义了一个标志boost::once_flag及一个初始化这个标志的宏BOOST_ONCE_INIT。并且是在编译期间初始化而不是运行期间 boost::call_once表示在多线程访问该语句时始终只执行一次调用的函数,来确保mutexDebugLog和 vMsgsBeforeOpenLog的初始化是线程安全的。 //util.cpp static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT; 其中第一个参数是被调用的函数地址，第二个参数类型为boost::once_flag，并初始化这个标志为BOOST_ONCE_INIT 在函数DebugPrintInit()中定义了变量mutexDebugLog,类型为boost::mutex()，表示为互斥锁，在OpenDebugLog()函数中是使用了boost::mutex::scoped_lock来上锁，scoped_lock是能够保证在作用域范围内是互斥访问的，离开作用域时由析构函数自动解锁。在DebugPrintInit()中创建了对象vMsgsBeforeOpenLog，类型为链表，此时链表为空，在OpenDebugLog()中需要在打开日志前转储缓冲信息，就是把vMsgsBeforeOpenLog的信息转到debug.log中，那么vMsgsBeforeOpenLog的内容是怎么获得的呢 在util.cpp的LogPrintStr函数中 // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } 这里就是把日志先存入vMsgsBeforeOpenLog在log文件未打开的时候，所以在OpenDebugLog()之前vMsgsBeforeOpenLog变量已经被创建了，然后LogPrintStr又被调用了很多次，每次都写入一写内容。 III 打印提示信息 if (!fLogTimestamps) LogPrintf(&quot;Startup time: %s\n&quot;, DateTimeStrFormat(&quot;%Y-%m-%d %H:%M:%S&quot;, GetTime())); LogPrintf(&quot;Default data directory %s\n&quot;, GetDefaultDataDir().string()); LogPrintf(&quot;Using data directory %s\n&quot;, strDataDir); LogPrintf(&quot;Using config file %s\n&quot;, GetConfigFile().string()); LogPrintf(&quot;Using at most %i connections (%i file descriptors available)\n&quot;, nMaxConnections, nFD); std::ostringstream strErrors; 如果没有设置打印时间戳，就打印起始时间，后面打印默认地址、数据目录之类的信息。 （五）草稿中。。。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81450432 源码0.13.2版的，在vscode中打开的 目录 源码0.13.2版的，在vscode中打开的 9）交易标准与签名字节数 10）钱包相关参数 11）交易相关参数 12）各种参数 13）mempoolreplacement 9.4 application initialization 1）椭圆加密曲线 2) initsanitycheck 3) 锁定目录结构 4）创建pid文件 5）参数设置 9）交易标准与签名字节数 非标准交易 fRequireStandard = !GetBoolArg(&quot;-acceptnonstdtxn&quot;, !Params().RequireStandard()); if (Params().RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); Params().RequireStandard()就是返回fRequireStandard //chainparams.h class CChainParams /** Policy: Filter transactions that do not match well-defined patterns */ bool RequireStandard() const { return fRequireStandard; } bool fRequireStandard; params()是在step2中定义的，CChainParams是基类，有三个子类这个之前也介绍过了，三个子类是基于不同的网络的，在主网中fRequireStandard=true,测试网和私有网都是false。也就是主网只接受标准交易，测试网与私有网可以接受非标准交易。 签名字节数 nBytesPerSigOp = GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); 默认的签名操作字节数为20 //src/policy/policy.cpp unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP; //policy.h /** Default for -bytespersigop */ static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20; 10）钱包相关参数 I 钱包开关 #ifdef ENABLE_WALLET if (!CWallet::ParameterInteraction()) return false; #endif // ENABLE_WALLET ENABLE_WALLET宏定义开关在configure.ac文件中，可以在源码编译的时候控制该宏定义的开关 //configure.ac # Enable wallet AC_ARG_ENABLE([wallet], [AS_HELP_STRING([--disable-wallet], [disable wallet (enabled by default)])], [enable_wallet=$enableval], [enable_wallet=yes]) 可以看到默认是打开钱包的，我们可以在运行比特币钱包客户端时通过disablewallet参数关闭钱包功能。 再看CWallet::ParameterInteraction()，如果设置了开启钱包，那么与钱包相关的交互参数必须设置正确，否则程序返回。CWallet::ParameterInteraction()位于src/wallet/wallet.cpp中，分析函数中的各个参数 II -mintxfee 每kb低于mintxfee的费用被视为交易创建时的未付费 if (mapArgs.count(&quot;-mintxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-mintxfee&quot;], n) &amp;&amp; n &gt; 0) CWallet::minTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;mintxfee&quot;, mapArgs[&quot;-mintxfee&quot;])); } ParseMoney()位于utilmoneystr.cpp，用于解析传入的数字，转为聪为单位的费用（包括小数的处理，数据格式正确与否）传回计算后的数值。这段的参数处理代码与minRelayTxFee参数的处理基本一致。 //amount.h static const CAmount COIN = 100000000; III -fallbackfee 当没有足够的信息用以估算费用时默认使用的费率。 代码中先解析参数是否正确，另外判断参数如果超过最高费率HIGH_TX_FEE_PER_KB会报警告⚠️ //main.h //! Discourage users to set fees higher than this amount (in satoshis) per kB static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN; 那么HIGH_TX_FEE_PER_KB为0.01BTC III -paytxfee与maxtxfee 分别代表支付交易手续费与最高交易手续费，如果高于最高费率HIGH_TX_FEE_PER_KB有警告提示，若是低于最低费率::minRelayTxFee，则报错退出程序。 IV -txconfirmtarget nTxConfirmTarget = GetArg(&quot;-txconfirmtarget&quot;, DEFAULT_TX_CONFIRM_TARGET); 从注释来看，txconfirmtarget表示如果没有设置paytxfee，则使用足够的费用，以便交易可能在平均n个块（默认值：%u）内开始确认。 //src/wallet/wallet.h //! -txconfirmtarget default static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2; 这里的默认值为2。如果设为6，你的交易获得首个确认将花费平均6个区块链验证时间。从0.14版本开始就是6个了，也就是我们说的比特币每一笔交易都需要经过6个区块确认才能算真正的交易成功。 V spendzeroconfchange 在发送交易时花费未确认的更改，也就是可以花费0确认的费用 bSpendZeroConfChange = GetBoolArg(&quot;-spendzeroconfchange&quot;, DEFAULT_SPEND_ZEROCONF_CHANGE); 在这里是默认可以的 //src/wallet/wallet.h //! Default for -spendzeroconfchange static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true; //! Default for -sendfreetransactions static const bool DEFAULT_SEND_FREE_TRANSACTIONS = false; VI fSendFreeTransactions 如果可能，发送0费用的交易 fSendFreeTransactions = GetBoolArg(&quot;-sendfreetransactions&quot;, DEFAULT_SEND_FREE_TRANSACTIONS); 默认为不可以，默认不可以发送0手续费的交易 11）交易相关参数 fIsBareMultisigStd = GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); I -permitbaremultisig 从注释来看是传递非P2SH多重签名脚本，默认是允许的 Relay non-P2SH multisig (default: %u)&quot;), DEFAULT_PERMIT_BAREMULTISIG //main.h /** Default for -permitbaremultisig */ static const bool DEFAULT_PERMIT_BAREMULTISIG = true; 也就是默认非P2SH多重签名的交易在全网传播。 II -datacarrier、-datacarriersize 在帮助信息中找到注释，-datacarrier表示传播和挖矿包含交易以外数据信息的交易，默认设置为true;再看datacarriersize表示包含数据的交易大小默认值 //src/script/standard.cpp unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY; //src/script/standard.h static const unsigned int MAX_OP_RETURN_RELAY = 83; 其默认值为83字节 12）各种参数 I mocktime 用于回归测试，从新时期（这里指1970年，从输出time” : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT) 推测）开始用n秒替换真实时间 // Option to startup with mocktime set (used for regression testing): SetMockTime(GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op 调用函数SetMockTime，执行赋值操作，一句代码。 //utlitime.cpp static int64_t nMockTime = 0; //!&lt; For unit testing void SetMockTime(int64_t nMockTimeIn) { nMockTime = nMockTimeIn; } 从注释可以看到，mocktime是用于单元测试的，默认值为0。 II peerbloomfilter if (GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); //main.h static const bool DEFAULT_PEERBLOOMFILTERS = true; Bloom滤波器支持块过滤和事务处理，默认为true,关于bloom的具体信息可以看《精通比特币（第二版）》8.9Bloom过滤器。在支持过滤器的前提下，程序中设置了当前运行节点的服务模式 //net.cpp ServiceFlags nLocalServices = NODE_NETWORK; ServiceFlags是枚举类型，nLocalServices是初始赋值为NODE_NETWORK，在上述代码中又增加赋值NODE_BLOOM，即具备全节点信息存储与bloom过滤器功能，这两者是所有客户端默认具备的。 //protocol.h /** nServices flags */ enum ServiceFlags : uint64_t { // Nothing NODE_NONE = 0, // NODE_NETWORK means that the node is capable of serving the block chain. It is currently // set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want // network services but don&#39;t provide them. NODE_NETWORK = (1 &lt;&lt; 0), // NODE_GETUTXO means the node is capable of responding to the getutxo protocol request. // Bitcoin Core does not support this but a patch set called Bitcoin XT does. // See BIP 64 for details on how this is implemented. NODE_GETUTXO = (1 &lt;&lt; 1), // NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections. // Bitcoin Core nodes used to support this by default, without advertising this bit, // but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION) NODE_BLOOM = (1 &lt;&lt; 2), // Indicates that a node can be asked for blocks and transactions including // witness data. NODE_WITNESS = (1 &lt;&lt; 3), ··· }; III -rpcserialversion 从帮助信息来看，该参数表示在非冗长模式、非隔离见证（0）或隔离见证（1）模式下原始交易或区块以16进制序列化方式呈现。默认值为1 //src/rpc/server.h static const unsigned int DEFAULT_RPC_SERIALIZE_VERSION = 1; 代码主要是对取值做判断，该值只能为0或1 if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); IV maxtipage nMaxTipAge = GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 结合帮助信息和默认值来看，该参数表示当我们运行的节点包含的区块信息落后主网最长点24小时后，比特币客户端将进行区块同步下载(initial block download)操作。 //main.h static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60; 关于initial block download(IBD)从官网的解释来看，并不是只能在刚启动时执行，而是当前节点信息落后全网最长链24小时或144个块就会执行。 13）mempoolreplacement mempoolreplacement:Enable transaction replacement in the memory pool 表示能够替换交易池的交易，这个解释有些笼统，去bitcoinwiki查找transaction replacement,所谓交易替换是指可以在拥有全节点的客户端中替换交易池的交易，即针对同一输入，可以用花费了该部分或全部该输入金额的交易替换交易池中的交易。因此交易池中的交易是可以被替换的，前提是替换的交易产生于同一输入 fEnableReplacement = GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; mapArgs.count(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } 先看下其默认值 //main.h /** Default for -mempoolreplacement */ static const bool DEFAULT_ENABLE_REPLACEMENT = true; 默认打开交易替换，解释一下boost::split,其中vstrReplacementModes是用来存储分割的结果的容器，strReplacementModeList是要分割的内容，按“，“分割，这段就是查找交易池替换模式内容，判断是否包含”fee”模式，如果包含则fEnableReplacement=true. 14)bip9params 首先查看帮助信息 -bip9params=deployment:start:end Use given start/end times for specified bip9 deployment (regtest-only) bip9params是比特币在私有网测试时使用的参数，作为执行部署、执行部署开始和部署结束时间。bip9信号与激活的相关概念可以参考《精通比特币（第二版）》10.14使用区块版本发出软分叉信号。 bip9之前BIP-34，BIP-66 和 BIP-65 使用的机制成功地激活了三个软分叉，但通过使用块版本的整数值来实现，每次只能激活一个分叉，bip9将块版本解释为bit字段而不是一个整数，以及一些其他的规范。 回到代码部分，主要是针对bip9params参数的值进行私有网络测试部署，以测试软分叉后软件是否运行正常。 从这里开始，之前参考的作者写的就不适合我继续参考了，开始参考另一位博主了–Splay– 9.4 application initialization // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log 1）椭圆加密曲线 初始化椭圆曲线 // Initialize elliptic curve code ECC_Start(); globalVerifyHandle.reset(new ECCVerifyHandle()); 先看ECC_Start()，实现在key.cpp void ECC_Start() { assert(secp256k1_context_sign == NULL); secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN); assert(ctx != NULL); { // Pass in a random blinding seed to the secp256k1 context. unsigned char seed[32]; LockObject(seed); GetRandBytes(seed, 32); bool ret = secp256k1_context_randomize(ctx, seed); assert(ret); UnlockObject(seed); } secp256k1_context_sign = ctx; } 2) initsanitycheck 可用性检测，未通过则报错 // Sanity check if (!InitSanityCheck()) return InitError(strprintf(_(&quot;Initialization sanity check failed. %s is shutting down.&quot;), _(PACKAGE_NAME))); 主要功能是确保比特币在可用的环境中运行，并提供所有必要的库支持。 //init.cpp /** Sanity checks * Ensure that Bitcoin is running in a usable environment with all * necessary library support. */ bool InitSanityCheck(void) { if(!ECC_InitSanityCheck()) { InitError(&quot;Elliptic curve cryptography sanity check failure. Aborting.&quot;); return false; } if (!glibc_sanity_test() || !glibcxx_sanity_test()) return false; return true; } 主要是三个验证，ECC_InitSanityCheck()为椭圆曲线加密结果的完整性验证，glibc_sanity_test() 和 glibcxx_sanity_test()验证当前运行环境是否支持C/C++运行环境 I ECC_nitSanityCheck 椭圆曲线加密结果验证 //key.cpp bool ECC_InitSanityCheck() { CKey key; key.MakeNewKey(true); CPubKey pubkey = key.GetPubKey(); return key.VerifyPubKey(pubkey); } //key.h /** Check that required EC support is available at runtime. */ bool ECC_InitSanityCheck(void); 首先定义私钥对象，CKey类型 //key.h /** An encapsulated private key. */ class CKey { private: //! Whether this private key is valid. We check for correctness when modifying the key //! data, so fValid should always correspond to the actual state. bool fValid; //! Whether the public key corresponding to this private key is (to be) compressed. bool fCompressed; //! The actual byte data unsigned char vch[32]; //! Check whether the 32-byte array pointed to be vch is valid keydata. bool static Check(const unsigned char* vch); 可以看到私钥是保存在长度为32的字符串vch中，我们知道私钥是256位，256/8=32字节。fValid参数用于表示私钥是否有效，该参数是在私钥发生变化时进行相应的修改，即私钥值有效为true。fCompressed表示与这个私钥相符合的公钥是否被压缩，true为压缩公钥。Check检查这32位字节是否是有效的密钥数据。 //key.h class CKey内 public: //! Construct an invalid private key. CKey() : fValid(false), fCompressed(false) { LockObject(vch); } 定义对象调用构造函数时，该私钥是无效的，对应的公钥是不压缩的。调用 LockObject锁定私钥，从注释分析这个函数 //src/support/pagelocker.h Functions for directly locking/unlocking memory objects. Intended for non-dynamically allocated structures. //用于直接锁定/解锁内存对象的函数。用于非动态分配结构。 template &lt;typename T&gt; void LockObject(const T&amp; t) { LockedPageManager::Instance().LockRange((void*)(&amp;t), sizeof(T)); } LockRange就是在所有管理范围内，会新增一个锁的计数，具体代码不再展开 之后要创建私钥，来看MakeNewKey()这个函数,传入的参数true代表与私钥相符合的公钥是压缩的 //key.h //! Generate a new private key using a cryptographic PRNG. void MakeNewKey(bool fCompressed); //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch)); } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 从注释看这个函数通过使用加密PRNG（伪随机数，可以参考《图解密码技术》第12章随机数也可以百度）生成私钥。通过GetStrongRandBytes循环获取私钥，直到满足 Check的条件为止。找到满足的私钥后，设置该密钥为有效，是否压缩赋值。 //random.cpp void GetStrongRandBytes(unsigned char* out, int num) { assert(num &lt;= 32); CSHA512 hasher; unsigned char buf[64]; // First source: OpenSSL&#39;s RNG RandAddSeedPerfmon(); GetRandBytes(buf, 32); hasher.Write(buf, 32); // Second source: OS RNG GetOSRand(buf); hasher.Write(buf, 32); // Produce output hasher.Finalize(buf); memcpy(out, buf, num); memory_cleanse(buf, 64); } 通过OpenSSL’s RNG获得随机数，然后通过OS RNG获取随机数，生成哈希值，这里使用的是SHA512哈希算法，不过私钥是256位，所以我们只需要32位，之后清除随机数的内存。 Check函数的实现 //key.cpp bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } 这个函数是调用libsecp256k1库实现随机数的验证，libsecp256k1库的源码也包含在比特币源码中，位于src/secp256k1文件夹中，在secp256k1.h中有该函数的声明 /** Verify an ECDSA secret key. * * Returns: 1: secret key is valid * 0: secret key is invalid * Args: ctx: pointer to a context object (cannot be NULL) * In: seckey: pointer to a 32-byte secret key (cannot be NULL) */ 这个函数的功能是验证基于椭圆曲线创建的密钥。 下一步，创建公钥CPubKey pubkey = key.GetPubKey();先看CPubKey类 //pubkey.h class CPubKey /** * Just store the serialized data. * Its length can very cheaply be computed from the first byte. */ unsigned char vch[65]; ··· 包含一个参数vch[65]主要用于存储序列化的公钥值，可以通过第一个字节即vch[0]获取公钥的长度，如果该值为2或3则为压缩公钥长度为33，值为4，6，7则为非压缩公钥长度为65。不是上述值，则该公钥值无效。 再看 key.GetPubKey()，该函数通过调用secp256k1库提供的函数首先通过secp256k1_ec_pubkey_create函数创建公钥值，再通过secp256k1_ec_pubkey_serialize函数实现压缩或非压缩公钥序列值的计算。 最后验证公钥 return key.VerifyPubKey(pubkey); bool CKey::VerifyPubKey(const CPubKey&amp; pubkey) const { if (pubkey.IsCompressed() != fCompressed) { return false; } unsigned char rnd[8]; std::string str = &quot;Bitcoin key verification\n&quot;; GetRandBytes(rnd, sizeof(rnd)); uint256 hash; CHash256().Write((unsigned char*)str.data(), str.size()).Write(rnd, sizeof(rnd)).Finalize(hash.begin()); std::vector&lt;unsigned char&gt; vchSig; Sign(hash, vchSig); return pubkey.Verify(hash, vchSig); } 获取8字节的随机数，把”Bitcoin key verification”和生成的随机数共同计算哈希值，在sign函数通过该哈希值基于ECADSA算法实现签名的计算，利用签名信息验证获取的公钥的有效性，验证函数为Verify(） //pubkey.h /** * Verify a DER signature (~72 bytes). * If this public key is not fully valid, the return value will be false. */ bool Verify(const uint256&amp; hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 这个验证函数是验证DER格式的签名，DER是一种编码方案 II C与C++运行环境验证 glibc_sanity_test() 、 !glibcxx_sanity_test()这两个函数就是验证运行环境中C/C++运行库的有效性，即比特币核心软件能否在当前环境中正常运行。 3) 锁定目录结构 确保只有一个比特币进程在使用数据目录 // Make sure only a single Bitcoin process is using the data directory. boost::filesystem::path pathLockFile = GetDataDir() / &quot;.lock&quot;; FILE* file = fopen(pathLockFile.string().c_str(), &quot;a&quot;); // empty lock file; created if it doesn&#39;t exist. if (file) fclose(file); try { static boost::interprocess::file_lock lock(pathLockFile.string().c_str()); if (!lock.try_lock()) return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;), strDataDir, _(PACKAGE_NAME))); } catch(const boost::interprocess::interprocess_exception&amp; e) { return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;) + &quot; %s.&quot;, strDataDir, _(PACKAGE_NAME), e.what())); } 4）创建pid文件 对于非windows系统创建进程的pid文件 #ifndef WIN32 CreatePidFile(GetPidFile(), getpid()); #endif 参考文章http://siwind.iteye.com/blog/1753517可以知道 (1) pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。 用cat命令可以看到。 (2) pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 那么这段代码创建pid文件的目的就是防止进程启动多个副本，从而打乱原有的消息传输。 5）参数设置 I 限定日志大小 if (GetBoolArg(&quot;-shrinkdebugfile&quot;, !fDebug)) ShrinkDebugFile(); -shrinkdebugfile:Shrink debug.log file on client startup (default: 1 when no -debug) 限制日志文件的大小，如果没有设置-debug参数，那么默认值为1 如果设置了这个参数，则调用函数ShrinkDebugFile //util.cpp void ShrinkDebugFile() { // Scroll debug.log if it&#39;s getting too big boost::filesystem::path pathLog = GetDataDir() / &quot;debug.log&quot;; FILE* file = fopen(pathLog.string().c_str(), &quot;r&quot;); if (file &amp;&amp; boost::filesystem::file_size(pathLog) &gt; 10 * 1000000) { // Restart the file with some of the end std::vector &lt;char&gt; vch(200000,0); fseek(file, -((long)vch.size()), SEEK_END); int nBytes = fread(begin_ptr(vch), 1, vch.size(), file); fclose(file); file = fopen(pathLog.string().c_str(), &quot;w&quot;); if (file) { fwrite(begin_ptr(vch), 1, nBytes, file); fclose(file); } } else if (file != NULL) fclose(file); } 判断debug.log文件大小超过10*1000000（10M）的话就重新读取文件最后200000字节的内容重新保存到debug.log文件中。 II deuglog显示处理 if (fPrintToDebugLog) OpenDebugLog(); 默认是打印到测试日志的 //util.cpp bool fPrintToDebugLog = true; OpenDebugLog（）函数实现如下 //util.cpp static void DebugPrintInit() { assert(mutexDebugLog == NULL); mutexDebugLog = new boost::mutex(); vMsgsBeforeOpenLog = new list&lt;string&gt;; } void OpenDebugLog() { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); assert(fileout == NULL); assert(vMsgsBeforeOpenLog); boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; fileout = fopen(pathDebug.string().c_str(), &quot;a&quot;); if (fileout) setbuf(fileout, NULL); // unbuffered // dump buffered messages from before we opened the log while (!vMsgsBeforeOpenLog-&gt;empty()) { FileWriteStr(vMsgsBeforeOpenLog-&gt;front(), fileout); vMsgsBeforeOpenLog-&gt;pop_front(); } delete vMsgsBeforeOpenLog; vMsgsBeforeOpenLog = NULL; } Boost线程库提供了boost::call_once来支持“一次实现”，并且定义了一个标志boost::once_flag及一个初始化这个标志的宏BOOST_ONCE_INIT。并且是在编译期间初始化而不是运行期间 boost::call_once表示在多线程访问该语句时始终只执行一次调用的函数,来确保mutexDebugLog和 vMsgsBeforeOpenLog的初始化是线程安全的。 //util.cpp static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT; 其中第一个参数是被调用的函数地址，第二个参数类型为boost::once_flag，并初始化这个标志为BOOST_ONCE_INIT 在函数DebugPrintInit()中定义了变量mutexDebugLog,类型为boost::mutex()，表示为互斥锁，在OpenDebugLog()函数中是使用了boost::mutex::scoped_lock来上锁，scoped_lock是能够保证在作用域范围内是互斥访问的，离开作用域时由析构函数自动解锁。在DebugPrintInit()中创建了对象vMsgsBeforeOpenLog，类型为链表，此时链表为空，在OpenDebugLog()中需要在打开日志前转储缓冲信息，就是把vMsgsBeforeOpenLog的信息转到debug.log中，那么vMsgsBeforeOpenLog的内容是怎么获得的呢 在util.cpp的LogPrintStr函数中 // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } 这里就是把日志先存入vMsgsBeforeOpenLog在log文件未打开的时候，所以在OpenDebugLog()之前vMsgsBeforeOpenLog变量已经被创建了，然后LogPrintStr又被调用了很多次，每次都写入一写内容。 III 打印提示信息 if (!fLogTimestamps) LogPrintf(&quot;Startup time: %s\n&quot;, DateTimeStrFormat(&quot;%Y-%m-%d %H:%M:%S&quot;, GetTime())); LogPrintf(&quot;Default data directory %s\n&quot;, GetDefaultDataDir().string()); LogPrintf(&quot;Using data directory %s\n&quot;, strDataDir); LogPrintf(&quot;Using config file %s\n&quot;, GetConfigFile().string()); LogPrintf(&quot;Using at most %i connections (%i file descriptors available)\n&quot;, nMaxConnections, nFD); std::ostringstream strErrors; 如果没有设置打印时间戳，就打印起始时间，后面打印默认地址、数据目录之类的信息。 （五）草稿中。。。 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/08/08/3953b10ee3d49809c25fe8a6d4f70017.html" />
<meta property="og:url" content="https://mlh.app/2018/08/08/3953b10ee3d49809c25fe8a6d4f70017.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81450432 源码0.13.2版的，在vscode中打开的 目录 源码0.13.2版的，在vscode中打开的 9）交易标准与签名字节数 10）钱包相关参数 11）交易相关参数 12）各种参数 13）mempoolreplacement 9.4 application initialization 1）椭圆加密曲线 2) initsanitycheck 3) 锁定目录结构 4）创建pid文件 5）参数设置 9）交易标准与签名字节数 非标准交易 fRequireStandard = !GetBoolArg(&quot;-acceptnonstdtxn&quot;, !Params().RequireStandard()); if (Params().RequireStandard() &amp;&amp; !fRequireStandard) return InitError(strprintf(&quot;acceptnonstdtxn is not currently supported for %s chain&quot;, chainparams.NetworkIDString())); Params().RequireStandard()就是返回fRequireStandard //chainparams.h class CChainParams /** Policy: Filter transactions that do not match well-defined patterns */ bool RequireStandard() const { return fRequireStandard; } bool fRequireStandard; params()是在step2中定义的，CChainParams是基类，有三个子类这个之前也介绍过了，三个子类是基于不同的网络的，在主网中fRequireStandard=true,测试网和私有网都是false。也就是主网只接受标准交易，测试网与私有网可以接受非标准交易。 签名字节数 nBytesPerSigOp = GetArg(&quot;-bytespersigop&quot;, nBytesPerSigOp); 默认的签名操作字节数为20 //src/policy/policy.cpp unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP; //policy.h /** Default for -bytespersigop */ static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20; 10）钱包相关参数 I 钱包开关 #ifdef ENABLE_WALLET if (!CWallet::ParameterInteraction()) return false; #endif // ENABLE_WALLET ENABLE_WALLET宏定义开关在configure.ac文件中，可以在源码编译的时候控制该宏定义的开关 //configure.ac # Enable wallet AC_ARG_ENABLE([wallet], [AS_HELP_STRING([--disable-wallet], [disable wallet (enabled by default)])], [enable_wallet=$enableval], [enable_wallet=yes]) 可以看到默认是打开钱包的，我们可以在运行比特币钱包客户端时通过disablewallet参数关闭钱包功能。 再看CWallet::ParameterInteraction()，如果设置了开启钱包，那么与钱包相关的交互参数必须设置正确，否则程序返回。CWallet::ParameterInteraction()位于src/wallet/wallet.cpp中，分析函数中的各个参数 II -mintxfee 每kb低于mintxfee的费用被视为交易创建时的未付费 if (mapArgs.count(&quot;-mintxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-mintxfee&quot;], n) &amp;&amp; n &gt; 0) CWallet::minTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;mintxfee&quot;, mapArgs[&quot;-mintxfee&quot;])); } ParseMoney()位于utilmoneystr.cpp，用于解析传入的数字，转为聪为单位的费用（包括小数的处理，数据格式正确与否）传回计算后的数值。这段的参数处理代码与minRelayTxFee参数的处理基本一致。 //amount.h static const CAmount COIN = 100000000; III -fallbackfee 当没有足够的信息用以估算费用时默认使用的费率。 代码中先解析参数是否正确，另外判断参数如果超过最高费率HIGH_TX_FEE_PER_KB会报警告⚠️ //main.h //! Discourage users to set fees higher than this amount (in satoshis) per kB static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN; 那么HIGH_TX_FEE_PER_KB为0.01BTC III -paytxfee与maxtxfee 分别代表支付交易手续费与最高交易手续费，如果高于最高费率HIGH_TX_FEE_PER_KB有警告提示，若是低于最低费率::minRelayTxFee，则报错退出程序。 IV -txconfirmtarget nTxConfirmTarget = GetArg(&quot;-txconfirmtarget&quot;, DEFAULT_TX_CONFIRM_TARGET); 从注释来看，txconfirmtarget表示如果没有设置paytxfee，则使用足够的费用，以便交易可能在平均n个块（默认值：%u）内开始确认。 //src/wallet/wallet.h //! -txconfirmtarget default static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2; 这里的默认值为2。如果设为6，你的交易获得首个确认将花费平均6个区块链验证时间。从0.14版本开始就是6个了，也就是我们说的比特币每一笔交易都需要经过6个区块确认才能算真正的交易成功。 V spendzeroconfchange 在发送交易时花费未确认的更改，也就是可以花费0确认的费用 bSpendZeroConfChange = GetBoolArg(&quot;-spendzeroconfchange&quot;, DEFAULT_SPEND_ZEROCONF_CHANGE); 在这里是默认可以的 //src/wallet/wallet.h //! Default for -spendzeroconfchange static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true; //! Default for -sendfreetransactions static const bool DEFAULT_SEND_FREE_TRANSACTIONS = false; VI fSendFreeTransactions 如果可能，发送0费用的交易 fSendFreeTransactions = GetBoolArg(&quot;-sendfreetransactions&quot;, DEFAULT_SEND_FREE_TRANSACTIONS); 默认为不可以，默认不可以发送0手续费的交易 11）交易相关参数 fIsBareMultisigStd = GetBoolArg(&quot;-permitbaremultisig&quot;, DEFAULT_PERMIT_BAREMULTISIG); fAcceptDatacarrier = GetBoolArg(&quot;-datacarrier&quot;, DEFAULT_ACCEPT_DATACARRIER); nMaxDatacarrierBytes = GetArg(&quot;-datacarriersize&quot;, nMaxDatacarrierBytes); I -permitbaremultisig 从注释来看是传递非P2SH多重签名脚本，默认是允许的 Relay non-P2SH multisig (default: %u)&quot;), DEFAULT_PERMIT_BAREMULTISIG //main.h /** Default for -permitbaremultisig */ static const bool DEFAULT_PERMIT_BAREMULTISIG = true; 也就是默认非P2SH多重签名的交易在全网传播。 II -datacarrier、-datacarriersize 在帮助信息中找到注释，-datacarrier表示传播和挖矿包含交易以外数据信息的交易，默认设置为true;再看datacarriersize表示包含数据的交易大小默认值 //src/script/standard.cpp unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY; //src/script/standard.h static const unsigned int MAX_OP_RETURN_RELAY = 83; 其默认值为83字节 12）各种参数 I mocktime 用于回归测试，从新时期（这里指1970年，从输出time” : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT) 推测）开始用n秒替换真实时间 // Option to startup with mocktime set (used for regression testing): SetMockTime(GetArg(&quot;-mocktime&quot;, 0)); // SetMockTime(0) is a no-op 调用函数SetMockTime，执行赋值操作，一句代码。 //utlitime.cpp static int64_t nMockTime = 0; //!&lt; For unit testing void SetMockTime(int64_t nMockTimeIn) { nMockTime = nMockTimeIn; } 从注释可以看到，mocktime是用于单元测试的，默认值为0。 II peerbloomfilter if (GetBoolArg(&quot;-peerbloomfilters&quot;, DEFAULT_PEERBLOOMFILTERS)) nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM); //main.h static const bool DEFAULT_PEERBLOOMFILTERS = true; Bloom滤波器支持块过滤和事务处理，默认为true,关于bloom的具体信息可以看《精通比特币（第二版）》8.9Bloom过滤器。在支持过滤器的前提下，程序中设置了当前运行节点的服务模式 //net.cpp ServiceFlags nLocalServices = NODE_NETWORK; ServiceFlags是枚举类型，nLocalServices是初始赋值为NODE_NETWORK，在上述代码中又增加赋值NODE_BLOOM，即具备全节点信息存储与bloom过滤器功能，这两者是所有客户端默认具备的。 //protocol.h /** nServices flags */ enum ServiceFlags : uint64_t { // Nothing NODE_NONE = 0, // NODE_NETWORK means that the node is capable of serving the block chain. It is currently // set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want // network services but don&#39;t provide them. NODE_NETWORK = (1 &lt;&lt; 0), // NODE_GETUTXO means the node is capable of responding to the getutxo protocol request. // Bitcoin Core does not support this but a patch set called Bitcoin XT does. // See BIP 64 for details on how this is implemented. NODE_GETUTXO = (1 &lt;&lt; 1), // NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections. // Bitcoin Core nodes used to support this by default, without advertising this bit, // but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION) NODE_BLOOM = (1 &lt;&lt; 2), // Indicates that a node can be asked for blocks and transactions including // witness data. NODE_WITNESS = (1 &lt;&lt; 3), ··· }; III -rpcserialversion 从帮助信息来看，该参数表示在非冗长模式、非隔离见证（0）或隔离见证（1）模式下原始交易或区块以16进制序列化方式呈现。默认值为1 //src/rpc/server.h static const unsigned int DEFAULT_RPC_SERIALIZE_VERSION = 1; 代码主要是对取值做判断，该值只能为0或1 if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &lt; 0) return InitError(&quot;rpcserialversion must be non-negative.&quot;); if (GetArg(&quot;-rpcserialversion&quot;, DEFAULT_RPC_SERIALIZE_VERSION) &gt; 1) return InitError(&quot;unknown rpcserialversion requested.&quot;); IV maxtipage nMaxTipAge = GetArg(&quot;-maxtipage&quot;, DEFAULT_MAX_TIP_AGE); 结合帮助信息和默认值来看，该参数表示当我们运行的节点包含的区块信息落后主网最长点24小时后，比特币客户端将进行区块同步下载(initial block download)操作。 //main.h static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60; 关于initial block download(IBD)从官网的解释来看，并不是只能在刚启动时执行，而是当前节点信息落后全网最长链24小时或144个块就会执行。 13）mempoolreplacement mempoolreplacement:Enable transaction replacement in the memory pool 表示能够替换交易池的交易，这个解释有些笼统，去bitcoinwiki查找transaction replacement,所谓交易替换是指可以在拥有全节点的客户端中替换交易池的交易，即针对同一输入，可以用花费了该部分或全部该输入金额的交易替换交易池中的交易。因此交易池中的交易是可以被替换的，前提是替换的交易产生于同一输入 fEnableReplacement = GetBoolArg(&quot;-mempoolreplacement&quot;, DEFAULT_ENABLE_REPLACEMENT); if ((!fEnableReplacement) &amp;&amp; mapArgs.count(&quot;-mempoolreplacement&quot;)) { // Minimal effort at forwards compatibility std::string strReplacementModeList = GetArg(&quot;-mempoolreplacement&quot;, &quot;&quot;); // default is impossible std::vector&lt;std::string&gt; vstrReplacementModes; boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(&quot;,&quot;)); fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), &quot;fee&quot;) != vstrReplacementModes.end()); } 先看下其默认值 //main.h /** Default for -mempoolreplacement */ static const bool DEFAULT_ENABLE_REPLACEMENT = true; 默认打开交易替换，解释一下boost::split,其中vstrReplacementModes是用来存储分割的结果的容器，strReplacementModeList是要分割的内容，按“，“分割，这段就是查找交易池替换模式内容，判断是否包含”fee”模式，如果包含则fEnableReplacement=true. 14)bip9params 首先查看帮助信息 -bip9params=deployment:start:end Use given start/end times for specified bip9 deployment (regtest-only) bip9params是比特币在私有网测试时使用的参数，作为执行部署、执行部署开始和部署结束时间。bip9信号与激活的相关概念可以参考《精通比特币（第二版）》10.14使用区块版本发出软分叉信号。 bip9之前BIP-34，BIP-66 和 BIP-65 使用的机制成功地激活了三个软分叉，但通过使用块版本的整数值来实现，每次只能激活一个分叉，bip9将块版本解释为bit字段而不是一个整数，以及一些其他的规范。 回到代码部分，主要是针对bip9params参数的值进行私有网络测试部署，以测试软分叉后软件是否运行正常。 从这里开始，之前参考的作者写的就不适合我继续参考了，开始参考另一位博主了–Splay– 9.4 application initialization // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log 1）椭圆加密曲线 初始化椭圆曲线 // Initialize elliptic curve code ECC_Start(); globalVerifyHandle.reset(new ECCVerifyHandle()); 先看ECC_Start()，实现在key.cpp void ECC_Start() { assert(secp256k1_context_sign == NULL); secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN); assert(ctx != NULL); { // Pass in a random blinding seed to the secp256k1 context. unsigned char seed[32]; LockObject(seed); GetRandBytes(seed, 32); bool ret = secp256k1_context_randomize(ctx, seed); assert(ret); UnlockObject(seed); } secp256k1_context_sign = ctx; } 2) initsanitycheck 可用性检测，未通过则报错 // Sanity check if (!InitSanityCheck()) return InitError(strprintf(_(&quot;Initialization sanity check failed. %s is shutting down.&quot;), _(PACKAGE_NAME))); 主要功能是确保比特币在可用的环境中运行，并提供所有必要的库支持。 //init.cpp /** Sanity checks * Ensure that Bitcoin is running in a usable environment with all * necessary library support. */ bool InitSanityCheck(void) { if(!ECC_InitSanityCheck()) { InitError(&quot;Elliptic curve cryptography sanity check failure. Aborting.&quot;); return false; } if (!glibc_sanity_test() || !glibcxx_sanity_test()) return false; return true; } 主要是三个验证，ECC_InitSanityCheck()为椭圆曲线加密结果的完整性验证，glibc_sanity_test() 和 glibcxx_sanity_test()验证当前运行环境是否支持C/C++运行环境 I ECC_nitSanityCheck 椭圆曲线加密结果验证 //key.cpp bool ECC_InitSanityCheck() { CKey key; key.MakeNewKey(true); CPubKey pubkey = key.GetPubKey(); return key.VerifyPubKey(pubkey); } //key.h /** Check that required EC support is available at runtime. */ bool ECC_InitSanityCheck(void); 首先定义私钥对象，CKey类型 //key.h /** An encapsulated private key. */ class CKey { private: //! Whether this private key is valid. We check for correctness when modifying the key //! data, so fValid should always correspond to the actual state. bool fValid; //! Whether the public key corresponding to this private key is (to be) compressed. bool fCompressed; //! The actual byte data unsigned char vch[32]; //! Check whether the 32-byte array pointed to be vch is valid keydata. bool static Check(const unsigned char* vch); 可以看到私钥是保存在长度为32的字符串vch中，我们知道私钥是256位，256/8=32字节。fValid参数用于表示私钥是否有效，该参数是在私钥发生变化时进行相应的修改，即私钥值有效为true。fCompressed表示与这个私钥相符合的公钥是否被压缩，true为压缩公钥。Check检查这32位字节是否是有效的密钥数据。 //key.h class CKey内 public: //! Construct an invalid private key. CKey() : fValid(false), fCompressed(false) { LockObject(vch); } 定义对象调用构造函数时，该私钥是无效的，对应的公钥是不压缩的。调用 LockObject锁定私钥，从注释分析这个函数 //src/support/pagelocker.h Functions for directly locking/unlocking memory objects. Intended for non-dynamically allocated structures. //用于直接锁定/解锁内存对象的函数。用于非动态分配结构。 template &lt;typename T&gt; void LockObject(const T&amp; t) { LockedPageManager::Instance().LockRange((void*)(&amp;t), sizeof(T)); } LockRange就是在所有管理范围内，会新增一个锁的计数，具体代码不再展开 之后要创建私钥，来看MakeNewKey()这个函数,传入的参数true代表与私钥相符合的公钥是压缩的 //key.h //! Generate a new private key using a cryptographic PRNG. void MakeNewKey(bool fCompressed); //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch)); } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 从注释看这个函数通过使用加密PRNG（伪随机数，可以参考《图解密码技术》第12章随机数也可以百度）生成私钥。通过GetStrongRandBytes循环获取私钥，直到满足 Check的条件为止。找到满足的私钥后，设置该密钥为有效，是否压缩赋值。 //random.cpp void GetStrongRandBytes(unsigned char* out, int num) { assert(num &lt;= 32); CSHA512 hasher; unsigned char buf[64]; // First source: OpenSSL&#39;s RNG RandAddSeedPerfmon(); GetRandBytes(buf, 32); hasher.Write(buf, 32); // Second source: OS RNG GetOSRand(buf); hasher.Write(buf, 32); // Produce output hasher.Finalize(buf); memcpy(out, buf, num); memory_cleanse(buf, 64); } 通过OpenSSL’s RNG获得随机数，然后通过OS RNG获取随机数，生成哈希值，这里使用的是SHA512哈希算法，不过私钥是256位，所以我们只需要32位，之后清除随机数的内存。 Check函数的实现 //key.cpp bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } 这个函数是调用libsecp256k1库实现随机数的验证，libsecp256k1库的源码也包含在比特币源码中，位于src/secp256k1文件夹中，在secp256k1.h中有该函数的声明 /** Verify an ECDSA secret key. * * Returns: 1: secret key is valid * 0: secret key is invalid * Args: ctx: pointer to a context object (cannot be NULL) * In: seckey: pointer to a 32-byte secret key (cannot be NULL) */ 这个函数的功能是验证基于椭圆曲线创建的密钥。 下一步，创建公钥CPubKey pubkey = key.GetPubKey();先看CPubKey类 //pubkey.h class CPubKey /** * Just store the serialized data. * Its length can very cheaply be computed from the first byte. */ unsigned char vch[65]; ··· 包含一个参数vch[65]主要用于存储序列化的公钥值，可以通过第一个字节即vch[0]获取公钥的长度，如果该值为2或3则为压缩公钥长度为33，值为4，6，7则为非压缩公钥长度为65。不是上述值，则该公钥值无效。 再看 key.GetPubKey()，该函数通过调用secp256k1库提供的函数首先通过secp256k1_ec_pubkey_create函数创建公钥值，再通过secp256k1_ec_pubkey_serialize函数实现压缩或非压缩公钥序列值的计算。 最后验证公钥 return key.VerifyPubKey(pubkey); bool CKey::VerifyPubKey(const CPubKey&amp; pubkey) const { if (pubkey.IsCompressed() != fCompressed) { return false; } unsigned char rnd[8]; std::string str = &quot;Bitcoin key verification\\n&quot;; GetRandBytes(rnd, sizeof(rnd)); uint256 hash; CHash256().Write((unsigned char*)str.data(), str.size()).Write(rnd, sizeof(rnd)).Finalize(hash.begin()); std::vector&lt;unsigned char&gt; vchSig; Sign(hash, vchSig); return pubkey.Verify(hash, vchSig); } 获取8字节的随机数，把”Bitcoin key verification”和生成的随机数共同计算哈希值，在sign函数通过该哈希值基于ECADSA算法实现签名的计算，利用签名信息验证获取的公钥的有效性，验证函数为Verify(） //pubkey.h /** * Verify a DER signature (~72 bytes). * If this public key is not fully valid, the return value will be false. */ bool Verify(const uint256&amp; hash, const std::vector&lt;unsigned char&gt;&amp; vchSig) const; 这个验证函数是验证DER格式的签名，DER是一种编码方案 II C与C++运行环境验证 glibc_sanity_test() 、 !glibcxx_sanity_test()这两个函数就是验证运行环境中C/C++运行库的有效性，即比特币核心软件能否在当前环境中正常运行。 3) 锁定目录结构 确保只有一个比特币进程在使用数据目录 // Make sure only a single Bitcoin process is using the data directory. boost::filesystem::path pathLockFile = GetDataDir() / &quot;.lock&quot;; FILE* file = fopen(pathLockFile.string().c_str(), &quot;a&quot;); // empty lock file; created if it doesn&#39;t exist. if (file) fclose(file); try { static boost::interprocess::file_lock lock(pathLockFile.string().c_str()); if (!lock.try_lock()) return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;), strDataDir, _(PACKAGE_NAME))); } catch(const boost::interprocess::interprocess_exception&amp; e) { return InitError(strprintf(_(&quot;Cannot obtain a lock on data directory %s. %s is probably already running.&quot;) + &quot; %s.&quot;, strDataDir, _(PACKAGE_NAME), e.what())); } 4）创建pid文件 对于非windows系统创建进程的pid文件 #ifndef WIN32 CreatePidFile(GetPidFile(), getpid()); #endif 参考文章http://siwind.iteye.com/blog/1753517可以知道 (1) pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。 用cat命令可以看到。 (2) pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 那么这段代码创建pid文件的目的就是防止进程启动多个副本，从而打乱原有的消息传输。 5）参数设置 I 限定日志大小 if (GetBoolArg(&quot;-shrinkdebugfile&quot;, !fDebug)) ShrinkDebugFile(); -shrinkdebugfile:Shrink debug.log file on client startup (default: 1 when no -debug) 限制日志文件的大小，如果没有设置-debug参数，那么默认值为1 如果设置了这个参数，则调用函数ShrinkDebugFile //util.cpp void ShrinkDebugFile() { // Scroll debug.log if it&#39;s getting too big boost::filesystem::path pathLog = GetDataDir() / &quot;debug.log&quot;; FILE* file = fopen(pathLog.string().c_str(), &quot;r&quot;); if (file &amp;&amp; boost::filesystem::file_size(pathLog) &gt; 10 * 1000000) { // Restart the file with some of the end std::vector &lt;char&gt; vch(200000,0); fseek(file, -((long)vch.size()), SEEK_END); int nBytes = fread(begin_ptr(vch), 1, vch.size(), file); fclose(file); file = fopen(pathLog.string().c_str(), &quot;w&quot;); if (file) { fwrite(begin_ptr(vch), 1, nBytes, file); fclose(file); } } else if (file != NULL) fclose(file); } 判断debug.log文件大小超过10*1000000（10M）的话就重新读取文件最后200000字节的内容重新保存到debug.log文件中。 II deuglog显示处理 if (fPrintToDebugLog) OpenDebugLog(); 默认是打印到测试日志的 //util.cpp bool fPrintToDebugLog = true; OpenDebugLog（）函数实现如下 //util.cpp static void DebugPrintInit() { assert(mutexDebugLog == NULL); mutexDebugLog = new boost::mutex(); vMsgsBeforeOpenLog = new list&lt;string&gt;; } void OpenDebugLog() { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); assert(fileout == NULL); assert(vMsgsBeforeOpenLog); boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; fileout = fopen(pathDebug.string().c_str(), &quot;a&quot;); if (fileout) setbuf(fileout, NULL); // unbuffered // dump buffered messages from before we opened the log while (!vMsgsBeforeOpenLog-&gt;empty()) { FileWriteStr(vMsgsBeforeOpenLog-&gt;front(), fileout); vMsgsBeforeOpenLog-&gt;pop_front(); } delete vMsgsBeforeOpenLog; vMsgsBeforeOpenLog = NULL; } Boost线程库提供了boost::call_once来支持“一次实现”，并且定义了一个标志boost::once_flag及一个初始化这个标志的宏BOOST_ONCE_INIT。并且是在编译期间初始化而不是运行期间 boost::call_once表示在多线程访问该语句时始终只执行一次调用的函数,来确保mutexDebugLog和 vMsgsBeforeOpenLog的初始化是线程安全的。 //util.cpp static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT; 其中第一个参数是被调用的函数地址，第二个参数类型为boost::once_flag，并初始化这个标志为BOOST_ONCE_INIT 在函数DebugPrintInit()中定义了变量mutexDebugLog,类型为boost::mutex()，表示为互斥锁，在OpenDebugLog()函数中是使用了boost::mutex::scoped_lock来上锁，scoped_lock是能够保证在作用域范围内是互斥访问的，离开作用域时由析构函数自动解锁。在DebugPrintInit()中创建了对象vMsgsBeforeOpenLog，类型为链表，此时链表为空，在OpenDebugLog()中需要在打开日志前转储缓冲信息，就是把vMsgsBeforeOpenLog的信息转到debug.log中，那么vMsgsBeforeOpenLog的内容是怎么获得的呢 在util.cpp的LogPrintStr函数中 // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } 这里就是把日志先存入vMsgsBeforeOpenLog在log文件未打开的时候，所以在OpenDebugLog()之前vMsgsBeforeOpenLog变量已经被创建了，然后LogPrintStr又被调用了很多次，每次都写入一写内容。 III 打印提示信息 if (!fLogTimestamps) LogPrintf(&quot;Startup time: %s\\n&quot;, DateTimeStrFormat(&quot;%Y-%m-%d %H:%M:%S&quot;, GetTime())); LogPrintf(&quot;Default data directory %s\\n&quot;, GetDefaultDataDir().string()); LogPrintf(&quot;Using data directory %s\\n&quot;, strDataDir); LogPrintf(&quot;Using config file %s\\n&quot;, GetConfigFile().string()); LogPrintf(&quot;Using at most %i connections (%i file descriptors available)\\n&quot;, nMaxConnections, nFD); std::ostringstream strErrors; 如果没有设置打印时间戳，就打印起始时间，后面打印默认地址、数据目录之类的信息。 （五）草稿中。。。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/08/08/3953b10ee3d49809c25fe8a6d4f70017.html","headline":"比特币源码学习0.13 (四)","dateModified":"2018-08-08T00:00:00+08:00","datePublished":"2018-08-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/08/3953b10ee3d49809c25fe8a6d4f70017.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13 (四)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81450432 
 </div> 
 <div class="markdown_views"> 
  <h3 id="源码0132版的在vscode中打开的">源码0.13.2版的，在vscode中打开的</h3> 
  <hr> 
  <p><span id="catalog">目录</span></p> 
  <p></p>
  <div class="toc"> 
   <ul> 
    <li>
     <ul> 
      <li>
       <ul> 
        <li><a href="#源码0132版的在vscode中打开的" rel="nofollow">源码0.13.2版的，在vscode中打开的</a>
         <ul> 
          <li>
           <ul> 
            <li>
             <ul> 
              <li><a href="#9交易标准与签名字节数" rel="nofollow">9）交易标准与签名字节数</a></li> 
              <li><a href="#10钱包相关参数" rel="nofollow">10）钱包相关参数</a></li> 
              <li><a href="#11交易相关参数" rel="nofollow">11）交易相关参数</a></li> 
              <li><a href="#12各种参数" rel="nofollow">12）各种参数</a></li> 
              <li><a href="#13mempoolreplacement" rel="nofollow">13）mempoolreplacement</a></li> 
             </ul> </li> 
            <li><a href="#94-application-initialization" rel="nofollow">9.4 application initialization</a>
             <ul> 
              <li><a href="#1椭圆加密曲线" rel="nofollow">1）椭圆加密曲线</a></li> 
              <li><a href="#2-initsanitycheck" rel="nofollow">2) initsanitycheck</a></li> 
              <li><a href="#3-锁定目录结构" rel="nofollow">3) 锁定目录结构</a></li> 
              <li><a href="#4创建pid文件" rel="nofollow">4）创建pid文件</a></li> 
              <li><a href="#5参数设置" rel="nofollow">5）参数设置</a></li> 
             </ul> </li> 
           </ul> </li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </div> 
  <p></p> 
  <hr> 
  <h6 id="9交易标准与签名字节数">9）交易标准与签名字节数</h6> 
  <p>非标准交易</p> 
  <pre class="prettyprint"><code class=" hljs lasso">    fRequireStandard <span class="hljs-subst">=</span> <span class="hljs-subst">!</span>GetBoolArg(<span class="hljs-string">"-acceptnonstdtxn"</span>, <span class="hljs-subst">!</span><span class="hljs-keyword">Params</span>()<span class="hljs-built_in">.</span>RequireStandard());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Params</span>()<span class="hljs-built_in">.</span>RequireStandard() <span class="hljs-subst">&amp;&amp;</span> <span class="hljs-subst">!</span>fRequireStandard)
        <span class="hljs-keyword">return</span> InitError(strprintf(<span class="hljs-string">"acceptnonstdtxn is not currently supported for %s chain"</span>, chainparams<span class="hljs-built_in">.</span>NetworkIDString()));</code></pre> 
  <p>Params().RequireStandard()就是返回fRequireStandard</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//chainparams.h class CChainParams</span>
<span class="hljs-javadoc">/** Policy: Filter transactions that do not match well-defined patterns */</span>
    bool RequireStandard() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> fRequireStandard; }
    bool fRequireStandard;</code></pre> 
  <p>params()是在step2中定义的，CChainParams是基类，有三个子类这个之前也介绍过了，三个子类是基于不同的网络的，在主网中fRequireStandard=true,测试网和私有网都是false。也就是主网只接受标准交易，测试网与私有网可以接受非标准交易。 <br> 签名字节数</p> 
  <pre class="prettyprint"><code class=" hljs bash"> nBytesPerSigOp = GetArg(<span class="hljs-string">"-bytespersigop"</span>, nBytesPerSigOp);</code></pre> 
  <p>默认的签名操作字节数为20</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//src/policy/policy.cpp</span>
unsigned <span class="hljs-keyword">int</span> nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;
<span class="hljs-comment">//policy.h</span>
<span class="hljs-javadoc">/** Default for -bytespersigop */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_BYTES_PER_SIGOP = <span class="hljs-number">20</span>;</code></pre> 
  <hr> 
  <h6 id="10钱包相关参数">10）钱包相关参数</h6> 
  <p>I 钱包开关</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-variable">#ifdef</span> ENABLE_WALLET
    <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>CWallet<span class="hljs-tag">::ParameterInteraction</span>())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
<span class="hljs-variable">#endif</span> <span class="hljs-comment">// ENABLE_WALLET</span></code></pre> 
  <p>ENABLE_WALLET宏定义开关在configure.ac文件中，可以在源码编译的时候控制该宏定义的开关</p> 
  <pre class="prettyprint"><code class=" hljs mel"><span class="hljs-comment">//configure.ac</span>
# Enable wallet
AC_ARG_ENABLE([wallet],
  [AS_HELP_STRING([--<span class="hljs-keyword">disable</span>-wallet],
  [<span class="hljs-keyword">disable</span> wallet (enabled by <span class="hljs-keyword">default</span>)])],
  [enable_wallet=<span class="hljs-variable">$enableval</span>],
  [enable_wallet=yes])</code></pre> 
  <p>可以看到默认是打开钱包的，我们可以在运行比特币钱包客户端时通过disablewallet参数关闭钱包功能。 <br> 再看CWallet::ParameterInteraction()，如果设置了开启钱包，那么与钱包相关的交互参数必须设置正确，否则程序返回。CWallet::ParameterInteraction()位于src/wallet/wallet.cpp中，分析函数中的各个参数 <br> II -mintxfee <br> 每kb低于mintxfee的费用被视为交易创建时的未付费</p> 
  <pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">if</span> (mapArgs.<span class="hljs-keyword">count</span>(<span class="hljs-string">"-mintxfee"</span>))
    {
        CAmount n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (ParseMoney(mapArgs[<span class="hljs-string">"-mintxfee"</span>], n) &amp;&amp; n &gt; <span class="hljs-number">0</span>)
            CWallet::minTxFee = CFeeRate(n);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"mintxfee"</span>, mapArgs[<span class="hljs-string">"-mintxfee"</span>]));
    }</code></pre> 
  <p>ParseMoney()位于utilmoneystr.cpp，用于解析传入的数字，转为聪为单位的费用（包括小数的处理，数据格式正确与否）传回计算后的数值。这段的参数处理代码与minRelayTxFee参数的处理基本一致。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//amount.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CAmount COIN = <span class="hljs-number">100000000</span>;</code></pre> 
  <p>III -fallbackfee <br> 当没有足够的信息用以估算费用时默认使用的费率。 <br> 代码中先解析参数是否正确，另外判断参数如果超过最高费率HIGH_TX_FEE_PER_KB会报警告⚠️</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//main.h</span>
<span class="hljs-comment">//! Discourage users to set fees higher than this amount (in satoshis) per kB</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CAmount HIGH_TX_FEE_PER_KB = <span class="hljs-number">0.01</span> * COIN;</code></pre> 
  <p>那么HIGH_TX_FEE_PER_KB为0.01BTC <br> III -paytxfee与maxtxfee <br> 分别代表支付交易手续费与最高交易手续费，如果高于最高费率HIGH_TX_FEE_PER_KB有警告提示，若是低于最低费率::minRelayTxFee，则报错退出程序。 <br> IV -txconfirmtarget</p> 
  <pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">nTxConfirmTarget = <span class="hljs-value">GetArg(<span class="hljs-string">"-txconfirmtarget"</span>, DEFAULT_TX_CONFIRM_TARGET);</span></span></code></pre> 
  <p>从注释来看，txconfirmtarget表示如果没有设置paytxfee，则使用足够的费用，以便交易可能在平均n个块（默认值：%u）内开始确认。</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//src/wallet/wallet.h</span>
<span class="hljs-comment">//! -txconfirmtarget default</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> DEFAULT_TX_CONFIRM_TARGET = <span class="hljs-number">2</span>;</code></pre> 
  <p>这里的默认值为2。如果设为6，你的交易获得首个确认将花费平均6个区块链验证时间。从0.14版本开始就是6个了，也就是我们说的比特币每一笔交易都需要经过6个区块确认才能算真正的交易成功。 <br> V spendzeroconfchange <br> 在发送交易时花费未确认的更改，也就是可以花费0确认的费用</p> 
  <pre class="prettyprint"><code class=" hljs bash"> bSpendZeroConfChange = GetBoolArg(<span class="hljs-string">"-spendzeroconfchange"</span>, DEFAULT_SPEND_ZEROCONF_CHANGE);</code></pre> 
  <p>在这里是默认可以的</p> 
  <pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-comment">//src/wallet/wallet.h</span>
 <span class="hljs-comment">//! Default for -spendzeroconfchange</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_SPEND_ZEROCONF_CHANGE = <span class="hljs-keyword">true</span>;
<span class="hljs-comment">//! Default for -sendfreetransactions</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_SEND_FREE_TRANSACTIONS = <span class="hljs-keyword">false</span>;</code></pre> 
  <p>VI fSendFreeTransactions <br> 如果可能，发送0费用的交易</p> 
  <pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">fSendFreeTransactions = <span class="hljs-value">GetBoolArg(<span class="hljs-string">"-sendfreetransactions"</span>, DEFAULT_SEND_FREE_TRANSACTIONS);</span></span></code></pre> 
  <p>默认为不可以，默认不可以发送0手续费的交易</p> 
  <hr> 
  <h6 id="11交易相关参数">11）交易相关参数</h6> 
  <pre class="prettyprint"><code class=" hljs bash"> fIsBareMultisigStd = GetBoolArg(<span class="hljs-string">"-permitbaremultisig"</span>, DEFAULT_PERMIT_BAREMULTISIG);
    fAcceptDatacarrier = GetBoolArg(<span class="hljs-string">"-datacarrier"</span>, DEFAULT_ACCEPT_DATACARRIER);
    nMaxDatacarrierBytes = GetArg(<span class="hljs-string">"-datacarriersize"</span>, nMaxDatacarrierBytes);</code></pre> 
  <p>I -permitbaremultisig <br> 从注释来看是传递非P2SH多重签名脚本，默认是允许的</p> 
  <pre class="prettyprint"><code class=" hljs dos">Relay non-P2SH multisig (default: %u)"), DEFAULT_PERMIT_BA<span class="hljs-comment">REMULTISIG</span>
//main.h
/** Default <span class="hljs-flow">for</span> -permitba<span class="hljs-comment">remultisig */</span>
static const bool DEFAULT_PERMIT_BA<span class="hljs-comment">REMULTISIG = true;</span></code></pre> 
  <p>也就是默认非P2SH多重签名的交易在全网传播。 <br> II -datacarrier、-datacarriersize <br> 在帮助信息中找到注释，-datacarrier表示传播和挖矿包含交易以外数据信息的交易，默认设置为true;再看datacarriersize表示包含数据的交易大小默认值</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//src/script/standard.cpp</span>
<span class="hljs-keyword">unsigned</span> nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY;
<span class="hljs-comment">//src/script/standard.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> MAX_OP_RETURN_RELAY = <span class="hljs-number">83</span>; </code></pre> 
  <p>其默认值为83字节</p> 
  <hr> 
  <h6 id="12各种参数">12）各种参数</h6> 
  <p>I mocktime <br> 用于回归测试，从新时期（这里指1970年，从输出time” : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT) 推测）开始用n秒替换真实时间</p> 
  <pre class="prettyprint"><code class=" hljs vhdl">    // Option <span class="hljs-keyword">to</span> startup <span class="hljs-keyword">with</span> mocktime set (used <span class="hljs-keyword">for</span> regression testing):
    SetMockTime(GetArg(<span class="hljs-string">"-mocktime"</span>, <span class="hljs-number">0</span>)); // SetMockTime(<span class="hljs-number">0</span>) <span class="hljs-keyword">is</span> a no-op</code></pre> 
  <p>调用函数SetMockTime，执行赋值操作，一句代码。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//utlitime.cpp</span>
<span class="hljs-keyword">static</span> int64_t nMockTime = <span class="hljs-number">0</span>; <span class="hljs-comment">//!&lt; For unit testing</span>
<span class="hljs-keyword">void</span> SetMockTime(int64_t nMockTimeIn)
{
    nMockTime = nMockTimeIn;
}</code></pre> 
  <p>从注释可以看到，mocktime是用于单元测试的，默认值为0。 <br> II peerbloomfilter</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-peerbloomfilters"</span>, DEFAULT_PEERBLOOMFILTERS))
        nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM);
<span class="hljs-comment">//main.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_PEERBLOOMFILTERS = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>Bloom滤波器支持块过滤和事务处理，默认为true,关于bloom的具体信息可以看《精通比特币（第二版）》8.9Bloom过滤器。在支持过滤器的前提下，程序中设置了当前运行节点的服务模式</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">//net.cpp ServiceFlags nLocalServices </span>=<span class="hljs-string"> NODE_NETWORK;</span></code></pre> 
  <p>ServiceFlags是枚举类型，nLocalServices是初始赋值为NODE_NETWORK，在上述代码中又增加赋值NODE_BLOOM，即具备全节点信息存储与bloom过滤器功能，这两者是所有客户端默认具备的。</p> 
  <pre class="prettyprint"><code class=" hljs mizar">//protocol.h
/** nServices flags */
enum ServiceFlags : uint64_t {
    // Nothing
    NODE_NONE = 0,
    // NODE_NETWORK <span class="hljs-keyword">means</span> <span class="hljs-keyword">that</span> the node <span class="hljs-keyword">is</span> capable <span class="hljs-keyword">of</span> serving the block chain. It <span class="hljs-keyword">is</span> currently
    // <span class="hljs-keyword">set</span> <span class="hljs-keyword">by</span> all Bitcoin Core nodes, <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> unset <span class="hljs-keyword">by</span> SPV clients <span class="hljs-keyword">or</span> other peers <span class="hljs-keyword">that</span> just want
    // network services but don't provide them.
    NODE_NETWORK = (1 &lt;&lt; 0),
    // NODE_GETUTXO <span class="hljs-keyword">means</span> the node <span class="hljs-keyword">is</span> capable <span class="hljs-keyword">of</span> responding to the getutxo protocol request.
    // Bitcoin Core does <span class="hljs-keyword">not</span> support this but a patch <span class="hljs-keyword">set</span> called Bitcoin XT does.
    // See BIP 64 <span class="hljs-keyword">for</span> details on how this <span class="hljs-keyword">is</span> implemented.
    NODE_GETUTXO = (1 &lt;&lt; 1),
    // NODE_BLOOM <span class="hljs-keyword">means</span> the node <span class="hljs-keyword">is</span> capable <span class="hljs-keyword">and</span> willing to handle bloom-filtered connections.
    // Bitcoin Core nodes used to support this <span class="hljs-keyword">by</span> default, without advertising this bit,
    // but no longer do <span class="hljs-keyword">as</span> <span class="hljs-keyword">of</span> protocol version 70011 (= NO_BLOOM_VERSION)
    NODE_BLOOM = (1 &lt;&lt; 2),
    // Indicates <span class="hljs-keyword">that</span> a node can <span class="hljs-keyword">be</span> asked <span class="hljs-keyword">for</span> blocks <span class="hljs-keyword">and</span> transactions including
    // witness data.
    NODE_WITNESS = (1 &lt;&lt; 3),
    ···
};</code></pre> 
  <p>III -rpcserialversion <br> 从帮助信息来看，该参数表示在非冗长模式、非隔离见证（0）或隔离见证（1）模式下原始交易或区块以16进制序列化方式呈现。默认值为1</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//src/rpc/server.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> DEFAULT_RPC_SERIALIZE_VERSION = <span class="hljs-number">1</span>;</code></pre> 
  <p>代码主要是对取值做判断，该值只能为0或1</p> 
  <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-keyword">if</span> (GetArg(<span class="hljs-string">"-rpcserialversion"</span>, DEFAULT_RPC_SERIALIZE_VERSION) &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"rpcserialversion must be non-negative."</span>);

    <span class="hljs-keyword">if</span> (GetArg(<span class="hljs-string">"-rpcserialversion"</span>, DEFAULT_RPC_SERIALIZE_VERSION) &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"unknown rpcserialversion requested."</span>);</code></pre> 
  <p>IV maxtipage</p> 
  <pre class="prettyprint"><code class=" hljs bash"> nMaxTipAge = GetArg(<span class="hljs-string">"-maxtipage"</span>, DEFAULT_MAX_TIP_AGE);</code></pre> 
  <p>结合帮助信息和默认值来看，该参数表示当我们运行的节点包含的区块信息落后主网最长点24小时后，比特币客户端将进行区块同步下载(initial block download)操作。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//main.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> int64_t DEFAULT_MAX_TIP_AGE = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;</code></pre> 
  <p>关于<a href="https://bitcoin.org/en/developer-guide#connecting-to-peers" rel="nofollow">initial block download(IBD)</a>从官网的解释来看，并不是只能在刚启动时执行，而是当前节点信息落后全网最长链24小时或144个块就会执行。</p> 
  <hr> 
  <h6 id="13mempoolreplacement">13）mempoolreplacement</h6> 
  <pre class="prettyprint"><code class=" hljs applescript">mempoolreplacement:Enable <span class="hljs-keyword">transaction</span> replacement <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> memory pool</code></pre> 
  <p>表示能够替换交易池的交易，这个解释有些笼统，去bitcoinwiki查找<a href="https://en.bitcoin.it/wiki/Transaction_replacement" rel="nofollow">transaction replacement</a>,所谓交易替换是指可以在拥有全节点的客户端中替换交易池的交易，即针对同一输入，可以用花费了该部分或全部该输入金额的交易替换交易池中的交易。因此交易池中的交易是可以被替换的，前提是替换的交易产生于同一输入</p> 
  <pre class="prettyprint"><code class=" hljs cpp">fEnableReplacement = GetBoolArg(<span class="hljs-string">"-mempoolreplacement"</span>, DEFAULT_ENABLE_REPLACEMENT);
    <span class="hljs-keyword">if</span> ((!fEnableReplacement) &amp;&amp; mapArgs.count(<span class="hljs-string">"-mempoolreplacement"</span>)) {
        <span class="hljs-comment">// Minimal effort at forwards compatibility</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strReplacementModeList = GetArg(<span class="hljs-string">"-mempoolreplacement"</span>, <span class="hljs-string">""</span>);  <span class="hljs-comment">// default is impossible</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> vstrReplacementModes;
        boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(<span class="hljs-string">","</span>));
        fEnableReplacement = (<span class="hljs-built_in">std</span>::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), <span class="hljs-string">"fee"</span>) != vstrReplacementModes.end());
    }</code></pre> 
  <p>先看下其默认值</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** Default for -mempoolreplacement */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> bool DEFAULT_ENABLE_REPLACEMENT = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>默认打开交易替换，解释一下boost::split,其中vstrReplacementModes是用来存储分割的结果的容器，strReplacementModeList是要分割的内容，按“，“分割，这段就是查找交易池替换模式内容，判断是否包含”fee”模式，如果包含则fEnableReplacement=true.</p> 
  <hr> 
  <p>14)bip9params <br> 首先查看帮助信息</p> 
  <pre class="prettyprint"><code class=" hljs sql">-bip9params=deployment:start:<span class="hljs-operator"><span class="hljs-keyword">end</span> Use given <span class="hljs-keyword">start</span>/<span class="hljs-keyword">end</span> times <span class="hljs-keyword">for</span> specified bip9 deployment (regtest-<span class="hljs-keyword">only</span>)</span></code></pre> 
  <p>bip9params是比特币在私有网测试时使用的参数，作为执行部署、执行部署开始和部署结束时间。bip9信号与激活的相关概念可以参考《精通比特币（第二版）》10.14使用区块版本发出软分叉信号。 <br> bip9之前BIP-34，BIP-66 和 BIP-65 使用的机制成功地激活了三个软分叉，但通过使用块版本的整数值来实现，每次只能激活一个分叉，bip9将块版本解释为bit字段而不是一个整数，以及一些其他的规范。 <br> 回到代码部分，主要是针对bip9params参数的值进行私有网络测试部署，以测试软分叉后软件是否运行正常。</p> 
  <hr> 
  <p>从这里开始，之前参考的作者写的就不适合我继续参考了，开始参考另一位博主了<a href="https://blog.csdn.net/pure_lady" rel="nofollow">–Splay–</a></p> 
  <h5 id="94-application-initialization">9.4 application initialization</h5> 
  <pre class="prettyprint"><code class=" hljs markdown"> // <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>** Step 4: application initialization: dir lock, daemonize, pidfile, debug log</code></pre> 
  <h6 id="1椭圆加密曲线">1）椭圆加密曲线</h6> 
  <p>初始化椭圆曲线</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">// Initialize elliptic curve code</span>
    <span class="hljs-function">ECC_Start()</span>;
    globalVerifyHandle<span class="hljs-class">.reset</span>(new <span class="hljs-function">ECCVerifyHandle()</span>);</code></pre> 
  <p>先看ECC_Start()，实现在key.cpp</p> 
  <pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">void</span> ECC_Start() {
    <span class="hljs-keyword">assert</span>(secp256k1_context_sign == NULL);

    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);
    <span class="hljs-keyword">assert</span>(ctx != NULL);

    {
        <span class="hljs-comment">// Pass in a random blinding seed to the secp256k1 context.</span>
        unsigned <span class="hljs-built_in">char</span> seed[<span class="hljs-number">32</span>];
        LockObject(seed);
        GetRandBytes(seed, <span class="hljs-number">32</span>);
        <span class="hljs-built_in">bool</span> ret = secp256k1_context_randomize(ctx, seed);
        <span class="hljs-keyword">assert</span>(ret);
        UnlockObject(seed);
    }
    secp256k1_context_sign = ctx;
}</code></pre> 
  <h6 id="2-initsanitycheck"><span id="&quot;initsanitycheck">2) initsanitycheck</span></h6> 
  <p>可用性检测，未通过则报错</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">// Sanity check</span>
    if (!<span class="hljs-function">InitSanityCheck()</span>)
        return <span class="hljs-function">InitError(<span class="hljs-function">strprintf(_(<span class="hljs-string">"Initialization sanity check failed. %s is shutting down."</span>)</span>, _(PACKAGE_NAME)</span>));</code></pre> 
  <p>主要功能是确保比特币在可用的环境中运行，并提供所有必要的库支持。</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//init.cpp</span>
<span class="hljs-javadoc">/** Sanity checks * Ensure that Bitcoin is running in a usable environment with all * necessary library support. */</span>
bool InitSanityCheck(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">if</span>(!ECC_InitSanityCheck()) {
        InitError(<span class="hljs-string">"Elliptic curve cryptography sanity check failure. Aborting."</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">if</span> (!glibc_sanity_test() || !glibcxx_sanity_test())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>主要是三个验证，ECC_InitSanityCheck()为椭圆曲线加密结果的完整性验证，glibc_sanity_test() 和 glibcxx_sanity_test()验证当前运行环境是否支持C/C++运行环境 <br> I ECC_nitSanityCheck <br> 椭圆曲线加密结果验证</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//key.cpp</span>
bool ECC_InitSanityCheck() {
    CKey key;
    key.MakeNewKey(<span class="hljs-keyword">true</span>);
    CPubKey pubkey = key.GetPubKey();
    <span class="hljs-keyword">return</span> key.VerifyPubKey(pubkey);
}
<span class="hljs-comment">//key.h</span>
<span class="hljs-javadoc">/** Check that required EC support is available at runtime. */</span>
bool ECC_InitSanityCheck(<span class="hljs-keyword">void</span>);</code></pre> 
  <p>首先定义私钥对象，CKey类型</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//key.h</span>
<span class="hljs-javadoc">/** An encapsulated private key. */</span>
class CKey
{
<span class="hljs-keyword">private</span>:
    //! Whether <span class="hljs-keyword">this</span> <span class="hljs-keyword">private</span> key is valid. We check <span class="hljs-keyword">for</span> correctness when modifying the key
    //! data, so fValid should always correspond to the actual state.
    bool fValid;
    <span class="hljs-comment">//! Whether the public key corresponding to this private key is (to be) compressed.</span>
    bool fCompressed;
    <span class="hljs-comment">//! The actual byte data</span>
    unsigned <span class="hljs-keyword">char</span> vch[<span class="hljs-number">32</span>];
    <span class="hljs-comment">//! Check whether the 32-byte array pointed to be vch is valid keydata.</span>
    bool <span class="hljs-keyword">static</span> Check(<span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">char</span>* vch);</code></pre> 
  <p>可以看到私钥是保存在长度为32的字符串vch中，我们知道私钥是256位，256/8=32字节。fValid参数用于表示私钥是否有效，该参数是在私钥发生变化时进行相应的修改，即私钥值有效为true。fCompressed表示与这个私钥相符合的公钥是否被压缩，true为压缩公钥。Check检查这32位字节是否是有效的密钥数据。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//key.h class CKey内</span>
<span class="hljs-keyword">public</span>:
    //! Construct an invalid <span class="hljs-keyword">private</span> key.
    <span class="hljs-title">CKey</span>() : <span class="hljs-title">fValid</span>(<span class="hljs-keyword">false</span>), <span class="hljs-title">fCompressed</span>(<span class="hljs-keyword">false</span>)
    {
        LockObject(vch);
    }</code></pre> 
  <p>定义对象调用构造函数时，该私钥是无效的，对应的公钥是不压缩的。调用 LockObject锁定私钥，从注释分析这个函数</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//src/support/pagelocker.h</span>
Functions <span class="hljs-keyword">for</span> directly locking/unlocking memory objects. Intended <span class="hljs-keyword">for</span> non-dynamically allocated structures.
<span class="hljs-comment">//用于直接锁定/解锁内存对象的函数。用于非动态分配结构。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> LockObject(<span class="hljs-keyword">const</span> T&amp; t)
{
    LockedPageManager::Instance().LockRange((<span class="hljs-keyword">void</span>*)(&amp;t), <span class="hljs-keyword">sizeof</span>(T));
}</code></pre> 
  <p>LockRange就是在所有管理范围内，会新增一个锁的计数，具体代码不再展开 <br> 之后要创建私钥，来看<span id="makenewkey"><font color="#008B8B">MakeNewKey()</font></span>这个函数,传入的参数true代表与私钥相符合的公钥是压缩的</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//key.h</span>
<span class="hljs-comment">//! Generate a new private key using a cryptographic PRNG.</span>
    <span class="hljs-keyword">void</span> MakeNewKey(<span class="hljs-keyword">bool</span> fCompressed);
<span class="hljs-comment">//key.cpp</span>
<span class="hljs-keyword">void</span> CKey::MakeNewKey(<span class="hljs-keyword">bool</span> fCompressedIn) {
    <span class="hljs-keyword">do</span> {
        GetStrongRandBytes(vch, <span class="hljs-keyword">sizeof</span>(vch));
    } <span class="hljs-keyword">while</span> (!Check(vch));
    fValid = <span class="hljs-keyword">true</span>;
    fCompressed = fCompressedIn;
}</code></pre> 
  <p>从注释看这个函数通过使用加密PRNG（伪随机数，可以参考《图解密码技术》第12章随机数也可以百度）生成私钥。通过GetStrongRandBytes循环获取私钥，直到满足 Check的条件为止。找到满足的私钥后，设置该密钥为有效，是否压缩赋值。</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//random.cpp</span>
void <span class="hljs-function">GetStrongRandBytes(unsigned char* out, int num)</span>
{
    <span class="hljs-function">assert(num &lt;= <span class="hljs-number">32</span>)</span>;
    CSHA512 hasher;
    unsigned <span class="hljs-value">char</span> buf<span class="hljs-attr_selector">[64]</span>;
    <span class="hljs-comment">// First source: OpenSSL's RNG</span>
    <span class="hljs-function">RandAddSeedPerfmon()</span>;
    <span class="hljs-function">GetRandBytes(buf, <span class="hljs-number">32</span>)</span>;
    hasher<span class="hljs-class">.Write</span>(buf, 32);
    <span class="hljs-comment">// Second source: OS RNG</span>
    <span class="hljs-function">GetOSRand(buf)</span>;
    hasher<span class="hljs-class">.Write</span>(buf, 32);
    <span class="hljs-comment">// Produce output</span>
    hasher<span class="hljs-class">.Finalize</span>(buf);
    <span class="hljs-function">memcpy(out, buf, num)</span>;
    <span class="hljs-function">memory_cleanse(buf, <span class="hljs-number">64</span>)</span>;
}</code></pre> 
  <p>通过OpenSSL’s RNG获得随机数，然后通过OS RNG获取随机数，生成哈希值，这里使用的是SHA512哈希算法，不过私钥是256位，所以我们只需要32位，之后清除随机数的内存。 <br> Check函数的实现</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//key.cpp</span>
<span class="hljs-keyword">bool</span> CKey::Check(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *vch) {
    <span class="hljs-keyword">return</span> secp256k1_ec_seckey_verify(secp256k1_context_sign, vch);
}</code></pre> 
  <p>这个函数是调用libsecp256k1库实现随机数的验证，libsecp256k1库的源码也包含在比特币源码中，位于src/secp256k1文件夹中，在secp256k1.h中有该函数的声明</p> 
  <pre class="prettyprint"><code class=" hljs vbnet">/** Verify an ECDSA secret <span class="hljs-keyword">key</span>.
 *
 *  Returns: <span class="hljs-number">1</span>: secret <span class="hljs-keyword">key</span> <span class="hljs-keyword">is</span> valid
 *           <span class="hljs-number">0</span>: secret <span class="hljs-keyword">key</span> <span class="hljs-keyword">is</span> invalid
 *  Args:    ctx: pointer <span class="hljs-keyword">to</span> a context <span class="hljs-built_in">object</span> (cannot be NULL)
 *  <span class="hljs-keyword">In</span>:      seckey: pointer <span class="hljs-keyword">to</span> a <span class="hljs-number">32</span>-<span class="hljs-built_in">byte</span> secret <span class="hljs-keyword">key</span> (cannot be NULL)
 */</code></pre> 
  <p>这个函数的功能是验证基于椭圆曲线创建的密钥。 <br> 下一步，创建公钥CPubKey pubkey = key.GetPubKey();先看CPubKey类</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//pubkey.h class CPubKey</span>
<span class="hljs-javadoc">/** * Just store the serialized data. * Its length can very cheaply be computed from the first byte. */</span>
    unsigned <span class="hljs-keyword">char</span> vch[<span class="hljs-number">65</span>];
    ···</code></pre> 
  <p>包含一个参数vch[65]主要用于存储序列化的公钥值，可以通过第一个字节即vch[0]获取公钥的长度，如果该值为2或3则为压缩公钥长度为33，值为4，6，7则为非压缩公钥长度为65。不是上述值，则该公钥值无效。 <br> 再看 key.GetPubKey()，该函数通过调用secp256k1库提供的函数首先通过secp256k1_ec_pubkey_create函数创建公钥值，再通过secp256k1_ec_pubkey_serialize函数实现压缩或非压缩公钥序列值的计算。 <br> 最后验证公钥 return key.VerifyPubKey(pubkey);</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CKey::VerifyPubKey(<span class="hljs-keyword">const</span> CPubKey&amp; pubkey) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (pubkey.IsCompressed() != fCompressed) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> rnd[<span class="hljs-number">8</span>];
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-string">"Bitcoin key verification\n"</span>;
    GetRandBytes(rnd, <span class="hljs-keyword">sizeof</span>(rnd));
    uint256 hash;
    CHash256().Write((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)str.data(), str.size()).Write(rnd, <span class="hljs-keyword">sizeof</span>(rnd)).Finalize(hash.begin());
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchSig;
    Sign(hash, vchSig);
    <span class="hljs-keyword">return</span> pubkey.Verify(hash, vchSig);
}</code></pre> 
  <p>获取8字节的随机数，把”Bitcoin key verification”和生成的随机数共同计算哈希值，在sign函数通过该哈希值基于ECADSA算法实现签名的计算，利用签名信息验证获取的公钥的有效性，验证函数为Verify(）</p> 
  <pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-comment">//pubkey.h</span>
 <span class="hljs-comment">/** * Verify a DER signature (~72 bytes). * If this public key is not fully valid, the return value will be false. */</span>
    <span class="hljs-keyword">bool</span> Verify(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span>&amp; vchSig) <span class="hljs-keyword">const</span>;</code></pre> 
  <p>这个验证函数是验证DER格式的签名，<a href="https://blog.csdn.net/baidu_36649389/article/details/53538223" rel="nofollow">DER</a>是一种编码方案 <br> II C与C++运行环境验证 <br> glibc_sanity_test() 、 !glibcxx_sanity_test()这两个函数就是验证运行环境中C/C++运行库的有效性，即比特币核心软件能否在当前环境中正常运行。</p> 
  <h6 id="3-锁定目录结构">3) 锁定目录结构</h6> 
  <p>确保只有一个比特币进程在使用数据目录</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// Make sure only a single Bitcoin process is using the data directory.</span>
    boost::filesystem::path pathLockFile = GetDataDir() / <span class="hljs-string">".lock"</span>;
    FILE* file = fopen(pathLockFile.<span class="hljs-keyword">string</span>().c_str(), <span class="hljs-string">"a"</span>); <span class="hljs-comment">// empty lock file; created if it doesn't exist.</span>
    <span class="hljs-keyword">if</span> (file) fclose(file);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">static</span> boost::interprocess::file_lock <span class="hljs-keyword">lock</span>(pathLockFile.<span class="hljs-keyword">string</span>().c_str());
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">lock</span>.try_lock())
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Cannot obtain a lock on data directory %s. %s is probably already running."</span>), strDataDir, _(PACKAGE_NAME)));
    } <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">const</span> boost::interprocess::interprocess_exception&amp; e) {
        <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Cannot obtain a lock on data directory %s. %s is probably already running."</span>) + <span class="hljs-string">" %s."</span>, strDataDir, _(PACKAGE_NAME), e.what()));
    }</code></pre> 
  <h6 id="4创建pid文件">4）创建pid文件</h6> 
  <p>对于非windows系统创建进程的pid文件</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef WIN32</span>
    CreatePidFile(GetPidFile(), getpid());
<span class="hljs-preprocessor">#endif</span></code></pre> 
  <p>参考文章<a href="http://siwind.iteye.com/blog/1753517" rel="nofollow">http://siwind.iteye.com/blog/1753517</a>可以知道</p> 
  <pre class="prettyprint"><code class=" hljs matlab">(<span class="hljs-number">1</span>) pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。 
用<span class="hljs-built_in">cat</span>命令可以看到。 
(<span class="hljs-number">2</span>) pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 </code></pre> 
  <p>那么这段代码创建pid文件的目的就是防止进程启动多个副本，从而打乱原有的消息传输。</p> 
  <h6 id="5参数设置">5）参数设置</h6> 
  <p>I 限定日志大小</p> 
  <pre class="prettyprint"><code class=" hljs scss">if (<span class="hljs-function">GetBoolArg(<span class="hljs-string">"-shrinkdebugfile"</span>, !fDebug)</span>)
        <span class="hljs-function">ShrinkDebugFile()</span>;</code></pre> 
  <blockquote> 
   <p>-shrinkdebugfile:Shrink debug.log file on client startup (default: 1 when no -debug) <br> 限制日志文件的大小，如果没有设置-debug参数，那么默认值为1</p> 
  </blockquote> 
  <p>如果设置了这个参数，则调用函数ShrinkDebugFile</p> 
  <pre class="prettyprint"><code class=" hljs mel"><span class="hljs-comment">//util.cpp</span>
void ShrinkDebugFile()
{
    <span class="hljs-comment">// Scroll debug.log if it's getting too big</span>
    boost::filesystem::path pathLog = GetDataDir() / <span class="hljs-string">"debug.log"</span>;
    FILE* <span class="hljs-keyword">file</span> = <span class="hljs-keyword">fopen</span>(pathLog.<span class="hljs-keyword">string</span>().c_str(), <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span> &amp;&amp; boost::filesystem::file_size(pathLog) &gt; <span class="hljs-number">10</span> * <span class="hljs-number">1000000</span>)
    {
        <span class="hljs-comment">// Restart the file with some of the end</span>
        std::<span class="hljs-keyword">vector</span> &lt;char&gt; vch(<span class="hljs-number">200000</span>,<span class="hljs-number">0</span>);
        fseek(<span class="hljs-keyword">file</span>, -((long)vch.<span class="hljs-keyword">size</span>()), SEEK_END);
        <span class="hljs-keyword">int</span> nBytes = <span class="hljs-keyword">fread</span>(begin_ptr(vch), <span class="hljs-number">1</span>, vch.<span class="hljs-keyword">size</span>(), <span class="hljs-keyword">file</span>);
        <span class="hljs-keyword">fclose</span>(<span class="hljs-keyword">file</span>);

        <span class="hljs-keyword">file</span> = <span class="hljs-keyword">fopen</span>(pathLog.<span class="hljs-keyword">string</span>().c_str(), <span class="hljs-string">"w"</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>)
        {
            <span class="hljs-keyword">fwrite</span>(begin_ptr(vch), <span class="hljs-number">1</span>, nBytes, <span class="hljs-keyword">file</span>);
            <span class="hljs-keyword">fclose</span>(<span class="hljs-keyword">file</span>);
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span> != NULL)
        <span class="hljs-keyword">fclose</span>(<span class="hljs-keyword">file</span>);
}</code></pre> 
  <p>判断debug.log文件大小超过10*1000000（10M）的话就重新读取文件最后200000字节的内容重新保存到debug.log文件中。 <br> II deuglog显示处理</p> 
  <pre class="prettyprint"><code class=" hljs bash">    <span class="hljs-keyword">if</span> (fPrintToDebugLog)
        OpenDebugLog();</code></pre> 
  <p>默认是打印到测试日志的</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//util.cpp</span>
<span class="hljs-keyword">bool</span> fPrintToDebugLog = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>OpenDebugLog（）函数实现如下</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//util.cpp</span>
static <span class="hljs-literal">void</span> DebugPrintInit()
{
    assert(mutexDebugLog <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>);
    mutexDebugLog <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> boost<span class="hljs-tag">::mutex</span>();
    vMsgsBeforeOpenLog <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> <span class="hljs-built_in">list</span><span class="hljs-subst">&lt;</span><span class="hljs-built_in">string</span><span class="hljs-subst">&gt;</span>;
}
<span class="hljs-literal">void</span> OpenDebugLog()
{
    boost<span class="hljs-tag">::call_once</span>(<span class="hljs-subst">&amp;</span>DebugPrintInit, debugPrintInitFlag);
    boost<span class="hljs-tag">::mutex</span><span class="hljs-tag">::scoped_lock</span> scoped_lock(<span class="hljs-subst">*</span>mutexDebugLog);

    assert(fileout <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>);
    assert(vMsgsBeforeOpenLog);
    boost<span class="hljs-tag">::filesystem</span><span class="hljs-tag">::path</span> pathDebug <span class="hljs-subst">=</span> GetDataDir() <span class="hljs-subst">/</span> <span class="hljs-string">"debug.log"</span>;
    fileout <span class="hljs-subst">=</span> fopen(pathDebug<span class="hljs-built_in">.</span><span class="hljs-built_in">string</span>()<span class="hljs-built_in">.</span>c_str(), <span class="hljs-string">"a"</span>);
    <span class="hljs-keyword">if</span> (fileout) setbuf(fileout, <span class="hljs-built_in">NULL</span>); <span class="hljs-comment">// unbuffered</span>

    <span class="hljs-comment">// dump buffered messages from before we opened the log</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-subst">!</span>vMsgsBeforeOpenLog<span class="hljs-subst">-&gt;</span>empty()) {
        FileWriteStr(vMsgsBeforeOpenLog<span class="hljs-subst">-&gt;</span>front(), fileout);
        vMsgsBeforeOpenLog<span class="hljs-subst">-&gt;</span>pop_front();
    }

    delete vMsgsBeforeOpenLog;
    vMsgsBeforeOpenLog <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
}</code></pre> 
  <blockquote> 
   <p><a href="https://blog.csdn.net/liujiayu2/article/details/50587064" rel="nofollow">Boost线程库提供了boost::call_once来支持“一次实现”，并且定义了一个标志boost::once_flag及一个初始化这个标志的宏BOOST_ONCE_INIT。</a>并且是在编译期间初始化而不是运行期间</p> 
  </blockquote> 
  <p>boost::call_once表示在多线程访问该语句时始终只执行一次调用的函数,来确保mutexDebugLog和 vMsgsBeforeOpenLog的初始化是线程安全的。</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//util.cpp</span>
<span class="hljs-value">static</span> boost<span class="hljs-value">::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;</span></code></pre> 
  <p>其中第一个参数是被调用的函数地址，第二个参数类型为boost::once_flag，并初始化这个标志为BOOST_ONCE_INIT <br> 在函数DebugPrintInit()中定义了变量mutexDebugLog,类型为boost::mutex()，表示为互斥锁，在OpenDebugLog()函数中是使用了boost::mutex::scoped_lock来上锁，scoped_lock是能够保证在作用域范围内是互斥访问的，离开作用域时由析构函数自动解锁。在DebugPrintInit()中创建了对象vMsgsBeforeOpenLog，类型为链表，此时链表为空，在OpenDebugLog()中需要在打开日志前转储缓冲信息，就是把vMsgsBeforeOpenLog的信息转到debug.log中，那么vMsgsBeforeOpenLog的内容是怎么获得的呢 <br> 在util.cpp的LogPrintStr函数中</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">// buffer if we haven't opened the log yet</span>
        <span class="hljs-keyword">if</span> (fileout <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
            assert(vMsgsBeforeOpenLog);
            ret <span class="hljs-subst">=</span> strTimestamped<span class="hljs-built_in">.</span>length();
            vMsgsBeforeOpenLog<span class="hljs-subst">-&gt;</span>push_back(strTimestamped);
        }</code></pre> 
  <p>这里就是把日志先存入vMsgsBeforeOpenLog在log文件未打开的时候，所以在OpenDebugLog()之前vMsgsBeforeOpenLog变量已经被创建了，然后LogPrintStr又被调用了很多次，每次都写入一写内容。 <br> III 打印提示信息</p> 
  <pre class="prettyprint"><code class=" hljs perl"> <span class="hljs-keyword">if</span> (!fLogTimestamps)
        LogPrintf(<span class="hljs-string">"Startup time: <span class="hljs-variable">%s</span>\n"</span>, DateTimeStrFormat(<span class="hljs-string">"<span class="hljs-variable">%Y</span>-<span class="hljs-variable">%m</span>-<span class="hljs-variable">%d</span> <span class="hljs-variable">%H</span>:<span class="hljs-variable">%M</span>:<span class="hljs-variable">%S</span>"</span>, GetTime()));
    LogPrintf(<span class="hljs-string">"Default data directory <span class="hljs-variable">%s</span>\n"</span>, GetDefaultDataDir().string());
    LogPrintf(<span class="hljs-string">"Using data directory <span class="hljs-variable">%s</span>\n"</span>, strDataDir);
    LogPrintf(<span class="hljs-string">"Using config file <span class="hljs-variable">%s</span>\n"</span>, GetConfigFile().string());
    LogPrintf(<span class="hljs-string">"Using at most <span class="hljs-variable">%i</span> connections (<span class="hljs-variable">%i</span> file descriptors available)\n"</span>, nMaxConnections, nFD);
    std::ostringstream strErrors;</code></pre> 
  <p>如果没有设置打印时间戳，就打印起始时间，后面打印默认地址、数据目录之类的信息。</p> 
  <hr> 
  <p>（五）草稿中。。。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81450432,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81450432,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81450432,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81450432,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
