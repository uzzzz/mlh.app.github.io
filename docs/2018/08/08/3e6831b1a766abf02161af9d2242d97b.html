<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS智能合约开发（一） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS智能合约开发（一）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、 智能合约功能 二、 通讯模式 2.1 运行机制 2.2 内联通信 2.3 延迟通信 2.4 交易和动作 2.5 交易确认 2.6 动作处理程序和动作的apply上下文 2.7 交易限制 三、文件结构 3.1 创建框架 3.2 apply处理程序 3.3 EOSIO_ABI 宏 四、多索引数据库API 4.1 EOSIO多索引API 4.2 EOSIO多索引迭代器 4.3 创建多索引表 4.4 创建多索引表 一、 智能合约功能 EOSIO智能合约是在区块链上注册并在EOSIO节点上执行的软件，实现了“合约”的功能，合约行动请求帐目存储在区块链中。智能合约定义了接口（操作，参数，数据结构）和实现接口的代码。代码被编译成规范的字节码格式，使节点可以检索和执行。区块链存储合约的交易（例如，合法转移，游戏移动）。每份智能合约都必须附有一份李嘉图合约，其中定义了具有法律约束力的条款和条件。 二、 通讯模式 2.1 运行机制 EOSIO智能合约由一组操作和类型定义组成。操作定义指定并实现合约的行为，类型定义指定所需的内容和结构。 操作主要在基于消息的通信体系结构中运行：客户端通过向nodeos发送（推送）消息来调用操作。可以使用cleos命令完成。它也可以使用EOSIO发送方法（例如，eosio :: action :: send）来完成。 nodeos将操作请求分派给实现合约的WASM代码，该代码运行完之后继续处理下一个操作。 EOSIO智能合约可以彼此通信，例如，让另一个合约执行与当前交易的完成相关的某些操作，或者触发当前交易范围之外的未来交易。 EOSIO支持两种基本通信模型，内联和延迟。在当前交易中执行的操作是内联操作的示例，而触发的将来交易是延迟操作的示例。 合约之间的沟通应视为异步发生，异步通信模型可能导致垃圾邮件，资源限制算法将解析垃圾邮件。 2.2 内联通信 内联通信采用请求其他操作的形式，需要作为调用操作的一部分执行。其使用和原始交易的相同作用域和权限进行操作，并保证使用当前交易执行，即调用交易中的嵌套交易。 如果交易的任何部分失败，则内联操作将与交易的其余部分一起展开。无论成功与否，调用内联操作都不会在交易范围之外生成任何通知。 2.3 延迟通信 延迟通信在采用发送到对等交易的动作通知的形式。 根据生产者的判断，延迟的操作最多可以安排在稍后的时间运行，无法保证将执行延期操作。从始发交易的角度来看，即创建延迟交易的交易，它只能确定创建请求是否成功提交或者是否失败（如果失败，它将立即失败）。 延期交易具有发送合约的权限，交易可以取消延期交易。 2.4 交易和动作 动作表示单个操作，而交易是一个或多个动作的集合。 合约和帐户以行动的形式进行沟通。 如果要将操作作为一个整体执行，则可以单独发送操作，也可以以组合形式发送操作。 交易中可以有一个动作也可以有多个 ，当有多个操作时，其中一个操作失败，则这个交易失败。 2.5 交易确认 交易完成后，将生成交易收据，此收据采用散列形式。 接收交易散列并不意味着交易已被确认，它只意味着节点接受它而没有错误，这也意味着其他生产者很可能会接受它。通过确认，在交易历史记录中可以看到包含它的块编号的交易。 2.6 动作处理程序和动作的apply上下文 智能合约提供动作处理程序来执行所请求操作的工作。每次动作运行时，通过在合约实现中运行apply方法“应用”操作，EOSIO会创建一个新的动作“应用”上下文，动作在该上下文中运行。 下图说明了apply上下文动作的关键元素： EOSIO网络中的每个节点都会获得每个合约中的每个动作的副本并运行。一些节点正在执行合约的实际工作，而其他节点正在处理以证明交易块的有效性。因此，重要的是合约能够确定“他们是谁”，或者基本上，他们在哪个环境下运行。在动作上下文中提供上下文标识信息，如上图中 的receiver, code, action。 receiver是当前正在处理该操作的帐户。code 是授权合约的帐户。 action是当前正在运行的操作的ID。 动作在交易中运作;如果交易失败，则必须回滚所有操作的结果。动作上下文的关键部分是当前交易数据，这包含交易头、交易中所有原始操作的有序向量、交易中上下文自由操作的向量，由code定义的可修复的上下文无关数据集（作为blob的向量提供）实现合约，以及blob向量的完整索引。 在处理动作之前，EOSIO会为动作设置一个干净的工作内存。操作的工作内存仅对该操作可用，即使对于同一交易中的操作也是如此。在执行另一个操作时可能已设置的变量在另一个操作的上下文中不可用。在动作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。动作可能有许多影响， 其中包括：更改状态在EOSIO持久存储中保持不变；通知当前交易的收件人；将内联操作请求发送给新接收方；生成新的（延期）交易；取消现有的延期交易。 2.7 交易限制 每个交易必须在30ms或更短时间内执行。 如果交易包含多个操作，并且这些操作的总和大于30毫秒，则整个交易将失败。 在没有对其操作进行并发性要求的情况下，可以通过在单独的交易中包含CPU消费动作来规避这种情况。 三、文件结构 3.1 创建框架 $ eosiocpp -n ${contract} 以上将在./$ {conttract}目录中创建一个带有两个文件： ${contract}.hpp ${contract}.cpp 3.2 apply处理程序 每个智能合约都必须提供应用操作处理程序。 apply动作处理程序是一个侦听所有传入操作并执行所需行为的函数。 为了响应特定操作，code识别和响应特定操作请求。 apply使用receiver、code、action输入参数作为过滤器，来映射到实现特定操作的所需功能。 apply函数可以使用以下方法过滤code参数： if (code == N(${contract_name}) { //对特定动作的处理 } 在给定code之后，可以使用如下方法过滤action参数： if (action == N(${action_name}) { //your handler to respond to a particular action } 3.3 EOSIO_ABI 宏 EOSIO_ABI宏封装了apply函数的基本动作： #define EOSIO_ABI( TYPE, MEMBERS ) \ extern &quot;C&quot; { \ void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \ auto self = receiver; \ if( code == self ) { \ TYPE thiscontract( self ); \ switch( action ) { \ EOSIO_API( TYPE, MEMBERS ) \ } \ /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \ } \ } \ } \ 只需要在宏中指定合约中的code和action名称即可，所有底层C代码映射逻辑都由宏生成。 如EOSIO_ABI（hello，（hi））中，hello和hi是来自合约的值。 apply函数记录所交付的行为，不做任何其他检查。 如果块生产者允许，任何人都可以随时提供任何操作。 如果没有任何必要的签名，合约将按消耗的带宽计费。 （1）apply:动作处理程序，它监听所有传入的动作并根据函数中的规范做出反应。 需要两个输入参数code和action。 （2）code filter： if (code == N(${contract_name}) { // your handler to respond to particular action } （3）action filter： if (action == N(${action_name}) { //your handler to respond to a particular action } （4）wast：部署到区块链的程序必须是wast格式，编译方法如下： $ eosiocpp -o ${contract}.wast ${contract}.cpp （5）abi:应用程序二进制接口（ABI）是一个JSON，在JSON和二进制之间转换用户操作。 abi还描述了如何将数据库状态转换为JSON或从JSON转换。 通过abi描述合约后，开发人员和用户将能够通过JSON无缝地与所开发的合约进行交互。可以如下编译产生： $ eosiocpp -g ${contract}.abi ${contract}.hpp ABI的一个例子： { //定义现有类型的别名列表,在这里，将name定义为account_name的别名。 &quot;types&quot;: [{ &quot;new_type_name&quot;: &quot;account_name&quot;, &quot;type&quot;: &quot;name&quot; } ], &quot;structs&quot;: [{ //在此处定义了transfer类型 &quot;name&quot;: &quot;transfer&quot;, &quot;base&quot;: &quot;&quot;, //from、to、quantity与&quot;types&quot;相对应 &quot;fields&quot;: { &quot;from&quot;: &quot;account_name&quot;, &quot;to&quot;: &quot;account_name&quot;, &quot;quantity&quot;: &quot;uint64&quot; } },{ &quot;name&quot;: &quot;account&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: { &quot;account&quot;: &quot;name&quot;, &quot;balance&quot;: &quot;uint64&quot; } } ], //在此定义了action:transfer,类型为transfer。告诉EOSIO遇到${account}-&gt;transfer时应该载入trransfer类 &quot;actions&quot;: [{ &quot;action&quot;: &quot;transfer&quot;, &quot;type&quot;: &quot;transfer&quot; } ], &quot;tables&quot;: [{ &quot;table&quot;: &quot;account&quot;, &quot;type&quot;: &quot;account&quot;, &quot;index_type&quot;: &quot;i64&quot;, &quot;key_names&quot; : [&quot;account&quot;], &quot;key_types&quot; : [&quot;name&quot;] } ] } 四、多索引数据库API EOSIO提供了一组服务和接口，使合约开发人员能够跨行动保持状态，从而保持事务边界。 如果没有持久性，当处理超出范围时，在处理操作和事务期间生成的状态将丢失。 对持久性服务的需求 acttion执行EOSIO合同的工作。 action在上下文的环境中运行。 如action apply上下文关系图中所示，操作上下文提供了执行操作所需的一些操作。 在处理操作之前，EOSIO会为操作设置一个干净的工作内存。 在操作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。 持久性组件包括： 1）在数据库中保持状态的服务 2）增强查询功能以查找和检索数据库内容 3）服务的C ++ API，供合约开发人员使用 4）用于访问核心服务的C API，对库和系统开发人员有用 4.1 EOSIO多索引API eosio :: multi_index对应传统数据库中的表，其中行是容器中的单个对象，列是容器中对象的成员属性，索引提供了对象的快速查找。 key与对象成员属性兼容。 传统的数据库表允许索引是表中某些列的用户定义函数。 eosio :: multi_index类似地允许索引是任何用户定义的函数（作为元素类型的类/结构的成员函数提供），但其返回值仅限于一组受限的支持键类型。 统的数据库表通常只有一个允许的唯一主键明确标识表中的特定行，并提供表中行的标准排序顺序。 eosio :: multi_index支持类似的语义，但eosio :: multi_index容器中对象的主键必须是唯一的无符号64位整数。 eosio :: multi_index容器中的对象按主键索引按无符号64位整数主键的升序排序。 4.2 EOSIO多索引迭代器 EOSIO持久性服务提供多索引迭代器。 与仅提供键值存储的其他区块链不同，EOSIO多索引表允许合同开发者保留按各种不同键类型排序的对象集合，这些键类型可以从对象内的数据派生。 这实现了丰富的检索功能。 最多可以定义16个二级索引，每个索引都有自己的排序和检索表内容的方式。 EOSIO多索引迭代器遵循C ++迭代器通用的模式。 所有迭代器都是双向const，const_iterator或const_reverse_iterator。 可以取消引用迭代器以提供对多索引表中对象的访问。 4.3 创建多索引表 以下是使用EOSIO Multi-Index表创建自己的持久数据的步骤： 1）使用C ++类或结构体定义对象。每个对象都在其自己的多索引表中。 2）在名为primary_key的类/结构中定义一个const成员函数，该函数返回对象的uint64_t主键值。 3）确定二级指数。最多支持16个附加索引。二级指数支持几种密钥类型： idx64 - 原始64位无符号整数键 idx128 - 原始128位无符号整数键，或128位固定大小的词典键 idx256 - 256位固定大小的词典键 idx_double - 双精度浮点键 idx_long_double - 四倍精度浮点键 为每个二级索引定义一个密钥提取器。密钥提取器是用于从多索引表的元素获取密钥的函数。 4.4 创建多索引表 （1）实例化多索引表 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope } } EOSIO_ABI( addressbook, (myaction) ) （2）插入操作： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （2）修改： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.modify( itr, account payer, [&amp;]( auto&amp; address ) { address.city = &quot;San Luis Obispo&quot;; address.state = &quot;CA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （3）删除 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.erase( itr ); eosio_assert(itr != addresses.end(), &quot;Address not erased properly&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （5）get 使用主键查找，返回对包含指定主键的对象的常量引用。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto user = addresses.get(N(dan)); eosio_assert(user.first_name == &quot;Daniel&quot;, &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （6）find 使用主键在表中搜索现有对象。如果找不到具有主键primary的对象，则找到的对象的迭代器，其主键等于主键或引用表的结束迭代器。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) 阅读更多" />
<meta property="og:description" content="一、 智能合约功能 二、 通讯模式 2.1 运行机制 2.2 内联通信 2.3 延迟通信 2.4 交易和动作 2.5 交易确认 2.6 动作处理程序和动作的apply上下文 2.7 交易限制 三、文件结构 3.1 创建框架 3.2 apply处理程序 3.3 EOSIO_ABI 宏 四、多索引数据库API 4.1 EOSIO多索引API 4.2 EOSIO多索引迭代器 4.3 创建多索引表 4.4 创建多索引表 一、 智能合约功能 EOSIO智能合约是在区块链上注册并在EOSIO节点上执行的软件，实现了“合约”的功能，合约行动请求帐目存储在区块链中。智能合约定义了接口（操作，参数，数据结构）和实现接口的代码。代码被编译成规范的字节码格式，使节点可以检索和执行。区块链存储合约的交易（例如，合法转移，游戏移动）。每份智能合约都必须附有一份李嘉图合约，其中定义了具有法律约束力的条款和条件。 二、 通讯模式 2.1 运行机制 EOSIO智能合约由一组操作和类型定义组成。操作定义指定并实现合约的行为，类型定义指定所需的内容和结构。 操作主要在基于消息的通信体系结构中运行：客户端通过向nodeos发送（推送）消息来调用操作。可以使用cleos命令完成。它也可以使用EOSIO发送方法（例如，eosio :: action :: send）来完成。 nodeos将操作请求分派给实现合约的WASM代码，该代码运行完之后继续处理下一个操作。 EOSIO智能合约可以彼此通信，例如，让另一个合约执行与当前交易的完成相关的某些操作，或者触发当前交易范围之外的未来交易。 EOSIO支持两种基本通信模型，内联和延迟。在当前交易中执行的操作是内联操作的示例，而触发的将来交易是延迟操作的示例。 合约之间的沟通应视为异步发生，异步通信模型可能导致垃圾邮件，资源限制算法将解析垃圾邮件。 2.2 内联通信 内联通信采用请求其他操作的形式，需要作为调用操作的一部分执行。其使用和原始交易的相同作用域和权限进行操作，并保证使用当前交易执行，即调用交易中的嵌套交易。 如果交易的任何部分失败，则内联操作将与交易的其余部分一起展开。无论成功与否，调用内联操作都不会在交易范围之外生成任何通知。 2.3 延迟通信 延迟通信在采用发送到对等交易的动作通知的形式。 根据生产者的判断，延迟的操作最多可以安排在稍后的时间运行，无法保证将执行延期操作。从始发交易的角度来看，即创建延迟交易的交易，它只能确定创建请求是否成功提交或者是否失败（如果失败，它将立即失败）。 延期交易具有发送合约的权限，交易可以取消延期交易。 2.4 交易和动作 动作表示单个操作，而交易是一个或多个动作的集合。 合约和帐户以行动的形式进行沟通。 如果要将操作作为一个整体执行，则可以单独发送操作，也可以以组合形式发送操作。 交易中可以有一个动作也可以有多个 ，当有多个操作时，其中一个操作失败，则这个交易失败。 2.5 交易确认 交易完成后，将生成交易收据，此收据采用散列形式。 接收交易散列并不意味着交易已被确认，它只意味着节点接受它而没有错误，这也意味着其他生产者很可能会接受它。通过确认，在交易历史记录中可以看到包含它的块编号的交易。 2.6 动作处理程序和动作的apply上下文 智能合约提供动作处理程序来执行所请求操作的工作。每次动作运行时，通过在合约实现中运行apply方法“应用”操作，EOSIO会创建一个新的动作“应用”上下文，动作在该上下文中运行。 下图说明了apply上下文动作的关键元素： EOSIO网络中的每个节点都会获得每个合约中的每个动作的副本并运行。一些节点正在执行合约的实际工作，而其他节点正在处理以证明交易块的有效性。因此，重要的是合约能够确定“他们是谁”，或者基本上，他们在哪个环境下运行。在动作上下文中提供上下文标识信息，如上图中 的receiver, code, action。 receiver是当前正在处理该操作的帐户。code 是授权合约的帐户。 action是当前正在运行的操作的ID。 动作在交易中运作;如果交易失败，则必须回滚所有操作的结果。动作上下文的关键部分是当前交易数据，这包含交易头、交易中所有原始操作的有序向量、交易中上下文自由操作的向量，由code定义的可修复的上下文无关数据集（作为blob的向量提供）实现合约，以及blob向量的完整索引。 在处理动作之前，EOSIO会为动作设置一个干净的工作内存。操作的工作内存仅对该操作可用，即使对于同一交易中的操作也是如此。在执行另一个操作时可能已设置的变量在另一个操作的上下文中不可用。在动作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。动作可能有许多影响， 其中包括：更改状态在EOSIO持久存储中保持不变；通知当前交易的收件人；将内联操作请求发送给新接收方；生成新的（延期）交易；取消现有的延期交易。 2.7 交易限制 每个交易必须在30ms或更短时间内执行。 如果交易包含多个操作，并且这些操作的总和大于30毫秒，则整个交易将失败。 在没有对其操作进行并发性要求的情况下，可以通过在单独的交易中包含CPU消费动作来规避这种情况。 三、文件结构 3.1 创建框架 $ eosiocpp -n ${contract} 以上将在./$ {conttract}目录中创建一个带有两个文件： ${contract}.hpp ${contract}.cpp 3.2 apply处理程序 每个智能合约都必须提供应用操作处理程序。 apply动作处理程序是一个侦听所有传入操作并执行所需行为的函数。 为了响应特定操作，code识别和响应特定操作请求。 apply使用receiver、code、action输入参数作为过滤器，来映射到实现特定操作的所需功能。 apply函数可以使用以下方法过滤code参数： if (code == N(${contract_name}) { //对特定动作的处理 } 在给定code之后，可以使用如下方法过滤action参数： if (action == N(${action_name}) { //your handler to respond to a particular action } 3.3 EOSIO_ABI 宏 EOSIO_ABI宏封装了apply函数的基本动作： #define EOSIO_ABI( TYPE, MEMBERS ) \ extern &quot;C&quot; { \ void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \ auto self = receiver; \ if( code == self ) { \ TYPE thiscontract( self ); \ switch( action ) { \ EOSIO_API( TYPE, MEMBERS ) \ } \ /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \ } \ } \ } \ 只需要在宏中指定合约中的code和action名称即可，所有底层C代码映射逻辑都由宏生成。 如EOSIO_ABI（hello，（hi））中，hello和hi是来自合约的值。 apply函数记录所交付的行为，不做任何其他检查。 如果块生产者允许，任何人都可以随时提供任何操作。 如果没有任何必要的签名，合约将按消耗的带宽计费。 （1）apply:动作处理程序，它监听所有传入的动作并根据函数中的规范做出反应。 需要两个输入参数code和action。 （2）code filter： if (code == N(${contract_name}) { // your handler to respond to particular action } （3）action filter： if (action == N(${action_name}) { //your handler to respond to a particular action } （4）wast：部署到区块链的程序必须是wast格式，编译方法如下： $ eosiocpp -o ${contract}.wast ${contract}.cpp （5）abi:应用程序二进制接口（ABI）是一个JSON，在JSON和二进制之间转换用户操作。 abi还描述了如何将数据库状态转换为JSON或从JSON转换。 通过abi描述合约后，开发人员和用户将能够通过JSON无缝地与所开发的合约进行交互。可以如下编译产生： $ eosiocpp -g ${contract}.abi ${contract}.hpp ABI的一个例子： { //定义现有类型的别名列表,在这里，将name定义为account_name的别名。 &quot;types&quot;: [{ &quot;new_type_name&quot;: &quot;account_name&quot;, &quot;type&quot;: &quot;name&quot; } ], &quot;structs&quot;: [{ //在此处定义了transfer类型 &quot;name&quot;: &quot;transfer&quot;, &quot;base&quot;: &quot;&quot;, //from、to、quantity与&quot;types&quot;相对应 &quot;fields&quot;: { &quot;from&quot;: &quot;account_name&quot;, &quot;to&quot;: &quot;account_name&quot;, &quot;quantity&quot;: &quot;uint64&quot; } },{ &quot;name&quot;: &quot;account&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: { &quot;account&quot;: &quot;name&quot;, &quot;balance&quot;: &quot;uint64&quot; } } ], //在此定义了action:transfer,类型为transfer。告诉EOSIO遇到${account}-&gt;transfer时应该载入trransfer类 &quot;actions&quot;: [{ &quot;action&quot;: &quot;transfer&quot;, &quot;type&quot;: &quot;transfer&quot; } ], &quot;tables&quot;: [{ &quot;table&quot;: &quot;account&quot;, &quot;type&quot;: &quot;account&quot;, &quot;index_type&quot;: &quot;i64&quot;, &quot;key_names&quot; : [&quot;account&quot;], &quot;key_types&quot; : [&quot;name&quot;] } ] } 四、多索引数据库API EOSIO提供了一组服务和接口，使合约开发人员能够跨行动保持状态，从而保持事务边界。 如果没有持久性，当处理超出范围时，在处理操作和事务期间生成的状态将丢失。 对持久性服务的需求 acttion执行EOSIO合同的工作。 action在上下文的环境中运行。 如action apply上下文关系图中所示，操作上下文提供了执行操作所需的一些操作。 在处理操作之前，EOSIO会为操作设置一个干净的工作内存。 在操作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。 持久性组件包括： 1）在数据库中保持状态的服务 2）增强查询功能以查找和检索数据库内容 3）服务的C ++ API，供合约开发人员使用 4）用于访问核心服务的C API，对库和系统开发人员有用 4.1 EOSIO多索引API eosio :: multi_index对应传统数据库中的表，其中行是容器中的单个对象，列是容器中对象的成员属性，索引提供了对象的快速查找。 key与对象成员属性兼容。 传统的数据库表允许索引是表中某些列的用户定义函数。 eosio :: multi_index类似地允许索引是任何用户定义的函数（作为元素类型的类/结构的成员函数提供），但其返回值仅限于一组受限的支持键类型。 统的数据库表通常只有一个允许的唯一主键明确标识表中的特定行，并提供表中行的标准排序顺序。 eosio :: multi_index支持类似的语义，但eosio :: multi_index容器中对象的主键必须是唯一的无符号64位整数。 eosio :: multi_index容器中的对象按主键索引按无符号64位整数主键的升序排序。 4.2 EOSIO多索引迭代器 EOSIO持久性服务提供多索引迭代器。 与仅提供键值存储的其他区块链不同，EOSIO多索引表允许合同开发者保留按各种不同键类型排序的对象集合，这些键类型可以从对象内的数据派生。 这实现了丰富的检索功能。 最多可以定义16个二级索引，每个索引都有自己的排序和检索表内容的方式。 EOSIO多索引迭代器遵循C ++迭代器通用的模式。 所有迭代器都是双向const，const_iterator或const_reverse_iterator。 可以取消引用迭代器以提供对多索引表中对象的访问。 4.3 创建多索引表 以下是使用EOSIO Multi-Index表创建自己的持久数据的步骤： 1）使用C ++类或结构体定义对象。每个对象都在其自己的多索引表中。 2）在名为primary_key的类/结构中定义一个const成员函数，该函数返回对象的uint64_t主键值。 3）确定二级指数。最多支持16个附加索引。二级指数支持几种密钥类型： idx64 - 原始64位无符号整数键 idx128 - 原始128位无符号整数键，或128位固定大小的词典键 idx256 - 256位固定大小的词典键 idx_double - 双精度浮点键 idx_long_double - 四倍精度浮点键 为每个二级索引定义一个密钥提取器。密钥提取器是用于从多索引表的元素获取密钥的函数。 4.4 创建多索引表 （1）实例化多索引表 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope } } EOSIO_ABI( addressbook, (myaction) ) （2）插入操作： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （2）修改： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.modify( itr, account payer, [&amp;]( auto&amp; address ) { address.city = &quot;San Luis Obispo&quot;; address.state = &quot;CA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （3）删除 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.erase( itr ); eosio_assert(itr != addresses.end(), &quot;Address not erased properly&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （5）get 使用主键查找，返回对包含指定主键的对象的常量引用。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto user = addresses.get(N(dan)); eosio_assert(user.first_name == &quot;Daniel&quot;, &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （6）find 使用主键在表中搜索现有对象。如果找不到具有主键primary的对象，则找到的对象的迭代器，其主键等于主键或引用表的结束迭代器。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/08/3e6831b1a766abf02161af9d2242d97b.html" />
<meta property="og:url" content="https://mlh.app/2018/08/08/3e6831b1a766abf02161af9d2242d97b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、 智能合约功能 二、 通讯模式 2.1 运行机制 2.2 内联通信 2.3 延迟通信 2.4 交易和动作 2.5 交易确认 2.6 动作处理程序和动作的apply上下文 2.7 交易限制 三、文件结构 3.1 创建框架 3.2 apply处理程序 3.3 EOSIO_ABI 宏 四、多索引数据库API 4.1 EOSIO多索引API 4.2 EOSIO多索引迭代器 4.3 创建多索引表 4.4 创建多索引表 一、 智能合约功能 EOSIO智能合约是在区块链上注册并在EOSIO节点上执行的软件，实现了“合约”的功能，合约行动请求帐目存储在区块链中。智能合约定义了接口（操作，参数，数据结构）和实现接口的代码。代码被编译成规范的字节码格式，使节点可以检索和执行。区块链存储合约的交易（例如，合法转移，游戏移动）。每份智能合约都必须附有一份李嘉图合约，其中定义了具有法律约束力的条款和条件。 二、 通讯模式 2.1 运行机制 EOSIO智能合约由一组操作和类型定义组成。操作定义指定并实现合约的行为，类型定义指定所需的内容和结构。 操作主要在基于消息的通信体系结构中运行：客户端通过向nodeos发送（推送）消息来调用操作。可以使用cleos命令完成。它也可以使用EOSIO发送方法（例如，eosio :: action :: send）来完成。 nodeos将操作请求分派给实现合约的WASM代码，该代码运行完之后继续处理下一个操作。 EOSIO智能合约可以彼此通信，例如，让另一个合约执行与当前交易的完成相关的某些操作，或者触发当前交易范围之外的未来交易。 EOSIO支持两种基本通信模型，内联和延迟。在当前交易中执行的操作是内联操作的示例，而触发的将来交易是延迟操作的示例。 合约之间的沟通应视为异步发生，异步通信模型可能导致垃圾邮件，资源限制算法将解析垃圾邮件。 2.2 内联通信 内联通信采用请求其他操作的形式，需要作为调用操作的一部分执行。其使用和原始交易的相同作用域和权限进行操作，并保证使用当前交易执行，即调用交易中的嵌套交易。 如果交易的任何部分失败，则内联操作将与交易的其余部分一起展开。无论成功与否，调用内联操作都不会在交易范围之外生成任何通知。 2.3 延迟通信 延迟通信在采用发送到对等交易的动作通知的形式。 根据生产者的判断，延迟的操作最多可以安排在稍后的时间运行，无法保证将执行延期操作。从始发交易的角度来看，即创建延迟交易的交易，它只能确定创建请求是否成功提交或者是否失败（如果失败，它将立即失败）。 延期交易具有发送合约的权限，交易可以取消延期交易。 2.4 交易和动作 动作表示单个操作，而交易是一个或多个动作的集合。 合约和帐户以行动的形式进行沟通。 如果要将操作作为一个整体执行，则可以单独发送操作，也可以以组合形式发送操作。 交易中可以有一个动作也可以有多个 ，当有多个操作时，其中一个操作失败，则这个交易失败。 2.5 交易确认 交易完成后，将生成交易收据，此收据采用散列形式。 接收交易散列并不意味着交易已被确认，它只意味着节点接受它而没有错误，这也意味着其他生产者很可能会接受它。通过确认，在交易历史记录中可以看到包含它的块编号的交易。 2.6 动作处理程序和动作的apply上下文 智能合约提供动作处理程序来执行所请求操作的工作。每次动作运行时，通过在合约实现中运行apply方法“应用”操作，EOSIO会创建一个新的动作“应用”上下文，动作在该上下文中运行。 下图说明了apply上下文动作的关键元素： EOSIO网络中的每个节点都会获得每个合约中的每个动作的副本并运行。一些节点正在执行合约的实际工作，而其他节点正在处理以证明交易块的有效性。因此，重要的是合约能够确定“他们是谁”，或者基本上，他们在哪个环境下运行。在动作上下文中提供上下文标识信息，如上图中 的receiver, code, action。 receiver是当前正在处理该操作的帐户。code 是授权合约的帐户。 action是当前正在运行的操作的ID。 动作在交易中运作;如果交易失败，则必须回滚所有操作的结果。动作上下文的关键部分是当前交易数据，这包含交易头、交易中所有原始操作的有序向量、交易中上下文自由操作的向量，由code定义的可修复的上下文无关数据集（作为blob的向量提供）实现合约，以及blob向量的完整索引。 在处理动作之前，EOSIO会为动作设置一个干净的工作内存。操作的工作内存仅对该操作可用，即使对于同一交易中的操作也是如此。在执行另一个操作时可能已设置的变量在另一个操作的上下文中不可用。在动作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。动作可能有许多影响， 其中包括：更改状态在EOSIO持久存储中保持不变；通知当前交易的收件人；将内联操作请求发送给新接收方；生成新的（延期）交易；取消现有的延期交易。 2.7 交易限制 每个交易必须在30ms或更短时间内执行。 如果交易包含多个操作，并且这些操作的总和大于30毫秒，则整个交易将失败。 在没有对其操作进行并发性要求的情况下，可以通过在单独的交易中包含CPU消费动作来规避这种情况。 三、文件结构 3.1 创建框架 $ eosiocpp -n ${contract} 以上将在./$ {conttract}目录中创建一个带有两个文件： ${contract}.hpp ${contract}.cpp 3.2 apply处理程序 每个智能合约都必须提供应用操作处理程序。 apply动作处理程序是一个侦听所有传入操作并执行所需行为的函数。 为了响应特定操作，code识别和响应特定操作请求。 apply使用receiver、code、action输入参数作为过滤器，来映射到实现特定操作的所需功能。 apply函数可以使用以下方法过滤code参数： if (code == N(${contract_name}) { //对特定动作的处理 } 在给定code之后，可以使用如下方法过滤action参数： if (action == N(${action_name}) { //your handler to respond to a particular action } 3.3 EOSIO_ABI 宏 EOSIO_ABI宏封装了apply函数的基本动作： #define EOSIO_ABI( TYPE, MEMBERS ) \\ extern &quot;C&quot; { \\ void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\ auto self = receiver; \\ if( code == self ) { \\ TYPE thiscontract( self ); \\ switch( action ) { \\ EOSIO_API( TYPE, MEMBERS ) \\ } \\ /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\ } \\ } \\ } \\ 只需要在宏中指定合约中的code和action名称即可，所有底层C代码映射逻辑都由宏生成。 如EOSIO_ABI（hello，（hi））中，hello和hi是来自合约的值。 apply函数记录所交付的行为，不做任何其他检查。 如果块生产者允许，任何人都可以随时提供任何操作。 如果没有任何必要的签名，合约将按消耗的带宽计费。 （1）apply:动作处理程序，它监听所有传入的动作并根据函数中的规范做出反应。 需要两个输入参数code和action。 （2）code filter： if (code == N(${contract_name}) { // your handler to respond to particular action } （3）action filter： if (action == N(${action_name}) { //your handler to respond to a particular action } （4）wast：部署到区块链的程序必须是wast格式，编译方法如下： $ eosiocpp -o ${contract}.wast ${contract}.cpp （5）abi:应用程序二进制接口（ABI）是一个JSON，在JSON和二进制之间转换用户操作。 abi还描述了如何将数据库状态转换为JSON或从JSON转换。 通过abi描述合约后，开发人员和用户将能够通过JSON无缝地与所开发的合约进行交互。可以如下编译产生： $ eosiocpp -g ${contract}.abi ${contract}.hpp ABI的一个例子： { //定义现有类型的别名列表,在这里，将name定义为account_name的别名。 &quot;types&quot;: [{ &quot;new_type_name&quot;: &quot;account_name&quot;, &quot;type&quot;: &quot;name&quot; } ], &quot;structs&quot;: [{ //在此处定义了transfer类型 &quot;name&quot;: &quot;transfer&quot;, &quot;base&quot;: &quot;&quot;, //from、to、quantity与&quot;types&quot;相对应 &quot;fields&quot;: { &quot;from&quot;: &quot;account_name&quot;, &quot;to&quot;: &quot;account_name&quot;, &quot;quantity&quot;: &quot;uint64&quot; } },{ &quot;name&quot;: &quot;account&quot;, &quot;base&quot;: &quot;&quot;, &quot;fields&quot;: { &quot;account&quot;: &quot;name&quot;, &quot;balance&quot;: &quot;uint64&quot; } } ], //在此定义了action:transfer,类型为transfer。告诉EOSIO遇到${account}-&gt;transfer时应该载入trransfer类 &quot;actions&quot;: [{ &quot;action&quot;: &quot;transfer&quot;, &quot;type&quot;: &quot;transfer&quot; } ], &quot;tables&quot;: [{ &quot;table&quot;: &quot;account&quot;, &quot;type&quot;: &quot;account&quot;, &quot;index_type&quot;: &quot;i64&quot;, &quot;key_names&quot; : [&quot;account&quot;], &quot;key_types&quot; : [&quot;name&quot;] } ] } 四、多索引数据库API EOSIO提供了一组服务和接口，使合约开发人员能够跨行动保持状态，从而保持事务边界。 如果没有持久性，当处理超出范围时，在处理操作和事务期间生成的状态将丢失。 对持久性服务的需求 acttion执行EOSIO合同的工作。 action在上下文的环境中运行。 如action apply上下文关系图中所示，操作上下文提供了执行操作所需的一些操作。 在处理操作之前，EOSIO会为操作设置一个干净的工作内存。 在操作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。 持久性组件包括： 1）在数据库中保持状态的服务 2）增强查询功能以查找和检索数据库内容 3）服务的C ++ API，供合约开发人员使用 4）用于访问核心服务的C API，对库和系统开发人员有用 4.1 EOSIO多索引API eosio :: multi_index对应传统数据库中的表，其中行是容器中的单个对象，列是容器中对象的成员属性，索引提供了对象的快速查找。 key与对象成员属性兼容。 传统的数据库表允许索引是表中某些列的用户定义函数。 eosio :: multi_index类似地允许索引是任何用户定义的函数（作为元素类型的类/结构的成员函数提供），但其返回值仅限于一组受限的支持键类型。 统的数据库表通常只有一个允许的唯一主键明确标识表中的特定行，并提供表中行的标准排序顺序。 eosio :: multi_index支持类似的语义，但eosio :: multi_index容器中对象的主键必须是唯一的无符号64位整数。 eosio :: multi_index容器中的对象按主键索引按无符号64位整数主键的升序排序。 4.2 EOSIO多索引迭代器 EOSIO持久性服务提供多索引迭代器。 与仅提供键值存储的其他区块链不同，EOSIO多索引表允许合同开发者保留按各种不同键类型排序的对象集合，这些键类型可以从对象内的数据派生。 这实现了丰富的检索功能。 最多可以定义16个二级索引，每个索引都有自己的排序和检索表内容的方式。 EOSIO多索引迭代器遵循C ++迭代器通用的模式。 所有迭代器都是双向const，const_iterator或const_reverse_iterator。 可以取消引用迭代器以提供对多索引表中对象的访问。 4.3 创建多索引表 以下是使用EOSIO Multi-Index表创建自己的持久数据的步骤： 1）使用C ++类或结构体定义对象。每个对象都在其自己的多索引表中。 2）在名为primary_key的类/结构中定义一个const成员函数，该函数返回对象的uint64_t主键值。 3）确定二级指数。最多支持16个附加索引。二级指数支持几种密钥类型： idx64 - 原始64位无符号整数键 idx128 - 原始128位无符号整数键，或128位固定大小的词典键 idx256 - 256位固定大小的词典键 idx_double - 双精度浮点键 idx_long_double - 四倍精度浮点键 为每个二级索引定义一个密钥提取器。密钥提取器是用于从多索引表的元素获取密钥的函数。 4.4 创建多索引表 （1）实例化多索引表 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope } } EOSIO_ABI( addressbook, (myaction) ) （2）插入操作： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （2）修改： #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.modify( itr, account payer, [&amp;]( auto&amp; address ) { address.city = &quot;San Luis Obispo&quot;; address.state = &quot;CA&quot;; }); } } EOSIO_ABI( addressbook, (myaction) ) （3）删除 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Address for account not found&quot;); addresses.erase( itr ); eosio_assert(itr != addresses.end(), &quot;Address not erased properly&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （5）get 使用主键查找，返回对包含指定主键的对象的常量引用。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto user = addresses.get(N(dan)); eosio_assert(user.first_name == &quot;Daniel&quot;, &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) （6）find 使用主键在表中搜索现有对象。如果找不到具有主键primary的对象，则找到的对象的迭代器，其主键等于主键或引用表的结束迭代器。 #include using namespace eosio; using namespace std; class addressbook: contract { struct address { uint64_t account_name; string first_name; string last_name; string street; string city; string state; uint64_t primary_key() const { return account_name; } EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) ) }; public: addressbook(account_name self):contract(self) {} typedef eosio::multi_index&lt; N(address), address &gt; address_index; void myaction() { address_index addresses(_self, _self); // code, scope // add to table, first argument is account to bill for storage addresses.emplace(_self, [&amp;](auto&amp; address) { address.account_name = N(dan); address.first_name = &quot;Daniel&quot;; address.last_name = &quot;Larimer&quot;; address.street = &quot;1 EOS Way&quot;; address.city = &quot;Blacksburg&quot;; address.state = &quot;VA&quot;; }); auto itr = addresses.find(N(dan)); eosio_assert(itr != addresses.end(), &quot;Couldn&#39;t get him.&quot;); } } EOSIO_ABI( addressbook, (myaction) ) 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/08/3e6831b1a766abf02161af9d2242d97b.html","headline":"EOS智能合约开发（一）","dateModified":"2018-08-08T00:00:00+08:00","datePublished":"2018-08-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/08/3e6831b1a766abf02161af9d2242d97b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS智能合约开发（一）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p></p>
  <div class="toc"> 
   <ul> 
    <li><a href="#一-智能合约功能" rel="nofollow">一、 智能合约功能</a></li> 
    <li><a href="#二-通讯模式" rel="nofollow">二、 通讯模式</a>
     <ul> 
      <li><a href="#21-运行机制" rel="nofollow">2.1 运行机制</a></li> 
      <li><a href="#22-内联通信" rel="nofollow">2.2 内联通信</a></li> 
      <li><a href="#23-延迟通信" rel="nofollow">2.3 延迟通信</a></li> 
      <li><a href="#24-交易和动作" rel="nofollow">2.4 交易和动作</a></li> 
      <li><a href="#25-交易确认" rel="nofollow">2.5 交易确认</a></li> 
      <li><a href="#26-动作处理程序和动作的apply上下文" rel="nofollow">2.6 动作处理程序和动作的apply上下文</a></li> 
      <li><a href="#27-交易限制" rel="nofollow">2.7 交易限制</a></li> 
     </ul> </li> 
    <li><a href="#三文件结构" rel="nofollow">三、文件结构</a>
     <ul> 
      <li><a href="#31-创建框架" rel="nofollow">3.1 创建框架</a></li> 
      <li><a href="#32-apply处理程序" rel="nofollow">3.2 apply处理程序</a></li> 
      <li><a href="#33-eosioabi-宏" rel="nofollow">3.3 EOSIO_ABI 宏</a></li> 
     </ul> </li> 
    <li><a href="#四多索引数据库api" rel="nofollow">四、多索引数据库API</a>
     <ul> 
      <li><a href="#41-eosio多索引api" rel="nofollow">4.1 EOSIO多索引API</a></li> 
      <li><a href="#42-eosio多索引迭代器" rel="nofollow">4.2 EOSIO多索引迭代器</a></li> 
      <li><a href="#43-创建多索引表" rel="nofollow">4.3 创建多索引表</a></li> 
      <li><a href="#44-创建多索引表" rel="nofollow">4.4 创建多索引表</a></li> 
     </ul> </li> 
   </ul> 
  </div> 
  <p></p> 
  <h1 id="一-智能合约功能">一、 智能合约功能</h1> 
  <p>EOSIO智能合约是在区块链上注册并在EOSIO节点上执行的软件，实现了“合约”的功能，合约行动请求帐目存储在区块链中。智能合约定义了接口（操作，参数，数据结构）和实现接口的代码。代码被编译成规范的字节码格式，使节点可以检索和执行。区块链存储合约的交易（例如，合法转移，游戏移动）。每份智能合约都必须附有一份李嘉图合约，其中定义了具有法律约束力的条款和条件。</p> 
  <h1 id="二-通讯模式">二、 通讯模式</h1> 
  <h2 id="21-运行机制">2.1 运行机制</h2> 
  <p>EOSIO智能合约由一组操作和类型定义组成。操作定义指定并实现合约的行为，类型定义指定所需的内容和结构。 操作主要在基于消息的通信体系结构中运行：客户端通过向nodeos发送（推送）消息来调用操作。可以使用cleos命令完成。它也可以使用EOSIO发送方法（例如，eosio :: action :: send）来完成。 nodeos将操作请求分派给实现合约的WASM代码，该代码运行完之后继续处理下一个操作。 <br> EOSIO智能合约可以彼此通信，例如，让另一个合约执行与当前交易的完成相关的某些操作，或者触发当前交易范围之外的未来交易。 <br> EOSIO支持两种基本通信模型，内联和延迟。在当前交易中执行的操作是内联操作的示例，而触发的将来交易是延迟操作的示例。 <br> 合约之间的沟通应视为异步发生，异步通信模型可能导致垃圾邮件，资源限制算法将解析垃圾邮件。</p> 
  <h2 id="22-内联通信">2.2 内联通信</h2> 
  <p>内联通信采用请求其他操作的形式，需要作为调用操作的一部分执行。其使用和原始交易的相同作用域和权限进行操作，并保证使用当前交易执行，即调用交易中的嵌套交易。 如果交易的任何部分失败，则内联操作将与交易的其余部分一起展开。无论成功与否，调用内联操作都不会在交易范围之外生成任何通知。</p> 
  <h2 id="23-延迟通信">2.3 延迟通信</h2> 
  <p>延迟通信在采用发送到对等交易的动作通知的形式。 根据生产者的判断，延迟的操作最多可以安排在稍后的时间运行，无法保证将执行延期操作。从始发交易的角度来看，即创建延迟交易的交易，它只能确定创建请求是否成功提交或者是否失败（如果失败，它将立即失败）。 延期交易具有发送合约的权限，交易可以取消延期交易。</p> 
  <h2 id="24-交易和动作">2.4 交易和动作</h2> 
  <p>动作表示单个操作，而交易是一个或多个动作的集合。 合约和帐户以行动的形式进行沟通。 如果要将操作作为一个整体执行，则可以单独发送操作，也可以以组合形式发送操作。 <br> 交易中可以有一个动作也可以有多个 ，当有多个操作时，其中一个操作失败，则这个交易失败。</p> 
  <h2 id="25-交易确认">2.5 交易确认</h2> 
  <p>交易完成后，将生成交易收据，此收据采用散列形式。 接收交易散列并不意味着交易已被确认，它只意味着节点接受它而没有错误，这也意味着其他生产者很可能会接受它。通过确认，在交易历史记录中可以看到包含它的块编号的交易。</p> 
  <h2 id="26-动作处理程序和动作的apply上下文">2.6 动作处理程序和动作的apply上下文</h2> 
  <p>智能合约提供动作处理程序来执行所请求操作的工作。每次动作运行时，通过在合约实现中运行apply方法“应用”操作，EOSIO会创建一个新的动作“应用”上下文，动作在该上下文中运行。 下图说明了apply上下文动作的关键元素： <br> <img src="https://files.readme.io/6d71afc-action-apply-context-diagram.png" alt="" title=""> <br> EOSIO网络中的每个节点都会获得每个合约中的每个动作的副本并运行。一些节点正在执行合约的实际工作，而其他节点正在处理以证明交易块的有效性。因此，重要的是合约能够确定“他们是谁”，或者基本上，他们在哪个环境下运行。在动作上下文中提供上下文标识信息，如上图中 的receiver, code, action。 receiver是当前正在处理该操作的帐户。code 是授权合约的帐户。 action是当前正在运行的操作的ID。 <br> 动作在交易中运作;如果交易失败，则必须回滚所有操作的结果。动作上下文的关键部分是当前交易数据，这包含交易头、交易中所有原始操作的有序向量、交易中上下文自由操作的向量，由code定义的可修复的上下文无关数据集（作为blob的向量提供）实现合约，以及blob向量的完整索引。 <br> 在处理动作之前，EOSIO会为动作设置一个干净的工作内存。操作的工作内存仅对该操作可用，即使对于同一交易中的操作也是如此。在执行另一个操作时可能已设置的变量在另一个操作的上下文中不可用。在动作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。动作可能有许多影响， 其中包括：更改状态在EOSIO持久存储中保持不变；通知当前交易的收件人；将内联操作请求发送给新接收方；生成新的（延期）交易；取消现有的延期交易。</p> 
  <h2 id="27-交易限制">2.7 交易限制</h2> 
  <p>每个交易必须在30ms或更短时间内执行。 如果交易包含多个操作，并且这些操作的总和大于30毫秒，则整个交易将失败。 在没有对其操作进行并发性要求的情况下，可以通过在单独的交易中包含CPU消费动作来规避这种情况。</p> 
  <h1 id="三文件结构">三、文件结构</h1> 
  <h2 id="31-创建框架">3.1 创建框架</h2> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>eosiocpp -n <span class="hljs-variable">${</span>contract}</code></pre> 
  <p>以上将在./$ {conttract}目录中创建一个带有两个文件：</p> 
  <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">${contract}</span>.hpp <span class="hljs-variable">${contract}</span>.cpp</code></pre> 
  <h2 id="32-apply处理程序">3.2 apply处理程序</h2> 
  <p>每个智能合约都必须提供应用操作处理程序。 apply动作处理程序是一个侦听所有传入操作并执行所需行为的函数。 为了响应特定操作，code识别和响应特定操作请求。 apply使用receiver、code、action输入参数作为过滤器，来映射到实现特定操作的所需功能。 apply函数可以使用以下方法过滤code参数：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">if</span> (code == <span class="hljs-constant">N</span>(<span class="hljs-variable">${</span>contract_name}) {
   <span class="hljs-regexp">//</span>对特定动作的处理
}</code></pre> 
  <p>在给定code之后，可以使用如下方法过滤action参数：</p> 
  <pre class="prettyprint"><code class=" hljs sql">if (action == N(${action_name}) {
    //your <span class="hljs-operator"><span class="hljs-keyword">handler</span> <span class="hljs-keyword">to</span> respond <span class="hljs-keyword">to</span> a particular <span class="hljs-keyword">action</span> }</span></code></pre> 
  <h2 id="33-eosioabi-宏">3.3 EOSIO_ABI 宏</h2> 
  <p>EOSIO_ABI宏封装了apply函数的基本动作：</p> 
  <pre class="prettyprint"><code class=" hljs tex"><span class="hljs-special">#</span>define EOSIO_ABI( TYPE, MEMBERS ) <span class="hljs-command">\ </span>extern "C" <span class="hljs-special">{</span> <span class="hljs-command">\ </span>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) <span class="hljs-special">{</span> <span class="hljs-command">\ </span>      auto self = receiver; <span class="hljs-command">\ </span>      if( code == self ) <span class="hljs-special">{</span> <span class="hljs-command">\ </span>         TYPE thiscontract( self ); <span class="hljs-command">\ </span>         switch( action ) <span class="hljs-special">{</span> <span class="hljs-command">\ </span>            EOSIO_API( TYPE, MEMBERS ) <span class="hljs-command">\ </span>         <span class="hljs-special">}</span> <span class="hljs-command">\ </span>         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ <span class="hljs-command">\ </span>      <span class="hljs-special">}</span> <span class="hljs-command">\ </span>   <span class="hljs-special">}</span> <span class="hljs-command">\ </span><span class="hljs-special">}</span> \</code></pre> 
  <p>只需要在宏中指定合约中的code和action名称即可，所有底层C代码映射逻辑都由宏生成。 如EOSIO_ABI（hello，（hi））中，hello和hi是来自合约的值。 <br> apply函数记录所交付的行为，不做任何其他检查。 如果块生产者允许，任何人都可以随时提供任何操作。 如果没有任何必要的签名，合约将按消耗的带宽计费。 <br> （1）apply:动作处理程序，它监听所有传入的动作并根据函数中的规范做出反应。 需要两个输入参数code和action。 <br> （2）code filter：</p> 
  <pre class="prettyprint"><code class=" hljs sql">if (code == N(${contract_name}) {
    // your <span class="hljs-operator"><span class="hljs-keyword">handler</span> <span class="hljs-keyword">to</span> respond <span class="hljs-keyword">to</span> particular <span class="hljs-keyword">action</span> }</span></code></pre> 
  <p>（3）action filter：</p> 
  <pre class="prettyprint"><code class=" hljs sql">if (action == N(${action_name}) {
    //your <span class="hljs-operator"><span class="hljs-keyword">handler</span> <span class="hljs-keyword">to</span> respond <span class="hljs-keyword">to</span> a particular <span class="hljs-keyword">action</span> }</span></code></pre> 
  <p>（4）wast：部署到区块链的程序必须是wast格式，编译方法如下：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>eosiocpp -o <span class="hljs-variable">${</span>contract}.wast <span class="hljs-variable">${</span>contract}.cpp</code></pre> 
  <p>（5）abi:应用程序二进制接口（ABI）是一个JSON，在JSON和二进制之间转换用户操作。 abi还描述了如何将数据库状态转换为JSON或从JSON转换。 通过abi描述合约后，开发人员和用户将能够通过JSON无缝地与所开发的合约进行交互。可以如下编译产生：</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>eosiocpp -g <span class="hljs-variable">${</span>contract}.abi <span class="hljs-variable">${</span>contract}.hpp</code></pre> 
  <p>ABI的一个例子：</p> 
  <pre class="prettyprint"><code class=" hljs ruby">{
<span class="hljs-regexp">//</span>定义现有类型的别名列表,在这里，将name定义为account_name的别名。
  <span class="hljs-string">"types"</span><span class="hljs-symbol">:</span> [{
      <span class="hljs-string">"new_type_name"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account_name"</span>,
      <span class="hljs-string">"type"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"name"</span>
    }
  ],
  <span class="hljs-string">"structs"</span><span class="hljs-symbol">:</span> [{
  <span class="hljs-regexp">//</span>在此处定义了transfer类型
      <span class="hljs-string">"name"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"transfer"</span>,
      <span class="hljs-string">"base"</span><span class="hljs-symbol">:</span> <span class="hljs-string">""</span>,
  <span class="hljs-regexp">//from</span>、to、quantity与<span class="hljs-string">"types"</span>相对应
      <span class="hljs-string">"fields"</span><span class="hljs-symbol">:</span> {
        <span class="hljs-string">"from"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account_name"</span>,
        <span class="hljs-string">"to"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account_name"</span>,
        <span class="hljs-string">"quantity"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"uint64"</span>
      }
    },{
      <span class="hljs-string">"name"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account"</span>,
      <span class="hljs-string">"base"</span><span class="hljs-symbol">:</span> <span class="hljs-string">""</span>,
      <span class="hljs-string">"fields"</span><span class="hljs-symbol">:</span> {
        <span class="hljs-string">"account"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"name"</span>,
        <span class="hljs-string">"balance"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"uint64"</span>
      }
    }
  ],
  <span class="hljs-regexp">//</span>在此定义了<span class="hljs-symbol">action:</span>transfer,类型为transfer。告诉<span class="hljs-constant">EOSIO</span>遇到<span class="hljs-variable">${</span>account}-&gt;transfer时应该载入trransfer类
  <span class="hljs-string">"actions"</span><span class="hljs-symbol">:</span> [{
      <span class="hljs-string">"action"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"transfer"</span>,
      <span class="hljs-string">"type"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"transfer"</span>
    }
  ],
  <span class="hljs-string">"tables"</span><span class="hljs-symbol">:</span> [{
      <span class="hljs-string">"table"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account"</span>,
      <span class="hljs-string">"type"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"account"</span>,
      <span class="hljs-string">"index_type"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"i64"</span>,
      <span class="hljs-string">"key_names"</span> <span class="hljs-symbol">:</span> [<span class="hljs-string">"account"</span>],
      <span class="hljs-string">"key_types"</span> <span class="hljs-symbol">:</span> [<span class="hljs-string">"name"</span>]
    }
  ]
}</code></pre> 
  <h1 id="四多索引数据库api">四、多索引数据库API</h1> 
  <p>EOSIO提供了一组服务和接口，使合约开发人员能够跨行动保持状态，从而保持事务边界。 如果没有持久性，当处理超出范围时，在处理操作和事务期间生成的状态将丢失。 <br> 对持久性服务的需求 <br> acttion执行EOSIO合同的工作。 action在上下文的环境中运行。 如action apply上下文关系图中所示，操作上下文提供了执行操作所需的一些操作。 在处理操作之前，EOSIO会为操作设置一个干净的工作内存。 在操作之间传递状态的唯一方法是将其持久化并从EOSIO数据库中检索它。 <br> 持久性组件包括： <br> 1）在数据库中保持状态的服务 <br> 2）增强查询功能以查找和检索数据库内容 <br> 3）服务的C ++ API，供合约开发人员使用 <br> 4）用于访问核心服务的C API，对库和系统开发人员有用</p> 
  <h2 id="41-eosio多索引api">4.1 EOSIO多索引API</h2> 
  <p>eosio :: multi_index对应传统数据库中的表，其中行是容器中的单个对象，列是容器中对象的成员属性，索引提供了对象的快速查找。 key与对象成员属性兼容。 <br> 传统的数据库表允许索引是表中某些列的用户定义函数。 eosio :: multi_index类似地允许索引是任何用户定义的函数（作为元素类型的类/结构的成员函数提供），但其返回值仅限于一组受限的支持键类型。 <br> 统的数据库表通常只有一个允许的唯一主键明确标识表中的特定行，并提供表中行的标准排序顺序。 eosio :: multi_index支持类似的语义，但eosio :: multi_index容器中对象的主键必须是唯一的无符号64位整数。 eosio :: multi_index容器中的对象按主键索引按无符号64位整数主键的升序排序。</p> 
  <h2 id="42-eosio多索引迭代器">4.2 EOSIO多索引迭代器</h2> 
  <p>EOSIO持久性服务提供多索引迭代器。 与仅提供键值存储的其他区块链不同，EOSIO多索引表允许合同开发者保留按各种不同键类型排序的对象集合，这些键类型可以从对象内的数据派生。 这实现了丰富的检索功能。 最多可以定义16个二级索引，每个索引都有自己的排序和检索表内容的方式。 <br> EOSIO多索引迭代器遵循C ++迭代器通用的模式。 所有迭代器都是双向const，const_iterator或const_reverse_iterator。 可以取消引用迭代器以提供对多索引表中对象的访问。</p> 
  <h2 id="43-创建多索引表">4.3 创建多索引表</h2> 
  <p>以下是使用EOSIO Multi-Index表创建自己的持久数据的步骤： <br> 1）使用C ++类或结构体定义对象。每个对象都在其自己的多索引表中。 <br> 2）在名为primary_key的类/结构中定义一个const成员函数，该函数返回对象的uint64_t主键值。 <br> 3）确定二级指数。最多支持16个附加索引。二级指数支持几种密钥类型： <br> idx64 - 原始64位无符号整数键 <br> idx128 - 原始128位无符号整数键，或128位固定大小的词典键 <br> idx256 - 256位固定大小的词典键 <br> idx_double - 双精度浮点键 <br> idx_long_double - 四倍精度浮点键 <br> 为每个二级索引定义一个密钥提取器。密钥提取器是用于从多索引表的元素获取密钥的函数。</p> 
  <h2 id="44-创建多索引表">4.4 创建多索引表</h2> 
  <p>（1）实例化多索引表</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
  <p>（2）插入操作：</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
      <span class="hljs-comment">// add to table, first argument is account to bill for storage</span>
      addresses.emplace(_self, [&amp;](<span class="hljs-keyword">auto</span>&amp; address) {
        address.account_name = N(dan);
        address.first_name = <span class="hljs-string">"Daniel"</span>;
        address.last_name = <span class="hljs-string">"Larimer"</span>;
        address.street = <span class="hljs-string">"1 EOS Way"</span>;
        address.city = <span class="hljs-string">"Blacksburg"</span>;
        address.state = <span class="hljs-string">"VA"</span>;
      });
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
  <p>（2）修改：</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
      <span class="hljs-comment">// add to table, first argument is account to bill for storage</span>
      addresses.emplace(_self, [&amp;](<span class="hljs-keyword">auto</span>&amp; address) {
        address.account_name = N(dan);
        address.first_name = <span class="hljs-string">"Daniel"</span>;
        address.last_name = <span class="hljs-string">"Larimer"</span>;
        address.street = <span class="hljs-string">"1 EOS Way"</span>;
        address.city = <span class="hljs-string">"Blacksburg"</span>;
        address.state = <span class="hljs-string">"VA"</span>;
      });
      <span class="hljs-keyword">auto</span> itr = addresses.find(N(dan));
      eosio_assert(itr != addresses.end(), <span class="hljs-string">"Address for account not found"</span>);
      addresses.modify( itr, account payer, [&amp;]( <span class="hljs-keyword">auto</span>&amp; address ) {
        address.city = <span class="hljs-string">"San Luis Obispo"</span>;
        address.state = <span class="hljs-string">"CA"</span>;
      });
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
  <p>（3）删除</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
      <span class="hljs-comment">// add to table, first argument is account to bill for storage</span>
      addresses.emplace(_self, [&amp;](<span class="hljs-keyword">auto</span>&amp; address) {
        address.account_name = N(dan);
        address.first_name = <span class="hljs-string">"Daniel"</span>;
        address.last_name = <span class="hljs-string">"Larimer"</span>;
        address.street = <span class="hljs-string">"1 EOS Way"</span>;
        address.city = <span class="hljs-string">"Blacksburg"</span>;
        address.state = <span class="hljs-string">"VA"</span>;
      });
      <span class="hljs-keyword">auto</span> itr = addresses.find(N(dan));
      eosio_assert(itr != addresses.end(), <span class="hljs-string">"Address for account not found"</span>);
      addresses.erase( itr );
      eosio_assert(itr != addresses.end(), <span class="hljs-string">"Address not erased properly"</span>);
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
  <p>（5）get <br> 使用主键查找，返回对包含指定主键的对象的常量引用。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
      <span class="hljs-comment">// add to table, first argument is account to bill for storage</span>
      addresses.emplace(_self, [&amp;](<span class="hljs-keyword">auto</span>&amp; address) {
        address.account_name = N(dan);
        address.first_name = <span class="hljs-string">"Daniel"</span>;
        address.last_name = <span class="hljs-string">"Larimer"</span>;
        address.street = <span class="hljs-string">"1 EOS Way"</span>;
        address.city = <span class="hljs-string">"Blacksburg"</span>;
        address.state = <span class="hljs-string">"VA"</span>;
      });
      <span class="hljs-keyword">auto</span> user = addresses.get(N(dan));
      eosio_assert(user.first_name == <span class="hljs-string">"Daniel"</span>, <span class="hljs-string">"Couldn't get him."</span>);
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
  <p>（6）find <br> 使用主键在表中搜索现有对象。如果找不到具有主键primary的对象，则找到的对象的迭代器，其主键等于主键或引用表的结束迭代器。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> eosio;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> addressbook: contract {
  <span class="hljs-keyword">struct</span> address {
     uint64_t account_name;
     <span class="hljs-built_in">string</span> first_name;
     <span class="hljs-built_in">string</span> last_name;
     <span class="hljs-built_in">string</span> street;
     <span class="hljs-built_in">string</span> city;
     <span class="hljs-built_in">string</span> state;
     uint64_t primary_key() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> account_name; }
     EOSLIB_SERIALIZE( address, (account_name)(first_name)(last_name)(street)(city)(state) )
  };
  <span class="hljs-keyword">public</span>:
    addressbook(account_name self):contract(self) {}
    <span class="hljs-keyword">typedef</span> eosio::multi_index&lt; N(address), address &gt; address_index;
    <span class="hljs-keyword">void</span> myaction() {
      address_index addresses(_self, _self); <span class="hljs-comment">// code, scope</span>
      <span class="hljs-comment">// add to table, first argument is account to bill for storage</span>
      addresses.emplace(_self, [&amp;](<span class="hljs-keyword">auto</span>&amp; address) {
        address.account_name = N(dan);
        address.first_name = <span class="hljs-string">"Daniel"</span>;
        address.last_name = <span class="hljs-string">"Larimer"</span>;
        address.street = <span class="hljs-string">"1 EOS Way"</span>;
        address.city = <span class="hljs-string">"Blacksburg"</span>;
        address.state = <span class="hljs-string">"VA"</span>;
      });
      <span class="hljs-keyword">auto</span> itr = addresses.find(N(dan));
      eosio_assert(itr != addresses.end(), <span class="hljs-string">"Couldn't get him."</span>);
    }
}
EOSIO_ABI( addressbook, (myaction) )</code></pre> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/http188188/article/details/81504087,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/http188188/article/details/81504087,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
