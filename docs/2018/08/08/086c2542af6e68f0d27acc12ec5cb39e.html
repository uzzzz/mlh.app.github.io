<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链的浅要了解 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链的浅要了解" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="最近去了解了一下前段时间很火的比特币，不看之前听亲朋讲大概是类似传销一样的东西，简单了解之后越发觉得这个东西很神奇，可以说，很刺激。 说起区块链，必谈的肯定是比特币。 1.人类商品贸易形式的发展。 原始社会的以物换物，到黄金这样的实物货币，到纸币这样的符号货币，再到中央银行，也就是现在这样的刷卡支付。无论任何的交易，都将经过银行。 存在的问题： 以物换物：极其不方便，但是仍然有其可保留性。 实物货币：货币产量有限，而且存在遗失的可能性。 符号货币：存储进出的方式很不方便。 中央银行：如果记账方的公信力不足，存在记账者作弊的可能性。 2.比特币的简要机制 基础： A.账本 1.有一本公开的账本（有且仅有）：1.任何人都可以看到所有交易的账本，交易的范围不再局限于自己个人，而是从账本存在开始的所有交易，他人的也是可以看到的。 2.取消了传统的记录余额的做法，只要有存初始变量，那么每一个人都是可以被算出有多少钱的，只要记录每一笔交易即可。 B公钥加密系统 说白了，就是个身份和签名机制，密码学里的一个东西。 有两方面，保证了双方交易互相不知道对方是谁，比如自己这边的公钥，可以进行签名，而且这个签名是不可被伪造的。 然后自己这边也有另一个检验章的东西，可以显示出这个章隐藏的交易信息从而进行交易。 C记账的人 那么问题就来了，账本有了，交易的方法也有了，那么不还是需要一个记账的人吗。 这个时候就有一个思维误区了，谁说记账的人就一定是一个人？既然记账的人要存在公信力，那么什么是比大多数更存在公信力的呢？如果一笔交易，大多数都认为这是正确的，那么这就是正确的。 也就是很多人所称的挖矿了，首先，矿工肯定是个劳动者，他可以是很多人，很多人必然会存在竞争。那么竞争就需要一个诱惑，这个诱惑就是酬劳，于是只需要一个奖励机制即可。 3.再深入的理解比特币的交易与支付。 比如A给B10个比特币，这时候你的账单上应该有的信息是，A的签名认证，比特币的数量，付款人，收款人。 然后将这个账单发给收款的人B，那么就出现了问题了，收款的人B，怎么知道A够不够付这10个，虽然知道了这个人，但是如何知道这个人够不够余额。其实解决也不难，就是把交易生效的时间一定要定死在矿工确定这个交易有效之后，也就说说，矿工要承担传统银行的那个责任，检查A的余额是否足够。 4.那么就是矿工的工作。 其实说白了，就是记账。 这时候就要提到一个耳熟能详的函数了--哈希函数，因为哈希函数的种类有很多种，而且随着时代的发展很多已经被证明不再安全。这里面就有个著名的生日攻击。 但是SHA256并不存在这个漏洞，于是使用两次，可以保证在目前的环境下，不会造成漏洞。 这个具体有空再写。 也就是说，矿工实际上有很多的工作要做。 首先，要保证这是一本完整的账本，不能出现同样的页码。 然后就是不能出现重复的记账，两页记录同一个消息。 最后就是要判断，哪个矿工的账本记录是有效的。 关于第一个问题，其实是很简单的，说白了，怎么保证一页接一页？首先想到的肯定是链表啊，只要在这一页的那里记录上上一页的页码不就保证了这样的操作。 关于第二个第三个问题，也就是要有一个对矿工们做出的账单有个比较检验的机制，于是比特币的创造者设置了一个幸运数字，大家知道hash函数，任何一部分小的改变，可以造成最终hash结果的巨大差异。那么这个时候，我们可以有一个生成页码的公式 当前账单页码=Hash(账单本身的内容，上一页账单的页码，幸运数字),然后系统规定一个最终的结果必须满足一个条件，比如说，页码的开头必须是五个0？被小看这个条件，这个条件肯定是艰难的，因为哈希函数是不可逆转的，也就是说你只能通过幸运数字的不断尝试而得到正确的结果。如果矿工的劳动成果正确且完整，那么很简单，可以得到一定的酬劳。 5.如何确认矿工得到的账本就是正确的。 上面说了，最好的公信力其实是大多数，如果一个矿工得到了账本，那么其他所有的矿工必须停下所有正在进行的工作去确认这个账本，这个工作是没有酬劳的，因为比较简单，只要检验账本的编号正确，前一页的账本存在且是有效的，而且交易的余额恰好能达成即可。确认之后无异议就可以将这一页也给装订进去，交易达成，矿工也得到了该得到的酬劳，保证了矿工手里始终只有一本账本。 6.存在的问题 1.如果同时受到了两份账本，但是账本都是合法的。那么就不存在用线性链表的方式了，那么有人会说，很简单啊，用树就是了。树会存在主干，只要最长的链始终作为主干就可以了。这样的问题可能会造成账本的不一致，但是这种不一致换句话讲，无伤大雅，因为小分支，终究是会消失的。 2.如果矿工全部被买通？这个显然是不存在的，因为每个人都不知道对方是谁，没有人能伪造他人信息去付款，诚实的矿工也不会去承认不合法的有效性。 3.存在的攻击行为？如果一个人只有10个B，他同时付给了A和B，同时获得了A和B给的酬劳，也被记账了。 那么怎么做到呢，其实很简单，这个人先付A10个B，A看到记账之后，确认到账，付了钱，账本上也有了。 然后这个人变成矿工的角色，获得刚才被确认的前一页，做出分支，超过刚才的分支长度，这样A的那个分支就不再有效，也就是不被矿工所认可。 这个时候就可以再付给B10个，理论上可以一直下去。 那么问题来了- -仔细一想，这样真的能造出比它长很多的分支吗？不可能吧。因为幸运数字完全是运气，没有推算的可能性，除非他有庞大的计算体系或是什么还未知的巧妙算法。 4.矿工收获的酬劳如何获得。 系统发放？如果一直发放不是相当于在变相增加比特币？和货币一样，大量发放是不可能的，这回严重的通货膨胀，比如说津巴布韦币。 其实问题很好解决，一开始可以由系统发放奖励，当记账数到一定程度，减少，然后再减少，一直到没有，然后比特币就定死了。 那么这个时候谁还会做矿工不是吃力不讨好吗？这个时候矿工就不再是义务了，需要支付的人给予他们类似税一样的东西，也就是办事费，手续费，。 &nbsp; 那么区块实际就是指一页页的账本。它的数据结构实际是一个默克树。然后那个签名的了解密码学的应该也是看出来了，就是EC（椭圆曲线加密） &nbsp; 阅读更多" />
<meta property="og:description" content="最近去了解了一下前段时间很火的比特币，不看之前听亲朋讲大概是类似传销一样的东西，简单了解之后越发觉得这个东西很神奇，可以说，很刺激。 说起区块链，必谈的肯定是比特币。 1.人类商品贸易形式的发展。 原始社会的以物换物，到黄金这样的实物货币，到纸币这样的符号货币，再到中央银行，也就是现在这样的刷卡支付。无论任何的交易，都将经过银行。 存在的问题： 以物换物：极其不方便，但是仍然有其可保留性。 实物货币：货币产量有限，而且存在遗失的可能性。 符号货币：存储进出的方式很不方便。 中央银行：如果记账方的公信力不足，存在记账者作弊的可能性。 2.比特币的简要机制 基础： A.账本 1.有一本公开的账本（有且仅有）：1.任何人都可以看到所有交易的账本，交易的范围不再局限于自己个人，而是从账本存在开始的所有交易，他人的也是可以看到的。 2.取消了传统的记录余额的做法，只要有存初始变量，那么每一个人都是可以被算出有多少钱的，只要记录每一笔交易即可。 B公钥加密系统 说白了，就是个身份和签名机制，密码学里的一个东西。 有两方面，保证了双方交易互相不知道对方是谁，比如自己这边的公钥，可以进行签名，而且这个签名是不可被伪造的。 然后自己这边也有另一个检验章的东西，可以显示出这个章隐藏的交易信息从而进行交易。 C记账的人 那么问题就来了，账本有了，交易的方法也有了，那么不还是需要一个记账的人吗。 这个时候就有一个思维误区了，谁说记账的人就一定是一个人？既然记账的人要存在公信力，那么什么是比大多数更存在公信力的呢？如果一笔交易，大多数都认为这是正确的，那么这就是正确的。 也就是很多人所称的挖矿了，首先，矿工肯定是个劳动者，他可以是很多人，很多人必然会存在竞争。那么竞争就需要一个诱惑，这个诱惑就是酬劳，于是只需要一个奖励机制即可。 3.再深入的理解比特币的交易与支付。 比如A给B10个比特币，这时候你的账单上应该有的信息是，A的签名认证，比特币的数量，付款人，收款人。 然后将这个账单发给收款的人B，那么就出现了问题了，收款的人B，怎么知道A够不够付这10个，虽然知道了这个人，但是如何知道这个人够不够余额。其实解决也不难，就是把交易生效的时间一定要定死在矿工确定这个交易有效之后，也就说说，矿工要承担传统银行的那个责任，检查A的余额是否足够。 4.那么就是矿工的工作。 其实说白了，就是记账。 这时候就要提到一个耳熟能详的函数了--哈希函数，因为哈希函数的种类有很多种，而且随着时代的发展很多已经被证明不再安全。这里面就有个著名的生日攻击。 但是SHA256并不存在这个漏洞，于是使用两次，可以保证在目前的环境下，不会造成漏洞。 这个具体有空再写。 也就是说，矿工实际上有很多的工作要做。 首先，要保证这是一本完整的账本，不能出现同样的页码。 然后就是不能出现重复的记账，两页记录同一个消息。 最后就是要判断，哪个矿工的账本记录是有效的。 关于第一个问题，其实是很简单的，说白了，怎么保证一页接一页？首先想到的肯定是链表啊，只要在这一页的那里记录上上一页的页码不就保证了这样的操作。 关于第二个第三个问题，也就是要有一个对矿工们做出的账单有个比较检验的机制，于是比特币的创造者设置了一个幸运数字，大家知道hash函数，任何一部分小的改变，可以造成最终hash结果的巨大差异。那么这个时候，我们可以有一个生成页码的公式 当前账单页码=Hash(账单本身的内容，上一页账单的页码，幸运数字),然后系统规定一个最终的结果必须满足一个条件，比如说，页码的开头必须是五个0？被小看这个条件，这个条件肯定是艰难的，因为哈希函数是不可逆转的，也就是说你只能通过幸运数字的不断尝试而得到正确的结果。如果矿工的劳动成果正确且完整，那么很简单，可以得到一定的酬劳。 5.如何确认矿工得到的账本就是正确的。 上面说了，最好的公信力其实是大多数，如果一个矿工得到了账本，那么其他所有的矿工必须停下所有正在进行的工作去确认这个账本，这个工作是没有酬劳的，因为比较简单，只要检验账本的编号正确，前一页的账本存在且是有效的，而且交易的余额恰好能达成即可。确认之后无异议就可以将这一页也给装订进去，交易达成，矿工也得到了该得到的酬劳，保证了矿工手里始终只有一本账本。 6.存在的问题 1.如果同时受到了两份账本，但是账本都是合法的。那么就不存在用线性链表的方式了，那么有人会说，很简单啊，用树就是了。树会存在主干，只要最长的链始终作为主干就可以了。这样的问题可能会造成账本的不一致，但是这种不一致换句话讲，无伤大雅，因为小分支，终究是会消失的。 2.如果矿工全部被买通？这个显然是不存在的，因为每个人都不知道对方是谁，没有人能伪造他人信息去付款，诚实的矿工也不会去承认不合法的有效性。 3.存在的攻击行为？如果一个人只有10个B，他同时付给了A和B，同时获得了A和B给的酬劳，也被记账了。 那么怎么做到呢，其实很简单，这个人先付A10个B，A看到记账之后，确认到账，付了钱，账本上也有了。 然后这个人变成矿工的角色，获得刚才被确认的前一页，做出分支，超过刚才的分支长度，这样A的那个分支就不再有效，也就是不被矿工所认可。 这个时候就可以再付给B10个，理论上可以一直下去。 那么问题来了- -仔细一想，这样真的能造出比它长很多的分支吗？不可能吧。因为幸运数字完全是运气，没有推算的可能性，除非他有庞大的计算体系或是什么还未知的巧妙算法。 4.矿工收获的酬劳如何获得。 系统发放？如果一直发放不是相当于在变相增加比特币？和货币一样，大量发放是不可能的，这回严重的通货膨胀，比如说津巴布韦币。 其实问题很好解决，一开始可以由系统发放奖励，当记账数到一定程度，减少，然后再减少，一直到没有，然后比特币就定死了。 那么这个时候谁还会做矿工不是吃力不讨好吗？这个时候矿工就不再是义务了，需要支付的人给予他们类似税一样的东西，也就是办事费，手续费，。 &nbsp; 那么区块实际就是指一页页的账本。它的数据结构实际是一个默克树。然后那个签名的了解密码学的应该也是看出来了，就是EC（椭圆曲线加密） &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/08/086c2542af6e68f0d27acc12ec5cb39e.html" />
<meta property="og:url" content="https://mlh.app/2018/08/08/086c2542af6e68f0d27acc12ec5cb39e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"最近去了解了一下前段时间很火的比特币，不看之前听亲朋讲大概是类似传销一样的东西，简单了解之后越发觉得这个东西很神奇，可以说，很刺激。 说起区块链，必谈的肯定是比特币。 1.人类商品贸易形式的发展。 原始社会的以物换物，到黄金这样的实物货币，到纸币这样的符号货币，再到中央银行，也就是现在这样的刷卡支付。无论任何的交易，都将经过银行。 存在的问题： 以物换物：极其不方便，但是仍然有其可保留性。 实物货币：货币产量有限，而且存在遗失的可能性。 符号货币：存储进出的方式很不方便。 中央银行：如果记账方的公信力不足，存在记账者作弊的可能性。 2.比特币的简要机制 基础： A.账本 1.有一本公开的账本（有且仅有）：1.任何人都可以看到所有交易的账本，交易的范围不再局限于自己个人，而是从账本存在开始的所有交易，他人的也是可以看到的。 2.取消了传统的记录余额的做法，只要有存初始变量，那么每一个人都是可以被算出有多少钱的，只要记录每一笔交易即可。 B公钥加密系统 说白了，就是个身份和签名机制，密码学里的一个东西。 有两方面，保证了双方交易互相不知道对方是谁，比如自己这边的公钥，可以进行签名，而且这个签名是不可被伪造的。 然后自己这边也有另一个检验章的东西，可以显示出这个章隐藏的交易信息从而进行交易。 C记账的人 那么问题就来了，账本有了，交易的方法也有了，那么不还是需要一个记账的人吗。 这个时候就有一个思维误区了，谁说记账的人就一定是一个人？既然记账的人要存在公信力，那么什么是比大多数更存在公信力的呢？如果一笔交易，大多数都认为这是正确的，那么这就是正确的。 也就是很多人所称的挖矿了，首先，矿工肯定是个劳动者，他可以是很多人，很多人必然会存在竞争。那么竞争就需要一个诱惑，这个诱惑就是酬劳，于是只需要一个奖励机制即可。 3.再深入的理解比特币的交易与支付。 比如A给B10个比特币，这时候你的账单上应该有的信息是，A的签名认证，比特币的数量，付款人，收款人。 然后将这个账单发给收款的人B，那么就出现了问题了，收款的人B，怎么知道A够不够付这10个，虽然知道了这个人，但是如何知道这个人够不够余额。其实解决也不难，就是把交易生效的时间一定要定死在矿工确定这个交易有效之后，也就说说，矿工要承担传统银行的那个责任，检查A的余额是否足够。 4.那么就是矿工的工作。 其实说白了，就是记账。 这时候就要提到一个耳熟能详的函数了--哈希函数，因为哈希函数的种类有很多种，而且随着时代的发展很多已经被证明不再安全。这里面就有个著名的生日攻击。 但是SHA256并不存在这个漏洞，于是使用两次，可以保证在目前的环境下，不会造成漏洞。 这个具体有空再写。 也就是说，矿工实际上有很多的工作要做。 首先，要保证这是一本完整的账本，不能出现同样的页码。 然后就是不能出现重复的记账，两页记录同一个消息。 最后就是要判断，哪个矿工的账本记录是有效的。 关于第一个问题，其实是很简单的，说白了，怎么保证一页接一页？首先想到的肯定是链表啊，只要在这一页的那里记录上上一页的页码不就保证了这样的操作。 关于第二个第三个问题，也就是要有一个对矿工们做出的账单有个比较检验的机制，于是比特币的创造者设置了一个幸运数字，大家知道hash函数，任何一部分小的改变，可以造成最终hash结果的巨大差异。那么这个时候，我们可以有一个生成页码的公式 当前账单页码=Hash(账单本身的内容，上一页账单的页码，幸运数字),然后系统规定一个最终的结果必须满足一个条件，比如说，页码的开头必须是五个0？被小看这个条件，这个条件肯定是艰难的，因为哈希函数是不可逆转的，也就是说你只能通过幸运数字的不断尝试而得到正确的结果。如果矿工的劳动成果正确且完整，那么很简单，可以得到一定的酬劳。 5.如何确认矿工得到的账本就是正确的。 上面说了，最好的公信力其实是大多数，如果一个矿工得到了账本，那么其他所有的矿工必须停下所有正在进行的工作去确认这个账本，这个工作是没有酬劳的，因为比较简单，只要检验账本的编号正确，前一页的账本存在且是有效的，而且交易的余额恰好能达成即可。确认之后无异议就可以将这一页也给装订进去，交易达成，矿工也得到了该得到的酬劳，保证了矿工手里始终只有一本账本。 6.存在的问题 1.如果同时受到了两份账本，但是账本都是合法的。那么就不存在用线性链表的方式了，那么有人会说，很简单啊，用树就是了。树会存在主干，只要最长的链始终作为主干就可以了。这样的问题可能会造成账本的不一致，但是这种不一致换句话讲，无伤大雅，因为小分支，终究是会消失的。 2.如果矿工全部被买通？这个显然是不存在的，因为每个人都不知道对方是谁，没有人能伪造他人信息去付款，诚实的矿工也不会去承认不合法的有效性。 3.存在的攻击行为？如果一个人只有10个B，他同时付给了A和B，同时获得了A和B给的酬劳，也被记账了。 那么怎么做到呢，其实很简单，这个人先付A10个B，A看到记账之后，确认到账，付了钱，账本上也有了。 然后这个人变成矿工的角色，获得刚才被确认的前一页，做出分支，超过刚才的分支长度，这样A的那个分支就不再有效，也就是不被矿工所认可。 这个时候就可以再付给B10个，理论上可以一直下去。 那么问题来了- -仔细一想，这样真的能造出比它长很多的分支吗？不可能吧。因为幸运数字完全是运气，没有推算的可能性，除非他有庞大的计算体系或是什么还未知的巧妙算法。 4.矿工收获的酬劳如何获得。 系统发放？如果一直发放不是相当于在变相增加比特币？和货币一样，大量发放是不可能的，这回严重的通货膨胀，比如说津巴布韦币。 其实问题很好解决，一开始可以由系统发放奖励，当记账数到一定程度，减少，然后再减少，一直到没有，然后比特币就定死了。 那么这个时候谁还会做矿工不是吃力不讨好吗？这个时候矿工就不再是义务了，需要支付的人给予他们类似税一样的东西，也就是办事费，手续费，。 &nbsp; 那么区块实际就是指一页页的账本。它的数据结构实际是一个默克树。然后那个签名的了解密码学的应该也是看出来了，就是EC（椭圆曲线加密） &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/08/086c2542af6e68f0d27acc12ec5cb39e.html","headline":"区块链的浅要了解","dateModified":"2018-08-08T00:00:00+08:00","datePublished":"2018-08-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/08/086c2542af6e68f0d27acc12ec5cb39e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链的浅要了解</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>最近去了解了一下前段时间很火的比特币，不看之前听亲朋讲大概是类似传销一样的东西，简单了解之后越发觉得这个东西很神奇，可以说，很刺激。</p> 
  <p>说起区块链，必谈的肯定是比特币。</p> 
  <p>1.人类商品贸易形式的发展。</p> 
  <p>原始社会的以物换物，到黄金这样的实物货币，到纸币这样的符号货币，再到中央银行，也就是现在这样的刷卡支付。无论任何的交易，都将经过银行。</p> 
  <p>存在的问题：</p> 
  <p>以物换物：极其不方便，但是仍然有其可保留性。</p> 
  <p>实物货币：货币产量有限，而且存在遗失的可能性。</p> 
  <p>符号货币：存储进出的方式很不方便。</p> 
  <p>中央银行：如果记账方的公信力不足，存在记账者作弊的可能性。</p> 
  <p>2.比特币的简要机制</p> 
  <p>基础：</p> 
  <p>A.账本</p> 
  <p>1.有一本公开的账本（有且仅有）：1.任何人都可以看到所有交易的账本，交易的范围不再局限于自己个人，而是从账本存在开始的所有交易，他人的也是可以看到的。</p> 
  <p>2.取消了传统的记录余额的做法，只要有存初始变量，那么每一个人都是可以被算出有多少钱的，只要记录每一笔交易即可。</p> 
  <p>B公钥加密系统</p> 
  <p>说白了，就是个身份和签名机制，密码学里的一个东西。</p> 
  <p>有两方面，保证了双方交易互相不知道对方是谁，比如自己这边的公钥，可以进行签名，而且这个签名是不可被伪造的。</p> 
  <p>然后自己这边也有另一个检验章的东西，可以显示出这个章隐藏的交易信息从而进行交易。</p> 
  <p>C记账的人</p> 
  <p>那么问题就来了，账本有了，交易的方法也有了，那么不还是需要一个记账的人吗。</p> 
  <p>这个时候就有一个思维误区了，谁说记账的人就一定是一个人？既然记账的人要存在公信力，那么什么是比大多数更存在公信力的呢？如果一笔交易，大多数都认为这是正确的，那么这就是正确的。</p> 
  <p>也就是很多人所称的挖矿了，首先，矿工肯定是个劳动者，他可以是很多人，很多人必然会存在竞争。那么竞争就需要一个诱惑，这个诱惑就是酬劳，于是只需要一个奖励机制即可。</p> 
  <p>3.再深入的理解比特币的交易与支付。</p> 
  <p>比如A给B10个比特币，这时候你的账单上应该有的信息是，A的签名认证，比特币的数量，付款人，收款人。</p> 
  <p>然后将这个账单发给收款的人B，那么就出现了问题了，收款的人B，怎么知道A够不够付这10个，虽然知道了这个人，但是如何知道这个人够不够余额。其实解决也不难，就是把交易生效的时间一定要定死在矿工确定这个交易有效之后，也就说说，矿工要承担传统银行的那个责任，检查A的余额是否足够。</p> 
  <p>4.那么就是矿工的工作。</p> 
  <p>其实说白了，就是记账。</p> 
  <p>这时候就要提到一个耳熟能详的函数了--哈希函数，因为哈希函数的种类有很多种，而且随着时代的发展很多已经被证明不再安全。这里面就有个著名的生日攻击。</p> 
  <p>但是SHA256并不存在这个漏洞，于是使用两次，可以保证在目前的环境下，不会造成漏洞。</p> 
  <p>这个具体有空再写。</p> 
  <p>也就是说，矿工实际上有很多的工作要做。</p> 
  <p>首先，要保证这是一本完整的账本，不能出现同样的页码。</p> 
  <p>然后就是不能出现重复的记账，两页记录同一个消息。</p> 
  <p>最后就是要判断，哪个矿工的账本记录是有效的。</p> 
  <p>关于第一个问题，其实是很简单的，说白了，怎么保证一页接一页？首先想到的肯定是链表啊，只要在这一页的那里记录上上一页的页码不就保证了这样的操作。</p> 
  <p>关于第二个第三个问题，也就是要有一个对矿工们做出的账单有个比较检验的机制，于是比特币的创造者设置了一个幸运数字，大家知道hash函数，任何一部分小的改变，可以造成最终hash结果的巨大差异。那么这个时候，我们可以有一个生成页码的公式</p> 
  <p>当前账单页码=Hash(账单本身的内容，上一页账单的页码，幸运数字),然后系统规定一个最终的结果必须满足一个条件，比如说，页码的开头必须是五个0？被小看这个条件，这个条件肯定是艰难的，因为哈希函数是不可逆转的，也就是说你只能通过幸运数字的不断尝试而得到正确的结果。如果矿工的劳动成果正确且完整，那么很简单，可以得到一定的酬劳。</p> 
  <p>5.如何确认矿工得到的账本就是正确的。</p> 
  <p>上面说了，最好的公信力其实是大多数，如果一个矿工得到了账本，那么其他所有的矿工必须停下所有正在进行的工作去确认这个账本，这个工作是没有酬劳的，因为比较简单，只要检验账本的编号正确，前一页的账本存在且是有效的，而且交易的余额恰好能达成即可。确认之后无异议就可以将这一页也给装订进去，交易达成，矿工也得到了该得到的酬劳，保证了矿工手里始终只有一本账本。</p> 
  <p>6.存在的问题</p> 
  <p>1.如果同时受到了两份账本，但是账本都是合法的。那么就不存在用线性链表的方式了，那么有人会说，很简单啊，用树就是了。树会存在主干，只要最长的链始终作为主干就可以了。这样的问题可能会造成账本的不一致，但是这种不一致换句话讲，无伤大雅，因为小分支，终究是会消失的。</p> 
  <p>2.如果矿工全部被买通？这个显然是不存在的，因为每个人都不知道对方是谁，没有人能伪造他人信息去付款，诚实的矿工也不会去承认不合法的有效性。</p> 
  <p>3.存在的攻击行为？如果一个人只有10个B，他同时付给了A和B，同时获得了A和B给的酬劳，也被记账了。</p> 
  <p>那么怎么做到呢，其实很简单，这个人先付A10个B，A看到记账之后，确认到账，付了钱，账本上也有了。</p> 
  <p>然后这个人变成矿工的角色，获得刚才被确认的前一页，做出分支，超过刚才的分支长度，这样A的那个分支就不再有效，也就是不被矿工所认可。</p> 
  <p>这个时候就可以再付给B10个，理论上可以一直下去。</p> 
  <p>那么问题来了- -仔细一想，这样真的能造出比它长很多的分支吗？不可能吧。因为幸运数字完全是运气，没有推算的可能性，除非他有庞大的计算体系或是什么还未知的巧妙算法。</p> 
  <p>4.矿工收获的酬劳如何获得。</p> 
  <p>系统发放？如果一直发放不是相当于在变相增加比特币？和货币一样，大量发放是不可能的，这回严重的通货膨胀，比如说津巴布韦币。</p> 
  <p>其实问题很好解决，一开始可以由系统发放奖励，当记账数到一定程度，减少，然后再减少，一直到没有，然后比特币就定死了。</p> 
  <p>那么这个时候谁还会做矿工不是吃力不讨好吗？这个时候矿工就不再是义务了，需要支付的人给予他们类似税一样的东西，也就是办事费，手续费，。</p> 
  <p>&nbsp;</p> 
  <p>那么区块实际就是指一页页的账本。它的数据结构实际是一个默克树。然后那个签名的了解密码学的应该也是看出来了，就是EC（椭圆曲线加密）</p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TateBrwonJava/article/details/81490874,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TateBrwonJava/article/details/81490874,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
