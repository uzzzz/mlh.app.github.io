<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>VNPY - CTA策略模块策略回测 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="VNPY - CTA策略模块策略回测" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者：魔元 目录 使用回测引擎 读懂回测报告 优化策略参数 多进程优化 量化策略主要是从历史数据统计或者发现规律然后应用于实盘交易。当然历史不是简单的重复，这就要求策略需要根据市场调整和优化参数。通过回测历史数据可以验证策略的有效性，了解策略的历史收益、最大回撤和回撤时长，对策略参数进行优化等等。CTA策略模块的主要回测目标是验证交易信号是否正确，仓位大小的问题在实盘中则由交易员来确定。 使用回测引擎 vnpy的回测引擎位于vnpy/trader/app/ctaStrategy/ctaBacktesting.py，此文件中主要包含以下几个类： BacktestingEngine 回测引擎类，主要功能是设置回测参数，初始化策略对象，运行回测并输出结果。类接口和实盘引擎类(CtaEngine)保持一致，从而实现同一套策略代码从回测到实盘。用户主要是调用本类的接口来回测策略。 TradingResult 撮合好的交易结果类，由回测引擎计算回测结果时使用。类成员包含开仓价格，平仓价格，交易数量，成交金额，滑点成本，手续费成本及净盈亏等。 这里面有一点注意是交易数量的正负代表开仓方向。以股指IF为例，3000点时开1手多单，3010点平仓，这时就会生成一个TradingResult实例，交易数量为1。若3000点时开1手空单，3010点平仓，这时生成的TradingResult实例的交易数量为-1。 代码如下： ```Python self.entryPrice = entryPrice # 开仓价格 self.exitPrice = exitPrice # 平仓价格 self.entryDt = entryDt # 开仓时间datetime self.exitDt = exitDt # 平仓时间 self.volume = volume # 交易数量（+/-代表方向） self.turnover = (self.entryPrice+self.exitPrice)*size*abs(volume) # 成交金额 self.commission = self.turnover*rate # 手续费成本 self.slippage = slippage*2*size*abs(volume) # 滑点成本 self.pnl = ((self.exitPrice - self.entryPrice) * volume * size - self.commission - self.slippage) # 净盈亏 ``` OptimizationSetting 参数优化设置类，主要是生成优化参数组合。每个参数组合都由回测引擎执行一遍，以得到不同参数组合的回测结果。优化参数回测时会使用此类。 回测引擎API介绍 由于用户主要是调用本类的接口来回测策略，所以将对本类的接口做逐一介绍。一方面回测引擎类的接口跟实盘策略引擎保持一样，这方面的接口主要是被策略调用； 另一方面回测引擎类也要提供回测相关的接口，所以将回测引擎类的接口从功能性分成这几个方面介绍： 用户回测策略接口 配置相关接口 setBacktestingMode 设置回测模式，支持两种模式，一种是Tick模式，另一种是K线模式 参数 类型 说明 mode string 回测模式，支持两种模式：BacktestingEngine.TICK_MODE和BacktestingEngine.BAR_MODE 返回值：None setStartDate 设置回测开始日期 参数 类型 说明 startDate string 回测开始日期 initDays int 策略回测开始前需要准备多少日的数据。默认是10日。举个例子，假设策略是日K线回测，数据库里的数据是日K线，如果策略里需要5日均线，这里此参数设为4。假设策略是1分钟K线回测，数据库里的数据是1分钟K线，如果策略里需要5分钟均线，这里此参数则设为1。因为1日里的1分钟K线数据远远大于4，已经足够满足策略开始的准备数据了。 返回值：None setEndDate 设置回测结束日期 参数 类型 说明 endDate string 回测结束日期。默认是&#39;&#39;。若使用默认参数，则是数据在数据库里的最近日期。 返回值：None setDatabase 设置产品（合约）数据的数据库名及表名，这样回测引擎可以载入对应的数据。 参数 类型 说明 dbName string 数据库名 symbol string 数据库表名 返回值：None setSlippage 设置每一手产品（合约）的滑点，单位是产品（合约）的价格 参数 类型 说明 slippage float 滑点数值 返回值：None setRate 设置佣金比例，交易手续费=成交金额X佣金比例 参数 类型 说明 rate float 佣金比例 返回值：None setSize 设置产品（合约）大小，单位为元。成交金额=合约价格(面值)X合约大小 参数 类型 说明 size float 合约大小 返回值：None setPriceTick 设置产品（合约）的最小价格变动，单位是产品（合约）的价格 参数 类型 说明 priceTick float 最小价格变动 返回值：None 回测相关接口 initStrategy 根据策略参数，实例化回测策略对象。 参数 类型 说明 strategyClass class 策略类 setting dict 策略参数配置，若使用策略的默认参数则为None 返回值：None runBacktesting 运行回测。从数据库里载入数据，逐条推入策略做回测，同时模拟委托和成交，并保存回测过程的中间数据，以此可以计算回测结果并显示。 参数：无 返回值：None calculateBacktestingResult 逐条匹配交易，并计算回测结果。由于回测策略是假设初始资金为0，这样交易后资金可能为负值。这里跟实盘有区别，实盘需要保证金，回测时只考虑每笔交易的盈亏。 参数：无 返回值：dict 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，非正值，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 timeList list 每笔交易的时间序列，时间为交易出场时间 pnlList list 每笔盈亏序列 capitalList list 每笔交易后的资金序列 drawdownList list 每笔交易后的回撤序列 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 showBacktestingResult 计算回测结果，输出回测报告，并显示回测结果图：资金子图，回撤子图，每笔交易盈亏子图 参数：无 返回值：None calculateDailyResult 按照逐日盯市的方式计算每日的交易盈亏和持仓盈亏，并汇总成最终按日统计的盈亏情况。 参数：无 返回值：dict showDailyResult 显示按照逐日盯市方式统计的回测结果和资金曲线，提供Sharpe Ratio的统计结果。 参数：无 返回值：None 优化参数相关接口 runOptimization 运行普通模式的优化参数，也就是说python主进程循环回测每一个参数组合，并输出每个参数组合的优化结果。普通模式下只能使用CPU的一个核。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None runParallelOptimization 运行多进程模式的优化参数，也就是说并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的优化结果。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None 策略相关接口 由于策略既可以跑在回测引擎又可以跑在实盘引擎，所以这部分接口保持跟实盘引擎一致。这部分接口只做功能介绍，不做具体参数的介绍，因为对用户回测策略来讲，这是一个黑盒。根据交易相关和非交易相关，这部分接口可以分为两类： 交易相关接口 sendOrder 模拟限价委托单，并把限价单保存在限价单字典和工作限价单字典中。工作限价单字典里是需要撮合成交的委托。限价单字典里则是所有委托。 cancelOrder 模拟撤销限价委托单，并从工作限价单字典中删除。 sendStopOrder 模拟本地停止单，并把停止单保存在停止单字典和工作停止单字典中。工作停止单字典里是需要撮合成交的委托。停止单字典里则是所有委托。 cancelStopOrder 模拟撤销停止委托单，并从工作停止单字典中删除。 非交易相关接口 insertData 插入数据到数据库，回测时直接pass loadTick 载入初始化列表中的数据，即策略回测开始前的准备数据 loadBar 载入初始化列表中的数据，即策略回测开始前的准备数据 writeCtaLog 记录日志到日志列表 putStrategyEvent 发送策略更新事件，回测中忽略 内部接口 这部分接口为回测引擎自己调用。后面在讲接口使用的时候，会通过流程图做细节介绍。这里先逐一简单做下介绍： output 输出到控制台 newTick 生成新的Tick，完成撮合交易并推送给策略 newBar 生成新的Bar，完成撮合交易并推送给策略 crossLimitOrder 基于最新数据撮合限价单 crossStopOrder 基于最新数据撮合停止单 如何使用回测引擎API 本节结合代码和流程图讲解如何使用回测引擎API。 回测过程流程图 下图为基于策略特定参数的回测过程 回测过程详解 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。历史数据得预先存储在MongoDB中，若没有， 则可执行vnpy/vn.trader/ctaAlgo/ctaHistroyData.py里的代码，把回测数据插入到数据库中， 如下 # 这里将项目中包含的股指日内分钟线csv导入MongoDB，作者电脑耗时大约3分钟 import os loadMcCsv(os.path.join(os.path.dirname(__file__), &#39;IF0000_1min.csv&#39;), MINUTE_DB_NAME, &#39;IF0000&#39;) 如果数据已经在数据库中，则运行下面的代码设置回测引擎的相关参数 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 设置使用的历史数据库 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 这里MINUTE_DB_NAME是 MINUTE_DB_NAME = &#39;VnTrader_1Min_Db&#39; 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 在回测引擎中传入策略参数创建策略对象。这里回测vnpy/vn.trader/ctaAlgo/strategyAtrRsi.py里的AtrRsiStrategy策略，策略参数只设置了&#39;atrLength&#39;为11，其它则用策略默认参数。 # 在引擎中创建策略对象 d = {&#39;atrLength&#39;: 11} engine.initStrategy(AtrRsiStrategy, d) 策略的默认参数如下： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 跑回测 # 开始跑回测 engine.runBacktesting() 显示回测结果 # 显示回测结果 # spyder或者ipython notebook中运行时，会弹出盈亏曲线图 # 直接在cmd中回测则只会打印一些回测数值 engine.showBacktestingResult() 回测过程中主要步骤的流程图 下面是回测过程主要步骤的流程图，这部分实现对用户回测策略来讲是黑盒，可以不关注。 跑回测主要流程图 显示回测结果主要流程图 计算回测结果主要流程图 计算回测结果是采用贪婪算法将成交单按时间顺序逐一做开平仓清算。下图只是给出主要的逻辑步骤，具体细节参考代码，即： def calculateBacktestingResult(self): &quot;&quot;&quot; 计算回测结果 &quot;&quot;&quot; ... 读懂回测报告 在IPython下运行AtrRsiStrategy策略的回测，示例中使用的是VS2013下的IPython环境。示例中的vnpy代码位于F:\vnpy。读者可自行调整为自己机器上的vnpy代码所在目录。 In [2]: import sys ...: sys.path.append(&#39;F:\\vnpy\\vn.trader&#39;) ...: sys.path.append(&#39;F:\\vnpy\\vn.trader\ctaAlgo&#39;) ...: from __future__ import division ...: from datetime import datetime, timedelta ...: from collections import OrderedDict ...: from itertools import product ...: import multiprocessing ...: import pymongo ...: from ctaBase import * ...: from ctaSetting import * ...: from vtConstant import * ...: from vtGateway import VtOrderData, VtTradeData ...: from vtFunction import loadMongoSetting ...: from ctaBacktesting import * ...: from strategyAtrRsi import * ...: In [3]: # 创建回测引擎 ...: engine = BacktestingEngine() ...: In [4]: # 设置引擎的回测模式为K线 ...: engine.setBacktestingMode(engine.BAR_MODE) ...: ...: # 设置回测用的数据起始日期和结束日期 ...: engine.setStartDate(&#39;20110101&#39;) ...: engine.setEndDate(&#39;20161231&#39;) ...: ...: # 设置使用的历史数据库 ...: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ...: In [5]: # 设置产品相关参数 ...: engine.setSlippage(0.2) # 股指1跳 ...: engine.setRate(0.3/10000) # 万0.3 ...: engine.setSize(300) # 股指合约大小 ...: In [6]: # 在引擎中创建策略对象 ...: d = {&#39;atrLength&#39;: 11} ...: engine.initStrategy(AtrRsiStrategy, d) ...: In [7]: # 开始跑回测 ...: engine.runBacktesting() ...: 2017-02-08 19:01:03.243000 开始载入数据 2017-02-08 19:01:03.383000 载入完成，数据量：341851 2017-02-08 19:01:03.383000 开始回测 2017-02-08 19:01:03.396000 策略初始化完成 2017-02-08 19:01:03.396000 策略启动完成 2017-02-08 19:01:03.396000 开始回放数据 2017-02-08 19:01:17.451000 数据回放结束 In [8]: # 显示回测结果 ...: engine.showBacktestingResult() ...: 2017-02-08 19:01:24.706000 计算回测结果 2017-02-08 19:01:24.790000 ------------------------------ 2017-02-08 19:01:24.790000 第一笔交易： 2011-01-11 13:19:00 2017-02-08 19:01:24.790000 最后一笔交易： 2016-04-01 13:17:00 2017-02-08 19:01:24.790000 总交易次数： 3,965.0 2017-02-08 19:01:24.790000 总盈亏： 695,298.02 2017-02-08 19:01:24.791000 最大回撤: -197,106.11 2017-02-08 19:01:24.791000 平均每笔盈利： 175.36 2017-02-08 19:01:24.791000 平均每笔滑点： 120.0 2017-02-08 19:01:24.791000 平均每笔佣金： 57.01 2017-02-08 19:01:24.791000 胜率 36.39% 2017-02-08 19:01:24.791000 盈利交易平均值 8,721.64 2017-02-08 19:01:24.791000 亏损交易平均值 -4,714.52 2017-02-08 19:01:24.791000 盈亏比： 1.85 回测报告说明 首先先解释一下回测报告里的交易是什么意思： 以股指IF为例，3000点时开1手多单，3010点平仓，这1手开平仓即为一笔交易。若3000点时开2手多单，3010点平1手，这1手开平仓即为一笔交易；接下来3020点再平1手，这1手开平仓为另一笔交易。 交易时间为平仓时间 计算回测结果字段说明 字段 说明 第一笔交易 第一笔交易的平仓时间 最后一笔交易 最后一笔交易的平仓时间 总交易次数 整个回测的总交易次数 总盈亏 整个回测的总盈亏，由于回测时初始资金为0，总盈亏其实就是当前资金 最大回撤 每次交易后的回撤 = 每笔交易后的资金 - 回测中最大资金。由于回撤为非正值，所以最大回撤为所有交易后的回撤绝对值最大的 平均每笔盈利 总盈亏/总交易次数 平均每笔滑点 总滑点成本/总交易次数 平均每笔佣金 总佣金成本/总交易次数 胜率 盈利交易次数/总交易次数*100(%) 盈利交易平均值 总盈利交易的盈利/总盈利交易次数 亏损交易平均值 总亏损交易的盈利/总亏损交易次数 盈亏比 盈利交易平均值/亏损交易平均值 计算回测结果图说明 图里的X轴没有采用交易时间刻度，而是将每笔交易按时间顺序从0开始标成0,1,2,3,4,... 子图名 说明 capital 每笔交易后的资金序列图 DD dropdown，每笔交易后的回撤序列图 pnl profit&amp;loss，每笔交易的盈亏直方图（概率分布图） 优化策略参数 策略的参数优化是对指定的优化目标（比如胜率，总盈亏，盈亏比等），回测每个参数的网格组合，从而找到使优化目标最优的参数组合。比如AtrRsiStrategy策略，有七个参数： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 这里面&#39;initDays&#39;可以忽略。如果&#39;atrLength&#39;的取值范围是12-20，步长2；&#39;atrMa&#39;的取值范围是20-30，步长5。这样对于&#39;atrLength&#39;有5个取值[12,14,16,18,20]，对于&#39;atrMaLength&#39;有3个取值[20,25,30]，总共有5X3, 15个参数组合需要回测。如果设置更多的参数和更小的步长，由于参数的组合数量是幂次方，可想而知需要回测的参数组合的数量相当大，这样就要耗费大量的时间。 优化参数有两种模式： 普通模式 Python主进程循环回测每一个参数组合，并输出每个参数组合的运行结果。由于GIL，普通模式下只能使用CPU的一个核。 多进程模式 并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的运行结果。 本节主要讲解普通模式的参数优化。下图为普通模式的参数优化流程图： 下表为支持的优化目标键值: 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 参数优化主流程详解 用户只需关注参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解： 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行单进程优化 ## 运行单进程优化函数，自动输出结果 engine.runOptimization(AtrRsiStrategy, setting) 示例在IPython下的运行结果 浮点数由于精度问题，可能会出现误差。由于参数组合是无序字典，所以可能参数组合的回测顺序跟笔者的不一样。笔者电脑上，单进程优化耗时约3分40秒。 In [12]: import sys ....: sys.path.append(&#39;F:\\vnpy\\vn.trader&#39;) ....: sys.path.append(&#39;F:\\vnpy\\vn.trader\ctaAlgo&#39;) ....: from __future__ import division ....: from datetime import datetime, timedelta ....: from collections import OrderedDict ....: from itertools import product ....: import multiprocessing ....: import pymongo ....: from ctaBase import * ....: from ctaSetting import * ....: from vtConstant import * ....: from vtGateway import VtOrderData, VtTradeData ....: from vtFunction import loadMongoSetting ....: from ctaBacktesting import * ....: from strategyAtrRsi import * ....: In [13]: # 创建回测引擎 ....: engine = BacktestingEngine() ....: In [14]: # 设置引擎的回测模式为K线 ....: engine.setBacktestingMode(engine.BAR_MODE) ....: ....: # 设置回测用的数据起始日期和结束日期 ....: engine.setStartDate(&#39;20110101&#39;) ....: engine.setEndDate(&#39;20161231&#39;) ....: ....: # 载入历史数据到引擎中 ....: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ....: In [15]: # 设置产品相关参数 ....: engine.setSlippage(0.2) # 股指1跳 ....: engine.setRate(0.3/10000) # 万0.3 ....: engine.setSize(300) # 股指合约大小 ....: In [16]: # 创建优化参数设置实例 ....: setting = OptimizationSetting() # 新建一个优化任务设置对象 ....: In [17]: setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 ....: setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 ....: setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 ....: setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 ....: In [18]: ## 运行单进程优化函数，自动输出结果 ....: engine.runOptimization(AtrRsiStrategy, setting) ....: 2017-02-08 19:06:19.279000 ------------------------------ 2017-02-08 19:06:19.280000 setting: {&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:19.282000 开始载入数据 2017-02-08 19:06:21.034000 载入完成，数据量：341851 2017-02-08 19:06:21.034000 开始回测 2017-02-08 19:06:21.050000 策略初始化完成 2017-02-08 19:06:21.050000 策略启动完成 2017-02-08 19:06:21.050000 开始回放数据 2017-02-08 19:06:35.728000 数据回放结束 2017-02-08 19:06:35.728000 计算回测结果 2017-02-08 19:06:35.923000 ------------------------------ 2017-02-08 19:06:35.924000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:35.925000 开始载入数据 2017-02-08 19:06:36.015000 载入完成，数据量：341851 2017-02-08 19:06:36.015000 开始回测 2017-02-08 19:06:36.030000 策略初始化完成 2017-02-08 19:06:36.030000 策略启动完成 2017-02-08 19:06:36.030000 开始回放数据 2017-02-08 19:06:50.140000 数据回放结束 2017-02-08 19:06:50.140000 计算回测结果 ... 2017-02-08 19:09:30.237000 ------------------------------ 2017-02-08 19:09:30.237000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:30.239000 开始载入数据 2017-02-08 19:09:30.330000 载入完成，数据量：341851 2017-02-08 19:09:30.330000 开始回测 2017-02-08 19:09:30.343000 策略初始化完成 2017-02-08 19:09:30.343000 策略启动完成 2017-02-08 19:09:30.343000 开始回放数据 2017-02-08 19:09:44.499000 数据回放结束 2017-02-08 19:09:44.499000 计算回测结果 2017-02-08 19:09:44.696000 ------------------------------ 2017-02-08 19:09:44.696000 setting: {&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:44.697000 开始载入数据 2017-02-08 19:09:44.787000 载入完成，数据量：341851 2017-02-08 19:09:44.787000 开始回测 2017-02-08 19:09:44.801000 策略初始化完成 2017-02-08 19:09:44.801000 策略启动完成 2017-02-08 19:09:44.801000 开始回放数据 2017-02-08 19:09:58.942000 数据回放结束 2017-02-08 19:09:58.942000 计算回测结果 2017-02-08 19:09:59.242000 ------------------------------ 2017-02-08 19:09:59.242000 优化结果： 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 1127713.85011 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 1030743.75807 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 983294.726285 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 975329.10312 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 949746.520421 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 914875.145592 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 899113.140024 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 896378.557181 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 893726.622984 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 883947.771514 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 873221.532605 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 857260.355525 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 852615.557093 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 790618.233326 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 726949.447939 优化结果的输出格式是：参数组合：优化目标值 多进程优化 本节主要讲解参数的优化的多进程模式。由于Python的GIL原因，多进程模式可以更好的利用CPU的多核，提高优化参数速度。由于vnpy已经提供RPC模块，所以可以基于RPC模块实现分布式参数优化。 多进程参数优化主流程图和优化函数流程图&nbsp; 多进程参数优化主流程详解 用户只需关注多进程参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解。跟普通模式的参数优化的区别是最后调用多进程优化接口。笔者电脑上，示例中AtrRsiStrategy策略多进程回测的耗时约为52秒。 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行多进程优化 ## 运行多进程优化函数，自动输出结果 engine.runParallelOptimization(AtrRsiStrategy, setting) 阅读更多" />
<meta property="og:description" content="作者：魔元 目录 使用回测引擎 读懂回测报告 优化策略参数 多进程优化 量化策略主要是从历史数据统计或者发现规律然后应用于实盘交易。当然历史不是简单的重复，这就要求策略需要根据市场调整和优化参数。通过回测历史数据可以验证策略的有效性，了解策略的历史收益、最大回撤和回撤时长，对策略参数进行优化等等。CTA策略模块的主要回测目标是验证交易信号是否正确，仓位大小的问题在实盘中则由交易员来确定。 使用回测引擎 vnpy的回测引擎位于vnpy/trader/app/ctaStrategy/ctaBacktesting.py，此文件中主要包含以下几个类： BacktestingEngine 回测引擎类，主要功能是设置回测参数，初始化策略对象，运行回测并输出结果。类接口和实盘引擎类(CtaEngine)保持一致，从而实现同一套策略代码从回测到实盘。用户主要是调用本类的接口来回测策略。 TradingResult 撮合好的交易结果类，由回测引擎计算回测结果时使用。类成员包含开仓价格，平仓价格，交易数量，成交金额，滑点成本，手续费成本及净盈亏等。 这里面有一点注意是交易数量的正负代表开仓方向。以股指IF为例，3000点时开1手多单，3010点平仓，这时就会生成一个TradingResult实例，交易数量为1。若3000点时开1手空单，3010点平仓，这时生成的TradingResult实例的交易数量为-1。 代码如下： ```Python self.entryPrice = entryPrice # 开仓价格 self.exitPrice = exitPrice # 平仓价格 self.entryDt = entryDt # 开仓时间datetime self.exitDt = exitDt # 平仓时间 self.volume = volume # 交易数量（+/-代表方向） self.turnover = (self.entryPrice+self.exitPrice)*size*abs(volume) # 成交金额 self.commission = self.turnover*rate # 手续费成本 self.slippage = slippage*2*size*abs(volume) # 滑点成本 self.pnl = ((self.exitPrice - self.entryPrice) * volume * size - self.commission - self.slippage) # 净盈亏 ``` OptimizationSetting 参数优化设置类，主要是生成优化参数组合。每个参数组合都由回测引擎执行一遍，以得到不同参数组合的回测结果。优化参数回测时会使用此类。 回测引擎API介绍 由于用户主要是调用本类的接口来回测策略，所以将对本类的接口做逐一介绍。一方面回测引擎类的接口跟实盘策略引擎保持一样，这方面的接口主要是被策略调用； 另一方面回测引擎类也要提供回测相关的接口，所以将回测引擎类的接口从功能性分成这几个方面介绍： 用户回测策略接口 配置相关接口 setBacktestingMode 设置回测模式，支持两种模式，一种是Tick模式，另一种是K线模式 参数 类型 说明 mode string 回测模式，支持两种模式：BacktestingEngine.TICK_MODE和BacktestingEngine.BAR_MODE 返回值：None setStartDate 设置回测开始日期 参数 类型 说明 startDate string 回测开始日期 initDays int 策略回测开始前需要准备多少日的数据。默认是10日。举个例子，假设策略是日K线回测，数据库里的数据是日K线，如果策略里需要5日均线，这里此参数设为4。假设策略是1分钟K线回测，数据库里的数据是1分钟K线，如果策略里需要5分钟均线，这里此参数则设为1。因为1日里的1分钟K线数据远远大于4，已经足够满足策略开始的准备数据了。 返回值：None setEndDate 设置回测结束日期 参数 类型 说明 endDate string 回测结束日期。默认是&#39;&#39;。若使用默认参数，则是数据在数据库里的最近日期。 返回值：None setDatabase 设置产品（合约）数据的数据库名及表名，这样回测引擎可以载入对应的数据。 参数 类型 说明 dbName string 数据库名 symbol string 数据库表名 返回值：None setSlippage 设置每一手产品（合约）的滑点，单位是产品（合约）的价格 参数 类型 说明 slippage float 滑点数值 返回值：None setRate 设置佣金比例，交易手续费=成交金额X佣金比例 参数 类型 说明 rate float 佣金比例 返回值：None setSize 设置产品（合约）大小，单位为元。成交金额=合约价格(面值)X合约大小 参数 类型 说明 size float 合约大小 返回值：None setPriceTick 设置产品（合约）的最小价格变动，单位是产品（合约）的价格 参数 类型 说明 priceTick float 最小价格变动 返回值：None 回测相关接口 initStrategy 根据策略参数，实例化回测策略对象。 参数 类型 说明 strategyClass class 策略类 setting dict 策略参数配置，若使用策略的默认参数则为None 返回值：None runBacktesting 运行回测。从数据库里载入数据，逐条推入策略做回测，同时模拟委托和成交，并保存回测过程的中间数据，以此可以计算回测结果并显示。 参数：无 返回值：None calculateBacktestingResult 逐条匹配交易，并计算回测结果。由于回测策略是假设初始资金为0，这样交易后资金可能为负值。这里跟实盘有区别，实盘需要保证金，回测时只考虑每笔交易的盈亏。 参数：无 返回值：dict 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，非正值，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 timeList list 每笔交易的时间序列，时间为交易出场时间 pnlList list 每笔盈亏序列 capitalList list 每笔交易后的资金序列 drawdownList list 每笔交易后的回撤序列 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 showBacktestingResult 计算回测结果，输出回测报告，并显示回测结果图：资金子图，回撤子图，每笔交易盈亏子图 参数：无 返回值：None calculateDailyResult 按照逐日盯市的方式计算每日的交易盈亏和持仓盈亏，并汇总成最终按日统计的盈亏情况。 参数：无 返回值：dict showDailyResult 显示按照逐日盯市方式统计的回测结果和资金曲线，提供Sharpe Ratio的统计结果。 参数：无 返回值：None 优化参数相关接口 runOptimization 运行普通模式的优化参数，也就是说python主进程循环回测每一个参数组合，并输出每个参数组合的优化结果。普通模式下只能使用CPU的一个核。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None runParallelOptimization 运行多进程模式的优化参数，也就是说并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的优化结果。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None 策略相关接口 由于策略既可以跑在回测引擎又可以跑在实盘引擎，所以这部分接口保持跟实盘引擎一致。这部分接口只做功能介绍，不做具体参数的介绍，因为对用户回测策略来讲，这是一个黑盒。根据交易相关和非交易相关，这部分接口可以分为两类： 交易相关接口 sendOrder 模拟限价委托单，并把限价单保存在限价单字典和工作限价单字典中。工作限价单字典里是需要撮合成交的委托。限价单字典里则是所有委托。 cancelOrder 模拟撤销限价委托单，并从工作限价单字典中删除。 sendStopOrder 模拟本地停止单，并把停止单保存在停止单字典和工作停止单字典中。工作停止单字典里是需要撮合成交的委托。停止单字典里则是所有委托。 cancelStopOrder 模拟撤销停止委托单，并从工作停止单字典中删除。 非交易相关接口 insertData 插入数据到数据库，回测时直接pass loadTick 载入初始化列表中的数据，即策略回测开始前的准备数据 loadBar 载入初始化列表中的数据，即策略回测开始前的准备数据 writeCtaLog 记录日志到日志列表 putStrategyEvent 发送策略更新事件，回测中忽略 内部接口 这部分接口为回测引擎自己调用。后面在讲接口使用的时候，会通过流程图做细节介绍。这里先逐一简单做下介绍： output 输出到控制台 newTick 生成新的Tick，完成撮合交易并推送给策略 newBar 生成新的Bar，完成撮合交易并推送给策略 crossLimitOrder 基于最新数据撮合限价单 crossStopOrder 基于最新数据撮合停止单 如何使用回测引擎API 本节结合代码和流程图讲解如何使用回测引擎API。 回测过程流程图 下图为基于策略特定参数的回测过程 回测过程详解 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。历史数据得预先存储在MongoDB中，若没有， 则可执行vnpy/vn.trader/ctaAlgo/ctaHistroyData.py里的代码，把回测数据插入到数据库中， 如下 # 这里将项目中包含的股指日内分钟线csv导入MongoDB，作者电脑耗时大约3分钟 import os loadMcCsv(os.path.join(os.path.dirname(__file__), &#39;IF0000_1min.csv&#39;), MINUTE_DB_NAME, &#39;IF0000&#39;) 如果数据已经在数据库中，则运行下面的代码设置回测引擎的相关参数 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 设置使用的历史数据库 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 这里MINUTE_DB_NAME是 MINUTE_DB_NAME = &#39;VnTrader_1Min_Db&#39; 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 在回测引擎中传入策略参数创建策略对象。这里回测vnpy/vn.trader/ctaAlgo/strategyAtrRsi.py里的AtrRsiStrategy策略，策略参数只设置了&#39;atrLength&#39;为11，其它则用策略默认参数。 # 在引擎中创建策略对象 d = {&#39;atrLength&#39;: 11} engine.initStrategy(AtrRsiStrategy, d) 策略的默认参数如下： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 跑回测 # 开始跑回测 engine.runBacktesting() 显示回测结果 # 显示回测结果 # spyder或者ipython notebook中运行时，会弹出盈亏曲线图 # 直接在cmd中回测则只会打印一些回测数值 engine.showBacktestingResult() 回测过程中主要步骤的流程图 下面是回测过程主要步骤的流程图，这部分实现对用户回测策略来讲是黑盒，可以不关注。 跑回测主要流程图 显示回测结果主要流程图 计算回测结果主要流程图 计算回测结果是采用贪婪算法将成交单按时间顺序逐一做开平仓清算。下图只是给出主要的逻辑步骤，具体细节参考代码，即： def calculateBacktestingResult(self): &quot;&quot;&quot; 计算回测结果 &quot;&quot;&quot; ... 读懂回测报告 在IPython下运行AtrRsiStrategy策略的回测，示例中使用的是VS2013下的IPython环境。示例中的vnpy代码位于F:\vnpy。读者可自行调整为自己机器上的vnpy代码所在目录。 In [2]: import sys ...: sys.path.append(&#39;F:\\vnpy\\vn.trader&#39;) ...: sys.path.append(&#39;F:\\vnpy\\vn.trader\ctaAlgo&#39;) ...: from __future__ import division ...: from datetime import datetime, timedelta ...: from collections import OrderedDict ...: from itertools import product ...: import multiprocessing ...: import pymongo ...: from ctaBase import * ...: from ctaSetting import * ...: from vtConstant import * ...: from vtGateway import VtOrderData, VtTradeData ...: from vtFunction import loadMongoSetting ...: from ctaBacktesting import * ...: from strategyAtrRsi import * ...: In [3]: # 创建回测引擎 ...: engine = BacktestingEngine() ...: In [4]: # 设置引擎的回测模式为K线 ...: engine.setBacktestingMode(engine.BAR_MODE) ...: ...: # 设置回测用的数据起始日期和结束日期 ...: engine.setStartDate(&#39;20110101&#39;) ...: engine.setEndDate(&#39;20161231&#39;) ...: ...: # 设置使用的历史数据库 ...: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ...: In [5]: # 设置产品相关参数 ...: engine.setSlippage(0.2) # 股指1跳 ...: engine.setRate(0.3/10000) # 万0.3 ...: engine.setSize(300) # 股指合约大小 ...: In [6]: # 在引擎中创建策略对象 ...: d = {&#39;atrLength&#39;: 11} ...: engine.initStrategy(AtrRsiStrategy, d) ...: In [7]: # 开始跑回测 ...: engine.runBacktesting() ...: 2017-02-08 19:01:03.243000 开始载入数据 2017-02-08 19:01:03.383000 载入完成，数据量：341851 2017-02-08 19:01:03.383000 开始回测 2017-02-08 19:01:03.396000 策略初始化完成 2017-02-08 19:01:03.396000 策略启动完成 2017-02-08 19:01:03.396000 开始回放数据 2017-02-08 19:01:17.451000 数据回放结束 In [8]: # 显示回测结果 ...: engine.showBacktestingResult() ...: 2017-02-08 19:01:24.706000 计算回测结果 2017-02-08 19:01:24.790000 ------------------------------ 2017-02-08 19:01:24.790000 第一笔交易： 2011-01-11 13:19:00 2017-02-08 19:01:24.790000 最后一笔交易： 2016-04-01 13:17:00 2017-02-08 19:01:24.790000 总交易次数： 3,965.0 2017-02-08 19:01:24.790000 总盈亏： 695,298.02 2017-02-08 19:01:24.791000 最大回撤: -197,106.11 2017-02-08 19:01:24.791000 平均每笔盈利： 175.36 2017-02-08 19:01:24.791000 平均每笔滑点： 120.0 2017-02-08 19:01:24.791000 平均每笔佣金： 57.01 2017-02-08 19:01:24.791000 胜率 36.39% 2017-02-08 19:01:24.791000 盈利交易平均值 8,721.64 2017-02-08 19:01:24.791000 亏损交易平均值 -4,714.52 2017-02-08 19:01:24.791000 盈亏比： 1.85 回测报告说明 首先先解释一下回测报告里的交易是什么意思： 以股指IF为例，3000点时开1手多单，3010点平仓，这1手开平仓即为一笔交易。若3000点时开2手多单，3010点平1手，这1手开平仓即为一笔交易；接下来3020点再平1手，这1手开平仓为另一笔交易。 交易时间为平仓时间 计算回测结果字段说明 字段 说明 第一笔交易 第一笔交易的平仓时间 最后一笔交易 最后一笔交易的平仓时间 总交易次数 整个回测的总交易次数 总盈亏 整个回测的总盈亏，由于回测时初始资金为0，总盈亏其实就是当前资金 最大回撤 每次交易后的回撤 = 每笔交易后的资金 - 回测中最大资金。由于回撤为非正值，所以最大回撤为所有交易后的回撤绝对值最大的 平均每笔盈利 总盈亏/总交易次数 平均每笔滑点 总滑点成本/总交易次数 平均每笔佣金 总佣金成本/总交易次数 胜率 盈利交易次数/总交易次数*100(%) 盈利交易平均值 总盈利交易的盈利/总盈利交易次数 亏损交易平均值 总亏损交易的盈利/总亏损交易次数 盈亏比 盈利交易平均值/亏损交易平均值 计算回测结果图说明 图里的X轴没有采用交易时间刻度，而是将每笔交易按时间顺序从0开始标成0,1,2,3,4,... 子图名 说明 capital 每笔交易后的资金序列图 DD dropdown，每笔交易后的回撤序列图 pnl profit&amp;loss，每笔交易的盈亏直方图（概率分布图） 优化策略参数 策略的参数优化是对指定的优化目标（比如胜率，总盈亏，盈亏比等），回测每个参数的网格组合，从而找到使优化目标最优的参数组合。比如AtrRsiStrategy策略，有七个参数： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 这里面&#39;initDays&#39;可以忽略。如果&#39;atrLength&#39;的取值范围是12-20，步长2；&#39;atrMa&#39;的取值范围是20-30，步长5。这样对于&#39;atrLength&#39;有5个取值[12,14,16,18,20]，对于&#39;atrMaLength&#39;有3个取值[20,25,30]，总共有5X3, 15个参数组合需要回测。如果设置更多的参数和更小的步长，由于参数的组合数量是幂次方，可想而知需要回测的参数组合的数量相当大，这样就要耗费大量的时间。 优化参数有两种模式： 普通模式 Python主进程循环回测每一个参数组合，并输出每个参数组合的运行结果。由于GIL，普通模式下只能使用CPU的一个核。 多进程模式 并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的运行结果。 本节主要讲解普通模式的参数优化。下图为普通模式的参数优化流程图： 下表为支持的优化目标键值: 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 参数优化主流程详解 用户只需关注参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解： 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行单进程优化 ## 运行单进程优化函数，自动输出结果 engine.runOptimization(AtrRsiStrategy, setting) 示例在IPython下的运行结果 浮点数由于精度问题，可能会出现误差。由于参数组合是无序字典，所以可能参数组合的回测顺序跟笔者的不一样。笔者电脑上，单进程优化耗时约3分40秒。 In [12]: import sys ....: sys.path.append(&#39;F:\\vnpy\\vn.trader&#39;) ....: sys.path.append(&#39;F:\\vnpy\\vn.trader\ctaAlgo&#39;) ....: from __future__ import division ....: from datetime import datetime, timedelta ....: from collections import OrderedDict ....: from itertools import product ....: import multiprocessing ....: import pymongo ....: from ctaBase import * ....: from ctaSetting import * ....: from vtConstant import * ....: from vtGateway import VtOrderData, VtTradeData ....: from vtFunction import loadMongoSetting ....: from ctaBacktesting import * ....: from strategyAtrRsi import * ....: In [13]: # 创建回测引擎 ....: engine = BacktestingEngine() ....: In [14]: # 设置引擎的回测模式为K线 ....: engine.setBacktestingMode(engine.BAR_MODE) ....: ....: # 设置回测用的数据起始日期和结束日期 ....: engine.setStartDate(&#39;20110101&#39;) ....: engine.setEndDate(&#39;20161231&#39;) ....: ....: # 载入历史数据到引擎中 ....: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ....: In [15]: # 设置产品相关参数 ....: engine.setSlippage(0.2) # 股指1跳 ....: engine.setRate(0.3/10000) # 万0.3 ....: engine.setSize(300) # 股指合约大小 ....: In [16]: # 创建优化参数设置实例 ....: setting = OptimizationSetting() # 新建一个优化任务设置对象 ....: In [17]: setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 ....: setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 ....: setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 ....: setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 ....: In [18]: ## 运行单进程优化函数，自动输出结果 ....: engine.runOptimization(AtrRsiStrategy, setting) ....: 2017-02-08 19:06:19.279000 ------------------------------ 2017-02-08 19:06:19.280000 setting: {&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:19.282000 开始载入数据 2017-02-08 19:06:21.034000 载入完成，数据量：341851 2017-02-08 19:06:21.034000 开始回测 2017-02-08 19:06:21.050000 策略初始化完成 2017-02-08 19:06:21.050000 策略启动完成 2017-02-08 19:06:21.050000 开始回放数据 2017-02-08 19:06:35.728000 数据回放结束 2017-02-08 19:06:35.728000 计算回测结果 2017-02-08 19:06:35.923000 ------------------------------ 2017-02-08 19:06:35.924000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:35.925000 开始载入数据 2017-02-08 19:06:36.015000 载入完成，数据量：341851 2017-02-08 19:06:36.015000 开始回测 2017-02-08 19:06:36.030000 策略初始化完成 2017-02-08 19:06:36.030000 策略启动完成 2017-02-08 19:06:36.030000 开始回放数据 2017-02-08 19:06:50.140000 数据回放结束 2017-02-08 19:06:50.140000 计算回测结果 ... 2017-02-08 19:09:30.237000 ------------------------------ 2017-02-08 19:09:30.237000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:30.239000 开始载入数据 2017-02-08 19:09:30.330000 载入完成，数据量：341851 2017-02-08 19:09:30.330000 开始回测 2017-02-08 19:09:30.343000 策略初始化完成 2017-02-08 19:09:30.343000 策略启动完成 2017-02-08 19:09:30.343000 开始回放数据 2017-02-08 19:09:44.499000 数据回放结束 2017-02-08 19:09:44.499000 计算回测结果 2017-02-08 19:09:44.696000 ------------------------------ 2017-02-08 19:09:44.696000 setting: {&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:44.697000 开始载入数据 2017-02-08 19:09:44.787000 载入完成，数据量：341851 2017-02-08 19:09:44.787000 开始回测 2017-02-08 19:09:44.801000 策略初始化完成 2017-02-08 19:09:44.801000 策略启动完成 2017-02-08 19:09:44.801000 开始回放数据 2017-02-08 19:09:58.942000 数据回放结束 2017-02-08 19:09:58.942000 计算回测结果 2017-02-08 19:09:59.242000 ------------------------------ 2017-02-08 19:09:59.242000 优化结果： 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 1127713.85011 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 1030743.75807 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 983294.726285 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 975329.10312 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 949746.520421 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 914875.145592 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 899113.140024 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 896378.557181 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 893726.622984 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 883947.771514 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 873221.532605 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 857260.355525 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 852615.557093 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 790618.233326 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 726949.447939 优化结果的输出格式是：参数组合：优化目标值 多进程优化 本节主要讲解参数的优化的多进程模式。由于Python的GIL原因，多进程模式可以更好的利用CPU的多核，提高优化参数速度。由于vnpy已经提供RPC模块，所以可以基于RPC模块实现分布式参数优化。 多进程参数优化主流程图和优化函数流程图&nbsp; 多进程参数优化主流程详解 用户只需关注多进程参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解。跟普通模式的参数优化的区别是最后调用多进程优化接口。笔者电脑上，示例中AtrRsiStrategy策略多进程回测的耗时约为52秒。 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行多进程优化 ## 运行多进程优化函数，自动输出结果 engine.runParallelOptimization(AtrRsiStrategy, setting) 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者：魔元 目录 使用回测引擎 读懂回测报告 优化策略参数 多进程优化 量化策略主要是从历史数据统计或者发现规律然后应用于实盘交易。当然历史不是简单的重复，这就要求策略需要根据市场调整和优化参数。通过回测历史数据可以验证策略的有效性，了解策略的历史收益、最大回撤和回撤时长，对策略参数进行优化等等。CTA策略模块的主要回测目标是验证交易信号是否正确，仓位大小的问题在实盘中则由交易员来确定。 使用回测引擎 vnpy的回测引擎位于vnpy/trader/app/ctaStrategy/ctaBacktesting.py，此文件中主要包含以下几个类： BacktestingEngine 回测引擎类，主要功能是设置回测参数，初始化策略对象，运行回测并输出结果。类接口和实盘引擎类(CtaEngine)保持一致，从而实现同一套策略代码从回测到实盘。用户主要是调用本类的接口来回测策略。 TradingResult 撮合好的交易结果类，由回测引擎计算回测结果时使用。类成员包含开仓价格，平仓价格，交易数量，成交金额，滑点成本，手续费成本及净盈亏等。 这里面有一点注意是交易数量的正负代表开仓方向。以股指IF为例，3000点时开1手多单，3010点平仓，这时就会生成一个TradingResult实例，交易数量为1。若3000点时开1手空单，3010点平仓，这时生成的TradingResult实例的交易数量为-1。 代码如下： ```Python self.entryPrice = entryPrice # 开仓价格 self.exitPrice = exitPrice # 平仓价格 self.entryDt = entryDt # 开仓时间datetime self.exitDt = exitDt # 平仓时间 self.volume = volume # 交易数量（+/-代表方向） self.turnover = (self.entryPrice+self.exitPrice)*size*abs(volume) # 成交金额 self.commission = self.turnover*rate # 手续费成本 self.slippage = slippage*2*size*abs(volume) # 滑点成本 self.pnl = ((self.exitPrice - self.entryPrice) * volume * size - self.commission - self.slippage) # 净盈亏 ``` OptimizationSetting 参数优化设置类，主要是生成优化参数组合。每个参数组合都由回测引擎执行一遍，以得到不同参数组合的回测结果。优化参数回测时会使用此类。 回测引擎API介绍 由于用户主要是调用本类的接口来回测策略，所以将对本类的接口做逐一介绍。一方面回测引擎类的接口跟实盘策略引擎保持一样，这方面的接口主要是被策略调用； 另一方面回测引擎类也要提供回测相关的接口，所以将回测引擎类的接口从功能性分成这几个方面介绍： 用户回测策略接口 配置相关接口 setBacktestingMode 设置回测模式，支持两种模式，一种是Tick模式，另一种是K线模式 参数 类型 说明 mode string 回测模式，支持两种模式：BacktestingEngine.TICK_MODE和BacktestingEngine.BAR_MODE 返回值：None setStartDate 设置回测开始日期 参数 类型 说明 startDate string 回测开始日期 initDays int 策略回测开始前需要准备多少日的数据。默认是10日。举个例子，假设策略是日K线回测，数据库里的数据是日K线，如果策略里需要5日均线，这里此参数设为4。假设策略是1分钟K线回测，数据库里的数据是1分钟K线，如果策略里需要5分钟均线，这里此参数则设为1。因为1日里的1分钟K线数据远远大于4，已经足够满足策略开始的准备数据了。 返回值：None setEndDate 设置回测结束日期 参数 类型 说明 endDate string 回测结束日期。默认是&#39;&#39;。若使用默认参数，则是数据在数据库里的最近日期。 返回值：None setDatabase 设置产品（合约）数据的数据库名及表名，这样回测引擎可以载入对应的数据。 参数 类型 说明 dbName string 数据库名 symbol string 数据库表名 返回值：None setSlippage 设置每一手产品（合约）的滑点，单位是产品（合约）的价格 参数 类型 说明 slippage float 滑点数值 返回值：None setRate 设置佣金比例，交易手续费=成交金额X佣金比例 参数 类型 说明 rate float 佣金比例 返回值：None setSize 设置产品（合约）大小，单位为元。成交金额=合约价格(面值)X合约大小 参数 类型 说明 size float 合约大小 返回值：None setPriceTick 设置产品（合约）的最小价格变动，单位是产品（合约）的价格 参数 类型 说明 priceTick float 最小价格变动 返回值：None 回测相关接口 initStrategy 根据策略参数，实例化回测策略对象。 参数 类型 说明 strategyClass class 策略类 setting dict 策略参数配置，若使用策略的默认参数则为None 返回值：None runBacktesting 运行回测。从数据库里载入数据，逐条推入策略做回测，同时模拟委托和成交，并保存回测过程的中间数据，以此可以计算回测结果并显示。 参数：无 返回值：None calculateBacktestingResult 逐条匹配交易，并计算回测结果。由于回测策略是假设初始资金为0，这样交易后资金可能为负值。这里跟实盘有区别，实盘需要保证金，回测时只考虑每笔交易的盈亏。 参数：无 返回值：dict 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，非正值，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 timeList list 每笔交易的时间序列，时间为交易出场时间 pnlList list 每笔盈亏序列 capitalList list 每笔交易后的资金序列 drawdownList list 每笔交易后的回撤序列 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 showBacktestingResult 计算回测结果，输出回测报告，并显示回测结果图：资金子图，回撤子图，每笔交易盈亏子图 参数：无 返回值：None calculateDailyResult 按照逐日盯市的方式计算每日的交易盈亏和持仓盈亏，并汇总成最终按日统计的盈亏情况。 参数：无 返回值：dict showDailyResult 显示按照逐日盯市方式统计的回测结果和资金曲线，提供Sharpe Ratio的统计结果。 参数：无 返回值：None 优化参数相关接口 runOptimization 运行普通模式的优化参数，也就是说python主进程循环回测每一个参数组合，并输出每个参数组合的优化结果。普通模式下只能使用CPU的一个核。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None runParallelOptimization 运行多进程模式的优化参数，也就是说并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的优化结果。 参数 类型 说明 strategyClass class 策略类 optimizationSetting class OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标 返回值：None 策略相关接口 由于策略既可以跑在回测引擎又可以跑在实盘引擎，所以这部分接口保持跟实盘引擎一致。这部分接口只做功能介绍，不做具体参数的介绍，因为对用户回测策略来讲，这是一个黑盒。根据交易相关和非交易相关，这部分接口可以分为两类： 交易相关接口 sendOrder 模拟限价委托单，并把限价单保存在限价单字典和工作限价单字典中。工作限价单字典里是需要撮合成交的委托。限价单字典里则是所有委托。 cancelOrder 模拟撤销限价委托单，并从工作限价单字典中删除。 sendStopOrder 模拟本地停止单，并把停止单保存在停止单字典和工作停止单字典中。工作停止单字典里是需要撮合成交的委托。停止单字典里则是所有委托。 cancelStopOrder 模拟撤销停止委托单，并从工作停止单字典中删除。 非交易相关接口 insertData 插入数据到数据库，回测时直接pass loadTick 载入初始化列表中的数据，即策略回测开始前的准备数据 loadBar 载入初始化列表中的数据，即策略回测开始前的准备数据 writeCtaLog 记录日志到日志列表 putStrategyEvent 发送策略更新事件，回测中忽略 内部接口 这部分接口为回测引擎自己调用。后面在讲接口使用的时候，会通过流程图做细节介绍。这里先逐一简单做下介绍： output 输出到控制台 newTick 生成新的Tick，完成撮合交易并推送给策略 newBar 生成新的Bar，完成撮合交易并推送给策略 crossLimitOrder 基于最新数据撮合限价单 crossStopOrder 基于最新数据撮合停止单 如何使用回测引擎API 本节结合代码和流程图讲解如何使用回测引擎API。 回测过程流程图 下图为基于策略特定参数的回测过程 回测过程详解 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。历史数据得预先存储在MongoDB中，若没有， 则可执行vnpy/vn.trader/ctaAlgo/ctaHistroyData.py里的代码，把回测数据插入到数据库中， 如下 # 这里将项目中包含的股指日内分钟线csv导入MongoDB，作者电脑耗时大约3分钟 import os loadMcCsv(os.path.join(os.path.dirname(__file__), &#39;IF0000_1min.csv&#39;), MINUTE_DB_NAME, &#39;IF0000&#39;) 如果数据已经在数据库中，则运行下面的代码设置回测引擎的相关参数 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 设置使用的历史数据库 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 这里MINUTE_DB_NAME是 MINUTE_DB_NAME = &#39;VnTrader_1Min_Db&#39; 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 在回测引擎中传入策略参数创建策略对象。这里回测vnpy/vn.trader/ctaAlgo/strategyAtrRsi.py里的AtrRsiStrategy策略，策略参数只设置了&#39;atrLength&#39;为11，其它则用策略默认参数。 # 在引擎中创建策略对象 d = {&#39;atrLength&#39;: 11} engine.initStrategy(AtrRsiStrategy, d) 策略的默认参数如下： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 跑回测 # 开始跑回测 engine.runBacktesting() 显示回测结果 # 显示回测结果 # spyder或者ipython notebook中运行时，会弹出盈亏曲线图 # 直接在cmd中回测则只会打印一些回测数值 engine.showBacktestingResult() 回测过程中主要步骤的流程图 下面是回测过程主要步骤的流程图，这部分实现对用户回测策略来讲是黑盒，可以不关注。 跑回测主要流程图 显示回测结果主要流程图 计算回测结果主要流程图 计算回测结果是采用贪婪算法将成交单按时间顺序逐一做开平仓清算。下图只是给出主要的逻辑步骤，具体细节参考代码，即： def calculateBacktestingResult(self): &quot;&quot;&quot; 计算回测结果 &quot;&quot;&quot; ... 读懂回测报告 在IPython下运行AtrRsiStrategy策略的回测，示例中使用的是VS2013下的IPython环境。示例中的vnpy代码位于F:\\vnpy。读者可自行调整为自己机器上的vnpy代码所在目录。 In [2]: import sys ...: sys.path.append(&#39;F:\\\\vnpy\\\\vn.trader&#39;) ...: sys.path.append(&#39;F:\\\\vnpy\\\\vn.trader\\ctaAlgo&#39;) ...: from __future__ import division ...: from datetime import datetime, timedelta ...: from collections import OrderedDict ...: from itertools import product ...: import multiprocessing ...: import pymongo ...: from ctaBase import * ...: from ctaSetting import * ...: from vtConstant import * ...: from vtGateway import VtOrderData, VtTradeData ...: from vtFunction import loadMongoSetting ...: from ctaBacktesting import * ...: from strategyAtrRsi import * ...: In [3]: # 创建回测引擎 ...: engine = BacktestingEngine() ...: In [4]: # 设置引擎的回测模式为K线 ...: engine.setBacktestingMode(engine.BAR_MODE) ...: ...: # 设置回测用的数据起始日期和结束日期 ...: engine.setStartDate(&#39;20110101&#39;) ...: engine.setEndDate(&#39;20161231&#39;) ...: ...: # 设置使用的历史数据库 ...: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ...: In [5]: # 设置产品相关参数 ...: engine.setSlippage(0.2) # 股指1跳 ...: engine.setRate(0.3/10000) # 万0.3 ...: engine.setSize(300) # 股指合约大小 ...: In [6]: # 在引擎中创建策略对象 ...: d = {&#39;atrLength&#39;: 11} ...: engine.initStrategy(AtrRsiStrategy, d) ...: In [7]: # 开始跑回测 ...: engine.runBacktesting() ...: 2017-02-08 19:01:03.243000 开始载入数据 2017-02-08 19:01:03.383000 载入完成，数据量：341851 2017-02-08 19:01:03.383000 开始回测 2017-02-08 19:01:03.396000 策略初始化完成 2017-02-08 19:01:03.396000 策略启动完成 2017-02-08 19:01:03.396000 开始回放数据 2017-02-08 19:01:17.451000 数据回放结束 In [8]: # 显示回测结果 ...: engine.showBacktestingResult() ...: 2017-02-08 19:01:24.706000 计算回测结果 2017-02-08 19:01:24.790000 ------------------------------ 2017-02-08 19:01:24.790000 第一笔交易： 2011-01-11 13:19:00 2017-02-08 19:01:24.790000 最后一笔交易： 2016-04-01 13:17:00 2017-02-08 19:01:24.790000 总交易次数： 3,965.0 2017-02-08 19:01:24.790000 总盈亏： 695,298.02 2017-02-08 19:01:24.791000 最大回撤: -197,106.11 2017-02-08 19:01:24.791000 平均每笔盈利： 175.36 2017-02-08 19:01:24.791000 平均每笔滑点： 120.0 2017-02-08 19:01:24.791000 平均每笔佣金： 57.01 2017-02-08 19:01:24.791000 胜率 36.39% 2017-02-08 19:01:24.791000 盈利交易平均值 8,721.64 2017-02-08 19:01:24.791000 亏损交易平均值 -4,714.52 2017-02-08 19:01:24.791000 盈亏比： 1.85 回测报告说明 首先先解释一下回测报告里的交易是什么意思： 以股指IF为例，3000点时开1手多单，3010点平仓，这1手开平仓即为一笔交易。若3000点时开2手多单，3010点平1手，这1手开平仓即为一笔交易；接下来3020点再平1手，这1手开平仓为另一笔交易。 交易时间为平仓时间 计算回测结果字段说明 字段 说明 第一笔交易 第一笔交易的平仓时间 最后一笔交易 最后一笔交易的平仓时间 总交易次数 整个回测的总交易次数 总盈亏 整个回测的总盈亏，由于回测时初始资金为0，总盈亏其实就是当前资金 最大回撤 每次交易后的回撤 = 每笔交易后的资金 - 回测中最大资金。由于回撤为非正值，所以最大回撤为所有交易后的回撤绝对值最大的 平均每笔盈利 总盈亏/总交易次数 平均每笔滑点 总滑点成本/总交易次数 平均每笔佣金 总佣金成本/总交易次数 胜率 盈利交易次数/总交易次数*100(%) 盈利交易平均值 总盈利交易的盈利/总盈利交易次数 亏损交易平均值 总亏损交易的盈利/总亏损交易次数 盈亏比 盈利交易平均值/亏损交易平均值 计算回测结果图说明 图里的X轴没有采用交易时间刻度，而是将每笔交易按时间顺序从0开始标成0,1,2,3,4,... 子图名 说明 capital 每笔交易后的资金序列图 DD dropdown，每笔交易后的回撤序列图 pnl profit&amp;loss，每笔交易的盈亏直方图（概率分布图） 优化策略参数 策略的参数优化是对指定的优化目标（比如胜率，总盈亏，盈亏比等），回测每个参数的网格组合，从而找到使优化目标最优的参数组合。比如AtrRsiStrategy策略，有七个参数： # 策略参数 atrLength = 22 # 计算ATR指标的窗口数 atrMaLength = 10 # 计算ATR均线的窗口数 rsiLength = 5 # 计算RSI的窗口数 rsiEntry = 16 # RSI的开仓信号 trailingPercent = 0.8 # 百分比移动止损 initDays = 10 # 初始化数据所用的天数 fixedSize = 1 # 每次交易的数量 这里面&#39;initDays&#39;可以忽略。如果&#39;atrLength&#39;的取值范围是12-20，步长2；&#39;atrMa&#39;的取值范围是20-30，步长5。这样对于&#39;atrLength&#39;有5个取值[12,14,16,18,20]，对于&#39;atrMaLength&#39;有3个取值[20,25,30]，总共有5X3, 15个参数组合需要回测。如果设置更多的参数和更小的步长，由于参数的组合数量是幂次方，可想而知需要回测的参数组合的数量相当大，这样就要耗费大量的时间。 优化参数有两种模式： 普通模式 Python主进程循环回测每一个参数组合，并输出每个参数组合的运行结果。由于GIL，普通模式下只能使用CPU的一个核。 多进程模式 并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的运行结果。 本节主要讲解普通模式的参数优化。下图为普通模式的参数优化流程图： 下表为支持的优化目标键值: 键值 值的类型 说明 capital float 当前资金，单位是元 maxCapital float 资金最高净值，单位是元 drawdown float 当前回撤，单位是元 totalResult int 总成交次数 totalTurnover float 总成交金额 totalCommission float 总手续费 totalSlippage float 所有交易产生的滑点费用，单位是元 winningRate float 胜率(%) averageWinning float 盈利交易平均值，单位是元 averageLosing float 亏损交易平均值，单位是元 profitLossRatio float 盈亏比 参数优化主流程详解 用户只需关注参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解： 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行单进程优化 ## 运行单进程优化函数，自动输出结果 engine.runOptimization(AtrRsiStrategy, setting) 示例在IPython下的运行结果 浮点数由于精度问题，可能会出现误差。由于参数组合是无序字典，所以可能参数组合的回测顺序跟笔者的不一样。笔者电脑上，单进程优化耗时约3分40秒。 In [12]: import sys ....: sys.path.append(&#39;F:\\\\vnpy\\\\vn.trader&#39;) ....: sys.path.append(&#39;F:\\\\vnpy\\\\vn.trader\\ctaAlgo&#39;) ....: from __future__ import division ....: from datetime import datetime, timedelta ....: from collections import OrderedDict ....: from itertools import product ....: import multiprocessing ....: import pymongo ....: from ctaBase import * ....: from ctaSetting import * ....: from vtConstant import * ....: from vtGateway import VtOrderData, VtTradeData ....: from vtFunction import loadMongoSetting ....: from ctaBacktesting import * ....: from strategyAtrRsi import * ....: In [13]: # 创建回测引擎 ....: engine = BacktestingEngine() ....: In [14]: # 设置引擎的回测模式为K线 ....: engine.setBacktestingMode(engine.BAR_MODE) ....: ....: # 设置回测用的数据起始日期和结束日期 ....: engine.setStartDate(&#39;20110101&#39;) ....: engine.setEndDate(&#39;20161231&#39;) ....: ....: # 载入历史数据到引擎中 ....: engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) ....: In [15]: # 设置产品相关参数 ....: engine.setSlippage(0.2) # 股指1跳 ....: engine.setRate(0.3/10000) # 万0.3 ....: engine.setSize(300) # 股指合约大小 ....: In [16]: # 创建优化参数设置实例 ....: setting = OptimizationSetting() # 新建一个优化任务设置对象 ....: In [17]: setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 ....: setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 ....: setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 ....: setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 ....: In [18]: ## 运行单进程优化函数，自动输出结果 ....: engine.runOptimization(AtrRsiStrategy, setting) ....: 2017-02-08 19:06:19.279000 ------------------------------ 2017-02-08 19:06:19.280000 setting: {&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:19.282000 开始载入数据 2017-02-08 19:06:21.034000 载入完成，数据量：341851 2017-02-08 19:06:21.034000 开始回测 2017-02-08 19:06:21.050000 策略初始化完成 2017-02-08 19:06:21.050000 策略启动完成 2017-02-08 19:06:21.050000 开始回放数据 2017-02-08 19:06:35.728000 数据回放结束 2017-02-08 19:06:35.728000 计算回测结果 2017-02-08 19:06:35.923000 ------------------------------ 2017-02-08 19:06:35.924000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12} 2017-02-08 19:06:35.925000 开始载入数据 2017-02-08 19:06:36.015000 载入完成，数据量：341851 2017-02-08 19:06:36.015000 开始回测 2017-02-08 19:06:36.030000 策略初始化完成 2017-02-08 19:06:36.030000 策略启动完成 2017-02-08 19:06:36.030000 开始回放数据 2017-02-08 19:06:50.140000 数据回放结束 2017-02-08 19:06:50.140000 计算回测结果 ... 2017-02-08 19:09:30.237000 ------------------------------ 2017-02-08 19:09:30.237000 setting: {&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:30.239000 开始载入数据 2017-02-08 19:09:30.330000 载入完成，数据量：341851 2017-02-08 19:09:30.330000 开始回测 2017-02-08 19:09:30.343000 策略初始化完成 2017-02-08 19:09:30.343000 策略启动完成 2017-02-08 19:09:30.343000 开始回放数据 2017-02-08 19:09:44.499000 数据回放结束 2017-02-08 19:09:44.499000 计算回测结果 2017-02-08 19:09:44.696000 ------------------------------ 2017-02-08 19:09:44.696000 setting: {&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20} 2017-02-08 19:09:44.697000 开始载入数据 2017-02-08 19:09:44.787000 载入完成，数据量：341851 2017-02-08 19:09:44.787000 开始回测 2017-02-08 19:09:44.801000 策略初始化完成 2017-02-08 19:09:44.801000 策略启动完成 2017-02-08 19:09:44.801000 开始回放数据 2017-02-08 19:09:58.942000 数据回放结束 2017-02-08 19:09:58.942000 计算回测结果 2017-02-08 19:09:59.242000 ------------------------------ 2017-02-08 19:09:59.242000 优化结果： 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 1127713.85011 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 1030743.75807 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 983294.726285 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 975329.10312 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 949746.520421 2017-02-08 19:09:59.242000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 914875.145592 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 899113.140024 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 896378.557181 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 30, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 893726.622984 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 16}&quot;]: 883947.771514 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 14}&quot;]: 873221.532605 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 12}&quot;]: 857260.355525 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 20, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 852615.557093 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 20}&quot;]: 790618.233326 2017-02-08 19:09:59.243000 [&quot;{&#39;atrMaLength&#39;: 25, &#39;rsiLength&#39;: 5, &#39;atrLength&#39;: 18}&quot;]: 726949.447939 优化结果的输出格式是：参数组合：优化目标值 多进程优化 本节主要讲解参数的优化的多进程模式。由于Python的GIL原因，多进程模式可以更好的利用CPU的多核，提高优化参数速度。由于vnpy已经提供RPC模块，所以可以基于RPC模块实现分布式参数优化。 多进程参数优化主流程图和优化函数流程图&nbsp; 多进程参数优化主流程详解 用户只需关注多进程参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解。跟普通模式的参数优化的区别是最后调用多进程优化接口。笔者电脑上，示例中AtrRsiStrategy策略多进程回测的耗时约为52秒。 对用户来讲，首先要创建回测引擎实例 # 创建回测引擎 engine = BacktestingEngine() 设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。 # 设置引擎的回测模式为K线 engine.setBacktestingMode(engine.BAR_MODE) # 设置回测用的数据起始日期和结束日期 engine.setStartDate(&#39;20110101&#39;) engine.setEndDate(&#39;20161231&#39;) # 载入历史数据到引擎中 engine.setDatabase(MINUTE_DB_NAME, &#39;IF0000&#39;) 设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元 # 设置产品相关参数 engine.setSlippage(0.2) # 股指1跳 engine.setRate(0.3/10000) # 万0.3 engine.setSize(300) # 股指合约大小 创建优化参数实例 # 创建优化参数设置实例 setting = OptimizationSetting() # 新建一个优化任务设置对象 设置优化目标和参数 setting.setOptimizeTarget(&#39;capital&#39;) # 设置优化排序的目标是策略净盈利 setting.addParameter(&#39;atrLength&#39;, 12, 20, 2) # 增加第一个优化参数atrLength，起始12，结束20，步进2 setting.addParameter(&#39;atrMaLength&#39;, 20, 30, 5) # 增加第二个优化参数atrMaLength，起始20，结束30，步进5 setting.addParameter(&#39;rsiLength&#39;, 5) # 增加一个固定数值的参数 运行多进程优化 ## 运行多进程优化函数，自动输出结果 engine.runParallelOptimization(AtrRsiStrategy, setting) 阅读更多","@type":"BlogPosting","url":"/2018/08/10/44cfdb5199031b2613887344f2f0c7fc.html","headline":"VNPY - CTA策略模块策略回测","dateModified":"2018-08-10T00:00:00+08:00","datePublished":"2018-08-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/10/44cfdb5199031b2613887344f2f0c7fc.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>VNPY - CTA策略模块策略回测</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>作者：魔元</strong></p> 
  <p><strong>目录</strong></p> 
  <ul>
   <li><a href="https://github.com/vnpy/vnpy/wiki/CTA%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9D%97%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B#%E4%BD%BF%E7%94%A8%E5%9B%9E%E6%B5%8B%E5%BC%95%E6%93%8E" rel="nofollow">使用回测引擎</a></li> 
   <li><a href="https://github.com/vnpy/vnpy/wiki/CTA%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9D%97%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B#%E8%AF%BB%E6%87%82%E5%9B%9E%E6%B5%8B%E6%8A%A5%E5%91%8A" rel="nofollow">读懂回测报告</a></li> 
   <li><a href="https://github.com/vnpy/vnpy/wiki/CTA%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9D%97%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E5%8F%82%E6%95%B0" rel="nofollow">优化策略参数</a></li> 
   <li><a href="https://github.com/vnpy/vnpy/wiki/CTA%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9D%97%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%8C%96" rel="nofollow">多进程优化</a></li> 
  </ul>
  <p>量化策略主要是从历史数据统计或者发现规律然后应用于实盘交易。当然历史不是简单的重复，这就要求策略需要根据市场调整和优化参数。通过回测历史数据可以验证策略的有效性，了解策略的历史收益、最大回撤和回撤时长，对策略参数进行优化等等。CTA策略模块的主要回测目标是验证交易信号是否正确，仓位大小的问题在实盘中则由交易员来确定。</p> 
  <h2>使用回测引擎</h2> 
  <p><span style="color:#f33b45;">vnpy的回测引擎位于<strong>vnpy/trader/app/ctaStrategy/ctaBacktesting.py</strong></span>，此文件中主要包含以下几个类：</p> 
  <ul>
   <li> <p><strong>BacktestingEngine</strong></p> 
    <ul>
     <li>回测引擎类，主要功能是设置回测参数，初始化策略对象，运行回测并输出结果。类接口和实盘引擎类(CtaEngine)保持一致，从而实现同一套策略代码从回测到实盘。<strong>用户主要是调用本类的接口来回测策略</strong>。</li> 
    </ul></li> 
   <li> <p><strong>TradingResult</strong></p> 
    <ul>
     <li>撮合好的交易结果类，由回测引擎计算回测结果时使用。类成员包含开仓价格，平仓价格，交易数量，成交金额，滑点成本，手续费成本及净盈亏等。</li> 
    </ul><p>这里面有一点注意是交易数量的正负代表开仓方向。以股指IF为例，3000点时开1手多单，3010点平仓，这时就会生成一个TradingResult实例，交易数量为1。若3000点时开1手空单，3010点平仓，这时生成的TradingResult实例的交易数量为-1。<br> 代码如下：</p> <pre class="has">
<code>  ```Python
  self.entryPrice = entryPrice    # 开仓价格
  self.exitPrice = exitPrice      # 平仓价格

  self.entryDt = entryDt          # 开仓时间datetime    
  self.exitDt = exitDt            # 平仓时间

  self.volume = volume    # 交易数量（+/-代表方向）

  self.turnover = (self.entryPrice+self.exitPrice)*size*abs(volume)   # 成交金额
  self.commission = self.turnover*rate                                # 手续费成本
  self.slippage = slippage*2*size*abs(volume)                         # 滑点成本
  self.pnl = ((self.exitPrice - self.entryPrice) * volume * size
              - self.commission - self.slippage)                      # 净盈亏
  ```
</code></pre> </li> 
   <li> <p><strong>OptimizationSetting</strong></p> 
    <ul>
     <li><span style="color:#f33b45;">参数优化设置类，主要是生成优化参数组合。每个参数组合都由回测引擎执行一遍，以得到不同参数组合的回测结果。优化参数回测时会使用此类。</span></li> 
    </ul></li> 
  </ul>
  <h3>回测引擎API介绍</h3> 
  <p>由于用户主要是调用本类的接口来回测策略，所以将对本类的接口做逐一介绍。一方面回测引擎类的接口跟实盘策略引擎保持一样，这方面的接口主要是被策略调用； 另一方面回测引擎类也要提供回测相关的接口，所以将回测引擎类的接口从功能性分成这几个方面介绍：</p> 
  <ul>
   <li> <p><strong>用户回测策略接口</strong></p> 
    <ul>
     <li> <p>配置相关接口</p> 
      <ul>
       <li> <p>setBacktestingMode</p> 
        <ul>
         <li> <p>设置回测模式，支持两种模式，一种是Tick模式，另一种是K线模式</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>mode</td> 
             <td>string</td> 
             <td>回测模式，支持两种模式：BacktestingEngine.TICK_MODE和BacktestingEngine.BAR_MODE</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setStartDate</p> 
        <ul>
         <li> <p>设置回测开始日期</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>startDate</td> 
             <td>string</td> 
             <td>回测开始日期</td> 
            </tr>
            <tr>
             <td>initDays</td> 
             <td>int</td> 
             <td>策略回测开始前需要准备多少日的数据。默认是10日。举个例子，假设策略是日K线回测，数据库里的数据是日K线，如果策略里需要5日均线，这里此参数设为4。假设策略是1分钟K线回测，数据库里的数据是1分钟K线，如果策略里需要5分钟均线，这里此参数则设为1。因为1日里的1分钟K线数据远远大于4，已经足够满足策略开始的准备数据了。</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setEndDate</p> 
        <ul>
         <li> <p>设置回测结束日期</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>endDate</td> 
             <td>string</td> 
             <td>回测结束日期。默认是''。若使用默认参数，则是数据在数据库里的最近日期。</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setDatabase</p> 
        <ul>
         <li> <p>设置产品（合约）数据的数据库名及表名，这样回测引擎可以载入对应的数据。</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>dbName</td> 
             <td>string</td> 
             <td>数据库名</td> 
            </tr>
            <tr>
             <td>symbol</td> 
             <td>string</td> 
             <td>数据库表名</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setSlippage</p> 
        <ul>
         <li> <p>设置每一手产品（合约）的滑点，单位是产品（合约）的价格</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>slippage</td> 
             <td>float</td> 
             <td>滑点数值</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setRate</p> 
        <ul>
         <li> <p>设置佣金比例，交易手续费=成交金额X佣金比例</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>rate</td> 
             <td>float</td> 
             <td>佣金比例</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setSize</p> 
        <ul>
         <li> <p>设置产品（合约）大小，单位为元。成交金额=合约价格(面值)X合约大小</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>size</td> 
             <td>float</td> 
             <td>合约大小</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>setPriceTick</p> 
        <ul>
         <li> <p>设置产品（合约）的最小价格变动，单位是产品（合约）的价格</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>priceTick</td> 
             <td>float</td> 
             <td>最小价格变动</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
      </ul></li> 
     <li> <p>回测相关接口</p> 
      <ul>
       <li> <p>initStrategy</p> 
        <ul>
         <li> <p>根据策略参数，实例化回测策略对象。</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>strategyClass</td> 
             <td>class</td> 
             <td>策略类</td> 
            </tr>
            <tr>
             <td>setting</td> 
             <td>dict</td> 
             <td>策略参数配置，若使用策略的默认参数则为None</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>runBacktesting</p> 
        <ul>
         <li> <p><span style="color:#f33b45;">运行回测。从数据库里载入数据，逐条推入策略做回测，同时模拟委托和成交，并保存回测过程的中间数据，以此可以计算回测结果并显示。</span></p> </li> 
         <li> <p>参数：无</p> <p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>calculateBacktestingResult</p> 
        <ul>
         <li> <p>逐条匹配交易，并计算回测结果。由于回测策略是假设初始资金为0，这样交易后资金可能为负值。这里跟实盘有区别，实盘需要保证金，回测时只考虑每笔交易的盈亏。</p> </li> 
         <li> <p>参数：无</p> <p>返回值：dict</p> 
          <table>
           <thead>
            <tr>
             <th>键值</th> 
             <th>值的类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>capital</td> 
             <td>float</td> 
             <td>当前资金，单位是元</td> 
            </tr>
            <tr>
             <td>maxCapital</td> 
             <td>float</td> 
             <td>资金最高净值，单位是元</td> 
            </tr>
            <tr>
             <td>drawdown</td> 
             <td>float</td> 
             <td>当前回撤，非正值，单位是元</td> 
            </tr>
            <tr>
             <td>totalResult</td> 
             <td>int</td> 
             <td>总成交次数</td> 
            </tr>
            <tr>
             <td>totalTurnover</td> 
             <td>float</td> 
             <td>总成交金额</td> 
            </tr>
            <tr>
             <td>totalCommission</td> 
             <td>float</td> 
             <td>总手续费</td> 
            </tr>
            <tr>
             <td>totalSlippage</td> 
             <td>float</td> 
             <td>所有交易产生的滑点费用，单位是元</td> 
            </tr>
            <tr>
             <td>timeList</td> 
             <td>list</td> 
             <td>每笔交易的时间序列，时间为交易出场时间</td> 
            </tr>
            <tr>
             <td>pnlList</td> 
             <td>list</td> 
             <td>每笔盈亏序列</td> 
            </tr>
            <tr>
             <td>capitalList</td> 
             <td>list</td> 
             <td>每笔交易后的资金序列</td> 
            </tr>
            <tr>
             <td>drawdownList</td> 
             <td>list</td> 
             <td>每笔交易后的回撤序列</td> 
            </tr>
            <tr>
             <td>winningRate</td> 
             <td>float</td> 
             <td>胜率(%)</td> 
            </tr>
            <tr>
             <td>averageWinning</td> 
             <td>float</td> 
             <td>盈利交易平均值，单位是元</td> 
            </tr>
            <tr>
             <td>averageLosing</td> 
             <td>float</td> 
             <td>亏损交易平均值，单位是元</td> 
            </tr>
            <tr>
             <td>profitLossRatio</td> 
             <td>float</td> 
             <td>盈亏比</td> 
            </tr>
           </tbody>
          </table></li> 
        </ul></li> 
       <li> <p>showBacktestingResult</p> 
        <ul>
         <li> <p>计算回测结果，输出回测报告，并显示回测结果图：资金子图，回撤子图，每笔交易盈亏子图</p> </li> 
         <li> <p>参数：无</p> <p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>calculateDailyResult</p> 
        <ul>
         <li> <p>按照逐日盯市的方式计算每日的交易盈亏和持仓盈亏，并汇总成最终按日统计的盈亏情况。</p> </li> 
         <li> <p>参数：无</p> <p>返回值：dict</p> </li> 
        </ul></li> 
       <li> <p>showDailyResult</p> 
        <ul>
         <li> <p>显示按照逐日盯市方式统计的回测结果和资金曲线，提供Sharpe Ratio的统计结果。</p> </li> 
         <li> <p>参数：无</p> <p>返回值：None</p> </li> 
        </ul></li> 
      </ul></li> 
     <li> <p>优化参数相关接口</p> 
      <ul>
       <li> <p>runOptimization</p> 
        <ul>
         <li> <p>运行普通模式的优化参数，也就是说python主进程循环回测每一个参数组合，并输出每个参数组合的优化结果。普通模式下只能使用CPU的一个核。</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>strategyClass</td> 
             <td>class</td> 
             <td>策略类</td> 
            </tr>
            <tr>
             <td>optimizationSetting</td> 
             <td>class</td> 
             <td>OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
       <li> <p>runParallelOptimization</p> 
        <ul>
         <li> <p>运行多进程模式的优化参数，也就是说并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的优化结果。</p> </li> 
         <li> 
          <table>
           <thead>
            <tr>
             <th>参数</th> 
             <th>类型</th> 
             <th>说明</th> 
            </tr>
           </thead>
           <tbody>
            <tr>
             <td>strategyClass</td> 
             <td>class</td> 
             <td>策略类</td> 
            </tr>
            <tr>
             <td>optimizationSetting</td> 
             <td>class</td> 
             <td>OptimizationSetting对象，基于它生成优化参数组合，并获取优化目标</td> 
            </tr>
           </tbody>
          </table><p>返回值：None</p> </li> 
        </ul></li> 
      </ul></li> 
    </ul></li> 
   <li> <p><strong>策略相关接口</strong></p> 
    <ul>
     <li>由于策略既可以跑在回测引擎又可以跑在实盘引擎，所以这部分接口保持跟实盘引擎一致。这部分接口只做功能介绍，不做具体参数的介绍，因为对用户回测策略来讲，这是一个黑盒。根据交易相关和非交易相关，这部分接口可以分为两类： 
      <ul>
       <li> <p>交易相关接口</p> 
        <ul>
         <li>sendOrder 
          <ul>
           <li>模拟限价委托单，并把限价单保存在限价单字典和工作限价单字典中。工作限价单字典里是需要撮合成交的委托。限价单字典里则是所有委托。</li> 
          </ul></li> 
         <li>cancelOrder 
          <ul>
           <li>模拟撤销限价委托单，并从工作限价单字典中删除。</li> 
          </ul></li> 
         <li>sendStopOrder 
          <ul>
           <li>模拟本地停止单，并把停止单保存在停止单字典和工作停止单字典中。工作停止单字典里是需要撮合成交的委托。停止单字典里则是所有委托。</li> 
          </ul></li> 
         <li>cancelStopOrder 
          <ul>
           <li>模拟撤销停止委托单，并从工作停止单字典中删除。</li> 
          </ul></li> 
        </ul></li> 
       <li> <p>非交易相关接口</p> 
        <ul>
         <li>insertData 
          <ul>
           <li>插入数据到数据库，回测时直接pass</li> 
          </ul></li> 
         <li>loadTick 
          <ul>
           <li>载入初始化列表中的数据，即策略回测开始前的准备数据</li> 
          </ul></li> 
         <li>loadBar 
          <ul>
           <li>载入初始化列表中的数据，即策略回测开始前的准备数据</li> 
          </ul></li> 
         <li>writeCtaLog 
          <ul>
           <li>记录日志到日志列表</li> 
          </ul></li> 
         <li>putStrategyEvent 
          <ul>
           <li>发送策略更新事件，回测中忽略</li> 
          </ul></li> 
        </ul></li> 
      </ul></li> 
    </ul></li> 
   <li> <p><strong>内部接口</strong></p> 
    <ul>
     <li><span style="color:#f33b45;">这部分接口为回测引擎自己调用。后面在讲接口使用的时候，会通过流程图做细节介绍</span>。这里先逐一简单做下介绍： 
      <ul>
       <li>output 
        <ul>
         <li>输出到控制台</li> 
        </ul></li> 
       <li>newTick 
        <ul>
         <li>生成新的Tick，完成撮合交易并推送给策略</li> 
        </ul></li> 
       <li>newBar 
        <ul>
         <li>生成新的Bar，完成撮合交易并推送给策略</li> 
        </ul></li> 
       <li>crossLimitOrder 
        <ul>
         <li>基于最新数据撮合限价单</li> 
        </ul></li> 
       <li>crossStopOrder 
        <ul>
         <li>基于最新数据撮合停止单</li> 
        </ul></li> 
      </ul></li> 
    </ul></li> 
  </ul>
  <h3>如何使用回测引擎API</h3> 
  <p>本节结合代码和流程图讲解如何使用回测引擎API。</p> 
  <p>回测过程流程图</p> 
  <p>下图为基于策略特定参数的回测过程</p> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/7b74cc12082b2e07a9edacf4b86aec1a047c05e6/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f2545362539372541302545362541302538372545392541322539382e706e673f457870697265733d31353138343138353333264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d4b5a335952577569483278334d4539684642397a4d253246433157504d253344"></p> 
  <p>回测过程详解</p> 
  <ol>
   <li>对用户来讲，首先要创建回测引擎实例</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 创建回测引擎
engine = BacktestingEngine()</code></pre> 
  <ol>
   <li>设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。历史数据得预先存储在MongoDB中，若没有， 则可执行<strong>vnpy/vn.trader/ctaAlgo/ctaHistroyData.py</strong>里的代码，把回测数据插入到数据库中， 如下</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 这里将项目中包含的股指日内分钟线csv导入MongoDB，作者电脑耗时大约3分钟
import os
loadMcCsv(os.path.join(os.path.dirname(__file__), 'IF0000_1min.csv'), MINUTE_DB_NAME, 'IF0000')</code></pre> 
  <p>如果数据已经在数据库中，则运行下面的代码设置回测引擎的相关参数</p> 
  <pre>
<code class="language-html hljs"># 设置引擎的回测模式为K线
engine.setBacktestingMode(engine.BAR_MODE)

# 设置回测用的数据起始日期和结束日期
engine.setStartDate('20110101')
engine.setEndDate('20161231')

# 设置使用的历史数据库
engine.setDatabase(MINUTE_DB_NAME, 'IF0000')</code></pre> 
  <p>这里<strong>MINUTE_DB_NAME</strong>是</p> 
  <pre>
<code class="language-html hljs">MINUTE_DB_NAME = 'VnTrader_1Min_Db'</code></pre> 
  <ol>
   <li>设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 设置产品相关参数
engine.setSlippage(0.2)     # 股指1跳
engine.setRate(0.3/10000)   # 万0.3
engine.setSize(300)         # 股指合约大小    </code></pre> 
  <ol>
   <li>在回测引擎中传入策略参数创建策略对象。这里回测<strong>vnpy/vn.trader/ctaAlgo/strategyAtrRsi.py</strong>里的AtrRsiStrategy策略，策略参数只设置了'atrLength'为11，其它则用策略默认参数。</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 在引擎中创建策略对象
d = {'atrLength': 11}
engine.initStrategy(AtrRsiStrategy, d)</code></pre> 
  <p>策略的默认参数如下：</p> 
  <pre>
<code class="language-html hljs"># 策略参数
atrLength = 22          # 计算ATR指标的窗口数   
atrMaLength = 10        # 计算ATR均线的窗口数
rsiLength = 5           # 计算RSI的窗口数
rsiEntry = 16           # RSI的开仓信号
trailingPercent = 0.8   # 百分比移动止损
initDays = 10           # 初始化数据所用的天数
fixedSize = 1           # 每次交易的数量</code></pre> 
  <ol>
   <li>跑回测</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 开始跑回测
engine.runBacktesting()</code></pre> 
  <ol>
   <li>显示回测结果</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 显示回测结果
# spyder或者ipython notebook中运行时，会弹出盈亏曲线图
# 直接在cmd中回测则只会打印一些回测数值
engine.showBacktestingResult()</code></pre> 
  <p>回测过程中主要步骤的流程图</p> 
  <p>下面是回测过程主要步骤的流程图，这部分实现对用户回测策略来讲是黑盒，可以不关注。</p> 
  <p>跑回测主要流程图</p> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/18f5b8c6b1999e20a2dd3d5b16c1fee7f2a1729c/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f254536253937254130254536254130253837254539254132253938312e706e673f457870697265733d31353138343138353535264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d37775041364a59324f33716a33364c79627a493438624a714f6e45253344"></p> 
  <p>显示回测结果主要流程图</p> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/4a3c89a56db9012e2168c2bc4cf58fae50c34d25/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f254536253937254130254536254130253837254539254132253938332e706e673f457870697265733d31353138343138353836264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d5455746f7665794b384253714a4a6d32787162685a67505a57684d253344"></p> 
  <p>计算回测结果主要流程图</p> 
  <p><span style="color:#f33b45;">计算回测结果是采用贪婪算法将成交单按时间顺序逐一做开平仓清算。</span>下图只是给出主要的逻辑步骤，具体细节参考代码，即：</p> 
  <pre>
<code class="language-html hljs">def calculateBacktestingResult(self):
    """
    计算回测结果
    """
    ...</code></pre> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/d56281b7f6cf883d6751a48aa2ddda255b54e90d/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f726573756c742e706e673f457870697265733d31353138343138363533264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d794c4e30636c7742617a706f32695356253246686a536a64344d595363253344"></p> 
  <h2>读懂回测报告</h2> 
  <p>在IPython下运行AtrRsiStrategy策略的回测，示例中使用的是VS2013下的IPython环境。示例中的vnpy代码位于<strong>F:\vnpy</strong>。读者可自行调整为自己机器上的vnpy代码所在目录。</p> 
  <pre>
<code class="language-html hljs">In [2]: import sys
   ...: sys.path.append('F:\\vnpy\\vn.trader')
   ...: sys.path.append('F:\\vnpy\\vn.trader\ctaAlgo')
   ...: from __future__ import division
   ...: from datetime import datetime, timedelta
   ...: from collections import OrderedDict
   ...: from itertools import product
   ...: import multiprocessing
   ...: import pymongo
   ...: from ctaBase import *
   ...: from ctaSetting import *
   ...: from vtConstant import *
   ...: from vtGateway import VtOrderData, VtTradeData
   ...: from vtFunction import loadMongoSetting
   ...: from ctaBacktesting import *
   ...: from strategyAtrRsi import *
   ...:

In [3]: # 创建回测引擎
   ...: engine = BacktestingEngine()
   ...:

In [4]: # 设置引擎的回测模式为K线
   ...: engine.setBacktestingMode(engine.BAR_MODE)
   ...:
   ...: # 设置回测用的数据起始日期和结束日期
   ...: engine.setStartDate('20110101')
   ...: engine.setEndDate('20161231')
   ...:
   ...: # 设置使用的历史数据库
   ...: engine.setDatabase(MINUTE_DB_NAME, 'IF0000')
   ...:

In [5]: # 设置产品相关参数
   ...: engine.setSlippage(0.2)     # 股指1跳
   ...: engine.setRate(0.3/10000)   # 万0.3
   ...: engine.setSize(300)         # 股指合约大小
   ...:

In [6]: # 在引擎中创建策略对象
   ...: d = {'atrLength': 11}
   ...: engine.initStrategy(AtrRsiStrategy, d)
   ...:

In [7]: # 开始跑回测
   ...: engine.runBacktesting()
   ...:
2017-02-08 19:01:03.243000	开始载入数据
2017-02-08 19:01:03.383000	载入完成，数据量：341851
2017-02-08 19:01:03.383000	开始回测
2017-02-08 19:01:03.396000	策略初始化完成
2017-02-08 19:01:03.396000	策略启动完成
2017-02-08 19:01:03.396000	开始回放数据
2017-02-08 19:01:17.451000	数据回放结束

In [8]: # 显示回测结果
   ...: engine.showBacktestingResult()
   ...:
2017-02-08 19:01:24.706000	计算回测结果
2017-02-08 19:01:24.790000	------------------------------
2017-02-08 19:01:24.790000	第一笔交易：	2011-01-11 13:19:00
2017-02-08 19:01:24.790000	最后一笔交易：	2016-04-01 13:17:00
2017-02-08 19:01:24.790000	总交易次数：	3,965.0
2017-02-08 19:01:24.790000	总盈亏：	695,298.02
2017-02-08 19:01:24.791000	最大回撤: 	-197,106.11
2017-02-08 19:01:24.791000	平均每笔盈利：	175.36
2017-02-08 19:01:24.791000	平均每笔滑点：	120.0
2017-02-08 19:01:24.791000	平均每笔佣金：	57.01
2017-02-08 19:01:24.791000	胜率		36.39%
2017-02-08 19:01:24.791000	盈利交易平均值	8,721.64
2017-02-08 19:01:24.791000	亏损交易平均值	-4,714.52
2017-02-08 19:01:24.791000	盈亏比：	1.85</code></pre> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/9161dbf5afda45d2971a535eb1684a0d48518d6f/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f254536253937254130254536254130253837254539254132253938362e706e673f457870697265733d31353138343138373438264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d69504a50335843334c585a2532464b44637973593170654e57714e3255253344"></p> 
  <h3>回测报告说明</h3> 
  <p>首先先解释一下回测报告里的交易是什么意思：</p> 
  <ul>
   <li>以股指IF为例，3000点时开1手多单，3010点平仓，这1手开平仓即为一笔交易。若3000点时开2手多单，3010点平1手，这1手开平仓即为一笔交易；接下来3020点再平1手，这1手开平仓为另一笔交易。</li> 
   <li>交易时间为平仓时间</li> 
  </ul>
  <p>计算回测结果字段说明</p> 
  <table>
   <thead>
    <tr>
     <th>字段</th> 
     <th>说明</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>第一笔交易</td> 
     <td>第一笔交易的平仓时间</td> 
    </tr>
    <tr>
     <td>最后一笔交易</td> 
     <td>最后一笔交易的平仓时间</td> 
    </tr>
    <tr>
     <td>总交易次数</td> 
     <td>整个回测的总交易次数</td> 
    </tr>
    <tr>
     <td>总盈亏</td> 
     <td>整个回测的总盈亏，由于回测时初始资金为0，总盈亏其实就是当前资金</td> 
    </tr>
    <tr>
     <td>最大回撤</td> 
     <td>每次交易后的回撤 = 每笔交易后的资金 - 回测中最大资金。由于回撤为非正值，所以最大回撤为所有交易后的回撤绝对值最大的</td> 
    </tr>
    <tr>
     <td>平均每笔盈利</td> 
     <td>总盈亏/总交易次数</td> 
    </tr>
    <tr>
     <td>平均每笔滑点</td> 
     <td>总滑点成本/总交易次数</td> 
    </tr>
    <tr>
     <td>平均每笔佣金</td> 
     <td>总佣金成本/总交易次数</td> 
    </tr>
    <tr>
     <td>胜率</td> 
     <td>盈利交易次数/总交易次数*100(%)</td> 
    </tr>
    <tr>
     <td>盈利交易平均值</td> 
     <td>总盈利交易的盈利/总盈利交易次数</td> 
    </tr>
    <tr>
     <td>亏损交易平均值</td> 
     <td>总亏损交易的盈利/总亏损交易次数</td> 
    </tr>
    <tr>
     <td>盈亏比</td> 
     <td>盈利交易平均值/亏损交易平均值</td> 
    </tr>
   </tbody>
  </table>
  <p>计算回测结果图说明</p> 
  <p>图里的X轴没有采用交易时间刻度，而是将每笔交易按时间顺序从0开始标成0,1,2,3,4,...</p> 
  <table>
   <thead>
    <tr>
     <th>子图名</th> 
     <th>说明</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>capital</td> 
     <td>每笔交易后的资金序列图</td> 
    </tr>
    <tr>
     <td>DD</td> 
     <td>dropdown，每笔交易后的回撤序列图</td> 
    </tr>
    <tr>
     <td>pnl</td> 
     <td>profit&amp;loss，每笔交易的盈亏直方图（概率分布图）</td> 
    </tr>
   </tbody>
  </table>
  <h2><span style="color:#f33b45;">优化策略参数</span></h2> 
  <p>策略的参数优化是对指定的优化目标（比如胜率，总盈亏，盈亏比等），回测每个参数的网格组合，从而找到使优化目标最优的参数组合。比如AtrRsiStrategy策略，有七个参数：</p> 
  <pre>
<code class="language-html hljs"># 策略参数
atrLength = 22          # 计算ATR指标的窗口数   
atrMaLength = 10        # 计算ATR均线的窗口数
rsiLength = 5           # 计算RSI的窗口数
rsiEntry = 16           # RSI的开仓信号
trailingPercent = 0.8   # 百分比移动止损
initDays = 10           # 初始化数据所用的天数
fixedSize = 1           # 每次交易的数量</code></pre> 
  <p>这里面'initDays'可以忽略。如果'atrLength'的取值范围是12-20，步长2；'atrMa'的取值范围是20-30，步长5。这样对于'atrLength'有5个取值[12,14,16,18,20]，对于'atrMaLength'有3个取值[20,25,30]，总共有5X3, 15个参数组合需要回测。如果设置更多的参数和更小的步长，由于参数的组合数量是幂次方，可想而知需要回测的参数组合的数量相当大，这样就要耗费大量的时间。 优化参数有两种模式：</p> 
  <ul>
   <li>普通模式 
    <ul>
     <li>Python主进程循环回测每一个参数组合，并输出每个参数组合的运行结果。由于GIL，普通模式下只能使用CPU的一个核。</li> 
    </ul></li> 
   <li>多进程模式 
    <ul>
     <li><span style="color:#f33b45;">并行运行多个进程（等于CPU的核个数）回测每一个参数组合，并输出每个参数组合的运行结果。</span></li> 
    </ul></li> 
  </ul>
  <p>本节主要讲解普通模式的参数优化。下图为普通模式的参数优化流程图：</p> 
  <p><img alt="Markdown" class="has" src="https://camo.githubusercontent.com/4c73b48176c027ab82f0ca3213e6a125a0f1c285/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f254536253937254130254536254130253837254539254132253938342e706e673f457870697265733d31353138343138373732264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d4d564975374a4f7858617058644a715a367464726f4a3733723877253344"></p> 
  <p>下表为支持的优化目标键值:</p> 
  <table>
   <thead>
    <tr>
     <th>键值</th> 
     <th>值的类型</th> 
     <th>说明</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>capital</td> 
     <td>float</td> 
     <td>当前资金，单位是元</td> 
    </tr>
    <tr>
     <td>maxCapital</td> 
     <td>float</td> 
     <td>资金最高净值，单位是元</td> 
    </tr>
    <tr>
     <td>drawdown</td> 
     <td>float</td> 
     <td>当前回撤，单位是元</td> 
    </tr>
    <tr>
     <td>totalResult</td> 
     <td>int</td> 
     <td>总成交次数</td> 
    </tr>
    <tr>
     <td>totalTurnover</td> 
     <td>float</td> 
     <td>总成交金额</td> 
    </tr>
    <tr>
     <td>totalCommission</td> 
     <td>float</td> 
     <td>总手续费</td> 
    </tr>
    <tr>
     <td>totalSlippage</td> 
     <td>float</td> 
     <td>所有交易产生的滑点费用，单位是元</td> 
    </tr>
    <tr>
     <td>winningRate</td> 
     <td>float</td> 
     <td>胜率(%)</td> 
    </tr>
    <tr>
     <td>averageWinning</td> 
     <td>float</td> 
     <td>盈利交易平均值，单位是元</td> 
    </tr>
    <tr>
     <td>averageLosing</td> 
     <td>float</td> 
     <td>亏损交易平均值，单位是元</td> 
    </tr>
    <tr>
     <td>profitLossRatio</td> 
     <td>float</td> 
     <td>盈亏比</td> 
    </tr>
   </tbody>
  </table>
  <h3><span style="color:#f33b45;">参数优化主流程详解</span></h3> 
  <p>用户只需关注参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解：</p> 
  <ol>
   <li>对用户来讲，首先要创建回测引擎实例</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 创建回测引擎
engine = BacktestingEngine()</code></pre> 
  <ol>
   <li>设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 设置引擎的回测模式为K线
engine.setBacktestingMode(engine.BAR_MODE)

# 设置回测用的数据起始日期和结束日期
engine.setStartDate('20110101')
engine.setEndDate('20161231')

# 载入历史数据到引擎中
engine.setDatabase(MINUTE_DB_NAME, 'IF0000')</code></pre> 
  <ol>
   <li>设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 设置产品相关参数
engine.setSlippage(0.2)     # 股指1跳
engine.setRate(0.3/10000)   # 万0.3
engine.setSize(300)         # 股指合约大小    </code></pre> 
  <ol>
   <li>创建优化参数实例</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 创建优化参数设置实例
setting = OptimizationSetting()                 # 新建一个优化任务设置对象</code></pre> 
  <ol>
   <li>设置优化目标和参数</li> 
  </ol>
  <pre>
<code class="language-html hljs">setting.setOptimizeTarget('capital')            # 设置优化排序的目标是策略净盈利
setting.addParameter('atrLength', 12, 20, 2)    # 增加第一个优化参数atrLength，起始12，结束20，步进2
setting.addParameter('atrMaLength', 20, 30, 5)  # 增加第二个优化参数atrMaLength，起始20，结束30，步进5
setting.addParameter('rsiLength', 5)            # 增加一个固定数值的参数</code></pre> 
  <ol>
   <li>运行单进程优化</li> 
  </ol>
  <pre>
<code class="language-html hljs">## 运行单进程优化函数，自动输出结果
engine.runOptimization(AtrRsiStrategy, setting)        </code></pre> 
  <h3>示例在IPython下的运行结果</h3> 
  <p>浮点数由于精度问题，可能会出现误差。由于参数组合是无序字典，所以可能参数组合的回测顺序跟笔者的不一样。笔者电脑上，单进程优化耗时约3分40秒。</p> 
  <pre>
<code class="language-html hljs">In [12]: import sys
   ....: sys.path.append('F:\\vnpy\\vn.trader')
   ....: sys.path.append('F:\\vnpy\\vn.trader\ctaAlgo')
   ....: from __future__ import division
   ....: from datetime import datetime, timedelta
   ....: from collections import OrderedDict
   ....: from itertools import product
   ....: import multiprocessing
   ....: import pymongo
   ....: from ctaBase import *
   ....: from ctaSetting import *
   ....: from vtConstant import *
   ....: from vtGateway import VtOrderData, VtTradeData
   ....: from vtFunction import loadMongoSetting
   ....: from ctaBacktesting import *
   ....: from strategyAtrRsi import *
   ....:

In [13]: # 创建回测引擎
   ....: engine = BacktestingEngine()
   ....:

In [14]: # 设置引擎的回测模式为K线
   ....: engine.setBacktestingMode(engine.BAR_MODE)
   ....:
   ....: # 设置回测用的数据起始日期和结束日期
   ....: engine.setStartDate('20110101')
   ....: engine.setEndDate('20161231')
   ....:
   ....: # 载入历史数据到引擎中
   ....: engine.setDatabase(MINUTE_DB_NAME, 'IF0000')
   ....:

In [15]: # 设置产品相关参数
   ....: engine.setSlippage(0.2)     # 股指1跳
   ....: engine.setRate(0.3/10000)   # 万0.3
   ....: engine.setSize(300)         # 股指合约大小
   ....:

In [16]: # 创建优化参数设置实例
   ....: setting = OptimizationSetting()                 # 新建一个优化任务设置对象
   ....:

In [17]: setting.setOptimizeTarget('capital')            # 设置优化排序的目标是策略净盈利
   ....: setting.addParameter('atrLength', 12, 20, 2)    # 增加第一个优化参数atrLength，起始12，结束20，步进2
   ....: setting.addParameter('atrMaLength', 20, 30, 5)  # 增加第二个优化参数atrMaLength，起始20，结束30，步进5
   ....: setting.addParameter('rsiLength', 5)            # 增加一个固定数值的参数
   ....:

In [18]: ## 运行单进程优化函数，自动输出结果
   ....: engine.runOptimization(AtrRsiStrategy, setting)    
   ....:
2017-02-08 19:06:19.279000	------------------------------
2017-02-08 19:06:19.280000	setting: {'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 12}
2017-02-08 19:06:19.282000	开始载入数据
2017-02-08 19:06:21.034000	载入完成，数据量：341851
2017-02-08 19:06:21.034000	开始回测
2017-02-08 19:06:21.050000	策略初始化完成
2017-02-08 19:06:21.050000	策略启动完成
2017-02-08 19:06:21.050000	开始回放数据
2017-02-08 19:06:35.728000	数据回放结束
2017-02-08 19:06:35.728000	计算回测结果
2017-02-08 19:06:35.923000	------------------------------
2017-02-08 19:06:35.924000	setting: {'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 12}
2017-02-08 19:06:35.925000	开始载入数据
2017-02-08 19:06:36.015000	载入完成，数据量：341851
2017-02-08 19:06:36.015000	开始回测
2017-02-08 19:06:36.030000	策略初始化完成
2017-02-08 19:06:36.030000	策略启动完成
2017-02-08 19:06:36.030000	开始回放数据
2017-02-08 19:06:50.140000	数据回放结束
2017-02-08 19:06:50.140000	计算回测结果
...
2017-02-08 19:09:30.237000	------------------------------
2017-02-08 19:09:30.237000	setting: {'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 20}
2017-02-08 19:09:30.239000	开始载入数据
2017-02-08 19:09:30.330000	载入完成，数据量：341851
2017-02-08 19:09:30.330000	开始回测
2017-02-08 19:09:30.343000	策略初始化完成
2017-02-08 19:09:30.343000	策略启动完成
2017-02-08 19:09:30.343000	开始回放数据
2017-02-08 19:09:44.499000	数据回放结束
2017-02-08 19:09:44.499000	计算回测结果
2017-02-08 19:09:44.696000	------------------------------
2017-02-08 19:09:44.696000	setting: {'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 20}
2017-02-08 19:09:44.697000	开始载入数据
2017-02-08 19:09:44.787000	载入完成，数据量：341851
2017-02-08 19:09:44.787000	开始回测
2017-02-08 19:09:44.801000	策略初始化完成
2017-02-08 19:09:44.801000	策略启动完成
2017-02-08 19:09:44.801000	开始回放数据
2017-02-08 19:09:58.942000	数据回放结束
2017-02-08 19:09:58.942000	计算回测结果
2017-02-08 19:09:59.242000	------------------------------
2017-02-08 19:09:59.242000	优化结果：
2017-02-08 19:09:59.242000	["{'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 20}"]: 1127713.85011
2017-02-08 19:09:59.242000	["{'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 18}"]: 1030743.75807
2017-02-08 19:09:59.242000	["{'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 16}"]: 983294.726285
2017-02-08 19:09:59.242000	["{'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 18}"]: 975329.10312
2017-02-08 19:09:59.242000	["{'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 12}"]: 949746.520421
2017-02-08 19:09:59.242000	["{'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 12}"]: 914875.145592
2017-02-08 19:09:59.243000	["{'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 16}"]: 899113.140024
2017-02-08 19:09:59.243000	["{'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 14}"]: 896378.557181
2017-02-08 19:09:59.243000	["{'atrMaLength': 30, 'rsiLength': 5, 'atrLength': 14}"]: 893726.622984
2017-02-08 19:09:59.243000	["{'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 16}"]: 883947.771514
2017-02-08 19:09:59.243000	["{'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 14}"]: 873221.532605
2017-02-08 19:09:59.243000	["{'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 12}"]: 857260.355525
2017-02-08 19:09:59.243000	["{'atrMaLength': 20, 'rsiLength': 5, 'atrLength': 20}"]: 852615.557093
2017-02-08 19:09:59.243000	["{'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 20}"]: 790618.233326
2017-02-08 19:09:59.243000	["{'atrMaLength': 25, 'rsiLength': 5, 'atrLength': 18}"]: 726949.447939</code></pre> 
  <p>优化结果的输出格式是：参数组合：优化目标值</p> 
  <h2>多进程优化</h2> 
  <p>本节主要讲解参数的优化的多进程模式。由于Python的GIL原因，多进程模式可以更好的利用CPU的多核，提高优化参数速度。由于vnpy已经提供RPC模块，所以可以基于RPC模块实现分布式参数优化。</p> 
  <p><strong>多进程参数优化主流程图和优化函数流程图</strong>&nbsp;<img alt="Markdown" class="has" src="https://camo.githubusercontent.com/8991d8950ead644be675fabaa2e2a9eaf7486e22/687474703a2f2f766e707977696b692e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f2545372541442539362545372539352541352545352539422539452545362542352538425f2545392541442539342545352538352538332f254536253937254130254536254130253837254539254132253938352e706e673f457870697265733d31353138343138383035264f53534163636573734b657949643d544d502e4151484e5941596c79637a4a794c6f36726d5638584e384e373278713564716d726e6d7346454f62426b41324b54737767526e4c51527a61674d4a6341444174416852546b786a4159464644304e78354e6c496f6964654658686b4b78414956414a4d794235384a50316c477a334a512d745a47787554786a6a6177265369676e61747572653d4a32763068656c6969613067364b77775a6c756a6c4a556e427938253344"></p> 
  <h3>多进程参数优化主流程详解</h3> 
  <p>用户只需关注多进程参数优化主流程，这里以AtrRsiStrategy策略为例，对每个步骤结合代码做以下详解。跟普通模式的参数优化的区别是最后调用多进程优化接口。笔者电脑上，示例中AtrRsiStrategy策略多进程回测的耗时约为52秒。</p> 
  <ol>
   <li>对用户来讲，首先要创建回测引擎实例</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 创建回测引擎
engine = BacktestingEngine()</code></pre> 
  <ol>
   <li>设置回测引擎的相关参数(回测模式，回测起始日期，数据库)。</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 设置引擎的回测模式为K线
engine.setBacktestingMode(engine.BAR_MODE)

# 设置回测用的数据起始日期和结束日期
engine.setStartDate('20110101')
engine.setEndDate('20161231')

# 载入历史数据到引擎中
engine.setDatabase(MINUTE_DB_NAME, 'IF0000')</code></pre> 
  <ol>
   <li>设置产品（合约）相关参数(滑点，佣金，合约大小)。这里回测的合约是股指，滑点设为股指1跳，股指一手每点价格为300元</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 设置产品相关参数
engine.setSlippage(0.2)     # 股指1跳
engine.setRate(0.3/10000)   # 万0.3
engine.setSize(300)         # 股指合约大小    </code></pre> 
  <ol>
   <li>创建优化参数实例</li> 
  </ol>
  <pre>
<code class="language-html hljs"># 创建优化参数设置实例
setting = OptimizationSetting()                 # 新建一个优化任务设置对象</code></pre> 
  <ol>
   <li>设置优化目标和参数</li> 
  </ol>
  <pre>
<code class="language-html hljs">setting.setOptimizeTarget('capital')            # 设置优化排序的目标是策略净盈利
setting.addParameter('atrLength', 12, 20, 2)    # 增加第一个优化参数atrLength，起始12，结束20，步进2
setting.addParameter('atrMaLength', 20, 30, 5)  # 增加第二个优化参数atrMaLength，起始20，结束30，步进5
setting.addParameter('rsiLength', 5)            # 增加一个固定数值的参数</code></pre> 
  <ol>
   <li>运行多进程优化</li> 
  </ol>
  <pre>
<code class="language-html hljs">## 运行多进程优化函数，自动输出结果
engine.runParallelOptimization(AtrRsiStrategy, setting)   </code></pre> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/IAlexanderI/article/details/81566021,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/IAlexanderI/article/details/81566021,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
