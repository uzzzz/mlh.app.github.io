<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链实现代码详细分析（Python） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链实现代码详细分析（Python）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="代码 import hashlib import json import requests from textwrap import dedent from time import time from uuid import uuid4 from urllib.parse import urlparse from flask import Flask, jsonify, request class Blockchain(object): def __init__(self): ... self.nodes = set() # 用 set 来储存节点，避免重复添加节点. ... self.chain = [] self.current_transactions = [] # 创建创世区块 self.new_block(previous_hash=1, proof=100) def reister_node(self, address): &quot;&quot;&quot; 在节点列表中添加一个新节点 :param address: :return: &quot;&quot;&quot; prsed_url = urlparse(address) self.nodes.add(prsed_url.netloc) def valid_chain(self, chain): &quot;&quot;&quot; 确定一个给定的区块链是否有效 :param chain: :return: &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(&#39;{}&#39;.format(last_block)) print(&#39;{}&#39;.format(block)) print(&quot;\n______\n&quot;) # 检查block的散列是否正确 if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # 检查工作证明是否正确 if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def ressolve_conflicts(self): &quot;&quot;&quot; 共识算法 :return: &quot;&quot;&quot; neighbours = self.nodes new_chain = None # 寻找最长链条 max_length = len(self.chain) # 获取并验证网络中的所有节点的链 for node in neighbours: response = requests.get(&#39;http://{}/chain&#39;.format(node)) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # 检查长度是否长，链是否有效 if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # 如果发现一个新的有效链比当前的长，就替换当前的链 if new_chain: self.chain = new_chain return True return False def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 创建一个新的块并将其添加到链中 :param proof: 由工作证明算法生成证明 :param previous_hash: 前一个区块的hash值 :return: 新区块 &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 重置当前交易记录 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): # 将新事务添加到事务列表中 &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender:发送方的地址 :param recipient:收信人地址 :param amount:数量 :return:保存该事务的块的索引 &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @staticmethod def hash(block): &quot;&quot;&quot; 给一个区块生成 SHA-256 值 :param block: :return: &quot;&quot;&quot; # 必须确保这个字典（区块）是经过排序的，否则将会得到不一致的散列 block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): # 返回链中的最后一个块 return self.chain[-1] def proof_of_work(self, last_proof): # 工作算法的简单证明 proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): # 验证证明 guess = (&#39;{}{}&#39;.format(last_proof, proof)).encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; # 实例化节点 app = Flask(__name__) # 为该节点生成一个全局惟一的地址 node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # 实例化Blockchain类 blockchain = Blockchain() # 进行挖矿请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # 运行工作算法的证明来获得下一个证明。 last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 必须得到一份寻找证据的奖赏。 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # 通过将其添加到链中来构建新的块 previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 # 创建交易请求 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transactions(): values = request.get_json() # 检查所需要的字段是否位于POST的data中 required = [&#39;seder&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in request): return &#39;Missing values&#39;, 400 # 创建一个新的事物 index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 # 获取所有快信息 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 # 添加节点 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 # 解决冲突 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 类 BlockChain分析: 构造函数： 创建一个变量nodes来存储所有的节点(保证节点之间互不相同) 创建一个变量chain来存储链 调用new_block函数创建创世块(设置初始hash值(创世块的previous hash), 检验值设置为100) hash函数(static method): 将整个块的转成一个string,，然后再通过这个string生成hash值，并转成16进制 值得称赞的是，这里要确保通过json将dict转成string的过程中，需要保证keys的顺序。只有这样，才能确保整个hash映射到整个块的时候，得到的结果具有唯一性 last_block函数(通过@property操作符变成了一个属性) 会返回这个blockChain中最后一个块 valid_proof证明函数 传进来的两个检验值，一个是last_proof 还有一个就是proof。 在直接放在一起之后，通过哈希映射之中的sha256映射(再转16进制) 最后，通过判断上面得到的最终的哈希值来判断前4位是不是都是0 如果4个0开头，那么就是合法，否者就是不合法的 proof_of_work函数 通过传进来的那个函数中的参数(也就是前一个的proof值) 通过循环来逐步找到对应的当前proof使得上面的valid_proof函数返回的是一个true值 reister_node()函数 传进来的参数为address,表示地址。 这个参数必须是网页url，或者是对应的ip地址。 经过解析之后，节点的命名就是一个ip地址或者是网页地址（网络层面上跟ip地址等价） valid_chain()函数 这里会传进来一个chain 可以理解为一个列表之类的可遍历的对象。 然后判断后一个块的previous_hash是不是真的就是前一个块做了hash的结果 同时也需要判断，这个检验值是否合法 直到这些都满足之后，才算是ok的 new_block函数： 创建一个新的块。语言层面上，其实就是一个字典。每个块存储的交易都是整个类一开始就公有的 index设置为链长度+1 ‘previous_hash’:previous_hash or self.hash(self.chain[-1]) 这个地方有点意思。 如果是创世块，这里就会直接得到对应的结果 ressolve_conflicts函数： 先循环检验每个节点。来进行判断 要求子节点存储的长度要小于总长度 要求子节点存储的链也必须是合法的 如果有合法的，并且子节点上的链长度更长那就复制给main服务器 如果发生过改变，就返回True else return false 阅读更多" />
<meta property="og:description" content="代码 import hashlib import json import requests from textwrap import dedent from time import time from uuid import uuid4 from urllib.parse import urlparse from flask import Flask, jsonify, request class Blockchain(object): def __init__(self): ... self.nodes = set() # 用 set 来储存节点，避免重复添加节点. ... self.chain = [] self.current_transactions = [] # 创建创世区块 self.new_block(previous_hash=1, proof=100) def reister_node(self, address): &quot;&quot;&quot; 在节点列表中添加一个新节点 :param address: :return: &quot;&quot;&quot; prsed_url = urlparse(address) self.nodes.add(prsed_url.netloc) def valid_chain(self, chain): &quot;&quot;&quot; 确定一个给定的区块链是否有效 :param chain: :return: &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(&#39;{}&#39;.format(last_block)) print(&#39;{}&#39;.format(block)) print(&quot;\n______\n&quot;) # 检查block的散列是否正确 if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # 检查工作证明是否正确 if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def ressolve_conflicts(self): &quot;&quot;&quot; 共识算法 :return: &quot;&quot;&quot; neighbours = self.nodes new_chain = None # 寻找最长链条 max_length = len(self.chain) # 获取并验证网络中的所有节点的链 for node in neighbours: response = requests.get(&#39;http://{}/chain&#39;.format(node)) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # 检查长度是否长，链是否有效 if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # 如果发现一个新的有效链比当前的长，就替换当前的链 if new_chain: self.chain = new_chain return True return False def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 创建一个新的块并将其添加到链中 :param proof: 由工作证明算法生成证明 :param previous_hash: 前一个区块的hash值 :return: 新区块 &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 重置当前交易记录 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): # 将新事务添加到事务列表中 &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender:发送方的地址 :param recipient:收信人地址 :param amount:数量 :return:保存该事务的块的索引 &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @staticmethod def hash(block): &quot;&quot;&quot; 给一个区块生成 SHA-256 值 :param block: :return: &quot;&quot;&quot; # 必须确保这个字典（区块）是经过排序的，否则将会得到不一致的散列 block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): # 返回链中的最后一个块 return self.chain[-1] def proof_of_work(self, last_proof): # 工作算法的简单证明 proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): # 验证证明 guess = (&#39;{}{}&#39;.format(last_proof, proof)).encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; # 实例化节点 app = Flask(__name__) # 为该节点生成一个全局惟一的地址 node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # 实例化Blockchain类 blockchain = Blockchain() # 进行挖矿请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # 运行工作算法的证明来获得下一个证明。 last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 必须得到一份寻找证据的奖赏。 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # 通过将其添加到链中来构建新的块 previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 # 创建交易请求 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transactions(): values = request.get_json() # 检查所需要的字段是否位于POST的data中 required = [&#39;seder&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in request): return &#39;Missing values&#39;, 400 # 创建一个新的事物 index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 # 获取所有快信息 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 # 添加节点 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 # 解决冲突 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 类 BlockChain分析: 构造函数： 创建一个变量nodes来存储所有的节点(保证节点之间互不相同) 创建一个变量chain来存储链 调用new_block函数创建创世块(设置初始hash值(创世块的previous hash), 检验值设置为100) hash函数(static method): 将整个块的转成一个string,，然后再通过这个string生成hash值，并转成16进制 值得称赞的是，这里要确保通过json将dict转成string的过程中，需要保证keys的顺序。只有这样，才能确保整个hash映射到整个块的时候，得到的结果具有唯一性 last_block函数(通过@property操作符变成了一个属性) 会返回这个blockChain中最后一个块 valid_proof证明函数 传进来的两个检验值，一个是last_proof 还有一个就是proof。 在直接放在一起之后，通过哈希映射之中的sha256映射(再转16进制) 最后，通过判断上面得到的最终的哈希值来判断前4位是不是都是0 如果4个0开头，那么就是合法，否者就是不合法的 proof_of_work函数 通过传进来的那个函数中的参数(也就是前一个的proof值) 通过循环来逐步找到对应的当前proof使得上面的valid_proof函数返回的是一个true值 reister_node()函数 传进来的参数为address,表示地址。 这个参数必须是网页url，或者是对应的ip地址。 经过解析之后，节点的命名就是一个ip地址或者是网页地址（网络层面上跟ip地址等价） valid_chain()函数 这里会传进来一个chain 可以理解为一个列表之类的可遍历的对象。 然后判断后一个块的previous_hash是不是真的就是前一个块做了hash的结果 同时也需要判断，这个检验值是否合法 直到这些都满足之后，才算是ok的 new_block函数： 创建一个新的块。语言层面上，其实就是一个字典。每个块存储的交易都是整个类一开始就公有的 index设置为链长度+1 ‘previous_hash’:previous_hash or self.hash(self.chain[-1]) 这个地方有点意思。 如果是创世块，这里就会直接得到对应的结果 ressolve_conflicts函数： 先循环检验每个节点。来进行判断 要求子节点存储的长度要小于总长度 要求子节点存储的链也必须是合法的 如果有合法的，并且子节点上的链长度更长那就复制给main服务器 如果发生过改变，就返回True else return false 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/10/1e1898d345fa93b7112dfd7230c8ba5b.html" />
<meta property="og:url" content="https://mlh.app/2018/08/10/1e1898d345fa93b7112dfd7230c8ba5b.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"代码 import hashlib import json import requests from textwrap import dedent from time import time from uuid import uuid4 from urllib.parse import urlparse from flask import Flask, jsonify, request class Blockchain(object): def __init__(self): ... self.nodes = set() # 用 set 来储存节点，避免重复添加节点. ... self.chain = [] self.current_transactions = [] # 创建创世区块 self.new_block(previous_hash=1, proof=100) def reister_node(self, address): &quot;&quot;&quot; 在节点列表中添加一个新节点 :param address: :return: &quot;&quot;&quot; prsed_url = urlparse(address) self.nodes.add(prsed_url.netloc) def valid_chain(self, chain): &quot;&quot;&quot; 确定一个给定的区块链是否有效 :param chain: :return: &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(&#39;{}&#39;.format(last_block)) print(&#39;{}&#39;.format(block)) print(&quot;\\n______\\n&quot;) # 检查block的散列是否正确 if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # 检查工作证明是否正确 if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def ressolve_conflicts(self): &quot;&quot;&quot; 共识算法 :return: &quot;&quot;&quot; neighbours = self.nodes new_chain = None # 寻找最长链条 max_length = len(self.chain) # 获取并验证网络中的所有节点的链 for node in neighbours: response = requests.get(&#39;http://{}/chain&#39;.format(node)) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # 检查长度是否长，链是否有效 if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # 如果发现一个新的有效链比当前的长，就替换当前的链 if new_chain: self.chain = new_chain return True return False def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 创建一个新的块并将其添加到链中 :param proof: 由工作证明算法生成证明 :param previous_hash: 前一个区块的hash值 :return: 新区块 &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 重置当前交易记录 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): # 将新事务添加到事务列表中 &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender:发送方的地址 :param recipient:收信人地址 :param amount:数量 :return:保存该事务的块的索引 &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @staticmethod def hash(block): &quot;&quot;&quot; 给一个区块生成 SHA-256 值 :param block: :return: &quot;&quot;&quot; # 必须确保这个字典（区块）是经过排序的，否则将会得到不一致的散列 block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): # 返回链中的最后一个块 return self.chain[-1] def proof_of_work(self, last_proof): # 工作算法的简单证明 proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): # 验证证明 guess = (&#39;{}{}&#39;.format(last_proof, proof)).encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; # 实例化节点 app = Flask(__name__) # 为该节点生成一个全局惟一的地址 node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # 实例化Blockchain类 blockchain = Blockchain() # 进行挖矿请求 @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # 运行工作算法的证明来获得下一个证明。 last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 必须得到一份寻找证据的奖赏。 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # 通过将其添加到链中来构建新的块 previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 # 创建交易请求 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transactions(): values = request.get_json() # 检查所需要的字段是否位于POST的data中 required = [&#39;seder&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in request): return &#39;Missing values&#39;, 400 # 创建一个新的事物 index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 # 获取所有快信息 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 # 添加节点 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 # 解决冲突 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 类 BlockChain分析: 构造函数： 创建一个变量nodes来存储所有的节点(保证节点之间互不相同) 创建一个变量chain来存储链 调用new_block函数创建创世块(设置初始hash值(创世块的previous hash), 检验值设置为100) hash函数(static method): 将整个块的转成一个string,，然后再通过这个string生成hash值，并转成16进制 值得称赞的是，这里要确保通过json将dict转成string的过程中，需要保证keys的顺序。只有这样，才能确保整个hash映射到整个块的时候，得到的结果具有唯一性 last_block函数(通过@property操作符变成了一个属性) 会返回这个blockChain中最后一个块 valid_proof证明函数 传进来的两个检验值，一个是last_proof 还有一个就是proof。 在直接放在一起之后，通过哈希映射之中的sha256映射(再转16进制) 最后，通过判断上面得到的最终的哈希值来判断前4位是不是都是0 如果4个0开头，那么就是合法，否者就是不合法的 proof_of_work函数 通过传进来的那个函数中的参数(也就是前一个的proof值) 通过循环来逐步找到对应的当前proof使得上面的valid_proof函数返回的是一个true值 reister_node()函数 传进来的参数为address,表示地址。 这个参数必须是网页url，或者是对应的ip地址。 经过解析之后，节点的命名就是一个ip地址或者是网页地址（网络层面上跟ip地址等价） valid_chain()函数 这里会传进来一个chain 可以理解为一个列表之类的可遍历的对象。 然后判断后一个块的previous_hash是不是真的就是前一个块做了hash的结果 同时也需要判断，这个检验值是否合法 直到这些都满足之后，才算是ok的 new_block函数： 创建一个新的块。语言层面上，其实就是一个字典。每个块存储的交易都是整个类一开始就公有的 index设置为链长度+1 ‘previous_hash’:previous_hash or self.hash(self.chain[-1]) 这个地方有点意思。 如果是创世块，这里就会直接得到对应的结果 ressolve_conflicts函数： 先循环检验每个节点。来进行判断 要求子节点存储的长度要小于总长度 要求子节点存储的链也必须是合法的 如果有合法的，并且子节点上的链长度更长那就复制给main服务器 如果发生过改变，就返回True else return false 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/10/1e1898d345fa93b7112dfd7230c8ba5b.html","headline":"区块链实现代码详细分析（Python）","dateModified":"2018-08-10T00:00:00+08:00","datePublished":"2018-08-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/10/1e1898d345fa93b7112dfd7230c8ba5b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链实现代码详细分析（Python）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h2 id="代码">代码</h2> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> textwrap <span class="hljs-keyword">import</span> dedent
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4
<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse
<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, request


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        ...
        self.nodes = set()
        <span class="hljs-comment"># 用 set 来储存节点，避免重复添加节点.</span>
        ...
        self.chain = []
        self.current_transactions = []

        <span class="hljs-comment"># 创建创世区块</span>
        self.new_block(previous_hash=<span class="hljs-number">1</span>, proof=<span class="hljs-number">100</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reister_node</span><span class="hljs-params">(self, address)</span>:</span>
        <span class="hljs-string">""" 在节点列表中添加一个新节点 :param address: :return: """</span>
        prsed_url = urlparse(address)
        self.nodes.add(prsed_url.netloc)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_chain</span><span class="hljs-params">(self, chain)</span>:</span>
        <span class="hljs-string">""" 确定一个给定的区块链是否有效 :param chain: :return: """</span>
        last_block = chain[<span class="hljs-number">0</span>]
        current_index = <span class="hljs-number">1</span>

        <span class="hljs-keyword">while</span> current_index &lt; len(chain):
            block = chain[current_index]
            print(<span class="hljs-string">'{}'</span>.format(last_block))
            print(<span class="hljs-string">'{}'</span>.format(block))
            print(<span class="hljs-string">"\n______\n"</span>)
            <span class="hljs-comment"># 检查block的散列是否正确</span>
            <span class="hljs-keyword">if</span> block[<span class="hljs-string">'previous_hash'</span>] != self.hash(last_block):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-comment"># 检查工作证明是否正确</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.valid_proof(last_block[<span class="hljs-string">'proof'</span>], block[<span class="hljs-string">'proof'</span>]):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

            last_block = block
            current_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ressolve_conflicts</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">""" 共识算法 :return: """</span>
        neighbours = self.nodes
        new_chain = <span class="hljs-keyword">None</span>
        <span class="hljs-comment"># 寻找最长链条</span>
        max_length = len(self.chain)

        <span class="hljs-comment"># 获取并验证网络中的所有节点的链</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> neighbours:
            response = requests.get(<span class="hljs-string">'http://{}/chain'</span>.format(node))

            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
                length = response.json()[<span class="hljs-string">'length'</span>]
                chain = response.json()[<span class="hljs-string">'chain'</span>]

                <span class="hljs-comment"># 检查长度是否长，链是否有效</span>
                <span class="hljs-keyword">if</span> length &gt; max_length <span class="hljs-keyword">and</span> self.valid_chain(chain):
                    max_length = length
                    new_chain = chain

        <span class="hljs-comment"># 如果发现一个新的有效链比当前的长，就替换当前的链</span>
        <span class="hljs-keyword">if</span> new_chain:
            self.chain = new_chain
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_block</span><span class="hljs-params">(self, proof, previous_hash=None)</span>:</span>
        <span class="hljs-string">""" 创建一个新的块并将其添加到链中 :param proof: 由工作证明算法生成证明 :param previous_hash: 前一个区块的hash值 :return: 新区块 """</span>
        block = {
            <span class="hljs-string">'index'</span>: len(self.chain) + <span class="hljs-number">1</span>,
            <span class="hljs-string">'timestamp'</span>: time(),
            <span class="hljs-string">'transactions'</span>: self.current_transactions,
            <span class="hljs-string">'proof'</span>: proof,
            <span class="hljs-string">'previous_hash'</span>: previous_hash <span class="hljs-keyword">or</span> self.hash(self.chain[-<span class="hljs-number">1</span>]),
        }

        <span class="hljs-comment"># 重置当前交易记录</span>
        self.current_transactions = []

        self.chain.append(block)
        <span class="hljs-keyword">return</span> block

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">(self, sender, recipient, amount)</span>:</span>
        <span class="hljs-comment"># 将新事务添加到事务列表中</span>
        <span class="hljs-string">""" Creates a new transaction to go into the next mined Block :param sender:发送方的地址 :param recipient:收信人地址 :param amount:数量 :return:保存该事务的块的索引 """</span>
        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })

        <span class="hljs-keyword">return</span> self.last_block[<span class="hljs-string">'index'</span>] + <span class="hljs-number">1</span>

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span><span class="hljs-params">(block)</span>:</span>
        <span class="hljs-string">""" 给一个区块生成 SHA-256 值 :param block: :return: """</span>
        <span class="hljs-comment"># 必须确保这个字典（区块）是经过排序的，否则将会得到不一致的散列</span>
        block_string = json.dumps(block, sort_keys=<span class="hljs-keyword">True</span>).encode()
        <span class="hljs-keyword">return</span> hashlib.sha256(block_string).hexdigest()

    <span class="hljs-decorator">@property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># 返回链中的最后一个块</span>
        <span class="hljs-keyword">return</span> self.chain[-<span class="hljs-number">1</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proof_of_work</span><span class="hljs-params">(self, last_proof)</span>:</span>
        <span class="hljs-comment"># 工作算法的简单证明</span>
        proof = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> self.valid_proof(last_proof, proof) <span class="hljs-keyword">is</span> <span class="hljs-keyword">False</span>:
            proof += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> proof

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_proof</span><span class="hljs-params">(last_proof, proof)</span>:</span>
        <span class="hljs-comment"># 验证证明</span>
        guess = (<span class="hljs-string">'{}{}'</span>.format(last_proof, proof)).encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        <span class="hljs-keyword">return</span> guess_hash[:<span class="hljs-number">4</span>] == <span class="hljs-string">"0000"</span>


<span class="hljs-comment"># 实例化节点</span>
app = Flask(__name__)

<span class="hljs-comment"># 为该节点生成一个全局惟一的地址</span>
node_identifier = str(uuid4()).replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">''</span>)

<span class="hljs-comment"># 实例化Blockchain类</span>
blockchain = Blockchain()


<span class="hljs-comment"># 进行挖矿请求</span>
<span class="hljs-decorator">@app.route('/mine', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># 运行工作算法的证明来获得下一个证明。</span>
    last_block = blockchain.last_block
    last_proof = last_block[<span class="hljs-string">'proof'</span>]
    proof = blockchain.proof_of_work(last_proof)

    <span class="hljs-comment"># 必须得到一份寻找证据的奖赏。</span>
    blockchain.new_transaction(
        sender=<span class="hljs-string">"0"</span>,
        recipient=node_identifier,
        amount=<span class="hljs-number">1</span>,
    )

    <span class="hljs-comment"># 通过将其添加到链中来构建新的块</span>
    previous_hash = blockchain.hash(last_block)
    block = blockchain.new_block(proof, previous_hash)
    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">"New Block Forged"</span>,
        <span class="hljs-string">'index'</span>: block[<span class="hljs-string">'index'</span>],
        <span class="hljs-string">'transactions'</span>: block[<span class="hljs-string">'transactions'</span>],
        <span class="hljs-string">'proof'</span>: block[<span class="hljs-string">'proof'</span>],
        <span class="hljs-string">'previous_hash'</span>: block[<span class="hljs-string">'previous_hash'</span>],
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-comment"># 创建交易请求</span>
<span class="hljs-decorator">@app.route('/transactions/new', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transactions</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()

    <span class="hljs-comment"># 检查所需要的字段是否位于POST的data中</span>
    required = [<span class="hljs-string">'seder'</span>, <span class="hljs-string">'recipient'</span>, <span class="hljs-string">'amount'</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all(k <span class="hljs-keyword">in</span> values <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> request):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Missing values'</span>, <span class="hljs-number">400</span>

    <span class="hljs-comment"># 创建一个新的事物</span>
    index = blockchain.new_transaction(values[<span class="hljs-string">'sender'</span>], values[<span class="hljs-string">'recipient'</span>], values[<span class="hljs-string">'amount'</span>])
    response = {<span class="hljs-string">'message'</span>: <span class="hljs-string">'Transaction will be added to Block {}'</span>.format(index)}
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-comment"># 获取所有快信息</span>
<span class="hljs-decorator">@app.route('/chain', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">full_chain</span><span class="hljs-params">()</span>:</span>
    response = {
        <span class="hljs-string">'chain'</span>: blockchain.chain,
        <span class="hljs-string">'length'</span>: len(blockchain.chain),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-comment"># 添加节点</span>
<span class="hljs-decorator">@app.route('/nodes/register', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_nodes</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()
    nodes = values.get(<span class="hljs-string">'nodes'</span>)
    <span class="hljs-keyword">if</span> nodes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Error: Please supply a valid list of nodes"</span>, <span class="hljs-number">400</span>

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:
        blockchain.register_node(node)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New nodes have been added'</span>,
        <span class="hljs-string">'total_nodes'</span>: list(blockchain.nodes),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-comment"># 解决冲突</span>
<span class="hljs-decorator">@app.route('/nodes/resolve', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consensus</span><span class="hljs-params">()</span>:</span>
    replaced = blockchain.resolve_conflicts()

    <span class="hljs-keyword">if</span> replaced:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain was replaced'</span>,
            <span class="hljs-string">'new_chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">else</span>:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain is authoritative'</span>,
            <span class="hljs-string">'chain'</span>: blockchain.chain
        }

    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, port=<span class="hljs-number">5000</span>)
</code></pre> 
  <h3 id="类-blockchain分析">类 BlockChain分析:</h3> 
  <p><strong>构造函数：</strong></p> 
  <ul> 
   <li>创建一个变量nodes来存储所有的节点(保证节点之间互不相同)</li> 
   <li>创建一个变量chain来存储链</li> 
   <li>调用new_block函数创建创世块(设置初始hash值(创世块的previous hash), 检验值设置为100)</li> 
  </ul> 
  <p><strong>hash函数(static method):</strong></p> 
  <ul> 
   <li>将整个块的转成一个string,，然后再通过这个string生成hash值，并转成16进制</li> 
   <li>值得称赞的是，这里要确保通过json将dict转成string的过程中，需要保证keys的顺序。只有这样，才能确保整个hash映射到整个块的时候，得到的结果具有唯一性</li> 
  </ul> 
  <p><strong>last_block函数(通过@property操作符变成了一个属性)</strong></p> 
  <ul> 
   <li>会返回这个blockChain中最后一个块</li> 
  </ul> 
  <p><strong>valid_proof证明函数</strong></p> 
  <ul> 
   <li>传进来的两个检验值，一个是last_proof 还有一个就是proof。</li> 
   <li>在直接放在一起之后，通过哈希映射之中的sha256映射(再转16进制)</li> 
   <li>最后，通过判断上面得到的最终的哈希值来判断前4位是不是都是0</li> 
   <li>如果4个0开头，那么就是合法，否者就是不合法的</li> 
  </ul> 
  <p><strong>proof_of_work函数</strong></p> 
  <ul> 
   <li>通过传进来的那个函数中的参数(也就是前一个的proof值)</li> 
   <li>通过循环来逐步找到对应的当前proof使得上面的valid_proof函数返回的是一个true值</li> 
  </ul> 
  <p><strong>reister_node()函数</strong></p> 
  <ul> 
   <li>传进来的参数为<strong>address</strong>,表示地址。</li> 
   <li>这个参数必须是网页url，或者是对应的ip地址。</li> 
   <li>经过解析之后，节点的命名就是一个ip地址或者是网页地址（网络层面上跟ip地址等价）</li> 
  </ul> 
  <p><strong>valid_chain()函数</strong></p> 
  <ul> 
   <li>这里会传进来一个chain 可以理解为一个列表之类的可遍历的对象。</li> 
   <li>然后判断后一个块的previous_hash是不是真的就是前一个块做了hash的结果</li> 
   <li>同时也需要判断，这个检验值是否合法</li> 
   <li>直到这些都满足之后，才算是ok的</li> 
  </ul> 
  <p><strong>new_block函数：</strong></p> 
  <ul> 
   <li>创建一个新的块。语言层面上，其实就是一个字典。每个块存储的交易都是整个类一开始就公有的</li> 
   <li>index设置为链长度+1</li> 
   <li>‘previous_hash’:previous_hash or self.hash(self.chain[-1]) 这个地方有点意思。</li> 
   <li>如果是创世块，这里就会直接得到对应的结果</li> 
  </ul> 
  <p><strong>ressolve_conflicts函数：</strong></p> 
  <ul> 
   <li>先循环检验每个节点。来进行判断</li> 
   <li>要求子节点存储的长度要小于总长度</li> 
   <li>要求子节点存储的链也必须是合法的</li> 
   <li>如果有合法的，并且子节点上的链长度更长那就复制给main服务器</li> 
   <li>如果发生过改变，就返回True</li> 
   <li>else return false</li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/a19990412/article/details/81565205,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/a19990412/article/details/81565205,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
