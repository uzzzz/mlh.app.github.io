<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链学习,比特币篇 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链学习,比特币篇" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 关键技术、术语。 先列出比特币系统会用到的技术、术语，详细解释一下。 1SHA-256安全哈希函数 哈希函数是密码学的一个基础知识，具有以下三个特性： 其输入可为任意大小的字符串 它产生固定大小的输出 它能进行有效计算，也就是对于特定的输入字符串，在合理时间内，可以算出哈希函数的输出，哈希值计算的复杂度为O（n）。 要使哈希函数达到密码安全，要求其具有以下特性：（1）哈希阻力，如果无法找到两个值，x和y，x！=y。 而H(x)=H(y)，则称哈希函数H具有碰撞阻力；（2）隐秘性，如果我们知道哈希函数的输出y=H（x），我们没有可行的办法算出输入值x。 哈希函数一个重要应用就是信息摘要，我们确认两个文件是否相同，只需计算比较两个文件的哈希值，文件的信息摘要。记录比较哈希值可以检测文件在服务器是否损害或者蓄意修改。哈希函数对于一个信息生成固定长度的摘要，为我们提供一种记住之前所见事物，并为今后认出这些事物的有效方法。 哈希函数有很多，SHA-256安全哈希函数是一个被比特币采用，并且效果很不错。SHA-256算法输入的最大长度不超过2^64 bit，输入按512-bit分组进行处理，产生的输出256-bit。具体实现可以参考： https://blog.csdn.net/lwanttowin/article/details/53726450 &nbsp; 2哈希指针 哈希指针是一种数据结构，简单来说一个指向数据存储位置及其位置数据的哈希值的指针。一个普通指针可以告诉你数据存储的位置，哈希指针不但告诉你数据存储的位置，并且还可以给你一种方式，让你验证数据没有被篡改过。 &nbsp; 3区块链 通过哈希指针构建一个链表， 我们称这个数据结构为区块链（block chain）。 区块链的每个区块不仅能告诉我们上一个区块的值在哪儿，还包含了该值的摘要，使我们能够验证那个值有没有改变。区块链的一个应用就是可以存储信息的防篡改。如果修改了区块链中任意区块数据的修改，那么将会导致下一个数据块哈希指针的不正确。只要我们锁定区块链的头部数据，我们就可以检测到篡改行为。如下图： 我们可以搭建一个包含很多区块的区块链网络，链表头部哈希指针被称为创世区块。 &nbsp; 4梅克尔树 梅克尔树用哈希指针建立的二叉树。 梅克尔树所有的数据区块都被两两分组，指向这些数据区块的指针被存储在上一层的父节点中，而父节点再次两两分组，一直持续这个过程，直到到达最后树的根节点。记住树最前面的哈希指针，可以通过哈希指针回溯到列表任何位置，这让我们确保数据未被篡改。 隶属证明，为证明某个数据区块是否来自一个梅克尔树，我们只需要找到该数据区块到树根节点的路径，如下图： 1.5 数字签名与哈希函数一起，为讨论加密货币奠定基础。数字签名被认为对纸上签名的数字模拟， 具有两个特性：（1）只有自己可以制作自己的签名，但任何看到它的人都可以验证其有效性；（2）签名只与某个特定文件有关系，因此签名不能用于表明你同意或支持另外一份不同的文件。 数字签名方案由以下三个算法构成： （sk，pk）：=generateKeys（keysize) &nbsp;把keysize作为输入，来产生一对公钥和私钥。私钥被安全保存，并用来签名一段消息；公钥pk是人人都可以找到的，可以用来验证你的签名。 sig:=sign(sk.message)签名过程是把一段消息和私钥作为一个输入，对于消息输出是签名。 isValid: = verify(pk, message, sig) 验证过程是通过把一段消息和签名消息与公钥作为输入，如果返回是真，证明签名属实；如果返回是假，证明签名是假。 generateKeys和sign都可以采用随机算法，verify则需要确定的。我们详细检验数字签名要求具备的两个特性，第一个就是有效签名必须验证通过，就是用密钥sk签署一条消息后，只有有人用pk验证同一消息的签名，该签名必须证实为正确。第二个要求计算上签名不可能伪造。 &nbsp; 6椭圆曲线数字签名 ECDSA 比特币使用的数字签名叫做椭圆曲线数字签名。 &nbsp; 7公钥、私钥与比特币地址 公钥就是身份，让某人能为pk身份发声，他必须知道相应的密钥sk。将公钥视为身份，你就可以随时制定新的身份。通过数字签名方案中的generateKeys程序，生成新的密钥对sk和pk。pk是你可以使用的新身份，sk是相应的密钥。公钥和私钥的体系，帮助引入了去中心化的身份管理的理念。你可以自己作为用户注册，无须到中央机构注册为系统用户。比特币对待身份的方式就是如此。 这些身份在比特币系统中被称为比特币地址，比特币地址其实就是公钥的哈希值。作为去中心化身份管理方案的一部分，它就是凭空捏造的一个身份。 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。私钥、公钥和比特币地址之间的关系如下图所示： 私钥（k）就是一个随机选出的数字而已。生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1 到2^256之间选一个数字”无异。以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD比特币私钥空间的大小是2^256，这是一个非常大的数字。用十进制表示的话，大约是10^77，而可见宇宙被估计只含有10^80个原子。 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。以之前产生的私钥k和与生成点G相乘得到公钥K：K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G。 公钥K 被定义为一个点 K = (x, y)： K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。 这个数学技巧成为证明比特币资金所有权的不可伪造和安全的数字签名的基础。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。如： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy&nbsp;&nbsp;&nbsp;在交易中，比特币地址通常以收款方出现。下图描述了如何从公钥生成比特币地址。 比特币地址产生的完整过程：从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。&nbsp;&nbsp;&nbsp;&nbsp; 同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y：K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 压缩格式公钥，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2&nbsp;mod p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为缀。 压缩后的公钥：K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 8比特币钱包 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 钱包主要有两种类型，（1）非确定性钱包，其中每个密钥都是从随机数独立生成的。密钥彼此无关。（2）确定性钱包，，其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。例如：16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 助记词表示的种子：army van defense carry jealous true garbage claim echo media make crunch 9纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷存储）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。 1.10 硬件钱包 &nbsp; &nbsp; 比特币硬件钱包，Trezor是一个简单的USB设备，具有两个按钮，用于存储密钥和签署交易。 &nbsp; &nbsp; &nbsp; &nbsp; 2 快速开始 下图是展示比特币区块链如何运作的. 了解比特币工作机制, 作为新用户Alice来说，从手机钱包入手是最适合, 一个常见误解是，比特币钱包里含有比特币。 事实上，钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中。用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。 下载Android的”Mycelium”,并安装到手机上, 运行如下: 这个页面最重要的就是比特币地址: &nbsp;1KAZvbKYG8PLczToaNpUxqUMhyHtz9P979. 旁边是比特币地址对应的二维码. 现在还没有比特币，作为新用户来说，从他人处购买比特币是最快捷的方式。接下来就花$10从Joe处购买比特币， 比特币和大多数货币一样，有浮动汇率，有很多网站可以查询当前比特币价格，与Joe协商好汇率后，把$10给Joe，然后打开钱包，选择接收，将显示一个比特币地址及二维码。 Joe在自己的手机钱包选择发送，输入目的比特币地址以及比特币或当地货币的发送的金额，如下图： Joe仔细确认输入后，按发送确认交易。 Joe的比特币钱包就构建了一个交易，从Joe的钱包将0.1比特币发给了Alice提供地址，并用了Joe的私钥签署交易。在很短时间内，网络中大多数良好的节点都会接收到交易，并首次看到Alice的地址。同时Alice的钱包也不断监听比特币网络上发布的交易，寻找与自己钱包地址匹配的内容， 在Joe钱包发送交易的几秒后，Alice的钱包就显示正在接收0.1比特币。确认开始，Alice的地址将Joe交易显示为“未确认”，要确认，一个交易就必须包含在一个区块中，并被添加到区块链，这种情况平均每10分钟发生一次，这工作由矿工挖矿完成。Alice现在就拥有了属于自己的比特币了。 &nbsp; 3 比特币原理 比特币系统与传统银行系统的差别是基于去中心化的信任。比特币系统由用户（用户通过密钥控制钱包）、交易（每一笔交易都会被广播到整个比特币网络）、矿工（通过竞争计算生成在每个节点达成共识的区块链，区块链包含了比特币网络发生的所有交易）组成。 用户发起的交易，一般来说，可以包含一个或多个输入，交易另一面，有一个或多个输出。 两者差额就代表一笔隐含的矿工费。Joe兑换了比特币给Alice， Alice支付Bob咖啡店一笔交易，假定Bob又向Gopesh支付网页设计费，构成交易链如图： 中间一笔交易为Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡，找零0.0845比特币，剩余0.0005比特币作为交易费用，矿工费，越多的矿工费，交易越容易尽快被网络处理。另外，我们可以通过区块链查询站点查询每一币交易，通过 https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2&nbsp;查询到，blockchain explorer是一个作为比特币搜索引擎运行的Web应用程序，它允许您搜索地址，交易和块，并查看它们之间的关系和资金流动。 &nbsp; 这笔交易现在在比特币网络上传播开，但只有被一个称为挖矿的过程验证且加入一个区块后，这个交易才会成为区块链的一部分。 比特币系统的信任是建立在计算（挖矿）基础上，交易被包在一起放进区块中需要极大的计算量来证明，但只需要少量计算就能验证已被证明。 挖矿在比特币系统中有两个重要作用：（1）挖矿节点通过参考比特币的共识规则验证所有交易。 因此，挖矿通过拒绝无效或畸形交易来提供比特币交易的安全性。（2）挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。挖矿在成本和报酬之间取得了良好的平衡。Alice这笔交易最终被包含在277316号区块，该区块共包含了419笔交易，可以通过https://www.blockchain.com/btc/block-height/277316 查看这个区块信息，如图： 下图我们可以看到包含Alice的交易的第277,316号区块。在它之下有277,316个区块（包括0号区块），像链子 一样一个连着一个（区块链），一直连到0号区块，即创世区块。 4 比特币交易 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 我们再来看Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡这笔交易。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的交易看起来与典型的区块浏览器提供的交易非常不同。Alice的交易被解码后是这个样子： { &nbsp;&nbsp;&quot;version&quot;: 1, &nbsp;&nbsp;&quot;locktime&quot;: 0, &nbsp;&nbsp;&quot;vin&quot;: [&nbsp;&nbsp;&nbsp;//交易输入 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;txid&quot;:&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;vout&quot;: 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;sequence&quot;: 4294967295 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;], &nbsp;&nbsp;&quot;vout&quot;: [&nbsp;&nbsp;//交易输出 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.01500000,&nbsp;&nbsp;//一定的比特币 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;&nbsp;&nbsp; //脚本公钥 &nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.08450000, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;] } 比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”（unspent transaction outputs），即UTXO。 所有UTXO的集合被称为UTXO集。当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。通过钱包所控制的密钥，我们可以把这些UTXO花出去。 交易输出包含两部分：（1）一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；（2）确定花费输出所需条件的加密难题（cryptographic puzzle）。这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如下表所示： 交易的两个输出序列化如下加粗部分，0.015比特币的价值是1,500,000 satoshis。 这是十六进制的16 e3 60。在串行化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。scriptPubKey的长度为25个字节，以十六进制显示为19个字节。 交易输入将UTXO（通过引用）标记为将被消费，并通过解锁脚本提供所有权证明。输入包含四个元素：（1）一个交易ID，引用包含正在使用的UTXO的交易；（2）一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）；（3）一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出；（4）一个序列号。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易被序列化以在网络上传输时，它们的输入被编码成字节流。交易输入的序列化格式如下表所示： 是否可以识别下面这些以十六进制表示法表示的字段，交易ID以反转字节顺序序列化，因此以（十六进制）18开头，以79结尾；输出索引为4字节组的“0”，容易识别；scriptSig的长度为139个字节，或十六进制为8b；序列号设置为FFFFFFFF，也容易识别。 大多数交易包含交易费（矿工费），这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。对于挖矿、费用和矿工得到的奖励，在挖矿一章中将有更详细的讨论。交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励；同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中。 5 比特币交易脚本和脚本语言 比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。 放置在UTXO上的锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时 （互不干扰地）执行，以确定这笔交易是否满足支付条件。比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了脚本语言的图灵非完备性，受限制的语言能防止交易验证机制被作为一个漏洞而加以利用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效（请参阅单独执行解锁和锁定脚本部分）。 所有输入都是独立验证的，作为交易总体验证的一部分。由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），曾被称为脚本公钥（scriptPubKey）。由于认识到这种脚本技术存在着更为广泛的可能性，我们又将它称为“锁定脚本”（locking script）。 假设Alice要向Bob支付0.015比特币, Alice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。锁定脚本如下: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_DUP OP_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP_EQUALVERIFY OP_CHECKSIG OP_DUP:复制栈顶数据，然后该数据放置栈顶 OP_HASH160:对栈顶数据执行ripemd160(sha256(data)) (这其实是两次摘要计算，不详述) be10f0a…:bob的比特币地址 OP_EQUALVERIFY:对比栈顶的两个数据，如果相等都被移除 OP_CHECKSIG:验证签名 Bob如果要接收这笔比特币(另一种说法是Bob可以引用该笔输出)，就要给出一个解锁脚本,然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效。解锁脚本如下: 3046022100ba1427639c9f67f2ca1088d0140318a98cb1e84f604dc90ae00ed7a5f9c61cab02210094233d018f2f014a5864c9e0795f13735780cafd51b950f503534a6af246aca30103a63ab88e75116b313c6de384496328df2656156b8ac48c75505cd20a4890f5ab 看起来是一堆数字，其实『签名』和『公钥』（sig &amp; pubkey）的组合。签名是Bob的私钥对该笔交易的信息加密的结果，公钥就是指的Bob的公钥。由于私钥只Bob才知道，所以也只有他才能拿出正确的签名。下面是脚本执行的过程: 简单的几十个字节的脚本，就完成了交易的验证确保该笔转账的合法性。 &nbsp; &nbsp; &nbsp; &nbsp; 在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值哈希类型。签名密钥是用户的私钥，结果是签名： ((Sig = F{sig}(F{hash}(m), dA)))这里的： dA&nbsp;是签名私钥 m&nbsp;是交易（或其部分） Fhash是散列函数 Fsig是签名算法 Sig&nbsp;是结果签名 函数Fsig产生由两个值组成的签名Sig，通常称为R和S：Sig = (R, S) 现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”（Distinguished Encoding Rules）或 DER的国际标准编码方案。 我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名：3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301 该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素： 0x30表示DER序列的开始 0x45&nbsp;- 序列的长度（69字节） 0x02&nbsp;- 一个整数值 0x21&nbsp;- 整数的长度（33字节） R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb 0x02&nbsp;- 接下来是一个整数 0x20&nbsp;- 整数的长度（32字节） S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL） 6 P2P网络架构 比特币采用了基于国际互联网的P2P（peer-to-peer）网络架构。“比特币网络”是按照比特币P2P协议运行的一系列节点的集合。尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。 7 挖矿 挖矿的目的不是创造新的比特币。 这是激励机制。 这种机制实现了去中心化的安全。挖矿确保了比特币系统安全，并且在没有中央权力机构的情况下实现了全网络范围的共识。 新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励计划，同时实现了货币发行。 比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：（1）每个全节点依据综合标准对每个交易进行独立验证（2）通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块（3）每个节点独立的对新区块进行校验并组装进区块链（4）每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。 &nbsp;&nbsp; 如下图,比特币区块链主要有两层基于哈希函数的结构,第一层是区块链上,每个区块头部都有指针指向其前一个区块,第二层是每个区块里,包含所有交易的梅克尔树. 作为矿工,首先要从交易池中选出一系列有效交易并编译成梅克尔树, &nbsp;然后组装出一个新区块,让它的头部指向区块链前一个区块,新区块头部有一个32位随机数, 挖矿工作量证明就是要你不断尝试不同的临时随机数,直到该随机数能使整个区块的哈希值小于目标值. 挖矿参考算法：挖矿算法为SHA256。在挖矿过程中，矿工将比特币的80个字节长度的区块头数据进行两次SHA256运算，运算结果就是一个256位（32字节）长度的字符串。通过比较与当前难度值的大小判断当前区块是否合法。即满足下列条件：&nbsp;SHA256(SHA256(block_header))&lt; difficulty&nbsp;如果不满足上面的条件，则需要在区块头中改变一下随机值，或者使用随机数据填充coinbase交易，这样就能改变区块头的数据，从而找到满足条件的区块。 从2009年以来，比特币的全网算力增长了超过十亿倍。比特币全网算力创新高：46.92EH/s. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算力的表示&nbsp;1 H/S = 每秒一次运算1 KH/S = 1000 H/S，即每秒1千次运算1 MH/S = 1000 KH/S，即每秒100万次运算1 GH/S = 1000 MH/S，即每秒10亿次运算1 TH/S = 1000 GH/S，即每秒1万亿次运算1 PH/S = 1000 TH/S，即每秒1000万亿次运算1 EH/S = 1000 PH/S，即每秒100万万亿次运算 挖矿设备主要经历了从 CPU -&gt; GPU -&gt; FPGA -&gt; ASIC 的变化. 随着参与挖矿的人数越来越多，比特币全网的算力不断上涨，单个设备或少量的算力都很难再挖到比特币。这时候，矿池诞生了。矿池突破地理位置的限制，将分散在全球的矿工及矿场的算力进行联结，一起挖矿。矿池负责信息打包，接入进来的矿场负责竞争记账权。由于集合了很多矿工的算力，所以矿池的算力占比大，挖到比特币的概率更高。加入矿池相当于选择组队挖矿，在矿池中就可以按照你的算力占全矿池的算力比例来给你分配收益。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="1 关键技术、术语。 先列出比特币系统会用到的技术、术语，详细解释一下。 1SHA-256安全哈希函数 哈希函数是密码学的一个基础知识，具有以下三个特性： 其输入可为任意大小的字符串 它产生固定大小的输出 它能进行有效计算，也就是对于特定的输入字符串，在合理时间内，可以算出哈希函数的输出，哈希值计算的复杂度为O（n）。 要使哈希函数达到密码安全，要求其具有以下特性：（1）哈希阻力，如果无法找到两个值，x和y，x！=y。 而H(x)=H(y)，则称哈希函数H具有碰撞阻力；（2）隐秘性，如果我们知道哈希函数的输出y=H（x），我们没有可行的办法算出输入值x。 哈希函数一个重要应用就是信息摘要，我们确认两个文件是否相同，只需计算比较两个文件的哈希值，文件的信息摘要。记录比较哈希值可以检测文件在服务器是否损害或者蓄意修改。哈希函数对于一个信息生成固定长度的摘要，为我们提供一种记住之前所见事物，并为今后认出这些事物的有效方法。 哈希函数有很多，SHA-256安全哈希函数是一个被比特币采用，并且效果很不错。SHA-256算法输入的最大长度不超过2^64 bit，输入按512-bit分组进行处理，产生的输出256-bit。具体实现可以参考： https://blog.csdn.net/lwanttowin/article/details/53726450 &nbsp; 2哈希指针 哈希指针是一种数据结构，简单来说一个指向数据存储位置及其位置数据的哈希值的指针。一个普通指针可以告诉你数据存储的位置，哈希指针不但告诉你数据存储的位置，并且还可以给你一种方式，让你验证数据没有被篡改过。 &nbsp; 3区块链 通过哈希指针构建一个链表， 我们称这个数据结构为区块链（block chain）。 区块链的每个区块不仅能告诉我们上一个区块的值在哪儿，还包含了该值的摘要，使我们能够验证那个值有没有改变。区块链的一个应用就是可以存储信息的防篡改。如果修改了区块链中任意区块数据的修改，那么将会导致下一个数据块哈希指针的不正确。只要我们锁定区块链的头部数据，我们就可以检测到篡改行为。如下图： 我们可以搭建一个包含很多区块的区块链网络，链表头部哈希指针被称为创世区块。 &nbsp; 4梅克尔树 梅克尔树用哈希指针建立的二叉树。 梅克尔树所有的数据区块都被两两分组，指向这些数据区块的指针被存储在上一层的父节点中，而父节点再次两两分组，一直持续这个过程，直到到达最后树的根节点。记住树最前面的哈希指针，可以通过哈希指针回溯到列表任何位置，这让我们确保数据未被篡改。 隶属证明，为证明某个数据区块是否来自一个梅克尔树，我们只需要找到该数据区块到树根节点的路径，如下图： 1.5 数字签名与哈希函数一起，为讨论加密货币奠定基础。数字签名被认为对纸上签名的数字模拟， 具有两个特性：（1）只有自己可以制作自己的签名，但任何看到它的人都可以验证其有效性；（2）签名只与某个特定文件有关系，因此签名不能用于表明你同意或支持另外一份不同的文件。 数字签名方案由以下三个算法构成： （sk，pk）：=generateKeys（keysize) &nbsp;把keysize作为输入，来产生一对公钥和私钥。私钥被安全保存，并用来签名一段消息；公钥pk是人人都可以找到的，可以用来验证你的签名。 sig:=sign(sk.message)签名过程是把一段消息和私钥作为一个输入，对于消息输出是签名。 isValid: = verify(pk, message, sig) 验证过程是通过把一段消息和签名消息与公钥作为输入，如果返回是真，证明签名属实；如果返回是假，证明签名是假。 generateKeys和sign都可以采用随机算法，verify则需要确定的。我们详细检验数字签名要求具备的两个特性，第一个就是有效签名必须验证通过，就是用密钥sk签署一条消息后，只有有人用pk验证同一消息的签名，该签名必须证实为正确。第二个要求计算上签名不可能伪造。 &nbsp; 6椭圆曲线数字签名 ECDSA 比特币使用的数字签名叫做椭圆曲线数字签名。 &nbsp; 7公钥、私钥与比特币地址 公钥就是身份，让某人能为pk身份发声，他必须知道相应的密钥sk。将公钥视为身份，你就可以随时制定新的身份。通过数字签名方案中的generateKeys程序，生成新的密钥对sk和pk。pk是你可以使用的新身份，sk是相应的密钥。公钥和私钥的体系，帮助引入了去中心化的身份管理的理念。你可以自己作为用户注册，无须到中央机构注册为系统用户。比特币对待身份的方式就是如此。 这些身份在比特币系统中被称为比特币地址，比特币地址其实就是公钥的哈希值。作为去中心化身份管理方案的一部分，它就是凭空捏造的一个身份。 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。私钥、公钥和比特币地址之间的关系如下图所示： 私钥（k）就是一个随机选出的数字而已。生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1 到2^256之间选一个数字”无异。以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD比特币私钥空间的大小是2^256，这是一个非常大的数字。用十进制表示的话，大约是10^77，而可见宇宙被估计只含有10^80个原子。 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。以之前产生的私钥k和与生成点G相乘得到公钥K：K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G。 公钥K 被定义为一个点 K = (x, y)： K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。 这个数学技巧成为证明比特币资金所有权的不可伪造和安全的数字签名的基础。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。如： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy&nbsp;&nbsp;&nbsp;在交易中，比特币地址通常以收款方出现。下图描述了如何从公钥生成比特币地址。 比特币地址产生的完整过程：从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。&nbsp;&nbsp;&nbsp;&nbsp; 同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y：K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 压缩格式公钥，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2&nbsp;mod p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为缀。 压缩后的公钥：K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 8比特币钱包 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 钱包主要有两种类型，（1）非确定性钱包，其中每个密钥都是从随机数独立生成的。密钥彼此无关。（2）确定性钱包，，其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。例如：16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 助记词表示的种子：army van defense carry jealous true garbage claim echo media make crunch 9纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷存储）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。 1.10 硬件钱包 &nbsp; &nbsp; 比特币硬件钱包，Trezor是一个简单的USB设备，具有两个按钮，用于存储密钥和签署交易。 &nbsp; &nbsp; &nbsp; &nbsp; 2 快速开始 下图是展示比特币区块链如何运作的. 了解比特币工作机制, 作为新用户Alice来说，从手机钱包入手是最适合, 一个常见误解是，比特币钱包里含有比特币。 事实上，钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中。用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。 下载Android的”Mycelium”,并安装到手机上, 运行如下: 这个页面最重要的就是比特币地址: &nbsp;1KAZvbKYG8PLczToaNpUxqUMhyHtz9P979. 旁边是比特币地址对应的二维码. 现在还没有比特币，作为新用户来说，从他人处购买比特币是最快捷的方式。接下来就花$10从Joe处购买比特币， 比特币和大多数货币一样，有浮动汇率，有很多网站可以查询当前比特币价格，与Joe协商好汇率后，把$10给Joe，然后打开钱包，选择接收，将显示一个比特币地址及二维码。 Joe在自己的手机钱包选择发送，输入目的比特币地址以及比特币或当地货币的发送的金额，如下图： Joe仔细确认输入后，按发送确认交易。 Joe的比特币钱包就构建了一个交易，从Joe的钱包将0.1比特币发给了Alice提供地址，并用了Joe的私钥签署交易。在很短时间内，网络中大多数良好的节点都会接收到交易，并首次看到Alice的地址。同时Alice的钱包也不断监听比特币网络上发布的交易，寻找与自己钱包地址匹配的内容， 在Joe钱包发送交易的几秒后，Alice的钱包就显示正在接收0.1比特币。确认开始，Alice的地址将Joe交易显示为“未确认”，要确认，一个交易就必须包含在一个区块中，并被添加到区块链，这种情况平均每10分钟发生一次，这工作由矿工挖矿完成。Alice现在就拥有了属于自己的比特币了。 &nbsp; 3 比特币原理 比特币系统与传统银行系统的差别是基于去中心化的信任。比特币系统由用户（用户通过密钥控制钱包）、交易（每一笔交易都会被广播到整个比特币网络）、矿工（通过竞争计算生成在每个节点达成共识的区块链，区块链包含了比特币网络发生的所有交易）组成。 用户发起的交易，一般来说，可以包含一个或多个输入，交易另一面，有一个或多个输出。 两者差额就代表一笔隐含的矿工费。Joe兑换了比特币给Alice， Alice支付Bob咖啡店一笔交易，假定Bob又向Gopesh支付网页设计费，构成交易链如图： 中间一笔交易为Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡，找零0.0845比特币，剩余0.0005比特币作为交易费用，矿工费，越多的矿工费，交易越容易尽快被网络处理。另外，我们可以通过区块链查询站点查询每一币交易，通过 https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2&nbsp;查询到，blockchain explorer是一个作为比特币搜索引擎运行的Web应用程序，它允许您搜索地址，交易和块，并查看它们之间的关系和资金流动。 &nbsp; 这笔交易现在在比特币网络上传播开，但只有被一个称为挖矿的过程验证且加入一个区块后，这个交易才会成为区块链的一部分。 比特币系统的信任是建立在计算（挖矿）基础上，交易被包在一起放进区块中需要极大的计算量来证明，但只需要少量计算就能验证已被证明。 挖矿在比特币系统中有两个重要作用：（1）挖矿节点通过参考比特币的共识规则验证所有交易。 因此，挖矿通过拒绝无效或畸形交易来提供比特币交易的安全性。（2）挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。挖矿在成本和报酬之间取得了良好的平衡。Alice这笔交易最终被包含在277316号区块，该区块共包含了419笔交易，可以通过https://www.blockchain.com/btc/block-height/277316 查看这个区块信息，如图： 下图我们可以看到包含Alice的交易的第277,316号区块。在它之下有277,316个区块（包括0号区块），像链子 一样一个连着一个（区块链），一直连到0号区块，即创世区块。 4 比特币交易 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 我们再来看Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡这笔交易。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的交易看起来与典型的区块浏览器提供的交易非常不同。Alice的交易被解码后是这个样子： { &nbsp;&nbsp;&quot;version&quot;: 1, &nbsp;&nbsp;&quot;locktime&quot;: 0, &nbsp;&nbsp;&quot;vin&quot;: [&nbsp;&nbsp;&nbsp;//交易输入 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;txid&quot;:&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;vout&quot;: 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;sequence&quot;: 4294967295 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;], &nbsp;&nbsp;&quot;vout&quot;: [&nbsp;&nbsp;//交易输出 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.01500000,&nbsp;&nbsp;//一定的比特币 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;&nbsp;&nbsp; //脚本公钥 &nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.08450000, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;] } 比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”（unspent transaction outputs），即UTXO。 所有UTXO的集合被称为UTXO集。当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。通过钱包所控制的密钥，我们可以把这些UTXO花出去。 交易输出包含两部分：（1）一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；（2）确定花费输出所需条件的加密难题（cryptographic puzzle）。这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如下表所示： 交易的两个输出序列化如下加粗部分，0.015比特币的价值是1,500,000 satoshis。 这是十六进制的16 e3 60。在串行化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。scriptPubKey的长度为25个字节，以十六进制显示为19个字节。 交易输入将UTXO（通过引用）标记为将被消费，并通过解锁脚本提供所有权证明。输入包含四个元素：（1）一个交易ID，引用包含正在使用的UTXO的交易；（2）一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）；（3）一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出；（4）一个序列号。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易被序列化以在网络上传输时，它们的输入被编码成字节流。交易输入的序列化格式如下表所示： 是否可以识别下面这些以十六进制表示法表示的字段，交易ID以反转字节顺序序列化，因此以（十六进制）18开头，以79结尾；输出索引为4字节组的“0”，容易识别；scriptSig的长度为139个字节，或十六进制为8b；序列号设置为FFFFFFFF，也容易识别。 大多数交易包含交易费（矿工费），这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。对于挖矿、费用和矿工得到的奖励，在挖矿一章中将有更详细的讨论。交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励；同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中。 5 比特币交易脚本和脚本语言 比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。 放置在UTXO上的锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时 （互不干扰地）执行，以确定这笔交易是否满足支付条件。比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了脚本语言的图灵非完备性，受限制的语言能防止交易验证机制被作为一个漏洞而加以利用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效（请参阅单独执行解锁和锁定脚本部分）。 所有输入都是独立验证的，作为交易总体验证的一部分。由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），曾被称为脚本公钥（scriptPubKey）。由于认识到这种脚本技术存在着更为广泛的可能性，我们又将它称为“锁定脚本”（locking script）。 假设Alice要向Bob支付0.015比特币, Alice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。锁定脚本如下: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_DUP OP_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP_EQUALVERIFY OP_CHECKSIG OP_DUP:复制栈顶数据，然后该数据放置栈顶 OP_HASH160:对栈顶数据执行ripemd160(sha256(data)) (这其实是两次摘要计算，不详述) be10f0a…:bob的比特币地址 OP_EQUALVERIFY:对比栈顶的两个数据，如果相等都被移除 OP_CHECKSIG:验证签名 Bob如果要接收这笔比特币(另一种说法是Bob可以引用该笔输出)，就要给出一个解锁脚本,然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效。解锁脚本如下: 3046022100ba1427639c9f67f2ca1088d0140318a98cb1e84f604dc90ae00ed7a5f9c61cab02210094233d018f2f014a5864c9e0795f13735780cafd51b950f503534a6af246aca30103a63ab88e75116b313c6de384496328df2656156b8ac48c75505cd20a4890f5ab 看起来是一堆数字，其实『签名』和『公钥』（sig &amp; pubkey）的组合。签名是Bob的私钥对该笔交易的信息加密的结果，公钥就是指的Bob的公钥。由于私钥只Bob才知道，所以也只有他才能拿出正确的签名。下面是脚本执行的过程: 简单的几十个字节的脚本，就完成了交易的验证确保该笔转账的合法性。 &nbsp; &nbsp; &nbsp; &nbsp; 在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值哈希类型。签名密钥是用户的私钥，结果是签名： ((Sig = F{sig}(F{hash}(m), dA)))这里的： dA&nbsp;是签名私钥 m&nbsp;是交易（或其部分） Fhash是散列函数 Fsig是签名算法 Sig&nbsp;是结果签名 函数Fsig产生由两个值组成的签名Sig，通常称为R和S：Sig = (R, S) 现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”（Distinguished Encoding Rules）或 DER的国际标准编码方案。 我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名：3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301 该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素： 0x30表示DER序列的开始 0x45&nbsp;- 序列的长度（69字节） 0x02&nbsp;- 一个整数值 0x21&nbsp;- 整数的长度（33字节） R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb 0x02&nbsp;- 接下来是一个整数 0x20&nbsp;- 整数的长度（32字节） S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL） 6 P2P网络架构 比特币采用了基于国际互联网的P2P（peer-to-peer）网络架构。“比特币网络”是按照比特币P2P协议运行的一系列节点的集合。尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。 7 挖矿 挖矿的目的不是创造新的比特币。 这是激励机制。 这种机制实现了去中心化的安全。挖矿确保了比特币系统安全，并且在没有中央权力机构的情况下实现了全网络范围的共识。 新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励计划，同时实现了货币发行。 比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：（1）每个全节点依据综合标准对每个交易进行独立验证（2）通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块（3）每个节点独立的对新区块进行校验并组装进区块链（4）每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。 &nbsp;&nbsp; 如下图,比特币区块链主要有两层基于哈希函数的结构,第一层是区块链上,每个区块头部都有指针指向其前一个区块,第二层是每个区块里,包含所有交易的梅克尔树. 作为矿工,首先要从交易池中选出一系列有效交易并编译成梅克尔树, &nbsp;然后组装出一个新区块,让它的头部指向区块链前一个区块,新区块头部有一个32位随机数, 挖矿工作量证明就是要你不断尝试不同的临时随机数,直到该随机数能使整个区块的哈希值小于目标值. 挖矿参考算法：挖矿算法为SHA256。在挖矿过程中，矿工将比特币的80个字节长度的区块头数据进行两次SHA256运算，运算结果就是一个256位（32字节）长度的字符串。通过比较与当前难度值的大小判断当前区块是否合法。即满足下列条件：&nbsp;SHA256(SHA256(block_header))&lt; difficulty&nbsp;如果不满足上面的条件，则需要在区块头中改变一下随机值，或者使用随机数据填充coinbase交易，这样就能改变区块头的数据，从而找到满足条件的区块。 从2009年以来，比特币的全网算力增长了超过十亿倍。比特币全网算力创新高：46.92EH/s. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算力的表示&nbsp;1 H/S = 每秒一次运算1 KH/S = 1000 H/S，即每秒1千次运算1 MH/S = 1000 KH/S，即每秒100万次运算1 GH/S = 1000 MH/S，即每秒10亿次运算1 TH/S = 1000 GH/S，即每秒1万亿次运算1 PH/S = 1000 TH/S，即每秒1000万亿次运算1 EH/S = 1000 PH/S，即每秒100万万亿次运算 挖矿设备主要经历了从 CPU -&gt; GPU -&gt; FPGA -&gt; ASIC 的变化. 随着参与挖矿的人数越来越多，比特币全网的算力不断上涨，单个设备或少量的算力都很难再挖到比特币。这时候，矿池诞生了。矿池突破地理位置的限制，将分散在全球的矿工及矿场的算力进行联结，一起挖矿。矿池负责信息打包，接入进来的矿场负责竞争记账权。由于集合了很多矿工的算力，所以矿池的算力占比大，挖到比特币的概率更高。加入矿池相当于选择组队挖矿，在矿池中就可以按照你的算力占全矿池的算力比例来给你分配收益。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/12/86baa7e0b90f4defa1691625b9388d74.html" />
<meta property="og:url" content="https://mlh.app/2018/08/12/86baa7e0b90f4defa1691625b9388d74.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1 关键技术、术语。 先列出比特币系统会用到的技术、术语，详细解释一下。 1SHA-256安全哈希函数 哈希函数是密码学的一个基础知识，具有以下三个特性： 其输入可为任意大小的字符串 它产生固定大小的输出 它能进行有效计算，也就是对于特定的输入字符串，在合理时间内，可以算出哈希函数的输出，哈希值计算的复杂度为O（n）。 要使哈希函数达到密码安全，要求其具有以下特性：（1）哈希阻力，如果无法找到两个值，x和y，x！=y。 而H(x)=H(y)，则称哈希函数H具有碰撞阻力；（2）隐秘性，如果我们知道哈希函数的输出y=H（x），我们没有可行的办法算出输入值x。 哈希函数一个重要应用就是信息摘要，我们确认两个文件是否相同，只需计算比较两个文件的哈希值，文件的信息摘要。记录比较哈希值可以检测文件在服务器是否损害或者蓄意修改。哈希函数对于一个信息生成固定长度的摘要，为我们提供一种记住之前所见事物，并为今后认出这些事物的有效方法。 哈希函数有很多，SHA-256安全哈希函数是一个被比特币采用，并且效果很不错。SHA-256算法输入的最大长度不超过2^64 bit，输入按512-bit分组进行处理，产生的输出256-bit。具体实现可以参考： https://blog.csdn.net/lwanttowin/article/details/53726450 &nbsp; 2哈希指针 哈希指针是一种数据结构，简单来说一个指向数据存储位置及其位置数据的哈希值的指针。一个普通指针可以告诉你数据存储的位置，哈希指针不但告诉你数据存储的位置，并且还可以给你一种方式，让你验证数据没有被篡改过。 &nbsp; 3区块链 通过哈希指针构建一个链表， 我们称这个数据结构为区块链（block chain）。 区块链的每个区块不仅能告诉我们上一个区块的值在哪儿，还包含了该值的摘要，使我们能够验证那个值有没有改变。区块链的一个应用就是可以存储信息的防篡改。如果修改了区块链中任意区块数据的修改，那么将会导致下一个数据块哈希指针的不正确。只要我们锁定区块链的头部数据，我们就可以检测到篡改行为。如下图： 我们可以搭建一个包含很多区块的区块链网络，链表头部哈希指针被称为创世区块。 &nbsp; 4梅克尔树 梅克尔树用哈希指针建立的二叉树。 梅克尔树所有的数据区块都被两两分组，指向这些数据区块的指针被存储在上一层的父节点中，而父节点再次两两分组，一直持续这个过程，直到到达最后树的根节点。记住树最前面的哈希指针，可以通过哈希指针回溯到列表任何位置，这让我们确保数据未被篡改。 隶属证明，为证明某个数据区块是否来自一个梅克尔树，我们只需要找到该数据区块到树根节点的路径，如下图： 1.5 数字签名与哈希函数一起，为讨论加密货币奠定基础。数字签名被认为对纸上签名的数字模拟， 具有两个特性：（1）只有自己可以制作自己的签名，但任何看到它的人都可以验证其有效性；（2）签名只与某个特定文件有关系，因此签名不能用于表明你同意或支持另外一份不同的文件。 数字签名方案由以下三个算法构成： （sk，pk）：=generateKeys（keysize) &nbsp;把keysize作为输入，来产生一对公钥和私钥。私钥被安全保存，并用来签名一段消息；公钥pk是人人都可以找到的，可以用来验证你的签名。 sig:=sign(sk.message)签名过程是把一段消息和私钥作为一个输入，对于消息输出是签名。 isValid: = verify(pk, message, sig) 验证过程是通过把一段消息和签名消息与公钥作为输入，如果返回是真，证明签名属实；如果返回是假，证明签名是假。 generateKeys和sign都可以采用随机算法，verify则需要确定的。我们详细检验数字签名要求具备的两个特性，第一个就是有效签名必须验证通过，就是用密钥sk签署一条消息后，只有有人用pk验证同一消息的签名，该签名必须证实为正确。第二个要求计算上签名不可能伪造。 &nbsp; 6椭圆曲线数字签名 ECDSA 比特币使用的数字签名叫做椭圆曲线数字签名。 &nbsp; 7公钥、私钥与比特币地址 公钥就是身份，让某人能为pk身份发声，他必须知道相应的密钥sk。将公钥视为身份，你就可以随时制定新的身份。通过数字签名方案中的generateKeys程序，生成新的密钥对sk和pk。pk是你可以使用的新身份，sk是相应的密钥。公钥和私钥的体系，帮助引入了去中心化的身份管理的理念。你可以自己作为用户注册，无须到中央机构注册为系统用户。比特币对待身份的方式就是如此。 这些身份在比特币系统中被称为比特币地址，比特币地址其实就是公钥的哈希值。作为去中心化身份管理方案的一部分，它就是凭空捏造的一个身份。 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。私钥、公钥和比特币地址之间的关系如下图所示： 私钥（k）就是一个随机选出的数字而已。生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1 到2^256之间选一个数字”无异。以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD比特币私钥空间的大小是2^256，这是一个非常大的数字。用十进制表示的话，大约是10^77，而可见宇宙被估计只含有10^80个原子。 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。以之前产生的私钥k和与生成点G相乘得到公钥K：K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G。 公钥K 被定义为一个点 K = (x, y)： K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。 这个数学技巧成为证明比特币资金所有权的不可伪造和安全的数字签名的基础。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。如： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy&nbsp;&nbsp;&nbsp;在交易中，比特币地址通常以收款方出现。下图描述了如何从公钥生成比特币地址。 比特币地址产生的完整过程：从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。&nbsp;&nbsp;&nbsp;&nbsp; 同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y：K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 压缩格式公钥，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2&nbsp;mod p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为缀。 压缩后的公钥：K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 8比特币钱包 比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。 钱包主要有两种类型，（1）非确定性钱包，其中每个密钥都是从随机数独立生成的。密钥彼此无关。（2）确定性钱包，，其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。例如：16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 助记词表示的种子：army van defense carry jealous true garbage claim echo media make crunch 9纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷存储）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。 1.10 硬件钱包 &nbsp; &nbsp; 比特币硬件钱包，Trezor是一个简单的USB设备，具有两个按钮，用于存储密钥和签署交易。 &nbsp; &nbsp; &nbsp; &nbsp; 2 快速开始 下图是展示比特币区块链如何运作的. 了解比特币工作机制, 作为新用户Alice来说，从手机钱包入手是最适合, 一个常见误解是，比特币钱包里含有比特币。 事实上，钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中。用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。 下载Android的”Mycelium”,并安装到手机上, 运行如下: 这个页面最重要的就是比特币地址: &nbsp;1KAZvbKYG8PLczToaNpUxqUMhyHtz9P979. 旁边是比特币地址对应的二维码. 现在还没有比特币，作为新用户来说，从他人处购买比特币是最快捷的方式。接下来就花$10从Joe处购买比特币， 比特币和大多数货币一样，有浮动汇率，有很多网站可以查询当前比特币价格，与Joe协商好汇率后，把$10给Joe，然后打开钱包，选择接收，将显示一个比特币地址及二维码。 Joe在自己的手机钱包选择发送，输入目的比特币地址以及比特币或当地货币的发送的金额，如下图： Joe仔细确认输入后，按发送确认交易。 Joe的比特币钱包就构建了一个交易，从Joe的钱包将0.1比特币发给了Alice提供地址，并用了Joe的私钥签署交易。在很短时间内，网络中大多数良好的节点都会接收到交易，并首次看到Alice的地址。同时Alice的钱包也不断监听比特币网络上发布的交易，寻找与自己钱包地址匹配的内容， 在Joe钱包发送交易的几秒后，Alice的钱包就显示正在接收0.1比特币。确认开始，Alice的地址将Joe交易显示为“未确认”，要确认，一个交易就必须包含在一个区块中，并被添加到区块链，这种情况平均每10分钟发生一次，这工作由矿工挖矿完成。Alice现在就拥有了属于自己的比特币了。 &nbsp; 3 比特币原理 比特币系统与传统银行系统的差别是基于去中心化的信任。比特币系统由用户（用户通过密钥控制钱包）、交易（每一笔交易都会被广播到整个比特币网络）、矿工（通过竞争计算生成在每个节点达成共识的区块链，区块链包含了比特币网络发生的所有交易）组成。 用户发起的交易，一般来说，可以包含一个或多个输入，交易另一面，有一个或多个输出。 两者差额就代表一笔隐含的矿工费。Joe兑换了比特币给Alice， Alice支付Bob咖啡店一笔交易，假定Bob又向Gopesh支付网页设计费，构成交易链如图： 中间一笔交易为Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡，找零0.0845比特币，剩余0.0005比特币作为交易费用，矿工费，越多的矿工费，交易越容易尽快被网络处理。另外，我们可以通过区块链查询站点查询每一币交易，通过 https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2&nbsp;查询到，blockchain explorer是一个作为比特币搜索引擎运行的Web应用程序，它允许您搜索地址，交易和块，并查看它们之间的关系和资金流动。 &nbsp; 这笔交易现在在比特币网络上传播开，但只有被一个称为挖矿的过程验证且加入一个区块后，这个交易才会成为区块链的一部分。 比特币系统的信任是建立在计算（挖矿）基础上，交易被包在一起放进区块中需要极大的计算量来证明，但只需要少量计算就能验证已被证明。 挖矿在比特币系统中有两个重要作用：（1）挖矿节点通过参考比特币的共识规则验证所有交易。 因此，挖矿通过拒绝无效或畸形交易来提供比特币交易的安全性。（2）挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。挖矿在成本和报酬之间取得了良好的平衡。Alice这笔交易最终被包含在277316号区块，该区块共包含了419笔交易，可以通过https://www.blockchain.com/btc/block-height/277316 查看这个区块信息，如图： 下图我们可以看到包含Alice的交易的第277,316号区块。在它之下有277,316个区块（包括0号区块），像链子 一样一个连着一个（区块链），一直连到0号区块，即创世区块。 4 比特币交易 比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 我们再来看Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡这笔交易。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的交易看起来与典型的区块浏览器提供的交易非常不同。Alice的交易被解码后是这个样子： { &nbsp;&nbsp;&quot;version&quot;: 1, &nbsp;&nbsp;&quot;locktime&quot;: 0, &nbsp;&nbsp;&quot;vin&quot;: [&nbsp;&nbsp;&nbsp;//交易输入 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;txid&quot;:&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;vout&quot;: 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;sequence&quot;: 4294967295 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;], &nbsp;&nbsp;&quot;vout&quot;: [&nbsp;&nbsp;//交易输出 &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.01500000,&nbsp;&nbsp;//一定的比特币 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;&nbsp;&nbsp; //脚本公钥 &nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value&quot;: 0.08450000, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;] } 比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”（unspent transaction outputs），即UTXO。 所有UTXO的集合被称为UTXO集。当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。通过钱包所控制的密钥，我们可以把这些UTXO花出去。 交易输出包含两部分：（1）一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；（2）确定花费输出所需条件的加密难题（cryptographic puzzle）。这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如下表所示： 交易的两个输出序列化如下加粗部分，0.015比特币的价值是1,500,000 satoshis。 这是十六进制的16 e3 60。在串行化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。scriptPubKey的长度为25个字节，以十六进制显示为19个字节。 交易输入将UTXO（通过引用）标记为将被消费，并通过解锁脚本提供所有权证明。输入包含四个元素：（1）一个交易ID，引用包含正在使用的UTXO的交易；（2）一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）；（3）一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出；（4）一个序列号。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当交易被序列化以在网络上传输时，它们的输入被编码成字节流。交易输入的序列化格式如下表所示： 是否可以识别下面这些以十六进制表示法表示的字段，交易ID以反转字节顺序序列化，因此以（十六进制）18开头，以79结尾；输出索引为4字节组的“0”，容易识别；scriptSig的长度为139个字节，或十六进制为8b；序列号设置为FFFFFFFF，也容易识别。 大多数交易包含交易费（矿工费），这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。对于挖矿、费用和矿工得到的奖励，在挖矿一章中将有更详细的讨论。交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励；同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中。 5 比特币交易脚本和脚本语言 比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。 放置在UTXO上的锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时 （互不干扰地）执行，以确定这笔交易是否满足支付条件。比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了脚本语言的图灵非完备性，受限制的语言能防止交易验证机制被作为一个漏洞而加以利用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效（请参阅单独执行解锁和锁定脚本部分）。 所有输入都是独立验证的，作为交易总体验证的一部分。由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），曾被称为脚本公钥（scriptPubKey）。由于认识到这种脚本技术存在着更为广泛的可能性，我们又将它称为“锁定脚本”（locking script）。 假设Alice要向Bob支付0.015比特币, Alice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。锁定脚本如下: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_DUP OP_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP_EQUALVERIFY OP_CHECKSIG OP_DUP:复制栈顶数据，然后该数据放置栈顶 OP_HASH160:对栈顶数据执行ripemd160(sha256(data)) (这其实是两次摘要计算，不详述) be10f0a…:bob的比特币地址 OP_EQUALVERIFY:对比栈顶的两个数据，如果相等都被移除 OP_CHECKSIG:验证签名 Bob如果要接收这笔比特币(另一种说法是Bob可以引用该笔输出)，就要给出一个解锁脚本,然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效。解锁脚本如下: 3046022100ba1427639c9f67f2ca1088d0140318a98cb1e84f604dc90ae00ed7a5f9c61cab02210094233d018f2f014a5864c9e0795f13735780cafd51b950f503534a6af246aca30103a63ab88e75116b313c6de384496328df2656156b8ac48c75505cd20a4890f5ab 看起来是一堆数字，其实『签名』和『公钥』（sig &amp; pubkey）的组合。签名是Bob的私钥对该笔交易的信息加密的结果，公钥就是指的Bob的公钥。由于私钥只Bob才知道，所以也只有他才能拿出正确的签名。下面是脚本执行的过程: 简单的几十个字节的脚本，就完成了交易的验证确保该笔转账的合法性。 &nbsp; &nbsp; &nbsp; &nbsp; 在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值哈希类型。签名密钥是用户的私钥，结果是签名： ((Sig = F{sig}(F{hash}(m), dA)))这里的： dA&nbsp;是签名私钥 m&nbsp;是交易（或其部分） Fhash是散列函数 Fsig是签名算法 Sig&nbsp;是结果签名 函数Fsig产生由两个值组成的签名Sig，通常称为R和S：Sig = (R, S) 现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”（Distinguished Encoding Rules）或 DER的国际标准编码方案。 我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名：3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301 该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素： 0x30表示DER序列的开始 0x45&nbsp;- 序列的长度（69字节） 0x02&nbsp;- 一个整数值 0x21&nbsp;- 整数的长度（33字节） R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb 0x02&nbsp;- 接下来是一个整数 0x20&nbsp;- 整数的长度（32字节） S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL） 6 P2P网络架构 比特币采用了基于国际互联网的P2P（peer-to-peer）网络架构。“比特币网络”是按照比特币P2P协议运行的一系列节点的集合。尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。 7 挖矿 挖矿的目的不是创造新的比特币。 这是激励机制。 这种机制实现了去中心化的安全。挖矿确保了比特币系统安全，并且在没有中央权力机构的情况下实现了全网络范围的共识。 新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励计划，同时实现了货币发行。 比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：（1）每个全节点依据综合标准对每个交易进行独立验证（2）通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块（3）每个节点独立的对新区块进行校验并组装进区块链（4）每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。 &nbsp;&nbsp; 如下图,比特币区块链主要有两层基于哈希函数的结构,第一层是区块链上,每个区块头部都有指针指向其前一个区块,第二层是每个区块里,包含所有交易的梅克尔树. 作为矿工,首先要从交易池中选出一系列有效交易并编译成梅克尔树, &nbsp;然后组装出一个新区块,让它的头部指向区块链前一个区块,新区块头部有一个32位随机数, 挖矿工作量证明就是要你不断尝试不同的临时随机数,直到该随机数能使整个区块的哈希值小于目标值. 挖矿参考算法：挖矿算法为SHA256。在挖矿过程中，矿工将比特币的80个字节长度的区块头数据进行两次SHA256运算，运算结果就是一个256位（32字节）长度的字符串。通过比较与当前难度值的大小判断当前区块是否合法。即满足下列条件：&nbsp;SHA256(SHA256(block_header))&lt; difficulty&nbsp;如果不满足上面的条件，则需要在区块头中改变一下随机值，或者使用随机数据填充coinbase交易，这样就能改变区块头的数据，从而找到满足条件的区块。 从2009年以来，比特币的全网算力增长了超过十亿倍。比特币全网算力创新高：46.92EH/s. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算力的表示&nbsp;1 H/S = 每秒一次运算1 KH/S = 1000 H/S，即每秒1千次运算1 MH/S = 1000 KH/S，即每秒100万次运算1 GH/S = 1000 MH/S，即每秒10亿次运算1 TH/S = 1000 GH/S，即每秒1万亿次运算1 PH/S = 1000 TH/S，即每秒1000万亿次运算1 EH/S = 1000 PH/S，即每秒100万万亿次运算 挖矿设备主要经历了从 CPU -&gt; GPU -&gt; FPGA -&gt; ASIC 的变化. 随着参与挖矿的人数越来越多，比特币全网的算力不断上涨，单个设备或少量的算力都很难再挖到比特币。这时候，矿池诞生了。矿池突破地理位置的限制，将分散在全球的矿工及矿场的算力进行联结，一起挖矿。矿池负责信息打包，接入进来的矿场负责竞争记账权。由于集合了很多矿工的算力，所以矿池的算力占比大，挖到比特币的概率更高。加入矿池相当于选择组队挖矿，在矿池中就可以按照你的算力占全矿池的算力比例来给你分配收益。 &nbsp; &nbsp; &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/12/86baa7e0b90f4defa1691625b9388d74.html","headline":"区块链学习,比特币篇","dateModified":"2018-08-12T00:00:00+08:00","datePublished":"2018-08-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/12/86baa7e0b90f4defa1691625b9388d74.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链学习,比特币篇</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2><strong><strong><strong>1 关键技术、术语。</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">先列出比特币系统会用到的技术、术语，详细解释一下。</span></p> 
  <ol>
   <li>1<span style="color:#000000;">SHA-256安全哈希函数</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">哈希函数是密码学的一个基础知识，具有以下三个特性：</span></p> 
  <ol>
   <li><span style="color:#000000;">其输入可为任意大小的字符串</span></li> 
   <li><span style="color:#000000;">它产生固定大小的输出</span></li> 
   <li><span style="color:#000000;">它能进行有效计算，也就是对于特定的输入字符串，在合理时间内，可以算出哈希函数的输出，哈希值计算的复杂度为O（n）。</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">要使哈希函数达到密码安全，要求其具有以下特性：（1）哈希阻力，如果无法找到两个值，x和y，x！=y。 而H(x)=H(y)，则称哈希函数H具有碰撞阻力；（2）隐秘性，如果我们知道哈希函数的输出y=H（x），我们没有可行的办法算出输入值x。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">哈希函数一个重要应用就是信息摘要，我们确认两个文件是否相同，只需计算比较两个文件的哈希值，文件的信息摘要。记录比较哈希值可以检测文件在服务器是否损害或者蓄意修改。</span><span style="color:#ff0000;">哈希函数对于一个信息生成固定长度的摘要，为我们提供一种记住之前所见事物，并为今后认出这些事物的有效方法。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">哈希函数有很多，SHA-256安全哈希函数是一个被比特币采用，并且效果很不错。</span><span style="color:#000000;">SHA-25</span><span style="color:#000000;">6</span><span style="color:#000000;">算法输入的最大长度不超过2^64 bit，输入按512-bi</span><span style="color:#000000;">t</span><span style="color:#000000;">分组进行处理，产生的输出256-bit</span><span style="color:#000000;">。具体实现可以参考：</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">https://blog.csdn.net/lwanttowin/article/details/53726450</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <ol>
   <li>2<span style="color:#000000;">哈希指针</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">哈希指针是一种数据结构，简单来说一个指向数据存储位置及其位置数据的哈希值的指针。一个普通指针可以告诉你数据存储的位置，</span><span style="color:#ff0000;">哈希指针不但告诉你数据存储的位置，并且还可以给你一种方式，让你验证数据没有被篡改过。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <ol>
   <li>3<span style="color:#000000;">区块链</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">通过哈希指针构建一个链表， 我们称这个数据结构为区块链（block chain）。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212219449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">区块链的每个区块不仅能告诉我们上一个区块的值在哪儿，还包含了该值的摘要，使我们能够验证那个值有没有改变。</span><span style="color:#000000;">区块链的一个应用就是可以存储信息的防篡改。如果修改了区块链中任意区块数据的修改，那么将会导致下一个数据块哈希指针的不正确。只要我们锁定区块链的头部数据，我们就可以检测到篡改行为。如下图：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212250885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">我们可以搭建一个包含很多区块的区块链网络，链表头部哈希指针被称为创世区块。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <ol>
   <li><span style="color:#000000;">4梅克尔树</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">梅克尔树用哈希指针建立的二叉树。 </span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212303890?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">梅克尔树所有的数据区块都被两两分组，指向这些数据区块的指针被存储在上一层的父节点中，而父节点再次两两分组，一直持续这个过程，直到到达最后树的根节点。</span><span style="color:#ff0000;">记住树最前面的哈希指针，可以通过哈希指针回溯到列表任何位置，这让我们确保数据未被篡改。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">隶属证明，为证明某个数据区块是否来自一个梅克尔树，我们只需要找到该数据区块到树根节点的路径</span>，如下图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212325944?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">1.5 数字签名与哈希函数一起，为讨论加密货币奠定基础。</span><span style="color:#000000;">数字签名被认为对纸上签名的数字模拟， 具有两个特性：（1）只有自己可以制作自己的签名，但任何看到它的人都可以验证其有效性；（2）签名只与某个特定文件有关系，因此签名不能用于表明你同意或支持另外一份不同的文件。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">数字签名方案由以下三个算法构成：</span></p> 
  <ol>
   <li><span style="color:#000000;">（sk，pk）：=generateKeys（keysize) &nbsp;把keysize作为输入，来产生一对公钥和私钥。私钥被安全保存，并用来签名一段消息；公钥pk是人人都可以找到的，可以用来验证你的签名。</span></li> 
   <li><span style="color:#000000;">sig:=sign(sk.message)签名过程是把一段消息和私钥作为一个输入，对于消息输出是签名。</span></li> 
   <li><span style="color:#000000;">isValid: = verify(pk, message, sig) 验证过程是通过把一段消息和签名消息与公钥作为输入，如果返回是真，证明签名属实；如果返回是假，证明签名是假。</span></li> 
  </ol>
  <p style="margin-left:0pt;">g<span style="color:#000000;">enerateKeys和sign都可以采用随机算法，verify则需要确定的。我们详细检验数字签名要求具备的两个特性，第一个就是有效签名必须验证通过，就是用密钥sk签署一条消息后，只有有人用pk验证同一消息的签名，该签名必须证实为正确。第二个要求计算上签名不可能伪造。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <ol>
   <li>6<span style="color:#000000;">椭圆曲线数字签名 ECDSA</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币使用的数字签名叫做椭圆曲线数字签名。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <ol>
   <li>7<span style="color:#000000;">公钥、私钥与比特币地址</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">公钥就是身份，让某人能为pk身份发声，他必须知道相应的密钥sk。将公钥视为身份，你就可以随时制定新的身份。通过数字签名方案中的generateKeys程序，生成新的密钥对sk和pk。pk是你可以使用的新身份，sk是相应的密钥。</span><span style="color:#ff0000;">公钥和私钥的体系，帮助引入了去中心化的身份管理的理念。</span><span style="color:#000000;">你可以自己作为用户注册，无须到中央机构注册为系统用户。比特币对待身份的方式就是如此。 </span><span style="color:#ff0000;">这些身份在比特币系统中被称为比特币地址，比特币地址其实就是公钥的哈希值。</span><span style="color:#000000;">作为去中心化身份管理方案的一部分，它就是凭空捏造的一个身份。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。</span><span style="color:#ff0000;">私钥（k）是一个数字，通常是随机选出的。</span><span style="color:#000000;">有了私钥，我们就</span><span style="color:#ff0000;">可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。</span><span style="color:#000000;">有了公钥（K），我们就可以</span><span style="color:#ff0000;">使用一个单向加密哈希函数生成比特币地址（A）</span><span style="color:#000000;">。私钥、公钥和比特币地址之间的关系如下图所示：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212346740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">私钥（k）就是一个随机选出的数字而已。生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1 到2^256之间选一个数字”无异。</span><span style="color:#000000;">以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD比特币私钥空间的大小是2^256，这是一个非常大的数字。用十进制表示的话，大约是10^77，而可见宇宙被估计只含有10^80个原子。</span> <span style="color:#000000;">通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥</span><span style="color:#000000;">。</span><span style="color:#000000;">以之前产生的私钥k和与生成点G相乘得到公钥K：K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</span><span style="color:#000000;">。 </span><span style="color:#000000;">公钥K 被定义为一个点 K = (x, y)：</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">K = (x, y)</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">其中，</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。 这个数学技巧成为证明比特币资金所有权</span><span style="color:#000000;">的不可伪造</span><span style="color:#000000;">和安全的数字签名的基础。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。</span><span style="color:#000000;">由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。</span><span style="color:#000000;">如： </span><span style="color:#000000;">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</span>&nbsp;&nbsp;&nbsp;<span style="color:#000000;">在交易中，比特币地址通常以收款方出现。</span><span style="color:#000000;">下图</span><span style="color:#000000;">描述了如何从公钥生成比特币地址。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212404909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比</span><span style="color:#000000;">特币地址产生的完整过程</span><span style="color:#000000;">：</span><span style="color:#000000;">从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，最终产生Base58Check格式的比特币地址。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000000;">公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212418631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。</span>&nbsp;&nbsp;&nbsp;&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">同样的公钥以520比特的数字（130个十六进制数字）来表达。这个520比特的数字以前缀04开头，紧接着是x及y坐标，组成格式为04 x y：K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000000;">压缩格式公钥，</span><span style="color:#000000;">一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2&nbsp;mod p = (x3&nbsp;+ 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为缀。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212431438?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">压缩后的公钥：K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</span></p> 
  <ol>
   <li>8<span style="color:#000000;">比特币钱包</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#ff0000;">比特币钱包只包含私钥而不是比特币。</span><span style="color:#000000;">每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">钱包主要有两种类型，（1）非确定性钱包，其中每个密钥都是从随机数独立生成的。密钥彼此无关。（2）确定性钱包，，其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。例如：</span><span style="color:#000000;">16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">助记词表示的种子：army van defense carry jealous true garbage claim echo media make crunch</span></p> 
  <ol>
   <li>9<span style="color:#000000;">纸钱包</span></li> 
  </ol>
  <p style="margin-left:0pt;"><span style="color:#000000;">纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中导出。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷存储）的方式。作为备份机制，一个纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212444654?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">1.10 硬件钱包</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币硬件钱包，Trezor是一个简单的USB设备，具有两个按钮，用于存储密钥和签署交易。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212459747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2><strong><strong><strong>2 快速开始</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">下图是展示比特币区块链如何运作的.</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212514876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">了解比特币工作机制, 作为新用户Alice来说，从手机钱包入手是最适合, </span><span style="color:#ff0000;">一个常见误解是，比特币钱包里含有比特币。 事实上，钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中。用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。 </span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">下载Android的</span><span style="color:#000000;">”</span><span style="color:#000000;">Mycelium</span><span style="color:#000000;">”</span><span style="color:#000000;">,并安装到手机上, 运行如下:</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212525199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">这个页面最重要的就是比特币地址: &nbsp;1KAZvbKYG8PLczToaNpUxqUMhyHtz9P979. 旁边是比特币地址对应的二维码. 现在还没有比特币，作为新用户来说，从他人处购买比特币是最快捷的方式。接下来就花$10从Joe处购买比特币， 比特币和大多数货币一样，有浮动汇率，有很多网站可以查询当前比特币价格，与Joe协商好汇率后，把$10给Joe，然后打开钱包，选择接收，将显示一个比特币地址及二维码。 Joe在自己的手机钱包选择发送，输入目的比特币地址以及比特币或当地货币的发送的金额，如下图：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/201808122125420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">Joe仔细确认输入后，按发送确认交易。 Joe的比特币钱包就构建了一个交易，从Joe的钱包将0.1比特币发给了Alice提供地址，并用了Joe的私钥签署交易。在很短时间内，网络中大多数良好的节点都会接收到交易，并首次看到Alice的地址。同时Alice的钱包也不断监听比特币网络上发布的交易，寻找与自己钱包地址匹配的内容， 在Joe钱包发送交易的几秒后，Alice的钱包就显示正在接收0.1比特币。确认开始，Alice的地址将Joe交易显示为“未确认”，要确认，一个交易就必须包含在一个区块中，并被添加到区块链，这种情况平均每10分钟发生一次，这工作由矿工挖矿完成。Alice现在就拥有了属于自己的比特币了。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2><strong><strong><strong>3 比特币原理</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币系统与传统银行系统的差别是基于去中心化的信任。比特币系统由用户（用户通过密钥控制钱包）、交易（每一笔交易都会被广播到整个比特币网络）、矿工（通过竞争计算生成在每个节点达成共识的区块链，区块链包含了比特币网络发生的所有交易）组成。 用户发起的交易，一般来说，可以包含一个或多个输入，交易另一面，有一个或多个输出。 两者差额就代表一笔隐含的矿工费。Joe兑换了比特币给Alice， Alice支付Bob咖啡店一笔交易，假定Bob又向Gopesh支付网页设计费，构成交易链如图：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212556225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">中间一笔交易为Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡，找零0.0845比特币，剩余0.0005比特币作为交易费用，矿工费，越多的矿工费，交易越容易尽快被网络处理。另外，我们可以通过区块链查询站点查询每一币交易，通过</span></p> 
  <p style="margin-left:0pt;"><a href="https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2" rel="nofollow"><u><span style="color:#000000;"><u>https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</u></span></u></a><span style="color:#000000;">&nbsp;查询到，blockchain explorer是一个作为比特币搜索引擎运行的Web应用程序，它允许您搜索地址，交易和块，并查看它们之间的关系和资金流动。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018081221261185?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">这笔交易现在在比特币网络上传播开，但只有被一个称为挖矿的过程验证且加入一个区块后，这个交易才会成为区块链的一部分。 比特币系统的信任是建立在计算（挖矿）基础上，交易被包在一起放进区块中需要极大的计算量来证明，但只需要少量计算就能验证已被证明。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">挖矿在比特币系统中有两个重要作用：</span><span style="color:#000000;">（1）</span><span style="color:#000000;">挖矿节点通过参考比特币的共识规则验证所有交易。 因此，挖矿通过拒绝无效或畸形交易来提供比特币交易的安全性。</span><span style="color:#000000;">（2）</span><span style="color:#000000;">挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。挖矿在成本和报酬之间取得了良好的平衡。</span><span style="color:#000000;">Alice这笔交易最终被包含在277316号区块，该区块共包含了419笔交易，可以通过https://www.blockchain.com/btc/block-height/277316 查看这个区块信息，如图：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212628646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">下图</span><span style="color:#000000;">我们可以看到包含Alice的交易的第277,316号区块。在它之下有277,316个区块（包括0号区块），像链子 一样一个连着一个（区块链），一直连到0号区块，即创世区块。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212643796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <h2><strong><strong><strong>4 比特币交易</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">我们再来看</span><span style="color:#000000;">Alice拿拥有的0.1比特币从Bob处购买了0.015比特币的咖啡这笔交易。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212658187?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的交易看起来与典型的区块浏览器提供的交易非常不同。Alice的交易被解码后是这个样子：</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">{</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;"version": 1,</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;"locktime": 0,</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;"vin": [</span>&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;//交易输入</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;{</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"txid":"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"vout": 0,</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"sequence": 4294967295</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;],</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;"vout": [</span>&nbsp;<span style="color:#ff0000;">&nbsp;//交易输出</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;{</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"value": 0.01500000,</span>&nbsp;&nbsp;<span style="color:#ff0000;">//一定的比特币</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"</span>&nbsp;&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">//脚本公钥</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;},</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;{</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"value": 0.08450000,</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">&nbsp;&nbsp;]</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">}</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”（unspent transaction outputs），即UTXO。 所有UTXO的集合被称为UTXO集。当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。通过钱包所控制的密钥，我们可以把这些UTXO花出去。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">交易输出包含两部分：</span><span style="color:#ff0000;">（1）</span><span style="color:#ff0000;">一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；</span><span style="color:#ff0000;">（2）</span><span style="color:#ff0000;">确定花费输出所需条件的加密难题（cryptographic puzzle）</span><span style="color:#ff0000;">。</span><span style="color:#ff0000;">这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000000;">当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如下表所示：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212725669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">交易的两个输出序列化如下加粗部分，0.015比特币的价值是1,500,000 satoshis。 这是十六进制的16 e3 60。</span><span style="color:#000000;">在串行化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。scriptPubKey的长度为25个字节，以十六进制显示为19个字节。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212752444?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#ff0000;">交易输入将UTXO（通过引用）标记为将被消费，并通过解锁脚本提供所有权证明。</span><span style="color:#ff0000;">输入包含四个元素：</span><span style="color:#ff0000;">（1）</span><span style="color:#ff0000;">一个交易ID，引用包含正在使用的UTXO的交易</span><span style="color:#ff0000;">；（2）</span><span style="color:#ff0000;">一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）</span><span style="color:#ff0000;">；（3）</span><span style="color:#ff0000;">一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出</span><span style="color:#ff0000;">；（4）</span><span style="color:#ff0000;">一个序列号</span><span style="color:#ff0000;">。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span style="color:#000000;">当交易被序列化以在网络上传输时，它们的输入被编码成字节流</span><span style="color:#000000;">。</span><span style="color:#000000;">交易输</span><span style="color:#000000;">入</span><span style="color:#000000;">的序列化格式如下表所示：</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212737405?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">是否可以识别下面这些以十六进制表示法表示的字段</span><span style="color:#000000;">，</span><span style="color:#000000;">交易ID以反转字节顺序序列化，因此以（十六进制）18开头，以79结尾</span><span style="color:#000000;">；</span><span style="color:#000000;">输出索引为4字节组的“0”，容易识别</span><span style="color:#000000;">；</span><span style="color:#000000;">scriptSig的长度为139个字节，或十六进制为8b</span><span style="color:#000000;">；</span><span style="color:#000000;">序列号设置为FFFFFFFF，也容易识别</span><span style="color:#000000;">。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212805555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">大多数交易包含交易费（矿工费），这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。对于挖矿、费用和矿工得到的奖励，在挖矿一章中将有更详细的讨论。交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励；同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中。</span></p> 
  <h2><strong><strong><strong>5 比特币交易脚本和脚本语言</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。 放置在UTXO上的锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时 （互不干扰地）执行，以确定这笔交易是否满足支付条件。比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了</span><span style="color:#ff0000;">脚本语言的图灵非完备性</span><span style="color:#000000;">，受限制的语言能防止交易验证机制被作为一个漏洞而加以利用。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000000;">比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效（请参阅单独执行解锁和锁定脚本部分）。 所有输入都是独立验证的，作为交易总体验证的一部分。</span><span style="color:#ff0000;">由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值）</span><span style="color:#000000;">，曾被称为脚本公钥（scriptPubKey）。由于认识到这种脚本技术存在着更为广泛的可能性，我们</span><span style="color:#000000;">又</span><span style="color:#000000;">将它称为“锁定脚本”（locking script）。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212816119?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">假设</span><span style="color:#000000;">A</span><span style="color:#000000;">lice要向</span><span style="color:#000000;">B</span><span style="color:#000000;">ob支付0.015比特币, </span><span style="color:#000000;">A</span><span style="color:#000000;">lice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。锁定脚本如下:</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#000000;">OP_DUP OP_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP_EQUALVERIFY OP_CHECKSIG</span> <span style="color:#000000;">OP_DUP:复制栈顶数据，然后该数据放置栈顶</span> <span style="color:#000000;">OP_HASH160:对栈顶数据执行ripemd160(sha256(data)) (这其实是两次摘要计算，不详述)</span> <span style="color:#000000;">be10f0a…:bob的比特币地址</span> <span style="color:#000000;">OP_EQUALVERIFY:对比栈顶的两个数据，如果相等都被移除</span> <span style="color:#000000;">OP_CHECKSIG:验证签名</span> <span style="color:#000000;">B</span><span style="color:#000000;">ob如果要接收这笔比特币(另一种说法是</span><span style="color:#000000;">B</span><span style="color:#000000;">ob可以引用该笔输出)，就要给出一个解锁脚本,然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效。解锁脚本如</span><span style="color:#000000;">下</span><span style="color:#000000;">:</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">3046022100ba1427639c9f67f2ca1088d0140318a98cb1e84f604dc90ae00ed7a5f9c61cab02210094233d018f2f014a5864c9e0795f13735780cafd51b950f503534a6af246aca30103a63ab88e75116b313c6de384496328df2656156b8ac48c75505cd20a4890f5ab</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">看起来是一堆数字，其实『签名』和『公钥』（sig &amp; pubkey）的组合。签名是</span><span style="color:#000000;">B</span><span style="color:#000000;">ob的私钥对该笔交易的信息加密的结果，公钥就是指的</span><span style="color:#000000;">B</span><span style="color:#000000;">ob的公钥。由于私钥只</span><span style="color:#000000;">B</span><span style="color:#000000;">ob才知道，所以也只有他才能拿出正确的签名。下面是脚本执行的过程:</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212844268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212855941?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">简单的几十个字节的脚本，就完成了交易的验证确保该笔转账的合法性。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值哈希类型。签名密钥是用户的私钥，结果是签名：</span></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">((Sig = F{sig}(F{hash}(m), dA)))这里的：</span> <span style="color:#000000;">dA&nbsp;是签名私钥</span> <span style="color:#000000;">m&nbsp;是交易（或其部分）</span> <span style="color:#000000;">F</span><span style="color:#000000;">hash</span><span style="color:#000000;">是散列函数</span> <span style="color:#000000;">F</span><span style="color:#000000;">sig</span><span style="color:#000000;">是签名算法</span> <span style="color:#000000;">Sig&nbsp;是结果签名</span> <span style="color:#000000;">函数</span><span style="color:#000000;">Fsig</span><span style="color:#000000;">产生由两个值组成的签名Sig，通常称为R和S：Sig = (R, S)</span> <span style="color:#000000;">现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”（Distinguished Encoding Rules）或 DER的国际标准编码方案。</span> <span style="color:#000000;">我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名：3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301</span> <span style="color:#000000;">该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素：</span> <span style="color:#000000;">0x30表示DER序列的开始</span> <span style="color:#000000;">0x45&nbsp;- 序列的长度（69字节）</span> <span style="color:#000000;">0x02&nbsp;- 一个整数值</span> <span style="color:#000000;">0x21&nbsp;- 整数的长度（33字节）</span> <span style="color:#000000;">R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb</span> <span style="color:#000000;">0x02&nbsp;- 接下来是一个整数</span> <span style="color:#000000;">0x20&nbsp;- 整数的长度（32字节）</span> <span style="color:#000000;">S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813</span> <span style="color:#000000;">后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL）</span></p> 
  <p style="margin-left:0pt;"><strong><strong>6 P2P网络架构</strong></strong><strong> </strong></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">比特币采用了基于国际互联网</span><span style="color:#000000;">的</span><span style="color:#000000;">P2P（peer-to-peer）网络架构。“比特币网络”是按照比特币P2P协议运行的一系列节点的集合。尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。</span><span style="color:#ff0000;">每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。</span></p> 
  <h2><strong><strong><strong>7 挖矿</strong></strong></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#000000;">挖矿的目的不是创造新的比特币。 这是激励机制。 这种机制实现了去中心化的安全。挖矿确保了比特币系统安全，并且在没有中央权力机构的情况下实现了全网络范围的共识。 新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励计划，同时实现了货币发行。</span> <span style="color:#000000;">比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：</span><span style="color:#000000;">（1）</span><span style="color:#000000;">每个全节点依据综合标准对每个交易进行独立验证</span><span style="color:#000000;">（2）</span><span style="color:#000000;">通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块</span><span style="color:#000000;">（3）</span><span style="color:#000000;">每个节点独立的对新区块进行校验并组装进区块链</span><span style="color:#000000;">（4）</span><span style="color:#000000;">每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。</span> <span style="color:#000000;">&nbsp;&nbsp; 如下图,比特币区块链主要有两层基于哈希函数的结构,第一层是区块链上,每个区块头部都有指针指向其前一个区块,第二层是每个区块里,包含所有交易的梅克尔树.</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018081221291139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">作为矿工,首先要从交易池中选出一系列有效交易并编译成梅克尔树, &nbsp;然后组装出一个新区块,让它的头部指向区块链前一个区块,新区块头部有一个32位随机数, 挖矿工作量证明就是要你不断尝试不同的临时随机数,直到该随机数能使整个区块的哈希值小于目标值. 挖矿参考算法：挖矿算法为SHA256。在挖矿过程中，矿工将比特币的80个字节长度的区块头数据进行两次SHA256运算，运算结果就是一个256位（32字节）长度的字符串。通过比较与当前难度值的大小判断当前区块是否合法。即满足下列条件：</span>&nbsp;<br><span style="color:#000000;">SHA256(SHA256(block_header))&lt; difficulty</span>&nbsp;<br><span style="color:#000000;">如果不满足上面的条件，则需要在区块头中改变一下随机值，或者使用随机数据填充coinbase交易，这样就能改变区块头的数据，</span><span style="color:#000000;">从而找到满足条件的区块。</span> <span style="color:#000000;">从2009年以来，比特币的全网算力增长了超过十亿倍。</span><span style="color:#000000;">比特币全网算力创新高：46.92EH/s. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#000000;">算力的表示&nbsp;</span><br><span style="color:#000000;">1 H/S = 每秒一次运算</span><br><span style="color:#000000;">1 KH/S = 1000 H/S，即每秒1千次运算</span><br><span style="color:#000000;">1 MH/S = 1000 KH/S，即每秒100万次运算</span><br><span style="color:#000000;">1 GH/S = 1000 MH/S，即每秒10亿次运算</span><br><span style="color:#000000;">1 TH/S = 1000 GH/S，即每秒1万亿次运算</span><br><span style="color:#000000;">1 PH/S = 1000 TH/S，即每秒1000万亿次运算</span><br><span style="color:#000000;">1 EH/S = 1000 PH/S，即每秒100万万亿次运算</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212923203?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">挖矿设备主要经历了从 CPU -&gt; GPU -&gt; FPGA -&gt; ASIC 的变化</span><span style="color:#000000;">. </span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812212935259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlUc3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0pt;"></p> 
  <p style="margin-left:0pt;"><span style="color:#000000;">随着参与挖矿的人数越来越多，比特币全网的算力不断上涨，单个设备或少量的算力都很难再挖到比特币。这时候，矿池诞生了。矿池突破地理位置的限制，将分散在全球的矿工及矿场的算力进行联结，一起挖矿。矿池负责信息打包，接入进来的矿场负责竞争记账权。由于集合了很多矿工的算力，所以矿池的算力占比大，挖到比特币的概率更高。加入矿池相当于选择组队挖矿，在矿池中就可以按照你的算力占全矿池的算力比例来给你分配收益。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AndyTsui/article/details/81610831,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/AndyTsui/article/details/81610831,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
