<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>如何一夜暴富？深度学习教你预测比特币价格 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="如何一夜暴富？深度学习教你预测比特币价格" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="如何一夜暴富？深度学习教你预测比特币价格 2018年08月06日 17:50:00 &nbsp; 近年来，以比特币为代表的加密数字货币一直是社交媒体和搜索引擎上的热门。但是，比特币价格浮动也使各位看官们经历了过山车般的体验。 &nbsp; 随着本周各大权威机构纷纷表示看好区块链的未来，从1月17日到18日凌晨，比特币成功止住前一日暴跌的颓势，涨幅接近20%（18.46%）。 &nbsp; 如果我们能够智能化的制定投资策略的话，就能发现这些反复无常的波动背后潜藏着巨大的利润。 &nbsp; 与传统金融工具相比，加密货币由于缺乏指标数据，预测变得非常困难。 本文以当下最火的比特币为例，来探讨如何用深度学习预测加密数字货币的价格，并了解它们未来的发展趋势。 &nbsp; 免责声明：比特币等数字货币的交易属于投资行为。交易有风险，买币须谨慎。 第一步 要运行本文中的代码，请确保已经安装了以下环境和代码库： Python 2.7 Tensorflow=1.2.0 Keras=2.1.1 Pandas=0.20.3 Numpy=1.13.3 h5py=2.7.0 sklearn=0.19.1 数据采集 &nbsp; 用于分析预测的数据可以从Kaggle或者Poloniex上收集到。 为确保在不同数据集之间代码适用的一致性，从Poloniex上收集数据的列名都会更改为与Kaggle相匹配的列名。 &nbsp; 数据准备 从数据源收集而来的数据需要先被解析一下才能送到模型中进行预测。下面代码中，PastSampler类是参考这个博客上的方法将数据分成一列子数据集和相应的标签数据集。模型输入数据大小（N）为256个，输出大小（K）为16个。 值得注意的是，从Poloniex收集来的数据是以5分钟为基础间隔时序数据。 这表明输入模型的数据跨度为1280分钟，而输出的数据跨度超过了80分钟。 &nbsp; &nbsp; 在创建完PastSampler类之后，我将利用此类来收集数据。 由于原始数据的取值范围从0到10000以上，因此需要对数据进行缩放操作来使神经网络更容易理解数据。 &nbsp; 模型构建 CNN &nbsp; 一维卷积神经网络可以通过核窗口在输入数据上滑动的情况下很好地捕捉数据的局部特征。如下图所示。 &nbsp; CNN 图例，来自 http://cs231n.github.io/convolutional-networks/ &nbsp; 上述代码是我建立的第一个卷积神经网络模型。 以下代码将我的GPU编号为“1”（这是因为我有4个GPU，您可以将其设置为您任何一个GPU）。 由于Tensorflow在多GPU上运行似乎不尽人意，因此把它限制在一个GPU上运行很合适的。 如果您没有GPU也请不要担心，尽管忽略下面的代码就好。 构建CNN模型的代码是非常简单的。加入dropout层是为了避免过拟合问题。 损失函数的定义为均方误差（MSE），而优化器选用最先进的Adam自适应优化。 唯一需要担心的是每层之间的输入数据和输出数据的维度。 计算某个卷积层输出数据维度的公式是： 输出时间步长=（输入时间步长 - 核窗口大小）/步幅+ 1 在下面代码的末尾，我添加了两个回调函数CSVLogger和ModelCheckpoint。 前者可以帮助我跟踪所有的训练和验证过程，而后者则可以存储每个周期的模型权重参数。 LSTM 长期短期记忆（LSTM）网络是递归神经网络（RNN）的一种变体，发明它的目的是为了解决在普通RNN中存在的梯度消失问题。 据称LSTM能够记住更长的时序输入步长。 LSTM 图例 (来自 http://colah.github.io/posts/2015-08-Understanding-LSTMs/&gt;) &nbsp; LSTM比CNN更容易通过代码实现，这是因为你根本不需要关心核窗口的大小，步长，输入和输出的数据维度大小之间的关系等。 只需要确保输入网络数据和输出网络的数据维度就可以了。 GRU 门控循环单元（GRU）是RNN的另一种变体。 它的网络结构不如LSTM那么复杂，只有一个复位门和忘记门，而不是记忆单元。 据称GRU的性能与LSTM是相当的，但效率可以更高。 （在本文中也是如此的，因为LSTM大约需要跑45秒/周期，而GRU则不到40秒/周期） 来自：http://www.jackdermody.net/brightwire/article/GRU_Recurrent_Neural_Networks) 只需将LSTM模型中的第二行 替换为 绘图结果 由于三个模型的计算结果图像很相似，所以我只会查看CNN模型的图像。 首先，我们需要重建模型并将训练权重加载到模型中。 然后，我们需要对预测后的数据进行反向缩放，因为之前使用了MinMaxScaler，因此此时预测的数据范围是在[0,1]。 如上所示的两个Dataframes分别构造了真实值（实际价格）以及比特币的预测价格。为了更好的可视化，绘制的图像只显示了2017年8月之后的数据。 我们使用pyplot绘制图形。 由于预测出的价格是以16分钟为间隔的，所以为了让我们更方便的查看结果，我就不把它们全部链接起来了。 结果，这里预测的数据被绘制成红点，如第三行中的“ro”所示。 下图中的蓝线表示真实值（实际价格数据），而红点表示预测的比特币价格。 使用2层CNN模型预测的最佳比特币价格 从上图可以看出，预测价格与比特币的实际价格是非常相似的。 为了得到最佳模型效果，我决定测试集中配置下的神经网络，如下表所示。 不同模型下的预测结果 上表中的每一行都是从100个训练周期中得到的最佳验证损失的模型。 从以上结果可以看出，LeakyReLU似乎总是比通常的ReLU产生更好的损失效果。 但是，使用Leaky ReLU作为激活函数的4层CNN模型会得到较大的验证损失值，这可能是由于重新验证的模型所导致的问题。 CNN模型可以训练得非常快（使用GPU时，2秒/周期），在性能上要比LSTM和GRU稍差一点。 虽然3层CNN似乎可以更好地捕捉数据的局部时间依赖性，但最好的模型似乎是用 tanh和Leaky ReLU作为激活函数的LSTM模型。 用Tanh和Leaky ReLu作为激活函数的LSTM模型 用Leaky ReLu作为激活函数的3层CNN模型 虽然预测看起来都相当不错，但是过度拟合还是很值得留意的。 当用LeakyReLU训练LSTM时，训练损失和验证损失之间存在差距（5.97E-06 vs 3.92E-05），应该使用正则化来最小化这个差异。 正则化 为了找到最佳的正则化方案，我用L1和L2在不同的几个值中实验。 首先，我们需要定义一个新的函数来使得数据能够拟合到LSTM中。 在这里，我将使用在偏置正规化方法对偏差向量进行正则化。 通过重复训练模型30次，每次30个周期为标准进行实验。 如果你使用的是Jupyter notebook，则可以直接从输出数据中查看如下表格。 使用偏置正则化的结果 为了可视化比较，我们可以使用boxplot绘图： 通过比较可知，L2正则化中偏差向量的系数为0.01时可以似乎得到了最好的结果。 为了找出所有超参数正则化之间的最佳组合，包括激活，偏置，核窗口，循环矩阵等等，有必要逐一测试所有正则化方案，但这对我目前的硬件配置来说并不现实。 因此，我将搁置下来以后再议。 结论 从本文，你已经了解到： 如何收集时序的比特币数据。 如何准备数据进行训练和预测。 如何使用深度学习技术预测比特币的价格。 如何可视化预测的结果。 如何在模型上应用正则化技术。 &nbsp; 来源: AI科技大本营 英文原文来源： https://github.com/khuangaf 阅读更多" />
<meta property="og:description" content="如何一夜暴富？深度学习教你预测比特币价格 2018年08月06日 17:50:00 &nbsp; 近年来，以比特币为代表的加密数字货币一直是社交媒体和搜索引擎上的热门。但是，比特币价格浮动也使各位看官们经历了过山车般的体验。 &nbsp; 随着本周各大权威机构纷纷表示看好区块链的未来，从1月17日到18日凌晨，比特币成功止住前一日暴跌的颓势，涨幅接近20%（18.46%）。 &nbsp; 如果我们能够智能化的制定投资策略的话，就能发现这些反复无常的波动背后潜藏着巨大的利润。 &nbsp; 与传统金融工具相比，加密货币由于缺乏指标数据，预测变得非常困难。 本文以当下最火的比特币为例，来探讨如何用深度学习预测加密数字货币的价格，并了解它们未来的发展趋势。 &nbsp; 免责声明：比特币等数字货币的交易属于投资行为。交易有风险，买币须谨慎。 第一步 要运行本文中的代码，请确保已经安装了以下环境和代码库： Python 2.7 Tensorflow=1.2.0 Keras=2.1.1 Pandas=0.20.3 Numpy=1.13.3 h5py=2.7.0 sklearn=0.19.1 数据采集 &nbsp; 用于分析预测的数据可以从Kaggle或者Poloniex上收集到。 为确保在不同数据集之间代码适用的一致性，从Poloniex上收集数据的列名都会更改为与Kaggle相匹配的列名。 &nbsp; 数据准备 从数据源收集而来的数据需要先被解析一下才能送到模型中进行预测。下面代码中，PastSampler类是参考这个博客上的方法将数据分成一列子数据集和相应的标签数据集。模型输入数据大小（N）为256个，输出大小（K）为16个。 值得注意的是，从Poloniex收集来的数据是以5分钟为基础间隔时序数据。 这表明输入模型的数据跨度为1280分钟，而输出的数据跨度超过了80分钟。 &nbsp; &nbsp; 在创建完PastSampler类之后，我将利用此类来收集数据。 由于原始数据的取值范围从0到10000以上，因此需要对数据进行缩放操作来使神经网络更容易理解数据。 &nbsp; 模型构建 CNN &nbsp; 一维卷积神经网络可以通过核窗口在输入数据上滑动的情况下很好地捕捉数据的局部特征。如下图所示。 &nbsp; CNN 图例，来自 http://cs231n.github.io/convolutional-networks/ &nbsp; 上述代码是我建立的第一个卷积神经网络模型。 以下代码将我的GPU编号为“1”（这是因为我有4个GPU，您可以将其设置为您任何一个GPU）。 由于Tensorflow在多GPU上运行似乎不尽人意，因此把它限制在一个GPU上运行很合适的。 如果您没有GPU也请不要担心，尽管忽略下面的代码就好。 构建CNN模型的代码是非常简单的。加入dropout层是为了避免过拟合问题。 损失函数的定义为均方误差（MSE），而优化器选用最先进的Adam自适应优化。 唯一需要担心的是每层之间的输入数据和输出数据的维度。 计算某个卷积层输出数据维度的公式是： 输出时间步长=（输入时间步长 - 核窗口大小）/步幅+ 1 在下面代码的末尾，我添加了两个回调函数CSVLogger和ModelCheckpoint。 前者可以帮助我跟踪所有的训练和验证过程，而后者则可以存储每个周期的模型权重参数。 LSTM 长期短期记忆（LSTM）网络是递归神经网络（RNN）的一种变体，发明它的目的是为了解决在普通RNN中存在的梯度消失问题。 据称LSTM能够记住更长的时序输入步长。 LSTM 图例 (来自 http://colah.github.io/posts/2015-08-Understanding-LSTMs/&gt;) &nbsp; LSTM比CNN更容易通过代码实现，这是因为你根本不需要关心核窗口的大小，步长，输入和输出的数据维度大小之间的关系等。 只需要确保输入网络数据和输出网络的数据维度就可以了。 GRU 门控循环单元（GRU）是RNN的另一种变体。 它的网络结构不如LSTM那么复杂，只有一个复位门和忘记门，而不是记忆单元。 据称GRU的性能与LSTM是相当的，但效率可以更高。 （在本文中也是如此的，因为LSTM大约需要跑45秒/周期，而GRU则不到40秒/周期） 来自：http://www.jackdermody.net/brightwire/article/GRU_Recurrent_Neural_Networks) 只需将LSTM模型中的第二行 替换为 绘图结果 由于三个模型的计算结果图像很相似，所以我只会查看CNN模型的图像。 首先，我们需要重建模型并将训练权重加载到模型中。 然后，我们需要对预测后的数据进行反向缩放，因为之前使用了MinMaxScaler，因此此时预测的数据范围是在[0,1]。 如上所示的两个Dataframes分别构造了真实值（实际价格）以及比特币的预测价格。为了更好的可视化，绘制的图像只显示了2017年8月之后的数据。 我们使用pyplot绘制图形。 由于预测出的价格是以16分钟为间隔的，所以为了让我们更方便的查看结果，我就不把它们全部链接起来了。 结果，这里预测的数据被绘制成红点，如第三行中的“ro”所示。 下图中的蓝线表示真实值（实际价格数据），而红点表示预测的比特币价格。 使用2层CNN模型预测的最佳比特币价格 从上图可以看出，预测价格与比特币的实际价格是非常相似的。 为了得到最佳模型效果，我决定测试集中配置下的神经网络，如下表所示。 不同模型下的预测结果 上表中的每一行都是从100个训练周期中得到的最佳验证损失的模型。 从以上结果可以看出，LeakyReLU似乎总是比通常的ReLU产生更好的损失效果。 但是，使用Leaky ReLU作为激活函数的4层CNN模型会得到较大的验证损失值，这可能是由于重新验证的模型所导致的问题。 CNN模型可以训练得非常快（使用GPU时，2秒/周期），在性能上要比LSTM和GRU稍差一点。 虽然3层CNN似乎可以更好地捕捉数据的局部时间依赖性，但最好的模型似乎是用 tanh和Leaky ReLU作为激活函数的LSTM模型。 用Tanh和Leaky ReLu作为激活函数的LSTM模型 用Leaky ReLu作为激活函数的3层CNN模型 虽然预测看起来都相当不错，但是过度拟合还是很值得留意的。 当用LeakyReLU训练LSTM时，训练损失和验证损失之间存在差距（5.97E-06 vs 3.92E-05），应该使用正则化来最小化这个差异。 正则化 为了找到最佳的正则化方案，我用L1和L2在不同的几个值中实验。 首先，我们需要定义一个新的函数来使得数据能够拟合到LSTM中。 在这里，我将使用在偏置正规化方法对偏差向量进行正则化。 通过重复训练模型30次，每次30个周期为标准进行实验。 如果你使用的是Jupyter notebook，则可以直接从输出数据中查看如下表格。 使用偏置正则化的结果 为了可视化比较，我们可以使用boxplot绘图： 通过比较可知，L2正则化中偏差向量的系数为0.01时可以似乎得到了最好的结果。 为了找出所有超参数正则化之间的最佳组合，包括激活，偏置，核窗口，循环矩阵等等，有必要逐一测试所有正则化方案，但这对我目前的硬件配置来说并不现实。 因此，我将搁置下来以后再议。 结论 从本文，你已经了解到： 如何收集时序的比特币数据。 如何准备数据进行训练和预测。 如何使用深度学习技术预测比特币的价格。 如何可视化预测的结果。 如何在模型上应用正则化技术。 &nbsp; 来源: AI科技大本营 英文原文来源： https://github.com/khuangaf 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"如何一夜暴富？深度学习教你预测比特币价格 2018年08月06日 17:50:00 &nbsp; 近年来，以比特币为代表的加密数字货币一直是社交媒体和搜索引擎上的热门。但是，比特币价格浮动也使各位看官们经历了过山车般的体验。 &nbsp; 随着本周各大权威机构纷纷表示看好区块链的未来，从1月17日到18日凌晨，比特币成功止住前一日暴跌的颓势，涨幅接近20%（18.46%）。 &nbsp; 如果我们能够智能化的制定投资策略的话，就能发现这些反复无常的波动背后潜藏着巨大的利润。 &nbsp; 与传统金融工具相比，加密货币由于缺乏指标数据，预测变得非常困难。 本文以当下最火的比特币为例，来探讨如何用深度学习预测加密数字货币的价格，并了解它们未来的发展趋势。 &nbsp; 免责声明：比特币等数字货币的交易属于投资行为。交易有风险，买币须谨慎。 第一步 要运行本文中的代码，请确保已经安装了以下环境和代码库： Python 2.7 Tensorflow=1.2.0 Keras=2.1.1 Pandas=0.20.3 Numpy=1.13.3 h5py=2.7.0 sklearn=0.19.1 数据采集 &nbsp; 用于分析预测的数据可以从Kaggle或者Poloniex上收集到。 为确保在不同数据集之间代码适用的一致性，从Poloniex上收集数据的列名都会更改为与Kaggle相匹配的列名。 &nbsp; 数据准备 从数据源收集而来的数据需要先被解析一下才能送到模型中进行预测。下面代码中，PastSampler类是参考这个博客上的方法将数据分成一列子数据集和相应的标签数据集。模型输入数据大小（N）为256个，输出大小（K）为16个。 值得注意的是，从Poloniex收集来的数据是以5分钟为基础间隔时序数据。 这表明输入模型的数据跨度为1280分钟，而输出的数据跨度超过了80分钟。 &nbsp; &nbsp; 在创建完PastSampler类之后，我将利用此类来收集数据。 由于原始数据的取值范围从0到10000以上，因此需要对数据进行缩放操作来使神经网络更容易理解数据。 &nbsp; 模型构建 CNN &nbsp; 一维卷积神经网络可以通过核窗口在输入数据上滑动的情况下很好地捕捉数据的局部特征。如下图所示。 &nbsp; CNN 图例，来自 http://cs231n.github.io/convolutional-networks/ &nbsp; 上述代码是我建立的第一个卷积神经网络模型。 以下代码将我的GPU编号为“1”（这是因为我有4个GPU，您可以将其设置为您任何一个GPU）。 由于Tensorflow在多GPU上运行似乎不尽人意，因此把它限制在一个GPU上运行很合适的。 如果您没有GPU也请不要担心，尽管忽略下面的代码就好。 构建CNN模型的代码是非常简单的。加入dropout层是为了避免过拟合问题。 损失函数的定义为均方误差（MSE），而优化器选用最先进的Adam自适应优化。 唯一需要担心的是每层之间的输入数据和输出数据的维度。 计算某个卷积层输出数据维度的公式是： 输出时间步长=（输入时间步长 - 核窗口大小）/步幅+ 1 在下面代码的末尾，我添加了两个回调函数CSVLogger和ModelCheckpoint。 前者可以帮助我跟踪所有的训练和验证过程，而后者则可以存储每个周期的模型权重参数。 LSTM 长期短期记忆（LSTM）网络是递归神经网络（RNN）的一种变体，发明它的目的是为了解决在普通RNN中存在的梯度消失问题。 据称LSTM能够记住更长的时序输入步长。 LSTM 图例 (来自 http://colah.github.io/posts/2015-08-Understanding-LSTMs/&gt;) &nbsp; LSTM比CNN更容易通过代码实现，这是因为你根本不需要关心核窗口的大小，步长，输入和输出的数据维度大小之间的关系等。 只需要确保输入网络数据和输出网络的数据维度就可以了。 GRU 门控循环单元（GRU）是RNN的另一种变体。 它的网络结构不如LSTM那么复杂，只有一个复位门和忘记门，而不是记忆单元。 据称GRU的性能与LSTM是相当的，但效率可以更高。 （在本文中也是如此的，因为LSTM大约需要跑45秒/周期，而GRU则不到40秒/周期） 来自：http://www.jackdermody.net/brightwire/article/GRU_Recurrent_Neural_Networks) 只需将LSTM模型中的第二行 替换为 绘图结果 由于三个模型的计算结果图像很相似，所以我只会查看CNN模型的图像。 首先，我们需要重建模型并将训练权重加载到模型中。 然后，我们需要对预测后的数据进行反向缩放，因为之前使用了MinMaxScaler，因此此时预测的数据范围是在[0,1]。 如上所示的两个Dataframes分别构造了真实值（实际价格）以及比特币的预测价格。为了更好的可视化，绘制的图像只显示了2017年8月之后的数据。 我们使用pyplot绘制图形。 由于预测出的价格是以16分钟为间隔的，所以为了让我们更方便的查看结果，我就不把它们全部链接起来了。 结果，这里预测的数据被绘制成红点，如第三行中的“ro”所示。 下图中的蓝线表示真实值（实际价格数据），而红点表示预测的比特币价格。 使用2层CNN模型预测的最佳比特币价格 从上图可以看出，预测价格与比特币的实际价格是非常相似的。 为了得到最佳模型效果，我决定测试集中配置下的神经网络，如下表所示。 不同模型下的预测结果 上表中的每一行都是从100个训练周期中得到的最佳验证损失的模型。 从以上结果可以看出，LeakyReLU似乎总是比通常的ReLU产生更好的损失效果。 但是，使用Leaky ReLU作为激活函数的4层CNN模型会得到较大的验证损失值，这可能是由于重新验证的模型所导致的问题。 CNN模型可以训练得非常快（使用GPU时，2秒/周期），在性能上要比LSTM和GRU稍差一点。 虽然3层CNN似乎可以更好地捕捉数据的局部时间依赖性，但最好的模型似乎是用 tanh和Leaky ReLU作为激活函数的LSTM模型。 用Tanh和Leaky ReLu作为激活函数的LSTM模型 用Leaky ReLu作为激活函数的3层CNN模型 虽然预测看起来都相当不错，但是过度拟合还是很值得留意的。 当用LeakyReLU训练LSTM时，训练损失和验证损失之间存在差距（5.97E-06 vs 3.92E-05），应该使用正则化来最小化这个差异。 正则化 为了找到最佳的正则化方案，我用L1和L2在不同的几个值中实验。 首先，我们需要定义一个新的函数来使得数据能够拟合到LSTM中。 在这里，我将使用在偏置正规化方法对偏差向量进行正则化。 通过重复训练模型30次，每次30个周期为标准进行实验。 如果你使用的是Jupyter notebook，则可以直接从输出数据中查看如下表格。 使用偏置正则化的结果 为了可视化比较，我们可以使用boxplot绘图： 通过比较可知，L2正则化中偏差向量的系数为0.01时可以似乎得到了最好的结果。 为了找出所有超参数正则化之间的最佳组合，包括激活，偏置，核窗口，循环矩阵等等，有必要逐一测试所有正则化方案，但这对我目前的硬件配置来说并不现实。 因此，我将搁置下来以后再议。 结论 从本文，你已经了解到： 如何收集时序的比特币数据。 如何准备数据进行训练和预测。 如何使用深度学习技术预测比特币的价格。 如何可视化预测的结果。 如何在模型上应用正则化技术。 &nbsp; 来源: AI科技大本营 英文原文来源： https://github.com/khuangaf 阅读更多","@type":"BlogPosting","url":"/2018/08/12/f0ee57ba4e8e0bd371c82cebc936fa85.html","headline":"如何一夜暴富？深度学习教你预测比特币价格","dateModified":"2018-08-12T00:00:00+08:00","datePublished":"2018-08-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/12/f0ee57ba4e8e0bd371c82cebc936fa85.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>如何一夜暴富？深度学习教你预测比特币价格</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1>如何一夜暴富？深度学习教你预测比特币价格</h1> 
  <p>2018年08月06日 17:50:00</p> 
  <p><strong><img alt="640?wx_fmt=gif" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/L2QczVR5icb1ibuIibakTJ3F250Nysa1Y8jqOuFd19BkBIlScdu5jSCOM5V9QGicQSVnalZwytEicfesHgu9C3vuwIA/640?wx_fmt=gif"></strong></p> 
  <p>&nbsp;</p> 
  <p>近年来，以比特币为代表的加密数字货币一直是社交媒体和搜索引擎上的热门。但是，比特币价格浮动也使各位看官们经历了过山车般的体验。</p> 
  <p>&nbsp;</p> 
  <p>随着本周各大权威机构纷纷表示看好区块链的未来，从1月17日到18日凌晨，比特币成功止住前一日暴跌的颓势，涨幅接近20%（18.46%）。</p> 
  <p>&nbsp;</p> 
  <p>如果我们能够智能化的制定投资策略的话，就能发现这些反复无常的波动背后潜藏着巨大的利润。</p> 
  <p>&nbsp;</p> 
  <p>与传统金融工具相比，加密货币由于缺乏指标数据，预测变得非常困难。 本文以当下最火的比特币为例，来探讨如何用深度学习预测加密数字货币的价格，并了解它们未来的发展趋势。</p> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p>免责声明：比特币等数字货币的交易属于投资行为。交易有风险，买币须谨慎。</p> 
  </blockquote> 
  <p><strong>第一步</strong></p> 
  <p>要运行本文中的代码，请确保已经安装了以下环境和代码库：</p> 
  <ul>
   <li> <p>Python 2.7</p> </li> 
   <li> <p>Tensorflow=1.2.0</p> </li> 
   <li> <p>Keras=2.1.1</p> </li> 
   <li> <p>Pandas=0.20.3</p> </li> 
   <li> <p>Numpy=1.13.3</p> </li> 
   <li> <p>h5py=2.7.0</p> </li> 
   <li> <p>sklearn=0.19.1</p> </li> 
  </ul>
  <p><strong>数据采集</strong></p> 
  <p>&nbsp;</p> 
  <p>用于分析预测的数据可以从Kaggle或者Poloniex上收集到。 为确保在不同数据集之间代码适用的一致性，从Poloniex上收集数据的列名都会更改为与Kaggle相匹配的列名。</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNibqu39POVuo2k7KnxvhLrPtYhicSsiaibhMUMHt4H8ygEibYv3h2tia6Tx9w/640?wx_fmt=jpeg"></p> 
  <p><strong>数据准备</strong></p> 
  <p>从数据源收集而来的数据需要先被解析一下才能送到模型中进行预测。下面代码中，PastSampler类是参考这个博客上的方法将数据分成一列子数据集和相应的标签数据集。模型输入数据大小（N）为256个，输出大小（K）为16个。</p> 
  <p>值得注意的是，从Poloniex收集来的数据是以5分钟为基础间隔时序数据。 这表明输入模型的数据跨度为1280分钟，而输出的数据跨度超过了80分钟。</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNsy4jHWK8sEmxmoRtWxL4MK6M3MiafpI0xZ3c8Gic7DEia7ICUib80WOtRA/640?wx_fmt=jpeg"></p> 
  <p>&nbsp;</p> 
  <p>在创建完PastSampler类之后，我将利用此类来收集数据。 由于原始数据的取值范围从0到10000以上，因此需要对数据进行缩放操作来使神经网络更容易理解数据。</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNmc8hhE9icmxGFYGKhqb2icrjicDbAvsia6mE9DBfsnVIRHxxMvkVGMPpYg/640?wx_fmt=jpeg"></p> 
  <p><strong>模型构建</strong></p> 
  <p><strong>CNN</strong></p> 
  <p>&nbsp;</p> 
  <p>一维卷积神经网络可以通过核窗口在输入数据上滑动的情况下很好地捕捉数据的局部特征。如下图所示。</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNAwW68C5uY4aAd0nqoicnOcsGibc6GSppF62DTm6O6NiaP7aBmicyC6SjZQ/640?wx_fmt=png"></p> 
  <p>CNN 图例，来自 http://cs231n.github.io/convolutional-networks/</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNsWSXd47qsL0MkyxvkVzHeAoNCv0xjWKKmrrwzftblrJrxZCSyQQX9w/640?wx_fmt=jpeg"></p> 
  <p>上述代码是我建立的第一个卷积神经网络模型。 以下代码将我的GPU编号为“1”（这是因为我有4个GPU，您可以将其设置为您任何一个GPU）。 由于Tensorflow在多GPU上运行似乎不尽人意，因此把它限制在一个GPU上运行很合适的。 如果您没有GPU也请不要担心，尽管忽略下面的代码就好。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNrFHibNoDALibx8AFSwQQTPKicDFficVDoeEVQD84O5DVJwtxOgjBmS6N9A/640?wx_fmt=png"></p> 
  <p>构建CNN模型的代码是非常简单的。加入dropout层是为了避免过拟合问题。 损失函数的定义为均方误差（MSE），而优化器选用最先进的Adam自适应优化。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNLETcB25v2xnlL8q1U2gUEiadGpWghRg9qB7ysGH7zHKh8QGpo2hiaQkQ/640?wx_fmt=png"></p> 
  <p>唯一需要担心的是每层之间的输入数据和输出数据的维度。 计算某个卷积层输出数据维度的公式是：</p> 
  <blockquote> 
   <p>输出时间步长=（输入时间步长 - 核窗口大小）/步幅+ 1</p> 
  </blockquote> 
  <p>在下面代码的末尾，我添加了两个回调函数CSVLogger和ModelCheckpoint。 前者可以帮助我跟踪所有的训练和验证过程，而后者则可以存储每个周期的模型权重参数。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNCRebbjuN5vmSIXeVsuS8L1zEwxTwaV74l8TJ3eRicWngRyjMjIRgleQ/640?wx_fmt=jpeg"></p> 
  <p><strong>LSTM</strong></p> 
  <p>长期短期记忆（LSTM）网络是递归神经网络（RNN）的一种变体，发明它的目的是为了解决在普通RNN中存在的梯度消失问题。 据称LSTM能够记住更长的时序输入步长。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBN49hD5fgnmibiarjpquDcW7Le8HICxtFuyZl0mUkrmDL9SIo220YeMkhQ/640?wx_fmt=png"></p> 
  <p>LSTM 图例 (来自 http://colah.github.io/posts/2015-08-Understanding-LSTMs/&gt;)</p> 
  <p>&nbsp;</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBN7d0kEzbPqr8Jo72dLkPbXJMEMcjJ1ibo9cDY1A0Kn6he0ZwtQsLKAzw/640?wx_fmt=jpeg"></p> 
  <p>LSTM比CNN更容易通过代码实现，这是因为你根本不需要关心核窗口的大小，步长，输入和输出的数据维度大小之间的关系等。 只需要确保输入网络数据和输出网络的数据维度就可以了。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBN88ZDTiaNRMX0HUmTwtf73d32MkrZ2FCuR561UpMPibbep3doeSa0HA6w/640?wx_fmt=png"></p> 
  <p><strong>GRU</strong></p> 
  <p>门控循环单元（GRU）是RNN的另一种变体。 它的网络结构不如LSTM那么复杂，只有一个复位门和忘记门，而不是记忆单元。 据称GRU的性能与LSTM是相当的，但效率可以更高。 （在本文中也是如此的，因为LSTM大约需要跑45秒/周期，而GRU则不到40秒/周期）</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNA55N8ZlicB6UNEKCdYB3Na4jQFEN2N6DDV9q25swzCIvZI8u3SKagWQ/640?wx_fmt=png"></p> 
  <p>来自：http://www.jackdermody.net/brightwire/article/GRU_Recurrent_Neural_Networks)</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNm47VnT3ed0GfhheNRb01ibNoVficLxPkL7cDzjGtUunnzZyzGaqFRE9A/640?wx_fmt=jpeg"></p> 
  <p>只需将LSTM模型中的第二行</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNXT78iblYIoezI7Wdfzdib1rPJa1Kpc6bUj9gQULHzCDyhV9ZUQb71f5A/640?wx_fmt=png"></p> 
  <p>替换为</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNCJZ2Evr4Zhs6O2TvCFUDteBXIwM3ias89Py2CIfGvlsUFeC72mMUpKQ/640?wx_fmt=png"></p> 
  <p><strong>绘图结果</strong></p> 
  <p>由于三个模型的计算结果图像很相似，所以我只会查看CNN模型的图像。 首先，我们需要重建模型并将训练权重加载到模型中。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNicqribcUTB9qib31IHP2ibF4bBUic2XgCFzeW1apZTsB5dSKhU31U6RoqicQ/640?wx_fmt=jpeg"></p> 
  <p>然后，我们需要对预测后的数据进行反向缩放，因为之前使用了MinMaxScaler，因此此时预测的数据范围是在[0,1]。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNvMFVeRuSQHugpQZL3ZyczGC1znJh8c9Qm7tT6cKQTAu5PYkQicTepQg/640?wx_fmt=jpeg"></p> 
  <p>如上所示的两个Dataframes分别构造了真实值（实际价格）以及比特币的预测价格。为了更好的可视化，绘制的图像只显示了2017年8月之后的数据。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNHe5jNuqUeaoickKFaNFNECMgribtMstu0ye3Zics3vbPhWPWMTmq7F72w/640?wx_fmt=jpeg"></p> 
  <p>我们使用pyplot绘制图形。 由于预测出的价格是以16分钟为间隔的，所以为了让我们更方便的查看结果，我就不把它们全部链接起来了。 结果，这里预测的数据被绘制成红点，如第三行中的“ro”所示。</p> 
  <p>下图中的蓝线表示真实值（实际价格数据），而红点表示预测的比特币价格。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNrCf8oYmUxESqrs0Y7CePdtjZ8ibXjVd09Ooiae52r8pvVj3PPE0rWv3Q/640?wx_fmt=png"></p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNGme0vFTqxVMb6I2Xb0xWEEzyfLswZLvmmfRicty1V86VRKyBtaxv2lQ/640?wx_fmt=jpeg"></p> 
  <p><strong>使用2层CNN模型预测的最佳比特币价格</strong></p> 
  <p>从上图可以看出，预测价格与比特币的实际价格是非常相似的。 为了得到最佳模型效果，我决定测试集中配置下的神经网络，如下表所示。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNzaLNIbwaXKsD8P1AgpJpuBRca17zrE2iaNdo9Uza0ZLfUibNoTjCzmDA/640?wx_fmt=png"></p> 
  <p><strong>不同模型下的预测结果</strong></p> 
  <p>上表中的每一行都是从100个训练周期中得到的最佳验证损失的模型。 从以上结果可以看出，LeakyReLU似乎总是比通常的ReLU产生更好的损失效果。 但是，使用Leaky ReLU作为激活函数的4层CNN模型会得到较大的验证损失值，这可能是由于重新验证的模型所导致的问题。 CNN模型可以训练得非常快（使用GPU时，2秒/周期），在性能上要比LSTM和GRU稍差一点。 虽然3层CNN似乎可以更好地捕捉数据的局部时间依赖性，但最好的模型似乎是用 tanh和Leaky ReLU作为激活函数的LSTM模型。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNVSAEylHDmGWZ3pClnO14eHWBmyyTHmEzRLLREr2iap8xyJiauLyE90yA/640?wx_fmt=png"></p> 
  <p>用Tanh和Leaky ReLu作为激活函数的LSTM模型</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNJxlxCf92PnKoN5FZjcDlgJNjhw2sR1uCeUdicicEb3Vt2uibFkhZib9jEQ/640?wx_fmt=png"></p> 
  <p>用Leaky ReLu作为激活函数的3层CNN模型</p> 
  <p>虽然预测看起来都相当不错，但是过度拟合还是很值得留意的。 当用LeakyReLU训练LSTM时，训练损失和验证损失之间存在差距（5.97E-06 vs 3.92E-05），应该使用正则化来最小化这个差异。</p> 
  <p><strong>正则化</strong></p> 
  <p>为了找到最佳的正则化方案，我用L1和L2在不同的几个值中实验。 首先，我们需要定义一个新的函数来使得数据能够拟合到LSTM中。 在这里，我将使用在偏置正规化方法对偏差向量进行正则化。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNDL2JtibbxwHNAv96QjG6g5PodmToXjXyXDj3FPwfhmnulZGrt9sgZZg/640?wx_fmt=jpeg"></p> 
  <p>通过重复训练模型30次，每次30个周期为标准进行实验。</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNQcjic9pJhM9nI0tJbmtEB0CODWwkvtgLwlvLPureolC8XM0fWzKZkibw/640?wx_fmt=jpeg"></p> 
  <p>如果你使用的是Jupyter notebook，则可以直接从输出数据中查看如下表格。</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNUVMAKQUpAAb8huRakCBagZntxIcDyHA9tChg7YbE8YialTGXFxSCayQ/640?wx_fmt=png"></p> 
  <p>使用偏置正则化的结果</p> 
  <p><img alt="640?wx_fmt=jpeg" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBN6fnhfTbUeA3EUuPJUEpZVKm3GDdRYdib1eRcLIHlB5FmhxxebiajAUnQ/640?wx_fmt=jpeg"></p> 
  <p>为了可视化比较，我们可以使用boxplot绘图：</p> 
  <p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/BnSNEaficFAbjDVFRdIG98zziaicNzpkOBNgpTO7GgCgjHpsAZiaZyotp2ws7YzNLhZ1h3T1hgKDODMzDC1DmFGqAg/640?wx_fmt=png"></p> 
  <p>通过比较可知，L2正则化中偏差向量的系数为0.01时可以似乎得到了最好的结果。</p> 
  <p>为了找出所有超参数正则化之间的最佳组合，包括激活，偏置，核窗口，循环矩阵等等，有必要逐一测试所有正则化方案，但这对我目前的硬件配置来说并不现实。 因此，我将搁置下来以后再议。</p> 
  <p><strong>结论</strong></p> 
  <p>从本文，你已经了解到：</p> 
  <ul>
   <li> <p>如何收集时序的比特币数据。</p> </li> 
   <li> <p>如何准备数据进行训练和预测。</p> </li> 
   <li> <p>如何使用深度学习技术预测比特币的价格。</p> </li> 
   <li> <p>如何可视化预测的结果。</p> </li> 
   <li> <p>如何在模型上应用正则化技术。</p> </li> 
  </ul>
  <p>&nbsp;</p> 
  <p>来源: AI科技大本营</p> 
  <p>英文原文来源：</p> 
  <p>https://github.com/khuangaf</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/starzhou/article/details/81603187,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/starzhou/article/details/81603187,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
