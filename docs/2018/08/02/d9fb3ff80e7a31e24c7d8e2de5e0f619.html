<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>第十篇 墨客区块链(MOAC BlockChain) 如何将自定义数据写到区块链中 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="第十篇 墨客区块链(MOAC BlockChain) 如何将自定义数据写到区块链中" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链的一个显著特点是，数据一旦写入链中，就不可篡改重写。 在墨客区块链中，每一笔交易（transaction），都有一个保存数据的data空间，本文主要讲解如何将自定义数据（可以是一句话、一篇文章等）写入区块链的交易中，并读取出来。 当然，保存数据到区块链是会消耗gas费的，且gas费跟数据量是正相关的。 本文内容不适用于有强逻辑性和关系型的大数据存储。 1.做一笔交易，将数据写入区块链 该笔交易没有发送mc，或者其他token，仅将数据写到区块链。 代码文档sendData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7aXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; send(chain3, account.address, account.secret, txCount = -1); function send(chain3, fromAddress, fromSecret, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var gasTotal = gasPrice * gasLimit; console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;Hello MOAC!!!&quot; }; //转换log数据格式 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 代码使用sendRawTransaction时需要私钥签名，得到本地节点账号的私钥方法见： 《第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约》的第三节“3.部署智能合约”。 直接node，运行结果如下： 返回信息中包含： 本次交易写入数据“Hello MOAC!!!”及其十六进制表示。 本次交易的hash值：0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc。 到浏览器查询hash： 其中的Input Data就是本次交易写入的数据。与node sendData.js时显示的hex格式数据内容一致。 &nbsp; 2.查看区块链里的数据字段 当前，每笔交易里的数据在浏览器还显示为hex。因此需要自己写代码解读出其中的内容。 读数据代码callData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //设置API访问moac节点方式 //获取交易信息 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; var receipt = chain3.mc.getTransaction(hash); console.log(&#39;get transaction from hash :&#39;+ JSON.stringify(receipt)); console.log(); //获取交易内保存的数据data，需要提前写入 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; chain3.mc.getTransaction(hash,function(error, result){ //console.log(result); inputData = result.input; res_str = Buffer.from(inputData.replace(&#39;0x&#39;,&#39;&#39;),&#39;hex&#39;).toString(); res_json = JSON.parse(res_str); console.log(&#39;your data :&#39;,res_json); console.log(&#39;your msg :&#39;,res_json.msg); }); 直接node，运行结果如下： 通过交易hash得到交易的所有信息，并分析出data数据。 &nbsp; 3.将数据批量写入区块链 结合对excel表格的读写操作，可以简单地将批量数据写入到区块链中去。 首先设计一个excel文件，保存要写到区块链的数据。命名为testMessage.xlsx。 本实例用到message。id和name不在代码里使用，仅用于文档记录。time用于返回时间，在成功后会新建一个文件，返回每次信息发送的时间。 代码文件goMessage.js。node执行即可。 注意：1. 将数据上链的交易会收取gas费，且收取的费用跟数据大小正相关；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. 该代码里包含手动设置nounce完成tx的实例。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //通过node-xlsx读取的excel文件就是一个json数据 var xlsx = require(&#39;node-xlsx&#39;); //定义xlsx，自行npm install node-xlsx var fs = require(&#39;fs&#39;); //定义fs，自行npm install fs var address = &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;; var account = { address: &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;, secret: &quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot; }; //主要参数 var thisTxCount = -1; //nounce值，本例手动设置，初始为-1，读取实际值后，每次自增1 var interval = 2; //发送一次信息的间隔时间，秒 var message = &quot;Hello MOAC!!!&quot;; //定义要发送的信息，从cxcel文件读取 var obj = xlsx.parse(__dirname + &#39;/testMessage.xlsx&#39;);//配置excel文件的路径 var excelObj = obj[0].data; //obj[i].data表示excel文件第i+1个sheet文档的全部内容 var data = []; var promiseList = []; //用于异步返回 for (var i in excelObj) { var arr = []; if (i &gt; 0) { //数据从第二行开始，通常在excel中第一行（i=0）就是每一列的title sleep(interval * 1000); //每隔2秒，发送一次信息 message = excelObj[i][2]; //得到要发送的信息内容 excelObj[i][3] = (new Date).toLocaleString(); //记录发送交易的时间 promiseList.push(send(chain3, account.address, account.secret, message, thisTxCount, i)); } } Promise.all(promiseList).then(function (objList) { //所有异步完成后回调 //遍历objList objList.forEach(item=&gt;{ excelObj[item.index][4] = item.hash; //记录发送交易的哈希 }) var buffer = xlsx.build([ { name: &#39;sheet1&#39;, data: excelObj } ]); //创建新文件，将发送时间等记录到文件中 fs.writeFileSync((new Date).toLocaleDateString() + &#39;-&#39; + (new Date).getTime() + &#39;-&#39; + &#39;hadSendMessage.xlsx&#39;, buffer, {&#39;flag&#39;: &#39;w&#39;}); }); //自己写的休眠函数 function sleep(numberMillis) { var now = new Date(); var exitTime = now.getTime() + numberMillis; while (true) { now = new Date(); if (now.getTime() &gt; exitTime) return; } } function send(chain3, fromAddress, fromSecret, message, txCount = -1, index) { var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);//获取nounce值 //console.log(&quot;Get tx account&quot;, txcount); thisTxCount = txcount + 1; //手动设置nounce，每次自增1 var gasPrice = 25000000000; var gasLimit = 100000; //数据量越大，gas费应该设置得越高 var gasTotal = gasPrice * gasLimit; //console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time: (new Date).getTime(), //获取当前时间(从1970.1.1开始的毫秒数) type: &quot;info&quot;, msg: message }; //转换log数据格式,将数据转换为16进制字符串 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39; + data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data, shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); return new Promise(function (resolve, reject) { //异步调用方法 mc.sendRawTransaction(signedTx, function (err, hash) { if (!err) { console.log(&#39;i=&#39;, index); console.log(&quot;succeed: &quot;, hash); let objBack = { //index及对应的hash hash, index } resolve(objBack); } else { console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); reject(err); } }); }) } 执行结果：返回所有交易的hash值。 并且建立一个新的文件2018-8-12-1534085632480-hadSendMessage.xlsx。 &nbsp; 4.在交易里发送 mc + data 发送一笔交易，包含发送mc，同时把数据写到data字段。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var amount = 0.002; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;MOAC GO!!!&quot; }; let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } &nbsp; 阅读更多" />
<meta property="og:description" content="区块链的一个显著特点是，数据一旦写入链中，就不可篡改重写。 在墨客区块链中，每一笔交易（transaction），都有一个保存数据的data空间，本文主要讲解如何将自定义数据（可以是一句话、一篇文章等）写入区块链的交易中，并读取出来。 当然，保存数据到区块链是会消耗gas费的，且gas费跟数据量是正相关的。 本文内容不适用于有强逻辑性和关系型的大数据存储。 1.做一笔交易，将数据写入区块链 该笔交易没有发送mc，或者其他token，仅将数据写到区块链。 代码文档sendData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7aXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; send(chain3, account.address, account.secret, txCount = -1); function send(chain3, fromAddress, fromSecret, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var gasTotal = gasPrice * gasLimit; console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;Hello MOAC!!!&quot; }; //转换log数据格式 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 代码使用sendRawTransaction时需要私钥签名，得到本地节点账号的私钥方法见： 《第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约》的第三节“3.部署智能合约”。 直接node，运行结果如下： 返回信息中包含： 本次交易写入数据“Hello MOAC!!!”及其十六进制表示。 本次交易的hash值：0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc。 到浏览器查询hash： 其中的Input Data就是本次交易写入的数据。与node sendData.js时显示的hex格式数据内容一致。 &nbsp; 2.查看区块链里的数据字段 当前，每笔交易里的数据在浏览器还显示为hex。因此需要自己写代码解读出其中的内容。 读数据代码callData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //设置API访问moac节点方式 //获取交易信息 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; var receipt = chain3.mc.getTransaction(hash); console.log(&#39;get transaction from hash :&#39;+ JSON.stringify(receipt)); console.log(); //获取交易内保存的数据data，需要提前写入 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; chain3.mc.getTransaction(hash,function(error, result){ //console.log(result); inputData = result.input; res_str = Buffer.from(inputData.replace(&#39;0x&#39;,&#39;&#39;),&#39;hex&#39;).toString(); res_json = JSON.parse(res_str); console.log(&#39;your data :&#39;,res_json); console.log(&#39;your msg :&#39;,res_json.msg); }); 直接node，运行结果如下： 通过交易hash得到交易的所有信息，并分析出data数据。 &nbsp; 3.将数据批量写入区块链 结合对excel表格的读写操作，可以简单地将批量数据写入到区块链中去。 首先设计一个excel文件，保存要写到区块链的数据。命名为testMessage.xlsx。 本实例用到message。id和name不在代码里使用，仅用于文档记录。time用于返回时间，在成功后会新建一个文件，返回每次信息发送的时间。 代码文件goMessage.js。node执行即可。 注意：1. 将数据上链的交易会收取gas费，且收取的费用跟数据大小正相关；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. 该代码里包含手动设置nounce完成tx的实例。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //通过node-xlsx读取的excel文件就是一个json数据 var xlsx = require(&#39;node-xlsx&#39;); //定义xlsx，自行npm install node-xlsx var fs = require(&#39;fs&#39;); //定义fs，自行npm install fs var address = &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;; var account = { address: &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;, secret: &quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot; }; //主要参数 var thisTxCount = -1; //nounce值，本例手动设置，初始为-1，读取实际值后，每次自增1 var interval = 2; //发送一次信息的间隔时间，秒 var message = &quot;Hello MOAC!!!&quot;; //定义要发送的信息，从cxcel文件读取 var obj = xlsx.parse(__dirname + &#39;/testMessage.xlsx&#39;);//配置excel文件的路径 var excelObj = obj[0].data; //obj[i].data表示excel文件第i+1个sheet文档的全部内容 var data = []; var promiseList = []; //用于异步返回 for (var i in excelObj) { var arr = []; if (i &gt; 0) { //数据从第二行开始，通常在excel中第一行（i=0）就是每一列的title sleep(interval * 1000); //每隔2秒，发送一次信息 message = excelObj[i][2]; //得到要发送的信息内容 excelObj[i][3] = (new Date).toLocaleString(); //记录发送交易的时间 promiseList.push(send(chain3, account.address, account.secret, message, thisTxCount, i)); } } Promise.all(promiseList).then(function (objList) { //所有异步完成后回调 //遍历objList objList.forEach(item=&gt;{ excelObj[item.index][4] = item.hash; //记录发送交易的哈希 }) var buffer = xlsx.build([ { name: &#39;sheet1&#39;, data: excelObj } ]); //创建新文件，将发送时间等记录到文件中 fs.writeFileSync((new Date).toLocaleDateString() + &#39;-&#39; + (new Date).getTime() + &#39;-&#39; + &#39;hadSendMessage.xlsx&#39;, buffer, {&#39;flag&#39;: &#39;w&#39;}); }); //自己写的休眠函数 function sleep(numberMillis) { var now = new Date(); var exitTime = now.getTime() + numberMillis; while (true) { now = new Date(); if (now.getTime() &gt; exitTime) return; } } function send(chain3, fromAddress, fromSecret, message, txCount = -1, index) { var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);//获取nounce值 //console.log(&quot;Get tx account&quot;, txcount); thisTxCount = txcount + 1; //手动设置nounce，每次自增1 var gasPrice = 25000000000; var gasLimit = 100000; //数据量越大，gas费应该设置得越高 var gasTotal = gasPrice * gasLimit; //console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time: (new Date).getTime(), //获取当前时间(从1970.1.1开始的毫秒数) type: &quot;info&quot;, msg: message }; //转换log数据格式,将数据转换为16进制字符串 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39; + data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data, shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); return new Promise(function (resolve, reject) { //异步调用方法 mc.sendRawTransaction(signedTx, function (err, hash) { if (!err) { console.log(&#39;i=&#39;, index); console.log(&quot;succeed: &quot;, hash); let objBack = { //index及对应的hash hash, index } resolve(objBack); } else { console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); reject(err); } }); }) } 执行结果：返回所有交易的hash值。 并且建立一个新的文件2018-8-12-1534085632480-hadSendMessage.xlsx。 &nbsp; 4.在交易里发送 mc + data 发送一笔交易，包含发送mc，同时把数据写到data字段。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var amount = 0.002; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;MOAC GO!!!&quot; }; let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-02T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链的一个显著特点是，数据一旦写入链中，就不可篡改重写。 在墨客区块链中，每一笔交易（transaction），都有一个保存数据的data空间，本文主要讲解如何将自定义数据（可以是一句话、一篇文章等）写入区块链的交易中，并读取出来。 当然，保存数据到区块链是会消耗gas费的，且gas费跟数据量是正相关的。 本文内容不适用于有强逻辑性和关系型的大数据存储。 1.做一笔交易，将数据写入区块链 该笔交易没有发送mc，或者其他token，仅将数据写到区块链。 代码文档sendData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7aXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; send(chain3, account.address, account.secret, txCount = -1); function send(chain3, fromAddress, fromSecret, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var gasTotal = gasPrice * gasLimit; console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;Hello MOAC!!!&quot; }; //转换log数据格式 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 代码使用sendRawTransaction时需要私钥签名，得到本地节点账号的私钥方法见： 《第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约》的第三节“3.部署智能合约”。 直接node，运行结果如下： 返回信息中包含： 本次交易写入数据“Hello MOAC!!!”及其十六进制表示。 本次交易的hash值：0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc。 到浏览器查询hash： 其中的Input Data就是本次交易写入的数据。与node sendData.js时显示的hex格式数据内容一致。 &nbsp; 2.查看区块链里的数据字段 当前，每笔交易里的数据在浏览器还显示为hex。因此需要自己写代码解读出其中的内容。 读数据代码callData.js如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //设置API访问moac节点方式 //获取交易信息 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; var receipt = chain3.mc.getTransaction(hash); console.log(&#39;get transaction from hash :&#39;+ JSON.stringify(receipt)); console.log(); //获取交易内保存的数据data，需要提前写入 hash = &quot;0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc&quot;; chain3.mc.getTransaction(hash,function(error, result){ //console.log(result); inputData = result.input; res_str = Buffer.from(inputData.replace(&#39;0x&#39;,&#39;&#39;),&#39;hex&#39;).toString(); res_json = JSON.parse(res_str); console.log(&#39;your data :&#39;,res_json); console.log(&#39;your msg :&#39;,res_json.msg); }); 直接node，运行结果如下： 通过交易hash得到交易的所有信息，并分析出data数据。 &nbsp; 3.将数据批量写入区块链 结合对excel表格的读写操作，可以简单地将批量数据写入到区块链中去。 首先设计一个excel文件，保存要写到区块链的数据。命名为testMessage.xlsx。 本实例用到message。id和name不在代码里使用，仅用于文档记录。time用于返回时间，在成功后会新建一个文件，返回每次信息发送的时间。 代码文件goMessage.js。node执行即可。 注意：1. 将数据上链的交易会收取gas费，且收取的费用跟数据大小正相关；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. 该代码里包含手动设置nounce完成tx的实例。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); //通过node-xlsx读取的excel文件就是一个json数据 var xlsx = require(&#39;node-xlsx&#39;); //定义xlsx，自行npm install node-xlsx var fs = require(&#39;fs&#39;); //定义fs，自行npm install fs var address = &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;; var account = { address: &quot;0x745c57ca5318093115d61bbca36XXXXXXXXXXXX&quot;, secret: &quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot; }; //主要参数 var thisTxCount = -1; //nounce值，本例手动设置，初始为-1，读取实际值后，每次自增1 var interval = 2; //发送一次信息的间隔时间，秒 var message = &quot;Hello MOAC!!!&quot;; //定义要发送的信息，从cxcel文件读取 var obj = xlsx.parse(__dirname + &#39;/testMessage.xlsx&#39;);//配置excel文件的路径 var excelObj = obj[0].data; //obj[i].data表示excel文件第i+1个sheet文档的全部内容 var data = []; var promiseList = []; //用于异步返回 for (var i in excelObj) { var arr = []; if (i &gt; 0) { //数据从第二行开始，通常在excel中第一行（i=0）就是每一列的title sleep(interval * 1000); //每隔2秒，发送一次信息 message = excelObj[i][2]; //得到要发送的信息内容 excelObj[i][3] = (new Date).toLocaleString(); //记录发送交易的时间 promiseList.push(send(chain3, account.address, account.secret, message, thisTxCount, i)); } } Promise.all(promiseList).then(function (objList) { //所有异步完成后回调 //遍历objList objList.forEach(item=&gt;{ excelObj[item.index][4] = item.hash; //记录发送交易的哈希 }) var buffer = xlsx.build([ { name: &#39;sheet1&#39;, data: excelObj } ]); //创建新文件，将发送时间等记录到文件中 fs.writeFileSync((new Date).toLocaleDateString() + &#39;-&#39; + (new Date).getTime() + &#39;-&#39; + &#39;hadSendMessage.xlsx&#39;, buffer, {&#39;flag&#39;: &#39;w&#39;}); }); //自己写的休眠函数 function sleep(numberMillis) { var now = new Date(); var exitTime = now.getTime() + numberMillis; while (true) { now = new Date(); if (now.getTime() &gt; exitTime) return; } } function send(chain3, fromAddress, fromSecret, message, txCount = -1, index) { var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);//获取nounce值 //console.log(&quot;Get tx account&quot;, txcount); thisTxCount = txcount + 1; //手动设置nounce，每次自增1 var gasPrice = 25000000000; var gasLimit = 100000; //数据量越大，gas费应该设置得越高 var gasTotal = gasPrice * gasLimit; //console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time: (new Date).getTime(), //获取当前时间(从1970.1.1开始的毫秒数) type: &quot;info&quot;, msg: message }; //转换log数据格式,将数据转换为16进制字符串 let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39; + data; console.log(data); var rawTx = { from: fromAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), data: data, shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); return new Promise(function (resolve, reject) { //异步调用方法 mc.sendRawTransaction(signedTx, function (err, hash) { if (!err) { console.log(&#39;i=&#39;, index); console.log(&quot;succeed: &quot;, hash); let objBack = { //index及对应的hash hash, index } resolve(objBack); } else { console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); reject(err); } }); }) } 执行结果：返回所有交易的hash值。 并且建立一个新的文件2018-8-12-1534085632480-hadSendMessage.xlsx。 &nbsp; 4.在交易里发送 mc + data 发送一笔交易，包含发送mc，同时把数据写到data字段。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var address = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var amount = 0.002; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); //以下为写入数据log let log = { time:(new Date).getTime(), type:&quot;info&quot;, msg:&quot;MOAC GO!!!&quot; }; let str = JSON.stringify(log); console.log(str); let data = Buffer.from(str).toString(&#39;hex&#39;); data = &#39;0x&#39;+data; console.log(data); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), data: data , shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } &nbsp; 阅读更多","@type":"BlogPosting","url":"/2018/08/02/d9fb3ff80e7a31e24c7d8e2de5e0f619.html","headline":"第十篇 墨客区块链(MOAC BlockChain) 如何将自定义数据写到区块链中","dateModified":"2018-08-02T00:00:00+08:00","datePublished":"2018-08-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/02/d9fb3ff80e7a31e24c7d8e2de5e0f619.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>第十篇 墨客区块链(MOAC BlockChain) 如何将自定义数据写到区块链中</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>区块链的一个显著特点是，数据一旦写入链中，就不可篡改重写。</p> 
  <p>在墨客区块链中，每一笔交易（transaction），都有一个保存数据的data空间，本文主要讲解如何将自定义数据（可以是一句话、一篇文章等）写入区块链的交易中，并读取出来。</p> 
  <p>当然，保存数据到区块链是会消耗gas费的，且gas费跟数据量是正相关的。</p> 
  <p>本文内容不适用于有强逻辑性和关系型的大数据存储。</p> 
  <p><strong>1.做一笔交易，将数据写入区块链</strong></p> 
  <p>该笔交易没有发送mc，或者其他token，仅将数据写到区块链。</p> 
  <p>代码文档sendData.js如下：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

var address = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var account = {address:"0x745c57ca5318093115d61bbca368XXXXXXXXXXXX",secret:"bb673026deda3c3cd0c63f6ccddfb02a7aXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"};

send(chain3, account.address, account.secret, txCount = -1);

function send(chain3, fromAddress, fromSecret, txCount = -1){
  var mc = chain3.mc;
  var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);
  console.log("Get tx account", txcount);

  var gasPrice = 25000000000;
  var gasLimit = 100000;
  var gasTotal = gasPrice * gasLimit;
  console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, 'mc'));
  
  //以下为写入数据log
  let log = {
    time:(new Date).getTime(),
    type:"info",
    msg:"Hello MOAC!!!"
  };
  //转换log数据格式
  let str = JSON.stringify(log);
  console.log(str);
  let data = Buffer.from(str).toString('hex');
  data = '0x'+data;
  console.log(data);  

  var rawTx = {
    from: fromAddress,
    nonce: chain3.intToHex(txcount),
    gasPrice: chain3.intToHex(gasPrice),
    gasLimit: chain3.intToHex(gasLimit),
    data: data ,
    shardingFlag: 0, //default is global contract
    chainId: chain3.version.network
  };

  var signedTx = chain3.signTransaction(rawTx, fromSecret);
  mc.sendRawTransaction(signedTx, function(err, hash) {
      if (!err){
          console.log("succeed: ", hash);
          return hash;
      }else{
          console.log("error:", err);
          console.log('raw tx:', rawTx);
      }
  });
}</code></pre> 
  <p>代码使用sendRawTransaction时需要私钥签名，得到本地节点账号的私钥方法见：</p> 
  <p>《<a href="https://blog.csdn.net/lyq13573221675/article/details/81285250" rel="nofollow">第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约</a>》的第三节“<strong>3.部署智能合约</strong>”。</p> 
  <p>直接node，运行结果如下：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180802121341764?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>返回信息中包含：</p> 
  <p>本次交易写入数据“Hello MOAC!!!”及其十六进制表示。</p> 
  <p>本次交易的hash值：0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc。</p> 
  <p>到<a href="http://explorer.moac.io/tx/0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc" rel="nofollow">浏览器</a>查询hash：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180802122009729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>其中的Input Data就是本次交易写入的数据。与node sendData.js时显示的hex格式数据内容一致。</p> 
  <p>&nbsp;</p> 
  <p><strong>2.查看区块链里的数据字段</strong></p> 
  <p>当前，每笔交易里的数据在浏览器还显示为hex。因此需要自己写代码解读出其中的内容。</p> 
  <p>读数据代码callData.js如下：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));  //设置API访问moac节点方式

//获取交易信息
hash = "0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc";
var receipt = chain3.mc.getTransaction(hash);
console.log('get transaction from hash  :'+ JSON.stringify(receipt));

console.log();
//获取交易内保存的数据data，需要提前写入
hash = "0x7834667df3890d0a4bc2fc949d45206fec8fe4b63853181dd9cc20c1b6c009dc";
chain3.mc.getTransaction(hash,function(error, result){
    //console.log(result);
    inputData = result.input;
    res_str = Buffer.from(inputData.replace('0x',''),'hex').toString();
    res_json = JSON.parse(res_str);
    console.log('your data :',res_json);
    console.log('your msg  :',res_json.msg);
});</code></pre> 
  <p>直接node，运行结果如下：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180802123530747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>通过交易hash得到交易的所有信息，并分析出data数据。</p> 
  <p>&nbsp;</p> 
  <p><strong>3.将数据批量写入区块链</strong></p> 
  <p>结合对excel表格的读写操作，可以简单地将批量数据写入到区块链中去。</p> 
  <p>首先设计一个excel文件，保存要写到区块链的数据。命名为testMessage.xlsx。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180805223710987?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>本实例用到message。id和name不在代码里使用，仅用于文档记录。time用于返回时间，在成功后会新建一个文件，返回每次信息发送的时间。</p> 
  <p>代码文件goMessage.js。node执行即可。</p> 
  <p><span style="color:#ff0000;">注意：</span><span style="color:#ff0000;">1. </span><span style="color:#ff0000;">将数据上链的交易会收取</span><span style="color:#ff0000;">gas</span><span style="color:#ff0000;">费，且收取的费用跟数据大小正相关；</span><br><span style="color:#ff0000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. </span><span style="color:#ff0000;">该代码里包含手动设置nounce完成tx的实例。</span></p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

//通过node-xlsx读取的excel文件就是一个json数据
var xlsx = require('node-xlsx');    //定义xlsx，自行npm install node-xlsx
var fs = require('fs');             //定义fs，自行npm install fs

var address = "0x745c57ca5318093115d61bbca36XXXXXXXXXXXX";
var account = {
    address: "0x745c57ca5318093115d61bbca36XXXXXXXXXXXX",
    secret: "bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX"
};

//主要参数
var thisTxCount = -1;               //nounce值，本例手动设置，初始为-1，读取实际值后，每次自增1
var interval = 2;                   //发送一次信息的间隔时间，秒
var message = "Hello MOAC!!!";      //定义要发送的信息，从cxcel文件读取

var obj = xlsx.parse(__dirname + '/testMessage.xlsx');//配置excel文件的路径
var excelObj = obj[0].data;         //obj[i].data表示excel文件第i+1个sheet文档的全部内容

var data = [];
var promiseList = [];               //用于异步返回
for (var i in excelObj) {
    var arr = [];
    if (i &gt; 0) {                    //数据从第二行开始，通常在excel中第一行（i=0）就是每一列的title
        sleep(interval * 1000);     //每隔2秒，发送一次信息
        message = excelObj[i][2];   //得到要发送的信息内容
        excelObj[i][3] = (new Date).toLocaleString();  //记录发送交易的时间
        promiseList.push(send(chain3, account.address, account.secret, message, thisTxCount, i));		
    }
}

Promise.all(promiseList).then(function (objList) {  //所有异步完成后回调
    //遍历objList
    objList.forEach(item=&gt;{
        excelObj[item.index][4] = item.hash;        //记录发送交易的哈希
    })
    var buffer = xlsx.build([
        {
            name: 'sheet1',
            data: excelObj
        }
    ]);
    //创建新文件，将发送时间等记录到文件中
    fs.writeFileSync((new Date).toLocaleDateString() + '-' + (new Date).getTime() + '-' + 'hadSendMessage.xlsx', buffer, {'flag': 'w'});
});

//自己写的休眠函数
function sleep(numberMillis) {
    var now = new Date();
    var exitTime = now.getTime() + numberMillis;
    while (true) {
        now = new Date();
        if (now.getTime() &gt; exitTime)
            return;
    }
}

function send(chain3, fromAddress, fromSecret, message, txCount = -1, index) {
    var mc = chain3.mc;
    var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);//获取nounce值
    //console.log("Get tx account", txcount);
    thisTxCount = txcount + 1;        //手动设置nounce，每次自增1

    var gasPrice = 25000000000;
    var gasLimit = 100000;            //数据量越大，gas费应该设置得越高
    var gasTotal = gasPrice * gasLimit;
    //console.log(gasPrice, gasLimit, chain3.fromSha(gasTotal, 'mc'));

    //以下为写入数据log
    let log = {
        time: (new Date).getTime(),   //获取当前时间(从1970.1.1开始的毫秒数)
        type: "info",
        msg: message
    };
    //转换log数据格式,将数据转换为16进制字符串
    let str = JSON.stringify(log);
    console.log(str);
    let data = Buffer.from(str).toString('hex');
    data = '0x' + data;
    console.log(data);

    var rawTx = {
        from: fromAddress,
        nonce: chain3.intToHex(txcount),
        gasPrice: chain3.intToHex(gasPrice),
        gasLimit: chain3.intToHex(gasLimit),
        data: data,
        shardingFlag: 0, //default is global contract
        chainId: chain3.version.network
    };

    var signedTx = chain3.signTransaction(rawTx, fromSecret);
    return new Promise(function (resolve, reject) {                   //异步调用方法
        mc.sendRawTransaction(signedTx, function (err, hash) {
            if (!err) {                
                console.log('i=', index);
                console.log("succeed: ", hash);
                let objBack = {                                       //index及对应的hash
                    hash,
                    index
                }
                resolve(objBack);
            } else {
                console.log("error:", err);
                console.log('raw tx:', rawTx);
                reject(err);
            }
        });
    })
}
</code></pre> 
  <p>执行结果：返回所有交易的hash值。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812230950590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>并且建立一个新的文件2018-8-12-1534085632480-hadSendMessage.xlsx。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180812231244601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p><strong>4.在交易里发送 mc + data</strong></p> 
  <p>发送一笔交易，包含发送mc，同时把数据写到data字段。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

var address = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var account = {address:"0x745c57ca5318093115d61bbca368XXXXXXXXXXXX",secret:"bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX"};

var toAddress = "0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX";
var amount = 0.002;

send(chain3, account.address, account.secret, toAddress, amount, txCount = -1)

function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){
  var mc = chain3.mc;
  var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);
  console.log("Get tx account", txcount);

  var gasPrice = 25000000000;
  var gasLimit = 100000;
  var value = chain3.toSha(amount, 'mc');
  var gasTotal = gasPrice * gasLimit + Number(value);
  console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, 'mc'));
  
  //以下为写入数据log
  let log = {
    time:(new Date).getTime(),
    type:"info",
    msg:"MOAC GO!!!"
  };
  let str = JSON.stringify(log);
  console.log(str);
  let data = Buffer.from(str).toString('hex');
  data = '0x'+data;
  console.log(data);  

  var rawTx = {
    from: fromAddress,
    to: toAddress,
    nonce: chain3.intToHex(txcount),
    gasPrice: chain3.intToHex(gasPrice),
    gasLimit: chain3.intToHex(gasLimit),
    value: chain3.intToHex(value),
    data: data ,
    shardingFlag: 0, //default is global contract
    chainId: chain3.version.network
  };

  var signedTx = chain3.signTransaction(rawTx, fromSecret);
  mc.sendRawTransaction(signedTx, function(err, hash) {
      if (!err){
          console.log("succeed: ", hash);
          return hash;
      }else{
          console.log("error:", err);
	        console.log('raw tx:', rawTx);
      }
  });
}</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/81354458,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/81354458,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
