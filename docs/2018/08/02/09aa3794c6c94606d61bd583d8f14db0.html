<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>手把手教你发行属于自己的区块链Token | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="手把手教你发行属于自己的区块链Token" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="手把手教你发行属于自己的区块链Token &nbsp; 预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。&nbsp; 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。&nbsp; 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署&nbsp; 之后会弹出确认transaction的面板，拖到最下面点击confirm&nbsp;MetaMask会弹出，确认交易，点击submit&nbsp;&nbsp; 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板&nbsp; 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05&nbsp; 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add&nbsp;&nbsp; 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。&nbsp; 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示&nbsp; 在Contract name:的输入框输入部署的合约名称Token,&nbsp;Compiler&nbsp;选择在remix的sttings 中Solidity version&nbsp;显示的版本号。Optimization&nbsp;选择&nbsp;No。 然后在Enter the Solidity Contract Code below&nbsp;下面的输入框中原样填入Remix中的代码&nbsp; 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样&nbsp; 至此Token发行教程完结。 阅读更多" />
<meta property="og:description" content="手把手教你发行属于自己的区块链Token &nbsp; 预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。&nbsp; 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。&nbsp; 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署&nbsp; 之后会弹出确认transaction的面板，拖到最下面点击confirm&nbsp;MetaMask会弹出，确认交易，点击submit&nbsp;&nbsp; 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板&nbsp; 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05&nbsp; 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add&nbsp;&nbsp; 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。&nbsp; 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示&nbsp; 在Contract name:的输入框输入部署的合约名称Token,&nbsp;Compiler&nbsp;选择在remix的sttings 中Solidity version&nbsp;显示的版本号。Optimization&nbsp;选择&nbsp;No。 然后在Enter the Solidity Contract Code below&nbsp;下面的输入框中原样填入Remix中的代码&nbsp; 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样&nbsp; 至此Token发行教程完结。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/02/09aa3794c6c94606d61bd583d8f14db0.html" />
<meta property="og:url" content="https://mlh.app/2018/08/02/09aa3794c6c94606d61bd583d8f14db0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-02T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"手把手教你发行属于自己的区块链Token &nbsp; 预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。&nbsp; 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。&nbsp; 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署&nbsp; 之后会弹出确认transaction的面板，拖到最下面点击confirm&nbsp;MetaMask会弹出，确认交易，点击submit&nbsp;&nbsp; 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板&nbsp; 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05&nbsp; 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add&nbsp;&nbsp; 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。&nbsp; 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示&nbsp; 在Contract name:的输入框输入部署的合约名称Token,&nbsp;Compiler&nbsp;选择在remix的sttings 中Solidity version&nbsp;显示的版本号。Optimization&nbsp;选择&nbsp;No。 然后在Enter the Solidity Contract Code below&nbsp;下面的输入框中原样填入Remix中的代码&nbsp; 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样&nbsp; 至此Token发行教程完结。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/02/09aa3794c6c94606d61bd583d8f14db0.html","headline":"手把手教你发行属于自己的区块链Token","dateModified":"2018-08-02T00:00:00+08:00","datePublished":"2018-08-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/02/09aa3794c6c94606d61bd583d8f14db0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>手把手教你发行属于自己的区块链Token</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1>手把手教你发行属于自己的区块链Token</h1> 
  <p>&nbsp;</p> 
  <h1 id="预先准备"><a name="t0"></a>预先准备</h1> 
  <ul>
   <li><a href="https://www.myetherwallet.com/" rel="nofollow">以太坊钱包</a></li> 
   <li>一定数量的eth余额</li> 
   <li><a href="https://metamask.io/" rel="nofollow">MetaMask</a></li> 
  </ul>
  <h1 id="token的参数"><a name="t1"></a>Token的参数</h1> 
  <p>在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token</p> 
  <ul>
   <li>Token的名称：<strong>Dylan Token</strong></li> 
   <li>Token的标识：<strong>DT</strong></li> 
   <li>发行量：<strong>19940512</strong></li> 
   <li>Token的小数位：<strong>18</strong></li> 
  </ul>
  <h1 id="编写合约"><a name="t2"></a>编写合约</h1> 
  <p>想要基于以太坊拥有自己的<strong>Token</strong>，需要通过智能合约的形式去发行，编写如下基于<strong>ERC20</strong>的<strong>solidity</strong>代码：</p> 
  <pre class="has">
<code>pragma solidity ^0.4.18;

library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &gt;= a);
    return c;
  }
}

contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract StandardToken is ERC20, BasicToken {

  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &lt;= balances[_from]);
    require(_value &lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

contract Token is StandardToken {

    string public name    = "Dylan Token";
    string public symbol  = "DT";
    uint8 public decimals = 18;

    uint256 public constant INITIAL_SUPPLY = 19940512;

    function Token() public {
        totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
    }
}</code></pre> 
  <ul>
   <li>1</li> 
   <li>2</li> 
   <li>3</li> 
   <li>4</li> 
   <li>5</li> 
   <li>6</li> 
   <li>7</li> 
   <li>8</li> 
   <li>9</li> 
   <li>10</li> 
   <li>11</li> 
   <li>12</li> 
   <li>13</li> 
   <li>14</li> 
   <li>15</li> 
   <li>16</li> 
   <li>17</li> 
   <li>18</li> 
   <li>19</li> 
   <li>20</li> 
   <li>21</li> 
   <li>22</li> 
   <li>23</li> 
   <li>24</li> 
   <li>25</li> 
   <li>26</li> 
   <li>27</li> 
   <li>28</li> 
   <li>29</li> 
   <li>30</li> 
   <li>31</li> 
   <li>32</li> 
   <li>33</li> 
   <li>34</li> 
   <li>35</li> 
   <li>36</li> 
   <li>37</li> 
   <li>38</li> 
   <li>39</li> 
   <li>40</li> 
   <li>41</li> 
   <li>42</li> 
   <li>43</li> 
   <li>44</li> 
   <li>45</li> 
   <li>46</li> 
   <li>47</li> 
   <li>48</li> 
   <li>49</li> 
   <li>50</li> 
   <li>51</li> 
   <li>52</li> 
   <li>53</li> 
   <li>54</li> 
   <li>55</li> 
   <li>56</li> 
   <li>57</li> 
   <li>58</li> 
   <li>59</li> 
   <li>60</li> 
   <li>61</li> 
   <li>62</li> 
   <li>63</li> 
   <li>64</li> 
   <li>65</li> 
   <li>66</li> 
   <li>67</li> 
   <li>68</li> 
   <li>69</li> 
   <li>70</li> 
   <li>71</li> 
   <li>72</li> 
   <li>73</li> 
   <li>74</li> 
   <li>75</li> 
   <li>76</li> 
   <li>77</li> 
   <li>78</li> 
   <li>79</li> 
   <li>80</li> 
   <li>81</li> 
   <li>82</li> 
   <li>83</li> 
   <li>84</li> 
   <li>85</li> 
   <li>86</li> 
   <li>87</li> 
   <li>88</li> 
   <li>89</li> 
   <li>90</li> 
   <li>91</li> 
   <li>92</li> 
   <li>93</li> 
   <li>94</li> 
   <li>95</li> 
   <li>96</li> 
   <li>97</li> 
   <li>98</li> 
   <li>99</li> 
   <li>100</li> 
   <li>101</li> 
   <li>102</li> 
   <li>103</li> 
   <li>104</li> 
   <li>105</li> 
   <li>106</li> 
   <li>107</li> 
   <li>108</li> 
   <li>109</li> 
   <li>110</li> 
   <li>111</li> 
   <li>112</li> 
   <li>113</li> 
   <li>114</li> 
   <li>115</li> 
   <li>116</li> 
   <li>117</li> 
   <li>118</li> 
   <li>119</li> 
   <li>120</li> 
   <li>121</li> 
   <li>122</li> 
   <li>123</li> 
   <li>124</li> 
   <li>125</li> 
   <li>126</li> 
   <li>127</li> 
   <li>128</li> 
   <li>129</li> 
   <li>130</li> 
   <li>131</li> 
   <li>132</li> 
   <li>133</li> 
   <li>134</li> 
   <li>135</li> 
   <li>136</li> 
   <li>137</li> 
   <li>138</li> 
   <li>139</li> 
   <li>140</li> 
   <li>141</li> 
   <li>142</li> 
   <li>143</li> 
   <li>144</li> 
   <li>145</li> 
   <li>146</li> 
   <li>147</li> 
   <li>148</li> 
   <li>149</li> 
   <li>150</li> 
   <li>151</li> 
   <li>152</li> 
   <li>153</li> 
   <li>154</li> 
   <li>155</li> 
   <li>156</li> 
   <li>157</li> 
   <li>158</li> 
   <li>159</li> 
   <li>160</li> 
   <li>161</li> 
   <li>162</li> 
   <li>163</li> 
   <li>164</li> 
   <li>165</li> 
   <li>166</li> 
   <li>167</li> 
   <li>168</li> 
   <li>169</li> 
   <li>170</li> 
   <li>171</li> 
   <li>172</li> 
   <li>173</li> 
   <li>174</li> 
   <li>175</li> 
   <li>176</li> 
   <li>177</li> 
   <li>178</li> 
   <li>179</li> 
   <li>180</li> 
   <li>181</li> 
   <li>182</li> 
   <li>183</li> 
   <li>184</li> 
   <li>185</li> 
   <li>186</li> 
   <li>187</li> 
   <li>188</li> 
   <li>189</li> 
   <li>190</li> 
   <li>191</li> 
   <li>192</li> 
   <li>193</li> 
   <li>194</li> 
   <li>195</li> 
   <li>196</li> 
   <li>197</li> 
   <li>198</li> 
   <li>199</li> 
   <li>200</li> 
  </ul>
  <p>需要修改<strong>Token</strong>的名字<code>name</code>、标识<code>symbol</code>、发行量<code>INITIAL_SUPPLY</code>和小数位<code>decimals</code>的，直接在<strong>合约</strong><code>Token</code>中修改相应的变量即可。</p> 
  <h1 id="编译部署合约"><a name="t3"></a>编译部署合约</h1> 
  <p>打开<a href="https://remix.ethereum.org/" rel="nofollow">Remix-Solidity IDE</a>，一种在线的Solidity IDE。&nbsp;<br> 将上述的三个合约代码导入至Remix中，点击<strong>start to compile</strong>进行编译。&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514190650474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 编译完成后切换到Run，<strong>下拉框选择Token</strong>，点击<strong>Deploy</strong>进行部署&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514190729238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 之后会弹出确认<strong>transaction</strong>的面板，拖到最下面点击<strong>confirm</strong>&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211028263?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br><strong>MetaMask</strong>会弹出，确认交易，点击<strong>submit</strong>&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211044443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">&nbsp;<br> 稍等片刻，交易被确认，会出现下图红框所示的合约地址，<strong>复制到剪贴板</strong>&nbsp;<br> 教程中<strong>Dylan Token</strong>合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211359137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 再进入<strong>MetaMask</strong>，点击<strong>Tokens</strong>——<strong>AddToken</strong>，粘贴复制的合约地址，点击<strong>Add</strong>&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211520559?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">&nbsp;<br> 就可以在自己的钱包中看到刚刚发行的<strong>Token</strong>了</p> 
  <h1 id="认证合约代码"><a name="t4"></a>认证合约代码</h1> 
  <p><strong>注意：此步骤需科学上网，不然提交之前的验证码显示出不来。</strong>&nbsp;<br> 在<a href="https://etherscan.io/" rel="nofollow">以太坊区块浏览器</a>中找到自己的合约地址，点击<strong>Contract code</strong>——<strong>Verify and Publish</strong>，如下图所示&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211601605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 在<strong>Contract name</strong>:的输入框输入部署的合约名称<strong>Token</strong>,&nbsp;<strong>Compiler</strong>&nbsp;选择在remix的sttings 中<strong>Solidity version</strong>&nbsp;显示的版本号。<strong>Optimization</strong>&nbsp;选择&nbsp;<strong>No</strong>。 然后在<strong>Enter the Solidity Contract Code below</strong>&nbsp;下面的输入框中原样填入<strong>Remix</strong>中的代码&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018051421173369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的<strong>successfully</strong>的字样&nbsp;<br><img alt="这里写图片描述" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211914410?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> 至此Token发行教程完结。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ffzhihua/article/details/81355243,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ffzhihua/article/details/81355243,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
