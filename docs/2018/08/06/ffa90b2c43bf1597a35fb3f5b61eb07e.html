<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS开发推荐VS Code和CLion做IDE工具 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS开发推荐VS Code和CLion做IDE工具" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="每一个开发人员都需要一个良好的IDE，EOS开发也是一样，为项目开发过程构建一个良好的IDE环境是第一步。这就是为什么我们要写这个如何使用VS Code或者CLion进行EOS开发的快速教程的原因。 我们还为VS Code创建了一些脚本，这些脚本将你在终端中使用的一些命令自动化。 设置Visual Studio Code 首先，如果你还没有这些VS Code扩展的话，安装一下。对于EOS Dapp开发，它们将非常有帮助： C/C++ - VS Code的智能感知、调试和代码浏览 CMake - Visual Studio Code的CMake语言支持 CMake Tools - Visual Studio Code扩展CMake支持 WebAssembly - 用于WebAssembly文本表示的语法高亮显示 当我们开发EOSIO dApps时，我们需要编写.hpp和.cpp文件中的代码。然而，这是整个过程中很小的一部分。大多数时候，我们需要生成一些其他文件，这些文件将用于在区块链上部署合约，进行单元测试等等。这就是CMake有用的地方。 CMake是用于控制软件编译过程的命令行工具。一旦它在你的IDE内正确设置的话，会使整个开发过程更加容易。 既然我们要使用CMake工具，我们应该对我们的项目结构做一些改变。我们将重用EOSIO项目的构架，因为它拥有我们所需要的一切。当然，我们有一些小的变化。 我们有一张图片，展示了新的项目结构。让我们看一看。 首先，我们有了build文件夹。这是放置所有构建内容的地方。你所使用的每一个生成文件都在那里。接下来是CMakeModules，它包含一些有用的Cmake模块，这些自定义模块用于编译过程。 contracts是我们的核心文件夹。这就是我们要放置智能合约的地方。目前，eosiolib, libc++和musl默认存在这里用于编译。紧接着是externals和libraries。两个文件夹都包含用于使整个编译过程更容易的库。 项目结构中最后一个重要的东西是配置文件CMakeLists.txt。每个目录都有自己的带有命令的CMakeLists.txt文件。 可以在我们的repo中找到所有的文件夹和脚本的新项目结构。 CMakeLists 让我们看一些配置文件，因为你需要知道如何使用它们。 1.CMakeLists.txt（4） 这是设置编译过程的主要配置文件。你应该知道，当你开发Dapp时，你需要设置项目名称。版本和语言是可选的。 # Set the minimum required version of cmake for a project cmake_minimum_required(VERSION 3.5) # Set a name, version, and enable languages for the entire project. project( ProjectName ) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/libraries/fc/CMakeModules&quot;) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules&quot;) # Load and run CMake code from a file or module. include( GNUInstallDirs ) include( SetupTargetMacros ) # Set a normal, cache, or environment variable to a given value set( CMAKE_CXX_STANDARD 14 ) set( CMAKE_CXX_EXTENSIONS ON ) set( CXX_STANDARD_REQUIRED ON) set( CLI_CLIENT_EXECUTABLE_NAME cleos ) set( GUI_CLIENT_EXECUTABLE_NAME eosio ) set(CMAKE_EXPORT_COMPILE_COMMANDS &quot;ON&quot;) # add defaults for openssl if (&quot;${OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) if (NOT &quot;$ENV{OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) set(OPENSSL_ROOT_DIR $ENV{OPENSSL_ROOT_DIR}) set(OPENSSL_INCLUDE_DIR ${OPENSSL_ROOT_DIR}/include) elseif (APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/local/opt/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/local/opt/openssl/include&quot;) elseif(UNIX AND NOT APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/include/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/include/openssl/include&quot;) else() message(FATAL_ERROR &quot;openssl not found and don&#39;t know where to look, please specify OPENSSL_ROOT_DIR&quot;) endif() endif() if(UNIX) if(APPLE) set(whole_archive_flag &quot;-force_load&quot;) set(no_whole_archive_flag &quot;&quot;) else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() SET( Boost_USE_STATIC_LIBS ON CACHE STRING &quot;ON or OFF&quot; ) IF( WIN32 ) SET(BOOST_ROOT $ENV{BOOST_ROOT}) set(Boost_USE_MULTITHREADED ON) set(BOOST_ALL_DYN_LINK OFF) # force dynamic linking for all libraries ENDIF(WIN32) FIND_PACKAGE(Boost 1.66 REQUIRED COMPONENTS thread date_time filesystem system program_options signals serialization chrono unit_test_framework context locale iostreams) # Add a subdirectory to the build. add_subdirectory(externals) include(wasm) add_subdirectory(libraries) add_subdirectory(contracts) 2.CMakeLists.txt (3) 第二个配置文件在contracts文件夹内。每一个新的智能合约都应该作为这个配置中的子目录来添加。重要的是不要忘了这一步合约不会编译。CMake不知道。 set(DEFAULT_SYSTEM_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts/libc++/upstream/include ${CMAKE_SOURCE_DIR}/contracts/musl/upstream/include ${Boost_INCLUDE_DIR}) set(STANDARD_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts ${CMAKE_SOURCE_DIR}/externals/magic_get/include) add_subdirectory(eosiolib) add_subdirectory(musl) add_subdirectory(libc++) # Your contracts (add the name of the folder which contains you smart contract) add_subdirectory(Players) 3.CMakeLists.txt（2） 每个智能合约都有自己的配置文件。这里需要注意的是，每个合约都有不同的TARGET，大部分情况下，它就是文件夹的名称。 file(GLOB ABI_FILES &quot;*.abi&quot;) configure_file(&quot;${ABI_FILES}&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}&quot; COPYONLY) # Change &quot;Players&quot; with the name of the folder containing your smart contracts add_wast_executable(TARGET Players INCLUDE_FOLDERS &quot;${STANDARD_INCLUDE_FOLDERS}&quot; LIBRARIES libc libc++ eosiolib DESTINATION_FOLDER ${CMAKE_CURRENT_BINARY_DIR} ) 现在，当我们有了新的项目结构时，我们必须定制命令来编译和构建我们所做的每一件事。但是怎么开始呢？幸运的是，VS Code有一些很酷的东西叫做Tasks。它帮助我们自动化每个命令，只需点击几下。 VS Code的Tasks 首先，我们必须生成包含我们的自定义命令的tasks.json文件。按⇧+⌘+P打开VS代码中的command palette，然后键入““Tasks”并选择“Configure Task”。 然后下一步选择Create tasks.json file from template，然后Others： VS code将创建一个名为“.vscode”的文件夹，在里面，你可以找到tasks.json。现在我们需要添加命令。复制并粘贴下面的代码到tasks.json： { &quot;version&quot;: &quot;2.0.0&quot;, &quot;reveal&quot;: &quot;always&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceRoot}&quot; }, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;CMake&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/compile.sh&quot; }, { &quot;label&quot;: &quot;Build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/build.sh&quot; }, { &quot;label&quot;: &quot;Generate ABI&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/generate.sh ${fileDirname} ${fileBasenameNoExtension}&quot;, } ] } 我们已经创建了三个自定义命令，命名为CMake、Build和Generate ABI。它们执行三个shell脚本compile.sh,build.sh和generate.sh。前两个脚本基本上都是相同的，除了build.sh还进行了编译以外。可能大多数时候你会使用第二个。 compile.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. build.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. # Build make 另一方面，使用第三个脚本generate.sh(生成智能合约ABI)。在生成过程中需要生成一些文件。必须在合约文件夹内执行命令。选择一个.cpp文件并运行它。 generate.sh echo &quot;Current working directory -&quot; $1 cd $1 eosiocpp -g $2.abi $2.cpp 令人惊叹的！我们已经准备好了VS Code。为了使整个开发变得更容易，我们将为我们的命令创建快捷方式。当你仍然在VS代码中时，点击Preferences – Keyboard Shortcuts。快捷方式窗口找到并打开keybindings.json（它在顶部）： 一旦keybindings.json打开，我们将创建快捷方式。对于我们的命令，我们选择了cmd+e、cmd+r和cmd+i，但是你可以选择其他。这是你必须添加的json： 一旦你已经完成了所有的设置，现在准备在VS Code上开发EOS DApps吧. CLion 设置 与VS Code相比，设置CLion非常简单。当加载CLion中的架构时，IDE会自动在cmake-build-debug文件夹中创建所有生成文件。一旦准备就绪，就可以使用“⌘+F9”快捷方式执行实际构建。这就是你需要做的一切，太简单了吧？ 但是，如果你想为CMake设置附加项，可以从Preferences – Build, Execution, Deployment中选择。 更多关于配置CLion中的CMake的信息，你可以在CLion IDE的官方文档中找到。写的非常好！ ========================================================= 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 这里是原文 阅读更多" />
<meta property="og:description" content="每一个开发人员都需要一个良好的IDE，EOS开发也是一样，为项目开发过程构建一个良好的IDE环境是第一步。这就是为什么我们要写这个如何使用VS Code或者CLion进行EOS开发的快速教程的原因。 我们还为VS Code创建了一些脚本，这些脚本将你在终端中使用的一些命令自动化。 设置Visual Studio Code 首先，如果你还没有这些VS Code扩展的话，安装一下。对于EOS Dapp开发，它们将非常有帮助： C/C++ - VS Code的智能感知、调试和代码浏览 CMake - Visual Studio Code的CMake语言支持 CMake Tools - Visual Studio Code扩展CMake支持 WebAssembly - 用于WebAssembly文本表示的语法高亮显示 当我们开发EOSIO dApps时，我们需要编写.hpp和.cpp文件中的代码。然而，这是整个过程中很小的一部分。大多数时候，我们需要生成一些其他文件，这些文件将用于在区块链上部署合约，进行单元测试等等。这就是CMake有用的地方。 CMake是用于控制软件编译过程的命令行工具。一旦它在你的IDE内正确设置的话，会使整个开发过程更加容易。 既然我们要使用CMake工具，我们应该对我们的项目结构做一些改变。我们将重用EOSIO项目的构架，因为它拥有我们所需要的一切。当然，我们有一些小的变化。 我们有一张图片，展示了新的项目结构。让我们看一看。 首先，我们有了build文件夹。这是放置所有构建内容的地方。你所使用的每一个生成文件都在那里。接下来是CMakeModules，它包含一些有用的Cmake模块，这些自定义模块用于编译过程。 contracts是我们的核心文件夹。这就是我们要放置智能合约的地方。目前，eosiolib, libc++和musl默认存在这里用于编译。紧接着是externals和libraries。两个文件夹都包含用于使整个编译过程更容易的库。 项目结构中最后一个重要的东西是配置文件CMakeLists.txt。每个目录都有自己的带有命令的CMakeLists.txt文件。 可以在我们的repo中找到所有的文件夹和脚本的新项目结构。 CMakeLists 让我们看一些配置文件，因为你需要知道如何使用它们。 1.CMakeLists.txt（4） 这是设置编译过程的主要配置文件。你应该知道，当你开发Dapp时，你需要设置项目名称。版本和语言是可选的。 # Set the minimum required version of cmake for a project cmake_minimum_required(VERSION 3.5) # Set a name, version, and enable languages for the entire project. project( ProjectName ) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/libraries/fc/CMakeModules&quot;) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules&quot;) # Load and run CMake code from a file or module. include( GNUInstallDirs ) include( SetupTargetMacros ) # Set a normal, cache, or environment variable to a given value set( CMAKE_CXX_STANDARD 14 ) set( CMAKE_CXX_EXTENSIONS ON ) set( CXX_STANDARD_REQUIRED ON) set( CLI_CLIENT_EXECUTABLE_NAME cleos ) set( GUI_CLIENT_EXECUTABLE_NAME eosio ) set(CMAKE_EXPORT_COMPILE_COMMANDS &quot;ON&quot;) # add defaults for openssl if (&quot;${OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) if (NOT &quot;$ENV{OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) set(OPENSSL_ROOT_DIR $ENV{OPENSSL_ROOT_DIR}) set(OPENSSL_INCLUDE_DIR ${OPENSSL_ROOT_DIR}/include) elseif (APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/local/opt/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/local/opt/openssl/include&quot;) elseif(UNIX AND NOT APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/include/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/include/openssl/include&quot;) else() message(FATAL_ERROR &quot;openssl not found and don&#39;t know where to look, please specify OPENSSL_ROOT_DIR&quot;) endif() endif() if(UNIX) if(APPLE) set(whole_archive_flag &quot;-force_load&quot;) set(no_whole_archive_flag &quot;&quot;) else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() SET( Boost_USE_STATIC_LIBS ON CACHE STRING &quot;ON or OFF&quot; ) IF( WIN32 ) SET(BOOST_ROOT $ENV{BOOST_ROOT}) set(Boost_USE_MULTITHREADED ON) set(BOOST_ALL_DYN_LINK OFF) # force dynamic linking for all libraries ENDIF(WIN32) FIND_PACKAGE(Boost 1.66 REQUIRED COMPONENTS thread date_time filesystem system program_options signals serialization chrono unit_test_framework context locale iostreams) # Add a subdirectory to the build. add_subdirectory(externals) include(wasm) add_subdirectory(libraries) add_subdirectory(contracts) 2.CMakeLists.txt (3) 第二个配置文件在contracts文件夹内。每一个新的智能合约都应该作为这个配置中的子目录来添加。重要的是不要忘了这一步合约不会编译。CMake不知道。 set(DEFAULT_SYSTEM_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts/libc++/upstream/include ${CMAKE_SOURCE_DIR}/contracts/musl/upstream/include ${Boost_INCLUDE_DIR}) set(STANDARD_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts ${CMAKE_SOURCE_DIR}/externals/magic_get/include) add_subdirectory(eosiolib) add_subdirectory(musl) add_subdirectory(libc++) # Your contracts (add the name of the folder which contains you smart contract) add_subdirectory(Players) 3.CMakeLists.txt（2） 每个智能合约都有自己的配置文件。这里需要注意的是，每个合约都有不同的TARGET，大部分情况下，它就是文件夹的名称。 file(GLOB ABI_FILES &quot;*.abi&quot;) configure_file(&quot;${ABI_FILES}&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}&quot; COPYONLY) # Change &quot;Players&quot; with the name of the folder containing your smart contracts add_wast_executable(TARGET Players INCLUDE_FOLDERS &quot;${STANDARD_INCLUDE_FOLDERS}&quot; LIBRARIES libc libc++ eosiolib DESTINATION_FOLDER ${CMAKE_CURRENT_BINARY_DIR} ) 现在，当我们有了新的项目结构时，我们必须定制命令来编译和构建我们所做的每一件事。但是怎么开始呢？幸运的是，VS Code有一些很酷的东西叫做Tasks。它帮助我们自动化每个命令，只需点击几下。 VS Code的Tasks 首先，我们必须生成包含我们的自定义命令的tasks.json文件。按⇧+⌘+P打开VS代码中的command palette，然后键入““Tasks”并选择“Configure Task”。 然后下一步选择Create tasks.json file from template，然后Others： VS code将创建一个名为“.vscode”的文件夹，在里面，你可以找到tasks.json。现在我们需要添加命令。复制并粘贴下面的代码到tasks.json： { &quot;version&quot;: &quot;2.0.0&quot;, &quot;reveal&quot;: &quot;always&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceRoot}&quot; }, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;CMake&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/compile.sh&quot; }, { &quot;label&quot;: &quot;Build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/build.sh&quot; }, { &quot;label&quot;: &quot;Generate ABI&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/generate.sh ${fileDirname} ${fileBasenameNoExtension}&quot;, } ] } 我们已经创建了三个自定义命令，命名为CMake、Build和Generate ABI。它们执行三个shell脚本compile.sh,build.sh和generate.sh。前两个脚本基本上都是相同的，除了build.sh还进行了编译以外。可能大多数时候你会使用第二个。 compile.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. build.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. # Build make 另一方面，使用第三个脚本generate.sh(生成智能合约ABI)。在生成过程中需要生成一些文件。必须在合约文件夹内执行命令。选择一个.cpp文件并运行它。 generate.sh echo &quot;Current working directory -&quot; $1 cd $1 eosiocpp -g $2.abi $2.cpp 令人惊叹的！我们已经准备好了VS Code。为了使整个开发变得更容易，我们将为我们的命令创建快捷方式。当你仍然在VS代码中时，点击Preferences – Keyboard Shortcuts。快捷方式窗口找到并打开keybindings.json（它在顶部）： 一旦keybindings.json打开，我们将创建快捷方式。对于我们的命令，我们选择了cmd+e、cmd+r和cmd+i，但是你可以选择其他。这是你必须添加的json： 一旦你已经完成了所有的设置，现在准备在VS Code上开发EOS DApps吧. CLion 设置 与VS Code相比，设置CLion非常简单。当加载CLion中的架构时，IDE会自动在cmake-build-debug文件夹中创建所有生成文件。一旦准备就绪，就可以使用“⌘+F9”快捷方式执行实际构建。这就是你需要做的一切，太简单了吧？ 但是，如果你想为CMake设置附加项，可以从Preferences – Build, Execution, Deployment中选择。 更多关于配置CLion中的CMake的信息，你可以在CLion IDE的官方文档中找到。写的非常好！ ========================================================= 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 这里是原文 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/06/ffa90b2c43bf1597a35fb3f5b61eb07e.html" />
<meta property="og:url" content="https://mlh.app/2018/08/06/ffa90b2c43bf1597a35fb3f5b61eb07e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"每一个开发人员都需要一个良好的IDE，EOS开发也是一样，为项目开发过程构建一个良好的IDE环境是第一步。这就是为什么我们要写这个如何使用VS Code或者CLion进行EOS开发的快速教程的原因。 我们还为VS Code创建了一些脚本，这些脚本将你在终端中使用的一些命令自动化。 设置Visual Studio Code 首先，如果你还没有这些VS Code扩展的话，安装一下。对于EOS Dapp开发，它们将非常有帮助： C/C++ - VS Code的智能感知、调试和代码浏览 CMake - Visual Studio Code的CMake语言支持 CMake Tools - Visual Studio Code扩展CMake支持 WebAssembly - 用于WebAssembly文本表示的语法高亮显示 当我们开发EOSIO dApps时，我们需要编写.hpp和.cpp文件中的代码。然而，这是整个过程中很小的一部分。大多数时候，我们需要生成一些其他文件，这些文件将用于在区块链上部署合约，进行单元测试等等。这就是CMake有用的地方。 CMake是用于控制软件编译过程的命令行工具。一旦它在你的IDE内正确设置的话，会使整个开发过程更加容易。 既然我们要使用CMake工具，我们应该对我们的项目结构做一些改变。我们将重用EOSIO项目的构架，因为它拥有我们所需要的一切。当然，我们有一些小的变化。 我们有一张图片，展示了新的项目结构。让我们看一看。 首先，我们有了build文件夹。这是放置所有构建内容的地方。你所使用的每一个生成文件都在那里。接下来是CMakeModules，它包含一些有用的Cmake模块，这些自定义模块用于编译过程。 contracts是我们的核心文件夹。这就是我们要放置智能合约的地方。目前，eosiolib, libc++和musl默认存在这里用于编译。紧接着是externals和libraries。两个文件夹都包含用于使整个编译过程更容易的库。 项目结构中最后一个重要的东西是配置文件CMakeLists.txt。每个目录都有自己的带有命令的CMakeLists.txt文件。 可以在我们的repo中找到所有的文件夹和脚本的新项目结构。 CMakeLists 让我们看一些配置文件，因为你需要知道如何使用它们。 1.CMakeLists.txt（4） 这是设置编译过程的主要配置文件。你应该知道，当你开发Dapp时，你需要设置项目名称。版本和语言是可选的。 # Set the minimum required version of cmake for a project cmake_minimum_required(VERSION 3.5) # Set a name, version, and enable languages for the entire project. project( ProjectName ) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/libraries/fc/CMakeModules&quot;) list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules&quot;) # Load and run CMake code from a file or module. include( GNUInstallDirs ) include( SetupTargetMacros ) # Set a normal, cache, or environment variable to a given value set( CMAKE_CXX_STANDARD 14 ) set( CMAKE_CXX_EXTENSIONS ON ) set( CXX_STANDARD_REQUIRED ON) set( CLI_CLIENT_EXECUTABLE_NAME cleos ) set( GUI_CLIENT_EXECUTABLE_NAME eosio ) set(CMAKE_EXPORT_COMPILE_COMMANDS &quot;ON&quot;) # add defaults for openssl if (&quot;${OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) if (NOT &quot;$ENV{OPENSSL_ROOT_DIR}&quot; STREQUAL &quot;&quot;) set(OPENSSL_ROOT_DIR $ENV{OPENSSL_ROOT_DIR}) set(OPENSSL_INCLUDE_DIR ${OPENSSL_ROOT_DIR}/include) elseif (APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/local/opt/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/local/opt/openssl/include&quot;) elseif(UNIX AND NOT APPLE) set(OPENSSL_ROOT_DIR &quot;/usr/include/openssl&quot;) set(OPENSSL_INCLUDE_DIR &quot;/usr/include/openssl/include&quot;) else() message(FATAL_ERROR &quot;openssl not found and don&#39;t know where to look, please specify OPENSSL_ROOT_DIR&quot;) endif() endif() if(UNIX) if(APPLE) set(whole_archive_flag &quot;-force_load&quot;) set(no_whole_archive_flag &quot;&quot;) else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() else() set(whole_archive_flag &quot;--whole-archive&quot;) set(no_whole_archive_flag &quot;--no-whole-archive&quot;) endif() SET( Boost_USE_STATIC_LIBS ON CACHE STRING &quot;ON or OFF&quot; ) IF( WIN32 ) SET(BOOST_ROOT $ENV{BOOST_ROOT}) set(Boost_USE_MULTITHREADED ON) set(BOOST_ALL_DYN_LINK OFF) # force dynamic linking for all libraries ENDIF(WIN32) FIND_PACKAGE(Boost 1.66 REQUIRED COMPONENTS thread date_time filesystem system program_options signals serialization chrono unit_test_framework context locale iostreams) # Add a subdirectory to the build. add_subdirectory(externals) include(wasm) add_subdirectory(libraries) add_subdirectory(contracts) 2.CMakeLists.txt (3) 第二个配置文件在contracts文件夹内。每一个新的智能合约都应该作为这个配置中的子目录来添加。重要的是不要忘了这一步合约不会编译。CMake不知道。 set(DEFAULT_SYSTEM_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts/libc++/upstream/include ${CMAKE_SOURCE_DIR}/contracts/musl/upstream/include ${Boost_INCLUDE_DIR}) set(STANDARD_INCLUDE_FOLDERS ${CMAKE_SOURCE_DIR}/contracts ${CMAKE_SOURCE_DIR}/externals/magic_get/include) add_subdirectory(eosiolib) add_subdirectory(musl) add_subdirectory(libc++) # Your contracts (add the name of the folder which contains you smart contract) add_subdirectory(Players) 3.CMakeLists.txt（2） 每个智能合约都有自己的配置文件。这里需要注意的是，每个合约都有不同的TARGET，大部分情况下，它就是文件夹的名称。 file(GLOB ABI_FILES &quot;*.abi&quot;) configure_file(&quot;${ABI_FILES}&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}&quot; COPYONLY) # Change &quot;Players&quot; with the name of the folder containing your smart contracts add_wast_executable(TARGET Players INCLUDE_FOLDERS &quot;${STANDARD_INCLUDE_FOLDERS}&quot; LIBRARIES libc libc++ eosiolib DESTINATION_FOLDER ${CMAKE_CURRENT_BINARY_DIR} ) 现在，当我们有了新的项目结构时，我们必须定制命令来编译和构建我们所做的每一件事。但是怎么开始呢？幸运的是，VS Code有一些很酷的东西叫做Tasks。它帮助我们自动化每个命令，只需点击几下。 VS Code的Tasks 首先，我们必须生成包含我们的自定义命令的tasks.json文件。按⇧+⌘+P打开VS代码中的command palette，然后键入““Tasks”并选择“Configure Task”。 然后下一步选择Create tasks.json file from template，然后Others： VS code将创建一个名为“.vscode”的文件夹，在里面，你可以找到tasks.json。现在我们需要添加命令。复制并粘贴下面的代码到tasks.json： { &quot;version&quot;: &quot;2.0.0&quot;, &quot;reveal&quot;: &quot;always&quot;, &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceRoot}&quot; }, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;CMake&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/compile.sh&quot; }, { &quot;label&quot;: &quot;Build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/build.sh&quot; }, { &quot;label&quot;: &quot;Generate ABI&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;sh ${workspaceRoot}/.vscode/scripts/generate.sh ${fileDirname} ${fileBasenameNoExtension}&quot;, } ] } 我们已经创建了三个自定义命令，命名为CMake、Build和Generate ABI。它们执行三个shell脚本compile.sh,build.sh和generate.sh。前两个脚本基本上都是相同的，除了build.sh还进行了编译以外。可能大多数时候你会使用第二个。 compile.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. build.sh # Create a build folder if it doesn&#39;t exist mkdir -p build # Change the current directory to &quot;build&quot; cd build # Create all the build files needed cmake -G &#39;Unix Makefiles&#39; -DCMAKE_BUILD_TYPE=Debug .. # Build make 另一方面，使用第三个脚本generate.sh(生成智能合约ABI)。在生成过程中需要生成一些文件。必须在合约文件夹内执行命令。选择一个.cpp文件并运行它。 generate.sh echo &quot;Current working directory -&quot; $1 cd $1 eosiocpp -g $2.abi $2.cpp 令人惊叹的！我们已经准备好了VS Code。为了使整个开发变得更容易，我们将为我们的命令创建快捷方式。当你仍然在VS代码中时，点击Preferences – Keyboard Shortcuts。快捷方式窗口找到并打开keybindings.json（它在顶部）： 一旦keybindings.json打开，我们将创建快捷方式。对于我们的命令，我们选择了cmd+e、cmd+r和cmd+i，但是你可以选择其他。这是你必须添加的json： 一旦你已经完成了所有的设置，现在准备在VS Code上开发EOS DApps吧. CLion 设置 与VS Code相比，设置CLion非常简单。当加载CLion中的架构时，IDE会自动在cmake-build-debug文件夹中创建所有生成文件。一旦准备就绪，就可以使用“⌘+F9”快捷方式执行实际构建。这就是你需要做的一切，太简单了吧？ 但是，如果你想为CMake设置附加项，可以从Preferences – Build, Execution, Deployment中选择。 更多关于配置CLion中的CMake的信息，你可以在CLion IDE的官方文档中找到。写的非常好！ ========================================================= 分享一个交互式的在线编程实战，EOS智能合约与DApp开发入门： EOS教程 本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 web3j教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 以太坊教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。 这里是原文 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/06/ffa90b2c43bf1597a35fb3f5b61eb07e.html","headline":"EOS开发推荐VS Code和CLion做IDE工具","dateModified":"2018-08-06T00:00:00+08:00","datePublished":"2018-08-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/06/ffa90b2c43bf1597a35fb3f5b61eb07e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS开发推荐VS Code和CLion做IDE工具</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>每一个开发人员都需要一个良好的IDE，EOS开发也是一样，为项目开发过程构建一个良好的IDE环境是第一步。这就是为什么我们要写这个如何使用<a href="https://code.visualstudio.com/" rel="nofollow">VS Code</a>或者<a href="https://www.jetbrains.com/clion/" rel="nofollow">CLion</a>进行EOS开发的快速教程的原因。</p> 
  <p>我们还为VS Code创建了一些脚本，这些脚本将你在终端中使用的一些命令自动化。</p> 
  <h3 id="设置visual-studio-code">设置Visual Studio Code</h3> 
  <p>首先，如果你还没有这些VS Code扩展的话，安装一下。对于EOS Dapp开发，它们将非常有帮助：</p> 
  <ul> 
   <li><strong>C/C++</strong> - VS Code的智能感知、调试和代码浏览</li> 
   <li><strong>CMake</strong> - Visual Studio Code的CMake语言支持</li> 
   <li><strong>CMake Tools</strong> - Visual Studio Code扩展CMake支持</li> 
   <li><strong>WebAssembly</strong> - 用于WebAssembly文本表示的语法高亮显示</li> 
  </ul> 
  <p>当我们开发EOSIO dApps时，我们需要编写.hpp和.cpp文件中的代码。然而，这是整个过程中很小的一部分。大多数时候，我们需要生成一些其他文件，这些文件将用于在区块链上部署合约，进行单元测试等等。这就是<a href="https://cmake.org/" rel="nofollow">CMake</a>有用的地方。</p> 
  <p>CMake是用于控制软件编译过程的命令行工具。一旦它在你的IDE内正确设置的话，会使整个开发过程更加容易。</p> 
  <p>既然我们要使用CMake工具，我们应该对我们的项目结构做一些改变。我们将重用EOSIO项目的构架，因为它拥有我们所需要的一切。当然，我们有一些小的变化。</p> 
  <p>我们有一张图片，展示了新的项目结构。让我们看一看。</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/project_skeleton.png" alt="" title=""></p> 
  <p>首先，我们有了<strong>build</strong>文件夹。这是放置所有构建内容的地方。你所使用的每一个生成文件都在那里。接下来是<strong>CMakeModules</strong>，它包含一些有用的Cmake模块，这些自定义模块用于编译过程。</p> 
  <p><strong>contracts</strong>是我们的核心文件夹。这就是我们要放置智能合约的地方。目前，<strong>eosiolib</strong>, <strong>libc++</strong>和<strong>musl</strong>默认存在这里用于编译。紧接着是<strong>externals</strong>和<strong>libraries</strong>。两个文件夹都包含用于使整个编译过程更容易的库。</p> 
  <p>项目结构中最后一个重要的东西是配置文件<strong>CMakeLists.txt</strong>。每个目录都有自己的带有命令的<strong>CMakeLists.txt</strong>文件。</p> 
  <p>可以在我们的<a href="https://github.com/infiniteXLabs/default-template" rel="nofollow">repo</a>中找到所有的文件夹和脚本的新项目结构。</p> 
  <h3 id="cmakelists">CMakeLists</h3> 
  <p>让我们看一些配置文件，因为你需要知道如何使用它们。</p> 
  <p>1.CMakeLists.txt（4）</p> 
  <p>这是设置编译过程的主要配置文件。你应该知道，当你开发Dapp时，你需要设置项目名称。版本和语言是可选的。</p> 
  <pre class="prettyprint"><code class=" hljs cmake"><span class="hljs-comment"># Set the minimum required version of cmake for a project</span>
<span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)

<span class="hljs-comment"># Set a name, version, and enable languages for the entire project.</span>
<span class="hljs-keyword">project</span>( ProjectName )

list(APPEND CMAKE_MODULE_PATH <span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/libraries/fc/CMakeModules"</span>)
list(APPEND CMAKE_MODULE_PATH <span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules"</span>)

<span class="hljs-comment"># Load and run CMake code from a file or module.</span>
<span class="hljs-keyword">include</span>( GNUInstallDirs )
<span class="hljs-keyword">include</span>( SetupTargetMacros )

<span class="hljs-comment"># Set a normal, cache, or environment variable to a given value</span>
<span class="hljs-keyword">set</span>( CMAKE_CXX_STANDARD <span class="hljs-number">14</span> )
<span class="hljs-keyword">set</span>( CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">ON</span> )
<span class="hljs-keyword">set</span>( CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)

<span class="hljs-keyword">set</span>( CLI_CLIENT_EXECUTABLE_NAME cleos )
<span class="hljs-keyword">set</span>( GUI_CLIENT_EXECUTABLE_NAME eosio )

<span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-string">"ON"</span>)


<span class="hljs-comment"># add defaults for openssl</span>
<span class="hljs-keyword">if</span> (<span class="hljs-string">"${OPENSSL_ROOT_DIR}"</span> <span class="hljs-operator">STREQUAL</span> <span class="hljs-string">""</span>)
   <span class="hljs-keyword">if</span> (NOT <span class="hljs-string">"$ENV{OPENSSL_ROOT_DIR}"</span> <span class="hljs-operator">STREQUAL</span> <span class="hljs-string">""</span>)
      <span class="hljs-keyword">set</span>(OPENSSL_ROOT_DIR $ENV{OPENSSL_ROOT_DIR})
      <span class="hljs-keyword">set</span>(OPENSSL_INCLUDE_DIR <span class="hljs-envvar">${OPENSSL_ROOT_DIR}</span>/<span class="hljs-keyword">include</span>)
   <span class="hljs-keyword">elseif</span> (APPLE)
      <span class="hljs-keyword">set</span>(OPENSSL_ROOT_DIR <span class="hljs-string">"/usr/local/opt/openssl"</span>)
      <span class="hljs-keyword">set</span>(OPENSSL_INCLUDE_DIR <span class="hljs-string">"/usr/local/opt/openssl/include"</span>)
   <span class="hljs-keyword">elseif</span>(UNIX <span class="hljs-keyword">AND</span> NOT APPLE)
      <span class="hljs-keyword">set</span>(OPENSSL_ROOT_DIR <span class="hljs-string">"/usr/include/openssl"</span>)
      <span class="hljs-keyword">set</span>(OPENSSL_INCLUDE_DIR <span class="hljs-string">"/usr/include/openssl/include"</span>)
   <span class="hljs-keyword">else</span>()
      <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">"openssl not found and don't know where to look, please specify OPENSSL_ROOT_DIR"</span>)
   <span class="hljs-keyword">endif</span>()
<span class="hljs-keyword">endif</span>()

<span class="hljs-keyword">if</span>(UNIX)
  <span class="hljs-keyword">if</span>(APPLE)
    <span class="hljs-keyword">set</span>(whole_archive_flag <span class="hljs-string">"-force_load"</span>)
    <span class="hljs-keyword">set</span>(no_whole_archive_flag <span class="hljs-string">""</span>)
  <span class="hljs-keyword">else</span>()
    <span class="hljs-keyword">set</span>(whole_archive_flag <span class="hljs-string">"--whole-archive"</span>)
    <span class="hljs-keyword">set</span>(no_whole_archive_flag <span class="hljs-string">"--no-whole-archive"</span>)
  <span class="hljs-keyword">endif</span>()
<span class="hljs-keyword">else</span>()
  <span class="hljs-keyword">set</span>(whole_archive_flag <span class="hljs-string">"--whole-archive"</span>)
  <span class="hljs-keyword">set</span>(no_whole_archive_flag <span class="hljs-string">"--no-whole-archive"</span>)
<span class="hljs-keyword">endif</span>()

<span class="hljs-keyword">SET</span>( Boost_USE_STATIC_LIBS <span class="hljs-keyword">ON</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">"ON or OFF"</span> )
<span class="hljs-keyword">IF</span>( WIN32 )
  <span class="hljs-keyword">SET</span>(BOOST_ROOT $ENV{BOOST_ROOT})
  <span class="hljs-keyword">set</span>(Boost_USE_MULTITHREADED <span class="hljs-keyword">ON</span>)
  <span class="hljs-keyword">set</span>(BOOST_ALL_DYN_LINK <span class="hljs-keyword">OFF</span>) <span class="hljs-comment"># force dynamic linking for all libraries</span>
<span class="hljs-keyword">ENDIF</span>(WIN32)
<span class="hljs-keyword">FIND_PACKAGE</span>(Boost <span class="hljs-number">1.66</span> REQUIRED COMPONENTS
    thread
    date_time
    filesystem
    system
    program_options
    signals
    serialization
    chrono
    unit_test_framework
    context
    locale
    iostreams)

<span class="hljs-comment"># Add a subdirectory to the build.</span>
<span class="hljs-keyword">add_subdirectory</span>(externals)

<span class="hljs-keyword">include</span>(wasm)

<span class="hljs-keyword">add_subdirectory</span>(libraries)
<span class="hljs-keyword">add_subdirectory</span>(contracts)</code></pre> 
  <p>2.CMakeLists.txt (3)</p> 
  <p>第二个配置文件在<strong>contracts</strong>文件夹内。每一个新的智能合约都应该作为这个配置中的子目录来添加。重要的是不要忘了这一步合约不会编译。CMake不知道。</p> 
  <pre class="prettyprint"><code class=" hljs cmake"><span class="hljs-keyword">set</span>(DEFAULT_SYSTEM_INCLUDE_FOLDERS <span class="hljs-envvar">${CMAKE_SOURCE_DIR}</span>/contracts/libc++/upstream/<span class="hljs-keyword">include</span> <span class="hljs-envvar">${CMAKE_SOURCE_DIR}</span>/contracts/musl/upstream/<span class="hljs-keyword">include</span> <span class="hljs-envvar">${Boost_INCLUDE_DIR}</span>)
<span class="hljs-keyword">set</span>(STANDARD_INCLUDE_FOLDERS <span class="hljs-envvar">${CMAKE_SOURCE_DIR}</span>/contracts <span class="hljs-envvar">${CMAKE_SOURCE_DIR}</span>/externals/magic_get/<span class="hljs-keyword">include</span>)

<span class="hljs-keyword">add_subdirectory</span>(eosiolib)
<span class="hljs-keyword">add_subdirectory</span>(musl)
<span class="hljs-keyword">add_subdirectory</span>(libc++)

<span class="hljs-comment"># Your contracts (add the name of the folder which contains you smart contract)</span>
<span class="hljs-keyword">add_subdirectory</span>(Players)</code></pre> 
  <p>3.CMakeLists.txt（2）</p> 
  <p>每个智能合约都有自己的配置文件。这里需要注意的是，每个合约都有不同的TARGET，大部分情况下，它就是文件夹的名称。</p> 
  <pre class="prettyprint"><code class=" hljs bash">file(GLOB ABI_FILES <span class="hljs-string">"*.abi"</span>)
configure_file(<span class="hljs-string">"<span class="hljs-variable">${ABI_FILES}</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${CMAKE_CURRENT_BINARY_DIR}</span>"</span> COPYONLY)

<span class="hljs-comment"># Change "Players" with the name of the folder containing your smart contracts</span>
add_wast_executable(TARGET Players
  INCLUDE_FOLDERS <span class="hljs-string">"<span class="hljs-variable">${STANDARD_INCLUDE_FOLDERS}</span>"</span>
  LIBRARIES libc libc++ eosiolib
  DESTINATION_FOLDER <span class="hljs-variable">${CMAKE_CURRENT_BINARY_DIR}</span>
)</code></pre> 
  <p>现在，当我们有了新的项目结构时，我们必须定制命令来编译和构建我们所做的每一件事。但是怎么开始呢？幸运的是，VS Code有一些很酷的东西叫做Tasks。它帮助我们自动化每个命令，只需点击几下。</p> 
  <h3 id="vs-code的tasks">VS Code的Tasks</h3> 
  <p>首先，我们必须生成包含我们的自定义命令的<strong>tasks.json</strong>文件。按⇧+⌘+P打开VS代码中的command palette，然后键入““Tasks”并选择“Configure Task”。</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/configure_task.png" alt="" title=""></p> 
  <p>然后下一步选择<strong>Create tasks.json file from template</strong>，然后<strong>Others</strong>：</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/create_tasks.png" alt="" title=""></p> 
  <p>VS code将创建一个名为“<strong>.vscode</strong>”的文件夹，在里面，你可以找到<code>tasks.json</code>。现在我们需要添加命令。复制并粘贴下面的代码到<code>tasks.json</code>：</p> 
  <pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"2.0.0"</span></span>,
    "<span class="hljs-attribute">reveal</span>": <span class="hljs-value"><span class="hljs-string">"always"</span></span>,
    "<span class="hljs-attribute">options</span>": <span class="hljs-value">{ "<span class="hljs-attribute">cwd</span>": <span class="hljs-value"><span class="hljs-string">"${workspaceRoot}"</span> </span>}</span>,
    "<span class="hljs-attribute">tasks</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">label</span>": <span class="hljs-value"><span class="hljs-string">"CMake"</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"shell"</span></span>, "<span class="hljs-attribute">command</span>": <span class="hljs-value"><span class="hljs-string">"sh ${workspaceRoot}/.vscode/scripts/compile.sh"</span> </span>}, { "<span class="hljs-attribute">label</span>": <span class="hljs-value"><span class="hljs-string">"Build"</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"shell"</span></span>, "<span class="hljs-attribute">command</span>": <span class="hljs-value"><span class="hljs-string">"sh ${workspaceRoot}/.vscode/scripts/build.sh"</span> </span>}, { "<span class="hljs-attribute">label</span>": <span class="hljs-value"><span class="hljs-string">"Generate ABI"</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"shell"</span></span>, "<span class="hljs-attribute">command</span>": <span class="hljs-value"><span class="hljs-string">"sh ${workspaceRoot}/.vscode/scripts/generate.sh ${fileDirname} ${fileBasenameNoExtension}"</span></span>, } ] </span>}</code></pre> 
  <p>我们已经创建了三个自定义命令，命名为<strong>CMake</strong>、<strong>Build</strong>和<strong>Generate ABI</strong>。它们执行三个shell脚本<strong>compile.sh</strong>,<strong>build.sh</strong>和<strong>generate.sh</strong>。前两个脚本基本上都是相同的，除了build.sh还进行了编译以外。可能大多数时候你会使用第二个。</p> 
  <p><strong>compile.sh</strong></p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># Create a build folder if it doesn't exist</span>
mkdir -p build

<span class="hljs-preprocessor"># Change the current directory to "build"</span>
cd build

<span class="hljs-preprocessor"># Create all the build files needed</span>
cmake -G <span class="hljs-string">'Unix Makefiles'</span> -DCMAKE_BUILD_TYPE=Debug ..</code></pre> 
  <p><strong>build.sh</strong></p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># Create a build folder if it doesn't exist</span>
mkdir -p build

<span class="hljs-preprocessor"># Change the current directory to "build"</span>
cd build

<span class="hljs-preprocessor"># Create all the build files needed</span>
cmake -G <span class="hljs-string">'Unix Makefiles'</span> -DCMAKE_BUILD_TYPE=Debug ..

<span class="hljs-preprocessor"># Build</span>
make</code></pre> 
  <p>另一方面，使用第三个脚本generate.sh(生成智能合约ABI)。在生成过程中需要生成一些文件。必须在合约文件夹内执行命令。选择一个.cpp文件并运行它。</p> 
  <p><strong>generate.sh</strong></p> 
  <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"Current working directory -"</span> <span class="hljs-variable">$1</span>
<span class="hljs-built_in">cd</span> <span class="hljs-variable">$1</span>

eosiocpp -g <span class="hljs-variable">$2</span>.abi <span class="hljs-variable">$2</span>.cpp</code></pre> 
  <p>令人惊叹的！我们已经准备好了VS Code。为了使整个开发变得更容易，我们将为我们的命令创建快捷方式。当你仍然在VS代码中时，点击<strong>Preferences – Keyboard Shortcuts</strong>。快捷方式窗口找到并打开<strong>keybindings.json</strong>（它在顶部）：</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/vscode_shortcuts.png" alt="" title=""></p> 
  <p>一旦keybindings.json打开，我们将创建快捷方式。对于我们的命令，我们选择了<strong>cmd+e</strong>、<strong>cmd+r</strong>和<strong>cmd+i</strong>，但是你可以选择其他。这是你必须添加的json：</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/commands_shortcuts-1.png" alt="" title=""></p> 
  <p>一旦你已经完成了所有的设置，现在准备在VS Code上开发EOS DApps吧.</p> 
  <h3 id="clion-设置">CLion 设置</h3> 
  <p>与VS Code相比，设置CLion非常简单。当加载CLion中的架构时，IDE会自动在<strong>cmake-build-debug</strong>文件夹中创建所有生成文件。一旦准备就绪，就可以使用“⌘+F9”快捷方式执行实际构建。这就是你需要做的一切，太简单了吧？</p> 
  <p>但是，如果你想为CMake设置附加项，可以从<strong>Preferences – Build, Execution, Deployment</strong>中选择。</p> 
  <p><img src="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/clion_setup.png" alt="" title=""></p> 
  <p>更多关于配置CLion中的CMake的信息，你可以在CLion IDE的<a href="https://www.jetbrains.com/help/clion/configuring-cmake.html" rel="nofollow">官方文档</a>中找到。写的非常好！</p> 
  <p>=========================================================</p> 
  <p>分享一个交互式的在线编程实战，<strong>EOS智能合约与DApp开发入门</strong>：</p> 
  <p><a href="http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=86csdn" rel="nofollow">EOS教程</a></p> 
  <p>本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=86csdn" rel="nofollow">web3j教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=86csdn" rel="nofollow">以太坊教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=86csdn" rel="nofollow">以太坊开发</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=86csdn" rel="nofollow">python以太坊</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=86csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和事件等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=86csdn" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和事件等。</li> 
   </ul> 
  </blockquote> 
  <p>这里是<a href="http://blog.hubwiz.com/2018/08/05/EOS-CLion-dev/" rel="nofollow">原文</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/81449230,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/81449230,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
