<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊Gas 如何计算 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊Gas 如何计算" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="适读人群： 专业攻城狮+程序猿 系统、深入地了解以太坊/区块链 就是这么简单，当然前提是您对下面这些知识有些了解 了解区块链的概念以及比特币的运行机制。 您已经是一名专业的软件攻城狮，并且有基本的编程知识，理解系统/架构/数学等知识 当然您也会这篇只是一个干货集锦，接下来的每篇文章都会针对每一部分作细致讲解。拿好小板凳，开讲啦！或者您可以先关注文末的二维码（如果您还没关注的话），我们的官方微信公众号会及时更新每一part 的内容，如果您已经关注，那就准备好瓜子，边磕边学习吧。 &nbsp; 1 以太坊 以太坊是一台分布式计算机，网络中的每个节点都执行一些字节码（智能合约），然后将结果状态存储在区块链中。区块链实质是一个应用了密码学技术的分布式数据库系统。（有关密码学的文章，前几篇文章中也有提及。） 当然，一个段落不足以清楚解释问题，您可以继续阅读以太坊白皮书，或者在其他相关帖子中去了解。 &nbsp; 2 智能合约 “智能合约”实际上只是一些类似在&nbsp;Ethereum&nbsp;平台这样的分布式环境中执行的代码。执行该代码的平台为这段代码提供了一些属性，例如：不变性，确定性操作，分布式和可验证状态等。“智能合约”实际上就是执行代码被管理的状态存储在区块链中，不可变，任何人都可以通过回顾这条链上的所有交易来检查当前状态是否正确。 在以太坊中，合约有一个地址来唯一标识它们（这是创建者地址的散列，以及他们之前发送了多少交易）。然后，客户端可以通过发送以太网，调用函数，查询它管理的分布式状态等方式与该地址进行交互。 智能合约也是一些代码，其中一些分布式状态由区块链管理。例如，您用来接收/发送ETH的multi-sid钱包只是一个智能合约，上面有一个用户界面。 &nbsp; 3 GAS 智能合约（代码块）由网络中的每个完整节点执行，容错性强（优点），但是这会花费大量的算力和时间（缺点）。因为执行计算需要花费金钱，所以执行计算的成本与代码执行的计算有关。换言之，EVM&nbsp;中的每个低级别操作码都需要花费一定量的“GAS”来执行。“GAS”只是一个抽象词汇，用于表示执行计算的成本。还有一个网络执行中的gas限制，以解决停机问题; 也就是说，你不能编写永不结束的程序，因为你消耗完“GAS”,网络会停止计算。 gas&nbsp;的“价格”（即这台分布式计算机上两个数字相加会花费我多少成本）”由市场决定，类似于比特币的交易费用。如果您支付更高的&nbsp;gas&nbsp;价格，节点将优先处理您的交易以获得更多收益。 一般来说，在Ethereum上计算和存储要比在传统环境中价格高，但是Eathereum为您的代码提供了上面讨论的所有这些好的属性，这些属性也同样重要。 &nbsp; 4 去中心化应用DApp DApp 是一个运行在以太网络上的“服务端”，就像Android/ios上的app. github上的ethereum组织有一个dapp-bin存储库，它有一些引用和示例。不过，一定要查看最近的文件状态信息，因为信息会很快过时。 &nbsp; 5 DApp 客户端 这些分布式应用程序通常伴随着一些用户友好的前端，因为没有人希望通过客户端或操作码手动处理例如带有散列和操作码这样的请求。 dApp客户端实际上就是任何“客户端”或“前端”，除了这个客户端与Ethereum区块链(可能除了其他服务)的接口之外。这些客户端通常是用JavaScript编写的，因为我们还没有将所有的库都转换成NodeJS。 更重要的是，大多数dApp客户端主要使用JavaScript编写，因为它可以在Web浏览器中运行。由于有很多GO语言的库，它们也经常用Go编写。所以您可以在JavaScript和Go(或许是Rust)之间进行选择，以便与Ethereum区块链及其上正在开发的协议进行交互。 那么问题来了？围绕“分布式应用程序”的确切术语/定义存在一些混淆/讨论：是否仅仅是智能合约？它是整个系统的后端，在某种程度上，与以太坊平台的接口存储信任？或者也可能包含客户端代码以及用户界面，因此整个包被称为“dApp”？ 我将其定义为“与以太坊区块链接口系统后端”。这与“智能合约”有很大不同，证明其自身概念，并且也意味着（确实）任何人都可以创建客户端来与分布式应用进行交互。 &nbsp; 6 DApp浏览器 dApp&nbsp;浏览器，&nbsp;它是一个应用程序，为了&nbsp;dApp&nbsp;客户端（通常是与&nbsp;Ethereum&nbsp;节点交互的JavaScript&nbsp;（与智能合约进行通信））的使用更容易。 dApp&nbsp;浏览器的主要目的是： 提供一个到&nbsp;Ethereum&nbsp;节点的连接（本地或远程托管的节点），也可以通过简单的方式将连接更改为指向不同节点（可能连接到不同的网络）， 并为用户提供帐户界面（“钱包”），方便与这些dApp进行交互。 Mist&nbsp;是官方&nbsp;Ethereum dApp&nbsp;浏览器。它实际上只是一个漂亮的&nbsp;Web&nbsp;用户界面，用于与&nbsp;Ethereum节点进行交互并向智能合约发送/接收事务。 Status 是一款移动浏览器，在手机上可以使用。 Toshi&nbsp;是&nbsp;Coinbase&nbsp;开发&nbsp;Ethereum&nbsp;钱包和浏览器的一次尝试。它把赌注压在“微信”+“聊天机器人”中。 MetaMask&nbsp;是一款&nbsp;Chrome&nbsp;扩展程序，可将&nbsp;Chrome&nbsp;变成“dApps&nbsp;浏览器”。其核心功能是它将web3（一个&nbsp;JavaScript Ethereum&nbsp;客户端库）注入每个页面，允许&nbsp;dApp&nbsp;连接到&nbsp;MetaMask&nbsp;托管的以太坊节点。Chrome 扩展程序允许管理钱包并将其连接到可用的不同以太网络。 Parity是一个以太坊客户端（以及一个全节点实现），它与您的Web浏览器集成在一起，将它变成一个dApp浏览器。 &nbsp; 7 以太坊节点 大多数关于比特币节点的知识在这都适用。节点存储区块链的副本，并可选择执行所有事务以确认结果状态。使用&nbsp;geth（first-party，Go）或&nbsp;parity（third-party，Rust）运行一个完整的节点或轻客户端。 您的节点需要知道要下载哪个区块链以及要与哪些对等点通信; 请参阅下面不同的可用网络的相关讨论。 您应该继续使用&nbsp;docker&nbsp;和某种持久性存储来运行所有这些节点客户端。如果你不想自己运行一个节点，你可以使用像&nbsp;Infura&nbsp;这样的第三方。还有一种方法可以运行本地节点进行测试和开发，稍后再讨论。 如果您将dApp客户端分发给用户，则不需要提供对以太坊节点的访问; dApp浏览器为任何需要它的客户端提供连接。 &nbsp; 8 以太坊代币 你知道我们如何编写代码（“智能合约”）将状态存储到区块链上了？ 即在该状态下我们将以太坊地址映射存储为一个整数。并称这个整数为balance。即“Tokens” 没错，你所听到的所有“Tokens”存储在哈希表中，通过API（aka协议）来增删改查。 继续阅读关于&nbsp;[the ethereum.org tutorial on creating a crowdsale]&nbsp;; 你会发现它只是一个合约（Crowdsale）,与另一个合约（MyToken）交互，就像上面链接的基本&nbsp;token contract&nbsp;一样。 人们正在使用token来进行各种用途，并且很快你会发现想象力是无限的。Tokens经常用于激励与协议的交互，证明资产的所有权，投票权等。 Vitalik&nbsp;最近撰写了一篇分析&nbsp;tokens&nbsp;的博客文章&nbsp;[&nbsp;Analyzing token sale models]，可以拿来读一下。 &nbsp; 9 与智能合约进行交互 通过连接到&nbsp;Ethereum&nbsp;节点并通过&nbsp;JSON RPC API&nbsp;执行函数，您可以与智能合约（又名，执行方法和读取状态）进行交互。有许多以太坊节点客户端以开发友好的方式执行此操作。geth&nbsp;和&nbsp;parity&nbsp;都提供为与 contracts 交互提供控制台/浏览器。 如果您想以编程方式与contracts进行交互，则有各种Ethereum客户端实现。对于JavaScript，web3.js，ethjs和ethers.js很受欢迎。对于golang，go-ethereum中的abigen可执行文件提供了用于contracts进行交互的软件包。尽管如此，它只是一个标准的JSON RPC API，因此如果一旦不可用，您可以随时编写自己的适配器以选择您所选择的语言。&nbsp;除了简单的功能执行外，一些客户端库还提供了便利功能。 运行本地以太坊节点进行测试和开发Ganache（以前称为ethereumjs-testrpc）。 当你“deploy”一个智能合约时，你真正要做的就是用contract bytecode作为参数向0-address（0x0）发送一个交易。交易详解 &nbsp; 10 Truffle,Embark,Populous,Perigord 一旦你开始写智能合约，你最后会一遍又一遍地做很多相同的操作; 将你的源代码编译成字节码和abi，部署到网络，测试已部署合约等。你可能也会想更关注于你想实现的东西。 像Truffle，Embark，Populous和Perigord这样的框架可以标准化和自动化许多细节。他们为开发，部署以及非常重要的测试合约提供了很好的开发体验。 这篇漫游指南很好的阐述了使用Truffle 来部署和交互合约。 Embark（Node）对开发人员应该如何构建项目有类似但不同的想法。 Perigord（Go）与Truffle非常相似。 Populous（Python）是一个积极开发的 Python 框架，可以满足相同的需求。 当你一开始接触合约时，如果你没有理解框架所提供的价值的话，你应该避免使用，就像你不应该开始学习如何使用 rails new 编写 HTML 一样。 &nbsp; 11 ETHPM &amp; NPM 共享一种关怀，所以ETHPM是一个去中心化的智能合约包资源库。使用ETHPM，您可以继承或链接到其他知名的合约和库，从而减少代码重复，并为将来的开发提供良好的合约基础。 &nbsp; 12 State of the Networks Mainnet&nbsp;- 以太网主网，通常是所以客户端和浏览器的默认网络。 Ropsten-主要在以太坊使用工作量证明测试网。这个网络由于计算量小，很容易被DDOS，split和其他问题。它最近被再次启用，并在被垃圾邮件攻击后暂时放弃后再次启用。 Kovan – Parity-唯一使用权威证明的客户端测试网络，针对垃圾邮件攻击提供免疫力和一致的4秒封锁时间。 Rinkeby - geth&nbsp;客户端仅使用 Clique Consensus 的 testnet，因此尽管计算量较低，但对恶意行为者更具适应性。 您也可以运行您自己的以太坊专用网络。Go-ethereum 团队建立了puppeth来配置完整的网络，包括自定义的 bootnode，创世区块和共识规则，这正是 Rinkeby 网络的动力所在。您也可以运行自己的基础架构，可能使用 kubernetes 或 docker-compose。但是你可能不需要在短时间内运行一个私有网络。 &nbsp; 13 “账户”和“钱包” Ethereum&nbsp;账户是私钥和地址对。他们基本上只是储存 Ether，创建时不需要&nbsp;gas。以太坊网络上的所有交易都来自一个账户; 合约不具备启动交易的能力。 钱包是两件事情之一： 1）用于创建和发送使用你的账户的交易的优化界面（即MyEtherWallet， 2）一个用于发送和接收以太网的智能合约（这又是一些代码）这是在Github上的一个钱包可靠实现.它们有多种类型，如多签名等。 现在我们已经正确地定义了这两者，准备好让人们把这两个词混淆在一起，并把任何发送/接收到醚的东西都贴上“钱包”的标签，并把所有东西都称为“账户”。 &nbsp; 14 智能合约编程语言 Solidity Solidity是描述智能合约的first-party语言。因为是最流行的语言，所以有很多例子和参考教程。除非你有更好的学习，不然还是建议你认真学习他。 Remix是一个基于网络的IDE，下面是一个&nbsp;Solidity&nbsp;合约： &nbsp; &nbsp; LLL LLL是一门Lisp风格的底层编程语言。虽然以太坊官方并没有将它作为主要需要支持的语言，但它仍旧持续进行着更新，且与solidity在同一个资源库。 &nbsp; Serpent Serpent&nbsp;是一种编译为 EVM 字节码的高级 Python-esq 语言。由于 Zeppelin 发现了许多严重的 bug，因此它已被弃用。对于类似语言，请参阅 Vyper。 &nbsp; Vyper(previously Viper) Vyper也是python启发和开发的，专注于安全性、简单性和无意外。它仍在开发中。 &nbsp; Others 在可用性和开发的不同状态中还有一些其他高级语言，毫无疑问将会有更多的语言被开发出来。但是，为了获得广泛的采用，语言和编译器必须经过彻底的审查和测试，这是需要时间来证明的。 &nbsp; 15 智能合约的安全 一旦智能合约部署到以太坊，它是不变的，并且永远存在。如果你写了一个bug，你不能删除; 你只能在后续的版本修复。 因为有那么多为&nbsp;Ethereum&nbsp;和其他智能合同平台开发的工程师来自&nbsp;web&nbsp;开发，所以这是一个最新和最疯狂的概念。 ConsenSys&nbsp;拥有一个完美的&nbsp;smart contract best practices，您应该深入理解。 在你部署一个能够操作真实现金的智能合约之前，你应该打开一个&nbsp;bug&nbsp;奖励并且对其进行测试。如果您正在处理RealMoney™，则应该对您的代码进行专业审计。 &nbsp; 16 Whisper Whisper&nbsp;是一个构建到以太坊的信息系统。它允许dApp发布少量信息，以实现非实时通信。 它使用协议shh这是非常好的,很少有文档和采用这种协议。尽管它在一段时间内没有更新，但这里有一个使用Whisper实现聊天客户端的示例dapp。 &nbsp; 17 去中心自动化组织（DAOS） 这是一个组织（就像一群人），他们不用法律文件来强制执行操作，而是使用一堆智能合约。然后，你们的人群使用这些合约来完成一个组织所做的所有正常工作，比如进行投票。 这样做的一个副作用是决策制定，治理，并且永久地存储在区块链中（在这些合约的状态下）。 &nbsp; 18 IPFS &amp; FileCoin IPFS（星际文件系统）是分发文件的协议。把它看作是一个使用 bittorrent 和 git 背后思想的文件系统，其中数据是内容寻址和不可变的。IPFS 使用称为 IPLD 的数据模型存储信息。 虽然这是一个新的协议，但有一个http网关和一个文件系统适配器，这意味着您可以通过http获取IPFS内容，并将整个全局文件系统挂载到本地磁盘的/ ipfs上。IPFS还提供称为IPNS（InterPlanetary名称空间）的命名系统，它允许可变状态（回想一下IPFS中的所有内容都是不可变的）。 您甚至可以使用DNS TXT记录来指导您的IPNS客户端，使您能够生成人性化的数据链接。 FileCoin是Protocol Labs为IPFS上的存储创建分布式市场所做的努力; 即为网络提供存储的激励层。 FileCoin共识协议消除工作证明的浪费，并且使用SpaceTime证明和复制证明，来确保一块数据被复制了一定的次数，并被存储了特定的时间。 您应该阅读&nbsp;IPFS白皮书，FileCoin白皮书&nbsp;和 IPLD规范。 &nbsp; 19 项目 Gravity Gravity利用区块链的信任和价值体系，基于内容寻址的存储协议，构建存储系统，并设计去中心化的资源调度和计算网络，组成一体的大规模计算平台，提供外部公共大数据服务。 &nbsp; &nbsp;&nbsp;Augur Augur是一个去中心化的预测市场，可以让用户对真实世界的事件结果进行投注。一方面，您拥有预测市场，用户通过交易代币来表明对特定结果的信任; 一旦结果得以实现，获胜代币具有全部价值。 为了实现这一点，你需要分散的oracle协议，它创建了一个提供真实事件知识的市场，由 REP（声誉）协议 token 激励。 在GitHub上的对于Augur markets 合约非常值得一读。 &nbsp; Gnosis Gnosis&nbsp;与Augur 有相似的理念，也是去中心化的预测市场。 &nbsp; Golem 与IPFS + FileCoin创建分布式存储市场一样，Golem是计算能力的分布式市场。 &nbsp; OxProject 0xProject创建用于交易token的协议和使用该协议的 dApp。开发人员可以在其分布式应用程序（也称为智能合约收集）之上建立一个交易所（技术上的“relayer”），用户不必担心您的应用程序的信用问题来结算交易; 结算在区块链上处理。0x协议旨在使用链外第三方（“relayers”）广播交易和管理订单（因此可以创建/更新/删除订单，而无需向以太坊发送缓慢且昂贵的交易）,但是使用&nbsp;Ethereum&nbsp;来进行结算。 他们首先实现了0xPortal(以前是0xOTC)，这是一个 dApp，使用他们的协议在用户之间直接传输 token。你可以查看他们在GitHub上的合约.他们向主网络发起了合约，并正在与社区合作建立relayers. &nbsp; Swap ConsenSys的Swap协议非常相似，但专注于通过“Indexers”传达意图（而不是签署交易承诺），然后让订单被撮合到 p2p。这是白皮书。 &nbsp; Bancor 代币的流动性是密码生态系统中相对较大的问题。用户之间的交易既要满足你的购买欲望，也要满足对方的出售意愿(反之亦然)。 Bancor是一个协议（以及一套实施该协议的智能合约），可让您创建token，1）根据订单自行定价，2）通过持有另一个代币（如Ether或任何ERC20）作为抵押提供即时流动性。 &nbsp; Open Zeppelin &amp; zeppelin_os Zeppelin是一家技术公司，在这个领域做了一些非常了不起的专业工作。老实说，他们正在做很多事情，而且很难详尽的叙述。 他们管理Open Zeppelin，这是一套经过审核的智能合约最佳实践，您可以在自己的dApp中继承和使用它们。看看他们的GitHub上关于solidity contracts的回复，这是一个很好的学习资源。老实说，你应该看看里面的每一份合约。 他们正在将代码可重用性概念向前推进一步，并创建zeppelin_os。 忽略术语“OS”; 它不是经典意义上的操作系统。zeppelin_os是一组功能，工具和服务的集合，旨在提供可靠的开发人员体验，同时最大限度地提高智能合约安全性。 zeppelin_os的一部分是“zeppelin_os内核”，它不是内核，但实际上是一组知名的智能合约，充当库。它们可以通过代理库模型进行升级，并且可以在安全补丁情况下独立升级。由于在合约本身中包含的代码较少，因此部署成本更低，开发人员减少了代码重复。 zeppelin_os还有其他一些精巧的计划方面，比如调度程序（合同函数的异步执行，因为默认情况下，合约在与之交互之前不会执行任何操作），市场协议和离线开发人员体验工具。您可以通过白皮书了解更多关于它们的信息。 &nbsp; ENS - Ethereum Name&nbsp;Service ENS是人类可读名称到地址的分散注册表。再加一个描述性项目名称。各种项目与它集成在一起，允许您支付.eth 地址或以其他方式将其用作方便的查找工具。您也可以创建解析到.eth地址的 DNS 记录。 &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="适读人群： 专业攻城狮+程序猿 系统、深入地了解以太坊/区块链 就是这么简单，当然前提是您对下面这些知识有些了解 了解区块链的概念以及比特币的运行机制。 您已经是一名专业的软件攻城狮，并且有基本的编程知识，理解系统/架构/数学等知识 当然您也会这篇只是一个干货集锦，接下来的每篇文章都会针对每一部分作细致讲解。拿好小板凳，开讲啦！或者您可以先关注文末的二维码（如果您还没关注的话），我们的官方微信公众号会及时更新每一part 的内容，如果您已经关注，那就准备好瓜子，边磕边学习吧。 &nbsp; 1 以太坊 以太坊是一台分布式计算机，网络中的每个节点都执行一些字节码（智能合约），然后将结果状态存储在区块链中。区块链实质是一个应用了密码学技术的分布式数据库系统。（有关密码学的文章，前几篇文章中也有提及。） 当然，一个段落不足以清楚解释问题，您可以继续阅读以太坊白皮书，或者在其他相关帖子中去了解。 &nbsp; 2 智能合约 “智能合约”实际上只是一些类似在&nbsp;Ethereum&nbsp;平台这样的分布式环境中执行的代码。执行该代码的平台为这段代码提供了一些属性，例如：不变性，确定性操作，分布式和可验证状态等。“智能合约”实际上就是执行代码被管理的状态存储在区块链中，不可变，任何人都可以通过回顾这条链上的所有交易来检查当前状态是否正确。 在以太坊中，合约有一个地址来唯一标识它们（这是创建者地址的散列，以及他们之前发送了多少交易）。然后，客户端可以通过发送以太网，调用函数，查询它管理的分布式状态等方式与该地址进行交互。 智能合约也是一些代码，其中一些分布式状态由区块链管理。例如，您用来接收/发送ETH的multi-sid钱包只是一个智能合约，上面有一个用户界面。 &nbsp; 3 GAS 智能合约（代码块）由网络中的每个完整节点执行，容错性强（优点），但是这会花费大量的算力和时间（缺点）。因为执行计算需要花费金钱，所以执行计算的成本与代码执行的计算有关。换言之，EVM&nbsp;中的每个低级别操作码都需要花费一定量的“GAS”来执行。“GAS”只是一个抽象词汇，用于表示执行计算的成本。还有一个网络执行中的gas限制，以解决停机问题; 也就是说，你不能编写永不结束的程序，因为你消耗完“GAS”,网络会停止计算。 gas&nbsp;的“价格”（即这台分布式计算机上两个数字相加会花费我多少成本）”由市场决定，类似于比特币的交易费用。如果您支付更高的&nbsp;gas&nbsp;价格，节点将优先处理您的交易以获得更多收益。 一般来说，在Ethereum上计算和存储要比在传统环境中价格高，但是Eathereum为您的代码提供了上面讨论的所有这些好的属性，这些属性也同样重要。 &nbsp; 4 去中心化应用DApp DApp 是一个运行在以太网络上的“服务端”，就像Android/ios上的app. github上的ethereum组织有一个dapp-bin存储库，它有一些引用和示例。不过，一定要查看最近的文件状态信息，因为信息会很快过时。 &nbsp; 5 DApp 客户端 这些分布式应用程序通常伴随着一些用户友好的前端，因为没有人希望通过客户端或操作码手动处理例如带有散列和操作码这样的请求。 dApp客户端实际上就是任何“客户端”或“前端”，除了这个客户端与Ethereum区块链(可能除了其他服务)的接口之外。这些客户端通常是用JavaScript编写的，因为我们还没有将所有的库都转换成NodeJS。 更重要的是，大多数dApp客户端主要使用JavaScript编写，因为它可以在Web浏览器中运行。由于有很多GO语言的库，它们也经常用Go编写。所以您可以在JavaScript和Go(或许是Rust)之间进行选择，以便与Ethereum区块链及其上正在开发的协议进行交互。 那么问题来了？围绕“分布式应用程序”的确切术语/定义存在一些混淆/讨论：是否仅仅是智能合约？它是整个系统的后端，在某种程度上，与以太坊平台的接口存储信任？或者也可能包含客户端代码以及用户界面，因此整个包被称为“dApp”？ 我将其定义为“与以太坊区块链接口系统后端”。这与“智能合约”有很大不同，证明其自身概念，并且也意味着（确实）任何人都可以创建客户端来与分布式应用进行交互。 &nbsp; 6 DApp浏览器 dApp&nbsp;浏览器，&nbsp;它是一个应用程序，为了&nbsp;dApp&nbsp;客户端（通常是与&nbsp;Ethereum&nbsp;节点交互的JavaScript&nbsp;（与智能合约进行通信））的使用更容易。 dApp&nbsp;浏览器的主要目的是： 提供一个到&nbsp;Ethereum&nbsp;节点的连接（本地或远程托管的节点），也可以通过简单的方式将连接更改为指向不同节点（可能连接到不同的网络）， 并为用户提供帐户界面（“钱包”），方便与这些dApp进行交互。 Mist&nbsp;是官方&nbsp;Ethereum dApp&nbsp;浏览器。它实际上只是一个漂亮的&nbsp;Web&nbsp;用户界面，用于与&nbsp;Ethereum节点进行交互并向智能合约发送/接收事务。 Status 是一款移动浏览器，在手机上可以使用。 Toshi&nbsp;是&nbsp;Coinbase&nbsp;开发&nbsp;Ethereum&nbsp;钱包和浏览器的一次尝试。它把赌注压在“微信”+“聊天机器人”中。 MetaMask&nbsp;是一款&nbsp;Chrome&nbsp;扩展程序，可将&nbsp;Chrome&nbsp;变成“dApps&nbsp;浏览器”。其核心功能是它将web3（一个&nbsp;JavaScript Ethereum&nbsp;客户端库）注入每个页面，允许&nbsp;dApp&nbsp;连接到&nbsp;MetaMask&nbsp;托管的以太坊节点。Chrome 扩展程序允许管理钱包并将其连接到可用的不同以太网络。 Parity是一个以太坊客户端（以及一个全节点实现），它与您的Web浏览器集成在一起，将它变成一个dApp浏览器。 &nbsp; 7 以太坊节点 大多数关于比特币节点的知识在这都适用。节点存储区块链的副本，并可选择执行所有事务以确认结果状态。使用&nbsp;geth（first-party，Go）或&nbsp;parity（third-party，Rust）运行一个完整的节点或轻客户端。 您的节点需要知道要下载哪个区块链以及要与哪些对等点通信; 请参阅下面不同的可用网络的相关讨论。 您应该继续使用&nbsp;docker&nbsp;和某种持久性存储来运行所有这些节点客户端。如果你不想自己运行一个节点，你可以使用像&nbsp;Infura&nbsp;这样的第三方。还有一种方法可以运行本地节点进行测试和开发，稍后再讨论。 如果您将dApp客户端分发给用户，则不需要提供对以太坊节点的访问; dApp浏览器为任何需要它的客户端提供连接。 &nbsp; 8 以太坊代币 你知道我们如何编写代码（“智能合约”）将状态存储到区块链上了？ 即在该状态下我们将以太坊地址映射存储为一个整数。并称这个整数为balance。即“Tokens” 没错，你所听到的所有“Tokens”存储在哈希表中，通过API（aka协议）来增删改查。 继续阅读关于&nbsp;[the ethereum.org tutorial on creating a crowdsale]&nbsp;; 你会发现它只是一个合约（Crowdsale）,与另一个合约（MyToken）交互，就像上面链接的基本&nbsp;token contract&nbsp;一样。 人们正在使用token来进行各种用途，并且很快你会发现想象力是无限的。Tokens经常用于激励与协议的交互，证明资产的所有权，投票权等。 Vitalik&nbsp;最近撰写了一篇分析&nbsp;tokens&nbsp;的博客文章&nbsp;[&nbsp;Analyzing token sale models]，可以拿来读一下。 &nbsp; 9 与智能合约进行交互 通过连接到&nbsp;Ethereum&nbsp;节点并通过&nbsp;JSON RPC API&nbsp;执行函数，您可以与智能合约（又名，执行方法和读取状态）进行交互。有许多以太坊节点客户端以开发友好的方式执行此操作。geth&nbsp;和&nbsp;parity&nbsp;都提供为与 contracts 交互提供控制台/浏览器。 如果您想以编程方式与contracts进行交互，则有各种Ethereum客户端实现。对于JavaScript，web3.js，ethjs和ethers.js很受欢迎。对于golang，go-ethereum中的abigen可执行文件提供了用于contracts进行交互的软件包。尽管如此，它只是一个标准的JSON RPC API，因此如果一旦不可用，您可以随时编写自己的适配器以选择您所选择的语言。&nbsp;除了简单的功能执行外，一些客户端库还提供了便利功能。 运行本地以太坊节点进行测试和开发Ganache（以前称为ethereumjs-testrpc）。 当你“deploy”一个智能合约时，你真正要做的就是用contract bytecode作为参数向0-address（0x0）发送一个交易。交易详解 &nbsp; 10 Truffle,Embark,Populous,Perigord 一旦你开始写智能合约，你最后会一遍又一遍地做很多相同的操作; 将你的源代码编译成字节码和abi，部署到网络，测试已部署合约等。你可能也会想更关注于你想实现的东西。 像Truffle，Embark，Populous和Perigord这样的框架可以标准化和自动化许多细节。他们为开发，部署以及非常重要的测试合约提供了很好的开发体验。 这篇漫游指南很好的阐述了使用Truffle 来部署和交互合约。 Embark（Node）对开发人员应该如何构建项目有类似但不同的想法。 Perigord（Go）与Truffle非常相似。 Populous（Python）是一个积极开发的 Python 框架，可以满足相同的需求。 当你一开始接触合约时，如果你没有理解框架所提供的价值的话，你应该避免使用，就像你不应该开始学习如何使用 rails new 编写 HTML 一样。 &nbsp; 11 ETHPM &amp; NPM 共享一种关怀，所以ETHPM是一个去中心化的智能合约包资源库。使用ETHPM，您可以继承或链接到其他知名的合约和库，从而减少代码重复，并为将来的开发提供良好的合约基础。 &nbsp; 12 State of the Networks Mainnet&nbsp;- 以太网主网，通常是所以客户端和浏览器的默认网络。 Ropsten-主要在以太坊使用工作量证明测试网。这个网络由于计算量小，很容易被DDOS，split和其他问题。它最近被再次启用，并在被垃圾邮件攻击后暂时放弃后再次启用。 Kovan – Parity-唯一使用权威证明的客户端测试网络，针对垃圾邮件攻击提供免疫力和一致的4秒封锁时间。 Rinkeby - geth&nbsp;客户端仅使用 Clique Consensus 的 testnet，因此尽管计算量较低，但对恶意行为者更具适应性。 您也可以运行您自己的以太坊专用网络。Go-ethereum 团队建立了puppeth来配置完整的网络，包括自定义的 bootnode，创世区块和共识规则，这正是 Rinkeby 网络的动力所在。您也可以运行自己的基础架构，可能使用 kubernetes 或 docker-compose。但是你可能不需要在短时间内运行一个私有网络。 &nbsp; 13 “账户”和“钱包” Ethereum&nbsp;账户是私钥和地址对。他们基本上只是储存 Ether，创建时不需要&nbsp;gas。以太坊网络上的所有交易都来自一个账户; 合约不具备启动交易的能力。 钱包是两件事情之一： 1）用于创建和发送使用你的账户的交易的优化界面（即MyEtherWallet， 2）一个用于发送和接收以太网的智能合约（这又是一些代码）这是在Github上的一个钱包可靠实现.它们有多种类型，如多签名等。 现在我们已经正确地定义了这两者，准备好让人们把这两个词混淆在一起，并把任何发送/接收到醚的东西都贴上“钱包”的标签，并把所有东西都称为“账户”。 &nbsp; 14 智能合约编程语言 Solidity Solidity是描述智能合约的first-party语言。因为是最流行的语言，所以有很多例子和参考教程。除非你有更好的学习，不然还是建议你认真学习他。 Remix是一个基于网络的IDE，下面是一个&nbsp;Solidity&nbsp;合约： &nbsp; &nbsp; LLL LLL是一门Lisp风格的底层编程语言。虽然以太坊官方并没有将它作为主要需要支持的语言，但它仍旧持续进行着更新，且与solidity在同一个资源库。 &nbsp; Serpent Serpent&nbsp;是一种编译为 EVM 字节码的高级 Python-esq 语言。由于 Zeppelin 发现了许多严重的 bug，因此它已被弃用。对于类似语言，请参阅 Vyper。 &nbsp; Vyper(previously Viper) Vyper也是python启发和开发的，专注于安全性、简单性和无意外。它仍在开发中。 &nbsp; Others 在可用性和开发的不同状态中还有一些其他高级语言，毫无疑问将会有更多的语言被开发出来。但是，为了获得广泛的采用，语言和编译器必须经过彻底的审查和测试，这是需要时间来证明的。 &nbsp; 15 智能合约的安全 一旦智能合约部署到以太坊，它是不变的，并且永远存在。如果你写了一个bug，你不能删除; 你只能在后续的版本修复。 因为有那么多为&nbsp;Ethereum&nbsp;和其他智能合同平台开发的工程师来自&nbsp;web&nbsp;开发，所以这是一个最新和最疯狂的概念。 ConsenSys&nbsp;拥有一个完美的&nbsp;smart contract best practices，您应该深入理解。 在你部署一个能够操作真实现金的智能合约之前，你应该打开一个&nbsp;bug&nbsp;奖励并且对其进行测试。如果您正在处理RealMoney™，则应该对您的代码进行专业审计。 &nbsp; 16 Whisper Whisper&nbsp;是一个构建到以太坊的信息系统。它允许dApp发布少量信息，以实现非实时通信。 它使用协议shh这是非常好的,很少有文档和采用这种协议。尽管它在一段时间内没有更新，但这里有一个使用Whisper实现聊天客户端的示例dapp。 &nbsp; 17 去中心自动化组织（DAOS） 这是一个组织（就像一群人），他们不用法律文件来强制执行操作，而是使用一堆智能合约。然后，你们的人群使用这些合约来完成一个组织所做的所有正常工作，比如进行投票。 这样做的一个副作用是决策制定，治理，并且永久地存储在区块链中（在这些合约的状态下）。 &nbsp; 18 IPFS &amp; FileCoin IPFS（星际文件系统）是分发文件的协议。把它看作是一个使用 bittorrent 和 git 背后思想的文件系统，其中数据是内容寻址和不可变的。IPFS 使用称为 IPLD 的数据模型存储信息。 虽然这是一个新的协议，但有一个http网关和一个文件系统适配器，这意味着您可以通过http获取IPFS内容，并将整个全局文件系统挂载到本地磁盘的/ ipfs上。IPFS还提供称为IPNS（InterPlanetary名称空间）的命名系统，它允许可变状态（回想一下IPFS中的所有内容都是不可变的）。 您甚至可以使用DNS TXT记录来指导您的IPNS客户端，使您能够生成人性化的数据链接。 FileCoin是Protocol Labs为IPFS上的存储创建分布式市场所做的努力; 即为网络提供存储的激励层。 FileCoin共识协议消除工作证明的浪费，并且使用SpaceTime证明和复制证明，来确保一块数据被复制了一定的次数，并被存储了特定的时间。 您应该阅读&nbsp;IPFS白皮书，FileCoin白皮书&nbsp;和 IPLD规范。 &nbsp; 19 项目 Gravity Gravity利用区块链的信任和价值体系，基于内容寻址的存储协议，构建存储系统，并设计去中心化的资源调度和计算网络，组成一体的大规模计算平台，提供外部公共大数据服务。 &nbsp; &nbsp;&nbsp;Augur Augur是一个去中心化的预测市场，可以让用户对真实世界的事件结果进行投注。一方面，您拥有预测市场，用户通过交易代币来表明对特定结果的信任; 一旦结果得以实现，获胜代币具有全部价值。 为了实现这一点，你需要分散的oracle协议，它创建了一个提供真实事件知识的市场，由 REP（声誉）协议 token 激励。 在GitHub上的对于Augur markets 合约非常值得一读。 &nbsp; Gnosis Gnosis&nbsp;与Augur 有相似的理念，也是去中心化的预测市场。 &nbsp; Golem 与IPFS + FileCoin创建分布式存储市场一样，Golem是计算能力的分布式市场。 &nbsp; OxProject 0xProject创建用于交易token的协议和使用该协议的 dApp。开发人员可以在其分布式应用程序（也称为智能合约收集）之上建立一个交易所（技术上的“relayer”），用户不必担心您的应用程序的信用问题来结算交易; 结算在区块链上处理。0x协议旨在使用链外第三方（“relayers”）广播交易和管理订单（因此可以创建/更新/删除订单，而无需向以太坊发送缓慢且昂贵的交易）,但是使用&nbsp;Ethereum&nbsp;来进行结算。 他们首先实现了0xPortal(以前是0xOTC)，这是一个 dApp，使用他们的协议在用户之间直接传输 token。你可以查看他们在GitHub上的合约.他们向主网络发起了合约，并正在与社区合作建立relayers. &nbsp; Swap ConsenSys的Swap协议非常相似，但专注于通过“Indexers”传达意图（而不是签署交易承诺），然后让订单被撮合到 p2p。这是白皮书。 &nbsp; Bancor 代币的流动性是密码生态系统中相对较大的问题。用户之间的交易既要满足你的购买欲望，也要满足对方的出售意愿(反之亦然)。 Bancor是一个协议（以及一套实施该协议的智能合约），可让您创建token，1）根据订单自行定价，2）通过持有另一个代币（如Ether或任何ERC20）作为抵押提供即时流动性。 &nbsp; Open Zeppelin &amp; zeppelin_os Zeppelin是一家技术公司，在这个领域做了一些非常了不起的专业工作。老实说，他们正在做很多事情，而且很难详尽的叙述。 他们管理Open Zeppelin，这是一套经过审核的智能合约最佳实践，您可以在自己的dApp中继承和使用它们。看看他们的GitHub上关于solidity contracts的回复，这是一个很好的学习资源。老实说，你应该看看里面的每一份合约。 他们正在将代码可重用性概念向前推进一步，并创建zeppelin_os。 忽略术语“OS”; 它不是经典意义上的操作系统。zeppelin_os是一组功能，工具和服务的集合，旨在提供可靠的开发人员体验，同时最大限度地提高智能合约安全性。 zeppelin_os的一部分是“zeppelin_os内核”，它不是内核，但实际上是一组知名的智能合约，充当库。它们可以通过代理库模型进行升级，并且可以在安全补丁情况下独立升级。由于在合约本身中包含的代码较少，因此部署成本更低，开发人员减少了代码重复。 zeppelin_os还有其他一些精巧的计划方面，比如调度程序（合同函数的异步执行，因为默认情况下，合约在与之交互之前不会执行任何操作），市场协议和离线开发人员体验工具。您可以通过白皮书了解更多关于它们的信息。 &nbsp; ENS - Ethereum Name&nbsp;Service ENS是人类可读名称到地址的分散注册表。再加一个描述性项目名称。各种项目与它集成在一起，允许您支付.eth 地址或以其他方式将其用作方便的查找工具。您也可以创建解析到.eth地址的 DNS 记录。 &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/06/34e449362fd0a54b7b45dc9dcf1020fc.html" />
<meta property="og:url" content="https://mlh.app/2018/08/06/34e449362fd0a54b7b45dc9dcf1020fc.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"适读人群： 专业攻城狮+程序猿 系统、深入地了解以太坊/区块链 就是这么简单，当然前提是您对下面这些知识有些了解 了解区块链的概念以及比特币的运行机制。 您已经是一名专业的软件攻城狮，并且有基本的编程知识，理解系统/架构/数学等知识 当然您也会这篇只是一个干货集锦，接下来的每篇文章都会针对每一部分作细致讲解。拿好小板凳，开讲啦！或者您可以先关注文末的二维码（如果您还没关注的话），我们的官方微信公众号会及时更新每一part 的内容，如果您已经关注，那就准备好瓜子，边磕边学习吧。 &nbsp; 1 以太坊 以太坊是一台分布式计算机，网络中的每个节点都执行一些字节码（智能合约），然后将结果状态存储在区块链中。区块链实质是一个应用了密码学技术的分布式数据库系统。（有关密码学的文章，前几篇文章中也有提及。） 当然，一个段落不足以清楚解释问题，您可以继续阅读以太坊白皮书，或者在其他相关帖子中去了解。 &nbsp; 2 智能合约 “智能合约”实际上只是一些类似在&nbsp;Ethereum&nbsp;平台这样的分布式环境中执行的代码。执行该代码的平台为这段代码提供了一些属性，例如：不变性，确定性操作，分布式和可验证状态等。“智能合约”实际上就是执行代码被管理的状态存储在区块链中，不可变，任何人都可以通过回顾这条链上的所有交易来检查当前状态是否正确。 在以太坊中，合约有一个地址来唯一标识它们（这是创建者地址的散列，以及他们之前发送了多少交易）。然后，客户端可以通过发送以太网，调用函数，查询它管理的分布式状态等方式与该地址进行交互。 智能合约也是一些代码，其中一些分布式状态由区块链管理。例如，您用来接收/发送ETH的multi-sid钱包只是一个智能合约，上面有一个用户界面。 &nbsp; 3 GAS 智能合约（代码块）由网络中的每个完整节点执行，容错性强（优点），但是这会花费大量的算力和时间（缺点）。因为执行计算需要花费金钱，所以执行计算的成本与代码执行的计算有关。换言之，EVM&nbsp;中的每个低级别操作码都需要花费一定量的“GAS”来执行。“GAS”只是一个抽象词汇，用于表示执行计算的成本。还有一个网络执行中的gas限制，以解决停机问题; 也就是说，你不能编写永不结束的程序，因为你消耗完“GAS”,网络会停止计算。 gas&nbsp;的“价格”（即这台分布式计算机上两个数字相加会花费我多少成本）”由市场决定，类似于比特币的交易费用。如果您支付更高的&nbsp;gas&nbsp;价格，节点将优先处理您的交易以获得更多收益。 一般来说，在Ethereum上计算和存储要比在传统环境中价格高，但是Eathereum为您的代码提供了上面讨论的所有这些好的属性，这些属性也同样重要。 &nbsp; 4 去中心化应用DApp DApp 是一个运行在以太网络上的“服务端”，就像Android/ios上的app. github上的ethereum组织有一个dapp-bin存储库，它有一些引用和示例。不过，一定要查看最近的文件状态信息，因为信息会很快过时。 &nbsp; 5 DApp 客户端 这些分布式应用程序通常伴随着一些用户友好的前端，因为没有人希望通过客户端或操作码手动处理例如带有散列和操作码这样的请求。 dApp客户端实际上就是任何“客户端”或“前端”，除了这个客户端与Ethereum区块链(可能除了其他服务)的接口之外。这些客户端通常是用JavaScript编写的，因为我们还没有将所有的库都转换成NodeJS。 更重要的是，大多数dApp客户端主要使用JavaScript编写，因为它可以在Web浏览器中运行。由于有很多GO语言的库，它们也经常用Go编写。所以您可以在JavaScript和Go(或许是Rust)之间进行选择，以便与Ethereum区块链及其上正在开发的协议进行交互。 那么问题来了？围绕“分布式应用程序”的确切术语/定义存在一些混淆/讨论：是否仅仅是智能合约？它是整个系统的后端，在某种程度上，与以太坊平台的接口存储信任？或者也可能包含客户端代码以及用户界面，因此整个包被称为“dApp”？ 我将其定义为“与以太坊区块链接口系统后端”。这与“智能合约”有很大不同，证明其自身概念，并且也意味着（确实）任何人都可以创建客户端来与分布式应用进行交互。 &nbsp; 6 DApp浏览器 dApp&nbsp;浏览器，&nbsp;它是一个应用程序，为了&nbsp;dApp&nbsp;客户端（通常是与&nbsp;Ethereum&nbsp;节点交互的JavaScript&nbsp;（与智能合约进行通信））的使用更容易。 dApp&nbsp;浏览器的主要目的是： 提供一个到&nbsp;Ethereum&nbsp;节点的连接（本地或远程托管的节点），也可以通过简单的方式将连接更改为指向不同节点（可能连接到不同的网络）， 并为用户提供帐户界面（“钱包”），方便与这些dApp进行交互。 Mist&nbsp;是官方&nbsp;Ethereum dApp&nbsp;浏览器。它实际上只是一个漂亮的&nbsp;Web&nbsp;用户界面，用于与&nbsp;Ethereum节点进行交互并向智能合约发送/接收事务。 Status 是一款移动浏览器，在手机上可以使用。 Toshi&nbsp;是&nbsp;Coinbase&nbsp;开发&nbsp;Ethereum&nbsp;钱包和浏览器的一次尝试。它把赌注压在“微信”+“聊天机器人”中。 MetaMask&nbsp;是一款&nbsp;Chrome&nbsp;扩展程序，可将&nbsp;Chrome&nbsp;变成“dApps&nbsp;浏览器”。其核心功能是它将web3（一个&nbsp;JavaScript Ethereum&nbsp;客户端库）注入每个页面，允许&nbsp;dApp&nbsp;连接到&nbsp;MetaMask&nbsp;托管的以太坊节点。Chrome 扩展程序允许管理钱包并将其连接到可用的不同以太网络。 Parity是一个以太坊客户端（以及一个全节点实现），它与您的Web浏览器集成在一起，将它变成一个dApp浏览器。 &nbsp; 7 以太坊节点 大多数关于比特币节点的知识在这都适用。节点存储区块链的副本，并可选择执行所有事务以确认结果状态。使用&nbsp;geth（first-party，Go）或&nbsp;parity（third-party，Rust）运行一个完整的节点或轻客户端。 您的节点需要知道要下载哪个区块链以及要与哪些对等点通信; 请参阅下面不同的可用网络的相关讨论。 您应该继续使用&nbsp;docker&nbsp;和某种持久性存储来运行所有这些节点客户端。如果你不想自己运行一个节点，你可以使用像&nbsp;Infura&nbsp;这样的第三方。还有一种方法可以运行本地节点进行测试和开发，稍后再讨论。 如果您将dApp客户端分发给用户，则不需要提供对以太坊节点的访问; dApp浏览器为任何需要它的客户端提供连接。 &nbsp; 8 以太坊代币 你知道我们如何编写代码（“智能合约”）将状态存储到区块链上了？ 即在该状态下我们将以太坊地址映射存储为一个整数。并称这个整数为balance。即“Tokens” 没错，你所听到的所有“Tokens”存储在哈希表中，通过API（aka协议）来增删改查。 继续阅读关于&nbsp;[the ethereum.org tutorial on creating a crowdsale]&nbsp;; 你会发现它只是一个合约（Crowdsale）,与另一个合约（MyToken）交互，就像上面链接的基本&nbsp;token contract&nbsp;一样。 人们正在使用token来进行各种用途，并且很快你会发现想象力是无限的。Tokens经常用于激励与协议的交互，证明资产的所有权，投票权等。 Vitalik&nbsp;最近撰写了一篇分析&nbsp;tokens&nbsp;的博客文章&nbsp;[&nbsp;Analyzing token sale models]，可以拿来读一下。 &nbsp; 9 与智能合约进行交互 通过连接到&nbsp;Ethereum&nbsp;节点并通过&nbsp;JSON RPC API&nbsp;执行函数，您可以与智能合约（又名，执行方法和读取状态）进行交互。有许多以太坊节点客户端以开发友好的方式执行此操作。geth&nbsp;和&nbsp;parity&nbsp;都提供为与 contracts 交互提供控制台/浏览器。 如果您想以编程方式与contracts进行交互，则有各种Ethereum客户端实现。对于JavaScript，web3.js，ethjs和ethers.js很受欢迎。对于golang，go-ethereum中的abigen可执行文件提供了用于contracts进行交互的软件包。尽管如此，它只是一个标准的JSON RPC API，因此如果一旦不可用，您可以随时编写自己的适配器以选择您所选择的语言。&nbsp;除了简单的功能执行外，一些客户端库还提供了便利功能。 运行本地以太坊节点进行测试和开发Ganache（以前称为ethereumjs-testrpc）。 当你“deploy”一个智能合约时，你真正要做的就是用contract bytecode作为参数向0-address（0x0）发送一个交易。交易详解 &nbsp; 10 Truffle,Embark,Populous,Perigord 一旦你开始写智能合约，你最后会一遍又一遍地做很多相同的操作; 将你的源代码编译成字节码和abi，部署到网络，测试已部署合约等。你可能也会想更关注于你想实现的东西。 像Truffle，Embark，Populous和Perigord这样的框架可以标准化和自动化许多细节。他们为开发，部署以及非常重要的测试合约提供了很好的开发体验。 这篇漫游指南很好的阐述了使用Truffle 来部署和交互合约。 Embark（Node）对开发人员应该如何构建项目有类似但不同的想法。 Perigord（Go）与Truffle非常相似。 Populous（Python）是一个积极开发的 Python 框架，可以满足相同的需求。 当你一开始接触合约时，如果你没有理解框架所提供的价值的话，你应该避免使用，就像你不应该开始学习如何使用 rails new 编写 HTML 一样。 &nbsp; 11 ETHPM &amp; NPM 共享一种关怀，所以ETHPM是一个去中心化的智能合约包资源库。使用ETHPM，您可以继承或链接到其他知名的合约和库，从而减少代码重复，并为将来的开发提供良好的合约基础。 &nbsp; 12 State of the Networks Mainnet&nbsp;- 以太网主网，通常是所以客户端和浏览器的默认网络。 Ropsten-主要在以太坊使用工作量证明测试网。这个网络由于计算量小，很容易被DDOS，split和其他问题。它最近被再次启用，并在被垃圾邮件攻击后暂时放弃后再次启用。 Kovan – Parity-唯一使用权威证明的客户端测试网络，针对垃圾邮件攻击提供免疫力和一致的4秒封锁时间。 Rinkeby - geth&nbsp;客户端仅使用 Clique Consensus 的 testnet，因此尽管计算量较低，但对恶意行为者更具适应性。 您也可以运行您自己的以太坊专用网络。Go-ethereum 团队建立了puppeth来配置完整的网络，包括自定义的 bootnode，创世区块和共识规则，这正是 Rinkeby 网络的动力所在。您也可以运行自己的基础架构，可能使用 kubernetes 或 docker-compose。但是你可能不需要在短时间内运行一个私有网络。 &nbsp; 13 “账户”和“钱包” Ethereum&nbsp;账户是私钥和地址对。他们基本上只是储存 Ether，创建时不需要&nbsp;gas。以太坊网络上的所有交易都来自一个账户; 合约不具备启动交易的能力。 钱包是两件事情之一： 1）用于创建和发送使用你的账户的交易的优化界面（即MyEtherWallet， 2）一个用于发送和接收以太网的智能合约（这又是一些代码）这是在Github上的一个钱包可靠实现.它们有多种类型，如多签名等。 现在我们已经正确地定义了这两者，准备好让人们把这两个词混淆在一起，并把任何发送/接收到醚的东西都贴上“钱包”的标签，并把所有东西都称为“账户”。 &nbsp; 14 智能合约编程语言 Solidity Solidity是描述智能合约的first-party语言。因为是最流行的语言，所以有很多例子和参考教程。除非你有更好的学习，不然还是建议你认真学习他。 Remix是一个基于网络的IDE，下面是一个&nbsp;Solidity&nbsp;合约： &nbsp; &nbsp; LLL LLL是一门Lisp风格的底层编程语言。虽然以太坊官方并没有将它作为主要需要支持的语言，但它仍旧持续进行着更新，且与solidity在同一个资源库。 &nbsp; Serpent Serpent&nbsp;是一种编译为 EVM 字节码的高级 Python-esq 语言。由于 Zeppelin 发现了许多严重的 bug，因此它已被弃用。对于类似语言，请参阅 Vyper。 &nbsp; Vyper(previously Viper) Vyper也是python启发和开发的，专注于安全性、简单性和无意外。它仍在开发中。 &nbsp; Others 在可用性和开发的不同状态中还有一些其他高级语言，毫无疑问将会有更多的语言被开发出来。但是，为了获得广泛的采用，语言和编译器必须经过彻底的审查和测试，这是需要时间来证明的。 &nbsp; 15 智能合约的安全 一旦智能合约部署到以太坊，它是不变的，并且永远存在。如果你写了一个bug，你不能删除; 你只能在后续的版本修复。 因为有那么多为&nbsp;Ethereum&nbsp;和其他智能合同平台开发的工程师来自&nbsp;web&nbsp;开发，所以这是一个最新和最疯狂的概念。 ConsenSys&nbsp;拥有一个完美的&nbsp;smart contract best practices，您应该深入理解。 在你部署一个能够操作真实现金的智能合约之前，你应该打开一个&nbsp;bug&nbsp;奖励并且对其进行测试。如果您正在处理RealMoney™，则应该对您的代码进行专业审计。 &nbsp; 16 Whisper Whisper&nbsp;是一个构建到以太坊的信息系统。它允许dApp发布少量信息，以实现非实时通信。 它使用协议shh这是非常好的,很少有文档和采用这种协议。尽管它在一段时间内没有更新，但这里有一个使用Whisper实现聊天客户端的示例dapp。 &nbsp; 17 去中心自动化组织（DAOS） 这是一个组织（就像一群人），他们不用法律文件来强制执行操作，而是使用一堆智能合约。然后，你们的人群使用这些合约来完成一个组织所做的所有正常工作，比如进行投票。 这样做的一个副作用是决策制定，治理，并且永久地存储在区块链中（在这些合约的状态下）。 &nbsp; 18 IPFS &amp; FileCoin IPFS（星际文件系统）是分发文件的协议。把它看作是一个使用 bittorrent 和 git 背后思想的文件系统，其中数据是内容寻址和不可变的。IPFS 使用称为 IPLD 的数据模型存储信息。 虽然这是一个新的协议，但有一个http网关和一个文件系统适配器，这意味着您可以通过http获取IPFS内容，并将整个全局文件系统挂载到本地磁盘的/ ipfs上。IPFS还提供称为IPNS（InterPlanetary名称空间）的命名系统，它允许可变状态（回想一下IPFS中的所有内容都是不可变的）。 您甚至可以使用DNS TXT记录来指导您的IPNS客户端，使您能够生成人性化的数据链接。 FileCoin是Protocol Labs为IPFS上的存储创建分布式市场所做的努力; 即为网络提供存储的激励层。 FileCoin共识协议消除工作证明的浪费，并且使用SpaceTime证明和复制证明，来确保一块数据被复制了一定的次数，并被存储了特定的时间。 您应该阅读&nbsp;IPFS白皮书，FileCoin白皮书&nbsp;和 IPLD规范。 &nbsp; 19 项目 Gravity Gravity利用区块链的信任和价值体系，基于内容寻址的存储协议，构建存储系统，并设计去中心化的资源调度和计算网络，组成一体的大规模计算平台，提供外部公共大数据服务。 &nbsp; &nbsp;&nbsp;Augur Augur是一个去中心化的预测市场，可以让用户对真实世界的事件结果进行投注。一方面，您拥有预测市场，用户通过交易代币来表明对特定结果的信任; 一旦结果得以实现，获胜代币具有全部价值。 为了实现这一点，你需要分散的oracle协议，它创建了一个提供真实事件知识的市场，由 REP（声誉）协议 token 激励。 在GitHub上的对于Augur markets 合约非常值得一读。 &nbsp; Gnosis Gnosis&nbsp;与Augur 有相似的理念，也是去中心化的预测市场。 &nbsp; Golem 与IPFS + FileCoin创建分布式存储市场一样，Golem是计算能力的分布式市场。 &nbsp; OxProject 0xProject创建用于交易token的协议和使用该协议的 dApp。开发人员可以在其分布式应用程序（也称为智能合约收集）之上建立一个交易所（技术上的“relayer”），用户不必担心您的应用程序的信用问题来结算交易; 结算在区块链上处理。0x协议旨在使用链外第三方（“relayers”）广播交易和管理订单（因此可以创建/更新/删除订单，而无需向以太坊发送缓慢且昂贵的交易）,但是使用&nbsp;Ethereum&nbsp;来进行结算。 他们首先实现了0xPortal(以前是0xOTC)，这是一个 dApp，使用他们的协议在用户之间直接传输 token。你可以查看他们在GitHub上的合约.他们向主网络发起了合约，并正在与社区合作建立relayers. &nbsp; Swap ConsenSys的Swap协议非常相似，但专注于通过“Indexers”传达意图（而不是签署交易承诺），然后让订单被撮合到 p2p。这是白皮书。 &nbsp; Bancor 代币的流动性是密码生态系统中相对较大的问题。用户之间的交易既要满足你的购买欲望，也要满足对方的出售意愿(反之亦然)。 Bancor是一个协议（以及一套实施该协议的智能合约），可让您创建token，1）根据订单自行定价，2）通过持有另一个代币（如Ether或任何ERC20）作为抵押提供即时流动性。 &nbsp; Open Zeppelin &amp; zeppelin_os Zeppelin是一家技术公司，在这个领域做了一些非常了不起的专业工作。老实说，他们正在做很多事情，而且很难详尽的叙述。 他们管理Open Zeppelin，这是一套经过审核的智能合约最佳实践，您可以在自己的dApp中继承和使用它们。看看他们的GitHub上关于solidity contracts的回复，这是一个很好的学习资源。老实说，你应该看看里面的每一份合约。 他们正在将代码可重用性概念向前推进一步，并创建zeppelin_os。 忽略术语“OS”; 它不是经典意义上的操作系统。zeppelin_os是一组功能，工具和服务的集合，旨在提供可靠的开发人员体验，同时最大限度地提高智能合约安全性。 zeppelin_os的一部分是“zeppelin_os内核”，它不是内核，但实际上是一组知名的智能合约，充当库。它们可以通过代理库模型进行升级，并且可以在安全补丁情况下独立升级。由于在合约本身中包含的代码较少，因此部署成本更低，开发人员减少了代码重复。 zeppelin_os还有其他一些精巧的计划方面，比如调度程序（合同函数的异步执行，因为默认情况下，合约在与之交互之前不会执行任何操作），市场协议和离线开发人员体验工具。您可以通过白皮书了解更多关于它们的信息。 &nbsp; ENS - Ethereum Name&nbsp;Service ENS是人类可读名称到地址的分散注册表。再加一个描述性项目名称。各种项目与它集成在一起，允许您支付.eth 地址或以其他方式将其用作方便的查找工具。您也可以创建解析到.eth地址的 DNS 记录。 &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/06/34e449362fd0a54b7b45dc9dcf1020fc.html","headline":"以太坊Gas 如何计算","dateModified":"2018-08-06T00:00:00+08:00","datePublished":"2018-08-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/06/34e449362fd0a54b7b45dc9dcf1020fc.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊Gas 如何计算</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>适读人群：</p> 
  <ol>
   <li> <p>专业<strong>攻城狮</strong>+<strong>程序猿</strong></p> </li> 
   <li> <p>系统、深入地了解以太坊/区块链</p> </li> 
  </ol>
  <p>就是这么简单，当然前提是您对下面这些知识有些了解</p> 
  <ol>
   <li> <p>了解区块链的概念以及比特币的运行机制。</p> </li> 
   <li> <p>您已经是一名专业的软件<strong>攻城狮</strong>，并且有基本的编程知识，理解系统/架构/数学等知识</p> </li> 
  </ol>
  <p>当然您也会这篇只是一个干货集锦，接下来的每篇文章都会针对每一部分作细致讲解。拿好小板凳，开讲啦！或者您可以先关注<strong>文末的二维码</strong>（如果您还没关注的话），我们的官方微信公众号会及时更新每一part 的内容，如果您已经关注，那就准备好瓜子，边磕边学习吧。</p> 
  <p>&nbsp;</p> 
  <p>1</p> 
  <p>以太坊</p> 
  <p>以太坊是一台分布式计算机，网络中的每个节点都执行一些字节码（智能合约），然后将结果状态存储在区块链中。区块链实质是一个应用了密码学技术的分布式数据库系统。（有关密码学的文章，前几篇文章中也有提及。）</p> 
  <p>当然，一个段落不足以清楚解释问题，您可以继续阅读以太坊白皮书，或者在其他相关帖子中去了解。</p> 
  <p>&nbsp;</p> 
  <p>2</p> 
  <p>智能合约</p> 
  <p>“智能合约”实际上只是一些类似在&nbsp;Ethereum&nbsp;平台这样的分布式环境中执行的代码。执行该代码的平台为这段代码提供了一些属性，例如：不变性，确定性操作，分布式和可验证状态等。“智能合约”实际上就是执行代码被管理的状态存储在区块链中，不可变，任何人都可以通过回顾这条链上的所有交易来检查当前状态是否正确。</p> 
  <p>在以太坊中，合约有一个地址来唯一标识它们（这是创建者地址的散列，以及他们之前发送了多少交易）。然后，客户端可以通过发送以太网，调用函数，查询它管理的分布式状态等方式与该地址进行交互。</p> 
  <p>智能合约也是一些代码，其中一些分布式状态由区块链管理。例如，您用来接收/发送ETH的multi-sid钱包只是一个智能合约，上面有一个用户界面。</p> 
  <p>&nbsp;</p> 
  <p>3</p> 
  <p>GAS</p> 
  <p>智能合约（代码块）由网络中的每个完整节点执行，容错性强（优点），但是这会花费大量的算力和时间（缺点）。因为执行计算需要花费金钱，所以执行计算的成本与代码执行的计算有关。换言之，EVM&nbsp;中的每个低级别操作码都需要花费一定量的“<strong>GAS</strong>”来执行。“<strong>GAS</strong>”只是一个抽象词汇，用于表示执行计算的成本。还有一个网络执行中的gas限制，以解决停机问题; 也就是说，你不能编写永不结束的程序，因为你消耗完“<strong>GAS</strong>”,网络会停止计算。</p> 
  <p>gas&nbsp;的“价格”（即这台分布式计算机上两个数字相加会花费我多少成本）”由市场决定，类似于比特币的交易费用。如果您支付更高的&nbsp;gas&nbsp;价格，节点将优先处理您的交易以获得更多收益。</p> 
  <p>一般来说，在Ethereum上计算和存储要比在传统环境中价格高，但是Eathereum为您的代码提供了上面讨论的所有这些好的属性，这些属性也同样重要。</p> 
  <p>&nbsp;</p> 
  <p>4</p> 
  <p>去中心化应用DApp</p> 
  <p>DApp 是一个运行在以太网络上的“服务端”，就像Android/ios上的app.</p> 
  <p>github上的ethereum组织有一个dapp-bin存储库，它有一些引用和示例。不过，一定要查看最近的文件状态信息，因为信息会很快过时。</p> 
  <p>&nbsp;</p> 
  <p>5</p> 
  <p>DApp 客户端</p> 
  <p>这些分布式应用程序通常伴随着一些用户友好的前端，因为没有人希望通过客户端或操作码手动处理例如带有散列和操作码这样的请求。</p> 
  <p>dApp客户端实际上就是任何“客户端”或“前端”，除了这个客户端与Ethereum区块链(可能除了其他服务)的接口之外。这些客户端通常是用JavaScript编写的，因为我们还没有将所有的库都转换成NodeJS。</p> 
  <p>更重要的是，大多数dApp客户端主要使用JavaScript编写，因为它可以在Web浏览器中运行。由于有很多GO语言的库，它们也经常用Go编写。所以您可以在JavaScript和Go(或许是Rust)之间进行选择，以便与Ethereum区块链及其上正在开发的协议进行交互。</p> 
  <p>那么问题来了？围绕“分布式应用程序”的确切术语/定义存在一些混淆/讨论：是否仅仅是智能合约？它是整个系统的后端，在某种程度上，与以太坊平台的接口存储信任？或者也可能包含客户端代码以及用户界面，因此整个包被称为“dApp”？</p> 
  <p>我将其定义为“与以太坊区块链接口系统后端”。这与“智能合约”有很大不同，证明其自身概念，并且也意味着（确实）任何人都可以创建客户端来与分布式应用进行交互。</p> 
  <p>&nbsp;</p> 
  <p>6</p> 
  <p>DApp浏览器</p> 
  <p>dApp&nbsp;浏览器，&nbsp;它是一个应用程序，为了&nbsp;dApp&nbsp;客户端（通常是与&nbsp;Ethereum&nbsp;节点交互的JavaScript&nbsp;（与智能合约进行通信））的使用更容易。</p> 
  <p>dApp&nbsp;浏览器的主要目的是：</p> 
  <ol>
   <li> <p>提供一个到&nbsp;Ethereum&nbsp;节点的连接（本地或远程托管的节点），也可以通过简单的方式将连接更改为指向不同节点（可能连接到不同的网络），</p> </li> 
   <li> <p>并为用户提供帐户界面（“钱包”），方便与这些dApp进行交互。</p> </li> 
  </ol>
  <p>Mist&nbsp;是官方&nbsp;Ethereum dApp&nbsp;浏览器。它实际上只是一个漂亮的&nbsp;Web&nbsp;用户界面，用于与&nbsp;Ethereum节点进行交互并向智能合约发送/接收事务。</p> 
  <p>Status 是一款移动浏览器，在手机上可以使用。</p> 
  <p>Toshi&nbsp;是&nbsp;Coinbase&nbsp;开发&nbsp;Ethereum&nbsp;钱包和浏览器的一次尝试。它把赌注压在“微信”+“聊天机器人”中。</p> 
  <p>MetaMask&nbsp;是一款&nbsp;Chrome&nbsp;扩展程序，可将&nbsp;Chrome&nbsp;变成“dApps&nbsp;浏览器”。其核心功能是它将web3（一个&nbsp;JavaScript Ethereum&nbsp;客户端库）注入每个页面，允许&nbsp;dApp&nbsp;连接到&nbsp;MetaMask&nbsp;托管的以太坊节点。Chrome 扩展程序允许管理钱包并将其连接到可用的不同以太网络。</p> 
  <p>Parity是一个以太坊客户端（以及一个全节点实现），它与您的Web浏览器集成在一起，将它变成一个dApp浏览器。</p> 
  <p>&nbsp;</p> 
  <p>7</p> 
  <p>以太坊节点</p> 
  <p>大多数关于比特币节点的知识在这都适用。节点存储区块链的副本，并可选择执行所有事务以确认结果状态。使用&nbsp;geth（first-party，Go）或&nbsp;parity（third-party，Rust）运行一个完整的节点或轻客户端。</p> 
  <p>您的节点需要知道要下载哪个区块链以及要与哪些对等点通信; 请参阅下面不同的可用网络的相关讨论。</p> 
  <p>您应该继续使用&nbsp;docker&nbsp;和某种持久性存储来运行所有这些节点客户端。如果你不想自己运行一个节点，你可以使用像&nbsp;Infura&nbsp;这样的第三方。还有一种方法可以运行本地节点进行测试和开发，稍后再讨论。</p> 
  <p>如果您将dApp客户端分发给用户，则不需要提供对以太坊节点的访问; dApp浏览器为任何需要它的客户端提供连接。</p> 
  <p>&nbsp;</p> 
  <p>8</p> 
  <p>以太坊代币</p> 
  <p>你知道我们如何编写代码（“智能合约”）将状态存储到区块链上了？ 即在该状态下我们将以太坊地址映射存储为一个整数。并称这个整数为balance。即“Tokens”</p> 
  <p>没错，你所听到的所有“Tokens”存储在哈希表中，通过API（aka协议）来增删改查。</p> 
  <p>继续阅读关于&nbsp;[the ethereum.org tutorial on creating a crowdsale]&nbsp;; 你会发现它只是一个合约（Crowdsale）,与另一个合约（MyToken）交互，就像上面链接的基本&nbsp;token contract&nbsp;一样。</p> 
  <p><strong>人们正在使用</strong><strong>token</strong><strong>来进行各种用途，并且很快你会发现想象力是无限的。</strong>Tokens经常用于激励与协议的交互，证明资产的所有权，投票权等。</p> 
  <p>Vitalik&nbsp;最近撰写了一篇分析&nbsp;tokens&nbsp;的博客文章&nbsp;[&nbsp;Analyzing token sale models]，可以拿来读一下。</p> 
  <p>&nbsp;</p> 
  <p>9</p> 
  <p>与智能合约进行交互</p> 
  <p>通过连接到&nbsp;Ethereum&nbsp;节点并通过&nbsp;JSON RPC API&nbsp;执行函数，您可以与智能合约（又名，执行方法和读取状态）进行交互。有许多以太坊节点客户端以开发友好的方式执行此操作。<strong>geth</strong>&nbsp;和&nbsp;<strong>parity&nbsp;</strong>都提供为与 contracts 交互提供控制台/浏览器。</p> 
  <p>如果您想以编程方式与contracts进行交互，则有各种Ethereum客户端实现。对于JavaScript，web3.js，ethjs和ethers.js很受欢迎。对于golang，go-ethereum中的abigen可执行文件提供了用于contracts进行交互的软件包。尽管如此，它只是一个标准的JSON RPC API，因此如果一旦不可用，您可以随时编写自己的适配器以选择您所选择的语言。&nbsp;除了简单的功能执行外，一些客户端库还提供了便利功能。</p> 
  <p>运行本地以太坊节点进行测试和开发Ganache（以前称为ethereumjs-testrpc）。</p> 
  <p>当你“deploy”一个智能合约时，你真正要做的就是用contract bytecode作为参数向0-address（0x0）发送一个交易。交易详解</p> 
  <p>&nbsp;</p> 
  <p>10</p> 
  <p>Truffle,Embark,Populous,Perigord</p> 
  <p>一旦你开始写智能合约，你最后会一遍又一遍地做很多相同的操作; 将你的源代码编译成字节码和abi，部署到网络，测试已部署合约等。你可能也会想更关注于你想实现的东西。</p> 
  <p>像Truffle，Embark，Populous和Perigord这样的框架可以标准化和自动化许多细节。他们为开发，部署以及非常重要的测试合约提供了很好的开发体验。</p> 
  <p>这篇漫游指南很好的阐述了使用Truffle 来部署和交互合约。</p> 
  <p><strong>Embark（Node）</strong>对开发人员应该如何构建项目有类似但不同的想法。</p> 
  <p><strong>Perigord（Go）</strong>与Truffle非常相似。</p> 
  <p><strong>Populous（Python）</strong>是一个积极开发的 Python 框架，可以满足相同的需求。</p> 
  <p>当你一开始接触合约时，如果你没有理解框架所提供的价值的话，你应该避免使用，就像你不应该开始学习如何使用 rails new 编写 HTML 一样。</p> 
  <p>&nbsp;</p> 
  <p>11</p> 
  <p>ETHPM &amp; NPM</p> 
  <p>共享一种关怀，所以ETHPM是一个去中心化的智能合约包资源库。使用ETHPM，您可以继承或链接到其他知名的合约和库，从而减少代码重复，并为将来的开发提供良好的合约基础。</p> 
  <p>&nbsp;</p> 
  <p>12</p> 
  <p>State of the Networks</p> 
  <p><strong>Mainnet</strong>&nbsp;- 以太网主网，通常是所以客户端和浏览器的默认网络。</p> 
  <p><strong>Ropsten</strong>-主要在以太坊使用工作量证明测试网。这个网络由于计算量小，很容易被DDOS，split和其他问题。它最近被再次启用，并在被垃圾邮件攻击后暂时放弃后再次启用。</p> 
  <p><strong>Kovan – Parity</strong>-唯一使用权威证明的客户端测试网络，针对垃圾邮件攻击提供免疫力和一致的4秒封锁时间。</p> 
  <p><strong>Rinkeby - geth&nbsp;</strong>客户端仅使用 Clique Consensus 的 testnet，因此尽管计算量较低，但对恶意行为者更具适应性。</p> 
  <p>您也可以运行您自己的以太坊专用网络。Go-ethereum 团队建立了puppeth来配置完整的网络，包括自定义的 bootnode，创世区块和共识规则，这正是 Rinkeby 网络的动力所在。您也可以运行自己的基础架构，可能使用 kubernetes 或 docker-compose。但是你可能不需要在短时间内运行一个私有网络。</p> 
  <p>&nbsp;</p> 
  <p>13</p> 
  <p>“账户”和“钱包”</p> 
  <p>Ethereum&nbsp;账户是私钥和地址对。他们基本上只是储存 Ether，创建时不需要&nbsp;gas。以太坊网络上的所有交易都来自一个账户; 合约不具备启动交易的能力。</p> 
  <p>钱包是两件事情之一： 1）用于创建和发送使用你的账户的交易的优化界面（即MyEtherWallet， 2）一个用于发送和接收以太网的智能合约（这又是一些代码）这是在Github上的一个钱包可靠实现.它们有多种类型，如多签名等。</p> 
  <p>现在我们已经正确地定义了这两者，准备好让人们把这两个词混淆在一起，并把任何发送/接收到醚的东西都贴上“钱包”的标签，并把所有东西都称为“账户”。</p> 
  <p>&nbsp;</p> 
  <p>14</p> 
  <p>智能合约编程语言</p> 
  <p><strong><strong><strong>Solidity</strong></strong></strong></p> 
  <p>Solidity是描述智能合约的first-party语言。因为是最流行的语言，所以有很多例子和参考教程。除非你有更好的学习，不然还是建议你认真学习他。</p> 
  <p>Remix是一个基于网络的IDE，下面是一个&nbsp;<strong>Solidity</strong>&nbsp;合约：</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://mmbiz.qpic.cn/mmbiz_png/PqicHbKBPuwzU0w9u5x0ibztls42OyKB8cGADHicQDCiaulpW0x0eU8GLtxkjGPQwrVUPSQdydY75AFyGDCyibx8BuA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1"></p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>LLL</strong></strong></strong></p> 
  <p>LLL是一门Lisp风格的底层编程语言。虽然以太坊官方并没有将它作为主要需要支持的语言，但它仍旧持续进行着更新，且与solidity在同一个资源库。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Serpent</strong></strong></strong></p> 
  <p>Serpent&nbsp;是一种编译为 EVM 字节码的高级 Python-esq 语言。由于 Zeppelin 发现了许多严重的 bug，因此它已被弃用。对于类似语言，请参阅 Vyper。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Vyper(previously Viper)</strong></strong></strong></p> 
  <p>Vyper也是python启发和开发的，专注于安全性、简单性和无意外。它仍在开发中。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Others</strong></strong></strong></p> 
  <p>在可用性和开发的不同状态中还有一些其他高级语言，毫无疑问将会有更多的语言被开发出来。但是，为了获得广泛的采用，语言和编译器必须经过彻底的审查和测试，这是需要时间来证明的。</p> 
  <p>&nbsp;</p> 
  <p>15</p> 
  <p>智能合约的安全</p> 
  <p>一旦智能合约部署到以太坊，它是不变的，并且永远存在。如果你写了一个bug，你不能删除; 你只能在后续的版本修复。</p> 
  <p>因为有那么多为&nbsp;Ethereum&nbsp;和其他智能合同平台开发的工程师来自&nbsp;web&nbsp;开发，所以这是一个最新和最疯狂的概念。</p> 
  <p>ConsenSys&nbsp;拥有一个完美的&nbsp;smart contract best practices，您应该深入理解。</p> 
  <p>在你部署一个能够操作真实现金的智能合约之前，你应该打开一个&nbsp;bug&nbsp;奖励并且对其进行测试。如果您正在处理RealMoney™，则应该对您的代码进行专业审计。</p> 
  <p>&nbsp;</p> 
  <p>16</p> 
  <p>Whisper</p> 
  <p>Whisper&nbsp;是一个构建到以太坊的信息系统。它允许dApp发布少量信息，以实现非实时通信。</p> 
  <p>它使用协议shh这是非常好的,很少有文档和采用这种协议。尽管它在一段时间内没有更新，但这里有一个使用Whisper实现聊天客户端的示例dapp。</p> 
  <p>&nbsp;</p> 
  <p>17</p> 
  <p>去中心自动化组织（DAOS）</p> 
  <p>这是一个组织（就像一群人），他们不用法律文件来强制执行操作，而是使用一堆智能合约。然后，你们的人群使用这些合约来完成一个组织所做的所有正常工作，比如进行投票。</p> 
  <p>这样做的一个副作用是决策制定，治理，并且永久地存储在区块链中（在这些合约的状态下）。</p> 
  <p>&nbsp;</p> 
  <p>18</p> 
  <p>IPFS &amp; FileCoin</p> 
  <p>IPFS（星际文件系统）是分发文件的协议。把它看作是一个使用 bittorrent 和 git 背后思想的文件系统，其中数据是内容寻址和不可变的。IPFS 使用称为 IPLD 的数据模型存储信息。</p> 
  <p>虽然这是一个新的协议，但有一个http网关和一个文件系统适配器，这意味着您可以通过http获取IPFS内容，并将整个全局文件系统挂载到本地磁盘的/ ipfs上。IPFS还提供称为IPNS（InterPlanetary名称空间）的命名系统，它允许可变状态（回想一下IPFS中的所有内容都是不可变的）。 您甚至可以使用DNS TXT记录来指导您的IPNS客户端，使您能够生成人性化的数据链接。</p> 
  <p>FileCoin是Protocol Labs为IPFS上的存储创建分布式市场所做的努力; 即为网络提供存储的激励层。 FileCoin共识协议消除工作证明的浪费，并且使用SpaceTime证明和复制证明，来确保一块数据被复制了一定的次数，并被存储了特定的时间。</p> 
  <p>您应该阅读&nbsp;IPFS白皮书，FileCoin白皮书&nbsp;和 IPLD规范。</p> 
  <p>&nbsp;</p> 
  <p>19</p> 
  <p>项目</p> 
  <p><strong><strong><strong>Gravity</strong></strong></strong></p> 
  <p>Gravity利用区块链的信任和价值体系，基于内容寻址的存储协议，构建存储系统，并设计去中心化的资源调度和计算网络，组成一体的大规模计算平台，提供外部公共大数据服务。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>&nbsp;</strong></strong></strong><strong><strong><strong>&nbsp;Augur</strong></strong></strong></p> 
  <p>Augur是一个去中心化的预测市场，可以让用户对真实世界的事件结果进行投注。一方面，您拥有预测市场，用户通过交易代币来表明对特定结果的信任; 一旦结果得以实现，获胜代币具有全部价值。 为了实现这一点，你需要分散的oracle协议，它创建了一个提供真实事件知识的市场，由 REP（声誉）协议 token 激励。</p> 
  <p>在GitHub上的对于Augur markets 合约非常值得一读。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Gnosis</strong></strong></strong></p> 
  <p>Gnosis&nbsp;与Augur 有相似的理念，也是去中心化的预测市场。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Golem</strong></strong></strong></p> 
  <p>与IPFS + FileCoin创建分布式存储市场一样，Golem是计算能力的分布式市场。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>OxProject</strong></strong></strong></p> 
  <p>0xProject创建用于交易token的协议和使用该协议的 dApp。开发人员可以在其分布式应用程序（也称为智能合约收集）之上建立一个交易所（技术上的“relayer”），用户不必担心您的应用程序的信用问题来结算交易; 结算在区块链上处理。0x协议旨在使用链外第三方（“relayers”）广播交易和管理订单（因此可以创建/更新/删除订单，而无需向以太坊发送缓慢且昂贵的交易）,但是使用&nbsp;Ethereum&nbsp;来进行结算。</p> 
  <p>他们首先实现了0xPortal(以前是0xOTC)，这是一个 dApp，使用他们的协议在用户之间直接传输 token。你可以查看他们在GitHub上的合约.他们向主网络发起了合约，并正在与社区合作建立relayers.</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Swap</strong></strong></strong></p> 
  <p>ConsenSys的Swap协议非常相似，但专注于通过“Indexers”传达意图（而不是签署交易承诺），然后让订单被撮合到 p2p。这是白皮书。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Bancor</strong></strong></strong></p> 
  <p>代币的流动性是密码生态系统中相对较大的问题。用户之间的交易既要满足你的购买欲望，也要满足对方的出售意愿(反之亦然)。</p> 
  <p>Bancor是一个协议（以及一套实施该协议的智能合约），可让您创建token，1）根据订单自行定价，2）通过持有另一个代币（如Ether或任何ERC20）作为抵押提供即时流动性。</p> 
  <p>&nbsp;</p> 
  <p><strong><strong><strong>Open Zeppelin &amp; zeppelin_os</strong></strong></strong></p> 
  <p>Zeppelin是一家技术公司，在这个领域做了一些非常了不起的专业工作。老实说，他们正在做很多事情，而且很难详尽的叙述。</p> 
  <p>他们管理Open Zeppelin，这是一套经过审核的智能合约最佳实践，您可以在自己的dApp中继承和使用它们。看看他们的GitHub上关于solidity contracts的回复，这是一个很好的学习资源。老实说，你应该看看里面的每一份合约。</p> 
  <p>他们正在将代码可重用性概念向前推进一步，并创建zeppelin_os。 忽略术语“OS”; 它不是经典意义上的操作系统。zeppelin_os是一组功能，工具和服务的集合，旨在提供可靠的开发人员体验，同时最大限度地提高智能合约安全性。</p> 
  <p>zeppelin_os的一部分是“zeppelin_os内核”，它不是内核，但实际上是一组知名的智能合约，充当库。它们可以通过代理库模型进行升级，并且可以在安全补丁情况下独立升级。由于在合约本身中包含的代码较少，因此部署成本更低，开发人员减少了代码重复。</p> 
  <p>zeppelin_os还有其他一些精巧的计划方面，比如调度程序（合同函数的异步执行，因为默认情况下，合约在与之交互之前不会执行任何操作），市场协议和离线开发人员体验工具。您可以通过白皮书了解更多关于它们的信息。</p> 
  <p><strong><strong><strong>&nbsp; ENS - Ethereum Name&nbsp;Service</strong></strong></strong></p> 
  <p>ENS是人类可读名称到地址的分散注册表。再加一个描述性项目名称。各种项目与它集成在一起，允许您支付.eth 地址或以其他方式将其用作方便的查找工具。您也可以创建解析到.eth地址的 DNS 记录。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://mmbiz.qpic.cn/mmbiz_png/PqicHbKBPuwzU0w9u5x0ibztls42OyKB8cME5x6WKx0Xbibuv7NiajuMnx30eEIpgbBa203Xz4JZDAZ6pjMuDLzv2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1"></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_42470308/article/details/81461008,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_42470308/article/details/81461008,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
