<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13（三） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13（三）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="源码0.13.2版的，在sublime中打开的 目录 源码0.13.2版的，在sublime中打开的 9.AppInit2() 9.1 setup 1）关闭警告消息 2）abort() 3)DEP 4）初始化网络 5)文件创建 6）进程终止信号 7）挂起信号处理 8）管道错误处理 9.2parameter interactions 1）-prune 2）确保文件描述符 9.3 parameter-to-internal-flags 1）不支持的内部标志 2）检索 3）交易池限制 4）脚本验证线程 5）区块修剪 6）注册RPC命令 7）节点超时参数 8）最小交易费 默认文件在src文件夹下，ide又增加了一个vs code，跳转到静态常量比较方便。最近在看书《区块链开发指南》，建议参考https://blog.csdn.net/pure_lady/article/details/77982837#t1这个博主，写的清楚多了 在linux中bitcoin数据目录默认路径～/.bitcoin/ 文件 详细描述 bicoin.conf bitcoin配置文件，bitcoid启动的时候会读取这个文件 debug.log 调试信息文件，各种日志写入均存储在该文件中 peers.dat 节点的信息 wallet.dat 钱包文件，保存你的私钥和相关交易记录，非常重要 blocks 区块链（blockchain）的数据存储目录 chainstate 区块链(blockchain)的状态存储目录 testnets 测试链的数据信息 9.AppInit2() 回到bitcoind.cpp继续后面的代码 fRet = AppInit2(threadGroup, scheduler); 那么来查看AppInit2这个函数，这个函数比较复杂，从备注来看分了12步 step 1:setup（安装网络环境，挂接事件处理器等） step 2:parameter interactions（进一步的参数交互设置，如区块裁剪prune和txindex的冲突检查、文件描述符的限制检查等） step 3:parameter-to-internal-flags（参数转换为内部变量，这样外部参数的设置将转换成程序内部的状态） step 4:application initialization :dir lock,daemonize,pidfile,debug log（初始化ECC，目录锁检查，保证只有一个bitcoind运行等） step 5:verify wallet database integrity（若启用钱包功能，则会检查钱包数据库的完整性） step 6:network initialization（网络初始化） step 7:load block chain（加载区块链数据，即blocks目录下的数据） step 8:load wallet（若是启用钱包功能，则加载钱包） step 9:data directory maintenance（若是裁剪模式，则进行blockstore的裁剪） step 10:import blocks（导入数据块） step 11:start node（启动节点服务，监听网络p2p请求，若启用-gen挖矿参数，则调用generatebitcoins启动数个挖矿线程bitcoinminer） step 12:finished(完成) //init.cpp /** Initialize bitcoin. * @pre Parameters should be parsed and config file should be read. */ bool AppInit2(boost::thread_group&amp; threadGroup, CScheduler&amp; scheduler) { 从备注来看AppInit2这个函数的作用是初始化bitcoin,这步之前需要完成参数解析与配置文件的读取。 9.1 setup 1）关闭警告消息 // ********************************************************* Step 1: setup #ifdef _MSC_VER // Turn off Microsoft heap dump noise _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE); _CrtSetReportFile(_CRT_WARN, CreateFileA(&quot;NUL&quot;, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)); #endif 从注释来看这段的功能是关闭微软内存堆的噪声，应该是针对微软的开发环境设置的，其他编译环境中这段不执行。 关于_MSC_VER的解释 _MSC_VER是微软的预编译控制。 _MSC_VER可以分解为：MS：Microsoft的简写;C:MSC就是Microsoft的C编译器;VER：Version的简写。_MSC_VER的意思就是：Microsoft的C编译器的版本。 微软不同时期，编译器有不同的版本： MS VC++10.0 _MSC_VER=1600;MS VC++9.0 _MSC_VER=1500;MS VC++8.0 _MSC_VER=1400 代码中的两个函数_CrtSetReportMode、_CrtSetReportFile在代码中没有找到定义，根据查询到的内容，在这段代码中是设置为报告类型为警告，报告输出方式为文件输出，但是输出文件为空，那么警告消息的输出可以理解为被关闭了。 2）abort() #if _MSC_VER &gt;= 1400 // Disable confusing &quot;helpful&quot; text message on abort, Ctrl-C _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT); #endif 这段是针对vc++8.0以上的处理，解决程序非正常终止时的帮助消息是否打印的问题，详细信息参考函数本身的说明_set_abort_behavior 3)DEP #ifdef WIN32 // Enable Data Execution Prevention (DEP) // Minimum supported OS versions: WinXP SP3, WinVista &gt;= SP1, Win Server 2008 // A failure is non-critical and needs no further attention! #ifndef PROCESS_DEP_ENABLE // We define this here, because GCCs winbase.h limits this to _WIN32_WINNT &gt;= 0x0601 (Windows 7), // which is not correct. Can be removed, when GCCs winbase.h is fixed! #define PROCESS_DEP_ENABLE 0x00000001 #endif typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD); PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;), &quot;SetProcessDEPPolicy&quot;); if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE); #endif 注释：启用数据执行保护（DEP），支持的最低操作系统WinXP SP3, WinVista &gt;= SP1, Win Server 2008；由于GCCs winbase.h将该功能限制在_WIN32_WINNT &gt;= 0x0601 (Windows 7)才能使用，这是不对的，所以有下面的强制宏定义。 代码表示通过函数指针获取Kernel32.dll中的SetProcessDEPPolicy函数对象，实现DEP功能的开启。 4）初始化网络 if (!SetupNetworking()) return InitError(&quot;Initializing networking failed&quot;); 调用函数SetupNetworking //util.cpp bool SetupNetworking() { #ifdef WIN32 // Initialize Windows Sockets WSADATA wsadata; int ret = WSAStartup(MAKEWORD(2,2), &amp;wsadata); if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2) return false; #endif return true; } 根据注释来看是初始化Windows Sockets，初始化工作通过WSAStartup函数实现。 5)文件创建 #ifndef WIN32 if (GetBoolArg(&quot;-sysperms&quot;, false)) { #ifdef ENABLE_WALLET if (!GetBoolArg(&quot;-disablewallet&quot;, false)) return InitError(&quot;-sysperms is not allowed in combination with enabled wallet functionality&quot;); #endif } else { umask(077); } ifndef WIN32是针对非window系统，首先判断参数是否设置了-sysperms,未设置则调用umask(077) -sysperms Create new files with system default permissions, instead of umask 077(only effective with disabled wallet functionality) 创建具有系统默认权限的新文件，而不是UMASK 077（仅对禁用钱包功能有效） 如果钱包未启用，则提示报错信息。umask用于设置文件与文件夹使用权限，077代表—rwxrwx,表示owner没有任何权限，group和other有所有权限。 6）进程终止信号 // Clean shutdown on SIGTERM struct sigaction sa;//信号处理对象 sa.sa_handler = HandleSIGTERM;//进程终止信号处理句柄 sigemptyset(&amp;sa.sa_mask); sa.sa_flags = 0; sigaction(SIGTERM, &amp;sa, NULL);//终止信号处理 sigaction(SIGINT, &amp;sa, NULL);//中断信号处理 句柄函数 //init.cpp std::atomic&lt;bool&gt; fRequestShutdown(false);//在同一文件不同位置 void HandleSIGTERM(int) { fRequestShutdown = true; } 函数非常简单，就是将全局变量fRequestShutdown设置为true std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 7）挂起信号处理 // Reopen debug.log on SIGHUP struct sigaction sa_hup;//信号处理对象 sa_hup.sa_handler = HandleSIGHUP; sigemptyset(&amp;sa_hup.sa_mask); sa_hup.sa_flags = 0; sigaction(SIGHUP, &amp;sa_hup, NULL);//挂起信号处理 和终止信号处理过程基本相同，句柄函数 std::atomic&lt;bool&gt; fReopenDebugLog(false); void HandleSIGHUP(int) { fReopenDebugLog = true; } 将全局变量fReopenDebugLog设置为true,在util.cpp中LogPrintStr重新打开日志文件 // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } 8）管道错误处理 // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly signal(SIGPIPE, SIG_IGN); #endif 忽略SIGPIPE，否则如果客户端关闭，它会导致守护进程下降。 9.2parameter interactions 没有备注就在在init.cpp的 // ********************************************************* Step 2: parameter interactions const CChainParams&amp; chainparams = Params(); CChainParams这个类在6.2有提到，这里就不再详细写了。 //chainparams.cpp const CChainParams &amp;Params() { assert(pCurrentParams); return *pCurrentParams; } 在step3 目录9.3 9)非标准交易 中有使用 1）-prune 这个参数如果设置资源配置不足的bitcoin.conf的配置信息应该还记得，我也有写在比特币源码编译那里，作用是通过删除旧的块，将磁盘空间要求降低到这个兆字节。 // if using block pruning, then disable txindex if (GetArg(&quot;-prune&quot;, 0)) { if (GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); #ifdef ENABLE_WALLET if (GetBoolArg(&quot;-rescan&quot;, false)) { return InitError(_(&quot;Rescans are not possible in pruned mode. You will need to use -reindex which will download the whole blockchain again.&quot;)); } #endif } -prune是和-txindex有冲突的，这个在《精通比特币》这本书里有写 //《精通比特币》 3.2.6配置比特币核心节点 prune 通过删除旧的块，将磁盘空间要求降低到这个兆字节。 在资源受限的节点上不能 满足完整块的节点使用这个。 txindex 维护所有交易的索引。 这意味着可以通过 ID 以编程方式检索任何交易的块链的 完整副本。 由于没有完整的区块链，也就无法使用钱包，无法回溯历史区块。 不过删除旧的块是怎们删除的呢，如果整个块删除那就连不起来了，会中间断开，搜索 在白皮书中有提到 Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block&#39;s hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block&#39;s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 作者的想法是修剪掉最新交易（已确认）之前的交易数据 也就是针对merkle tree来修剪的，有两种修剪对象，一个是所有输出被花费的的叶子节点（交易），另一是节点包含的所有子节点都已被修剪。并且是在0.11版本之后才开始实现这个功能。 根据bitcoin release note中的描述 Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 在比特币运行的本地环境中，有四种类型的数据（查看～/.bitcoin/目录，测试网查看～/.bitcoin/teseets/blocks/目录） raw block,从网络中接收的原始块信息，对应文件为blk*****.dat undo data,在进行chain reorganization时使用的数据，对应的文件为rev******.dat.chain reorganization是指某一节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行chain reorganization block index,区块索引，每一个区块都有一个唯一的索引，对应文件为/index下的**.ldb就是level db数据库文件。 UTXO,未花费支出，对应文件为../chainstate/下的.ldb文件 2）确保文件描述符 关于linux的文件描述符，可以参考https://blog.csdn.net/cywosp/article/details/38965239 介绍这段代码中用到的几个宏定义 //net.h /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 最大可维护的节点连接书，默认125 //compat.h #define FD_SETSIZE 1024 // max number of fds in fd_set 可包含的最大文件描述符的个数，默认1024 #ifdef WIN32 // Win32 LevelDB doesn&#39;t use filedescriptors, and the ones used for // accessing block files don&#39;t count towards the fd_set size limit // anyway. #define MIN_CORE_FILEDESCRIPTORS 0 #else #define MIN_CORE_FILEDESCRIPTORS 150 #endif 最小核心文件描述符的个数，windows下为0，linux为150 具体代码就不放上来了。返回目录 9.3 parameter-to-internal-flags 内部标志的参数处理 1）不支持的内部标志 -debug/-nodebug:如果-debug=0或者-nodebug被设置，设置fDebug=false,关闭调试信息; //util.cpp bool fDebug = false; -debugnet：不支持的参数，用-debug=net替代; -socks:不支持的参数，目前只支持SOCKS5; -tor:不支持的参数，应使用-onion; onion=&lt;ip:port&gt; Use separate SOCKS5 proxy to reach peers via Tor hidden services -benchmark:不支持的参数，用-debug=bench替代 -whitelistalwaysrelay:不支持的参数，应使用-whitelistrelay或-whitelistforcerelay -blockminsize:不支持的参数 2）检索 检测交易池和区块索引，这两个参数在私有网模式下默认为true // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } mempool是CTxMemPool类型 //main.cpp CTxMemPool mempool(::minRelayTxFee); CTxMemPool定义在txmempool.h,根据注释来看 CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. 该类是用来保存在当前最佳链下的有效交易并且这些交易也会被打包到后续的区块中。 Transactions are added when they are seen on the network *(or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. 但不是所有被发现的交易都会被添加到池里：如果一个新交易在池中花费了一个交易的输入（双花），则它被丢弃，非标准事务也是如此。所以CTxMemPool 需要对交易进行完整性检测，检测频率通过setSanityCheck来设置 //txmempool.h uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } 4294967295.0=2^32-1,nCheckFrequency代表池中所有交易的检测频率，即每隔nCheckFrequency个交易检测一次。传入的dFrequency的值是1.0 再返回去看ratio的获取 int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); CChainParams这个类在6.2选择比特币网络中有提到，要看的是DefaultConsistencyChecks()这个函数返回值 //chainparams.h CChainParams类中 /** Default value for -checkmempool and -checkblockindex argument */ bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; } bool fDefaultConsistencyChecks; CChainParams类是基类，其三个子类中，CMainParams，CTestNetParams这两个类中fDefaultConsistencyChecks=false,CRegTestParams=true。也就是说只有在私有网中才默认需要进行一致性检测。 接下来看区块索引检测 fCheckBlockIndex = GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); //main.cpp bool fCheckBlockIndex = false; bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED; //main.h static const bool DEFAULT_CHECKPOINTS_ENABLED = true; 私有网是默认进行区块索引的检测。参数检测点是默认为true,即默认进行检测点检查。关于检测点的作用这里不写了。检测点的具体使用后面应该会有。 3）交易池限制 // mempool limits int64_t nMempoolSizeMax = GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); 首先计算最大和最小交易池size,其中的默认值 //policy.h /** Default for -maxmempool, maximum megabytes//(MB) of mempool memory usage */ static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300; //main.h /** Default for -limitdescendantsize, maximum kilobytes//(KB) of in-mempool descendants */ static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101; 默认最大存储容量是300MB,最小存储容量101KB。 4）脚本验证线程 -par=0意味着自动执行，但nScriptCheckThreads=0代表没有并发 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; fServer = GetBoolArg(&quot;-server&quot;, false); 在help信息中找到对-par参数的解释 -par=&lt;n&gt; Set the number of script verification threads (-2 to 16, 0 = auto, &lt;0 =leave that many cores free, default: 0) 默认的线程验证为0=auto，&lt;0表示释放内核，下面还定义了最大的脚本验证线程数是16 //main.h /** -par default (number of script-checking threads, 0 = auto) */ static const int DEFAULT_SCRIPTCHECK_THREADS = 0; /** Number of blocks that can be requested at any given time from a single peer. */ static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16; 接下来看对nScriptCheckThreads的逻辑判断:nScriptCheckThreads&lt;0,通过GetNumCores（）函数获取程序运行机器能提供的线程数，然后加上，再判断后面的； //util.cpp int GetNumCores() { #if BOOST_VERSION &gt;= 105600 return boost::thread::physical_concurrency(); #else // Must fall back to hardware_concurrency, which unfortunately counts virtual cores return boost::thread::hardware_concurrency(); #endif } //version.hpp #define BOOST_VERSION 105800 上述代码用到了c++ boost库的boost:thread,对这两个函数不是很理解，去boost库查找 physical_concurrency()返回当前系统上可用的物理内核，与hardware_concurrency()不同，他不返回虚拟内核的数量，只计算物理内核。 5）区块修剪 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nSignedPruneTarget = GetArg(&quot;-prune&quot;, 0) * 1024 * 1024; if (nSignedPruneTarget &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } -prune这个参数在9.2 1)已经介绍过了，来看代码部分，首先获取数值，单位是MB，判断数值，该参数不能为负数。 nPruneTarget = (uint64_t) nSignedPruneTarget; if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } //main.h static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024; 最低的空间要求是550M，这点在帮助信息也有明确的提示 -prune=&lt;n&gt; Reduce storage requirements by pruning (deleting) old blocks. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain.(default: 0 = disable pruning blocks, &gt;550 = target size in MiB to use for block files) 6）注册RPC命令 在代码中就调用了一下 RegisterAllCoreRPCCommands(tableRPC); 在src/rpc/register.h下是对该函数的定义 static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;tableRPC) { /** Register block chain RPC commands */ RegisterBlockchainRPCCommands(tableRPC);//区块链RPC命令注册 /** Register P2P networking RPC commands */ RegisterNetRPCCommands(tableRPC);//P2P网络命令注册 /** Register miscellaneous RPC commands */ RegisterMiscRPCCommands(tableRPC);//其他工具RPC /** Register mining RPC commands */ RegisterMiningRPCCommands(tableRPC);//挖矿RPC命令 /** Register raw transaction RPC commands */ RegisterRawTransactionRPCCommands(tableRPC);//交易RPC } 分别来看这些命令注册实现的具体位置 I 区块链RPC命令，整个cpp文件都是对应命令的具体实现，下面是命令列表，在RegisterBlockchainRPCCommands函数中通过遍历的方式添加命令。 //src/rpc/blockchain.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, true }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, true }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, true }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, true }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, true }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, true }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, true }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, true }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, true }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, true }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, true }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, true }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, true }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, true }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, true }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, true }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, true }, }; void RegisterBlockchainRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } II P2P网络RPC命令，代码结构基本相同的 //src/rpc/net.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, true }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, true }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, true }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, true }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, true }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, true }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, true }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, true }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, true }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, true }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, true }, }; void RegisterNetRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } III 其他工具RPC命令 //src/rpc/misc.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;control&quot;, &quot;getinfo&quot;, &amp;getinfo, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;validateaddress&quot;, &amp;validateaddress, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;createmultisig&quot;, &amp;createmultisig, true }, { &quot;util&quot;, &quot;verifymessage&quot;, &amp;verifymessage, true }, { &quot;util&quot;, &quot;signmessagewithprivkey&quot;, &amp;signmessagewithprivkey, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;setmocktime&quot;, &amp;setmocktime, true }, }; IV mining rpc commands //src/rpc/mining.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, true }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, true }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, true }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, true }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, true }, { &quot;generating&quot;, &quot;generate&quot;, &amp;generate, true }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, true }, { &quot;util&quot;, &quot;estimatefee&quot;, &amp;estimatefee, true }, { &quot;util&quot;, &quot;estimatepriority&quot;, &amp;estimatepriority, true }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, true }, { &quot;util&quot;, &quot;estimatesmartpriority&quot;, &amp;estimatesmartpriority, true }, }; V 交易RPC命令 //src/rpc/rawtransaction.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, true }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, false }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, false }, /* uses wallet if enabled */ { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, true }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, true }, }; 这些命令的注册方式都是相似的，就不再说明了。 后面的代码，如果定义了开启钱包宏(默认开启)，没有关闭钱包，就注册钱包的RPC命令。 #ifdef ENABLE_WALLET bool fDisableWallet = GetBoolArg(&quot;-disablewallet&quot;, false); if (!fDisableWallet) RegisterWalletRPCCommands(tableRPC); #endif //src/config/bitcion-config.h /* Define to 1 to enable wallet functions */ #define ENABLE_WALLET 1 注册方式与前面的相似，在src/wallwet/rpcwallet.cpp 这些rpc命令可以在在bitcoin-cli命令行中使用，bitcoin-cli help可以获取这些帮助信息 7）节点超时参数 比特币网络中新加入的节点都回去寻找节点，加入比特币p2p网络中，与其他节点完成同步操作，不过寻找节点的时间是有限制的，默认值为5000ms,并且不能设置为负数 nConnectTimeout = GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; //netbase.h //! -timeout default static const int DEFAULT_CONNECT_TIMEOUT = 5000; 8）最小交易费 首先来看注释内容，该费率为没千字节所需的最小费率，这个费率值的设置对矿工来说需要谨慎设置：如果你设置为0，那么每个被挖出的块都会被交易的垃圾邮件发送者的1聪交易费的交易填满，最低交易费应高于处理交易所需的成本。 // Fee-per-kilobyte amount considered the same as &quot;free&quot; // If you are mining, be careful setting this: // if you set it to zero then // a transaction spammer can cheaply fill blocks using // 1-satoshi-fee transactions. It should be set above the real // cost to you of processing a transaction. if (mapArgs.count(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-minrelaytxfee&quot;], n) &amp;&amp; n &gt; 0) ::minRelayTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, mapArgs[&quot;-minrelaytxfee&quot;])); } 如果设置了-minrelaytxfee，调用CFeeRate设置费用；若未设置，也是调用该函数，设为默认值，默认最小费率为1000聪 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); //main.h /** Default for -minrelaytxfee, minimum relay fee for transactions */ static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 接下来看一下minRelayTxFee这个全局变量的使用场所 //main.cpp CTxMemPool mempool(::minRelayTxFee); FeeFilterRounder filterRounder(::minRelayTxFee); 在设置矿池和费用循环过滤中用到。 比特币源码学习0.13（四） 阅读更多" />
<meta property="og:description" content="源码0.13.2版的，在sublime中打开的 目录 源码0.13.2版的，在sublime中打开的 9.AppInit2() 9.1 setup 1）关闭警告消息 2）abort() 3)DEP 4）初始化网络 5)文件创建 6）进程终止信号 7）挂起信号处理 8）管道错误处理 9.2parameter interactions 1）-prune 2）确保文件描述符 9.3 parameter-to-internal-flags 1）不支持的内部标志 2）检索 3）交易池限制 4）脚本验证线程 5）区块修剪 6）注册RPC命令 7）节点超时参数 8）最小交易费 默认文件在src文件夹下，ide又增加了一个vs code，跳转到静态常量比较方便。最近在看书《区块链开发指南》，建议参考https://blog.csdn.net/pure_lady/article/details/77982837#t1这个博主，写的清楚多了 在linux中bitcoin数据目录默认路径～/.bitcoin/ 文件 详细描述 bicoin.conf bitcoin配置文件，bitcoid启动的时候会读取这个文件 debug.log 调试信息文件，各种日志写入均存储在该文件中 peers.dat 节点的信息 wallet.dat 钱包文件，保存你的私钥和相关交易记录，非常重要 blocks 区块链（blockchain）的数据存储目录 chainstate 区块链(blockchain)的状态存储目录 testnets 测试链的数据信息 9.AppInit2() 回到bitcoind.cpp继续后面的代码 fRet = AppInit2(threadGroup, scheduler); 那么来查看AppInit2这个函数，这个函数比较复杂，从备注来看分了12步 step 1:setup（安装网络环境，挂接事件处理器等） step 2:parameter interactions（进一步的参数交互设置，如区块裁剪prune和txindex的冲突检查、文件描述符的限制检查等） step 3:parameter-to-internal-flags（参数转换为内部变量，这样外部参数的设置将转换成程序内部的状态） step 4:application initialization :dir lock,daemonize,pidfile,debug log（初始化ECC，目录锁检查，保证只有一个bitcoind运行等） step 5:verify wallet database integrity（若启用钱包功能，则会检查钱包数据库的完整性） step 6:network initialization（网络初始化） step 7:load block chain（加载区块链数据，即blocks目录下的数据） step 8:load wallet（若是启用钱包功能，则加载钱包） step 9:data directory maintenance（若是裁剪模式，则进行blockstore的裁剪） step 10:import blocks（导入数据块） step 11:start node（启动节点服务，监听网络p2p请求，若启用-gen挖矿参数，则调用generatebitcoins启动数个挖矿线程bitcoinminer） step 12:finished(完成) //init.cpp /** Initialize bitcoin. * @pre Parameters should be parsed and config file should be read. */ bool AppInit2(boost::thread_group&amp; threadGroup, CScheduler&amp; scheduler) { 从备注来看AppInit2这个函数的作用是初始化bitcoin,这步之前需要完成参数解析与配置文件的读取。 9.1 setup 1）关闭警告消息 // ********************************************************* Step 1: setup #ifdef _MSC_VER // Turn off Microsoft heap dump noise _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE); _CrtSetReportFile(_CRT_WARN, CreateFileA(&quot;NUL&quot;, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)); #endif 从注释来看这段的功能是关闭微软内存堆的噪声，应该是针对微软的开发环境设置的，其他编译环境中这段不执行。 关于_MSC_VER的解释 _MSC_VER是微软的预编译控制。 _MSC_VER可以分解为：MS：Microsoft的简写;C:MSC就是Microsoft的C编译器;VER：Version的简写。_MSC_VER的意思就是：Microsoft的C编译器的版本。 微软不同时期，编译器有不同的版本： MS VC++10.0 _MSC_VER=1600;MS VC++9.0 _MSC_VER=1500;MS VC++8.0 _MSC_VER=1400 代码中的两个函数_CrtSetReportMode、_CrtSetReportFile在代码中没有找到定义，根据查询到的内容，在这段代码中是设置为报告类型为警告，报告输出方式为文件输出，但是输出文件为空，那么警告消息的输出可以理解为被关闭了。 2）abort() #if _MSC_VER &gt;= 1400 // Disable confusing &quot;helpful&quot; text message on abort, Ctrl-C _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT); #endif 这段是针对vc++8.0以上的处理，解决程序非正常终止时的帮助消息是否打印的问题，详细信息参考函数本身的说明_set_abort_behavior 3)DEP #ifdef WIN32 // Enable Data Execution Prevention (DEP) // Minimum supported OS versions: WinXP SP3, WinVista &gt;= SP1, Win Server 2008 // A failure is non-critical and needs no further attention! #ifndef PROCESS_DEP_ENABLE // We define this here, because GCCs winbase.h limits this to _WIN32_WINNT &gt;= 0x0601 (Windows 7), // which is not correct. Can be removed, when GCCs winbase.h is fixed! #define PROCESS_DEP_ENABLE 0x00000001 #endif typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD); PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;), &quot;SetProcessDEPPolicy&quot;); if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE); #endif 注释：启用数据执行保护（DEP），支持的最低操作系统WinXP SP3, WinVista &gt;= SP1, Win Server 2008；由于GCCs winbase.h将该功能限制在_WIN32_WINNT &gt;= 0x0601 (Windows 7)才能使用，这是不对的，所以有下面的强制宏定义。 代码表示通过函数指针获取Kernel32.dll中的SetProcessDEPPolicy函数对象，实现DEP功能的开启。 4）初始化网络 if (!SetupNetworking()) return InitError(&quot;Initializing networking failed&quot;); 调用函数SetupNetworking //util.cpp bool SetupNetworking() { #ifdef WIN32 // Initialize Windows Sockets WSADATA wsadata; int ret = WSAStartup(MAKEWORD(2,2), &amp;wsadata); if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2) return false; #endif return true; } 根据注释来看是初始化Windows Sockets，初始化工作通过WSAStartup函数实现。 5)文件创建 #ifndef WIN32 if (GetBoolArg(&quot;-sysperms&quot;, false)) { #ifdef ENABLE_WALLET if (!GetBoolArg(&quot;-disablewallet&quot;, false)) return InitError(&quot;-sysperms is not allowed in combination with enabled wallet functionality&quot;); #endif } else { umask(077); } ifndef WIN32是针对非window系统，首先判断参数是否设置了-sysperms,未设置则调用umask(077) -sysperms Create new files with system default permissions, instead of umask 077(only effective with disabled wallet functionality) 创建具有系统默认权限的新文件，而不是UMASK 077（仅对禁用钱包功能有效） 如果钱包未启用，则提示报错信息。umask用于设置文件与文件夹使用权限，077代表—rwxrwx,表示owner没有任何权限，group和other有所有权限。 6）进程终止信号 // Clean shutdown on SIGTERM struct sigaction sa;//信号处理对象 sa.sa_handler = HandleSIGTERM;//进程终止信号处理句柄 sigemptyset(&amp;sa.sa_mask); sa.sa_flags = 0; sigaction(SIGTERM, &amp;sa, NULL);//终止信号处理 sigaction(SIGINT, &amp;sa, NULL);//中断信号处理 句柄函数 //init.cpp std::atomic&lt;bool&gt; fRequestShutdown(false);//在同一文件不同位置 void HandleSIGTERM(int) { fRequestShutdown = true; } 函数非常简单，就是将全局变量fRequestShutdown设置为true std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 7）挂起信号处理 // Reopen debug.log on SIGHUP struct sigaction sa_hup;//信号处理对象 sa_hup.sa_handler = HandleSIGHUP; sigemptyset(&amp;sa_hup.sa_mask); sa_hup.sa_flags = 0; sigaction(SIGHUP, &amp;sa_hup, NULL);//挂起信号处理 和终止信号处理过程基本相同，句柄函数 std::atomic&lt;bool&gt; fReopenDebugLog(false); void HandleSIGHUP(int) { fReopenDebugLog = true; } 将全局变量fReopenDebugLog设置为true,在util.cpp中LogPrintStr重新打开日志文件 // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } 8）管道错误处理 // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly signal(SIGPIPE, SIG_IGN); #endif 忽略SIGPIPE，否则如果客户端关闭，它会导致守护进程下降。 9.2parameter interactions 没有备注就在在init.cpp的 // ********************************************************* Step 2: parameter interactions const CChainParams&amp; chainparams = Params(); CChainParams这个类在6.2有提到，这里就不再详细写了。 //chainparams.cpp const CChainParams &amp;Params() { assert(pCurrentParams); return *pCurrentParams; } 在step3 目录9.3 9)非标准交易 中有使用 1）-prune 这个参数如果设置资源配置不足的bitcoin.conf的配置信息应该还记得，我也有写在比特币源码编译那里，作用是通过删除旧的块，将磁盘空间要求降低到这个兆字节。 // if using block pruning, then disable txindex if (GetArg(&quot;-prune&quot;, 0)) { if (GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); #ifdef ENABLE_WALLET if (GetBoolArg(&quot;-rescan&quot;, false)) { return InitError(_(&quot;Rescans are not possible in pruned mode. You will need to use -reindex which will download the whole blockchain again.&quot;)); } #endif } -prune是和-txindex有冲突的，这个在《精通比特币》这本书里有写 //《精通比特币》 3.2.6配置比特币核心节点 prune 通过删除旧的块，将磁盘空间要求降低到这个兆字节。 在资源受限的节点上不能 满足完整块的节点使用这个。 txindex 维护所有交易的索引。 这意味着可以通过 ID 以编程方式检索任何交易的块链的 完整副本。 由于没有完整的区块链，也就无法使用钱包，无法回溯历史区块。 不过删除旧的块是怎们删除的呢，如果整个块删除那就连不起来了，会中间断开，搜索 在白皮书中有提到 Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block&#39;s hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block&#39;s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 作者的想法是修剪掉最新交易（已确认）之前的交易数据 也就是针对merkle tree来修剪的，有两种修剪对象，一个是所有输出被花费的的叶子节点（交易），另一是节点包含的所有子节点都已被修剪。并且是在0.11版本之后才开始实现这个功能。 根据bitcoin release note中的描述 Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 在比特币运行的本地环境中，有四种类型的数据（查看～/.bitcoin/目录，测试网查看～/.bitcoin/teseets/blocks/目录） raw block,从网络中接收的原始块信息，对应文件为blk*****.dat undo data,在进行chain reorganization时使用的数据，对应的文件为rev******.dat.chain reorganization是指某一节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行chain reorganization block index,区块索引，每一个区块都有一个唯一的索引，对应文件为/index下的**.ldb就是level db数据库文件。 UTXO,未花费支出，对应文件为../chainstate/下的.ldb文件 2）确保文件描述符 关于linux的文件描述符，可以参考https://blog.csdn.net/cywosp/article/details/38965239 介绍这段代码中用到的几个宏定义 //net.h /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 最大可维护的节点连接书，默认125 //compat.h #define FD_SETSIZE 1024 // max number of fds in fd_set 可包含的最大文件描述符的个数，默认1024 #ifdef WIN32 // Win32 LevelDB doesn&#39;t use filedescriptors, and the ones used for // accessing block files don&#39;t count towards the fd_set size limit // anyway. #define MIN_CORE_FILEDESCRIPTORS 0 #else #define MIN_CORE_FILEDESCRIPTORS 150 #endif 最小核心文件描述符的个数，windows下为0，linux为150 具体代码就不放上来了。返回目录 9.3 parameter-to-internal-flags 内部标志的参数处理 1）不支持的内部标志 -debug/-nodebug:如果-debug=0或者-nodebug被设置，设置fDebug=false,关闭调试信息; //util.cpp bool fDebug = false; -debugnet：不支持的参数，用-debug=net替代; -socks:不支持的参数，目前只支持SOCKS5; -tor:不支持的参数，应使用-onion; onion=&lt;ip:port&gt; Use separate SOCKS5 proxy to reach peers via Tor hidden services -benchmark:不支持的参数，用-debug=bench替代 -whitelistalwaysrelay:不支持的参数，应使用-whitelistrelay或-whitelistforcerelay -blockminsize:不支持的参数 2）检索 检测交易池和区块索引，这两个参数在私有网模式下默认为true // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } mempool是CTxMemPool类型 //main.cpp CTxMemPool mempool(::minRelayTxFee); CTxMemPool定义在txmempool.h,根据注释来看 CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. 该类是用来保存在当前最佳链下的有效交易并且这些交易也会被打包到后续的区块中。 Transactions are added when they are seen on the network *(or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. 但不是所有被发现的交易都会被添加到池里：如果一个新交易在池中花费了一个交易的输入（双花），则它被丢弃，非标准事务也是如此。所以CTxMemPool 需要对交易进行完整性检测，检测频率通过setSanityCheck来设置 //txmempool.h uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } 4294967295.0=2^32-1,nCheckFrequency代表池中所有交易的检测频率，即每隔nCheckFrequency个交易检测一次。传入的dFrequency的值是1.0 再返回去看ratio的获取 int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); CChainParams这个类在6.2选择比特币网络中有提到，要看的是DefaultConsistencyChecks()这个函数返回值 //chainparams.h CChainParams类中 /** Default value for -checkmempool and -checkblockindex argument */ bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; } bool fDefaultConsistencyChecks; CChainParams类是基类，其三个子类中，CMainParams，CTestNetParams这两个类中fDefaultConsistencyChecks=false,CRegTestParams=true。也就是说只有在私有网中才默认需要进行一致性检测。 接下来看区块索引检测 fCheckBlockIndex = GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); //main.cpp bool fCheckBlockIndex = false; bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED; //main.h static const bool DEFAULT_CHECKPOINTS_ENABLED = true; 私有网是默认进行区块索引的检测。参数检测点是默认为true,即默认进行检测点检查。关于检测点的作用这里不写了。检测点的具体使用后面应该会有。 3）交易池限制 // mempool limits int64_t nMempoolSizeMax = GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); 首先计算最大和最小交易池size,其中的默认值 //policy.h /** Default for -maxmempool, maximum megabytes//(MB) of mempool memory usage */ static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300; //main.h /** Default for -limitdescendantsize, maximum kilobytes//(KB) of in-mempool descendants */ static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101; 默认最大存储容量是300MB,最小存储容量101KB。 4）脚本验证线程 -par=0意味着自动执行，但nScriptCheckThreads=0代表没有并发 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; fServer = GetBoolArg(&quot;-server&quot;, false); 在help信息中找到对-par参数的解释 -par=&lt;n&gt; Set the number of script verification threads (-2 to 16, 0 = auto, &lt;0 =leave that many cores free, default: 0) 默认的线程验证为0=auto，&lt;0表示释放内核，下面还定义了最大的脚本验证线程数是16 //main.h /** -par default (number of script-checking threads, 0 = auto) */ static const int DEFAULT_SCRIPTCHECK_THREADS = 0; /** Number of blocks that can be requested at any given time from a single peer. */ static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16; 接下来看对nScriptCheckThreads的逻辑判断:nScriptCheckThreads&lt;0,通过GetNumCores（）函数获取程序运行机器能提供的线程数，然后加上，再判断后面的； //util.cpp int GetNumCores() { #if BOOST_VERSION &gt;= 105600 return boost::thread::physical_concurrency(); #else // Must fall back to hardware_concurrency, which unfortunately counts virtual cores return boost::thread::hardware_concurrency(); #endif } //version.hpp #define BOOST_VERSION 105800 上述代码用到了c++ boost库的boost:thread,对这两个函数不是很理解，去boost库查找 physical_concurrency()返回当前系统上可用的物理内核，与hardware_concurrency()不同，他不返回虚拟内核的数量，只计算物理内核。 5）区块修剪 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nSignedPruneTarget = GetArg(&quot;-prune&quot;, 0) * 1024 * 1024; if (nSignedPruneTarget &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } -prune这个参数在9.2 1)已经介绍过了，来看代码部分，首先获取数值，单位是MB，判断数值，该参数不能为负数。 nPruneTarget = (uint64_t) nSignedPruneTarget; if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } //main.h static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024; 最低的空间要求是550M，这点在帮助信息也有明确的提示 -prune=&lt;n&gt; Reduce storage requirements by pruning (deleting) old blocks. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain.(default: 0 = disable pruning blocks, &gt;550 = target size in MiB to use for block files) 6）注册RPC命令 在代码中就调用了一下 RegisterAllCoreRPCCommands(tableRPC); 在src/rpc/register.h下是对该函数的定义 static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;tableRPC) { /** Register block chain RPC commands */ RegisterBlockchainRPCCommands(tableRPC);//区块链RPC命令注册 /** Register P2P networking RPC commands */ RegisterNetRPCCommands(tableRPC);//P2P网络命令注册 /** Register miscellaneous RPC commands */ RegisterMiscRPCCommands(tableRPC);//其他工具RPC /** Register mining RPC commands */ RegisterMiningRPCCommands(tableRPC);//挖矿RPC命令 /** Register raw transaction RPC commands */ RegisterRawTransactionRPCCommands(tableRPC);//交易RPC } 分别来看这些命令注册实现的具体位置 I 区块链RPC命令，整个cpp文件都是对应命令的具体实现，下面是命令列表，在RegisterBlockchainRPCCommands函数中通过遍历的方式添加命令。 //src/rpc/blockchain.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, true }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, true }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, true }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, true }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, true }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, true }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, true }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, true }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, true }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, true }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, true }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, true }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, true }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, true }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, true }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, true }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, true }, }; void RegisterBlockchainRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } II P2P网络RPC命令，代码结构基本相同的 //src/rpc/net.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, true }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, true }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, true }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, true }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, true }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, true }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, true }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, true }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, true }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, true }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, true }, }; void RegisterNetRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } III 其他工具RPC命令 //src/rpc/misc.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;control&quot;, &quot;getinfo&quot;, &amp;getinfo, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;validateaddress&quot;, &amp;validateaddress, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;createmultisig&quot;, &amp;createmultisig, true }, { &quot;util&quot;, &quot;verifymessage&quot;, &amp;verifymessage, true }, { &quot;util&quot;, &quot;signmessagewithprivkey&quot;, &amp;signmessagewithprivkey, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;setmocktime&quot;, &amp;setmocktime, true }, }; IV mining rpc commands //src/rpc/mining.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, true }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, true }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, true }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, true }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, true }, { &quot;generating&quot;, &quot;generate&quot;, &amp;generate, true }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, true }, { &quot;util&quot;, &quot;estimatefee&quot;, &amp;estimatefee, true }, { &quot;util&quot;, &quot;estimatepriority&quot;, &amp;estimatepriority, true }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, true }, { &quot;util&quot;, &quot;estimatesmartpriority&quot;, &amp;estimatesmartpriority, true }, }; V 交易RPC命令 //src/rpc/rawtransaction.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, true }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, false }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, false }, /* uses wallet if enabled */ { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, true }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, true }, }; 这些命令的注册方式都是相似的，就不再说明了。 后面的代码，如果定义了开启钱包宏(默认开启)，没有关闭钱包，就注册钱包的RPC命令。 #ifdef ENABLE_WALLET bool fDisableWallet = GetBoolArg(&quot;-disablewallet&quot;, false); if (!fDisableWallet) RegisterWalletRPCCommands(tableRPC); #endif //src/config/bitcion-config.h /* Define to 1 to enable wallet functions */ #define ENABLE_WALLET 1 注册方式与前面的相似，在src/wallwet/rpcwallet.cpp 这些rpc命令可以在在bitcoin-cli命令行中使用，bitcoin-cli help可以获取这些帮助信息 7）节点超时参数 比特币网络中新加入的节点都回去寻找节点，加入比特币p2p网络中，与其他节点完成同步操作，不过寻找节点的时间是有限制的，默认值为5000ms,并且不能设置为负数 nConnectTimeout = GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; //netbase.h //! -timeout default static const int DEFAULT_CONNECT_TIMEOUT = 5000; 8）最小交易费 首先来看注释内容，该费率为没千字节所需的最小费率，这个费率值的设置对矿工来说需要谨慎设置：如果你设置为0，那么每个被挖出的块都会被交易的垃圾邮件发送者的1聪交易费的交易填满，最低交易费应高于处理交易所需的成本。 // Fee-per-kilobyte amount considered the same as &quot;free&quot; // If you are mining, be careful setting this: // if you set it to zero then // a transaction spammer can cheaply fill blocks using // 1-satoshi-fee transactions. It should be set above the real // cost to you of processing a transaction. if (mapArgs.count(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-minrelaytxfee&quot;], n) &amp;&amp; n &gt; 0) ::minRelayTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, mapArgs[&quot;-minrelaytxfee&quot;])); } 如果设置了-minrelaytxfee，调用CFeeRate设置费用；若未设置，也是调用该函数，设为默认值，默认最小费率为1000聪 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); //main.h /** Default for -minrelaytxfee, minimum relay fee for transactions */ static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 接下来看一下minRelayTxFee这个全局变量的使用场所 //main.cpp CTxMemPool mempool(::minRelayTxFee); FeeFilterRounder filterRounder(::minRelayTxFee); 在设置矿池和费用循环过滤中用到。 比特币源码学习0.13（四） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/06/8f0edf39c0123e1727acc8eda91f443e.html" />
<meta property="og:url" content="https://mlh.app/2018/08/06/8f0edf39c0123e1727acc8eda91f443e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"源码0.13.2版的，在sublime中打开的 目录 源码0.13.2版的，在sublime中打开的 9.AppInit2() 9.1 setup 1）关闭警告消息 2）abort() 3)DEP 4）初始化网络 5)文件创建 6）进程终止信号 7）挂起信号处理 8）管道错误处理 9.2parameter interactions 1）-prune 2）确保文件描述符 9.3 parameter-to-internal-flags 1）不支持的内部标志 2）检索 3）交易池限制 4）脚本验证线程 5）区块修剪 6）注册RPC命令 7）节点超时参数 8）最小交易费 默认文件在src文件夹下，ide又增加了一个vs code，跳转到静态常量比较方便。最近在看书《区块链开发指南》，建议参考https://blog.csdn.net/pure_lady/article/details/77982837#t1这个博主，写的清楚多了 在linux中bitcoin数据目录默认路径～/.bitcoin/ 文件 详细描述 bicoin.conf bitcoin配置文件，bitcoid启动的时候会读取这个文件 debug.log 调试信息文件，各种日志写入均存储在该文件中 peers.dat 节点的信息 wallet.dat 钱包文件，保存你的私钥和相关交易记录，非常重要 blocks 区块链（blockchain）的数据存储目录 chainstate 区块链(blockchain)的状态存储目录 testnets 测试链的数据信息 9.AppInit2() 回到bitcoind.cpp继续后面的代码 fRet = AppInit2(threadGroup, scheduler); 那么来查看AppInit2这个函数，这个函数比较复杂，从备注来看分了12步 step 1:setup（安装网络环境，挂接事件处理器等） step 2:parameter interactions（进一步的参数交互设置，如区块裁剪prune和txindex的冲突检查、文件描述符的限制检查等） step 3:parameter-to-internal-flags（参数转换为内部变量，这样外部参数的设置将转换成程序内部的状态） step 4:application initialization :dir lock,daemonize,pidfile,debug log（初始化ECC，目录锁检查，保证只有一个bitcoind运行等） step 5:verify wallet database integrity（若启用钱包功能，则会检查钱包数据库的完整性） step 6:network initialization（网络初始化） step 7:load block chain（加载区块链数据，即blocks目录下的数据） step 8:load wallet（若是启用钱包功能，则加载钱包） step 9:data directory maintenance（若是裁剪模式，则进行blockstore的裁剪） step 10:import blocks（导入数据块） step 11:start node（启动节点服务，监听网络p2p请求，若启用-gen挖矿参数，则调用generatebitcoins启动数个挖矿线程bitcoinminer） step 12:finished(完成) //init.cpp /** Initialize bitcoin. * @pre Parameters should be parsed and config file should be read. */ bool AppInit2(boost::thread_group&amp; threadGroup, CScheduler&amp; scheduler) { 从备注来看AppInit2这个函数的作用是初始化bitcoin,这步之前需要完成参数解析与配置文件的读取。 9.1 setup 1）关闭警告消息 // ********************************************************* Step 1: setup #ifdef _MSC_VER // Turn off Microsoft heap dump noise _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE); _CrtSetReportFile(_CRT_WARN, CreateFileA(&quot;NUL&quot;, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)); #endif 从注释来看这段的功能是关闭微软内存堆的噪声，应该是针对微软的开发环境设置的，其他编译环境中这段不执行。 关于_MSC_VER的解释 _MSC_VER是微软的预编译控制。 _MSC_VER可以分解为：MS：Microsoft的简写;C:MSC就是Microsoft的C编译器;VER：Version的简写。_MSC_VER的意思就是：Microsoft的C编译器的版本。 微软不同时期，编译器有不同的版本： MS VC++10.0 _MSC_VER=1600;MS VC++9.0 _MSC_VER=1500;MS VC++8.0 _MSC_VER=1400 代码中的两个函数_CrtSetReportMode、_CrtSetReportFile在代码中没有找到定义，根据查询到的内容，在这段代码中是设置为报告类型为警告，报告输出方式为文件输出，但是输出文件为空，那么警告消息的输出可以理解为被关闭了。 2）abort() #if _MSC_VER &gt;= 1400 // Disable confusing &quot;helpful&quot; text message on abort, Ctrl-C _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT); #endif 这段是针对vc++8.0以上的处理，解决程序非正常终止时的帮助消息是否打印的问题，详细信息参考函数本身的说明_set_abort_behavior 3)DEP #ifdef WIN32 // Enable Data Execution Prevention (DEP) // Minimum supported OS versions: WinXP SP3, WinVista &gt;= SP1, Win Server 2008 // A failure is non-critical and needs no further attention! #ifndef PROCESS_DEP_ENABLE // We define this here, because GCCs winbase.h limits this to _WIN32_WINNT &gt;= 0x0601 (Windows 7), // which is not correct. Can be removed, when GCCs winbase.h is fixed! #define PROCESS_DEP_ENABLE 0x00000001 #endif typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD); PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;), &quot;SetProcessDEPPolicy&quot;); if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE); #endif 注释：启用数据执行保护（DEP），支持的最低操作系统WinXP SP3, WinVista &gt;= SP1, Win Server 2008；由于GCCs winbase.h将该功能限制在_WIN32_WINNT &gt;= 0x0601 (Windows 7)才能使用，这是不对的，所以有下面的强制宏定义。 代码表示通过函数指针获取Kernel32.dll中的SetProcessDEPPolicy函数对象，实现DEP功能的开启。 4）初始化网络 if (!SetupNetworking()) return InitError(&quot;Initializing networking failed&quot;); 调用函数SetupNetworking //util.cpp bool SetupNetworking() { #ifdef WIN32 // Initialize Windows Sockets WSADATA wsadata; int ret = WSAStartup(MAKEWORD(2,2), &amp;wsadata); if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2) return false; #endif return true; } 根据注释来看是初始化Windows Sockets，初始化工作通过WSAStartup函数实现。 5)文件创建 #ifndef WIN32 if (GetBoolArg(&quot;-sysperms&quot;, false)) { #ifdef ENABLE_WALLET if (!GetBoolArg(&quot;-disablewallet&quot;, false)) return InitError(&quot;-sysperms is not allowed in combination with enabled wallet functionality&quot;); #endif } else { umask(077); } ifndef WIN32是针对非window系统，首先判断参数是否设置了-sysperms,未设置则调用umask(077) -sysperms Create new files with system default permissions, instead of umask 077(only effective with disabled wallet functionality) 创建具有系统默认权限的新文件，而不是UMASK 077（仅对禁用钱包功能有效） 如果钱包未启用，则提示报错信息。umask用于设置文件与文件夹使用权限，077代表—rwxrwx,表示owner没有任何权限，group和other有所有权限。 6）进程终止信号 // Clean shutdown on SIGTERM struct sigaction sa;//信号处理对象 sa.sa_handler = HandleSIGTERM;//进程终止信号处理句柄 sigemptyset(&amp;sa.sa_mask); sa.sa_flags = 0; sigaction(SIGTERM, &amp;sa, NULL);//终止信号处理 sigaction(SIGINT, &amp;sa, NULL);//中断信号处理 句柄函数 //init.cpp std::atomic&lt;bool&gt; fRequestShutdown(false);//在同一文件不同位置 void HandleSIGTERM(int) { fRequestShutdown = true; } 函数非常简单，就是将全局变量fRequestShutdown设置为true std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 7）挂起信号处理 // Reopen debug.log on SIGHUP struct sigaction sa_hup;//信号处理对象 sa_hup.sa_handler = HandleSIGHUP; sigemptyset(&amp;sa_hup.sa_mask); sa_hup.sa_flags = 0; sigaction(SIGHUP, &amp;sa_hup, NULL);//挂起信号处理 和终止信号处理过程基本相同，句柄函数 std::atomic&lt;bool&gt; fReopenDebugLog(false); void HandleSIGHUP(int) { fReopenDebugLog = true; } 将全局变量fReopenDebugLog设置为true,在util.cpp中LogPrintStr重新打开日志文件 // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } 8）管道错误处理 // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly signal(SIGPIPE, SIG_IGN); #endif 忽略SIGPIPE，否则如果客户端关闭，它会导致守护进程下降。 9.2parameter interactions 没有备注就在在init.cpp的 // ********************************************************* Step 2: parameter interactions const CChainParams&amp; chainparams = Params(); CChainParams这个类在6.2有提到，这里就不再详细写了。 //chainparams.cpp const CChainParams &amp;Params() { assert(pCurrentParams); return *pCurrentParams; } 在step3 目录9.3 9)非标准交易 中有使用 1）-prune 这个参数如果设置资源配置不足的bitcoin.conf的配置信息应该还记得，我也有写在比特币源码编译那里，作用是通过删除旧的块，将磁盘空间要求降低到这个兆字节。 // if using block pruning, then disable txindex if (GetArg(&quot;-prune&quot;, 0)) { if (GetBoolArg(&quot;-txindex&quot;, DEFAULT_TXINDEX)) return InitError(_(&quot;Prune mode is incompatible with -txindex.&quot;)); #ifdef ENABLE_WALLET if (GetBoolArg(&quot;-rescan&quot;, false)) { return InitError(_(&quot;Rescans are not possible in pruned mode. You will need to use -reindex which will download the whole blockchain again.&quot;)); } #endif } -prune是和-txindex有冲突的，这个在《精通比特币》这本书里有写 //《精通比特币》 3.2.6配置比特币核心节点 prune 通过删除旧的块，将磁盘空间要求降低到这个兆字节。 在资源受限的节点上不能 满足完整块的节点使用这个。 txindex 维护所有交易的索引。 这意味着可以通过 ID 以编程方式检索任何交易的块链的 完整副本。 由于没有完整的区块链，也就无法使用钱包，无法回溯历史区块。 不过删除旧的块是怎们删除的呢，如果整个块删除那就连不起来了，会中间断开，搜索 在白皮书中有提到 Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block&#39;s hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block&#39;s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 作者的想法是修剪掉最新交易（已确认）之前的交易数据 也就是针对merkle tree来修剪的，有两种修剪对象，一个是所有输出被花费的的叶子节点（交易），另一是节点包含的所有子节点都已被修剪。并且是在0.11版本之后才开始实现这个功能。 根据bitcoin release note中的描述 Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。 在比特币运行的本地环境中，有四种类型的数据（查看～/.bitcoin/目录，测试网查看～/.bitcoin/teseets/blocks/目录） raw block,从网络中接收的原始块信息，对应文件为blk*****.dat undo data,在进行chain reorganization时使用的数据，对应的文件为rev******.dat.chain reorganization是指某一节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行chain reorganization block index,区块索引，每一个区块都有一个唯一的索引，对应文件为/index下的**.ldb就是level db数据库文件。 UTXO,未花费支出，对应文件为../chainstate/下的.ldb文件 2）确保文件描述符 关于linux的文件描述符，可以参考https://blog.csdn.net/cywosp/article/details/38965239 介绍这段代码中用到的几个宏定义 //net.h /** The maximum number of peer connections to maintain. */ static const unsigned int DEFAULT_MAX_PEER_CONNECTIONS = 125; 最大可维护的节点连接书，默认125 //compat.h #define FD_SETSIZE 1024 // max number of fds in fd_set 可包含的最大文件描述符的个数，默认1024 #ifdef WIN32 // Win32 LevelDB doesn&#39;t use filedescriptors, and the ones used for // accessing block files don&#39;t count towards the fd_set size limit // anyway. #define MIN_CORE_FILEDESCRIPTORS 0 #else #define MIN_CORE_FILEDESCRIPTORS 150 #endif 最小核心文件描述符的个数，windows下为0，linux为150 具体代码就不放上来了。返回目录 9.3 parameter-to-internal-flags 内部标志的参数处理 1）不支持的内部标志 -debug/-nodebug:如果-debug=0或者-nodebug被设置，设置fDebug=false,关闭调试信息; //util.cpp bool fDebug = false; -debugnet：不支持的参数，用-debug=net替代; -socks:不支持的参数，目前只支持SOCKS5; -tor:不支持的参数，应使用-onion; onion=&lt;ip:port&gt; Use separate SOCKS5 proxy to reach peers via Tor hidden services -benchmark:不支持的参数，用-debug=bench替代 -whitelistalwaysrelay:不支持的参数，应使用-whitelistrelay或-whitelistforcerelay -blockminsize:不支持的参数 2）检索 检测交易池和区块索引，这两个参数在私有网模式下默认为true // Checkmempool and checkblockindex default to true in regtest mode int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); if (ratio != 0) { mempool.setSanityCheck(1.0 / ratio); } mempool是CTxMemPool类型 //main.cpp CTxMemPool mempool(::minRelayTxFee); CTxMemPool定义在txmempool.h,根据注释来看 CTxMemPool stores valid-according-to-the-current-best-chain * transactions that may be included in the next block. 该类是用来保存在当前最佳链下的有效交易并且这些交易也会被打包到后续的区块中。 Transactions are added when they are seen on the network *(or created by the local node), but not all transactions seen * are added to the pool: if a new transaction double-spends * an input of a transaction in the pool, it is dropped, * as are non-standard transactions. 但不是所有被发现的交易都会被添加到池里：如果一个新交易在池中花费了一个交易的输入（双花），则它被丢弃，非标准事务也是如此。所以CTxMemPool 需要对交易进行完整性检测，检测频率通过setSanityCheck来设置 //txmempool.h uint32_t nCheckFrequency; //!&lt; Value n means that n times in 2^32 we check void setSanityCheck(double dFrequency = 1.0) { nCheckFrequency = dFrequency * 4294967295.0; } 4294967295.0=2^32-1,nCheckFrequency代表池中所有交易的检测频率，即每隔nCheckFrequency个交易检测一次。传入的dFrequency的值是1.0 再返回去看ratio的获取 int ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(GetArg(&quot;-checkmempool&quot;, chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000); CChainParams这个类在6.2选择比特币网络中有提到，要看的是DefaultConsistencyChecks()这个函数返回值 //chainparams.h CChainParams类中 /** Default value for -checkmempool and -checkblockindex argument */ bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; } bool fDefaultConsistencyChecks; CChainParams类是基类，其三个子类中，CMainParams，CTestNetParams这两个类中fDefaultConsistencyChecks=false,CRegTestParams=true。也就是说只有在私有网中才默认需要进行一致性检测。 接下来看区块索引检测 fCheckBlockIndex = GetBoolArg(&quot;-checkblockindex&quot;, chainparams.DefaultConsistencyChecks()); fCheckpointsEnabled = GetBoolArg(&quot;-checkpoints&quot;, DEFAULT_CHECKPOINTS_ENABLED); //main.cpp bool fCheckBlockIndex = false; bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED; //main.h static const bool DEFAULT_CHECKPOINTS_ENABLED = true; 私有网是默认进行区块索引的检测。参数检测点是默认为true,即默认进行检测点检查。关于检测点的作用这里不写了。检测点的具体使用后面应该会有。 3）交易池限制 // mempool limits int64_t nMempoolSizeMax = GetArg(&quot;-maxmempool&quot;, DEFAULT_MAX_MEMPOOL_SIZE) * 1000000; int64_t nMempoolSizeMin = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40; if (nMempoolSizeMax &lt; 0 || nMempoolSizeMax &lt; nMempoolSizeMin) return InitError(strprintf(_(&quot;-maxmempool must be at least %d MB&quot;), std::ceil(nMempoolSizeMin / 1000000.0))); 首先计算最大和最小交易池size,其中的默认值 //policy.h /** Default for -maxmempool, maximum megabytes//(MB) of mempool memory usage */ static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300; //main.h /** Default for -limitdescendantsize, maximum kilobytes//(KB) of in-mempool descendants */ static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101; 默认最大存储容量是300MB,最小存储容量101KB。 4）脚本验证线程 -par=0意味着自动执行，但nScriptCheckThreads=0代表没有并发 // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency nScriptCheckThreads = GetArg(&quot;-par&quot;, DEFAULT_SCRIPTCHECK_THREADS); if (nScriptCheckThreads &lt;= 0) nScriptCheckThreads += GetNumCores(); if (nScriptCheckThreads &lt;= 1) nScriptCheckThreads = 0; else if (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS) nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS; fServer = GetBoolArg(&quot;-server&quot;, false); 在help信息中找到对-par参数的解释 -par=&lt;n&gt; Set the number of script verification threads (-2 to 16, 0 = auto, &lt;0 =leave that many cores free, default: 0) 默认的线程验证为0=auto，&lt;0表示释放内核，下面还定义了最大的脚本验证线程数是16 //main.h /** -par default (number of script-checking threads, 0 = auto) */ static const int DEFAULT_SCRIPTCHECK_THREADS = 0; /** Number of blocks that can be requested at any given time from a single peer. */ static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16; 接下来看对nScriptCheckThreads的逻辑判断:nScriptCheckThreads&lt;0,通过GetNumCores（）函数获取程序运行机器能提供的线程数，然后加上，再判断后面的； //util.cpp int GetNumCores() { #if BOOST_VERSION &gt;= 105600 return boost::thread::physical_concurrency(); #else // Must fall back to hardware_concurrency, which unfortunately counts virtual cores return boost::thread::hardware_concurrency(); #endif } //version.hpp #define BOOST_VERSION 105800 上述代码用到了c++ boost库的boost:thread,对这两个函数不是很理解，去boost库查找 physical_concurrency()返回当前系统上可用的物理内核，与hardware_concurrency()不同，他不返回虚拟内核的数量，只计算物理内核。 5）区块修剪 // block pruning; get the amount of disk space (in MiB) to allot for block &amp; undo files int64_t nSignedPruneTarget = GetArg(&quot;-prune&quot;, 0) * 1024 * 1024; if (nSignedPruneTarget &lt; 0) { return InitError(_(&quot;Prune cannot be configured with a negative value.&quot;)); } -prune这个参数在9.2 1)已经介绍过了，来看代码部分，首先获取数值，单位是MB，判断数值，该参数不能为负数。 nPruneTarget = (uint64_t) nSignedPruneTarget; if (nPruneTarget) { if (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) { return InitError(strprintf(_(&quot;Prune configured below the minimum of %d MiB. Please use a higher number.&quot;), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)); } LogPrintf(&quot;Prune configured to target %uMiB on disk for block and undo files.\\n&quot;, nPruneTarget / 1024 / 1024); fPruneMode = true; } //main.h static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024; 最低的空间要求是550M，这点在帮助信息也有明确的提示 -prune=&lt;n&gt; Reduce storage requirements by pruning (deleting) old blocks. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain.(default: 0 = disable pruning blocks, &gt;550 = target size in MiB to use for block files) 6）注册RPC命令 在代码中就调用了一下 RegisterAllCoreRPCCommands(tableRPC); 在src/rpc/register.h下是对该函数的定义 static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;tableRPC) { /** Register block chain RPC commands */ RegisterBlockchainRPCCommands(tableRPC);//区块链RPC命令注册 /** Register P2P networking RPC commands */ RegisterNetRPCCommands(tableRPC);//P2P网络命令注册 /** Register miscellaneous RPC commands */ RegisterMiscRPCCommands(tableRPC);//其他工具RPC /** Register mining RPC commands */ RegisterMiningRPCCommands(tableRPC);//挖矿RPC命令 /** Register raw transaction RPC commands */ RegisterRawTransactionRPCCommands(tableRPC);//交易RPC } 分别来看这些命令注册实现的具体位置 I 区块链RPC命令，整个cpp文件都是对应命令的具体实现，下面是命令列表，在RegisterBlockchainRPCCommands函数中通过遍历的方式添加命令。 //src/rpc/blockchain.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, true }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, true }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, true }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, true }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, true }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, true }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, true }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, true }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, true }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, true }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, true }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, true }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, true }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, true }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, true }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, true }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, true }, }; void RegisterBlockchainRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } II P2P网络RPC命令，代码结构基本相同的 //src/rpc/net.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, true }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, true }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, true }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, true }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, true }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, true }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, true }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, true }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, true }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, true }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, true }, }; void RegisterNetRPCCommands(CRPCTable &amp;tableRPC) { for (unsigned int vcidx = 0; vcidx &lt; ARRAYLEN(commands); vcidx++) tableRPC.appendCommand(commands[vcidx].name, &amp;commands[vcidx]); } III 其他工具RPC命令 //src/rpc/misc.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;control&quot;, &quot;getinfo&quot;, &amp;getinfo, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;validateaddress&quot;, &amp;validateaddress, true }, /* uses wallet if enabled */ { &quot;util&quot;, &quot;createmultisig&quot;, &amp;createmultisig, true }, { &quot;util&quot;, &quot;verifymessage&quot;, &amp;verifymessage, true }, { &quot;util&quot;, &quot;signmessagewithprivkey&quot;, &amp;signmessagewithprivkey, true }, /* Not shown in help */ { &quot;hidden&quot;, &quot;setmocktime&quot;, &amp;setmocktime, true }, }; IV mining rpc commands //src/rpc/mining.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, true }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, true }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, true }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, true }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, true }, { &quot;generating&quot;, &quot;generate&quot;, &amp;generate, true }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, true }, { &quot;util&quot;, &quot;estimatefee&quot;, &amp;estimatefee, true }, { &quot;util&quot;, &quot;estimatepriority&quot;, &amp;estimatepriority, true }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, true }, { &quot;util&quot;, &quot;estimatesmartpriority&quot;, &amp;estimatesmartpriority, true }, }; V 交易RPC命令 //src/rpc/rawtransaction.cpp static const CRPCCommand commands[] = { // category name actor (function) okSafeMode // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, true }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, true }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, false }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, false }, /* uses wallet if enabled */ { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, true }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, true }, }; 这些命令的注册方式都是相似的，就不再说明了。 后面的代码，如果定义了开启钱包宏(默认开启)，没有关闭钱包，就注册钱包的RPC命令。 #ifdef ENABLE_WALLET bool fDisableWallet = GetBoolArg(&quot;-disablewallet&quot;, false); if (!fDisableWallet) RegisterWalletRPCCommands(tableRPC); #endif //src/config/bitcion-config.h /* Define to 1 to enable wallet functions */ #define ENABLE_WALLET 1 注册方式与前面的相似，在src/wallwet/rpcwallet.cpp 这些rpc命令可以在在bitcoin-cli命令行中使用，bitcoin-cli help可以获取这些帮助信息 7）节点超时参数 比特币网络中新加入的节点都回去寻找节点，加入比特币p2p网络中，与其他节点完成同步操作，不过寻找节点的时间是有限制的，默认值为5000ms,并且不能设置为负数 nConnectTimeout = GetArg(&quot;-timeout&quot;, DEFAULT_CONNECT_TIMEOUT); if (nConnectTimeout &lt;= 0) nConnectTimeout = DEFAULT_CONNECT_TIMEOUT; //netbase.h //! -timeout default static const int DEFAULT_CONNECT_TIMEOUT = 5000; 8）最小交易费 首先来看注释内容，该费率为没千字节所需的最小费率，这个费率值的设置对矿工来说需要谨慎设置：如果你设置为0，那么每个被挖出的块都会被交易的垃圾邮件发送者的1聪交易费的交易填满，最低交易费应高于处理交易所需的成本。 // Fee-per-kilobyte amount considered the same as &quot;free&quot; // If you are mining, be careful setting this: // if you set it to zero then // a transaction spammer can cheaply fill blocks using // 1-satoshi-fee transactions. It should be set above the real // cost to you of processing a transaction. if (mapArgs.count(&quot;-minrelaytxfee&quot;)) { CAmount n = 0; if (ParseMoney(mapArgs[&quot;-minrelaytxfee&quot;], n) &amp;&amp; n &gt; 0) ::minRelayTxFee = CFeeRate(n); else return InitError(AmountErrMsg(&quot;minrelaytxfee&quot;, mapArgs[&quot;-minrelaytxfee&quot;])); } 如果设置了-minrelaytxfee，调用CFeeRate设置费用；若未设置，也是调用该函数，设为默认值，默认最小费率为1000聪 //main.cpp CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE); //main.h /** Default for -minrelaytxfee, minimum relay fee for transactions */ static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000; 接下来看一下minRelayTxFee这个全局变量的使用场所 //main.cpp CTxMemPool mempool(::minRelayTxFee); FeeFilterRounder filterRounder(::minRelayTxFee); 在设置矿池和费用循环过滤中用到。 比特币源码学习0.13（四） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/06/8f0edf39c0123e1727acc8eda91f443e.html","headline":"比特币源码学习0.13（三）","dateModified":"2018-08-06T00:00:00+08:00","datePublished":"2018-08-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/06/8f0edf39c0123e1727acc8eda91f443e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13（三）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h3 id="源码0132版的在sublime中打开的">源码0.13.2版的，在sublime中打开的</h3> 
  <hr> 
  <p><span id="catalog">目录</span></p> 
  <p></p>
  <div class="toc">
   <div class="toc"> 
    <ul> 
     <li>
      <ul> 
       <li>
        <ul> 
         <li><a href="#源码0132版的在sublime中打开的" rel="nofollow">源码0.13.2版的，在sublime中打开的</a>
          <ul> 
           <li><a href="#9appinit2" rel="nofollow">9.AppInit2()</a>
            <ul> 
             <li><a href="#91-setup" rel="nofollow">9.1 setup</a>
              <ul> 
               <li><a href="#1关闭警告消息" rel="nofollow">1）关闭警告消息</a></li> 
               <li><a href="#2abort" rel="nofollow">2）abort()</a></li> 
               <li><a href="#3dep" rel="nofollow">3)DEP</a></li> 
               <li><a href="#4初始化网络" rel="nofollow">4）初始化网络</a></li> 
               <li><a href="#5文件创建" rel="nofollow">5)文件创建</a></li> 
               <li><a href="#6进程终止信号" rel="nofollow">6）进程终止信号</a></li> 
               <li><a href="#7挂起信号处理" rel="nofollow">7）挂起信号处理</a></li> 
               <li><a href="#8管道错误处理" rel="nofollow">8）管道错误处理</a></li> 
              </ul> </li> 
             <li><a href="#92parameter-interactions" rel="nofollow">9.2parameter interactions</a>
              <ul> 
               <li><a href="#1-prune" rel="nofollow">1）-prune</a></li> 
               <li><a href="#2确保文件描述符" rel="nofollow">2）确保文件描述符</a></li> 
              </ul> </li> 
             <li><a href="#93-parameter-to-internal-flags" rel="nofollow">9.3 parameter-to-internal-flags</a>
              <ul> 
               <li><a href="#1不支持的内部标志" rel="nofollow">1）不支持的内部标志</a></li> 
               <li><a href="#2检索" rel="nofollow">2）检索</a></li> 
               <li><a href="#3交易池限制" rel="nofollow">3）交易池限制</a></li> 
               <li><a href="#4脚本验证线程" rel="nofollow">4）脚本验证线程</a></li> 
               <li><a href="#5区块修剪" rel="nofollow">5）区块修剪</a></li> 
               <li><a href="#6注册rpc命令" rel="nofollow">6）注册RPC命令</a></li> 
               <li><a href="#7节点超时参数" rel="nofollow">7）节点超时参数</a></li> 
               <li><a href="#8最小交易费" rel="nofollow">8）最小交易费</a></li> 
              </ul> </li> 
            </ul> </li> 
          </ul> </li> 
        </ul> </li> 
      </ul> </li> 
    </ul> 
   </div> 
  </div> 
  <p></p> 
  <hr> 
  <p>默认文件在src文件夹下，ide又增加了一个vs code，跳转到静态常量比较方便。最近在看书《区块链开发指南》，建议参考<a href="https://blog.csdn.net/pure_lady/article/details/77982837#t1" rel="nofollow">https://blog.csdn.net/pure_lady/article/details/77982837#t1</a>这个博主，写的清楚多了 <br> 在linux中bitcoin数据目录默认路径～/.bitcoin/</p> 
  <table>
   <tbody> 
    <tr>
     <th>文件</th>
     <th>详细描述</th>
    </tr> 
    <tr>
     <td>bicoin.conf</td>
     <td>bitcoin配置文件，bitcoid启动的时候会读取这个文件</td>
    </tr> 
    <tr>
     <td>debug.log</td>
     <td>调试信息文件，各种日志写入均存储在该文件中</td>
    </tr> 
    <tr>
     <td>peers.dat</td>
     <td>节点的信息</td>
    </tr> 
    <tr>
     <td>wallet.dat</td>
     <td>钱包文件，保存你的私钥和相关交易记录，非常重要</td>
    </tr> 
    <tr>
     <td>blocks</td>
     <td>区块链（blockchain）的数据存储目录</td>
    </tr> 
    <tr>
     <td>chainstate</td>
     <td>区块链(blockchain)的状态存储目录</td>
    </tr> 
    <tr>
     <td>testnets</td>
     <td>测试链的数据信息</td>
    </tr> 
   </tbody>
  </table> 
  <h4 id="9appinit2">9.AppInit2()</h4> 
  <p>回到<font color="#008B8B">bitcoind.cpp</font>继续后面的代码</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">fRet </span>=<span class="hljs-string"> AppInit2(threadGroup, scheduler);</span></code></pre> 
  <p>那么来查看<font color="#008B8B">AppInit2</font>这个函数，这个函数比较复杂，从备注来看分了12步 <br> step 1:setup（安装网络环境，挂接事件处理器等） <br> step 2:parameter interactions（进一步的参数交互设置，如区块裁剪prune和txindex的冲突检查、文件描述符的限制检查等） <br> step 3:parameter-to-internal-flags（参数转换为内部变量，这样外部参数的设置将转换成程序内部的状态） <br> step 4:application initialization :dir lock,daemonize,pidfile,debug log（初始化ECC，目录锁检查，保证只有一个bitcoind运行等） <br> step 5:verify wallet database integrity（若启用钱包功能，则会检查钱包数据库的完整性） <br> step 6:network initialization（网络初始化） <br> step 7:load block chain（加载区块链数据，即blocks目录下的数据） <br> step 8:load wallet（若是启用钱包功能，则加载钱包） <br> step 9:data directory maintenance（若是裁剪模式，则进行blockstore的裁剪） <br> step 10:import blocks（导入数据块） <br> step 11:start node（启动节点服务，监听网络p2p请求，若启用-gen挖矿参数，则调用generatebitcoins启动数个挖矿线程bitcoinminer） <br> step 12:finished(完成)</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//init.cpp</span>
<span class="hljs-javadoc">/** Initialize bitcoin. * <span class="hljs-javadoctag"> @pre</span> Parameters should be parsed and config file should be read. */</span>
bool AppInit2(boost::thread_group&amp; threadGroup, CScheduler&amp; scheduler)
{</code></pre> 
  <p>从备注来看<font color="#008B8B">AppInit2</font>这个函数的作用是初始化<font color="#008B8B">bitcoin</font>,这步之前需要完成参数解析与配置文件的读取。</p> 
  <hr> 
  <h5 id="91-setup">9.1 setup</h5> 
  <h6 id="1关闭警告消息">1）关闭警告消息</h6> 
  <pre class="prettyprint"><code class=" hljs markdown">// <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>** Step 1: setup
<span class="hljs-header">#ifdef _MSC_VER</span>
<span class="hljs-code"> // Turn off Microsoft heap dump noise</span>
<span class="hljs-code"> _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);</span>
<span class="hljs-code"> _CrtSetReportFile(_CRT_WARN, CreateFileA("NUL", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));</span>
<span class="hljs-header">#endif</span></code></pre> 
  <p>从注释来看这段的功能是关闭微软内存堆的噪声，应该是针对微软的开发环境设置的，其他编译环境中这段不执行。 <br> 关于<font color="#008B8B">_MSC_VER</font>的解释 <br> <font color="#4682B4">_MSC_VER是微软的预编译控制。 <br> _MSC_VER可以分解为：MS：Microsoft的简写;C:MSC就是Microsoft的C编译器;VER：Version的简写。_MSC_VER的意思就是：Microsoft的C编译器的版本。 <br> 微软不同时期，编译器有不同的版本： <br> MS VC++10.0 _MSC_VER=1600;MS VC++9.0 _MSC_VER=1500;MS VC++8.0 _MSC_VER=1400</font> <br> 代码中的两个函数<a href="https://technet.microsoft.com/zh-cn/library/1y71x448.aspx/" rel="nofollow">_CrtSetReportMode</a>、<a href="https://msdn.microsoft.com/en-us/library/a68f826y.aspx" rel="nofollow">_CrtSetReportFile</a>在代码中没有找到定义，根据查询到的内容，在这段代码中是设置为报告类型为警告，报告输出方式为文件输出，但是输出文件为空，那么警告消息的输出可以理解为被关闭了。</p> 
  <h6 id="2abort">2）abort()</h6> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> _MSC_VER &gt;= 1400</span>
    <span class="hljs-comment">// Disable confusing "helpful" text message on abort, Ctrl-C</span>
    _set_abort_behavior(<span class="hljs-number">0</span>, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span></code></pre> 
  <p>这段是针对vc++8.0以上的处理，解决程序非正常终止时的帮助消息是否打印的问题，详细信息参考函数本身的说明<a href="https://msdn.microsoft.com/en-us/e631wekh" rel="nofollow">_set_abort_behavior</a></p> 
  <h6 id="3dep">3)DEP</h6> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifdef WIN32</span>
    <span class="hljs-comment">// Enable Data Execution Prevention (DEP)</span>
    <span class="hljs-comment">// Minimum supported OS versions: WinXP SP3, WinVista &gt;= SP1, Win Server 2008</span>
    <span class="hljs-comment">// A failure is non-critical and needs no further attention!</span>
<span class="hljs-preprocessor">#ifndef PROCESS_DEP_ENABLE</span>
    <span class="hljs-comment">// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT &gt;= 0x0601 (Windows 7),</span>
    <span class="hljs-comment">// which is not correct. Can be removed, when GCCs winbase.h is fixed!</span>
<span class="hljs-preprocessor">#define PROCESS_DEP_ENABLE 0x00000001</span>
<span class="hljs-preprocessor">#endif</span>
    typedef<span class="hljs-constant"> BOOL </span>(WINAPI *PSETPROCDEPPOL)(DWORD);
   <span class="hljs-constant"> PSETPROCDEPPOL </span>setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(<span class="hljs-string">"Kernel32.dll"</span>), <span class="hljs-string">"SetProcessDEPPolicy"</span>);
    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);
<span class="hljs-preprocessor">#endif</span></code></pre> 
  <p>注释：启用数据执行保护（DEP），支持的最低操作系统WinXP SP3, WinVista &gt;= SP1, Win Server 2008；由于GCCs winbase.h将该功能限制在_WIN32_WINNT &gt;= 0x0601 (Windows 7)才能使用，这是不对的，所以有下面的强制宏定义。 <br> 代码表示通过函数指针获取<font color="#008B8B">Kernel32.dll</font>中的<font color="#008B8B">SetProcessDEPPolicy</font>函数对象，实现DEP功能的开启。</p> 
  <h6 id="4初始化网络">4）初始化网络</h6> 
  <pre class="prettyprint"><code class=" hljs bash"> <span class="hljs-keyword">if</span> (!SetupNetworking())
        <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"Initializing networking failed"</span>);</code></pre> 
  <p>调用函数<font color="#008B8B">SetupNetworking</font></p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//util.cpp</span>
<span class="hljs-keyword">bool</span> SetupNetworking()
{
<span class="hljs-preprocessor">#ifdef WIN32</span>
    <span class="hljs-comment">// Initialize Windows Sockets</span>
    WSADATA wsadata;
    <span class="hljs-keyword">int</span> ret = WSAStartup(MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), &amp;wsadata);
    <span class="hljs-keyword">if</span> (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != <span class="hljs-number">2</span> || HIBYTE(wsadata.wVersion) != <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>根据注释来看是初始化Windows Sockets，初始化工作通过<a href="https://blog.csdn.net/clemontine/article/details/53141041" rel="nofollow">WSAStartup</a>函数实现。</p> 
  <h6 id="5文件创建">5)文件创建</h6> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#ifndef WIN32</span>
    <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-sysperms"</span>, <span class="hljs-keyword">false</span>)) {
<span class="hljs-preprocessor">#ifdef ENABLE_WALLET</span>
        <span class="hljs-keyword">if</span> (!GetBoolArg(<span class="hljs-string">"-disablewallet"</span>, <span class="hljs-keyword">false</span>))
            <span class="hljs-keyword">return</span> InitError(<span class="hljs-string">"-sysperms is not allowed in combination with enabled wallet functionality"</span>);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    } <span class="hljs-keyword">else</span> {
        umask(<span class="hljs-number">077</span>);
    }</code></pre> 
  <p>ifndef WIN32是针对非window系统，首先判断参数是否设置了<font color="#008B8B">-sysperms</font>,未设置则调用<font color="#008B8B">umask(077)</font></p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">-sysperms
Create <span class="hljs-built_in">new</span> <span class="hljs-built_in">files</span> <span class="hljs-operator">with</span> <span class="hljs-keyword">system</span> default permissions, instead <span class="hljs-operator">of</span> umask <span class="hljs-number">077</span>(only <span class="hljs-keyword">effective</span> <span class="hljs-operator">with</span> disabled wallet functionality)
 创建具有系统默认权限的新文件，而不是UMASK <span class="hljs-number">077</span>（仅对禁用钱包功能有效）</code></pre> 
  <p>如果钱包未启用，则提示报错信息。umask用于设置文件与文件夹使用权限，077代表—rwxrwx,表示owner没有任何权限，group和other有所有权限。</p> 
  <h6 id="6进程终止信号">6）进程终止信号</h6> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">// Clean shutdown on SIGTERM</span>
    <span class="hljs-keyword">struct</span> sigaction sa;<span class="hljs-comment">//信号处理对象</span>
    sa<span class="hljs-variable">.sa_handler</span> = HandleSIGTERM;<span class="hljs-comment">//进程终止信号处理句柄</span>
    sigemptyset(&amp;sa<span class="hljs-variable">.sa_mask</span>);
    sa<span class="hljs-variable">.sa_flags</span> = <span class="hljs-number">0</span>;
    sigaction(SIGTERM, &amp;sa, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//终止信号处理</span>
    sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//中断信号处理</span></code></pre> 
  <p>句柄函数</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//init.cpp</span>
<span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-keyword">bool</span>&gt; fRequestShutdown(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//在同一文件不同位置</span>
<span class="hljs-keyword">void</span> HandleSIGTERM(<span class="hljs-keyword">int</span>)
{
    fRequestShutdown = <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>函数非常简单，就是将全局变量fRequestShutdown设置为true <br> <font color="#4682B4">std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。</font></p> 
  <h6 id="7挂起信号处理">7）挂起信号处理</h6> 
  <pre class="prettyprint"><code class=" hljs autohotkey">// Reopen debug.log on SIGHUP
    struct sigaction s<span class="hljs-built_in">a_hup</span><span class="hljs-comment">;//信号处理对象</span>
    s<span class="hljs-built_in">a_hup</span>.s<span class="hljs-built_in">a_handler</span> = HandleSIGHUP<span class="hljs-comment">;</span>
    sigemptyset(&amp;s<span class="hljs-built_in">a_hup</span>.s<span class="hljs-built_in">a_mask</span>)<span class="hljs-comment">;</span>
    s<span class="hljs-built_in">a_hup</span>.s<span class="hljs-built_in">a_flags</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    sigaction(SIGHUP, &amp;s<span class="hljs-built_in">a_hup</span>, NULL)<span class="hljs-comment">;//挂起信号处理</span></code></pre> 
  <p>和终止信号处理过程基本相同，句柄函数</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">std:</span><span class="hljs-symbol">:atomic&lt;bool&gt;</span> fReopenDebugLog(<span class="hljs-keyword">false</span>);
void <span class="hljs-constant">HandleSIGHUP</span>(int)
{
    fReopenDebugLog = <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>将全局变量fReopenDebugLog设置为true,在util.cpp中LogPrintStr重新打开日志文件</p> 
  <pre class="prettyprint"><code class=" hljs lasso"> <span class="hljs-comment">// reopen the log file, if requested</span>
            <span class="hljs-keyword">if</span> (fReopenDebugLog) {
                fReopenDebugLog <span class="hljs-subst">=</span> <span class="hljs-literal">false</span>;
                boost<span class="hljs-tag">::filesystem</span><span class="hljs-tag">::path</span> pathDebug <span class="hljs-subst">=</span> GetDataDir() <span class="hljs-subst">/</span> <span class="hljs-string">"debug.log"</span>;
                <span class="hljs-keyword">if</span> (freopen(pathDebug<span class="hljs-built_in">.</span><span class="hljs-built_in">string</span>()<span class="hljs-built_in">.</span>c_str(),<span class="hljs-string">"a"</span>,fileout) <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
                    setbuf(fileout, <span class="hljs-built_in">NULL</span>); <span class="hljs-comment">// unbuffered</span>
            }</code></pre> 
  <h6 id="8管道错误处理">8）管道错误处理</h6> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-comment">// Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly</span>
    <span class="hljs-keyword">signal</span>(SIGPIPE, SIG_IGN);
<span class="hljs-preprocessor">#endif</span></code></pre> 
  <p>忽略SIGPIPE，否则如果客户端关闭，它会导致守护进程下降。</p> 
  <hr> 
  <h5 id="92parameter-interactions">9.2parameter interactions</h5> 
  <p>没有备注就在在init.cpp的</p> 
  <pre class="prettyprint"><code class=" hljs markdown">// <span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>** Step 2: parameter interactions
<span class="hljs-code"> const CChainParams&amp; chainparams = Params();</span></code></pre> 
  <p>CChainParams这个类在6.2有提到，这里就不再详细写了。</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">//chainparams.cpp</span>
<span class="hljs-keyword">const</span> CChainParams &amp;Params() {
    <span class="hljs-keyword">assert</span>(pCurrentParams);
    <span class="hljs-keyword">return</span> *pCurrentParams;
}</code></pre> 
  <p>在step3 目录9.3 9)非标准交易 中有使用 </p> 
  <h6 id="1-prune"><span id="prune">1）-prune</span></h6> 
  <p>这个参数如果设置资源配置不足的bitcoin.conf的配置信息应该还记得，我也有写在比特币源码编译那里，作用是通过删除旧的块，将磁盘空间要求降低到这个兆字节。</p> 
  <pre class="prettyprint"><code class=" hljs bash">// <span class="hljs-keyword">if</span> using block pruning, <span class="hljs-keyword">then</span> disable txindex
    <span class="hljs-keyword">if</span> (GetArg(<span class="hljs-string">"-prune"</span>, <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-txindex"</span>, DEFAULT_TXINDEX))
            <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Prune mode is incompatible with -txindex."</span>));
<span class="hljs-comment">#ifdef ENABLE_WALLET</span>
        <span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-rescan"</span>, <span class="hljs-literal">false</span>)) {
            <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Rescans are not possible in pruned mode. You will need to use -reindex which will download the whole blockchain again."</span>));
        }
<span class="hljs-comment">#endif</span>
    }</code></pre> 
  <p>-prune是和-txindex有冲突的，这个在《精通比特币》这本书里有写</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//《精通比特币》 3.2.6配置比特币核心节点</span>
prune
通过删除旧的块，将磁盘空间要求降低到这个兆字节。 在资源受限的节点上不能 满足完整块的节点使用这个。
txindex
维护所有交易的索引。 这意味着可以通过 ID 以编程方式检索任何交易的块链的
完整副本。</code></pre> 
  <p>由于没有完整的区块链，也就无法使用钱包，无法回溯历史区块。 <br> 不过删除旧的块是怎们删除的呢，如果整个块删除那就连不起来了，会中间断开，搜索 <br> 在白皮书中有提到</p> 
  <pre class="prettyprint"><code class=" hljs applescript">Once <span class="hljs-keyword">the</span> latest <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">in</span> a coin <span class="hljs-keyword">is</span> buried under enough blocks, <span class="hljs-keyword">the</span> spent transactions <span class="hljs-keyword">before</span> <span class="hljs-keyword">it</span> can be discarded <span class="hljs-keyword">to</span> save disk <span class="hljs-constant">space</span>. 
To facilitate this <span class="hljs-keyword">without</span> breaking <span class="hljs-keyword">the</span> block's hash, transactions are hashed <span class="hljs-keyword">in</span> a Merkle Tree [<span class="hljs-number">7</span>][<span class="hljs-number">2</span>][<span class="hljs-number">5</span>], <span class="hljs-keyword">with</span> only <span class="hljs-keyword">the</span> root included <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> block's hash.
 Old blocks can <span class="hljs-keyword">then</span> be compacted <span class="hljs-keyword">by</span> stubbing off branches <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> tree. The interior hashes do <span class="hljs-keyword">not</span> need <span class="hljs-keyword">to</span> be stored.</code></pre> 
  <p>作者的想法是修剪掉最新交易（已确认）之前的交易数据 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180802104923569?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 也就是针对merkle tree来修剪的，有两种修剪对象，一个是所有输出被花费的的叶子节点（交易），另一是节点包含的所有子节点都已被修剪。并且是在0.11版本之后才开始实现这个功能。 <br> 根据<a href="https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#block-file-pruning" rel="nofollow">bitcoin release note</a>中的描述</p> 
  <blockquote> 
   <p>Block pruning allows Bitcoin Core to delete the raw block and undo data once it’s been validated and used to build the databases. At that point, the raw data is used only to relay blocks to other nodes, to handle reorganizations, to look up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or for rescanning the wallet. The block index continues to hold the metadata about all blocks in the blockchain. <br> 区块修剪允许bitcoin core删除raw block和undo data，一旦这些数据已经被验证和更新过数据库。这时候的raw data只能用来转发区块到其他节点、处理区块重组、查看过去的交易（如果启用了-txindex交易索引或者通过RPC/REST接口调用）以及重新扫描钱包。区块索引依然维护所有区块的元数据。</p> 
  </blockquote> 
  <p>在比特币运行的本地环境中，有四种类型的数据（查看～/.bitcoin/目录，测试网查看～/.bitcoin/teseets/blocks/目录） <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180814144151245?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> <code>raw block</code>,从网络中接收的原始块信息，对应文件为blk*****.dat <br> <code>undo data</code>,在进行chain reorganization时使用的数据，对应的文件为rev******.dat.chain reorganization是指某一节点发现存在一条比节点当前本地维护的链更长的链，那么该节点就需要进行chain reorganization <br> <code>block index</code>,区块索引，每一个区块都有一个唯一的索引，对应文件为/index下的<strong>**</strong>.ldb就是level db数据库文件。 <br> <code>UTXO</code>,未花费支出，对应文件为../chainstate/下的.ldb文件</p> 
  <h6 id="2确保文件描述符">2）确保文件描述符</h6> 
  <p>关于linux的文件描述符，可以参考<a href="https://blog.csdn.net/cywosp/article/details/38965239" rel="nofollow">https://blog.csdn.net/cywosp/article/details/38965239</a> <br> 介绍这段代码中用到的几个宏定义</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//net.h</span>
<span class="hljs-javadoc">/** The maximum number of peer connections to maintain. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_MAX_PEER_CONNECTIONS = <span class="hljs-number">125</span>;</code></pre> 
  <p>最大可维护的节点连接书，默认125</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//compat.h</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FD_SETSIZE 1024 // max number of fds in fd_set</span></code></pre> 
  <p>可包含的最大文件描述符的个数，默认1024</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifdef WIN32</span>
<span class="hljs-comment">// Win32 LevelDB doesn't use filedescriptors, and the ones used for</span>
<span class="hljs-comment">// accessing block files don't count towards the fd_set size limit</span>
<span class="hljs-comment">// anyway.</span>
<span class="hljs-preprocessor">#define MIN_CORE_FILEDESCRIPTORS 0</span>
<span class="hljs-preprocessor">#else</span>
<span class="hljs-preprocessor">#define MIN_CORE_FILEDESCRIPTORS 150</span>
<span class="hljs-preprocessor">#endif</span></code></pre> 
  <p>最小核心文件描述符的个数，windows下为0，linux为150 <br> 具体代码就不放上来了。<a href="#catalog" rel="nofollow">返回目录</a></p> 
  <hr> 
  <h5 id="93-parameter-to-internal-flags">9.3 parameter-to-internal-flags</h5> 
  <p>内部标志的参数处理</p> 
  <h6 id="1不支持的内部标志">1）不支持的内部标志</h6> 
  <p>-debug/-nodebug:如果-debug=0或者-nodebug被设置，设置fDebug=false,关闭调试信息;</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//util.cpp</span>
<span class="hljs-keyword">bool</span> fDebug = <span class="hljs-keyword">false</span>;</code></pre> 
  <p>-debugnet：不支持的参数，用-debug=net替代; <br> -socks:不支持的参数，目前只支持SOCKS5; <br> -tor:不支持的参数，应使用-onion;</p> 
  <pre class="prettyprint"><code class=" hljs vhdl">onion=&lt;ip:<span class="hljs-keyword">port</span>&gt; <span class="hljs-keyword">Use</span> separate SOCKS5 proxy <span class="hljs-keyword">to</span> reach peers via Tor hidden services </code></pre> 
  <p>-benchmark:不支持的参数，用-debug=bench替代 <br> -whitelistalwaysrelay:不支持的参数，应使用-whitelistrelay或-whitelistforcerelay <br> -blockminsize:不支持的参数</p> 
  <h6 id="2检索">2）检索</h6> 
  <p>检测交易池和区块索引，这两个参数在私有网模式下默认为true</p> 
  <pre class="prettyprint"><code class=" hljs mel"><span class="hljs-comment">// Checkmempool and checkblockindex default to true in regtest mode</span>
    <span class="hljs-keyword">int</span> ratio = std::<span class="hljs-keyword">min</span>&lt;<span class="hljs-keyword">int</span>&gt;(std::<span class="hljs-keyword">max</span>&lt;<span class="hljs-keyword">int</span>&gt;(GetArg(<span class="hljs-string">"-checkmempool"</span>, chainparams.DefaultConsistencyChecks() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">0</span>), <span class="hljs-number">1000000</span>);
    <span class="hljs-keyword">if</span> (ratio != <span class="hljs-number">0</span>) {
        mempool.setSanityCheck(<span class="hljs-number">1.0</span> / ratio);
    }</code></pre> 
  <p>mempool是CTxMemPool类型</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//main.cpp</span>
CTxMemPool <span class="hljs-function">mempool(::minRelayTxFee)</span>;</code></pre> 
  <p>CTxMemPool定义在txmempool.h,根据注释来看</p> 
  <pre class="prettyprint"><code class=" hljs lasso">CTxMemPool stores valid<span class="hljs-attribute">-according</span><span class="hljs-attribute">-to</span><span class="hljs-attribute">-the</span><span class="hljs-attribute">-current</span><span class="hljs-attribute">-best</span><span class="hljs-attribute">-chain</span>
 <span class="hljs-subst">*</span> transactions that may be included <span class="hljs-keyword">in</span> the next block<span class="hljs-built_in">.</span></code></pre> 
  <p>该类是用来保存在当前最佳链下的有效交易并且这些交易也会被打包到后续的区块中。</p> 
  <pre class="prettyprint"><code class=" hljs applescript">Transactions are added when they are seen <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword">the</span> network
 *(<span class="hljs-keyword">or</span> created <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">local</span> node), <span class="hljs-keyword">but</span> <span class="hljs-keyword">not</span> all transactions seen
 * are added <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> pool: <span class="hljs-keyword">if</span> a new <span class="hljs-keyword">transaction</span> double-spends
 * an input <span class="hljs-keyword">of</span> a <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> pool, <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> dropped,
 * <span class="hljs-keyword">as</span> are non-standard transactions.</code></pre> 
  <p>但不是所有被发现的交易都会被添加到池里：如果一个新交易在池中花费了一个交易的输入（双花），则它被丢弃，非标准事务也是如此。所以CTxMemPool 需要对交易进行完整性检测，检测频率通过setSanityCheck来设置</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//txmempool.h</span>
 uint32_t nCheckFrequency; <span class="hljs-comment">//!&lt; Value n means that n times in 2^32 we check</span>
 <span class="hljs-keyword">void</span> setSanityCheck(<span class="hljs-keyword">double</span> dFrequency = <span class="hljs-number">1.0</span>) { nCheckFrequency = dFrequency * <span class="hljs-number">4294967295.0</span>; }</code></pre> 
  <p>4294967295.0=2^32-1,nCheckFrequency代表池中所有交易的检测频率，即每隔nCheckFrequency个交易检测一次。传入的dFrequency的值是1.0 <br> 再返回去看ratio的获取</p> 
  <pre class="prettyprint"><code class=" hljs ruby">int ratio = <span class="hljs-symbol">std:</span><span class="hljs-symbol">:min&lt;int&gt;</span>(<span class="hljs-symbol">std:</span><span class="hljs-symbol">:max&lt;int&gt;</span>(<span class="hljs-constant">GetArg</span>(<span class="hljs-string">"-checkmempool"</span>, chainparams.<span class="hljs-constant">DefaultConsistencyChecks</span>() ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>), <span class="hljs-number">0</span>), <span class="hljs-number">1000000</span>);</code></pre> 
  <p>CChainParams这个类在6.2选择比特币网络中有提到，要看的是DefaultConsistencyChecks()这个函数返回值</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//chainparams.h CChainParams类中</span>
    <span class="hljs-javadoc">/** Default value for -checkmempool and -checkblockindex argument */</span>
    bool DefaultConsistencyChecks() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> fDefaultConsistencyChecks; }
    bool fDefaultConsistencyChecks;</code></pre> 
  <p>CChainParams类是基类，其三个子类中，CMainParams，CTestNetParams这两个类中fDefaultConsistencyChecks=false,CRegTestParams=true。也就是说只有在私有网中才默认需要进行一致性检测。 <br> 接下来看区块索引检测</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">fCheckBlockIndex = GetBoolArg(<span class="hljs-string">"-checkblockindex"</span>, chainparams<span class="hljs-preprocessor">.DefaultConsistencyChecks</span>())<span class="hljs-comment">;</span>
    fCheckpointsEnabled = GetBoolArg(<span class="hljs-string">"-checkpoints"</span>, DEFAULT_CHECKPOINTS_ENABLED)<span class="hljs-comment">;</span></code></pre> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//main.cpp</span>
<span class="hljs-keyword">bool</span> fCheckBlockIndex = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">bool</span> fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED;
<span class="hljs-comment">//main.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_CHECKPOINTS_ENABLED = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>私有网是默认进行区块索引的检测。参数检测点是默认为true,即默认进行检测点检查。关于<a href="https://bitcoin.stackexchange.com/questions/1797/what-are-checkpoints" rel="nofollow">检测点</a>的作用这里不写了。检测点的具体使用后面应该会有。</p> 
  <h6 id="3交易池限制">3）交易池限制</h6> 
  <pre class="prettyprint"><code class=" hljs bash">// mempool limits
    int64_t nMempoolSizeMax = GetArg(<span class="hljs-string">"-maxmempool"</span>, DEFAULT_MAX_MEMPOOL_SIZE) * <span class="hljs-number">1000000</span>;
    int64_t nMempoolSizeM<span class="hljs-keyword">in</span> = GetArg(<span class="hljs-string">"-limitdescendantsize"</span>, DEFAULT_DESCENDANT_SIZE_LIMIT) * <span class="hljs-number">1000</span> * <span class="hljs-number">40</span>;
    <span class="hljs-keyword">if</span> (nMempoolSizeMax &lt; <span class="hljs-number">0</span> || nMempoolSizeMax &lt; nMempoolSizeM<span class="hljs-keyword">in</span>)
        <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"-maxmempool must be at least %d MB"</span>), std::ceil(nMempoolSizeM<span class="hljs-keyword">in</span> / <span class="hljs-number">1000000.0</span>)));
</code></pre> 
  <p>首先计算最大和最小交易池size,其中的默认值</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//policy.h</span>
<span class="hljs-javadoc">/** Default for -maxmempool, maximum megabytes//(MB) of mempool memory usage */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_MAX_MEMPOOL_SIZE = <span class="hljs-number">300</span>;
<span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** Default for -limitdescendantsize, maximum kilobytes//(KB) of in-mempool descendants */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_DESCENDANT_SIZE_LIMIT = <span class="hljs-number">101</span>;</code></pre> 
  <p>默认最大存储容量是300MB,最小存储容量101KB。</p> 
  <h6 id="4脚本验证线程">4）脚本验证线程</h6> 
  <p>-par=0意味着自动执行，但nScriptCheckThreads=0代表没有并发</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency</span>
    nScriptCheckThreads = GetArg(<span class="hljs-string">"-par"</span>, DEFAULT_SCRIPTCHECK_THREADS);
    <span class="hljs-keyword">if</span> (nScriptCheckThreads &lt;= <span class="hljs-number">0</span>)
        nScriptCheckThreads += GetNumCores();
    <span class="hljs-keyword">if</span> (nScriptCheckThreads &lt;= <span class="hljs-number">1</span>)
        nScriptCheckThreads = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nScriptCheckThreads &gt; MAX_SCRIPTCHECK_THREADS)
        nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;
    fServer = GetBoolArg(<span class="hljs-string">"-server"</span>, <span class="hljs-keyword">false</span>);</code></pre> 
  <p>在help信息中找到对-par参数的解释</p> 
  <pre class="prettyprint"><code class=" hljs applescript">-par=&lt;n&gt;
       Set <span class="hljs-keyword">the</span> <span class="hljs-type">number</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">script</span> verification threads (-<span class="hljs-number">2</span> <span class="hljs-keyword">to</span> <span class="hljs-number">16</span>, <span class="hljs-number">0</span> = auto, &lt;<span class="hljs-number">0</span> =leave <span class="hljs-keyword">that</span> many cores free, default: <span class="hljs-number">0</span>)</code></pre> 
  <p>默认的线程验证为0=auto，&lt;0表示释放内核，下面还定义了最大的脚本验证线程数是16</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** -par default (number of script-checking threads, 0 = auto) */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> DEFAULT_SCRIPTCHECK_THREADS = <span class="hljs-number">0</span>;
<span class="hljs-javadoc">/** Number of blocks that can be requested at any given time from a single peer. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_BLOCKS_IN_TRANSIT_PER_PEER = <span class="hljs-number">16</span>;</code></pre> 
  <p>接下来看对nScriptCheckThreads的逻辑判断:nScriptCheckThreads&lt;0,通过GetNumCores（）函数获取程序运行机器能提供的线程数，然后加上，再判断后面的；</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//util.cpp</span>
<span class="hljs-keyword">int</span> GetNumCores()
{
<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> BOOST_VERSION &gt;= 105600</span>
    <span class="hljs-keyword">return</span> boost::thread::physical_concurrency();
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span> // Must fall back to hardware_concurrency, which unfortunately counts virtual cores</span>
    <span class="hljs-keyword">return</span> boost::thread::hardware_concurrency();
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
}
<span class="hljs-comment">//version.hpp</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BOOST_VERSION 105800</span></code></pre> 
  <p>上述代码用到了c++ boost库的boost:thread,对这两个函数不是很理解，去boost库查找 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180803134812578?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> physical_concurrency()返回当前系统上可用的物理内核，与hardware_concurrency()不同，他不返回虚拟内核的数量，只计算物理内核。</p> 
  <h6 id="5区块修剪">5）区块修剪</h6> 
  <pre class="prettyprint"><code class=" hljs coffeescript"> <span class="hljs-regexp">//</span> block pruning; get the amount <span class="hljs-keyword">of</span> disk space (<span class="hljs-keyword">in</span> MiB) to allot <span class="hljs-keyword">for</span> block &amp; undo files
    int64_t nSignedPruneTarget = GetArg(<span class="hljs-string">"-prune"</span>, <span class="hljs-number">0</span>) * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
    <span class="hljs-keyword">if</span> (nSignedPruneTarget &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> InitError(_(<span class="hljs-string">"Prune cannot be configured with a negative value."</span>));
    }</code></pre> 
  <p>-prune这个参数在<a href="#prune" rel="nofollow">9.2 1)</a>已经介绍过了，来看代码部分，首先获取数值，单位是MB，判断数值，该参数不能为负数。</p> 
  <pre class="prettyprint"><code class=" hljs cs">nPruneTarget = (uint64_t) nSignedPruneTarget;
    <span class="hljs-keyword">if</span> (nPruneTarget) {
        <span class="hljs-keyword">if</span> (nPruneTarget &lt; MIN_DISK_SPACE_FOR_BLOCK_FILES) {
            <span class="hljs-keyword">return</span> InitError(strprintf(_(<span class="hljs-string">"Prune configured below the minimum of %d MiB. Please use a higher number."</span>), MIN_DISK_SPACE_FOR_BLOCK_FILES / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>));
        }
        LogPrintf(<span class="hljs-string">"Prune configured to target %uMiB on disk for block and undo files.\n"</span>, nPruneTarget / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);
        fPruneMode = <span class="hljs-keyword">true</span>;
    }
<span class="hljs-comment">//main.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = <span class="hljs-number">550</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;</code></pre> 
  <p>最低的空间要求是550M，这点在帮助信息也有明确的提示</p> 
  <pre class="prettyprint"><code class=" hljs oxygene">  -prune=&lt;n&gt;
       Reduce storage requirements <span class="hljs-keyword">by</span> pruning (deleting) <span class="hljs-keyword">old</span> blocks. This mode <span class="hljs-keyword">is</span> incompatible <span class="hljs-keyword">with</span> -txindex <span class="hljs-keyword">and</span> -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain.(<span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> = disable pruning blocks, &gt;<span class="hljs-number">550</span> = target size <span class="hljs-keyword">in</span> MiB <span class="hljs-keyword">to</span> use <span class="hljs-keyword">for</span> <span class="hljs-keyword">block</span> files)</code></pre> 
  <h6 id="6注册rpc命令">6）注册RPC命令</h6> 
  <p>在代码中就调用了一下</p> 
  <pre class="prettyprint"><code class=" hljs scss"> <span class="hljs-function">RegisterAllCoreRPCCommands(tableRPC)</span>;</code></pre> 
  <p>在src/rpc/register.h下是对该函数的定义</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> RegisterAllCoreRPCCommands(CRPCTable &amp;tableRPC)
{
    <span class="hljs-javadoc">/** Register block chain RPC commands */</span>
    RegisterBlockchainRPCCommands(tableRPC);<span class="hljs-comment">//区块链RPC命令注册</span>
    <span class="hljs-javadoc">/** Register P2P networking RPC commands */</span>
    RegisterNetRPCCommands(tableRPC);<span class="hljs-comment">//P2P网络命令注册</span>
    <span class="hljs-javadoc">/** Register miscellaneous RPC commands */</span>
    RegisterMiscRPCCommands(tableRPC);<span class="hljs-comment">//其他工具RPC</span>
    <span class="hljs-javadoc">/** Register mining RPC commands */</span>
    RegisterMiningRPCCommands(tableRPC);<span class="hljs-comment">//挖矿RPC命令</span>
    <span class="hljs-javadoc">/** Register raw transaction RPC commands */</span>
    RegisterRawTransactionRPCCommands(tableRPC);<span class="hljs-comment">//交易RPC</span>
}</code></pre> 
  <p>分别来看这些命令注册实现的具体位置 <br> I 区块链RPC命令，整个cpp文件都是对应命令的具体实现，下面是命令列表，在RegisterBlockchainRPCCommands函数中通过遍历的方式添加命令。</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//src/rpc/blockchain.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CRPCCommand commands[] =
{ <span class="hljs-comment">// category name actor (function) okSafeMode</span>
  <span class="hljs-comment">// --------------------- ------------------------ ----------------------- ----------</span>
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getblockchaininfo"</span>,      &amp;getblockchaininfo,      <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getbestblockhash"</span>,       &amp;getbestblockhash,       <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getblockcount"</span>,          &amp;getblockcount,          <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getblock"</span>,               &amp;getblock,               <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getblockhash"</span>,           &amp;getblockhash,           <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getblockheader"</span>,         &amp;getblockheader,         <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getchaintips"</span>,           &amp;getchaintips,           <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getdifficulty"</span>,          &amp;getdifficulty,          <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getmempoolancestors"</span>,    &amp;getmempoolancestors,    <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getmempooldescendants"</span>,  &amp;getmempooldescendants,  <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getmempoolentry"</span>,        &amp;getmempoolentry,        <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getmempoolinfo"</span>,         &amp;getmempoolinfo,         <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"getrawmempool"</span>,          &amp;getrawmempool,          <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"gettxout"</span>,               &amp;gettxout,               <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"gettxoutsetinfo"</span>,        &amp;gettxoutsetinfo,        <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"verifychain"</span>,            &amp;verifychain,            <span class="hljs-literal">true</span>  },

    <span class="hljs-comment">/* Not shown in help */</span>
    { <span class="hljs-string">"hidden"</span>,             <span class="hljs-string">"invalidateblock"</span>,        &amp;invalidateblock,        <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"hidden"</span>,             <span class="hljs-string">"reconsiderblock"</span>,        &amp;reconsiderblock,        <span class="hljs-literal">true</span>  },
};

<span class="hljs-keyword">void</span> RegisterBlockchainRPCCommands(CRPCTable &amp;tableRPC)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> vcidx = <span class="hljs-number">0</span>; vcidx &lt; ARRAYLEN(commands); vcidx++)
        tableRPC<span class="hljs-variable">.appendCommand</span>(commands[vcidx]<span class="hljs-variable">.name</span>, &amp;commands[vcidx]);
}</code></pre> 
  <p>II P2P网络RPC命令，代码结构基本相同的</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//src/rpc/net.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CRPCCommand commands[] =
{ <span class="hljs-comment">// category name actor (function) okSafeMode</span>
  <span class="hljs-comment">// --------------------- ------------------------ ----------------------- ----------</span>
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"getconnectioncount"</span>,     &amp;getconnectioncount,     <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"ping"</span>,                   &amp;ping,                   <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"getpeerinfo"</span>,            &amp;getpeerinfo,            <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"addnode"</span>,                &amp;addnode,                <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"disconnectnode"</span>,         &amp;disconnectnode,         <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"getaddednodeinfo"</span>,       &amp;getaddednodeinfo,       <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"getnettotals"</span>,           &amp;getnettotals,           <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"getnetworkinfo"</span>,         &amp;getnetworkinfo,         <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"setban"</span>,                 &amp;setban,                 <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"listbanned"</span>,             &amp;listbanned,             <span class="hljs-literal">true</span>  },
    { <span class="hljs-string">"network"</span>,            <span class="hljs-string">"clearbanned"</span>,            &amp;clearbanned,            <span class="hljs-literal">true</span>  },
};

<span class="hljs-keyword">void</span> RegisterNetRPCCommands(CRPCTable &amp;tableRPC)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> vcidx = <span class="hljs-number">0</span>; vcidx &lt; ARRAYLEN(commands); vcidx++)
        tableRPC<span class="hljs-variable">.appendCommand</span>(commands[vcidx]<span class="hljs-variable">.name</span>, &amp;commands[vcidx]);
}</code></pre> 
  <p>III 其他工具RPC命令</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//src/rpc/misc.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CRPCCommand commands[] =
{ <span class="hljs-comment">// category name actor (function) okSafeMode</span>
  <span class="hljs-comment">// --------------------- ------------------------ ----------------------- ----------</span>
    { <span class="hljs-string">"control"</span>,            <span class="hljs-string">"getinfo"</span>,                &amp;getinfo,                <span class="hljs-keyword">true</span>  }, <span class="hljs-comment">/* uses wallet if enabled */</span>
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"validateaddress"</span>,        &amp;validateaddress,        <span class="hljs-keyword">true</span>  }, <span class="hljs-comment">/* uses wallet if enabled */</span>
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"createmultisig"</span>,         &amp;createmultisig,         <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"verifymessage"</span>,          &amp;verifymessage,          <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"signmessagewithprivkey"</span>, &amp;signmessagewithprivkey, <span class="hljs-keyword">true</span>  },

    <span class="hljs-comment">/* Not shown in help */</span>
    { <span class="hljs-string">"hidden"</span>,             <span class="hljs-string">"setmocktime"</span>,            &amp;setmocktime,            <span class="hljs-keyword">true</span>  },
};</code></pre> 
  <p>IV mining rpc commands</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//src/rpc/mining.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CRPCCommand commands[] =
{ <span class="hljs-comment">// category name actor (function) okSafeMode</span>
  <span class="hljs-comment">// --------------------- ------------------------ ----------------------- ----------</span>
    { <span class="hljs-string">"mining"</span>,             <span class="hljs-string">"getnetworkhashps"</span>,       &amp;getnetworkhashps,       <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"mining"</span>,             <span class="hljs-string">"getmininginfo"</span>,          &amp;getmininginfo,          <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"mining"</span>,             <span class="hljs-string">"prioritisetransaction"</span>,  &amp;prioritisetransaction,  <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"mining"</span>,             <span class="hljs-string">"getblocktemplate"</span>,       &amp;getblocktemplate,       <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"mining"</span>,             <span class="hljs-string">"submitblock"</span>,            &amp;submitblock,            <span class="hljs-keyword">true</span>  },

    { <span class="hljs-string">"generating"</span>,         <span class="hljs-string">"generate"</span>,               &amp;generate,               <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"generating"</span>,         <span class="hljs-string">"generatetoaddress"</span>,      &amp;generatetoaddress,      <span class="hljs-keyword">true</span>  },

    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"estimatefee"</span>,            &amp;estimatefee,            <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"estimatepriority"</span>,       &amp;estimatepriority,       <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"estimatesmartfee"</span>,       &amp;estimatesmartfee,       <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"util"</span>,               <span class="hljs-string">"estimatesmartpriority"</span>,  &amp;estimatesmartpriority,  <span class="hljs-keyword">true</span>  },
};</code></pre> 
  <p>V 交易RPC命令</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//src/rpc/rawtransaction.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> CRPCCommand commands[] =
{ <span class="hljs-comment">// category name actor (function) okSafeMode</span>
  <span class="hljs-comment">// --------------------- ------------------------ ----------------------- ----------</span>
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"getrawtransaction"</span>,      &amp;getrawtransaction,      <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"createrawtransaction"</span>,   &amp;createrawtransaction,   <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"decoderawtransaction"</span>,   &amp;decoderawtransaction,   <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"decodescript"</span>,           &amp;decodescript,           <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"sendrawtransaction"</span>,     &amp;sendrawtransaction,     <span class="hljs-keyword">false</span> },
    { <span class="hljs-string">"rawtransactions"</span>,    <span class="hljs-string">"signrawtransaction"</span>,     &amp;signrawtransaction,     <span class="hljs-keyword">false</span> }, <span class="hljs-comment">/* uses wallet if enabled */</span>

    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"gettxoutproof"</span>,          &amp;gettxoutproof,          <span class="hljs-keyword">true</span>  },
    { <span class="hljs-string">"blockchain"</span>,         <span class="hljs-string">"verifytxoutproof"</span>,       &amp;verifytxoutproof,       <span class="hljs-keyword">true</span>  },
};</code></pre> 
  <p>这些命令的注册方式都是相似的，就不再说明了。 <br> 后面的代码，如果定义了开启钱包宏(默认开启)，没有关闭钱包，就注册钱包的RPC命令。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#ifdef ENABLE_WALLET</span>
    <span class="hljs-keyword">bool</span> fDisableWallet = GetBoolArg(<span class="hljs-string">"-disablewallet"</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">if</span> (!fDisableWallet)
        RegisterWalletRPCCommands(tableRPC);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-comment">//src/config/bitcion-config.h</span>
<span class="hljs-comment">/* Define to 1 to enable wallet functions */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ENABLE_WALLET 1</span></code></pre> 
  <p>注册方式与前面的相似，在src/wallwet/rpcwallet.cpp <br> 这些rpc命令可以在在bitcoin-cli命令行中使用，bitcoin-cli help可以获取这些帮助信息</p> 
  <h6 id="7节点超时参数">7）节点超时参数</h6> 
  <p>比特币网络中新加入的节点都回去寻找节点，加入比特币p2p网络中，与其他节点完成同步操作，不过寻找节点的时间是有限制的，默认值为5000ms,并且不能设置为负数</p> 
  <pre class="prettyprint"><code class=" hljs cs">nConnectTimeout = GetArg(<span class="hljs-string">"-timeout"</span>, DEFAULT_CONNECT_TIMEOUT);
    <span class="hljs-keyword">if</span> (nConnectTimeout &lt;= <span class="hljs-number">0</span>)
        nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
<span class="hljs-comment">//netbase.h</span>
<span class="hljs-comment">//! -timeout default</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> DEFAULT_CONNECT_TIMEOUT = <span class="hljs-number">5000</span>;</code></pre> 
  <h6 id="8最小交易费">8）最小交易费</h6> 
  <p>首先来看注释内容，该费率为没千字节所需的最小费率，这个费率值的设置对矿工来说需要谨慎设置：如果你设置为0，那么每个被挖出的块都会被交易的垃圾邮件发送者的1聪交易费的交易填满，最低交易费应高于处理交易所需的成本。</p> 
  <pre class="prettyprint"><code class=" hljs axapta">    <span class="hljs-comment">// Fee-per-kilobyte amount considered the same as "free"</span>
    <span class="hljs-comment">// If you are mining, be careful setting this:</span>
    <span class="hljs-comment">// if you set it to zero then</span>
    <span class="hljs-comment">// a transaction spammer can cheaply fill blocks using</span>
    <span class="hljs-comment">// 1-satoshi-fee transactions. It should be set above the real</span>
    <span class="hljs-comment">// cost to you of processing a transaction.</span>
    <span class="hljs-keyword">if</span> (mapArgs.<span class="hljs-keyword">count</span>(<span class="hljs-string">"-minrelaytxfee"</span>))
    {
        CAmount n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (ParseMoney(mapArgs[<span class="hljs-string">"-minrelaytxfee"</span>], n) &amp;&amp; n &gt; <span class="hljs-number">0</span>)
            ::minRelayTxFee = CFeeRate(n);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> InitError(AmountErrMsg(<span class="hljs-string">"minrelaytxfee"</span>, mapArgs[<span class="hljs-string">"-minrelaytxfee"</span>]));
    }</code></pre> 
  <p>如果设置了-minrelaytxfee，调用CFeeRate设置费用；若未设置，也是调用该函数，设为默认值，默认最小费率为1000聪</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.cpp</span>
CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);
<span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** Default for -minrelaytxfee, minimum relay fee for transactions */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">int</span> DEFAULT_MIN_RELAY_TX_FEE = <span class="hljs-number">1000</span>;</code></pre> 
  <p>接下来看一下minRelayTxFee这个全局变量的使用场所</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//main.cpp</span>
CTxMemPool <span class="hljs-function">mempool(::minRelayTxFee)</span>;
FeeFilterRounder <span class="hljs-function">filterRounder(::minRelayTxFee)</span>;</code></pre> 
  <p>在设置矿池和费用循环过滤中用到。</p> 
  <hr> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81450432" rel="nofollow">比特币源码学习0.13（四）</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81326806,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81326806,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
