<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS数字资产合约实战（四）eosio.token.cpp的创建资产，发行资产，交易资产 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS数字资产合约实战（四）eosio.token.cpp的创建资产，发行资产，交易资产" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="eosio.token.cpp部分代码的解析（eosi.token.hpp实现）创建资产，发行资产，交易资产的三个函数 #include &lt;eosio.token/eosio.token.hpp&gt; namespace eosio{ &nbsp; &nbsp; &nbsp; &nbsp; //创建资产种类和属性 &nbsp; &nbsp; &nbsp; &nbsp; //issuer &nbsp; 发币人 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //maximum_supply 发币的最大量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_freeze &nbsp;发币人是否冻结 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_recall 发币人是否可以召回 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_whitelist 发币人是否可以设置白名单， 有的币是发给特定的人，有的人不能接受这种代币（资产） &nbsp; &nbsp; &nbsp; &nbsp;void token::create(account_name issuer, asset maxium_supply, uint8_t issuer_can_freeze, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t issuer_can_recall, uint8_t issuer_can_whitelist){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(_self); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//必须有智能合约主人的授权。（智能合约的主人就是这个智能合约账户本身） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto sym = maximum_supply.sumbol; &nbsp; //设置这种资产的符号。（BTC,EOS） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(sym.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.is_valid(),&quot;invalid supply&quot;); &nbsp; //这种资产的最大量不符合要求 ，报错信息：invalid supply &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.amount&gt;0,&quot;maximum_supply must be posivive&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个多索引列表，这个列表的类型是资产资料类型（currency_stats） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats &nbsp; statstable(_self， sym.name()); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建这个多索引列表以后，我们就可以和数据库通讯了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先查询这个资产的名字是否存在，是否被占用了 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto existing = statstable.find(sym.name()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(existing==statstable.end(),&quot;token symble already existing&quot;); //如果这个迭代器 existing不等于列表的end， 说明已经存在，那么就报错信息token symble already existing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//如果等于的话，说明该资产名不存在，我们接下加入进来。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statstable.emplace(_self,[&amp;](auto &amp; s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.supply.symble = maximum_supply.symbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.max_supply = maximum_supply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.issuer = issuer; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_freeze = issuer_can_freeze; &nbsp; //c++ 整型转到布尔型， 自动强制转换，非0为真。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_recall = issuer_can_recall; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_whitelist = issuer_can_whitelist; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//发布资产数量（增发） &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;发给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 发多少 &nbsp; &nbsp; &nbsp; &nbsp;//mem &nbsp; 发行的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::issue(account_name to, asset quantity, string memo) //从函数表面看是直接发到to账户，在底层，还是发给创建者账户，然后再给to 账户加上资产 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(&quot;issue&quot;); //先print一下，告诉系统，开始发资产了。 cleos eos 命令行程序 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto sym = quantity.symbol.name(); &nbsp;//先定义一个变量储存资产的名字 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个资产资料列表 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats stastable(_self, sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const auto &nbsp; st =stastable.get(sym); //在多索引列表中找该资产。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //增发资产的时候，有没有发币人issuer的授权 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(st.issuer); &nbsp;//只能由创建者来发币，不能别人发币（资产）。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(st.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must issue posivive quantity&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity&lt;=st.max_supply-st.supply，&quot;quantity exceeds availbe supply&quot;);//还能发行的资产要小于等于最大可以发行的资产减去已经发行的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stastable.modify(st,0,[&amp;](auto &amp;s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.supply += quantity; &nbsp;//增发的资产数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//调用add_balance()函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;给谁加 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//quantity 增发的数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st &nbsp; &nbsp;增加的资产状态 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st.issuer &nbsp;支付RAM的人（发币人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//这样处理不是很好 &nbsp; &nbsp;add_balance(to, quantity,st, st.issuer); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //add_balance以上的操作 有点问题，EOS官方不是这样实现的，这样实现的，会给某人（to）无声无息的在列表中给这个人增加了资产，但不会通知到被增发的账户的。 除非被增发的账户不断的去查询。 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //发行资产如何通知到被增发的账户呢？先不直接给需要被增发的账户to 增发，而是先给发起资产发行人增发。然后让资产发行人再转给需要被增发的账户（to ）。调用SEND_INLINE_ACTION()这个宏。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance（st.issuer, quantity,st,st.ssuer）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(to!=issuer)//不是给issuer自己增发 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SEND_INLINE_ACTION(*this，transfer，{st.issuer，N(active)}，{st.issuer,to,quanity, memo});//特别注意：如果给issuer自己增发资产，这句代码就不用了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //SEND_INLINE_ACTION在一个ACTION中再嵌套一个ACTION（条用了transfer）,这样就可以通知到被增发的账户to 知道自己被增发了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //*this &nbsp; &nbsp;就是本智能合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //transfer &nbsp; 就是要发起的ACTION函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //需要的st.issuer的active 权限 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//就是传入transfer 的函数 参数说明，1是发行人转出 &nbsp;2 转给谁， 3 转的数量 &nbsp; 4 交易备注。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//交易资产（转账） &nbsp; &nbsp; &nbsp; &nbsp;//from &nbsp;谁转出来 &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp; &nbsp; &nbsp; 转给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 数量 &nbsp; &nbsp; &nbsp; &nbsp;//memo &nbsp;转账的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::transfer(account_name from , account_name to, asset quantity, string memo) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&quot;transfer&quot;); //打印一个信息，表示要转账了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(from ); &nbsp;//检查发行人的授权。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto &nbsp;sym &nbsp;=quanity.symbol.name(); //把资产名字取出来 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stats stastable(_self, sym); &nbsp; //系统和数据库交互的一个工具,得到该智能合约的拥有者名下的这个资产的数据表。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//_self &nbsp; 这个资产的拥有者（发行人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const auto &amp; st = statstable.get(sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//收据 ，就是把资产从from转到to后，需要得到收据。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(from ); //得到from 收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(to); &nbsp;//得到to收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quanity.is_valid(),&quot;invalid quantity&quot;); &nbsp;//如果是无效的，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must transfer posivive quantity&quot;); //如果不大于0，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//实现交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub_balance(from,quantity,st); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance(to,quantity,st,from); &nbsp; &nbsp; &nbsp; &nbsp;} ｝ //三个公有函数（三个action）暴露给系统。 EOSIO_ABI(eosio::token,(create)(issue)(transfer)) 阅读更多" />
<meta property="og:description" content="eosio.token.cpp部分代码的解析（eosi.token.hpp实现）创建资产，发行资产，交易资产的三个函数 #include &lt;eosio.token/eosio.token.hpp&gt; namespace eosio{ &nbsp; &nbsp; &nbsp; &nbsp; //创建资产种类和属性 &nbsp; &nbsp; &nbsp; &nbsp; //issuer &nbsp; 发币人 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //maximum_supply 发币的最大量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_freeze &nbsp;发币人是否冻结 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_recall 发币人是否可以召回 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_whitelist 发币人是否可以设置白名单， 有的币是发给特定的人，有的人不能接受这种代币（资产） &nbsp; &nbsp; &nbsp; &nbsp;void token::create(account_name issuer, asset maxium_supply, uint8_t issuer_can_freeze, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t issuer_can_recall, uint8_t issuer_can_whitelist){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(_self); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//必须有智能合约主人的授权。（智能合约的主人就是这个智能合约账户本身） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto sym = maximum_supply.sumbol; &nbsp; //设置这种资产的符号。（BTC,EOS） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(sym.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.is_valid(),&quot;invalid supply&quot;); &nbsp; //这种资产的最大量不符合要求 ，报错信息：invalid supply &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.amount&gt;0,&quot;maximum_supply must be posivive&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个多索引列表，这个列表的类型是资产资料类型（currency_stats） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats &nbsp; statstable(_self， sym.name()); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建这个多索引列表以后，我们就可以和数据库通讯了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先查询这个资产的名字是否存在，是否被占用了 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto existing = statstable.find(sym.name()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(existing==statstable.end(),&quot;token symble already existing&quot;); //如果这个迭代器 existing不等于列表的end， 说明已经存在，那么就报错信息token symble already existing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//如果等于的话，说明该资产名不存在，我们接下加入进来。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statstable.emplace(_self,[&amp;](auto &amp; s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.supply.symble = maximum_supply.symbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.max_supply = maximum_supply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.issuer = issuer; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_freeze = issuer_can_freeze; &nbsp; //c++ 整型转到布尔型， 自动强制转换，非0为真。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_recall = issuer_can_recall; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_whitelist = issuer_can_whitelist; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//发布资产数量（增发） &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;发给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 发多少 &nbsp; &nbsp; &nbsp; &nbsp;//mem &nbsp; 发行的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::issue(account_name to, asset quantity, string memo) //从函数表面看是直接发到to账户，在底层，还是发给创建者账户，然后再给to 账户加上资产 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(&quot;issue&quot;); //先print一下，告诉系统，开始发资产了。 cleos eos 命令行程序 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto sym = quantity.symbol.name(); &nbsp;//先定义一个变量储存资产的名字 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个资产资料列表 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats stastable(_self, sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const auto &nbsp; st =stastable.get(sym); //在多索引列表中找该资产。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //增发资产的时候，有没有发币人issuer的授权 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(st.issuer); &nbsp;//只能由创建者来发币，不能别人发币（资产）。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(st.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must issue posivive quantity&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity&lt;=st.max_supply-st.supply，&quot;quantity exceeds availbe supply&quot;);//还能发行的资产要小于等于最大可以发行的资产减去已经发行的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stastable.modify(st,0,[&amp;](auto &amp;s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.supply += quantity; &nbsp;//增发的资产数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//调用add_balance()函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;给谁加 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//quantity 增发的数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st &nbsp; &nbsp;增加的资产状态 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st.issuer &nbsp;支付RAM的人（发币人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//这样处理不是很好 &nbsp; &nbsp;add_balance(to, quantity,st, st.issuer); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //add_balance以上的操作 有点问题，EOS官方不是这样实现的，这样实现的，会给某人（to）无声无息的在列表中给这个人增加了资产，但不会通知到被增发的账户的。 除非被增发的账户不断的去查询。 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //发行资产如何通知到被增发的账户呢？先不直接给需要被增发的账户to 增发，而是先给发起资产发行人增发。然后让资产发行人再转给需要被增发的账户（to ）。调用SEND_INLINE_ACTION()这个宏。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance（st.issuer, quantity,st,st.ssuer）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(to!=issuer)//不是给issuer自己增发 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SEND_INLINE_ACTION(*this，transfer，{st.issuer，N(active)}，{st.issuer,to,quanity, memo});//特别注意：如果给issuer自己增发资产，这句代码就不用了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //SEND_INLINE_ACTION在一个ACTION中再嵌套一个ACTION（条用了transfer）,这样就可以通知到被增发的账户to 知道自己被增发了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //*this &nbsp; &nbsp;就是本智能合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //transfer &nbsp; 就是要发起的ACTION函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //需要的st.issuer的active 权限 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//就是传入transfer 的函数 参数说明，1是发行人转出 &nbsp;2 转给谁， 3 转的数量 &nbsp; 4 交易备注。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//交易资产（转账） &nbsp; &nbsp; &nbsp; &nbsp;//from &nbsp;谁转出来 &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp; &nbsp; &nbsp; 转给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 数量 &nbsp; &nbsp; &nbsp; &nbsp;//memo &nbsp;转账的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::transfer(account_name from , account_name to, asset quantity, string memo) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&quot;transfer&quot;); //打印一个信息，表示要转账了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(from ); &nbsp;//检查发行人的授权。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto &nbsp;sym &nbsp;=quanity.symbol.name(); //把资产名字取出来 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stats stastable(_self, sym); &nbsp; //系统和数据库交互的一个工具,得到该智能合约的拥有者名下的这个资产的数据表。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//_self &nbsp; 这个资产的拥有者（发行人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const auto &amp; st = statstable.get(sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//收据 ，就是把资产从from转到to后，需要得到收据。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(from ); //得到from 收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(to); &nbsp;//得到to收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quanity.is_valid(),&quot;invalid quantity&quot;); &nbsp;//如果是无效的，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must transfer posivive quantity&quot;); //如果不大于0，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//实现交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub_balance(from,quantity,st); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance(to,quantity,st,from); &nbsp; &nbsp; &nbsp; &nbsp;} ｝ //三个公有函数（三个action）暴露给系统。 EOSIO_ABI(eosio::token,(create)(issue)(transfer)) 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/24/d43cf4c9005b563213852399e695bd25.html" />
<meta property="og:url" content="https://mlh.app/2018/08/24/d43cf4c9005b563213852399e695bd25.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"eosio.token.cpp部分代码的解析（eosi.token.hpp实现）创建资产，发行资产，交易资产的三个函数 #include &lt;eosio.token/eosio.token.hpp&gt; namespace eosio{ &nbsp; &nbsp; &nbsp; &nbsp; //创建资产种类和属性 &nbsp; &nbsp; &nbsp; &nbsp; //issuer &nbsp; 发币人 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //maximum_supply 发币的最大量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_freeze &nbsp;发币人是否冻结 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_recall 发币人是否可以召回 &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_whitelist 发币人是否可以设置白名单， 有的币是发给特定的人，有的人不能接受这种代币（资产） &nbsp; &nbsp; &nbsp; &nbsp;void token::create(account_name issuer, asset maxium_supply, uint8_t issuer_can_freeze, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t issuer_can_recall, uint8_t issuer_can_whitelist){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(_self); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//必须有智能合约主人的授权。（智能合约的主人就是这个智能合约账户本身） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto sym = maximum_supply.sumbol; &nbsp; //设置这种资产的符号。（BTC,EOS） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(sym.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.is_valid(),&quot;invalid supply&quot;); &nbsp; //这种资产的最大量不符合要求 ，报错信息：invalid supply &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.amount&gt;0,&quot;maximum_supply must be posivive&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个多索引列表，这个列表的类型是资产资料类型（currency_stats） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats &nbsp; statstable(_self， sym.name()); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建这个多索引列表以后，我们就可以和数据库通讯了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先查询这个资产的名字是否存在，是否被占用了 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto existing = statstable.find(sym.name()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(existing==statstable.end(),&quot;token symble already existing&quot;); //如果这个迭代器 existing不等于列表的end， 说明已经存在，那么就报错信息token symble already existing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//如果等于的话，说明该资产名不存在，我们接下加入进来。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statstable.emplace(_self,[&amp;](auto &amp; s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.supply.symble = maximum_supply.symbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.max_supply = maximum_supply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.issuer = issuer; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_freeze = issuer_can_freeze; &nbsp; //c++ 整型转到布尔型， 自动强制转换，非0为真。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_recall = issuer_can_recall; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_whitelist = issuer_can_whitelist; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//发布资产数量（增发） &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;发给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 发多少 &nbsp; &nbsp; &nbsp; &nbsp;//mem &nbsp; 发行的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::issue(account_name to, asset quantity, string memo) //从函数表面看是直接发到to账户，在底层，还是发给创建者账户，然后再给to 账户加上资产 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(&quot;issue&quot;); //先print一下，告诉系统，开始发资产了。 cleos eos 命令行程序 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto sym = quantity.symbol.name(); &nbsp;//先定义一个变量储存资产的名字 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //新建一个资产资料列表 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats stastable(_self, sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const auto &nbsp; st =stastable.get(sym); //在多索引列表中找该资产。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //增发资产的时候，有没有发币人issuer的授权 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(st.issuer); &nbsp;//只能由创建者来发币，不能别人发币（资产）。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(st.is_valid(),&quot; invalid name&quot;); &nbsp;//这种资产符号是不是合法的,如果不符合，报错信息: invalid name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must issue posivive quantity&quot;);//这种资产最大的发行量必须必须大于0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity&lt;=st.max_supply-st.supply，&quot;quantity exceeds availbe supply&quot;);//还能发行的资产要小于等于最大可以发行的资产减去已经发行的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stastable.modify(st,0,[&amp;](auto &amp;s){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.supply += quantity; &nbsp;//增发的资产数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//调用add_balance()函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;给谁加 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//quantity 增发的数量 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st &nbsp; &nbsp;增加的资产状态 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st.issuer &nbsp;支付RAM的人（发币人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//这样处理不是很好 &nbsp; &nbsp;add_balance(to, quantity,st, st.issuer); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //add_balance以上的操作 有点问题，EOS官方不是这样实现的，这样实现的，会给某人（to）无声无息的在列表中给这个人增加了资产，但不会通知到被增发的账户的。 除非被增发的账户不断的去查询。 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //发行资产如何通知到被增发的账户呢？先不直接给需要被增发的账户to 增发，而是先给发起资产发行人增发。然后让资产发行人再转给需要被增发的账户（to ）。调用SEND_INLINE_ACTION()这个宏。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance（st.issuer, quantity,st,st.ssuer）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(to!=issuer)//不是给issuer自己增发 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SEND_INLINE_ACTION(*this，transfer，{st.issuer，N(active)}，{st.issuer,to,quanity, memo});//特别注意：如果给issuer自己增发资产，这句代码就不用了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //SEND_INLINE_ACTION在一个ACTION中再嵌套一个ACTION（条用了transfer）,这样就可以通知到被增发的账户to 知道自己被增发了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //*this &nbsp; &nbsp;就是本智能合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //transfer &nbsp; 就是要发起的ACTION函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //需要的st.issuer的active 权限 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//就是传入transfer 的函数 参数说明，1是发行人转出 &nbsp;2 转给谁， 3 转的数量 &nbsp; 4 交易备注。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//交易资产（转账） &nbsp; &nbsp; &nbsp; &nbsp;//from &nbsp;谁转出来 &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp; &nbsp; &nbsp; 转给谁 &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 数量 &nbsp; &nbsp; &nbsp; &nbsp;//memo &nbsp;转账的时候的备注 &nbsp; &nbsp; &nbsp; &nbsp;void token::transfer(account_name from , account_name to, asset quantity, string memo) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(&quot;transfer&quot;); //打印一个信息，表示要转账了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(from ); &nbsp;//检查发行人的授权。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto &nbsp;sym &nbsp;=quanity.symbol.name(); //把资产名字取出来 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stats stastable(_self, sym); &nbsp; //系统和数据库交互的一个工具,得到该智能合约的拥有者名下的这个资产的数据表。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//_self &nbsp; 这个资产的拥有者（发行人） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const auto &amp; st = statstable.get(sym); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//收据 ，就是把资产从from转到to后，需要得到收据。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(from ); //得到from 收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(to); &nbsp;//得到to收据 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quanity.is_valid(),&quot;invalid quantity&quot;); &nbsp;//如果是无效的，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,&quot;must transfer posivive quantity&quot;); //如果不大于0，报错信息 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//实现交易 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub_balance(from,quantity,st); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance(to,quantity,st,from); &nbsp; &nbsp; &nbsp; &nbsp;} ｝ //三个公有函数（三个action）暴露给系统。 EOSIO_ABI(eosio::token,(create)(issue)(transfer)) 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/24/d43cf4c9005b563213852399e695bd25.html","headline":"EOS数字资产合约实战（四）eosio.token.cpp的创建资产，发行资产，交易资产","dateModified":"2018-08-24T00:00:00+08:00","datePublished":"2018-08-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/24/d43cf4c9005b563213852399e695bd25.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS数字资产合约实战（四）eosio.token.cpp的创建资产，发行资产，交易资产</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>eosio.token.cpp部分代码的解析（eosi.token.hpp实现）创建资产，发行资产，交易资产的三个函数</strong></p> 
  <p>#include &lt;eosio.token/eosio.token.hpp&gt;</p> 
  <p>namespace eosio{</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;<strong> //创建资产种类和属性<br> &nbsp; &nbsp; &nbsp; &nbsp; //issuer &nbsp; 发币人 &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //maximum_supply 发币的最大量 &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_freeze &nbsp;发币人是否冻结<br> &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_recall 发币人是否可以召回<br> &nbsp; &nbsp; &nbsp; &nbsp; //issuer_can_whitelist 发币人是否可以设置白名单， 有的币是发给特定的人，有的人不能接受这种代币（资产）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp;void token::create(account_name issuer, asset maxium_supply, uint8_t issuer_can_freeze,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t issuer_can_recall, uint8_t issuer_can_whitelist){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(_self); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>//必须有智能合约主人的授权。（智能合约的主人就是这个智能合约账户本身）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto sym = maximum_supply.sumbol; &nbsp; <strong>//设置这种资产的符号。（BTC,EOS）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(sym.is_valid()," invalid name"); &nbsp;<strong>//这种资产符号是不是合法的,如果不符合，报错信息: invalid name</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.is_valid(),"invalid supply"); &nbsp;<strong> //这种资产的最大量不符合要求 ，报错信息：invalid supply</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(maximum_supply.amount&gt;0,"maximum_supply must be posivive");<strong>//这种资产最大的发行量必须必须大于0</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>//新建一个多索引列表，这个列表的类型是资产资料类型（currency_stats）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats &nbsp; statstable(_self， sym.name()); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>//新建这个多索引列表以后，我们就可以和数据库通讯了。<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 首先查询这个资产的名字是否存在，是否被占用了</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto existing = statstable.find(sym.name());<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eosio_assert(existing==statstable.end(),"token symble already existing"); /<strong>/如果这个迭代器 existing不等于列表的end， 说明已经存在，那么就报错信息token symble already existing</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>//如果等于的话，说明该资产名不存在，我们接下加入进来。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statstable.emplace(_self,[&amp;](auto &amp; s){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.supply.symble = maximum_supply.symbol;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.max_supply = maximum_supply;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.issuer = issuer;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_freeze = issuer_can_freeze; &nbsp; <strong>//c++ 整型转到布尔型， 自动强制转换，非0为真。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_recall = issuer_can_recall;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.can_whitelist = issuer_can_whitelist; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; <strong>&nbsp;//发布资产数量（增发）<br> &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;发给谁<br> &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 发多少<br> &nbsp; &nbsp; &nbsp; &nbsp;//mem &nbsp; 发行的时候的备注</strong><br> &nbsp; &nbsp; &nbsp; &nbsp;void token::issue(account_name to, asset quantity, string memo)<strong> //从函数表面看是直接发到to账户，在底层，还是发给创建者账户，然后再给to 账户加上资产</strong><br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("issue"); <strong>//先print一下，告诉系统，开始发资产了。 cleos eos 命令行程序</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto sym = quantity.symbol.name(); &nbsp;<strong>//先定义一个变量储存资产的名字</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>//新建一个资产资料列表</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats stastable(_self, sym);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const auto &nbsp; st =stastable.get(sym); <strong>//在多索引列表中找该资产。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong> //增发资产的时候，有没有发币人issuer的授权</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(st.issuer); &nbsp;<strong>//只能由创建者来发币，不能别人发币（资产）。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(st.is_valid()," invalid name"); &nbsp;<strong>//这种资产符号是不是合法的,如果不符合，报错信息: invalid name</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,"must issue posivive quantity");<strong>//这种资产最大的发行量必须必须大于0</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity&lt;=st.max_supply-st.supply，"quantity exceeds availbe supply");<strong>//还能发行的资产要小于等于最大可以发行的资产减去已经发行的</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stastable.modify(st,0,[&amp;](auto &amp;s){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.supply += quantity; &nbsp;<strong>//增发的资产数量</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp;//调用add_balance()函数<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp;给谁加<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//quantity 增发的数量<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st &nbsp; &nbsp;增加的资产状态<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//st.issuer &nbsp;支付RAM的人（发币人）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>//这样处理不是很好 &nbsp; &nbsp;add_balance(to, quantity,st, st.issuer); &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //add_balance以上的操作 有点问题，EOS官方不是这样实现的，这样实现的，会给某人（to）无声无息的在列表中给这个人增加了资产，但不会通知到被增发的账户的。 除非被增发的账户不断的去查询。 &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //发行资产如何通知到被增发的账户呢？先不直接给需要被增发的账户to 增发，而是先给发起资产发行人增发。然后让资产发行人再转给需要被增发的账户（to ）。调用SEND_INLINE_ACTION()这个宏。 &nbsp; </strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance（st.issuer, quantity,st,st.ssuer）；&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(to!=issuer)<strong>//不是给issuer自己增发</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SEND_INLINE_ACTION(*this，transfer，{st.issuer，N(active)}，{st.issuer,to,quanity, memo});<strong>//特别注意：如果给issuer自己增发资产，这句代码就不用了。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp; //SEND_INLINE_ACTION在一个ACTION中再嵌套一个ACTION（条用了transfer）,这样就可以通知到被增发的账户to 知道自己被增发了。<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //*this &nbsp; &nbsp;就是本智能合约<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //transfer &nbsp; 就是要发起的ACTION函数<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //需要的st.issuer的active 权限<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//就是传入transfer 的函数 参数说明，1是发行人转出 &nbsp;2 转给谁， 3 转的数量 &nbsp; 4 交易备注。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<strong>//交易资产（转账）<br> &nbsp; &nbsp; &nbsp; &nbsp;//from &nbsp;谁转出来<br> &nbsp; &nbsp; &nbsp; &nbsp;//to &nbsp; &nbsp; &nbsp; 转给谁<br> &nbsp; &nbsp; &nbsp; &nbsp;//quantity &nbsp; 数量<br> &nbsp; &nbsp; &nbsp; &nbsp;//memo &nbsp;转账的时候的备注</strong><br> &nbsp; &nbsp; &nbsp; &nbsp;void token::transfer(account_name from , account_name to, asset quantity, string memo) &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print("transfer"); <strong>//打印一个信息，表示要转账了。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_auth(from ); &nbsp;<strong>//检查发行人的授权。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto &nbsp;sym &nbsp;=quanity.symbol.name(); <strong>//把资产名字取出来</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stats stastable(_self, sym); &nbsp; <strong>//系统和数据库交互的一个工具,得到该智能合约的拥有者名下的这个资产的数据表。<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//_self &nbsp; 这个资产的拥有者（发行人）</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const auto &amp; st = statstable.get(sym);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>//收据 ，就是把资产从from转到to后，需要得到收据。</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(from ); <strong>//得到from 收据</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;require_recipient(to); <strong>&nbsp;//得到to收据</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quanity.is_valid(),"invalid quantity"); <strong>&nbsp;//如果是无效的，报错信息</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eosio_assert(quantity.amount&gt;0,"must transfer posivive quantity"); <strong>//如果不大于0，报错信息</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp;//实现交易</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub_balance(from,quantity,st);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add_balance(to,quantity,st,from);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> ｝</p> 
  <p><br><strong>//三个公有函数（三个action）暴露给系统。</strong><br> EOSIO_ABI(eosio::token,(create)(issue)(transfer))</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/akai9898/article/details/82016957,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/akai9898/article/details/82016957,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
