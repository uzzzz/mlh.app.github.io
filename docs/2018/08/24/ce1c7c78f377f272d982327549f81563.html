<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习-钱包标准(一)-BIP32 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习-钱包标准(一)-BIP32" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82011876 钱包分类 钱包，参考书籍《精通比特币（第二版）》第五章钱包 钱包的一些标准有： 助记码，基于 BIP-39 HD 钱包，基于 BIP-32 多用途 HD 钱包结构，基于 BIP-43 多币种和多帐户钱包，基于 BIP-44 比特币钱包只含有密钥而不是钱币，每个用户有包含多个密钥的钱包。有两种主要类型非确定性钱包（其中每个密钥都是从随 机数独立生成的）和确定性钱包（其中所有的密钥都是从一个主 密钥派生出来，这个主密钥即为种子(seed)）。 1.非确定性钱包 2.确定性（种子）钱包 3.分层确定性钱包(HD Wallets (BIP-32/BIP-44)) 确定性钱包的最高级形式是通过 BIP0032 标准定义的 HD 钱包。 结合代码部分来看这个标准 BIP 32 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki 比特币改进协议32 https://blog.csdn.net/pony_maggie/article/details/76178228 The specification consists of two parts. In a first part, a system for deriving a tree of keypairs from a single seed is presented. The second part demonstrates how to build a wallet structure on top of such a tree. 该规范由两部分组成。 在第一部分中，提出了一种用于从单个种子导出密钥对树的系统。 第二部分演示了如何在这样的树顶部构建钱包结构。 part I 密钥派生 在下面，会定义一个从父密钥派生多个子密钥的函数，为了防止这些子密钥仅依赖密钥本省，我们首先使用额外的256位熵扩展私钥和公钥，这个被称为链码的扩展对于相应的私钥和公钥是相同的，由32个字节组成。 我们将扩展私钥表示为（k，c），k表示普通私钥，c表示链码；扩展公钥表示为（K，c）K表示point(k) point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the secp256k1 base point with the integer p. 每个扩展密钥有231个普通子密钥和231个硬化子密钥，这些子密钥都有一个索引。普通子密钥使用索引0-231，硬化子密钥使用231-232-1,为简化硬化子密钥的索引，用数字iH代表i+231 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非 你已经有了链码。 来看这个函数 给定父扩展密钥和索引，可以计算相应的子密钥。这个算法的实现取决于子密钥是否是一个硬化的密钥（或者，等价与i&gt;=231）,以及我们是否在讨论私钥或公钥。 Child key derivation (CKD) functions Given a parent extended key and an index i, it is possible to compute the corresponding child extended key. The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether i ≥ 231), and whether we’re talking about private or public keys. Private parent key → private child key//父私钥到子私钥 The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key: 1.Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.) If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)). 2.Split I into two 32-byte sequences, IL and IR. The returned child key ki is parse256(IL) + kpar (mod n). The returned chain code ci is IR. 3.In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2127.) The HMAC-SHA512 function is specified in RFC 4231. Public parent key → public child key//父公钥-&gt;子公钥 The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.//只针对未硬化的子密钥定义 Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): return failure If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)). Split I into two 32-byte sequences, IL and IR. The returned child key Ki is point(parse256(IL)) + Kpar. The returned chain code ci is IR. In case parse256(IL) ≥ n or Ki is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i. Private parent key → public child key//父私钥-&gt;子公钥 The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions). The returned key K is point(k). The returned chain code c is just the passed chain code. To compute the public child key of a parent private key: N(CKDpriv((kpar, cpar), i)) (works always). CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys). Public parent key → private child key//不存在 子密钥的派生函数，这段可以结合源码来看，对应Derive函数 SetMaster seed-&gt;masterkey，主密钥生成，seed一般使用BIP39标准 根种子输入到 HMAC-SHA512 算法中就可以得到一个可用来创造主私钥(m) (master private key(m) )和主链代码(a master chain code)的哈希。主私钥(m) 之后可以通过使用我们在本章先前看到的那个普通椭圆曲线 m * G 过程生来成相 对应的主公钥(M)。 链代码用于从母密钥中创造子密钥的那个函数中引入熵。 Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG. Calculate I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S) Split I into two 32-byte sequences, IL and IR. Use parse256(IL) as master secret key, and IR as master chain code void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) { static const unsigned char hashkey[] = {&#39;B&#39;,&#39;i&#39;,&#39;t&#39;,&#39;c&#39;,&#39;o&#39;,&#39;i&#39;,&#39;n&#39;,&#39; &#39;,&#39;s&#39;,&#39;e&#39;,&#39;e&#39;,&#39;d&#39;}; unsigned char out[64]; LockObject(out); CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out); key.Set(&amp;out[0], &amp;out[32], true); memcpy(chaincode.begin(), &amp;out[32], 32); UnlockObject(out); nDepth = 0;//表示master node nChild = 0;//还没有子密钥 memset(vchFingerprint, 0, sizeof(vchFingerprint));//指纹初始化为0 } memcpy:memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 void *memcpy(void *dest, const void *src, size_t n) memset:memset是计算机中C/C++语言初始化函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。 首先调用CHMAC_SHA512， HMAC-SHA-512 is the realization of the HMAC message authentication code using the SHA-512 hash function. HMAC-SHA-512是使用SHA-512哈希函数实现HMAC消息认证码。 CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen) { unsigned char rkey[128]; if (keylen &lt;= 128) { memcpy(rkey, key, keylen); memset(rkey + keylen, 0, 128 - keylen);//其余位初始化为0 } else { CSHA512().Write(key, keylen).Finalize(rkey); memset(rkey + 64, 0, 64); } //每个字符做异或操作 for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c; outer.Write(rkey, 128);//CSHA512 outer for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c ^ 0x36;//抵消0x5c，等于原 rkey[n]^0x36 inner.Write(rkey, 128);//CSHA512 inner } 这里调用的write是CSHA512::Write，具体步骤不介绍了 //src/crypto/sha512.cpp CSHA512&amp; CSHA512::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 128; if (bufsize &amp;&amp; bufsize + len &gt;= 128) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 128 - bufsize); bytes += 128 - bufsize; data += 128 - bufsize; sha512::Transform(s, buf); bufsize = 0; } while (end &gt;= data + 128) { // Process full chunks directly from the source. sha512::Transform(s, data); data += 128; bytes += 128; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } Derive Key identifiers Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256) of the serialized ECDSA public key K, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses. It is not advised to represent this data in base58 format though, as it may be interpreted as an address that way (and wallet software is not required to accept payment to the chain key itself). The first 32 bits of the identifier are called the key fingerprint. //key.cpp bool CExtKey::Derive(CExtKey &amp;out, unsigned int nChild) const { out.nDepth = nDepth + 1;//深度加一 CKeyID id = key.GetPubKey().GetID();//密钥标识符,GetID函数就是取Hash160 memcpy(&amp;out.vchFingerprint[0], &amp;id, 4);//标识符的前32位称为密钥指纹 out.nChild = nChild; return key.Derive(out.key, out.chaincode, nChild, chaincode); } bool CKey::Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert(IsCompressed()); unsigned char out[64]; LockObject(out); //1.Check whether i ≥ 2&lt;sup&gt;31 &lt;/sup&gt;(whether the child is a hardened key). if ((nChild &gt;&gt; 31) == 0) { CPubKey pubkey = GetPubKey(); assert(pubkey.begin() + 33 == pubkey.end()); BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out); } else { assert(begin() + 32 == end()); BIP32Hash(cc, nChild, 0, begin(), out); } //2. Split I into two 32-byte sequences, IL and IR. memcpy(ccChild.begin(), out+32, 32); memcpy((unsigned char*)keyChild.begin(), begin(), 32); //3. bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), out); UnlockObject(out); keyChild.fCompressed = true; keyChild.fValid = ret; return ret; } 序列化格式 密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。 这只需要三个输入量:一个密钥，一个链码以及想要的子密钥的索引。密钥以及 链码这两个重要的部分被结合之后，就叫做扩展密钥(extended key)。术语 “extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。 扩展的私钥 //key.cpp struct CExtKey { unsigned char nDepth;//深度 unsigned char vchFingerprint[4];//父密钥的指纹 unsigned int nChild; ChainCode chaincode;//链码 CKey key;//私钥 ... 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private) 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, …. 4 bytes: the fingerprint of the parent’s key (0x00000000 if master key) 4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key) 32 bytes: the chain code 33 bytes: the public key or private key data (serP(K) for public keys, 0x00 || ser256(k) for private keys) 这种78字节结构可以像Base58中的其他比特币数据一样进行编码，首先添加32个校验和位（从双SHA-256校验和中导出），然后转换为Base58表示。 这导致Base58编码的字符串最多112个字符。 由于版本字节的选择，Base58表示将在主网上以“xprv”或“xpub”开头，在testnet上以“tprv”或“tpub”开头。 扩展的公钥结构也是类似的。 特点 分层确定性钱包的一个很有用的特点就是可以 不通过私钥而直接从公共母密钥派生出公共子密钥的能 力。这就给了我们两种衍 生子公钥的方法:或者通过子私钥，再或者就是直接通过母公钥。 这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 bool CPubKey::Derive(CPubKey&amp; pubkeyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert((nChild &gt;&gt; 31) == 0); assert(begin() + 33 == end()); unsigned char out[64]; BIP32Hash(cc, nChild, *begin(), begin()+1, out); memcpy(ccChild.begin(), out+32, 32); secp256k1_pubkey pubkey; if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &amp;pubkey, &amp;(*this)[0], size())) { return false; } if (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &amp;pubkey, out)) { return false; } unsigned char pub[33]; size_t publen = 33; secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &amp;publen, &amp;pubkey, SECP256K1_EC_COMPRESSED); pubkeyChild.Set(pub, pub + publen); return true; } 关于硬化 前面在派生的子密钥的时候有对密钥是否硬化做的判断，这里介绍下硬化 从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD 钱包使用一种叫做硬化衍生(hardened derivation)的替代 衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用 了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火 墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几 乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥。 简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴 露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母 私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层 级的子密钥最好使用强化衍生。 part II 钱包结构 客户端要求具备兼容性，即使不支持所有功能。 缺省的钱包结构 HDW（分层确定性钱包）被组织为几个“帐户”。 帐户已编号，默认帐户（“”）为数字0.客户端不需要支持多个帐户 - 如果不支持，则仅使用默认帐户。 由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以 “M“打头。因此，母密钥生成的第一个子私钥是 m/0。第一个公钥是 M/0。第一 个子密钥的子密钥就是 m/0/1，以此类推。 每个帐户由两个密钥对链组成：内部和外部链。 外部钥匙串用于生成新的公共地址，而内部钥匙串用于所有其他操作（更改地址，生成地址，……，任何不需要通信的内容）。 不支持单独的钥匙串的客户端应该使用外部钥匙链。 m / iH / 0 / k对应于从主m导出的HDW的帐号i的外链的第k个密钥对。 m / iH/ 1 / k对应于从主m导出的HDW的帐号i的内部链的第k个密钥对。 兼容性 为了符合此标准，客户端必须至少能够导入扩展的公钥或私钥，以便将其直接后代作为钱包密钥进行访问。 在规范的第二部分中提供的钱包结构（主/帐户/链/子链）仅供参考，但建议作为最小结构以便于兼容 - 即使没有单独的帐户或内部链和外部链之间的区别。 但是，实现可能会因特定需求而偏离它; 更复杂的应用程序可能需要更复杂的树结构。 BIP44 文档https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki 该BIP基于BIP-0032（从现在开始的BIP32）和BIP-0043（从现在开始的BIP43）中描述的目的方案中描述的算法定义确定性钱包的逻辑层级。 HD 钱包树状结构提供了极大的灵活性。每一个母扩展密钥有 40 亿个子密钥:20 亿个常规子密钥和 20 亿个强化子密钥。而每个子密钥又会有 40 亿个子密钥并 且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的 BIP-43 提出使用第一个强化子索引作为特殊的标识符表示 树状结构的“purpose”。基于 BIP-43，HD 钱包应该使用且只用第一层级的树的分 支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个 例子，HD 钱包只使用分支 m/i’/是 为了表明那个被索引号“i”定义的特殊为目地。 在 BIP-43 标准下，为了延长的那个特殊规范，BIP-44 提议了多账户结构作为 “purpose”。所有遵循 BIP-44 的 HD 钱包依据只使用树的第一个分支的要求而被定 义:m/44’/。 BIP-44 指定了包含 5 个预定义树状层级的结构: 第一层的 purpose 总是被设定为 44’。 第二层的“coin_type”特指币种并且允许多元货币 HD 钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义:Bitcoin is m/44’/0’、Bitcoin Testnet is m/44’/1’，以及 Litecoin is m/44’/2’。 完整注册硬币类型列表https://github.com/satoshilabs/slips/blob/master/slip-0044.md 第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细 分他们的钱包到独立的逻辑性亚账户。 举个例子，一个 HD 钱包可能包含两个比 特币“账户”:m/44’/0’/0’ 和 m/44’/0’/1’。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个 HD 钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都 是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。 被 HD 钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的 “address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44’/0’/0’/0/2。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82011876 钱包分类 钱包，参考书籍《精通比特币（第二版）》第五章钱包 钱包的一些标准有： 助记码，基于 BIP-39 HD 钱包，基于 BIP-32 多用途 HD 钱包结构，基于 BIP-43 多币种和多帐户钱包，基于 BIP-44 比特币钱包只含有密钥而不是钱币，每个用户有包含多个密钥的钱包。有两种主要类型非确定性钱包（其中每个密钥都是从随 机数独立生成的）和确定性钱包（其中所有的密钥都是从一个主 密钥派生出来，这个主密钥即为种子(seed)）。 1.非确定性钱包 2.确定性（种子）钱包 3.分层确定性钱包(HD Wallets (BIP-32/BIP-44)) 确定性钱包的最高级形式是通过 BIP0032 标准定义的 HD 钱包。 结合代码部分来看这个标准 BIP 32 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki 比特币改进协议32 https://blog.csdn.net/pony_maggie/article/details/76178228 The specification consists of two parts. In a first part, a system for deriving a tree of keypairs from a single seed is presented. The second part demonstrates how to build a wallet structure on top of such a tree. 该规范由两部分组成。 在第一部分中，提出了一种用于从单个种子导出密钥对树的系统。 第二部分演示了如何在这样的树顶部构建钱包结构。 part I 密钥派生 在下面，会定义一个从父密钥派生多个子密钥的函数，为了防止这些子密钥仅依赖密钥本省，我们首先使用额外的256位熵扩展私钥和公钥，这个被称为链码的扩展对于相应的私钥和公钥是相同的，由32个字节组成。 我们将扩展私钥表示为（k，c），k表示普通私钥，c表示链码；扩展公钥表示为（K，c）K表示point(k) point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the secp256k1 base point with the integer p. 每个扩展密钥有231个普通子密钥和231个硬化子密钥，这些子密钥都有一个索引。普通子密钥使用索引0-231，硬化子密钥使用231-232-1,为简化硬化子密钥的索引，用数字iH代表i+231 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非 你已经有了链码。 来看这个函数 给定父扩展密钥和索引，可以计算相应的子密钥。这个算法的实现取决于子密钥是否是一个硬化的密钥（或者，等价与i&gt;=231）,以及我们是否在讨论私钥或公钥。 Child key derivation (CKD) functions Given a parent extended key and an index i, it is possible to compute the corresponding child extended key. The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether i ≥ 231), and whether we’re talking about private or public keys. Private parent key → private child key//父私钥到子私钥 The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key: 1.Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.) If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)). 2.Split I into two 32-byte sequences, IL and IR. The returned child key ki is parse256(IL) + kpar (mod n). The returned chain code ci is IR. 3.In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2127.) The HMAC-SHA512 function is specified in RFC 4231. Public parent key → public child key//父公钥-&gt;子公钥 The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.//只针对未硬化的子密钥定义 Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): return failure If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)). Split I into two 32-byte sequences, IL and IR. The returned child key Ki is point(parse256(IL)) + Kpar. The returned chain code ci is IR. In case parse256(IL) ≥ n or Ki is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i. Private parent key → public child key//父私钥-&gt;子公钥 The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions). The returned key K is point(k). The returned chain code c is just the passed chain code. To compute the public child key of a parent private key: N(CKDpriv((kpar, cpar), i)) (works always). CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys). Public parent key → private child key//不存在 子密钥的派生函数，这段可以结合源码来看，对应Derive函数 SetMaster seed-&gt;masterkey，主密钥生成，seed一般使用BIP39标准 根种子输入到 HMAC-SHA512 算法中就可以得到一个可用来创造主私钥(m) (master private key(m) )和主链代码(a master chain code)的哈希。主私钥(m) 之后可以通过使用我们在本章先前看到的那个普通椭圆曲线 m * G 过程生来成相 对应的主公钥(M)。 链代码用于从母密钥中创造子密钥的那个函数中引入熵。 Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG. Calculate I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S) Split I into two 32-byte sequences, IL and IR. Use parse256(IL) as master secret key, and IR as master chain code void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) { static const unsigned char hashkey[] = {&#39;B&#39;,&#39;i&#39;,&#39;t&#39;,&#39;c&#39;,&#39;o&#39;,&#39;i&#39;,&#39;n&#39;,&#39; &#39;,&#39;s&#39;,&#39;e&#39;,&#39;e&#39;,&#39;d&#39;}; unsigned char out[64]; LockObject(out); CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out); key.Set(&amp;out[0], &amp;out[32], true); memcpy(chaincode.begin(), &amp;out[32], 32); UnlockObject(out); nDepth = 0;//表示master node nChild = 0;//还没有子密钥 memset(vchFingerprint, 0, sizeof(vchFingerprint));//指纹初始化为0 } memcpy:memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 void *memcpy(void *dest, const void *src, size_t n) memset:memset是计算机中C/C++语言初始化函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。 首先调用CHMAC_SHA512， HMAC-SHA-512 is the realization of the HMAC message authentication code using the SHA-512 hash function. HMAC-SHA-512是使用SHA-512哈希函数实现HMAC消息认证码。 CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen) { unsigned char rkey[128]; if (keylen &lt;= 128) { memcpy(rkey, key, keylen); memset(rkey + keylen, 0, 128 - keylen);//其余位初始化为0 } else { CSHA512().Write(key, keylen).Finalize(rkey); memset(rkey + 64, 0, 64); } //每个字符做异或操作 for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c; outer.Write(rkey, 128);//CSHA512 outer for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c ^ 0x36;//抵消0x5c，等于原 rkey[n]^0x36 inner.Write(rkey, 128);//CSHA512 inner } 这里调用的write是CSHA512::Write，具体步骤不介绍了 //src/crypto/sha512.cpp CSHA512&amp; CSHA512::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 128; if (bufsize &amp;&amp; bufsize + len &gt;= 128) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 128 - bufsize); bytes += 128 - bufsize; data += 128 - bufsize; sha512::Transform(s, buf); bufsize = 0; } while (end &gt;= data + 128) { // Process full chunks directly from the source. sha512::Transform(s, data); data += 128; bytes += 128; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } Derive Key identifiers Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256) of the serialized ECDSA public key K, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses. It is not advised to represent this data in base58 format though, as it may be interpreted as an address that way (and wallet software is not required to accept payment to the chain key itself). The first 32 bits of the identifier are called the key fingerprint. //key.cpp bool CExtKey::Derive(CExtKey &amp;out, unsigned int nChild) const { out.nDepth = nDepth + 1;//深度加一 CKeyID id = key.GetPubKey().GetID();//密钥标识符,GetID函数就是取Hash160 memcpy(&amp;out.vchFingerprint[0], &amp;id, 4);//标识符的前32位称为密钥指纹 out.nChild = nChild; return key.Derive(out.key, out.chaincode, nChild, chaincode); } bool CKey::Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert(IsCompressed()); unsigned char out[64]; LockObject(out); //1.Check whether i ≥ 2&lt;sup&gt;31 &lt;/sup&gt;(whether the child is a hardened key). if ((nChild &gt;&gt; 31) == 0) { CPubKey pubkey = GetPubKey(); assert(pubkey.begin() + 33 == pubkey.end()); BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out); } else { assert(begin() + 32 == end()); BIP32Hash(cc, nChild, 0, begin(), out); } //2. Split I into two 32-byte sequences, IL and IR. memcpy(ccChild.begin(), out+32, 32); memcpy((unsigned char*)keyChild.begin(), begin(), 32); //3. bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), out); UnlockObject(out); keyChild.fCompressed = true; keyChild.fValid = ret; return ret; } 序列化格式 密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。 这只需要三个输入量:一个密钥，一个链码以及想要的子密钥的索引。密钥以及 链码这两个重要的部分被结合之后，就叫做扩展密钥(extended key)。术语 “extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。 扩展的私钥 //key.cpp struct CExtKey { unsigned char nDepth;//深度 unsigned char vchFingerprint[4];//父密钥的指纹 unsigned int nChild; ChainCode chaincode;//链码 CKey key;//私钥 ... 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private) 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, …. 4 bytes: the fingerprint of the parent’s key (0x00000000 if master key) 4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key) 32 bytes: the chain code 33 bytes: the public key or private key data (serP(K) for public keys, 0x00 || ser256(k) for private keys) 这种78字节结构可以像Base58中的其他比特币数据一样进行编码，首先添加32个校验和位（从双SHA-256校验和中导出），然后转换为Base58表示。 这导致Base58编码的字符串最多112个字符。 由于版本字节的选择，Base58表示将在主网上以“xprv”或“xpub”开头，在testnet上以“tprv”或“tpub”开头。 扩展的公钥结构也是类似的。 特点 分层确定性钱包的一个很有用的特点就是可以 不通过私钥而直接从公共母密钥派生出公共子密钥的能 力。这就给了我们两种衍 生子公钥的方法:或者通过子私钥，再或者就是直接通过母公钥。 这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 bool CPubKey::Derive(CPubKey&amp; pubkeyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert((nChild &gt;&gt; 31) == 0); assert(begin() + 33 == end()); unsigned char out[64]; BIP32Hash(cc, nChild, *begin(), begin()+1, out); memcpy(ccChild.begin(), out+32, 32); secp256k1_pubkey pubkey; if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &amp;pubkey, &amp;(*this)[0], size())) { return false; } if (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &amp;pubkey, out)) { return false; } unsigned char pub[33]; size_t publen = 33; secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &amp;publen, &amp;pubkey, SECP256K1_EC_COMPRESSED); pubkeyChild.Set(pub, pub + publen); return true; } 关于硬化 前面在派生的子密钥的时候有对密钥是否硬化做的判断，这里介绍下硬化 从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD 钱包使用一种叫做硬化衍生(hardened derivation)的替代 衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用 了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火 墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几 乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥。 简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴 露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母 私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层 级的子密钥最好使用强化衍生。 part II 钱包结构 客户端要求具备兼容性，即使不支持所有功能。 缺省的钱包结构 HDW（分层确定性钱包）被组织为几个“帐户”。 帐户已编号，默认帐户（“”）为数字0.客户端不需要支持多个帐户 - 如果不支持，则仅使用默认帐户。 由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以 “M“打头。因此，母密钥生成的第一个子私钥是 m/0。第一个公钥是 M/0。第一 个子密钥的子密钥就是 m/0/1，以此类推。 每个帐户由两个密钥对链组成：内部和外部链。 外部钥匙串用于生成新的公共地址，而内部钥匙串用于所有其他操作（更改地址，生成地址，……，任何不需要通信的内容）。 不支持单独的钥匙串的客户端应该使用外部钥匙链。 m / iH / 0 / k对应于从主m导出的HDW的帐号i的外链的第k个密钥对。 m / iH/ 1 / k对应于从主m导出的HDW的帐号i的内部链的第k个密钥对。 兼容性 为了符合此标准，客户端必须至少能够导入扩展的公钥或私钥，以便将其直接后代作为钱包密钥进行访问。 在规范的第二部分中提供的钱包结构（主/帐户/链/子链）仅供参考，但建议作为最小结构以便于兼容 - 即使没有单独的帐户或内部链和外部链之间的区别。 但是，实现可能会因特定需求而偏离它; 更复杂的应用程序可能需要更复杂的树结构。 BIP44 文档https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki 该BIP基于BIP-0032（从现在开始的BIP32）和BIP-0043（从现在开始的BIP43）中描述的目的方案中描述的算法定义确定性钱包的逻辑层级。 HD 钱包树状结构提供了极大的灵活性。每一个母扩展密钥有 40 亿个子密钥:20 亿个常规子密钥和 20 亿个强化子密钥。而每个子密钥又会有 40 亿个子密钥并 且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的 BIP-43 提出使用第一个强化子索引作为特殊的标识符表示 树状结构的“purpose”。基于 BIP-43，HD 钱包应该使用且只用第一层级的树的分 支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个 例子，HD 钱包只使用分支 m/i’/是 为了表明那个被索引号“i”定义的特殊为目地。 在 BIP-43 标准下，为了延长的那个特殊规范，BIP-44 提议了多账户结构作为 “purpose”。所有遵循 BIP-44 的 HD 钱包依据只使用树的第一个分支的要求而被定 义:m/44’/。 BIP-44 指定了包含 5 个预定义树状层级的结构: 第一层的 purpose 总是被设定为 44’。 第二层的“coin_type”特指币种并且允许多元货币 HD 钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义:Bitcoin is m/44’/0’、Bitcoin Testnet is m/44’/1’，以及 Litecoin is m/44’/2’。 完整注册硬币类型列表https://github.com/satoshilabs/slips/blob/master/slip-0044.md 第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细 分他们的钱包到独立的逻辑性亚账户。 举个例子，一个 HD 钱包可能包含两个比 特币“账户”:m/44’/0’/0’ 和 m/44’/0’/1’。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个 HD 钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都 是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。 被 HD 钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的 “address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44’/0’/0’/0/2。 阅读更多 登录后自动展开" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82011876 钱包分类 钱包，参考书籍《精通比特币（第二版）》第五章钱包 钱包的一些标准有： 助记码，基于 BIP-39 HD 钱包，基于 BIP-32 多用途 HD 钱包结构，基于 BIP-43 多币种和多帐户钱包，基于 BIP-44 比特币钱包只含有密钥而不是钱币，每个用户有包含多个密钥的钱包。有两种主要类型非确定性钱包（其中每个密钥都是从随 机数独立生成的）和确定性钱包（其中所有的密钥都是从一个主 密钥派生出来，这个主密钥即为种子(seed)）。 1.非确定性钱包 2.确定性（种子）钱包 3.分层确定性钱包(HD Wallets (BIP-32/BIP-44)) 确定性钱包的最高级形式是通过 BIP0032 标准定义的 HD 钱包。 结合代码部分来看这个标准 BIP 32 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki 比特币改进协议32 https://blog.csdn.net/pony_maggie/article/details/76178228 The specification consists of two parts. In a first part, a system for deriving a tree of keypairs from a single seed is presented. The second part demonstrates how to build a wallet structure on top of such a tree. 该规范由两部分组成。 在第一部分中，提出了一种用于从单个种子导出密钥对树的系统。 第二部分演示了如何在这样的树顶部构建钱包结构。 part I 密钥派生 在下面，会定义一个从父密钥派生多个子密钥的函数，为了防止这些子密钥仅依赖密钥本省，我们首先使用额外的256位熵扩展私钥和公钥，这个被称为链码的扩展对于相应的私钥和公钥是相同的，由32个字节组成。 我们将扩展私钥表示为（k，c），k表示普通私钥，c表示链码；扩展公钥表示为（K，c）K表示point(k) point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the secp256k1 base point with the integer p. 每个扩展密钥有231个普通子密钥和231个硬化子密钥，这些子密钥都有一个索引。普通子密钥使用索引0-231，硬化子密钥使用231-232-1,为简化硬化子密钥的索引，用数字iH代表i+231 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非 你已经有了链码。 来看这个函数 给定父扩展密钥和索引，可以计算相应的子密钥。这个算法的实现取决于子密钥是否是一个硬化的密钥（或者，等价与i&gt;=231）,以及我们是否在讨论私钥或公钥。 Child key derivation (CKD) functions Given a parent extended key and an index i, it is possible to compute the corresponding child extended key. The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether i ≥ 231), and whether we’re talking about private or public keys. Private parent key → private child key//父私钥到子私钥 The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key: 1.Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.) If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)). 2.Split I into two 32-byte sequences, IL and IR. The returned child key ki is parse256(IL) + kpar (mod n). The returned chain code ci is IR. 3.In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2127.) The HMAC-SHA512 function is specified in RFC 4231. Public parent key → public child key//父公钥-&gt;子公钥 The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.//只针对未硬化的子密钥定义 Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): return failure If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)). Split I into two 32-byte sequences, IL and IR. The returned child key Ki is point(parse256(IL)) + Kpar. The returned chain code ci is IR. In case parse256(IL) ≥ n or Ki is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i. Private parent key → public child key//父私钥-&gt;子公钥 The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions). The returned key K is point(k). The returned chain code c is just the passed chain code. To compute the public child key of a parent private key: N(CKDpriv((kpar, cpar), i)) (works always). CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys). Public parent key → private child key//不存在 子密钥的派生函数，这段可以结合源码来看，对应Derive函数 SetMaster seed-&gt;masterkey，主密钥生成，seed一般使用BIP39标准 根种子输入到 HMAC-SHA512 算法中就可以得到一个可用来创造主私钥(m) (master private key(m) )和主链代码(a master chain code)的哈希。主私钥(m) 之后可以通过使用我们在本章先前看到的那个普通椭圆曲线 m * G 过程生来成相 对应的主公钥(M)。 链代码用于从母密钥中创造子密钥的那个函数中引入熵。 Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG. Calculate I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S) Split I into two 32-byte sequences, IL and IR. Use parse256(IL) as master secret key, and IR as master chain code void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) { static const unsigned char hashkey[] = {&#39;B&#39;,&#39;i&#39;,&#39;t&#39;,&#39;c&#39;,&#39;o&#39;,&#39;i&#39;,&#39;n&#39;,&#39; &#39;,&#39;s&#39;,&#39;e&#39;,&#39;e&#39;,&#39;d&#39;}; unsigned char out[64]; LockObject(out); CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out); key.Set(&amp;out[0], &amp;out[32], true); memcpy(chaincode.begin(), &amp;out[32], 32); UnlockObject(out); nDepth = 0;//表示master node nChild = 0;//还没有子密钥 memset(vchFingerprint, 0, sizeof(vchFingerprint));//指纹初始化为0 } memcpy:memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 void *memcpy(void *dest, const void *src, size_t n) memset:memset是计算机中C/C++语言初始化函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。 首先调用CHMAC_SHA512， HMAC-SHA-512 is the realization of the HMAC message authentication code using the SHA-512 hash function. HMAC-SHA-512是使用SHA-512哈希函数实现HMAC消息认证码。 CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen) { unsigned char rkey[128]; if (keylen &lt;= 128) { memcpy(rkey, key, keylen); memset(rkey + keylen, 0, 128 - keylen);//其余位初始化为0 } else { CSHA512().Write(key, keylen).Finalize(rkey); memset(rkey + 64, 0, 64); } //每个字符做异或操作 for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c; outer.Write(rkey, 128);//CSHA512 outer for (int n = 0; n &lt; 128; n++) rkey[n] ^= 0x5c ^ 0x36;//抵消0x5c，等于原 rkey[n]^0x36 inner.Write(rkey, 128);//CSHA512 inner } 这里调用的write是CSHA512::Write，具体步骤不介绍了 //src/crypto/sha512.cpp CSHA512&amp; CSHA512::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 128; if (bufsize &amp;&amp; bufsize + len &gt;= 128) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 128 - bufsize); bytes += 128 - bufsize; data += 128 - bufsize; sha512::Transform(s, buf); bufsize = 0; } while (end &gt;= data + 128) { // Process full chunks directly from the source. sha512::Transform(s, data); data += 128; bytes += 128; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } Derive Key identifiers Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256) of the serialized ECDSA public key K, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses. It is not advised to represent this data in base58 format though, as it may be interpreted as an address that way (and wallet software is not required to accept payment to the chain key itself). The first 32 bits of the identifier are called the key fingerprint. //key.cpp bool CExtKey::Derive(CExtKey &amp;out, unsigned int nChild) const { out.nDepth = nDepth + 1;//深度加一 CKeyID id = key.GetPubKey().GetID();//密钥标识符,GetID函数就是取Hash160 memcpy(&amp;out.vchFingerprint[0], &amp;id, 4);//标识符的前32位称为密钥指纹 out.nChild = nChild; return key.Derive(out.key, out.chaincode, nChild, chaincode); } bool CKey::Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert(IsCompressed()); unsigned char out[64]; LockObject(out); //1.Check whether i ≥ 2&lt;sup&gt;31 &lt;/sup&gt;(whether the child is a hardened key). if ((nChild &gt;&gt; 31) == 0) { CPubKey pubkey = GetPubKey(); assert(pubkey.begin() + 33 == pubkey.end()); BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out); } else { assert(begin() + 32 == end()); BIP32Hash(cc, nChild, 0, begin(), out); } //2. Split I into two 32-byte sequences, IL and IR. memcpy(ccChild.begin(), out+32, 32); memcpy((unsigned char*)keyChild.begin(), begin(), 32); //3. bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), out); UnlockObject(out); keyChild.fCompressed = true; keyChild.fValid = ret; return ret; } 序列化格式 密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。 这只需要三个输入量:一个密钥，一个链码以及想要的子密钥的索引。密钥以及 链码这两个重要的部分被结合之后，就叫做扩展密钥(extended key)。术语 “extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。 扩展的私钥 //key.cpp struct CExtKey { unsigned char nDepth;//深度 unsigned char vchFingerprint[4];//父密钥的指纹 unsigned int nChild; ChainCode chaincode;//链码 CKey key;//私钥 ... 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private) 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, …. 4 bytes: the fingerprint of the parent’s key (0x00000000 if master key) 4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key) 32 bytes: the chain code 33 bytes: the public key or private key data (serP(K) for public keys, 0x00 || ser256(k) for private keys) 这种78字节结构可以像Base58中的其他比特币数据一样进行编码，首先添加32个校验和位（从双SHA-256校验和中导出），然后转换为Base58表示。 这导致Base58编码的字符串最多112个字符。 由于版本字节的选择，Base58表示将在主网上以“xprv”或“xpub”开头，在testnet上以“tprv”或“tpub”开头。 扩展的公钥结构也是类似的。 特点 分层确定性钱包的一个很有用的特点就是可以 不通过私钥而直接从公共母密钥派生出公共子密钥的能 力。这就给了我们两种衍 生子公钥的方法:或者通过子私钥，再或者就是直接通过母公钥。 这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。 bool CPubKey::Derive(CPubKey&amp; pubkeyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const { assert(IsValid()); assert((nChild &gt;&gt; 31) == 0); assert(begin() + 33 == end()); unsigned char out[64]; BIP32Hash(cc, nChild, *begin(), begin()+1, out); memcpy(ccChild.begin(), out+32, 32); secp256k1_pubkey pubkey; if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &amp;pubkey, &amp;(*this)[0], size())) { return false; } if (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &amp;pubkey, out)) { return false; } unsigned char pub[33]; size_t publen = 33; secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &amp;publen, &amp;pubkey, SECP256K1_EC_COMPRESSED); pubkeyChild.Set(pub, pub + publen); return true; } 关于硬化 前面在派生的子密钥的时候有对密钥是否硬化做的判断，这里介绍下硬化 从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 为了应对这种风险，HD 钱包使用一种叫做硬化衍生(hardened derivation)的替代 衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用 了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火 墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几 乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥。 简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴 露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母 私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层 级的子密钥最好使用强化衍生。 part II 钱包结构 客户端要求具备兼容性，即使不支持所有功能。 缺省的钱包结构 HDW（分层确定性钱包）被组织为几个“帐户”。 帐户已编号，默认帐户（“”）为数字0.客户端不需要支持多个帐户 - 如果不支持，则仅使用默认帐户。 由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以 “M“打头。因此，母密钥生成的第一个子私钥是 m/0。第一个公钥是 M/0。第一 个子密钥的子密钥就是 m/0/1，以此类推。 每个帐户由两个密钥对链组成：内部和外部链。 外部钥匙串用于生成新的公共地址，而内部钥匙串用于所有其他操作（更改地址，生成地址，……，任何不需要通信的内容）。 不支持单独的钥匙串的客户端应该使用外部钥匙链。 m / iH / 0 / k对应于从主m导出的HDW的帐号i的外链的第k个密钥对。 m / iH/ 1 / k对应于从主m导出的HDW的帐号i的内部链的第k个密钥对。 兼容性 为了符合此标准，客户端必须至少能够导入扩展的公钥或私钥，以便将其直接后代作为钱包密钥进行访问。 在规范的第二部分中提供的钱包结构（主/帐户/链/子链）仅供参考，但建议作为最小结构以便于兼容 - 即使没有单独的帐户或内部链和外部链之间的区别。 但是，实现可能会因特定需求而偏离它; 更复杂的应用程序可能需要更复杂的树结构。 BIP44 文档https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki 该BIP基于BIP-0032（从现在开始的BIP32）和BIP-0043（从现在开始的BIP43）中描述的目的方案中描述的算法定义确定性钱包的逻辑层级。 HD 钱包树状结构提供了极大的灵活性。每一个母扩展密钥有 40 亿个子密钥:20 亿个常规子密钥和 20 亿个强化子密钥。而每个子密钥又会有 40 亿个子密钥并 且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的 BIP-43 提出使用第一个强化子索引作为特殊的标识符表示 树状结构的“purpose”。基于 BIP-43，HD 钱包应该使用且只用第一层级的树的分 支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个 例子，HD 钱包只使用分支 m/i’/是 为了表明那个被索引号“i”定义的特殊为目地。 在 BIP-43 标准下，为了延长的那个特殊规范，BIP-44 提议了多账户结构作为 “purpose”。所有遵循 BIP-44 的 HD 钱包依据只使用树的第一个分支的要求而被定 义:m/44’/。 BIP-44 指定了包含 5 个预定义树状层级的结构: 第一层的 purpose 总是被设定为 44’。 第二层的“coin_type”特指币种并且允许多元货币 HD 钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义:Bitcoin is m/44’/0’、Bitcoin Testnet is m/44’/1’，以及 Litecoin is m/44’/2’。 完整注册硬币类型列表https://github.com/satoshilabs/slips/blob/master/slip-0044.md 第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细 分他们的钱包到独立的逻辑性亚账户。 举个例子，一个 HD 钱包可能包含两个比 特币“账户”:m/44’/0’/0’ 和 m/44’/0’/1’。每个账户都是它自己亚树的根。 第四层级就是“change”。每一个 HD 钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都 是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。 被 HD 钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的 “address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44’/0’/0’/0/2。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"/2018/08/24/ce1c7c78f377f272d982327549f81563.html","headline":"比特币源码学习-钱包标准(一)-BIP32","dateModified":"2018-08-24T00:00:00+08:00","datePublished":"2018-08-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/24/ce1c7c78f377f272d982327549f81563.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习-钱包标准(一)-BIP32</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/82011876 
 </div> 
 <div class="markdown_views"> 
  <h1 id="钱包分类">钱包分类</h1> 
  <p>钱包，参考书籍《精通比特币（第二版）》第五章钱包 <br> 钱包的一些标准有：</p> 
  <blockquote> 
   <p>助记码，基于 BIP-39 <br> HD 钱包，基于 BIP-32 <br> 多用途 HD 钱包结构，基于 BIP-43 <br> 多币种和多帐户钱包，基于 BIP-44</p> 
  </blockquote> 
  <p>比特币钱包只含有密钥而不是钱币，每个用户有包含多个密钥的钱包。有两种主要类型非确定性钱包（其中每个密钥都是从随 机数独立生成的）和确定性钱包（其中所有的密钥都是从一个主 密钥派生出来，这个主密钥即为种子(seed)）。 <br> 1.非确定性钱包 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829144323356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 2.确定性（种子）钱包 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829144424950?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="确定性钱包" title=""> <br> 3.分层确定性钱包(HD Wallets (BIP-32/BIP-44)) <br> 确定性钱包的最高级形式是通过 BIP0032 标准定义的 HD 钱包。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829144450759?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="分层确定性钱包" title=""> <br> 结合代码部分来看这个标准</p> 
  <h1 id="bip-32">BIP 32</h1> 
  <p><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" rel="nofollow">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a> <br> 比特币改进协议32 <a href="https://blog.csdn.net/pony_maggie/article/details/76178228" rel="nofollow">https://blog.csdn.net/pony_maggie/article/details/76178228</a></p> 
  <blockquote> 
   <p>The specification consists of two parts. In a first part, a system for deriving a tree of keypairs from a single seed is presented. The second part demonstrates how to build a wallet structure on top of such a tree. <br> 该规范由两部分组成。 在第一部分中，提出了一种用于从单个种子导出密钥对树的系统。 第二部分演示了如何在这样的树顶部构建钱包结构。</p> 
  </blockquote> 
  <h2 id="part-i-密钥派生">part I 密钥派生</h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821171433331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 在下面，会定义一个从父密钥派生多个子密钥的函数，为了防止这些子密钥仅依赖密钥本省，我们首先使用额外的256位熵扩展私钥和公钥，这个被称为链码的扩展对于相应的私钥和公钥是相同的，由32个字节组成。 <br> 我们将扩展私钥表示为（k，c），k表示普通私钥，c表示链码；扩展公钥表示为（K，c）K表示point(k)</p> 
  <blockquote> 
   <p>point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the secp256k1 base point with the integer p.</p> 
  </blockquote> 
  <p>每个扩展密钥有2<sup>31</sup>个普通子密钥和2<sup>31</sup>个硬化子密钥，这些子密钥都有一个索引。普通子密钥使用索引0-2<sup>31</sup>，硬化子密钥使用2<sup>31</sup>-2<sup>32</sup>-1,为简化硬化子密钥的索引，用数字i<sub>H</sub>代表i+2<sup>31</sup> <br> 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。因此，有了子密钥并不能让它发现自己的姊妹密钥，除非 <br> 你已经有了链码。 <br> 来看这个函数 <br> 给定父扩展密钥和索引，可以计算相应的子密钥。这个算法的实现取决于子密钥是否是一个硬化的密钥（或者，等价与i&gt;=2<sup>31</sup>）,以及我们是否在讨论私钥或公钥。</p> 
  <blockquote> 
   <p>Child key derivation (CKD) functions <br> Given a parent extended key and an index i, it is possible to compute the corresponding child extended key. The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether i ≥ 231), and whether we’re talking about private or public keys. <br> <code>Private parent key → private child key</code>//父私钥到子私钥 <br> The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key: <br> 1.Check whether i ≥ 2<sup>31 </sup>(whether the child is a hardened key). <br> If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.) <br> If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)). <br> 2.Split I into two 32-byte sequences, IL and IR. <br> The returned child key ki is parse256(IL) + kpar (mod n). <br> The returned chain code ci is IR. <br> 3.In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2127.) <br> The HMAC-SHA512 function is specified in RFC 4231. <br> <code>Public parent key → public child key</code>//父公钥-&gt;子公钥 <br> The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.//只针对未硬化的子密钥定义 <br> Check whether i ≥ 2<sup>31</sup> (whether the child is a hardened key). <br> If so (hardened child): return failure <br> If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)). <br> Split I into two 32-byte sequences, IL and IR. <br> The returned child key Ki is point(parse256(IL)) + Kpar. <br> The returned chain code ci is IR. <br> In case parse256(IL) ≥ n or Ki is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i. <br> <code>Private parent key → public child key</code>//父私钥-&gt;子公钥 <br> The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions). <br> The returned key K is point(k). <br> The returned chain code c is just the passed chain code. <br> To compute the public child key of a parent private key: <br> N(CKDpriv((kpar, cpar), i)) (works always). <br> CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys). <br> <code>Public parent key → private child key</code>//不存在</p> 
  </blockquote> 
  <p>子密钥的派生函数，这段可以结合源码来看，对应Derive函数</p> 
  <hr> 
  <h3 id="setmaster">SetMaster</h3> 
  <p>seed-&gt;masterkey，主密钥生成，seed一般使用BIP39标准 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829114110951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 根种子输入到 HMAC-SHA512 算法中就可以得到一个可用来创造主私钥(m) (master private key(m) )和主链代码(a master chain code)的哈希。主私钥(m) 之后可以通过使用我们在本章先前看到的那个普通椭圆曲线 m * G 过程生来成相 对应的主公钥(M)。 链代码用于从母密钥中创造子密钥的那个函数中引入熵。</p> 
  <blockquote> 
   <p>Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG. <br> Calculate I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S) <br> Split I into two 32-byte sequences, IL and IR. <br> Use parse256(IL) as master secret key, and IR as master chain code</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> CExtKey::SetMaster(<span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">char</span> *seed, unsigned <span class="hljs-keyword">int</span> nSeedLen) {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">char</span> hashkey[] = {<span class="hljs-string">'B'</span>,<span class="hljs-string">'i'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'o'</span>,<span class="hljs-string">'i'</span>,<span class="hljs-string">'n'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'s'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'d'</span>};
    unsigned <span class="hljs-keyword">char</span> <span class="hljs-keyword">out</span>[<span class="hljs-number">64</span>];
    LockObject(<span class="hljs-keyword">out</span>);
    CHMAC_SHA512(hashkey, <span class="hljs-keyword">sizeof</span>(hashkey)).Write(seed, nSeedLen).Finalize(<span class="hljs-keyword">out</span>);
    key.Set(&amp;<span class="hljs-keyword">out</span>[<span class="hljs-number">0</span>], &amp;<span class="hljs-keyword">out</span>[<span class="hljs-number">32</span>], <span class="hljs-keyword">true</span>);
    memcpy(chaincode.begin(), &amp;<span class="hljs-keyword">out</span>[<span class="hljs-number">32</span>], <span class="hljs-number">32</span>);
    UnlockObject(<span class="hljs-keyword">out</span>);
    nDepth = <span class="hljs-number">0</span>;<span class="hljs-comment">//表示master node</span>
    nChild = <span class="hljs-number">0</span>;<span class="hljs-comment">//还没有子密钥</span>
    memset(vchFingerprint, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vchFingerprint));<span class="hljs-comment">//指纹初始化为0</span>
}</code></pre> 
  <blockquote> 
   <p><code>memcpy</code>:memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 <br> void *memcpy(void *dest, const void *src, size_t n) <br> <code>memset</code>:memset是计算机中C/C++语言初始化函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。</p> 
  </blockquote> 
  <p>首先调用CHMAC_SHA512，</p> 
  <blockquote> 
   <p>HMAC-SHA-512 is the realization of the HMAC message authentication code using the SHA-512 hash function. <br> HMAC-SHA-512是使用SHA-512哈希函数实现HMAC消息认证码。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cpp">CHMAC_SHA512::CHMAC_SHA512(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* key, size_t keylen)
{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> rkey[<span class="hljs-number">128</span>];
    <span class="hljs-keyword">if</span> (keylen &lt;= <span class="hljs-number">128</span>) {
        <span class="hljs-built_in">memcpy</span>(rkey, key, keylen);
        <span class="hljs-built_in">memset</span>(rkey + keylen, <span class="hljs-number">0</span>, <span class="hljs-number">128</span> - keylen);<span class="hljs-comment">//其余位初始化为0</span>
    } <span class="hljs-keyword">else</span> {
        CSHA512().Write(key, keylen).Finalize(rkey);
        <span class="hljs-built_in">memset</span>(rkey + <span class="hljs-number">64</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>);
    }
<span class="hljs-comment">//每个字符做异或操作</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">128</span>; n++)
        rkey[n] ^= <span class="hljs-number">0x5c</span>;
    outer.Write(rkey, <span class="hljs-number">128</span>);<span class="hljs-comment">//CSHA512 outer</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">128</span>; n++)
        rkey[n] ^= <span class="hljs-number">0x5c</span> ^ <span class="hljs-number">0x36</span>;<span class="hljs-comment">//抵消0x5c，等于原 rkey[n]^0x36</span>
    inner.Write(rkey, <span class="hljs-number">128</span>);<span class="hljs-comment">//CSHA512 inner</span>
}</code></pre> 
  <p>这里调用的write是CSHA512::Write，具体步骤不介绍了</p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//src/crypto/sha512.cpp</span>
CSHA512<span class="hljs-subst">&amp;</span> CSHA512<span class="hljs-tag">::Write</span>(const unsigned char<span class="hljs-subst">*</span> <span class="hljs-built_in">data</span>, size_t len)
{
    const unsigned char<span class="hljs-subst">*</span> end <span class="hljs-subst">=</span> <span class="hljs-built_in">data</span> <span class="hljs-subst">+</span> len;
    size_t bufsize <span class="hljs-subst">=</span> <span class="hljs-built_in">bytes</span> <span class="hljs-subst">%</span> <span class="hljs-number">128</span>;
    <span class="hljs-keyword">if</span> (bufsize <span class="hljs-subst">&amp;&amp;</span> bufsize <span class="hljs-subst">+</span> len <span class="hljs-subst">&gt;=</span> <span class="hljs-number">128</span>) {
        <span class="hljs-comment">// Fill the buffer, and process it.</span>
        memcpy(buf <span class="hljs-subst">+</span> bufsize, <span class="hljs-built_in">data</span>, <span class="hljs-number">128</span> <span class="hljs-subst">-</span> bufsize);
        <span class="hljs-built_in">bytes</span> <span class="hljs-subst">+=</span> <span class="hljs-number">128</span> <span class="hljs-subst">-</span> bufsize;
        <span class="hljs-built_in">data</span> <span class="hljs-subst">+=</span> <span class="hljs-number">128</span> <span class="hljs-subst">-</span> bufsize;
        sha512<span class="hljs-tag">::Transform</span>(s, buf);
        bufsize <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">while</span> (end <span class="hljs-subst">&gt;=</span> <span class="hljs-built_in">data</span> <span class="hljs-subst">+</span> <span class="hljs-number">128</span>) {
        <span class="hljs-comment">// Process full chunks directly from the source.</span>
        sha512<span class="hljs-tag">::Transform</span>(s, <span class="hljs-built_in">data</span>);
        <span class="hljs-built_in">data</span> <span class="hljs-subst">+=</span> <span class="hljs-number">128</span>;
        <span class="hljs-built_in">bytes</span> <span class="hljs-subst">+=</span> <span class="hljs-number">128</span>;
    }
    <span class="hljs-keyword">if</span> (end <span class="hljs-subst">&gt;</span> <span class="hljs-built_in">data</span>) {
        <span class="hljs-comment">// Fill the buffer with what remains.</span>
        memcpy(buf <span class="hljs-subst">+</span> bufsize, <span class="hljs-built_in">data</span>, end <span class="hljs-subst">-</span> <span class="hljs-built_in">data</span>);
        <span class="hljs-built_in">bytes</span> <span class="hljs-subst">+=</span> end <span class="hljs-subst">-</span> <span class="hljs-built_in">data</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-subst">*</span>this;
}</code></pre> 
  <h3 id="derive">Derive</h3> 
  <blockquote> 
   <p>Key identifiers <br> Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256) of the serialized ECDSA public key K, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses. It is not advised to represent this data in base58 format though, as it may be interpreted as an address that way (and wallet software is not required to accept payment to the chain key itself).</p> 
  </blockquote> 
  <p>The first 32 bits of the identifier are called the key fingerprint.</p> 
  <pre class="prettyprint"><code class=" hljs d"><span class="hljs-comment">//key.cpp</span>
<span class="hljs-built_in">bool</span> CExtKey::Derive(CExtKey &amp;<span class="hljs-keyword">out</span>, unsigned <span class="hljs-keyword">int</span> nChild) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">out</span>.nDepth = nDepth + <span class="hljs-number">1</span>;<span class="hljs-comment">//深度加一</span>
    CKeyID id = key.GetPubKey().GetID();<span class="hljs-comment">//密钥标识符,GetID函数就是取Hash160</span>
    memcpy(&amp;<span class="hljs-keyword">out</span>.vchFingerprint[<span class="hljs-number">0</span>], &amp;id, <span class="hljs-number">4</span>);<span class="hljs-comment">//标识符的前32位称为密钥指纹</span>
    <span class="hljs-keyword">out</span>.nChild = nChild;
    <span class="hljs-keyword">return</span> key.Derive(<span class="hljs-keyword">out</span>.key, <span class="hljs-keyword">out</span>.chaincode, nChild, chaincode);
}
<span class="hljs-built_in">bool</span> CKey::Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned <span class="hljs-keyword">int</span> nChild, <span class="hljs-keyword">const</span> ChainCode&amp; cc) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">assert</span>(IsValid());
    <span class="hljs-keyword">assert</span>(IsCompressed());
    unsigned <span class="hljs-built_in">char</span> <span class="hljs-keyword">out</span>[<span class="hljs-number">64</span>];
    LockObject(<span class="hljs-keyword">out</span>);
    <span class="hljs-comment">//1.Check whether i ≥ 2&lt;sup&gt;31 &lt;/sup&gt;(whether the child is a hardened key).</span>
    <span class="hljs-keyword">if</span> ((nChild &gt;&gt; <span class="hljs-number">31</span>) == <span class="hljs-number">0</span>) {
        CPubKey pubkey = GetPubKey();
        <span class="hljs-keyword">assert</span>(pubkey.begin() + <span class="hljs-number">33</span> == pubkey.end());
        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+<span class="hljs-number">1</span>, <span class="hljs-keyword">out</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">assert</span>(begin() + <span class="hljs-number">32</span> == end());
        BIP32Hash(cc, nChild, <span class="hljs-number">0</span>, begin(), <span class="hljs-keyword">out</span>);
    }
   <span class="hljs-comment">//2. Split I into two 32-byte sequences, IL and IR.</span>
    memcpy(ccChild.begin(), <span class="hljs-keyword">out</span>+<span class="hljs-number">32</span>, <span class="hljs-number">32</span>);
    memcpy((unsigned <span class="hljs-built_in">char</span>*)keyChild.begin(), begin(), <span class="hljs-number">32</span>);
    <span class="hljs-comment">//3.</span>
    <span class="hljs-built_in">bool</span> ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned <span class="hljs-built_in">char</span>*)keyChild.begin(), <span class="hljs-keyword">out</span>);
    UnlockObject(<span class="hljs-keyword">out</span>);
    keyChild.fCompressed = <span class="hljs-literal">true</span>;
    keyChild.fValid = ret;
    <span class="hljs-keyword">return</span> ret;
}</code></pre> 
  <h3 id="序列化格式">序列化格式</h3> 
  <blockquote> 
   <p>密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。 这只需要三个输入量:一个密钥，一个链码以及想要的子密钥的索引。密钥以及 链码这两个重要的部分被结合之后，就叫做扩展密钥(extended key)。术语 “extended key”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。</p> 
  </blockquote> 
  <p>扩展的私钥</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//key.cpp</span>
<span class="hljs-keyword">struct</span> CExtKey {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> nDepth;<span class="hljs-comment">//深度</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> vchFingerprint[<span class="hljs-number">4</span>];<span class="hljs-comment">//父密钥的指纹</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nChild;
    ChainCode chaincode;<span class="hljs-comment">//链码</span>
    CKey key;<span class="hljs-comment">//私钥</span>
    ...</code></pre> 
  <blockquote> 
   <p>4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private) <br> 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, …. <br> 4 bytes: the fingerprint of the parent’s key (0x00000000 if master key) <br> 4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key) <br> 32 bytes: the chain code <br> 33 bytes: the public key or private key data (serP(K) for public keys, 0x00 || ser256(k) for private keys)</p> 
   <p>这种78字节结构可以像Base58中的其他比特币数据一样进行编码，首先添加32个校验和位（从双SHA-256校验和中导出），然后转换为Base58表示。 这导致Base58编码的字符串最多112个字符。 由于版本字节的选择，Base58表示将在主网上以“xprv”或“xpub”开头，在testnet上以“tprv”或“tpub”开头。 <br> 扩展的公钥结构也是类似的。</p> 
  </blockquote> 
  <h3 id="特点">特点</h3> 
  <p>分层确定性钱包的一个很有用的特点就是可以 不通过私钥而直接从公共母密钥派生出公共子密钥的能 力。这就给了我们两种衍 生子公钥的方法:或者通过子私钥，再或者就是直接通过母公钥。 <br> 这种快捷方式可以用来创造非常保密的只有公钥配置。在配置中，服务器或者应用程序不管有没有私钥，都可以有扩展公钥的副本。这种配置可以创造出无限数量的公钥以及比特币地址。但是发送到这个地址里的任何比特币都不能使用。与此同时，在另一种更保险的服务器上，扩展私钥可以衍生出所有的对应的可签署交易以及花钱的私钥。</p> 
  <pre class="prettyprint"><code class=" hljs d"><span class="hljs-built_in">bool</span> CPubKey::Derive(CPubKey&amp; pubkeyChild, ChainCode &amp;ccChild, unsigned <span class="hljs-keyword">int</span> nChild, <span class="hljs-keyword">const</span> ChainCode&amp; cc) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">assert</span>(IsValid());
    <span class="hljs-keyword">assert</span>((nChild &gt;&gt; <span class="hljs-number">31</span>) == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">assert</span>(begin() + <span class="hljs-number">33</span> == end());
    unsigned <span class="hljs-built_in">char</span> <span class="hljs-keyword">out</span>[<span class="hljs-number">64</span>];
    BIP32Hash(cc, nChild, *begin(), begin()+<span class="hljs-number">1</span>, <span class="hljs-keyword">out</span>);
    memcpy(ccChild.begin(), <span class="hljs-keyword">out</span>+<span class="hljs-number">32</span>, <span class="hljs-number">32</span>);
    secp256k1_pubkey pubkey;
    <span class="hljs-keyword">if</span> (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &amp;pubkey, &amp;(*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>], size())) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &amp;pubkey, <span class="hljs-keyword">out</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    unsigned <span class="hljs-built_in">char</span> pub[<span class="hljs-number">33</span>];
    size_t publen = <span class="hljs-number">33</span>;
    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &amp;publen, &amp;pubkey, SECP256K1_EC_COMPRESSED);
    pubkeyChild.Set(pub, pub + publen);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre> 
  <p>关于硬化 <br> 前面在派生的子密钥的时候有对密钥是否硬化做的判断，这里介绍下硬化</p> 
  <blockquote> 
   <p>从扩展公钥衍生一个分支公钥的能力是很重要的，但牵扯一些风险。访问扩展公钥并不能得到访问子私钥的途径。但是，因为扩展公钥包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。简单地泄露的私钥以及一个母链码，可以暴露所有的子密钥。更糟糕的是，子私钥与母链码可以用来推断母私钥。 <br> 为了应对这种风险，HD 钱包使用一种叫做硬化衍生(hardened derivation)的替代 衍生函数。这就“打破”了母公钥以及子链码之间的关系。这个硬化衍生函数使用 了母私钥去推导子链码，而不是母公钥。这就在母/子顺序中创造了一道“防火 墙”——有链码但并不能够用来推算子链码或者姊妹私钥。强化衍生函数看起来几 乎与一般的衍生的子私钥相同，不同的是母私钥被用来输入散列函数中而不是母公钥。 <br> 简单地来说，如果你想要利用扩展公钥的便捷来衍生公钥的分支而不将你自己暴 露在泄露扩展链码的风险下， 你应该从强化母私钥衍生公钥，而不是从一般的母 私钥来衍生。最好的方式是，为了避免了推到出主密钥，主密钥所衍生的第一层 级的子密钥最好使用强化衍生。</p> 
  </blockquote> 
  <hr> 
  <h2 id="part-ii-钱包结构">part II 钱包结构</h2> 
  <p>客户端要求具备兼容性，即使不支持所有功能。</p> 
  <h3 id="缺省的钱包结构">缺省的钱包结构</h3> 
  <p>HDW（分层确定性钱包）被组织为几个“帐户”。 帐户已编号，默认帐户（“”）为数字0.客户端不需要支持多个帐户 - 如果不支持，则仅使用默认帐户。 <br> 由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以 “M“打头。因此，母密钥生成的第一个子私钥是 m/0。第一个公钥是 M/0。第一 个子密钥的子密钥就是 m/0/1，以此类推。 <br> 每个帐户由两个密钥对链组成：内部和外部链。 外部钥匙串用于生成新的公共地址，而内部钥匙串用于所有其他操作（更改地址，生成地址，……，任何不需要通信的内容）。 不支持单独的钥匙串的客户端应该使用外部钥匙链。 <br> m / i<sub>H </sub>/ 0 / k对应于从主m导出的HDW的帐号i的外链的第k个密钥对。 <br> m / i<sub>H</sub>/ 1 / k对应于从主m导出的HDW的帐号i的内部链的第k个密钥对。</p> 
  <h3 id="兼容性">兼容性</h3> 
  <p>为了符合此标准，客户端必须至少能够导入扩展的公钥或私钥，以便将其直接后代作为钱包密钥进行访问。 在规范的第二部分中提供的钱包结构（主/帐户/链/子链）仅供参考，但建议作为最小结构以便于兼容 - 即使没有单独的帐户或内部链和外部链之间的区别。 但是，实现可能会因特定需求而偏离它; 更复杂的应用程序可能需要更复杂的树结构。</p> 
  <hr> 
  <h1 id="bip44">BIP44</h1> 
  <p>文档<a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" rel="nofollow">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a> <br> 该BIP基于BIP-0032（从现在开始的BIP32）和BIP-0043（从现在开始的BIP43）中描述的目的方案中描述的算法定义确定性钱包的逻辑层级。</p> 
  <blockquote> 
   <p>HD 钱包树状结构提供了极大的灵活性。每一个母扩展密钥有 40 亿个子密钥:20 亿个常规子密钥和 20 亿个强化子密钥。而每个子密钥又会有 40 亿个子密钥并 且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。尤其是对于在不同的HD钱包之间进行转移交易，因为内部组织到内部分支以及亚分支的可能性是无穷的 <br> BIP-43 提出使用第一个强化子索引作为特殊的标识符表示 树状结构的“purpose”。基于 BIP-43，HD 钱包应该使用且只用第一层级的树的分 支，而且有索引号码去识别结构并且有命名空间来定义剩余的树的目的地。举个 例子，HD 钱包只使用分支 m/i’/是 为了表明那个被索引号“i”定义的特殊为目地。</p> 
  </blockquote> 
  <p>在 BIP-43 标准下，为了延长的那个特殊规范，BIP-44 提议了多账户结构作为 “purpose”。所有遵循 BIP-44 的 HD 钱包依据只使用树的第一个分支的要求而被定 义:m/44’/。 BIP-44 指定了包含 5 个预定义树状层级的结构: <br> 第一层的 purpose 总是被设定为 44’。</p> 
  <p>第二层的“coin_type”特指币种并且允许多元货币 HD 钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义:Bitcoin is m/44’/0’、Bitcoin Testnet is m/44’/1’，以及 Litecoin is m/44’/2’。 <br> 完整注册硬币类型列表<a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md" rel="nofollow">https://github.com/satoshilabs/slips/blob/master/slip-0044.md</a></p> 
  <p>第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细 分他们的钱包到独立的逻辑性亚账户。 举个例子，一个 HD 钱包可能包含两个比 特币“账户”:m/44’/0’/0’ 和 m/44’/0’/1’。每个账户都是它自己亚树的根。</p> 
  <p>第四层级就是“change”。每一个 HD 钱包有两个亚树，一个是用来接收地址一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都 是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p> 
  <p>被 HD 钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的 “address_index”。比如，第三个层级的主账户收到比特币支付的地址就是 M/44’/0’/0’/0/2。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82011876,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82011876,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82011876,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/82011876,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
