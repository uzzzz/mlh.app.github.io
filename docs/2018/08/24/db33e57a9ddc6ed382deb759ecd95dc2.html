<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链：Solidity值类型(地址Address) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链：Solidity值类型(地址Address)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wtdask/article/details/82020705 地址Address 以太坊钱包地址位数验证 以太坊中的地址的长度为20字节，一字节等于8位，一共160位，所以address其实亦可以用uint160来声明。 我的以太坊钱包地址为0xDF12793CA392ff748adF013D146f8dA73df6E304，0x代表十六进制，我们将DF12793CA392ff748adF013D146f8dA73df6E304拷贝，如下图所示，将其进行二进制转换，不难发现，它的二进制刚好160位。 备注：以太坊钱包地址是以16进制的形式呈现，我们知道一个十六进制的数字等于4个字节，160 ／ 4 = 40，你自己验证一下，钱包地址DF12793CA392ff748adF013D146f8dA73df6E304的长度为40。 以太坊钱包地址 0xDF12793CA392ff748adF013D146f8dA73df6E304 通过工具对应的二进制为： 1101111100010010011110010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ps：通过工具转换的二进制可能存在问题，可以自己尝试转换。 pragma solidity ^0.4.4; contract test { address _owner; uint160 _ownerUint; function test() { _owner = 0xDF12793CA392ff748adF013D146f8dA73df6E304; _ownerUint = 1273516916528256943268872459582090959717186069252; } function owner() constant returns (address) { return _owner; } function ownerUint160() constant returns(uint160){ //转换10进制 1273516916528256943268872459582090959717186069252 return uint160(_owner); } function ownerUintToAddress() constant returns (address) { return address(_ownerUint); } } //0x 16进制 45 //B 2进制 0100 0101 //1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 //1 + 0 + 4 + 0 + 0 + 0 + 64 + 0 = 69 //D 10进制 69 //0x DF12793CA392ff748adF013D146f8dA73df6E304 //D 转换10进制 1273516916528256943268872459582090959717186069252 //1 2 3 4 5 6 7 8 9 A B C D E F //40个 * 4位(二进制) =160位 //1101 1111 0001 0010 0111 10010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 //1+4+8=13 D 1+2+4+8=15 F 1 2 1+2+4=7 .... //address //uint160 不可不知的几个常识 合约拥有者 msg.sender就是当前调用方法时的发起人，一个合约部署后，通过钱包地址操作合约的人很多，但是如何正确判断谁是合约的拥有者，判断方式很简单，就是第一次部署合约时，谁出的gas，谁就对合约具有拥有权。 pragma solidity ^0.4.4; contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } } //0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C 合约地址 pragma solidity ^0.4.4; // 0x903ad08970c70d10e5fb5b3c26f7b714830afcf6 // 0x62e40877f4747e06197aa1a2b9ac06dd9bb244a3 // 0xf055775ebd516e7419ae486c1d50c682d4170645 // 0xe7795e05d15f7406baf411cafe766fc28eccf35f // 0xe7795e05d15f7406baf411cafe766fc28eccf35f contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } function returnContractAddress() constant returns (address) { return this; } } 一个合约部署后，会有一个合约地址，这个合约地址就代表合约自己。 this在合约中到底是msg.sender还是合约地址，由上图不难看出，this即是当前合约地址。 部署 在Remix网页编辑器中点击部署(Deploy)按钮 点击插件的submit 显示部署挖矿成功，钱包中的测试以太币也相应的减去部署需要花费的gas 支持的运算符 pragma solidity ^0.4.4; contract Test { address address1; address address2; // &lt;=，&lt;，==，!=，&gt;=和&gt; function Test() { address1 = 0xF055775eBD516e7419ae486C1d50C682d4170645; address2 = 0xEAEC9B481c60e8cDc3cdF2D342082C349E5D6318; } // &lt;= function test1() constant returns (bool) { return address1 &lt;= address2; } // &lt; function test2() constant returns (bool) { return address1 &lt; address2; } // != function test3() constant returns (bool) { return address1 != address2; } // &gt;= function test4() constant returns (bool) { return address1 &gt;= address2; } // &gt; function test5() constant returns (bool) { return address1 &gt; address2; } } &lt;=，&lt;，==，!=，&gt;=，&gt; 成员变量和函数 一、 balance 如果我们需要查看一个地址的余额，我们可以使用balance属性进行查看。 pragma solidity ^0.4.4; contract addressBalance{ function getBalance(address addr) constant returns (uint){ return addr.balance; } } 在Account一栏中，会自动生成测试钱包地址供我们测试使用，在我们点击Deploy按钮时，Account一栏选中的是钱包地址，我们部署合约时，花费的gas就从这个钱包地址里面扣除，【PS：这5个钱包地址每次都是系统临时生成，所以在我们开发测试过程中，每次的地址不会相同】。因为在本案例中，我们部署合约时，用的是第一个Account，所以gas自然从它里面扣除，大家会发现，其它四个钱包地址中的余额是ether，而第一个钱包地址中不到100个ether。 当我们点击getBalance获取某个钱包地址的余额时，获取到的余额的单位是Wei，一个ether等于1000000000000000000Wei，Wei是最小单位，相当于我们的1元RMB等于100分。【PS：1ether等于10的18次方Wei】 99999999999996890347 wei == 99.999999999996890347 ether 二、this 查看当前合约地址余额 pragma solidity ^0.4.4; contract addressBalance{ function getBalance() constant returns (uint){ return this.balance; } function getContractAddrees() constant returns (address){ return this; } function getBalance(address addr) constant returns (uint){ return addr.balance; } } 三、transfer transfer：从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，代码将抛出异常并停止转账。 pragma solidity ^0.4.4; contract PayableKeyword{ // 从合约发起方向 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址转入 msg.value 个以太币，单位是 wei function deposit() payable{ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; Account2.transfer(msg.value); } // 读取 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址的余额 function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } // 读取合约发起方的余额 function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } } 四、send send：send相对transfer方法较底层，不过使用方法和transfer相同，都是从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，send不会抛出异常，而是直接返回false。 pragma solidity ^0.4.4; contract PayableKeyword{ function deposit() payable returns (bool){ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.send(msg.value); } function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } ⚠️Warning send()方法执行时有一些风险 调用递归深度不能超1024。 如果gas不够，执行会失败。 所以使用这个方法要检查成功与否。 transfer相对send较安全 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wtdask/article/details/82020705 地址Address 以太坊钱包地址位数验证 以太坊中的地址的长度为20字节，一字节等于8位，一共160位，所以address其实亦可以用uint160来声明。 我的以太坊钱包地址为0xDF12793CA392ff748adF013D146f8dA73df6E304，0x代表十六进制，我们将DF12793CA392ff748adF013D146f8dA73df6E304拷贝，如下图所示，将其进行二进制转换，不难发现，它的二进制刚好160位。 备注：以太坊钱包地址是以16进制的形式呈现，我们知道一个十六进制的数字等于4个字节，160 ／ 4 = 40，你自己验证一下，钱包地址DF12793CA392ff748adF013D146f8dA73df6E304的长度为40。 以太坊钱包地址 0xDF12793CA392ff748adF013D146f8dA73df6E304 通过工具对应的二进制为： 1101111100010010011110010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ps：通过工具转换的二进制可能存在问题，可以自己尝试转换。 pragma solidity ^0.4.4; contract test { address _owner; uint160 _ownerUint; function test() { _owner = 0xDF12793CA392ff748adF013D146f8dA73df6E304; _ownerUint = 1273516916528256943268872459582090959717186069252; } function owner() constant returns (address) { return _owner; } function ownerUint160() constant returns(uint160){ //转换10进制 1273516916528256943268872459582090959717186069252 return uint160(_owner); } function ownerUintToAddress() constant returns (address) { return address(_ownerUint); } } //0x 16进制 45 //B 2进制 0100 0101 //1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 //1 + 0 + 4 + 0 + 0 + 0 + 64 + 0 = 69 //D 10进制 69 //0x DF12793CA392ff748adF013D146f8dA73df6E304 //D 转换10进制 1273516916528256943268872459582090959717186069252 //1 2 3 4 5 6 7 8 9 A B C D E F //40个 * 4位(二进制) =160位 //1101 1111 0001 0010 0111 10010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 //1+4+8=13 D 1+2+4+8=15 F 1 2 1+2+4=7 .... //address //uint160 不可不知的几个常识 合约拥有者 msg.sender就是当前调用方法时的发起人，一个合约部署后，通过钱包地址操作合约的人很多，但是如何正确判断谁是合约的拥有者，判断方式很简单，就是第一次部署合约时，谁出的gas，谁就对合约具有拥有权。 pragma solidity ^0.4.4; contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } } //0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C 合约地址 pragma solidity ^0.4.4; // 0x903ad08970c70d10e5fb5b3c26f7b714830afcf6 // 0x62e40877f4747e06197aa1a2b9ac06dd9bb244a3 // 0xf055775ebd516e7419ae486c1d50c682d4170645 // 0xe7795e05d15f7406baf411cafe766fc28eccf35f // 0xe7795e05d15f7406baf411cafe766fc28eccf35f contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } function returnContractAddress() constant returns (address) { return this; } } 一个合约部署后，会有一个合约地址，这个合约地址就代表合约自己。 this在合约中到底是msg.sender还是合约地址，由上图不难看出，this即是当前合约地址。 部署 在Remix网页编辑器中点击部署(Deploy)按钮 点击插件的submit 显示部署挖矿成功，钱包中的测试以太币也相应的减去部署需要花费的gas 支持的运算符 pragma solidity ^0.4.4; contract Test { address address1; address address2; // &lt;=，&lt;，==，!=，&gt;=和&gt; function Test() { address1 = 0xF055775eBD516e7419ae486C1d50C682d4170645; address2 = 0xEAEC9B481c60e8cDc3cdF2D342082C349E5D6318; } // &lt;= function test1() constant returns (bool) { return address1 &lt;= address2; } // &lt; function test2() constant returns (bool) { return address1 &lt; address2; } // != function test3() constant returns (bool) { return address1 != address2; } // &gt;= function test4() constant returns (bool) { return address1 &gt;= address2; } // &gt; function test5() constant returns (bool) { return address1 &gt; address2; } } &lt;=，&lt;，==，!=，&gt;=，&gt; 成员变量和函数 一、 balance 如果我们需要查看一个地址的余额，我们可以使用balance属性进行查看。 pragma solidity ^0.4.4; contract addressBalance{ function getBalance(address addr) constant returns (uint){ return addr.balance; } } 在Account一栏中，会自动生成测试钱包地址供我们测试使用，在我们点击Deploy按钮时，Account一栏选中的是钱包地址，我们部署合约时，花费的gas就从这个钱包地址里面扣除，【PS：这5个钱包地址每次都是系统临时生成，所以在我们开发测试过程中，每次的地址不会相同】。因为在本案例中，我们部署合约时，用的是第一个Account，所以gas自然从它里面扣除，大家会发现，其它四个钱包地址中的余额是ether，而第一个钱包地址中不到100个ether。 当我们点击getBalance获取某个钱包地址的余额时，获取到的余额的单位是Wei，一个ether等于1000000000000000000Wei，Wei是最小单位，相当于我们的1元RMB等于100分。【PS：1ether等于10的18次方Wei】 99999999999996890347 wei == 99.999999999996890347 ether 二、this 查看当前合约地址余额 pragma solidity ^0.4.4; contract addressBalance{ function getBalance() constant returns (uint){ return this.balance; } function getContractAddrees() constant returns (address){ return this; } function getBalance(address addr) constant returns (uint){ return addr.balance; } } 三、transfer transfer：从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，代码将抛出异常并停止转账。 pragma solidity ^0.4.4; contract PayableKeyword{ // 从合约发起方向 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址转入 msg.value 个以太币，单位是 wei function deposit() payable{ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; Account2.transfer(msg.value); } // 读取 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址的余额 function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } // 读取合约发起方的余额 function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } } 四、send send：send相对transfer方法较底层，不过使用方法和transfer相同，都是从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，send不会抛出异常，而是直接返回false。 pragma solidity ^0.4.4; contract PayableKeyword{ function deposit() payable returns (bool){ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.send(msg.value); } function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } ⚠️Warning send()方法执行时有一些风险 调用递归深度不能超1024。 如果gas不够，执行会失败。 所以使用这个方法要检查成功与否。 transfer相对send较安全 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/24/db33e57a9ddc6ed382deb759ecd95dc2.html" />
<meta property="og:url" content="https://mlh.app/2018/08/24/db33e57a9ddc6ed382deb759ecd95dc2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wtdask/article/details/82020705 地址Address 以太坊钱包地址位数验证 以太坊中的地址的长度为20字节，一字节等于8位，一共160位，所以address其实亦可以用uint160来声明。 我的以太坊钱包地址为0xDF12793CA392ff748adF013D146f8dA73df6E304，0x代表十六进制，我们将DF12793CA392ff748adF013D146f8dA73df6E304拷贝，如下图所示，将其进行二进制转换，不难发现，它的二进制刚好160位。 备注：以太坊钱包地址是以16进制的形式呈现，我们知道一个十六进制的数字等于4个字节，160 ／ 4 = 40，你自己验证一下，钱包地址DF12793CA392ff748adF013D146f8dA73df6E304的长度为40。 以太坊钱包地址 0xDF12793CA392ff748adF013D146f8dA73df6E304 通过工具对应的二进制为： 1101111100010010011110010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ps：通过工具转换的二进制可能存在问题，可以自己尝试转换。 pragma solidity ^0.4.4; contract test { address _owner; uint160 _ownerUint; function test() { _owner = 0xDF12793CA392ff748adF013D146f8dA73df6E304; _ownerUint = 1273516916528256943268872459582090959717186069252; } function owner() constant returns (address) { return _owner; } function ownerUint160() constant returns(uint160){ //转换10进制 1273516916528256943268872459582090959717186069252 return uint160(_owner); } function ownerUintToAddress() constant returns (address) { return address(_ownerUint); } } //0x 16进制 45 //B 2进制 0100 0101 //1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 //1 + 0 + 4 + 0 + 0 + 0 + 64 + 0 = 69 //D 10进制 69 //0x DF12793CA392ff748adF013D146f8dA73df6E304 //D 转换10进制 1273516916528256943268872459582090959717186069252 //1 2 3 4 5 6 7 8 9 A B C D E F //40个 * 4位(二进制) =160位 //1101 1111 0001 0010 0111 10010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 //1+4+8=13 D 1+2+4+8=15 F 1 2 1+2+4=7 .... //address //uint160 不可不知的几个常识 合约拥有者 msg.sender就是当前调用方法时的发起人，一个合约部署后，通过钱包地址操作合约的人很多，但是如何正确判断谁是合约的拥有者，判断方式很简单，就是第一次部署合约时，谁出的gas，谁就对合约具有拥有权。 pragma solidity ^0.4.4; contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } } //0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C 合约地址 pragma solidity ^0.4.4; // 0x903ad08970c70d10e5fb5b3c26f7b714830afcf6 // 0x62e40877f4747e06197aa1a2b9ac06dd9bb244a3 // 0xf055775ebd516e7419ae486c1d50c682d4170645 // 0xe7795e05d15f7406baf411cafe766fc28eccf35f // 0xe7795e05d15f7406baf411cafe766fc28eccf35f contract Test { address public _owner; uint public _number; function Test() { _owner = msg.sender; _number = 100; } function msgSenderAddress() constant returns (address) { return msg.sender; } function setNumberAdd1() { _number = _number + 5; } function setNumberAdd2() { if (_owner == msg.sender) { _number = _number + 10; } } function returnContractAddress() constant returns (address) { return this; } } 一个合约部署后，会有一个合约地址，这个合约地址就代表合约自己。 this在合约中到底是msg.sender还是合约地址，由上图不难看出，this即是当前合约地址。 部署 在Remix网页编辑器中点击部署(Deploy)按钮 点击插件的submit 显示部署挖矿成功，钱包中的测试以太币也相应的减去部署需要花费的gas 支持的运算符 pragma solidity ^0.4.4; contract Test { address address1; address address2; // &lt;=，&lt;，==，!=，&gt;=和&gt; function Test() { address1 = 0xF055775eBD516e7419ae486C1d50C682d4170645; address2 = 0xEAEC9B481c60e8cDc3cdF2D342082C349E5D6318; } // &lt;= function test1() constant returns (bool) { return address1 &lt;= address2; } // &lt; function test2() constant returns (bool) { return address1 &lt; address2; } // != function test3() constant returns (bool) { return address1 != address2; } // &gt;= function test4() constant returns (bool) { return address1 &gt;= address2; } // &gt; function test5() constant returns (bool) { return address1 &gt; address2; } } &lt;=，&lt;，==，!=，&gt;=，&gt; 成员变量和函数 一、 balance 如果我们需要查看一个地址的余额，我们可以使用balance属性进行查看。 pragma solidity ^0.4.4; contract addressBalance{ function getBalance(address addr) constant returns (uint){ return addr.balance; } } 在Account一栏中，会自动生成测试钱包地址供我们测试使用，在我们点击Deploy按钮时，Account一栏选中的是钱包地址，我们部署合约时，花费的gas就从这个钱包地址里面扣除，【PS：这5个钱包地址每次都是系统临时生成，所以在我们开发测试过程中，每次的地址不会相同】。因为在本案例中，我们部署合约时，用的是第一个Account，所以gas自然从它里面扣除，大家会发现，其它四个钱包地址中的余额是ether，而第一个钱包地址中不到100个ether。 当我们点击getBalance获取某个钱包地址的余额时，获取到的余额的单位是Wei，一个ether等于1000000000000000000Wei，Wei是最小单位，相当于我们的1元RMB等于100分。【PS：1ether等于10的18次方Wei】 99999999999996890347 wei == 99.999999999996890347 ether 二、this 查看当前合约地址余额 pragma solidity ^0.4.4; contract addressBalance{ function getBalance() constant returns (uint){ return this.balance; } function getContractAddrees() constant returns (address){ return this; } function getBalance(address addr) constant returns (uint){ return addr.balance; } } 三、transfer transfer：从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，代码将抛出异常并停止转账。 pragma solidity ^0.4.4; contract PayableKeyword{ // 从合约发起方向 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址转入 msg.value 个以太币，单位是 wei function deposit() payable{ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; Account2.transfer(msg.value); } // 读取 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址的余额 function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } // 读取合约发起方的余额 function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } } 四、send send：send相对transfer方法较底层，不过使用方法和transfer相同，都是从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，send不会抛出异常，而是直接返回false。 pragma solidity ^0.4.4; contract PayableKeyword{ function deposit() payable returns (bool){ address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.send(msg.value); } function getAccount2Balance() constant returns (uint) { address Account2 = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; return Account2.balance; } function getOwnerBalance() constant returns (uint) { address Owner = msg.sender; return Owner.balance; } ⚠️Warning send()方法执行时有一些风险 调用递归深度不能超1024。 如果gas不够，执行会失败。 所以使用这个方法要检查成功与否。 transfer相对send较安全 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/24/db33e57a9ddc6ed382deb759ecd95dc2.html","headline":"区块链：Solidity值类型(地址Address)","dateModified":"2018-08-24T00:00:00+08:00","datePublished":"2018-08-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/24/db33e57a9ddc6ed382deb759ecd95dc2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链：Solidity值类型(地址Address)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/wtdask/article/details/82020705 
 </div> 
 <div class="markdown_views"> 
  <h2 id="地址address">地址Address</h2> 
  <p><strong>以太坊钱包地址位数验证</strong></p> 
  <p>以太坊中的地址的长度为<code>20字节</code>，<code>一字节等于8位</code>，一共<code>160位</code>，所以<code>address</code>其实亦可以用<code>uint160</code>来声明。</p> 
  <p>我的以太坊钱包地址为<code>0xDF12793CA392ff748adF013D146f8dA73df6E304</code>，<code>0x</code>代表<code>十六进制</code>，我们将<code>DF12793CA392ff748adF013D146f8dA73df6E304</code>拷贝，如下图所示，将其进行二进制转换，不难发现，它的二进制刚好<code>160位</code>。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824103657414?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>备注：以<code>太坊钱包地址</code>是以<code>16进制</code>的形式呈现，我们知道一个<code>十六进制的数字等于4个字节</code>，160 ／ 4 = 40，你自己验证一下，<code>钱包地址</code>DF12793CA392ff748adF013D146f8dA73df6E304的<code>长度为40</code>。</p> 
  <p>以太坊钱包地址</p> 
  <pre class="prettyprint"><code class=" hljs ">0xDF12793CA392ff748adF013D146f8dA73df6E304</code></pre> 
  <p>通过工具对应的二进制为：</p> 
  <pre class="prettyprint"><code class=" hljs ">1101111100010010011110010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018082414194288?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>ps：通过工具转换的二进制可能存在问题，可以自己尝试转换。</p> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract  test {
  address _owner;
  uint160 _ownerUint;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> {</span>
    _owner = <span class="hljs-number">0xDF12793CA392ff748adF013D146f8dA73df6E304</span>;
    _ownerUint = <span class="hljs-number">1273516916528256943268872459582090959717186069252</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">owner</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span> {</span>
    <span class="hljs-keyword">return</span> _owner;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownerUint160</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint160)</span>{</span> 
      <span class="hljs-comment">//转换10进制 1273516916528256943268872459582090959717186069252</span>
     <span class="hljs-keyword">return</span> uint160(_owner);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownerUintToAddress</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span> {</span>
    <span class="hljs-keyword">return</span> address(_ownerUint);
  }
}

<span class="hljs-comment">//0x 16进制 45</span>
<span class="hljs-comment">//B 2进制 0100 0101</span>

<span class="hljs-comment">//1 + 2 + 4 + 8 + 16 + 32 + 64 + 128</span>
<span class="hljs-comment">//1 + 0 + 4 + 0 + 0 + 0 + 64 + 0 = 69</span>
<span class="hljs-comment">//D 10进制 69 </span>


<span class="hljs-comment">//0x DF12793CA392ff748adF013D146f8dA73df6E304 </span>
<span class="hljs-comment">//D 转换10进制 1273516916528256943268872459582090959717186069252</span>

<span class="hljs-comment">//1 2 3 4 5 6 7 8 9 A B C D E F</span>
<span class="hljs-comment">//40个 * 4位(二进制) =160位 </span>
<span class="hljs-comment">//1101 1111 0001 0010 0111 10010011110010100011100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="hljs-comment">//1+4+8=13 D 1+2+4+8=15 F 1 2 1+2+4=7 ....</span>
<span class="hljs-comment">//address</span>
<span class="hljs-comment">//uint160</span>
</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824141708389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><strong>不可不知的几个常识</strong></p> 
  <ul> 
   <li>合约拥有者</li> 
  </ul> 
  <p><code>msg.sender</code>就是当前调用方法时的发起人，一个合约部署后，通过钱包地址操作合约的人很多，但是如何正确判断谁是合约的拥有者，判断方式很简单，就是第一次部署合约时，谁出的<code>gas</code>，谁就对合约<code>具有拥有权</code>。</p> 
  <pre class="prettyprint"><code class=" hljs php">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract Test {

    address <span class="hljs-keyword">public</span> _owner;

    uint <span class="hljs-keyword">public</span> _number;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> {</span>
        _owner = msg.sender;
        _number = <span class="hljs-number">100</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msgSenderAddress</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span> {</span>
        <span class="hljs-keyword">return</span> msg.sender;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNumberAdd1</span><span class="hljs-params">()</span> {</span>
        _number = _number + <span class="hljs-number">5</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNumberAdd2</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (_owner == msg.sender) {
            _number = _number + <span class="hljs-number">10</span>;
        }
    }
}

<span class="hljs-comment">//0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C</span></code></pre> 
  <ul> 
   <li>合约地址</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs actionscript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;


<span class="hljs-comment">// 0x903ad08970c70d10e5fb5b3c26f7b714830afcf6</span>
<span class="hljs-comment">// 0x62e40877f4747e06197aa1a2b9ac06dd9bb244a3</span>

<span class="hljs-comment">// 0xf055775ebd516e7419ae486c1d50c682d4170645</span>

<span class="hljs-comment">// 0xe7795e05d15f7406baf411cafe766fc28eccf35f</span>
<span class="hljs-comment">// 0xe7795e05d15f7406baf411cafe766fc28eccf35f</span>

contract Test {

    address <span class="hljs-keyword">public</span> _owner;

    uint <span class="hljs-keyword">public</span> _number;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> {</span>
        _owner = msg.sender;
        _number = <span class="hljs-number">100</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msgSenderAddress</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span> {</span>
        <span class="hljs-keyword">return</span> msg.sender;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNumberAdd1</span><span class="hljs-params">()</span> {</span>
        _number = _number + <span class="hljs-number">5</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNumberAdd2</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (_owner == msg.sender) {
            _number = _number + <span class="hljs-number">10</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnContractAddress</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

}</code></pre> 
  <p>一个合约部署后，会有一个合约地址，这个合约地址就代表合约自己。 <br> <code>this</code>在合约中到底是<code>msg.sender</code>还是<code>合约地址</code>，由上图不难看出，<code>this</code>即是<code>当前合约地址</code>。</p> 
  <p><strong>部署</strong></p> 
  <p>在Remix网页编辑器中点击部署(Deploy)按钮</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824164850445?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>点击插件的<code>submit</code></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824165135735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>显示部署挖矿成功，钱包中的测试以太币也相应的减去部署需要花费的<code>gas</code></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824165228823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824165842368?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><strong>支持的运算符</strong></p> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;



contract Test {

    address address1;
    address address2;

    <span class="hljs-comment">// &lt;=，&lt;，==，!=，&gt;=和&gt;</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> {</span>
        address1 = <span class="hljs-number">0xF055775eBD516e7419ae486C1d50C682d4170645</span>;
        address2 = <span class="hljs-number">0xEAEC9B481c60e8cDc3cdF2D342082C349E5D6318</span>;
    }


    <span class="hljs-comment">// &lt;=</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> address1 &lt;= address2;
    }

    <span class="hljs-comment">// &lt;</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> address1 &lt; address2;
    }

    <span class="hljs-comment">// != </span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> address1 != address2;
    }

    <span class="hljs-comment">// &gt;=</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> address1 &gt;= address2;
    }

    <span class="hljs-comment">// &gt;</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> address1 &gt; address2;
    }
}</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824172205343?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li><code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>，<code>&gt;</code></li> 
  </ul> 
  <p><strong>成员变量和函数</strong></p> 
  <ul> 
   <li><p>一、 balance</p> <p>如果我们需要查看一个地址的余额，我们可以使用<code>balance</code>属性进行查看。</p></li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract addressBalance{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(address addr)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>{</span>
        <span class="hljs-keyword">return</span> addr.balance;
    }

}</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/201808241730446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>在<code>Account</code>一栏中，会自动生成测试钱包地址供我们测试使用，在我们点击<code>Deploy</code>按钮时，<code>Account</code>一栏选中的是钱包地址，我们<code>部署合约</code>时，花费的<code>gas</code>就从这个钱包地址里面扣除，【PS：这5个钱包地址每次都是系统临时生成，所以在我们开发测试过程中，每次的地址不会相同】。因为在本案例中，我们部署合约时，用的是第一个<code>Account</code>，所以<code>gas</code>自然从它里面扣除，大家会发现，其它四个钱包地址中的余额是<code>ether</code>，而第一个钱包地址中不到100个<code>ether</code>。</p> 
  <p>当我们点击<code>getBalance</code>获取某个钱包地址的余额时，获取到的余额的单位是<code>Wei</code>，一个<code>ether</code>等于<code>1000000000000000000Wei</code>，<code>Wei是最小单位</code>，相当于我们的1元RMB等于100分。【PS：1ether等于10的18次方Wei】</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">99999999999996890347 wei =</span>=<span class="hljs-string"> 99.999999999996890347 ether</span></code></pre> 
  <ul> 
   <li>二、this 查看当前合约地址余额</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract addressBalance{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>{</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContractAddrees</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address)</span>{</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(address addr)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span>{</span>
        <span class="hljs-keyword">return</span> addr.balance;
    }

}</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824174553926?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li>三、transfer</li> 
  </ul> 
  <p><code>transfer</code>：从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，代码将抛出异常并停止转账。</p> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract PayableKeyword{ 


    <span class="hljs-comment">// 从合约发起方向 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址转入 msg.value 个以太币，单位是 wei</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span><span class="hljs-params">()</span> <span class="hljs-title">payable</span>{</span>

        address Account2 = <span class="hljs-number">0x14723a09acff6d2a60dcdf7aa4aff308fddc160c</span>;
        Account2.transfer(msg.value);
    }


    <span class="hljs-comment">// 读取 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c 地址的余额</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAccount2Balance</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>

        address Account2 = <span class="hljs-number">0x14723a09acff6d2a60dcdf7aa4aff308fddc160c</span>;

        <span class="hljs-keyword">return</span> Account2.balance;
    }  

    <span class="hljs-comment">// 读取合约发起方的余额</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOwnerBalance</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>

        address Owner = msg.sender;
        <span class="hljs-keyword">return</span> Owner.balance;
    } 

}</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180824175144405?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0ZGFzaw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li>四、send</li> 
  </ul> 
  <p><code>send：</code>send相对<code>transfer</code>方法<code>较底层</code>，不过<code>使用方法和transfer相同</code>，都是从合约发起方向某个地址转入以太币(单位是wei)，地址无效或者合约发起方余额不足时，send不会抛出异常，而是直接返回false。</p> 
  <pre class="prettyprint"><code class=" hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.4</span>;

contract PayableKeyword{ 


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span><span class="hljs-params">()</span> <span class="hljs-title">payable</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span>{</span>

        address Account2 = <span class="hljs-number">0x14723a09acff6d2a60dcdf7aa4aff308fddc160c</span>;
        <span class="hljs-keyword">return</span> Account2.send(msg.value);
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAccount2Balance</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>

        address Account2 = <span class="hljs-number">0x14723a09acff6d2a60dcdf7aa4aff308fddc160c</span>;

        <span class="hljs-keyword">return</span> Account2.balance;
    }  


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOwnerBalance</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>

        address Owner = msg.sender;
        <span class="hljs-keyword">return</span> Owner.balance;
    } 
</code></pre> 
  <p>⚠️Warning</p> 
  <p>send()方法执行时有一些风险</p> 
  <ul> 
   <li>调用递归深度不能超1024。</li> 
   <li>如果gas不够，执行会失败。</li> 
   <li>所以使用这个方法要检查成功与否。</li> 
   <li>transfer相对send较安全</li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wtdask/article/details/82020705,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wtdask/article/details/82020705,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
