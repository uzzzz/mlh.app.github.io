<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>编写区块链游戏学智能合约 教程1：搭建僵尸工厂 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="编写区块链游戏学智能合约 教程1：搭建僵尸工厂" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/langzxz/article/details/82057418 该教程来自 CryptoZombies 网址：https://cryptozombies.io/zh/course/ CryptoZombies 是个在编游戏的过程中学习 Solidity 智能协议语言的互动教程。编游戏的同时学习以太坊的智能协议。关键是它免费。 僵尸工厂用于生产僵尸，每一个僵尸由头部基因、眼部基因、上衣基因、皮肤基因、眼色基因、衣服眼色基因组成，每个基因数值不一样，呈现的基因外形会有差异，通过这6个基因的组合，从而生产大量形状不一样的僵尸。 8356281049284737 这个数字的不同部分会对应僵尸的不同的特点，每个基因是都是由一个16位的整数组成。 例如：前两位数字是 83， 是计算僵尸的头型，我们做83 % 7 + 1 = 7 运算， 此僵尸将被赋予第七类头型。（求余7是因为程序只设计了7中头型） 1. 合约 从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下: contract HelloWorld { } 版本指令 所有的 Solidity 源码都必须冠以 version pragma — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。 例如: pragma solidity ^0.4.19; (当前 Solidity 的最新版本是 0.4.19). 综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码: pragma solidity ^0.4.19; contract HelloWorld { } 2. 状态变量和整数 我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。 状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。 例子: contract Example { // 这个无符号整数将会永久的被保存在区块链中 uint myUnsignedInteger = 100; } 在上面的例子中，定义 myUnsignedInteger 为 uint 类型，并赋值100。 无符号整数: uint uint 无符号数据类型， 指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。 注: Solidity中， uint 实际上是 uint256代名词， 一个256位的无符号整数。你也可以定义位数少的uints — uint8， uint16， uint32， 等…… 但一般来讲你愿意使用简单的 uint， 除非在某些特殊情况下，这我们后面会讲。 3. 数学运算 在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同: 加法: x + y 减法: x - y 乘法: x * y 除法: x / y 求余: x % y (例如, 13 % 5 余 3, 因为13除以5，余3) Solidity 还支持 乘方操作 (如：x 的 y次方） // 例如： 5 ** 2 = 25 uint x = 5 ** 2; // equal to 5^2 = 25 4.结构体 有时你需要更复杂的数据类型，Solidity 提供了 结构体: struct Person { uint age; string name; } 结构体允许你生成一个更复杂的数据类型，它有多个属性。 注：我们刚刚引进了一个新类型, string。 字符串用于保存任意长度的 UTF-8 编码数据。 如：string greeting = &quot;Hello world!&quot;。 5. 数组 如果你想建立一个集合，可以用 数组这样的数据类型. Solidity 支持两种数组: 静态数组和动态数组: // 固定长度为2的静态数组: uint[2] fixedArray; // 固定长度为5的string类型的静态数组: string[5] stringArray; // 动态数组，长度不固定，可以动态添加元素: uint[] dynamicArray; 你也可以建立一个 结构体类型的数组 例如，上面提到的Person: Person[] people; // dynamic Array, we can keep adding to it 记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。 公共数组 你可以定义 public 数组, Solidity 会自动创建 getter 方法. 语法如下: Person[] public people; 其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。 6. 定义函数 在 Solidity 中函数定义的句法如下: function eatHamburgers(string _name, uint _amount) { } 这是一个名为 eatHamburgers 的函数，它接受两个参数：一个 string类型的 和 一个 uint类型的。现在函数内部还是空的。 注：: 习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。 我们的函数定义如下: eatHamburgers(&quot;vitalik&quot;, 100); 7. 使用结构体和数组 创建新的结构体 还记得上面的 Person 结构吗？ struct Person { uint age; string name; } Person[] public people; 现在我们学习创建新的 Person 结构，然后把它加入到名为 people 的数组中. // 创建一个新的Person: Person satoshi = Person(172, &quot;Satoshi&quot;); // 将新创建的satoshi添加进people数组: people.push(satoshi); 你也可以两步并一步，用一行代码更简洁: people.push(Person(16, &quot;Vitalik&quot;)); 注：array.push() 在数组的 尾部 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如: uint[] numbers; numbers.push(5); numbers.push(10); numbers.push(15); // numbers is now equal to [5, 10, 15] 8. 私有 / 公共函数 Solidity 定义的函数的属性默认为公共。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。 显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为私有是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为公共。 如何定义一个私有的函数呢？ uint[] numbers; function _addToArray(uint _number) private { numbers.push(_number); } 这意味着只有我们合约中的其它函数才能够调用这个函数，给 numbers 数组添加新成员。 可以看到，在函数名字后面使用关键字 private 即可。和函数的参数类似，私有函数的名字用(_)起始。 9. 函数的更多属性 返回值 要想函数返回一个数值，按如下定义： string greeting = &quot;What&#39;s up dog&quot;; function sayHello() public returns (string) { return greeting; } Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 string)。 函数的修饰符 上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。 这种情况下我们可以把函数定义为 view, 意味着它只能读取数据不能更改数据: function sayHello() public view returns (string) {} Solidity 还支持pure 函数, 表明这个函数甚至都不访问应用里的数据，例如： function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure. 注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。 10. Keccak256 和 类型转换 如何让 _generateRandomDna 函数返回一个全(半) 随机的 uint? Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。 这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。 例子: //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(&quot;aaaab&quot;); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(&quot;aaaac&quot;); 显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。 注: 在区块链中安全地产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。 类型转换 有时你需要变换数据类型。例如: uint8 a = 5; uint b = 6; // 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8: uint8 c = a * b; // 我们需要将 b 转换为 uint8: uint8 c = a * uint8(b); 上面, a * b 返回类型是 uint, 但是当我们尝试用 uint8 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 uint8, 就可以了，编译器也不会出错。 11. 事件 我们的合约几乎就要完成了！让我们加上一个事件. 事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。 例子: // 这里建立事件 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; //触发事件，通知app IntegersAdded(_x, _y, result); return result; } 你的 app 前端可以监听这个事件。JavaScript 实现如下: YourContract.IntegersAdded(function(error, result) { // 干些事 } 这里介绍了Solidity的一部分基础语法，如果要掌握更多的Solidity基础知识，可以参考区块链技术-智能合约Solidity编程语言。 下面就将本节教程 搭建僵尸工厂 的完整代码以及言语解释写下。 这里应用了上面介绍的所有Solidity语法知识。 pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } 这段合约代码是一个僵尸工厂。 咱从最开始解读这个合约。 1. 第一行，这个合约基于0.4.19这个版本的编译器 2. 第二行，建立一个合约 ZombieFactory 3. 第四行，定义一个 事件 叫做 NewZombie。 它有3个参数:zombieId(uint)， name (string)， 和 dna (uint)。 4. 第六行，僵尸DNA将由一个十六位数字组成，所以定义 dnaDigits 为 uint 数据类型, 并赋值 16。 5. 第七行，为了保证我们的僵尸的DNA只含有16个字符，我们先造一个uint数据，让它等于10^16。这样一来以后我们可以用模运算符 % 把一个整数变成16位。所以，建立一个uint类型的变量，名字叫dnaModulus, 令其等于 10 的 dnaDigits 次方. 6. 第九行至第十二行，在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以建立一个struct 命名为 Zombie，里面包含了两个属性name (类型为string), 和 dna (类型为uint)。 7. 第十四行，为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们创建一个数据类型为 Zombie 的结构体数组，用 public 修饰，命名为：zombies. 8. 第十六行，建立一个私有函数 _createZombie。 它有两个参数:_name (类型为string), 和_dna (类型为uint) 9. 第十七行，在函数体里新创建一个 Zombie， 然后把它加入 zombies 数组中。 新创建的僵尸的 name 和 dna，来自于函数的参数。加入数组后，因为array.push() 返回数组的长度，类型是uint。所以可以把它当做 zombie 的 id或者索引 10. 第十八行，生成事件NewZombie,并将 zombie 的id ，name，dna传送出去。 11. 第二十一行，我们需要建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。所以，创建一个 private 函数，命名为 _generateRandomDna。它只接收一个输入变量 _str (类型 string), 返回一个 uint 类型的数值。此函数只读取我们合约中的一些变量，所以标记为view。 12. 第二十二行，取 _str 的 keccak256 散列值生成一个伪随机十六进制数，类型转换为 uint, 最后保存在类型为 uint 名为 rand 的变量中。 13. 第二十三行，我们只想让我们的DNA的长度为16位 (还记得 dnaModulus?)。所以第二行代码应该 return 上面计算的数值对 dnaModulus 求余数(%) 14. 第二十六行，创建一个 public 函数，命名为createRandomZombie. 它将被传入一个变量 _name (数据类型是 string)。 15. 第二十七行，调用_generateRandomDna 函数，传入 _name 参数, 结果保存在一个类型为 uint的变量里，命名为 randDna。 16. 第二十八行，调用_createZombie 函数， 传入参数：_name 和 randDna。 我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。 以太坊有一个 JavaScript 库，名为Web3.js。 在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。 如果下面的代码你不能全都理解，不用担心。 // 下面是调用合约的方式: var abi = /* abi是由编译器生成的 */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* 发布之后在以太坊上生成的合约地址 */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory` 能访问公共的函数以及事件 // 某个监听文本输入的监听器: $(&quot;#ourButton&quot;).click(function(e) { var name = $(&quot;#nameInput&quot;).val() //调用合约的 `createRandomZombie` 函数: ZombieFactory.createRandomZombie(name) }) // 监听 `NewZombie` 事件, 并且更新UI var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 获取 Zombie 的 dna, 更新图像 function generateZombie(id, name, dna) { let dnaStr = String(dna) // 如果dna少于16位,在它前面用0补上 while (dnaStr.length &lt; 16) dnaStr = &quot;0&quot; + dnaStr let zombieDetails = { // 前两位数构成头部.我们可能有7种头部, 所以 % 7 // 得到的数在0-6,再加上1,数的范围变成1-7 // 通过这样计算： headChoice: dnaStr.substring(0, 2) % 7 + 1， // 我们得到的图片名称从head1.png 到 head7.png // 接下来的两位数构成眼睛, 眼睛变化就对11取模: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 再接下来的两位数构成衣服，衣服变化就对6取模: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, //最后6位控制颜色. 用css选择器: hue-rotate来更新 // 360度: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: &quot;A Level 1 CryptoZombie&quot;, } return zombieDetails } 我们的 JavaScript 所做的就是获取由zombieDetails 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/langzxz/article/details/82057418 该教程来自 CryptoZombies 网址：https://cryptozombies.io/zh/course/ CryptoZombies 是个在编游戏的过程中学习 Solidity 智能协议语言的互动教程。编游戏的同时学习以太坊的智能协议。关键是它免费。 僵尸工厂用于生产僵尸，每一个僵尸由头部基因、眼部基因、上衣基因、皮肤基因、眼色基因、衣服眼色基因组成，每个基因数值不一样，呈现的基因外形会有差异，通过这6个基因的组合，从而生产大量形状不一样的僵尸。 8356281049284737 这个数字的不同部分会对应僵尸的不同的特点，每个基因是都是由一个16位的整数组成。 例如：前两位数字是 83， 是计算僵尸的头型，我们做83 % 7 + 1 = 7 运算， 此僵尸将被赋予第七类头型。（求余7是因为程序只设计了7中头型） 1. 合约 从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下: contract HelloWorld { } 版本指令 所有的 Solidity 源码都必须冠以 version pragma — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。 例如: pragma solidity ^0.4.19; (当前 Solidity 的最新版本是 0.4.19). 综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码: pragma solidity ^0.4.19; contract HelloWorld { } 2. 状态变量和整数 我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。 状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。 例子: contract Example { // 这个无符号整数将会永久的被保存在区块链中 uint myUnsignedInteger = 100; } 在上面的例子中，定义 myUnsignedInteger 为 uint 类型，并赋值100。 无符号整数: uint uint 无符号数据类型， 指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。 注: Solidity中， uint 实际上是 uint256代名词， 一个256位的无符号整数。你也可以定义位数少的uints — uint8， uint16， uint32， 等…… 但一般来讲你愿意使用简单的 uint， 除非在某些特殊情况下，这我们后面会讲。 3. 数学运算 在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同: 加法: x + y 减法: x - y 乘法: x * y 除法: x / y 求余: x % y (例如, 13 % 5 余 3, 因为13除以5，余3) Solidity 还支持 乘方操作 (如：x 的 y次方） // 例如： 5 ** 2 = 25 uint x = 5 ** 2; // equal to 5^2 = 25 4.结构体 有时你需要更复杂的数据类型，Solidity 提供了 结构体: struct Person { uint age; string name; } 结构体允许你生成一个更复杂的数据类型，它有多个属性。 注：我们刚刚引进了一个新类型, string。 字符串用于保存任意长度的 UTF-8 编码数据。 如：string greeting = &quot;Hello world!&quot;。 5. 数组 如果你想建立一个集合，可以用 数组这样的数据类型. Solidity 支持两种数组: 静态数组和动态数组: // 固定长度为2的静态数组: uint[2] fixedArray; // 固定长度为5的string类型的静态数组: string[5] stringArray; // 动态数组，长度不固定，可以动态添加元素: uint[] dynamicArray; 你也可以建立一个 结构体类型的数组 例如，上面提到的Person: Person[] people; // dynamic Array, we can keep adding to it 记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。 公共数组 你可以定义 public 数组, Solidity 会自动创建 getter 方法. 语法如下: Person[] public people; 其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。 6. 定义函数 在 Solidity 中函数定义的句法如下: function eatHamburgers(string _name, uint _amount) { } 这是一个名为 eatHamburgers 的函数，它接受两个参数：一个 string类型的 和 一个 uint类型的。现在函数内部还是空的。 注：: 习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。 我们的函数定义如下: eatHamburgers(&quot;vitalik&quot;, 100); 7. 使用结构体和数组 创建新的结构体 还记得上面的 Person 结构吗？ struct Person { uint age; string name; } Person[] public people; 现在我们学习创建新的 Person 结构，然后把它加入到名为 people 的数组中. // 创建一个新的Person: Person satoshi = Person(172, &quot;Satoshi&quot;); // 将新创建的satoshi添加进people数组: people.push(satoshi); 你也可以两步并一步，用一行代码更简洁: people.push(Person(16, &quot;Vitalik&quot;)); 注：array.push() 在数组的 尾部 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如: uint[] numbers; numbers.push(5); numbers.push(10); numbers.push(15); // numbers is now equal to [5, 10, 15] 8. 私有 / 公共函数 Solidity 定义的函数的属性默认为公共。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。 显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为私有是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为公共。 如何定义一个私有的函数呢？ uint[] numbers; function _addToArray(uint _number) private { numbers.push(_number); } 这意味着只有我们合约中的其它函数才能够调用这个函数，给 numbers 数组添加新成员。 可以看到，在函数名字后面使用关键字 private 即可。和函数的参数类似，私有函数的名字用(_)起始。 9. 函数的更多属性 返回值 要想函数返回一个数值，按如下定义： string greeting = &quot;What&#39;s up dog&quot;; function sayHello() public returns (string) { return greeting; } Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 string)。 函数的修饰符 上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。 这种情况下我们可以把函数定义为 view, 意味着它只能读取数据不能更改数据: function sayHello() public view returns (string) {} Solidity 还支持pure 函数, 表明这个函数甚至都不访问应用里的数据，例如： function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure. 注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。 10. Keccak256 和 类型转换 如何让 _generateRandomDna 函数返回一个全(半) 随机的 uint? Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。 这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。 例子: //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(&quot;aaaab&quot;); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(&quot;aaaac&quot;); 显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。 注: 在区块链中安全地产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。 类型转换 有时你需要变换数据类型。例如: uint8 a = 5; uint b = 6; // 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8: uint8 c = a * b; // 我们需要将 b 转换为 uint8: uint8 c = a * uint8(b); 上面, a * b 返回类型是 uint, 但是当我们尝试用 uint8 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 uint8, 就可以了，编译器也不会出错。 11. 事件 我们的合约几乎就要完成了！让我们加上一个事件. 事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。 例子: // 这里建立事件 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; //触发事件，通知app IntegersAdded(_x, _y, result); return result; } 你的 app 前端可以监听这个事件。JavaScript 实现如下: YourContract.IntegersAdded(function(error, result) { // 干些事 } 这里介绍了Solidity的一部分基础语法，如果要掌握更多的Solidity基础知识，可以参考区块链技术-智能合约Solidity编程语言。 下面就将本节教程 搭建僵尸工厂 的完整代码以及言语解释写下。 这里应用了上面介绍的所有Solidity语法知识。 pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } 这段合约代码是一个僵尸工厂。 咱从最开始解读这个合约。 1. 第一行，这个合约基于0.4.19这个版本的编译器 2. 第二行，建立一个合约 ZombieFactory 3. 第四行，定义一个 事件 叫做 NewZombie。 它有3个参数:zombieId(uint)， name (string)， 和 dna (uint)。 4. 第六行，僵尸DNA将由一个十六位数字组成，所以定义 dnaDigits 为 uint 数据类型, 并赋值 16。 5. 第七行，为了保证我们的僵尸的DNA只含有16个字符，我们先造一个uint数据，让它等于10^16。这样一来以后我们可以用模运算符 % 把一个整数变成16位。所以，建立一个uint类型的变量，名字叫dnaModulus, 令其等于 10 的 dnaDigits 次方. 6. 第九行至第十二行，在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以建立一个struct 命名为 Zombie，里面包含了两个属性name (类型为string), 和 dna (类型为uint)。 7. 第十四行，为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们创建一个数据类型为 Zombie 的结构体数组，用 public 修饰，命名为：zombies. 8. 第十六行，建立一个私有函数 _createZombie。 它有两个参数:_name (类型为string), 和_dna (类型为uint) 9. 第十七行，在函数体里新创建一个 Zombie， 然后把它加入 zombies 数组中。 新创建的僵尸的 name 和 dna，来自于函数的参数。加入数组后，因为array.push() 返回数组的长度，类型是uint。所以可以把它当做 zombie 的 id或者索引 10. 第十八行，生成事件NewZombie,并将 zombie 的id ，name，dna传送出去。 11. 第二十一行，我们需要建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。所以，创建一个 private 函数，命名为 _generateRandomDna。它只接收一个输入变量 _str (类型 string), 返回一个 uint 类型的数值。此函数只读取我们合约中的一些变量，所以标记为view。 12. 第二十二行，取 _str 的 keccak256 散列值生成一个伪随机十六进制数，类型转换为 uint, 最后保存在类型为 uint 名为 rand 的变量中。 13. 第二十三行，我们只想让我们的DNA的长度为16位 (还记得 dnaModulus?)。所以第二行代码应该 return 上面计算的数值对 dnaModulus 求余数(%) 14. 第二十六行，创建一个 public 函数，命名为createRandomZombie. 它将被传入一个变量 _name (数据类型是 string)。 15. 第二十七行，调用_generateRandomDna 函数，传入 _name 参数, 结果保存在一个类型为 uint的变量里，命名为 randDna。 16. 第二十八行，调用_createZombie 函数， 传入参数：_name 和 randDna。 我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。 以太坊有一个 JavaScript 库，名为Web3.js。 在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。 如果下面的代码你不能全都理解，不用担心。 // 下面是调用合约的方式: var abi = /* abi是由编译器生成的 */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* 发布之后在以太坊上生成的合约地址 */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory` 能访问公共的函数以及事件 // 某个监听文本输入的监听器: $(&quot;#ourButton&quot;).click(function(e) { var name = $(&quot;#nameInput&quot;).val() //调用合约的 `createRandomZombie` 函数: ZombieFactory.createRandomZombie(name) }) // 监听 `NewZombie` 事件, 并且更新UI var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 获取 Zombie 的 dna, 更新图像 function generateZombie(id, name, dna) { let dnaStr = String(dna) // 如果dna少于16位,在它前面用0补上 while (dnaStr.length &lt; 16) dnaStr = &quot;0&quot; + dnaStr let zombieDetails = { // 前两位数构成头部.我们可能有7种头部, 所以 % 7 // 得到的数在0-6,再加上1,数的范围变成1-7 // 通过这样计算： headChoice: dnaStr.substring(0, 2) % 7 + 1， // 我们得到的图片名称从head1.png 到 head7.png // 接下来的两位数构成眼睛, 眼睛变化就对11取模: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 再接下来的两位数构成衣服，衣服变化就对6取模: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, //最后6位控制颜色. 用css选择器: hue-rotate来更新 // 360度: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: &quot;A Level 1 CryptoZombie&quot;, } return zombieDetails } 我们的 JavaScript 所做的就是获取由zombieDetails 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/langzxz/article/details/82057418 该教程来自 CryptoZombies 网址：https://cryptozombies.io/zh/course/ CryptoZombies 是个在编游戏的过程中学习 Solidity 智能协议语言的互动教程。编游戏的同时学习以太坊的智能协议。关键是它免费。 僵尸工厂用于生产僵尸，每一个僵尸由头部基因、眼部基因、上衣基因、皮肤基因、眼色基因、衣服眼色基因组成，每个基因数值不一样，呈现的基因外形会有差异，通过这6个基因的组合，从而生产大量形状不一样的僵尸。 8356281049284737 这个数字的不同部分会对应僵尸的不同的特点，每个基因是都是由一个16位的整数组成。 例如：前两位数字是 83， 是计算僵尸的头型，我们做83 % 7 + 1 = 7 运算， 此僵尸将被赋予第七类头型。（求余7是因为程序只设计了7中头型） 1. 合约 从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下: contract HelloWorld { } 版本指令 所有的 Solidity 源码都必须冠以 version pragma — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。 例如: pragma solidity ^0.4.19; (当前 Solidity 的最新版本是 0.4.19). 综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码: pragma solidity ^0.4.19; contract HelloWorld { } 2. 状态变量和整数 我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。 状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。 例子: contract Example { // 这个无符号整数将会永久的被保存在区块链中 uint myUnsignedInteger = 100; } 在上面的例子中，定义 myUnsignedInteger 为 uint 类型，并赋值100。 无符号整数: uint uint 无符号数据类型， 指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。 注: Solidity中， uint 实际上是 uint256代名词， 一个256位的无符号整数。你也可以定义位数少的uints — uint8， uint16， uint32， 等…… 但一般来讲你愿意使用简单的 uint， 除非在某些特殊情况下，这我们后面会讲。 3. 数学运算 在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同: 加法: x + y 减法: x - y 乘法: x * y 除法: x / y 求余: x % y (例如, 13 % 5 余 3, 因为13除以5，余3) Solidity 还支持 乘方操作 (如：x 的 y次方） // 例如： 5 ** 2 = 25 uint x = 5 ** 2; // equal to 5^2 = 25 4.结构体 有时你需要更复杂的数据类型，Solidity 提供了 结构体: struct Person { uint age; string name; } 结构体允许你生成一个更复杂的数据类型，它有多个属性。 注：我们刚刚引进了一个新类型, string。 字符串用于保存任意长度的 UTF-8 编码数据。 如：string greeting = &quot;Hello world!&quot;。 5. 数组 如果你想建立一个集合，可以用 数组这样的数据类型. Solidity 支持两种数组: 静态数组和动态数组: // 固定长度为2的静态数组: uint[2] fixedArray; // 固定长度为5的string类型的静态数组: string[5] stringArray; // 动态数组，长度不固定，可以动态添加元素: uint[] dynamicArray; 你也可以建立一个 结构体类型的数组 例如，上面提到的Person: Person[] people; // dynamic Array, we can keep adding to it 记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。 公共数组 你可以定义 public 数组, Solidity 会自动创建 getter 方法. 语法如下: Person[] public people; 其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。 6. 定义函数 在 Solidity 中函数定义的句法如下: function eatHamburgers(string _name, uint _amount) { } 这是一个名为 eatHamburgers 的函数，它接受两个参数：一个 string类型的 和 一个 uint类型的。现在函数内部还是空的。 注：: 习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。 我们的函数定义如下: eatHamburgers(&quot;vitalik&quot;, 100); 7. 使用结构体和数组 创建新的结构体 还记得上面的 Person 结构吗？ struct Person { uint age; string name; } Person[] public people; 现在我们学习创建新的 Person 结构，然后把它加入到名为 people 的数组中. // 创建一个新的Person: Person satoshi = Person(172, &quot;Satoshi&quot;); // 将新创建的satoshi添加进people数组: people.push(satoshi); 你也可以两步并一步，用一行代码更简洁: people.push(Person(16, &quot;Vitalik&quot;)); 注：array.push() 在数组的 尾部 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如: uint[] numbers; numbers.push(5); numbers.push(10); numbers.push(15); // numbers is now equal to [5, 10, 15] 8. 私有 / 公共函数 Solidity 定义的函数的属性默认为公共。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。 显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为私有是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为公共。 如何定义一个私有的函数呢？ uint[] numbers; function _addToArray(uint _number) private { numbers.push(_number); } 这意味着只有我们合约中的其它函数才能够调用这个函数，给 numbers 数组添加新成员。 可以看到，在函数名字后面使用关键字 private 即可。和函数的参数类似，私有函数的名字用(_)起始。 9. 函数的更多属性 返回值 要想函数返回一个数值，按如下定义： string greeting = &quot;What&#39;s up dog&quot;; function sayHello() public returns (string) { return greeting; } Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 string)。 函数的修饰符 上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。 这种情况下我们可以把函数定义为 view, 意味着它只能读取数据不能更改数据: function sayHello() public view returns (string) {} Solidity 还支持pure 函数, 表明这个函数甚至都不访问应用里的数据，例如： function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure. 注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。 10. Keccak256 和 类型转换 如何让 _generateRandomDna 函数返回一个全(半) 随机的 uint? Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。 这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。 例子: //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(&quot;aaaab&quot;); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(&quot;aaaac&quot;); 显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。 注: 在区块链中安全地产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。 类型转换 有时你需要变换数据类型。例如: uint8 a = 5; uint b = 6; // 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8: uint8 c = a * b; // 我们需要将 b 转换为 uint8: uint8 c = a * uint8(b); 上面, a * b 返回类型是 uint, 但是当我们尝试用 uint8 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 uint8, 就可以了，编译器也不会出错。 11. 事件 我们的合约几乎就要完成了！让我们加上一个事件. 事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。 例子: // 这里建立事件 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; //触发事件，通知app IntegersAdded(_x, _y, result); return result; } 你的 app 前端可以监听这个事件。JavaScript 实现如下: YourContract.IntegersAdded(function(error, result) { // 干些事 } 这里介绍了Solidity的一部分基础语法，如果要掌握更多的Solidity基础知识，可以参考区块链技术-智能合约Solidity编程语言。 下面就将本节教程 搭建僵尸工厂 的完整代码以及言语解释写下。 这里应用了上面介绍的所有Solidity语法知识。 pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } 这段合约代码是一个僵尸工厂。 咱从最开始解读这个合约。 1. 第一行，这个合约基于0.4.19这个版本的编译器 2. 第二行，建立一个合约 ZombieFactory 3. 第四行，定义一个 事件 叫做 NewZombie。 它有3个参数:zombieId(uint)， name (string)， 和 dna (uint)。 4. 第六行，僵尸DNA将由一个十六位数字组成，所以定义 dnaDigits 为 uint 数据类型, 并赋值 16。 5. 第七行，为了保证我们的僵尸的DNA只含有16个字符，我们先造一个uint数据，让它等于10^16。这样一来以后我们可以用模运算符 % 把一个整数变成16位。所以，建立一个uint类型的变量，名字叫dnaModulus, 令其等于 10 的 dnaDigits 次方. 6. 第九行至第十二行，在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以建立一个struct 命名为 Zombie，里面包含了两个属性name (类型为string), 和 dna (类型为uint)。 7. 第十四行，为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们创建一个数据类型为 Zombie 的结构体数组，用 public 修饰，命名为：zombies. 8. 第十六行，建立一个私有函数 _createZombie。 它有两个参数:_name (类型为string), 和_dna (类型为uint) 9. 第十七行，在函数体里新创建一个 Zombie， 然后把它加入 zombies 数组中。 新创建的僵尸的 name 和 dna，来自于函数的参数。加入数组后，因为array.push() 返回数组的长度，类型是uint。所以可以把它当做 zombie 的 id或者索引 10. 第十八行，生成事件NewZombie,并将 zombie 的id ，name，dna传送出去。 11. 第二十一行，我们需要建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。所以，创建一个 private 函数，命名为 _generateRandomDna。它只接收一个输入变量 _str (类型 string), 返回一个 uint 类型的数值。此函数只读取我们合约中的一些变量，所以标记为view。 12. 第二十二行，取 _str 的 keccak256 散列值生成一个伪随机十六进制数，类型转换为 uint, 最后保存在类型为 uint 名为 rand 的变量中。 13. 第二十三行，我们只想让我们的DNA的长度为16位 (还记得 dnaModulus?)。所以第二行代码应该 return 上面计算的数值对 dnaModulus 求余数(%) 14. 第二十六行，创建一个 public 函数，命名为createRandomZombie. 它将被传入一个变量 _name (数据类型是 string)。 15. 第二十七行，调用_generateRandomDna 函数，传入 _name 参数, 结果保存在一个类型为 uint的变量里，命名为 randDna。 16. 第二十八行，调用_createZombie 函数， 传入参数：_name 和 randDna。 我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。 以太坊有一个 JavaScript 库，名为Web3.js。 在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。 如果下面的代码你不能全都理解，不用担心。 // 下面是调用合约的方式: var abi = /* abi是由编译器生成的 */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* 发布之后在以太坊上生成的合约地址 */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory` 能访问公共的函数以及事件 // 某个监听文本输入的监听器: $(&quot;#ourButton&quot;).click(function(e) { var name = $(&quot;#nameInput&quot;).val() //调用合约的 `createRandomZombie` 函数: ZombieFactory.createRandomZombie(name) }) // 监听 `NewZombie` 事件, 并且更新UI var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 获取 Zombie 的 dna, 更新图像 function generateZombie(id, name, dna) { let dnaStr = String(dna) // 如果dna少于16位,在它前面用0补上 while (dnaStr.length &lt; 16) dnaStr = &quot;0&quot; + dnaStr let zombieDetails = { // 前两位数构成头部.我们可能有7种头部, 所以 % 7 // 得到的数在0-6,再加上1,数的范围变成1-7 // 通过这样计算： headChoice: dnaStr.substring(0, 2) % 7 + 1， // 我们得到的图片名称从head1.png 到 head7.png // 接下来的两位数构成眼睛, 眼睛变化就对11取模: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 再接下来的两位数构成衣服，衣服变化就对6取模: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, //最后6位控制颜色. 用css选择器: hue-rotate来更新 // 360度: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: &quot;A Level 1 CryptoZombie&quot;, } return zombieDetails } 我们的 JavaScript 所做的就是获取由zombieDetails 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。 阅读更多","@type":"BlogPosting","url":"/2018/08/26/ef0f844481b22dc17017053705bf9e26.html","headline":"编写区块链游戏学智能合约 教程1：搭建僵尸工厂","dateModified":"2018-08-26T00:00:00+08:00","datePublished":"2018-08-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/26/ef0f844481b22dc17017053705bf9e26.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>编写区块链游戏学智能合约 教程1：搭建僵尸工厂</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/langzxz/article/details/82057418 
 </div> 
 <div class="markdown_views"> 
  <p>该教程来自 <a href="https://cryptozombies.io/zh/course/" rel="nofollow">CryptoZombies</a> <br> 网址：<a href="https://cryptozombies.io/zh/course/" rel="nofollow">https://cryptozombies.io/zh/course/</a> <br> CryptoZombies 是个在编游戏的过程中学习 Solidity 智能协议语言的互动教程。编游戏的同时学习以太坊的智能协议。关键是它免费。</p> 
  <p>僵尸工厂用于生产僵尸，每一个僵尸由头部基因、眼部基因、上衣基因、皮肤基因、眼色基因、衣服眼色基因组成，每个基因数值不一样，呈现的基因外形会有差异，通过这6个基因的组合，从而生产大量形状不一样的僵尸。</p> 
  <blockquote> 
   <p>8356281049284737</p> 
  </blockquote> 
  <p>这个数字的不同部分会对应僵尸的不同的特点，每个基因是都是由一个16位的整数组成。 <br> 例如：前两位数字是 83， 是计算僵尸的头型，我们做83 % 7 + 1 = 7 运算， 此僵尸将被赋予第七类头型。（求余7是因为程序只设计了7中头型）</p> 
  <h3 id="1-合约">1. 合约</h3> 
  <p>从最基本的开始入手: <br> Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p> 
  <p>一份名为 HelloWorld 的空合约如下:</p> 
  <pre class="prettyprint"><code class="language-Solidity hljs css"><span class="hljs-tag">contract</span> <span class="hljs-tag">HelloWorld</span> <span class="hljs-rules">{ <span class="hljs-rule">}</span></span></code></pre> 
  <p>版本指令 <br> 所有的 Solidity 源码都必须冠以 <code>version pragma</code> — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p> 
  <p>例如: pragma solidity ^0.4.19; (当前 Solidity 的最新版本是 0.4.19). <br> 综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p> 
  <pre class="prettyprint"><code class="language-Solidity hljs sql"><span class="hljs-operator"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.19</span>;</span>

contract HelloWorld {

}</code></pre> 
  <h3 id="2-状态变量和整数">2. 状态变量和整数</h3> 
  <p>我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p> 
  <p>状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p> 
  <p>例子:</p> 
  <pre class="prettyprint"><code class=" hljs cs">contract Example {
  <span class="hljs-comment">// 这个无符号整数将会永久的被保存在区块链中</span>
  <span class="hljs-keyword">uint</span> myUnsignedInteger = <span class="hljs-number">100</span>;
}</code></pre> 
  <p>在上面的例子中，定义 myUnsignedInteger 为 uint 类型，并赋值100。</p> 
  <p>无符号整数: <code>uint</code> <br> <code>uint</code> 无符号数据类型， 指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。</p> 
  <blockquote> 
   <p>注: Solidity中， uint 实际上是 uint256代名词， 一个256位的无符号整数。你也可以定义位数少的uints — uint8， uint16， uint32， 等…… 但一般来讲你愿意使用简单的 uint， 除非在某些特殊情况下，这我们后面会讲。</p> 
  </blockquote> 
  <h3 id="3-数学运算">3. 数学运算</h3> 
  <p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p> 
  <ul> 
   <li>加法: <code>x + y</code></li> 
   <li>减法: <code>x - y</code></li> 
   <li>乘法: <code>x * y</code></li> 
   <li>除法: <code>x / y</code></li> 
   <li>求余: <code>x % y</code> (例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3) <br> Solidity 还支持 <code>乘方操作</code> (如：x 的 y次方） // 例如： 5 ** 2 = 25</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">uint</span> x = <span class="hljs-number">5</span> ** <span class="hljs-number">2</span>; <span class="hljs-comment">// equal to 5^2 = 25</span></code></pre> 
  <h3 id="4结构体">4.结构体</h3> 
  <p>有时你需要更复杂的数据类型，Solidity 提供了 结构体:</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> Person {
  <span class="hljs-keyword">uint</span> age;
  <span class="hljs-keyword">string</span> name;
}</code></pre> 
  <p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p> 
  <p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如：<code>string greeting = "Hello world!"</code>。</p> 
  <h3 id="5-数组">5. 数组</h3> 
  <p>如果你想建立一个集合，可以用 数组这样的数据类型. Solidity 支持两种数组: <code>静态数组</code>和<code>动态数组</code>:</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 固定长度为2的静态数组:</span>
<span class="hljs-keyword">uint</span>[<span class="hljs-number">2</span>] fixedArray;
<span class="hljs-comment">// 固定长度为5的string类型的静态数组:</span>
<span class="hljs-keyword">string</span>[<span class="hljs-number">5</span>] stringArray;
<span class="hljs-comment">// 动态数组，长度不固定，可以动态添加元素:</span>
<span class="hljs-keyword">uint</span>[] dynamicArray;</code></pre> 
  <p>你也可以建立一个 结构体类型的数组 例如，上面提到的<code>Person</code>:</p> 
  <pre class="prettyprint"><code class=" hljs vhdl">Person[] people; // dynamic <span class="hljs-keyword">Array</span>, we can keep adding <span class="hljs-keyword">to</span> it</code></pre> 
  <p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p> 
  <p>公共数组 <br> 你可以定义 <code>public</code> 数组, Solidity 会自动创建 <code>getter</code> 方法. 语法如下:</p> 
  <pre class="prettyprint"><code class=" hljs cs">Person[] <span class="hljs-keyword">public</span> people;</code></pre> 
  <p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p> 
  <h3 id="6-定义函数">6. 定义函数</h3> 
  <p>在 Solidity 中函数定义的句法如下:</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eatHamburgers</span><span class="hljs-params">(string _name, uint _amount)</span> {</span>

}</code></pre> 
  <p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p> 
  <p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p> 
  <p>我们的函数定义如下:</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">eatHamburgers(<span class="hljs-string">"vitalik"</span>, <span class="hljs-number">100</span>)</span>;</code></pre> 
  <h3 id="7-使用结构体和数组">7. 使用结构体和数组</h3> 
  <p>创建新的结构体 <br> 还记得上面的 <code>Person</code> 结构吗？</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> Person {
  <span class="hljs-keyword">uint</span> age;
  <span class="hljs-keyword">string</span> name;
}

Person[] <span class="hljs-keyword">public</span> people;</code></pre> 
  <p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 创建一个新的Person:</span>
Person satoshi = Person(<span class="hljs-number">172</span>, <span class="hljs-string">"Satoshi"</span>);

<span class="hljs-comment">// 将新创建的satoshi添加进people数组:</span>
people.push(satoshi);</code></pre> 
  <p>你也可以两步并一步，用一行代码更简洁:</p> 
  <p><code>people.push(Person(16, "Vitalik"));</code> <br> 注：<code>array.push()</code> 在数组的 尾部 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p> 
  <pre class="prettyprint"><code class=" hljs perl">uint[] numbers;
numbers.<span class="hljs-keyword">push</span>(<span class="hljs-number">5</span>);
numbers.<span class="hljs-keyword">push</span>(<span class="hljs-number">10</span>);
numbers.<span class="hljs-keyword">push</span>(<span class="hljs-number">15</span>);
<span class="hljs-regexp">//</span> numbers is now equal to [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]</code></pre> 
  <h3 id="8-私有-公共函数">8. 私有 / 公共函数</h3> 
  <p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p> 
  <p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p> 
  <p>如何定义一个私有的函数呢？</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">uint</span>[] numbers;

function _addToArray(<span class="hljs-keyword">uint</span> _number) <span class="hljs-keyword">private</span> {
  numbers.push(_number);
}</code></pre> 
  <p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p> 
  <p>可以看到，在函数名字后面使用关键字 <code>private</code> 即可。和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</p> 
  <h3 id="9-函数的更多属性">9. 函数的更多属性</h3> 
  <h4 id="返回值">返回值</h4> 
  <p>要想函数返回一个数值，按如下定义：</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">string</span> greeting = <span class="hljs-string">"What's up dog"</span>;

function sayHello() <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-keyword">string</span>) {
  <span class="hljs-keyword">return</span> greeting;
}</code></pre> 
  <p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p> 
  <h4 id="函数的修饰符">函数的修饰符</h4> 
  <p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p> 
  <p>这种情况下我们可以把函数定义为 <code>view</code>, 意味着它只能读取数据不能更改数据:</p> 
  <pre class="prettyprint"><code class=" hljs cs">function sayHello() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-keyword">string</span>) {}</code></pre> 
  <p>Solidity 还支持<code>pure</code> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p> 
  <pre class="prettyprint"><code class=" hljs cs">function _multiply(<span class="hljs-keyword">uint</span> a, <span class="hljs-keyword">uint</span> b) <span class="hljs-keyword">private</span> pure <span class="hljs-title">returns</span> (<span class="hljs-keyword">uint</span>) {
  <span class="hljs-keyword">return</span> a * b;
}</code></pre> 
  <p>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 <code>pure</code>.</p> 
  <blockquote> 
   <p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p> 
  </blockquote> 
  <h3 id="10-keccak256-和-类型转换">10. Keccak256 和 类型转换</h3> 
  <p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p> 
  <p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p> 
  <p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p> 
  <p>例子:</p> 
  <pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span>
<span class="hljs-function">keccak256(<span class="hljs-string">"aaaab"</span>)</span>;
<span class="hljs-comment">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span>
<span class="hljs-function">keccak256(<span class="hljs-string">"aaaac"</span>)</span>;</code></pre> 
  <p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p> 
  <blockquote> 
   <p>注: 在区块链中安全地产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p> 
  </blockquote> 
  <h4 id="类型转换">类型转换</h4> 
  <p>有时你需要变换数据类型。例如:</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">uint8</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">uint</span> b = <span class="hljs-number">6</span>;
<span class="hljs-comment">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span>
<span class="hljs-keyword">uint8</span> c = a * b;
<span class="hljs-comment">// 我们需要将 b 转换为 uint8:</span>
<span class="hljs-keyword">uint8</span> c = a * <span class="hljs-keyword">uint8</span>(b);</code></pre> 
  <p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p> 
  <h3 id="11-事件">11. 事件</h3> 
  <p>我们的合约几乎就要完成了！让我们加上一个事件.</p> 
  <p>事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p> 
  <p>例子:</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 这里建立事件</span>
<span class="hljs-keyword">event</span> IntegersAdded(<span class="hljs-keyword">uint</span> x, <span class="hljs-keyword">uint</span> y, <span class="hljs-keyword">uint</span> result);

function add(<span class="hljs-keyword">uint</span> _x, <span class="hljs-keyword">uint</span> _y) <span class="hljs-keyword">public</span> {
  <span class="hljs-keyword">uint</span> result = _x + _y;
  <span class="hljs-comment">//触发事件，通知app</span>
  IntegersAdded(_x, _y, result);
  <span class="hljs-keyword">return</span> result;
}</code></pre> 
  <p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p> 
  <pre class="prettyprint"><code class=" hljs javascript">YourContract.IntegersAdded(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, result)</span> {</span> 
  <span class="hljs-comment">// 干些事</span>
}</code></pre> 
  <p>这里介绍了<code>Solidity</code>的一部分基础语法，如果要掌握更多的<code>Solidity</code>基础知识，可以参考<a href="http://www.tryblockchain.org/index.html" rel="nofollow">区块链技术-智能合约Solidity编程语言</a>。</p> 
  <p>下面就将本节教程 搭建僵尸工厂 的完整代码以及言语解释写下。 <br> 这里应用了上面介绍的所有<code>Solidity</code>语法知识。</p> 
  <pre class="prettyprint"><code class=" hljs cs">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.19</span>;
contract ZombieFactory {

    <span class="hljs-keyword">event</span> NewZombie(<span class="hljs-keyword">uint</span> zombieId, <span class="hljs-keyword">string</span> name, <span class="hljs-keyword">uint</span> dna);

    <span class="hljs-keyword">uint</span> dnaDigits = <span class="hljs-number">16</span>;
    <span class="hljs-keyword">uint</span> dnaModulus = <span class="hljs-number">10</span> ** dnaDigits;

    <span class="hljs-keyword">struct</span> Zombie {
        <span class="hljs-keyword">string</span> name;
        <span class="hljs-keyword">uint</span> dna;
    }

    Zombie[] <span class="hljs-keyword">public</span> zombies;

    function _createZombie(<span class="hljs-keyword">string</span> _name, <span class="hljs-keyword">uint</span> _dna) <span class="hljs-keyword">private</span> {
        <span class="hljs-keyword">uint</span> id = zombies.push(Zombie(_name, _dna)) - <span class="hljs-number">1</span>;
        NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(<span class="hljs-keyword">string</span> _str) <span class="hljs-keyword">private</span> view <span class="hljs-title">returns</span> (<span class="hljs-keyword">uint</span>) {
        <span class="hljs-keyword">uint</span> rand = <span class="hljs-keyword">uint</span>(keccak256(_str));
        <span class="hljs-keyword">return</span> rand % dnaModulus;
    }

    function createRandomZombie(<span class="hljs-keyword">string</span> _name) <span class="hljs-keyword">public</span> {
        <span class="hljs-keyword">uint</span> randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }

}</code></pre> 
  <p>这段合约代码是一个僵尸工厂。 <br> 咱从最开始解读这个合约。 <br> 1. 第一行，这个合约基于<code>0.4.19</code>这个版本的编译器 <br> 2. 第二行，建立一个合约 <code>ZombieFactory</code> <br> 3. 第四行，定义一个 事件 叫做 <code>NewZombie</code>。 它有3个参数:<code>zombieId</code>(<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。 <br> 4. 第六行，僵尸DNA将由一个十六位数字组成，所以定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 16。 <br> 5. 第七行，为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。所以，建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <code>10</code> 的 <code>dnaDigits</code> 次方. <br> 6. 第九行至第十二行，在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以建立一个<code>struct</code> 命名为 <code>Zombie</code>，里面包含了两个属性<code>name</code> (类型为<code>string</code>), 和 <code>dna</code> (类型为<code>uint</code>)。 <br> 7. 第十四行，为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>. <br> 8. 第十六行，建立一个私有函数 <code>_createZombie</code>。 它有两个参数:<code>_name</code> (类型为<code>string</code>), 和<code>_dna</code> (类型为<code>uint</code>) <br> 9. 第十七行，在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。加入数组后，因为array.push() 返回数组的长度，类型是uint。所以可以把它当做 zombie 的 id或者索引 <br> 10. 第十八行，生成事件<code>NewZombie</code>,并将 zombie 的id ，name，dna传送出去。 <br> 11. 第二十一行，我们需要建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。所以，创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。此函数只读取我们合约中的一些变量，所以标记为view。 <br> 12. 第二十二行，取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。 <br> 13. 第二十三行，我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>) <br> 14. 第二十六行，创建一个 <code>public</code> 函数，命名为<code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 <br> 15. 第二十七行，调用<code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code>的变量里，命名为 <code>randDna</code>。 <br> 16. 第二十八行，调用<code>_createZombie</code> 函数， 传入参数：<code>_name</code> 和 <code>randDna</code>。</p> 
  <p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p> 
  <p>以太坊有一个 JavaScript 库，名为<code>Web3.js</code>。</p> 
  <p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置<code>Web3.js</code>。 但是现在我们通过一段代码来了解 <code>Web3.js</code> 是如何和我们发布的合约交互的吧。</p> 
  <p>如果下面的代码你不能全都理解，不用担心。</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// 下面是调用合约的方式:</span>
<span class="hljs-keyword">var</span> abi = <span class="hljs-comment">/* abi是由编译器生成的 */</span>
<span class="hljs-keyword">var</span> ZombieFactoryContract = web3.eth.contract(abi)
<span class="hljs-keyword">var</span> contractAddress = <span class="hljs-comment">/* 发布之后在以太坊上生成的合约地址 */</span>
<span class="hljs-keyword">var</span> ZombieFactory = ZombieFactoryContract.at(contractAddress)
<span class="hljs-comment">// `ZombieFactory` 能访问公共的函数以及事件</span>

<span class="hljs-comment">// 某个监听文本输入的监听器:</span>
$(<span class="hljs-string">"#ourButton"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>
  <span class="hljs-keyword">var</span> name = $(<span class="hljs-string">"#nameInput"</span>).val()
  <span class="hljs-comment">//调用合约的 `createRandomZombie` 函数:</span>
  ZombieFactory.createRandomZombie(name)
})

<span class="hljs-comment">// 监听 `NewZombie` 事件, 并且更新UI</span>
<span class="hljs-keyword">var</span> event = ZombieFactory.NewZombie(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, result)</span> {</span>
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span>
  generateZombie(result.zombieId, result.name, result.dna)
})

<span class="hljs-comment">// 获取 Zombie 的 dna, 更新图像</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateZombie</span><span class="hljs-params">(id, name, dna)</span> {</span>
  <span class="hljs-keyword">let</span> dnaStr = <span class="hljs-built_in">String</span>(dna)
  <span class="hljs-comment">// 如果dna少于16位,在它前面用0补上</span>
  <span class="hljs-keyword">while</span> (dnaStr.length &lt; <span class="hljs-number">16</span>)
    dnaStr = <span class="hljs-string">"0"</span> + dnaStr

  <span class="hljs-keyword">let</span> zombieDetails = {
    <span class="hljs-comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span>
    <span class="hljs-comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span>
    <span class="hljs-comment">// 通过这样计算：</span>
    headChoice: dnaStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) % <span class="hljs-number">7</span> + <span class="hljs-number">1</span>，
    <span class="hljs-comment">// 我们得到的图片名称从head1.png 到 head7.png</span>

    <span class="hljs-comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span>
    eyeChoice: dnaStr.substring(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) % <span class="hljs-number">11</span> + <span class="hljs-number">1</span>,
    <span class="hljs-comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span>
    shirtChoice: dnaStr.substring(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>,
    <span class="hljs-comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span>
    <span class="hljs-comment">// 360度:</span>
    skinColorChoice: <span class="hljs-built_in">parseInt</span>(dnaStr.substring(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>) / <span class="hljs-number">100</span> * <span class="hljs-number">360</span>),
    eyeColorChoice: <span class="hljs-built_in">parseInt</span>(dnaStr.substring(<span class="hljs-number">8</span>, <span class="hljs-number">10</span>) / <span class="hljs-number">100</span> * <span class="hljs-number">360</span>),
    clothesColorChoice: <span class="hljs-built_in">parseInt</span>(dnaStr.substring(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>) / <span class="hljs-number">100</span> * <span class="hljs-number">360</span>),
    zombieName: name,
    zombieDescription: <span class="hljs-string">"A Level 1 CryptoZombie"</span>,
  }
  <span class="hljs-keyword">return</span> zombieDetails
}</code></pre> 
  <p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/langzxz/article/details/82057418,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/langzxz/article/details/82057418,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
