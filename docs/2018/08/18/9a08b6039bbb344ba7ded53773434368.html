<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币入门-交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币入门-交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="对比特币来说，其他的所有模块都是为了保证交易的生成，在比特网络中得以传播和验证，并最终被添加在比特币总账簿 如果说钱包提供了身份证明和财产的证明和锁定，那么交易提供了财产的流动，如果失去了交易，那么钱包存在的意义并不大 一笔比特币交易的生命周期起始于它被创建的那刻（诞生 origination），任何人都可以发起交易，哪怕是和自己无关的交易。 随后，比特币交易会被以个或者多个签名加密，这些签名标志着对该交易指向的比特币资金的使用许可。接下来，比特币交易被广播到比特币网络中，每个节点都会做（比特币交易参与者）验证、如果交易信息通过验证，就将交易在网络中继续广播，同时，交易发起者会收到一条表示交易有效并被接受的返回信息。如果这笔交易被验证为有效，这个节点会拒绝接受这笔交易且同时返回给交易发起者一条表示交易被拒绝的信息，直到这笔交易被网络中绝多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中 这又分为几个过程 - 创建交易信息 - 网络中广播并验证 - 加入区块链 交易 交易信息 交易信息类似一张支票，可以理解为一个数据结构，一笔交易（这个数据结构）可以由任何人创建发起，关键是资金支付人的签名 交易信息结构 大小 字段 描述 4字节 版本 明确这笔交易的规则 1-9字节 输入数量 被包含的输入数量 不定 输入 一个或多个交易 1-9字节 输出数量 被包含的输出数量 不定 输出 一个或多个输出交易 4字节 时钟时间 一个UNIX时间戳或区块号 交易也可以指定锁定时间，即可以被加在区块中的最早时间，就像延期一个支票的生效时间 比特币交易的基本单位是不可分割的 UTXO，他可以是一聪的任意倍数，1比特币 = 一千万聪，一个用户接受比特币时，UTXO被存在区块中，实际上不存在交易的地址和签名，有的只是被锁住的分散在各个区块中的 UTXO，通过对区块链整个的推导计算，可以得到所有人拥有的 UTXO 即，余额 在比特币的世界中既没有账号也没有余额，只有分散到区块链中的UTXO 一个 UTXO 可以使 1聪 的任意倍，但是一个 UTXO 一旦被创造出来，使用时就无法再分割了，只能作为一个整体支付，所以一般支付时都会存在找零，即，多笔输出。例如，你有20比特币的UTXO并且想支付 1 比特币，那么你的交易必须消耗掉整个 20 比特币的UTXO并且产生两个输出：一个是支付了 1 比特币给接收人，另一个是支付 19 比特币的找零到你的钱包 交易输出 就像原始交易一样，你不能将一个 100 元平均撕开作为 50 支付，同时你也可以使用多个零钱组装为 50 元，所以我们的一次交易通常有多笔输入输出。被交易消耗的 UTXO 被称为交易输入，由交易创建的 UTXO 被称为交易输出。 输入和输出到底先有哪个，其实是现有输出，因为我们可以默认第一笔输入就是创世区块中系统的输入 每一笔比特币交易输出都会被记录下来，所有的输出都是作为另一个输入，然后被用于新的支付 输出结构 尺寸 字段 说明 8字节 总量 用聪表示的比特币值 1-9字节 锁定脚本尺寸 用字节表示的后面的锁定脚本的长度 边长 锁定脚本 一个定义了支付输出所需条件的脚本 支付条件 交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上 这个锁定脚本一般是个地址，通过签名可以解锁这个地址的使用权，再去支付给别人 交易输入 简单的说，交易输入就是指向 UTXO 的指针，考虑一下，因为 UTXO 不可分割的特性，用户的余额就是所有没被指向输入的输出 一个交易的输入需要一个解锁脚本，用来满足 UTXO 的支付条件，解锁脚本通常是一个签名，用于证明对于锁定脚本中的比特币地址的所有权 尺寸 字段 说明 32字节 交易 指向交易包含的被花费的 UTXO 的指针 4字节 索引 被话费的 UTXO 的索引 1-9字节 解锁脚本尺寸 用于解锁脚本的大小 边长 解锁脚本 一个达到 UTXO 锁定脚本中条件的脚本 4字节 序列号 目前未被使用的交易替换功能，设成0xFFFFFFFF处 （会不会一个输出被多次使用作为输入） 交易费 交易费可当做是为了包含一笔交易到一个区块中的奖励，交易费被矿工挖到，并记录在这个交易的区块中 交易费基于交易的尺寸，基于千字节来计算，而不是比特币的价值。总的来说，交易费基于市场所设置，生效于比特币网络中。矿工依据许多不同的标准，按重要性对交易进行排序，这包括费用，并且甚至可能在某种特定情况下免费处理交易。交易费影响处理优先级，这意味着有足够费用的交易会更可能地被包含在下一个挖出的区块中；与此同时，交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，并且没有交易费的交易也许最终会被处理，但是，包含交易费将提高处理优先级交易费在交易中并没有特殊的字段，而是通过输入 - 输出 = 差，得到交易费 在交易中并没有交易费的字段，而是由矿工决定，如果矿工觉得没有任何交易费则不处理该交易，则他可能不会被计入到区块中，则交易不成立 交易链条和孤立交易 随着交易的进行，他们组成了一个链条，每一笔交易都是基于之前的交易。 如果发生了一个父交易，在父交易没有被确定之前又产生了一个基于他的子交易，而子交易在父交易之前到达其他节点。这种情况下，节点会首先接受这个交易，而不能找到参考他的父交易，节点不会立即抛弃这个交易，而是将他放在临时交易池中，并将此交易广播给其他节点。 没有父交易的交易池被称为孤立交易池，一旦接受到父节点，所有与该父节点有关的交易都会被释放，递归地重新验证，然后整个交易链都会被交易池包括进去，并等待其他区块所挖走。内存中存储的孤立交易是有限的，这是为了防止客户端的 Dos 攻击 交易脚本 每一笔交易都有锁定脚本和解锁脚本，通常锁定脚本是使用公钥锁定，解锁脚本则是通过私钥生成的数字签名 每一个比特币客户端会通过同时执行锁定和解锁脚本来验证一笔交易，从本质上来说，交易成立需要锁定和解锁，但是比特币作为可编程货币，提供了灵活的验证脚本，从而变出多种交易模式 阅读更多" />
<meta property="og:description" content="对比特币来说，其他的所有模块都是为了保证交易的生成，在比特网络中得以传播和验证，并最终被添加在比特币总账簿 如果说钱包提供了身份证明和财产的证明和锁定，那么交易提供了财产的流动，如果失去了交易，那么钱包存在的意义并不大 一笔比特币交易的生命周期起始于它被创建的那刻（诞生 origination），任何人都可以发起交易，哪怕是和自己无关的交易。 随后，比特币交易会被以个或者多个签名加密，这些签名标志着对该交易指向的比特币资金的使用许可。接下来，比特币交易被广播到比特币网络中，每个节点都会做（比特币交易参与者）验证、如果交易信息通过验证，就将交易在网络中继续广播，同时，交易发起者会收到一条表示交易有效并被接受的返回信息。如果这笔交易被验证为有效，这个节点会拒绝接受这笔交易且同时返回给交易发起者一条表示交易被拒绝的信息，直到这笔交易被网络中绝多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中 这又分为几个过程 - 创建交易信息 - 网络中广播并验证 - 加入区块链 交易 交易信息 交易信息类似一张支票，可以理解为一个数据结构，一笔交易（这个数据结构）可以由任何人创建发起，关键是资金支付人的签名 交易信息结构 大小 字段 描述 4字节 版本 明确这笔交易的规则 1-9字节 输入数量 被包含的输入数量 不定 输入 一个或多个交易 1-9字节 输出数量 被包含的输出数量 不定 输出 一个或多个输出交易 4字节 时钟时间 一个UNIX时间戳或区块号 交易也可以指定锁定时间，即可以被加在区块中的最早时间，就像延期一个支票的生效时间 比特币交易的基本单位是不可分割的 UTXO，他可以是一聪的任意倍数，1比特币 = 一千万聪，一个用户接受比特币时，UTXO被存在区块中，实际上不存在交易的地址和签名，有的只是被锁住的分散在各个区块中的 UTXO，通过对区块链整个的推导计算，可以得到所有人拥有的 UTXO 即，余额 在比特币的世界中既没有账号也没有余额，只有分散到区块链中的UTXO 一个 UTXO 可以使 1聪 的任意倍，但是一个 UTXO 一旦被创造出来，使用时就无法再分割了，只能作为一个整体支付，所以一般支付时都会存在找零，即，多笔输出。例如，你有20比特币的UTXO并且想支付 1 比特币，那么你的交易必须消耗掉整个 20 比特币的UTXO并且产生两个输出：一个是支付了 1 比特币给接收人，另一个是支付 19 比特币的找零到你的钱包 交易输出 就像原始交易一样，你不能将一个 100 元平均撕开作为 50 支付，同时你也可以使用多个零钱组装为 50 元，所以我们的一次交易通常有多笔输入输出。被交易消耗的 UTXO 被称为交易输入，由交易创建的 UTXO 被称为交易输出。 输入和输出到底先有哪个，其实是现有输出，因为我们可以默认第一笔输入就是创世区块中系统的输入 每一笔比特币交易输出都会被记录下来，所有的输出都是作为另一个输入，然后被用于新的支付 输出结构 尺寸 字段 说明 8字节 总量 用聪表示的比特币值 1-9字节 锁定脚本尺寸 用字节表示的后面的锁定脚本的长度 边长 锁定脚本 一个定义了支付输出所需条件的脚本 支付条件 交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上 这个锁定脚本一般是个地址，通过签名可以解锁这个地址的使用权，再去支付给别人 交易输入 简单的说，交易输入就是指向 UTXO 的指针，考虑一下，因为 UTXO 不可分割的特性，用户的余额就是所有没被指向输入的输出 一个交易的输入需要一个解锁脚本，用来满足 UTXO 的支付条件，解锁脚本通常是一个签名，用于证明对于锁定脚本中的比特币地址的所有权 尺寸 字段 说明 32字节 交易 指向交易包含的被花费的 UTXO 的指针 4字节 索引 被话费的 UTXO 的索引 1-9字节 解锁脚本尺寸 用于解锁脚本的大小 边长 解锁脚本 一个达到 UTXO 锁定脚本中条件的脚本 4字节 序列号 目前未被使用的交易替换功能，设成0xFFFFFFFF处 （会不会一个输出被多次使用作为输入） 交易费 交易费可当做是为了包含一笔交易到一个区块中的奖励，交易费被矿工挖到，并记录在这个交易的区块中 交易费基于交易的尺寸，基于千字节来计算，而不是比特币的价值。总的来说，交易费基于市场所设置，生效于比特币网络中。矿工依据许多不同的标准，按重要性对交易进行排序，这包括费用，并且甚至可能在某种特定情况下免费处理交易。交易费影响处理优先级，这意味着有足够费用的交易会更可能地被包含在下一个挖出的区块中；与此同时，交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，并且没有交易费的交易也许最终会被处理，但是，包含交易费将提高处理优先级交易费在交易中并没有特殊的字段，而是通过输入 - 输出 = 差，得到交易费 在交易中并没有交易费的字段，而是由矿工决定，如果矿工觉得没有任何交易费则不处理该交易，则他可能不会被计入到区块中，则交易不成立 交易链条和孤立交易 随着交易的进行，他们组成了一个链条，每一笔交易都是基于之前的交易。 如果发生了一个父交易，在父交易没有被确定之前又产生了一个基于他的子交易，而子交易在父交易之前到达其他节点。这种情况下，节点会首先接受这个交易，而不能找到参考他的父交易，节点不会立即抛弃这个交易，而是将他放在临时交易池中，并将此交易广播给其他节点。 没有父交易的交易池被称为孤立交易池，一旦接受到父节点，所有与该父节点有关的交易都会被释放，递归地重新验证，然后整个交易链都会被交易池包括进去，并等待其他区块所挖走。内存中存储的孤立交易是有限的，这是为了防止客户端的 Dos 攻击 交易脚本 每一笔交易都有锁定脚本和解锁脚本，通常锁定脚本是使用公钥锁定，解锁脚本则是通过私钥生成的数字签名 每一个比特币客户端会通过同时执行锁定和解锁脚本来验证一笔交易，从本质上来说，交易成立需要锁定和解锁，但是比特币作为可编程货币，提供了灵活的验证脚本，从而变出多种交易模式 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"对比特币来说，其他的所有模块都是为了保证交易的生成，在比特网络中得以传播和验证，并最终被添加在比特币总账簿 如果说钱包提供了身份证明和财产的证明和锁定，那么交易提供了财产的流动，如果失去了交易，那么钱包存在的意义并不大 一笔比特币交易的生命周期起始于它被创建的那刻（诞生 origination），任何人都可以发起交易，哪怕是和自己无关的交易。 随后，比特币交易会被以个或者多个签名加密，这些签名标志着对该交易指向的比特币资金的使用许可。接下来，比特币交易被广播到比特币网络中，每个节点都会做（比特币交易参与者）验证、如果交易信息通过验证，就将交易在网络中继续广播，同时，交易发起者会收到一条表示交易有效并被接受的返回信息。如果这笔交易被验证为有效，这个节点会拒绝接受这笔交易且同时返回给交易发起者一条表示交易被拒绝的信息，直到这笔交易被网络中绝多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中 这又分为几个过程 - 创建交易信息 - 网络中广播并验证 - 加入区块链 交易 交易信息 交易信息类似一张支票，可以理解为一个数据结构，一笔交易（这个数据结构）可以由任何人创建发起，关键是资金支付人的签名 交易信息结构 大小 字段 描述 4字节 版本 明确这笔交易的规则 1-9字节 输入数量 被包含的输入数量 不定 输入 一个或多个交易 1-9字节 输出数量 被包含的输出数量 不定 输出 一个或多个输出交易 4字节 时钟时间 一个UNIX时间戳或区块号 交易也可以指定锁定时间，即可以被加在区块中的最早时间，就像延期一个支票的生效时间 比特币交易的基本单位是不可分割的 UTXO，他可以是一聪的任意倍数，1比特币 = 一千万聪，一个用户接受比特币时，UTXO被存在区块中，实际上不存在交易的地址和签名，有的只是被锁住的分散在各个区块中的 UTXO，通过对区块链整个的推导计算，可以得到所有人拥有的 UTXO 即，余额 在比特币的世界中既没有账号也没有余额，只有分散到区块链中的UTXO 一个 UTXO 可以使 1聪 的任意倍，但是一个 UTXO 一旦被创造出来，使用时就无法再分割了，只能作为一个整体支付，所以一般支付时都会存在找零，即，多笔输出。例如，你有20比特币的UTXO并且想支付 1 比特币，那么你的交易必须消耗掉整个 20 比特币的UTXO并且产生两个输出：一个是支付了 1 比特币给接收人，另一个是支付 19 比特币的找零到你的钱包 交易输出 就像原始交易一样，你不能将一个 100 元平均撕开作为 50 支付，同时你也可以使用多个零钱组装为 50 元，所以我们的一次交易通常有多笔输入输出。被交易消耗的 UTXO 被称为交易输入，由交易创建的 UTXO 被称为交易输出。 输入和输出到底先有哪个，其实是现有输出，因为我们可以默认第一笔输入就是创世区块中系统的输入 每一笔比特币交易输出都会被记录下来，所有的输出都是作为另一个输入，然后被用于新的支付 输出结构 尺寸 字段 说明 8字节 总量 用聪表示的比特币值 1-9字节 锁定脚本尺寸 用字节表示的后面的锁定脚本的长度 边长 锁定脚本 一个定义了支付输出所需条件的脚本 支付条件 交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上 这个锁定脚本一般是个地址，通过签名可以解锁这个地址的使用权，再去支付给别人 交易输入 简单的说，交易输入就是指向 UTXO 的指针，考虑一下，因为 UTXO 不可分割的特性，用户的余额就是所有没被指向输入的输出 一个交易的输入需要一个解锁脚本，用来满足 UTXO 的支付条件，解锁脚本通常是一个签名，用于证明对于锁定脚本中的比特币地址的所有权 尺寸 字段 说明 32字节 交易 指向交易包含的被花费的 UTXO 的指针 4字节 索引 被话费的 UTXO 的索引 1-9字节 解锁脚本尺寸 用于解锁脚本的大小 边长 解锁脚本 一个达到 UTXO 锁定脚本中条件的脚本 4字节 序列号 目前未被使用的交易替换功能，设成0xFFFFFFFF处 （会不会一个输出被多次使用作为输入） 交易费 交易费可当做是为了包含一笔交易到一个区块中的奖励，交易费被矿工挖到，并记录在这个交易的区块中 交易费基于交易的尺寸，基于千字节来计算，而不是比特币的价值。总的来说，交易费基于市场所设置，生效于比特币网络中。矿工依据许多不同的标准，按重要性对交易进行排序，这包括费用，并且甚至可能在某种特定情况下免费处理交易。交易费影响处理优先级，这意味着有足够费用的交易会更可能地被包含在下一个挖出的区块中；与此同时，交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，并且没有交易费的交易也许最终会被处理，但是，包含交易费将提高处理优先级交易费在交易中并没有特殊的字段，而是通过输入 - 输出 = 差，得到交易费 在交易中并没有交易费的字段，而是由矿工决定，如果矿工觉得没有任何交易费则不处理该交易，则他可能不会被计入到区块中，则交易不成立 交易链条和孤立交易 随着交易的进行，他们组成了一个链条，每一笔交易都是基于之前的交易。 如果发生了一个父交易，在父交易没有被确定之前又产生了一个基于他的子交易，而子交易在父交易之前到达其他节点。这种情况下，节点会首先接受这个交易，而不能找到参考他的父交易，节点不会立即抛弃这个交易，而是将他放在临时交易池中，并将此交易广播给其他节点。 没有父交易的交易池被称为孤立交易池，一旦接受到父节点，所有与该父节点有关的交易都会被释放，递归地重新验证，然后整个交易链都会被交易池包括进去，并等待其他区块所挖走。内存中存储的孤立交易是有限的，这是为了防止客户端的 Dos 攻击 交易脚本 每一笔交易都有锁定脚本和解锁脚本，通常锁定脚本是使用公钥锁定，解锁脚本则是通过私钥生成的数字签名 每一个比特币客户端会通过同时执行锁定和解锁脚本来验证一笔交易，从本质上来说，交易成立需要锁定和解锁，但是比特币作为可编程货币，提供了灵活的验证脚本，从而变出多种交易模式 阅读更多","@type":"BlogPosting","url":"/2018/08/18/9a08b6039bbb344ba7ded53773434368.html","headline":"比特币入门-交易","dateModified":"2018-08-18T00:00:00+08:00","datePublished":"2018-08-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/18/9a08b6039bbb344ba7ded53773434368.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币入门-交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>对比特币来说，其他的所有模块都是为了保证交易的生成，在比特网络中得以传播和验证，并最终被添加在比特币总账簿</p> 
  <p>如果说钱包提供了身份证明和财产的证明和锁定，那么交易提供了财产的流动，如果失去了交易，那么钱包存在的意义并不大</p> 
  <p>一笔比特币交易的生命周期起始于它被创建的那刻（诞生 origination），任何人都可以发起交易，哪怕是和自己无关的交易。 随后，比特币交易会被以个或者多个签名加密，这些签名标志着对该交易指向的比特币资金的使用许可。接下来，比特币交易被广播到比特币网络中，每个节点都会做（比特币交易参与者）验证、如果交易信息通过验证，就将交易在网络中继续广播，同时，交易发起者会收到一条表示交易有效并被接受的返回信息。如果这笔交易被验证为有效，这个节点会拒绝接受这笔交易且同时返回给交易发起者一条表示交易被拒绝的信息，直到这笔交易被网络中绝多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中</p> 
  <p>这又分为几个过程 <br> - 创建交易信息 <br> - 网络中广播并验证 <br> - 加入区块链</p> 
  <h1 id="交易">交易</h1> 
  <h2 id="交易信息">交易信息</h2> 
  <p>交易信息类似一张支票，可以理解为一个数据结构，一笔交易（这个数据结构）可以由任何人创建发起，关键是资金支付人的签名</p> 
  <p>交易信息结构</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">大小</th> 
     <th align="center">字段</th> 
     <th align="center">描述</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td align="center">4字节</td> 
     <td align="center">版本</td> 
     <td align="center">明确这笔交易的规则</td> 
    </tr> 
    <tr> 
     <td align="center">1-9字节</td> 
     <td align="center">输入数量</td> 
     <td align="center">被包含的输入数量</td> 
    </tr> 
    <tr> 
     <td align="center">不定</td> 
     <td align="center">输入</td> 
     <td align="center">一个或多个交易</td> 
    </tr> 
    <tr> 
     <td align="center">1-9字节</td> 
     <td align="center">输出数量</td> 
     <td align="center">被包含的输出数量</td> 
    </tr> 
    <tr> 
     <td align="center">不定</td> 
     <td align="center">输出</td> 
     <td align="center">一个或多个输出交易</td> 
    </tr> 
    <tr> 
     <td align="center">4字节</td> 
     <td align="center">时钟时间</td> 
     <td align="center">一个UNIX时间戳或区块号</td> 
    </tr> 
   </tbody>
  </table> 
  <blockquote> 
   <p>交易也可以指定锁定时间，即可以被加在区块中的最早时间，就像延期一个支票的生效时间</p> 
  </blockquote> 
  <p>比特币交易的基本单位是不可分割的 UTXO，他可以是一聪的任意倍数，1比特币 = 一千万聪，一个用户接受比特币时，UTXO被存在区块中，实际上不存在交易的地址和签名，有的只是被锁住的分散在各个区块中的 UTXO，通过对区块链整个的推导计算，可以得到所有人拥有的 UTXO 即，余额</p> 
  <blockquote> 
   <p>在比特币的世界中既没有账号也没有余额，只有分散到区块链中的UTXO</p> 
  </blockquote> 
  <p>一个 UTXO 可以使 1聪 的任意倍，但是一个 UTXO 一旦被创造出来，使用时就无法再分割了，只能作为一个整体支付，所以一般支付时都会存在找零，即，多笔输出。例如，你有20比特币的UTXO并且想支付 1 比特币，那么你的交易必须消耗掉整个 20 比特币的UTXO并且产生两个输出：一个是支付了 1 比特币给接收人，另一个是支付 19 比特币的找零到你的钱包</p> 
  <h2 id="交易输出">交易输出</h2> 
  <p>就像原始交易一样，你不能将一个 100 元平均撕开作为 50 支付，同时你也可以使用多个零钱组装为 50 元，所以我们的一次交易通常有多笔输入输出。被交易消耗的 UTXO 被称为交易输入，由交易创建的 UTXO 被称为交易输出。</p> 
  <p>输入和输出到底先有哪个，其实是现有输出，因为我们可以默认第一笔输入就是创世区块中系统的输入</p> 
  <p>每一笔比特币交易输出都会被记录下来，所有的输出都是作为另一个输入，然后被用于新的支付</p> 
  <p>输出结构</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">尺寸</th> 
     <th align="center">字段</th> 
     <th align="center">说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td align="center">8字节</td> 
     <td align="center">总量</td> 
     <td align="center">用聪表示的比特币值</td> 
    </tr> 
    <tr> 
     <td align="center">1-9字节</td> 
     <td align="center">锁定脚本尺寸</td> 
     <td align="center">用字节表示的后面的锁定脚本的长度</td> 
    </tr> 
    <tr> 
     <td align="center">边长</td> 
     <td align="center">锁定脚本</td> 
     <td align="center">一个定义了支付输出所需条件的脚本</td> 
    </tr> 
   </tbody>
  </table> 
  <h3 id="支付条件">支付条件</h3> 
  <p>交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上</p> 
  <p>这个锁定脚本一般是个地址，通过签名可以解锁这个地址的使用权，再去支付给别人</p> 
  <h2 id="交易输入">交易输入</h2> 
  <p>简单的说，交易输入就是指向 UTXO 的指针，考虑一下，因为 UTXO 不可分割的特性，用户的余额就是所有没被指向输入的输出</p> 
  <p>一个交易的输入需要一个解锁脚本，用来满足 UTXO 的支付条件，解锁脚本通常是一个签名，用于证明对于锁定脚本中的比特币地址的所有权</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">尺寸</th> 
     <th align="center">字段</th> 
     <th align="center">说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td align="center">32字节</td> 
     <td align="center">交易</td> 
     <td align="center">指向交易包含的被花费的 UTXO 的指针</td> 
    </tr> 
    <tr> 
     <td align="center">4字节</td> 
     <td align="center">索引</td> 
     <td align="center">被话费的 UTXO 的索引</td> 
    </tr> 
    <tr> 
     <td align="center">1-9字节</td> 
     <td align="center">解锁脚本尺寸</td> 
     <td align="center">用于解锁脚本的大小</td> 
    </tr> 
    <tr> 
     <td align="center">边长</td> 
     <td align="center">解锁脚本</td> 
     <td align="center">一个达到 UTXO 锁定脚本中条件的脚本</td> 
    </tr> 
    <tr> 
     <td align="center">4字节</td> 
     <td align="center">序列号</td> 
     <td align="center">目前未被使用的交易替换功能，设成0xFFFFFFFF处</td> 
    </tr> 
   </tbody>
  </table> 
  <p>（会不会一个输出被多次使用作为输入）</p> 
  <h2 id="交易费">交易费</h2> 
  <p>交易费可当做是为了包含一笔交易到一个区块中的奖励，交易费被矿工挖到，并记录在这个交易的区块中</p> 
  <p>交易费基于交易的尺寸，基于千字节来计算，而不是比特币的价值。总的来说，交易费基于市场所设置，生效于比特币网络中。矿工依据许多不同的标准，按重要性对交易进行排序，这包括费用，并且甚至可能在某种特定情况下免费处理交易。交易费影响处理优先级，这意味着有足够费用的交易会更可能地被包含在下一个挖出的区块中；与此同时，交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，并且没有交易费的交易也许最终会被处理，但是，包含交易费将提高处理优先级交易费在交易中并没有特殊的字段，而是通过输入 - 输出 = 差，得到交易费</p> 
  <p>在交易中并没有交易费的字段，而是由矿工决定，如果矿工觉得没有任何交易费则不处理该交易，则他可能不会被计入到区块中，则交易不成立</p> 
  <h2 id="交易链条和孤立交易">交易链条和孤立交易</h2> 
  <p>随着交易的进行，他们组成了一个链条，每一笔交易都是基于之前的交易。</p> 
  <p>如果发生了一个父交易，在父交易没有被确定之前又产生了一个基于他的子交易，而子交易在父交易之前到达其他节点。这种情况下，节点会首先接受这个交易，而不能找到参考他的父交易，节点不会立即抛弃这个交易，而是将他放在临时交易池中，并将此交易广播给其他节点。</p> 
  <p>没有父交易的交易池被称为孤立交易池，一旦接受到父节点，所有与该父节点有关的交易都会被释放，递归地重新验证，然后整个交易链都会被交易池包括进去，并等待其他区块所挖走。内存中存储的孤立交易是有限的，这是为了防止客户端的 Dos 攻击</p> 
  <h2 id="交易脚本">交易脚本</h2> 
  <p>每一笔交易都有锁定脚本和解锁脚本，通常锁定脚本是使用公钥锁定，解锁脚本则是通过私钥生成的数字签名</p> 
  <p>每一个比特币客户端会通过同时执行锁定和解锁脚本来验证一笔交易，从本质上来说，交易成立需要锁定和解锁，但是比特币作为可编程货币，提供了灵活的验证脚本，从而变出多种交易模式</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_39653200/article/details/81812247,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_39653200/article/details/81812247,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
