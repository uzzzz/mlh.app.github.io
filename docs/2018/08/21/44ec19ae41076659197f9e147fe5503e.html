<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13-数据结构-区块 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13-数据结构-区块" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81874834 目录 CBlockHeader CBlock CBlockIndex CChain CMerkleTx CWalletTx 在了解挖矿前先来看下区块的结构。 在比特币的p2p网络中，每个节点都保存有一个区块链副本。所谓的区块链由相互连接的区块（）所构成，每个区块中包含多笔交易，为了便于存储、搜索、读取在内存和磁盘中的区块和交易信息，比特币引入一些访问类，包括索引区块的CBlockIndex、CDiskBlockIndex 和索引交易。 CBlockHeader 是CBlock的父类，所以先介绍CBlockHeader,这个类是区块头的数据结构 uint256: 256-bit opaque blob. blob:binary large objects. 字段尺寸 描述 数据类型 说明 4 nVersion int32_t block的版本信息，基于创建该区块的软件版本 32 hashPrevBlock uint256 该区块前一区块的hash值 32 hashMerkleRoot uint256 与该区块相关的全部交易的hash(Merkle树)，Merkle树是hash的二叉树，在比特币中使用两次SHA-256算法来生成Merkle树 4 nTime uint32_t 记录block创建时间的时间戳 4 nBits uint32_t 创建block的计算难度 4 nNonce uint32_t 用于生成这一block的Nonce值 主要看下这段代码的数据结构，函数比较简单 //block.h /*网络中的节点将新的交易收集到块中，把他们散列到哈希树(Merkle树)中，然后遍历随机数以使得块的hash值满足工作量证明要求 *当节点找到满足要求的一个随机数，就把块广播给其节点，并添加到区块链上，每个区块的第一个交易都是coinbase交易。*/ class CBlockHeader { public: // header int32_t nVersion; uint256 hashPrevBlock; uint256 hashMerkleRoot; uint32_t nTime; uint32_t nBits; uint32_t nNonce; CBlockHeader() { SetNull(); } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(this-&gt;nVersion); READWRITE(hashPrevBlock); READWRITE(hashMerkleRoot); READWRITE(nTime); READWRITE(nBits); READWRITE(nNonce); } void SetNull() { nVersion = 0; hashPrevBlock.SetNull(); hashMerkleRoot.SetNull(); nTime = 0; nBits = 0; nNonce = 0; } bool IsNull() const { return (nBits == 0); } uint256 GetHash() const; int64_t GetBlockTime() const { return (int64_t)nTime; } }; ##GetHash() //1. blocp.cpp uint256 CBlockHeader::GetHash() const { return SerializeHash(*this); } //2. hash.h /** Compute the 256-bit hash of an object&#39;s serialization. */ template&lt;typename T&gt; uint256 SerializeHash(const T&amp; obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION) { CHashWriter ss(nType, nVersion); ss &lt;&lt; obj; return ss.GetHash(); } //3. class CHashWriter // invalidates the object uint256 GetHash() { uint256 result; ctx.Finalize((unsigned char*)&amp;result);//ctx是v return result; } 可以看到对区块获取hash值是使用区块头的数据计算所得，不包括交易容器vtx,当然区块的hash与交易是有关的 ，hashMerkleRoot是区块头的一部分，该成员变量由函数BlockMerkleRoot计算所得，用到的参数是block.vtx，也就是交易部分 //merkle.h /* * Compute the Merkle root of the transactions in a block. * *mutated is set to true if a duplicated subtree was found. */ uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated = NULL); 关于merkle树，可以参考src/consensus/目录下的merkle.cpp的注释 CBlock CBlock公有继承类CBlockHeader 字段尺寸 描述 数据类型 说明 80 CBlockHeader 区块头 vtx vector&lt;CTransaction&gt; 所有的交易 fChecked mutable bool 交易是否验证过并构成Merkle树 //block.h class CBlock : public CBlockHeader { public: // network and disk std::vector&lt;CTransaction&gt; vtx; // memory only mutable bool fChecked; CBlock() { SetNull(); } CBlock(const CBlockHeader &amp;header) { SetNull(); *((CBlockHeader*)this) = header; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(*(CBlockHeader*)this); READWRITE(vtx); } void SetNull() { CBlockHeader::SetNull(); vtx.clear(); fChecked = false; } CBlockHeader GetBlockHeader() const { CBlockHeader block; block.nVersion = nVersion; block.hashPrevBlock = hashPrevBlock; block.hashMerkleRoot = hashMerkleRoot; block.nTime = nTime; block.nBits = nBits; block.nNonce = nNonce; return block; } std::string ToString() const; }; CBlockIndex 区块链是树状结构，从根部的起源块开始，每个块可能具有多个候选者作为下一个块。 块索引可能有多个pprev指向它，但最多其中一个可以是当前活动分支的一部分。 class CBlockIndex { public: //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex const uint256* phashBlock;//指向区块hash的指针 //! pointer to the index of the predecessor of this block CBlockIndex* pprev;//指向当前区块前一区块索引的指针 //! pointer to the index of some further predecessor of this block CBlockIndex* pskip;//指向前几区块的指针 //! height of the entry in the chain. The genesis block has height 0 int nHeight;//从创世块开始的高度 //! Which # file this block is stored in (blk?????.dat) int nFile;//这个区块保存在哪个文件 //! Byte offset within blk?????.dat where this block&#39;s data is stored unsigned int nDataPos; //! Byte offset within rev?????.dat where this block&#39;s undo data is stored unsigned int nUndoPos; //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block arith_uint256 nChainWork; //! Number of transactions in this block. //! Note: in a potential headers-first mode, this number cannot be relied upon unsigned int nTx;//交易数 //! (memory only) Number of transactions in the chain up to and including this block. //! This value will be non-zero only if and only if transactions for this block and all its parents are available. //! Change to 64-bit type when necessary; won&#39;t happen before 2030 unsigned int nChainTx; //! Verification status of this block. See enum BlockStatus unsigned int nStatus; //! block header 区块头 int nVersion; uint256 hashMerkleRoot; unsigned int nTime; unsigned int nBits; unsigned int nNonce; //! (memory only) Sequential id assigned to distinguish order in which blocks are received. uint32_t nSequenceId; ··· 对比上面两个类，可以看到CBlock是纯数据（区块的交易数据和区块头），而CBlockIndex则包含区块链相关的信息（例如指向父区块的指针，在区块链上的高度等等） CChain CChain chainActive; chainActive是定义在main.cpp的全局变量，代表的是当前有最大累计工作量的分支，可以看到CChain是有一个数组保存CBlockIndex*，并且重写了一些操作符，方便检索到任意高度的区块。 /** An in-memory indexed chain of blocks. */ class CChain { private: std::vector&lt;CBlockIndex*&gt; vChain; public: /** Returns the index entry for the genesis block of this chain, or NULL if none. */ CBlockIndex *Genesis() const { return vChain.size() &gt; 0 ? vChain[0] : NULL; } /** Returns the index entry for the tip of this chain, or NULL if none. */ CBlockIndex *Tip() const { return vChain.size() &gt; 0 ? vChain[vChain.size() - 1] : NULL; } /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */ CBlockIndex *operator[](int nHeight) const { if (nHeight &lt; 0 || nHeight &gt;= (int)vChain.size()) return NULL; return vChain[nHeight]; } /** Compare two chains efficiently. */ friend bool operator==(const CChain &amp;a, const CChain &amp;b) { return a.vChain.size() == b.vChain.size() &amp;&amp; a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1]; } /** Efficiently check whether a block is present in this chain. */ bool Contains(const CBlockIndex *pindex) const { return (*this)[pindex-&gt;nHeight] == pindex; } /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */ CBlockIndex *Next(const CBlockIndex *pindex) const { if (Contains(pindex)) return (*this)[pindex-&gt;nHeight + 1]; else return NULL; } /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()-&gt;nHeight : -1. */ int Height() const { return vChain.size() - 1; } /** Set/initialize a chain with a given tip. */ void SetTip(CBlockIndex *pindex); /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */ CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const; /** Find the last common block between this chain and a block index entry. */ const CBlockIndex *FindFork(const CBlockIndex *pindex) const; }; 下面来看继承自类CTransaction的两个类 CMerkleTx 一个交易带有一个能把它连接到区块链上的 merkle 分支 /** A transaction with a merkle branch linking it to the block chain. */ class CMerkleTx : public CTransaction { private: /** Constant used in hashBlock to indicate tx has been abandoned */ static const uint256 ABANDON_HASH; public: uint256 hashBlock; /* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest * block in the chain we know this or any in-wallet dependency conflicts * with. Older clients interpret nIndex == -1 as unconfirmed for backward * compatibility. */ int nIndex; CMerkleTx() { Init(); } CMerkleTx(const CTransaction&amp; txIn) : CTransaction(txIn) { Init(); } void Init() { hashBlock = uint256(); nIndex = -1; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { std::vector&lt;uint256&gt; vMerkleBranch; // For compatibility with older versions. READWRITE(*(CTransaction*)this); nVersion = this-&gt;nVersion; READWRITE(hashBlock); READWRITE(vMerkleBranch); READWRITE(nIndex); } int SetMerkleBranch(const CBlock&amp; block); /** * Return depth of transaction in blockchain: * &lt;0 : conflicts with a transaction this deep in the blockchain * 0 : in memory pool, waiting to be included in a block * &gt;=1 : this many blocks deep in the main chain */ int GetDepthInMainChain(const CBlockIndex* &amp;pindexRet) const; int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); } bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) &gt; 0; } int GetBlocksToMaturity() const; /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */ bool AcceptToMemoryPool(bool fLimitFree, const CAmount nAbsurdFee, CValidationState&amp; state); bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); } bool isAbandoned() const { return (hashBlock == ABANDON_HASH); } void setAbandoned() { hashBlock = ABANDON_HASH; } }; 这个类可以方便的验证一个交易是否属于一个区块。 CWalletTx 包含大量附加信息的交易，只有(这笔交易)所有者关心。 它包括将其链接回块链所需的任何未记录的事务。 //wallet.h /** * A transaction with a bunch of additional info that only the owner cares about. * It includes any unrecorded transactions needed to link it back to the block chain. */ class CWalletTx : public CMerkleTx { private: const CWallet* pwallet; public: mapValue_t mapValue; std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; vOrderForm; unsigned int fTimeReceivedIsTxTime; unsigned int nTimeReceived; //!&lt; time received by this node unsigned int nTimeSmart; char fFromMe; std::string strFromAccount; int64_t nOrderPos; //!&lt; position in ordered transaction list ··· 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81874834 目录 CBlockHeader CBlock CBlockIndex CChain CMerkleTx CWalletTx 在了解挖矿前先来看下区块的结构。 在比特币的p2p网络中，每个节点都保存有一个区块链副本。所谓的区块链由相互连接的区块（）所构成，每个区块中包含多笔交易，为了便于存储、搜索、读取在内存和磁盘中的区块和交易信息，比特币引入一些访问类，包括索引区块的CBlockIndex、CDiskBlockIndex 和索引交易。 CBlockHeader 是CBlock的父类，所以先介绍CBlockHeader,这个类是区块头的数据结构 uint256: 256-bit opaque blob. blob:binary large objects. 字段尺寸 描述 数据类型 说明 4 nVersion int32_t block的版本信息，基于创建该区块的软件版本 32 hashPrevBlock uint256 该区块前一区块的hash值 32 hashMerkleRoot uint256 与该区块相关的全部交易的hash(Merkle树)，Merkle树是hash的二叉树，在比特币中使用两次SHA-256算法来生成Merkle树 4 nTime uint32_t 记录block创建时间的时间戳 4 nBits uint32_t 创建block的计算难度 4 nNonce uint32_t 用于生成这一block的Nonce值 主要看下这段代码的数据结构，函数比较简单 //block.h /*网络中的节点将新的交易收集到块中，把他们散列到哈希树(Merkle树)中，然后遍历随机数以使得块的hash值满足工作量证明要求 *当节点找到满足要求的一个随机数，就把块广播给其节点，并添加到区块链上，每个区块的第一个交易都是coinbase交易。*/ class CBlockHeader { public: // header int32_t nVersion; uint256 hashPrevBlock; uint256 hashMerkleRoot; uint32_t nTime; uint32_t nBits; uint32_t nNonce; CBlockHeader() { SetNull(); } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(this-&gt;nVersion); READWRITE(hashPrevBlock); READWRITE(hashMerkleRoot); READWRITE(nTime); READWRITE(nBits); READWRITE(nNonce); } void SetNull() { nVersion = 0; hashPrevBlock.SetNull(); hashMerkleRoot.SetNull(); nTime = 0; nBits = 0; nNonce = 0; } bool IsNull() const { return (nBits == 0); } uint256 GetHash() const; int64_t GetBlockTime() const { return (int64_t)nTime; } }; ##GetHash() //1. blocp.cpp uint256 CBlockHeader::GetHash() const { return SerializeHash(*this); } //2. hash.h /** Compute the 256-bit hash of an object&#39;s serialization. */ template&lt;typename T&gt; uint256 SerializeHash(const T&amp; obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION) { CHashWriter ss(nType, nVersion); ss &lt;&lt; obj; return ss.GetHash(); } //3. class CHashWriter // invalidates the object uint256 GetHash() { uint256 result; ctx.Finalize((unsigned char*)&amp;result);//ctx是v return result; } 可以看到对区块获取hash值是使用区块头的数据计算所得，不包括交易容器vtx,当然区块的hash与交易是有关的 ，hashMerkleRoot是区块头的一部分，该成员变量由函数BlockMerkleRoot计算所得，用到的参数是block.vtx，也就是交易部分 //merkle.h /* * Compute the Merkle root of the transactions in a block. * *mutated is set to true if a duplicated subtree was found. */ uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated = NULL); 关于merkle树，可以参考src/consensus/目录下的merkle.cpp的注释 CBlock CBlock公有继承类CBlockHeader 字段尺寸 描述 数据类型 说明 80 CBlockHeader 区块头 vtx vector&lt;CTransaction&gt; 所有的交易 fChecked mutable bool 交易是否验证过并构成Merkle树 //block.h class CBlock : public CBlockHeader { public: // network and disk std::vector&lt;CTransaction&gt; vtx; // memory only mutable bool fChecked; CBlock() { SetNull(); } CBlock(const CBlockHeader &amp;header) { SetNull(); *((CBlockHeader*)this) = header; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(*(CBlockHeader*)this); READWRITE(vtx); } void SetNull() { CBlockHeader::SetNull(); vtx.clear(); fChecked = false; } CBlockHeader GetBlockHeader() const { CBlockHeader block; block.nVersion = nVersion; block.hashPrevBlock = hashPrevBlock; block.hashMerkleRoot = hashMerkleRoot; block.nTime = nTime; block.nBits = nBits; block.nNonce = nNonce; return block; } std::string ToString() const; }; CBlockIndex 区块链是树状结构，从根部的起源块开始，每个块可能具有多个候选者作为下一个块。 块索引可能有多个pprev指向它，但最多其中一个可以是当前活动分支的一部分。 class CBlockIndex { public: //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex const uint256* phashBlock;//指向区块hash的指针 //! pointer to the index of the predecessor of this block CBlockIndex* pprev;//指向当前区块前一区块索引的指针 //! pointer to the index of some further predecessor of this block CBlockIndex* pskip;//指向前几区块的指针 //! height of the entry in the chain. The genesis block has height 0 int nHeight;//从创世块开始的高度 //! Which # file this block is stored in (blk?????.dat) int nFile;//这个区块保存在哪个文件 //! Byte offset within blk?????.dat where this block&#39;s data is stored unsigned int nDataPos; //! Byte offset within rev?????.dat where this block&#39;s undo data is stored unsigned int nUndoPos; //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block arith_uint256 nChainWork; //! Number of transactions in this block. //! Note: in a potential headers-first mode, this number cannot be relied upon unsigned int nTx;//交易数 //! (memory only) Number of transactions in the chain up to and including this block. //! This value will be non-zero only if and only if transactions for this block and all its parents are available. //! Change to 64-bit type when necessary; won&#39;t happen before 2030 unsigned int nChainTx; //! Verification status of this block. See enum BlockStatus unsigned int nStatus; //! block header 区块头 int nVersion; uint256 hashMerkleRoot; unsigned int nTime; unsigned int nBits; unsigned int nNonce; //! (memory only) Sequential id assigned to distinguish order in which blocks are received. uint32_t nSequenceId; ··· 对比上面两个类，可以看到CBlock是纯数据（区块的交易数据和区块头），而CBlockIndex则包含区块链相关的信息（例如指向父区块的指针，在区块链上的高度等等） CChain CChain chainActive; chainActive是定义在main.cpp的全局变量，代表的是当前有最大累计工作量的分支，可以看到CChain是有一个数组保存CBlockIndex*，并且重写了一些操作符，方便检索到任意高度的区块。 /** An in-memory indexed chain of blocks. */ class CChain { private: std::vector&lt;CBlockIndex*&gt; vChain; public: /** Returns the index entry for the genesis block of this chain, or NULL if none. */ CBlockIndex *Genesis() const { return vChain.size() &gt; 0 ? vChain[0] : NULL; } /** Returns the index entry for the tip of this chain, or NULL if none. */ CBlockIndex *Tip() const { return vChain.size() &gt; 0 ? vChain[vChain.size() - 1] : NULL; } /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */ CBlockIndex *operator[](int nHeight) const { if (nHeight &lt; 0 || nHeight &gt;= (int)vChain.size()) return NULL; return vChain[nHeight]; } /** Compare two chains efficiently. */ friend bool operator==(const CChain &amp;a, const CChain &amp;b) { return a.vChain.size() == b.vChain.size() &amp;&amp; a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1]; } /** Efficiently check whether a block is present in this chain. */ bool Contains(const CBlockIndex *pindex) const { return (*this)[pindex-&gt;nHeight] == pindex; } /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */ CBlockIndex *Next(const CBlockIndex *pindex) const { if (Contains(pindex)) return (*this)[pindex-&gt;nHeight + 1]; else return NULL; } /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()-&gt;nHeight : -1. */ int Height() const { return vChain.size() - 1; } /** Set/initialize a chain with a given tip. */ void SetTip(CBlockIndex *pindex); /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */ CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const; /** Find the last common block between this chain and a block index entry. */ const CBlockIndex *FindFork(const CBlockIndex *pindex) const; }; 下面来看继承自类CTransaction的两个类 CMerkleTx 一个交易带有一个能把它连接到区块链上的 merkle 分支 /** A transaction with a merkle branch linking it to the block chain. */ class CMerkleTx : public CTransaction { private: /** Constant used in hashBlock to indicate tx has been abandoned */ static const uint256 ABANDON_HASH; public: uint256 hashBlock; /* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest * block in the chain we know this or any in-wallet dependency conflicts * with. Older clients interpret nIndex == -1 as unconfirmed for backward * compatibility. */ int nIndex; CMerkleTx() { Init(); } CMerkleTx(const CTransaction&amp; txIn) : CTransaction(txIn) { Init(); } void Init() { hashBlock = uint256(); nIndex = -1; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { std::vector&lt;uint256&gt; vMerkleBranch; // For compatibility with older versions. READWRITE(*(CTransaction*)this); nVersion = this-&gt;nVersion; READWRITE(hashBlock); READWRITE(vMerkleBranch); READWRITE(nIndex); } int SetMerkleBranch(const CBlock&amp; block); /** * Return depth of transaction in blockchain: * &lt;0 : conflicts with a transaction this deep in the blockchain * 0 : in memory pool, waiting to be included in a block * &gt;=1 : this many blocks deep in the main chain */ int GetDepthInMainChain(const CBlockIndex* &amp;pindexRet) const; int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); } bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) &gt; 0; } int GetBlocksToMaturity() const; /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */ bool AcceptToMemoryPool(bool fLimitFree, const CAmount nAbsurdFee, CValidationState&amp; state); bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); } bool isAbandoned() const { return (hashBlock == ABANDON_HASH); } void setAbandoned() { hashBlock = ABANDON_HASH; } }; 这个类可以方便的验证一个交易是否属于一个区块。 CWalletTx 包含大量附加信息的交易，只有(这笔交易)所有者关心。 它包括将其链接回块链所需的任何未记录的事务。 //wallet.h /** * A transaction with a bunch of additional info that only the owner cares about. * It includes any unrecorded transactions needed to link it back to the block chain. */ class CWalletTx : public CMerkleTx { private: const CWallet* pwallet; public: mapValue_t mapValue; std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; vOrderForm; unsigned int fTimeReceivedIsTxTime; unsigned int nTimeReceived; //!&lt; time received by this node unsigned int nTimeSmart; char fFromMe; std::string strFromAccount; int64_t nOrderPos; //!&lt; position in ordered transaction list ··· 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/21/44ec19ae41076659197f9e147fe5503e.html" />
<meta property="og:url" content="https://mlh.app/2018/08/21/44ec19ae41076659197f9e147fe5503e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81874834 目录 CBlockHeader CBlock CBlockIndex CChain CMerkleTx CWalletTx 在了解挖矿前先来看下区块的结构。 在比特币的p2p网络中，每个节点都保存有一个区块链副本。所谓的区块链由相互连接的区块（）所构成，每个区块中包含多笔交易，为了便于存储、搜索、读取在内存和磁盘中的区块和交易信息，比特币引入一些访问类，包括索引区块的CBlockIndex、CDiskBlockIndex 和索引交易。 CBlockHeader 是CBlock的父类，所以先介绍CBlockHeader,这个类是区块头的数据结构 uint256: 256-bit opaque blob. blob:binary large objects. 字段尺寸 描述 数据类型 说明 4 nVersion int32_t block的版本信息，基于创建该区块的软件版本 32 hashPrevBlock uint256 该区块前一区块的hash值 32 hashMerkleRoot uint256 与该区块相关的全部交易的hash(Merkle树)，Merkle树是hash的二叉树，在比特币中使用两次SHA-256算法来生成Merkle树 4 nTime uint32_t 记录block创建时间的时间戳 4 nBits uint32_t 创建block的计算难度 4 nNonce uint32_t 用于生成这一block的Nonce值 主要看下这段代码的数据结构，函数比较简单 //block.h /*网络中的节点将新的交易收集到块中，把他们散列到哈希树(Merkle树)中，然后遍历随机数以使得块的hash值满足工作量证明要求 *当节点找到满足要求的一个随机数，就把块广播给其节点，并添加到区块链上，每个区块的第一个交易都是coinbase交易。*/ class CBlockHeader { public: // header int32_t nVersion; uint256 hashPrevBlock; uint256 hashMerkleRoot; uint32_t nTime; uint32_t nBits; uint32_t nNonce; CBlockHeader() { SetNull(); } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(this-&gt;nVersion); READWRITE(hashPrevBlock); READWRITE(hashMerkleRoot); READWRITE(nTime); READWRITE(nBits); READWRITE(nNonce); } void SetNull() { nVersion = 0; hashPrevBlock.SetNull(); hashMerkleRoot.SetNull(); nTime = 0; nBits = 0; nNonce = 0; } bool IsNull() const { return (nBits == 0); } uint256 GetHash() const; int64_t GetBlockTime() const { return (int64_t)nTime; } }; ##GetHash() //1. blocp.cpp uint256 CBlockHeader::GetHash() const { return SerializeHash(*this); } //2. hash.h /** Compute the 256-bit hash of an object&#39;s serialization. */ template&lt;typename T&gt; uint256 SerializeHash(const T&amp; obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION) { CHashWriter ss(nType, nVersion); ss &lt;&lt; obj; return ss.GetHash(); } //3. class CHashWriter // invalidates the object uint256 GetHash() { uint256 result; ctx.Finalize((unsigned char*)&amp;result);//ctx是v return result; } 可以看到对区块获取hash值是使用区块头的数据计算所得，不包括交易容器vtx,当然区块的hash与交易是有关的 ，hashMerkleRoot是区块头的一部分，该成员变量由函数BlockMerkleRoot计算所得，用到的参数是block.vtx，也就是交易部分 //merkle.h /* * Compute the Merkle root of the transactions in a block. * *mutated is set to true if a duplicated subtree was found. */ uint256 BlockMerkleRoot(const CBlock&amp; block, bool* mutated = NULL); 关于merkle树，可以参考src/consensus/目录下的merkle.cpp的注释 CBlock CBlock公有继承类CBlockHeader 字段尺寸 描述 数据类型 说明 80 CBlockHeader 区块头 vtx vector&lt;CTransaction&gt; 所有的交易 fChecked mutable bool 交易是否验证过并构成Merkle树 //block.h class CBlock : public CBlockHeader { public: // network and disk std::vector&lt;CTransaction&gt; vtx; // memory only mutable bool fChecked; CBlock() { SetNull(); } CBlock(const CBlockHeader &amp;header) { SetNull(); *((CBlockHeader*)this) = header; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { READWRITE(*(CBlockHeader*)this); READWRITE(vtx); } void SetNull() { CBlockHeader::SetNull(); vtx.clear(); fChecked = false; } CBlockHeader GetBlockHeader() const { CBlockHeader block; block.nVersion = nVersion; block.hashPrevBlock = hashPrevBlock; block.hashMerkleRoot = hashMerkleRoot; block.nTime = nTime; block.nBits = nBits; block.nNonce = nNonce; return block; } std::string ToString() const; }; CBlockIndex 区块链是树状结构，从根部的起源块开始，每个块可能具有多个候选者作为下一个块。 块索引可能有多个pprev指向它，但最多其中一个可以是当前活动分支的一部分。 class CBlockIndex { public: //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex const uint256* phashBlock;//指向区块hash的指针 //! pointer to the index of the predecessor of this block CBlockIndex* pprev;//指向当前区块前一区块索引的指针 //! pointer to the index of some further predecessor of this block CBlockIndex* pskip;//指向前几区块的指针 //! height of the entry in the chain. The genesis block has height 0 int nHeight;//从创世块开始的高度 //! Which # file this block is stored in (blk?????.dat) int nFile;//这个区块保存在哪个文件 //! Byte offset within blk?????.dat where this block&#39;s data is stored unsigned int nDataPos; //! Byte offset within rev?????.dat where this block&#39;s undo data is stored unsigned int nUndoPos; //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block arith_uint256 nChainWork; //! Number of transactions in this block. //! Note: in a potential headers-first mode, this number cannot be relied upon unsigned int nTx;//交易数 //! (memory only) Number of transactions in the chain up to and including this block. //! This value will be non-zero only if and only if transactions for this block and all its parents are available. //! Change to 64-bit type when necessary; won&#39;t happen before 2030 unsigned int nChainTx; //! Verification status of this block. See enum BlockStatus unsigned int nStatus; //! block header 区块头 int nVersion; uint256 hashMerkleRoot; unsigned int nTime; unsigned int nBits; unsigned int nNonce; //! (memory only) Sequential id assigned to distinguish order in which blocks are received. uint32_t nSequenceId; ··· 对比上面两个类，可以看到CBlock是纯数据（区块的交易数据和区块头），而CBlockIndex则包含区块链相关的信息（例如指向父区块的指针，在区块链上的高度等等） CChain CChain chainActive; chainActive是定义在main.cpp的全局变量，代表的是当前有最大累计工作量的分支，可以看到CChain是有一个数组保存CBlockIndex*，并且重写了一些操作符，方便检索到任意高度的区块。 /** An in-memory indexed chain of blocks. */ class CChain { private: std::vector&lt;CBlockIndex*&gt; vChain; public: /** Returns the index entry for the genesis block of this chain, or NULL if none. */ CBlockIndex *Genesis() const { return vChain.size() &gt; 0 ? vChain[0] : NULL; } /** Returns the index entry for the tip of this chain, or NULL if none. */ CBlockIndex *Tip() const { return vChain.size() &gt; 0 ? vChain[vChain.size() - 1] : NULL; } /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */ CBlockIndex *operator[](int nHeight) const { if (nHeight &lt; 0 || nHeight &gt;= (int)vChain.size()) return NULL; return vChain[nHeight]; } /** Compare two chains efficiently. */ friend bool operator==(const CChain &amp;a, const CChain &amp;b) { return a.vChain.size() == b.vChain.size() &amp;&amp; a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1]; } /** Efficiently check whether a block is present in this chain. */ bool Contains(const CBlockIndex *pindex) const { return (*this)[pindex-&gt;nHeight] == pindex; } /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */ CBlockIndex *Next(const CBlockIndex *pindex) const { if (Contains(pindex)) return (*this)[pindex-&gt;nHeight + 1]; else return NULL; } /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()-&gt;nHeight : -1. */ int Height() const { return vChain.size() - 1; } /** Set/initialize a chain with a given tip. */ void SetTip(CBlockIndex *pindex); /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */ CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const; /** Find the last common block between this chain and a block index entry. */ const CBlockIndex *FindFork(const CBlockIndex *pindex) const; }; 下面来看继承自类CTransaction的两个类 CMerkleTx 一个交易带有一个能把它连接到区块链上的 merkle 分支 /** A transaction with a merkle branch linking it to the block chain. */ class CMerkleTx : public CTransaction { private: /** Constant used in hashBlock to indicate tx has been abandoned */ static const uint256 ABANDON_HASH; public: uint256 hashBlock; /* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest * block in the chain we know this or any in-wallet dependency conflicts * with. Older clients interpret nIndex == -1 as unconfirmed for backward * compatibility. */ int nIndex; CMerkleTx() { Init(); } CMerkleTx(const CTransaction&amp; txIn) : CTransaction(txIn) { Init(); } void Init() { hashBlock = uint256(); nIndex = -1; } ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action, int nType, int nVersion) { std::vector&lt;uint256&gt; vMerkleBranch; // For compatibility with older versions. READWRITE(*(CTransaction*)this); nVersion = this-&gt;nVersion; READWRITE(hashBlock); READWRITE(vMerkleBranch); READWRITE(nIndex); } int SetMerkleBranch(const CBlock&amp; block); /** * Return depth of transaction in blockchain: * &lt;0 : conflicts with a transaction this deep in the blockchain * 0 : in memory pool, waiting to be included in a block * &gt;=1 : this many blocks deep in the main chain */ int GetDepthInMainChain(const CBlockIndex* &amp;pindexRet) const; int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); } bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) &gt; 0; } int GetBlocksToMaturity() const; /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */ bool AcceptToMemoryPool(bool fLimitFree, const CAmount nAbsurdFee, CValidationState&amp; state); bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); } bool isAbandoned() const { return (hashBlock == ABANDON_HASH); } void setAbandoned() { hashBlock = ABANDON_HASH; } }; 这个类可以方便的验证一个交易是否属于一个区块。 CWalletTx 包含大量附加信息的交易，只有(这笔交易)所有者关心。 它包括将其链接回块链所需的任何未记录的事务。 //wallet.h /** * A transaction with a bunch of additional info that only the owner cares about. * It includes any unrecorded transactions needed to link it back to the block chain. */ class CWalletTx : public CMerkleTx { private: const CWallet* pwallet; public: mapValue_t mapValue; std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; vOrderForm; unsigned int fTimeReceivedIsTxTime; unsigned int nTimeReceived; //!&lt; time received by this node unsigned int nTimeSmart; char fFromMe; std::string strFromAccount; int64_t nOrderPos; //!&lt; position in ordered transaction list ··· 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/21/44ec19ae41076659197f9e147fe5503e.html","headline":"比特币源码学习0.13-数据结构-区块","dateModified":"2018-08-21T00:00:00+08:00","datePublished":"2018-08-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/21/44ec19ae41076659197f9e147fe5503e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13-数据结构-区块</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81874834 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <hr> 
  <p></p>
  <div class="toc">
   <h3>目录</h3>
   <ul>
    <li><a href="#CBlockHeader_6" rel="nofollow">CBlockHeader</a></li>
    <li><a href="#CBlock_112" rel="nofollow">CBlock</a></li>
    <li><a href="#CBlockIndex_173" rel="nofollow">CBlockIndex</a></li>
    <li><a href="#CChain_229" rel="nofollow">CChain</a></li>
    <li><a href="#CMerkleTx_295" rel="nofollow">CMerkleTx</a></li>
    <li><a href="#CWalletTx_365" rel="nofollow">CWalletTx</a></li>
   </ul>
  </div>
  <br> 在了解挖矿前先来看下区块的结构。
  <br> 在比特币的p2p网络中，每个节点都保存有一个区块链副本。所谓的区块链由相互连接的区块（）所构成，每个区块中包含多笔交易，为了便于存储、搜索、读取在内存和磁盘中的区块和交易信息，比特币引入一些访问类，包括索引区块的CBlockIndex、CDiskBlockIndex 和索引交易。
  <p></p> 
  <hr> 
  <h1><a id="CBlockHeader_6"></a>CBlockHeader</h1> 
  <p>是<code>CBlock</code>的父类，所以先介绍<code>CBlockHeader</code>,这个类是区块头的数据结构</p> 
  <blockquote> 
   <p><code>uint256</code>: 256-bit opaque blob.<br> <code>blob</code>:binary large objects.</p> 
  </blockquote> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="left">描述</th> 
     <th>数据类型</th> 
     <th align="left">说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>4</td> 
     <td align="left">nVersion</td> 
     <td>int32_t</td> 
     <td align="left">block的版本信息，基于创建该区块的软件版本</td> 
    </tr> 
    <tr> 
     <td>32</td> 
     <td align="left">hashPrevBlock</td> 
     <td>uint256</td> 
     <td align="left">该区块前一区块的hash值</td> 
    </tr> 
    <tr> 
     <td>32</td> 
     <td align="left">hashMerkleRoot</td> 
     <td>uint256</td> 
     <td align="left">与该区块相关的全部交易的hash(Merkle树)，Merkle树是hash的二叉树，在比特币中使用两次SHA-256算法来生成Merkle树</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="left">nTime</td> 
     <td>uint32_t</td> 
     <td align="left">记录block创建时间的时间戳</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="left">nBits</td> 
     <td>uint32_t</td> 
     <td align="left">创建block的计算难度</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="left">nNonce</td> 
     <td>uint32_t</td> 
     <td align="left">用于生成这一block的Nonce值</td> 
    </tr> 
   </tbody> 
  </table>
  <p>主要看下这段代码的数据结构，函数比较简单</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//block.h</span>
<span class="token comment">/*网络中的节点将新的交易收集到块中，把他们散列到哈希树(Merkle树)中，然后遍历随机数以使得块的hash值满足工作量证明要求 *当节点找到满足要求的一个随机数，就把块广播给其节点，并添加到区块链上，每个区块的第一个交易都是coinbase交易。*/</span>
class CBlockHeader
<span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    <span class="token comment">// header</span>
    int32_t nVersion<span class="token punctuation">;</span>
    uint256 hashPrevBlock<span class="token punctuation">;</span>
    uint256 hashMerkleRoot<span class="token punctuation">;</span>
    uint32_t nTime<span class="token punctuation">;</span>
    uint32_t nBits<span class="token punctuation">;</span>
    uint32_t nNonce<span class="token punctuation">;</span>

    <span class="token function">CBlockHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ADD_SERIALIZE_METHODS<span class="token punctuation">;</span>

    template <span class="token operator">&lt;</span>typename Stream<span class="token punctuation">,</span> typename Operation<span class="token operator">&gt;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">SerializationOp</span><span class="token punctuation">(</span>Stream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> Operation ser_action<span class="token punctuation">,</span> <span class="token keyword">int</span> nType<span class="token punctuation">,</span> <span class="token keyword">int</span> nVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>this<span class="token operator">-&gt;</span>nVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>hashPrevBlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>hashMerkleRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>nTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>nBits<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>nNonce<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        nVersion <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        hashPrevBlock<span class="token punctuation">.</span><span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMerkleRoot<span class="token punctuation">.</span><span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        nBits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        nNonce <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    bool <span class="token function">IsNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>nBits <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    uint256 <span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    int64_t <span class="token function">GetBlockTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>int64_t<span class="token punctuation">)</span>nTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>##GetHash()</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//1. blocp.cpp</span>
uint256 CBlockHeader<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">SerializeHash</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//2. hash.h</span>
<span class="token comment">/** Compute the 256-bit hash of an object's serialization. */</span>
template<span class="token operator">&lt;</span>typename T<span class="token operator">&gt;</span>
uint256 <span class="token function">SerializeHash</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> nType<span class="token operator">=</span>SER_GETHASH<span class="token punctuation">,</span> <span class="token keyword">int</span> nVersion<span class="token operator">=</span>PROTOCOL_VERSION<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CHashWriter <span class="token function">ss</span><span class="token punctuation">(</span>nType<span class="token punctuation">,</span> nVersion<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ss <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ss<span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//3. class CHashWriter </span>
 <span class="token comment">// invalidates the object</span>
    uint256 <span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        uint256 result<span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ctx是v</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
  <p>可以看到对区块获取hash值是使用区块头的数据计算所得，不包括交易容器vtx,当然区块的hash与交易是有关的 ，hashMerkleRoot是区块头的一部分，该成员变量由函数<code>BlockMerkleRoot</code>计算所得，用到的参数是block.vtx，也就是交易部分</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//merkle.h</span>
<span class="token comment">/* * Compute the Merkle root of the transactions in a block. * *mutated is set to true if a duplicated subtree was found. */</span>
uint256 <span class="token function">BlockMerkleRoot</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlock<span class="token operator">&amp;</span> block<span class="token punctuation">,</span> bool<span class="token operator">*</span> mutated <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>关于merkle树，可以参考src/consensus/目录下的merkle.cpp的注释</p> 
  <hr> 
  <h1><a id="CBlock_112"></a>CBlock</h1> 
  <p>CBlock公有继承类CBlockHeader</p> 
  <table> 
   <thead> 
    <tr> 
     <th>字段尺寸</th> 
     <th align="center">描述</th> 
     <th align="right">数据类型</th> 
     <th align="right">说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>80</td> 
     <td align="center">CBlockHeader</td> 
     <td align="right"></td> 
     <td align="right">区块头</td> 
    </tr> 
    <tr> 
     <td></td> 
     <td align="center">vtx</td> 
     <td align="right">vector&lt;<a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction" rel="nofollow">CTransaction</a>&gt;</td> 
     <td align="right">所有的交易</td> 
    </tr> 
    <tr> 
     <td></td> 
     <td align="center">fChecked</td> 
     <td align="right">mutable bool</td> 
     <td align="right">交易是否验证过并构成Merkle树</td> 
    </tr> 
   </tbody> 
  </table>
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//block.h</span>
class CBlock <span class="token punctuation">:</span> public CBlockHeader
<span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    <span class="token comment">// network and disk</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>CTransaction<span class="token operator">&gt;</span> vtx<span class="token punctuation">;</span>

    <span class="token comment">// memory only</span>
    mutable bool fChecked<span class="token punctuation">;</span>

    <span class="token function">CBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">CBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockHeader <span class="token operator">&amp;</span>header<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CBlockHeader<span class="token operator">*</span><span class="token punctuation">)</span>this<span class="token punctuation">)</span> <span class="token operator">=</span> header<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ADD_SERIALIZE_METHODS<span class="token punctuation">;</span>

    template <span class="token operator">&lt;</span>typename Stream<span class="token punctuation">,</span> typename Operation<span class="token operator">&gt;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">SerializationOp</span><span class="token punctuation">(</span>Stream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> Operation ser_action<span class="token punctuation">,</span> <span class="token keyword">int</span> nType<span class="token punctuation">,</span> <span class="token keyword">int</span> nVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>CBlockHeader<span class="token operator">*</span><span class="token punctuation">)</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        CBlockHeader<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">SetNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vtx<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fChecked <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    CBlockHeader <span class="token function">GetBlockHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        CBlockHeader block<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>nVersion       <span class="token operator">=</span> nVersion<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>hashPrevBlock  <span class="token operator">=</span> hashPrevBlock<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>hashMerkleRoot <span class="token operator">=</span> hashMerkleRoot<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>nTime          <span class="token operator">=</span> nTime<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>nBits          <span class="token operator">=</span> nBits<span class="token punctuation">;</span>
        block<span class="token punctuation">.</span>nNonce         <span class="token operator">=</span> nNonce<span class="token punctuation">;</span>
        <span class="token keyword">return</span> block<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <h1><a id="CBlockIndex_173"></a>CBlockIndex</h1> 
  <p>区块链是树状结构，从根部的起源块开始，每个块可能具有多个候选者作为下一个块。 块索引可能有多个pprev指向它，但最多其中一个可以是当前活动分支的一部分。</p> 
  <pre class=" language-c"><code class="prism  language-c">class CBlockIndex
<span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    <span class="token comment">//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex</span>
    <span class="token keyword">const</span> uint256<span class="token operator">*</span> phashBlock<span class="token punctuation">;</span><span class="token comment">//指向区块hash的指针</span>

    <span class="token comment">//! pointer to the index of the predecessor of this block</span>
    CBlockIndex<span class="token operator">*</span> pprev<span class="token punctuation">;</span><span class="token comment">//指向当前区块前一区块索引的指针</span>

    <span class="token comment">//! pointer to the index of some further predecessor of this block</span>
    CBlockIndex<span class="token operator">*</span> pskip<span class="token punctuation">;</span><span class="token comment">//指向前几区块的指针</span>

    <span class="token comment">//! height of the entry in the chain. The genesis block has height 0</span>
    <span class="token keyword">int</span> nHeight<span class="token punctuation">;</span><span class="token comment">//从创世块开始的高度</span>

    <span class="token comment">//! Which # file this block is stored in (blk?????.dat)</span>
    <span class="token keyword">int</span> nFile<span class="token punctuation">;</span><span class="token comment">//这个区块保存在哪个文件</span>

    <span class="token comment">//! Byte offset within blk?????.dat where this block's data is stored</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nDataPos<span class="token punctuation">;</span>

    <span class="token comment">//! Byte offset within rev?????.dat where this block's undo data is stored</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nUndoPos<span class="token punctuation">;</span>

    <span class="token comment">//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block</span>
    arith_uint256 nChainWork<span class="token punctuation">;</span>

    <span class="token comment">//! Number of transactions in this block.</span>
    <span class="token comment">//! Note: in a potential headers-first mode, this number cannot be relied upon</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTx<span class="token punctuation">;</span><span class="token comment">//交易数</span>

    <span class="token comment">//! (memory only) Number of transactions in the chain up to and including this block.</span>
    <span class="token comment">//! This value will be non-zero only if and only if transactions for this block and all its parents are available.</span>
    <span class="token comment">//! Change to 64-bit type when necessary; won't happen before 2030</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nChainTx<span class="token punctuation">;</span>

    <span class="token comment">//! Verification status of this block. See enum BlockStatus</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nStatus<span class="token punctuation">;</span>

    <span class="token comment">//! block header 区块头</span>
    <span class="token keyword">int</span> nVersion<span class="token punctuation">;</span>
    uint256 hashMerkleRoot<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTime<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nBits<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nNonce<span class="token punctuation">;</span>

    <span class="token comment">//! (memory only) Sequential id assigned to distinguish order in which blocks are received.</span>
  uint32_t nSequenceId<span class="token punctuation">;</span>
    ···
</code></pre> 
  <p>对比上面两个类，可以看到CBlock是纯数据（区块的交易数据和区块头），而CBlockIndex则包含区块链相关的信息（例如指向父区块的指针，在区块链上的高度等等）</p> 
  <hr> 
  <h1><a id="CChain_229"></a>CChain</h1> 
  <pre><code>CChain chainActive;
</code></pre> 
  <p>chainActive是定义在main.cpp的全局变量，代表的是当前有最大累计工作量的分支，可以看到CChain是有一个数组保存CBlockIndex*，并且重写了一些操作符，方便检索到任意高度的区块。</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">/** An in-memory indexed chain of blocks. */</span>
class CChain <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>CBlockIndex<span class="token operator">*</span><span class="token operator">&gt;</span> vChain<span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    <span class="token comment">/** Returns the index entry for the genesis block of this chain, or NULL if none. */</span>
    CBlockIndex <span class="token operator">*</span><span class="token function">Genesis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> vChain<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Returns the index entry for the tip of this chain, or NULL if none. */</span>
    CBlockIndex <span class="token operator">*</span><span class="token function">Tip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> vChain<span class="token punctuation">[</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */</span>
    CBlockIndex <span class="token operator">*</span>operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> nHeight<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nHeight <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nHeight <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> vChain<span class="token punctuation">[</span>nHeight<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Compare two chains efficiently. */</span>
    friend bool operator<span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> CChain <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> CChain <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
               a<span class="token punctuation">.</span>vChain<span class="token punctuation">[</span>a<span class="token punctuation">.</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">.</span>vChain<span class="token punctuation">[</span>b<span class="token punctuation">.</span>vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Efficiently check whether a block is present in this chain. */</span>
    bool <span class="token function">Contains</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindex<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span>pindex<span class="token operator">-&gt;</span>nHeight<span class="token punctuation">]</span> <span class="token operator">==</span> pindex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */</span>
    CBlockIndex <span class="token operator">*</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindex<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Contains</span><span class="token punctuation">(</span>pindex<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span>pindex<span class="token operator">-&gt;</span>nHeight <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()-&gt;nHeight : -1. */</span>
    <span class="token keyword">int</span> <span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> vChain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Set/initialize a chain with a given tip. */</span>
    <span class="token keyword">void</span> <span class="token function">SetTip</span><span class="token punctuation">(</span>CBlockIndex <span class="token operator">*</span>pindex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** Return a CBlockLocator that refers to a block in this chain (by default the tip). */</span>
    CBlockLocator <span class="token function">GetLocator</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindex <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token comment">/** Find the last common block between this chain and a block index entry. */</span>
    <span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span><span class="token function">FindFork</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindex<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <hr> 
  <p>下面来看继承自类CTransaction的两个类</p> 
  <h1><a id="CMerkleTx_295"></a>CMerkleTx</h1> 
  <p>一个交易带有一个能把它连接到区块链上的 merkle 分支</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">/** A transaction with a merkle branch linking it to the block chain. */</span>
class CMerkleTx <span class="token punctuation">:</span> public CTransaction
<span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
  <span class="token comment">/** Constant used in hashBlock to indicate tx has been abandoned */</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> uint256 ABANDON_HASH<span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    uint256 hashBlock<span class="token punctuation">;</span>

    <span class="token comment">/* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest * block in the chain we know this or any in-wallet dependency conflicts * with. Older clients interpret nIndex == -1 as unconfirmed for backward * compatibility. */</span>
    <span class="token keyword">int</span> nIndex<span class="token punctuation">;</span>

    <span class="token function">CMerkleTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">CMerkleTx</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction<span class="token operator">&amp;</span> txIn<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">CTransaction</span><span class="token punctuation">(</span>txIn<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        hashBlock <span class="token operator">=</span> <span class="token function">uint256</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ADD_SERIALIZE_METHODS<span class="token punctuation">;</span>

    template <span class="token operator">&lt;</span>typename Stream<span class="token punctuation">,</span> typename Operation<span class="token operator">&gt;</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">SerializationOp</span><span class="token punctuation">(</span>Stream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> Operation ser_action<span class="token punctuation">,</span> <span class="token keyword">int</span> nType<span class="token punctuation">,</span> <span class="token keyword">int</span> nVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>uint256<span class="token operator">&gt;</span> vMerkleBranch<span class="token punctuation">;</span> <span class="token comment">// For compatibility with older versions.</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>CTransaction<span class="token operator">*</span><span class="token punctuation">)</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nVersion <span class="token operator">=</span> this<span class="token operator">-&gt;</span>nVersion<span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>hashBlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>vMerkleBranch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">READWRITE</span><span class="token punctuation">(</span>nIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">SetMerkleBranch</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlock<span class="token operator">&amp;</span> block<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/** * Return depth of transaction in blockchain: * &lt;0 : conflicts with a transaction this deep in the blockchain * 0 : in memory pool, waiting to be included in a block * &gt;=1 : this many blocks deep in the main chain */</span>
    <span class="token keyword">int</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBlockIndex<span class="token operator">*</span> <span class="token operator">&amp;</span>pindexRet<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindexRet<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span>pindexRet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    bool <span class="token function">IsInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">const</span> CBlockIndex <span class="token operator">*</span>pindexRet<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span>pindexRet<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">GetBlocksToMaturity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment">/** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */</span>
    bool <span class="token function">AcceptToMemoryPool</span><span class="token punctuation">(</span>bool fLimitFree<span class="token punctuation">,</span> <span class="token keyword">const</span> CAmount nAbsurdFee<span class="token punctuation">,</span> CValidationState<span class="token operator">&amp;</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token function">hashUnset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>hashBlock<span class="token punctuation">.</span><span class="token function">IsNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> hashBlock <span class="token operator">==</span> ABANDON_HASH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    bool <span class="token function">isAbandoned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>hashBlock <span class="token operator">==</span> ABANDON_HASH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setAbandoned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> hashBlock <span class="token operator">=</span> ABANDON_HASH<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>这个类可以方便的验证一个交易是否属于一个区块。</p> 
  <hr> 
  <h1><a id="CWalletTx_365"></a>CWalletTx</h1> 
  <p>包含大量附加信息的交易，只有(这笔交易)所有者关心。 它包括将其链接回块链所需的任何未记录的事务。</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//wallet.h</span>
<span class="token comment">/** * A transaction with a bunch of additional info that only the owner cares about. * It includes any unrecorded transactions needed to link it back to the block chain. */</span>
class CWalletTx <span class="token punctuation">:</span> public CMerkleTx
<span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
    <span class="token keyword">const</span> CWallet<span class="token operator">*</span> pwallet<span class="token punctuation">;</span>

public<span class="token punctuation">:</span>
    mapValue_t mapValue<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> vOrderForm<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fTimeReceivedIsTxTime<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTimeReceived<span class="token punctuation">;</span> <span class="token comment">//!&lt; time received by this node</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nTimeSmart<span class="token punctuation">;</span>
    <span class="token keyword">char</span> fFromMe<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>string strFromAccount<span class="token punctuation">;</span>
    int64_t nOrderPos<span class="token punctuation">;</span> <span class="token comment">//!&lt; position in ordered transaction list</span>
···
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81874834,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81874834,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81874834,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81874834,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
