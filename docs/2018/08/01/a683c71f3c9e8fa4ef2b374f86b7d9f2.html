<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS智能合约开发（十）eosio.token合约分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS智能合约开发（十）eosio.token合约分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前面文章里，我们部署过eosio.token合约，今天我们就分析一下这个合约。 首先，我们部署eoiso.token合约，通过这个合约，可以创建不同的token，可以由不同的账户部署管理这个合约。所有的token都用这个合约来运行。 在我们部署这个合约之前，我们首先需要创建一个账户来管理这个合约，我们就创建一个eosio.token这个账户来管理这个合约吧。 cleos create account eosio eosio.token EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 然后我们可以部署可以找到的合同 ${EOSIO_SOURCE}/build/contracts/eosio.token $ cleos set contract eosio.token build/contracts/eosio.token -p eosio.token Reading WAST... Assembling WASM... Publishing contract... executed transaction: 528bdbce1181dc5fd72a24e4181e6587dace8ab43b2d7ac9b22b2017992a07ad 8708 bytes 10000 cycles # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;eosio.token&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001ce011d60067f7e7f7f7f7f00... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;eosio.token&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;transfer&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;... 合约已经创建了，您可以按以下定义查看接口contracts/eosio.token/eosio.token.hpp void create( account_name issuer, //资产发行账户 asset maximum_supply); //资产发行的最大数量 void issue( account_name to, //资产分发到的账户 asset quantity, //发行数量 string memo ); //备注信息 void transfer( account_name from,//资产转移账户 account_name to, //资产接收账户 asset quantity,//资产转移数量 string memo ); //备注信息 从上面接口可以看到，要创建Token，需要调用create(…)方法，使用正确的参数调用该操作。此命令可以按你最大需要去创建一个你定义的一个币种，来创建这个Token，发行人将有权发出问题并执行其他操作，例如冻结，召回和列入所有者白名单。 使用位置参数调用此方法的简明方法： $ cleos push action eosio.token create &#39;[ &quot;eosio&quot;, &quot;1000000000.0000 SYS&quot;]&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 或者，使用命名参数调用此方法的更详细的方法： $ cleos push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;, &quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;}&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 上面命令是不同的两种写法，都是创建在eosio.token账户上数量”1000000000.0000 SYS”的代币，这笔代币是由eosio.token创建的，也是由eosio.token签名的。 从返回结果分析： 1、这笔交易消耗了120 bytes 1000 cycles. 2、eosio.token &lt;= eosio.token::create 说明，这个代币是由eosio.token创建在eosio.token账户上。 3、{“issuer”:”eosio”,”maximum_supply”:”1000000000.0000 SYS”}说明，资产发布在eosio账户上，数量”1000000000.0000 SYS”。这一点需要注意，下面调用issue接口的时候，需要用eosio账户签名，因为资产发行在eosio账户上。 1、此命令创建了一个新令牌SYS，其中包含4个十分位数，最大供应量为1000000000.0000个SYS。 2、为了创建这个token，我们需要将这个代币创建在eosio.token账户上，因为eosio.token拥有“SYS”这个币种。可以允许其他用户购买“SYS”这个币种。出于这个原因，我们需要用eosio.token对这个币种做签名（-p eosio.token）。 void token::create( account_name issuer, asset maximum_supply ) { //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( _self ); auto sym = maximum_supply.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( maximum_supply.is_valid(), &quot;invalid supply&quot;); eosio_assert( maximum_supply.amount &gt; 0, &quot;max-supply must be positive&quot;); //设置状态机，将授权的账户，创建这个标志的币种 stats statstable( _self, sym.name() ); //检查状态机中是否存在这个标志的币种 auto existing = statstable.find( sym.name() ); eosio_assert( existing == statstable.end(), &quot;token with symbol already exists&quot; ); //更新状态机，将资产数量，资产发行者，资产标志一起写入状态机中 statstable.emplace( _self, [&amp;]( auto&amp; s ) { s.supply.symbol = maximum_supply.symbol; s.max_supply = maximum_supply; s.issuer = issuer; } 下面我们分析一下资产发行接口，使用issue( account_name to, asset quantity, string memo )接口，发行者（eosio）可以向useraccount1我们之前创建的帐户发放新token。 命令如下： $ cleos push action eosio.token issue &#39;[ &quot;useraccount1&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#39; -p eosio executed transaction: 822a607a9196112831ecc2dc14ffb1722634f1749f3ac18b73ffacd41160b019 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; issue # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; transfer # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} 这次输出包含几个不同的操作： 一个问题和三个传输。虽然我们签署的唯一行动是issue，issue行动执行“内联转移”，“内联转移”通知发件人账户和收件人帐户。输出指令执行了所有操作，调用它们的顺序以及操作是否生成的一些输出。 为了完成这笔交易总共做了三笔确认： 1、在执行issue函数下，由eosio.token做了一次确认； 2、在执行inline transfer函数下，首先由资产的发行者（eosio）做了一次确认； 3、最后由资产的接收者做一次确认（useraccount1），完成这笔资产分发。 如下图： 从技术上讲，eosio.token合约，可以跳过inline transfer，直接修改余额。但是，在这种情况下，eosio.token遵循我们合约约定，该约定要求所有帐户余额可以通过引用它们的转移操作的总和来推导。它还要求通知资金的发送方和接收方，以便它们可以自动处理存款和取款。 我们分析一下issue函数源代码，看看是怎么执行的 void token::issue( account_name to, asset quantity, string memo ) { auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); auto sym_name = sym.name(); //获取状态机信息； stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); //检查转给标志的币种是否存在，如果不存在，Action调用会中止，事务会回滚 eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); //修改状态机信息 statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); //调用add_balance函数，修改状态机信息 add_balance( st.issuer, quantity, st.issuer ); //通过调用inline transfer函数后，将交易写入区块中，完成这笔交易。 if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } void token::add_balance( account_name owner, asset value, account_name ram_payer ) { accounts to_acnts( _self, owner ); auto to = to_acnts.find( value.symbol.name() ); if( to == to_acnts.end() ) {//如果分发给的账户，没有这个币种，那么直接赋值给这个账户 to_acnts.emplace( ram_payer, [&amp;]( auto&amp; a ){ a.balance = value; }); } else {//如果分发给的账户，有这个币种，那么加上余额给这个账户 to_acnts.modify( to, 0, [&amp;]( auto&amp; a ) { a.balance += value; }); } } 如果要查看广播的实际事务，可以使用-d -j选项指示“不广播”和“将事务返回为json”。 $ cleos push action eosio.token issue &#39;[&quot;user&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p eosio -d -j { &quot;expiration&quot;: &quot;2018-08-01T15:20:44&quot;, &quot;region&quot;: 0, &quot;ref_block_num&quot;: 42580, &quot;ref_block_prefix&quot;: 3987474256, &quot;net_usage_words&quot;: 21, &quot;kcpu_usage&quot;: 1000, &quot;delay_sec&quot;: 0, &quot;context_free_actions&quot;: [], &quot;actions&quot;: [{ &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;issue&quot;, &quot;authorization&quot;: [{ &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; } ], &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; } ], &quot;signatures&quot;: [ &quot;EOSJzPywCKsgBitRh9kxFNeMJc8BeD6QZLagtXzmdS2ib5gKTeELiVxXvcnrdRUiY3ExP9saVkdkzvUNyRZSXj2CLJnj7U42H&quot; ], &quot;context_free_data&quot;: [] } 将代币转移到帐户“Tester” 现在该帐户useraccount1有令牌，我们会转移一些帐户tester。我们useraccount1使用permission参数指示授权此操作-p useraccount1。 $ cleos push action eosio.token transfer &#39;[ &quot;useraccount1&quot;, &quot;tester&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#39; -p useraccount1 executed transaction: 06d0a99652c11637230d08a207520bf38066b8817ef7cafaab2f0344aafd7018 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;useraccount1&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} # tester &lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} 为了完成这笔交易总共做了两笔确认： 1、在执行transfer 函数下，由useraccount1做了一次确认，并签名； 2、再由资产的接收者（tester ）做了一次确认，这笔资产才转移成功； 下面我们分析一下transfer这个函数的源代码 void token::transfer( account_name from, account_name to, asset quantity, string memo ) { eosio_assert( from != to, &quot;cannot transfer to self&quot; ); //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); //验证账户信息 require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); //调用减掉资产的函数，如果不成功，Action调用会中止，事务会回滚 sub_balance( from, quantity ); //调用增加资产的函数，如果不成功，Action调用会中止，事务会回滚 add_balance( to, quantity, from ); } 这里我们已经分析了eosio.token这个合约。 2018年8月1日整理于深圳 阅读更多" />
<meta property="og:description" content="前面文章里，我们部署过eosio.token合约，今天我们就分析一下这个合约。 首先，我们部署eoiso.token合约，通过这个合约，可以创建不同的token，可以由不同的账户部署管理这个合约。所有的token都用这个合约来运行。 在我们部署这个合约之前，我们首先需要创建一个账户来管理这个合约，我们就创建一个eosio.token这个账户来管理这个合约吧。 cleos create account eosio eosio.token EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 然后我们可以部署可以找到的合同 ${EOSIO_SOURCE}/build/contracts/eosio.token $ cleos set contract eosio.token build/contracts/eosio.token -p eosio.token Reading WAST... Assembling WASM... Publishing contract... executed transaction: 528bdbce1181dc5fd72a24e4181e6587dace8ab43b2d7ac9b22b2017992a07ad 8708 bytes 10000 cycles # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;eosio.token&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001ce011d60067f7e7f7f7f7f00... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;eosio.token&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;transfer&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;... 合约已经创建了，您可以按以下定义查看接口contracts/eosio.token/eosio.token.hpp void create( account_name issuer, //资产发行账户 asset maximum_supply); //资产发行的最大数量 void issue( account_name to, //资产分发到的账户 asset quantity, //发行数量 string memo ); //备注信息 void transfer( account_name from,//资产转移账户 account_name to, //资产接收账户 asset quantity,//资产转移数量 string memo ); //备注信息 从上面接口可以看到，要创建Token，需要调用create(…)方法，使用正确的参数调用该操作。此命令可以按你最大需要去创建一个你定义的一个币种，来创建这个Token，发行人将有权发出问题并执行其他操作，例如冻结，召回和列入所有者白名单。 使用位置参数调用此方法的简明方法： $ cleos push action eosio.token create &#39;[ &quot;eosio&quot;, &quot;1000000000.0000 SYS&quot;]&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 或者，使用命名参数调用此方法的更详细的方法： $ cleos push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;, &quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;}&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 上面命令是不同的两种写法，都是创建在eosio.token账户上数量”1000000000.0000 SYS”的代币，这笔代币是由eosio.token创建的，也是由eosio.token签名的。 从返回结果分析： 1、这笔交易消耗了120 bytes 1000 cycles. 2、eosio.token &lt;= eosio.token::create 说明，这个代币是由eosio.token创建在eosio.token账户上。 3、{“issuer”:”eosio”,”maximum_supply”:”1000000000.0000 SYS”}说明，资产发布在eosio账户上，数量”1000000000.0000 SYS”。这一点需要注意，下面调用issue接口的时候，需要用eosio账户签名，因为资产发行在eosio账户上。 1、此命令创建了一个新令牌SYS，其中包含4个十分位数，最大供应量为1000000000.0000个SYS。 2、为了创建这个token，我们需要将这个代币创建在eosio.token账户上，因为eosio.token拥有“SYS”这个币种。可以允许其他用户购买“SYS”这个币种。出于这个原因，我们需要用eosio.token对这个币种做签名（-p eosio.token）。 void token::create( account_name issuer, asset maximum_supply ) { //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( _self ); auto sym = maximum_supply.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( maximum_supply.is_valid(), &quot;invalid supply&quot;); eosio_assert( maximum_supply.amount &gt; 0, &quot;max-supply must be positive&quot;); //设置状态机，将授权的账户，创建这个标志的币种 stats statstable( _self, sym.name() ); //检查状态机中是否存在这个标志的币种 auto existing = statstable.find( sym.name() ); eosio_assert( existing == statstable.end(), &quot;token with symbol already exists&quot; ); //更新状态机，将资产数量，资产发行者，资产标志一起写入状态机中 statstable.emplace( _self, [&amp;]( auto&amp; s ) { s.supply.symbol = maximum_supply.symbol; s.max_supply = maximum_supply; s.issuer = issuer; } 下面我们分析一下资产发行接口，使用issue( account_name to, asset quantity, string memo )接口，发行者（eosio）可以向useraccount1我们之前创建的帐户发放新token。 命令如下： $ cleos push action eosio.token issue &#39;[ &quot;useraccount1&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#39; -p eosio executed transaction: 822a607a9196112831ecc2dc14ffb1722634f1749f3ac18b73ffacd41160b019 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; issue # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; transfer # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} 这次输出包含几个不同的操作： 一个问题和三个传输。虽然我们签署的唯一行动是issue，issue行动执行“内联转移”，“内联转移”通知发件人账户和收件人帐户。输出指令执行了所有操作，调用它们的顺序以及操作是否生成的一些输出。 为了完成这笔交易总共做了三笔确认： 1、在执行issue函数下，由eosio.token做了一次确认； 2、在执行inline transfer函数下，首先由资产的发行者（eosio）做了一次确认； 3、最后由资产的接收者做一次确认（useraccount1），完成这笔资产分发。 如下图： 从技术上讲，eosio.token合约，可以跳过inline transfer，直接修改余额。但是，在这种情况下，eosio.token遵循我们合约约定，该约定要求所有帐户余额可以通过引用它们的转移操作的总和来推导。它还要求通知资金的发送方和接收方，以便它们可以自动处理存款和取款。 我们分析一下issue函数源代码，看看是怎么执行的 void token::issue( account_name to, asset quantity, string memo ) { auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); auto sym_name = sym.name(); //获取状态机信息； stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); //检查转给标志的币种是否存在，如果不存在，Action调用会中止，事务会回滚 eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); //修改状态机信息 statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); //调用add_balance函数，修改状态机信息 add_balance( st.issuer, quantity, st.issuer ); //通过调用inline transfer函数后，将交易写入区块中，完成这笔交易。 if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } void token::add_balance( account_name owner, asset value, account_name ram_payer ) { accounts to_acnts( _self, owner ); auto to = to_acnts.find( value.symbol.name() ); if( to == to_acnts.end() ) {//如果分发给的账户，没有这个币种，那么直接赋值给这个账户 to_acnts.emplace( ram_payer, [&amp;]( auto&amp; a ){ a.balance = value; }); } else {//如果分发给的账户，有这个币种，那么加上余额给这个账户 to_acnts.modify( to, 0, [&amp;]( auto&amp; a ) { a.balance += value; }); } } 如果要查看广播的实际事务，可以使用-d -j选项指示“不广播”和“将事务返回为json”。 $ cleos push action eosio.token issue &#39;[&quot;user&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p eosio -d -j { &quot;expiration&quot;: &quot;2018-08-01T15:20:44&quot;, &quot;region&quot;: 0, &quot;ref_block_num&quot;: 42580, &quot;ref_block_prefix&quot;: 3987474256, &quot;net_usage_words&quot;: 21, &quot;kcpu_usage&quot;: 1000, &quot;delay_sec&quot;: 0, &quot;context_free_actions&quot;: [], &quot;actions&quot;: [{ &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;issue&quot;, &quot;authorization&quot;: [{ &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; } ], &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; } ], &quot;signatures&quot;: [ &quot;EOSJzPywCKsgBitRh9kxFNeMJc8BeD6QZLagtXzmdS2ib5gKTeELiVxXvcnrdRUiY3ExP9saVkdkzvUNyRZSXj2CLJnj7U42H&quot; ], &quot;context_free_data&quot;: [] } 将代币转移到帐户“Tester” 现在该帐户useraccount1有令牌，我们会转移一些帐户tester。我们useraccount1使用permission参数指示授权此操作-p useraccount1。 $ cleos push action eosio.token transfer &#39;[ &quot;useraccount1&quot;, &quot;tester&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#39; -p useraccount1 executed transaction: 06d0a99652c11637230d08a207520bf38066b8817ef7cafaab2f0344aafd7018 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;useraccount1&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} # tester &lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} 为了完成这笔交易总共做了两笔确认： 1、在执行transfer 函数下，由useraccount1做了一次确认，并签名； 2、再由资产的接收者（tester ）做了一次确认，这笔资产才转移成功； 下面我们分析一下transfer这个函数的源代码 void token::transfer( account_name from, account_name to, asset quantity, string memo ) { eosio_assert( from != to, &quot;cannot transfer to self&quot; ); //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); //验证账户信息 require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); //调用减掉资产的函数，如果不成功，Action调用会中止，事务会回滚 sub_balance( from, quantity ); //调用增加资产的函数，如果不成功，Action调用会中止，事务会回滚 add_balance( to, quantity, from ); } 这里我们已经分析了eosio.token这个合约。 2018年8月1日整理于深圳 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/01/a683c71f3c9e8fa4ef2b374f86b7d9f2.html" />
<meta property="og:url" content="https://mlh.app/2018/08/01/a683c71f3c9e8fa4ef2b374f86b7d9f2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"前面文章里，我们部署过eosio.token合约，今天我们就分析一下这个合约。 首先，我们部署eoiso.token合约，通过这个合约，可以创建不同的token，可以由不同的账户部署管理这个合约。所有的token都用这个合约来运行。 在我们部署这个合约之前，我们首先需要创建一个账户来管理这个合约，我们就创建一个eosio.token这个账户来管理这个合约吧。 cleos create account eosio eosio.token EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 然后我们可以部署可以找到的合同 ${EOSIO_SOURCE}/build/contracts/eosio.token $ cleos set contract eosio.token build/contracts/eosio.token -p eosio.token Reading WAST... Assembling WASM... Publishing contract... executed transaction: 528bdbce1181dc5fd72a24e4181e6587dace8ab43b2d7ac9b22b2017992a07ad 8708 bytes 10000 cycles # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;eosio.token&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001ce011d60067f7e7f7f7f7f00... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;eosio.token&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;transfer&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;... 合约已经创建了，您可以按以下定义查看接口contracts/eosio.token/eosio.token.hpp void create( account_name issuer, //资产发行账户 asset maximum_supply); //资产发行的最大数量 void issue( account_name to, //资产分发到的账户 asset quantity, //发行数量 string memo ); //备注信息 void transfer( account_name from,//资产转移账户 account_name to, //资产接收账户 asset quantity,//资产转移数量 string memo ); //备注信息 从上面接口可以看到，要创建Token，需要调用create(…)方法，使用正确的参数调用该操作。此命令可以按你最大需要去创建一个你定义的一个币种，来创建这个Token，发行人将有权发出问题并执行其他操作，例如冻结，召回和列入所有者白名单。 使用位置参数调用此方法的简明方法： $ cleos push action eosio.token create &#39;[ &quot;eosio&quot;, &quot;1000000000.0000 SYS&quot;]&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 或者，使用命名参数调用此方法的更详细的方法： $ cleos push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;, &quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;}&#39; -p eosio.token executed transaction: 0e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 120 bytes 1000 cycles # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;1000000000.0000 SYS&quot;} 上面命令是不同的两种写法，都是创建在eosio.token账户上数量”1000000000.0000 SYS”的代币，这笔代币是由eosio.token创建的，也是由eosio.token签名的。 从返回结果分析： 1、这笔交易消耗了120 bytes 1000 cycles. 2、eosio.token &lt;= eosio.token::create 说明，这个代币是由eosio.token创建在eosio.token账户上。 3、{“issuer”:”eosio”,”maximum_supply”:”1000000000.0000 SYS”}说明，资产发布在eosio账户上，数量”1000000000.0000 SYS”。这一点需要注意，下面调用issue接口的时候，需要用eosio账户签名，因为资产发行在eosio账户上。 1、此命令创建了一个新令牌SYS，其中包含4个十分位数，最大供应量为1000000000.0000个SYS。 2、为了创建这个token，我们需要将这个代币创建在eosio.token账户上，因为eosio.token拥有“SYS”这个币种。可以允许其他用户购买“SYS”这个币种。出于这个原因，我们需要用eosio.token对这个币种做签名（-p eosio.token）。 void token::create( account_name issuer, asset maximum_supply ) { //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( _self ); auto sym = maximum_supply.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( maximum_supply.is_valid(), &quot;invalid supply&quot;); eosio_assert( maximum_supply.amount &gt; 0, &quot;max-supply must be positive&quot;); //设置状态机，将授权的账户，创建这个标志的币种 stats statstable( _self, sym.name() ); //检查状态机中是否存在这个标志的币种 auto existing = statstable.find( sym.name() ); eosio_assert( existing == statstable.end(), &quot;token with symbol already exists&quot; ); //更新状态机，将资产数量，资产发行者，资产标志一起写入状态机中 statstable.emplace( _self, [&amp;]( auto&amp; s ) { s.supply.symbol = maximum_supply.symbol; s.max_supply = maximum_supply; s.issuer = issuer; } 下面我们分析一下资产发行接口，使用issue( account_name to, asset quantity, string memo )接口，发行者（eosio）可以向useraccount1我们之前创建的帐户发放新token。 命令如下： $ cleos push action eosio.token issue &#39;[ &quot;useraccount1&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot; ]&#39; -p eosio executed transaction: 822a607a9196112831ecc2dc14ffb1722634f1749f3ac18b73ffacd41160b019 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; issue # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} &gt;&gt; transfer # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;useraccount1&quot;,&quot;quantity&quot;:&quot;100.0000 SYS&quot;,&quot;memo&quot;:&quot;memo&quot;} 这次输出包含几个不同的操作： 一个问题和三个传输。虽然我们签署的唯一行动是issue，issue行动执行“内联转移”，“内联转移”通知发件人账户和收件人帐户。输出指令执行了所有操作，调用它们的顺序以及操作是否生成的一些输出。 为了完成这笔交易总共做了三笔确认： 1、在执行issue函数下，由eosio.token做了一次确认； 2、在执行inline transfer函数下，首先由资产的发行者（eosio）做了一次确认； 3、最后由资产的接收者做一次确认（useraccount1），完成这笔资产分发。 如下图： 从技术上讲，eosio.token合约，可以跳过inline transfer，直接修改余额。但是，在这种情况下，eosio.token遵循我们合约约定，该约定要求所有帐户余额可以通过引用它们的转移操作的总和来推导。它还要求通知资金的发送方和接收方，以便它们可以自动处理存款和取款。 我们分析一下issue函数源代码，看看是怎么执行的 void token::issue( account_name to, asset quantity, string memo ) { auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); auto sym_name = sym.name(); //获取状态机信息； stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); //检查转给标志的币种是否存在，如果不存在，Action调用会中止，事务会回滚 eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); //修改状态机信息 statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); //调用add_balance函数，修改状态机信息 add_balance( st.issuer, quantity, st.issuer ); //通过调用inline transfer函数后，将交易写入区块中，完成这笔交易。 if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } void token::add_balance( account_name owner, asset value, account_name ram_payer ) { accounts to_acnts( _self, owner ); auto to = to_acnts.find( value.symbol.name() ); if( to == to_acnts.end() ) {//如果分发给的账户，没有这个币种，那么直接赋值给这个账户 to_acnts.emplace( ram_payer, [&amp;]( auto&amp; a ){ a.balance = value; }); } else {//如果分发给的账户，有这个币种，那么加上余额给这个账户 to_acnts.modify( to, 0, [&amp;]( auto&amp; a ) { a.balance += value; }); } } 如果要查看广播的实际事务，可以使用-d -j选项指示“不广播”和“将事务返回为json”。 $ cleos push action eosio.token issue &#39;[&quot;user&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p eosio -d -j { &quot;expiration&quot;: &quot;2018-08-01T15:20:44&quot;, &quot;region&quot;: 0, &quot;ref_block_num&quot;: 42580, &quot;ref_block_prefix&quot;: 3987474256, &quot;net_usage_words&quot;: 21, &quot;kcpu_usage&quot;: 1000, &quot;delay_sec&quot;: 0, &quot;context_free_actions&quot;: [], &quot;actions&quot;: [{ &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;issue&quot;, &quot;authorization&quot;: [{ &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; } ], &quot;data&quot;: &quot;00000000007015d640420f000000000004454f5300000000046d656d6f&quot; } ], &quot;signatures&quot;: [ &quot;EOSJzPywCKsgBitRh9kxFNeMJc8BeD6QZLagtXzmdS2ib5gKTeELiVxXvcnrdRUiY3ExP9saVkdkzvUNyRZSXj2CLJnj7U42H&quot; ], &quot;context_free_data&quot;: [] } 将代币转移到帐户“Tester” 现在该帐户useraccount1有令牌，我们会转移一些帐户tester。我们useraccount1使用permission参数指示授权此操作-p useraccount1。 $ cleos push action eosio.token transfer &#39;[ &quot;useraccount1&quot;, &quot;tester&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot; ]&#39; -p useraccount1 executed transaction: 06d0a99652c11637230d08a207520bf38066b8817ef7cafaab2f0344aafd7018 268 bytes 1000 cycles # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;useraccount1&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer # useraccount1&lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} # tester &lt;= eosio.token::transfer {&quot;from&quot;:&quot;user&quot;,&quot;to&quot;:&quot;tester&quot;,&quot;quantity&quot;:&quot;25.0000 SYS&quot;,&quot;memo&quot;:&quot;m&quot;} 为了完成这笔交易总共做了两笔确认： 1、在执行transfer 函数下，由useraccount1做了一次确认，并签名； 2、再由资产的接收者（tester ）做了一次确认，这笔资产才转移成功； 下面我们分析一下transfer这个函数的源代码 void token::transfer( account_name from, account_name to, asset quantity, string memo ) { eosio_assert( from != to, &quot;cannot transfer to self&quot; ); //获取授权，如果没有授权，Action调用会中止，事务会回滚 require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); //验证账户信息 require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; ); //调用减掉资产的函数，如果不成功，Action调用会中止，事务会回滚 sub_balance( from, quantity ); //调用增加资产的函数，如果不成功，Action调用会中止，事务会回滚 add_balance( to, quantity, from ); } 这里我们已经分析了eosio.token这个合约。 2018年8月1日整理于深圳 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/01/a683c71f3c9e8fa4ef2b374f86b7d9f2.html","headline":"EOS智能合约开发（十）eosio.token合约分析","dateModified":"2018-08-01T00:00:00+08:00","datePublished":"2018-08-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/01/a683c71f3c9e8fa4ef2b374f86b7d9f2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS智能合约开发（十）eosio.token合约分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>前面文章里，我们部署过eosio.token合约，今天我们就分析一下这个合约。 <br> 首先，我们部署eoiso.token合约，通过这个合约，可以创建不同的token，可以由不同的账户部署管理这个合约。所有的token都用这个合约来运行。</p> 
  <blockquote> 
   <p>在我们部署这个合约之前，我们首先需要创建一个账户来管理这个合约，我们就创建一个eosio.token这个账户来管理这个合约吧。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">cleos <span class="hljs-built_in">create</span> account eosio eosio.<span class="hljs-keyword">token</span> EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4 EOS7ijWCBmoXBi3CgtK7DJxentZZeTkeUnaSDvyro9dq7Sd1C3dC4</code></pre> 
  <blockquote> 
   <p>然后我们可以部署可以找到的合同 ${EOSIO_SOURCE}/build/contracts/eosio.token</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs d">$ cleos set contract eosio.token build/contracts/eosio.token -p eosio.token
Reading WAST...
Assembling WASM...
Publishing contract...
executed transaction: <span class="hljs-number">528</span>bdbce1181dc5fd72a24e4181e6587dace8ab43b2d7ac9b22b2017992a07ad  <span class="hljs-number">8708</span> bytes  <span class="hljs-number">10000</span> cycles
#         eosio &lt;= eosio::setcode               {<span class="hljs-string">"account"</span>:<span class="hljs-string">"eosio.token"</span>,<span class="hljs-string">"vmtype"</span>:<span class="hljs-number">0</span>,<span class="hljs-string">"vmversion"</span>:<span class="hljs-number">0</span>,<span class="hljs-string">"code"</span>:<span class="hljs-string">"0061736d0100000001ce011d60067f7e7f7f7f7f00... # eosio &lt;= eosio::setabi {"</span>account<span class="hljs-string">":"</span>eosio.token<span class="hljs-string">","</span>abi<span class="hljs-string">":{"</span>types<span class="hljs-string">":[],"</span>structs<span class="hljs-string">":[{"</span>name<span class="hljs-string">":"</span>transfe<span class="hljs-string">r","</span>base<span class="hljs-string">":"</span><span class="hljs-string">","</span>fields<span class="hljs-string">":[{"</span>name<span class="hljs-string">"...</span></code></pre> 
  <blockquote> 
   <p>合约已经创建了，您可以按以下定义查看接口contracts/eosio.token/eosio.token.hpp</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs lasso">        <span class="hljs-literal">void</span> create( account_name issuer,  <span class="hljs-comment">//资产发行账户</span>
                      asset        maximum_supply); <span class="hljs-comment">//资产发行的最大数量</span>

         <span class="hljs-literal">void</span> issue( account_name <span class="hljs-keyword">to</span>, <span class="hljs-comment">//资产分发到的账户</span>
                     asset quantity, <span class="hljs-comment">//发行数量</span>
                     <span class="hljs-built_in">string</span> memo );  <span class="hljs-comment">//备注信息</span>

         <span class="hljs-literal">void</span> transfer( account_name from,<span class="hljs-comment">//资产转移账户</span>
                        account_name <span class="hljs-keyword">to</span>,  <span class="hljs-comment">//资产接收账户</span>
                        asset        quantity,<span class="hljs-comment">//资产转移数量</span>
                        <span class="hljs-built_in">string</span>       memo ); <span class="hljs-comment">//备注信息</span></code></pre> 
  <blockquote> 
   <p>从上面接口可以看到，要创建Token，需要调用create(…)方法，使用正确的参数调用该操作。此命令可以按你最大需要去创建一个你定义的一个币种，来创建这个Token，发行人将有权发出问题并执行其他操作，例如冻结，召回和列入所有者白名单。</p> 
  </blockquote> 
  <p>使用位置参数调用此方法的简明方法：</p> 
  <pre class="prettyprint"><code class=" hljs sql">$ cleos push action eosio.token <span class="hljs-operator"><span class="hljs-keyword">create</span> <span class="hljs-string">'[ "eosio", "1000000000.0000 SYS"]'</span> -p eosio.token executed <span class="hljs-keyword">transaction</span>: <span class="hljs-number">0e49</span>a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12 <span class="hljs-number">120</span> bytes <span class="hljs-number">1000</span> cycles # eosio.token &lt;= eosio.token::<span class="hljs-keyword">create</span> {<span class="hljs-string">"issuer"</span>:<span class="hljs-string">"eosio"</span>,<span class="hljs-string">"maximum_supply"</span>:<span class="hljs-string">"1000000000.0000 SYS"</span>}</span></code></pre> 
  <p>或者，使用命名参数调用此方法的更详细的方法：</p> 
  <pre class="prettyprint"><code class=" hljs autohotkey">$ cleos push action eosio.token create '{<span class="hljs-string">"issuer"</span>:<span class="hljs-string">"eosio"</span>, <span class="hljs-string">"maximum_supply"</span>:<span class="hljs-string">"1000000000.0000 SYS"</span>}' -p eosio.token
<span class="hljs-label">executed transaction:</span> <span class="hljs-number">0</span>e49a421f6e75f4c5e09dd738a02d3f51bd18a0cf31894f68d335cd70d9c0e12  <span class="hljs-number">120</span> bytes  <span class="hljs-number">1000</span> cycles
<span class="hljs-label"># eosio.token &lt;= eosio.token::</span>create          {<span class="hljs-string">"issuer"</span>:<span class="hljs-string">"eosio"</span>,<span class="hljs-string">"maximum_supply"</span>:<span class="hljs-string">"1000000000.0000 SYS"</span>}</code></pre> 
  <blockquote> 
   <p>上面命令是不同的两种写法，都是创建在eosio.token账户上数量”1000000000.0000 SYS”的代币，这笔代币是由eosio.token创建的，也是由eosio.token签名的。 <br> 从返回结果分析： <br> 1、这笔交易消耗了120 bytes 1000 cycles. <br> 2、eosio.token &lt;= eosio.token::create 说明，这个代币是由eosio.token创建在eosio.token账户上。 <br> 3、{“issuer”:”eosio”,”maximum_supply”:”1000000000.0000 SYS”}说明，资产发布在eosio账户上，数量”1000000000.0000 SYS”。这一点需要注意，下面调用issue接口的时候，需要用eosio账户签名，因为资产发行在eosio账户上。</p> 
  </blockquote> 
  <hr> 
  <blockquote> 
   <p>1、此命令创建了一个新令牌SYS，其中包含4个十分位数，最大供应量为1000000000.0000个SYS。 <br> 2、为了创建这个token，我们需要将这个代币创建在eosio.token账户上，因为eosio.token拥有“SYS”这个币种。可以允许其他用户购买“SYS”这个币种。出于这个原因，我们需要用eosio.token对这个币种做签名（-p eosio.token）。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs avrasm">void token::create( account_name issuer,
                    asset        maximum_supply )
{
    //获取授权，如果没有授权，Action调用会中止，事务会回滚
    require_auth( _self )<span class="hljs-comment">;</span>

    auto sym = maximum_supply<span class="hljs-preprocessor">.symbol</span><span class="hljs-comment">;</span>
    eosio_assert( sym<span class="hljs-preprocessor">.is</span>_valid(), <span class="hljs-string">"invalid symbol name"</span> )<span class="hljs-comment">;</span>
    eosio_assert( maximum_supply<span class="hljs-preprocessor">.is</span>_valid(), <span class="hljs-string">"invalid supply"</span>)<span class="hljs-comment">;</span>
    eosio_assert( maximum_supply<span class="hljs-preprocessor">.amount</span> &gt; <span class="hljs-number">0</span>, <span class="hljs-string">"max-supply must be positive"</span>)<span class="hljs-comment">;</span>

    //设置状态机，将授权的账户，创建这个标志的币种 
    stats statstable( _self, sym<span class="hljs-preprocessor">.name</span>() )<span class="hljs-comment">;</span>
    //检查状态机中是否存在这个标志的币种
    auto existing = statstable<span class="hljs-preprocessor">.find</span>( sym<span class="hljs-preprocessor">.name</span>() )<span class="hljs-comment">;</span>
    eosio_assert( existing == statstable<span class="hljs-preprocessor">.end</span>(), <span class="hljs-string">"token with symbol already exists"</span> )<span class="hljs-comment">;</span>
    //更新状态机，将资产数量，资产发行者，资产标志一起写入状态机中
    statstable<span class="hljs-preprocessor">.emplace</span>( _self, [&amp;]( auto&amp; s ) {
       s<span class="hljs-preprocessor">.supply</span><span class="hljs-preprocessor">.symbol</span> = maximum_supply<span class="hljs-preprocessor">.symbol</span><span class="hljs-comment">;</span>
       s<span class="hljs-preprocessor">.max</span>_supply    = maximum_supply<span class="hljs-comment">;</span>
       s<span class="hljs-preprocessor">.issuer</span>        = issuer<span class="hljs-comment">;</span>
    }</code></pre> 
  <p>下面我们分析一下资产发行接口，使用issue( account_name to, asset quantity, string memo )接口，发行者（eosio）可以向useraccount1我们之前创建的帐户发放新token。</p> 
  <p>命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs autohotkey">$ cleos push action eosio.token issue '[ <span class="hljs-string">"useraccount1"</span>, <span class="hljs-string">"100.0000 SYS"</span>, <span class="hljs-string">"memo"</span> ]' -p eosio
<span class="hljs-label">executed transaction:</span> <span class="hljs-number">822</span>a607a9196112831ecc2dc14ffb1722634f1749f3ac18b73ffacd41160b019  <span class="hljs-number">268</span> bytes  <span class="hljs-number">1000</span> cycles
<span class="hljs-label"># eosio.token &lt;= eosio.token::</span>issue           {<span class="hljs-string">"to"</span>:<span class="hljs-string">"useraccount1"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"100.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"memo"</span>}
&gt;&gt; issue
<span class="hljs-label"># eosio.token &lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"eosio"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"useraccount1"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"100.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"memo"</span>}
&gt;&gt; transfer
<span class="hljs-label"># eosio &lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"eosio"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"useraccount1"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"100.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"memo"</span>}
<span class="hljs-label"># useraccount1&lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"eosio"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"useraccount1"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"100.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"memo"</span>}</code></pre> 
  <blockquote> 
   <p>这次输出包含几个不同的操作： <br> 一个问题和三个传输。虽然我们签署的唯一行动是issue，issue行动执行“内联转移”，“内联转移”通知发件人账户和收件人帐户。输出指令执行了所有操作，调用它们的顺序以及操作是否生成的一些输出。 <br> 为了完成这笔交易总共做了三笔确认： <br> 1、在执行issue函数下，由eosio.token做了一次确认； <br> 2、在执行inline transfer函数下，首先由资产的发行者（eosio）做了一次确认； <br> 3、最后由资产的接收者做一次确认（useraccount1），完成这笔资产分发。</p> 
  </blockquote> 
  <p>如下图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180801161957283?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phbWJlYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 从技术上讲，eosio.token合约，可以跳过inline transfer，直接修改余额。但是，在这种情况下，eosio.token遵循我们合约约定，该约定要求所有帐户余额可以通过引用它们的转移操作的总和来推导。它还要求通知资金的发送方和接收方，以便它们可以自动处理存款和取款。</p> 
  <p>我们分析一下issue函数源代码，看看是怎么执行的</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">void token::issue( account_name to, asset quantity, string memo )
{
    auto sym = quantity<span class="hljs-preprocessor">.symbol</span><span class="hljs-comment">;</span>
    eosio_assert( sym<span class="hljs-preprocessor">.is</span>_valid(), <span class="hljs-string">"invalid symbol name"</span> )<span class="hljs-comment">;</span>
    eosio_assert( memo<span class="hljs-preprocessor">.size</span>() &lt;= <span class="hljs-number">256</span>, <span class="hljs-string">"memo has more than 256 bytes"</span> )<span class="hljs-comment">;</span>

    auto sym_name = sym<span class="hljs-preprocessor">.name</span>()<span class="hljs-comment">;</span>
    //获取状态机信息；
    stats statstable( _self, sym_name )<span class="hljs-comment">;</span>
    auto existing = statstable<span class="hljs-preprocessor">.find</span>( sym_name )<span class="hljs-comment">;</span>
    //检查转给标志的币种是否存在，如果不存在，Action调用会中止，事务会回滚
    eosio_assert( existing != statstable<span class="hljs-preprocessor">.end</span>(), <span class="hljs-string">"token with symbol does not exist, create token before issue"</span> )<span class="hljs-comment">;</span>
    const auto&amp; <span class="hljs-keyword">st</span> = *existing<span class="hljs-comment">;</span>
    //获取授权，如果没有授权，Action调用会中止，事务会回滚
    require_auth( <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span> )<span class="hljs-comment">;</span>
    eosio_assert( quantity<span class="hljs-preprocessor">.is</span>_valid(), <span class="hljs-string">"invalid quantity"</span> )<span class="hljs-comment">;</span>
    eosio_assert( quantity<span class="hljs-preprocessor">.amount</span> &gt; <span class="hljs-number">0</span>, <span class="hljs-string">"must issue positive quantity"</span> )<span class="hljs-comment">;</span>

    eosio_assert( quantity<span class="hljs-preprocessor">.symbol</span> == <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.supply</span><span class="hljs-preprocessor">.symbol</span>, <span class="hljs-string">"symbol precision mismatch"</span> )<span class="hljs-comment">;</span>
    eosio_assert( quantity<span class="hljs-preprocessor">.amount</span> &lt;= <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.max</span>_supply<span class="hljs-preprocessor">.amount</span> - <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.supply</span><span class="hljs-preprocessor">.amount</span>, <span class="hljs-string">"quantity exceeds available supply"</span>)<span class="hljs-comment">;</span>
    //修改状态机信息
    statstable<span class="hljs-preprocessor">.modify</span>( <span class="hljs-keyword">st</span>, <span class="hljs-number">0</span>, [&amp;]( auto&amp; s ) {
       s<span class="hljs-preprocessor">.supply</span> += quantity<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
    //调用add_balance函数，修改状态机信息
    add_balance( <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span>, quantity, <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span> )<span class="hljs-comment">;</span>
    //通过调用inline transfer函数后，将交易写入区块中，完成这笔交易。
    if( to != <span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span> ) {
       SEND_INLINE_ACTION( *this, transfer, {<span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span>,N(active)}, {<span class="hljs-keyword">st</span><span class="hljs-preprocessor">.issuer</span>, to, quantity, memo} )<span class="hljs-comment">;</span>
    }
}

void token::add_balance( account_name owner, asset value, account_name ram_payer )
{
   accounts to_acnts( _self, owner )<span class="hljs-comment">;</span>
   auto to = to_acnts<span class="hljs-preprocessor">.find</span>( value<span class="hljs-preprocessor">.symbol</span><span class="hljs-preprocessor">.name</span>() )<span class="hljs-comment">;</span>
   if( to == to_acnts<span class="hljs-preprocessor">.end</span>() ) {//如果分发给的账户，没有这个币种，那么直接赋值给这个账户
      to_acnts<span class="hljs-preprocessor">.emplace</span>( ram_payer, [&amp;]( auto&amp; a ){
        a<span class="hljs-preprocessor">.balance</span> = value<span class="hljs-comment">;</span>
      })<span class="hljs-comment">;</span>
   } else {//如果分发给的账户，有这个币种，那么加上余额给这个账户
      to_acnts<span class="hljs-preprocessor">.modify</span>( to, <span class="hljs-number">0</span>, [&amp;]( auto&amp; a ) {
        a<span class="hljs-preprocessor">.balance</span> += value<span class="hljs-comment">;</span>
      })<span class="hljs-comment">;</span>
   }
}</code></pre> 
  <p>如果要查看广播的实际事务，可以使用-d -j选项指示“不广播”和“将事务返回为json”。</p> 
  <pre class="prettyprint"><code class=" hljs scilab">$ cleos push action <span class="hljs-transposed_variable">eosio.</span>token issue <span class="hljs-string">'["</span>user<span class="hljs-string">", "</span><span class="hljs-number">100.0000</span> SYS<span class="hljs-string">", "</span>memo<span class="hljs-string">"]'</span> -p eosio -d -j
{
  <span class="hljs-string">"expiration"</span>: <span class="hljs-string">"2018-08-01T15:20:44"</span>,
  <span class="hljs-string">"region"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">"ref_block_num"</span>: <span class="hljs-number">42580</span>,
  <span class="hljs-string">"ref_block_prefix"</span>: <span class="hljs-number">3987474256</span>,
  <span class="hljs-string">"net_usage_words"</span>: <span class="hljs-number">21</span>,
  <span class="hljs-string">"kcpu_usage"</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-string">"delay_sec"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">"context_free_actions"</span>: <span class="hljs-matrix">[]</span>,
  <span class="hljs-string">"actions"</span>: <span class="hljs-matrix">[{ <span class="hljs-string">"account"</span>: <span class="hljs-string">"eosio.token"</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"issue"</span>, <span class="hljs-string">"authorization"</span>: [{ <span class="hljs-string">"actor"</span>: <span class="hljs-string">"eosio"</span>, <span class="hljs-string">"permission"</span>: <span class="hljs-string">"active"</span> } ]</span>,
      <span class="hljs-string">"data"</span>: <span class="hljs-string">"00000000007015d640420f000000000004454f5300000000046d656d6f"</span>
    }
  ],
  <span class="hljs-string">"signatures"</span>: <span class="hljs-matrix">[ <span class="hljs-string">"EOSJzPywCKsgBitRh9kxFNeMJc8BeD6QZLagtXzmdS2ib5gKTeELiVxXvcnrdRUiY3ExP9saVkdkzvUNyRZSXj2CLJnj7U42H"</span> ]</span>,
  <span class="hljs-string">"context_free_data"</span>: <span class="hljs-matrix">[]</span>
}</code></pre> 
  <p>将代币转移到帐户“Tester” <br> 现在该帐户useraccount1有令牌，我们会转移一些帐户tester。我们useraccount1使用permission参数指示授权此操作-p useraccount1。</p> 
  <pre class="prettyprint"><code class=" hljs autohotkey">$ cleos push action eosio.token transfer '[ <span class="hljs-string">"useraccount1"</span>, <span class="hljs-string">"tester"</span>, <span class="hljs-string">"25.0000 SYS"</span>, <span class="hljs-string">"m"</span> ]' -p useraccount1
<span class="hljs-label">executed transaction:</span> <span class="hljs-number">06</span>d0a99652c11637230d08a207520bf38066b8817ef7cafaab2f0344aafd7018  <span class="hljs-number">268</span> bytes  <span class="hljs-number">1000</span> cycles
<span class="hljs-label"># eosio.token &lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"useraccount1"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"tester"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"25.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"m"</span>}

&gt;&gt; transfer
<span class="hljs-label"># useraccount1&lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"user"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"tester"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"25.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"m"</span>}
<span class="hljs-label"># tester &lt;= eosio.token::</span>transfer        {<span class="hljs-string">"from"</span>:<span class="hljs-string">"user"</span>,<span class="hljs-string">"to"</span>:<span class="hljs-string">"tester"</span>,<span class="hljs-string">"quantity"</span>:<span class="hljs-string">"25.0000 SYS"</span>,<span class="hljs-string">"memo"</span>:<span class="hljs-string">"m"</span>}</code></pre> 
  <blockquote> 
   <p>为了完成这笔交易总共做了两笔确认： <br> 1、在执行transfer 函数下，由useraccount1做了一次确认，并签名； <br> 2、再由资产的接收者（tester ）做了一次确认，这笔资产才转移成功；</p> 
  </blockquote> 
  <p>下面我们分析一下transfer这个函数的源代码</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> token::transfer( account_name <span class="hljs-keyword">from</span>,
                      account_name to,
                      asset        quantity,
                      <span class="hljs-keyword">string</span>       memo )
{
    eosio_assert( <span class="hljs-keyword">from</span> != to, <span class="hljs-string">"cannot transfer to self"</span> );
    <span class="hljs-comment">//获取授权，如果没有授权，Action调用会中止，事务会回滚</span>
    require_auth( <span class="hljs-keyword">from</span> );
    eosio_assert( is_account( to ), <span class="hljs-string">"to account does not exist"</span>);
    auto sym = quantity.symbol.name();

    stats statstable( _self, sym );
    <span class="hljs-keyword">const</span> auto&amp; st = statstable.<span class="hljs-keyword">get</span>( sym );
    <span class="hljs-comment">//验证账户信息</span>
    require_recipient( <span class="hljs-keyword">from</span> );
    require_recipient( to );

    eosio_assert( quantity.is_valid(), <span class="hljs-string">"invalid quantity"</span> );
    eosio_assert( quantity.amount &gt; <span class="hljs-number">0</span>, <span class="hljs-string">"must transfer positive quantity"</span> );
    eosio_assert( quantity.symbol == st.supply.symbol, <span class="hljs-string">"symbol precision mismatch"</span> );
    eosio_assert( memo.size() &lt;= <span class="hljs-number">256</span>, <span class="hljs-string">"memo has more than 256 bytes"</span> );

    <span class="hljs-comment">//调用减掉资产的函数，如果不成功，Action调用会中止，事务会回滚</span>
    sub_balance( <span class="hljs-keyword">from</span>, quantity );
    <span class="hljs-comment">//调用增加资产的函数，如果不成功，Action调用会中止，事务会回滚</span>
    add_balance( to, quantity, <span class="hljs-keyword">from</span> );
}</code></pre> 
  <p>这里我们已经分析了eosio.token这个合约。</p> 
  <p>2018年8月1日整理于深圳</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jambeau/article/details/81329583,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jambeau/article/details/81329583,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
