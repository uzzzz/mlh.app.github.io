<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码学习0.13（二） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码学习0.13（二）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="源码0.13.2版的，在sublime中打开的 源码0.13.2版的，在sublime中打开的 6.2选择比特币网络 6.3RPC命令行判断 6.4 服务参数设置 7.初始化日志 8.InitParameterInteraction 默认文件在src文件夹下，ide改为sublime，在跳转到定义的体验好很多 6.2选择比特币网络 比特币网络分为主网、测试网以及私有网三种网络： 主网：Main network 测试网：Testnet (v3) 私有网：Regression test 接上面的代码 // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause) try { SelectParams(ChainNameFromCommandLine()); } catch (const std::exception&amp; e) { fprintf(stderr, &quot;Error: %s\n&quot;, e.what()); return false; } 代码注释的含义为检查testnet或regtest参数（Params()仅在该子句之后生效），try子句中调用了SelectParams()函数，是以ChainNameFromCommandLine()的返回值作为参数,先来看ChainNameFromCommandLine()函数，位于chainparamsbase.cpp中 std::string ChainNameFromCommandLine() { bool fRegTest = GetBoolArg(&quot;-regtest&quot;, false); bool fTestNet = GetBoolArg(&quot;-testnet&quot;, false); if (fTestNet &amp;&amp; fRegTest) throw std::runtime_error(&quot;Invalid combination of -regtest and -testnet.&quot;); if (fRegTest) return CBaseChainParams::REGTEST; if (fTestNet) return CBaseChainParams::TESTNET; return CBaseChainParams::MAIN; 首先获取-testnet与-regtest的参数设置，两个都设置的话扔出错误，根据设置返回，都没设置的话返回主网。 class CBaseChainParams { public: /** BIP70 chain name strings (main, test or regtest) */ static const std::string MAIN; static const std::string TESTNET; static const std::string REGTEST; 返回值为字符串常量，在chainparamsbase.h的定义如上，在chainparamsbase.cpp定义如下 const std::string CBaseChainParams::MAIN = &quot;main&quot;; const std::string CBaseChainParams::TESTNET = &quot;test&quot;; const std::string CBaseChainParams::REGTEST = &quot;regtest&quot;; 在获得链的网络名称后，我们来看SelectParams()这个函数，位于chainparams最后几行 void SelectParams(const std::string&amp; network) { SelectBaseParams(network); pCurrentParams = &amp;Params(network); } 这个函数中首先调用SelectBaseParams函数，位于chainpatamsbase.cpp void SelectBaseParams(const std::string&amp; chain) { pCurrentBaseParams = &amp;BaseParams(chain); } 这个函数是实现对pCurrentBaseParams的赋值，pCurrentBaseParams是CBaseChainParams类型的 static CBaseChainParams* pCurrentBaseParams = 0; 而CBaseChainParams是三种网络类型参数的基类，三种网络参数类位于chainpatamsbase.cpp class CBaseMainParams : public CBaseChainParams { public: CBaseMainParams() { nRPCPort = 8332; } }; static CBaseMainParams mainParams; /** * Testnet (v3) */ class CBaseTestNetParams : public CBaseChainParams { public: CBaseTestNetParams() { nRPCPort = 18332; strDataDir = &quot;testnet3&quot;; } }; static CBaseTestNetParams testNetParams; /* * Regression test */ class CBaseRegTestParams : public CBaseChainParams { public: CBaseRegTestParams() { nRPCPort = 18332; strDataDir = &quot;regtest&quot;; } }; static CBaseRegTestParams regTestParams; 在每个类的构造函数中定义了对应使用的端口以及数据保存目录。再来看BaseParams()的函数实现,位于chainpatamsbase.cpp CBaseChainParams&amp; BaseParams(const std::string&amp; chain) { if (chain == CBaseChainParams::MAIN) return mainParams; else if (chain == CBaseChainParams::TESTNET) return testNetParams; else if (chain == CBaseChainParams::REGTEST) return regTestParams; else throw std::runtime_error(strprintf(&quot;%s: Unknown chain %s.&quot;, __func__, chain)); } 就是根据传入的参数返回对应的参数类对象。 最后再来看SelectParams中的pCurrentParams = &amp;Params(network);，可以发现Params()函数与BaseParams()函数实现是一样的，都是根据传入参数获取对应的类对象，区别在于返回类对象的不同，Params()返回的是CChainParams&amp;类型的，这个类型是链的三个不同网络参数的基类，截取部分代码可以看到，这个类相比带base的类的配置信息更多，可以理解为base是基本参数，这一步是设置相应链的主要参数 //chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000;//区块奖励减半间隔 consensus.nMajorityEnforceBlockUpgrade = 750; consensus.nMajorityRejectBlockOutdated = 950; consensus.nMajorityWindow = 1000; consensus.BIP34Height = 227931; consensus.BIP34Hash = uint256S(&quot;0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8&quot;); consensus.powLimit = uint256S(&quot;00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;);//算力极限值 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60;//算力修改间隔 // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x0000000000000000000000000000000000000000003418b3ccbe5e93bcb39b43&quot;);//最低工作量 //创世块，第一个块奖励50个比特币 genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN); ··· 这段参数设置代码的参数中，我们主要关注下共识参数与创世区块信息的参数 consensus::Params consensus;//chainparams.h CBlock genesis//chainparams.cpp 主要来看主网中对这些参数的相关设置，⬆️看上面一段，添加备注的参数是经常听到的名次，如果要创建自己的数字货币，修改这些参数就可以了。所以创建一个新的货币并不难，关键在于是否有价值。 6.3RPC命令行判断 回到bitcoin.cpp继续参数解析部分 // Command-line RPC bool fCommandLine = false; for (int i = 1; i &lt; argc; i++) if (!IsSwitchChar(argv[i][0]) &amp;&amp; !boost::algorithm::istarts_with(argv[i], &quot;bitcoin:&quot;)) fCommandLine = true; if (fCommandLine) { fprintf(stderr, &quot;Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\n&quot;); exit(EXIT_FAILURE); } 上述代码对输入的参数逐个判断，首先通过IsSwitchCahr函数 //util.h inline bool IsSwitchChar(char c) { #ifdef WIN32 return c == &#39;-&#39; || c == &#39;/&#39;; #else return c == &#39;-&#39;; #endif } 判断参数是否有’-‘或’/’，并且不包含’bitcoin:’，带有不包含”-“的参数会报错，提示使用bitconi-cli 6.4 服务参数设置 默认bitcoind是打开服务器端 //bitcoind.cpp SoftSetBoolArg(&quot;-server&quot;, true); 函数SoftSetBoolArg()的实现在util.cpp中 bool SoftSetBoolArg(const std::string&amp; strArg, bool fValue) { if (fValue) return SoftSetArg(strArg, std::string(&quot;1&quot;)); else return SoftSetArg(strArg, std::string(&quot;0&quot;)); } bool SoftSetArg(const std::string&amp; strArg, const std::string&amp; strValue) { if (mapArgs.count(strArg)) return false; mapArgs[strArg] = strValue; return true; } 调用了SoftSetArg函数,strArg被赋值为server,那么首先在mapArgs(之前有介绍)中查找是否存在server，如果存在就不做处理，否则按传入的值设置。 7.初始化日志 回到bitcoind.cpp继续后面的代码 //init.cpp void InitLogging() { //-printtoconsole 日志信息发送到控制台，默认不发送到控制台 fPrintToConsole = GetBoolArg(&quot;-printtoconsole&quot;, false); //-logtimestamps 在日志中打印时间戳，默认打印 fLogTimestamps = GetBoolArg(&quot;-logtimestamps&quot;, DEFAULT_LOGTIMESTAMPS); //-logtimemicros 在日志中按微妙格式打印，默认不按 fLogTimeMicros = GetBoolArg(&quot;-logtimemicros&quot;, DEFAULT_LOGTIMEMICROS); //-logips 在日志中打印ip，默认不包含 fLogIPs = GetBoolArg(&quot;-logips&quot;, DEFAULT_LOGIPS); LogPrintf(&quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;); LogPrintf(&quot;Bitcoin version %s\n&quot;, FormatFullVersion()); } 其中三个默认参数 //util.h static const bool DEFAULT_LOGTIMEMICROS = false;//按微秒格式打印 static const bool DEFAULT_LOGIPS = false;//包含ip地址 static const bool DEFAULT_LOGTIMESTAMPS = true;//打印时间戳 看一下日志打印内容 8.InitParameterInteraction 初始化参数交互处理,设置后都会打印对应的语句 1）绑定并监听地址 //init.cpp // Parameter interaction based on rules void InitParameterInteraction() { // when specifying an explicit binding address, you want to listen on it // even when -connect or -proxy is specified if (mapArgs.count(&quot;-bind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -bind set -&gt; setting -listen=1\n&quot;, __func__); } if (mapArgs.count(&quot;-whitebind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -whitebind set -&gt; setting -listen=1\n&quot;, __func__); } 在指定显式绑定地址时，即使在指定-connect或-proxy时，也要监听它。绑定地址有两种参数，分别是bind和whitebind，从代码看对这两种参数的处理方式是相同的。 这里看一下LogPrintf函数,通过调用LogPrint实现 //util.h /** Return true if log accepts specified category */ bool LogAcceptCategory(const char* category); /** Send a string to the log output */ int LogPrintStr(const std::string &amp;str); #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__) template&lt;typename T1, typename... Args&gt; static inline int LogPrint(const char* category, const char* fmt, const T1&amp; v1, const Args&amp;... args) { if(!LogAcceptCategory(category)) return 0; \ return LogPrintStr(tfm::format(fmt, v1, args...)); } LogPrint对日志是否接收制定目录做判断，然后调用的是LogPrintStr //util.cpp int LogPrintStr(const std::string &amp;str) { int ret = 0; // Returns total number of characters written static bool fStartedNewLine = true; //添加时间戳 string strTimestamped = LogTimestampStr(str, &amp;fStartedNewLine); if (fPrintToConsole)//在7.初始化日志有设置 {// print to console ret = fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout); fflush(stdout); } else if (fPrintToDebugLog) { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } else { // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; //日志的默认地址对应路径下的debug.log boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } ret = FileWriteStr(strTimestamped, fileout); } } return ret; } &amp;fStartedNewLine是由调用上下文保存的状态变量，当不进行换行的多个调用时，将抑制时间戳的打印。将其初始化为true，并将其保存在调用上下文中。 LogPrintStr首先根据fStartedNewLine调用LogTimestampStr添加时间戳，其中根据fLogTimeMicros决定是否添加微秒的时间。根据条件输出到对应的设备中。 2）连接可信节点 查找mapArgs是否包含-connect参数，包括则将-dnsseed(使用dns查找)和-listen(接受外部的连接，并对其进行监听)设置为false,并打印。 3）代理模式 查找mapArgs参数中是否包含-proxy参数，如果包含则将-listen、-upnp、-discover都设置为false。 4）监听设置处理 //net.h /** -listen default */ static const bool DEFAULT_LISTEN = true; 如果-listen参数不为DEFAULT_LISTEN,即-listen为false则-upnp、-discover（自动默认发现地址）、-listenonion（匿名地址监听）都设置为false。 5）外部ip参数处理 查找mapArgs参数中是否包含-externalip参数，存在则将-discover设置为false，即不用查找其他的ip。 6）重新扫描钱包参数设置 如果-salvagewallet(尝试在启动时从毁坏的钱包恢复私钥)或-zapwallettxes(删除所有钱包交易，只恢复部分)设置为true，则将-rescan设置为true,重新扫描钱包。 7）区块模式参数设置 //net.h /** Default for blocks only*/ static const bool DEFAULT_BLOCKSONLY = false; 如果-blocksonly设置为true,则将-whitelistrelay、-walletbroadcast设置为false。 8）强制白名单连接参数 //main.h /** Default for DEFAULT_WHITELISTFORCERELAY. */ static const bool DEFAULT_WHITELISTFORCERELAY = true; 来自白名单主机的强制中继意味着我们将首先接受来自它们的中继。默认有白名单，将-whitelistrelay设置为true。可以看前面的截图第二行就是对应的打印内容。 比特币源码学习（三） 阅读更多" />
<meta property="og:description" content="源码0.13.2版的，在sublime中打开的 源码0.13.2版的，在sublime中打开的 6.2选择比特币网络 6.3RPC命令行判断 6.4 服务参数设置 7.初始化日志 8.InitParameterInteraction 默认文件在src文件夹下，ide改为sublime，在跳转到定义的体验好很多 6.2选择比特币网络 比特币网络分为主网、测试网以及私有网三种网络： 主网：Main network 测试网：Testnet (v3) 私有网：Regression test 接上面的代码 // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause) try { SelectParams(ChainNameFromCommandLine()); } catch (const std::exception&amp; e) { fprintf(stderr, &quot;Error: %s\n&quot;, e.what()); return false; } 代码注释的含义为检查testnet或regtest参数（Params()仅在该子句之后生效），try子句中调用了SelectParams()函数，是以ChainNameFromCommandLine()的返回值作为参数,先来看ChainNameFromCommandLine()函数，位于chainparamsbase.cpp中 std::string ChainNameFromCommandLine() { bool fRegTest = GetBoolArg(&quot;-regtest&quot;, false); bool fTestNet = GetBoolArg(&quot;-testnet&quot;, false); if (fTestNet &amp;&amp; fRegTest) throw std::runtime_error(&quot;Invalid combination of -regtest and -testnet.&quot;); if (fRegTest) return CBaseChainParams::REGTEST; if (fTestNet) return CBaseChainParams::TESTNET; return CBaseChainParams::MAIN; 首先获取-testnet与-regtest的参数设置，两个都设置的话扔出错误，根据设置返回，都没设置的话返回主网。 class CBaseChainParams { public: /** BIP70 chain name strings (main, test or regtest) */ static const std::string MAIN; static const std::string TESTNET; static const std::string REGTEST; 返回值为字符串常量，在chainparamsbase.h的定义如上，在chainparamsbase.cpp定义如下 const std::string CBaseChainParams::MAIN = &quot;main&quot;; const std::string CBaseChainParams::TESTNET = &quot;test&quot;; const std::string CBaseChainParams::REGTEST = &quot;regtest&quot;; 在获得链的网络名称后，我们来看SelectParams()这个函数，位于chainparams最后几行 void SelectParams(const std::string&amp; network) { SelectBaseParams(network); pCurrentParams = &amp;Params(network); } 这个函数中首先调用SelectBaseParams函数，位于chainpatamsbase.cpp void SelectBaseParams(const std::string&amp; chain) { pCurrentBaseParams = &amp;BaseParams(chain); } 这个函数是实现对pCurrentBaseParams的赋值，pCurrentBaseParams是CBaseChainParams类型的 static CBaseChainParams* pCurrentBaseParams = 0; 而CBaseChainParams是三种网络类型参数的基类，三种网络参数类位于chainpatamsbase.cpp class CBaseMainParams : public CBaseChainParams { public: CBaseMainParams() { nRPCPort = 8332; } }; static CBaseMainParams mainParams; /** * Testnet (v3) */ class CBaseTestNetParams : public CBaseChainParams { public: CBaseTestNetParams() { nRPCPort = 18332; strDataDir = &quot;testnet3&quot;; } }; static CBaseTestNetParams testNetParams; /* * Regression test */ class CBaseRegTestParams : public CBaseChainParams { public: CBaseRegTestParams() { nRPCPort = 18332; strDataDir = &quot;regtest&quot;; } }; static CBaseRegTestParams regTestParams; 在每个类的构造函数中定义了对应使用的端口以及数据保存目录。再来看BaseParams()的函数实现,位于chainpatamsbase.cpp CBaseChainParams&amp; BaseParams(const std::string&amp; chain) { if (chain == CBaseChainParams::MAIN) return mainParams; else if (chain == CBaseChainParams::TESTNET) return testNetParams; else if (chain == CBaseChainParams::REGTEST) return regTestParams; else throw std::runtime_error(strprintf(&quot;%s: Unknown chain %s.&quot;, __func__, chain)); } 就是根据传入的参数返回对应的参数类对象。 最后再来看SelectParams中的pCurrentParams = &amp;Params(network);，可以发现Params()函数与BaseParams()函数实现是一样的，都是根据传入参数获取对应的类对象，区别在于返回类对象的不同，Params()返回的是CChainParams&amp;类型的，这个类型是链的三个不同网络参数的基类，截取部分代码可以看到，这个类相比带base的类的配置信息更多，可以理解为base是基本参数，这一步是设置相应链的主要参数 //chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000;//区块奖励减半间隔 consensus.nMajorityEnforceBlockUpgrade = 750; consensus.nMajorityRejectBlockOutdated = 950; consensus.nMajorityWindow = 1000; consensus.BIP34Height = 227931; consensus.BIP34Hash = uint256S(&quot;0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8&quot;); consensus.powLimit = uint256S(&quot;00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;);//算力极限值 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60;//算力修改间隔 // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x0000000000000000000000000000000000000000003418b3ccbe5e93bcb39b43&quot;);//最低工作量 //创世块，第一个块奖励50个比特币 genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN); ··· 这段参数设置代码的参数中，我们主要关注下共识参数与创世区块信息的参数 consensus::Params consensus;//chainparams.h CBlock genesis//chainparams.cpp 主要来看主网中对这些参数的相关设置，⬆️看上面一段，添加备注的参数是经常听到的名次，如果要创建自己的数字货币，修改这些参数就可以了。所以创建一个新的货币并不难，关键在于是否有价值。 6.3RPC命令行判断 回到bitcoin.cpp继续参数解析部分 // Command-line RPC bool fCommandLine = false; for (int i = 1; i &lt; argc; i++) if (!IsSwitchChar(argv[i][0]) &amp;&amp; !boost::algorithm::istarts_with(argv[i], &quot;bitcoin:&quot;)) fCommandLine = true; if (fCommandLine) { fprintf(stderr, &quot;Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\n&quot;); exit(EXIT_FAILURE); } 上述代码对输入的参数逐个判断，首先通过IsSwitchCahr函数 //util.h inline bool IsSwitchChar(char c) { #ifdef WIN32 return c == &#39;-&#39; || c == &#39;/&#39;; #else return c == &#39;-&#39;; #endif } 判断参数是否有’-‘或’/’，并且不包含’bitcoin:’，带有不包含”-“的参数会报错，提示使用bitconi-cli 6.4 服务参数设置 默认bitcoind是打开服务器端 //bitcoind.cpp SoftSetBoolArg(&quot;-server&quot;, true); 函数SoftSetBoolArg()的实现在util.cpp中 bool SoftSetBoolArg(const std::string&amp; strArg, bool fValue) { if (fValue) return SoftSetArg(strArg, std::string(&quot;1&quot;)); else return SoftSetArg(strArg, std::string(&quot;0&quot;)); } bool SoftSetArg(const std::string&amp; strArg, const std::string&amp; strValue) { if (mapArgs.count(strArg)) return false; mapArgs[strArg] = strValue; return true; } 调用了SoftSetArg函数,strArg被赋值为server,那么首先在mapArgs(之前有介绍)中查找是否存在server，如果存在就不做处理，否则按传入的值设置。 7.初始化日志 回到bitcoind.cpp继续后面的代码 //init.cpp void InitLogging() { //-printtoconsole 日志信息发送到控制台，默认不发送到控制台 fPrintToConsole = GetBoolArg(&quot;-printtoconsole&quot;, false); //-logtimestamps 在日志中打印时间戳，默认打印 fLogTimestamps = GetBoolArg(&quot;-logtimestamps&quot;, DEFAULT_LOGTIMESTAMPS); //-logtimemicros 在日志中按微妙格式打印，默认不按 fLogTimeMicros = GetBoolArg(&quot;-logtimemicros&quot;, DEFAULT_LOGTIMEMICROS); //-logips 在日志中打印ip，默认不包含 fLogIPs = GetBoolArg(&quot;-logips&quot;, DEFAULT_LOGIPS); LogPrintf(&quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;); LogPrintf(&quot;Bitcoin version %s\n&quot;, FormatFullVersion()); } 其中三个默认参数 //util.h static const bool DEFAULT_LOGTIMEMICROS = false;//按微秒格式打印 static const bool DEFAULT_LOGIPS = false;//包含ip地址 static const bool DEFAULT_LOGTIMESTAMPS = true;//打印时间戳 看一下日志打印内容 8.InitParameterInteraction 初始化参数交互处理,设置后都会打印对应的语句 1）绑定并监听地址 //init.cpp // Parameter interaction based on rules void InitParameterInteraction() { // when specifying an explicit binding address, you want to listen on it // even when -connect or -proxy is specified if (mapArgs.count(&quot;-bind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -bind set -&gt; setting -listen=1\n&quot;, __func__); } if (mapArgs.count(&quot;-whitebind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -whitebind set -&gt; setting -listen=1\n&quot;, __func__); } 在指定显式绑定地址时，即使在指定-connect或-proxy时，也要监听它。绑定地址有两种参数，分别是bind和whitebind，从代码看对这两种参数的处理方式是相同的。 这里看一下LogPrintf函数,通过调用LogPrint实现 //util.h /** Return true if log accepts specified category */ bool LogAcceptCategory(const char* category); /** Send a string to the log output */ int LogPrintStr(const std::string &amp;str); #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__) template&lt;typename T1, typename... Args&gt; static inline int LogPrint(const char* category, const char* fmt, const T1&amp; v1, const Args&amp;... args) { if(!LogAcceptCategory(category)) return 0; \ return LogPrintStr(tfm::format(fmt, v1, args...)); } LogPrint对日志是否接收制定目录做判断，然后调用的是LogPrintStr //util.cpp int LogPrintStr(const std::string &amp;str) { int ret = 0; // Returns total number of characters written static bool fStartedNewLine = true; //添加时间戳 string strTimestamped = LogTimestampStr(str, &amp;fStartedNewLine); if (fPrintToConsole)//在7.初始化日志有设置 {// print to console ret = fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout); fflush(stdout); } else if (fPrintToDebugLog) { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } else { // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; //日志的默认地址对应路径下的debug.log boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } ret = FileWriteStr(strTimestamped, fileout); } } return ret; } &amp;fStartedNewLine是由调用上下文保存的状态变量，当不进行换行的多个调用时，将抑制时间戳的打印。将其初始化为true，并将其保存在调用上下文中。 LogPrintStr首先根据fStartedNewLine调用LogTimestampStr添加时间戳，其中根据fLogTimeMicros决定是否添加微秒的时间。根据条件输出到对应的设备中。 2）连接可信节点 查找mapArgs是否包含-connect参数，包括则将-dnsseed(使用dns查找)和-listen(接受外部的连接，并对其进行监听)设置为false,并打印。 3）代理模式 查找mapArgs参数中是否包含-proxy参数，如果包含则将-listen、-upnp、-discover都设置为false。 4）监听设置处理 //net.h /** -listen default */ static const bool DEFAULT_LISTEN = true; 如果-listen参数不为DEFAULT_LISTEN,即-listen为false则-upnp、-discover（自动默认发现地址）、-listenonion（匿名地址监听）都设置为false。 5）外部ip参数处理 查找mapArgs参数中是否包含-externalip参数，存在则将-discover设置为false，即不用查找其他的ip。 6）重新扫描钱包参数设置 如果-salvagewallet(尝试在启动时从毁坏的钱包恢复私钥)或-zapwallettxes(删除所有钱包交易，只恢复部分)设置为true，则将-rescan设置为true,重新扫描钱包。 7）区块模式参数设置 //net.h /** Default for blocks only*/ static const bool DEFAULT_BLOCKSONLY = false; 如果-blocksonly设置为true,则将-whitelistrelay、-walletbroadcast设置为false。 8）强制白名单连接参数 //main.h /** Default for DEFAULT_WHITELISTFORCERELAY. */ static const bool DEFAULT_WHITELISTFORCERELAY = true; 来自白名单主机的强制中继意味着我们将首先接受来自它们的中继。默认有白名单，将-whitelistrelay设置为true。可以看前面的截图第二行就是对应的打印内容。 比特币源码学习（三） 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"源码0.13.2版的，在sublime中打开的 源码0.13.2版的，在sublime中打开的 6.2选择比特币网络 6.3RPC命令行判断 6.4 服务参数设置 7.初始化日志 8.InitParameterInteraction 默认文件在src文件夹下，ide改为sublime，在跳转到定义的体验好很多 6.2选择比特币网络 比特币网络分为主网、测试网以及私有网三种网络： 主网：Main network 测试网：Testnet (v3) 私有网：Regression test 接上面的代码 // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause) try { SelectParams(ChainNameFromCommandLine()); } catch (const std::exception&amp; e) { fprintf(stderr, &quot;Error: %s\\n&quot;, e.what()); return false; } 代码注释的含义为检查testnet或regtest参数（Params()仅在该子句之后生效），try子句中调用了SelectParams()函数，是以ChainNameFromCommandLine()的返回值作为参数,先来看ChainNameFromCommandLine()函数，位于chainparamsbase.cpp中 std::string ChainNameFromCommandLine() { bool fRegTest = GetBoolArg(&quot;-regtest&quot;, false); bool fTestNet = GetBoolArg(&quot;-testnet&quot;, false); if (fTestNet &amp;&amp; fRegTest) throw std::runtime_error(&quot;Invalid combination of -regtest and -testnet.&quot;); if (fRegTest) return CBaseChainParams::REGTEST; if (fTestNet) return CBaseChainParams::TESTNET; return CBaseChainParams::MAIN; 首先获取-testnet与-regtest的参数设置，两个都设置的话扔出错误，根据设置返回，都没设置的话返回主网。 class CBaseChainParams { public: /** BIP70 chain name strings (main, test or regtest) */ static const std::string MAIN; static const std::string TESTNET; static const std::string REGTEST; 返回值为字符串常量，在chainparamsbase.h的定义如上，在chainparamsbase.cpp定义如下 const std::string CBaseChainParams::MAIN = &quot;main&quot;; const std::string CBaseChainParams::TESTNET = &quot;test&quot;; const std::string CBaseChainParams::REGTEST = &quot;regtest&quot;; 在获得链的网络名称后，我们来看SelectParams()这个函数，位于chainparams最后几行 void SelectParams(const std::string&amp; network) { SelectBaseParams(network); pCurrentParams = &amp;Params(network); } 这个函数中首先调用SelectBaseParams函数，位于chainpatamsbase.cpp void SelectBaseParams(const std::string&amp; chain) { pCurrentBaseParams = &amp;BaseParams(chain); } 这个函数是实现对pCurrentBaseParams的赋值，pCurrentBaseParams是CBaseChainParams类型的 static CBaseChainParams* pCurrentBaseParams = 0; 而CBaseChainParams是三种网络类型参数的基类，三种网络参数类位于chainpatamsbase.cpp class CBaseMainParams : public CBaseChainParams { public: CBaseMainParams() { nRPCPort = 8332; } }; static CBaseMainParams mainParams; /** * Testnet (v3) */ class CBaseTestNetParams : public CBaseChainParams { public: CBaseTestNetParams() { nRPCPort = 18332; strDataDir = &quot;testnet3&quot;; } }; static CBaseTestNetParams testNetParams; /* * Regression test */ class CBaseRegTestParams : public CBaseChainParams { public: CBaseRegTestParams() { nRPCPort = 18332; strDataDir = &quot;regtest&quot;; } }; static CBaseRegTestParams regTestParams; 在每个类的构造函数中定义了对应使用的端口以及数据保存目录。再来看BaseParams()的函数实现,位于chainpatamsbase.cpp CBaseChainParams&amp; BaseParams(const std::string&amp; chain) { if (chain == CBaseChainParams::MAIN) return mainParams; else if (chain == CBaseChainParams::TESTNET) return testNetParams; else if (chain == CBaseChainParams::REGTEST) return regTestParams; else throw std::runtime_error(strprintf(&quot;%s: Unknown chain %s.&quot;, __func__, chain)); } 就是根据传入的参数返回对应的参数类对象。 最后再来看SelectParams中的pCurrentParams = &amp;Params(network);，可以发现Params()函数与BaseParams()函数实现是一样的，都是根据传入参数获取对应的类对象，区别在于返回类对象的不同，Params()返回的是CChainParams&amp;类型的，这个类型是链的三个不同网络参数的基类，截取部分代码可以看到，这个类相比带base的类的配置信息更多，可以理解为base是基本参数，这一步是设置相应链的主要参数 //chainparams.cpp class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000;//区块奖励减半间隔 consensus.nMajorityEnforceBlockUpgrade = 750; consensus.nMajorityRejectBlockOutdated = 950; consensus.nMajorityWindow = 1000; consensus.BIP34Height = 227931; consensus.BIP34Hash = uint256S(&quot;0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8&quot;); consensus.powLimit = uint256S(&quot;00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;);//算力极限值 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60;//算力修改间隔 // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x0000000000000000000000000000000000000000003418b3ccbe5e93bcb39b43&quot;);//最低工作量 //创世块，第一个块奖励50个比特币 genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN); ··· 这段参数设置代码的参数中，我们主要关注下共识参数与创世区块信息的参数 consensus::Params consensus;//chainparams.h CBlock genesis//chainparams.cpp 主要来看主网中对这些参数的相关设置，⬆️看上面一段，添加备注的参数是经常听到的名次，如果要创建自己的数字货币，修改这些参数就可以了。所以创建一个新的货币并不难，关键在于是否有价值。 6.3RPC命令行判断 回到bitcoin.cpp继续参数解析部分 // Command-line RPC bool fCommandLine = false; for (int i = 1; i &lt; argc; i++) if (!IsSwitchChar(argv[i][0]) &amp;&amp; !boost::algorithm::istarts_with(argv[i], &quot;bitcoin:&quot;)) fCommandLine = true; if (fCommandLine) { fprintf(stderr, &quot;Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n&quot;); exit(EXIT_FAILURE); } 上述代码对输入的参数逐个判断，首先通过IsSwitchCahr函数 //util.h inline bool IsSwitchChar(char c) { #ifdef WIN32 return c == &#39;-&#39; || c == &#39;/&#39;; #else return c == &#39;-&#39;; #endif } 判断参数是否有’-‘或’/’，并且不包含’bitcoin:’，带有不包含”-“的参数会报错，提示使用bitconi-cli 6.4 服务参数设置 默认bitcoind是打开服务器端 //bitcoind.cpp SoftSetBoolArg(&quot;-server&quot;, true); 函数SoftSetBoolArg()的实现在util.cpp中 bool SoftSetBoolArg(const std::string&amp; strArg, bool fValue) { if (fValue) return SoftSetArg(strArg, std::string(&quot;1&quot;)); else return SoftSetArg(strArg, std::string(&quot;0&quot;)); } bool SoftSetArg(const std::string&amp; strArg, const std::string&amp; strValue) { if (mapArgs.count(strArg)) return false; mapArgs[strArg] = strValue; return true; } 调用了SoftSetArg函数,strArg被赋值为server,那么首先在mapArgs(之前有介绍)中查找是否存在server，如果存在就不做处理，否则按传入的值设置。 7.初始化日志 回到bitcoind.cpp继续后面的代码 //init.cpp void InitLogging() { //-printtoconsole 日志信息发送到控制台，默认不发送到控制台 fPrintToConsole = GetBoolArg(&quot;-printtoconsole&quot;, false); //-logtimestamps 在日志中打印时间戳，默认打印 fLogTimestamps = GetBoolArg(&quot;-logtimestamps&quot;, DEFAULT_LOGTIMESTAMPS); //-logtimemicros 在日志中按微妙格式打印，默认不按 fLogTimeMicros = GetBoolArg(&quot;-logtimemicros&quot;, DEFAULT_LOGTIMEMICROS); //-logips 在日志中打印ip，默认不包含 fLogIPs = GetBoolArg(&quot;-logips&quot;, DEFAULT_LOGIPS); LogPrintf(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); LogPrintf(&quot;Bitcoin version %s\\n&quot;, FormatFullVersion()); } 其中三个默认参数 //util.h static const bool DEFAULT_LOGTIMEMICROS = false;//按微秒格式打印 static const bool DEFAULT_LOGIPS = false;//包含ip地址 static const bool DEFAULT_LOGTIMESTAMPS = true;//打印时间戳 看一下日志打印内容 8.InitParameterInteraction 初始化参数交互处理,设置后都会打印对应的语句 1）绑定并监听地址 //init.cpp // Parameter interaction based on rules void InitParameterInteraction() { // when specifying an explicit binding address, you want to listen on it // even when -connect or -proxy is specified if (mapArgs.count(&quot;-bind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -bind set -&gt; setting -listen=1\\n&quot;, __func__); } if (mapArgs.count(&quot;-whitebind&quot;)) { if (SoftSetBoolArg(&quot;-listen&quot;, true)) LogPrintf(&quot;%s: parameter interaction: -whitebind set -&gt; setting -listen=1\\n&quot;, __func__); } 在指定显式绑定地址时，即使在指定-connect或-proxy时，也要监听它。绑定地址有两种参数，分别是bind和whitebind，从代码看对这两种参数的处理方式是相同的。 这里看一下LogPrintf函数,通过调用LogPrint实现 //util.h /** Return true if log accepts specified category */ bool LogAcceptCategory(const char* category); /** Send a string to the log output */ int LogPrintStr(const std::string &amp;str); #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__) template&lt;typename T1, typename... Args&gt; static inline int LogPrint(const char* category, const char* fmt, const T1&amp; v1, const Args&amp;... args) { if(!LogAcceptCategory(category)) return 0; \\ return LogPrintStr(tfm::format(fmt, v1, args...)); } LogPrint对日志是否接收制定目录做判断，然后调用的是LogPrintStr //util.cpp int LogPrintStr(const std::string &amp;str) { int ret = 0; // Returns total number of characters written static bool fStartedNewLine = true; //添加时间戳 string strTimestamped = LogTimestampStr(str, &amp;fStartedNewLine); if (fPrintToConsole)//在7.初始化日志有设置 {// print to console ret = fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout); fflush(stdout); } else if (fPrintToDebugLog) { boost::call_once(&amp;DebugPrintInit, debugPrintInitFlag); boost::mutex::scoped_lock scoped_lock(*mutexDebugLog); // buffer if we haven&#39;t opened the log yet if (fileout == NULL) { assert(vMsgsBeforeOpenLog); ret = strTimestamped.length(); vMsgsBeforeOpenLog-&gt;push_back(strTimestamped); } else { // reopen the log file, if requested if (fReopenDebugLog) { fReopenDebugLog = false; //日志的默认地址对应路径下的debug.log boost::filesystem::path pathDebug = GetDataDir() / &quot;debug.log&quot;; if (freopen(pathDebug.string().c_str(),&quot;a&quot;,fileout) != NULL) setbuf(fileout, NULL); // unbuffered } ret = FileWriteStr(strTimestamped, fileout); } } return ret; } &amp;fStartedNewLine是由调用上下文保存的状态变量，当不进行换行的多个调用时，将抑制时间戳的打印。将其初始化为true，并将其保存在调用上下文中。 LogPrintStr首先根据fStartedNewLine调用LogTimestampStr添加时间戳，其中根据fLogTimeMicros决定是否添加微秒的时间。根据条件输出到对应的设备中。 2）连接可信节点 查找mapArgs是否包含-connect参数，包括则将-dnsseed(使用dns查找)和-listen(接受外部的连接，并对其进行监听)设置为false,并打印。 3）代理模式 查找mapArgs参数中是否包含-proxy参数，如果包含则将-listen、-upnp、-discover都设置为false。 4）监听设置处理 //net.h /** -listen default */ static const bool DEFAULT_LISTEN = true; 如果-listen参数不为DEFAULT_LISTEN,即-listen为false则-upnp、-discover（自动默认发现地址）、-listenonion（匿名地址监听）都设置为false。 5）外部ip参数处理 查找mapArgs参数中是否包含-externalip参数，存在则将-discover设置为false，即不用查找其他的ip。 6）重新扫描钱包参数设置 如果-salvagewallet(尝试在启动时从毁坏的钱包恢复私钥)或-zapwallettxes(删除所有钱包交易，只恢复部分)设置为true，则将-rescan设置为true,重新扫描钱包。 7）区块模式参数设置 //net.h /** Default for blocks only*/ static const bool DEFAULT_BLOCKSONLY = false; 如果-blocksonly设置为true,则将-whitelistrelay、-walletbroadcast设置为false。 8）强制白名单连接参数 //main.h /** Default for DEFAULT_WHITELISTFORCERELAY. */ static const bool DEFAULT_WHITELISTFORCERELAY = true; 来自白名单主机的强制中继意味着我们将首先接受来自它们的中继。默认有白名单，将-whitelistrelay设置为true。可以看前面的截图第二行就是对应的打印内容。 比特币源码学习（三） 阅读更多","@type":"BlogPosting","url":"/2018/08/01/a536e8f66a9f50ce7108a21e47ee16f2.html","headline":"比特币源码学习0.13（二）","dateModified":"2018-08-01T00:00:00+08:00","datePublished":"2018-08-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/01/a536e8f66a9f50ce7108a21e47ee16f2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码学习0.13（二）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h3 id="源码0132版的在sublime中打开的">源码0.13.2版的，在sublime中打开的</h3> 
  <hr> 
  <p></p>
  <div class="toc">
   <div class="toc"> 
    <ul> 
     <li>
      <ul> 
       <li>
        <ul> 
         <li><a href="#源码0132版的在sublime中打开的" rel="nofollow">源码0.13.2版的，在sublime中打开的</a>
          <ul> 
           <li>
            <ul> 
             <li><a href="#62选择比特币网络" rel="nofollow">6.2选择比特币网络</a></li> 
             <li><a href="#63rpc命令行判断" rel="nofollow">6.3RPC命令行判断</a></li> 
             <li><a href="#64-服务参数设置" rel="nofollow">6.4 服务参数设置</a></li> 
            </ul> </li> 
           <li><a href="#7初始化日志" rel="nofollow">7.初始化日志</a></li> 
           <li><a href="#8initparameterinteraction" rel="nofollow">8.InitParameterInteraction</a></li> 
          </ul> </li> 
        </ul> </li> 
      </ul> </li> 
    </ul> 
   </div> 
  </div> 
  <p></p> 
  <hr> 
  <p>默认文件在src文件夹下，ide改为sublime，在跳转到定义的体验好很多</p> 
  <h5 id="62选择比特币网络">6.2选择比特币网络</h5> 
  <p>比特币网络分为主网、测试网以及私有网三种网络： <br> 主网：Main network <br> 测试网：Testnet (v3) <br> 私有网：Regression test <br> 接上面的代码</p> 
  <pre class="prettyprint"><code class=" hljs coffeescript"> <span class="hljs-regexp">//</span> Check <span class="hljs-keyword">for</span> -testnet <span class="hljs-keyword">or</span> -regtest parameter (Params() calls are only valid after <span class="hljs-keyword">this</span> clause)
        <span class="hljs-keyword">try</span> {
            SelectParams(ChainNameFromCommandLine());
        } <span class="hljs-keyword">catch</span> (<span class="hljs-reserved">const</span> <span class="hljs-attribute">std</span>::exception&amp; e) {
            fprintf(stderr, <span class="hljs-string">"Error: %s\n"</span>, e.what());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</code></pre> 
  <p>代码注释的含义为检查testnet或regtest参数（Params()仅在该子句之后生效），<font color="#008B8B">try</font>子句中调用了<font color="#008B8B">SelectParams()</font>函数，是以<font color="#008B8B">ChainNameFromCommandLine()</font>的返回值作为参数,先来看<font color="#008B8B">ChainNameFromCommandLine()</font>函数，位于<font color="#008B8B">chainparamsbase.cpp</font>中</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ChainNameFromCommandLine()
{
    <span class="hljs-keyword">bool</span> fRegTest = GetBoolArg(<span class="hljs-string">"-regtest"</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">bool</span> fTestNet = GetBoolArg(<span class="hljs-string">"-testnet"</span>, <span class="hljs-keyword">false</span>);

    <span class="hljs-keyword">if</span> (fTestNet &amp;&amp; fRegTest)
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Invalid combination of -regtest and -testnet."</span>);
    <span class="hljs-keyword">if</span> (fRegTest)
        <span class="hljs-keyword">return</span> CBaseChainParams::REGTEST;
    <span class="hljs-keyword">if</span> (fTestNet)
        <span class="hljs-keyword">return</span> CBaseChainParams::TESTNET;
    <span class="hljs-keyword">return</span> CBaseChainParams::MAIN;</code></pre> 
  <p>首先获取<font color="#008B8B">-testnet</font>与<font color="#008B8B">-regtest</font>的参数设置，两个都设置的话扔出错误，根据设置返回，都没设置的话返回主网。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> CBaseChainParams
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** BIP70 chain name strings (main, test or regtest) */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> MAIN;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TESTNET;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> REGTEST;</code></pre> 
  <p>返回值为字符串常量，在<font color="#008B8B">chainparamsbase.h</font>的定义如上，在<font color="#008B8B">chainparamsbase.cpp</font>定义如下</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> CBaseChainParams::MAIN = <span class="hljs-string">"main"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> CBaseChainParams::TESTNET = <span class="hljs-string">"test"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> CBaseChainParams::REGTEST = <span class="hljs-string">"regtest"</span>;</code></pre> 
  <p>在获得链的网络名称后，我们来看<font color="#008B8B">SelectParams()</font>这个函数，位于<font color="#008B8B">chainparams</font>最后几行</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> SelectParams(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; network)
{
    SelectBaseParams(network);
    pCurrentParams = &amp;Params(network);
}</code></pre> 
  <p>这个函数中首先调用<font color="#008B8B">SelectBaseParams</font>函数，位于<font color="#008B8B">chainpatamsbase.cpp</font></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> SelectBaseParams(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; chain)
{
    pCurrentBaseParams = &amp;BaseParams(chain);
}</code></pre> 
  <p>这个函数是实现对<font color="#008B8B">pCurrentBaseParams</font>的赋值，<font color="#008B8B">pCurrentBaseParams</font>是<font color="#008B8B">CBaseChainParams</font>类型的</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">static CBaseChainParams* pCurrentBaseParams </span>=<span class="hljs-string"> 0;</span></code></pre> 
  <p>而<font color="#008B8B">CBaseChainParams</font>是三种网络类型参数的基类，三种网络参数类位于<font color="#008B8B">chainpatamsbase.cpp</font></p> 
  <pre class="prettyprint"><code class=" hljs java">class CBaseMainParams : <span class="hljs-keyword">public</span> CBaseChainParams
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">CBaseMainParams</span>()
    {
        nRPCPort = <span class="hljs-number">8332</span>;
    }
};
<span class="hljs-keyword">static</span> CBaseMainParams mainParams;

<span class="hljs-javadoc">/** * Testnet (v3) */</span>
class CBaseTestNetParams : <span class="hljs-keyword">public</span> CBaseChainParams
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">CBaseTestNetParams</span>()
    {
        nRPCPort = <span class="hljs-number">18332</span>;
        strDataDir = <span class="hljs-string">"testnet3"</span>;
    }
};
<span class="hljs-keyword">static</span> CBaseTestNetParams testNetParams;

<span class="hljs-comment">/* * Regression test */</span>
class CBaseRegTestParams : <span class="hljs-keyword">public</span> CBaseChainParams
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">CBaseRegTestParams</span>()
    {
        nRPCPort = <span class="hljs-number">18332</span>;
        strDataDir = <span class="hljs-string">"regtest"</span>;
    }
};
<span class="hljs-keyword">static</span> CBaseRegTestParams regTestParams;</code></pre> 
  <p>在每个类的构造函数中定义了对应使用的端口以及数据保存目录。再来看<font color="#008B8B">BaseParams()</font>的函数实现,位于<font color="#008B8B">chainpatamsbase.cpp</font></p> 
  <pre class="prettyprint"><code class=" hljs lasso">CBaseChainParams<span class="hljs-subst">&amp;</span> BaseParams(const std<span class="hljs-tag">::string</span><span class="hljs-subst">&amp;</span> chain)
{
    <span class="hljs-keyword">if</span> (chain <span class="hljs-subst">==</span> CBaseChainParams<span class="hljs-tag">::MAIN</span>)
        <span class="hljs-keyword">return</span> mainParams;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chain <span class="hljs-subst">==</span> CBaseChainParams<span class="hljs-tag">::TESTNET</span>)
        <span class="hljs-keyword">return</span> testNetParams;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chain <span class="hljs-subst">==</span> CBaseChainParams<span class="hljs-tag">::REGTEST</span>)
        <span class="hljs-keyword">return</span> regTestParams;
    <span class="hljs-keyword">else</span>
        throw std<span class="hljs-tag">::runtime_error</span>(strprintf(<span class="hljs-string">"%s: Unknown chain %s."</span>, __func__, chain));
}</code></pre> 
  <p>就是根据传入的参数返回对应的参数类对象。 <br> 最后再来看<font color="#008B8B">SelectParams</font>中的<font color="#008B8B">pCurrentParams = &amp;Params(network);</font>，可以发现<font color="#008B8B">Params()</font>函数与<font color="#008B8B">BaseParams()</font>函数实现是一样的，都是根据传入参数获取对应的类对象，区别在于返回类对象的不同，<font color="#008B8B">Params()</font>返回的是<font color="#008B8B">CChainParams&amp;</font>类型的，这个类型是链的三个不同网络参数的基类，截取部分代码可以看到，这个类相比带base的类的配置信息更多，可以理解为base是基本参数，这一步是设置相应链的主要参数</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//chainparams.cpp</span>
class CMainParams : <span class="hljs-keyword">public</span> CChainParams {
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">CMainParams</span>() {
        strNetworkID = <span class="hljs-string">"main"</span>;
        consensus.nSubsidyHalvingInterval = <span class="hljs-number">210000</span>;<span class="hljs-comment">//区块奖励减半间隔</span>
        consensus.nMajorityEnforceBlockUpgrade = <span class="hljs-number">750</span>;
        consensus.nMajorityRejectBlockOutdated = <span class="hljs-number">950</span>;
        consensus.nMajorityWindow = <span class="hljs-number">1000</span>;
        consensus.BIP34Height = <span class="hljs-number">227931</span>;
        consensus.BIP34Hash = uint256S(<span class="hljs-string">"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8"</span>);
        consensus.powLimit = uint256S(<span class="hljs-string">"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff"</span>);<span class="hljs-comment">//算力极限值</span>
        consensus.nPowTargetTimespan = <span class="hljs-number">14</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>; <span class="hljs-comment">// two weeks</span>
        consensus.nPowTargetSpacing = <span class="hljs-number">10</span> * <span class="hljs-number">60</span>;<span class="hljs-comment">//算力修改间隔</span>
        <span class="hljs-comment">// The best chain should have at least this much work.</span>
        consensus.nMinimumChainWork = uint256S(<span class="hljs-string">"0x0000000000000000000000000000000000000000003418b3ccbe5e93bcb39b43"</span>);<span class="hljs-comment">//最低工作量</span>
        <span class="hljs-comment">//创世块，第一个块奖励50个比特币</span>
        genesis = CreateGenesisBlock(<span class="hljs-number">1231006505</span>, <span class="hljs-number">2083236893</span>, <span class="hljs-number">0x1d00ffff</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span> * COIN);
        ···</code></pre> 
  <p>这段参数设置代码的参数中，我们主要关注下共识参数与创世区块信息的参数</p> 
  <pre class="prettyprint"><code class=" hljs oxygene">consensus::<span class="hljs-keyword">Params</span> consensus;<span class="hljs-comment">//chainparams.h</span>
CBlock genesis<span class="hljs-comment">//chainparams.cpp</span></code></pre> 
  <p>主要来看主网中对这些参数的相关设置，⬆️看上面一段，添加备注的参数是经常听到的名次，如果要创建自己的数字货币，修改这些参数就可以了。所以创建一个新的货币并不难，关键在于是否有价值。</p> 
  <hr> 
  <h5 id="63rpc命令行判断">6.3RPC命令行判断</h5> 
  <p>回到<font color="#008B8B">bitcoin.cpp</font>继续参数解析部分</p> 
  <pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-comment">// Command-line RPC</span>
        <span class="hljs-keyword">bool</span> fCommandLine = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)
            <span class="hljs-keyword">if</span> (!IsSwitchChar(argv[i][<span class="hljs-number">0</span>]) &amp;&amp; !boost::algorithm::istarts_with(argv[i], <span class="hljs-string">"bitcoin:"</span>))
                fCommandLine = <span class="hljs-keyword">true</span>;

        <span class="hljs-keyword">if</span> (fCommandLine)
        {
            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\n"</span>);
            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
        }</code></pre> 
  <p>上述代码对输入的参数逐个判断，首先通过<font color="#008B8B">IsSwitchCahr</font>函数</p> 
  <pre class="prettyprint"><code class=" hljs vala"><span class="hljs-comment">//util.h</span>
inline <span class="hljs-keyword">bool</span> IsSwitchChar(<span class="hljs-keyword">char</span> c)
{
<span class="hljs-preprocessor">#ifdef WIN32</span>
    <span class="hljs-keyword">return</span> c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'/'</span>;
<span class="hljs-preprocessor">#else</span>
    <span class="hljs-keyword">return</span> c == <span class="hljs-string">'-'</span>;
<span class="hljs-preprocessor">#endif</span>
}</code></pre> 
  <p>判断参数是否有’-‘或’/’，并且不包含’bitcoin:’，带有不包含”-“的参数会报错，提示使用<font color="#008B8B">bitconi-cli<font> <br> <img src="https://img-blog.csdn.net/20180730155758382?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></font></font></p> 
  <hr> 
  <h5 id="64-服务参数设置">6.4 服务参数设置</h5> 
  <p>默认bitcoind是打开服务器端</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//bitcoind.cpp</span>
SoftSetBoolArg(<span class="hljs-string">"-server"</span>, <span class="hljs-keyword">true</span>);</code></pre> 
  <p>函数<font color="#008B8B">SoftSetBoolArg()</font>的实现在<font color="#008B8B">util.cpp</font>中</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> SoftSetBoolArg(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strArg, <span class="hljs-keyword">bool</span> fValue)
{
    <span class="hljs-keyword">if</span> (fValue)
        <span class="hljs-keyword">return</span> SoftSetArg(strArg, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"1"</span>));
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> SoftSetArg(strArg, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"0"</span>));
}
<span class="hljs-keyword">bool</span> SoftSetArg(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strArg, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strValue)
{
    <span class="hljs-keyword">if</span> (mapArgs.count(strArg))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    mapArgs[strArg] = strValue;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>调用了<font color="#008B8B">SoftSetArg</font>函数,<font color="#008B8B">strArg</font>被赋值为<font color="#008B8B">server</font>,那么首先在<font color="#008B8B">mapArgs</font>(之前有介绍)中查找是否存在<font color="#008B8B">server</font>，如果存在就不做处理，否则按传入的值设置。</p> 
  <hr> 
  <h4 id="7初始化日志">7.初始化日志</h4> 
  <p>回到<font color="#008B8B">bitcoind.cpp</font>继续后面的代码</p> 
  <pre class="prettyprint"><code class=" hljs tex">//init.cpp
void InitLogging()
<span class="hljs-special">{</span>
    //-printtoconsole 日志信息发送到控制台，默认不发送到控制台
    fPrintToConsole = GetBoolArg("-printtoconsole", false);
    //-logtimestamps 在日志中打印时间戳，默认打印
    fLogTimestamps = GetBoolArg("-logtimestamps", DEFAULT_LOGTIMESTAMPS);
    //-logtimemicros 在日志中按微妙格式打印，默认不按
    fLogTimeMicros = GetBoolArg("-logtimemicros", DEFAULT_LOGTIMEMICROS);
    //-logips 在日志中打印ip，默认不包含
    fLogIPs = GetBoolArg("-logips", DEFAULT_LOGIPS);

    LogPrintf("<span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span><span class="hljs-command">\n</span>");
    LogPrintf("Bitcoin version <span class="hljs-comment">%s\n", FormatFullVersion());</span>
<span class="hljs-special">}</span></code></pre> 
  <p>其中三个默认参数</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//util.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_LOGTIMEMICROS = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//按微秒格式打印</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_LOGIPS        = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//包含ip地址</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> DEFAULT_LOGTIMESTAMPS = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//打印时间戳</span></code></pre> 
  <p>看一下日志打印内容 <br> <img src="https://img-blog.csdn.net/20180731151953489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <hr> 
  <h4 id="8initparameterinteraction">8.InitParameterInteraction</h4> 
  <p>初始化参数交互处理,设置后都会打印对应的语句 <br> 1）绑定并监听地址</p> 
  <pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-comment">//init.cpp</span>
<span class="hljs-comment">// Parameter interaction based on rules</span>
<span class="hljs-keyword">void</span> InitParameterInteraction()
{
    <span class="hljs-comment">// when specifying an explicit binding address, you want to listen on it</span>
    <span class="hljs-comment">// even when -connect or -proxy is specified</span>
    <span class="hljs-keyword">if</span> (mapArgs.<span class="hljs-keyword">count</span>(<span class="hljs-string">"-bind"</span>)) {
        <span class="hljs-keyword">if</span> (SoftSetBoolArg(<span class="hljs-string">"-listen"</span>, <span class="hljs-keyword">true</span>))
            LogPrintf(<span class="hljs-string">"%s: parameter interaction: -bind set -&gt; setting -listen=1\n"</span>, __func__);
    }
    <span class="hljs-keyword">if</span> (mapArgs.<span class="hljs-keyword">count</span>(<span class="hljs-string">"-whitebind"</span>)) {
        <span class="hljs-keyword">if</span> (SoftSetBoolArg(<span class="hljs-string">"-listen"</span>, <span class="hljs-keyword">true</span>))
            LogPrintf(<span class="hljs-string">"%s: parameter interaction: -whitebind set -&gt; setting -listen=1\n"</span>, __func__);
    }</code></pre> 
  <p>在指定显式绑定地址时，即使在指定-connect或-proxy时，也要监听它。绑定地址有两种参数，分别是<font color="#008B8B">bind</font>和<font color="#008B8B">whitebind</font>，从代码看对这两种参数的处理方式是相同的。 <br> 这里看一下<font color="#008B8B">LogPrintf</font>函数,通过调用<font color="#008B8B">LogPrint</font>实现</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//util.h</span>
<span class="hljs-javadoc">/** Return true if log accepts specified category */</span>
bool LogAcceptCategory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* category);
<span class="hljs-javadoc">/** Send a string to the log output */</span>
<span class="hljs-keyword">int</span> LogPrintStr(<span class="hljs-keyword">const</span> std::string &amp;str);
#define LogPrintf(...) LogPrint(NULL, __VA_ARGS__)

template&lt;typename T1, typename... Args&gt;
<span class="hljs-keyword">static</span> inline <span class="hljs-keyword">int</span> LogPrint(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* category, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fmt, <span class="hljs-keyword">const</span> T1&amp; v1, <span class="hljs-keyword">const</span> Args&amp;... args)
{
    <span class="hljs-keyword">if</span>(!LogAcceptCategory(category)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                            \
    <span class="hljs-keyword">return</span> LogPrintStr(tfm::format(fmt, v1, args...));
}</code></pre> 
  <p><font color="#008B8B">LogPrint</font>对日志是否接收制定目录做判断，然后调用的是<font color="#008B8B">LogPrintStr</font></p> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//util.cpp</span>
int LogPrintStr(const std<span class="hljs-tag">::string</span> <span class="hljs-subst">&amp;</span>str)
{
    int ret <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Returns total number of characters written</span>
    static bool fStartedNewLine <span class="hljs-subst">=</span> <span class="hljs-literal">true</span>;
    <span class="hljs-comment">//添加时间戳</span>
    <span class="hljs-built_in">string</span> strTimestamped <span class="hljs-subst">=</span> LogTimestampStr(str, <span class="hljs-subst">&amp;</span>fStartedNewLine);
    <span class="hljs-keyword">if</span> (fPrintToConsole)<span class="hljs-comment">//在7.初始化日志有设置</span>
    {<span class="hljs-comment">// print to console</span>
        ret <span class="hljs-subst">=</span> fwrite(strTimestamped<span class="hljs-built_in">.</span><span class="hljs-built_in">data</span>(), <span class="hljs-number">1</span>, strTimestamped<span class="hljs-built_in">.</span>size(), stdout);
        fflush(stdout);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fPrintToDebugLog)
    {
        boost<span class="hljs-tag">::call_once</span>(<span class="hljs-subst">&amp;</span>DebugPrintInit, debugPrintInitFlag);
        boost<span class="hljs-tag">::mutex</span><span class="hljs-tag">::scoped_lock</span> scoped_lock(<span class="hljs-subst">*</span>mutexDebugLog);

        <span class="hljs-comment">// buffer if we haven't opened the log yet</span>
        <span class="hljs-keyword">if</span> (fileout <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
            assert(vMsgsBeforeOpenLog);
            ret <span class="hljs-subst">=</span> strTimestamped<span class="hljs-built_in">.</span>length();
            vMsgsBeforeOpenLog<span class="hljs-subst">-&gt;</span>push_back(strTimestamped);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// reopen the log file, if requested</span>
            <span class="hljs-keyword">if</span> (fReopenDebugLog) {
                fReopenDebugLog <span class="hljs-subst">=</span> <span class="hljs-literal">false</span>;
                <span class="hljs-comment">//日志的默认地址对应路径下的debug.log</span>
                boost<span class="hljs-tag">::filesystem</span><span class="hljs-tag">::path</span> pathDebug <span class="hljs-subst">=</span> GetDataDir() <span class="hljs-subst">/</span> <span class="hljs-string">"debug.log"</span>;
                <span class="hljs-keyword">if</span> (freopen(pathDebug<span class="hljs-built_in">.</span><span class="hljs-built_in">string</span>()<span class="hljs-built_in">.</span>c_str(),<span class="hljs-string">"a"</span>,fileout) <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
                    setbuf(fileout, <span class="hljs-built_in">NULL</span>); <span class="hljs-comment">// unbuffered</span>
            }

            ret <span class="hljs-subst">=</span> FileWriteStr(strTimestamped, fileout);
        }
    }
    <span class="hljs-keyword">return</span> ret;
}</code></pre> 
  <p><font color="#008B8B">&amp;fStartedNewLine</font>是由调用上下文保存的状态变量，当不进行换行的多个调用时，将抑制时间戳的打印。将其初始化为true，并将其保存在调用上下文中。 <br> <font color="#008B8B">LogPrintStr</font>首先根据<font color="#008B8B">fStartedNewLine</font>调用<font color="#008B8B">LogTimestampStr</font>添加时间戳，其中根据<font color="#008B8B">fLogTimeMicros</font>决定是否添加微秒的时间。根据条件输出到对应的设备中。 <br> 2）连接可信节点 <br> 查找<font color="#008B8B">mapArgs</font>是否包含<font color="#008B8B">-connect</font>参数，包括则将<font color="#008B8B">-dnsseed</font>(使用dns查找)和<font color="#008B8B">-listen</font>(接受外部的连接，并对其进行监听)设置为false,并打印。 <br> 3）代理模式 <br> 查找<font color="#008B8B">mapArgs</font>参数中是否包含<font color="#008B8B">-proxy</font>参数，如果包含则将<font color="#008B8B">-listen、-upnp、-discover</font>都设置为false。 <br> 4）监听设置处理</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//net.h</span>
<span class="hljs-javadoc">/** -listen default */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> bool DEFAULT_LISTEN = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>如果<font color="#008B8B">-listen</font>参数不为<font color="#008B8B">DEFAULT_LISTEN</font>,即<font color="#008B8B">-listen</font>为false则<font color="#008B8B">-upnp、-discover（自动默认发现地址）、-listenonion（匿名地址监听）</font>都设置为false。 <br> 5）外部ip参数处理 <br> 查找<font color="#008B8B">mapArgs</font>参数中是否包含<font color="#008B8B">-externalip</font>参数，存在则将<font color="#008B8B">-discover</font>设置为false，即不用查找其他的ip。 <br> 6）重新扫描钱包参数设置 <br> 如果<font color="#008B8B">-salvagewallet</font>(尝试在启动时从毁坏的钱包恢复私钥)或<font color="#008B8B">-zapwallettxes</font>(删除所有钱包交易，只恢复部分)设置为true，则将<font color="#008B8B">-rescan</font>设置为true,重新扫描钱包。 <br> 7）区块模式参数设置</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//net.h</span>
<span class="hljs-javadoc">/** Default for blocks only*/</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> bool DEFAULT_BLOCKSONLY = <span class="hljs-keyword">false</span>;</code></pre> 
  <p>如果<font color="#008B8B">-blocksonly</font>设置为true,则将<font color="#008B8B">-whitelistrelay、-walletbroadcast</font>设置为false。 <br> 8）强制白名单连接参数</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** Default for DEFAULT_WHITELISTFORCERELAY. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> bool DEFAULT_WHITELISTFORCERELAY = <span class="hljs-keyword">true</span>;</code></pre> 
  <p>来自白名单主机的强制中继意味着我们将首先接受来自它们的中继。默认有白名单，将<font color="#008B8B">-whitelistrelay</font>设置为true。可以看前面的截图第二行就是对应的打印内容。</p> 
  <hr> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81326806" rel="nofollow">比特币源码学习（三）</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81205614,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81205614,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
