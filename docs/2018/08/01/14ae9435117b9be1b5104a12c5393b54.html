<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>hyperledger fabric手动部署及核心模块解读 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="hyperledger fabric手动部署及核心模块解读" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文基于fabric1.1环境，实现手动部署网络，并浅略的解读其核心模块。fabric1.1的部署流程可以参考博客：https://blog.csdn.net/leehom__/article/details/81022151&nbsp; &nbsp;中的一部分。 我们可以在 &nbsp;fabric-samples/first-network &nbsp;目录下面，直接运行 &nbsp;./byfn.sh -m up 来启动网络，所有的中间步骤都已经写在脚本中，运行网络成功后，即可以执行安装实例化链码。本文主要通过手动启动fabric1.1网络来理解每个步骤，及其核心模块的一些解读。 目录 1.生成公私钥和证书 2.生成创世块和通道配置事务 3.启动网络 4.创建和加入通道 5.更新锚节点 &nbsp; 正文 一、生成公私钥和证书 首先进入到 fabric-samples/first-network 目录下执行下列命令 ../bin/cryptogen generate --config=./crypto-config.yaml 会看到有下列返回 org1.example.com org2.example.com 模块解读： 启动fabric网络之前需要使用cryptogen工具 生成相应的密钥和证书，密钥和证书（即MSP材料）被生成在first-network目录下的crypto-config文件夹下。cryptogen工具主要依靠配置文件 cryto-config.yaml，在配置文件中描述了生成的证书密钥的一些属性，例如，有多少个节点，有多少个组织等。我们先以first-network目录下的cryto-config.yaml为例，截取了它关键部分，我们来进行解读。如下所示： OrdererOrgs: //定义orderer节点 - Name: Orderer //orderer节点的名称 Domain: example.com //orderer节点的根域名 Specs: - Hostname: orderer //orderer节点主机名 PeerOrgs: - Name: Org1 Domain: org1.example.com //组织1的名称 EnableNodeOUs: true //组织1的根域名 Template: Count: 2 //组织1中的节点数目，2代表我们要生成2套公私钥和证书 Users: Count: 1 //组织1中的用户数目，Admin不包括在计数中 - Name: Org2 Domain: org2.example.com EnableNodeOUs: true Template: Count: 2 Users: Count: 1 我们以org1.example.com文件目录下 tree 命令后显示的文件结构为例，解读一下各文件，如下 ├── ca //根节点的签名证书 │&nbsp;&nbsp; ├── ca.org1.example.com-cert.pem │&nbsp;&nbsp; └── f517871a77a63a3385b3fd47227286969c18f6a14ebe1810efe7a9717ba3b5c4_sk ├── msp │&nbsp;&nbsp; ├── admincerts //组织管理员证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts //组织的根证书（cacerts在官方文档中介绍也比较模糊，还没懂有什么用） │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; └── tlscacerts //TLS连接身份证书 │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem ├── peers │&nbsp;&nbsp; ├── peer0.org1.example.com │&nbsp;&nbsp; │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts //组织的管理证书，只有这些证书才能进行创建通道等操作 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts //组织根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore //当前节点私钥 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 237ade394bea083945e8d9dd6bd9eb60b0e5ba09e277622df424f5bc8c98b92b_sk │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts //当前节点签名的数字证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer0.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts //TLS连接的身份证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ca.crt //组织的根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; ├── server.crt //验证本节点签名的证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── server.key //当前节点的私钥文件用来签名的 │&nbsp;&nbsp; └── peer1.org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 0cb3ca5a6b4c30920b0792226a972ee9b50d8a1972c88ea67112a5498c842fe6_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer1.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── server.crt │&nbsp;&nbsp; └── server.key ├── tlsca │&nbsp;&nbsp; ├── a377e0984699f8d5922b308c81bd6267d907cec3aa5a9f95e1b90e3f31b63714_sk │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── users ├── Admin@org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 32c066ca255faf1ee3a2039b4f4a9dbd9f02c22ae8f658460bf85639c76d4e22_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── client.crt │&nbsp;&nbsp; └── client.key └── User1@org1.example.com ├── msp │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; └── 1b5688498e510a9d99099aa4adc18f0530c3d83e63df7b0717094356576ede19_sk │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── tls ├── ca.crt ├── client.crt └── client.key 二、生成创世块和通道配置事务 （1）生成创世块，使用configtxgen工具，依靠于configtx.yaml配置文件，在first-network目录下执行下列语句，将会生成orderer的创世区块，生成的orderer genesis block 将输出在channel-artifacts文件夹下。 # 使用configtxgen工具，我们需要将configtx,yaml文件的路径传递给它 # 所以我们将当前工作目录指定一下 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后将会在终端看到下面的输出： 2018-07-31 21:41:22.200 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration 2018-07-31 21:41:22.210 CST [msp] getMspConfig -&gt; INFO 002 Loading NodeOUs 2018-07-31 21:41:22.211 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 004 Generating genesis block 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 005 Writing genesis block （2）通道配置事务，包括创建通道配置文件和相关锚节点文件，同样在first-network目录下执行下列命令 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 到目前为止first-network目录下的 channel-artifacts文件夹下一句有了channel.tx 和 genesis.block两个配置文件。接着还要生成相关的锚点文件，执行下列命令。 # the anchor peer for Org1 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP # the anchor peer for Org2 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 解读：本节中所使用的configtxgen模块用来生成四个配置文件，orderer的genesis block, channel的配置文件channel.tx&nbsp;, &nbsp;以及锚节点配置文件Org1MSPanchors.tx和Org2MSPanchors.tx&nbsp;（每一个对应一个Peer组织）。configtxgen工具确实需要用到configtx.yaml这个配置文件（但似乎在执行命令中并没有指向到其路径）。在该配置文件中，可以设定Orderer的共识算法、共识区块大小、超时时间等，本文截取了配置文件中的一段来解读，如下。 //节点的配置信息 Orderer: &amp;OrdererDefaults OrdererType: solo //orderer节点共识方法 Addresses: - orderer.example.com:7050 //orderer监听地址 BatchTimeout: 2s //在创建批处理之前等待的时间 BatchSize: MaxMessageCount: 10 //批处理的最大消息数量 AbsoluteMaxBytes: 99 MB //批处理中序列化消息允许的绝对最大字节数。 PreferredMaxBytes: 512 KB //首选最大字节数(还不是很能理解是什么意思) 三、启动网络 （1）我们将整个Fabric Docker环境的配置放在docker-compose-cli.yaml后，只需要使用以下命令即可 docker-compose -f docker-compose-cli.yaml up -d 或者你可以顺便启动一下状态数据库CouchDB，只需要将couchDB配置文件加入到命令中即可，couchDB访问路径为： http://localhost:5984/_utils &nbsp; &nbsp; &nbsp; （可以吧localhost换成自己的ip地址） docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d （2）环境变量的设置，由于在docker-compose-cli.yaml中，已经对四个环境变量指向了peer0.org1，所以我们可以直接对peer0.org1进行操作，如果想要向其他peer或者orderer发送请求，则需要修改想要的环境变量。如下 # Environment variables for peer0.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer1.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer0.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt # Environment variables for peer1.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt 四、创建和加入通道 回想一下，我们在 “二、生成创世块和通道配置事务创建通道 ”章节中 中使用configtxgen工具创建了通道配置交易。我们可以重复这个过程，以创建额外的通道配置事务，在configtx.yaml中使用相同或不同的配置文件传给configtxgen工具。然后你可以重复这个定义的过程来建立你网络中的其他通道。 但本文只做最简单的创建和加入通道。 （1）首先进入到CLI容器，在配置文件中环境变量设置的是指向peer0.org1，执行下列命令 docker exec -it cli bash 如果成功，将会看到下面的样子： root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer# （2）接下来创建通道，我们将传入生成的channel configuration transaction artifact （也就是channel.tx，channel.tx包含了简单通道的一个定义） export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem （3）加入节点。如果想要其他节点加入通道，参考上面对其他节点环境变量的设置后，再执行下面语句。现在环境变量指向peer0.org1,所以我们加入peer0.org1直接执行下列语句 peer channel join -b mychannel.block &nbsp;五、更新锚节点 更新通道定义，以定义Org1的锚点，执行下列命令 peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 更新通道定义，以定义Org2的锚点，首先要更改一下环境变量，再执行更新锚点命令 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 到此，网络已启动成功，可以进行安装、实例化链码及调用链码。 本文会继续更新，解读核心模块和配置文件。 阅读更多" />
<meta property="og:description" content="本文基于fabric1.1环境，实现手动部署网络，并浅略的解读其核心模块。fabric1.1的部署流程可以参考博客：https://blog.csdn.net/leehom__/article/details/81022151&nbsp; &nbsp;中的一部分。 我们可以在 &nbsp;fabric-samples/first-network &nbsp;目录下面，直接运行 &nbsp;./byfn.sh -m up 来启动网络，所有的中间步骤都已经写在脚本中，运行网络成功后，即可以执行安装实例化链码。本文主要通过手动启动fabric1.1网络来理解每个步骤，及其核心模块的一些解读。 目录 1.生成公私钥和证书 2.生成创世块和通道配置事务 3.启动网络 4.创建和加入通道 5.更新锚节点 &nbsp; 正文 一、生成公私钥和证书 首先进入到 fabric-samples/first-network 目录下执行下列命令 ../bin/cryptogen generate --config=./crypto-config.yaml 会看到有下列返回 org1.example.com org2.example.com 模块解读： 启动fabric网络之前需要使用cryptogen工具 生成相应的密钥和证书，密钥和证书（即MSP材料）被生成在first-network目录下的crypto-config文件夹下。cryptogen工具主要依靠配置文件 cryto-config.yaml，在配置文件中描述了生成的证书密钥的一些属性，例如，有多少个节点，有多少个组织等。我们先以first-network目录下的cryto-config.yaml为例，截取了它关键部分，我们来进行解读。如下所示： OrdererOrgs: //定义orderer节点 - Name: Orderer //orderer节点的名称 Domain: example.com //orderer节点的根域名 Specs: - Hostname: orderer //orderer节点主机名 PeerOrgs: - Name: Org1 Domain: org1.example.com //组织1的名称 EnableNodeOUs: true //组织1的根域名 Template: Count: 2 //组织1中的节点数目，2代表我们要生成2套公私钥和证书 Users: Count: 1 //组织1中的用户数目，Admin不包括在计数中 - Name: Org2 Domain: org2.example.com EnableNodeOUs: true Template: Count: 2 Users: Count: 1 我们以org1.example.com文件目录下 tree 命令后显示的文件结构为例，解读一下各文件，如下 ├── ca //根节点的签名证书 │&nbsp;&nbsp; ├── ca.org1.example.com-cert.pem │&nbsp;&nbsp; └── f517871a77a63a3385b3fd47227286969c18f6a14ebe1810efe7a9717ba3b5c4_sk ├── msp │&nbsp;&nbsp; ├── admincerts //组织管理员证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts //组织的根证书（cacerts在官方文档中介绍也比较模糊，还没懂有什么用） │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; └── tlscacerts //TLS连接身份证书 │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem ├── peers │&nbsp;&nbsp; ├── peer0.org1.example.com │&nbsp;&nbsp; │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts //组织的管理证书，只有这些证书才能进行创建通道等操作 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts //组织根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore //当前节点私钥 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 237ade394bea083945e8d9dd6bd9eb60b0e5ba09e277622df424f5bc8c98b92b_sk │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts //当前节点签名的数字证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer0.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts //TLS连接的身份证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ca.crt //组织的根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; ├── server.crt //验证本节点签名的证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── server.key //当前节点的私钥文件用来签名的 │&nbsp;&nbsp; └── peer1.org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 0cb3ca5a6b4c30920b0792226a972ee9b50d8a1972c88ea67112a5498c842fe6_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer1.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── server.crt │&nbsp;&nbsp; └── server.key ├── tlsca │&nbsp;&nbsp; ├── a377e0984699f8d5922b308c81bd6267d907cec3aa5a9f95e1b90e3f31b63714_sk │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── users ├── Admin@org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 32c066ca255faf1ee3a2039b4f4a9dbd9f02c22ae8f658460bf85639c76d4e22_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── client.crt │&nbsp;&nbsp; └── client.key └── User1@org1.example.com ├── msp │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; └── 1b5688498e510a9d99099aa4adc18f0530c3d83e63df7b0717094356576ede19_sk │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── tls ├── ca.crt ├── client.crt └── client.key 二、生成创世块和通道配置事务 （1）生成创世块，使用configtxgen工具，依靠于configtx.yaml配置文件，在first-network目录下执行下列语句，将会生成orderer的创世区块，生成的orderer genesis block 将输出在channel-artifacts文件夹下。 # 使用configtxgen工具，我们需要将configtx,yaml文件的路径传递给它 # 所以我们将当前工作目录指定一下 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后将会在终端看到下面的输出： 2018-07-31 21:41:22.200 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration 2018-07-31 21:41:22.210 CST [msp] getMspConfig -&gt; INFO 002 Loading NodeOUs 2018-07-31 21:41:22.211 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 004 Generating genesis block 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 005 Writing genesis block （2）通道配置事务，包括创建通道配置文件和相关锚节点文件，同样在first-network目录下执行下列命令 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 到目前为止first-network目录下的 channel-artifacts文件夹下一句有了channel.tx 和 genesis.block两个配置文件。接着还要生成相关的锚点文件，执行下列命令。 # the anchor peer for Org1 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP # the anchor peer for Org2 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 解读：本节中所使用的configtxgen模块用来生成四个配置文件，orderer的genesis block, channel的配置文件channel.tx&nbsp;, &nbsp;以及锚节点配置文件Org1MSPanchors.tx和Org2MSPanchors.tx&nbsp;（每一个对应一个Peer组织）。configtxgen工具确实需要用到configtx.yaml这个配置文件（但似乎在执行命令中并没有指向到其路径）。在该配置文件中，可以设定Orderer的共识算法、共识区块大小、超时时间等，本文截取了配置文件中的一段来解读，如下。 //节点的配置信息 Orderer: &amp;OrdererDefaults OrdererType: solo //orderer节点共识方法 Addresses: - orderer.example.com:7050 //orderer监听地址 BatchTimeout: 2s //在创建批处理之前等待的时间 BatchSize: MaxMessageCount: 10 //批处理的最大消息数量 AbsoluteMaxBytes: 99 MB //批处理中序列化消息允许的绝对最大字节数。 PreferredMaxBytes: 512 KB //首选最大字节数(还不是很能理解是什么意思) 三、启动网络 （1）我们将整个Fabric Docker环境的配置放在docker-compose-cli.yaml后，只需要使用以下命令即可 docker-compose -f docker-compose-cli.yaml up -d 或者你可以顺便启动一下状态数据库CouchDB，只需要将couchDB配置文件加入到命令中即可，couchDB访问路径为： http://localhost:5984/_utils &nbsp; &nbsp; &nbsp; （可以吧localhost换成自己的ip地址） docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d （2）环境变量的设置，由于在docker-compose-cli.yaml中，已经对四个环境变量指向了peer0.org1，所以我们可以直接对peer0.org1进行操作，如果想要向其他peer或者orderer发送请求，则需要修改想要的环境变量。如下 # Environment variables for peer0.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer1.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer0.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt # Environment variables for peer1.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt 四、创建和加入通道 回想一下，我们在 “二、生成创世块和通道配置事务创建通道 ”章节中 中使用configtxgen工具创建了通道配置交易。我们可以重复这个过程，以创建额外的通道配置事务，在configtx.yaml中使用相同或不同的配置文件传给configtxgen工具。然后你可以重复这个定义的过程来建立你网络中的其他通道。 但本文只做最简单的创建和加入通道。 （1）首先进入到CLI容器，在配置文件中环境变量设置的是指向peer0.org1，执行下列命令 docker exec -it cli bash 如果成功，将会看到下面的样子： root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer# （2）接下来创建通道，我们将传入生成的channel configuration transaction artifact （也就是channel.tx，channel.tx包含了简单通道的一个定义） export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem （3）加入节点。如果想要其他节点加入通道，参考上面对其他节点环境变量的设置后，再执行下面语句。现在环境变量指向peer0.org1,所以我们加入peer0.org1直接执行下列语句 peer channel join -b mychannel.block &nbsp;五、更新锚节点 更新通道定义，以定义Org1的锚点，执行下列命令 peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 更新通道定义，以定义Org2的锚点，首先要更改一下环境变量，再执行更新锚点命令 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 到此，网络已启动成功，可以进行安装、实例化链码及调用链码。 本文会继续更新，解读核心模块和配置文件。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/01/14ae9435117b9be1b5104a12c5393b54.html" />
<meta property="og:url" content="https://mlh.app/2018/08/01/14ae9435117b9be1b5104a12c5393b54.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文基于fabric1.1环境，实现手动部署网络，并浅略的解读其核心模块。fabric1.1的部署流程可以参考博客：https://blog.csdn.net/leehom__/article/details/81022151&nbsp; &nbsp;中的一部分。 我们可以在 &nbsp;fabric-samples/first-network &nbsp;目录下面，直接运行 &nbsp;./byfn.sh -m up 来启动网络，所有的中间步骤都已经写在脚本中，运行网络成功后，即可以执行安装实例化链码。本文主要通过手动启动fabric1.1网络来理解每个步骤，及其核心模块的一些解读。 目录 1.生成公私钥和证书 2.生成创世块和通道配置事务 3.启动网络 4.创建和加入通道 5.更新锚节点 &nbsp; 正文 一、生成公私钥和证书 首先进入到 fabric-samples/first-network 目录下执行下列命令 ../bin/cryptogen generate --config=./crypto-config.yaml 会看到有下列返回 org1.example.com org2.example.com 模块解读： 启动fabric网络之前需要使用cryptogen工具 生成相应的密钥和证书，密钥和证书（即MSP材料）被生成在first-network目录下的crypto-config文件夹下。cryptogen工具主要依靠配置文件 cryto-config.yaml，在配置文件中描述了生成的证书密钥的一些属性，例如，有多少个节点，有多少个组织等。我们先以first-network目录下的cryto-config.yaml为例，截取了它关键部分，我们来进行解读。如下所示： OrdererOrgs: //定义orderer节点 - Name: Orderer //orderer节点的名称 Domain: example.com //orderer节点的根域名 Specs: - Hostname: orderer //orderer节点主机名 PeerOrgs: - Name: Org1 Domain: org1.example.com //组织1的名称 EnableNodeOUs: true //组织1的根域名 Template: Count: 2 //组织1中的节点数目，2代表我们要生成2套公私钥和证书 Users: Count: 1 //组织1中的用户数目，Admin不包括在计数中 - Name: Org2 Domain: org2.example.com EnableNodeOUs: true Template: Count: 2 Users: Count: 1 我们以org1.example.com文件目录下 tree 命令后显示的文件结构为例，解读一下各文件，如下 ├── ca //根节点的签名证书 │&nbsp;&nbsp; ├── ca.org1.example.com-cert.pem │&nbsp;&nbsp; └── f517871a77a63a3385b3fd47227286969c18f6a14ebe1810efe7a9717ba3b5c4_sk ├── msp │&nbsp;&nbsp; ├── admincerts //组织管理员证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts //组织的根证书（cacerts在官方文档中介绍也比较模糊，还没懂有什么用） │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; └── tlscacerts //TLS连接身份证书 │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem ├── peers │&nbsp;&nbsp; ├── peer0.org1.example.com │&nbsp;&nbsp; │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts //组织的管理证书，只有这些证书才能进行创建通道等操作 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts //组织根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore //当前节点私钥 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 237ade394bea083945e8d9dd6bd9eb60b0e5ba09e277622df424f5bc8c98b92b_sk │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts //当前节点签名的数字证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer0.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts //TLS连接的身份证书 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ca.crt //组织的根证书 │&nbsp;&nbsp; │&nbsp;&nbsp; ├── server.crt //验证本节点签名的证书 │&nbsp;&nbsp; │&nbsp;&nbsp; └── server.key //当前节点的私钥文件用来签名的 │&nbsp;&nbsp; └── peer1.org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 0cb3ca5a6b4c30920b0792226a972ee9b50d8a1972c88ea67112a5498c842fe6_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer1.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── server.crt │&nbsp;&nbsp; └── server.key ├── tlsca │&nbsp;&nbsp; ├── a377e0984699f8d5922b308c81bd6267d907cec3aa5a9f95e1b90e3f31b63714_sk │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── users ├── Admin@org1.example.com │&nbsp;&nbsp; ├── msp │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 32c066ca255faf1ee3a2039b4f4a9dbd9f02c22ae8f658460bf85639c76d4e22_sk │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem │&nbsp;&nbsp; └── tls │&nbsp;&nbsp; ├── ca.crt │&nbsp;&nbsp; ├── client.crt │&nbsp;&nbsp; └── client.key └── User1@org1.example.com ├── msp │&nbsp;&nbsp; ├── admincerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; ├── cacerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem │&nbsp;&nbsp; ├── keystore │&nbsp;&nbsp; │&nbsp;&nbsp; └── 1b5688498e510a9d99099aa4adc18f0530c3d83e63df7b0717094356576ede19_sk │&nbsp;&nbsp; ├── signcerts │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem │&nbsp;&nbsp; └── tlscacerts │&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem └── tls ├── ca.crt ├── client.crt └── client.key 二、生成创世块和通道配置事务 （1）生成创世块，使用configtxgen工具，依靠于configtx.yaml配置文件，在first-network目录下执行下列语句，将会生成orderer的创世区块，生成的orderer genesis block 将输出在channel-artifacts文件夹下。 # 使用configtxgen工具，我们需要将configtx,yaml文件的路径传递给它 # 所以我们将当前工作目录指定一下 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 执行后将会在终端看到下面的输出： 2018-07-31 21:41:22.200 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration 2018-07-31 21:41:22.210 CST [msp] getMspConfig -&gt; INFO 002 Loading NodeOUs 2018-07-31 21:41:22.211 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 004 Generating genesis block 2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 005 Writing genesis block （2）通道配置事务，包括创建通道配置文件和相关锚节点文件，同样在first-network目录下执行下列命令 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 到目前为止first-network目录下的 channel-artifacts文件夹下一句有了channel.tx 和 genesis.block两个配置文件。接着还要生成相关的锚点文件，执行下列命令。 # the anchor peer for Org1 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP # the anchor peer for Org2 on channel ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 解读：本节中所使用的configtxgen模块用来生成四个配置文件，orderer的genesis block, channel的配置文件channel.tx&nbsp;, &nbsp;以及锚节点配置文件Org1MSPanchors.tx和Org2MSPanchors.tx&nbsp;（每一个对应一个Peer组织）。configtxgen工具确实需要用到configtx.yaml这个配置文件（但似乎在执行命令中并没有指向到其路径）。在该配置文件中，可以设定Orderer的共识算法、共识区块大小、超时时间等，本文截取了配置文件中的一段来解读，如下。 //节点的配置信息 Orderer: &amp;OrdererDefaults OrdererType: solo //orderer节点共识方法 Addresses: - orderer.example.com:7050 //orderer监听地址 BatchTimeout: 2s //在创建批处理之前等待的时间 BatchSize: MaxMessageCount: 10 //批处理的最大消息数量 AbsoluteMaxBytes: 99 MB //批处理中序列化消息允许的绝对最大字节数。 PreferredMaxBytes: 512 KB //首选最大字节数(还不是很能理解是什么意思) 三、启动网络 （1）我们将整个Fabric Docker环境的配置放在docker-compose-cli.yaml后，只需要使用以下命令即可 docker-compose -f docker-compose-cli.yaml up -d 或者你可以顺便启动一下状态数据库CouchDB，只需要将couchDB配置文件加入到命令中即可，couchDB访问路径为： http://localhost:5984/_utils &nbsp; &nbsp; &nbsp; （可以吧localhost换成自己的ip地址） docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d （2）环境变量的设置，由于在docker-compose-cli.yaml中，已经对四个环境变量指向了peer0.org1，所以我们可以直接对peer0.org1进行操作，如果想要向其他peer或者orderer发送请求，则需要修改想要的环境变量。如下 # Environment variables for peer0.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer1.org1 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt # Environment variables for peer0.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt # Environment variables for peer1.org2 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer1.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt 四、创建和加入通道 回想一下，我们在 “二、生成创世块和通道配置事务创建通道 ”章节中 中使用configtxgen工具创建了通道配置交易。我们可以重复这个过程，以创建额外的通道配置事务，在configtx.yaml中使用相同或不同的配置文件传给configtxgen工具。然后你可以重复这个定义的过程来建立你网络中的其他通道。 但本文只做最简单的创建和加入通道。 （1）首先进入到CLI容器，在配置文件中环境变量设置的是指向peer0.org1，执行下列命令 docker exec -it cli bash 如果成功，将会看到下面的样子： root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer# （2）接下来创建通道，我们将传入生成的channel configuration transaction artifact （也就是channel.tx，channel.tx包含了简单通道的一个定义） export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem （3）加入节点。如果想要其他节点加入通道，参考上面对其他节点环境变量的设置后，再执行下面语句。现在环境变量指向peer0.org1,所以我们加入peer0.org1直接执行下列语句 peer channel join -b mychannel.block &nbsp;五、更新锚节点 更新通道定义，以定义Org1的锚点，执行下列命令 peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 更新通道定义，以定义Org2的锚点，首先要更改一下环境变量，再执行更新锚点命令 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 到此，网络已启动成功，可以进行安装、实例化链码及调用链码。 本文会继续更新，解读核心模块和配置文件。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/01/14ae9435117b9be1b5104a12c5393b54.html","headline":"hyperledger fabric手动部署及核心模块解读","dateModified":"2018-08-01T00:00:00+08:00","datePublished":"2018-08-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/01/14ae9435117b9be1b5104a12c5393b54.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>hyperledger fabric手动部署及核心模块解读</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>本文基于fabric1.1环境，实现手动部署网络，并浅略的解读其核心模块。fabric1.1的部署流程可以参考博客：<a href="https://blog.csdn.net/leehom__/article/details/81022151" rel="nofollow">https://blog.csdn.net/leehom__/article/details/81022151</a>&nbsp; &nbsp;中的一部分。</p> 
  <p>我们可以在 &nbsp;fabric-samples/first-network &nbsp;目录下面，直接运行 &nbsp;./byfn.sh -m up 来启动网络，所有的中间步骤都已经写在脚本中，运行网络成功后，即可以执行安装实例化链码。本文主要通过手动启动fabric1.1网络来理解每个步骤，及其核心模块的一些解读。</p> 
  <h2>目录</h2> 
  <p>1.生成公私钥和证书</p> 
  <p>2.生成创世块和通道配置事务</p> 
  <p>3.启动网络</p> 
  <p>4.创建和加入通道</p> 
  <p>5.更新锚节点</p> 
  <p>&nbsp;</p> 
  <h2>正文</h2> 
  <p>一、生成公私钥和证书</p> 
  <p>首先进入到 fabric-samples/first-network 目录下执行下列命令</p> 
  <pre class="has">
<code class="language-bash">../bin/cryptogen generate --config=./crypto-config.yaml
</code></pre> 
  <p>会看到有下列返回</p> 
  <pre class="has">
<code>org1.example.com
org2.example.com</code></pre> 
  <p>模块解读：</p> 
  <p>启动fabric网络之前需要使用cryptogen工具 生成相应的密钥和证书，密钥和证书（即MSP材料）被生成在first-network目录下的crypto-config文件夹下。cryptogen工具主要依靠配置文件 cryto-config.yaml，在配置文件中描述了生成的证书密钥的一些属性，例如，有多少个节点，有多少个组织等。我们先以first-network目录下的cryto-config.yaml为例，截取了它关键部分，我们来进行解读。如下所示：</p> 
  <pre class="has">
<code>OrdererOrgs:                          //定义orderer节点
  - Name: Orderer                     //orderer节点的名称
    Domain: example.com               //orderer节点的根域名
    Specs:
      - Hostname: orderer             //orderer节点主机名

PeerOrgs:
  - Name: Org1
    Domain: org1.example.com          //组织1的名称
    EnableNodeOUs: true               //组织1的根域名
    Template:
      Count: 2                        //组织1中的节点数目，2代表我们要生成2套公私钥和证书
    Users:
      Count: 1                        //组织1中的用户数目，Admin不包括在计数中
  - Name: Org2
    Domain: org2.example.com
    EnableNodeOUs: true
    Template:
      Count: 2
    Users:
      Count: 1
</code></pre> 
  <p>我们以org1.example.com文件目录下 tree 命令后显示的文件结构为例，解读一下各文件，如下</p> 
  <pre class="has">
<code>
├── ca               //根节点的签名证书
│&nbsp;&nbsp; ├── ca.org1.example.com-cert.pem
│&nbsp;&nbsp; └── f517871a77a63a3385b3fd47227286969c18f6a14ebe1810efe7a9717ba3b5c4_sk
├── msp
│&nbsp;&nbsp; ├── admincerts     //组织管理员证书
│&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem
│&nbsp;&nbsp; ├── cacerts        //组织的根证书（cacerts在官方文档中介绍也比较模糊，还没懂有什么用）
│&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem
│&nbsp;&nbsp; ├── config.yaml
│&nbsp;&nbsp; └── tlscacerts     //TLS连接身份证书
│&nbsp;&nbsp;     └── tlsca.org1.example.com-cert.pem
├── peers
│&nbsp;&nbsp; ├── peer0.org1.example.com
│&nbsp;&nbsp; │&nbsp;&nbsp; ├── msp
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts  //组织的管理证书，只有这些证书才能进行创建通道等操作
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts     //组织根证书
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── config.yaml
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore    //当前节点私钥
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 237ade394bea083945e8d9dd6bd9eb60b0e5ba09e277622df424f5bc8c98b92b_sk
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts   //当前节点签名的数字证书
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer0.org1.example.com-cert.pem
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts  //TLS连接的身份证书
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── tlsca.org1.example.com-cert.pem
│&nbsp;&nbsp; │&nbsp;&nbsp; └── tls
│&nbsp;&nbsp; │&nbsp;&nbsp;     ├── ca.crt      //组织的根证书
│&nbsp;&nbsp; │&nbsp;&nbsp;     ├── server.crt  //验证本节点签名的证书
│&nbsp;&nbsp; │&nbsp;&nbsp;     └── server.key  //当前节点的私钥文件用来签名的
│&nbsp;&nbsp; └── peer1.org1.example.com
│&nbsp;&nbsp;     ├── msp
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── admincerts
│&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── cacerts
│&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── config.yaml
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── keystore
│&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── 0cb3ca5a6b4c30920b0792226a972ee9b50d8a1972c88ea67112a5498c842fe6_sk
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── signcerts
│&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── peer1.org1.example.com-cert.pem
│&nbsp;&nbsp;     │&nbsp;&nbsp; └── tlscacerts
│&nbsp;&nbsp;     │&nbsp;&nbsp;     └── tlsca.org1.example.com-cert.pem
│&nbsp;&nbsp;     └── tls
│&nbsp;&nbsp;         ├── ca.crt
│&nbsp;&nbsp;         ├── server.crt
│&nbsp;&nbsp;         └── server.key
├── tlsca
│&nbsp;&nbsp; ├── a377e0984699f8d5922b308c81bd6267d907cec3aa5a9f95e1b90e3f31b63714_sk
│&nbsp;&nbsp; └── tlsca.org1.example.com-cert.pem
└── users
    ├── Admin@org1.example.com
    │&nbsp;&nbsp; ├── msp
    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── admincerts
    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem
    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── cacerts
    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem
    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── keystore
    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 32c066ca255faf1ee3a2039b4f4a9dbd9f02c22ae8f658460bf85639c76d4e22_sk
    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── signcerts
    │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Admin@org1.example.com-cert.pem
    │&nbsp;&nbsp; │&nbsp;&nbsp; └── tlscacerts
    │&nbsp;&nbsp; │&nbsp;&nbsp;     └── tlsca.org1.example.com-cert.pem
    │&nbsp;&nbsp; └── tls
    │&nbsp;&nbsp;     ├── ca.crt
    │&nbsp;&nbsp;     ├── client.crt
    │&nbsp;&nbsp;     └── client.key
    └── User1@org1.example.com
        ├── msp
        │&nbsp;&nbsp; ├── admincerts
        │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem
        │&nbsp;&nbsp; ├── cacerts
        │&nbsp;&nbsp; │&nbsp;&nbsp; └── ca.org1.example.com-cert.pem
        │&nbsp;&nbsp; ├── keystore
        │&nbsp;&nbsp; │&nbsp;&nbsp; └── 1b5688498e510a9d99099aa4adc18f0530c3d83e63df7b0717094356576ede19_sk
        │&nbsp;&nbsp; ├── signcerts
        │&nbsp;&nbsp; │&nbsp;&nbsp; └── User1@org1.example.com-cert.pem
        │&nbsp;&nbsp; └── tlscacerts
        │&nbsp;&nbsp;     └── tlsca.org1.example.com-cert.pem
        └── tls
            ├── ca.crt
            ├── client.crt
            └── client.key
</code></pre> 
  <p>二、生成创世块和通道配置事务</p> 
  <p>（1）生成创世块，使用configtxgen工具，依靠于configtx.yaml配置文件，在first-network目录下执行下列语句，将会生成orderer的创世区块，生成的orderer genesis block 将输出在channel-artifacts文件夹下。</p> 
  <pre class="has">
<code class="language-bash"># 使用configtxgen工具，我们需要将configtx,yaml文件的路径传递给它
# 所以我们将当前工作目录指定一下
export FABRIC_CFG_PATH=$PWD      
../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</code></pre> 
  <p>执行后将会在终端看到下面的输出：</p> 
  <pre class="has">
<code>2018-07-31 21:41:22.200 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration
2018-07-31 21:41:22.210 CST [msp] getMspConfig -&gt; INFO 002 Loading NodeOUs
2018-07-31 21:41:22.211 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs
2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 004 Generating genesis block
2018-07-31 21:41:22.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 005 Writing genesis block
</code></pre> 
  <p>（2）通道配置事务，包括创建通道配置文件和相关锚节点文件，同样在first-network目录下执行下列命令</p> 
  <pre class="has">
<code class="language-bash">export CHANNEL_NAME=mychannel
../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME</code></pre> 
  <p>到目前为止first-network目录下的 channel-artifacts文件夹下一句有了channel.tx 和 genesis.block两个配置文件。接着还要生成相关的锚点文件，执行下列命令。</p> 
  <pre class="has">
<code class="language-bash"># the anchor peer for Org1 on channel
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP    

# the anchor peer for Org2 on channel
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
</code></pre> 
  <p>解读：本节中所使用的configtxgen模块用来生成四个配置文件，orderer的<span style="color:#e74c3c;">genesis block</span>, channel的配置文件<span style="color:#e74c3c;">channel.tx&nbsp;</span>, &nbsp;以及锚节点配置文件<span style="color:#f33b45;">Org1MSPanchors.tx</span>和<span style="color:#f33b45;">Org2MSPanchors.tx</span><span style="color:#e74c3c;">&nbsp;</span>（每一个对应一个Peer组织）。configtxgen工具确实需要用到configtx.yaml这个配置文件（但似乎在执行命令中并没有指向到其路径）。在该配置文件中，可以设定Orderer的共识算法、共识区块大小、超时时间等，本文截取了配置文件中的一段来解读，如下。</p> 
  <pre class="has">
<code>//节点的配置信息
Orderer: &amp;OrdererDefaults
    OrdererType: solo                  //orderer节点共识方法
    Addresses:
        - orderer.example.com:7050     //orderer监听地址
    BatchTimeout: 2s                   //在创建批处理之前等待的时间
    BatchSize:
        MaxMessageCount: 10            //批处理的最大消息数量
        AbsoluteMaxBytes: 99 MB        //批处理中序列化消息允许的绝对最大字节数。
        PreferredMaxBytes: 512 KB      //首选最大字节数(还不是很能理解是什么意思)</code></pre> 
  <p>三、启动网络</p> 
  <p><span style="color:#2e3033;">（1）我们将整个</span><span style="color:#2e3033;">Fabric Docker</span><span style="color:#2e3033;">环境的配置放在</span><span style="color:#2e3033;">docker-compose-cli.yaml</span><span style="color:#2e3033;">后，只需要使用以下命令即可</span></p> 
  <pre class="has">
<code class="language-bash">docker-compose -f docker-compose-cli.yaml up -d
</code></pre> 
  <p>或者你可以顺便启动一下状态数据库CouchDB，只需要将couchDB配置文件加入到命令中即可，couchDB访问路径为：</p> 
  <ul>
   <li> <p><code>http://localhost:5984/_utils &nbsp; &nbsp; &nbsp; （可以吧localhost换成自己的ip地址）</code></p> </li> 
  </ul>
  <pre class="has">
<code class="language-bash">docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d
</code></pre> 
  <p>（2）环境变量的设置，由于在docker-compose-cli.yaml中，已经对四个环境变量指向了peer0.org1，所以我们可以直接对peer0.org1进行操作，如果想要向其他peer或者orderer发送请求，则需要修改想要的环境变量。如下</p> 
  <pre class="has">
<code class="language-bash"># Environment variables for peer0.org1

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID="Org1MSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

# Environment variables for peer1.org1
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 
CORE_PEER_ADDRESS=peer1.org1.example.com:7051
CORE_PEER_LOCALMSPID="Org1MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 

# Environment variables for peer0.org2
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:7051
CORE_PEER_LOCALMSPID="Org2MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

# Environment variables for peer1.org2
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer1.org2.example.com:7051
CORE_PEER_LOCALMSPID="Org2MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt 

</code></pre> 
  <p>四、创建和加入通道</p> 
  <p><span style="color:#2e3033;">回想一下，我们在 “二、</span>生成创世块和通道配置事务<span style="color:#2e3033;">创建通道 ”章节中 中使用</span><span style="color:#2e3033;">configtxgen</span><span style="color:#2e3033;">工具创建了通道配置交易。我们可以重复这个过程，以创建额外的通道配置事务，在</span><span style="color:#2e3033;">configtx.yaml</span><span style="color:#2e3033;">中使用相同或不同的配置文件传给</span><span style="color:#2e3033;">configtxgen</span><span style="color:#2e3033;">工具。然后你可以重复这个定义的过程来建立你网络中的其他通道。</span></p> 
  <p><span style="color:#2e3033;">但本文只做最简单的创建和加入通道。</span></p> 
  <p><span style="color:#2e3033;">（1）首先进入到CLI容器，在配置文件中环境变量设置的是指向peer0.org1，执行下列命令</span></p> 
  <pre class="has">
<code class="language-bash">docker exec -it cli bash</code></pre> 
  <p>如果成功，将会看到下面的样子：</p> 
  <pre class="has">
<code>root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer#
</code></pre> 
  <p>（2）<span style="color:#2e3033;">接下来<strong>创建通道</strong>，我们将传入生成的</span><span style="color:#2e3033;">channel configuration transaction artifact </span><span style="color:#2e3033;">（也就是</span><span style="color:#2e3033;">channel.tx</span><span style="color:#2e3033;">，</span><span style="color:#2e3033;">channel.tx</span><span style="color:#2e3033;">包含了简单通道的一个定义）</span></p> 
  <pre class="has">
<code class="language-bash">export CHANNEL_NAME=mychannel
</code></pre> 
  <pre class="has">
<code class="language-bash">peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</code></pre> 
  <p>（3）加入节点。如果想要其他节点加入通道，参考上面对其他节点环境变量的设置后，再执行下面语句。现在环境变量指向peer0.org1,所以我们加入peer0.org1直接执行下列语句</p> 
  <pre class="has">
<code class="language-bash">peer channel join -b mychannel.block</code></pre> 
  <p>&nbsp;五、更新锚节点</p> 
  <p>更新通道定义，以定义Org1的锚点，执行下列命令</p> 
  <pre class="has">
<code class="language-bash">peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</code></pre> 
  <p>更新通道定义，以定义Org2的锚点，首先要更改一下环境变量，再执行更新锚点命令</p> 
  <pre class="has">
<code class="language-bash">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</code></pre> 
  <p>到此，网络已启动成功，可以进行安装、实例化链码及调用链码。</p> 
  <p>本文会继续更新，解读核心模块和配置文件。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/leehom__/article/details/81317160,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/leehom__/article/details/81317160,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
