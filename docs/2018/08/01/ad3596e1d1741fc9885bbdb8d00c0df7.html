<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链100讲：通过一次交易旅程来理解Hyperledger Fabric节点 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链100讲：通过一次交易旅程来理解Hyperledger Fabric节点" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 Peer Nodes 节点 在任何区块链网络里面，节点都是构成整个网络必不可少的组成部分。在Hyperledger Fabric的网络里面，在节点上，我们可以实现和定制 chaincode，当然还有与之附随的 chaincode 的 Blockchain Ledger。 节点是 chaincode， Blockchain Ledger的载体。每个节点上都有一份 chaincode 的 Blockchain Ledger 的拷贝。 每个节点都可以被：创建, 开始, 停止, 重新设定, 删除。 一个节点上，可以有多个 chaincode 和 Blockchain Ledger， 而一个 Blockchain Ledger为多个chaincode提供服务。 每个节点上都有一个默认的 system chaincodes。 2 Multiple Ledgers and Chaincodes *多账本 多智能合约* 一个节点里面，有一个 chaincode 的 Blockchain Ledger 是很常见的。在Hyperledger Fabric的网络里面,一个节点上有多个 Blockchain Ledger，而基于每个 Blockchain Ledger，又有多个 chaincode，也是很常见的。而每个节点上都有一个默认的 system chaincodes。 3 Applications and Peers 应用与节点 what’s most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles. 一个外部应用，比如安卓上的一个应用，可以通过 Hyperledger Fabric Software Development Kit (SDK) 里面提供的 APIs 来连接节点，触发 chaincode，生成交易，通过 ordered（排队，排序） 之后，被广播到网络其他节点上。 从一个应用的角度： 通过API链接节点 尝试激活智能合约 收到节点的回复（在回复之前，节点会激活请求的智能合约，智能合约生产指令，更新回复） 把收到的回复，提交给排序节点（排序节点会做相关确认，然后把这次交易的信息排队到广播队列中） 收到节点以及更新的回复 从一个节点的角度： 是有能力在确认相关信息之后，独立执行智能合约的。因为所需要的信息在这个节点的本地都有备份。 虽然可以独立执行智能合约，但是不能独立的把执行结果广播出去。 4 一次交易的旅程 4.1 参与方 A ：收购萝卜 B ：出售萝卜 peerA：代表A peerB：代表B 4.2 假设 我们的联盟网络已经建成，而且参与方已经通过相关资格认证机构，注册，并且有相关材料证明其身份。 The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 包含了代表萝卜市场的一对key和value的智能合约已经在联盟网络里配置好了。 智能合约的逻辑里面，包含了交易的步骤以及一个萝卜的价格。并且在背书协议里面，包含了必须双方提出背书。 4.3 交易步骤 A想发出购买萝卜的请求。因为需要双方背书，所以A同应用，把这请求同时发给了，peerA和peerB。 SDK生成请求。这个请求可以执行一个智能合约，从而可以读写（比如加入一对新的代表萝卜市场的key和value）账本。 SDK将交易打包为正确的格式，并用用户的加密凭证为此交易提议生成唯一的签名。 背书节点，如果签名验证成功，就执行请求 主要验证： ・请求的格式是否正确 ・这个请求在之前已经被执行过 ・签名是否有效 ・请求提出者，在权限上是否符合此次请求的内容。 背书节点，执行请求，生成结果。此时账本还没有做任何的更新。和背书节点的签名一起，返回给请求者。 本文作者：HiBlock区块链技术布道群-AmyWu 原文发布于简书 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<meta property="og:description" content="1 Peer Nodes 节点 在任何区块链网络里面，节点都是构成整个网络必不可少的组成部分。在Hyperledger Fabric的网络里面，在节点上，我们可以实现和定制 chaincode，当然还有与之附随的 chaincode 的 Blockchain Ledger。 节点是 chaincode， Blockchain Ledger的载体。每个节点上都有一份 chaincode 的 Blockchain Ledger 的拷贝。 每个节点都可以被：创建, 开始, 停止, 重新设定, 删除。 一个节点上，可以有多个 chaincode 和 Blockchain Ledger， 而一个 Blockchain Ledger为多个chaincode提供服务。 每个节点上都有一个默认的 system chaincodes。 2 Multiple Ledgers and Chaincodes *多账本 多智能合约* 一个节点里面，有一个 chaincode 的 Blockchain Ledger 是很常见的。在Hyperledger Fabric的网络里面,一个节点上有多个 Blockchain Ledger，而基于每个 Blockchain Ledger，又有多个 chaincode，也是很常见的。而每个节点上都有一个默认的 system chaincodes。 3 Applications and Peers 应用与节点 what’s most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles. 一个外部应用，比如安卓上的一个应用，可以通过 Hyperledger Fabric Software Development Kit (SDK) 里面提供的 APIs 来连接节点，触发 chaincode，生成交易，通过 ordered（排队，排序） 之后，被广播到网络其他节点上。 从一个应用的角度： 通过API链接节点 尝试激活智能合约 收到节点的回复（在回复之前，节点会激活请求的智能合约，智能合约生产指令，更新回复） 把收到的回复，提交给排序节点（排序节点会做相关确认，然后把这次交易的信息排队到广播队列中） 收到节点以及更新的回复 从一个节点的角度： 是有能力在确认相关信息之后，独立执行智能合约的。因为所需要的信息在这个节点的本地都有备份。 虽然可以独立执行智能合约，但是不能独立的把执行结果广播出去。 4 一次交易的旅程 4.1 参与方 A ：收购萝卜 B ：出售萝卜 peerA：代表A peerB：代表B 4.2 假设 我们的联盟网络已经建成，而且参与方已经通过相关资格认证机构，注册，并且有相关材料证明其身份。 The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 包含了代表萝卜市场的一对key和value的智能合约已经在联盟网络里配置好了。 智能合约的逻辑里面，包含了交易的步骤以及一个萝卜的价格。并且在背书协议里面，包含了必须双方提出背书。 4.3 交易步骤 A想发出购买萝卜的请求。因为需要双方背书，所以A同应用，把这请求同时发给了，peerA和peerB。 SDK生成请求。这个请求可以执行一个智能合约，从而可以读写（比如加入一对新的代表萝卜市场的key和value）账本。 SDK将交易打包为正确的格式，并用用户的加密凭证为此交易提议生成唯一的签名。 背书节点，如果签名验证成功，就执行请求 主要验证： ・请求的格式是否正确 ・这个请求在之前已经被执行过 ・签名是否有效 ・请求提出者，在权限上是否符合此次请求的内容。 背书节点，执行请求，生成结果。此时账本还没有做任何的更新。和背书节点的签名一起，返回给请求者。 本文作者：HiBlock区块链技术布道群-AmyWu 原文发布于简书 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/01/ad3596e1d1741fc9885bbdb8d00c0df7.html" />
<meta property="og:url" content="https://mlh.app/2018/08/01/ad3596e1d1741fc9885bbdb8d00c0df7.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1 Peer Nodes 节点 在任何区块链网络里面，节点都是构成整个网络必不可少的组成部分。在Hyperledger Fabric的网络里面，在节点上，我们可以实现和定制 chaincode，当然还有与之附随的 chaincode 的 Blockchain Ledger。 节点是 chaincode， Blockchain Ledger的载体。每个节点上都有一份 chaincode 的 Blockchain Ledger 的拷贝。 每个节点都可以被：创建, 开始, 停止, 重新设定, 删除。 一个节点上，可以有多个 chaincode 和 Blockchain Ledger， 而一个 Blockchain Ledger为多个chaincode提供服务。 每个节点上都有一个默认的 system chaincodes。 2 Multiple Ledgers and Chaincodes *多账本 多智能合约* 一个节点里面，有一个 chaincode 的 Blockchain Ledger 是很常见的。在Hyperledger Fabric的网络里面,一个节点上有多个 Blockchain Ledger，而基于每个 Blockchain Ledger，又有多个 chaincode，也是很常见的。而每个节点上都有一个默认的 system chaincodes。 3 Applications and Peers 应用与节点 what’s most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles. 一个外部应用，比如安卓上的一个应用，可以通过 Hyperledger Fabric Software Development Kit (SDK) 里面提供的 APIs 来连接节点，触发 chaincode，生成交易，通过 ordered（排队，排序） 之后，被广播到网络其他节点上。 从一个应用的角度： 通过API链接节点 尝试激活智能合约 收到节点的回复（在回复之前，节点会激活请求的智能合约，智能合约生产指令，更新回复） 把收到的回复，提交给排序节点（排序节点会做相关确认，然后把这次交易的信息排队到广播队列中） 收到节点以及更新的回复 从一个节点的角度： 是有能力在确认相关信息之后，独立执行智能合约的。因为所需要的信息在这个节点的本地都有备份。 虽然可以独立执行智能合约，但是不能独立的把执行结果广播出去。 4 一次交易的旅程 4.1 参与方 A ：收购萝卜 B ：出售萝卜 peerA：代表A peerB：代表B 4.2 假设 我们的联盟网络已经建成，而且参与方已经通过相关资格认证机构，注册，并且有相关材料证明其身份。 The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 包含了代表萝卜市场的一对key和value的智能合约已经在联盟网络里配置好了。 智能合约的逻辑里面，包含了交易的步骤以及一个萝卜的价格。并且在背书协议里面，包含了必须双方提出背书。 4.3 交易步骤 A想发出购买萝卜的请求。因为需要双方背书，所以A同应用，把这请求同时发给了，peerA和peerB。 SDK生成请求。这个请求可以执行一个智能合约，从而可以读写（比如加入一对新的代表萝卜市场的key和value）账本。 SDK将交易打包为正确的格式，并用用户的加密凭证为此交易提议生成唯一的签名。 背书节点，如果签名验证成功，就执行请求 主要验证： ・请求的格式是否正确 ・这个请求在之前已经被执行过 ・签名是否有效 ・请求提出者，在权限上是否符合此次请求的内容。 背书节点，执行请求，生成结果。此时账本还没有做任何的更新。和背书节点的签名一起，返回给请求者。 本文作者：HiBlock区块链技术布道群-AmyWu 原文发布于简书 加微信baobaotalk_com，加入技术布道群 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/01/ad3596e1d1741fc9885bbdb8d00c0df7.html","headline":"区块链100讲：通过一次交易旅程来理解Hyperledger Fabric节点","dateModified":"2018-08-01T00:00:00+08:00","datePublished":"2018-08-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/01/ad3596e1d1741fc9885bbdb8d00c0df7.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链100讲：通过一次交易旅程来理解Hyperledger Fabric节点</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-75ca3764b4c16769?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <h1 id="1">1</h1> 
  <h1 id="peer-nodes-节点"><strong>Peer Nodes 节点</strong></h1> 
  <p>在任何区块链网络里面，节点都是构成整个网络必不可少的组成部分。在Hyperledger Fabric的网络里面，在节点上，我们可以实现和定制 chaincode，当然还有与之附随的 chaincode 的 Blockchain Ledger。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-e0e6b3438b323cb6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <ul> 
   <li><p>节点是 chaincode， Blockchain Ledger的载体。每个节点上都有一份 chaincode 的 Blockchain Ledger 的拷贝。</p></li> 
   <li><p>每个节点都可以被：创建, 开始, 停止, 重新设定, 删除。</p></li> 
   <li><p>一个节点上，可以有多个 chaincode 和 Blockchain Ledger， 而一个 Blockchain Ledger为多个chaincode提供服务。</p></li> 
   <li><p>每个节点上都有一个默认的 system chaincodes。</p></li> 
  </ul> 
  <h1 id="2">2</h1> 
  <h1 id="multiple-ledgers-and-chaincodes-多账本-多智能合约"><strong>Multiple Ledgers and Chaincodes <em>*</em></strong>多账本 多智能合约*</h1> 
  <p>一个节点里面，有一个 chaincode 的 Blockchain Ledger 是很常见的。在Hyperledger Fabric的网络里面,一个节点上有多个 Blockchain Ledger，而基于每个 Blockchain Ledger，又有多个 chaincode，也是很常见的。而每个节点上都有一个默认的 system chaincodes。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-e4b931cfd1b549a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <h1 id="3">3</h1> 
  <h1 id="applications-and-peers-应用与节点"><strong>Applications and Peers 应用与节点</strong></h1> 
  <p>what’s most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles.</p> 
  <p>一个外部应用，比如安卓上的一个应用，可以通过 Hyperledger Fabric Software Development Kit (SDK) 里面提供的 APIs 来连接节点，触发 chaincode，生成交易，通过 ordered（排队，排序） 之后，被广播到网络其他节点上。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-b431beda80e51547?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>从一个应用的角度：</strong></p> 
  <ul> 
   <li><p>通过API链接节点</p></li> 
   <li><p>尝试激活智能合约</p></li> 
   <li><p>收到节点的回复（在回复之前，节点会激活请求的智能合约，智能合约生产指令，更新回复）</p></li> 
   <li><p>把收到的回复，提交给排序节点（排序节点会做相关确认，然后把这次交易的信息排队到广播队列中）</p></li> 
   <li><p>收到节点以及更新的回复</p></li> 
  </ul> 
  <p><strong>从一个节点的角度：</strong></p> 
  <ul> 
   <li><p>是有能力在确认相关信息之后，独立执行智能合约的。因为所需要的信息在这个节点的本地都有备份。</p></li> 
   <li><p>虽然可以独立执行智能合约，但是不能独立的把执行结果广播出去。</p></li> 
  </ul> 
  <h1 id="4">4</h1> 
  <h1 id="一次交易的旅程"><strong>一次交易的旅程</strong></h1> 
  <p><strong>4.1 参与方</strong></p> 
  <ul> 
   <li><p>A ：收购萝卜</p></li> 
   <li><p>B ：出售萝卜</p></li> 
   <li><p>peerA：代表A</p></li> 
   <li><p>peerB：代表B</p></li> 
  </ul> 
  <p><strong>4.2 假设</strong></p> 
  <ul> 
   <li>我们的联盟网络已经建成，而且参与方已经通过相关资格认证机构，注册，并且有相关材料证明其身份。</li> 
  </ul> 
  <blockquote> 
   <p>The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network.</p> 
  </blockquote> 
  <ul> 
   <li><p>包含了代表萝卜市场的一对key和value的智能合约已经在联盟网络里配置好了。</p></li> 
   <li><p>智能合约的逻辑里面，包含了交易的步骤以及一个萝卜的价格。并且在背书协议里面，包含了必须双方提出背书。</p></li> 
  </ul> 
  <p><strong>4.3 交易步骤</strong></p> 
  <ul> 
   <li><p>A想发出购买萝卜的请求。因为需要双方背书，所以A同应用，把这请求同时发给了，peerA和peerB。</p></li> 
   <li><p>SDK生成请求。这个请求可以执行一个智能合约，从而可以读写（比如加入一对新的代表萝卜市场的key和value）账本。</p></li> 
   <li><p>SDK将交易打包为正确的格式，并用用户的加密凭证为此交易提议生成唯一的签名。</p></li> 
   <li><p>背书节点，如果签名验证成功，就执行请求</p></li> 
  </ul> 
  <p>主要验证： <br> ・请求的格式是否正确 <br> ・这个请求在之前已经被执行过 <br> ・签名是否有效 <br> ・请求提出者，在权限上是否符合此次请求的内容。</p> 
  <ul> 
   <li>背书节点，执行请求，生成结果。此时账本还没有做任何的更新。和背书节点的签名一起，返回给请求者。</li> 
  </ul> 
  <blockquote> 
   <p>本文作者：HiBlock区块链技术布道群-<strong>AmyWu</strong></p> 
   <p>原文发布于简书</p> 
   <p>加微信baobaotalk_com，加入技术布道群</p> 
  </blockquote> 
  <p>以下是我们的社区介绍，欢迎各种合作、交流、学习：）</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-ad5f3de937eacf72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/81329175,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/81329175,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
