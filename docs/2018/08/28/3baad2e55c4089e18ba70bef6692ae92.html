<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码-一个交易的产生（一）–生成地址 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码-一个交易的产生（一）–生成地址" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 0.生成比特币地址 1.getnewaddress 1.2 GetKeyFromPool 1.2.1GenerateNewKey 2.base58编码 3.发送金额 3.1GetBalance() 3.1.1IsTrusted() 3.1.2GetAvailableCredit 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易。 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 0.生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 1.getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool();//充值密钥池到上限 // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;);//写入数据库，目的为“receive&quot; //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 1.2 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex);//擦除密钥 result = keypool.vchPubKey; } return true; } 这是我调用bitcoin-cli getnewaddress的日志信息，密钥池的大小是101把密钥，这次调用补上第108把密钥，本次使用第8把密钥，前7把都已经从密钥池中移除了 2018-09-26 07:12:29 keypool added key 108, size=101 2018-09-26 07:12:29 keypool reserve 8 2018-09-26 07:12:29 keypool keep 8 1.2.1GenerateNewKey CKey这个类的结构最好了解一下 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start 这个是表示使用确定性分层钱包 CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包需要了解一下 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 2.base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 这些可以在chainparams.cpp的对应参数类中找到，如下为测试网 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; //将psz解码并且验证正确后的内容存放在vchTemp,此时的vchTemp包含版本前缀和编码前的内容 bool rc58 = DecodeBase58Check(psz, vchTemp); if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) {//如果解码验证失败，清空成员变量vchData,vchVersion vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);//获取版本信息，就是版本前缀 vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size());//编码前的数据如比特币地址，脚本地址存入vchData中 memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这一段的逻辑就是解码验证，获取Version和Payload的过程 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch);//对版本前缀和内容的组合编码 } 借用精通比特币的图，编码过程如下，可以理解为vch=version+payload,在上一代码中vch=vchVersion+vchData. 那么顺便来看一下EncodeBase58Check这个函数 std::string EncodeBase58Check(const std::vector&lt;unsigned char&gt;&amp; vchIn) { // add 4-byte hash check to the end std::vector&lt;unsigned char&gt; vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char*)&amp;hash, (unsigned char*)&amp;hash + 4); return EncodeBase58(vch); } 这段很简单就是在后面加上4位的校验码，校验码就是对vch做两次sha256取前4位。然后调用EncodeBase58进行编码。 3.发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） A txout script template with a specific destination. It is either: CNoDestination: no destination set CKeyID: TX_PUBKEYHASH destination CScriptID: TX_SCRIPTHASH destination A CTxDestination is the internal data type encoded in a CBitcoinAddress typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } 3.1GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } 3.1.1IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); 3.1.2GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 0.生成比特币地址 1.getnewaddress 1.2 GetKeyFromPool 1.2.1GenerateNewKey 2.base58编码 3.发送金额 3.1GetBalance() 3.1.1IsTrusted() 3.1.2GetAvailableCredit 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易。 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 0.生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 1.getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool();//充值密钥池到上限 // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;);//写入数据库，目的为“receive&quot; //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 1.2 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex);//擦除密钥 result = keypool.vchPubKey; } return true; } 这是我调用bitcoin-cli getnewaddress的日志信息，密钥池的大小是101把密钥，这次调用补上第108把密钥，本次使用第8把密钥，前7把都已经从密钥池中移除了 2018-09-26 07:12:29 keypool added key 108, size=101 2018-09-26 07:12:29 keypool reserve 8 2018-09-26 07:12:29 keypool keep 8 1.2.1GenerateNewKey CKey这个类的结构最好了解一下 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start 这个是表示使用确定性分层钱包 CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包需要了解一下 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 2.base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 这些可以在chainparams.cpp的对应参数类中找到，如下为测试网 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; //将psz解码并且验证正确后的内容存放在vchTemp,此时的vchTemp包含版本前缀和编码前的内容 bool rc58 = DecodeBase58Check(psz, vchTemp); if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) {//如果解码验证失败，清空成员变量vchData,vchVersion vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);//获取版本信息，就是版本前缀 vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size());//编码前的数据如比特币地址，脚本地址存入vchData中 memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这一段的逻辑就是解码验证，获取Version和Payload的过程 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch);//对版本前缀和内容的组合编码 } 借用精通比特币的图，编码过程如下，可以理解为vch=version+payload,在上一代码中vch=vchVersion+vchData. 那么顺便来看一下EncodeBase58Check这个函数 std::string EncodeBase58Check(const std::vector&lt;unsigned char&gt;&amp; vchIn) { // add 4-byte hash check to the end std::vector&lt;unsigned char&gt; vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char*)&amp;hash, (unsigned char*)&amp;hash + 4); return EncodeBase58(vch); } 这段很简单就是在后面加上4位的校验码，校验码就是对vch做两次sha256取前4位。然后调用EncodeBase58进行编码。 3.发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） A txout script template with a specific destination. It is either: CNoDestination: no destination set CKeyID: TX_PUBKEYHASH destination CScriptID: TX_SCRIPTHASH destination A CTxDestination is the internal data type encoded in a CBitcoinAddress typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } 3.1GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } 3.1.1IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); 3.1.2GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 交易的产生（一）–生成地址 交易的产生（二）–创建交易 交易的产生（三）–提交交易 交易的产生（四）–脚本和签名 目录 0.生成比特币地址 1.getnewaddress 1.2 GetKeyFromPool 1.2.1GenerateNewKey 2.base58编码 3.发送金额 3.1GetBalance() 3.1.1IsTrusted() 3.1.2GetAvailableCredit 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易。 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 0.生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 1.getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \\&quot;account\\&quot; )\\n&quot; &quot;\\nReturns a new Bitcoin address for receiving payments.\\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \\n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\\n&quot; &quot;\\nArguments:\\n&quot; &quot;1. \\&quot;account\\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\&quot;\\&quot; is used. It can also be set to the empty string \\&quot;\\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n&quot; &quot;\\nResult:\\n&quot; &quot;\\&quot;bitcoinaddress\\&quot; (string) The new bitcoin address\\n&quot; &quot;\\nExamples:\\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool();//充值密钥池到上限 // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;);//写入数据库，目的为“receive&quot; //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 1.2 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex);//擦除密钥 result = keypool.vchPubKey; } return true; } 这是我调用bitcoin-cli getnewaddress的日志信息，密钥池的大小是101把密钥，这次调用补上第108把密钥，本次使用第8把密钥，前7把都已经从密钥池中移除了 2018-09-26 07:12:29 keypool added key 108, size=101 2018-09-26 07:12:29 keypool reserve 8 2018-09-26 07:12:29 keypool keep 8 1.2.1GenerateNewKey CKey这个类的结构最好了解一下 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start 这个是表示使用确定性分层钱包 CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包需要了解一下 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 2.base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 这些可以在chainparams.cpp的对应参数类中找到，如下为测试网 base58Prefixes[PUBKEY_ADDRESS] = std::vector&lt;unsigned char&gt;(1,111); base58Prefixes[SCRIPT_ADDRESS] = std::vector&lt;unsigned char&gt;(1,196); 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; //将psz解码并且验证正确后的内容存放在vchTemp,此时的vchTemp包含版本前缀和编码前的内容 bool rc58 = DecodeBase58Check(psz, vchTemp); if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) {//如果解码验证失败，清空成员变量vchData,vchVersion vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);//获取版本信息，就是版本前缀 vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size());//编码前的数据如比特币地址，脚本地址存入vchData中 memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这一段的逻辑就是解码验证，获取Version和Payload的过程 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch);//对版本前缀和内容的组合编码 } 借用精通比特币的图，编码过程如下，可以理解为vch=version+payload,在上一代码中vch=vchVersion+vchData. 那么顺便来看一下EncodeBase58Check这个函数 std::string EncodeBase58Check(const std::vector&lt;unsigned char&gt;&amp; vchIn) { // add 4-byte hash check to the end std::vector&lt;unsigned char&gt; vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char*)&amp;hash, (unsigned char*)&amp;hash + 4); return EncodeBase58(vch); } 这段很简单就是在后面加上4位的校验码，校验码就是对vch做两次sha256取前4位。然后调用EncodeBase58进行编码。 3.发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） A txout script template with a specific destination. It is either: CNoDestination: no destination set CKeyID: TX_PUBKEYHASH destination CScriptID: TX_SCRIPTHASH destination A CTxDestination is the internal data type encoded in a CBitcoinAddress typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } 3.1GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } 3.1.1IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); 3.1.2GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多","@type":"BlogPosting","url":"/2018/08/28/3baad2e55c4089e18ba70bef6692ae92.html","headline":"比特币源码-一个交易的产生（一）–生成地址","dateModified":"2018-08-28T00:00:00+08:00","datePublished":"2018-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/28/3baad2e55c4089e18ba70bef6692ae92.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码-一个交易的产生（一）--生成地址</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81906838" rel="nofollow">交易的产生（一）–生成地址</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">交易的产生（二）–创建交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82351978" rel="nofollow">交易的产生（三）–提交交易</a><br> <a href="https://blog.csdn.net/m0_37847176/article/details/82866757" rel="nofollow">交易的产生（四）–脚本和签名</a></p> 
  <hr> 
  <p></p>
  <div class="toc">
   <h3>目录</h3>
   <ul>
    <ul>
     <li><a href="#0_11" rel="nofollow">0.生成比特币地址</a></li>
     <li><a href="#1getnewaddress_18" rel="nofollow">1.getnewaddress</a></li>
     <li><a href="#12_GetKeyFromPool_66" rel="nofollow">1.2 GetKeyFromPool</a></li>
     <ul>
      <li><a href="#121GenerateNewKey_97" rel="nofollow">1.2.1GenerateNewKey</a></li>
     </ul>
     <li><a href="#2base58_287" rel="nofollow">2.base58编码</a></li>
     <li><a href="#3_379" rel="nofollow">3.发送金额</a></li>
     <ul>
      <li><a href="#31GetBalance_424" rel="nofollow">3.1GetBalance()</a></li>
      <ul>
       <li><a href="#311IsTrusted_443" rel="nofollow">3.1.1IsTrusted()</a></li>
       <li><a href="#312GetAvailableCredit_486" rel="nofollow">3.1.2GetAvailableCredit</a></li>
      </ul>
     </ul>
    </ul>
   </ul>
  </div>
  <p></p> 
  <hr> 
  <p>在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易。<br> 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。</p> 
  <h2><a id="0_11"></a>0.生成比特币地址</h2> 
  <p>从钱包的rpc指令getnewaddress开始看，先来看下调用结果<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821144451891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址<br> 然后在日志信息中会增加相应的记录<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821151439657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 下面来看这个指定对应调用的函数</p> 
  <h2><a id="1getnewaddress_18"></a>1.getnewaddress</h2> 
  <p>位于/src/rpc/wallet/rpcwallet.cpp</p> 
  <pre class=" language-c"><code class="prism  language-c">UniValue <span class="token function">getnewaddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> UniValue<span class="token operator">&amp;</span> params<span class="token punctuation">,</span> bool fHelp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">EnsureWalletIsAvailable</span><span class="token punctuation">(</span>fHelp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> NullUniValue<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>fHelp <span class="token operator">||</span> params<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        throw <span class="token function">runtime_error</span><span class="token punctuation">(</span>
            <span class="token string">"getnewaddress ( \"account\" )\n"</span>
            <span class="token string">"\nReturns a new Bitcoin address for receiving payments.\n"</span>
            <span class="token string">"If 'account' is specified (DEPRECATED), it is added to the address book \n"</span>
            <span class="token string">"so payments received with the address will be credited to 'account'.\n"</span>
            <span class="token string">"\nArguments:\n"</span>
            <span class="token string">"1. \"account\" (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \"\" is used. It can also be set to the empty string \"\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n"</span>
            <span class="token string">"\nResult:\n"</span>
            <span class="token string">"\"bitcoinaddress\" (string) The new bitcoin address\n"</span>
            <span class="token string">"\nExamples:\n"</span>
            <span class="token operator">+</span> <span class="token function">HelpExampleCli</span><span class="token punctuation">(</span><span class="token string">"getnewaddress"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
            <span class="token operator">+</span> <span class="token function">HelpExampleRpc</span><span class="token punctuation">(</span><span class="token string">"getnewaddress"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">LOCK2</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">,</span> pwalletMain<span class="token operator">-&gt;</span>cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Parse the account first so we don't generate a key if there's an error</span>
    string strAccount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        strAccount <span class="token operator">=</span> <span class="token function">AccountFromValue</span><span class="token punctuation">(</span>params<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pwalletMain<span class="token operator">-&gt;</span><span class="token function">IsLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        pwalletMain<span class="token operator">-&gt;</span><span class="token function">TopUpKeyPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//充值密钥池到上限</span>

    <span class="token comment">// Generate a new key that is added to wallet</span>
    CPubKey newKey<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pwalletMain<span class="token operator">-&gt;</span><span class="token function">GetKeyFromPool</span><span class="token punctuation">(</span>newKey<span class="token punctuation">)</span><span class="token punctuation">)</span>
        throw <span class="token function">JSONRPCError</span><span class="token punctuation">(</span>RPC_WALLET_KEYPOOL_RAN_OUT<span class="token punctuation">,</span> <span class="token string">"Error: Keypool ran out, please call keypoolrefill first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CKeyID keyID <span class="token operator">=</span> newKey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取的是hash160的值</span>
<span class="token comment">//pwalletMain是CWllat类的指针</span>
    pwalletMain<span class="token operator">-&gt;</span><span class="token function">SetAddressBook</span><span class="token punctuation">(</span>keyID<span class="token punctuation">,</span> strAccount<span class="token punctuation">,</span> <span class="token string">"receive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写入数据库，目的为“receive"</span>
<span class="token comment">//CBitcoinAddress函数调用Base58编码转换</span>
    <span class="token keyword">return</span> <span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span>keyID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。</p> 
  <hr> 
  <h2><a id="12_GetKeyFromPool_66"></a>1.2 GetKeyFromPool</h2> 
  <p>在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//src/wallet/wallet.cpp</span>
bool CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetKeyFromPool</span><span class="token punctuation">(</span>CPubKey<span class="token operator">&amp;</span> result<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    int64_t nIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    CKeyPool keypool<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">ReserveKeyFromKeyPool</span><span class="token punctuation">(</span>nIndex<span class="token punctuation">,</span> keypool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nIndex <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>
            result <span class="token operator">=</span> <span class="token function">GenerateNewKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">KeepKey</span><span class="token punctuation">(</span>nIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//擦除密钥</span>
        result <span class="token operator">=</span> keypool<span class="token punctuation">.</span>vchPubKey<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这是我调用bitcoin-cli getnewaddress的日志信息，密钥池的大小是101把密钥，这次调用补上第108把密钥，本次使用第8把密钥，前7把都已经从密钥池中移除了</p> 
  <pre><code>2018-09-26 07:12:29 keypool added key 108, size=101
2018-09-26 07:12:29 keypool reserve 8
2018-09-26 07:12:29 keypool keep 8
</code></pre> 
  <hr> 
  <h3><a id="121GenerateNewKey_97"></a>1.2.1GenerateNewKey</h3> 
  <p><a href="https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck" rel="nofollow">CKey</a>这个类的结构最好了解一下</p> 
  <blockquote> 
   <p><mark>-usehd</mark>:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start<br> 这个是表示使用确定性分层钱包</p> 
  </blockquote> 
  <pre class=" language-c"><code class="prism  language-c">CPubKey CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GenerateNewKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">AssertLockHeld</span><span class="token punctuation">(</span>cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mapKeyMetadata</span>
    bool fCompressed <span class="token operator">=</span> <span class="token function">CanSupportFeature</span><span class="token punctuation">(</span>FEATURE_COMPRPUBKEY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// default to compressed public keys if we want 0.6.0 wallets</span>
    <span class="token comment">// CKey是私钥的类</span>
    CKey secret<span class="token punctuation">;</span>

    <span class="token comment">// Create new metadata</span>
    int64_t nCreationTime <span class="token operator">=</span> <span class="token function">GetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CKeyMetadata <span class="token function">metadata</span><span class="token punctuation">(</span>nCreationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// use HD key derivation if HD was enabled during wallet creation </span>
    <span class="token comment">//1.如果在钱包创建时使用确定分层钱包，则使用HD密钥</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hdChain<span class="token punctuation">.</span>masterKeyID<span class="token punctuation">.</span><span class="token function">IsNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// for now we use a fixed keypath scheme of m/0'/0'/k</span>
        CKey key<span class="token punctuation">;</span>                      <span class="token comment">//master key seed (256bit)</span>
        CExtKey masterKey<span class="token punctuation">;</span>             <span class="token comment">//hd master key</span>
        CExtKey accountKey<span class="token punctuation">;</span>            <span class="token comment">//key at m/0'</span>
        CExtKey externalChainChildKey<span class="token punctuation">;</span> <span class="token comment">//key at m/0'/0'</span>
        CExtKey childKey<span class="token punctuation">;</span>              <span class="token comment">//key at m/0'/0'/&lt;n&gt;'</span>

        <span class="token comment">// try to get the master key</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GetKey</span><span class="token punctuation">(</span>hdChain<span class="token punctuation">.</span>masterKeyID<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
            throw std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">runtime_error</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": Master key not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        masterKey<span class="token punctuation">.</span><span class="token function">SetMaster</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// derive m/0' 派生</span>
        <span class="token comment">// use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32)</span>
        <span class="token comment">//使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;</span>
        masterKey<span class="token punctuation">.</span><span class="token function">Derive</span><span class="token punctuation">(</span>accountKey<span class="token punctuation">,</span> BIP32_HARDENED_KEY_LIMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// derive m/0'/0'</span>
        accountKey<span class="token punctuation">.</span><span class="token function">Derive</span><span class="token punctuation">(</span>externalChainChildKey<span class="token punctuation">,</span> BIP32_HARDENED_KEY_LIMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// derive child key at next index, skip keys already known to the wallet</span>
        <span class="token keyword">do</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// always derive hardened keys</span>
            <span class="token comment">// childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range</span>
            <span class="token comment">// example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649</span>
            externalChainChildKey<span class="token punctuation">.</span><span class="token function">Derive</span><span class="token punctuation">(</span>childKey<span class="token punctuation">,</span> hdChain<span class="token punctuation">.</span>nExternalChainCounter <span class="token operator">|</span> BIP32_HARDENED_KEY_LIMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
            metadata<span class="token punctuation">.</span>hdKeypath     <span class="token operator">=</span> <span class="token string">"m/0'/0'/"</span><span class="token operator">+</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">to_string</span><span class="token punctuation">(</span>hdChain<span class="token punctuation">.</span>nExternalChainCounter<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">;</span>
            metadata<span class="token punctuation">.</span>hdMasterKeyID <span class="token operator">=</span> hdChain<span class="token punctuation">.</span>masterKeyID<span class="token punctuation">;</span>
            <span class="token comment">// increment childkey index</span>
            hdChain<span class="token punctuation">.</span>nExternalChainCounter<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">HaveKey</span><span class="token punctuation">(</span>childKey<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">GetPubKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        secret <span class="token operator">=</span> childKey<span class="token punctuation">.</span>key<span class="token punctuation">;</span>

        <span class="token comment">// update the chain model in the database</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CWalletDB</span><span class="token punctuation">(</span>strWalletFile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">WriteHDChain</span><span class="token punctuation">(</span>hdChain<span class="token punctuation">)</span><span class="token punctuation">)</span>
            throw std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">runtime_error</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": Writing HD chain model failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//2.如果在创建钱包的时候是使用随机钱包</span>
        secret<span class="token punctuation">.</span><span class="token function">MakeNewKey</span><span class="token punctuation">(</span>fCompressed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Compressed public keys were introduced in version 0.6.0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fCompressed<span class="token punctuation">)</span>
        <span class="token function">SetMinVersion</span><span class="token punctuation">(</span>FEATURE_COMPRPUBKEY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//验证公钥</span>
    CPubKey pubkey <span class="token operator">=</span> secret<span class="token punctuation">.</span><span class="token function">GetPubKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span><span class="token function">VerifyPubKey</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//判断第一把密钥的创建时间</span>
    mapKeyMetadata<span class="token punctuation">[</span>pubkey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> metadata<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nTimeFirstKey <span class="token operator">||</span> nCreationTime <span class="token operator">&lt;</span> nTimeFirstKey<span class="token punctuation">)</span>
        nTimeFirstKey <span class="token operator">=</span> nCreationTime<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span>secret<span class="token punctuation">,</span> pubkey<span class="token punctuation">)</span><span class="token punctuation">)</span>
        throw std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">runtime_error</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": AddKey failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pubkey<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>其中的HD钱包部分是依据标准<a href="https://blog.csdn.net/m0_37847176/article/details/82011876" rel="nofollow">BIP32</a>实现的，如果是随机钱包，则调用CKey类的<code>MakeNewKey</code></p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//key.cpp</span>
<span class="token keyword">void</span> CKey<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">MakeNewKey</span><span class="token punctuation">(</span>bool fCompressedIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">GetStrongRandBytes</span><span class="token punctuation">(</span>vch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">////! The actual byte data unsigned char vch[32];</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Check</span><span class="token punctuation">(</span>vch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fValid <span class="token operator">=</span> true<span class="token punctuation">;</span>
    fCompressed <span class="token operator">=</span> fCompressedIn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。<br> 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥<br> 最后添加公钥，调用CWallet类的AddKeyPubKey</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//wallet.cpp</span>
bool CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKey<span class="token operator">&amp;</span> secret<span class="token punctuation">,</span> <span class="token keyword">const</span> CPubKey <span class="token operator">&amp;</span>pubkey<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">AssertLockHeld</span><span class="token punctuation">(</span>cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mapKeyMetadata</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CCryptoKeyStore<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span>secret<span class="token punctuation">,</span> pubkey<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token comment">// check if we need to remove from watch-only</span>
    CScript script<span class="token punctuation">;</span>
    script <span class="token operator">=</span> <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HaveWatchOnly</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">RemoveWatchOnly</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    script <span class="token operator">=</span> <span class="token function">GetScriptForRawPubKey</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HaveWatchOnly</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">RemoveWatchOnly</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fFileBacked<span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsCrypted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">CWalletDB</span><span class="token punctuation">(</span>strWalletFile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">WriteKey</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">,</span>
                                                 secret<span class="token punctuation">.</span><span class="token function">GetPrivKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                 mapKeyMetadata<span class="token punctuation">[</span>pubkey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>首先调用CCryptoKeyStore的<code>AddKeyPubKey</code>，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CCryptoKeyStore<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> CPubKey <span class="token operator">&amp;</span>pubkey<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs_KeyStore<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsCrypted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//是否激活加密</span>
            <span class="token keyword">return</span> CBasicKeyStore<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> pubkey<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>

        std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> vchCryptedSecret<span class="token punctuation">;</span>
        CKeyingMaterial <span class="token function">vchSecret</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">EncryptSecret</span><span class="token punctuation">(</span>vMasterKey<span class="token punctuation">,</span> vchSecret<span class="token punctuation">,</span> pubkey<span class="token punctuation">.</span><span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchCryptedSecret<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">AddCryptedKey</span><span class="token punctuation">(</span>pubkey<span class="token punctuation">,</span> vchCryptedSecret<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>未激活加密私钥的话</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CBasicKeyStore<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddKeyPubKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKey<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> CPubKey <span class="token operator">&amp;</span>pubkey<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">LOCK</span><span class="token punctuation">(</span>cs_KeyStore<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mapKeys<span class="token punctuation">[</span>pubkey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token comment">//私钥和公钥（hash值）保存在键值对mapKeys中</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>激活加密私钥<br> 首先调用<code>EncryptSecret</code>加密秘密，接着添加加密的私钥</p> 
  <pre class=" language-c"><code class="prism  language-c">bool CCryptoKeyStore<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">AddCryptedKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> CPubKey <span class="token operator">&amp;</span>vchPubKey<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>vchCryptedSecret<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK</span><span class="token punctuation">(</span>cs_KeyStore<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SetCrypted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>

        mapCryptedKeys<span class="token punctuation">[</span>vchPubKey<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>vchPubKey<span class="token punctuation">,</span> vchCryptedSecret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>把公钥（hash）、公钥、加密的秘密保存在键值对<mark>mapCryptedKeys</mark>中。<br> 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的<code>WriteKey</code></p> 
  <pre class=" language-c"><code class="prism  language-c">bool CWalletDB<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">WriteKey</span><span class="token punctuation">(</span><span class="token keyword">const</span> CPubKey<span class="token operator">&amp;</span> vchPubKey<span class="token punctuation">,</span> <span class="token keyword">const</span> CPrivKey<span class="token operator">&amp;</span> vchPrivKey<span class="token punctuation">,</span> <span class="token keyword">const</span> CKeyMetadata<span class="token operator">&amp;</span> keyMeta<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    nWalletDBUpdated<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Write</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make_pair</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"keymeta"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPubKey<span class="token punctuation">)</span><span class="token punctuation">,</span>
               keyMeta<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token comment">// hash pubkey/privkey to accelerate wallet load</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> vchKey<span class="token punctuation">;</span>
    vchKey<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>vchPubKey<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vchPrivKey<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vchKey<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vchKey<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPubKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPubKey<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vchKey<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vchKey<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPrivKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPrivKey<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">Write</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make_pair</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchPubKey<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make_pair</span><span class="token punctuation">(</span>vchPrivKey<span class="token punctuation">,</span> <span class="token function">Hash</span><span class="token punctuation">(</span>vchKey<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchKey<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。<br> <a href="https://blog.csdn.net/m0_37847176/article/details/81739999" rel="nofollow">加载钱包</a>需要了解一下</p> 
  <blockquote> 
   <p>Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。</p> 
  </blockquote> 
  <h2><a id="2base58_287"></a>2.base58编码</h2> 
  <p>代码中使用的代码如下</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span>keyID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <blockquote> 
   <p>base58-encoded Bitcoin addresses.<br> Public-key-hash-addresses have version 0 (or 111 testnet).<br> The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.<br> Script-hash-addresses have version 5 (or 196 testnet).<br> The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.<br> 公钥哈希地址具有版本0（或111 测试网）。<br> 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。<br> 脚本哈希地址具有版本5（或196 测试网）。<br> 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。</p> 
  </blockquote> 
  <table> 
   <thead> 
    <tr> 
     <th>Type</th> 
     <th align="center">Version Prefix(hex)</th> 
     <th align="left">base58 result prefix</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>bitcoin address</td> 
     <td align="center">0x00</td> 
     <td align="left">1</td> 
    </tr> 
    <tr> 
     <td>bitcoin testnet address</td> 
     <td align="center">0x6f</td> 
     <td align="left">m、n</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses</td> 
     <td align="center">0x05</td> 
     <td align="left">3</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses testnet</td> 
     <td align="center">0xc4</td> 
     <td align="left"></td> 
    </tr> 
   </tbody> 
  </table>
  <p>这些可以在chainparams.cpp的对应参数类中找到，如下为测试网</p> 
  <pre class=" language-c"><code class="prism  language-c">base58Prefixes<span class="token punctuation">[</span>PUBKEY_ADDRESS<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base58Prefixes<span class="token punctuation">[</span>SCRIPT_ADDRESS<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">196</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。</p> 
  <pre class=" language-c"><code class="prism  language-c">class CBitcoinAddress <span class="token punctuation">:</span> public CBase58Data <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    bool <span class="token function">Set</span><span class="token punctuation">(</span><span class="token keyword">const</span> CKeyID <span class="token operator">&amp;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token function">Set</span><span class="token punctuation">(</span><span class="token keyword">const</span> CScriptID <span class="token operator">&amp;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token function">Set</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxDestination <span class="token operator">&amp;</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    bool <span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token keyword">const</span> CChainParams <span class="token operator">&amp;</span>params<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

    <span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxDestination <span class="token operator">&amp;</span>dest<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">Set</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> strAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">SetString</span><span class="token punctuation">(</span>strAddress<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">CBitcoinAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pszAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">SetString</span><span class="token punctuation">(</span>pszAddress<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    CTxDestination <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    bool <span class="token function">GetKeyID</span><span class="token punctuation">(</span>CKeyID <span class="token operator">&amp;</span>keyID<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    bool <span class="token function">IsScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>根据代码推测是调用了第三个或第四个构造函数，都是调用<code>SetString()</code>函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的<code>bool SetString(const char* psz, unsigned int nVersionBytes = 1);</code></p> 
  <pre class=" language-c"><code class="prism  language-c">bool CBase58Data<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">SetString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> psz<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nVersionBytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> vchTemp<span class="token punctuation">;</span>
    <span class="token comment">//将psz解码并且验证正确后的内容存放在vchTemp,此时的vchTemp包含版本前缀和编码前的内容</span>
    bool rc58 <span class="token operator">=</span> <span class="token function">DecodeBase58Check</span><span class="token punctuation">(</span>psz<span class="token punctuation">,</span> vchTemp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>rc58<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>vchTemp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nVersionBytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果解码验证失败，清空成员变量vchData,vchVersion</span>
        vchData<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vchVersion<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vchVersion<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>vchTemp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchTemp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nVersionBytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取版本信息，就是版本前缀</span>
    vchData<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>vchTemp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nVersionBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vchData<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vchData<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vchTemp<span class="token punctuation">[</span>nVersionBytes<span class="token punctuation">]</span><span class="token punctuation">,</span> vchData<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编码前的数据如比特币地址，脚本地址存入vchData中</span>
    <span class="token function">memory_cleanse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vchTemp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vchTemp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这一段的逻辑就是解码验证，获取Version和Payload的过程</p> 
  <pre class=" language-c"><code class="prism  language-c">std<span class="token punctuation">:</span><span class="token punctuation">:</span>string CBase58Data<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> vch <span class="token operator">=</span> vchVersion<span class="token punctuation">;</span>
    <span class="token comment">//在vch的末尾插入vchData</span>
    vch<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vch<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchData<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vchData<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">EncodeBase58Check</span><span class="token punctuation">(</span>vch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对版本前缀和内容的组合编码</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>借用精通比特币的图，编码过程如下，可以理解为vch=version+payload,在上一代码中vch=vchVersion+vchData.</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828145938928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 那么顺便来看一下EncodeBase58Check这个函数</p> 
  <pre class=" language-c"><code class="prism  language-c">std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token function">EncodeBase58Check</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> vchIn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// add 4-byte hash check to the end</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">vch</span><span class="token punctuation">(</span>vchIn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint256 hash <span class="token operator">=</span> <span class="token function">Hash</span><span class="token punctuation">(</span>vch<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vch<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vch<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vch<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>hash<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>hash <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">EncodeBase58</span><span class="token punctuation">(</span>vch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>这段很简单就是在后面加上4位的校验码，校验码就是对vch做两次sha256取前4位。然后调用EncodeBase58进行编码。</p> 
  <h2><a id="3_379"></a>3.发送金额</h2> 
  <p>这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起）</p> 
  <blockquote> 
   <p>A txout script template with a specific destination. It is either:<br> CNoDestination: no destination set<br> CKeyID: TX_PUBKEYHASH destination<br> CScriptID: TX_SCRIPTHASH destination<br> A CTxDestination is the internal data type encoded in a CBitcoinAddress</p> 
  </blockquote> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">typedef</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>variant<span class="token operator">&lt;</span>CNoDestination<span class="token punctuation">,</span> CKeyID<span class="token punctuation">,</span> CScriptID<span class="token operator">&gt;</span> CTxDestination<span class="token punctuation">;</span>
</code></pre> 
  <blockquote> 
   <p><mark>CWalletTx</mark>:A transaction with a bunch of additional info that only the owner cares about.<br> It includes any unrecorded transactions needed to link it back to the block chain.</p> 
  </blockquote> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SendMoney</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxDestination <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> CAmount nValue<span class="token punctuation">,</span> bool fSubtractFeeFromAmount<span class="token punctuation">,</span> CWalletTx<span class="token operator">&amp;</span> wtxNew<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CAmount curBalance <span class="token operator">=</span> pwalletMain<span class="token operator">-&gt;</span><span class="token function">GetBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 1.Check amount 检查余额</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nValue <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        throw <span class="token function">JSONRPCError</span><span class="token punctuation">(</span>RPC_INVALID_PARAMETER<span class="token punctuation">,</span> <span class="token string">"Invalid amount"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>nValue <span class="token operator">&gt;</span> curBalance<span class="token punctuation">)</span>
        throw <span class="token function">JSONRPCError</span><span class="token punctuation">(</span>RPC_WALLET_INSUFFICIENT_FUNDS<span class="token punctuation">,</span> <span class="token string">"Insufficient funds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2.Parse Bitcoin address 解析比目的地，获得脚本</span>
    CScript scriptPubKey <span class="token operator">=</span> <span class="token function">GetScriptForDestination</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3.Create and send the transaction 创建并发送交易</span>
    CReserveKey <span class="token function">reservekey</span><span class="token punctuation">(</span>pwalletMain<span class="token punctuation">)</span><span class="token punctuation">;</span>
    CAmount nFeeRequired<span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>string strError<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>CRecipient<span class="token operator">&gt;</span> vecSend<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nChangePosRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    CRecipient recipient <span class="token operator">=</span> <span class="token punctuation">{</span>scriptPubKey<span class="token punctuation">,</span> nValue<span class="token punctuation">,</span> fSubtractFeeFromAmount<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//接收者（锁定脚本，金额，是否抽取费用）</span>
    vecSend<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>recipient<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pwalletMain<span class="token operator">-&gt;</span><span class="token function">CreateTransaction</span><span class="token punctuation">(</span>vecSend<span class="token punctuation">,</span> wtxNew<span class="token punctuation">,</span> reservekey<span class="token punctuation">,</span> nFeeRequired<span class="token punctuation">,</span> nChangePosRet<span class="token punctuation">,</span> strError<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fSubtractFeeFromAmount <span class="token operator">&amp;&amp;</span> nValue <span class="token operator">+</span> nFeeRequired <span class="token operator">&gt;</span> pwalletMain<span class="token operator">-&gt;</span><span class="token function">GetBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            strError <span class="token operator">=</span> <span class="token function">strprintf</span><span class="token punctuation">(</span><span class="token string">"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!"</span><span class="token punctuation">,</span> <span class="token function">FormatMoney</span><span class="token punctuation">(</span>nFeeRequired<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        throw <span class="token function">JSONRPCError</span><span class="token punctuation">(</span>RPC_WALLET_ERROR<span class="token punctuation">,</span> strError<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pwalletMain<span class="token operator">-&gt;</span><span class="token function">CommitTransaction</span><span class="token punctuation">(</span>wtxNew<span class="token punctuation">,</span> reservekey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//提交交易</span>
        throw <span class="token function">JSONRPCError</span><span class="token punctuation">(</span>RPC_WALLET_ERROR<span class="token punctuation">,</span> <span class="token string">"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h3><a id="31GetBalance_424"></a>3.1GetBalance()</h3> 
  <p>首先调用<code>GetBalance()</code>获取钱包的余额</p> 
  <pre class=" language-c"><code class="prism  language-c">CAmount CWallet<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    CAmount nTotal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token function">LOCK2</span><span class="token punctuation">(</span>cs_main<span class="token punctuation">,</span> cs_wallet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>map<span class="token operator">&lt;</span>uint256<span class="token punctuation">,</span> CWalletTx<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>const_iterator it <span class="token operator">=</span> mapWallet<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> mapWallet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">const</span> CWalletTx<span class="token operator">*</span> pcoin <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token comment">//CWalletTx</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pcoin<span class="token operator">-&gt;</span><span class="token function">IsTrusted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                nTotal <span class="token operator">+</span><span class="token operator">=</span> pcoin<span class="token operator">-&gt;</span><span class="token function">GetAvailableCredit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nTotal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h4><a id="311IsTrusted_443"></a>3.1.1IsTrusted()</h4> 
  <p>这里判断交易是否被信任</p> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//wallet.cpp</span>
bool CWalletTx<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">IsTrusted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Quick answer in most cases</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CheckFinalTx</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//判断交易是否是最终的，函数内调用了IsFinalTx</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nDepth <span class="token operator">=</span> <span class="token function">GetDepthInMainChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nDepth <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//交易所在区块后面的区块大于等于1即视为信任</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nDepth <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bSpendZeroConfChange <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsFromMe</span><span class="token punctuation">(</span>ISMINE_ALL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// using wtx's cached debit</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token comment">// Don't trust unconfirmed transactions from us unless they are in the mempool.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">InMempool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//不信任不在内存池中的交易</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token comment">// Trusted if all inputs are from us and are in the mempool:</span>
    <span class="token function">BOOST_FOREACH</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTxIn<span class="token operator">&amp;</span> txin<span class="token punctuation">,</span> vin<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Transactions not sent by us: not trusted</span>
        <span class="token keyword">const</span> CWalletTx<span class="token operator">*</span> parent <span class="token operator">=</span> pwallet<span class="token operator">-&gt;</span><span class="token function">GetWalletTx</span><span class="token punctuation">(</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token keyword">const</span> CTxOut<span class="token operator">&amp;</span> parentOut <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>vout<span class="token punctuation">[</span>txin<span class="token punctuation">.</span>prevout<span class="token punctuation">.</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pwallet<span class="token operator">-&gt;</span><span class="token function">IsMine</span><span class="token punctuation">(</span>parentOut<span class="token punctuation">)</span> <span class="token operator">!=</span> ISMINE_SPENDABLE<span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <pre class=" language-c"><code class="prism  language-c"><span class="token comment">//main.h</span>
<span class="token comment">/** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */</span>
bool <span class="token function">IsFinalTx</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTransaction <span class="token operator">&amp;</span>tx<span class="token punctuation">,</span> <span class="token keyword">int</span> nBlockHeight<span class="token punctuation">,</span> int64_t nBlockTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <h4><a id="312GetAvailableCredit_486"></a>3.1.2GetAvailableCredit</h4> 
  <p>这里有几个逻辑</p> 
  <pre class=" language-c"><code class="prism  language-c">CAmount CWalletTx<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetAvailableCredit</span><span class="token punctuation">(</span>bool fUseCache<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pwallet <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//没有钱包信息则返回0</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// Must wait until coinbase is safely deep enough in the chain before valuing it</span>
    <span class="token comment">//如果是coinbase交易，必须等这笔交易足够安全，否则返回0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsCoinBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">GetBlocksToMaturity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>fUseCache <span class="token operator">&amp;&amp;</span> fAvailableCreditCached<span class="token punctuation">)</span><span class="token comment">//如果使用缓存数据</span>
        <span class="token keyword">return</span> nAvailableCreditCached<span class="token punctuation">;</span>

    CAmount nCredit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    uint256 hashTx <span class="token operator">=</span> <span class="token function">GetHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vout<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pwallet<span class="token operator">-&gt;</span><span class="token function">IsSpent</span><span class="token punctuation">(</span>hashTx<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果这笔交易的输出未支出</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">const</span> CTxOut <span class="token operator">&amp;</span>txout <span class="token operator">=</span> vout<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            nCredit <span class="token operator">+</span><span class="token operator">=</span> pwallet<span class="token operator">-&gt;</span><span class="token function">GetCredit</span><span class="token punctuation">(</span>txout<span class="token punctuation">,</span> ISMINE_SPENDABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我可以花费的部分</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">MoneyRange</span><span class="token punctuation">(</span>nCredit<span class="token punctuation">)</span><span class="token punctuation">)</span>
                throw std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"CWalletTx::GetAvailableCredit() : value out of range"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    nAvailableCreditCached <span class="token operator">=</span> nCredit<span class="token punctuation">;</span>
    fAvailableCreditCached <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">return</span> nCredit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>太长了，分开写到另一篇<a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">创建一个交易</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81906838,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/m0_37847176/article/details/81906838,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
