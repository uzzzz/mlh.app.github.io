<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码-一个交易的产生 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码-一个交易的产生" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1） 参数 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;} CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired;未赋值 int&amp; nChangePosRet 改变标志位？ std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能 bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//计算总共要支付的 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++; } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，参考这篇 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping.针对费用狙击 For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 对于大型矿工而言，最佳区块和mempool中的交易价值可能超过尝试故意挖掘两个区块以孤立当前最佳区块的成本。通过设置nLockTime使得只有下一个区块可以包括交易，我们不鼓励这种做法，因为高度限制和有限的区块大小给矿工考虑费用狙击更少的选项来解除这种攻击。 考虑这个问题的一个简单方法是从钱包的角度来看，我们总是希望区块链能够向前发展。通过以这种方式设置nLockTime，我们基本上是在声明我们只希望此交易出现在下一个块中;我们不希望通过允许交易出现在比最佳链的下一个分叉块中更低的高度来促进重新排序。 当然，补贴足够高，交易量足够低，费用狙击就不是问题，但是现在通过实现一个修复，我们确保代码不会被编写对nLockTime进行假设，以防止以后修复。 以下解说引用自《精通比特币（）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）vouts { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins; //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0; // Start with no fee and loop until there is enough fee //循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest; txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true; CAmount nValueToSelect = nValue;//初始为0 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet; double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); if (recipient.fSubtractFeeFromAmount) { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者支出不能被总输出整除的剩余 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分 } 4) // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue; //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级 } 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control，默认没有设置，那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是不重复使用之前的密钥，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey); if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID()); } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 这里的意思是使用我们之前生成过的保留在钱包中的密钥 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数 bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1) { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF 使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output // Never create dust outputs; if we would, just // add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及vin的序列号，这个类写在这里https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入容器的底部。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded) break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded; continue; } } } 到这里循环结束 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1） 参数 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;} CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired;未赋值 int&amp; nChangePosRet 改变标志位？ std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能 bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//计算总共要支付的 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++; } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，参考这篇 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping.针对费用狙击 For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 对于大型矿工而言，最佳区块和mempool中的交易价值可能超过尝试故意挖掘两个区块以孤立当前最佳区块的成本。通过设置nLockTime使得只有下一个区块可以包括交易，我们不鼓励这种做法，因为高度限制和有限的区块大小给矿工考虑费用狙击更少的选项来解除这种攻击。 考虑这个问题的一个简单方法是从钱包的角度来看，我们总是希望区块链能够向前发展。通过以这种方式设置nLockTime，我们基本上是在声明我们只希望此交易出现在下一个块中;我们不希望通过允许交易出现在比最佳链的下一个分叉块中更低的高度来促进重新排序。 当然，补贴足够高，交易量足够低，费用狙击就不是问题，但是现在通过实现一个修复，我们确保代码不会被编写对nLockTime进行假设，以防止以后修复。 以下解说引用自《精通比特币（）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）vouts { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins; //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0; // Start with no fee and loop until there is enough fee //循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest; txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true; CAmount nValueToSelect = nValue;//初始为0 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet; double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); if (recipient.fSubtractFeeFromAmount) { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者支出不能被总输出整除的剩余 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分 } 4) // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue; //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级 } 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control，默认没有设置，那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是不重复使用之前的密钥，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey); if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID()); } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 这里的意思是使用我们之前生成过的保留在钱包中的密钥 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数 bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1) { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF 使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output // Never create dust outputs; if we would, just // add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及vin的序列号，这个类写在这里https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入容器的底部。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded) break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded; continue; } } } 到这里循环结束 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易。 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/08/28/bb856d71adcd51b952ff7535a4bc8c88.html" />
<meta property="og:url" content="https://mlh.app/2018/08/28/bb856d71adcd51b952ff7535a4bc8c88.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \\&quot;account\\&quot; )\\n&quot; &quot;\\nReturns a new Bitcoin address for receiving payments.\\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \\n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\\n&quot; &quot;\\nArguments:\\n&quot; &quot;1. \\&quot;account\\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\&quot;\\&quot; is used. It can also be set to the empty string \\&quot;\\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n&quot; &quot;\\nResult:\\n&quot; &quot;\\&quot;bitcoinaddress\\&quot; (string) The new bitcoin address\\n&quot; &quot;\\nExamples:\\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } CreateTransaction /** * Create a new transaction paying the recipients with a set of coins * selected by SelectCoins(); Also create the change output, when needed * @note passing nChangePosInOut as -1 will result in setting a random position */ 这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 鉴于这段代码很长，分段来讲 1） 参数 类型 名称 说明 vector&lt;CRecipient&gt; vecSend struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;} CWalletTx&amp; wtxNew 包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易 CReserveKey&amp; reservekey 密钥池分配的密钥 CAmount&amp; nFeeRet CAmount nFeeRequired;未赋值 int&amp; nChangePosRet 改变标志位？ std::string&amp; strFailReason 失败的原因 CCoinControl* coinControl 币控制功能 bool sign 默认为true bool CWallet::CreateTransaction(const vector&lt;CRecipient&gt;&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet, int&amp; nChangePosInOut, std::string&amp; strFailReason, const CCoinControl* coinControl, bool sign) { CAmount nValue = 0;//初始化为0 int nChangePosRequest = nChangePosInOut;//赋值 unsigned int nSubtractFeeFromAmount = 0; BOOST_FOREACH (const CRecipient&amp; recipient, vecSend)//解析接收者的信息 { if (nValue &lt; 0 || recipient.nAmount &lt; 0) {//交易金额不能为负 strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } nValue += recipient.nAmount;//计算总共要支付的 if (recipient.fSubtractFeeFromAmount) nSubtractFeeFromAmount++; } if (vecSend.empty() || nValue &lt; 0) { strFailReason = _(&quot;Transaction amounts must be positive&quot;); return false; } wtxNew.fTimeReceivedIsTxTime = true; wtxNew.BindWallet(this);//绑定钱包 CMutableTransaction txNew;//A mutable version of CTransaction. 2）nLockTime nLockTime是交易类的成员变量，参考这篇 https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。 Discourage fee sniping.针对费用狙击 For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. 对于大型矿工而言，最佳区块和mempool中的交易价值可能超过尝试故意挖掘两个区块以孤立当前最佳区块的成本。通过设置nLockTime使得只有下一个区块可以包括交易，我们不鼓励这种做法，因为高度限制和有限的区块大小给矿工考虑费用狙击更少的选项来解除这种攻击。 考虑这个问题的一个简单方法是从钱包的角度来看，我们总是希望区块链能够向前发展。通过以这种方式设置nLockTime，我们基本上是在声明我们只希望此交易出现在下一个块中;我们不希望通过允许交易出现在比最佳链的下一个分叉块中更低的高度来促进重新排序。 当然，补贴足够高，交易量足够低，费用狙击就不是问题，但是现在通过实现一个修复，我们确保代码不会被编写对nLockTime进行假设，以防止以后修复。 以下解说引用自《精通比特币（）》 费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。 txNew.nLockTime = chainActive.Height();//当前有效区块的高度 Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。 if (GetRandInt(10) == 0) txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100)); assert(txNew.nLockTime &lt;= (unsigned int)chainActive.Height()); assert(txNew.nLockTime &lt; LOCKTIME_THRESHOLD); 3）vouts { LOCK2(cs_main, cs_wallet); { std::vector&lt;COutput&gt; vAvailableCoins; //用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出 AvailableCoins(vAvailableCoins, true, coinControl); nFeeRet = 0; // Start with no fee and loop until there is enough fee //循环直到有足够的交易金额 while (true) { //初始化工作，清零 nChangePosInOut = nChangePosRequest; txNew.vin.clear(); txNew.vout.clear(); txNew.wit.SetNull(); wtxNew.fFromMe = true; bool fFirst = true; CAmount nValueToSelect = nValue;//初始为0 if (nSubtractFeeFromAmount == 0) nValueToSelect += nFeeRet; double dPriority = 0; 对每个接收者的处理，对每个接收者创建一个CTxOut https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout // vouts to the payees BOOST_FOREACH (const CRecipient&amp; recipient, vecSend) { CTxOut txout(recipient.nAmount, recipient.scriptPubKey); if (recipient.fSubtractFeeFromAmount) { txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient //第一个接收者支出不能被总输出整除的剩余 if (fFirst) // first receiver pays the remainder not divisible by output count { fFirst = false; txout.nValue -= nFeeRet % nSubtractFeeFromAmount; } } //如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易 if (txout.IsDust(::minRelayTxFee)) { if (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; 0) { if (txout.nValue &lt; 0) strFailReason = _(&quot;The transaction amount is too small to pay the fee&quot;); else strFailReason = _(&quot;The transaction amount is too small to send after the fee has been deducted&quot;); } else strFailReason = _(&quot;Transaction amount too small&quot;); return false; } txNew.vout.push_back(txout);//写入交易的输出部分 } 4) // Choose coins to use set&lt;pair&lt;const CWalletTx*,unsigned int&gt; &gt; setCoins; CAmount nValueIn = 0; //Shuffle and select coins until nTargetValue is reached while avoiding small change; //打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect //setCoins包含支付给你本人地址的交易，即你所拥有的币 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl)) { strFailReason = _(&quot;Insufficient funds&quot;); return false; } //对选择好的这一组coins的每个来源计算优先级 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) { CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue; //The coin age after the next block (depth+1) is used instead of the current, //reflecting an assumption the user would accept a bit more delay for //a chance at a free transaction. //But mempool inputs might still be in the mempool, so their age stays 0 /*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/ int age = pcoin.first-&gt;GetDepthInMainChain(); assert(age &gt;= 0); if (age != 0) age += 1; dPriority += (double)nCredit * age;//增加优先级 } 5）找零 const CAmount nChange = nValueIn - nValueToSelect;//超出所需支出，那么需要找零 if (nChange &gt; 0) { // Fill a vout to ourself // TODO: pass in scriptChange instead of reservekey so // change transaction isn&#39;t always pay-to-bitcoin-address /*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/ CScript scriptChange; // coin control: send change to custom address找零支付回习惯地址，如果设置的话 if (coinControl &amp;&amp; !boost::get&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange)) scriptChange = GetScriptForDestination(coinControl-&gt;destChange); // no coin control: send change to newly generated address //没有coin control，默认没有设置，那么找零到一个新创建的地址 else { // Note: We use a new key here to keep it from being obvious which side is the change. // The drawback is that by not reusing a previous key, the change may be lost if a // backup is restored, if the backup doesn&#39;t have the new private key for the change. // If we reused the old key, it would be possible to add code to look for and // rediscover unknown transactions that were written with keys of ours to recover // post-backup change. /*我们使用一个新的密钥避免找零地址变得明显。缺点是不重复使用之前的密钥，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/ // Reserve a new key pair from key pool 从密钥池中预约一个新的密钥 CPubKey vchPubKey; bool ret; ret = reservekey.GetReservedKey(vchPubKey); if (!ret) { strFailReason = _(&quot;Keypool ran out, please call keypoolrefill first&quot;); return false; } scriptChange = GetScriptForDestination(vchPubKey.GetID()); } CTxOut newTxOut(nChange, scriptChange);//新建一笔找零交易 这里的意思是使用我们之前生成过的保留在钱包中的密钥 上述代码调用reservekey的GetReservedKey，reservekey是传入的参数 bool CReserveKey::GetReservedKey(CPubKey&amp; pubkey) { if (nIndex == -1) { CKeyPool keypool; pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex != -1) vchPubKey = keypool.vchPubKey; else { return false; } } assert(vchPubKey.IsValid()); pubkey = vchPubKey; return true; } GetReservedKey调用CWallet类的ReserveKeyFromKeyPool void CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool) { nIndex = -1; keypool.vchPubKey = CPubKey();//构造一个无效的PubKey { LOCK(cs_wallet); if (!IsLocked()) TopUpKeyPool();//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中 // Get the oldest key if(setKeyPool.empty()) return; CWalletDB walletdb(strWalletFile); nIndex = *(setKeyPool.begin());//返回容器指向的第一个元素 setKeyPool.erase(setKeyPool.begin());//擦除这个指针指向的元素 if (!walletdb.ReadPool(nIndex, keypool)) throw runtime_error(std::string(__func__) + &quot;: read failed&quot;); if (!HaveKey(keypool.vchPubKey.GetID())) throw runtime_error(std::string(__func__) + &quot;: unknown key in key pool&quot;); assert(keypool.vchPubKey.IsValid()); LogPrintf(&quot;keypool reserve %d\\n&quot;, nIndex); } } 需要注意这里的setKeyPool是signd long long的set容器类型 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用WritePool函数，另一种是写在‘keymate‘中 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF 使用rpc指令 创建两笔交易 parallels@parallels-vm:~$ bitcoin-cli walletpassphrase aser6789dfgb 300 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 441bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04 parallels@parallels-vm:~$ bitcoin-cli getbalance 1.09896799 parallels@parallels-vm:~$ bitcoin-cli sendtoaddress &quot;2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF&quot; 0.2 aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641 parallels@parallels-vm:~$ 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 在创建三笔交易，创建一个地址，创建一个交易 6）dust output // Never create dust outputs; if we would, just // add the dust to the fee. if (newTxOut.IsDust(::minRelayTxFee)) { nChangePosInOut = -1; nFeeRet += nChange; reservekey.ReturnKey(); } else { if (nChangePosInOut == -1) { // Insert change txn at random position: nChangePosInOut = GetRandInt(txNew.vout.size()+1); } else if ((unsigned int)nChangePosInOut &gt; txNew.vout.size()) { strFailReason = _(&quot;Change index out of range&quot;); return false; } vector&lt;CTxOut&gt;::iterator position = txNew.vout.begin()+nChangePosInOut; txNew.vout.insert(position, newTxOut); } } else reservekey.ReturnKey(); 7）vin &amp; sign 涉及vin的序列号，这个类写在这里https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin // Fill vin // // Note how the sequence number is set to max()-1 so that the // nLockTime set above actually works. BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),std::numeric_limits&lt;unsigned int&gt;::max()-1)); 这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入容器的底部。 接下来看签名 // Sign int nIn = 0; CTransaction txNewConst(txNew); BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)&amp; coin, setCoins) { bool signSuccess; const CScript&amp; scriptPubKey = coin.first-&gt;vout[coin.second].scriptPubKey; SignatureData sigdata; if (sign) //非隔离见证的交易 signSuccess = ProduceSignature(TransactionSignatureCreator(this, &amp;txNewConst, nIn, coin.first-&gt;vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata); else //使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证 signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata); if (!signSuccess) { strFailReason = _(&quot;Signing transaction failed&quot;); return false; } else { //从交易中抽取签名数据然后插入 UpdateTransaction(txNew, nIn, sigdata); } nIn++; } 对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类CMerkleTx的父类CTransaction有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 调用函数ProduceSignature使用通用签名创建者生成脚本签名 //sign.h /** Produce a script signature using a generic signature creator. */ bool ProduceSignature(const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey, SignatureData&amp; sigdata); 8）判断 unsigned int nBytes = GetVirtualTransactionSize(txNew); // Remove scriptSigs if we used dummy signatures for fee calculation if (!sign) { BOOST_FOREACH (CTxIn&amp; vin, txNew.vin) vin.scriptSig = CScript(); txNew.wit.SetNull(); } // Embed the constructed transaction data in wtxNew. *static_cast&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew); // Limit size限制大小 if (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT) { strFailReason = _(&quot;Transaction too large&quot;); return false; } dPriority = wtxNew.ComputePriority(dPriority, nBytes); // Can we complete this as a free transaction? //构造一个免费的交易，费用不够的话用优先级来凑 if (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)//默认值分别为false、1000 { // Not enough fee: enough priority? double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget); // Require at least hard-coded AllowFree. if (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority)) break; } //获取最小交易费 CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool); if (coinControl &amp;&amp; nFeeNeeded &gt; 0 &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) { nFeeNeeded = coinControl-&gt;nMinimumTotalFee; } if (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate) nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes); // If we made it here and we aren&#39;t even able to meet the relay fee on the next pass, give up // because we must be at the maximum allowed fee. if (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes)) { strFailReason = _(&quot;Transaction too large for fee policy&quot;); return false; } if (nFeeRet &gt;= nFeeNeeded) break; // Done, enough fee included. // Include more fee and try again. nFeeRet = nFeeNeeded; continue; } } } 到这里循环结束 9）参数读取 if (GetBoolArg(&quot;-walletrejectlongchains&quot;, DEFAULT_WALLET_REJECT_LONG_CHAINS)) { // Lastly, ensure this tx will pass the mempool&#39;s chain limits LockPoints lp; CTxMemPoolEntry entry(txNew, 0, 0, 0, 0, false, 0, false, 0, lp); CTxMemPool::setEntries setAncestors; size_t nLimitAncestors = GetArg(&quot;-limitancestorcount&quot;, DEFAULT_ANCESTOR_LIMIT); size_t nLimitAncestorSize = GetArg(&quot;-limitancestorsize&quot;, DEFAULT_ANCESTOR_SIZE_LIMIT)*1000; size_t nLimitDescendants = GetArg(&quot;-limitdescendantcount&quot;, DEFAULT_DESCENDANT_LIMIT); size_t nLimitDescendantSize = GetArg(&quot;-limitdescendantsize&quot;, DEFAULT_DESCENDANT_SIZE_LIMIT)*1000; std::string errString; if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) { strFailReason = _(&quot;Transaction has too long of a mempool chain&quot;); return false; } } return true; } 那么到这里就创建完交易了，接下来提交交易。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/08/28/bb856d71adcd51b952ff7535a4bc8c88.html","headline":"比特币源码-一个交易的产生","dateModified":"2018-08-28T00:00:00+08:00","datePublished":"2018-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/28/bb856d71adcd51b952ff7535a4bc8c88.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码-一个交易的产生</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 
 </div> 
 <div class="markdown_views"> 
  <p>在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 <br> 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。</p> 
  <h1 id="生成比特币地址">生成比特币地址</h1> 
  <p>从钱包的rpc指令getnewaddress开始看，先来看下调用结果 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821144451891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 <br> 然后在日志信息中会增加相应的记录 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821151439657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 下面来看这个指定对应调用的函数</p> 
  <h2 id="getnewaddress">getnewaddress</h2> 
  <p>位于/src/rpc/wallet/rpcwallet.cpp</p> 
  <pre class="prettyprint"><code class=" hljs cs">UniValue getnewaddress(<span class="hljs-keyword">const</span> UniValue&amp; <span class="hljs-keyword">params</span>, <span class="hljs-keyword">bool</span> fHelp)
{
    <span class="hljs-keyword">if</span> (!EnsureWalletIsAvailable(fHelp))
        <span class="hljs-keyword">return</span> NullUniValue;

    <span class="hljs-keyword">if</span> (fHelp || <span class="hljs-keyword">params</span>.size() &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">throw</span> runtime_error(
            <span class="hljs-string">"getnewaddress ( \"account\" )\n"</span>
            <span class="hljs-string">"\nReturns a new Bitcoin address for receiving payments.\n"</span>
            <span class="hljs-string">"If 'account' is specified (DEPRECATED), it is added to the address book \n"</span>
            <span class="hljs-string">"so payments received with the address will be credited to 'account'.\n"</span>
            <span class="hljs-string">"\nArguments:\n"</span>
            <span class="hljs-string">"1. \"account\" (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \"\" is used. It can also be set to the empty string \"\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n"</span>
            <span class="hljs-string">"\nResult:\n"</span>
            <span class="hljs-string">"\"bitcoinaddress\" (string) The new bitcoin address\n"</span>
            <span class="hljs-string">"\nExamples:\n"</span>
            + HelpExampleCli(<span class="hljs-string">"getnewaddress"</span>, <span class="hljs-string">""</span>)
            + HelpExampleRpc(<span class="hljs-string">"getnewaddress"</span>, <span class="hljs-string">""</span>)
        );

    LOCK2(cs_main, pwalletMain-&gt;cs_wallet);

    <span class="hljs-comment">// Parse the account first so we don't generate a key if there's an error</span>
    <span class="hljs-keyword">string</span> strAccount;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">params</span>.size() &gt; <span class="hljs-number">0</span>)
        strAccount = AccountFromValue(<span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;IsLocked())
        pwalletMain-&gt;TopUpKeyPool();

    <span class="hljs-comment">// Generate a new key that is added to wallet</span>
    CPubKey newKey;
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;GetKeyFromPool(newKey))
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, <span class="hljs-string">"Error: Keypool ran out, please call keypoolrefill first"</span>);
    CKeyID keyID = newKey.GetID();<span class="hljs-comment">//获取的是hash160的值</span>
<span class="hljs-comment">//pwalletMain是CWllat类的指针</span>
    pwalletMain-&gt;SetAddressBook(keyID, strAccount, <span class="hljs-string">"receive"</span>);
<span class="hljs-comment">//CBitcoinAddress函数调用Base58编码转换</span>
    <span class="hljs-keyword">return</span> CBitcoinAddress(keyID).ToString();
}</code></pre> 
  <p>这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。</p> 
  <h2 id="getkeyfrompool">GetKeyFromPool</h2> 
  <p>在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//src/wallet/wallet.cpp</span>
<span class="hljs-keyword">bool</span> CWallet::GetKeyFromPool(CPubKey&amp; result)
{
    int64_t nIndex = <span class="hljs-number">0</span>;
    CKeyPool keypool;
    {
        LOCK(cs_wallet);
        ReserveKeyFromKeyPool(nIndex, keypool);
        <span class="hljs-keyword">if</span> (nIndex == -<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span> (IsLocked()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            result = GenerateNewKey();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        KeepKey(nIndex);
        result = keypool.vchPubKey;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <h3 id="generatenewkey">GenerateNewKey</h3> 
  <p>CKey可以参考<a href="https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck</a>里面有写到这个类，以及makenewkey()的实现</p> 
  <blockquote> 
   <p>-usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cpp">CPubKey CWallet::GenerateNewKey()
{
    AssertLockHeld(cs_wallet); <span class="hljs-comment">// mapKeyMetadata</span>
    <span class="hljs-keyword">bool</span> fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); <span class="hljs-comment">// default to compressed public keys if we want 0.6.0 wallets</span>
    <span class="hljs-comment">// CKey是私钥的类</span>
    CKey secret;

    <span class="hljs-comment">// Create new metadata</span>
    int64_t nCreationTime = GetTime();
    CKeyMetadata metadata(nCreationTime);

    <span class="hljs-comment">// use HD key derivation if HD was enabled during wallet creation </span>
    <span class="hljs-comment">//1.如果在钱包创建时使用确定分层钱包，则使用HD密钥</span>
    <span class="hljs-keyword">if</span> (!hdChain.masterKeyID.IsNull()) {
        <span class="hljs-comment">// for now we use a fixed keypath scheme of m/0'/0'/k</span>
        CKey key;                      <span class="hljs-comment">//master key seed (256bit)</span>
        CExtKey masterKey;             <span class="hljs-comment">//hd master key</span>
        CExtKey accountKey;            <span class="hljs-comment">//key at m/0'</span>
        CExtKey externalChainChildKey; <span class="hljs-comment">//key at m/0'/0'</span>
        CExtKey childKey;              <span class="hljs-comment">//key at m/0'/0'/&lt;n&gt;'</span>

        <span class="hljs-comment">// try to get the master key</span>
        <span class="hljs-keyword">if</span> (!GetKey(hdChain.masterKeyID, key))
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": Master key not found"</span>);

        masterKey.SetMaster(key.begin(), key.size());

        <span class="hljs-comment">// derive m/0' 派生</span>
        <span class="hljs-comment">// use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32)</span>
        <span class="hljs-comment">//使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;</span>
        masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);

        <span class="hljs-comment">// derive m/0'/0'</span>
        accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT);

        <span class="hljs-comment">// derive child key at next index, skip keys already known to the wallet</span>
        <span class="hljs-keyword">do</span>
        {
            <span class="hljs-comment">// always derive hardened keys</span>
            <span class="hljs-comment">// childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range</span>
            <span class="hljs-comment">// example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649</span>
            externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);
            metadata.hdKeypath     = <span class="hljs-string">"m/0'/0'/"</span>+<span class="hljs-built_in">std</span>::to_string(hdChain.nExternalChainCounter)+<span class="hljs-string">"'"</span>;
            metadata.hdMasterKeyID = hdChain.masterKeyID;
            <span class="hljs-comment">// increment childkey index</span>
            hdChain.nExternalChainCounter++;
        } <span class="hljs-keyword">while</span>(HaveKey(childKey.key.GetPubKey().GetID()));
        secret = childKey.key;

        <span class="hljs-comment">// update the chain model in the database</span>
        <span class="hljs-keyword">if</span> (!CWalletDB(strWalletFile).WriteHDChain(hdChain))
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": Writing HD chain model failed"</span>);
    } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//2.如果在创建钱包的时候是使用随机钱包</span>
        secret.MakeNewKey(fCompressed);
    }

    <span class="hljs-comment">// Compressed public keys were introduced in version 0.6.0</span>
    <span class="hljs-keyword">if</span> (fCompressed)
        SetMinVersion(FEATURE_COMPRPUBKEY);
<span class="hljs-comment">//验证公钥</span>
    CPubKey pubkey = secret.GetPubKey();
    assert(secret.VerifyPubKey(pubkey));
<span class="hljs-comment">//判断第一把密钥的创建时间</span>
    mapKeyMetadata[pubkey.GetID()] = metadata;
    <span class="hljs-keyword">if</span> (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey)
        nTimeFirstKey = nCreationTime;

    <span class="hljs-keyword">if</span> (!AddKeyPubKey(secret, pubkey))
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": AddKey failed"</span>);
    <span class="hljs-keyword">return</span> pubkey;
}</code></pre> 
  <p>其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里<a href="https://blog.csdn.net/m0_37847176/article/details/82011876" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/82011876</a> <br> 如果是随机钱包，则调用CKey类的<code>MakeNewKey</code></p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//key.cpp</span>
<span class="hljs-keyword">void</span> CKey::MakeNewKey(<span class="hljs-keyword">bool</span> fCompressedIn) {
    <span class="hljs-keyword">do</span> {
        GetStrongRandBytes(vch, <span class="hljs-keyword">sizeof</span>(vch));<span class="hljs-comment"><span class="hljs-xmlDocTag">///</span>/! The actual byte data unsigned char vch[32];</span>
    } <span class="hljs-keyword">while</span> (!Check(vch));
    fValid = <span class="hljs-keyword">true</span>;
    fCompressed = fCompressedIn;
}</code></pre> 
  <p>具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 <br> 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 <br> 最后添加公钥，调用CWallet类的AddKeyPubKey</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//wallet.cpp</span>
<span class="hljs-keyword">bool</span> CWallet::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; secret, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    AssertLockHeld(cs_wallet); <span class="hljs-comment">// mapKeyMetadata</span>
    <span class="hljs-keyword">if</span> (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// check if we need to remove from watch-only</span>
    CScript script;
    script = GetScriptForDestination(pubkey.GetID());
    <span class="hljs-keyword">if</span> (HaveWatchOnly(script))
        RemoveWatchOnly(script);
    script = GetScriptForRawPubKey(pubkey);
    <span class="hljs-keyword">if</span> (HaveWatchOnly(script))
        RemoveWatchOnly(script);

    <span class="hljs-keyword">if</span> (!fFileBacked)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (!IsCrypted()) {
        <span class="hljs-keyword">return</span> CWalletDB(strWalletFile).WriteKey(pubkey,
                                                 secret.GetPrivKey(),
                                                 mapKeyMetadata[pubkey.GetID()]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>首先调用CCryptoKeyStore的<code>AddKeyPubKey</code>，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CCryptoKeyStore::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; key, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    {
        LOCK(cs_KeyStore);
        <span class="hljs-keyword">if</span> (!IsCrypted())<span class="hljs-comment">//是否激活加密</span>
            <span class="hljs-keyword">return</span> CBasicKeyStore::AddKeyPubKey(key, pubkey);

        <span class="hljs-keyword">if</span> (IsLocked())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchCryptedSecret;
        CKeyingMaterial vchSecret(key.begin(), key.end());
        <span class="hljs-keyword">if</span> (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">if</span> (!AddCryptedKey(pubkey, vchCryptedSecret))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>未激活加密私钥的话</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">bool</span> CBasicKeyStore::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; key, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    LOCK(cs_KeyStore);
    mapKeys[pubkey.GetID()] = key;<span class="hljs-comment">//私钥和公钥（hash值）保存在键值对mapKeys中</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>激活加密私钥 <br> 首先调用<code>EncryptSecret</code>加密秘密，接着添加加密的私钥</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CCryptoKeyStore::AddCryptedKey(<span class="hljs-keyword">const</span> CPubKey &amp;vchPubKey, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> &amp;vchCryptedSecret)
{
    {
        LOCK(cs_KeyStore);
        <span class="hljs-keyword">if</span> (!SetCrypted())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 <br> 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的<code>WriteKey</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CWalletDB::WriteKey(<span class="hljs-keyword">const</span> CPubKey&amp; vchPubKey, <span class="hljs-keyword">const</span> CPrivKey&amp; vchPrivKey, <span class="hljs-keyword">const</span> CKeyMetadata&amp; keyMeta)
{
    nWalletDBUpdated++;

    <span class="hljs-keyword">if</span> (!Write(<span class="hljs-built_in">std</span>::make_pair(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"keymeta"</span>), vchPubKey),
               keyMeta, <span class="hljs-keyword">false</span>))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// hash pubkey/privkey to accelerate wallet load</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchKey;
    vchKey.reserve(vchPubKey.size() + vchPrivKey.size());
    vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());
    vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());

    <span class="hljs-keyword">return</span> Write(<span class="hljs-built_in">std</span>::make_pair(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"key"</span>), vchPubKey), <span class="hljs-built_in">std</span>::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), <span class="hljs-keyword">false</span>);
}</code></pre> 
  <p>这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 <br> 加载钱包在<a href="https://blog.csdn.net/m0_37847176/article/details/81739999" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81739999</a>这一篇中</p> 
  <blockquote> 
   <p>Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。</p> 
  </blockquote> 
  <h2 id="base58编码">base58编码</h2> 
  <p>代码中使用的代码如下</p> 
  <pre class="prettyprint"><code class=" hljs mathematica">CBitcoinAddress(keyID).<span class="hljs-keyword">ToString</span>();</code></pre> 
  <blockquote> 
   <p>base58-encoded Bitcoin addresses. <br> Public-key-hash-addresses have version 0 (or 111 testnet). <br> The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. <br> Script-hash-addresses have version 5 (or 196 testnet). <br> The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. <br> 公钥哈希地址具有版本0（或111 测试网）。 <br> 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 <br> 脚本哈希地址具有版本5（或196 测试网）。 <br> 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。</p> 
  </blockquote> 
  <table> 
   <thead> 
    <tr> 
     <th>Type</th> 
     <th align="center">Version Prefix(hex)</th> 
     <th align="right">base58 result prefix</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>bitcoin address</td> 
     <td align="center">0x00</td> 
     <td align="right">1</td> 
    </tr> 
    <tr> 
     <td>bitcoin testnet address</td> 
     <td align="center">0x6f</td> 
     <td align="right">m、n</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses</td> 
     <td align="center">0x05</td> 
     <td align="right">3</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses testnet</td> 
     <td align="center">0xc4</td> 
     <td align="right"></td> 
    </tr> 
   </tbody>
  </table> 
  <p>下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。</p> 
  <pre class="prettyprint"><code class=" hljs cs">class CBitcoinAddress : <span class="hljs-keyword">public</span> CBase58Data {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">bool</span> <span class="hljs-title">Set</span>(<span class="hljs-keyword">const</span> CKeyID &amp;id);
    <span class="hljs-keyword">bool</span> Set(<span class="hljs-keyword">const</span> CScriptID &amp;id);
    <span class="hljs-keyword">bool</span> Set(<span class="hljs-keyword">const</span> CTxDestination &amp;dest);
    <span class="hljs-keyword">bool</span> IsValid() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> IsValid(<span class="hljs-keyword">const</span> CChainParams &amp;<span class="hljs-keyword">params</span>) <span class="hljs-keyword">const</span>;

    CBitcoinAddress() {}
    CBitcoinAddress(<span class="hljs-keyword">const</span> CTxDestination &amp;dest) { Set(dest); }
    CBitcoinAddress(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span>&amp; strAddress) { SetString(strAddress); }
    CBitcoinAddress(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszAddress) { SetString(pszAddress); }

    CTxDestination Get() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> GetKeyID(CKeyID &amp;keyID) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> IsScript() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <p>根据代码推测是调用了第三个或第四个构造函数，都是调用<code>SetString()</code>函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的<code>bool SetString(const char* psz, unsigned int nVersionBytes = 1);</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CBase58Data::SetString(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* psz, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nVersionBytes)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchTemp;
    <span class="hljs-keyword">bool</span> rc58 = DecodeBase58Check(psz, vchTemp);<span class="hljs-comment">//psz是要编码的内容，编码后临时存放</span>
    <span class="hljs-keyword">if</span> ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) {
        vchData.clear();
        vchVersion.clear();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);
    vchData.resize(vchTemp.size() - nVersionBytes);
    <span class="hljs-keyword">if</span> (!vchData.empty())
        <span class="hljs-built_in">memcpy</span>(&amp;vchData[<span class="hljs-number">0</span>], &amp;vchTemp[nVersionBytes], vchData.size());
    memory_cleanse(&amp;vchTemp[<span class="hljs-number">0</span>], vchTemp.size());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>这部分代码的逻辑不是很清晰</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> CBase58Data::ToString() <span class="hljs-keyword">const</span>
{
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vch = vchVersion;
    <span class="hljs-comment">//在vch的末尾插入vchData</span>
    vch.insert(vch.end(), vchData.begin(), vchData.end());
    <span class="hljs-keyword">return</span> EncodeBase58Check(vch);
}</code></pre> 
  <p>借用精通比特币的图，编码过程</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828145938928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h1 id="发送金额">发送金额</h1> 
  <p>这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起）</p> 
  <blockquote> 
   <p>/** <br> * A txout script template with a specific destination. It is either: <br> * * CNoDestination: no destination set <br> * * CKeyID: TX_PUBKEYHASH destination <br> * * CScriptID: TX_SCRIPTHASH destination <br> * A CTxDestination is the internal data type encoded in a CBitcoinAddress <br> */</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs ruby">typedef <span class="hljs-symbol">boost:</span><span class="hljs-symbol">:variant&lt;CNoDestination</span>, <span class="hljs-constant">CKeyID</span>, <span class="hljs-constant">CScriptID</span>&gt; <span class="hljs-constant">CTxDestination</span>;</code></pre> 
  <blockquote> 
   <p><code>CWalletTx</code>:A transaction with a bunch of additional info that only the owner cares about. <br> It includes any unrecorded transactions needed to link it back to the block chain.</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SendMoney(<span class="hljs-keyword">const</span> CTxDestination &amp;address, CAmount nValue, <span class="hljs-keyword">bool</span> fSubtractFeeFromAmount, CWalletTx&amp; wtxNew)
{
    CAmount curBalance = pwalletMain-&gt;GetBalance();

    <span class="hljs-comment">// 1.Check amount 检查余额</span>
    <span class="hljs-keyword">if</span> (nValue &lt;= <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_INVALID_PARAMETER, <span class="hljs-string">"Invalid amount"</span>);

    <span class="hljs-keyword">if</span> (nValue &gt; curBalance)
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, <span class="hljs-string">"Insufficient funds"</span>);

    <span class="hljs-comment">// 2.Parse Bitcoin address 解析比目的地，获得脚本</span>
    CScript scriptPubKey = GetScriptForDestination(address);

    <span class="hljs-comment">// 3.Create and send the transaction 创建并发送交易</span>
    CReserveKey reservekey(pwalletMain);
    CAmount nFeeRequired;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strError;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CRecipient&gt;</span> vecSend;
    <span class="hljs-keyword">int</span> nChangePosRet = -<span class="hljs-number">1</span>;
    CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};<span class="hljs-comment">//接收者（锁定脚本，金额，是否抽取费用）</span>
    vecSend.push_back(recipient);
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {
        <span class="hljs-keyword">if</span> (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance())
            strError = strprintf(<span class="hljs-string">"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!"</span>, FormatMoney(nFeeRequired));
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_ERROR, strError);
    }
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))<span class="hljs-comment">//提交交易</span>
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_ERROR, <span class="hljs-string">"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here."</span>);
}</code></pre> 
  <h2 id="getbalance">GetBalance()</h2> 
  <p>首先调用<code>GetBalance()</code>获取钱包的余额</p> 
  <pre class="prettyprint"><code class=" hljs cpp">CAmount CWallet::GetBalance() <span class="hljs-keyword">const</span>
{
    CAmount nTotal = <span class="hljs-number">0</span>;
    {
        LOCK2(cs_main, cs_wallet);
        <span class="hljs-keyword">for</span> (<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;uint256, CWalletTx&gt;</span>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
        {
            <span class="hljs-keyword">const</span> CWalletTx* pcoin = &amp;(*it).second;<span class="hljs-comment">//CWalletTx</span>
            <span class="hljs-keyword">if</span> (pcoin-&gt;IsTrusted())
                nTotal += pcoin-&gt;GetAvailableCredit();
        }
    }

    <span class="hljs-keyword">return</span> nTotal;
}</code></pre> 
  <h3 id="istrusted">IsTrusted()</h3> 
  <p>这里判断交易是否被信任</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">//wallet.cpp</span>
bool CWalletTx::IsTrusted() <span class="hljs-keyword">const</span>
{
    <span class="hljs-comment">// Quick answer in most cases</span>
    <span class="hljs-keyword">if</span> (!CheckFinalTx(*this))<span class="hljs-comment">//判断交易是否是最终的，函数内调用了IsFinalTx</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    int nDepth = GetDepthInMainChain();
    <span class="hljs-keyword">if</span> (nDepth &gt;= <span class="hljs-number">1</span>)<span class="hljs-comment">//交易所在区块后面的区块大于等于1即视为信任</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (nDepth &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) <span class="hljs-comment">// using wtx's cached debit</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// Don't trust unconfirmed transactions from us unless they are in the mempool.</span>
    <span class="hljs-keyword">if</span> (!InMempool())<span class="hljs-comment">//不信任不在内存池中的交易</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// Trusted if all inputs are from us and are in the mempool:</span>
    BOOST_FOREACH(<span class="hljs-keyword">const</span> CTxIn&amp; txin, vin)
    {
        <span class="hljs-comment">// Transactions not sent by us: not trusted</span>
        <span class="hljs-keyword">const</span> CWalletTx* <span class="hljs-keyword">parent</span> = pwallet-&gt;GetWalletTx(txin.prevout.hash);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span> == <span class="hljs-keyword">NULL</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">const</span> CTxOut&amp; parentOut = <span class="hljs-keyword">parent</span>-&gt;vout[txin.prevout.n];
        <span class="hljs-keyword">if</span> (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */</span>
bool IsFinalTx(<span class="hljs-keyword">const</span> CTransaction &amp;tx, <span class="hljs-keyword">int</span> nBlockHeight, int64_t nBlockTime);</code></pre> 
  <h3 id="getavailablecredit">GetAvailableCredit</h3> 
  <p>这里有几个逻辑</p> 
  <pre class="prettyprint"><code class=" hljs cpp">CAmount CWalletTx::GetAvailableCredit(<span class="hljs-keyword">bool</span> fUseCache) <span class="hljs-keyword">const</span>
{  
    <span class="hljs-keyword">if</span> (pwallet == <span class="hljs-number">0</span>)<span class="hljs-comment">//没有钱包信息则返回0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Must wait until coinbase is safely deep enough in the chain before valuing it</span>
    <span class="hljs-comment">//如果是coinbase交易，必须等这笔交易足够安全，否则返回0</span>
    <span class="hljs-keyword">if</span> (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (fUseCache &amp;&amp; fAvailableCreditCached)<span class="hljs-comment">//如果使用缓存数据</span>
        <span class="hljs-keyword">return</span> nAvailableCreditCached;

    CAmount nCredit = <span class="hljs-number">0</span>;
    uint256 hashTx = GetHash();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vout.size(); i++)
    {
        <span class="hljs-keyword">if</span> (!pwallet-&gt;IsSpent(hashTx, i))<span class="hljs-comment">//如果这笔交易的输出未支出</span>
        {
            <span class="hljs-keyword">const</span> CTxOut &amp;txout = vout[i];
            nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);<span class="hljs-comment">//我可以花费的部分</span>
            <span class="hljs-keyword">if</span> (!MoneyRange(nCredit))
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"CWalletTx::GetAvailableCredit() : value out of range"</span>);
        }
    }

    nAvailableCreditCached = nCredit;
    fAvailableCreditCached = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> nCredit;
}</code></pre> 
  <h2 id="createtransaction">CreateTransaction</h2> 
  <blockquote> 
   <p>/** <br> * Create a new transaction paying the recipients with a set of coins <br> * selected by SelectCoins(); Also create the change output, when needed <br> * @note passing nChangePosInOut as -1 will result in setting a random position <br> */</p> 
  </blockquote> 
  <p>这里的 SelectCoins()是选择一组币使得nValueRet &gt;= nTargetValue，大于或等于目标金额 <br> 鉴于这段代码很长，分段来讲</p> 
  <h3 id="1">1）</h3> 
  <p>参数</p> 
  <table> 
   <thead> 
    <tr> 
     <th>类型</th> 
     <th align="center">名称</th> 
     <th align="right">说明</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>vector<code>&lt;CRecipient&gt;</code></td> 
     <td align="center">vecSend</td> 
     <td align="right">struct CRecipient{CScript scriptPubKey;CAmount nAmount;bool fSubtractFeeFromAmount;}</td> 
    </tr> 
    <tr> 
     <td>CWalletTx&amp;</td> 
     <td align="center">wtxNew</td> 
     <td align="right">包含附加信息的交易信息，这个类只关注本钱包发起（可能包含接收）的交易</td> 
    </tr> 
    <tr> 
     <td>CReserveKey&amp;</td> 
     <td align="center">reservekey</td> 
     <td align="right">密钥池分配的密钥</td> 
    </tr> 
    <tr> 
     <td>CAmount&amp;</td> 
     <td align="center">nFeeRet</td> 
     <td align="right">CAmount nFeeRequired;未赋值</td> 
    </tr> 
    <tr> 
     <td>int&amp;</td> 
     <td align="center">nChangePosRet</td> 
     <td align="right">改变标志位？</td> 
    </tr> 
    <tr> 
     <td>std::string&amp;</td> 
     <td align="center">strFailReason</td> 
     <td align="right">失败的原因</td> 
    </tr> 
    <tr> 
     <td>CCoinControl*</td> 
     <td align="center">coinControl</td> 
     <td align="right">币控制功能</td> 
    </tr> 
    <tr> 
     <td>bool</td> 
     <td align="center">sign</td> 
     <td align="right">默认为true</td> 
    </tr> 
   </tbody>
  </table> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CWallet::CreateTransaction(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CRecipient&gt;</span>&amp; vecSend, CWalletTx&amp; wtxNew, CReserveKey&amp; reservekey, CAmount&amp; nFeeRet,
                                <span class="hljs-keyword">int</span>&amp; nChangePosInOut, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; strFailReason, <span class="hljs-keyword">const</span> CCoinControl* coinControl, <span class="hljs-keyword">bool</span> sign)
{
    CAmount nValue = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化为0</span>
    <span class="hljs-keyword">int</span> nChangePosRequest = nChangePosInOut;<span class="hljs-comment">//赋值</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nSubtractFeeFromAmount = <span class="hljs-number">0</span>;
    BOOST_FOREACH (<span class="hljs-keyword">const</span> CRecipient&amp; recipient, vecSend)<span class="hljs-comment">//解析接收者的信息</span>
    {
        <span class="hljs-keyword">if</span> (nValue &lt; <span class="hljs-number">0</span> || recipient.nAmount &lt; <span class="hljs-number">0</span>)
        {<span class="hljs-comment">//交易金额不能为负</span>
            strFailReason = _(<span class="hljs-string">"Transaction amounts must be positive"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        nValue += recipient.nAmount;<span class="hljs-comment">//计算总共要支付的</span>

        <span class="hljs-keyword">if</span> (recipient.fSubtractFeeFromAmount)
            nSubtractFeeFromAmount++;
    }
    <span class="hljs-keyword">if</span> (vecSend.empty() || nValue &lt; <span class="hljs-number">0</span>)
    {
        strFailReason = _(<span class="hljs-string">"Transaction amounts must be positive"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    wtxNew.fTimeReceivedIsTxTime = <span class="hljs-keyword">true</span>;
    wtxNew.BindWallet(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//绑定钱包</span>
    CMutableTransaction txNew;<span class="hljs-comment">//A mutable version of CTransaction.</span></code></pre> 
  <h3 id="2nlocktime">2）nLockTime</h3> 
  <p>nLockTime是交易类的成员变量，参考这篇 <br> <a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81624052#ctransaction</a> <br> 锁定时间也称为 nLocktime，是来自于 Bitcoin Core 代码库中使用的变量名称。在 大多数交易中将其设置为零，以指示即时传播和执行。如果 nLocktime 不为零， 低于 5 亿，则将其解释为块高度，这意味着交易无效，并且在指定的块高度之前 未被中继或包含在块链中。 <br> 如果超过 5 亿，它被解释为 Unix 纪元时间戳(自 Jan-1-1970 之后的秒数)，并且 交易在指定时间之前无效。指定未来块或时间的 nLocktime 的交易必须由始发系 统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的 nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会被中继到其他节点。使用 nLocktime 等同于一张延期支票。</p> 
  <blockquote> 
   <p>Discourage fee sniping.针对费用狙击 <br> For a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the current best block. By setting nLockTime such that only the next block can include the transaction, we discourage this practice as the height restricted and limited blocksize gives miners considering fee sniping fewer options for pulling off this attack. <br> A simple way to think about this is from the wallet’s point of view we always want the blockchain to move forward. By setting nLockTime this way we’re basically making the statement that we only want this transaction to appear in the next block; we don’t want to potentially encourage reorgs by allowing transactions to appear at lower heights than the next block in forks of the best chain. <br> Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isn’t a problem yet, but by implementing a fix now we ensure code won’t be written that makes assumptions about nLockTime that preclude a fix later. <br> 对于大型矿工而言，最佳区块和mempool中的交易价值可能超过尝试故意挖掘两个区块以孤立当前最佳区块的成本。通过设置nLockTime使得只有下一个区块可以包括交易，我们不鼓励这种做法，因为高度限制和有限的区块大小给矿工考虑费用狙击更少的选项来解除这种攻击。 <br> 考虑这个问题的一个简单方法是从钱包的角度来看，我们总是希望区块链能够向前发展。通过以这种方式设置nLockTime，我们基本上是在声明我们只希望此交易出现在下一个块中;我们不希望通过允许交易出现在比最佳链的下一个分叉块中更低的高度来促进重新排序。 <br> 当然，补贴足够高，交易量足够低，费用狙击就不是问题，但是现在通过实现一个修复，我们确保代码不会被编写对nLockTime进行假设，以防止以后修复。</p> 
  </blockquote> 
  <p>以下解说引用自《精通比特币（）》</p> 
  <blockquote> 
   <p>费用狙击是一种理论攻击情形，矿工试图从将来的块(挑选手续费较高的交易)重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 <br> 例如，假设存在的最高块是块#100,000。如果不是试图把#100,001 号的矿区扩 大到区块链，那么一些矿工们会试图重新挖矿#100,000。这些矿工可以选择在候 选块#100,000 中包括任何有效的交易(尚未开采)。他们不必使用相同的交易 来恢复块。事实上，他们有动力选择最有利可图(最高每 kBB)的交易来包含在 其中。它们可以包括处于“旧”#100,000 中的任何交易，以及来自当前内存池的 任何交易。当他们重新创建块#100,000 时，他们本质上可以将交易从“现在”提取 到重写的“过去”中。 <br> 今天，这种袭击并不是非常有利可图，因为回报奖励(因为包括 一定数量的比特币奖励)远远高于每个区块的总费用。但在未来的某个时候，交 易费将是奖励的大部分(甚至是奖励的整体)。那时候这种情况变得不可避免了。 <br> 为了防止“费用狙击”，当 Bitcoin Core /钱包 创建交易时，默认情况下，它使用 nLocktime 将它们限制为“下一个块”。在我们的环境中，Bitcoin Core /钱包将在任 何创建的交易上将 nLocktime 设置为 100,001。在正常情况下，这个 nLocktime 没 有任何效果 - 交易只能包含在#100,001 块中，这是下一个区块。 但是在区块链 分叉攻击的情况下，由于所有这些交易都将被时间锁阻止在#100,001，所以矿工 们无法从筹码中提取高额交易。他们只能在当时有效的任何交易中重新挖矿 #100,000，这导致实质上不会获得新的费用。 为了实现这一点，Bitcoin Core/钱 包将所有新交易的 nLocktime 设置为，并将所有输入上的 nSequence 设置为 0xFFFFFFFE 以启用 nLocktime。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs avrasm">txNew<span class="hljs-preprocessor">.nLockTime</span> = chainActive<span class="hljs-preprocessor">.Height</span>()<span class="hljs-comment">;//当前有效区块的高度</span></code></pre> 
  <blockquote> 
   <p>Secondly occasionally randomly pick a nLockTime even further back, so that transactions that are delayed after signing for whatever reason, e.g. high-latency mix networks and some CoinJoin implementations, have better privacy. <br> 接着偶尔（0.1的概率）随机获取一个甚至可能更早的nLockTime，以便签名后的交易因任意原因延迟，比如高延迟混合网络和一些CoinJoin实现，有更好的隐私性。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs avrasm">if (GetRandInt(<span class="hljs-number">10</span>) == <span class="hljs-number">0</span>)
        txNew<span class="hljs-preprocessor">.nLockTime</span> = <span class="hljs-keyword">std</span>::max(<span class="hljs-number">0</span>, (int)txNew<span class="hljs-preprocessor">.nLockTime</span> - GetRandInt(<span class="hljs-number">100</span>))<span class="hljs-comment">;</span>

    assert(txNew<span class="hljs-preprocessor">.nLockTime</span> &lt;= (unsigned int)chainActive<span class="hljs-preprocessor">.Height</span>())<span class="hljs-comment">;</span>
    assert(txNew<span class="hljs-preprocessor">.nLockTime</span> &lt; LOCKTIME_THRESHOLD)<span class="hljs-comment">;</span></code></pre> 
  <hr> 
  <h3 id="3vouts">3）vouts</h3> 
  <pre class="prettyprint"><code class=" hljs cpp">{
        LOCK2(cs_main, cs_wallet);
        {
            <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;COutput&gt;</span> vAvailableCoins;
            <span class="hljs-comment">//用可用的交易输出填充vAvailableCoins，vAvailableCoins就是可用的交易输出</span>
            AvailableCoins(vAvailableCoins, <span class="hljs-keyword">true</span>, coinControl);

            nFeeRet = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// Start with no fee and loop until there is enough fee</span>
            <span class="hljs-comment">//循环直到有足够的交易金额</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)
            {
            <span class="hljs-comment">//初始化工作，清零</span>
                nChangePosInOut = nChangePosRequest;
                txNew.vin.clear();
                txNew.vout.clear();
                txNew.wit.SetNull();
                wtxNew.fFromMe = <span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">bool</span> fFirst = <span class="hljs-keyword">true</span>;

                CAmount nValueToSelect = nValue;<span class="hljs-comment">//初始为0</span>
                <span class="hljs-keyword">if</span> (nSubtractFeeFromAmount == <span class="hljs-number">0</span>)
                    nValueToSelect += nFeeRet;
                <span class="hljs-keyword">double</span> dPriority = <span class="hljs-number">0</span>;</code></pre> 
  <p>对每个接收者的处理，对每个接收者创建一个CTxOut <br> <a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81624052#ctxout</a></p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// vouts to the payees</span>
                BOOST_FOREACH (<span class="hljs-keyword">const</span> CRecipient&amp; recipient, vecSend)
                {
                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);

                    <span class="hljs-keyword">if</span> (recipient.fSubtractFeeFromAmount)
                    {
                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; <span class="hljs-comment">// Subtract fee equally from each selected recipient</span>


<span class="hljs-comment">//第一个接收者支出不能被总输出整除的剩余</span>
                        <span class="hljs-keyword">if</span> (fFirst) <span class="hljs-comment">// first receiver pays the remainder not divisible by output count</span>
                        {
                            fFirst = <span class="hljs-keyword">false</span>;
                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;
                        }
                    }
<span class="hljs-comment">//如果这个输出是Dust输出，也就是交易输出太小，称为灰尘交易</span>
                    <span class="hljs-keyword">if</span> (txout.IsDust(::minRelayTxFee))
                    {
                        <span class="hljs-keyword">if</span> (recipient.fSubtractFeeFromAmount &amp;&amp; nFeeRet &gt; <span class="hljs-number">0</span>)
                        {
                            <span class="hljs-keyword">if</span> (txout.nValue &lt; <span class="hljs-number">0</span>)
                                strFailReason = _(<span class="hljs-string">"The transaction amount is too small to pay the fee"</span>);
                            <span class="hljs-keyword">else</span>
                                strFailReason = _(<span class="hljs-string">"The transaction amount is too small to send after the fee has been deducted"</span>);
                        }
                        <span class="hljs-keyword">else</span>
                            strFailReason = _(<span class="hljs-string">"Transaction amount too small"</span>);
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                    }
                    txNew.vout.push_back(txout);<span class="hljs-comment">//写入交易的输出部分</span>
                }</code></pre> 
  <hr> 
  <h3 id="4">4)</h3> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// Choose coins to use</span>
<span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;pair&lt;<span class="hljs-keyword">const</span> CWalletTx*,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;</span> &gt; setCoins;
CAmount nValueIn = <span class="hljs-number">0</span>;
<span class="hljs-comment">//Shuffle and select coins until nTargetValue is reached while avoiding small change;</span>
<span class="hljs-comment">//打乱重排并选择可用的coins直到达到nTargetValue同时避免小的找零，这里是指到达nValueToSelect </span>
<span class="hljs-comment">//setCoins包含支付给你本人地址的交易，即你所拥有的币 </span>
<span class="hljs-keyword">if</span> (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl))
{
  strFailReason = _(<span class="hljs-string">"Insufficient funds"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
<span class="hljs-comment">//对选择好的这一组coins的每个来源计算优先级</span>
BOOST_FOREACH(PAIRTYPE(<span class="hljs-keyword">const</span> CWalletTx*, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) pcoin, setCoins)
{
    CAmount nCredit = pcoin.first-&gt;vout[pcoin.second].nValue;
    <span class="hljs-comment">//The coin age after the next block (depth+1) is used instead of the current,</span>
    <span class="hljs-comment">//reflecting an assumption the user would accept a bit more delay for</span>
    <span class="hljs-comment">//a chance at a free transaction.</span>
    <span class="hljs-comment">//But mempool inputs might still be in the mempool, so their age stays 0</span>
    <span class="hljs-comment">/*用下一个块（深度+ 1）之后的硬币年龄而不是当前，这反映了一个假设，即用户可以接受更多延迟以获得免费交易的机会。但是mempool输入可能仍然在mempool中， 所以他们的年龄保持在0*/</span>
    <span class="hljs-keyword">int</span> age = pcoin.first-&gt;GetDepthInMainChain();
    assert(age &gt;= <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (age != <span class="hljs-number">0</span>)
       age += <span class="hljs-number">1</span>;
    dPriority += (<span class="hljs-keyword">double</span>)nCredit * age;<span class="hljs-comment">//增加优先级</span>
}</code></pre> 
  <hr> 
  <h3 id="5找零">5）找零</h3> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">const</span> CAmount nChange = nValueIn - nValueToSelect;<span class="hljs-comment">//超出所需支出，那么需要找零</span>
<span class="hljs-keyword">if</span> (nChange &gt; <span class="hljs-number">0</span>)
 {
<span class="hljs-comment">// Fill a vout to ourself</span>
<span class="hljs-comment">// TODO: pass in scriptChange instead of reservekey so</span>
<span class="hljs-comment">// change transaction isn't always pay-to-bitcoin-address</span>
<span class="hljs-comment">/*为自己填写一个vout *TODO：传入scriptChange而不是reservekey，因此找零交易并不总是付费到比特币地址*/</span>
    CScript scriptChange;

    <span class="hljs-comment">// coin control: send change to custom address找零支付回习惯地址，如果设置的话</span>
     <span class="hljs-keyword">if</span> (coinControl &amp;&amp; !boost::<span class="hljs-keyword">get</span>&lt;CNoDestination&gt;(&amp;coinControl-&gt;destChange))
           scriptChange = GetScriptForDestination(coinControl-&gt;destChange);

     <span class="hljs-comment">// no coin control: send change to newly generated address</span>
     <span class="hljs-comment">//没有coin control，默认没有设置，那么找零到一个新创建的地址</span>
      <span class="hljs-keyword">else</span>
      {
       <span class="hljs-comment">// Note: We use a new key here to keep it from being obvious which side is the change.</span>
       <span class="hljs-comment">// The drawback is that by not reusing a previous key, the change may be lost if a</span>
       <span class="hljs-comment">// backup is restored, if the backup doesn't have the new private key for the change.</span>
       <span class="hljs-comment">// If we reused the old key, it would be possible to add code to look for and</span>
       <span class="hljs-comment">// rediscover unknown transactions that were written with keys of ours to recover</span>
       <span class="hljs-comment">// post-backup change.</span>
      <span class="hljs-comment">/*我们使用一个新的密钥避免找零地址变得明显。缺点是不重复使用之前的密钥，如果没有备份用于找零的新私钥， *则在恢复备份时可能会丢失找零。如果我们重复使用老的密钥，那么有可能通过添加代码去查找和重新发现 *用我们的密钥编写的未明确的交易以恢复备份后的更改*/</span>
      <span class="hljs-comment">// Reserve a new key pair from key pool 从密钥池中预约一个新的密钥</span>
          CPubKey vchPubKey;
          <span class="hljs-keyword">bool</span> ret;
          ret = reservekey.GetReservedKey(vchPubKey);
          <span class="hljs-keyword">if</span> (!ret)
          {
                strFailReason = _(<span class="hljs-string">"Keypool ran out, please call keypoolrefill first"</span>);
                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }

           scriptChange = GetScriptForDestination(vchPubKey.GetID());
                    }
       CTxOut newTxOut(nChange, scriptChange);<span class="hljs-comment">//新建一笔找零交易</span></code></pre> 
  <p>这里的意思是使用我们之前生成过的保留在钱包中的密钥 <br> 上述代码调用<code>reservekey</code>的<code>GetReservedKey</code>，<code>reservekey</code>是传入的参数</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">bool</span> CReserveKey::GetReservedKey(CPubKey&amp; pubkey)
{
    <span class="hljs-keyword">if</span> (nIndex == -<span class="hljs-number">1</span>)
    {
        CKeyPool keypool;
        pwallet-&gt;ReserveKeyFromKeyPool(nIndex, keypool);
        <span class="hljs-keyword">if</span> (nIndex != -<span class="hljs-number">1</span>)
            vchPubKey = keypool.vchPubKey;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }
    <span class="hljs-keyword">assert</span>(vchPubKey.IsValid());
    pubkey = vchPubKey;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p><code>GetReservedKey</code>调用<code>CWallet</code>类的<code>ReserveKeyFromKeyPool</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> CWallet::ReserveKeyFromKeyPool(int64_t&amp; nIndex, CKeyPool&amp; keypool)
{
    nIndex = -<span class="hljs-number">1</span>;
    keypool.vchPubKey = CPubKey();<span class="hljs-comment">//构造一个无效的PubKey</span>
    {
        LOCK(cs_wallet);

        <span class="hljs-keyword">if</span> (!IsLocked())
            TopUpKeyPool();<span class="hljs-comment">//充值密钥池，这个函数里一个循环，默认创建（最少）100个新的密钥添加到池中</span>

        <span class="hljs-comment">// Get the oldest key </span>
        <span class="hljs-keyword">if</span>(setKeyPool.empty())
            <span class="hljs-keyword">return</span>;

        CWalletDB walletdb(strWalletFile);

        nIndex = *(setKeyPool.begin());<span class="hljs-comment">//返回容器指向的第一个元素</span>
        setKeyPool.erase(setKeyPool.begin());<span class="hljs-comment">//擦除这个指针指向的元素</span>
        <span class="hljs-keyword">if</span> (!walletdb.ReadPool(nIndex, keypool))
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": read failed"</span>);
        <span class="hljs-keyword">if</span> (!HaveKey(keypool.vchPubKey.GetID()))
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": unknown key in key pool"</span>);
        assert(keypool.vchPubKey.IsValid());
        LogPrintf(<span class="hljs-string">"keypool reserve %d\n"</span>, nIndex);
    }
}</code></pre> 
  <p>需要注意这里的setKeyPool是signd long long的set容器类型 <br> 在日志信息中可以看到，创建了101把密钥，从1到101，也就是原本这个池中一把都没有，这个池应该是专门用于找零的池子，虽然密钥都是保存在键值对中，但是找零专用的密钥对写在池中“pool“，调用<code>WritePool</code>函数，另一种是写在‘keymate‘中 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827170709446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 发送测试币回2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF <br> 使用rpc指令 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827155338293?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 创建两笔交易</p> 
  <pre class="prettyprint"><code class=" hljs ruby">parallels<span class="hljs-variable">@parallels</span>-<span class="hljs-symbol">vm:</span>~<span class="hljs-variable">$ </span>bitcoin-cli walletpassphrase aser6789dfgb <span class="hljs-number">300</span>
parallels<span class="hljs-variable">@parallels</span>-<span class="hljs-symbol">vm:</span>~<span class="hljs-variable">$ </span>bitcoin-cli sendtoaddress <span class="hljs-string">"2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF"</span> <span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">441</span>bb6516409b37f0b2da928cf4691ff0508f99f5481add15d608ee39ee59b04
parallels<span class="hljs-variable">@parallels</span>-<span class="hljs-symbol">vm:</span>~<span class="hljs-variable">$ </span>bitcoin-cli getbalance
<span class="hljs-number">1.09896799</span>
parallels<span class="hljs-variable">@parallels</span>-<span class="hljs-symbol">vm:</span>~<span class="hljs-variable">$ </span>bitcoin-cli sendtoaddress <span class="hljs-string">"2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF"</span> <span class="hljs-number">0</span>.<span class="hljs-number">2</span>
aceeee8102eb3a922521edb784bf890e29c26e3336ab8e99b5430fc71345b641
parallels<span class="hljs-variable">@parallels</span>-<span class="hljs-symbol">vm:</span>~<span class="hljs-variable">$ </span>
</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827155901752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 第一笔交易输出找零到mpCjnRXL2mVbFBU77ixWsCJ88JyqfU2g1c，作为第二笔交易的输入 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827160155945?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180827160045373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 在创建三笔交易，创建一个地址，创建一个交易 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018082716174691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <hr> 
  <h3 id="6dust-output">6）dust output</h3> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// Never create dust outputs; if we would, just</span>
                    <span class="hljs-comment">// add the dust to the fee.</span>
                    <span class="hljs-keyword">if</span> (newTxOut.IsDust(::minRelayTxFee))
                    {
                        nChangePosInOut = -<span class="hljs-number">1</span>;
                        nFeeRet += nChange;
                        reservekey.ReturnKey();
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        <span class="hljs-keyword">if</span> (nChangePosInOut == -<span class="hljs-number">1</span>)
                        {
                            <span class="hljs-comment">// Insert change txn at random position:</span>
                            nChangePosInOut = GetRandInt(txNew.vout.size()+<span class="hljs-number">1</span>);
                        }
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)nChangePosInOut &gt; txNew.vout.size())
                        {
                            strFailReason = _(<span class="hljs-string">"Change index out of range"</span>);
                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                        }

                        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CTxOut&gt;</span>::iterator position = txNew.vout.begin()+nChangePosInOut;
                        txNew.vout.insert(position, newTxOut);
                    }
                }
                <span class="hljs-keyword">else</span>
                    reservekey.ReturnKey();</code></pre> 
  <hr> 
  <h3 id="7vin-sign">7）vin &amp; sign</h3> 
  <p>涉及vin的序列号，这个类写在这里<a href="https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81624052#ctxin</a></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// Fill vin</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note how the sequence number is set to max()-1 so that the</span>
<span class="hljs-comment">// nLockTime set above actually works.</span>
BOOST_FOREACH(<span class="hljs-keyword">const</span> PAIRTYPE(<span class="hljs-keyword">const</span> CWalletTx*,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)&amp; coin, setCoins)
    txNew.vin.push_back(CTxIn(coin.first-&gt;GetHash(),coin.second,CScript(),<span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;::max()-<span class="hljs-number">1</span>));</code></pre> 
  <p>这里设置输入交易容器vin，对于每一笔setCoins中的交易coin,构造CTxIn对象，使用的构造函数<code>CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);</code>第1、2个参数用于构造COutPoint，第3、4个参数是CTxIn的成员变量，这里设置序列号为max()-1，不是SEQUENCE_FINAL（=max()），因此nLockTime实际是有效的。最后将CTxIn逐个加入容器的底部。 <br> 接下来看签名</p> 
  <pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">// Sign</span>
<span class="hljs-keyword">int</span> nIn = <span class="hljs-number">0</span>;
CTransaction txNewConst(txNew);
BOOST_FOREACH(<span class="hljs-keyword">const</span> PAIRTYPE(<span class="hljs-keyword">const</span> CWalletTx*,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)&amp; coin, setCoins)
    {
        <span class="hljs-keyword">bool</span> signSuccess;
        <span class="hljs-keyword">const</span> CScript&amp; scriptPubKey = coin<span class="hljs-variable">.first</span>-&gt;vout[coin<span class="hljs-variable">.second</span>]<span class="hljs-variable">.scriptPubKey</span>;
        SignatureData sigdata;
        <span class="hljs-keyword">if</span> (sign)
        <span class="hljs-comment">//非隔离见证的交易</span>
            signSuccess = ProduceSignature(TransactionSignatureCreator(<span class="hljs-keyword">this</span>, &amp;txNewConst, nIn, coin<span class="hljs-variable">.first</span>-&gt;vout[coin<span class="hljs-variable">.second</span>]<span class="hljs-variable">.nValue</span>, SIGHASH_ALL), scriptPubKey, sigdata);
         <span class="hljs-keyword">else</span>
         <span class="hljs-comment">//使用隔离见证的交易，这里使用空的签名，在交易本身之外包含一个隔离见证</span>
             signSuccess = ProduceSignature(DummySignatureCreator(<span class="hljs-keyword">this</span>), scriptPubKey, sigdata);

           <span class="hljs-keyword">if</span> (!signSuccess)
               {
                   strFailReason = _(<span class="hljs-string">"Signing transaction failed"</span>);
                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//从交易中抽取签名数据然后插入</span>
                   UpdateTransaction(txNew, nIn, sigdata);
                }

           nIn++;
          }</code></pre> 
  <p>对于setCoins的每一笔交易coin，coin.first是CWalletTx的指针，CWalletTx没有成员变量，不过他的父类<code>CMerkleTx</code>的父类<code>CTransaction</code>有vout成员变量，通过序号获取对应的那一笔交易的锁定脚本scriptPubKey。 <br> 调用函数<code>ProduceSignature</code>使用通用签名创建者生成脚本签名</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//sign.h</span>
<span class="hljs-javadoc">/** Produce a script signature using a generic signature creator. */</span>
bool ProduceSignature(<span class="hljs-keyword">const</span> BaseSignatureCreator&amp; creator, <span class="hljs-keyword">const</span> CScript&amp; scriptPubKey, SignatureData&amp; sigdata);</code></pre> 
  <hr> 
  <p>8）判断</p> 
  <pre class="prettyprint"><code class=" hljs cpp"> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nBytes = GetVirtualTransactionSize(txNew);

                <span class="hljs-comment">// Remove scriptSigs if we used dummy signatures for fee calculation</span>
                <span class="hljs-keyword">if</span> (!sign) {
                    BOOST_FOREACH (CTxIn&amp; vin, txNew.vin)
                        vin.scriptSig = CScript();
                    txNew.wit.SetNull();
                }

                <span class="hljs-comment">// Embed the constructed transaction data in wtxNew.</span>
                *<span class="hljs-keyword">static_cast</span>&lt;CTransaction*&gt;(&amp;wtxNew) = CTransaction(txNew);

                <span class="hljs-comment">// Limit size限制大小</span>
                <span class="hljs-keyword">if</span> (GetTransactionWeight(txNew) &gt;= MAX_STANDARD_TX_WEIGHT)
                {
                    strFailReason = _(<span class="hljs-string">"Transaction too large"</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }

                dPriority = wtxNew.ComputePriority(dPriority, nBytes);

                <span class="hljs-comment">// Can we complete this as a free transaction?</span>
                <span class="hljs-comment">//构造一个免费的交易，费用不够的话用优先级来凑</span>
                <span class="hljs-keyword">if</span> (fSendFreeTransactions &amp;&amp; nBytes &lt;= MAX_FREE_TRANSACTION_CREATE_SIZE)<span class="hljs-comment">//默认值分别为false、1000</span>
                {
                    <span class="hljs-comment">// Not enough fee: enough priority?</span>
                    <span class="hljs-keyword">double</span> dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget);
                    <span class="hljs-comment">// Require at least hard-coded AllowFree.</span>
                    <span class="hljs-keyword">if</span> (dPriority &gt;= dPriorityNeeded &amp;&amp; AllowFree(dPriority))
                        <span class="hljs-keyword">break</span>;
                }
<span class="hljs-comment">//获取最小交易费</span>
                CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool);
                <span class="hljs-keyword">if</span> (coinControl &amp;&amp; nFeeNeeded &gt; <span class="hljs-number">0</span> &amp;&amp; coinControl-&gt;nMinimumTotalFee &gt; nFeeNeeded) {
                    nFeeNeeded = coinControl-&gt;nMinimumTotalFee;
                }
                <span class="hljs-keyword">if</span> (coinControl &amp;&amp; coinControl-&gt;fOverrideFeeRate)
                    nFeeNeeded = coinControl-&gt;nFeeRate.GetFee(nBytes);

                <span class="hljs-comment">// If we made it here and we aren't even able to meet the relay fee on the next pass, give up</span>
                <span class="hljs-comment">// because we must be at the maximum allowed fee.</span>
                <span class="hljs-keyword">if</span> (nFeeNeeded &lt; ::minRelayTxFee.GetFee(nBytes))
                {
                    strFailReason = _(<span class="hljs-string">"Transaction too large for fee policy"</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }

                <span class="hljs-keyword">if</span> (nFeeRet &gt;= nFeeNeeded)
                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Done, enough fee included.</span>

                <span class="hljs-comment">// Include more fee and try again.</span>
                nFeeRet = nFeeNeeded;
                <span class="hljs-keyword">continue</span>;
            }
        }
    }</code></pre> 
  <p>到这里循环结束</p> 
  <hr> 
  <h3 id="9参数读取">9）参数读取</h3> 
  <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">if</span> (GetBoolArg(<span class="hljs-string">"-walletrejectlongchains"</span>, DEFAULT_WALLET_REJECT_LONG_CHAINS)) {
        <span class="hljs-comment">// Lastly, ensure this tx will pass the mempool's chain limits</span>
        LockPoints lp;
        CTxMemPoolEntry entry(txNew, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, lp);
        CTxMemPool<span class="hljs-tag">::setEntries</span> setAncestors;
        size_t nLimitAncestors <span class="hljs-subst">=</span> GetArg(<span class="hljs-string">"-limitancestorcount"</span>, DEFAULT_ANCESTOR_LIMIT);
        size_t nLimitAncestorSize <span class="hljs-subst">=</span> GetArg(<span class="hljs-string">"-limitancestorsize"</span>, DEFAULT_ANCESTOR_SIZE_LIMIT)<span class="hljs-subst">*</span><span class="hljs-number">1000</span>;
        size_t nLimitDescendants <span class="hljs-subst">=</span> GetArg(<span class="hljs-string">"-limitdescendantcount"</span>, DEFAULT_DESCENDANT_LIMIT);
        size_t nLimitDescendantSize <span class="hljs-subst">=</span> GetArg(<span class="hljs-string">"-limitdescendantsize"</span>, DEFAULT_DESCENDANT_SIZE_LIMIT)<span class="hljs-subst">*</span><span class="hljs-number">1000</span>;
        std<span class="hljs-tag">::string</span> errString;
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>mempool<span class="hljs-built_in">.</span>CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {
            strFailReason <span class="hljs-subst">=</span> _(<span class="hljs-string">"Transaction has too long of a mempool chain"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</code></pre> 
  <p>那么到这里就创建完交易了，接下来提交交易。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
