<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【剑指区块链项目开发】小册（一）去中心化应用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【剑指区块链项目开发】小册（一）去中心化应用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，转载请注明出处，欢迎转载！喜欢右上角点个赞鼓励一下，谢谢！ https://blog.csdn.net/ImagineCode/article/details/82143125 微信扫一扫，关注小智链习社，更多关于区块链的技术文章第一时间奉上！ 1.1 什么是DApp 网络中不存在能够完全控制DApp的节点。 这些对等节点（peer）可以是网络中的任何计算节点，因此，发现 和防止节点对应用数据进行非法篡改或者与其他人分享错误信息是一个 重要挑战。 所以需要对等节点之间有一些关于某个节点发布的数据是否正确的共识。 在DApp中，没有一个中心服务器来协调节点，或者决定什么是对、什么是错，因此应对这个挑战确实不容易。 一致性协议（concensus protocol）可用于解决这个问题。 不同的DApp通常使用不同数据结构类型的共识协议，例如比特币使用工作量证明协议（PoW）来达成共识。 为了让用户使用DApp，每一个DApp都需要一个客户端（client）。 使用DApp时，用户首先需要运行DApp中自己的节点服务端，然后将客户端连接至节点服务端。 客户端通常作为服务和/或节点形式出现，以便让使用DApp的过程更容易。 Tip:中心化应用可能是分布式的，也可能不是分布式的，但去中心化应用肯定是分布式的。 DApp的缺点： 修改bug或者更新DApp很困难，因为网络中的每一个节点都需要 更新其节点软件。 一些应用要求验证用户身份（即KYC），却没有中心化的机构来 验证用户身份，开发应用时会遇到问题 创建去中心化应用比较困难 应用通常独立于第三方API，以获取或者存储数据。DApp不能依 赖中心化应用API，但是可以依赖其他DApp。 1.2 去中心化自治组织 DAO：去中心化自治组织。DAO是DApp的一个子类。 1.3 DApp中的用户身份 因为DApp中没有中央机构，验证用户身份成了一个挑战。 在现实生活中，用户做交易时，通常会自己验证对方的身份或者可以请一个机构来验证身份，这个想法也可以应用到DApp中。在进行交易之前，用户可以手动验证彼此的身份，这个想法适用于人们彼此进行交易的DApp。假设有一个DApp是去中心化的社交网络，显然可以通过这种方式验证身份信息。假设一个DApp是用来买卖商品的，在支付之前买卖双方可以验证彼此的身份，尽管这个想法看起来是可行的，但是在实践中很难实现，因为你可能并不想每次进行交易的时候都验证身份，也不是每个人都知道如何验证身份。 由于这些原因，我们目前剩下的可选择方案是，由提供客户端的公司派人手动验证用户身份。例如，创建一个比特币账户不需要身份证明，但是当提取比特币并兑换成货币时，交易所会要求提供身份证明。客户端可以忽略未经验证的用户，不让他们使用，也可以对已经身份验证的用户开放使用。这个解决办法也会产生一些小问题，即如果转换客户端，会发现交互的用户不一样了，因为不同的客户端有不同的验证用户集。因此，所有用户可能决定只使用一个特定客户端。但这不是一个很大的问题，因为如果客户端不能有效验证用户，用户就可以方便地转向另一个客户端，而且不丢失关键数据，因为关键数据的存储是去中心化的。 用什么过程来验证用户身份并不重要，用户总有办法伪装成其他人；用数字身份或者用扫描文件进行验证并不重要，因为二者都可能被盗或者被重复使用。重要的是让用户难以伪装成其他人，并收集足够的数据追踪用户，证明该用户进行了一些欺诈行为。 1.4 DAPP中的用户账户 有多种方法能实现DApp中的用户账户，最热门的方式是使用公钥-私钥对（public-private key pair）来代表一个账户。公钥的哈希（hash）是账户的唯一身份。为了改变账户中的数据，用户需要用私钥签名。如果用户丢失私钥，就永远不能访问账户了。 1.5 访问中心化应用 一些情况下，DApp需要从中心化应用中抓取数据。 但主要问题是DApp如何知道从一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应？根据DApp架构的不同，解决办法也有所不同。 例如在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人。 Oraclize为从中心化服务智能合约中抓取的数据提供TLSNotary验证。 1.6　DApp中的内部货币 DApp节点需要硬件和网络资源才能维持运行。 DApp节点需要一些有用的回报来维持运行，于是内部货币登场了。大多数DApp都有内置内部货币，或者可以说最成功的DApp都有内置内部货币。 共识协议决定节点收取多少内部货币。根据共识协议，只有为维护DApp安全和运行做出贡献的那些特定节点可以赚取货币，只进行数据读取的节点没有回报。例如在比特币中，只有矿工（miner）成功挖矿才能赚取比特币。 1.7　什么是授权的DApp 授权的DApp继承了免权限DApp的全部属性，但需要权限才能参与到网络中去。各种授权的DApp用到的权限系统不同。 要加入一个授权的Dapp就需要权限，授权的DApp没有内部货币。 这部分内容比较枯燥，但却是理解DApp的基础。 欢迎关注微信公众号“小智链习社”，我会在上面推出更多源码文章。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，转载请注明出处，欢迎转载！喜欢右上角点个赞鼓励一下，谢谢！ https://blog.csdn.net/ImagineCode/article/details/82143125 微信扫一扫，关注小智链习社，更多关于区块链的技术文章第一时间奉上！ 1.1 什么是DApp 网络中不存在能够完全控制DApp的节点。 这些对等节点（peer）可以是网络中的任何计算节点，因此，发现 和防止节点对应用数据进行非法篡改或者与其他人分享错误信息是一个 重要挑战。 所以需要对等节点之间有一些关于某个节点发布的数据是否正确的共识。 在DApp中，没有一个中心服务器来协调节点，或者决定什么是对、什么是错，因此应对这个挑战确实不容易。 一致性协议（concensus protocol）可用于解决这个问题。 不同的DApp通常使用不同数据结构类型的共识协议，例如比特币使用工作量证明协议（PoW）来达成共识。 为了让用户使用DApp，每一个DApp都需要一个客户端（client）。 使用DApp时，用户首先需要运行DApp中自己的节点服务端，然后将客户端连接至节点服务端。 客户端通常作为服务和/或节点形式出现，以便让使用DApp的过程更容易。 Tip:中心化应用可能是分布式的，也可能不是分布式的，但去中心化应用肯定是分布式的。 DApp的缺点： 修改bug或者更新DApp很困难，因为网络中的每一个节点都需要 更新其节点软件。 一些应用要求验证用户身份（即KYC），却没有中心化的机构来 验证用户身份，开发应用时会遇到问题 创建去中心化应用比较困难 应用通常独立于第三方API，以获取或者存储数据。DApp不能依 赖中心化应用API，但是可以依赖其他DApp。 1.2 去中心化自治组织 DAO：去中心化自治组织。DAO是DApp的一个子类。 1.3 DApp中的用户身份 因为DApp中没有中央机构，验证用户身份成了一个挑战。 在现实生活中，用户做交易时，通常会自己验证对方的身份或者可以请一个机构来验证身份，这个想法也可以应用到DApp中。在进行交易之前，用户可以手动验证彼此的身份，这个想法适用于人们彼此进行交易的DApp。假设有一个DApp是去中心化的社交网络，显然可以通过这种方式验证身份信息。假设一个DApp是用来买卖商品的，在支付之前买卖双方可以验证彼此的身份，尽管这个想法看起来是可行的，但是在实践中很难实现，因为你可能并不想每次进行交易的时候都验证身份，也不是每个人都知道如何验证身份。 由于这些原因，我们目前剩下的可选择方案是，由提供客户端的公司派人手动验证用户身份。例如，创建一个比特币账户不需要身份证明，但是当提取比特币并兑换成货币时，交易所会要求提供身份证明。客户端可以忽略未经验证的用户，不让他们使用，也可以对已经身份验证的用户开放使用。这个解决办法也会产生一些小问题，即如果转换客户端，会发现交互的用户不一样了，因为不同的客户端有不同的验证用户集。因此，所有用户可能决定只使用一个特定客户端。但这不是一个很大的问题，因为如果客户端不能有效验证用户，用户就可以方便地转向另一个客户端，而且不丢失关键数据，因为关键数据的存储是去中心化的。 用什么过程来验证用户身份并不重要，用户总有办法伪装成其他人；用数字身份或者用扫描文件进行验证并不重要，因为二者都可能被盗或者被重复使用。重要的是让用户难以伪装成其他人，并收集足够的数据追踪用户，证明该用户进行了一些欺诈行为。 1.4 DAPP中的用户账户 有多种方法能实现DApp中的用户账户，最热门的方式是使用公钥-私钥对（public-private key pair）来代表一个账户。公钥的哈希（hash）是账户的唯一身份。为了改变账户中的数据，用户需要用私钥签名。如果用户丢失私钥，就永远不能访问账户了。 1.5 访问中心化应用 一些情况下，DApp需要从中心化应用中抓取数据。 但主要问题是DApp如何知道从一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应？根据DApp架构的不同，解决办法也有所不同。 例如在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人。 Oraclize为从中心化服务智能合约中抓取的数据提供TLSNotary验证。 1.6　DApp中的内部货币 DApp节点需要硬件和网络资源才能维持运行。 DApp节点需要一些有用的回报来维持运行，于是内部货币登场了。大多数DApp都有内置内部货币，或者可以说最成功的DApp都有内置内部货币。 共识协议决定节点收取多少内部货币。根据共识协议，只有为维护DApp安全和运行做出贡献的那些特定节点可以赚取货币，只进行数据读取的节点没有回报。例如在比特币中，只有矿工（miner）成功挖矿才能赚取比特币。 1.7　什么是授权的DApp 授权的DApp继承了免权限DApp的全部属性，但需要权限才能参与到网络中去。各种授权的DApp用到的权限系统不同。 要加入一个授权的Dapp就需要权限，授权的DApp没有内部货币。 这部分内容比较枯燥，但却是理解DApp的基础。 欢迎关注微信公众号“小智链习社”，我会在上面推出更多源码文章。 阅读更多 登录后自动展开" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，转载请注明出处，欢迎转载！喜欢右上角点个赞鼓励一下，谢谢！ https://blog.csdn.net/ImagineCode/article/details/82143125 微信扫一扫，关注小智链习社，更多关于区块链的技术文章第一时间奉上！ 1.1 什么是DApp 网络中不存在能够完全控制DApp的节点。 这些对等节点（peer）可以是网络中的任何计算节点，因此，发现 和防止节点对应用数据进行非法篡改或者与其他人分享错误信息是一个 重要挑战。 所以需要对等节点之间有一些关于某个节点发布的数据是否正确的共识。 在DApp中，没有一个中心服务器来协调节点，或者决定什么是对、什么是错，因此应对这个挑战确实不容易。 一致性协议（concensus protocol）可用于解决这个问题。 不同的DApp通常使用不同数据结构类型的共识协议，例如比特币使用工作量证明协议（PoW）来达成共识。 为了让用户使用DApp，每一个DApp都需要一个客户端（client）。 使用DApp时，用户首先需要运行DApp中自己的节点服务端，然后将客户端连接至节点服务端。 客户端通常作为服务和/或节点形式出现，以便让使用DApp的过程更容易。 Tip:中心化应用可能是分布式的，也可能不是分布式的，但去中心化应用肯定是分布式的。 DApp的缺点： 修改bug或者更新DApp很困难，因为网络中的每一个节点都需要 更新其节点软件。 一些应用要求验证用户身份（即KYC），却没有中心化的机构来 验证用户身份，开发应用时会遇到问题 创建去中心化应用比较困难 应用通常独立于第三方API，以获取或者存储数据。DApp不能依 赖中心化应用API，但是可以依赖其他DApp。 1.2 去中心化自治组织 DAO：去中心化自治组织。DAO是DApp的一个子类。 1.3 DApp中的用户身份 因为DApp中没有中央机构，验证用户身份成了一个挑战。 在现实生活中，用户做交易时，通常会自己验证对方的身份或者可以请一个机构来验证身份，这个想法也可以应用到DApp中。在进行交易之前，用户可以手动验证彼此的身份，这个想法适用于人们彼此进行交易的DApp。假设有一个DApp是去中心化的社交网络，显然可以通过这种方式验证身份信息。假设一个DApp是用来买卖商品的，在支付之前买卖双方可以验证彼此的身份，尽管这个想法看起来是可行的，但是在实践中很难实现，因为你可能并不想每次进行交易的时候都验证身份，也不是每个人都知道如何验证身份。 由于这些原因，我们目前剩下的可选择方案是，由提供客户端的公司派人手动验证用户身份。例如，创建一个比特币账户不需要身份证明，但是当提取比特币并兑换成货币时，交易所会要求提供身份证明。客户端可以忽略未经验证的用户，不让他们使用，也可以对已经身份验证的用户开放使用。这个解决办法也会产生一些小问题，即如果转换客户端，会发现交互的用户不一样了，因为不同的客户端有不同的验证用户集。因此，所有用户可能决定只使用一个特定客户端。但这不是一个很大的问题，因为如果客户端不能有效验证用户，用户就可以方便地转向另一个客户端，而且不丢失关键数据，因为关键数据的存储是去中心化的。 用什么过程来验证用户身份并不重要，用户总有办法伪装成其他人；用数字身份或者用扫描文件进行验证并不重要，因为二者都可能被盗或者被重复使用。重要的是让用户难以伪装成其他人，并收集足够的数据追踪用户，证明该用户进行了一些欺诈行为。 1.4 DAPP中的用户账户 有多种方法能实现DApp中的用户账户，最热门的方式是使用公钥-私钥对（public-private key pair）来代表一个账户。公钥的哈希（hash）是账户的唯一身份。为了改变账户中的数据，用户需要用私钥签名。如果用户丢失私钥，就永远不能访问账户了。 1.5 访问中心化应用 一些情况下，DApp需要从中心化应用中抓取数据。 但主要问题是DApp如何知道从一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应？根据DApp架构的不同，解决办法也有所不同。 例如在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人。 Oraclize为从中心化服务智能合约中抓取的数据提供TLSNotary验证。 1.6　DApp中的内部货币 DApp节点需要硬件和网络资源才能维持运行。 DApp节点需要一些有用的回报来维持运行，于是内部货币登场了。大多数DApp都有内置内部货币，或者可以说最成功的DApp都有内置内部货币。 共识协议决定节点收取多少内部货币。根据共识协议，只有为维护DApp安全和运行做出贡献的那些特定节点可以赚取货币，只进行数据读取的节点没有回报。例如在比特币中，只有矿工（miner）成功挖矿才能赚取比特币。 1.7　什么是授权的DApp 授权的DApp继承了免权限DApp的全部属性，但需要权限才能参与到网络中去。各种授权的DApp用到的权限系统不同。 要加入一个授权的Dapp就需要权限，授权的DApp没有内部货币。 这部分内容比较枯燥，但却是理解DApp的基础。 欢迎关注微信公众号“小智链习社”，我会在上面推出更多源码文章。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"/2018/08/28/b1541e5e876cfaf12aa06343ba65638c.html","headline":"【剑指区块链项目开发】小册（一）去中心化应用","dateModified":"2018-08-28T00:00:00+08:00","datePublished":"2018-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/28/b1541e5e876cfaf12aa06343ba65638c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【剑指区块链项目开发】小册（一）去中心化应用</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，转载请注明出处，欢迎转载！喜欢右上角点个赞鼓励一下，谢谢！ https://blog.csdn.net/ImagineCode/article/details/82143125 
 </div> 
 <div class="markdown_views"> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828095227603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ltYWdpbmVDb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <hr> 
  <p>微信扫一扫，关注<strong>小智链习社</strong>，更多关于区块链的技术文章第一时间奉上！</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018090116135235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ltYWdpbmVDb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h3 id="11-什么是dapp">1.1 什么是DApp</h3> 
  <p>网络中不存在能够完全控制DApp的节点。 <br> 这些对等节点（peer）可以是网络中的任何计算节点，因此，发现 <br> 和防止节点对应用数据进行非法篡改或者与其他人分享错误信息是一个 <br> 重要挑战。 <br> <strong>所以需要对等节点之间有一些关于某个节点发布的数据是否正确的共识。</strong></p> 
  <p>在DApp中，没有一个中心服务器来协调节点，或者决定什么是对、什么是错，因此应对这个挑战确实不容易。</p> 
  <p><strong>一致性协议</strong>（concensus protocol）可用于解决这个问题。</p> 
  <p>不同的DApp通常使用不同数据结构类型的共识协议，例如比特币使用工作量证明协议（PoW）来达成共识。</p> 
  <p>为了让用户使用DApp，每一个DApp都需要一个客户端（client）。 <br> 使用DApp时，用户首先需要运行DApp中自己的节点服务端，然后将客户端连接至节点服务端。</p> 
  <p>客户端通常作为服务和/或节点形式出现，以便让使用DApp的过程更容易。</p> 
  <p>Tip:中心化应用可能是分布式的，也可能不是分布式的，但去中心化应用肯定是分布式的。</p> 
  <p><strong>DApp的缺点：</strong></p> 
  <ul> 
   <li><p>修改bug或者更新DApp很困难，因为网络中的每一个节点都需要 <br> 更新其节点软件。</p></li> 
   <li><p>一些应用要求验证用户身份（即KYC），却没有中心化的机构来 <br> 验证用户身份，开发应用时会遇到问题</p></li> 
   <li><p>创建去中心化应用比较困难</p></li> 
   <li><p>应用通常独立于第三方API，以获取或者存储数据。DApp不能依 <br> 赖中心化应用API，但是可以依赖其他DApp。</p></li> 
  </ul> 
  <h3 id="12-去中心化自治组织">1.2 去中心化自治组织</h3> 
  <p>DAO：去中心化自治组织。DAO是DApp的一个子类。</p> 
  <h3 id="13-dapp中的用户身份">1.3 DApp中的用户身份</h3> 
  <p><strong>因为DApp中没有中央机构，验证用户身份成了一个挑战。</strong></p> 
  <p>在现实生活中，用户做交易时，通常会自己验证对方的身份或者可以请一个机构来验证身份，这个想法也可以应用到DApp中。在进行交易之前，用户可以手动验证彼此的身份，这个想法适用于人们彼此进行交易的DApp。假设有一个DApp是去中心化的社交网络，显然可以通过这种方式验证身份信息。假设一个DApp是用来买卖商品的，在支付之前买卖双方可以验证彼此的身份，尽管这个想法看起来是可行的，但是在实践中很难实现，因为你可能并不想每次进行交易的时候都验证身份，也不是每个人都知道如何验证身份。</p> 
  <p>由于这些原因，我们目前剩下的可选择方案是，由提供客户端的公司派人手动验证用户身份。例如，创建一个比特币账户不需要身份证明，但是当提取比特币并兑换成货币时，交易所会要求提供身份证明。客户端可以忽略未经验证的用户，不让他们使用，也可以对已经身份验证的用户开放使用。这个解决办法也会产生一些小问题，即如果转换客户端，会发现交互的用户不一样了，因为不同的客户端有不同的验证用户集。因此，所有用户可能决定只使用一个特定客户端。但这不是一个很大的问题，因为如果客户端不能有效验证用户，用户就可以方便地转向另一个客户端，而且不丢失关键数据，因为关键数据的存储是去中心化的。</p> 
  <p>用什么过程来验证用户身份并不重要，用户总有办法伪装成其他人；用数字身份或者用扫描文件进行验证并不重要，因为二者都可能被盗或者被重复使用。<strong>重要的是让用户难以伪装成其他人，并收集足够的数据追踪用户，证明该用户进行了一些欺诈行为。</strong></p> 
  <h3 id="14-dapp中的用户账户">1.4 DAPP中的用户账户</h3> 
  <p>有多种方法能实现DApp中的用户账户，<strong>最热门的方式是使用公钥-私钥对（public-private key pair）来代表一个账户</strong>。公钥的哈希（hash）是账户的唯一身份。为了改变账户中的数据，用户需要用私钥签名。如果用户丢失私钥，就永远不能访问账户了。</p> 
  <h3 id="15-访问中心化应用">1.5 访问中心化应用</h3> 
  <p>一些情况下，DApp需要从中心化应用中抓取数据。 <br> 但主要问题是DApp如何知道从一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应？根据DApp架构的不同，解决办法也有所不同。</p> 
  <p><strong>例如在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人。</strong> Oraclize为从中心化服务智能合约中抓取的数据提供TLSNotary验证。</p> 
  <h3 id="16-dapp中的内部货币">1.6　DApp中的内部货币</h3> 
  <p><strong>DApp节点需要硬件和网络资源才能维持运行。</strong> DApp节点需要一些有用的回报来维持运行，于是内部货币登场了。大多数DApp都有内置内部货币，或者可以说最成功的DApp都有内置内部货币。</p> 
  <p>共识协议决定节点收取多少内部货币。根据共识协议，只有为维护DApp安全和运行做出贡献的那些特定节点可以赚取货币，只进行数据读取的节点没有回报。例如在比特币中，只有矿工（miner）成功挖矿才能赚取比特币。</p> 
  <h3 id="17-什么是授权的dapp">1.7　什么是授权的DApp</h3> 
  <p>授权的DApp继承了免权限DApp的全部属性，但需要权限才能参与到网络中去。各种授权的DApp用到的权限系统不同。</p> 
  <p>要加入一个授权的Dapp就需要权限，授权的DApp没有内部货币。</p> 
  <blockquote> 
   <p>这部分内容比较枯燥，但却是理解DApp的基础。</p> 
  </blockquote> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828100401612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ltYWdpbmVDb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>欢迎关注微信公众号“<strong>小智链习社</strong>”，我会在上面推出更多源码文章。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180829213721169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ltYWdpbmVDb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/82143125,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/82143125,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/82143125,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ImagineCode/article/details/82143125,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
