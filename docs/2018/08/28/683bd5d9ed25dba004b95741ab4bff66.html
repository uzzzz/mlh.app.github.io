<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码-一个交易的产生（一）–生成地址，构造交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码-一个交易的产生（一）–生成地址，构造交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \&quot;account\&quot; )\n&quot; &quot;\nReturns a new Bitcoin address for receiving payments.\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\n&quot; &quot;\nArguments:\n&quot; &quot;1. \&quot;account\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n&quot; &quot;\nResult:\n&quot; &quot;\&quot;bitcoinaddress\&quot; (string) The new bitcoin address\n&quot; &quot;\nExamples:\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多 登录后自动展开" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。 生成比特币地址 从钱包的rpc指令getnewaddress开始看，先来看下调用结果 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 然后在日志信息中会增加相应的记录 下面来看这个指定对应调用的函数 getnewaddress 位于/src/rpc/wallet/rpcwallet.cpp UniValue getnewaddress(const UniValue&amp; params, bool fHelp) { if (!EnsureWalletIsAvailable(fHelp)) return NullUniValue; if (fHelp || params.size() &gt; 1) throw runtime_error( &quot;getnewaddress ( \\&quot;account\\&quot; )\\n&quot; &quot;\\nReturns a new Bitcoin address for receiving payments.\\n&quot; &quot;If &#39;account&#39; is specified (DEPRECATED), it is added to the address book \\n&quot; &quot;so payments received with the address will be credited to &#39;account&#39;.\\n&quot; &quot;\\nArguments:\\n&quot; &quot;1. \\&quot;account\\&quot; (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\&quot;\\&quot; is used. It can also be set to the empty string \\&quot;\\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n&quot; &quot;\\nResult:\\n&quot; &quot;\\&quot;bitcoinaddress\\&quot; (string) The new bitcoin address\\n&quot; &quot;\\nExamples:\\n&quot; + HelpExampleCli(&quot;getnewaddress&quot;, &quot;&quot;) + HelpExampleRpc(&quot;getnewaddress&quot;, &quot;&quot;) ); LOCK2(cs_main, pwalletMain-&gt;cs_wallet); // Parse the account first so we don&#39;t generate a key if there&#39;s an error string strAccount; if (params.size() &gt; 0) strAccount = AccountFromValue(params[0]); if (!pwalletMain-&gt;IsLocked()) pwalletMain-&gt;TopUpKeyPool(); // Generate a new key that is added to wallet CPubKey newKey; if (!pwalletMain-&gt;GetKeyFromPool(newKey)) throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, &quot;Error: Keypool ran out, please call keypoolrefill first&quot;); CKeyID keyID = newKey.GetID();//获取的是hash160的值 //pwalletMain是CWllat类的指针 pwalletMain-&gt;SetAddressBook(keyID, strAccount, &quot;receive&quot;); //CBitcoinAddress函数调用Base58编码转换 return CBitcoinAddress(keyID).ToString(); } 这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。 GetKeyFromPool 在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥 //src/wallet/wallet.cpp bool CWallet::GetKeyFromPool(CPubKey&amp; result) { int64_t nIndex = 0; CKeyPool keypool; { LOCK(cs_wallet); ReserveKeyFromKeyPool(nIndex, keypool); if (nIndex == -1) { if (IsLocked()) return false; result = GenerateNewKey(); return true; } KeepKey(nIndex); result = keypool.vchPubKey; } return true; } GenerateNewKey CKey可以参考https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck里面有写到这个类，以及makenewkey()的实现 -usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start CPubKey CWallet::GenerateNewKey() { AssertLockHeld(cs_wallet); // mapKeyMetadata bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets // CKey是私钥的类 CKey secret; // Create new metadata int64_t nCreationTime = GetTime(); CKeyMetadata metadata(nCreationTime); // use HD key derivation if HD was enabled during wallet creation //1.如果在钱包创建时使用确定分层钱包，则使用HD密钥 if (!hdChain.masterKeyID.IsNull()) { // for now we use a fixed keypath scheme of m/0&#39;/0&#39;/k CKey key; //master key seed (256bit) CExtKey masterKey; //hd master key CExtKey accountKey; //key at m/0&#39; CExtKey externalChainChildKey; //key at m/0&#39;/0&#39; CExtKey childKey; //key at m/0&#39;/0&#39;/&lt;n&gt;&#39; // try to get the master key if (!GetKey(hdChain.masterKeyID, key)) throw std::runtime_error(std::string(__func__) + &quot;: Master key not found&quot;); masterKey.SetMaster(key.begin(), key.size()); // derive m/0&#39; 派生 // use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32) //使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000; masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT); // derive m/0&#39;/0&#39; accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT); // derive child key at next index, skip keys already known to the wallet do { // always derive hardened keys // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649 externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT); metadata.hdKeypath = &quot;m/0&#39;/0&#39;/&quot;+std::to_string(hdChain.nExternalChainCounter)+&quot;&#39;&quot;; metadata.hdMasterKeyID = hdChain.masterKeyID; // increment childkey index hdChain.nExternalChainCounter++; } while(HaveKey(childKey.key.GetPubKey().GetID())); secret = childKey.key; // update the chain model in the database if (!CWalletDB(strWalletFile).WriteHDChain(hdChain)) throw std::runtime_error(std::string(__func__) + &quot;: Writing HD chain model failed&quot;); } else { //2.如果在创建钱包的时候是使用随机钱包 secret.MakeNewKey(fCompressed); } // Compressed public keys were introduced in version 0.6.0 if (fCompressed) SetMinVersion(FEATURE_COMPRPUBKEY); //验证公钥 CPubKey pubkey = secret.GetPubKey(); assert(secret.VerifyPubKey(pubkey)); //判断第一把密钥的创建时间 mapKeyMetadata[pubkey.GetID()] = metadata; if (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey) nTimeFirstKey = nCreationTime; if (!AddKeyPubKey(secret, pubkey)) throw std::runtime_error(std::string(__func__) + &quot;: AddKey failed&quot;); return pubkey; } 其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里https://blog.csdn.net/m0_37847176/article/details/82011876 如果是随机钱包，则调用CKey类的MakeNewKey //key.cpp void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(vch, sizeof(vch));////! The actual byte data unsigned char vch[32]; } while (!Check(vch)); fValid = true; fCompressed = fCompressedIn; } 具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 最后添加公钥，调用CWallet类的AddKeyPubKey //wallet.cpp bool CWallet::AddKeyPubKey(const CKey&amp; secret, const CPubKey &amp;pubkey) { AssertLockHeld(cs_wallet); // mapKeyMetadata if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) return false; // check if we need to remove from watch-only CScript script; script = GetScriptForDestination(pubkey.GetID()); if (HaveWatchOnly(script)) RemoveWatchOnly(script); script = GetScriptForRawPubKey(pubkey); if (HaveWatchOnly(script)) RemoveWatchOnly(script); if (!fFileBacked) return true; if (!IsCrypted()) { return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]); } return true; } 首先调用CCryptoKeyStore的AddKeyPubKey，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。 bool CCryptoKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { { LOCK(cs_KeyStore); if (!IsCrypted())//是否激活加密 return CBasicKeyStore::AddKeyPubKey(key, pubkey); if (IsLocked()) return false; std::vector&lt;unsigned char&gt; vchCryptedSecret; CKeyingMaterial vchSecret(key.begin(), key.end()); if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) return false; if (!AddCryptedKey(pubkey, vchCryptedSecret)) return false; } return true; } 未激活加密私钥的话 bool CBasicKeyStore::AddKeyPubKey(const CKey&amp; key, const CPubKey &amp;pubkey) { LOCK(cs_KeyStore); mapKeys[pubkey.GetID()] = key;//私钥和公钥（hash值）保存在键值对mapKeys中 return true; } 激活加密私钥 首先调用EncryptSecret加密秘密，接着添加加密的私钥 bool CCryptoKeyStore::AddCryptedKey(const CPubKey &amp;vchPubKey, const std::vector&lt;unsigned char&gt; &amp;vchCryptedSecret) { { LOCK(cs_KeyStore); if (!SetCrypted()) return false; mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret); } return true; } 把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的WriteKey bool CWalletDB::WriteKey(const CPubKey&amp; vchPubKey, const CPrivKey&amp; vchPrivKey, const CKeyMetadata&amp; keyMeta) { nWalletDBUpdated++; if (!Write(std::make_pair(std::string(&quot;keymeta&quot;), vchPubKey), keyMeta, false)) return false; // hash pubkey/privkey to accelerate wallet load std::vector&lt;unsigned char&gt; vchKey; vchKey.reserve(vchPubKey.size() + vchPrivKey.size()); vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end()); vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end()); return Write(std::make_pair(std::string(&quot;key&quot;), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false); } 这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 加载钱包在https://blog.csdn.net/m0_37847176/article/details/81739999这一篇中 Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。 base58编码 代码中使用的代码如下 CBitcoinAddress(keyID).ToString(); base58-encoded Bitcoin addresses. Public-key-hash-addresses have version 0 (or 111 testnet). The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. Script-hash-addresses have version 5 (or 196 testnet). The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. 公钥哈希地址具有版本0（或111 测试网）。 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 脚本哈希地址具有版本5（或196 测试网）。 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。 Type Version Prefix(hex) base58 result prefix bitcoin address 0x00 1 bitcoin testnet address 0x6f m、n Script-hash-addresses 0x05 3 Script-hash-addresses testnet 0xc4 下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。 class CBitcoinAddress : public CBase58Data { public: bool Set(const CKeyID &amp;id); bool Set(const CScriptID &amp;id); bool Set(const CTxDestination &amp;dest); bool IsValid() const; bool IsValid(const CChainParams &amp;params) const; CBitcoinAddress() {} CBitcoinAddress(const CTxDestination &amp;dest) { Set(dest); } CBitcoinAddress(const std::string&amp; strAddress) { SetString(strAddress); } CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); } CTxDestination Get() const; bool GetKeyID(CKeyID &amp;keyID) const; bool IsScript() const; }; 根据代码推测是调用了第三个或第四个构造函数，都是调用SetString()函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的bool SetString(const char* psz, unsigned int nVersionBytes = 1); bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) { std::vector&lt;unsigned char&gt; vchTemp; bool rc58 = DecodeBase58Check(psz, vchTemp);//psz是要编码的内容，编码后临时存放 if ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) { vchData.clear(); vchVersion.clear(); return false; } vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes); vchData.resize(vchTemp.size() - nVersionBytes); if (!vchData.empty()) memcpy(&amp;vchData[0], &amp;vchTemp[nVersionBytes], vchData.size()); memory_cleanse(&amp;vchTemp[0], vchTemp.size()); return true; } 这部分代码的逻辑不是很清晰 std::string CBase58Data::ToString() const { std::vector&lt;unsigned char&gt; vch = vchVersion; //在vch的末尾插入vchData vch.insert(vch.end(), vchData.begin(), vchData.end()); return EncodeBase58Check(vch); } 借用精通比特币的图，编码过程 发送金额 这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起） /** * A txout script template with a specific destination. It is either: * * CNoDestination: no destination set * * CKeyID: TX_PUBKEYHASH destination * * CScriptID: TX_SCRIPTHASH destination * A CTxDestination is the internal data type encoded in a CBitcoinAddress */ typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID&gt; CTxDestination; CWalletTx:A transaction with a bunch of additional info that only the owner cares about. It includes any unrecorded transactions needed to link it back to the block chain. static void SendMoney(const CTxDestination &amp;address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx&amp; wtxNew) { CAmount curBalance = pwalletMain-&gt;GetBalance(); // 1.Check amount 检查余额 if (nValue &lt;= 0) throw JSONRPCError(RPC_INVALID_PARAMETER, &quot;Invalid amount&quot;); if (nValue &gt; curBalance) throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, &quot;Insufficient funds&quot;); // 2.Parse Bitcoin address 解析比目的地，获得脚本 CScript scriptPubKey = GetScriptForDestination(address); // 3.Create and send the transaction 创建并发送交易 CReserveKey reservekey(pwalletMain); CAmount nFeeRequired; std::string strError; vector&lt;CRecipient&gt; vecSend; int nChangePosRet = -1; CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};//接收者（锁定脚本，金额，是否抽取费用） vecSend.push_back(recipient); if (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) { if (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance()) strError = strprintf(&quot;Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!&quot;, FormatMoney(nFeeRequired)); throw JSONRPCError(RPC_WALLET_ERROR, strError); } if (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))//提交交易 throw JSONRPCError(RPC_WALLET_ERROR, &quot;Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.&quot;); } GetBalance() 首先调用GetBalance()获取钱包的余额 CAmount CWallet::GetBalance() const { CAmount nTotal = 0; { LOCK2(cs_main, cs_wallet); for (map&lt;uint256, CWalletTx&gt;::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) { const CWalletTx* pcoin = &amp;(*it).second;//CWalletTx if (pcoin-&gt;IsTrusted()) nTotal += pcoin-&gt;GetAvailableCredit(); } } return nTotal; } IsTrusted() 这里判断交易是否被信任 //wallet.cpp bool CWalletTx::IsTrusted() const { // Quick answer in most cases if (!CheckFinalTx(*this))//判断交易是否是最终的，函数内调用了IsFinalTx return false; int nDepth = GetDepthInMainChain(); if (nDepth &gt;= 1)//交易所在区块后面的区块大于等于1即视为信任 return true; if (nDepth &lt; 0) return false; if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx&#39;s cached debit return false; // Don&#39;t trust unconfirmed transactions from us unless they are in the mempool. if (!InMempool())//不信任不在内存池中的交易 return false; // Trusted if all inputs are from us and are in the mempool: BOOST_FOREACH(const CTxIn&amp; txin, vin) { // Transactions not sent by us: not trusted const CWalletTx* parent = pwallet-&gt;GetWalletTx(txin.prevout.hash); if (parent == NULL) return false; const CTxOut&amp; parentOut = parent-&gt;vout[txin.prevout.n]; if (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE) return false; } return true; } //main.h /** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */ bool IsFinalTx(const CTransaction &amp;tx, int nBlockHeight, int64_t nBlockTime); GetAvailableCredit 这里有几个逻辑 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const { if (pwallet == 0)//没有钱包信息则返回0 return 0; // Must wait until coinbase is safely deep enough in the chain before valuing it //如果是coinbase交易，必须等这笔交易足够安全，否则返回0 if (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; 0) return 0; if (fUseCache &amp;&amp; fAvailableCreditCached)//如果使用缓存数据 return nAvailableCreditCached; CAmount nCredit = 0; uint256 hashTx = GetHash(); for (unsigned int i = 0; i &lt; vout.size(); i++) { if (!pwallet-&gt;IsSpent(hashTx, i))//如果这笔交易的输出未支出 { const CTxOut &amp;txout = vout[i]; nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);//我可以花费的部分 if (!MoneyRange(nCredit)) throw std::runtime_error(&quot;CWalletTx::GetAvailableCredit() : value out of range&quot;); } } nAvailableCreditCached = nCredit; fAvailableCreditCached = true; return nCredit; } 太长了，分开写到另一篇创建一个交易 阅读更多 登录后自动展开","@type":"BlogPosting","url":"/2018/08/28/683bd5d9ed25dba004b95741ab4bff66.html","headline":"比特币源码-一个交易的产生（一）–生成地址，构造交易","dateModified":"2018-08-28T00:00:00+08:00","datePublished":"2018-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/28/683bd5d9ed25dba004b95741ab4bff66.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码-一个交易的产生（一）--生成地址，构造交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37847176/article/details/81906838 
 </div> 
 <div class="markdown_views"> 
  <p>在这一篇里系统得讲讲客户端/钱包如何生成比特币地址，并创建一个交易 <br> 我们知道比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥并不存储在网络中，而是由客户端生成后保存在名为钱包的文件（wallet.dat）或者简单的数据库中。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。</p> 
  <h1 id="生成比特币地址">生成比特币地址</h1> 
  <p>从钱包的rpc指令getnewaddress开始看，先来看下调用结果 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821144451891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 可以看到是返回一个比特币地址（测试网），如果是主网的话是以1开头的地址 <br> 然后在日志信息中会增加相应的记录 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180821151439657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 下面来看这个指定对应调用的函数</p> 
  <h2 id="getnewaddress">getnewaddress</h2> 
  <p>位于/src/rpc/wallet/rpcwallet.cpp</p> 
  <pre class="prettyprint"><code class=" hljs cs">UniValue getnewaddress(<span class="hljs-keyword">const</span> UniValue&amp; <span class="hljs-keyword">params</span>, <span class="hljs-keyword">bool</span> fHelp)
{
    <span class="hljs-keyword">if</span> (!EnsureWalletIsAvailable(fHelp))
        <span class="hljs-keyword">return</span> NullUniValue;

    <span class="hljs-keyword">if</span> (fHelp || <span class="hljs-keyword">params</span>.size() &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">throw</span> runtime_error(
            <span class="hljs-string">"getnewaddress ( \"account\" )\n"</span>
            <span class="hljs-string">"\nReturns a new Bitcoin address for receiving payments.\n"</span>
            <span class="hljs-string">"If 'account' is specified (DEPRECATED), it is added to the address book \n"</span>
            <span class="hljs-string">"so payments received with the address will be credited to 'account'.\n"</span>
            <span class="hljs-string">"\nArguments:\n"</span>
            <span class="hljs-string">"1. \"account\" (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \"\" is used. It can also be set to the empty string \"\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\n"</span>
            <span class="hljs-string">"\nResult:\n"</span>
            <span class="hljs-string">"\"bitcoinaddress\" (string) The new bitcoin address\n"</span>
            <span class="hljs-string">"\nExamples:\n"</span>
            + HelpExampleCli(<span class="hljs-string">"getnewaddress"</span>, <span class="hljs-string">""</span>)
            + HelpExampleRpc(<span class="hljs-string">"getnewaddress"</span>, <span class="hljs-string">""</span>)
        );

    LOCK2(cs_main, pwalletMain-&gt;cs_wallet);

    <span class="hljs-comment">// Parse the account first so we don't generate a key if there's an error</span>
    <span class="hljs-keyword">string</span> strAccount;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">params</span>.size() &gt; <span class="hljs-number">0</span>)
        strAccount = AccountFromValue(<span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;IsLocked())
        pwalletMain-&gt;TopUpKeyPool();

    <span class="hljs-comment">// Generate a new key that is added to wallet</span>
    CPubKey newKey;
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;GetKeyFromPool(newKey))
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, <span class="hljs-string">"Error: Keypool ran out, please call keypoolrefill first"</span>);
    CKeyID keyID = newKey.GetID();<span class="hljs-comment">//获取的是hash160的值</span>
<span class="hljs-comment">//pwalletMain是CWllat类的指针</span>
    pwalletMain-&gt;SetAddressBook(keyID, strAccount, <span class="hljs-string">"receive"</span>);
<span class="hljs-comment">//CBitcoinAddress函数调用Base58编码转换</span>
    <span class="hljs-keyword">return</span> CBitcoinAddress(keyID).ToString();
}</code></pre> 
  <p>这里的pwalletMain是指向CWallet类对象的指针。生成一个新的密钥在这里是通过调用函数GetKeyFromPool。可以看到这段代码最后是调用CBitcoinAddress函数返回比特币地址。</p> 
  <h2 id="getkeyfrompool">GetKeyFromPool</h2> 
  <p>在这个函数中首先调用ReserveKeyFromKeyPool查看密钥储备池中的密钥，如果没有储备的密钥，就通过GenerateNewKey生成一个新的密钥，否则根据索引获取储备池中的下一个密钥</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//src/wallet/wallet.cpp</span>
<span class="hljs-keyword">bool</span> CWallet::GetKeyFromPool(CPubKey&amp; result)
{
    int64_t nIndex = <span class="hljs-number">0</span>;
    CKeyPool keypool;
    {
        LOCK(cs_wallet);
        ReserveKeyFromKeyPool(nIndex, keypool);
        <span class="hljs-keyword">if</span> (nIndex == -<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span> (IsLocked()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            result = GenerateNewKey();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        KeepKey(nIndex);
        result = keypool.vchPubKey;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <h3 id="generatenewkey">GenerateNewKey</h3> 
  <p>CKey可以参考<a href="https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81450432#2-initsanitycheck</a>里面有写到这个类，以及makenewkey()的实现</p> 
  <blockquote> 
   <p>-usehd:Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cpp">CPubKey CWallet::GenerateNewKey()
{
    AssertLockHeld(cs_wallet); <span class="hljs-comment">// mapKeyMetadata</span>
    <span class="hljs-keyword">bool</span> fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); <span class="hljs-comment">// default to compressed public keys if we want 0.6.0 wallets</span>
    <span class="hljs-comment">// CKey是私钥的类</span>
    CKey secret;

    <span class="hljs-comment">// Create new metadata</span>
    int64_t nCreationTime = GetTime();
    CKeyMetadata metadata(nCreationTime);

    <span class="hljs-comment">// use HD key derivation if HD was enabled during wallet creation </span>
    <span class="hljs-comment">//1.如果在钱包创建时使用确定分层钱包，则使用HD密钥</span>
    <span class="hljs-keyword">if</span> (!hdChain.masterKeyID.IsNull()) {
        <span class="hljs-comment">// for now we use a fixed keypath scheme of m/0'/0'/k</span>
        CKey key;                      <span class="hljs-comment">//master key seed (256bit)</span>
        CExtKey masterKey;             <span class="hljs-comment">//hd master key</span>
        CExtKey accountKey;            <span class="hljs-comment">//key at m/0'</span>
        CExtKey externalChainChildKey; <span class="hljs-comment">//key at m/0'/0'</span>
        CExtKey childKey;              <span class="hljs-comment">//key at m/0'/0'/&lt;n&gt;'</span>

        <span class="hljs-comment">// try to get the master key</span>
        <span class="hljs-keyword">if</span> (!GetKey(hdChain.masterKeyID, key))
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": Master key not found"</span>);

        masterKey.SetMaster(key.begin(), key.size());

        <span class="hljs-comment">// derive m/0' 派生</span>
        <span class="hljs-comment">// use hardened derivation (child keys &gt;= 0x80000000 are hardened after bip32)</span>
        <span class="hljs-comment">//使用硬化的派生，const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;</span>
        masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);

        <span class="hljs-comment">// derive m/0'/0'</span>
        accountKey.Derive(externalChainChildKey, BIP32_HARDENED_KEY_LIMIT);

        <span class="hljs-comment">// derive child key at next index, skip keys already known to the wallet</span>
        <span class="hljs-keyword">do</span>
        {
            <span class="hljs-comment">// always derive hardened keys</span>
            <span class="hljs-comment">// childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range</span>
            <span class="hljs-comment">// example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649</span>
            externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);
            metadata.hdKeypath     = <span class="hljs-string">"m/0'/0'/"</span>+<span class="hljs-built_in">std</span>::to_string(hdChain.nExternalChainCounter)+<span class="hljs-string">"'"</span>;
            metadata.hdMasterKeyID = hdChain.masterKeyID;
            <span class="hljs-comment">// increment childkey index</span>
            hdChain.nExternalChainCounter++;
        } <span class="hljs-keyword">while</span>(HaveKey(childKey.key.GetPubKey().GetID()));
        secret = childKey.key;

        <span class="hljs-comment">// update the chain model in the database</span>
        <span class="hljs-keyword">if</span> (!CWalletDB(strWalletFile).WriteHDChain(hdChain))
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": Writing HD chain model failed"</span>);
    } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//2.如果在创建钱包的时候是使用随机钱包</span>
        secret.MakeNewKey(fCompressed);
    }

    <span class="hljs-comment">// Compressed public keys were introduced in version 0.6.0</span>
    <span class="hljs-keyword">if</span> (fCompressed)
        SetMinVersion(FEATURE_COMPRPUBKEY);
<span class="hljs-comment">//验证公钥</span>
    CPubKey pubkey = secret.GetPubKey();
    assert(secret.VerifyPubKey(pubkey));
<span class="hljs-comment">//判断第一把密钥的创建时间</span>
    mapKeyMetadata[pubkey.GetID()] = metadata;
    <span class="hljs-keyword">if</span> (!nTimeFirstKey || nCreationTime &lt; nTimeFirstKey)
        nTimeFirstKey = nCreationTime;

    <span class="hljs-keyword">if</span> (!AddKeyPubKey(secret, pubkey))
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(__func__) + <span class="hljs-string">": AddKey failed"</span>);
    <span class="hljs-keyword">return</span> pubkey;
}</code></pre> 
  <p>其中的HD钱包部分是依据标准BIP32实现的，写在另一篇里<a href="https://blog.csdn.net/m0_37847176/article/details/82011876" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/82011876</a> <br> 如果是随机钱包，则调用CKey类的<code>MakeNewKey</code></p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//key.cpp</span>
<span class="hljs-keyword">void</span> CKey::MakeNewKey(<span class="hljs-keyword">bool</span> fCompressedIn) {
    <span class="hljs-keyword">do</span> {
        GetStrongRandBytes(vch, <span class="hljs-keyword">sizeof</span>(vch));<span class="hljs-comment"><span class="hljs-xmlDocTag">///</span>/! The actual byte data unsigned char vch[32];</span>
    } <span class="hljs-keyword">while</span> (!Check(vch));
    fValid = <span class="hljs-keyword">true</span>;
    fCompressed = fCompressedIn;
}</code></pre> 
  <p>具体实现就是新建一个CKey类型的对象，获取强随机数，私钥是32位的，知道获取的随机数通过验证，此时的私钥是有效的。 <br> 然后获取对应私钥的公钥，通过椭圆曲线算法调用库，验证公钥 <br> 最后添加公钥，调用CWallet类的AddKeyPubKey</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//wallet.cpp</span>
<span class="hljs-keyword">bool</span> CWallet::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; secret, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    AssertLockHeld(cs_wallet); <span class="hljs-comment">// mapKeyMetadata</span>
    <span class="hljs-keyword">if</span> (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// check if we need to remove from watch-only</span>
    CScript script;
    script = GetScriptForDestination(pubkey.GetID());
    <span class="hljs-keyword">if</span> (HaveWatchOnly(script))
        RemoveWatchOnly(script);
    script = GetScriptForRawPubKey(pubkey);
    <span class="hljs-keyword">if</span> (HaveWatchOnly(script))
        RemoveWatchOnly(script);

    <span class="hljs-keyword">if</span> (!fFileBacked)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (!IsCrypted()) {
        <span class="hljs-keyword">return</span> CWalletDB(strWalletFile).WriteKey(pubkey,
                                                 secret.GetPrivKey(),
                                                 mapKeyMetadata[pubkey.GetID()]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>首先调用CCryptoKeyStore的<code>AddKeyPubKey</code>，CCryptoKeyStore是保存加密过的私钥的密钥库，继承自CBasicKeyStore，如果没有激活加密，则使用CBasicKeyStore。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CCryptoKeyStore::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; key, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    {
        LOCK(cs_KeyStore);
        <span class="hljs-keyword">if</span> (!IsCrypted())<span class="hljs-comment">//是否激活加密</span>
            <span class="hljs-keyword">return</span> CBasicKeyStore::AddKeyPubKey(key, pubkey);

        <span class="hljs-keyword">if</span> (IsLocked())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchCryptedSecret;
        CKeyingMaterial vchSecret(key.begin(), key.end());
        <span class="hljs-keyword">if</span> (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">if</span> (!AddCryptedKey(pubkey, vchCryptedSecret))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>未激活加密私钥的话</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">bool</span> CBasicKeyStore::AddKeyPubKey(<span class="hljs-keyword">const</span> CKey&amp; key, <span class="hljs-keyword">const</span> CPubKey &amp;pubkey)
{
    LOCK(cs_KeyStore);
    mapKeys[pubkey.GetID()] = key;<span class="hljs-comment">//私钥和公钥（hash值）保存在键值对mapKeys中</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>激活加密私钥 <br> 首先调用<code>EncryptSecret</code>加密秘密，接着添加加密的私钥</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CCryptoKeyStore::AddCryptedKey(<span class="hljs-keyword">const</span> CPubKey &amp;vchPubKey, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> &amp;vchCryptedSecret)
{
    {
        LOCK(cs_KeyStore);
        <span class="hljs-keyword">if</span> (!SetCrypted())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>把公钥（hash）、公钥、加密的秘密保存在键值对mapCryptedKeys中。 <br> 返回CWallet::AddKeyPubKey，最后调用 CWalletDB类的<code>WriteKey</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CWalletDB::WriteKey(<span class="hljs-keyword">const</span> CPubKey&amp; vchPubKey, <span class="hljs-keyword">const</span> CPrivKey&amp; vchPrivKey, <span class="hljs-keyword">const</span> CKeyMetadata&amp; keyMeta)
{
    nWalletDBUpdated++;

    <span class="hljs-keyword">if</span> (!Write(<span class="hljs-built_in">std</span>::make_pair(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"keymeta"</span>), vchPubKey),
               keyMeta, <span class="hljs-keyword">false</span>))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// hash pubkey/privkey to accelerate wallet load</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchKey;
    vchKey.reserve(vchPubKey.size() + vchPrivKey.size());
    vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());
    vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());

    <span class="hljs-keyword">return</span> Write(<span class="hljs-built_in">std</span>::make_pair(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"key"</span>), vchPubKey), <span class="hljs-built_in">std</span>::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), <span class="hljs-keyword">false</span>);
}</code></pre> 
  <p>这里是调用了CWalletDB的父类CDB的成员函数Write，CDB封装了Berkeley数据库的一系列操作接口，上述代码就是把密钥写入Berkeley数据库。 <br> 加载钱包在<a href="https://blog.csdn.net/m0_37847176/article/details/81739999" rel="nofollow">https://blog.csdn.net/m0_37847176/article/details/81739999</a>这一篇中</p> 
  <blockquote> 
   <p>Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据，广泛用于各种操作系统包括大多数Unix类操作系统和Windows操作系统以及实时操作系统。</p> 
  </blockquote> 
  <h2 id="base58编码">base58编码</h2> 
  <p>代码中使用的代码如下</p> 
  <pre class="prettyprint"><code class=" hljs mathematica">CBitcoinAddress(keyID).<span class="hljs-keyword">ToString</span>();</code></pre> 
  <blockquote> 
   <p>base58-encoded Bitcoin addresses. <br> Public-key-hash-addresses have version 0 (or 111 testnet). <br> The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key. <br> Script-hash-addresses have version 5 (or 196 testnet). <br> The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script. <br> 公钥哈希地址具有版本0（或111 测试网）。 <br> 数据向量包含RIPEMD160（SHA256（pubkey）），其中pubkey是序列化公钥。 <br> 脚本哈希地址具有版本5（或196 测试网）。 <br> 数据向量包含RIPEMD160（SHA256（cscript）），其中cscript是序列化的脚本。</p> 
  </blockquote> 
  <table> 
   <thead> 
    <tr> 
     <th>Type</th> 
     <th align="center">Version Prefix(hex)</th> 
     <th align="right">base58 result prefix</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>bitcoin address</td> 
     <td align="center">0x00</td> 
     <td align="right">1</td> 
    </tr> 
    <tr> 
     <td>bitcoin testnet address</td> 
     <td align="center">0x6f</td> 
     <td align="right">m、n</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses</td> 
     <td align="center">0x05</td> 
     <td align="right">3</td> 
    </tr> 
    <tr> 
     <td>Script-hash-addresses testnet</td> 
     <td align="center">0xc4</td> 
     <td align="right"></td> 
    </tr> 
   </tbody>
  </table> 
  <p>下面来看代码，类CBitcoinAddress继承自类CBase58Data，CBase58Data中有vchVersion成员变量表示版本信息。</p> 
  <pre class="prettyprint"><code class=" hljs cs">class CBitcoinAddress : <span class="hljs-keyword">public</span> CBase58Data {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">bool</span> <span class="hljs-title">Set</span>(<span class="hljs-keyword">const</span> CKeyID &amp;id);
    <span class="hljs-keyword">bool</span> Set(<span class="hljs-keyword">const</span> CScriptID &amp;id);
    <span class="hljs-keyword">bool</span> Set(<span class="hljs-keyword">const</span> CTxDestination &amp;dest);
    <span class="hljs-keyword">bool</span> IsValid() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> IsValid(<span class="hljs-keyword">const</span> CChainParams &amp;<span class="hljs-keyword">params</span>) <span class="hljs-keyword">const</span>;

    CBitcoinAddress() {}
    CBitcoinAddress(<span class="hljs-keyword">const</span> CTxDestination &amp;dest) { Set(dest); }
    CBitcoinAddress(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span>&amp; strAddress) { SetString(strAddress); }
    CBitcoinAddress(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszAddress) { SetString(pszAddress); }

    CTxDestination Get() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> GetKeyID(CKeyID &amp;keyID) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> IsScript() <span class="hljs-keyword">const</span>;
};</code></pre> 
  <p>根据代码推测是调用了第三个或第四个构造函数，都是调用<code>SetString()</code>函数，SetString()函数内部是调用父类的SetString()，也就是CBase58Data::SetString,在CBase58Data中声明的<code>bool SetString(const char* psz, unsigned int nVersionBytes = 1);</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CBase58Data::SetString(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* psz, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nVersionBytes)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vchTemp;
    <span class="hljs-keyword">bool</span> rc58 = DecodeBase58Check(psz, vchTemp);<span class="hljs-comment">//psz是要编码的内容，编码后临时存放</span>
    <span class="hljs-keyword">if</span> ((!rc58) || (vchTemp.size() &lt; nVersionBytes)) {
        vchData.clear();
        vchVersion.clear();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);
    vchData.resize(vchTemp.size() - nVersionBytes);
    <span class="hljs-keyword">if</span> (!vchData.empty())
        <span class="hljs-built_in">memcpy</span>(&amp;vchData[<span class="hljs-number">0</span>], &amp;vchTemp[nVersionBytes], vchData.size());
    memory_cleanse(&amp;vchTemp[<span class="hljs-number">0</span>], vchTemp.size());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>这部分代码的逻辑不是很清晰</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> CBase58Data::ToString() <span class="hljs-keyword">const</span>
{
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> vch = vchVersion;
    <span class="hljs-comment">//在vch的末尾插入vchData</span>
    vch.insert(vch.end(), vchData.begin(), vchData.end());
    <span class="hljs-keyword">return</span> EncodeBase58Check(vch);
}</code></pre> 
  <p>借用精通比特币的图，编码过程</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828145938928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODQ3MTc2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h1 id="发送金额">发送金额</h1> 
  <p>这个函数位于rpcwallet.cpp中，需要传入交易目的地，交易金额，fSubtractFeeFromAmount（从交易金额中抽取费用），包含附加的交易信息CWalletTx（比如这笔交易是发送给谁，为什么发起）</p> 
  <blockquote> 
   <p>/** <br> * A txout script template with a specific destination. It is either: <br> * * CNoDestination: no destination set <br> * * CKeyID: TX_PUBKEYHASH destination <br> * * CScriptID: TX_SCRIPTHASH destination <br> * A CTxDestination is the internal data type encoded in a CBitcoinAddress <br> */</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs ruby">typedef <span class="hljs-symbol">boost:</span><span class="hljs-symbol">:variant&lt;CNoDestination</span>, <span class="hljs-constant">CKeyID</span>, <span class="hljs-constant">CScriptID</span>&gt; <span class="hljs-constant">CTxDestination</span>;</code></pre> 
  <blockquote> 
   <p><code>CWalletTx</code>:A transaction with a bunch of additional info that only the owner cares about. <br> It includes any unrecorded transactions needed to link it back to the block chain.</p> 
  </blockquote> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SendMoney(<span class="hljs-keyword">const</span> CTxDestination &amp;address, CAmount nValue, <span class="hljs-keyword">bool</span> fSubtractFeeFromAmount, CWalletTx&amp; wtxNew)
{
    CAmount curBalance = pwalletMain-&gt;GetBalance();

    <span class="hljs-comment">// 1.Check amount 检查余额</span>
    <span class="hljs-keyword">if</span> (nValue &lt;= <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_INVALID_PARAMETER, <span class="hljs-string">"Invalid amount"</span>);

    <span class="hljs-keyword">if</span> (nValue &gt; curBalance)
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, <span class="hljs-string">"Insufficient funds"</span>);

    <span class="hljs-comment">// 2.Parse Bitcoin address 解析比目的地，获得脚本</span>
    CScript scriptPubKey = GetScriptForDestination(address);

    <span class="hljs-comment">// 3.Create and send the transaction 创建并发送交易</span>
    CReserveKey reservekey(pwalletMain);
    CAmount nFeeRequired;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strError;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CRecipient&gt;</span> vecSend;
    <span class="hljs-keyword">int</span> nChangePosRet = -<span class="hljs-number">1</span>;
    CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};<span class="hljs-comment">//接收者（锁定脚本，金额，是否抽取费用）</span>
    vecSend.push_back(recipient);
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {
        <span class="hljs-keyword">if</span> (!fSubtractFeeFromAmount &amp;&amp; nValue + nFeeRequired &gt; pwalletMain-&gt;GetBalance())
            strError = strprintf(<span class="hljs-string">"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!"</span>, FormatMoney(nFeeRequired));
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_ERROR, strError);
    }
    <span class="hljs-keyword">if</span> (!pwalletMain-&gt;CommitTransaction(wtxNew, reservekey))<span class="hljs-comment">//提交交易</span>
        <span class="hljs-keyword">throw</span> JSONRPCError(RPC_WALLET_ERROR, <span class="hljs-string">"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here."</span>);
}</code></pre> 
  <h2 id="getbalance">GetBalance()</h2> 
  <p>首先调用<code>GetBalance()</code>获取钱包的余额</p> 
  <pre class="prettyprint"><code class=" hljs cpp">CAmount CWallet::GetBalance() <span class="hljs-keyword">const</span>
{
    CAmount nTotal = <span class="hljs-number">0</span>;
    {
        LOCK2(cs_main, cs_wallet);
        <span class="hljs-keyword">for</span> (<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;uint256, CWalletTx&gt;</span>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
        {
            <span class="hljs-keyword">const</span> CWalletTx* pcoin = &amp;(*it).second;<span class="hljs-comment">//CWalletTx</span>
            <span class="hljs-keyword">if</span> (pcoin-&gt;IsTrusted())
                nTotal += pcoin-&gt;GetAvailableCredit();
        }
    }

    <span class="hljs-keyword">return</span> nTotal;
}</code></pre> 
  <h3 id="istrusted">IsTrusted()</h3> 
  <p>这里判断交易是否被信任</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">//wallet.cpp</span>
bool CWalletTx::IsTrusted() <span class="hljs-keyword">const</span>
{
    <span class="hljs-comment">// Quick answer in most cases</span>
    <span class="hljs-keyword">if</span> (!CheckFinalTx(*this))<span class="hljs-comment">//判断交易是否是最终的，函数内调用了IsFinalTx</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    int nDepth = GetDepthInMainChain();
    <span class="hljs-keyword">if</span> (nDepth &gt;= <span class="hljs-number">1</span>)<span class="hljs-comment">//交易所在区块后面的区块大于等于1即视为信任</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (nDepth &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) <span class="hljs-comment">// using wtx's cached debit</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// Don't trust unconfirmed transactions from us unless they are in the mempool.</span>
    <span class="hljs-keyword">if</span> (!InMempool())<span class="hljs-comment">//不信任不在内存池中的交易</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// Trusted if all inputs are from us and are in the mempool:</span>
    BOOST_FOREACH(<span class="hljs-keyword">const</span> CTxIn&amp; txin, vin)
    {
        <span class="hljs-comment">// Transactions not sent by us: not trusted</span>
        <span class="hljs-keyword">const</span> CWalletTx* <span class="hljs-keyword">parent</span> = pwallet-&gt;GetWalletTx(txin.prevout.hash);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span> == <span class="hljs-keyword">NULL</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">const</span> CTxOut&amp; parentOut = <span class="hljs-keyword">parent</span>-&gt;vout[txin.prevout.n];
        <span class="hljs-keyword">if</span> (pwallet-&gt;IsMine(parentOut) != ISMINE_SPENDABLE)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//main.h</span>
<span class="hljs-javadoc">/** * Check if transaction is final and can be included in a block with the * specified height and time. Consensus critical. */</span>
bool IsFinalTx(<span class="hljs-keyword">const</span> CTransaction &amp;tx, <span class="hljs-keyword">int</span> nBlockHeight, int64_t nBlockTime);</code></pre> 
  <h3 id="getavailablecredit">GetAvailableCredit</h3> 
  <p>这里有几个逻辑</p> 
  <pre class="prettyprint"><code class=" hljs cpp">CAmount CWalletTx::GetAvailableCredit(<span class="hljs-keyword">bool</span> fUseCache) <span class="hljs-keyword">const</span>
{  
    <span class="hljs-keyword">if</span> (pwallet == <span class="hljs-number">0</span>)<span class="hljs-comment">//没有钱包信息则返回0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Must wait until coinbase is safely deep enough in the chain before valuing it</span>
    <span class="hljs-comment">//如果是coinbase交易，必须等这笔交易足够安全，否则返回0</span>
    <span class="hljs-keyword">if</span> (IsCoinBase() &amp;&amp; GetBlocksToMaturity() &gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (fUseCache &amp;&amp; fAvailableCreditCached)<span class="hljs-comment">//如果使用缓存数据</span>
        <span class="hljs-keyword">return</span> nAvailableCreditCached;

    CAmount nCredit = <span class="hljs-number">0</span>;
    uint256 hashTx = GetHash();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vout.size(); i++)
    {
        <span class="hljs-keyword">if</span> (!pwallet-&gt;IsSpent(hashTx, i))<span class="hljs-comment">//如果这笔交易的输出未支出</span>
        {
            <span class="hljs-keyword">const</span> CTxOut &amp;txout = vout[i];
            nCredit += pwallet-&gt;GetCredit(txout, ISMINE_SPENDABLE);<span class="hljs-comment">//我可以花费的部分</span>
            <span class="hljs-keyword">if</span> (!MoneyRange(nCredit))
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"CWalletTx::GetAvailableCredit() : value out of range"</span>);
        }
    }

    nAvailableCreditCached = nCredit;
    fAvailableCreditCached = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> nCredit;
}</code></pre> 
  <p>太长了，分开写到另一篇<a href="https://blog.csdn.net/m0_37847176/article/details/82493420" rel="nofollow">创建一个交易</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37847176/article/details/81906838,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
