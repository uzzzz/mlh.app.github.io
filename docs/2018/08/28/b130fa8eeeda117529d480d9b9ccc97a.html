<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【我的区块链之路】- 去中心化的神级大作Hashgraph的讲解 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【我的区块链之路】- 去中心化的神级大作Hashgraph的讲解" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="【转载请标明出处】：&nbsp;https://blog.csdn.net/qq_25870633/article/details/82057232 本文章参考自： https://blog.csdn.net/lcloveyou/article/details/80289258 https://jiasule.v2ex.com/t/446575 首先今天我们来说一说HashGraph是个什么东西，在当下的区块链之所以没有被大规模的应用落地，其中TPS的瓶颈就是其中之一也是比较重量级的问题，所以充满了智慧的人类们想出了：侧链、超级节点、分片、DAG、HashGraph等等手段来提升区块链的TPS；我们在之前的文章&nbsp;DAG模型讲解及IOTA中的使用&nbsp;中已经了解到了提升TPS的DAG方案，那么我们今天要讲的HashGraph也是基于DAG的，Hashgraph 是一种数据结构和共识算法。Hashgraph 不是数字货币，也不是区块链（因为它其实是 DAG 图，并非是链式结构）； 首先我们来看几张对比图来看看hashgraph是如何如何的牛逼，怎么怎么的神级的： 图一： &nbsp; 图二： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 图三： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 在看完牛逼高大上的图片后，我们再来了解下几个东西。【不明白没关系，先记住我们往下看就可以】： 【一】：hashgraph中节点通过gossip协议进行通信，也就是说每个节点重复的随机的同步其他的节点 【二】：hashgraph中是使用event来记录交易信息 【三】：底层实际上仍然是DAG 【四】：异步拜占庭 【五】：是用了虚拟投票 在HashGraph中我们是用Event 来记录交易信息的，类似于Block，event的内容为：前两个event的hash值、当前时间戳及若干笔交易： 即：在 Hashgraph 中，每一个节点都在传播经过签名的已经从临近节点接收到Event的新打包event。当某个节点收到包含新交易信息的数据后，会组合并可能添加自己所知道的交易成为一个新的Event。Event是一个数据结构，除了包含自己的交易外，还包含它的之前的两个时间的hash。 假设目前全网的节点为A、B、C、D四个节点，且每个节点现在都有一个创世event，我们用竖线代表时间轴，如图： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 紧接着：B节点随机的把自己的event【黄色】广播给了D节点，D节点就会创建一个新的event【红色】，这个新event里除了加入新的交易事务的同时，还会加上两个指向父区块的hash值，一个指向自己的最新区块【蓝色】，一个指向B和自己聊天时候最新的event【黄色】(这一点类似于Git使用hash实现的链接，只不过git是单父亲模式) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后对整个事件加上时间戳并签名并继续开始随机广播重复上述动作，整个循环不断进行直到所有节点都获得相同的信息。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 最后整网的event及节点从逻辑上是如上图这样表现的； Event包含交易、两个hash、时间戳、签名，通过gossip协议通信 由于每个节点都会通过gossip维护一个散列图（最终每个节点都会记录着所有交易信息），所以每个节点计算共识投票的时候可以发起虚拟投票，也就是计算其他节点在给定的散列图中会怎么投票，从而不需要在网络上再做大量节点间的双向同步通信。 【注意】： 在某一时刻，不同节点的散列图中最新的区块可能都各不一样，但是更早些的区块和继承关系都是一致的， 而且随着时间的推逝和八卦的积极进行，他们的散列图会收敛到相同的结果。这里的一致指的是如果两个节点的散列图里都有区块x，那么这两个x都会指向相同的两个父区块。 Hashgraph里每个节点都会试图整理区块的顺序，这时节点就会对自己发起共识提案，例如“区块a是否早于区块b”，然后节点会照着自己保存的散列图有如精分一般遵从写死的代码逻辑和规则的从每个已知节点的角度进行投票计票和共识运算。这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 虚拟投票： 上面我们看到了 Hashgraph 如何在节点之间通信，但这仅仅只是通信步骤，节点之间达成共识还需要虚拟投票机制，为什么说是虚拟投票，因为通过执行gossip算法后所有节点都是全节点(为什么这么说？因为随着时间的推移，所有节点上都会引用了整网的event啊！！上面就有说了)，都存储了完整的网络历史(可能不同时间节点存储的不一样！但是最终都会趋向一样！)，在需要对某一提案达成共识时并不需要大规模的消息通信，每个节点独立执行投票算法，并且所有节点一定会得出相同的共识结果（因为知道最终大家所村的信息都会趋向一致，虽然不同时间存储的不一样，所以就会自信满满的相信，大家自己所算的结果也会和我的一致）。 【Hashgraph的几个重要的概念】：(8个) round（轮次）：是hashgraph中一个重要的概念，所有的节点收到event时都以同样的方法计算。&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个可以see 三分之二个witness的event的时候，从该event起就是新的round[r+1]了。 round created（创建轮次）：一个event的创建轮次是： R 或者 R+1，其中 R 是该事件父节点的最大轮次。当且仅当event能强可见绝对多数的 R 轮见证人，则该事件的创建轮次为 R+1；换句话说，（&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个强可见三分之二个witness的event的时候，从该event起就是新的round[r+1]了，那么这个新的r+1的round就是创建轮次） 简单来说，某个event在节点上传来传去，总得有个头才行，因为对一个没听过这个event的新节点而言，听到这个event的时候，自己签名加入transaction之后就是一个新的event了； 整个hashgraph的目标：【是就这些event的发生次序在整个节点网络达成共识，同时实现异步BFT。对于某个event而言，从见证人到知名见证人的转变，就好比比特币区块链上确认数从1个到6个的过程，对于这个event的确认信心逐渐增强的过程，当知名见证人达到绝大多数的时候，这个普通event就被整个网络确认了】，然后确认下一个event，这样一个一个将不断新加入的event定好顺序 &nbsp; round received（接受轮次）：如果 R 轮（创建轮次）中的所有知名见证人可见【注意这里不要求是强可见哦】某一普通event，则该event的接受轮次就是 R 轮，如果某普通event没有被 R 轮所有知名见证人可见，则它的接受轮次一定晚于 R 轮。【其实也就类似于，被6个块所引用的块叫做确认块是一个道理】 witness（见证人）：每一节点在每一轮次中创建的第一个Event被称为见证人（也可看作该轮次中相对的先祖evnet）。某节点也有可能在某一轮次中没有创建见证人event。 famous witness（知名见证人）：如果 R 轮的见证人能被绝对多数(三分之二)的 R+1 轮见证人可见，则它就是知名见证人。(因为出名了啊，下一轮的见证人都能看到你怎么会不出名呢？) 【其他几个概念】 supermajority （绝大多数）：超过 2/3 以上节点的数量 如果Alice作假，自己产生了两个新区块b和c都指向自己的最后的一块区块a，那么在Alice的纵轴上就会从链状变成树状，等于进行了分叉攻击。如果Alice把b的存在告诉了Bob，而把c的存在告诉了Carol，那么Bob和Carol这两个节点所进行的虚拟投票就会变得不一样（分叉了）。为了防止这个问题的发生，Hasgraph引入了可见（Seeing）和强可见（Strongly seeing）的概念。 seeing&nbsp;（可见）：当事件 B 可以沿着哈希指针（不论路径有多长哦）找到事件 A，那么事件 B 就可见事件 A strongly seeing（强可见）：当事件 B 能找到事件 A 的所有路径中跨越了绝对多数的节点(就是说B找A的路径上的event相互引用跨越了全网三分之二节点)，那么事件 B 强可见事件 A。经过数学论证是可以保证两个强可见的event在虚拟投票时能获得一致的结果，简单理解就是：件A和B的发生次序（order）得到了全网节点的共识 实际上就是，由强可见保证了两个节点在虚拟计票的时候，能够获得一致的结果。从而为作为Hashgraph能够达成最终拜占庭一致的理论基础。 虚拟投票： （每个节点都可以在本地通过虚拟投票的拜占庭协议来决定某见证人区块是否是知名见证人。每个r＋1轮的见证人区块都会对某第r轮见证人区块进行投票；而第r+2轮的某一见证人会对第r+1轮的投票进行计票，即第r+2轮的见证人会从自己可以强见到的第r+1轮见证人那里收集投票结果。一旦某个投票结果（Yes or No）的计票数目超过绝大多数，第r+2轮见证人就可以决定出投票的结果（decide），就算达成了共识） 简单理下：某个第一代先祖是否知名？，必须由第二代先祖来投票他们是否可见第一代祖先，而具体的计票则由第三代先祖进行，第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 任何一个第三代先祖如果能对投票结果（Yes or No）做出决定，那么这个结果就是全网的结论。 【注意】：如果这一轮(这个第三代)的见证人没发做出决定（没有任何结果超过绝对多数），那么则会继续交由下一代先祖来计票做决定，直到某轮某个先祖得出明确的结果。文中还有另一理论证明，只要每十轮增加一个随机轮（Coin round），投票肯定终究能完成。在随机轮中，见证者不会做出任何决定，如果见证人收集到了绝对多数的结果，他会根据结果进行附议投票，否则，见证人则根据自己的数字签名进行随机投票。 在正常情况下，大部分的event并非见证人event，所以对于这些event都不会举行上述的选举知名见证人的投票。而且大部分见证人会在第一轮投票中被一致通过或否决。所以大部分的选举投票不会耗时太过漫长。此外，一旦所有知名见证人被确定下来，整个网络里的event顺序（所谓公平性）也就能被更快更容易被推导出来。 为了确定区块顺序所以引入了接受轮次（received round）的概念，每个event除了创建轮次外还有接受轮次，第r轮（创建轮次）中所有的知名见证者可见的任何普通event都会被赋予第r轮的接受轮次。如果有的普通区块没有被所有知名可见证者看到，则它的接受轮次未定，而且肯定会比r更晚。 在确定了接受轮次后，则对所有event做排序，先按照接受轮次从低到高排，一样的话按照时间戳从早到晚排序，如果具备序号一样的话，则按照event的签名与某随机数异或出来的结果来排序（将该轮中所有知名见证者的签名进行异或可得到该随机数），这样得出的顺序被称作共识顺序（Consensus order） &nbsp; 具体的投票过程如下所示：（图中也会对 知名见证人，创建轮次，接收轮次等概念做以讲解） 我们从上述的描述中知道了，节点在round中创建的第一个event叫做witness(见证者)，如下图：（中A节点的witness就是A1，A2，A3，同理其他三个节点的也是图上红色的event） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后第二轮的因为我们可以看到 D2 event 可以强可见(路径跨越了全网三分之二节点)绝大多数（三分之二） 1轮的见证人，所以从D2开始属于 第2轮次；然后A2、B2、C2 分别是第2轮次中的其他三个节点上的见证人。依次3轮次和4轮次都是(妈的 4轮次感觉不是强可见绝大多数3轮的见证人啊。。。图有毒？) 虚拟投票的核心是先对于每一个见证人我们都需要判断是否是 知名见证人？ 下面我们来举例说明如何判断B2是否 知名见证人的： 我们从 知名见证人的定义中知道，一个见证人是否知名，是由相对于它的下一轮次中的 见证人对当前见证人是否可见的数据超过了 三分之二 来决定的，但是这部分统计的操作是由 下下轮次的见证人来记的，如： B2是否是famous witness首先由A3，B3，C3，D3判定。然后对于判定的计数又是由再后面一个round中的witness决定的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 首先，A3可见 B2，表示有一个从A3到B2的路径。换句话说，B2是A3的一个祖先，A3是B2的一个后裔。A3可见 B2，所以A3给B2投yes认为B2是 famous witness。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同样的 B3也可见B2，所以B3也认为B2是 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，C3也是由于可见B2，也认为B2就是它所谓人的 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同理，D3也是投了yes。那么在上面我们知道了 A3、B3、C3、D3都对B2投了yes。根据知名见证人的概念我们知道B2就是知名见证人了。 是到此投票还没有结束，因为我们接下来还需要统计票数。（交由下下轮次的见证人来统计） 投票的统计将在下一个round进行。所以B4来统计票数或者是D4统计票数。 因为第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 上图中没有A4和C4.但是随着时间的推移，hashgraph越来越大，A4和C4也会出现，他们也可以对投票进行计数。所以： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; B4 收集它能够 强可见的 见证人(及第2轮次的见证人)的投票结果。 在这个例子中，B4能够强可见A3.绿色的那条路径，实际上已经B4由多条路径到达A3.所以B4是强可见 A3的. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 同样的，B4 强可见 B3. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，B4 强可见 D3。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 至此，B4收到了超过 三分之二的yes票，所以B4可以认定投票结果是yes。所以绿色的B2节点现在就是 知名见证人了。【注意】：根据数学理论证明，任何一个 R+2 轮见证人如果对投票结果做出了决定，那么这个结果就是全网的结论，如果这轮见证人无法做出决定，就由下一轮见证人计票决定，直到得出确切结论。 假如在下一轮无法做出决定（例如 2:2 的投票结果），则将延续到下一轮，根据数学定理只要我们在每十轮增加一个随机轮次（ coin round ），则选举过程最终一定会结束（以概率 1 收敛，通俗点说就是几乎必然收敛，这是概率论中的概念）。在随机轮中，收集到绝对多数结果的见证人仅投票而不做决定，而其他见证人则根据数字签名的中间位进行随机投票。 那么我们再往下看，C2是不是 知名节点呢？： 上图中黄色路径表明，C3能 可见 C2，所以C3投票yes。但是A3，B3，D3不可见 C2，所以它们投票为No。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 由于 B4 强可见 A3，B3，C3, D3，所以它将统计投票结果，投票分别是No，No，Yes，No，所以结果是No。所以C2不是知名见证人啦。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 经过一系列的过程后，我们可以看到A2，D2，A1，B1，C1，D1都是 知名见证人。 但是在这个过程中，我们可以看到，大多数event都不是 见证人，所以对大多数的event 来说都没投票。大多数证人在第一轮投票中以几乎一致的投票被宣布为 知名见证人的。所以大多数选举不会持续很长时间 （这就是 共识很快的原因） 在上面的演示中，我们已经确定了round 2中每个 见证人的声望（即 A2、B2、C2、D2的是否知名见证人的声望）。一旦一个round中的所有见证人的声望已经确定，那我们就可以为一组event找到 接收轮次 和 共识时间戳。 如： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先考虑A2以下的灰色event，这个event（黑色的event）能够被round2中的每个 知名见证人 可见（如图中红色、绿色、蓝色路径所示）。【注意】：这里仅仅要求 可见，而不是 强可见。这里不要求C2 可见，因为C2不是 知名见证人。 因为黑色的这个event能够被round 2中的所有&nbsp; 知名见证人 可见，所以我们就说这个黑色 event 的 接收轮次 为round 2【看上面 接收轮次的概念也会明白的】 【接下来我们开始确定黑色事件的共识时间戳用于后续确定共识顺序】： 寻找 A 节点最早的事件 X，它既是 A2 的祖先也是黑色事件的儿子，同理寻找 B 节点的 Y 和 D 节点的 Z。然后将 XYZ 事件的时间戳依次排序并取中位数作为黑色节点的共识时间戳。然后我们继续确定其他节点的接受轮次。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以此类推， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 我们可以找到6个黑色event和4个深绿色event的共识。一共就由10 个接受轮次为 2 的event，我们需要将这10个event按照所有节点都同意的顺序排序。这个顺序就是共识顺序。我们按照以下优先级进行排序： 接受轮次 共识时间戳 按事件签名和某随机数异或的结果排序，这个随机数通过该轮所有知名见证人的数字签名进行异或运算得到 &nbsp; 完整的Hashgraph共识算法： 每个节点都在试图随机找到其他节点把自己所知event 通过gossip传播给对方。 每个节点同时也在接受其他节点更新过来的event，接受方节点需要额外进行一系列的运算，包括： 接受和处理接收的event信息 创建一个新的event，并且指向自己的最后event和gossip来源节点的最后event 对所有已知的event分配创建轮次，并确定区块是否是该轮次内的见证人 对所有已知的见证人区块进行选举投票，计算出是否 知名见证人 通过知名见证人，确定所有区块的共识顺序 这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 &nbsp; &nbsp; 三大优点：&nbsp; 公平 采用一致的时间戳，每一个事件，以及区块里的每一笔交易都有顺序（没有矿工） 速度 根据官网的测试数据，可以达到惊人的 250000 TPS；因为使用gossip做传播的，所以很快就能出 知名见证人，及很快就能达到共识 安全 Hashgraph 是一个 ABFT 系统，没有一个节点可以阻止网络达成共识或者在达成共识之后修改数据，号称能达到银行级别的安全性 Hashgraph通过增加随机性成为一种非确定性的异步协议。假设共识协议最终会终止，但终止发生的时间是不确定的。在目前的设计中，Hashgraph使用掷硬币（即签名的中间位）作为节点做出决定。因此，经过多轮抛硬币后，所有诚实节点具有相同的值的概率是非零的。最终所有诚实的节点将会变得一致。然而，如果所有拜占庭节点试图通过操纵gossip协议来破坏协议规则，如上面第2点所详述的那样，这种抛硬币方法的有效性和效率就成了问题，因为它可能需要多轮才能达成共识。 目前存在的问题： 目前为私有链，吞吐量参考价值存疑 目前Hashgraph是一个私有链，它的“运行速度快”只能跟其他私有链做比较，比如Hyperledger（700个交易/秒）和Red Belly（400,000个交易/秒），如果拿它的速度跟比特币和以太坊等公链来比较的话，是非常不公平的，因为现在的Hashgraph不需要设置防范恶意节点攻击的机制。此外，gossip算法是否适用于大规模公链环境也仍值得探讨。 能否经受恶意攻击 女巫攻击（Sybil attack），即攻击者通过创建大量假身份来破坏对等网络的信誉系统，并利用它们获得不成比例的巨大影响力。目前Hashgraph作为一个私有链，所有节点的身份已知，这种准入控制使得现阶段的Hashgraph无需考虑女巫攻击的危险。但如果未来Hashgraph打算往公有链方向发展的话，能否抵御女巫攻击将是Hashgraph必须思考的一个问题。 投票验证可能花费较多时间 Hashgraph的算法虽然很容易建立事件，但是在每个Round之后的投票验证过程却有可能很长。如果一直无法达到超过2/3的绝对多数，有可能要进行很多轮投票来决定谁记录的交易有效。（虽然我们从上面的图示中已经知道每轮投票其实只发生在 各个见证人之间，其他非见证人的 event 不参与，但是还是可能会存在这个一直无法达到超过2/3的绝大多数啊） 外部条件不同时的公平性问题：交易顺序如何决定？ Hashgraph白皮书中对公平性（Fairness）的解释如下： 假定存在A、B两个节点，A在B之前发出交易请求，如果最终在共识机制的判断下，A的交易的时间戳早于B的交易，我们就说该系统是有公平性的。如果A和B同时发生交易，并且两笔交易几乎是同时上传到网络并传播，此时就可能产生分叉，但是我们也说该系统是公平的。（why？？？）大多数共识机制都能够在以上两种情况下达到公平。 但是此解释是建立在A、B节点面临着同样的外部网络情况的假设前提下的。但我们考虑这样一个情况： 如果A的带宽是5M/s，而B的带宽是10M/s，A确实是比B早一点在网络中上传自己的交易信息，但是由于带宽限制，A的消息的传播速度会慢于B，这样就有可能导致最终投票时大多数人都更先接收到B的消息。这就像是在学校里，B的朋友更多，影响力大于A，因此在讨论八卦的时候，B可以把自己想传播的八卦信息更快地告诉更多人。即使可能是由A先开始传播八卦的，但因为影响力限制，大多数人都先听到B口中的版本。 在节点的外部条件不同时，投票是否也能反应真实地交易顺序，目前没有明确说明，因此仍然存在公平性的疑虑。 代码不开源 Hashgraph的代码不开源，且有专利保护，开发者需要申请SDK来进行开发，这是Hashgraph变成公链需要面临的一个很大障碍，这种闭源性本身与加密数字货币开源的理念是相违背的，所声称的公平、安全也无法提供确切的证据证明，可能无法得到信任。 &nbsp; &nbsp; 文中没有提到，那就是该算法应该是运行在代理之上的，因为每一步决定 知名见证人 的时候需要超过三分之二的 见证人强可见&nbsp; 这个event，所以推测应该是运行在代理（中心节点？）之上的，因为在全网的话无法判断三分之二具体是多大的数字。另外此算法的机制比较复杂，也没有一个很好的证明能够说明该算法在及时收敛上是管用的。 OK，到这里，我对hashgraph的抄袭也到此结束了，放心吧，这些文章我这个水货怎么可能是自己写出来的呢，我不东搬西运是不可能写下来的。。啦啦啦 阅读更多 登录后自动展开" />
<meta property="og:description" content="【转载请标明出处】：&nbsp;https://blog.csdn.net/qq_25870633/article/details/82057232 本文章参考自： https://blog.csdn.net/lcloveyou/article/details/80289258 https://jiasule.v2ex.com/t/446575 首先今天我们来说一说HashGraph是个什么东西，在当下的区块链之所以没有被大规模的应用落地，其中TPS的瓶颈就是其中之一也是比较重量级的问题，所以充满了智慧的人类们想出了：侧链、超级节点、分片、DAG、HashGraph等等手段来提升区块链的TPS；我们在之前的文章&nbsp;DAG模型讲解及IOTA中的使用&nbsp;中已经了解到了提升TPS的DAG方案，那么我们今天要讲的HashGraph也是基于DAG的，Hashgraph 是一种数据结构和共识算法。Hashgraph 不是数字货币，也不是区块链（因为它其实是 DAG 图，并非是链式结构）； 首先我们来看几张对比图来看看hashgraph是如何如何的牛逼，怎么怎么的神级的： 图一： &nbsp; 图二： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 图三： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 在看完牛逼高大上的图片后，我们再来了解下几个东西。【不明白没关系，先记住我们往下看就可以】： 【一】：hashgraph中节点通过gossip协议进行通信，也就是说每个节点重复的随机的同步其他的节点 【二】：hashgraph中是使用event来记录交易信息 【三】：底层实际上仍然是DAG 【四】：异步拜占庭 【五】：是用了虚拟投票 在HashGraph中我们是用Event 来记录交易信息的，类似于Block，event的内容为：前两个event的hash值、当前时间戳及若干笔交易： 即：在 Hashgraph 中，每一个节点都在传播经过签名的已经从临近节点接收到Event的新打包event。当某个节点收到包含新交易信息的数据后，会组合并可能添加自己所知道的交易成为一个新的Event。Event是一个数据结构，除了包含自己的交易外，还包含它的之前的两个时间的hash。 假设目前全网的节点为A、B、C、D四个节点，且每个节点现在都有一个创世event，我们用竖线代表时间轴，如图： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 紧接着：B节点随机的把自己的event【黄色】广播给了D节点，D节点就会创建一个新的event【红色】，这个新event里除了加入新的交易事务的同时，还会加上两个指向父区块的hash值，一个指向自己的最新区块【蓝色】，一个指向B和自己聊天时候最新的event【黄色】(这一点类似于Git使用hash实现的链接，只不过git是单父亲模式) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后对整个事件加上时间戳并签名并继续开始随机广播重复上述动作，整个循环不断进行直到所有节点都获得相同的信息。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 最后整网的event及节点从逻辑上是如上图这样表现的； Event包含交易、两个hash、时间戳、签名，通过gossip协议通信 由于每个节点都会通过gossip维护一个散列图（最终每个节点都会记录着所有交易信息），所以每个节点计算共识投票的时候可以发起虚拟投票，也就是计算其他节点在给定的散列图中会怎么投票，从而不需要在网络上再做大量节点间的双向同步通信。 【注意】： 在某一时刻，不同节点的散列图中最新的区块可能都各不一样，但是更早些的区块和继承关系都是一致的， 而且随着时间的推逝和八卦的积极进行，他们的散列图会收敛到相同的结果。这里的一致指的是如果两个节点的散列图里都有区块x，那么这两个x都会指向相同的两个父区块。 Hashgraph里每个节点都会试图整理区块的顺序，这时节点就会对自己发起共识提案，例如“区块a是否早于区块b”，然后节点会照着自己保存的散列图有如精分一般遵从写死的代码逻辑和规则的从每个已知节点的角度进行投票计票和共识运算。这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 虚拟投票： 上面我们看到了 Hashgraph 如何在节点之间通信，但这仅仅只是通信步骤，节点之间达成共识还需要虚拟投票机制，为什么说是虚拟投票，因为通过执行gossip算法后所有节点都是全节点(为什么这么说？因为随着时间的推移，所有节点上都会引用了整网的event啊！！上面就有说了)，都存储了完整的网络历史(可能不同时间节点存储的不一样！但是最终都会趋向一样！)，在需要对某一提案达成共识时并不需要大规模的消息通信，每个节点独立执行投票算法，并且所有节点一定会得出相同的共识结果（因为知道最终大家所村的信息都会趋向一致，虽然不同时间存储的不一样，所以就会自信满满的相信，大家自己所算的结果也会和我的一致）。 【Hashgraph的几个重要的概念】：(8个) round（轮次）：是hashgraph中一个重要的概念，所有的节点收到event时都以同样的方法计算。&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个可以see 三分之二个witness的event的时候，从该event起就是新的round[r+1]了。 round created（创建轮次）：一个event的创建轮次是： R 或者 R+1，其中 R 是该事件父节点的最大轮次。当且仅当event能强可见绝对多数的 R 轮见证人，则该事件的创建轮次为 R+1；换句话说，（&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个强可见三分之二个witness的event的时候，从该event起就是新的round[r+1]了，那么这个新的r+1的round就是创建轮次） 简单来说，某个event在节点上传来传去，总得有个头才行，因为对一个没听过这个event的新节点而言，听到这个event的时候，自己签名加入transaction之后就是一个新的event了； 整个hashgraph的目标：【是就这些event的发生次序在整个节点网络达成共识，同时实现异步BFT。对于某个event而言，从见证人到知名见证人的转变，就好比比特币区块链上确认数从1个到6个的过程，对于这个event的确认信心逐渐增强的过程，当知名见证人达到绝大多数的时候，这个普通event就被整个网络确认了】，然后确认下一个event，这样一个一个将不断新加入的event定好顺序 &nbsp; round received（接受轮次）：如果 R 轮（创建轮次）中的所有知名见证人可见【注意这里不要求是强可见哦】某一普通event，则该event的接受轮次就是 R 轮，如果某普通event没有被 R 轮所有知名见证人可见，则它的接受轮次一定晚于 R 轮。【其实也就类似于，被6个块所引用的块叫做确认块是一个道理】 witness（见证人）：每一节点在每一轮次中创建的第一个Event被称为见证人（也可看作该轮次中相对的先祖evnet）。某节点也有可能在某一轮次中没有创建见证人event。 famous witness（知名见证人）：如果 R 轮的见证人能被绝对多数(三分之二)的 R+1 轮见证人可见，则它就是知名见证人。(因为出名了啊，下一轮的见证人都能看到你怎么会不出名呢？) 【其他几个概念】 supermajority （绝大多数）：超过 2/3 以上节点的数量 如果Alice作假，自己产生了两个新区块b和c都指向自己的最后的一块区块a，那么在Alice的纵轴上就会从链状变成树状，等于进行了分叉攻击。如果Alice把b的存在告诉了Bob，而把c的存在告诉了Carol，那么Bob和Carol这两个节点所进行的虚拟投票就会变得不一样（分叉了）。为了防止这个问题的发生，Hasgraph引入了可见（Seeing）和强可见（Strongly seeing）的概念。 seeing&nbsp;（可见）：当事件 B 可以沿着哈希指针（不论路径有多长哦）找到事件 A，那么事件 B 就可见事件 A strongly seeing（强可见）：当事件 B 能找到事件 A 的所有路径中跨越了绝对多数的节点(就是说B找A的路径上的event相互引用跨越了全网三分之二节点)，那么事件 B 强可见事件 A。经过数学论证是可以保证两个强可见的event在虚拟投票时能获得一致的结果，简单理解就是：件A和B的发生次序（order）得到了全网节点的共识 实际上就是，由强可见保证了两个节点在虚拟计票的时候，能够获得一致的结果。从而为作为Hashgraph能够达成最终拜占庭一致的理论基础。 虚拟投票： （每个节点都可以在本地通过虚拟投票的拜占庭协议来决定某见证人区块是否是知名见证人。每个r＋1轮的见证人区块都会对某第r轮见证人区块进行投票；而第r+2轮的某一见证人会对第r+1轮的投票进行计票，即第r+2轮的见证人会从自己可以强见到的第r+1轮见证人那里收集投票结果。一旦某个投票结果（Yes or No）的计票数目超过绝大多数，第r+2轮见证人就可以决定出投票的结果（decide），就算达成了共识） 简单理下：某个第一代先祖是否知名？，必须由第二代先祖来投票他们是否可见第一代祖先，而具体的计票则由第三代先祖进行，第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 任何一个第三代先祖如果能对投票结果（Yes or No）做出决定，那么这个结果就是全网的结论。 【注意】：如果这一轮(这个第三代)的见证人没发做出决定（没有任何结果超过绝对多数），那么则会继续交由下一代先祖来计票做决定，直到某轮某个先祖得出明确的结果。文中还有另一理论证明，只要每十轮增加一个随机轮（Coin round），投票肯定终究能完成。在随机轮中，见证者不会做出任何决定，如果见证人收集到了绝对多数的结果，他会根据结果进行附议投票，否则，见证人则根据自己的数字签名进行随机投票。 在正常情况下，大部分的event并非见证人event，所以对于这些event都不会举行上述的选举知名见证人的投票。而且大部分见证人会在第一轮投票中被一致通过或否决。所以大部分的选举投票不会耗时太过漫长。此外，一旦所有知名见证人被确定下来，整个网络里的event顺序（所谓公平性）也就能被更快更容易被推导出来。 为了确定区块顺序所以引入了接受轮次（received round）的概念，每个event除了创建轮次外还有接受轮次，第r轮（创建轮次）中所有的知名见证者可见的任何普通event都会被赋予第r轮的接受轮次。如果有的普通区块没有被所有知名可见证者看到，则它的接受轮次未定，而且肯定会比r更晚。 在确定了接受轮次后，则对所有event做排序，先按照接受轮次从低到高排，一样的话按照时间戳从早到晚排序，如果具备序号一样的话，则按照event的签名与某随机数异或出来的结果来排序（将该轮中所有知名见证者的签名进行异或可得到该随机数），这样得出的顺序被称作共识顺序（Consensus order） &nbsp; 具体的投票过程如下所示：（图中也会对 知名见证人，创建轮次，接收轮次等概念做以讲解） 我们从上述的描述中知道了，节点在round中创建的第一个event叫做witness(见证者)，如下图：（中A节点的witness就是A1，A2，A3，同理其他三个节点的也是图上红色的event） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后第二轮的因为我们可以看到 D2 event 可以强可见(路径跨越了全网三分之二节点)绝大多数（三分之二） 1轮的见证人，所以从D2开始属于 第2轮次；然后A2、B2、C2 分别是第2轮次中的其他三个节点上的见证人。依次3轮次和4轮次都是(妈的 4轮次感觉不是强可见绝大多数3轮的见证人啊。。。图有毒？) 虚拟投票的核心是先对于每一个见证人我们都需要判断是否是 知名见证人？ 下面我们来举例说明如何判断B2是否 知名见证人的： 我们从 知名见证人的定义中知道，一个见证人是否知名，是由相对于它的下一轮次中的 见证人对当前见证人是否可见的数据超过了 三分之二 来决定的，但是这部分统计的操作是由 下下轮次的见证人来记的，如： B2是否是famous witness首先由A3，B3，C3，D3判定。然后对于判定的计数又是由再后面一个round中的witness决定的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 首先，A3可见 B2，表示有一个从A3到B2的路径。换句话说，B2是A3的一个祖先，A3是B2的一个后裔。A3可见 B2，所以A3给B2投yes认为B2是 famous witness。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同样的 B3也可见B2，所以B3也认为B2是 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，C3也是由于可见B2，也认为B2就是它所谓人的 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同理，D3也是投了yes。那么在上面我们知道了 A3、B3、C3、D3都对B2投了yes。根据知名见证人的概念我们知道B2就是知名见证人了。 是到此投票还没有结束，因为我们接下来还需要统计票数。（交由下下轮次的见证人来统计） 投票的统计将在下一个round进行。所以B4来统计票数或者是D4统计票数。 因为第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 上图中没有A4和C4.但是随着时间的推移，hashgraph越来越大，A4和C4也会出现，他们也可以对投票进行计数。所以： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; B4 收集它能够 强可见的 见证人(及第2轮次的见证人)的投票结果。 在这个例子中，B4能够强可见A3.绿色的那条路径，实际上已经B4由多条路径到达A3.所以B4是强可见 A3的. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 同样的，B4 强可见 B3. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，B4 强可见 D3。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 至此，B4收到了超过 三分之二的yes票，所以B4可以认定投票结果是yes。所以绿色的B2节点现在就是 知名见证人了。【注意】：根据数学理论证明，任何一个 R+2 轮见证人如果对投票结果做出了决定，那么这个结果就是全网的结论，如果这轮见证人无法做出决定，就由下一轮见证人计票决定，直到得出确切结论。 假如在下一轮无法做出决定（例如 2:2 的投票结果），则将延续到下一轮，根据数学定理只要我们在每十轮增加一个随机轮次（ coin round ），则选举过程最终一定会结束（以概率 1 收敛，通俗点说就是几乎必然收敛，这是概率论中的概念）。在随机轮中，收集到绝对多数结果的见证人仅投票而不做决定，而其他见证人则根据数字签名的中间位进行随机投票。 那么我们再往下看，C2是不是 知名节点呢？： 上图中黄色路径表明，C3能 可见 C2，所以C3投票yes。但是A3，B3，D3不可见 C2，所以它们投票为No。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 由于 B4 强可见 A3，B3，C3, D3，所以它将统计投票结果，投票分别是No，No，Yes，No，所以结果是No。所以C2不是知名见证人啦。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 经过一系列的过程后，我们可以看到A2，D2，A1，B1，C1，D1都是 知名见证人。 但是在这个过程中，我们可以看到，大多数event都不是 见证人，所以对大多数的event 来说都没投票。大多数证人在第一轮投票中以几乎一致的投票被宣布为 知名见证人的。所以大多数选举不会持续很长时间 （这就是 共识很快的原因） 在上面的演示中，我们已经确定了round 2中每个 见证人的声望（即 A2、B2、C2、D2的是否知名见证人的声望）。一旦一个round中的所有见证人的声望已经确定，那我们就可以为一组event找到 接收轮次 和 共识时间戳。 如： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先考虑A2以下的灰色event，这个event（黑色的event）能够被round2中的每个 知名见证人 可见（如图中红色、绿色、蓝色路径所示）。【注意】：这里仅仅要求 可见，而不是 强可见。这里不要求C2 可见，因为C2不是 知名见证人。 因为黑色的这个event能够被round 2中的所有&nbsp; 知名见证人 可见，所以我们就说这个黑色 event 的 接收轮次 为round 2【看上面 接收轮次的概念也会明白的】 【接下来我们开始确定黑色事件的共识时间戳用于后续确定共识顺序】： 寻找 A 节点最早的事件 X，它既是 A2 的祖先也是黑色事件的儿子，同理寻找 B 节点的 Y 和 D 节点的 Z。然后将 XYZ 事件的时间戳依次排序并取中位数作为黑色节点的共识时间戳。然后我们继续确定其他节点的接受轮次。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以此类推， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 我们可以找到6个黑色event和4个深绿色event的共识。一共就由10 个接受轮次为 2 的event，我们需要将这10个event按照所有节点都同意的顺序排序。这个顺序就是共识顺序。我们按照以下优先级进行排序： 接受轮次 共识时间戳 按事件签名和某随机数异或的结果排序，这个随机数通过该轮所有知名见证人的数字签名进行异或运算得到 &nbsp; 完整的Hashgraph共识算法： 每个节点都在试图随机找到其他节点把自己所知event 通过gossip传播给对方。 每个节点同时也在接受其他节点更新过来的event，接受方节点需要额外进行一系列的运算，包括： 接受和处理接收的event信息 创建一个新的event，并且指向自己的最后event和gossip来源节点的最后event 对所有已知的event分配创建轮次，并确定区块是否是该轮次内的见证人 对所有已知的见证人区块进行选举投票，计算出是否 知名见证人 通过知名见证人，确定所有区块的共识顺序 这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 &nbsp; &nbsp; 三大优点：&nbsp; 公平 采用一致的时间戳，每一个事件，以及区块里的每一笔交易都有顺序（没有矿工） 速度 根据官网的测试数据，可以达到惊人的 250000 TPS；因为使用gossip做传播的，所以很快就能出 知名见证人，及很快就能达到共识 安全 Hashgraph 是一个 ABFT 系统，没有一个节点可以阻止网络达成共识或者在达成共识之后修改数据，号称能达到银行级别的安全性 Hashgraph通过增加随机性成为一种非确定性的异步协议。假设共识协议最终会终止，但终止发生的时间是不确定的。在目前的设计中，Hashgraph使用掷硬币（即签名的中间位）作为节点做出决定。因此，经过多轮抛硬币后，所有诚实节点具有相同的值的概率是非零的。最终所有诚实的节点将会变得一致。然而，如果所有拜占庭节点试图通过操纵gossip协议来破坏协议规则，如上面第2点所详述的那样，这种抛硬币方法的有效性和效率就成了问题，因为它可能需要多轮才能达成共识。 目前存在的问题： 目前为私有链，吞吐量参考价值存疑 目前Hashgraph是一个私有链，它的“运行速度快”只能跟其他私有链做比较，比如Hyperledger（700个交易/秒）和Red Belly（400,000个交易/秒），如果拿它的速度跟比特币和以太坊等公链来比较的话，是非常不公平的，因为现在的Hashgraph不需要设置防范恶意节点攻击的机制。此外，gossip算法是否适用于大规模公链环境也仍值得探讨。 能否经受恶意攻击 女巫攻击（Sybil attack），即攻击者通过创建大量假身份来破坏对等网络的信誉系统，并利用它们获得不成比例的巨大影响力。目前Hashgraph作为一个私有链，所有节点的身份已知，这种准入控制使得现阶段的Hashgraph无需考虑女巫攻击的危险。但如果未来Hashgraph打算往公有链方向发展的话，能否抵御女巫攻击将是Hashgraph必须思考的一个问题。 投票验证可能花费较多时间 Hashgraph的算法虽然很容易建立事件，但是在每个Round之后的投票验证过程却有可能很长。如果一直无法达到超过2/3的绝对多数，有可能要进行很多轮投票来决定谁记录的交易有效。（虽然我们从上面的图示中已经知道每轮投票其实只发生在 各个见证人之间，其他非见证人的 event 不参与，但是还是可能会存在这个一直无法达到超过2/3的绝大多数啊） 外部条件不同时的公平性问题：交易顺序如何决定？ Hashgraph白皮书中对公平性（Fairness）的解释如下： 假定存在A、B两个节点，A在B之前发出交易请求，如果最终在共识机制的判断下，A的交易的时间戳早于B的交易，我们就说该系统是有公平性的。如果A和B同时发生交易，并且两笔交易几乎是同时上传到网络并传播，此时就可能产生分叉，但是我们也说该系统是公平的。（why？？？）大多数共识机制都能够在以上两种情况下达到公平。 但是此解释是建立在A、B节点面临着同样的外部网络情况的假设前提下的。但我们考虑这样一个情况： 如果A的带宽是5M/s，而B的带宽是10M/s，A确实是比B早一点在网络中上传自己的交易信息，但是由于带宽限制，A的消息的传播速度会慢于B，这样就有可能导致最终投票时大多数人都更先接收到B的消息。这就像是在学校里，B的朋友更多，影响力大于A，因此在讨论八卦的时候，B可以把自己想传播的八卦信息更快地告诉更多人。即使可能是由A先开始传播八卦的，但因为影响力限制，大多数人都先听到B口中的版本。 在节点的外部条件不同时，投票是否也能反应真实地交易顺序，目前没有明确说明，因此仍然存在公平性的疑虑。 代码不开源 Hashgraph的代码不开源，且有专利保护，开发者需要申请SDK来进行开发，这是Hashgraph变成公链需要面临的一个很大障碍，这种闭源性本身与加密数字货币开源的理念是相违背的，所声称的公平、安全也无法提供确切的证据证明，可能无法得到信任。 &nbsp; &nbsp; 文中没有提到，那就是该算法应该是运行在代理之上的，因为每一步决定 知名见证人 的时候需要超过三分之二的 见证人强可见&nbsp; 这个event，所以推测应该是运行在代理（中心节点？）之上的，因为在全网的话无法判断三分之二具体是多大的数字。另外此算法的机制比较复杂，也没有一个很好的证明能够说明该算法在及时收敛上是管用的。 OK，到这里，我对hashgraph的抄袭也到此结束了，放心吧，这些文章我这个水货怎么可能是自己写出来的呢，我不东搬西运是不可能写下来的。。啦啦啦 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/08/28/b130fa8eeeda117529d480d9b9ccc97a.html" />
<meta property="og:url" content="https://mlh.app/2018/08/28/b130fa8eeeda117529d480d9b9ccc97a.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"【转载请标明出处】：&nbsp;https://blog.csdn.net/qq_25870633/article/details/82057232 本文章参考自： https://blog.csdn.net/lcloveyou/article/details/80289258 https://jiasule.v2ex.com/t/446575 首先今天我们来说一说HashGraph是个什么东西，在当下的区块链之所以没有被大规模的应用落地，其中TPS的瓶颈就是其中之一也是比较重量级的问题，所以充满了智慧的人类们想出了：侧链、超级节点、分片、DAG、HashGraph等等手段来提升区块链的TPS；我们在之前的文章&nbsp;DAG模型讲解及IOTA中的使用&nbsp;中已经了解到了提升TPS的DAG方案，那么我们今天要讲的HashGraph也是基于DAG的，Hashgraph 是一种数据结构和共识算法。Hashgraph 不是数字货币，也不是区块链（因为它其实是 DAG 图，并非是链式结构）； 首先我们来看几张对比图来看看hashgraph是如何如何的牛逼，怎么怎么的神级的： 图一： &nbsp; 图二： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 图三： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 在看完牛逼高大上的图片后，我们再来了解下几个东西。【不明白没关系，先记住我们往下看就可以】： 【一】：hashgraph中节点通过gossip协议进行通信，也就是说每个节点重复的随机的同步其他的节点 【二】：hashgraph中是使用event来记录交易信息 【三】：底层实际上仍然是DAG 【四】：异步拜占庭 【五】：是用了虚拟投票 在HashGraph中我们是用Event 来记录交易信息的，类似于Block，event的内容为：前两个event的hash值、当前时间戳及若干笔交易： 即：在 Hashgraph 中，每一个节点都在传播经过签名的已经从临近节点接收到Event的新打包event。当某个节点收到包含新交易信息的数据后，会组合并可能添加自己所知道的交易成为一个新的Event。Event是一个数据结构，除了包含自己的交易外，还包含它的之前的两个时间的hash。 假设目前全网的节点为A、B、C、D四个节点，且每个节点现在都有一个创世event，我们用竖线代表时间轴，如图： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 紧接着：B节点随机的把自己的event【黄色】广播给了D节点，D节点就会创建一个新的event【红色】，这个新event里除了加入新的交易事务的同时，还会加上两个指向父区块的hash值，一个指向自己的最新区块【蓝色】，一个指向B和自己聊天时候最新的event【黄色】(这一点类似于Git使用hash实现的链接，只不过git是单父亲模式) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后对整个事件加上时间戳并签名并继续开始随机广播重复上述动作，整个循环不断进行直到所有节点都获得相同的信息。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 最后整网的event及节点从逻辑上是如上图这样表现的； Event包含交易、两个hash、时间戳、签名，通过gossip协议通信 由于每个节点都会通过gossip维护一个散列图（最终每个节点都会记录着所有交易信息），所以每个节点计算共识投票的时候可以发起虚拟投票，也就是计算其他节点在给定的散列图中会怎么投票，从而不需要在网络上再做大量节点间的双向同步通信。 【注意】： 在某一时刻，不同节点的散列图中最新的区块可能都各不一样，但是更早些的区块和继承关系都是一致的， 而且随着时间的推逝和八卦的积极进行，他们的散列图会收敛到相同的结果。这里的一致指的是如果两个节点的散列图里都有区块x，那么这两个x都会指向相同的两个父区块。 Hashgraph里每个节点都会试图整理区块的顺序，这时节点就会对自己发起共识提案，例如“区块a是否早于区块b”，然后节点会照着自己保存的散列图有如精分一般遵从写死的代码逻辑和规则的从每个已知节点的角度进行投票计票和共识运算。这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 虚拟投票： 上面我们看到了 Hashgraph 如何在节点之间通信，但这仅仅只是通信步骤，节点之间达成共识还需要虚拟投票机制，为什么说是虚拟投票，因为通过执行gossip算法后所有节点都是全节点(为什么这么说？因为随着时间的推移，所有节点上都会引用了整网的event啊！！上面就有说了)，都存储了完整的网络历史(可能不同时间节点存储的不一样！但是最终都会趋向一样！)，在需要对某一提案达成共识时并不需要大规模的消息通信，每个节点独立执行投票算法，并且所有节点一定会得出相同的共识结果（因为知道最终大家所村的信息都会趋向一致，虽然不同时间存储的不一样，所以就会自信满满的相信，大家自己所算的结果也会和我的一致）。 【Hashgraph的几个重要的概念】：(8个) round（轮次）：是hashgraph中一个重要的概念，所有的节点收到event时都以同样的方法计算。&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个可以see 三分之二个witness的event的时候，从该event起就是新的round[r+1]了。 round created（创建轮次）：一个event的创建轮次是： R 或者 R+1，其中 R 是该事件父节点的最大轮次。当且仅当event能强可见绝对多数的 R 轮见证人，则该事件的创建轮次为 R+1；换句话说，（&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。一旦出现一个强可见三分之二个witness的event的时候，从该event起就是新的round[r+1]了，那么这个新的r+1的round就是创建轮次） 简单来说，某个event在节点上传来传去，总得有个头才行，因为对一个没听过这个event的新节点而言，听到这个event的时候，自己签名加入transaction之后就是一个新的event了； 整个hashgraph的目标：【是就这些event的发生次序在整个节点网络达成共识，同时实现异步BFT。对于某个event而言，从见证人到知名见证人的转变，就好比比特币区块链上确认数从1个到6个的过程，对于这个event的确认信心逐渐增强的过程，当知名见证人达到绝大多数的时候，这个普通event就被整个网络确认了】，然后确认下一个event，这样一个一个将不断新加入的event定好顺序 &nbsp; round received（接受轮次）：如果 R 轮（创建轮次）中的所有知名见证人可见【注意这里不要求是强可见哦】某一普通event，则该event的接受轮次就是 R 轮，如果某普通event没有被 R 轮所有知名见证人可见，则它的接受轮次一定晚于 R 轮。【其实也就类似于，被6个块所引用的块叫做确认块是一个道理】 witness（见证人）：每一节点在每一轮次中创建的第一个Event被称为见证人（也可看作该轮次中相对的先祖evnet）。某节点也有可能在某一轮次中没有创建见证人event。 famous witness（知名见证人）：如果 R 轮的见证人能被绝对多数(三分之二)的 R+1 轮见证人可见，则它就是知名见证人。(因为出名了啊，下一轮的见证人都能看到你怎么会不出名呢？) 【其他几个概念】 supermajority （绝大多数）：超过 2/3 以上节点的数量 如果Alice作假，自己产生了两个新区块b和c都指向自己的最后的一块区块a，那么在Alice的纵轴上就会从链状变成树状，等于进行了分叉攻击。如果Alice把b的存在告诉了Bob，而把c的存在告诉了Carol，那么Bob和Carol这两个节点所进行的虚拟投票就会变得不一样（分叉了）。为了防止这个问题的发生，Hasgraph引入了可见（Seeing）和强可见（Strongly seeing）的概念。 seeing&nbsp;（可见）：当事件 B 可以沿着哈希指针（不论路径有多长哦）找到事件 A，那么事件 B 就可见事件 A strongly seeing（强可见）：当事件 B 能找到事件 A 的所有路径中跨越了绝对多数的节点(就是说B找A的路径上的event相互引用跨越了全网三分之二节点)，那么事件 B 强可见事件 A。经过数学论证是可以保证两个强可见的event在虚拟投票时能获得一致的结果，简单理解就是：件A和B的发生次序（order）得到了全网节点的共识 实际上就是，由强可见保证了两个节点在虚拟计票的时候，能够获得一致的结果。从而为作为Hashgraph能够达成最终拜占庭一致的理论基础。 虚拟投票： （每个节点都可以在本地通过虚拟投票的拜占庭协议来决定某见证人区块是否是知名见证人。每个r＋1轮的见证人区块都会对某第r轮见证人区块进行投票；而第r+2轮的某一见证人会对第r+1轮的投票进行计票，即第r+2轮的见证人会从自己可以强见到的第r+1轮见证人那里收集投票结果。一旦某个投票结果（Yes or No）的计票数目超过绝大多数，第r+2轮见证人就可以决定出投票的结果（decide），就算达成了共识） 简单理下：某个第一代先祖是否知名？，必须由第二代先祖来投票他们是否可见第一代祖先，而具体的计票则由第三代先祖进行，第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 任何一个第三代先祖如果能对投票结果（Yes or No）做出决定，那么这个结果就是全网的结论。 【注意】：如果这一轮(这个第三代)的见证人没发做出决定（没有任何结果超过绝对多数），那么则会继续交由下一代先祖来计票做决定，直到某轮某个先祖得出明确的结果。文中还有另一理论证明，只要每十轮增加一个随机轮（Coin round），投票肯定终究能完成。在随机轮中，见证者不会做出任何决定，如果见证人收集到了绝对多数的结果，他会根据结果进行附议投票，否则，见证人则根据自己的数字签名进行随机投票。 在正常情况下，大部分的event并非见证人event，所以对于这些event都不会举行上述的选举知名见证人的投票。而且大部分见证人会在第一轮投票中被一致通过或否决。所以大部分的选举投票不会耗时太过漫长。此外，一旦所有知名见证人被确定下来，整个网络里的event顺序（所谓公平性）也就能被更快更容易被推导出来。 为了确定区块顺序所以引入了接受轮次（received round）的概念，每个event除了创建轮次外还有接受轮次，第r轮（创建轮次）中所有的知名见证者可见的任何普通event都会被赋予第r轮的接受轮次。如果有的普通区块没有被所有知名可见证者看到，则它的接受轮次未定，而且肯定会比r更晚。 在确定了接受轮次后，则对所有event做排序，先按照接受轮次从低到高排，一样的话按照时间戳从早到晚排序，如果具备序号一样的话，则按照event的签名与某随机数异或出来的结果来排序（将该轮中所有知名见证者的签名进行异或可得到该随机数），这样得出的顺序被称作共识顺序（Consensus order） &nbsp; 具体的投票过程如下所示：（图中也会对 知名见证人，创建轮次，接收轮次等概念做以讲解） 我们从上述的描述中知道了，节点在round中创建的第一个event叫做witness(见证者)，如下图：（中A节点的witness就是A1，A2，A3，同理其他三个节点的也是图上红色的event） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后第二轮的因为我们可以看到 D2 event 可以强可见(路径跨越了全网三分之二节点)绝大多数（三分之二） 1轮的见证人，所以从D2开始属于 第2轮次；然后A2、B2、C2 分别是第2轮次中的其他三个节点上的见证人。依次3轮次和4轮次都是(妈的 4轮次感觉不是强可见绝大多数3轮的见证人啊。。。图有毒？) 虚拟投票的核心是先对于每一个见证人我们都需要判断是否是 知名见证人？ 下面我们来举例说明如何判断B2是否 知名见证人的： 我们从 知名见证人的定义中知道，一个见证人是否知名，是由相对于它的下一轮次中的 见证人对当前见证人是否可见的数据超过了 三分之二 来决定的，但是这部分统计的操作是由 下下轮次的见证人来记的，如： B2是否是famous witness首先由A3，B3，C3，D3判定。然后对于判定的计数又是由再后面一个round中的witness决定的 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 首先，A3可见 B2，表示有一个从A3到B2的路径。换句话说，B2是A3的一个祖先，A3是B2的一个后裔。A3可见 B2，所以A3给B2投yes认为B2是 famous witness。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同样的 B3也可见B2，所以B3也认为B2是 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，C3也是由于可见B2，也认为B2就是它所谓人的 知名见证人，投了yes。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 同理，D3也是投了yes。那么在上面我们知道了 A3、B3、C3、D3都对B2投了yes。根据知名见证人的概念我们知道B2就是知名见证人了。 是到此投票还没有结束，因为我们接下来还需要统计票数。（交由下下轮次的见证人来统计） 投票的统计将在下一个round进行。所以B4来统计票数或者是D4统计票数。 因为第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。 上图中没有A4和C4.但是随着时间的推移，hashgraph越来越大，A4和C4也会出现，他们也可以对投票进行计数。所以： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; B4 收集它能够 强可见的 见证人(及第2轮次的见证人)的投票结果。 在这个例子中，B4能够强可见A3.绿色的那条路径，实际上已经B4由多条路径到达A3.所以B4是强可见 A3的. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 同样的，B4 强可见 B3. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 同理，B4 强可见 D3。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 至此，B4收到了超过 三分之二的yes票，所以B4可以认定投票结果是yes。所以绿色的B2节点现在就是 知名见证人了。【注意】：根据数学理论证明，任何一个 R+2 轮见证人如果对投票结果做出了决定，那么这个结果就是全网的结论，如果这轮见证人无法做出决定，就由下一轮见证人计票决定，直到得出确切结论。 假如在下一轮无法做出决定（例如 2:2 的投票结果），则将延续到下一轮，根据数学定理只要我们在每十轮增加一个随机轮次（ coin round ），则选举过程最终一定会结束（以概率 1 收敛，通俗点说就是几乎必然收敛，这是概率论中的概念）。在随机轮中，收集到绝对多数结果的见证人仅投票而不做决定，而其他见证人则根据数字签名的中间位进行随机投票。 那么我们再往下看，C2是不是 知名节点呢？： 上图中黄色路径表明，C3能 可见 C2，所以C3投票yes。但是A3，B3，D3不可见 C2，所以它们投票为No。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 由于 B4 强可见 A3，B3，C3, D3，所以它将统计投票结果，投票分别是No，No，Yes，No，所以结果是No。所以C2不是知名见证人啦。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 经过一系列的过程后，我们可以看到A2，D2，A1，B1，C1，D1都是 知名见证人。 但是在这个过程中，我们可以看到，大多数event都不是 见证人，所以对大多数的event 来说都没投票。大多数证人在第一轮投票中以几乎一致的投票被宣布为 知名见证人的。所以大多数选举不会持续很长时间 （这就是 共识很快的原因） 在上面的演示中，我们已经确定了round 2中每个 见证人的声望（即 A2、B2、C2、D2的是否知名见证人的声望）。一旦一个round中的所有见证人的声望已经确定，那我们就可以为一组event找到 接收轮次 和 共识时间戳。 如： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先考虑A2以下的灰色event，这个event（黑色的event）能够被round2中的每个 知名见证人 可见（如图中红色、绿色、蓝色路径所示）。【注意】：这里仅仅要求 可见，而不是 强可见。这里不要求C2 可见，因为C2不是 知名见证人。 因为黑色的这个event能够被round 2中的所有&nbsp; 知名见证人 可见，所以我们就说这个黑色 event 的 接收轮次 为round 2【看上面 接收轮次的概念也会明白的】 【接下来我们开始确定黑色事件的共识时间戳用于后续确定共识顺序】： 寻找 A 节点最早的事件 X，它既是 A2 的祖先也是黑色事件的儿子，同理寻找 B 节点的 Y 和 D 节点的 Z。然后将 XYZ 事件的时间戳依次排序并取中位数作为黑色节点的共识时间戳。然后我们继续确定其他节点的接受轮次。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以此类推， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 我们可以找到6个黑色event和4个深绿色event的共识。一共就由10 个接受轮次为 2 的event，我们需要将这10个event按照所有节点都同意的顺序排序。这个顺序就是共识顺序。我们按照以下优先级进行排序： 接受轮次 共识时间戳 按事件签名和某随机数异或的结果排序，这个随机数通过该轮所有知名见证人的数字签名进行异或运算得到 &nbsp; 完整的Hashgraph共识算法： 每个节点都在试图随机找到其他节点把自己所知event 通过gossip传播给对方。 每个节点同时也在接受其他节点更新过来的event，接受方节点需要额外进行一系列的运算，包括： 接受和处理接收的event信息 创建一个新的event，并且指向自己的最后event和gossip来源节点的最后event 对所有已知的event分配创建轮次，并确定区块是否是该轮次内的见证人 对所有已知的见证人区块进行选举投票，计算出是否 知名见证人 通过知名见证人，确定所有区块的共识顺序 这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。 &nbsp; &nbsp; 三大优点：&nbsp; 公平 采用一致的时间戳，每一个事件，以及区块里的每一笔交易都有顺序（没有矿工） 速度 根据官网的测试数据，可以达到惊人的 250000 TPS；因为使用gossip做传播的，所以很快就能出 知名见证人，及很快就能达到共识 安全 Hashgraph 是一个 ABFT 系统，没有一个节点可以阻止网络达成共识或者在达成共识之后修改数据，号称能达到银行级别的安全性 Hashgraph通过增加随机性成为一种非确定性的异步协议。假设共识协议最终会终止，但终止发生的时间是不确定的。在目前的设计中，Hashgraph使用掷硬币（即签名的中间位）作为节点做出决定。因此，经过多轮抛硬币后，所有诚实节点具有相同的值的概率是非零的。最终所有诚实的节点将会变得一致。然而，如果所有拜占庭节点试图通过操纵gossip协议来破坏协议规则，如上面第2点所详述的那样，这种抛硬币方法的有效性和效率就成了问题，因为它可能需要多轮才能达成共识。 目前存在的问题： 目前为私有链，吞吐量参考价值存疑 目前Hashgraph是一个私有链，它的“运行速度快”只能跟其他私有链做比较，比如Hyperledger（700个交易/秒）和Red Belly（400,000个交易/秒），如果拿它的速度跟比特币和以太坊等公链来比较的话，是非常不公平的，因为现在的Hashgraph不需要设置防范恶意节点攻击的机制。此外，gossip算法是否适用于大规模公链环境也仍值得探讨。 能否经受恶意攻击 女巫攻击（Sybil attack），即攻击者通过创建大量假身份来破坏对等网络的信誉系统，并利用它们获得不成比例的巨大影响力。目前Hashgraph作为一个私有链，所有节点的身份已知，这种准入控制使得现阶段的Hashgraph无需考虑女巫攻击的危险。但如果未来Hashgraph打算往公有链方向发展的话，能否抵御女巫攻击将是Hashgraph必须思考的一个问题。 投票验证可能花费较多时间 Hashgraph的算法虽然很容易建立事件，但是在每个Round之后的投票验证过程却有可能很长。如果一直无法达到超过2/3的绝对多数，有可能要进行很多轮投票来决定谁记录的交易有效。（虽然我们从上面的图示中已经知道每轮投票其实只发生在 各个见证人之间，其他非见证人的 event 不参与，但是还是可能会存在这个一直无法达到超过2/3的绝大多数啊） 外部条件不同时的公平性问题：交易顺序如何决定？ Hashgraph白皮书中对公平性（Fairness）的解释如下： 假定存在A、B两个节点，A在B之前发出交易请求，如果最终在共识机制的判断下，A的交易的时间戳早于B的交易，我们就说该系统是有公平性的。如果A和B同时发生交易，并且两笔交易几乎是同时上传到网络并传播，此时就可能产生分叉，但是我们也说该系统是公平的。（why？？？）大多数共识机制都能够在以上两种情况下达到公平。 但是此解释是建立在A、B节点面临着同样的外部网络情况的假设前提下的。但我们考虑这样一个情况： 如果A的带宽是5M/s，而B的带宽是10M/s，A确实是比B早一点在网络中上传自己的交易信息，但是由于带宽限制，A的消息的传播速度会慢于B，这样就有可能导致最终投票时大多数人都更先接收到B的消息。这就像是在学校里，B的朋友更多，影响力大于A，因此在讨论八卦的时候，B可以把自己想传播的八卦信息更快地告诉更多人。即使可能是由A先开始传播八卦的，但因为影响力限制，大多数人都先听到B口中的版本。 在节点的外部条件不同时，投票是否也能反应真实地交易顺序，目前没有明确说明，因此仍然存在公平性的疑虑。 代码不开源 Hashgraph的代码不开源，且有专利保护，开发者需要申请SDK来进行开发，这是Hashgraph变成公链需要面临的一个很大障碍，这种闭源性本身与加密数字货币开源的理念是相违背的，所声称的公平、安全也无法提供确切的证据证明，可能无法得到信任。 &nbsp; &nbsp; 文中没有提到，那就是该算法应该是运行在代理之上的，因为每一步决定 知名见证人 的时候需要超过三分之二的 见证人强可见&nbsp; 这个event，所以推测应该是运行在代理（中心节点？）之上的，因为在全网的话无法判断三分之二具体是多大的数字。另外此算法的机制比较复杂，也没有一个很好的证明能够说明该算法在及时收敛上是管用的。 OK，到这里，我对hashgraph的抄袭也到此结束了，放心吧，这些文章我这个水货怎么可能是自己写出来的呢，我不东搬西运是不可能写下来的。。啦啦啦 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/08/28/b130fa8eeeda117529d480d9b9ccc97a.html","headline":"【我的区块链之路】- 去中心化的神级大作Hashgraph的讲解","dateModified":"2018-08-28T00:00:00+08:00","datePublished":"2018-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/28/b130fa8eeeda117529d480d9b9ccc97a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【我的区块链之路】- 去中心化的神级大作Hashgraph的讲解</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="color:#f33b45;">【转载请标明出处】：&nbsp;</span><a href="https://blog.csdn.net/qq_25870633/article/details/82057232" rel="nofollow"><span style="color:#f33b45;">https://blog.csdn.net/qq_25870633/article/details/82057232</span></a></p> 
  <p>本文章参考自：</p> 
  <p><a href="https://blog.csdn.net/lcloveyou/article/details/80289258" rel="nofollow">https://blog.csdn.net/lcloveyou/article/details/80289258</a></p> 
  <p><a href="https://jiasule.v2ex.com/t/446575" rel="nofollow">https://jiasule.v2ex.com/t/446575</a></p> 
  <p>首先今天我们来说一说HashGraph是个什么东西，在当下的区块链之所以没有被大规模的应用落地，其中TPS的瓶颈就是其中之一也是比较重量级的问题，所以充满了智慧的人类们想出了：<span style="color:#3399ea;">侧链</span>、<span style="color:#ffbb66;">超级节点</span>、<span style="color:#86ca5e;">分片</span>、<span style="color:#e579b6;">DAG</span>、<span style="color:#f33b45;">HashGraph</span>等等手段来提升区块链的TPS；我们在之前的文章&nbsp;<a href="https://blog.csdn.net/qq_25870633/article/details/82027506" rel="nofollow">DAG模型讲解及IOTA中的使用</a>&nbsp;中已经了解到了提升TPS的DAG方案，那么我们今天要讲的HashGraph也是基于DAG的，<span style="color:#f33b45;">Hashgraph 是一种数据结构和共识算法</span>。Hashgraph 不是数字货币，也不是区块链（因为<span style="color:#f33b45;">它其实是 DAG 图，并非是链式结构</span>）；</p> 
  <p>首先我们来看几张对比图来看看hashgraph是如何如何的牛逼，怎么怎么的神级的：</p> 
  <p>图一：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828021136544?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>图二：</p> 
  <p>&nbsp;</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828021205268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>图三：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180828021239294?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1ODcwNjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>在看完牛逼高大上的图片后，我们再来了解下几个东西。【不明白没关系，先记住我们往下看就可以】：</p> 
  <p>【一】：hashgraph中节点通过gossip协议进行通信，也就是说每个节点重复的随机的同步其他的节点</p> 
  <p>【二】：<span style="color:#f33b45;">hashgraph中是使用event来记录交易信息</span></p> 
  <p>【三】：底层实际上仍然是DAG</p> 
  <p>【四】：<span style="color:#f33b45;">异步拜占庭</span></p> 
  <p>【五】：<span style="color:#f33b45;">是用了虚拟投票</span></p> 
  <p>在HashGraph中我们是用Event 来记录交易信息的，类似于Block，event的内容为：<span style="color:#f33b45;">前两个event的hash值</span>、<span style="color:#f33b45;">当前时间戳</span>及<span style="color:#f33b45;">若干笔交易</span>：</p> 
  <p><img alt="" class="has" src="https://s1.ax2x.com/2018/04/12/NCT9a.jpg"></p> 
  <p>即：<span style="color:#f33b45;">在 Hashgraph 中，每一个节点都在传播经过签名的已经从临近节点接收到Event的新打包event。当某个节点收到包含新交易信息的数据后，会组合并可能添加自己所知道的交易成为一个新的Event。</span>Event是一个数据结构，除了包含自己的交易外，还包含它的之前的两个时间的hash。</p> 
  <p>假设目前全网的节点为A、B、C、D四个节点，且每个节点现在都有一个创世event，我们用竖线代表时间轴，如图：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512102726260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>紧接着：B节点随机的把自己的event【<span style="color:#ffbb66;">黄色</span>】广播给了D节点，D节点就会创建一个新的event【<span style="color:#f33b45;">红色</span>】，这个新event里除了<span style="color:#f33b45;">加入新的交易</span>事务的同时，还会加上两个指向父区块的hash值，一个指向自己的最新区块【<span style="color:#3399ea;">蓝色</span>】，一个指向B和自己聊天时候最新的event【<span style="color:#ffbb66;">黄色</span>】(这一点类似于Git使用hash实现的链接，只不过git是单父亲模式)</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512102927403?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>然后对整个事件加上时间戳并签名并继续开始随机广播重复上述动作，整个循环不断进行直到所有节点都获得相同的信息。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103004846?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>最后整网的event及节点从逻辑上是如上图这样表现的；</p> 
  <h2><span style="color:#e579b6;">Event包含交易、两个hash、时间戳、签名，通过gossip协议通信</span></h2> 
  <p>由于每个节点都会通过gossip维护一个散列图（最终每个节点都会记录着所有交易信息），所以<span style="color:#f33b45;">每个节点计算共识投票的时候可以发起虚拟投票</span>，也就是<span style="color:#f33b45;">计算其他节点在给定的散列图中会怎么投票</span>，从而不需要在网络上再做大量节点间的双向同步通信。</p> 
  <h2><span style="color:#7c79e5;">【注意】：</span></h2> 
  <p><span style="color:#e579b6;">在某一时刻，不同节点的散列图中最新的区块可能都各不一样，但是更早些的区块和继承关系都是一致的， 而且随着时间的推逝和八卦的积极进行，他们的散列图会收敛到相同的结果</span>。这里的一致指的是如果两个节点的散列图里都有区块x，那么这两个x都会指向相同的两个父区块。</p> 
  <p>Hashgraph里每个节点都会试图整理区块的顺序，这时节点就会对自己发起共识提案，例如“区块a是否早于区块b”，然后节点会照着自己保存的散列图有如精分一般遵从写死的代码逻辑和规则的从每个已知节点的角度进行投票计票和共识运算。这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，<span style="color:#f33b45;">共识迟早会进行并达成</span>，只是有早有晚。</p> 
  <h1>虚拟投票：</h1> 
  <p>上面我们看到了 <span style="color:#f33b45;">Hashgraph 如何在节点之间通信，但这仅仅只是通信步骤</span>，节点之间达成<span style="color:#3399ea;">共识还需要虚拟投票机制</span>，为什么说是虚拟投票，因为通过执行gossip算法后所有节点都是全节点(<span style="color:#3399ea;">为什么这么说？因为随着时间的推移，所有节点上都会引用了整网的event啊！！上面就有说了</span>)，都存储了完整的网络历史(<span style="color:#3399ea;">可能不同时间节点存储的不一样！但是最终都会趋向一样！</span>)，在需要对某一提案达成共识时并不需要大规模的消息通信，每个节点独立执行投票算法，并且所有节点一定会得出相同的共识结果（<span style="color:#3399ea;">因为知道最终大家所村的信息都会趋向一致，虽然不同时间存储的不一样，所以就会自信满满的相信，大家自己所算的结果也会和我的一致</span>）。</p> 
  <h1>【Hashgraph的几个重要的概念】：(8个)</h1> 
  <ul>
   <li><strong>round（<span style="color:#f33b45;">轮次</span></strong><strong>）</strong>：是hashgraph中一个重要的概念，所有的节点收到event时都以同样的方法计算。&nbsp;按照<span style="color:#e579b6;">时间水平线</span>划分round。每个round都有一个编号index，<span style="color:#f33b45;">每个节点在round[r]中创建的第一个event就叫做witness</span>。一旦出现一个可以see 三分之二个witness的event的时候，从该event起就是新的round[r+1]了。</li> 
   <li><strong>round created（<span style="color:#f33b45;">创建轮次</span>）</strong>：一个event的创建轮次是： R 或者 R+1，其中 R 是该事件父节点的最大轮次。<strong>当且仅当event能<span style="color:#f33b45;">强</span><span style="color:#3399ea;">可见</span><span style="color:#f33b45;">绝对多数</span>的 R 轮见证人</strong>，则该事件的创建轮次为 R+1；换句话说，（&nbsp;按照时间水平线划分round。每个round都有一个编号index，每个节点在round[r]中创建的第一个event就叫做witness。<strong>一旦出现一个强可见<span style="color:#f33b45;">三分之二</span>个witness的event的时候，从该event起就是<span style="color:#3399ea;">新的round[r+1]了</span></strong>，那么<span style="color:#f33b45;">这个新的r+1的round就是创建轮次</span>）</li> 
  </ul>
  <p>简单来说，某个event在节点上传来传去，总得有个头才行，因为对一个没听过这个event的新节点而言，听到这个event的时候，自己签名加入transaction之后就是一个新的event了；</p> 
  <h2><strong>整个hashgraph的目标</strong>：【是就<span style="color:#f33b45;">这些event的发生次序在整个节点网络达成共识，同时实现异步BFT</span>。对于某个event而言，<span style="color:#7c79e5;">从见证人到知名见证人的转变</span>，<span style="color:#e579b6;">就好比比特币区块链上确认数从1个到6个的过程</span>，对于这个event的确认信心逐渐增强的过程，当知名见证人达到绝大多数的时候，这个普通event就被整个网络确认了】，然后确认下一个event，这样一个一个将不断新加入的event定好顺序</h2> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>round received（<span style="color:#f33b45;">接受轮次</span>）</strong>：<strong>如果 R 轮（创建轮次）中的所有<span style="color:#f33b45;">知名见证人可见【注意这里不要求是强可见哦】某一</span><span style="color:#7c79e5;">普通event</span>，<span style="color:#3399ea;">则该</span><span style="color:#f33b45;">event的接受轮次</span><span style="color:#3399ea;">就是 R 轮</span></strong>，如果某普通event<span style="color:#f33b45;">没有被 R </span>轮所有知名见证人可见，则它的接受轮次一定晚于 R 轮。【其实也就类似于，被6个块所引用的块叫做确认块是一个道理】</li> 
   <li><strong>witness（<span style="color:#f33b45;">见证人</span>）</strong>：<strong><span style="color:#7c79e5;">每一节点在每一轮次中创建的第一个Event</span>被称为<span style="color:#f33b45;">见证人</span></strong>（也可看作该轮次中相对的先祖evnet）。某节点也有可能在某一轮次中没有创建见证人event。</li> 
   <li><strong>famous witness（<span style="color:#f33b45;">知名见证人</span>）</strong>：如果<strong> R 轮的见证人能<span style="color:#f33b45;">被绝对多数(三分之二)</span>的 R+1 轮见证人可见，则它就是知名见证人</strong>。(因为出名了啊，下一轮的见证人都能看到你怎么会不出名呢？)</li> 
  </ul>
  <p>【其他几个概念】</p> 
  <ul>
   <li><strong>supermajority （<span style="color:#f33b45;">绝大多数</span>）</strong>：超过 2/3 以上节点的数量</li> 
  </ul>
  <p>如果Alice作假，自己产生了两个新区块b和c都指向自己的最后的一块区块a，那么在Alice的纵轴上就会从链状变成树状，等于进行了分叉攻击。<span style="color:#3399ea;">如果Alice把b的存在告诉了Bob，而把c的存在告诉了Carol，那么Bob和Carol这两个节点所进行的虚拟投票就会变得不一样（分叉了）。</span>为了防止这个问题的发生，Hasgraph引入了可见（Seeing）和强可见（Strongly seeing）的概念。</p> 
  <ul>
   <li><strong>seeing&nbsp;（<span style="color:#f33b45;">可见</span>）</strong>：当事件 B 可以沿着哈希指针（不论路径有多长哦）找到事件 A，那么<span style="color:#f33b45;">事件 B 就可见事件 A</span></li> 
   <li><strong>strongly seeing（<span style="color:#f33b45;">强可见</span>）</strong>：<strong>当事件 B 能找到事件 A 的<span style="color:#f33b45;">所有路径</span>中跨越了绝对多数的节点(<span style="color:#3399ea;">就是说B找A的路径上的event相互引用跨越了全网三分之二节点</span>)</strong>，<strong>那么事件 B <span style="color:#f33b45;">强可见</span>事件 A</strong>。经过数学论证是可以保证<span style="color:#f33b45;">两个强可见的event</span>在虚拟投票时能获得一致的结果，简单理解就是：件A和B的发生次序（order）得到了全网节点的共识</li> 
  </ul>
  <p><strong>实际上就是，由强可见保证了两个节点在虚拟计票的时候，能够获得一致的结果。从而为作为Hashgraph能够达成最终拜占庭一致的理论基础。</strong></p> 
  <h1>虚拟投票：</h1> 
  <p>（<span style="color:#3399ea;">每个节点都可以在本地通过虚拟投票的拜占庭协议来决定某见证人区块是否是知名见证人</span>。<span style="color:#7c79e5;">每个r＋1轮的见证人区块都会对某第r轮见证人区块进行</span><span style="color:#f33b45;">投票</span>；而<span style="color:#3399ea;">第r+2轮的某一见证人会对第r+1轮的投票进行</span><span style="color:#f33b45;">计票</span>，即第r+2轮的见证人会从自己可以强见到的第r+1轮见证人那里收集投票结果。一旦某个投票结果（Yes or No）的计票数目超过绝大多数，第r+2轮见证人就可以决定出投票的结果（decide），就算达成了共识）</p> 
  <p>简单理下：<span style="color:#e579b6;">某个第一代先祖是否知名</span>？，<span style="color:#3399ea;">必须由第二代先祖来投票他们是否可见第一代祖先，而具体的计票则由第三代先祖进行，第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。</span></p> 
  <p><span style="color:#f33b45;">任何一个第三代先祖如果能对投票结果（Yes or No）做出决定</span>，那么这个结果就是全网的结论。</p> 
  <p>【注意】：<strong>如果这一轮(这个第三代)的见证人没发做出决定（没有任何结果超过绝对多数），那么则会继续交由下一代先祖来计票做决定</strong>，直到某轮某个先祖得出明确的结果。文中还有另一理论证明，<strong>只要每十轮增加一个随机轮（Coin round），投票肯定终究能完成</strong>。在随机轮中，见证者不会做出任何决定，如果见证人收集到了绝对多数的结果，他会根据结果进行附议投票，否则，见证人则根据自己的数字签名进行随机投票。</p> 
  <p><strong>在正常情况下，大部分的event并非见证人event，所以对于这些event都不会举行上述的选举知名见证人的投票</strong>。而且大部分见证人会在第一轮投票中被一致通过或否决。所以大部分的选举投票不会耗时太过漫长。此外，一旦所有知名见证人被确定下来，整个网络里的event顺序（所谓公平性）也就能被更快更容易被推导出来。</p> 
  <p><span style="color:#f33b45;">为了确定区块顺序</span>所以<span style="color:#7c79e5;">引入了接受轮次</span>（received round）的概念，每个event除了创建轮次外还有接受轮次，<span style="color:#f33b45;">第r轮（创建轮次）中所有的知名见证者可见的任何普通event都会被赋予第r轮的接受轮次</span>。如果有的普通区块没有被所有知名可见证者看到，则它的接受轮次未定，而且肯定会比r更晚。</p> 
  <p><span style="color:#f33b45;">在确定了接受轮次后，则对所有event做排序</span>，先按照接受轮次从低到高排，一样的话按照时间戳从早到晚排序，如果具备序号一样的话，则按照event的签名与<span style="color:#f33b45;">某随机数</span><span style="color:#7c79e5;">异或</span>出来的结果来排序（<span style="color:#7c79e5;">将该轮中所有知名见证者的签名进行异或可得到该随机数</span>），这样得出的顺序被称作<strong><span style="color:#f33b45;">共识顺序</span></strong>（Consensus order）</p> 
  <p>&nbsp;</p> 
  <p><strong>具体的投票过程如下所示：（图中也会对 知名见证人，创建轮次，接收轮次等概念做以讲解）</strong></p> 
  <p>我们从上述的描述中知道了，节点在round中创建的第一个event叫做witness(见证者)，如下图：（<span style="color:#7c79e5;">中A节点的witness就是A1，A2，A3，同理其他三个节点的也是图上红色的event</span>）</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103107837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>然后第二轮的因为我们可以看到 D2 event 可以强可见(路径跨越了全网三分之二节点)绝大多数（三分之二） 1轮的见证人，所以从D2开始属于 第2轮次；然后A2、B2、C2 分别是第2轮次中的其他三个节点上的见证人。依次3轮次和4轮次都是(妈的 4轮次感觉不是强可见绝大多数3轮的见证人啊。。。图有毒？)</p> 
  <h2><strong>虚拟投票的核心是先对于每一个见证人我们都需要判断是否是 知名见证人？</strong></h2> 
  <p>下面我们来举例说明如何判断B2是否 知名见证人的：</p> 
  <p>我们从 知名见证人的定义中知道，一个见证人是否知名，是由相对于它的下一轮次中的 见证人对当前见证人是否可见的数据超过了 三分之二 来决定的，但是这部分统计的操作是由 下下轮次的见证人来记的，如：</p> 
  <p>B2是否是famous witness首先由A3，B3，C3，D3判定。然后对于判定的计数又是由再后面一个round中的witness决定的</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103225813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>首先，A3可见 B2，表示有一个从A3到B2的路径。换句话说，B2是A3的一个祖先，A3是B2的一个后裔。A3可见 B2，所以A3给B2投yes认为B2是 famous witness。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103318823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>同样的 B3也可见B2，所以B3也认为B2是 知名见证人，投了yes。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103352436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>同理，C3也是由于可见B2，也认为B2就是它所谓人的 知名见证人，投了yes。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103433978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>同理，D3也是投了yes。那么在上面我们知道了 A3、B3、C3、D3都对B2投了yes。根据知名见证人的概念我们知道B2就是知名见证人了。</p> 
  <h2><span style="color:#f33b45;"><strong>是到此投票还没有结束，因为我们接下来还需要统计票数。（交由下下轮次的见证人来统计）</strong></span></h2> 
  <p>投票的统计将在下一个round进行。所以B4来统计票数或者是D4统计票数。</p> 
  <p>因为<span style="color:#3399ea;">第三代先祖肯定是可以强见绝对多数的第二代先祖的（参看创建轮次的定义），所以第三代先祖可以看到并记录下第二代先祖的投票，并且决定投票结果。</span></p> 
  <p><strong><span style="color:#f33b45;">上图中没有A4和C4.但是随着时间的推移，hashgraph越来越大，A4和C4也会出现</span></strong>，他们也可以对投票进行计数。所以：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103530890?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>B4 收集它能够 强可见的 见证人(及第2轮次的见证人)的投票结果。</p> 
  <p>在这个例子中，B4能够强可见A3.绿色的那条路径，实际上已经B4由多条路径到达A3.所以B4是强可见 A3的.</p> 
  <p><span style="color:#3399ea;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103613516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><span style="color:#3399ea;">&nbsp;</span></p> 
  <p>同样的，B4 强可见 B3.</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103743571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>同理，B4 强可见 D3。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512103815446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>至此，B4收到了超过 三分之二的yes票，所以B4可以认定投票结果是yes。所以绿色的B2节点现在就是 知名见证人了。【注意】：根据数学理论证明，<span style="color:#f33b45;">任何一个 R+2 轮见证人如果对投票结果做出了决定，那么这个结果就是全网的结论</span>，<span style="color:#3399ea;">如果这轮见证人无法做出决定，就由下一轮见证人计票决定，直到得出确切结论</span>。</p> 
  <p>假如在下一轮无法做出决定（例如 2:2 的投票结果），则将延续到下一轮，根据数学定理只要我们在<span style="color:#e579b6;">每十轮增加一个随机轮次</span>（ coin round ），则<span style="color:#e579b6;">选举过程最终一定会结束</span>（以概率 1 收敛，通俗点说就是几乎必然收敛，这是概率论中的概念）。<span style="color:#3399ea;"><strong>在随机轮中，收集到绝对多数结果的见证人仅投票而不做决定</strong></span>，而<span style="color:#3399ea;">其他见证人则根据数字签名的中间位进行随机投票。</span></p> 
  <p>那么我们再往下看，C2是不是 知名节点呢？：</p> 
  <p>上图中黄色路径表明，C3能 可见 C2，所以C3投票yes。但是A3，B3，D3不可见 C2，所以它们投票为No。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512104109762?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>由于 B4 强可见 A3，B3，C3, D3，所以它将统计投票结果，投票分别是No，No，Yes，No，所以结果是No。所以C2不是知名见证人啦。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512104134132?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>经过一系列的过程后，我们可以看到A2，D2，A1，B1，C1，D1都是 知名见证人。</p> 
  <p>但是在这个过程中，我们可以看到，大多数event都不是 见证人，所以对大多数的event 来说都没投票。大多数证人在第一轮投票中以几乎一致的投票被宣布为 知名见证人的。<strong><span style="color:#f33b45;">所以大多数选举不会持续很长时间 （这就是 共识很快的原因）</span></strong></p> 
  <h2>在上面的演示中，我们已经确定了round 2中每个 见证人的声望（即 A2、B2、C2、D2的是否知名见证人的声望）。<span style="color:#f33b45;">一旦一个round中的所有见证人的声望已经确定，那我们就可以为一组event找到 </span><span style="color:#3399ea;">接收轮次 和 共识时间戳</span>。</h2> 
  <p>如：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018051210415772?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>首先考虑A2以下的灰色event，这个event（黑色的event）能够被round2中的每个 知名见证人 可见（如图中<span style="color:#f33b45;">红色</span>、<span style="color:#86ca5e;">绿色</span>、<span style="color:#3399ea;">蓝色</span>路径所示）。【注意】：这里仅仅要求 可见，而不是 强可见。这里不要求C2 可见，因为C2不是 知名见证人。</p> 
  <h3><strong>因为黑色的这个event能够被<span style="color:#f33b45;">round 2</span>中的所有&nbsp; 知名见证人 可见，所以我们就说这个黑色 event 的 接收轮次 为<span style="color:#f33b45;">round 2</span>【看上面 接收轮次的概念也会明白的】</strong></h3> 
  <h1>【接下来我们开始确定黑色事件的共识时间戳用于后续确定共识顺序】<strong>：</strong></h1> 
  <p>寻找 A 节点最早的事件 X，它既是 A2 的祖先也是黑色事件的儿子，同理寻找 B 节点的 Y 和 D 节点的 Z。然后将 XYZ 事件的时间戳依次排序并取中位数作为黑色节点的共识时间戳。然后我们继续确定其他节点的接受轮次。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180512104309968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbG92ZXlvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>以此类推，</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="N1jhY.jpg" class="has" src="https://s1.ax2x.com/2018/04/13/N1jhY.jpg"></p> 
  <p>我们可以找到6个黑色event和4个深绿色event的共识。一共就由10 个接受轮次为 2 的event，<span style="color:#3399ea;">我们需要将这10个event按照所有节点都同意的顺序排序</span>。这个顺序就是<span style="color:#f33b45;"><strong>共识顺序</strong></span>。我们按照以下优先级进行排序：</p> 
  <ul>
   <li>接受轮次</li> 
   <li>共识时间戳</li> 
   <li>按事件签名和某随机数异或的结果排序，这个<span style="color:#3399ea;">随机数通过该轮所有知名见证人的数字签名进行异或运算得到</span></li> 
  </ul>
  <p>&nbsp;</p> 
  <h1>完整的Hashgraph共识算法：</h1> 
  <ol>
   <li> <p>每个节点都在试图随机找到其他节点把自己所知event 通过gossip传播给对方。</p> </li> 
   <li> <p>每个节点同时也在接受其他节点更新过来的event，接受方节点需要额外进行一系列的运算，包括：</p> 
    <ol>
     <li> <p>接受和处理接收的event信息</p> </li> 
     <li> <p>创建一个新的event，并且指向自己的最后event和gossip来源节点的最后event</p> </li> 
     <li> <p>对所有已知的event分配创建轮次，并确定区块是否是该轮次内的见证人</p> </li> 
     <li> <p>对所有已知的见证人区块进行选举投票，计算出是否 知名见证人</p> </li> 
     <li> <p>通过知名见证人，确定所有区块的共识顺序</p> </li> 
    </ol></li> 
  </ol>
  <p><strong>这里的共识是异步的，意味着每个节点会在不同时间点发起虚拟投票，做出决定，并且自信满满地相信这个提案在全网络下会获得相同的决定（即共识）。还是那句话，共识迟早会进行并达成，只是有早有晚。</strong><br> &nbsp;</p> 
  <p>&nbsp;</p> 
  <h1><strong>三大优点：&nbsp;</strong></h1> 
  <ul>
   <li> <p>公平</p> <p>采用一致的时间戳，每一个事件，以及区块里的每一笔交易都有顺序（没有矿工）</p> </li> 
   <li> <p>速度</p> <p>根据官网的测试数据，可以达到惊人的 250000 TPS；因为使用gossip做传播的，所以很快就能出 知名见证人，及很快就能达到共识</p> </li> 
   <li> <p>安全</p> <p>Hashgraph 是一个 ABFT 系统，没有一个节点可以阻止网络达成共识或者在达成共识之后修改数据，号称能达到银行级别的安全性</p> </li> 
  </ul>
  <p>Hashgraph通过<strong>增加随机性</strong>成为一种非确定性的异步协议。假设共识协议最终会终止，但<span style="color:#3399ea;">终止发生的时间是不确定的</span>。在目前的设计中，Hashgraph使用掷硬币（即签名的中间位）作为节点做出决定。因此，经过多轮抛硬币后，所有诚实节点具有相同的值的概率是非零的。<span style="color:#3399ea;">最终所有诚实的节点将会变得一致。</span>然而，如果所有拜占庭节点试图通过操纵gossip协议来破坏协议规则，如上面第2点所详述的那样，这种抛硬币方法的有效性和效率就成了问题，因为它可能需要多轮才能达成共识。</p> 
  <h1><strong>目前存在的问题：</strong></h1> 
  <p><strong>目前为私有链，吞吐量参考价值存疑</strong></p> 
  <p>目前Hashgraph是一个私有链，它的“运行速度快”只能跟其他私有链做比较，比如Hyperledger（700个交易/秒）和Red Belly（400,000个交易/秒），如果拿它的速度跟比特币和以太坊等公链来比较的话，是非常不公平的，因为现在的Hashgraph不需要设置防范恶意节点攻击的机制。此外，gossip算法是否适用于大规模公链环境也仍值得探讨。</p> 
  <p><strong>能否经受恶意攻击</strong></p> 
  <p>女巫攻击（Sybil attack），即攻击者通过创建大量假身份来破坏对等网络的信誉系统，并利用它们获得不成比例的巨大影响力。目前Hashgraph作为一个私有链，所有节点的身份已知，这种准入控制使得现阶段的Hashgraph无需考虑女巫攻击的危险。但如果未来Hashgraph打算往公有链方向发展的话，能否抵御女巫攻击将是Hashgraph必须思考的一个问题。</p> 
  <p><strong>投票验证可能花费较多时间</strong></p> 
  <p>Hashgraph的算法虽然很容易建立事件，但是在每个Round之后的投票验证过程却有可能很长。如果一直无法达到超过2/3的绝对多数，有可能要进行很多轮投票来决定谁记录的交易有效。（虽然我们从上面的图示中已经知道每轮投票其实只发生在 各个见证人之间，其他非见证人的 event 不参与，但是还是可能会存在这个一直无法达到超过2/3的绝大多数啊）</p> 
  <p><strong>外部条件不同时的公平性问题：交易顺序如何决定？</strong></p> 
  <p>Hashgraph白皮书中对公平性（Fairness）的解释如下：</p> 
  <p>假定存在A、B两个节点，A在B之前发出交易请求，如果最终在共识机制的判断下，A的交易的时间戳早于B的交易，我们就说该系统是有公平性的。<span style="color:#3399ea;">如果A和B同时发生交易，并且两笔交易几乎是同时上传到网络并传播，此时就可能产生分叉，但是我们也说该系统是公平的</span>。（why？？？）大多数共识机制都能够在以上两种情况下达到公平。</p> 
  <p>但是此解释是建立在A、B节点面临着同样的外部网络情况的假设前提下的。但我们考虑这样一个情况：</p> 
  <p>如果A的带宽是5M/s，而B的带宽是10M/s，A确实是比B早一点在网络中上传自己的交易信息，但是由于带宽限制，A的消息的传播速度会慢于B，这样就有可能导致最终投票时大多数人都更先接收到B的消息。这就像是在学校里，B的朋友更多，影响力大于A，因此在讨论八卦的时候，B可以把自己想传播的八卦信息更快地告诉更多人。即使可能是由A先开始传播八卦的，但因为影响力限制，大多数人都先听到B口中的版本。</p> 
  <p><span style="color:#3399ea;">在节点的外部条件不同时，投票是否也能反应真实地交易顺序，目前没有明确说明，因此仍然存在公平性的疑虑。</span></p> 
  <p><strong>代码不开源</strong></p> 
  <p>Hashgraph的代码不开源，且有专利保护，开发者需要申请SDK来进行开发，这是Hashgraph变成公链需要面临的一个很大障碍，这种闭源性本身与加密数字货币开源的理念是相违背的，所声称的公平、安全也无法提供确切的证据证明，可能无法得到信任。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>文中没有提到，那就是该算法应该是运行在代理之上的，因为每一步决定 知名见证人 的时候需要超过三分之二的 见证人强可见&nbsp; 这个event，所以推测应该是运行在代理（中心节点？）之上的，<span style="color:#f33b45;">因为在全网的话无法判断三分之二具体是多大的数字</span>。另外此算法的机制比较复杂，<span style="color:#f33b45;">也没有一个很好的证明能够说明该算法在</span><span style="color:#3399ea;">及时</span><span style="color:#f33b45;">收敛上是管用的</span>。</p> 
  <p>OK，到这里，我对hashgraph的抄袭也到此结束了，放心吧，这些文章我这个水货怎么可能是自己写出来的呢，我不东搬西运是不可能写下来的。。啦啦啦</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82057232,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82057232,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82057232,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_25870633/article/details/82057232,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
