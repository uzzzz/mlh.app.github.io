<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>探索比特币源码5-私钥 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="探索比特币源码5-私钥" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="经过一段时间的积累，终于来到了比特币源码阅读的环节。还是按照之前的节奏，我们就比对着精通比特币一书的进度，进行源码的阅读。 对于此文，只需你对比特币系统中私钥-公钥-地址的产生及关系有最基本的了解 因此你可以放心的直接阅读，如果遇到疑惑，可以返回来阅读以下资料，填补一些基本概念即可： 精通比特币第4章 椭圆曲线加密算法教程 密码学知识汇总 下面进入正题，本文将对比特币源码中的私钥相关部分进行梳理。 在阅读代码前，先明确一个概念：私钥是如何产生的？ 私钥如何产生 比特币的私钥就是一个256位二进制数字，就这么简单。 但是有一个条件，这个256位二进制数要小于一个非常大的质数n n = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141 这是由于比特币使用的椭圆曲线secp256k1的方程所对应的循环子群的秩为n。 这一点了解即可，如果你想了解为什么，建议仔细阅读椭圆曲线加密算法教程 也就是说，你可以用硬币、铅笔和纸来随机生成你的私钥： 掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥，只要其小于n。 当然更普遍的方法是使用代码生成，但是一定要注意：在你不够了解随机数产生器前，不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数作为私钥。应使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。（这段警告来自于《精通比特币》，我目前还不知晓怎样才算一个足够安全的伪随机数发生器，也望大家告知交流） 代码阅读 明确了私钥的定义，我们来阅读源码。 首先，我们进入src目录下 使用ls和grep命令，试图找到私钥-公钥相关源文件的位置 一番探索后确定，头文件key.h中的CKey类便是私钥的定义。 下面是key.h的源码，我个人的理解直接放在注释中了 // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Copyright (c) 2017 The Zcash developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_KEY_H #define BITCOIN_KEY_H #include &lt;pubkey.h&gt; // 显然这是定义公钥的代码 #include &lt;serialize.h&gt; #include &lt;support/allocators/secure.h&gt; #include &lt;uint256.h&gt; #include &lt;stdexcept&gt; #include &lt;vector&gt; /** * CPrivKey本质就是一个vector&lt;unsigned char&gt; * 其allocator在support/allocators/secure.h中进行了重载（具体原因暂不清楚） * 这个CPrivKey并不是我们理解的256bit的随机数私钥 * 而是一个编码后的一个私钥，编码的私钥长度为PRIVATE_KEY_SIZE或COMPRESSED_PRIVATE_KEY_SIZE。 * 从代码来看，这个私钥应该是DER编码的，具体什么是DER，为什么这样编码我还不太清楚。 */ typedef std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; CPrivKey; /** 封装的私钥类. */ class CKey { public: /** * 定义两个静态的大小用来表示普通私钥的长度和压缩后私钥的长度 * */ static const unsigned int PRIVATE_KEY_SIZE = 279; static const unsigned int COMPRESSED_PRIVATE_KEY_SIZE = 214; /** * 压缩后的私钥必须要比压缩前小，这是合理的要求了，使用static_assert在编译时进行检查 */ static_assert( PRIVATE_KEY_SIZE &gt;= COMPRESSED_PRIVATE_KEY_SIZE, &quot;COMPRESSED_PRIVATE_KEY_SIZE is larger than PRIVATE_KEY_SIZE&quot;); private: // 用于表示私钥是否有效 // 因为每次key被修改的时候都会做正确性判断，所以fValid应该和真实的状态保持一致。 bool fValid; // 表示对应私钥的公钥是否被压缩 bool fCompressed; //! 实际的私钥数据。 //! 这里存储的是我们所熟悉的256bit私钥（32字节） std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; keydata; //! 判断vch指向的32字节数据是否是有效的私钥数据 bool static Check(const unsigned char* vch); public: // 构造函数，初始化fValid和fCompressed，设置keydata的长度为32 CKey() : fValid(false), fCompressed(false) { keydata.resize(32); } // 重载Ckey的==运算符，只要密钥数据一致，是否压缩也一直，就表示两个CKey数据相同 friend bool operator==(const CKey&amp; a, const CKey&amp; b) { return a.fCompressed == b.fCompressed &amp;&amp; a.size() == b.size() &amp;&amp; memcmp(a.keydata.data(), b.keydata.data(), a.size()) == 0; } // 设置密钥的内容，并通过check判断是否为有效密钥 template &lt;typename T&gt; void Set(const T pbegin, const T pend, bool fCompressedIn) { if (size_t(pend - pbegin) != keydata.size()) { fValid = false; } else if (Check(&amp;pbegin[0])) { memcpy(keydata.data(), (unsigned char*)&amp;pbegin[0], keydata.size()); fValid = true; fCompressed = fCompressedIn; } else { fValid = false; } } // 这块是简单的加了几个方法，能让CKey的函数能够更方便的使用存储私钥的成员keydata unsigned int size() const { return (fValid ? keydata.size() : 0); } const unsigned char* begin() const { return keydata.data(); } const unsigned char* end() const { return keydata.data() + size(); } // 返回私钥是否有效 bool IsValid() const { return fValid; } // 返回私钥（对应的公钥）是否是压缩格式的 bool IsCompressed() const { return fCompressed; } //! 使用随机的方式创建一个新的密钥. void MakeNewKey(bool fCompressed); //! 获得私钥 //! 返回的私钥是CPrivKey类型的，也就是编码后的私钥 CPrivKey GetPrivKey() const; //! 获得公钥 //! 通过私钥计算出公钥并返回 CPubKey GetPubKey() const; /** * 签名，返回DER序列化的数字签名 * @param[in] hash 要进行签名的哈希值 * @param[out] 签名结果 * @param[test_case] 我也没搞清楚这是干啥的，貌似是传一个和随机数有关的任意数 */ bool Sign(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig, uint32_t test_case = 0) const; // Create a compact signature (65 bytes) bool SignCompact(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; // Derive BIP32 child key. bool Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const; // 验证私钥和公钥是否匹配。 // 使用的机制并不是使用私钥再次生成公钥并比对 bool VerifyPubKey(const CPubKey&amp; vchPubKey) const; // 加载一个私钥，顺便判断下与公钥是否匹配 bool Load(const CPrivKey&amp; privkey, const CPubKey&amp; vchPubKey, bool fSkipCheck); }; /** * 这也是一个私钥类型，应该是和HD钱包相关的 * CKey, CPubKey, CExtKey, CExtPubKey 是bitcoin core中的四种密钥实现 * 其中CKey, CPubKey是普通的私钥和公钥类型 * 而如果想使用 HD Wallet，必须使用CExtKey, CExtPubKey * 由于还不了解HD钱包，这个类我也没有详细阅读 * 或许可以看看这个https://medium.com/codechain/hd-wallet-observed-through-bitcoin-core-source-code-ce38f9eab371 */ struct CExtKey { unsigned char nDepth; unsigned char vchFingerprint[4]; unsigned int nChild; ChainCode chaincode; CKey key; friend bool operator==(const CExtKey&amp; a, const CExtKey&amp; b) { return a.nDepth == b.nDepth &amp;&amp; memcmp(&amp;a.vchFingerprint[0], &amp;b.vchFingerprint[0], sizeof(vchFingerprint)) == 0 &amp;&amp; a.nChild == b.nChild &amp;&amp; a.chaincode == b.chaincode &amp;&amp; a.key == b.key; } void Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const; void Decode(const unsigned char code[BIP32_EXTKEY_SIZE]); bool Derive(CExtKey&amp; out, unsigned int nChild) const; CExtPubKey Neuter() const; void SetMaster(const unsigned char* seed, unsigned int nSeedLen); template &lt;typename Stream&gt; void Serialize(Stream&amp; s) const { unsigned int len = BIP32_EXTKEY_SIZE; ::WriteCompactSize(s, len); unsigned char code[BIP32_EXTKEY_SIZE]; Encode(code); s.write((const char *)&amp;code[0], len); } template &lt;typename Stream&gt; void Unserialize(Stream&amp; s) { unsigned int len = ::ReadCompactSize(s); unsigned char code[BIP32_EXTKEY_SIZE]; if (len != BIP32_EXTKEY_SIZE) throw std::runtime_error(&quot;Invalid extended key size\n&quot;); s.read((char *)&amp;code[0], len); Decode(code); } }; // 使用椭圆算法加密前必须调用该程序启用上下文 void ECC_Start(void); // 使用椭圆加密后使用该函数销毁加密上下文 void ECC_Stop(void); // 获取运行时椭圆曲线需要的支持是否满足 bool ECC_InitSanityCheck(void); #endif // BITCOIN_KEY_H 下面简要的阅读源文件key.cpp 生成一个新的私钥的方法如下： bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(keydata.data(), keydata.size()); } while (!Check(keydata.data())); fValid = true; fCompressed = fCompressedIn; } 如前所述，比特币私钥其实就是一个256bit随机数（32字节长） 可以看到，代码中使用GetStrongRandBytes()函数生成强随机性的私钥 使用grep命令搜索该方法 $ grep -rlw &quot;GetStrongRandBytes&quot; * key.cpp random.cpp random.h wallet/wallet.cpp 最终确定，该方法位于random.h中，可在其中探寻详细代码 可以看到MakeNewKey()方法，通过不停调用GetStrongRandBytes(),直到找到能够满足要求的随机数作为私钥 Check()方法调用libsecp256k1加密库中的函数secp256k1_ec_seckey_verify进行验证 获取私钥的方法如下 CPrivKey CKey::GetPrivKey() const { assert(fValid); CPrivKey privkey; int ret; size_t privkeylen; privkey.resize(PRIVATE_KEY_SIZE); privkeylen = PRIVATE_KEY_SIZE; ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &amp;privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(ret); privkey.resize(privkeylen); return privkey; } 该函数核心是向ec_privkey_export_der()提供私钥数据keydata（通过begin()传递），进行DER序列化，并返回CPrivKey类型的私钥 至于比特币系统中为什么不传递原始的私钥，而是传递DER编码的私钥，相信随着不断学习，会得到答案。 获取公钥的方法如下 CPubKey CKey::GetPubKey() const { assert(fValid); secp256k1_pubkey pubkey; size_t clen = CPubKey::PUBLIC_KEY_SIZE; CPubKey result; int ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &amp;pubkey, begin()); assert(ret); secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned char*)result.begin(), &amp;clen, &amp;pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(result.size() == clen); assert(result.IsValid()); return result; } 可以看到，公钥的获取过程首先调用了libsecp256k1加密库中的函数secp256k1_ec_pubkey_create()生成了secp256k1_pubkey类型的公钥pubkey 然后又调用libsecp256k1加密库中的函数secp256k1_ec_pubkey_serialize将secp256k1_pubkey类型的公钥序列化为Bitcoin Core中的自定义公钥类型CPubKey 关于私钥的源码阅读就到这里。 由于刚刚窥探Bitcoin Core源码的冰山一角，难免出现理解错误的地方，本文中也列出了我目前还不理解的地方，还望各位能够指出~ 阅读更多" />
<meta property="og:description" content="经过一段时间的积累，终于来到了比特币源码阅读的环节。还是按照之前的节奏，我们就比对着精通比特币一书的进度，进行源码的阅读。 对于此文，只需你对比特币系统中私钥-公钥-地址的产生及关系有最基本的了解 因此你可以放心的直接阅读，如果遇到疑惑，可以返回来阅读以下资料，填补一些基本概念即可： 精通比特币第4章 椭圆曲线加密算法教程 密码学知识汇总 下面进入正题，本文将对比特币源码中的私钥相关部分进行梳理。 在阅读代码前，先明确一个概念：私钥是如何产生的？ 私钥如何产生 比特币的私钥就是一个256位二进制数字，就这么简单。 但是有一个条件，这个256位二进制数要小于一个非常大的质数n n = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141 这是由于比特币使用的椭圆曲线secp256k1的方程所对应的循环子群的秩为n。 这一点了解即可，如果你想了解为什么，建议仔细阅读椭圆曲线加密算法教程 也就是说，你可以用硬币、铅笔和纸来随机生成你的私钥： 掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥，只要其小于n。 当然更普遍的方法是使用代码生成，但是一定要注意：在你不够了解随机数产生器前，不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数作为私钥。应使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。（这段警告来自于《精通比特币》，我目前还不知晓怎样才算一个足够安全的伪随机数发生器，也望大家告知交流） 代码阅读 明确了私钥的定义，我们来阅读源码。 首先，我们进入src目录下 使用ls和grep命令，试图找到私钥-公钥相关源文件的位置 一番探索后确定，头文件key.h中的CKey类便是私钥的定义。 下面是key.h的源码，我个人的理解直接放在注释中了 // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Copyright (c) 2017 The Zcash developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_KEY_H #define BITCOIN_KEY_H #include &lt;pubkey.h&gt; // 显然这是定义公钥的代码 #include &lt;serialize.h&gt; #include &lt;support/allocators/secure.h&gt; #include &lt;uint256.h&gt; #include &lt;stdexcept&gt; #include &lt;vector&gt; /** * CPrivKey本质就是一个vector&lt;unsigned char&gt; * 其allocator在support/allocators/secure.h中进行了重载（具体原因暂不清楚） * 这个CPrivKey并不是我们理解的256bit的随机数私钥 * 而是一个编码后的一个私钥，编码的私钥长度为PRIVATE_KEY_SIZE或COMPRESSED_PRIVATE_KEY_SIZE。 * 从代码来看，这个私钥应该是DER编码的，具体什么是DER，为什么这样编码我还不太清楚。 */ typedef std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; CPrivKey; /** 封装的私钥类. */ class CKey { public: /** * 定义两个静态的大小用来表示普通私钥的长度和压缩后私钥的长度 * */ static const unsigned int PRIVATE_KEY_SIZE = 279; static const unsigned int COMPRESSED_PRIVATE_KEY_SIZE = 214; /** * 压缩后的私钥必须要比压缩前小，这是合理的要求了，使用static_assert在编译时进行检查 */ static_assert( PRIVATE_KEY_SIZE &gt;= COMPRESSED_PRIVATE_KEY_SIZE, &quot;COMPRESSED_PRIVATE_KEY_SIZE is larger than PRIVATE_KEY_SIZE&quot;); private: // 用于表示私钥是否有效 // 因为每次key被修改的时候都会做正确性判断，所以fValid应该和真实的状态保持一致。 bool fValid; // 表示对应私钥的公钥是否被压缩 bool fCompressed; //! 实际的私钥数据。 //! 这里存储的是我们所熟悉的256bit私钥（32字节） std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; keydata; //! 判断vch指向的32字节数据是否是有效的私钥数据 bool static Check(const unsigned char* vch); public: // 构造函数，初始化fValid和fCompressed，设置keydata的长度为32 CKey() : fValid(false), fCompressed(false) { keydata.resize(32); } // 重载Ckey的==运算符，只要密钥数据一致，是否压缩也一直，就表示两个CKey数据相同 friend bool operator==(const CKey&amp; a, const CKey&amp; b) { return a.fCompressed == b.fCompressed &amp;&amp; a.size() == b.size() &amp;&amp; memcmp(a.keydata.data(), b.keydata.data(), a.size()) == 0; } // 设置密钥的内容，并通过check判断是否为有效密钥 template &lt;typename T&gt; void Set(const T pbegin, const T pend, bool fCompressedIn) { if (size_t(pend - pbegin) != keydata.size()) { fValid = false; } else if (Check(&amp;pbegin[0])) { memcpy(keydata.data(), (unsigned char*)&amp;pbegin[0], keydata.size()); fValid = true; fCompressed = fCompressedIn; } else { fValid = false; } } // 这块是简单的加了几个方法，能让CKey的函数能够更方便的使用存储私钥的成员keydata unsigned int size() const { return (fValid ? keydata.size() : 0); } const unsigned char* begin() const { return keydata.data(); } const unsigned char* end() const { return keydata.data() + size(); } // 返回私钥是否有效 bool IsValid() const { return fValid; } // 返回私钥（对应的公钥）是否是压缩格式的 bool IsCompressed() const { return fCompressed; } //! 使用随机的方式创建一个新的密钥. void MakeNewKey(bool fCompressed); //! 获得私钥 //! 返回的私钥是CPrivKey类型的，也就是编码后的私钥 CPrivKey GetPrivKey() const; //! 获得公钥 //! 通过私钥计算出公钥并返回 CPubKey GetPubKey() const; /** * 签名，返回DER序列化的数字签名 * @param[in] hash 要进行签名的哈希值 * @param[out] 签名结果 * @param[test_case] 我也没搞清楚这是干啥的，貌似是传一个和随机数有关的任意数 */ bool Sign(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig, uint32_t test_case = 0) const; // Create a compact signature (65 bytes) bool SignCompact(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; // Derive BIP32 child key. bool Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const; // 验证私钥和公钥是否匹配。 // 使用的机制并不是使用私钥再次生成公钥并比对 bool VerifyPubKey(const CPubKey&amp; vchPubKey) const; // 加载一个私钥，顺便判断下与公钥是否匹配 bool Load(const CPrivKey&amp; privkey, const CPubKey&amp; vchPubKey, bool fSkipCheck); }; /** * 这也是一个私钥类型，应该是和HD钱包相关的 * CKey, CPubKey, CExtKey, CExtPubKey 是bitcoin core中的四种密钥实现 * 其中CKey, CPubKey是普通的私钥和公钥类型 * 而如果想使用 HD Wallet，必须使用CExtKey, CExtPubKey * 由于还不了解HD钱包，这个类我也没有详细阅读 * 或许可以看看这个https://medium.com/codechain/hd-wallet-observed-through-bitcoin-core-source-code-ce38f9eab371 */ struct CExtKey { unsigned char nDepth; unsigned char vchFingerprint[4]; unsigned int nChild; ChainCode chaincode; CKey key; friend bool operator==(const CExtKey&amp; a, const CExtKey&amp; b) { return a.nDepth == b.nDepth &amp;&amp; memcmp(&amp;a.vchFingerprint[0], &amp;b.vchFingerprint[0], sizeof(vchFingerprint)) == 0 &amp;&amp; a.nChild == b.nChild &amp;&amp; a.chaincode == b.chaincode &amp;&amp; a.key == b.key; } void Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const; void Decode(const unsigned char code[BIP32_EXTKEY_SIZE]); bool Derive(CExtKey&amp; out, unsigned int nChild) const; CExtPubKey Neuter() const; void SetMaster(const unsigned char* seed, unsigned int nSeedLen); template &lt;typename Stream&gt; void Serialize(Stream&amp; s) const { unsigned int len = BIP32_EXTKEY_SIZE; ::WriteCompactSize(s, len); unsigned char code[BIP32_EXTKEY_SIZE]; Encode(code); s.write((const char *)&amp;code[0], len); } template &lt;typename Stream&gt; void Unserialize(Stream&amp; s) { unsigned int len = ::ReadCompactSize(s); unsigned char code[BIP32_EXTKEY_SIZE]; if (len != BIP32_EXTKEY_SIZE) throw std::runtime_error(&quot;Invalid extended key size\n&quot;); s.read((char *)&amp;code[0], len); Decode(code); } }; // 使用椭圆算法加密前必须调用该程序启用上下文 void ECC_Start(void); // 使用椭圆加密后使用该函数销毁加密上下文 void ECC_Stop(void); // 获取运行时椭圆曲线需要的支持是否满足 bool ECC_InitSanityCheck(void); #endif // BITCOIN_KEY_H 下面简要的阅读源文件key.cpp 生成一个新的私钥的方法如下： bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(keydata.data(), keydata.size()); } while (!Check(keydata.data())); fValid = true; fCompressed = fCompressedIn; } 如前所述，比特币私钥其实就是一个256bit随机数（32字节长） 可以看到，代码中使用GetStrongRandBytes()函数生成强随机性的私钥 使用grep命令搜索该方法 $ grep -rlw &quot;GetStrongRandBytes&quot; * key.cpp random.cpp random.h wallet/wallet.cpp 最终确定，该方法位于random.h中，可在其中探寻详细代码 可以看到MakeNewKey()方法，通过不停调用GetStrongRandBytes(),直到找到能够满足要求的随机数作为私钥 Check()方法调用libsecp256k1加密库中的函数secp256k1_ec_seckey_verify进行验证 获取私钥的方法如下 CPrivKey CKey::GetPrivKey() const { assert(fValid); CPrivKey privkey; int ret; size_t privkeylen; privkey.resize(PRIVATE_KEY_SIZE); privkeylen = PRIVATE_KEY_SIZE; ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &amp;privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(ret); privkey.resize(privkeylen); return privkey; } 该函数核心是向ec_privkey_export_der()提供私钥数据keydata（通过begin()传递），进行DER序列化，并返回CPrivKey类型的私钥 至于比特币系统中为什么不传递原始的私钥，而是传递DER编码的私钥，相信随着不断学习，会得到答案。 获取公钥的方法如下 CPubKey CKey::GetPubKey() const { assert(fValid); secp256k1_pubkey pubkey; size_t clen = CPubKey::PUBLIC_KEY_SIZE; CPubKey result; int ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &amp;pubkey, begin()); assert(ret); secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned char*)result.begin(), &amp;clen, &amp;pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(result.size() == clen); assert(result.IsValid()); return result; } 可以看到，公钥的获取过程首先调用了libsecp256k1加密库中的函数secp256k1_ec_pubkey_create()生成了secp256k1_pubkey类型的公钥pubkey 然后又调用libsecp256k1加密库中的函数secp256k1_ec_pubkey_serialize将secp256k1_pubkey类型的公钥序列化为Bitcoin Core中的自定义公钥类型CPubKey 关于私钥的源码阅读就到这里。 由于刚刚窥探Bitcoin Core源码的冰山一角，难免出现理解错误的地方，本文中也列出了我目前还不理解的地方，还望各位能够指出~ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/14/580f3575b4a9adeaf64df59ba37d1ef6.html" />
<meta property="og:url" content="https://mlh.app/2018/08/14/580f3575b4a9adeaf64df59ba37d1ef6.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"经过一段时间的积累，终于来到了比特币源码阅读的环节。还是按照之前的节奏，我们就比对着精通比特币一书的进度，进行源码的阅读。 对于此文，只需你对比特币系统中私钥-公钥-地址的产生及关系有最基本的了解 因此你可以放心的直接阅读，如果遇到疑惑，可以返回来阅读以下资料，填补一些基本概念即可： 精通比特币第4章 椭圆曲线加密算法教程 密码学知识汇总 下面进入正题，本文将对比特币源码中的私钥相关部分进行梳理。 在阅读代码前，先明确一个概念：私钥是如何产生的？ 私钥如何产生 比特币的私钥就是一个256位二进制数字，就这么简单。 但是有一个条件，这个256位二进制数要小于一个非常大的质数n n = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141 这是由于比特币使用的椭圆曲线secp256k1的方程所对应的循环子群的秩为n。 这一点了解即可，如果你想了解为什么，建议仔细阅读椭圆曲线加密算法教程 也就是说，你可以用硬币、铅笔和纸来随机生成你的私钥： 掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥，只要其小于n。 当然更普遍的方法是使用代码生成，但是一定要注意：在你不够了解随机数产生器前，不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数作为私钥。应使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。（这段警告来自于《精通比特币》，我目前还不知晓怎样才算一个足够安全的伪随机数发生器，也望大家告知交流） 代码阅读 明确了私钥的定义，我们来阅读源码。 首先，我们进入src目录下 使用ls和grep命令，试图找到私钥-公钥相关源文件的位置 一番探索后确定，头文件key.h中的CKey类便是私钥的定义。 下面是key.h的源码，我个人的理解直接放在注释中了 // Copyright (c) 2009-2010 Satoshi Nakamoto // Copyright (c) 2009-2017 The Bitcoin Core developers // Copyright (c) 2017 The Zcash developers // Distributed under the MIT software license, see the accompanying // file COPYING or http://www.opensource.org/licenses/mit-license.php. #ifndef BITCOIN_KEY_H #define BITCOIN_KEY_H #include &lt;pubkey.h&gt; // 显然这是定义公钥的代码 #include &lt;serialize.h&gt; #include &lt;support/allocators/secure.h&gt; #include &lt;uint256.h&gt; #include &lt;stdexcept&gt; #include &lt;vector&gt; /** * CPrivKey本质就是一个vector&lt;unsigned char&gt; * 其allocator在support/allocators/secure.h中进行了重载（具体原因暂不清楚） * 这个CPrivKey并不是我们理解的256bit的随机数私钥 * 而是一个编码后的一个私钥，编码的私钥长度为PRIVATE_KEY_SIZE或COMPRESSED_PRIVATE_KEY_SIZE。 * 从代码来看，这个私钥应该是DER编码的，具体什么是DER，为什么这样编码我还不太清楚。 */ typedef std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; CPrivKey; /** 封装的私钥类. */ class CKey { public: /** * 定义两个静态的大小用来表示普通私钥的长度和压缩后私钥的长度 * */ static const unsigned int PRIVATE_KEY_SIZE = 279; static const unsigned int COMPRESSED_PRIVATE_KEY_SIZE = 214; /** * 压缩后的私钥必须要比压缩前小，这是合理的要求了，使用static_assert在编译时进行检查 */ static_assert( PRIVATE_KEY_SIZE &gt;= COMPRESSED_PRIVATE_KEY_SIZE, &quot;COMPRESSED_PRIVATE_KEY_SIZE is larger than PRIVATE_KEY_SIZE&quot;); private: // 用于表示私钥是否有效 // 因为每次key被修改的时候都会做正确性判断，所以fValid应该和真实的状态保持一致。 bool fValid; // 表示对应私钥的公钥是否被压缩 bool fCompressed; //! 实际的私钥数据。 //! 这里存储的是我们所熟悉的256bit私钥（32字节） std::vector&lt;unsigned char, secure_allocator&lt;unsigned char&gt; &gt; keydata; //! 判断vch指向的32字节数据是否是有效的私钥数据 bool static Check(const unsigned char* vch); public: // 构造函数，初始化fValid和fCompressed，设置keydata的长度为32 CKey() : fValid(false), fCompressed(false) { keydata.resize(32); } // 重载Ckey的==运算符，只要密钥数据一致，是否压缩也一直，就表示两个CKey数据相同 friend bool operator==(const CKey&amp; a, const CKey&amp; b) { return a.fCompressed == b.fCompressed &amp;&amp; a.size() == b.size() &amp;&amp; memcmp(a.keydata.data(), b.keydata.data(), a.size()) == 0; } // 设置密钥的内容，并通过check判断是否为有效密钥 template &lt;typename T&gt; void Set(const T pbegin, const T pend, bool fCompressedIn) { if (size_t(pend - pbegin) != keydata.size()) { fValid = false; } else if (Check(&amp;pbegin[0])) { memcpy(keydata.data(), (unsigned char*)&amp;pbegin[0], keydata.size()); fValid = true; fCompressed = fCompressedIn; } else { fValid = false; } } // 这块是简单的加了几个方法，能让CKey的函数能够更方便的使用存储私钥的成员keydata unsigned int size() const { return (fValid ? keydata.size() : 0); } const unsigned char* begin() const { return keydata.data(); } const unsigned char* end() const { return keydata.data() + size(); } // 返回私钥是否有效 bool IsValid() const { return fValid; } // 返回私钥（对应的公钥）是否是压缩格式的 bool IsCompressed() const { return fCompressed; } //! 使用随机的方式创建一个新的密钥. void MakeNewKey(bool fCompressed); //! 获得私钥 //! 返回的私钥是CPrivKey类型的，也就是编码后的私钥 CPrivKey GetPrivKey() const; //! 获得公钥 //! 通过私钥计算出公钥并返回 CPubKey GetPubKey() const; /** * 签名，返回DER序列化的数字签名 * @param[in] hash 要进行签名的哈希值 * @param[out] 签名结果 * @param[test_case] 我也没搞清楚这是干啥的，貌似是传一个和随机数有关的任意数 */ bool Sign(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig, uint32_t test_case = 0) const; // Create a compact signature (65 bytes) bool SignCompact(const uint256&amp; hash, std::vector&lt;unsigned char&gt;&amp; vchSig) const; // Derive BIP32 child key. bool Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, unsigned int nChild, const ChainCode&amp; cc) const; // 验证私钥和公钥是否匹配。 // 使用的机制并不是使用私钥再次生成公钥并比对 bool VerifyPubKey(const CPubKey&amp; vchPubKey) const; // 加载一个私钥，顺便判断下与公钥是否匹配 bool Load(const CPrivKey&amp; privkey, const CPubKey&amp; vchPubKey, bool fSkipCheck); }; /** * 这也是一个私钥类型，应该是和HD钱包相关的 * CKey, CPubKey, CExtKey, CExtPubKey 是bitcoin core中的四种密钥实现 * 其中CKey, CPubKey是普通的私钥和公钥类型 * 而如果想使用 HD Wallet，必须使用CExtKey, CExtPubKey * 由于还不了解HD钱包，这个类我也没有详细阅读 * 或许可以看看这个https://medium.com/codechain/hd-wallet-observed-through-bitcoin-core-source-code-ce38f9eab371 */ struct CExtKey { unsigned char nDepth; unsigned char vchFingerprint[4]; unsigned int nChild; ChainCode chaincode; CKey key; friend bool operator==(const CExtKey&amp; a, const CExtKey&amp; b) { return a.nDepth == b.nDepth &amp;&amp; memcmp(&amp;a.vchFingerprint[0], &amp;b.vchFingerprint[0], sizeof(vchFingerprint)) == 0 &amp;&amp; a.nChild == b.nChild &amp;&amp; a.chaincode == b.chaincode &amp;&amp; a.key == b.key; } void Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const; void Decode(const unsigned char code[BIP32_EXTKEY_SIZE]); bool Derive(CExtKey&amp; out, unsigned int nChild) const; CExtPubKey Neuter() const; void SetMaster(const unsigned char* seed, unsigned int nSeedLen); template &lt;typename Stream&gt; void Serialize(Stream&amp; s) const { unsigned int len = BIP32_EXTKEY_SIZE; ::WriteCompactSize(s, len); unsigned char code[BIP32_EXTKEY_SIZE]; Encode(code); s.write((const char *)&amp;code[0], len); } template &lt;typename Stream&gt; void Unserialize(Stream&amp; s) { unsigned int len = ::ReadCompactSize(s); unsigned char code[BIP32_EXTKEY_SIZE]; if (len != BIP32_EXTKEY_SIZE) throw std::runtime_error(&quot;Invalid extended key size\\n&quot;); s.read((char *)&amp;code[0], len); Decode(code); } }; // 使用椭圆算法加密前必须调用该程序启用上下文 void ECC_Start(void); // 使用椭圆加密后使用该函数销毁加密上下文 void ECC_Stop(void); // 获取运行时椭圆曲线需要的支持是否满足 bool ECC_InitSanityCheck(void); #endif // BITCOIN_KEY_H 下面简要的阅读源文件key.cpp 生成一个新的私钥的方法如下： bool CKey::Check(const unsigned char *vch) { return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch); } void CKey::MakeNewKey(bool fCompressedIn) { do { GetStrongRandBytes(keydata.data(), keydata.size()); } while (!Check(keydata.data())); fValid = true; fCompressed = fCompressedIn; } 如前所述，比特币私钥其实就是一个256bit随机数（32字节长） 可以看到，代码中使用GetStrongRandBytes()函数生成强随机性的私钥 使用grep命令搜索该方法 $ grep -rlw &quot;GetStrongRandBytes&quot; * key.cpp random.cpp random.h wallet/wallet.cpp 最终确定，该方法位于random.h中，可在其中探寻详细代码 可以看到MakeNewKey()方法，通过不停调用GetStrongRandBytes(),直到找到能够满足要求的随机数作为私钥 Check()方法调用libsecp256k1加密库中的函数secp256k1_ec_seckey_verify进行验证 获取私钥的方法如下 CPrivKey CKey::GetPrivKey() const { assert(fValid); CPrivKey privkey; int ret; size_t privkeylen; privkey.resize(PRIVATE_KEY_SIZE); privkeylen = PRIVATE_KEY_SIZE; ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &amp;privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(ret); privkey.resize(privkeylen); return privkey; } 该函数核心是向ec_privkey_export_der()提供私钥数据keydata（通过begin()传递），进行DER序列化，并返回CPrivKey类型的私钥 至于比特币系统中为什么不传递原始的私钥，而是传递DER编码的私钥，相信随着不断学习，会得到答案。 获取公钥的方法如下 CPubKey CKey::GetPubKey() const { assert(fValid); secp256k1_pubkey pubkey; size_t clen = CPubKey::PUBLIC_KEY_SIZE; CPubKey result; int ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &amp;pubkey, begin()); assert(ret); secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned char*)result.begin(), &amp;clen, &amp;pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED); assert(result.size() == clen); assert(result.IsValid()); return result; } 可以看到，公钥的获取过程首先调用了libsecp256k1加密库中的函数secp256k1_ec_pubkey_create()生成了secp256k1_pubkey类型的公钥pubkey 然后又调用libsecp256k1加密库中的函数secp256k1_ec_pubkey_serialize将secp256k1_pubkey类型的公钥序列化为Bitcoin Core中的自定义公钥类型CPubKey 关于私钥的源码阅读就到这里。 由于刚刚窥探Bitcoin Core源码的冰山一角，难免出现理解错误的地方，本文中也列出了我目前还不理解的地方，还望各位能够指出~ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/14/580f3575b4a9adeaf64df59ba37d1ef6.html","headline":"探索比特币源码5-私钥","dateModified":"2018-08-14T00:00:00+08:00","datePublished":"2018-08-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/14/580f3575b4a9adeaf64df59ba37d1ef6.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>探索比特币源码5-私钥</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>经过一段时间的积累，终于来到了比特币源码阅读的环节。还是按照之前的节奏，我们就比对着<a href="https://github.com/bitcoinbook/bitcoinbook" rel="nofollow">精通比特币</a>一书的进度，进行源码的阅读。</p> 
  <p>对于此文，只需你对比特币系统中私钥-公钥-地址的产生及关系有最基本的了解</p> 
  <p>因此你可以放心的直接阅读，如果遇到疑惑，可以返回来阅读以下资料，填补一些基本概念即可：</p> 
  <ul> 
   <li><a href="https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc" rel="nofollow">精通比特币第4章</a></li> 
   <li><a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" rel="nofollow">椭圆曲线加密算法教程</a></li> 
   <li><a href="https://blog.csdn.net/u011583927/article/details/81432863" rel="nofollow">密码学知识汇总</a></li> 
  </ul> 
  <p>下面进入正题，本文将对比特币源码中的私钥相关部分进行梳理。</p> 
  <p>在阅读代码前，先明确一个概念：私钥是如何产生的？</p> 
  <h2 id="私钥如何产生">私钥如何产生</h2> 
  <p>比特币的私钥就是一个256位二进制数字，就这么简单。</p> 
  <p>但是有一个条件，这个256位二进制数要小于一个非常大的质数n</p> 
  <p>n = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141</p> 
  <p>这是由于比特币使用的椭圆曲线<code>secp256k1</code>的方程所对应的循环子群的秩为n。</p> 
  <p>这一点了解即可，如果你想了解为什么，建议仔细阅读<a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" rel="nofollow">椭圆曲线加密算法教程</a></p> 
  <p>也就是说，你可以用硬币、铅笔和纸来随机生成你的私钥：</p> 
  <p>掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥，只要其小于n。</p> 
  <p>当然更普遍的方法是使用代码生成，但是一定要注意：在你不够了解随机数产生器前，不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数作为私钥。应使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。（这段警告来自于《精通比特币》，我目前还不知晓怎样才算一个足够安全的伪随机数发生器，也望大家告知交流）</p> 
  <h2 id="代码阅读">代码阅读</h2> 
  <p>明确了私钥的定义，我们来阅读源码。</p> 
  <p>首先，我们进入<code>src</code>目录下</p> 
  <p>使用<code>ls</code>和<code>grep</code>命令，试图找到<code>私钥-公钥</code>相关源文件的位置</p> 
  <p>一番探索后确定，头文件<code>key.h</code>中的<code>CKey</code>类便是私钥的定义。</p> 
  <p>下面是<code>key.h</code>的源码，我个人的理解直接放在注释中了</p> 
  <pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-comment">// Copyright (c) 2009-2010 Satoshi Nakamoto</span>
<span class="hljs-comment">// Copyright (c) 2009-2017 The Bitcoin Core developers</span>
<span class="hljs-comment">// Copyright (c) 2017 The Zcash developers</span>
<span class="hljs-comment">// Distributed under the MIT software license, see the accompanying</span>
<span class="hljs-comment">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</span>

<span class="hljs-preprocessor">#ifndef BITCOIN_KEY_H</span>
<span class="hljs-preprocessor">#define BITCOIN_KEY_H</span>

<span class="hljs-preprocessor">#include &lt;pubkey.h&gt; <span class="hljs-comment">// 显然这是定义公钥的代码</span></span>
<span class="hljs-preprocessor">#include &lt;serialize.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;support/allocators/secure.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;uint256.h&gt;</span>

<span class="hljs-preprocessor">#include &lt;stdexcept&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>


<span class="hljs-comment">/** * CPrivKey本质就是一个vector&lt;unsigned char&gt; * 其allocator在support/allocators/secure.h中进行了重载（具体原因暂不清楚） * 这个CPrivKey并不是我们理解的256bit的随机数私钥 * 而是一个编码后的一个私钥，编码的私钥长度为PRIVATE_KEY_SIZE或COMPRESSED_PRIVATE_KEY_SIZE。 * 从代码来看，这个私钥应该是DER编码的，具体什么是DER，为什么这样编码我还不太清楚。 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, secure_allocator&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> &gt; CPrivKey;

<span class="hljs-comment">/** 封装的私钥类. */</span>
<span class="hljs-keyword">class</span> CKey
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** * 定义两个静态的大小用来表示普通私钥的长度和压缩后私钥的长度 * */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> PRIVATE_KEY_SIZE            = <span class="hljs-number">279</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> COMPRESSED_PRIVATE_KEY_SIZE = <span class="hljs-number">214</span>;
    <span class="hljs-comment">/** * 压缩后的私钥必须要比压缩前小，这是合理的要求了，使用static_assert在编译时进行检查 */</span>
    <span class="hljs-keyword">static_assert</span>(
        PRIVATE_KEY_SIZE &gt;= COMPRESSED_PRIVATE_KEY_SIZE,
        <span class="hljs-string">"COMPRESSED_PRIVATE_KEY_SIZE is larger than PRIVATE_KEY_SIZE"</span>);

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 用于表示私钥是否有效</span>
    <span class="hljs-comment">// 因为每次key被修改的时候都会做正确性判断，所以fValid应该和真实的状态保持一致。</span>
    <span class="hljs-keyword">bool</span> fValid;

    <span class="hljs-comment">// 表示对应私钥的公钥是否被压缩</span>
    <span class="hljs-keyword">bool</span> fCompressed;

    <span class="hljs-comment">//! 实际的私钥数据。</span>
    <span class="hljs-comment">//! 这里存储的是我们所熟悉的256bit私钥（32字节）</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, secure_allocator&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span> &gt; keydata;

    <span class="hljs-comment">//! 判断vch指向的32字节数据是否是有效的私钥数据</span>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">static</span> Check(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* vch);

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 构造函数，初始化fValid和fCompressed，设置keydata的长度为32</span>
    CKey() : fValid(<span class="hljs-keyword">false</span>), fCompressed(<span class="hljs-keyword">false</span>)
    {
        keydata.resize(<span class="hljs-number">32</span>);
    }

    <span class="hljs-comment">// 重载Ckey的==运算符，只要密钥数据一致，是否压缩也一直，就表示两个CKey数据相同</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CKey&amp; a, <span class="hljs-keyword">const</span> CKey&amp; b)
    {
        <span class="hljs-keyword">return</span> a.fCompressed == b.fCompressed &amp;&amp;
            a.size() == b.size() &amp;&amp;
            <span class="hljs-built_in">memcmp</span>(a.keydata.data(), b.keydata.data(), a.size()) == <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 设置密钥的内容，并通过check判断是否为有效密钥</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">void</span> Set(<span class="hljs-keyword">const</span> T pbegin, <span class="hljs-keyword">const</span> T pend, <span class="hljs-keyword">bool</span> fCompressedIn)
    {
        <span class="hljs-keyword">if</span> (size_t(pend - pbegin) != keydata.size()) {
            fValid = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Check(&amp;pbegin[<span class="hljs-number">0</span>])) {
            <span class="hljs-built_in">memcpy</span>(keydata.data(), (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)&amp;pbegin[<span class="hljs-number">0</span>], keydata.size());
            fValid = <span class="hljs-keyword">true</span>;
            fCompressed = fCompressedIn;
        } <span class="hljs-keyword">else</span> {
            fValid = <span class="hljs-keyword">false</span>;
        }
    }

    <span class="hljs-comment">// 这块是简单的加了几个方法，能让CKey的函数能够更方便的使用存储私钥的成员keydata</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> (fValid ? keydata.size() : <span class="hljs-number">0</span>); }
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* begin() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> keydata.data(); }
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* end() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> keydata.data() + size(); }

    <span class="hljs-comment">// 返回私钥是否有效</span>
    <span class="hljs-keyword">bool</span> IsValid() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> fValid; }

    <span class="hljs-comment">// 返回私钥（对应的公钥）是否是压缩格式的</span>
    <span class="hljs-keyword">bool</span> IsCompressed() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> fCompressed; }

    <span class="hljs-comment">//! 使用随机的方式创建一个新的密钥.</span>
    <span class="hljs-keyword">void</span> MakeNewKey(<span class="hljs-keyword">bool</span> fCompressed);

    <span class="hljs-comment">//! 获得私钥</span>
    <span class="hljs-comment">//! 返回的私钥是CPrivKey类型的，也就是编码后的私钥</span>
    CPrivKey GetPrivKey() <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">//! 获得公钥</span>
    <span class="hljs-comment">//! 通过私钥计算出公钥并返回</span>
    CPubKey GetPubKey() <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">/** * 签名，返回DER序列化的数字签名 * @param[in] hash 要进行签名的哈希值 * @param[out] 签名结果 * @param[test_case] 我也没搞清楚这是干啥的，貌似是传一个和随机数有关的任意数 */</span>
    <span class="hljs-keyword">bool</span> Sign(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span>&amp; vchSig, uint32_t test_case = <span class="hljs-number">0</span>) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// Create a compact signature (65 bytes)</span>
    <span class="hljs-keyword">bool</span> SignCompact(<span class="hljs-keyword">const</span> uint256&amp; hash, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;</span>&amp; vchSig) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// Derive BIP32 child key.</span>
    <span class="hljs-keyword">bool</span> Derive(CKey&amp; keyChild, ChainCode &amp;ccChild, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nChild, <span class="hljs-keyword">const</span> ChainCode&amp; cc) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// 验证私钥和公钥是否匹配。</span>
    <span class="hljs-comment">// 使用的机制并不是使用私钥再次生成公钥并比对</span>
    <span class="hljs-keyword">bool</span> VerifyPubKey(<span class="hljs-keyword">const</span> CPubKey&amp; vchPubKey) <span class="hljs-keyword">const</span>;

    <span class="hljs-comment">// 加载一个私钥，顺便判断下与公钥是否匹配</span>
    <span class="hljs-keyword">bool</span> Load(<span class="hljs-keyword">const</span> CPrivKey&amp; privkey, <span class="hljs-keyword">const</span> CPubKey&amp; vchPubKey, <span class="hljs-keyword">bool</span> fSkipCheck);
};


<span class="hljs-comment">/** * 这也是一个私钥类型，应该是和HD钱包相关的 * CKey, CPubKey, CExtKey, CExtPubKey 是bitcoin core中的四种密钥实现 * 其中CKey, CPubKey是普通的私钥和公钥类型 * 而如果想使用 HD Wallet，必须使用CExtKey, CExtPubKey * 由于还不了解HD钱包，这个类我也没有详细阅读 * 或许可以看看这个https://medium.com/codechain/hd-wallet-observed-through-bitcoin-core-source-code-ce38f9eab371 */</span>
<span class="hljs-keyword">struct</span> CExtKey {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> nDepth;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> vchFingerprint[<span class="hljs-number">4</span>];
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nChild;
    ChainCode chaincode;
    CKey key;

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CExtKey&amp; a, <span class="hljs-keyword">const</span> CExtKey&amp; b)
    {
        <span class="hljs-keyword">return</span> a.nDepth == b.nDepth &amp;&amp;
            <span class="hljs-built_in">memcmp</span>(&amp;a.vchFingerprint[<span class="hljs-number">0</span>], &amp;b.vchFingerprint[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(vchFingerprint)) == <span class="hljs-number">0</span> &amp;&amp;
            a.nChild == b.nChild &amp;&amp;
            a.chaincode == b.chaincode &amp;&amp;
            a.key == b.key;
    }

    <span class="hljs-keyword">void</span> Encode(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> code[BIP32_EXTKEY_SIZE]) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> Decode(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> code[BIP32_EXTKEY_SIZE]);
    <span class="hljs-keyword">bool</span> Derive(CExtKey&amp; out, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nChild) <span class="hljs-keyword">const</span>;
    CExtPubKey Neuter() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> SetMaster(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* seed, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nSeedLen);
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream&gt;
    <span class="hljs-keyword">void</span> Serialize(Stream&amp; s) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = BIP32_EXTKEY_SIZE;
        ::WriteCompactSize(s, len);
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> code[BIP32_EXTKEY_SIZE];
        Encode(code);
        s.write((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;code[<span class="hljs-number">0</span>], len);
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream&gt;
    <span class="hljs-keyword">void</span> Unserialize(Stream&amp; s)
    {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = ::ReadCompactSize(s);
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> code[BIP32_EXTKEY_SIZE];
        <span class="hljs-keyword">if</span> (len != BIP32_EXTKEY_SIZE)
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Invalid extended key size\n"</span>);
        s.read((<span class="hljs-keyword">char</span> *)&amp;code[<span class="hljs-number">0</span>], len);
        Decode(code);
    }
};

<span class="hljs-comment">// 使用椭圆算法加密前必须调用该程序启用上下文</span>
<span class="hljs-keyword">void</span> ECC_Start(<span class="hljs-keyword">void</span>);

<span class="hljs-comment">// 使用椭圆加密后使用该函数销毁加密上下文</span>
<span class="hljs-keyword">void</span> ECC_Stop(<span class="hljs-keyword">void</span>);

<span class="hljs-comment">// 获取运行时椭圆曲线需要的支持是否满足</span>
<span class="hljs-keyword">bool</span> ECC_InitSanityCheck(<span class="hljs-keyword">void</span>);

<span class="hljs-preprocessor">#endif <span class="hljs-comment">// BITCOIN_KEY_H</span></span></code></pre> 
  <p>下面简要的阅读源文件<code>key.cpp</code></p> 
  <p><strong>生成一个新的私钥的方法如下：</strong></p> 
  <pre class="prettyprint"><code class="language-c++ hljs objectivec"><span class="hljs-keyword">bool</span> CKey::Check(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *vch) {
    <span class="hljs-keyword">return</span> secp256k1_ec_seckey_verify(secp256k1_context_sign, vch);
}

<span class="hljs-keyword">void</span> CKey::MakeNewKey(<span class="hljs-keyword">bool</span> fCompressedIn) {
    <span class="hljs-keyword">do</span> {
        GetStrongRandBytes(keydata<span class="hljs-variable">.data</span>(), keydata<span class="hljs-variable">.size</span>());
    } <span class="hljs-keyword">while</span> (!Check(keydata<span class="hljs-variable">.data</span>()));
    fValid = <span class="hljs-literal">true</span>;
    fCompressed = fCompressedIn;
}</code></pre> 
  <p>如前所述，比特币私钥其实就是一个256bit随机数（32字节长）</p> 
  <p>可以看到，代码中使用GetStrongRandBytes()函数生成强随机性的私钥</p> 
  <p>使用grep命令搜索该方法</p> 
  <pre class="prettyprint"><code class="language-shell hljs avrasm">$ grep -rlw <span class="hljs-string">"GetStrongRandBytes"</span> *
key<span class="hljs-preprocessor">.cpp</span>
random<span class="hljs-preprocessor">.cpp</span>
random<span class="hljs-preprocessor">.h</span>
wallet/wallet<span class="hljs-preprocessor">.cpp</span></code></pre> 
  <p>最终确定，该方法位于<code>random.h</code>中，可在其中探寻详细代码</p> 
  <p>可以看到<code>MakeNewKey()</code>方法，通过不停调用<code>GetStrongRandBytes()</code>,直到找到能够满足要求的随机数作为私钥</p> 
  <p><code>Check()</code>方法调用<code>libsecp256k1</code>加密库中的函数<code>secp256k1_ec_seckey_verify</code>进行验证</p> 
  <p><strong>获取私钥的方法如下</strong></p> 
  <pre class="prettyprint"><code class="language-c++ hljs avrasm">CPrivKey CKey::GetPrivKey() const {
    assert(fValid)<span class="hljs-comment">;</span>
    CPrivKey privkey<span class="hljs-comment">;</span>
    int <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span>
    size_t privkeylen<span class="hljs-comment">;</span>
    privkey<span class="hljs-preprocessor">.resize</span>(PRIVATE_KEY_SIZE)<span class="hljs-comment">;</span>
    privkeylen = PRIVATE_KEY_SIZE<span class="hljs-comment">;</span>
    <span class="hljs-keyword">ret</span> = ec_privkey_export_der(secp256k1_context_sign, privkey<span class="hljs-preprocessor">.data</span>(), &amp;privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED)<span class="hljs-comment">;</span>
    assert(<span class="hljs-keyword">ret</span>)<span class="hljs-comment">;</span>
    privkey<span class="hljs-preprocessor">.resize</span>(privkeylen)<span class="hljs-comment">;</span>
    return privkey<span class="hljs-comment">;</span>
}</code></pre> 
  <p>该函数核心是向<code>ec_privkey_export_der()</code>提供私钥数据keydata（通过begin()传递），进行DER序列化，并返回CPrivKey类型的私钥</p> 
  <p>至于比特币系统中为什么不传递原始的私钥，而是传递DER编码的私钥，相信随着不断学习，会得到答案。</p> 
  <p><strong>获取公钥的方法如下</strong></p> 
  <pre class="prettyprint"><code class="language-c++ hljs rust">CPubKey CKey::GetPubKey() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">assert</span>(fValid);
    secp256k1_pubkey pubkey;
    size_t clen = CPubKey::PUBLIC_KEY_SIZE;
    CPubKey result;
    <span class="hljs-keyword">int</span> ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &amp;pubkey, begin());
    <span class="hljs-keyword">assert</span>(ret);
    secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned <span class="hljs-keyword">char</span>*)result.begin(), &amp;clen, &amp;pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);
    <span class="hljs-keyword">assert</span>(result.size() == clen);
    <span class="hljs-keyword">assert</span>(result.IsValid());
    <span class="hljs-keyword">return</span> result;
}</code></pre> 
  <p>可以看到，公钥的获取过程首先调用了<code>libsecp256k1</code>加密库中的函数<code>secp256k1_ec_pubkey_create()</code>生成了secp256k1_pubkey类型的公钥pubkey</p> 
  <p>然后又调用<code>libsecp256k1</code>加密库中的函数<code>secp256k1_ec_pubkey_serialize</code>将secp256k1_pubkey类型的公钥序列化为Bitcoin Core中的自定义公钥类型CPubKey</p> 
  <p>关于私钥的源码阅读就到这里。</p> 
  <p>由于刚刚窥探Bitcoin Core源码的冰山一角，难免出现理解错误的地方，本文中也列出了我目前还不理解的地方，还望各位能够指出~</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011583927/article/details/81674572,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011583927/article/details/81674572,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
