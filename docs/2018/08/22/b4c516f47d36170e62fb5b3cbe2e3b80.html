<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>利用go语言实现比特币交易（Transaction） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="利用go语言实现比特币交易（Transaction）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="比特币交易 交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。 对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。下面的图示阐释了交易之间的互相关联： 注意： 有一些输出并没有被关联到某个输入上 一笔交易的输入可以引用之前多笔交易的输出 一个输入必须引用一个输出 贯穿本文，我们将会使用像“钱（money）”，“币（coin）”，“花费（spend）”，“发送（send）”，“账户（account）” 等等这样的词。但是在比特币中，其实并不存在这样的概念。交易仅仅是通过一个脚本（script）来锁定（lock）一些值（value），而这些值只可以被锁定它们的人解锁（unlock）。 每一笔比特币交易都会创造输出，输出都会被区块链记录下来。给某个人发送比特币，实际上意味着创造新的 UTXO 并注册到那个人的地址，可以为他所用。 交易的主函数： func (cli *CLI) send(from, to string, amount int, nodeID string, mineNow bool) { if !ValidateAddress(from) { log.Panic(&quot;ERROR: Sender address is not valid&quot;) } if !ValidateAddress(to) { log.Panic(&quot;ERROR: Recipient address is not valid&quot;) } bc := NewBlockchain(nodeID) //获取区块链实例 UTXOSet := UTXOSet{bc} //创建UTXO集 defer bc.Db.Close() wallets, err := NewWallets(nodeID) if err != nil { log.Panic(err) } wallet := wallets.GetWallet(from) tx := NewUTXOTransaction(&amp;wallet, to, amount, &amp;UTXOSet) if mineNow { cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) } else { sendTx(knownNodes[0], tx) } fmt.Println(&quot;Success!&quot;) } 我们从头分析整个交易过程，首先利用ValidateAddress（）方法判断输入的地址是否为有效的比特币地址，然后从我们的blotDB数据库中获取blockchain实例（我们利用一个数据库实现区块链数据的存储，这里读者可以忽略），其中读取数据库的代码如下 func NewBlockchain(nodeID string) *Blockchain { dbFile := fmt.Sprintf(dbFile, nodeID) if dbExists(dbFile) == false { fmt.Println(&quot;No existing blockchain found. Create one first.&quot;) os.Exit(1) } var tip []byte db, err := bolt.Open(dbFile, 0600, nil) //打开数据库 if err != nil { log.Panic(err) } err = db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) tip = b.Get([]byte(&quot;l&quot;)) //读取最新的区块链 return nil }) if err != nil { log.Panic(err) } bc := Blockchain{tip, db} return &amp;bc } 其中我们的区块链的基本原型为 type Blockchain struct { tip []byte Db *bolt.DB } type Block struct { Timestamp int64 Transactions []*Transaction PrevBlockHash []byte Hash []byte Nonce int Height int } 获取完成区块链实例后，我们创建出一个utxo集合，其数据结构为 type UTXOSet struct { Blockchain *Blockchain } 然后我们从钱包文件中获取我们的钱包集合（wallets）,接着调用我们的转账函数。 func NewUTXOTransaction(wallet *Wallet, to string, amount int, UTXOSet *UTXOSet) *Transaction { var inputs []TXInput var outputs []TXOutput pubKeyHash := HashPubKey(wallet.PublicKey) acc, validOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount) //找到能够使用的输出 if acc &lt; amount { //如果能够使用的输出小于目标值，则返回错误 log.Panic(&quot;ERROR: Not enough funds&quot;) } // Build a list of inputs for txid, outs := range validOutputs { txID, err := hex.DecodeString(txid) if err != nil { log.Panic(err) } for _, out := range outs { input := TXInput{txID, out, nil, wallet.PublicKey} inputs = append(inputs, input) } } // Build a list of outputs from := fmt.Sprintf(&quot;%s&quot;, wallet.GetAddress()) outputs = append(outputs, *NewTXOutput(amount, to)) //创建新的交易输出 if acc &gt; amount { outputs = append(outputs, *NewTXOutput(acc-amount, from)) // a change //找零输出 } tx := Transaction{nil, inputs, outputs} tx.ID = tx.Hash() //创建一笔交易 UTXOSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey) //对交易签名 return &amp;tx } 对于一笔交易来说，其数据结构为 type Transaction struct { ID []byte Vin []TXInput Vout []TXOutput } type TXInput struct { Txid []byte Vout int Signature []byte PubKey []byte } type TXOutput struct { Value int PubKeyHash []byte } type UTXOSet struct { Blockchain *Blockchain } 一笔交易来说，输出主要包含两部分： 一定量的比特币(Value)， 一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。一个输入引用了之前交易的一个输出：Txid 存储的是之前交易的 ID，Vout 存储的是该输出在那笔交易中所有输出的索引（因为一笔交易可能有多个输出，需要有信息指明是具体的哪一个）Signature是签名，而Pubkey是公钥，两者保证了用户无法花费属于其他人的币。 func HashPubKey(pubKey []byte) []byte { // RIPEMD160(SHA256(PubKey)) publicSHA256 := sha256.Sum256(pubKey) RIPEMD160Hasher := ripemd160.New() _, err := RIPEMD160Hasher.Write(publicSHA256[:]) if err != nil { log.Panic(err) } publicRIPEMD160 := RIPEMD160Hasher.Sum(nil) return publicRIPEMD160 } func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) { unspentOutputs := make(map[string][]int) //为输出开辟一块内存空间 accumulated := 0 db := u.Blockchain.db //获取存取区块链的数据库 err := db.View(func(tx *bolt.Tx) error { //读取数据库 b := tx.Bucket([]byte(utxoBucket)) c := b.Cursor() for k, v := c.First(); k != nil; k, v = c.Next() { //遍历数据库 txID := hex.EncodeToString(k) outs := DeserializeOutputs(v) for outIdx, out := range outs.Outputs { if out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount { //如果能够解锁输出，代表utxo集中的输出是的所有者是该公钥所对应的人 accumulated += out.Value //累加值 unspentOutputs[txID] = append(unspentOutputs[txID], outIdx) //加到数组中 } } } return nil }) if err != nil { log.Panic(err) } return accumulated, unspentOutputs } func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool { //判断输出是否能够被某个公钥解锁 return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0 } func NewTXOutput(value int, address string) *TXOutput { txo := &amp;TXOutput{value, nil} //注册一个输出 txo.Lock([]byte(address)) //设置输出的pubhashkey return txo } func (out *TXOutput) Lock(address []byte) { pubKeyHash := Base58Decode(address) pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4] out.PubKeyHash = pubKeyHash } 在创建新的输出时，我们必须找到所有的为花费的输出，并且确保他们有足够的价值（value），这就是FindSpendableOutputs 要做的事情，随后，对于每个找到的输出，会创建一个引用该输出的输入。接下来，我们创建两个输出： 一个由接收者地址锁定。这是给其他地址实际转移的币。 一个由发送者地址锁定。这是一个找零。只有当未花费输出超过新交易所需时产生。记住：输出是不可再分的。 func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) { prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } tx.Sign(privKey, prevTXs) } func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {//方法接受一个私钥和之前一个交易的map if tx.IsCoinbase() { return }//判断是是否为发币交易，因为发币交易没有输入，故不用进行签名 for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) } } txCopy := tx.TrimmedCopy() //将会被签名的是修剪后的交易副本，而不是一个完整的交易 for inID, vin := range txCopy.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash //迭代副本中的每一个输入，在每个输入中，Pubkey 被设置为所引用输出的PubKeyHash / dataToSign := fmt.Sprintf(&quot;%x\n&quot;, txCopy) r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, []byte(dataToSign))//我们通过private对txCopy进行签名将这串数字连接起来储存在signature中 if err != nil { log.Panic(err) } signature := append(r.Bytes(), s.Bytes()...) tx.Vin[inID].Signature = signature txCopy.Vin[inID].PubKey = nil } } func (tx *Transaction) TrimmedCopy() Transaction { var inputs []TXInput var outputs []TXOutput for _, vin := range tx.Vin {//将输入的TXInput.Signature 和TXIput.PubKey设置为空 inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil}) } for _, vout := range tx.Vout { outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash}) } txCopy := Transaction{tx.ID, inputs, outputs} return txCopy } 交易必须被签名，因为这是保证发送方不会花费其他人的币的唯一方式，如果一个签名是无效的，那么这笔交易也会被认为是无效的，因为这笔交易无法被加到区块链中。考虑到交易解锁的是之前的输出，然后重新分配里面的价值，并锁定新的输出，那么必须要签名一下的数据 存储在已经解锁输出的公钥哈希，他识别了一笔交易的发送方 存储在新的锁定输出里面的公钥哈希，他识别了一笔交易的接收方 新的输出值 因此，在比特币里，所签名的并不是一个交易，而是一个去除部分签名的输入的副本，输入里面存储了被引用输出的ScriptPubKey 如果现在进行过挖矿 cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) func NewCoinbaseTX(to, data string) *Transaction { if data == &quot;&quot; { //如果数据为空生成一个随机数据 randData := make([]byte, 20) _, err := rand.Read(randData) if err != nil { log.Panic(err) } data = fmt.Sprintf(&quot;%x&quot;, randData) }//生成一笔挖矿交易 txin := TXInput{[]byte{}, -1, nil, []byte(data)} txout := NewTXOutput(subsidy, to) tx := Transaction{nil, []TXInput{txin}, []TXOutput{*txout}} tx.ID = tx.Hash() return &amp;tx } func (bc *Blockchain) MineBlock(transactions []*Transaction) *Block { //开始挖矿 var lastHash []byte var lastHeight int for _, tx := range transactions { // TODO: ignore transaction if it&#39;s not valid if bc.VerifyTransaction(tx) != true { log.Panic(&quot;ERROR: Invalid transaction&quot;) //对打包在区块中的交易进行认证 } } err := bc.db.View(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) lastHash = b.Get([]byte(&quot;l&quot;)) //获取最新的一个块的hash值 blockData := b.Get(lastHash) block := DeserializeBlock(blockData) //将最新的一个块解序列 lastHeight = block.Height return nil }) if err != nil { log.Panic(err) } newBlock := NewBlock(transactions, lastHash, lastHeight+1) err = bc.db.Update(func(tx *bolt.Tx) error { //更新区块链数据库 b := tx.Bucket([]byte(blocksBucket)) err := b.Put(newBlock.Hash, newBlock.Serialize()) if err != nil { log.Panic(err) } err = b.Put([]byte(&quot;l&quot;), newBlock.Hash) if err != nil { log.Panic(err) } bc.tip = newBlock.Hash return nil }) if err != nil { log.Panic(err) } return newBlock } func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool { if tx.IsCoinbase() { return true } prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } return tx.Verify(prevTXs) } func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool { if tx.IsCoinbase() { //判断是否为大笔交易 return true } for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) //判断输入地址的有效性 } } txCopy := tx.TrimmedCopy() //创建一个裁剪版本的交易副本 curve := elliptic.P256() //我们需要相同区块用于生成密钥对 for inID, vin := range tx.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash r := big.Int{} s := big.Int{} sigLen := len(vin.Signature) r.SetBytes(vin.Signature[:(sigLen / 2)]) s.SetBytes(vin.Signature[(sigLen / 2):]) x := big.Int{} y := big.Int{} keyLen := len(vin.PubKey) x.SetBytes(vin.PubKey[:(keyLen / 2)]) y.SetBytes(vin.PubKey[(keyLen / 2):]) //这里我们解包存储在 TXInput.Signature 和 TXInput.PubKey 中的值，因为一个签名就是一对数字，一个公钥就是一对坐标。我们之前为了存储将它们连接在一起，现在我们需要对它们进行解包在 crypto/ecdsa 函数中使用 dataToVerify := fmt.Sprintf(&quot;%x\n&quot;, txCopy) rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y} if ecdsa.Verify(&amp;rawPubKey, []byte(dataToVerify), &amp;r, &amp;s) == false { //验证 return false } txCopy.Vin[inID].PubKey = nil } return true } func NewBlock(transactions []*Transaction, prevBlockHash []byte, height int) *Block {//产生一个新的块 block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0, height}//定义数据结构 pow := NewProofOfWork(block) //定义工作量证明的数据结构 nonce, hash := pow.Run() //挖矿 block.Hash = hash[:] block.Nonce = nonce return block } func (pow *ProofOfWork) Run() (int, []byte) { var hashInt big.Int var hash [32]byte nonce := 0 fmt.Printf(&quot;Mining a new block&quot;) for nonce &lt; maxNonce { data := pow.prepareData(nonce) hash = sha256.Sum256(data) fmt.Printf(&quot;\r%x&quot;, hash) hashInt.SetBytes(hash[:]) if hashInt.Cmp(pow.target) == -1 { break } else { nonce++ } } fmt.Print(&quot;\n\n&quot;) return nonce, hash[:] } func (pow *ProofOfWork) prepareData(nonce int) []byte { data := bytes.Join( [][]byte{ pow.block.PrevBlockHash, pow.block.HashTransactions(), IntToHex(pow.block.Timestamp), IntToHex(int64(targetBits)), IntToHex(int64(nonce)), }, []byte{}, ) return data } func (u UTXOSet) Update(block *Block) { db := u.Blockchain.db err := db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(utxoBucket)) for _, tx := range block.Transactions { if tx.IsCoinbase() == false { for _, vin := range tx.Vin { updatedOuts := TXOutputs{} outsBytes := b.Get(vin.Txid) outs := DeserializeOutputs(outsBytes) for outIdx, out := range outs.Outputs { if outIdx != vin.Vout { updatedOuts.Outputs = append(updatedOuts.Outputs, out) } } if len(updatedOuts.Outputs) == 0 { err := b.Delete(vin.Txid) if err != nil { log.Panic(err) } } else { err := b.Put(vin.Txid, updatedOuts.Serialize()) if err != nil { log.Panic(err) } } } } newOutputs := TXOutputs{} for _, out := range tx.Vout { newOutputs.Outputs = append(newOutputs.Outputs, out) } err := b.Put(tx.ID, newOutputs.Serialize()) if err != nil { log.Panic(err) } } return nil }) if err != nil { log.Panic(err) } } 参考 https://jeiwan.cc/ 阅读更多" />
<meta property="og:description" content="比特币交易 交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。 对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。下面的图示阐释了交易之间的互相关联： 注意： 有一些输出并没有被关联到某个输入上 一笔交易的输入可以引用之前多笔交易的输出 一个输入必须引用一个输出 贯穿本文，我们将会使用像“钱（money）”，“币（coin）”，“花费（spend）”，“发送（send）”，“账户（account）” 等等这样的词。但是在比特币中，其实并不存在这样的概念。交易仅仅是通过一个脚本（script）来锁定（lock）一些值（value），而这些值只可以被锁定它们的人解锁（unlock）。 每一笔比特币交易都会创造输出，输出都会被区块链记录下来。给某个人发送比特币，实际上意味着创造新的 UTXO 并注册到那个人的地址，可以为他所用。 交易的主函数： func (cli *CLI) send(from, to string, amount int, nodeID string, mineNow bool) { if !ValidateAddress(from) { log.Panic(&quot;ERROR: Sender address is not valid&quot;) } if !ValidateAddress(to) { log.Panic(&quot;ERROR: Recipient address is not valid&quot;) } bc := NewBlockchain(nodeID) //获取区块链实例 UTXOSet := UTXOSet{bc} //创建UTXO集 defer bc.Db.Close() wallets, err := NewWallets(nodeID) if err != nil { log.Panic(err) } wallet := wallets.GetWallet(from) tx := NewUTXOTransaction(&amp;wallet, to, amount, &amp;UTXOSet) if mineNow { cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) } else { sendTx(knownNodes[0], tx) } fmt.Println(&quot;Success!&quot;) } 我们从头分析整个交易过程，首先利用ValidateAddress（）方法判断输入的地址是否为有效的比特币地址，然后从我们的blotDB数据库中获取blockchain实例（我们利用一个数据库实现区块链数据的存储，这里读者可以忽略），其中读取数据库的代码如下 func NewBlockchain(nodeID string) *Blockchain { dbFile := fmt.Sprintf(dbFile, nodeID) if dbExists(dbFile) == false { fmt.Println(&quot;No existing blockchain found. Create one first.&quot;) os.Exit(1) } var tip []byte db, err := bolt.Open(dbFile, 0600, nil) //打开数据库 if err != nil { log.Panic(err) } err = db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) tip = b.Get([]byte(&quot;l&quot;)) //读取最新的区块链 return nil }) if err != nil { log.Panic(err) } bc := Blockchain{tip, db} return &amp;bc } 其中我们的区块链的基本原型为 type Blockchain struct { tip []byte Db *bolt.DB } type Block struct { Timestamp int64 Transactions []*Transaction PrevBlockHash []byte Hash []byte Nonce int Height int } 获取完成区块链实例后，我们创建出一个utxo集合，其数据结构为 type UTXOSet struct { Blockchain *Blockchain } 然后我们从钱包文件中获取我们的钱包集合（wallets）,接着调用我们的转账函数。 func NewUTXOTransaction(wallet *Wallet, to string, amount int, UTXOSet *UTXOSet) *Transaction { var inputs []TXInput var outputs []TXOutput pubKeyHash := HashPubKey(wallet.PublicKey) acc, validOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount) //找到能够使用的输出 if acc &lt; amount { //如果能够使用的输出小于目标值，则返回错误 log.Panic(&quot;ERROR: Not enough funds&quot;) } // Build a list of inputs for txid, outs := range validOutputs { txID, err := hex.DecodeString(txid) if err != nil { log.Panic(err) } for _, out := range outs { input := TXInput{txID, out, nil, wallet.PublicKey} inputs = append(inputs, input) } } // Build a list of outputs from := fmt.Sprintf(&quot;%s&quot;, wallet.GetAddress()) outputs = append(outputs, *NewTXOutput(amount, to)) //创建新的交易输出 if acc &gt; amount { outputs = append(outputs, *NewTXOutput(acc-amount, from)) // a change //找零输出 } tx := Transaction{nil, inputs, outputs} tx.ID = tx.Hash() //创建一笔交易 UTXOSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey) //对交易签名 return &amp;tx } 对于一笔交易来说，其数据结构为 type Transaction struct { ID []byte Vin []TXInput Vout []TXOutput } type TXInput struct { Txid []byte Vout int Signature []byte PubKey []byte } type TXOutput struct { Value int PubKeyHash []byte } type UTXOSet struct { Blockchain *Blockchain } 一笔交易来说，输出主要包含两部分： 一定量的比特币(Value)， 一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。一个输入引用了之前交易的一个输出：Txid 存储的是之前交易的 ID，Vout 存储的是该输出在那笔交易中所有输出的索引（因为一笔交易可能有多个输出，需要有信息指明是具体的哪一个）Signature是签名，而Pubkey是公钥，两者保证了用户无法花费属于其他人的币。 func HashPubKey(pubKey []byte) []byte { // RIPEMD160(SHA256(PubKey)) publicSHA256 := sha256.Sum256(pubKey) RIPEMD160Hasher := ripemd160.New() _, err := RIPEMD160Hasher.Write(publicSHA256[:]) if err != nil { log.Panic(err) } publicRIPEMD160 := RIPEMD160Hasher.Sum(nil) return publicRIPEMD160 } func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) { unspentOutputs := make(map[string][]int) //为输出开辟一块内存空间 accumulated := 0 db := u.Blockchain.db //获取存取区块链的数据库 err := db.View(func(tx *bolt.Tx) error { //读取数据库 b := tx.Bucket([]byte(utxoBucket)) c := b.Cursor() for k, v := c.First(); k != nil; k, v = c.Next() { //遍历数据库 txID := hex.EncodeToString(k) outs := DeserializeOutputs(v) for outIdx, out := range outs.Outputs { if out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount { //如果能够解锁输出，代表utxo集中的输出是的所有者是该公钥所对应的人 accumulated += out.Value //累加值 unspentOutputs[txID] = append(unspentOutputs[txID], outIdx) //加到数组中 } } } return nil }) if err != nil { log.Panic(err) } return accumulated, unspentOutputs } func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool { //判断输出是否能够被某个公钥解锁 return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0 } func NewTXOutput(value int, address string) *TXOutput { txo := &amp;TXOutput{value, nil} //注册一个输出 txo.Lock([]byte(address)) //设置输出的pubhashkey return txo } func (out *TXOutput) Lock(address []byte) { pubKeyHash := Base58Decode(address) pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4] out.PubKeyHash = pubKeyHash } 在创建新的输出时，我们必须找到所有的为花费的输出，并且确保他们有足够的价值（value），这就是FindSpendableOutputs 要做的事情，随后，对于每个找到的输出，会创建一个引用该输出的输入。接下来，我们创建两个输出： 一个由接收者地址锁定。这是给其他地址实际转移的币。 一个由发送者地址锁定。这是一个找零。只有当未花费输出超过新交易所需时产生。记住：输出是不可再分的。 func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) { prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } tx.Sign(privKey, prevTXs) } func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {//方法接受一个私钥和之前一个交易的map if tx.IsCoinbase() { return }//判断是是否为发币交易，因为发币交易没有输入，故不用进行签名 for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) } } txCopy := tx.TrimmedCopy() //将会被签名的是修剪后的交易副本，而不是一个完整的交易 for inID, vin := range txCopy.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash //迭代副本中的每一个输入，在每个输入中，Pubkey 被设置为所引用输出的PubKeyHash / dataToSign := fmt.Sprintf(&quot;%x\n&quot;, txCopy) r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, []byte(dataToSign))//我们通过private对txCopy进行签名将这串数字连接起来储存在signature中 if err != nil { log.Panic(err) } signature := append(r.Bytes(), s.Bytes()...) tx.Vin[inID].Signature = signature txCopy.Vin[inID].PubKey = nil } } func (tx *Transaction) TrimmedCopy() Transaction { var inputs []TXInput var outputs []TXOutput for _, vin := range tx.Vin {//将输入的TXInput.Signature 和TXIput.PubKey设置为空 inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil}) } for _, vout := range tx.Vout { outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash}) } txCopy := Transaction{tx.ID, inputs, outputs} return txCopy } 交易必须被签名，因为这是保证发送方不会花费其他人的币的唯一方式，如果一个签名是无效的，那么这笔交易也会被认为是无效的，因为这笔交易无法被加到区块链中。考虑到交易解锁的是之前的输出，然后重新分配里面的价值，并锁定新的输出，那么必须要签名一下的数据 存储在已经解锁输出的公钥哈希，他识别了一笔交易的发送方 存储在新的锁定输出里面的公钥哈希，他识别了一笔交易的接收方 新的输出值 因此，在比特币里，所签名的并不是一个交易，而是一个去除部分签名的输入的副本，输入里面存储了被引用输出的ScriptPubKey 如果现在进行过挖矿 cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) func NewCoinbaseTX(to, data string) *Transaction { if data == &quot;&quot; { //如果数据为空生成一个随机数据 randData := make([]byte, 20) _, err := rand.Read(randData) if err != nil { log.Panic(err) } data = fmt.Sprintf(&quot;%x&quot;, randData) }//生成一笔挖矿交易 txin := TXInput{[]byte{}, -1, nil, []byte(data)} txout := NewTXOutput(subsidy, to) tx := Transaction{nil, []TXInput{txin}, []TXOutput{*txout}} tx.ID = tx.Hash() return &amp;tx } func (bc *Blockchain) MineBlock(transactions []*Transaction) *Block { //开始挖矿 var lastHash []byte var lastHeight int for _, tx := range transactions { // TODO: ignore transaction if it&#39;s not valid if bc.VerifyTransaction(tx) != true { log.Panic(&quot;ERROR: Invalid transaction&quot;) //对打包在区块中的交易进行认证 } } err := bc.db.View(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) lastHash = b.Get([]byte(&quot;l&quot;)) //获取最新的一个块的hash值 blockData := b.Get(lastHash) block := DeserializeBlock(blockData) //将最新的一个块解序列 lastHeight = block.Height return nil }) if err != nil { log.Panic(err) } newBlock := NewBlock(transactions, lastHash, lastHeight+1) err = bc.db.Update(func(tx *bolt.Tx) error { //更新区块链数据库 b := tx.Bucket([]byte(blocksBucket)) err := b.Put(newBlock.Hash, newBlock.Serialize()) if err != nil { log.Panic(err) } err = b.Put([]byte(&quot;l&quot;), newBlock.Hash) if err != nil { log.Panic(err) } bc.tip = newBlock.Hash return nil }) if err != nil { log.Panic(err) } return newBlock } func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool { if tx.IsCoinbase() { return true } prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } return tx.Verify(prevTXs) } func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool { if tx.IsCoinbase() { //判断是否为大笔交易 return true } for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) //判断输入地址的有效性 } } txCopy := tx.TrimmedCopy() //创建一个裁剪版本的交易副本 curve := elliptic.P256() //我们需要相同区块用于生成密钥对 for inID, vin := range tx.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash r := big.Int{} s := big.Int{} sigLen := len(vin.Signature) r.SetBytes(vin.Signature[:(sigLen / 2)]) s.SetBytes(vin.Signature[(sigLen / 2):]) x := big.Int{} y := big.Int{} keyLen := len(vin.PubKey) x.SetBytes(vin.PubKey[:(keyLen / 2)]) y.SetBytes(vin.PubKey[(keyLen / 2):]) //这里我们解包存储在 TXInput.Signature 和 TXInput.PubKey 中的值，因为一个签名就是一对数字，一个公钥就是一对坐标。我们之前为了存储将它们连接在一起，现在我们需要对它们进行解包在 crypto/ecdsa 函数中使用 dataToVerify := fmt.Sprintf(&quot;%x\n&quot;, txCopy) rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y} if ecdsa.Verify(&amp;rawPubKey, []byte(dataToVerify), &amp;r, &amp;s) == false { //验证 return false } txCopy.Vin[inID].PubKey = nil } return true } func NewBlock(transactions []*Transaction, prevBlockHash []byte, height int) *Block {//产生一个新的块 block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0, height}//定义数据结构 pow := NewProofOfWork(block) //定义工作量证明的数据结构 nonce, hash := pow.Run() //挖矿 block.Hash = hash[:] block.Nonce = nonce return block } func (pow *ProofOfWork) Run() (int, []byte) { var hashInt big.Int var hash [32]byte nonce := 0 fmt.Printf(&quot;Mining a new block&quot;) for nonce &lt; maxNonce { data := pow.prepareData(nonce) hash = sha256.Sum256(data) fmt.Printf(&quot;\r%x&quot;, hash) hashInt.SetBytes(hash[:]) if hashInt.Cmp(pow.target) == -1 { break } else { nonce++ } } fmt.Print(&quot;\n\n&quot;) return nonce, hash[:] } func (pow *ProofOfWork) prepareData(nonce int) []byte { data := bytes.Join( [][]byte{ pow.block.PrevBlockHash, pow.block.HashTransactions(), IntToHex(pow.block.Timestamp), IntToHex(int64(targetBits)), IntToHex(int64(nonce)), }, []byte{}, ) return data } func (u UTXOSet) Update(block *Block) { db := u.Blockchain.db err := db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(utxoBucket)) for _, tx := range block.Transactions { if tx.IsCoinbase() == false { for _, vin := range tx.Vin { updatedOuts := TXOutputs{} outsBytes := b.Get(vin.Txid) outs := DeserializeOutputs(outsBytes) for outIdx, out := range outs.Outputs { if outIdx != vin.Vout { updatedOuts.Outputs = append(updatedOuts.Outputs, out) } } if len(updatedOuts.Outputs) == 0 { err := b.Delete(vin.Txid) if err != nil { log.Panic(err) } } else { err := b.Put(vin.Txid, updatedOuts.Serialize()) if err != nil { log.Panic(err) } } } } newOutputs := TXOutputs{} for _, out := range tx.Vout { newOutputs.Outputs = append(newOutputs.Outputs, out) } err := b.Put(tx.ID, newOutputs.Serialize()) if err != nil { log.Panic(err) } } return nil }) if err != nil { log.Panic(err) } } 参考 https://jeiwan.cc/ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/08/22/b4c516f47d36170e62fb5b3cbe2e3b80.html" />
<meta property="og:url" content="https://mlh.app/2018/08/22/b4c516f47d36170e62fb5b3cbe2e3b80.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"比特币交易 交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。 对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。下面的图示阐释了交易之间的互相关联： 注意： 有一些输出并没有被关联到某个输入上 一笔交易的输入可以引用之前多笔交易的输出 一个输入必须引用一个输出 贯穿本文，我们将会使用像“钱（money）”，“币（coin）”，“花费（spend）”，“发送（send）”，“账户（account）” 等等这样的词。但是在比特币中，其实并不存在这样的概念。交易仅仅是通过一个脚本（script）来锁定（lock）一些值（value），而这些值只可以被锁定它们的人解锁（unlock）。 每一笔比特币交易都会创造输出，输出都会被区块链记录下来。给某个人发送比特币，实际上意味着创造新的 UTXO 并注册到那个人的地址，可以为他所用。 交易的主函数： func (cli *CLI) send(from, to string, amount int, nodeID string, mineNow bool) { if !ValidateAddress(from) { log.Panic(&quot;ERROR: Sender address is not valid&quot;) } if !ValidateAddress(to) { log.Panic(&quot;ERROR: Recipient address is not valid&quot;) } bc := NewBlockchain(nodeID) //获取区块链实例 UTXOSet := UTXOSet{bc} //创建UTXO集 defer bc.Db.Close() wallets, err := NewWallets(nodeID) if err != nil { log.Panic(err) } wallet := wallets.GetWallet(from) tx := NewUTXOTransaction(&amp;wallet, to, amount, &amp;UTXOSet) if mineNow { cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) } else { sendTx(knownNodes[0], tx) } fmt.Println(&quot;Success!&quot;) } 我们从头分析整个交易过程，首先利用ValidateAddress（）方法判断输入的地址是否为有效的比特币地址，然后从我们的blotDB数据库中获取blockchain实例（我们利用一个数据库实现区块链数据的存储，这里读者可以忽略），其中读取数据库的代码如下 func NewBlockchain(nodeID string) *Blockchain { dbFile := fmt.Sprintf(dbFile, nodeID) if dbExists(dbFile) == false { fmt.Println(&quot;No existing blockchain found. Create one first.&quot;) os.Exit(1) } var tip []byte db, err := bolt.Open(dbFile, 0600, nil) //打开数据库 if err != nil { log.Panic(err) } err = db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) tip = b.Get([]byte(&quot;l&quot;)) //读取最新的区块链 return nil }) if err != nil { log.Panic(err) } bc := Blockchain{tip, db} return &amp;bc } 其中我们的区块链的基本原型为 type Blockchain struct { tip []byte Db *bolt.DB } type Block struct { Timestamp int64 Transactions []*Transaction PrevBlockHash []byte Hash []byte Nonce int Height int } 获取完成区块链实例后，我们创建出一个utxo集合，其数据结构为 type UTXOSet struct { Blockchain *Blockchain } 然后我们从钱包文件中获取我们的钱包集合（wallets）,接着调用我们的转账函数。 func NewUTXOTransaction(wallet *Wallet, to string, amount int, UTXOSet *UTXOSet) *Transaction { var inputs []TXInput var outputs []TXOutput pubKeyHash := HashPubKey(wallet.PublicKey) acc, validOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount) //找到能够使用的输出 if acc &lt; amount { //如果能够使用的输出小于目标值，则返回错误 log.Panic(&quot;ERROR: Not enough funds&quot;) } // Build a list of inputs for txid, outs := range validOutputs { txID, err := hex.DecodeString(txid) if err != nil { log.Panic(err) } for _, out := range outs { input := TXInput{txID, out, nil, wallet.PublicKey} inputs = append(inputs, input) } } // Build a list of outputs from := fmt.Sprintf(&quot;%s&quot;, wallet.GetAddress()) outputs = append(outputs, *NewTXOutput(amount, to)) //创建新的交易输出 if acc &gt; amount { outputs = append(outputs, *NewTXOutput(acc-amount, from)) // a change //找零输出 } tx := Transaction{nil, inputs, outputs} tx.ID = tx.Hash() //创建一笔交易 UTXOSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey) //对交易签名 return &amp;tx } 对于一笔交易来说，其数据结构为 type Transaction struct { ID []byte Vin []TXInput Vout []TXOutput } type TXInput struct { Txid []byte Vout int Signature []byte PubKey []byte } type TXOutput struct { Value int PubKeyHash []byte } type UTXOSet struct { Blockchain *Blockchain } 一笔交易来说，输出主要包含两部分： 一定量的比特币(Value)， 一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。一个输入引用了之前交易的一个输出：Txid 存储的是之前交易的 ID，Vout 存储的是该输出在那笔交易中所有输出的索引（因为一笔交易可能有多个输出，需要有信息指明是具体的哪一个）Signature是签名，而Pubkey是公钥，两者保证了用户无法花费属于其他人的币。 func HashPubKey(pubKey []byte) []byte { // RIPEMD160(SHA256(PubKey)) publicSHA256 := sha256.Sum256(pubKey) RIPEMD160Hasher := ripemd160.New() _, err := RIPEMD160Hasher.Write(publicSHA256[:]) if err != nil { log.Panic(err) } publicRIPEMD160 := RIPEMD160Hasher.Sum(nil) return publicRIPEMD160 } func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) { unspentOutputs := make(map[string][]int) //为输出开辟一块内存空间 accumulated := 0 db := u.Blockchain.db //获取存取区块链的数据库 err := db.View(func(tx *bolt.Tx) error { //读取数据库 b := tx.Bucket([]byte(utxoBucket)) c := b.Cursor() for k, v := c.First(); k != nil; k, v = c.Next() { //遍历数据库 txID := hex.EncodeToString(k) outs := DeserializeOutputs(v) for outIdx, out := range outs.Outputs { if out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount { //如果能够解锁输出，代表utxo集中的输出是的所有者是该公钥所对应的人 accumulated += out.Value //累加值 unspentOutputs[txID] = append(unspentOutputs[txID], outIdx) //加到数组中 } } } return nil }) if err != nil { log.Panic(err) } return accumulated, unspentOutputs } func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool { //判断输出是否能够被某个公钥解锁 return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0 } func NewTXOutput(value int, address string) *TXOutput { txo := &amp;TXOutput{value, nil} //注册一个输出 txo.Lock([]byte(address)) //设置输出的pubhashkey return txo } func (out *TXOutput) Lock(address []byte) { pubKeyHash := Base58Decode(address) pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4] out.PubKeyHash = pubKeyHash } 在创建新的输出时，我们必须找到所有的为花费的输出，并且确保他们有足够的价值（value），这就是FindSpendableOutputs 要做的事情，随后，对于每个找到的输出，会创建一个引用该输出的输入。接下来，我们创建两个输出： 一个由接收者地址锁定。这是给其他地址实际转移的币。 一个由发送者地址锁定。这是一个找零。只有当未花费输出超过新交易所需时产生。记住：输出是不可再分的。 func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) { prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } tx.Sign(privKey, prevTXs) } func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {//方法接受一个私钥和之前一个交易的map if tx.IsCoinbase() { return }//判断是是否为发币交易，因为发币交易没有输入，故不用进行签名 for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) } } txCopy := tx.TrimmedCopy() //将会被签名的是修剪后的交易副本，而不是一个完整的交易 for inID, vin := range txCopy.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash //迭代副本中的每一个输入，在每个输入中，Pubkey 被设置为所引用输出的PubKeyHash / dataToSign := fmt.Sprintf(&quot;%x\\n&quot;, txCopy) r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, []byte(dataToSign))//我们通过private对txCopy进行签名将这串数字连接起来储存在signature中 if err != nil { log.Panic(err) } signature := append(r.Bytes(), s.Bytes()...) tx.Vin[inID].Signature = signature txCopy.Vin[inID].PubKey = nil } } func (tx *Transaction) TrimmedCopy() Transaction { var inputs []TXInput var outputs []TXOutput for _, vin := range tx.Vin {//将输入的TXInput.Signature 和TXIput.PubKey设置为空 inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil}) } for _, vout := range tx.Vout { outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash}) } txCopy := Transaction{tx.ID, inputs, outputs} return txCopy } 交易必须被签名，因为这是保证发送方不会花费其他人的币的唯一方式，如果一个签名是无效的，那么这笔交易也会被认为是无效的，因为这笔交易无法被加到区块链中。考虑到交易解锁的是之前的输出，然后重新分配里面的价值，并锁定新的输出，那么必须要签名一下的数据 存储在已经解锁输出的公钥哈希，他识别了一笔交易的发送方 存储在新的锁定输出里面的公钥哈希，他识别了一笔交易的接收方 新的输出值 因此，在比特币里，所签名的并不是一个交易，而是一个去除部分签名的输入的副本，输入里面存储了被引用输出的ScriptPubKey 如果现在进行过挖矿 cbTx := NewCoinbaseTX(from, &quot;&quot;) txs := []*Transaction{cbTx, tx} newBlock := bc.MineBlock(txs) UTXOSet.Update(newBlock) func NewCoinbaseTX(to, data string) *Transaction { if data == &quot;&quot; { //如果数据为空生成一个随机数据 randData := make([]byte, 20) _, err := rand.Read(randData) if err != nil { log.Panic(err) } data = fmt.Sprintf(&quot;%x&quot;, randData) }//生成一笔挖矿交易 txin := TXInput{[]byte{}, -1, nil, []byte(data)} txout := NewTXOutput(subsidy, to) tx := Transaction{nil, []TXInput{txin}, []TXOutput{*txout}} tx.ID = tx.Hash() return &amp;tx } func (bc *Blockchain) MineBlock(transactions []*Transaction) *Block { //开始挖矿 var lastHash []byte var lastHeight int for _, tx := range transactions { // TODO: ignore transaction if it&#39;s not valid if bc.VerifyTransaction(tx) != true { log.Panic(&quot;ERROR: Invalid transaction&quot;) //对打包在区块中的交易进行认证 } } err := bc.db.View(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(blocksBucket)) lastHash = b.Get([]byte(&quot;l&quot;)) //获取最新的一个块的hash值 blockData := b.Get(lastHash) block := DeserializeBlock(blockData) //将最新的一个块解序列 lastHeight = block.Height return nil }) if err != nil { log.Panic(err) } newBlock := NewBlock(transactions, lastHash, lastHeight+1) err = bc.db.Update(func(tx *bolt.Tx) error { //更新区块链数据库 b := tx.Bucket([]byte(blocksBucket)) err := b.Put(newBlock.Hash, newBlock.Serialize()) if err != nil { log.Panic(err) } err = b.Put([]byte(&quot;l&quot;), newBlock.Hash) if err != nil { log.Panic(err) } bc.tip = newBlock.Hash return nil }) if err != nil { log.Panic(err) } return newBlock } func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool { if tx.IsCoinbase() { return true } prevTXs := make(map[string]Transaction) for _, vin := range tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) if err != nil { log.Panic(err) } prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } return tx.Verify(prevTXs) } func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool { if tx.IsCoinbase() { //判断是否为大笔交易 return true } for _, vin := range tx.Vin { if prevTXs[hex.EncodeToString(vin.Txid)].ID == nil { log.Panic(&quot;ERROR: Previous transaction is not correct&quot;) //判断输入地址的有效性 } } txCopy := tx.TrimmedCopy() //创建一个裁剪版本的交易副本 curve := elliptic.P256() //我们需要相同区块用于生成密钥对 for inID, vin := range tx.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = nil txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash r := big.Int{} s := big.Int{} sigLen := len(vin.Signature) r.SetBytes(vin.Signature[:(sigLen / 2)]) s.SetBytes(vin.Signature[(sigLen / 2):]) x := big.Int{} y := big.Int{} keyLen := len(vin.PubKey) x.SetBytes(vin.PubKey[:(keyLen / 2)]) y.SetBytes(vin.PubKey[(keyLen / 2):]) //这里我们解包存储在 TXInput.Signature 和 TXInput.PubKey 中的值，因为一个签名就是一对数字，一个公钥就是一对坐标。我们之前为了存储将它们连接在一起，现在我们需要对它们进行解包在 crypto/ecdsa 函数中使用 dataToVerify := fmt.Sprintf(&quot;%x\\n&quot;, txCopy) rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y} if ecdsa.Verify(&amp;rawPubKey, []byte(dataToVerify), &amp;r, &amp;s) == false { //验证 return false } txCopy.Vin[inID].PubKey = nil } return true } func NewBlock(transactions []*Transaction, prevBlockHash []byte, height int) *Block {//产生一个新的块 block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0, height}//定义数据结构 pow := NewProofOfWork(block) //定义工作量证明的数据结构 nonce, hash := pow.Run() //挖矿 block.Hash = hash[:] block.Nonce = nonce return block } func (pow *ProofOfWork) Run() (int, []byte) { var hashInt big.Int var hash [32]byte nonce := 0 fmt.Printf(&quot;Mining a new block&quot;) for nonce &lt; maxNonce { data := pow.prepareData(nonce) hash = sha256.Sum256(data) fmt.Printf(&quot;\\r%x&quot;, hash) hashInt.SetBytes(hash[:]) if hashInt.Cmp(pow.target) == -1 { break } else { nonce++ } } fmt.Print(&quot;\\n\\n&quot;) return nonce, hash[:] } func (pow *ProofOfWork) prepareData(nonce int) []byte { data := bytes.Join( [][]byte{ pow.block.PrevBlockHash, pow.block.HashTransactions(), IntToHex(pow.block.Timestamp), IntToHex(int64(targetBits)), IntToHex(int64(nonce)), }, []byte{}, ) return data } func (u UTXOSet) Update(block *Block) { db := u.Blockchain.db err := db.Update(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(utxoBucket)) for _, tx := range block.Transactions { if tx.IsCoinbase() == false { for _, vin := range tx.Vin { updatedOuts := TXOutputs{} outsBytes := b.Get(vin.Txid) outs := DeserializeOutputs(outsBytes) for outIdx, out := range outs.Outputs { if outIdx != vin.Vout { updatedOuts.Outputs = append(updatedOuts.Outputs, out) } } if len(updatedOuts.Outputs) == 0 { err := b.Delete(vin.Txid) if err != nil { log.Panic(err) } } else { err := b.Put(vin.Txid, updatedOuts.Serialize()) if err != nil { log.Panic(err) } } } } newOutputs := TXOutputs{} for _, out := range tx.Vout { newOutputs.Outputs = append(newOutputs.Outputs, out) } err := b.Put(tx.ID, newOutputs.Serialize()) if err != nil { log.Panic(err) } } return nil }) if err != nil { log.Panic(err) } } 参考 https://jeiwan.cc/ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/08/22/b4c516f47d36170e62fb5b3cbe2e3b80.html","headline":"利用go语言实现比特币交易（Transaction）","dateModified":"2018-08-22T00:00:00+08:00","datePublished":"2018-08-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/08/22/b4c516f47d36170e62fb5b3cbe2e3b80.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>利用go语言实现比特币交易（Transaction）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="比特币交易">比特币交易</h1> 
  <p>交易（transaction）是比特币的核心所在，而区块链唯一的目的，也正是为了能够安全可靠地存储交易。在区块链中，交易一旦被创建，就没有任何人能够再去修改或是删除它。 <br> 对于每一笔新的交易，它的输入会引用（reference）之前一笔交易的输出（这里有个例外，coinbase 交易），引用就是花费的意思。所谓引用之前的一个输出，也就是将之前的一个输出包含在另一笔交易的输入当中，就是花费之前的交易输出。交易的输出，就是币实际存储的地方。下面的图示阐释了交易之间的互相关联： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018082315373789?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzE5MDQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 注意：</p> 
  <ol> 
   <li>有一些输出并没有被关联到某个输入上</li> 
   <li>一笔交易的输入可以引用之前多笔交易的输出</li> 
   <li>一个输入必须引用一个输出</li> 
  </ol> 
  <p>贯穿本文，我们将会使用像“钱（money）”，“币（coin）”，“花费（spend）”，“发送（send）”，“账户（account）” 等等这样的词。但是在比特币中，其实并不存在这样的概念。交易仅仅是通过一个脚本（script）来锁定（lock）一些值（value），而这些值只可以被锁定它们的人解锁（unlock）。</p> 
  <p>每一笔比特币交易都会创造输出，输出都会被区块链记录下来。给某个人发送比特币，实际上意味着创造新的 UTXO 并注册到那个人的地址，可以为他所用。 <br> <strong>交易的主函数：</strong></p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">func (cli *CLI) <span class="hljs-built_in">send</span>(<span class="hljs-built_in">from</span>, <span class="hljs-built_in">to</span> <span class="hljs-keyword">string</span>, amount int, nodeID <span class="hljs-keyword">string</span>, mineNow bool) {
    <span class="hljs-keyword">if</span> !ValidateAddress(<span class="hljs-built_in">from</span>) {   
        <span class="hljs-built_in">log</span>.Panic(<span class="hljs-string">"ERROR: Sender address is not valid"</span>)
    }
    <span class="hljs-keyword">if</span> !ValidateAddress(<span class="hljs-built_in">to</span>) {
        <span class="hljs-built_in">log</span>.Panic(<span class="hljs-string">"ERROR: Recipient address is not valid"</span>)
    }
    bc := NewBlockchain(nodeID)   <span class="hljs-comment"> //获取区块链实例</span>
    UTXOSet := UTXOSet{bc}   <span class="hljs-comment"> //创建UTXO集</span>
    defer bc.Db.Close()
    wallets, err := NewWallets(nodeID)
    <span class="hljs-keyword">if</span> err != nil {
        <span class="hljs-built_in">log</span>.Panic(err)
    }
    wallet := wallets.GetWallet(<span class="hljs-built_in">from</span>)
    tx := NewUTXOTransaction(&amp;wallet, <span class="hljs-built_in">to</span>, amount, &amp;UTXOSet)
    <span class="hljs-keyword">if</span> mineNow {    
        cbTx := NewCoinbaseTX(<span class="hljs-built_in">from</span>, <span class="hljs-string">""</span>)
        txs := []*Transaction{cbTx, tx}
        newBlock := bc.MineBlock(txs)
        UTXOSet.Update(newBlock)
    } <span class="hljs-keyword">else</span> {
        sendTx(knownNodes[<span class="hljs-number">0</span>], tx)
    }

    fmt.Println(<span class="hljs-string">"Success!"</span>)
}</code></pre> 
  <p>我们从头分析整个交易过程，首先利用<a href="https://blog.csdn.net/m0_37719047/article/details/81945896" rel="nofollow">ValidateAddress（）</a>方法判断输入的地址是否为有效的比特币地址，然后从我们的blotDB数据库中获取blockchain实例（我们利用一个数据库实现区块链数据的存储，这里读者可以忽略），其中读取数据库的代码如下</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> NewBlockchain(nodeID <span class="hljs-typename">string</span>) *Blockchain {
    dbFile := fmt.Sprintf(dbFile, nodeID)
    <span class="hljs-keyword">if</span> dbExists(dbFile) == <span class="hljs-constant">false</span> {
        fmt.Println(<span class="hljs-string">"No existing blockchain found. Create one first."</span>)
        os.Exit<span class="hljs-number">(1</span>)
    }
    <span class="hljs-keyword">var</span> tip []<span class="hljs-typename">byte</span>
    db, err := bolt.Open(dbFile,<span class="hljs-number"> 0600</span>, <span class="hljs-constant">nil</span>)    <span class="hljs-comment">//打开数据库</span>
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    err = db.Update(<span class="hljs-keyword">func</span>(tx *bolt.Tx) error {
        b := tx.Bucket([]<span class="hljs-typename">byte</span>(blocksBucket))
        tip = b.Get([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"l"</span>))  <span class="hljs-comment">//读取最新的区块链</span>
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
    })
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    bc := Blockchain{tip, db}
    <span class="hljs-keyword">return</span> &amp;bc
}</code></pre> 
  <p>其中我们的区块链的基本原型为</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Blockchain</span> struct <span class="hljs-container">{ <span class="hljs-title">tip</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Db</span> *<span class="hljs-title">bolt</span>.<span class="hljs-type">DB</span> }</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Block</span> struct <span class="hljs-container">{ <span class="hljs-type">Timestamp</span> <span class="hljs-title">int64</span> <span class="hljs-type">Transactions</span> []*<span class="hljs-type">Transaction</span> <span class="hljs-type">PrevBlockHash</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Hash</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Nonce</span> <span class="hljs-title">int</span> <span class="hljs-type">Height</span> <span class="hljs-title">int</span> }</span></span></code></pre> 
  <p>获取完成区块链实例后，我们创建出一个utxo集合，其数据结构为</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">UTXOSet</span> struct <span class="hljs-container">{ <span class="hljs-type">Blockchain</span> *<span class="hljs-type">Blockchain</span> }</span></span></code></pre> 
  <p>然后我们从钱包文件中获取我们的<a href="https://blog.csdn.net/m0_37719047/article/details/81949561" rel="nofollow">钱包集合（wallets）</a>,接着调用我们的转账函数。</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> NewUTXOTransaction(wallet *Wallet, to <span class="hljs-typename">string</span>, amount <span class="hljs-typename">int</span>, UTXOSet *UTXOSet) *Transaction {
    <span class="hljs-keyword">var</span> inputs []TXInput
    <span class="hljs-keyword">var</span> outputs []TXOutput
    pubKeyHash := HashPubKey(wallet.PublicKey)
    acc, validOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount)    <span class="hljs-comment">//找到能够使用的输出</span>
    <span class="hljs-keyword">if</span> acc &lt; amount {    <span class="hljs-comment">//如果能够使用的输出小于目标值，则返回错误</span>
        log.Panic(<span class="hljs-string">"ERROR: Not enough funds"</span>)
    }
    <span class="hljs-comment">// Build a list of inputs</span>
    <span class="hljs-keyword">for</span> txid, outs := <span class="hljs-keyword">range</span> validOutputs {         
        txID, err := hex.DecodeString(txid)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Panic(err)
        }
        <span class="hljs-keyword">for</span> _, out := <span class="hljs-keyword">range</span> outs {
            input := TXInput{txID, out, <span class="hljs-constant">nil</span>, wallet.PublicKey}
            inputs = <span class="hljs-built_in">append</span>(inputs, input)
        }
    }
    <span class="hljs-comment">// Build a list of outputs</span>
    from := fmt.Sprintf(<span class="hljs-string">"%s"</span>, wallet.GetAddress())
    outputs = <span class="hljs-built_in">append</span>(outputs, *NewTXOutput(amount, to))    <span class="hljs-comment">//创建新的交易输出</span>
    <span class="hljs-keyword">if</span> acc &gt; amount {
        outputs = <span class="hljs-built_in">append</span>(outputs, *NewTXOutput(acc-amount, from)) <span class="hljs-comment">// a change //找零输出</span>
    }
    tx := Transaction{<span class="hljs-constant">nil</span>, inputs, outputs}
    tx.ID = tx.Hash()    <span class="hljs-comment">//创建一笔交易</span>
    UTXOSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey)       <span class="hljs-comment">//对交易签名</span>
    <span class="hljs-keyword">return</span> &amp;tx
}</code></pre> 
  <p>对于一笔交易来说，其数据结构为</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Transaction</span> struct <span class="hljs-container">{ <span class="hljs-type">ID</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Vin</span> []<span class="hljs-type">TXInput</span> <span class="hljs-type">Vout</span> []<span class="hljs-type">TXOutput</span> }</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">TXInput</span> struct <span class="hljs-container">{ <span class="hljs-type">Txid</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Vout</span> <span class="hljs-title">int</span> <span class="hljs-type">Signature</span> []<span class="hljs-title">byte</span> <span class="hljs-type">PubKey</span> []<span class="hljs-title">byte</span> }</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">TXOutput</span> struct <span class="hljs-container">{ <span class="hljs-type">Value</span> <span class="hljs-title">int</span> <span class="hljs-type">PubKeyHash</span> []<span class="hljs-title">byte</span> }</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">UTXOSet</span> struct <span class="hljs-container">{ <span class="hljs-type">Blockchain</span> *<span class="hljs-type">Blockchain</span> }</span></span></code></pre> 
  <p>一笔交易来说，输出主要包含两部分： 一定量的比特币(Value)， 一个锁定脚本(ScriptPubKey)，要花这笔钱，必须要解锁该脚本。一个输入引用了之前交易的一个输出：Txid 存储的是之前交易的 ID，Vout 存储的是该输出在那笔交易中所有输出的索引（因为一笔交易可能有多个输出，需要有信息指明是具体的哪一个）Signature是签名，而Pubkey是公钥，两者保证了用户无法花费属于其他人的币。</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> HashPubKey(pubKey []<span class="hljs-typename">byte</span>) []<span class="hljs-typename">byte</span> {  <span class="hljs-comment">// RIPEMD160(SHA256(PubKey))</span>
    publicSHA256 := sha256.Sum256(pubKey)
    RIPEMD160Hasher := ripemd160.New()
    _, err := RIPEMD160Hasher.Write(publicSHA256[:])
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    publicRIPEMD160 := RIPEMD160Hasher.Sum(<span class="hljs-constant">nil</span>)
    <span class="hljs-keyword">return</span> publicRIPEMD160
}
<span class="hljs-keyword">func</span> (u UTXOSet) FindSpendableOutputs(pubkeyHash []<span class="hljs-typename">byte</span>, amount <span class="hljs-typename">int</span>) (<span class="hljs-typename">int</span>, <span class="hljs-keyword">map</span>[<span class="hljs-typename">string</span>][]<span class="hljs-typename">int</span>) {
    unspentOutputs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-typename">string</span>][]<span class="hljs-typename">int</span>)     <span class="hljs-comment">//为输出开辟一块内存空间</span>
    accumulated :=<span class="hljs-number"> 0</span>       
    db := u.Blockchain.db             <span class="hljs-comment">//获取存取区块链的数据库</span>
    err := db.View(<span class="hljs-keyword">func</span>(tx *bolt.Tx) error {               <span class="hljs-comment">//读取数据库</span>
        b := tx.Bucket([]<span class="hljs-typename">byte</span>(utxoBucket))
        c := b.Cursor()
        <span class="hljs-keyword">for</span> k, v := c.First(); k != <span class="hljs-constant">nil</span>; k, v = c.Next() {               <span class="hljs-comment">//遍历数据库</span>
            txID := hex.EncodeToString(k)
            outs := DeserializeOutputs(v)
            <span class="hljs-keyword">for</span> outIdx, out := <span class="hljs-keyword">range</span> outs.Outputs {
                <span class="hljs-keyword">if</span> out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount {          <span class="hljs-comment">//如果能够解锁输出，代表utxo集中的输出是的所有者是该公钥所对应的人</span>
                    accumulated += out.Value     <span class="hljs-comment">//累加值</span>
                    unspentOutputs[txID] = <span class="hljs-built_in">append</span>(unspentOutputs[txID], outIdx)     <span class="hljs-comment">//加到数组中</span>
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
    })
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    <span class="hljs-keyword">return</span> accumulated, unspentOutputs
}
<span class="hljs-keyword">func</span> (out *TXOutput) IsLockedWithKey(pubKeyHash []<span class="hljs-typename">byte</span>) <span class="hljs-typename">bool</span> {      <span class="hljs-comment">//判断输出是否能够被某个公钥解锁</span>
    <span class="hljs-keyword">return</span> bytes.Compare(out.PubKeyHash, pubKeyHash) ==<span class="hljs-number"> 0</span>
} 
<span class="hljs-keyword">func</span> NewTXOutput(value <span class="hljs-typename">int</span>, address <span class="hljs-typename">string</span>) *TXOutput {
    txo := &amp;TXOutput{value, <span class="hljs-constant">nil</span>}    <span class="hljs-comment">//注册一个输出</span>
    txo.Lock([]<span class="hljs-typename">byte</span>(address))    <span class="hljs-comment">//设置输出的pubhashkey</span>
    <span class="hljs-keyword">return</span> txo
}
<span class="hljs-keyword">func</span> (out *TXOutput) Lock(address []<span class="hljs-typename">byte</span>) {
    pubKeyHash := Base58Decode(address)
    pubKeyHash = pubKeyHash<span class="hljs-number">[1</span> : <span class="hljs-built_in">len</span>(pubKeyHash<span class="hljs-number">)-4</span>]
    out.PubKeyHash = pubKeyHash
}
</code></pre> 
  <p>在创建新的输出时，我们必须找到所有的为花费的输出，并且确保他们有足够的价值（value），这就是<code>FindSpendableOutputs</code> 要做的事情，随后，对于每个找到的输出，会创建一个引用该输出的输入。接下来，我们创建两个输出：</p> 
  <ol> 
   <li><p>一个由接收者地址锁定。这是给其他地址实际转移的币。 </p></li> 
   <li><p>一个由发送者地址锁定。这是一个找零。只有当未花费输出超过新交易所需时产生。记住：输出是不可再分的。</p></li> 
  </ol> 
  <pre class="prettyprint"><code class=" hljs avrasm">func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa<span class="hljs-preprocessor">.PrivateKey</span>) {
    prevTXs := make(map[string]Transaction)
    for _, vin := range tx<span class="hljs-preprocessor">.Vin</span> {
        prevTX, err := bc<span class="hljs-preprocessor">.FindTransaction</span>(vin<span class="hljs-preprocessor">.Txid</span>)
        if err != nil {
            log<span class="hljs-preprocessor">.Panic</span>(err)
        }
        prevTXs[hex<span class="hljs-preprocessor">.EncodeToString</span>(prevTX<span class="hljs-preprocessor">.ID</span>)] = prevTX
    }
    tx<span class="hljs-preprocessor">.Sign</span>(privKey, prevTXs)
}
func (tx *Transaction) Sign(privKey ecdsa<span class="hljs-preprocessor">.PrivateKey</span>, prevTXs map[string]Transaction) {//方法接受一个私钥和之前一个交易的map
    if tx<span class="hljs-preprocessor">.IsCoinbase</span>() {
        return
    }//判断是是否为发币交易，因为发币交易没有输入，故不用进行签名

    for _, vin := range tx<span class="hljs-preprocessor">.Vin</span> {
        if prevTXs[hex<span class="hljs-preprocessor">.EncodeToString</span>(vin<span class="hljs-preprocessor">.Txid</span>)]<span class="hljs-preprocessor">.ID</span> == nil {
            log<span class="hljs-preprocessor">.Panic</span>(<span class="hljs-string">"ERROR: Previous transaction is not correct"</span>)
        }
    }

    txCopy := tx<span class="hljs-preprocessor">.TrimmedCopy</span>()  //将会被签名的是修剪后的交易副本，而不是一个完整的交易

    for inID, vin := range txCopy<span class="hljs-preprocessor">.Vin</span> {
        prevTx := prevTXs[hex<span class="hljs-preprocessor">.EncodeToString</span>(vin<span class="hljs-preprocessor">.Txid</span>)]
        txCopy<span class="hljs-preprocessor">.Vin</span>[inID]<span class="hljs-preprocessor">.Signature</span> = nil
        txCopy<span class="hljs-preprocessor">.Vin</span>[inID]<span class="hljs-preprocessor">.PubKey</span> = prevTx<span class="hljs-preprocessor">.Vout</span>[vin<span class="hljs-preprocessor">.Vout</span>]<span class="hljs-preprocessor">.PubKeyHash</span>
//迭代副本中的每一个输入，在每个输入中，Pubkey 被设置为所引用输出的PubKeyHash
/
        dataToSign := fmt<span class="hljs-preprocessor">.Sprintf</span>(<span class="hljs-string">"%x\n"</span>, txCopy)
        r, s, err := ecdsa<span class="hljs-preprocessor">.Sign</span>(rand<span class="hljs-preprocessor">.Reader</span>, &amp;privKey, []byte(dataToSign))//我们通过private对txCopy进行签名将这串数字连接起来储存在signature中
        if err != nil {
            log<span class="hljs-preprocessor">.Panic</span>(err)
        }
        signature := append(r<span class="hljs-preprocessor">.Bytes</span>(), s<span class="hljs-preprocessor">.Bytes</span>()...)
        tx<span class="hljs-preprocessor">.Vin</span>[inID]<span class="hljs-preprocessor">.Signature</span> = signature
        txCopy<span class="hljs-preprocessor">.Vin</span>[inID]<span class="hljs-preprocessor">.PubKey</span> = nil
    }
}


func (tx *Transaction) TrimmedCopy() Transaction {  
    var inputs []TXInput
    var outputs []TXOutput

    for _, vin := range tx<span class="hljs-preprocessor">.Vin</span> {//将输入的TXInput<span class="hljs-preprocessor">.Signature</span> 和TXIput<span class="hljs-preprocessor">.PubKey</span>设置为空
        inputs = append(inputs, TXInput{vin<span class="hljs-preprocessor">.Txid</span>, vin<span class="hljs-preprocessor">.Vout</span>, nil, nil})
    }

    for _, vout := range tx<span class="hljs-preprocessor">.Vout</span> {
        outputs = append(outputs, TXOutput{vout<span class="hljs-preprocessor">.Value</span>, vout<span class="hljs-preprocessor">.PubKeyHash</span>})
    }
    txCopy := Transaction{tx<span class="hljs-preprocessor">.ID</span>, inputs, outputs}
    return txCopy
}</code></pre> 
  <p>交易必须被签名，因为这是保证发送方不会花费其他人的币的唯一方式，如果一个签名是无效的，那么这笔交易也会被认为是无效的，因为这笔交易无法被加到区块链中。考虑到交易解锁的是之前的输出，然后重新分配里面的价值，并锁定新的输出，那么必须要签名一下的数据</p> 
  <ol> 
   <li>存储在已经解锁输出的公钥哈希，他识别了一笔交易的发送方</li> 
   <li>存储在新的锁定输出里面的公钥哈希，他识别了一笔交易的接收方</li> 
   <li>新的输出值 <br> 因此，在比特币里，所签名的并不是一个交易，而是一个去除部分签名的输入的副本，输入里面存储了被引用输出的<code>ScriptPubKey</code></li> 
  </ol> 
  <p>如果现在进行过挖矿</p> 
  <pre class="prettyprint"><code class=" hljs go">       cbTx := NewCoinbaseTX(from, <span class="hljs-string">""</span>)
        txs := []*Transaction{cbTx, tx}
        newBlock := bc.MineBlock(txs)
        UTXOSet.Update(newBlock)



<span class="hljs-keyword">func</span> NewCoinbaseTX(to, data <span class="hljs-typename">string</span>) *Transaction {
    <span class="hljs-keyword">if</span> data == <span class="hljs-string">""</span> {  <span class="hljs-comment">//如果数据为空生成一个随机数据</span>
        randData := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>,<span class="hljs-number"> 20</span>)
        _, err := rand.Read(randData)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Panic(err)
        }
        data = fmt.Sprintf(<span class="hljs-string">"%x"</span>, randData)
    }<span class="hljs-comment">//生成一笔挖矿交易</span>
    txin := TXInput{[]<span class="hljs-typename">byte</span>{},<span class="hljs-number"> -1</span>, <span class="hljs-constant">nil</span>, []<span class="hljs-typename">byte</span>(data)}
    txout := NewTXOutput(subsidy, to)
    tx := Transaction{<span class="hljs-constant">nil</span>, []TXInput{txin}, []TXOutput{*txout}}
    tx.ID = tx.Hash()
    <span class="hljs-keyword">return</span> &amp;tx
}

<span class="hljs-keyword">func</span> (bc *Blockchain) MineBlock(transactions []*Transaction) *Block {   <span class="hljs-comment">//开始挖矿</span>
    <span class="hljs-keyword">var</span> lastHash []<span class="hljs-typename">byte</span>
    <span class="hljs-keyword">var</span> lastHeight <span class="hljs-typename">int</span>
    <span class="hljs-keyword">for</span> _, tx := <span class="hljs-keyword">range</span> transactions {
        <span class="hljs-comment">// TODO: ignore transaction if it's not valid</span>
        <span class="hljs-keyword">if</span> bc.VerifyTransaction(tx) != <span class="hljs-constant">true</span> {
            log.Panic(<span class="hljs-string">"ERROR: Invalid transaction"</span>)   <span class="hljs-comment">//对打包在区块中的交易进行认证</span>
        }
    }

    err := bc.db.View(<span class="hljs-keyword">func</span>(tx *bolt.Tx) error {
        b := tx.Bucket([]<span class="hljs-typename">byte</span>(blocksBucket))
        lastHash = b.Get([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"l"</span>))   <span class="hljs-comment">//获取最新的一个块的hash值</span>
        blockData := b.Get(lastHash)
        block := DeserializeBlock(blockData)  <span class="hljs-comment">//将最新的一个块解序列</span>
        lastHeight = block.Height
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
    })
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    newBlock := NewBlock(transactions, lastHash, lastHeight<span class="hljs-number">+1</span>)
    err = bc.db.Update(<span class="hljs-keyword">func</span>(tx *bolt.Tx) error {    <span class="hljs-comment">//更新区块链数据库</span>
        b := tx.Bucket([]<span class="hljs-typename">byte</span>(blocksBucket))
        err := b.Put(newBlock.Hash, newBlock.Serialize())
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Panic(err)
        }
        err = b.Put([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"l"</span>), newBlock.Hash)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Panic(err)
        }
        bc.tip = newBlock.Hash
        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
    })
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
    <span class="hljs-keyword">return</span> newBlock
}
<span class="hljs-keyword">func</span> (bc *Blockchain) VerifyTransaction(tx *Transaction) <span class="hljs-typename">bool</span> {
    <span class="hljs-keyword">if</span> tx.IsCoinbase() {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
    }
    prevTXs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-typename">string</span>]Transaction)
    <span class="hljs-keyword">for</span> _, vin := <span class="hljs-keyword">range</span> tx.Vin {
        prevTX, err := bc.FindTransaction(vin.Txid)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Panic(err)
        }
        prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
    }
    <span class="hljs-keyword">return</span> tx.Verify(prevTXs)
}
<span class="hljs-keyword">func</span> (tx *Transaction) Verify(prevTXs <span class="hljs-keyword">map</span>[<span class="hljs-typename">string</span>]Transaction) <span class="hljs-typename">bool</span> {
    <span class="hljs-keyword">if</span> tx.IsCoinbase() {   <span class="hljs-comment">//判断是否为大笔交易</span>
        <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
    }
    <span class="hljs-keyword">for</span> _, vin := <span class="hljs-keyword">range</span> tx.Vin {
        <span class="hljs-keyword">if</span> prevTXs[hex.EncodeToString(vin.Txid)].ID == <span class="hljs-constant">nil</span> {
            log.Panic(<span class="hljs-string">"ERROR: Previous transaction is not correct"</span>)   <span class="hljs-comment">//判断输入地址的有效性</span>
        }
    }
    txCopy := tx.TrimmedCopy()    <span class="hljs-comment">//创建一个裁剪版本的交易副本</span>
    curve := elliptic.P256()    <span class="hljs-comment">//我们需要相同区块用于生成密钥对</span>
    <span class="hljs-keyword">for</span> inID, vin := <span class="hljs-keyword">range</span> tx.Vin {
        prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
        txCopy.Vin[inID].Signature = <span class="hljs-constant">nil</span>
        txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
        r := big.Int{}
        s := big.Int{}
        sigLen := <span class="hljs-built_in">len</span>(vin.Signature)
        r.SetBytes(vin.Signature[:(sigLen /<span class="hljs-number"> 2</span>)])
        s.SetBytes(vin.Signature[(sigLen /<span class="hljs-number"> 2</span>):])
        x := big.Int{}
        y := big.Int{}
        keyLen := <span class="hljs-built_in">len</span>(vin.PubKey)
        x.SetBytes(vin.PubKey[:(keyLen /<span class="hljs-number"> 2</span>)])
        y.SetBytes(vin.PubKey[(keyLen /<span class="hljs-number"> 2</span>):])
<span class="hljs-comment">//这里我们解包存储在 TXInput.Signature 和 TXInput.PubKey 中的值，因为一个签名就是一对数字，一个公钥就是一对坐标。我们之前为了存储将它们连接在一起，现在我们需要对它们进行解包在 crypto/ecdsa 函数中使用</span>
        dataToVerify := fmt.Sprintf(<span class="hljs-string">"%x\n"</span>, txCopy)
        rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y}
        <span class="hljs-keyword">if</span> ecdsa.Verify(&amp;rawPubKey, []<span class="hljs-typename">byte</span>(dataToVerify), &amp;r, &amp;s) == <span class="hljs-constant">false</span> {  <span class="hljs-comment">//验证</span>
            <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
        }
        txCopy.Vin[inID].PubKey = <span class="hljs-constant">nil</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
}
<span class="hljs-keyword">func</span> NewBlock(transactions []*Transaction, prevBlockHash []<span class="hljs-typename">byte</span>, height <span class="hljs-typename">int</span>) *Block {<span class="hljs-comment">//产生一个新的块</span>
    block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []<span class="hljs-typename">byte</span>{},<span class="hljs-number"> 0</span>, height}<span class="hljs-comment">//定义数据结构</span>
    pow := NewProofOfWork(block)    <span class="hljs-comment">//定义工作量证明的数据结构</span>
    nonce, hash := pow.Run()    <span class="hljs-comment">//挖矿</span>
    block.Hash = hash[:]
    block.Nonce = nonce
    <span class="hljs-keyword">return</span> block
}
<span class="hljs-keyword">func</span> (pow *ProofOfWork) Run() (<span class="hljs-typename">int</span>, []<span class="hljs-typename">byte</span>) {
    <span class="hljs-keyword">var</span> hashInt big.Int
    <span class="hljs-keyword">var</span> hash <span class="hljs-number">[32</span>]<span class="hljs-typename">byte</span>
    nonce :=<span class="hljs-number"> 0</span>
    fmt.Printf(<span class="hljs-string">"Mining a new block"</span>)
    <span class="hljs-keyword">for</span> nonce &lt; maxNonce {
        data := pow.prepareData(nonce)
        hash = sha256.Sum256(data)
        fmt.Printf(<span class="hljs-string">"\r%x"</span>, hash)
        hashInt.SetBytes(hash[:])
        <span class="hljs-keyword">if</span> hashInt.Cmp(pow.target) ==<span class="hljs-number"> -1</span> {
            <span class="hljs-keyword">break</span>
        } <span class="hljs-keyword">else</span> {
            nonce++
        }
    }
    fmt.Print(<span class="hljs-string">"\n\n"</span>)

    <span class="hljs-keyword">return</span> nonce, hash[:]
}
<span class="hljs-keyword">func</span> (pow *ProofOfWork) prepareData(nonce <span class="hljs-typename">int</span>) []<span class="hljs-typename">byte</span> {
    data := bytes.Join(
        [][]<span class="hljs-typename">byte</span>{
            pow.block.PrevBlockHash,
            pow.block.HashTransactions(),
            IntToHex(pow.block.Timestamp),
            IntToHex(<span class="hljs-typename">int64</span>(targetBits)),
            IntToHex(<span class="hljs-typename">int64</span>(nonce)),
        },
        []<span class="hljs-typename">byte</span>{},
    )

    <span class="hljs-keyword">return</span> data
}
<span class="hljs-keyword">func</span> (u UTXOSet) Update(block *Block) {
    db := u.Blockchain.db
    err := db.Update(<span class="hljs-keyword">func</span>(tx *bolt.Tx) error {
        b := tx.Bucket([]<span class="hljs-typename">byte</span>(utxoBucket))
        <span class="hljs-keyword">for</span> _, tx := <span class="hljs-keyword">range</span> block.Transactions {
            <span class="hljs-keyword">if</span> tx.IsCoinbase() == <span class="hljs-constant">false</span> {
                <span class="hljs-keyword">for</span> _, vin := <span class="hljs-keyword">range</span> tx.Vin {
                    updatedOuts := TXOutputs{}
                    outsBytes := b.Get(vin.Txid)
                    outs := DeserializeOutputs(outsBytes)

                    <span class="hljs-keyword">for</span> outIdx, out := <span class="hljs-keyword">range</span> outs.Outputs {
                        <span class="hljs-keyword">if</span> outIdx != vin.Vout {
                            updatedOuts.Outputs = <span class="hljs-built_in">append</span>(updatedOuts.Outputs, out)
                        }
                    }

                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(updatedOuts.Outputs) ==<span class="hljs-number"> 0</span> {
                        err := b.Delete(vin.Txid)
                        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
                            log.Panic(err)
                        }
                    } <span class="hljs-keyword">else</span> {
                        err := b.Put(vin.Txid, updatedOuts.Serialize())
                        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
                            log.Panic(err)
                        }
                    }

                }
            }
            newOutputs := TXOutputs{}
            <span class="hljs-keyword">for</span> _, out := <span class="hljs-keyword">range</span> tx.Vout {
                newOutputs.Outputs = <span class="hljs-built_in">append</span>(newOutputs.Outputs, out)
            }
            err := b.Put(tx.ID, newOutputs.Serialize())
            <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
                log.Panic(err)
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
    })
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Panic(err)
    }
}
</code></pre> 
  <h1 id="参考">参考</h1> 
  <p><a href="https://jeiwan.cc/" rel="nofollow">https://jeiwan.cc/</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37719047/article/details/81950648,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/m0_37719047/article/details/81950648,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
