<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>第十七篇 墨客区块链(MOAC BlockChain) JSON RPC API的使用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="第十七篇 墨客区块链(MOAC BlockChain) JSON RPC API的使用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/82107371 JSON 指的是 JavaScript 对象表示法（JavaScript&nbsp;Object&nbsp;Notation），是轻量级的文本数据交换格式。 JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON RPC就是基于JSON数据格式的RPC协议。墨客区块链在开放&nbsp;Chain3 JavaScript API&nbsp;的基础上，也开放了 JSON RPC API ，以适应用户不同编程语言的开发环境。 &nbsp; 1.环境安装 本文平台：MOAC Nuwa v1.0.2； 操作系统：64位 Windows 10 中文版； 开发环境：node.js v8.11.1&nbsp; +&nbsp; npm v5.6.0； 本文代码需要引入node.js的模块“request”，在项目目录安装该模块： d:\myProject&gt;npm install request &nbsp; 2.启动节点 以HTTP JSON-RPC方式启动节点： D:\nuwa1.0.2.win&gt;moac --rpc 启动节点时修改默认端口（8545）和地址（localhost）: D:\nuwa1.0.2.win&gt;moac --rpc --rpcaddr &lt;ip&gt; --rpcport &lt;portnumber&gt; 如果浏览器访问RPC，启动节点需要定义CORS域（“browser地址”）: D:\nuwa1.0.2.win&gt;moac --rpc --rpccorsdomain &quot;http://localhost:3000&quot; &nbsp; 3.无参数接口实例（chain3_clientVersion） Parameters none Return 返回客户端节点版本； Example：保存文件getClientVersion.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;chain3_clientVersion&quot;,&quot;params&quot;:[],&quot;id&quot;:101}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node getClientVersion.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 101, result: &#39;Moac/v1.0.2-stable-632a21f0/windows-amd64/go1.9.5&#39; } &nbsp; 4.带参数接口实例（mc_sendTransaction） Parameters Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 Return 返回交易的hash值； Example：保存文件sendTransaction.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //moac转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x9184e72a&quot;, // 2441406250 &quot;data&quot;: &quot;0x&quot;, }; var requestData2 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData2); //token转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; //没有0x var contractAddr = &quot;0xa2580d58a58998ca06e6f5b2a96aXXXXXXXXXXXX&quot;; var valueString = &quot;000000000000000000000000000000000000000000000000000000003b9aca00&quot;; //发送token数量1000000000，含8位Decimals var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400, &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x0&quot;, &quot;data&quot;: &quot;0xa9059cbb000000000000000000000000&quot; + toAddr + valueString, }; var requestData3 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData3); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 该步骤需要消耗gas费，因此运行以上代码需要解锁发送账号，在moac节点使用命令： &gt;personal.unlockAccount(mc.accounts[0], &lt;passwd&gt;, 300) node sendTransaction.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x015dc3d64e6f0d218ded0309563e6f2fb2126fa4f6f1XXXXXXXXXXXXXXXXXXXX&#39; } &nbsp; 5.非交易调用接口实例（mc_call） Parameters 1.Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 2.quantity | tag：integer，区块号；或者string，“latest”，“earliest” or &quot;pending&quot;。 Return 返回合约执行的结果； Example：保存文件mcCall.js。 var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //token查询 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var contractAddr = &quot;0xc89d49950bcf72d58cc203538e4eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;data&quot;: &quot;0x8462151c000000000000000000000000&quot; + toAddr, // 根据合约函数确定数据格式和数据值 }; var requestData5 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_call&quot;,&quot;params&quot;:[dict,&quot;latest&quot;],&quot;id&quot;:99}; httprequest(url,requestData5); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 对合约的查询无需消耗gas费，node mcCall.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000&#39; } &nbsp; 6.签名交易调用接口实例（mc_sendRawTransaction） Parameters Data：交易用私钥签名后的数据； Return Data：32字节。成功，则返回交易hash；无效，返回zero hash； Example：保存文件sendRawTransaction.js。 var request = require(&#39;request&#39;); var secp256k1 = require(&#39;secp256k1&#39;); var Hash = require(&quot;eth-lib/lib/hash&quot;); var RLP = require(&quot;eth-lib/lib/rlp&quot;); var Nat = require(&quot;eth-lib/lib/nat&quot;); var Bytes = require(&quot;eth-lib/lib/bytes&quot;); var Buffer = require(&#39;safe-buffer&#39;).Buffer; var url = &quot;http://127.0.0.1:8545&quot;; // 私钥签名交易 var privateKey = &quot;9a863cb325ba30b5f41bd285e80c14c2d96f86b21e90XXXXXXXXXXXXXXXXXXXX&quot;; var toAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var tx = { &quot;nonce&quot;: &quot;0x2e8&quot;, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x29e8d60800&quot;,// 180000000000 &quot;data&quot;: &quot;0x&quot;, &quot;chainId&quot;: &quot;0x63&quot;, // mianNet:99 &quot;shardingFlag&quot;: &quot;0x0&quot;, &quot;systemContract&quot;: &quot;0x0&quot;, &quot;via&quot;: &quot;0x&quot;, }; // start, 代码来自 chain3\lib\utils\account.js // To fix an error of 2 leading 0s var trimLeadingZero = function (hex) { while (hex &amp;&amp; hex.startsWith(&#39;0x00&#39;)) { hex = &#39;0x&#39; + hex.slice(4); } return hex; }; var makeEven = function (hex) { if(hex.length % 2 === 1) { hex = hex.replace(&#39;0x&#39;, &#39;0x0&#39;); } return hex; }; function isHexString(value, length) { if (typeof value !== &#39;string&#39; || !value.match(/^0x[0-9A-Fa-f]*$/)) { return false; } if (length &amp;&amp; value.length !== 2 + 2 * length) { return false; } return true; } function isHexPrefixed (str) { return str.slice(0, 2) === &#39;0x&#39;; } // Removes 0x from a given String function stripHexPrefix (str) { if (typeof str !== &#39;string&#39;) { return str; } return isHexPrefixed(str) ? str.slice(2) : str; } function toBuffer (v) { if (!Buffer.isBuffer(v)) { if (Array.isArray(v)) { v = Buffer.from(v) } else if (typeof v === &#39;string&#39;) { if (isHexString(v)) { v = Buffer.from(padToEven(stripHexPrefix(v)), &#39;hex&#39;) } else { v = Buffer.from(v) } } else if (typeof v === &#39;number&#39;) { v = intToBuffer(v) } else if (v === null || v === undefined) { v = Buffer.allocUnsafe(0) } else if (v.toArray) { // converts a BN to a Buffer v = Buffer.from(v.toArray()) } else { throw new Error(&#39;invalid type&#39;) } } return v } function bufferToHex (buf) { buf = toBuffer(buf) return &#39;0x&#39; + buf.toString(&#39;hex&#39;) } function intToHex (i) { var hex = i.toString(16) if (hex.length % 2) { hex = &#39;0&#39; + hex } return hex } function intToBuffer (i) { var hex = intToHex(i) return new Buffer(hex, &#39;hex&#39;) } function ecsign (msgHash, privateKeyStr) { //Convert the input string to Buffer if (typeof msgHash === &#39;string&#39;) { if (isHexString(msgHash)) { msgHash = Buffer.from(makeEven(stripHexPrefix(msgHash)), &#39;hex&#39;) } } var privateKey = new Buffer(privateKeyStr, &#39;hex&#39;); var sig = secp256k1.sign(msgHash, privateKey) var ret = {} ret.r = sig.signature.slice(0, 32) ret.s = sig.signature.slice(32, 64) ret.v = sig.recovery + 27 return ret } var signTransaction = function (tx, privateKey) { //Check the input fiels of the tx if (tx.chainId &lt; 1) { return new Error(&#39;&quot;Chain ID&quot; is invalid&#39;); } if (!tx.gas &amp;&amp; !tx.gasLimit) { return new Error(&#39;&quot;gas&quot; is missing&#39;); } if (tx.nonce &lt; 0 || tx.gasLimit &lt; 0 || tx.gasPrice &lt; 0 || tx.chainId &lt; 0) { return new Error(&#39;Gas, gasPrice, nonce or chainId is lower than 0&#39;); } //Sharding Flag only accept the //If input has not sharding flag, set it to 0 as global TX. if (tx.shardingFlag == undefined){ // console.log(&quot;Set default sharding to 0&quot;); tx.shardingFlag = 0; } try { //Make sure all the number fields are in HEX format var transaction = tx; transaction.nonce = tx.nonce; transaction.to = tx.to || &#39;0x&#39;;//Can be zero, for contract creation transaction.gasLimit = tx.gas; transaction.gasPrice = tx.gasPrice; transaction.data = tx.data || &#39;0x&#39;;//can be zero for general TXs transaction.value = tx.value || &#39;0x&#39;;//can be zero for contract call transaction.chainId = tx.chainId; transaction.shardingFlag = tx.shardingFlag; transaction.systemContract = &#39;0x0&#39;;//System contract flag, always = 0 transaction.via = tx.via || &#39;0x&#39;; //Sharding subchain address var rlpEncoded = RLP.encode([ Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.systemContract), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gasLimit), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.shardingFlag), transaction.via.toLowerCase(), Bytes.fromNat(transaction.chainId), &quot;0x&quot;, &quot;0x&quot;]); var hash = Hash.keccak256(rlpEncoded); // for MOAC, keep 9 fields instead of 6 var vPos = 9; //Sign the hash with the private key to produce the //V, R, S var newsign = ecsign(hash, stripHexPrefix(privateKey)); var rawTx = RLP.decode(rlpEncoded).slice(0,vPos+3); //Replace the V field with chainID info var newV = newsign.v + 8 + transaction.chainId *2; // Add trimLeadingZero to avoid &#39;0x00&#39; after makeEven // dont allow uneven r,s,v values rawTx[vPos] = trimLeadingZero(makeEven(bufferToHex(newV))); rawTx[vPos+1] = trimLeadingZero(makeEven(bufferToHex(newsign.r))); rawTx[vPos+2] = trimLeadingZero(makeEven(bufferToHex(newsign.s))); var rawTransaction = RLP.encode(rawTx); } catch(e) { return e; } return rawTransaction; }; // end, 代码来自 chain3\lib\utils\account.js var signTx = signTransaction(tx, privateKey) console.log(&quot;signTx:\n&quot; , signTx); var requestData6 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendRawTransaction&quot;,&quot;params&quot;:[signTx],&quot;id&quot;:99}; httprequest(url,requestData6); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node sendRawTransaction.js，返回结果： signTx:0xf86f8202ec808504a817c8008276c094745c57ca5318093115d61bbca3687ca02c2984278529e8d6080080808081eaa0df6856287f3b4ab31c4cc050a7c43b2e1b4d06e2a62ba974f2fe79fc90d023a7a04f68ddd218c2a584ab74568824f98534c7b7b30a9af5b18fb8df37c1e6b76d64 { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x4ef6096614f7c018a2681138443e528c462c0d889f7cd1f2d61db6861b135f5b&#39; } 代码中需要手动设置nonce。 如果nonce设置太高，会正常返回hash，但是交易一直会在pending状态； 如果nonce设置太低，会报错： { jsonrpc: &#39;2.0&#39;, id: 99, error: { code: -32000, message: &#39;nonce too low&#39; } } 备注：1.本例中使用私钥（privateKey）对交易（tx）进行签名，签名后的数据作为参数传进JSON RPC 接口； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.本例中签名的实现方法signTransaction，源码参考：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;https://github.com/MOACChain/chain3/blob/master/lib/utils/account.js； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.本例中的交易（tx）使用墨客主网格式（chainId=99；shardingFlag=0；systemContract=0；via=&quot;&quot;）。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/82107371 JSON 指的是 JavaScript 对象表示法（JavaScript&nbsp;Object&nbsp;Notation），是轻量级的文本数据交换格式。 JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON RPC就是基于JSON数据格式的RPC协议。墨客区块链在开放&nbsp;Chain3 JavaScript API&nbsp;的基础上，也开放了 JSON RPC API ，以适应用户不同编程语言的开发环境。 &nbsp; 1.环境安装 本文平台：MOAC Nuwa v1.0.2； 操作系统：64位 Windows 10 中文版； 开发环境：node.js v8.11.1&nbsp; +&nbsp; npm v5.6.0； 本文代码需要引入node.js的模块“request”，在项目目录安装该模块： d:\myProject&gt;npm install request &nbsp; 2.启动节点 以HTTP JSON-RPC方式启动节点： D:\nuwa1.0.2.win&gt;moac --rpc 启动节点时修改默认端口（8545）和地址（localhost）: D:\nuwa1.0.2.win&gt;moac --rpc --rpcaddr &lt;ip&gt; --rpcport &lt;portnumber&gt; 如果浏览器访问RPC，启动节点需要定义CORS域（“browser地址”）: D:\nuwa1.0.2.win&gt;moac --rpc --rpccorsdomain &quot;http://localhost:3000&quot; &nbsp; 3.无参数接口实例（chain3_clientVersion） Parameters none Return 返回客户端节点版本； Example：保存文件getClientVersion.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;chain3_clientVersion&quot;,&quot;params&quot;:[],&quot;id&quot;:101}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node getClientVersion.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 101, result: &#39;Moac/v1.0.2-stable-632a21f0/windows-amd64/go1.9.5&#39; } &nbsp; 4.带参数接口实例（mc_sendTransaction） Parameters Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 Return 返回交易的hash值； Example：保存文件sendTransaction.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //moac转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x9184e72a&quot;, // 2441406250 &quot;data&quot;: &quot;0x&quot;, }; var requestData2 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData2); //token转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; //没有0x var contractAddr = &quot;0xa2580d58a58998ca06e6f5b2a96aXXXXXXXXXXXX&quot;; var valueString = &quot;000000000000000000000000000000000000000000000000000000003b9aca00&quot;; //发送token数量1000000000，含8位Decimals var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400, &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x0&quot;, &quot;data&quot;: &quot;0xa9059cbb000000000000000000000000&quot; + toAddr + valueString, }; var requestData3 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData3); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 该步骤需要消耗gas费，因此运行以上代码需要解锁发送账号，在moac节点使用命令： &gt;personal.unlockAccount(mc.accounts[0], &lt;passwd&gt;, 300) node sendTransaction.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x015dc3d64e6f0d218ded0309563e6f2fb2126fa4f6f1XXXXXXXXXXXXXXXXXXXX&#39; } &nbsp; 5.非交易调用接口实例（mc_call） Parameters 1.Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 2.quantity | tag：integer，区块号；或者string，“latest”，“earliest” or &quot;pending&quot;。 Return 返回合约执行的结果； Example：保存文件mcCall.js。 var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //token查询 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var contractAddr = &quot;0xc89d49950bcf72d58cc203538e4eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;data&quot;: &quot;0x8462151c000000000000000000000000&quot; + toAddr, // 根据合约函数确定数据格式和数据值 }; var requestData5 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_call&quot;,&quot;params&quot;:[dict,&quot;latest&quot;],&quot;id&quot;:99}; httprequest(url,requestData5); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 对合约的查询无需消耗gas费，node mcCall.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000&#39; } &nbsp; 6.签名交易调用接口实例（mc_sendRawTransaction） Parameters Data：交易用私钥签名后的数据； Return Data：32字节。成功，则返回交易hash；无效，返回zero hash； Example：保存文件sendRawTransaction.js。 var request = require(&#39;request&#39;); var secp256k1 = require(&#39;secp256k1&#39;); var Hash = require(&quot;eth-lib/lib/hash&quot;); var RLP = require(&quot;eth-lib/lib/rlp&quot;); var Nat = require(&quot;eth-lib/lib/nat&quot;); var Bytes = require(&quot;eth-lib/lib/bytes&quot;); var Buffer = require(&#39;safe-buffer&#39;).Buffer; var url = &quot;http://127.0.0.1:8545&quot;; // 私钥签名交易 var privateKey = &quot;9a863cb325ba30b5f41bd285e80c14c2d96f86b21e90XXXXXXXXXXXXXXXXXXXX&quot;; var toAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var tx = { &quot;nonce&quot;: &quot;0x2e8&quot;, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x29e8d60800&quot;,// 180000000000 &quot;data&quot;: &quot;0x&quot;, &quot;chainId&quot;: &quot;0x63&quot;, // mianNet:99 &quot;shardingFlag&quot;: &quot;0x0&quot;, &quot;systemContract&quot;: &quot;0x0&quot;, &quot;via&quot;: &quot;0x&quot;, }; // start, 代码来自 chain3\lib\utils\account.js // To fix an error of 2 leading 0s var trimLeadingZero = function (hex) { while (hex &amp;&amp; hex.startsWith(&#39;0x00&#39;)) { hex = &#39;0x&#39; + hex.slice(4); } return hex; }; var makeEven = function (hex) { if(hex.length % 2 === 1) { hex = hex.replace(&#39;0x&#39;, &#39;0x0&#39;); } return hex; }; function isHexString(value, length) { if (typeof value !== &#39;string&#39; || !value.match(/^0x[0-9A-Fa-f]*$/)) { return false; } if (length &amp;&amp; value.length !== 2 + 2 * length) { return false; } return true; } function isHexPrefixed (str) { return str.slice(0, 2) === &#39;0x&#39;; } // Removes 0x from a given String function stripHexPrefix (str) { if (typeof str !== &#39;string&#39;) { return str; } return isHexPrefixed(str) ? str.slice(2) : str; } function toBuffer (v) { if (!Buffer.isBuffer(v)) { if (Array.isArray(v)) { v = Buffer.from(v) } else if (typeof v === &#39;string&#39;) { if (isHexString(v)) { v = Buffer.from(padToEven(stripHexPrefix(v)), &#39;hex&#39;) } else { v = Buffer.from(v) } } else if (typeof v === &#39;number&#39;) { v = intToBuffer(v) } else if (v === null || v === undefined) { v = Buffer.allocUnsafe(0) } else if (v.toArray) { // converts a BN to a Buffer v = Buffer.from(v.toArray()) } else { throw new Error(&#39;invalid type&#39;) } } return v } function bufferToHex (buf) { buf = toBuffer(buf) return &#39;0x&#39; + buf.toString(&#39;hex&#39;) } function intToHex (i) { var hex = i.toString(16) if (hex.length % 2) { hex = &#39;0&#39; + hex } return hex } function intToBuffer (i) { var hex = intToHex(i) return new Buffer(hex, &#39;hex&#39;) } function ecsign (msgHash, privateKeyStr) { //Convert the input string to Buffer if (typeof msgHash === &#39;string&#39;) { if (isHexString(msgHash)) { msgHash = Buffer.from(makeEven(stripHexPrefix(msgHash)), &#39;hex&#39;) } } var privateKey = new Buffer(privateKeyStr, &#39;hex&#39;); var sig = secp256k1.sign(msgHash, privateKey) var ret = {} ret.r = sig.signature.slice(0, 32) ret.s = sig.signature.slice(32, 64) ret.v = sig.recovery + 27 return ret } var signTransaction = function (tx, privateKey) { //Check the input fiels of the tx if (tx.chainId &lt; 1) { return new Error(&#39;&quot;Chain ID&quot; is invalid&#39;); } if (!tx.gas &amp;&amp; !tx.gasLimit) { return new Error(&#39;&quot;gas&quot; is missing&#39;); } if (tx.nonce &lt; 0 || tx.gasLimit &lt; 0 || tx.gasPrice &lt; 0 || tx.chainId &lt; 0) { return new Error(&#39;Gas, gasPrice, nonce or chainId is lower than 0&#39;); } //Sharding Flag only accept the //If input has not sharding flag, set it to 0 as global TX. if (tx.shardingFlag == undefined){ // console.log(&quot;Set default sharding to 0&quot;); tx.shardingFlag = 0; } try { //Make sure all the number fields are in HEX format var transaction = tx; transaction.nonce = tx.nonce; transaction.to = tx.to || &#39;0x&#39;;//Can be zero, for contract creation transaction.gasLimit = tx.gas; transaction.gasPrice = tx.gasPrice; transaction.data = tx.data || &#39;0x&#39;;//can be zero for general TXs transaction.value = tx.value || &#39;0x&#39;;//can be zero for contract call transaction.chainId = tx.chainId; transaction.shardingFlag = tx.shardingFlag; transaction.systemContract = &#39;0x0&#39;;//System contract flag, always = 0 transaction.via = tx.via || &#39;0x&#39;; //Sharding subchain address var rlpEncoded = RLP.encode([ Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.systemContract), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gasLimit), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.shardingFlag), transaction.via.toLowerCase(), Bytes.fromNat(transaction.chainId), &quot;0x&quot;, &quot;0x&quot;]); var hash = Hash.keccak256(rlpEncoded); // for MOAC, keep 9 fields instead of 6 var vPos = 9; //Sign the hash with the private key to produce the //V, R, S var newsign = ecsign(hash, stripHexPrefix(privateKey)); var rawTx = RLP.decode(rlpEncoded).slice(0,vPos+3); //Replace the V field with chainID info var newV = newsign.v + 8 + transaction.chainId *2; // Add trimLeadingZero to avoid &#39;0x00&#39; after makeEven // dont allow uneven r,s,v values rawTx[vPos] = trimLeadingZero(makeEven(bufferToHex(newV))); rawTx[vPos+1] = trimLeadingZero(makeEven(bufferToHex(newsign.r))); rawTx[vPos+2] = trimLeadingZero(makeEven(bufferToHex(newsign.s))); var rawTransaction = RLP.encode(rawTx); } catch(e) { return e; } return rawTransaction; }; // end, 代码来自 chain3\lib\utils\account.js var signTx = signTransaction(tx, privateKey) console.log(&quot;signTx:\n&quot; , signTx); var requestData6 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendRawTransaction&quot;,&quot;params&quot;:[signTx],&quot;id&quot;:99}; httprequest(url,requestData6); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node sendRawTransaction.js，返回结果： signTx:0xf86f8202ec808504a817c8008276c094745c57ca5318093115d61bbca3687ca02c2984278529e8d6080080808081eaa0df6856287f3b4ab31c4cc050a7c43b2e1b4d06e2a62ba974f2fe79fc90d023a7a04f68ddd218c2a584ab74568824f98534c7b7b30a9af5b18fb8df37c1e6b76d64 { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x4ef6096614f7c018a2681138443e528c462c0d889f7cd1f2d61db6861b135f5b&#39; } 代码中需要手动设置nonce。 如果nonce设置太高，会正常返回hash，但是交易一直会在pending状态； 如果nonce设置太低，会报错： { jsonrpc: &#39;2.0&#39;, id: 99, error: { code: -32000, message: &#39;nonce too low&#39; } } 备注：1.本例中使用私钥（privateKey）对交易（tx）进行签名，签名后的数据作为参数传进JSON RPC 接口； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.本例中签名的实现方法signTransaction，源码参考：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;https://github.com/MOACChain/chain3/blob/master/lib/utils/account.js； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.本例中的交易（tx）使用墨客主网格式（chainId=99；shardingFlag=0；systemContract=0；via=&quot;&quot;）。 阅读更多 登录后自动展开" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/82107371 JSON 指的是 JavaScript 对象表示法（JavaScript&nbsp;Object&nbsp;Notation），是轻量级的文本数据交换格式。 JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON RPC就是基于JSON数据格式的RPC协议。墨客区块链在开放&nbsp;Chain3 JavaScript API&nbsp;的基础上，也开放了 JSON RPC API ，以适应用户不同编程语言的开发环境。 &nbsp; 1.环境安装 本文平台：MOAC Nuwa v1.0.2； 操作系统：64位 Windows 10 中文版； 开发环境：node.js v8.11.1&nbsp; +&nbsp; npm v5.6.0； 本文代码需要引入node.js的模块“request”，在项目目录安装该模块： d:\\myProject&gt;npm install request &nbsp; 2.启动节点 以HTTP JSON-RPC方式启动节点： D:\\nuwa1.0.2.win&gt;moac --rpc 启动节点时修改默认端口（8545）和地址（localhost）: D:\\nuwa1.0.2.win&gt;moac --rpc --rpcaddr &lt;ip&gt; --rpcport &lt;portnumber&gt; 如果浏览器访问RPC，启动节点需要定义CORS域（“browser地址”）: D:\\nuwa1.0.2.win&gt;moac --rpc --rpccorsdomain &quot;http://localhost:3000&quot; &nbsp; 3.无参数接口实例（chain3_clientVersion） Parameters none Return 返回客户端节点版本； Example：保存文件getClientVersion.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;chain3_clientVersion&quot;,&quot;params&quot;:[],&quot;id&quot;:101}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node getClientVersion.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 101, result: &#39;Moac/v1.0.2-stable-632a21f0/windows-amd64/go1.9.5&#39; } &nbsp; 4.带参数接口实例（mc_sendTransaction） Parameters Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 Return 返回交易的hash值； Example：保存文件sendTransaction.js var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //moac转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x9184e72a&quot;, // 2441406250 &quot;data&quot;: &quot;0x&quot;, }; var requestData2 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData2); //token转账 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX&quot;; //没有0x var contractAddr = &quot;0xa2580d58a58998ca06e6f5b2a96aXXXXXXXXXXXX&quot;; var valueString = &quot;000000000000000000000000000000000000000000000000000000003b9aca00&quot;; //发送token数量1000000000，含8位Decimals var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400, &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x0&quot;, &quot;data&quot;: &quot;0xa9059cbb000000000000000000000000&quot; + toAddr + valueString, }; var requestData3 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendTransaction&quot;,&quot;params&quot;:[dict],&quot;id&quot;:99}; httprequest(url,requestData3); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 该步骤需要消耗gas费，因此运行以上代码需要解锁发送账号，在moac节点使用命令： &gt;personal.unlockAccount(mc.accounts[0], &lt;passwd&gt;, 300) node sendTransaction.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x015dc3d64e6f0d218ded0309563e6f2fb2126fa4f6f1XXXXXXXXXXXXXXXXXXXX&#39; } &nbsp; 5.非交易调用接口实例（mc_call） Parameters 1.Object：交易对象 from：20字节，交易发送账号地址； to：20字节，交易目的账号地址； gas：integer，交易执行需要提供的gas费数量，没有用完的将返还； gasPrice：integer，交易执行时，每一个支付的gas的价格； value：integer，交易的moac数量； data：附加数据； nounce：integer，发送账号的交易序号。 2.quantity | tag：integer，区块号；或者string，“latest”，“earliest” or &quot;pending&quot;。 Return 返回合约执行的结果； Example：保存文件mcCall.js。 var request = require(&#39;request&#39;); var url = &quot;http://127.0.0.1:8545&quot;; //token查询 var fromAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var toAddr = &quot;745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var contractAddr = &quot;0xc89d49950bcf72d58cc203538e4eXXXXXXXXXXXX&quot;; var dict = { &quot;from&quot;: fromAddr, &quot;to&quot;: contractAddr, &quot;data&quot;: &quot;0x8462151c000000000000000000000000&quot; + toAddr, // 根据合约函数确定数据格式和数据值 }; var requestData5 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_call&quot;,&quot;params&quot;:[dict,&quot;latest&quot;],&quot;id&quot;:99}; httprequest(url,requestData5); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 对合约的查询无需消耗gas费，node mcCall.js，返回结果： { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000&#39; } &nbsp; 6.签名交易调用接口实例（mc_sendRawTransaction） Parameters Data：交易用私钥签名后的数据； Return Data：32字节。成功，则返回交易hash；无效，返回zero hash； Example：保存文件sendRawTransaction.js。 var request = require(&#39;request&#39;); var secp256k1 = require(&#39;secp256k1&#39;); var Hash = require(&quot;eth-lib/lib/hash&quot;); var RLP = require(&quot;eth-lib/lib/rlp&quot;); var Nat = require(&quot;eth-lib/lib/nat&quot;); var Bytes = require(&quot;eth-lib/lib/bytes&quot;); var Buffer = require(&#39;safe-buffer&#39;).Buffer; var url = &quot;http://127.0.0.1:8545&quot;; // 私钥签名交易 var privateKey = &quot;9a863cb325ba30b5f41bd285e80c14c2d96f86b21e90XXXXXXXXXXXXXXXXXXXX&quot;; var toAddr = &quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;; var tx = { &quot;nonce&quot;: &quot;0x2e8&quot;, &quot;to&quot;: toAddr, &quot;gas&quot;: &quot;0x76c0&quot;, // 30400 &quot;gasPrice&quot;: &quot;0x4a817c800&quot;, // 20000000000 &quot;value&quot;: &quot;0x29e8d60800&quot;,// 180000000000 &quot;data&quot;: &quot;0x&quot;, &quot;chainId&quot;: &quot;0x63&quot;, // mianNet:99 &quot;shardingFlag&quot;: &quot;0x0&quot;, &quot;systemContract&quot;: &quot;0x0&quot;, &quot;via&quot;: &quot;0x&quot;, }; // start, 代码来自 chain3\\lib\\utils\\account.js // To fix an error of 2 leading 0s var trimLeadingZero = function (hex) { while (hex &amp;&amp; hex.startsWith(&#39;0x00&#39;)) { hex = &#39;0x&#39; + hex.slice(4); } return hex; }; var makeEven = function (hex) { if(hex.length % 2 === 1) { hex = hex.replace(&#39;0x&#39;, &#39;0x0&#39;); } return hex; }; function isHexString(value, length) { if (typeof value !== &#39;string&#39; || !value.match(/^0x[0-9A-Fa-f]*$/)) { return false; } if (length &amp;&amp; value.length !== 2 + 2 * length) { return false; } return true; } function isHexPrefixed (str) { return str.slice(0, 2) === &#39;0x&#39;; } // Removes 0x from a given String function stripHexPrefix (str) { if (typeof str !== &#39;string&#39;) { return str; } return isHexPrefixed(str) ? str.slice(2) : str; } function toBuffer (v) { if (!Buffer.isBuffer(v)) { if (Array.isArray(v)) { v = Buffer.from(v) } else if (typeof v === &#39;string&#39;) { if (isHexString(v)) { v = Buffer.from(padToEven(stripHexPrefix(v)), &#39;hex&#39;) } else { v = Buffer.from(v) } } else if (typeof v === &#39;number&#39;) { v = intToBuffer(v) } else if (v === null || v === undefined) { v = Buffer.allocUnsafe(0) } else if (v.toArray) { // converts a BN to a Buffer v = Buffer.from(v.toArray()) } else { throw new Error(&#39;invalid type&#39;) } } return v } function bufferToHex (buf) { buf = toBuffer(buf) return &#39;0x&#39; + buf.toString(&#39;hex&#39;) } function intToHex (i) { var hex = i.toString(16) if (hex.length % 2) { hex = &#39;0&#39; + hex } return hex } function intToBuffer (i) { var hex = intToHex(i) return new Buffer(hex, &#39;hex&#39;) } function ecsign (msgHash, privateKeyStr) { //Convert the input string to Buffer if (typeof msgHash === &#39;string&#39;) { if (isHexString(msgHash)) { msgHash = Buffer.from(makeEven(stripHexPrefix(msgHash)), &#39;hex&#39;) } } var privateKey = new Buffer(privateKeyStr, &#39;hex&#39;); var sig = secp256k1.sign(msgHash, privateKey) var ret = {} ret.r = sig.signature.slice(0, 32) ret.s = sig.signature.slice(32, 64) ret.v = sig.recovery + 27 return ret } var signTransaction = function (tx, privateKey) { //Check the input fiels of the tx if (tx.chainId &lt; 1) { return new Error(&#39;&quot;Chain ID&quot; is invalid&#39;); } if (!tx.gas &amp;&amp; !tx.gasLimit) { return new Error(&#39;&quot;gas&quot; is missing&#39;); } if (tx.nonce &lt; 0 || tx.gasLimit &lt; 0 || tx.gasPrice &lt; 0 || tx.chainId &lt; 0) { return new Error(&#39;Gas, gasPrice, nonce or chainId is lower than 0&#39;); } //Sharding Flag only accept the //If input has not sharding flag, set it to 0 as global TX. if (tx.shardingFlag == undefined){ // console.log(&quot;Set default sharding to 0&quot;); tx.shardingFlag = 0; } try { //Make sure all the number fields are in HEX format var transaction = tx; transaction.nonce = tx.nonce; transaction.to = tx.to || &#39;0x&#39;;//Can be zero, for contract creation transaction.gasLimit = tx.gas; transaction.gasPrice = tx.gasPrice; transaction.data = tx.data || &#39;0x&#39;;//can be zero for general TXs transaction.value = tx.value || &#39;0x&#39;;//can be zero for contract call transaction.chainId = tx.chainId; transaction.shardingFlag = tx.shardingFlag; transaction.systemContract = &#39;0x0&#39;;//System contract flag, always = 0 transaction.via = tx.via || &#39;0x&#39;; //Sharding subchain address var rlpEncoded = RLP.encode([ Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.systemContract), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gasLimit), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.shardingFlag), transaction.via.toLowerCase(), Bytes.fromNat(transaction.chainId), &quot;0x&quot;, &quot;0x&quot;]); var hash = Hash.keccak256(rlpEncoded); // for MOAC, keep 9 fields instead of 6 var vPos = 9; //Sign the hash with the private key to produce the //V, R, S var newsign = ecsign(hash, stripHexPrefix(privateKey)); var rawTx = RLP.decode(rlpEncoded).slice(0,vPos+3); //Replace the V field with chainID info var newV = newsign.v + 8 + transaction.chainId *2; // Add trimLeadingZero to avoid &#39;0x00&#39; after makeEven // dont allow uneven r,s,v values rawTx[vPos] = trimLeadingZero(makeEven(bufferToHex(newV))); rawTx[vPos+1] = trimLeadingZero(makeEven(bufferToHex(newsign.r))); rawTx[vPos+2] = trimLeadingZero(makeEven(bufferToHex(newsign.s))); var rawTransaction = RLP.encode(rawTx); } catch(e) { return e; } return rawTransaction; }; // end, 代码来自 chain3\\lib\\utils\\account.js var signTx = signTransaction(tx, privateKey) console.log(&quot;signTx:\\n&quot; , signTx); var requestData6 = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_sendRawTransaction&quot;,&quot;params&quot;:[signTx],&quot;id&quot;:99}; httprequest(url,requestData6); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; node sendRawTransaction.js，返回结果： signTx:0xf86f8202ec808504a817c8008276c094745c57ca5318093115d61bbca3687ca02c2984278529e8d6080080808081eaa0df6856287f3b4ab31c4cc050a7c43b2e1b4d06e2a62ba974f2fe79fc90d023a7a04f68ddd218c2a584ab74568824f98534c7b7b30a9af5b18fb8df37c1e6b76d64 { jsonrpc: &#39;2.0&#39;, id: 99, result: &#39;0x4ef6096614f7c018a2681138443e528c462c0d889f7cd1f2d61db6861b135f5b&#39; } 代码中需要手动设置nonce。 如果nonce设置太高，会正常返回hash，但是交易一直会在pending状态； 如果nonce设置太低，会报错： { jsonrpc: &#39;2.0&#39;, id: 99, error: { code: -32000, message: &#39;nonce too low&#39; } } 备注：1.本例中使用私钥（privateKey）对交易（tx）进行签名，签名后的数据作为参数传进JSON RPC 接口； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.本例中签名的实现方法signTransaction，源码参考：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;https://github.com/MOACChain/chain3/blob/master/lib/utils/account.js； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.本例中的交易（tx）使用墨客主网格式（chainId=99；shardingFlag=0；systemContract=0；via=&quot;&quot;）。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"/2018/08/27/d6735d4b0d7eb968c78548df46112ff5.html","headline":"第十七篇 墨客区块链(MOAC BlockChain) JSON RPC API的使用","dateModified":"2018-08-27T00:00:00+08:00","datePublished":"2018-08-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/08/27/d6735d4b0d7eb968c78548df46112ff5.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>第十七篇 墨客区块链(MOAC BlockChain) JSON RPC API的使用</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/82107371 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>JSON 指的是 JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript&nbsp;<strong>O</strong>bject&nbsp;<strong>N</strong>otation），是轻量级的文本数据交换格式。</p> 
  <p>JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然<strong><span style="color:#f33b45;">独立于语言和平台</span></strong>。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</p> 
  <p>JSON RPC就是基于JSON数据格式的RPC协议。墨客区块链在开放&nbsp;<a href="https://github.com/MOACChain/moac-core/wiki/Chain3" rel="nofollow">Chain3 JavaScript API</a>&nbsp;的基础上，也开放了 <a href="https://github.com/MOACChain/moac-core/wiki/JSON-RPC" rel="nofollow">JSON RPC API</a> ，以适应用户不同编程语言的开发环境。</p> 
  <p>&nbsp;</p> 
  <p><strong>1.环境安装</strong></p> 
  <p>本文平台：MOAC Nuwa v1.0.2；</p> 
  <p>操作系统：64位 Windows 10 中文版；</p> 
  <p>开发环境：node.js v8.11.1&nbsp; +&nbsp; npm v5.6.0；</p> 
  <p>本文代码需要引入node.js的模块“request”，在项目目录安装该模块：</p> 
  <pre class="has">
<code>d:\myProject&gt;npm install request</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>2.启动节点</strong></p> 
  <p>以HTTP JSON-RPC方式启动节点：</p> 
  <pre class="has">
<code>D:\nuwa1.0.2.win&gt;moac --rpc</code></pre> 
  <p>启动节点时修改默认端口（8545）和地址（localhost）:</p> 
  <pre class="has">
<code>D:\nuwa1.0.2.win&gt;moac --rpc --rpcaddr &lt;ip&gt; --rpcport &lt;portnumber&gt;</code></pre> 
  <p>如果浏览器访问RPC，启动节点需要定义CORS域（“browser地址”）:</p> 
  <pre class="has">
<code>D:\nuwa1.0.2.win&gt;moac --rpc --rpccorsdomain "http://localhost:3000"</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>3.无参数接口实例（chain3_clientVersion）</strong></p> 
  <p><strong>Parameters</strong></p> 
  <ul>
   <li>none</li> 
  </ul>
  <p><strong>Return</strong></p> 
  <ul>
   <li>返回客户端节点版本；</li> 
  </ul>
  <p><strong>Example</strong>：保存文件getClientVersion.js</p> 
  <pre class="has">
<code>var request = require('request');
var url = "http://127.0.0.1:8545";
var requestData = {"jsonrpc":"2.0","method":"chain3_clientVersion","params":[],"id":101};

httprequest(url,requestData);

function httprequest(url,data){
	request({
		url: url,
		method: "POST",
		json: true,
		body: data
	}, function(error, response, result) {
		if (!error &amp;&amp; response.statusCode == 200) {
			console.log(result) // 请求成功的处理逻辑
		}
	});
};</code></pre> 
  <p>node getClientVersion.js，返回结果：</p> 
  <pre class="has">
<code>{ jsonrpc: '2.0',
  id: 101,
  result: 'Moac/v1.0.2-stable-632a21f0/windows-amd64/go1.9.5' }</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>4.带参数接口实例（mc_sendTransaction）</strong></p> 
  <p><strong>Parameters</strong></p> 
  <p>Object：交易对象</p> 
  <ul>
   <li>from：20字节，交易发送账号地址；</li> 
   <li>to：20字节，交易目的账号地址；</li> 
   <li>gas：integer，交易执行需要提供的gas费数量，没有用完的将返还；</li> 
   <li>gasPrice：integer，交易执行时，每一个支付的gas的价格；</li> 
   <li>value：integer，交易的moac数量；</li> 
   <li>data：附加数据；</li> 
   <li>nounce：integer，发送账号的交易序号。</li> 
  </ul>
  <p><strong>Return</strong></p> 
  <ul>
   <li>返回交易的hash值；</li> 
  </ul>
  <p><strong>Example</strong>：保存文件sendTransaction.js</p> 
  <pre class="has">
<code>var request = require('request');
var url = "http://127.0.0.1:8545";

//moac转账
var fromAddr = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var toAddr   = "0x68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX";
var dict = {
                "from":     fromAddr,
                "to":       toAddr,
                "gas":      "0x76c0",      // 30400
                "gasPrice": "0x4a817c800", // 20000000000
                "value":    "0x9184e72a",  // 2441406250
                "data":     "0x",
            };
var requestData2 = {"jsonrpc":"2.0","method":"mc_sendTransaction","params":[dict],"id":99};
httprequest(url,requestData2);

//token转账
var fromAddr = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var toAddr   = "68986c1bcd54ae5dae69310fc64eXXXXXXXXXXXX";       //没有0x
var contractAddr = "0xa2580d58a58998ca06e6f5b2a96aXXXXXXXXXXXX";
var valueString  = "000000000000000000000000000000000000000000000000000000003b9aca00";  //发送token数量1000000000，含8位Decimals
var dict = {
                "from":     fromAddr,
                "to":       contractAddr,
                "gas":      "0x76c0",      // 30400,
                "gasPrice": "0x4a817c800", // 20000000000
                "value":    "0x0",         
                "data":     "0xa9059cbb000000000000000000000000" + toAddr + valueString,
            };
var requestData3 = {"jsonrpc":"2.0","method":"mc_sendTransaction","params":[dict],"id":99};
httprequest(url,requestData3);

function httprequest(url,data){
	request({
		url: url,
		method: "POST",
		json: true,
		body: data
	}, function(error, response, result) {
		if (!error &amp;&amp; response.statusCode == 200) {
			console.log(result) // 请求成功的处理逻辑
		}
	});
};</code></pre> 
  <p>该步骤需要消耗gas费，因此运行以上代码需要解锁发送账号，在moac节点使用命令：</p> 
  <pre class="has">
<code>&gt;personal.unlockAccount(mc.accounts[0], &lt;passwd&gt;, 300)</code></pre> 
  <p>node sendTransaction.js，返回结果：</p> 
  <pre class="has">
<code>{ jsonrpc: '2.0',
  id: 99,
  result: '0x015dc3d64e6f0d218ded0309563e6f2fb2126fa4f6f1XXXXXXXXXXXXXXXXXXXX' }</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>5.非交易调用接口实例（mc_call）</strong></p> 
  <p><strong>Parameters</strong></p> 
  <p>1.Object：交易对象</p> 
  <ul>
   <li>from：20字节，交易发送账号地址；</li> 
   <li>to：20字节，交易目的账号地址；</li> 
   <li>gas：integer，交易执行需要提供的gas费数量，没有用完的将返还；</li> 
   <li>gasPrice：integer，交易执行时，每一个支付的gas的价格；</li> 
   <li>value：integer，交易的moac数量；</li> 
   <li>data：附加数据；</li> 
   <li>nounce：integer，发送账号的交易序号。</li> 
  </ul>
  <p>2.quantity | tag：integer，区块号；或者string，“latest”，“earliest” or "pending"。</p> 
  <p><strong>Return</strong></p> 
  <ul>
   <li>返回合约执行的结果；</li> 
  </ul>
  <p><strong>Example</strong>：保存文件mcCall.js。</p> 
  <pre class="has">
<code>var request = require('request');
var url = "http://127.0.0.1:8545";

//token查询
var fromAddr = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var toAddr   =   "745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var contractAddr = "0xc89d49950bcf72d58cc203538e4eXXXXXXXXXXXX";
var dict = {
                "from":     fromAddr,
                "to":       contractAddr,
                "data":     "0x8462151c000000000000000000000000" + toAddr,  // 根据合约函数确定数据格式和数据值
            };
var requestData5 = {"jsonrpc":"2.0","method":"mc_call","params":[dict,"latest"],"id":99};

httprequest(url,requestData5);

function httprequest(url,data){
	request({
		url: url,
		method: "POST",
		json: true,
		body: data
	}, function(error, response, result) {
		if (!error &amp;&amp; response.statusCode == 200) {
			console.log(result) // 请求成功的处理逻辑
		}
	});
};</code></pre> 
  <p>对合约的查询无需消耗gas费，node mcCall.js，返回结果：</p> 
  <pre class="has">
<code>{ jsonrpc: '2.0',
  id: 99,
  result: '0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000' }</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>6.签名交易调用接口实例（mc_sendRawTransaction）</strong></p> 
  <p><strong>Parameters</strong></p> 
  <ul>
   <li>Data：交易用私钥签名后的数据；</li> 
  </ul>
  <p><strong>Return</strong></p> 
  <ul>
   <li>Data：32字节。成功，则返回交易hash；无效，返回zero hash；</li> 
  </ul>
  <p><strong>Example</strong>：保存文件sendRawTransaction.js。</p> 
  <pre class="has">
<code>var request   = require('request');
var secp256k1 = require('secp256k1');
var Hash      = require("eth-lib/lib/hash");
var RLP       = require("eth-lib/lib/rlp");
var Nat       = require("eth-lib/lib/nat");
var Bytes     = require("eth-lib/lib/bytes");
var Buffer    = require('safe-buffer').Buffer;

var url = "http://127.0.0.1:8545";

// 私钥签名交易
var privateKey = "9a863cb325ba30b5f41bd285e80c14c2d96f86b21e90XXXXXXXXXXXXXXXXXXXX";
var toAddr     = "0x745c57ca5318093115d61bbca368XXXXXXXXXXXX";
var tx = {
                "nonce":          "0x2e8",
                "to":             toAddr,
                "gas":            "0x76c0",      // 30400
                "gasPrice":       "0x4a817c800", // 20000000000
                "value":          "0x29e8d60800",// 180000000000
                "data":           "0x",
                "chainId":        "0x63",        // mianNet:99
                "shardingFlag":   "0x0",
                "systemContract": "0x0",
                "via":            "0x",
            };

			
// start, 代码来自 chain3\lib\utils\account.js	
// To fix an error of 2 leading 0s
var trimLeadingZero = function (hex) {
    while (hex &amp;&amp; hex.startsWith('0x00')) {
        hex = '0x' + hex.slice(4);
    }
    return hex;
};

var makeEven = function (hex) {
    if(hex.length % 2 === 1) {
        hex = hex.replace('0x', '0x0');
    }
    return hex;
};

function isHexString(value, length) {
    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length &amp;&amp; value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}

function isHexPrefixed (str) {
    return str.slice(0, 2) === '0x';
}

// Removes 0x from a given String
function stripHexPrefix (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}

function toBuffer (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v)
        } else if (typeof v === 'string') {
            if (isHexString(v)) {
                v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')
            } else {
                v = Buffer.from(v)
            }
        } else if (typeof v === 'number') {
            v = intToBuffer(v)
        } else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0)
        } else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray())
        } else {
            throw new Error('invalid type')
        }
    }
    return v
}

function bufferToHex (buf) {
    buf = toBuffer(buf)
    return '0x' + buf.toString('hex')
}

function intToHex (i) {
    var hex = i.toString(16)
    if (hex.length % 2) {
        hex = '0' + hex
    }
    return hex
}

function intToBuffer (i) {
    var hex = intToHex(i)
    return new Buffer(hex, 'hex')
}

function ecsign (msgHash, privateKeyStr) {
    //Convert the input string to Buffer
    if (typeof msgHash === 'string') {
        if (isHexString(msgHash)) {
            msgHash = Buffer.from(makeEven(stripHexPrefix(msgHash)), 'hex')
        } 
    }

    var privateKey = new Buffer(privateKeyStr, 'hex');
    var sig = secp256k1.sign(msgHash, privateKey)
    var ret = {}
    ret.r = sig.signature.slice(0, 32)
    ret.s = sig.signature.slice(32, 64)
    ret.v = sig.recovery + 27

    return ret
}
		
var signTransaction = function (tx, privateKey) {
    //Check the input fiels of the tx
    if (tx.chainId &lt; 1) {
        return new Error('"Chain ID" is invalid');
    }

    if (!tx.gas &amp;&amp; !tx.gasLimit) {
        return new Error('"gas" is missing');
    }

    if (tx.nonce  &lt; 0 ||
        tx.gasLimit  &lt; 0 ||
        tx.gasPrice  &lt; 0 ||
        tx.chainId  &lt; 0) {
        return new Error('Gas, gasPrice, nonce or chainId is lower than 0');
    }

    //Sharding Flag only accept the 
    //If input has not sharding flag, set it to 0 as global TX.
    if (tx.shardingFlag == undefined){
        // console.log("Set default sharding to 0");
        tx.shardingFlag = 0;
    }

    try {
        //Make sure all the number fields are in HEX format

        var transaction = tx;
        transaction.nonce = tx.nonce;
        transaction.to = tx.to || '0x';//Can be zero, for contract creation
        transaction.gasLimit = tx.gas;
        transaction.gasPrice = tx.gasPrice;
        transaction.data = tx.data || '0x';//can be zero for general TXs
        transaction.value = tx.value || '0x';//can be zero for contract call
        transaction.chainId = tx.chainId;
        transaction.shardingFlag = tx.shardingFlag;
        transaction.systemContract = '0x0';//System contract flag, always = 0
        transaction.via = tx.via || '0x'; //Sharding subchain address

        var rlpEncoded = RLP.encode([
            Bytes.fromNat(transaction.nonce),
            Bytes.fromNat(transaction.systemContract),
            Bytes.fromNat(transaction.gasPrice),
            Bytes.fromNat(transaction.gasLimit),
            transaction.to.toLowerCase(),
            Bytes.fromNat(transaction.value),
            transaction.data,
            Bytes.fromNat(transaction.shardingFlag),
            transaction.via.toLowerCase(),
            Bytes.fromNat(transaction.chainId),
            "0x",
            "0x"]);

        var hash = Hash.keccak256(rlpEncoded);

        // for MOAC, keep 9 fields instead of 6
        var vPos = 9;
        //Sign the hash with the private key to produce the
        //V, R, S
        var newsign = ecsign(hash, stripHexPrefix(privateKey));
        var rawTx = RLP.decode(rlpEncoded).slice(0,vPos+3);

        //Replace the V field with chainID info
        var newV = newsign.v + 8 + transaction.chainId *2;

        // Add trimLeadingZero to avoid '0x00' after makeEven
        // dont allow uneven r,s,v values
        rawTx[vPos] = trimLeadingZero(makeEven(bufferToHex(newV)));
        rawTx[vPos+1] = trimLeadingZero(makeEven(bufferToHex(newsign.r)));
        rawTx[vPos+2] = trimLeadingZero(makeEven(bufferToHex(newsign.s)));

        var rawTransaction = RLP.encode(rawTx);

    } catch(e) {
        return e;
    }
    return rawTransaction;
};				

// end, 代码来自 chain3\lib\utils\account.js	

var signTx = signTransaction(tx, privateKey)
console.log("signTx:\n" , signTx);			
			
var requestData6 = {"jsonrpc":"2.0","method":"mc_sendRawTransaction","params":[signTx],"id":99};

httprequest(url,requestData6);

function httprequest(url,data){
	request({
		url: url,
		method: "POST",
		json: true,
		body: data
	}, function(error, response, result) {
		if (!error &amp;&amp; response.statusCode == 200) {
			console.log(result) // 请求成功的处理逻辑
		}
	});
};</code></pre> 
  <p>node sendRawTransaction.js，返回结果：</p> 
  <pre class="has">
<code>signTx:0xf86f8202ec808504a817c8008276c094745c57ca5318093115d61bbca3687ca02c2984278529e8d6080080808081eaa0df6856287f3b4ab31c4cc050a7c43b2e1b4d06e2a62ba974f2fe79fc90d023a7a04f68ddd218c2a584ab74568824f98534c7b7b30a9af5b18fb8df37c1e6b76d64
{ jsonrpc: '2.0',
  id: 99,
  result: '0x4ef6096614f7c018a2681138443e528c462c0d889f7cd1f2d61db6861b135f5b' }</code></pre> 
  <p>代码中需要手动设置nonce。</p> 
  <p>如果nonce设置太高，会正常返回hash，但是交易一直会在pending状态；</p> 
  <p>如果nonce设置太低，会报错：</p> 
  <pre class="has">
<code>{ jsonrpc: '2.0',
  id: 99,
  error: { code: -32000, message: 'nonce too low' } }</code></pre> 
  <p><strong>备注：</strong>1.本例中使用私钥（privateKey）对交易（tx）进行签名，签名后的数据作为参数传进JSON RPC 接口；</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.本例中签名的实现方法signTransaction，源码参考：&nbsp;</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://github.com/MOACChain/chain3/blob/master/lib/utils/account.js" rel="nofollow">https://github.com/MOACChain/chain3/blob/master/lib/utils/account.js</a>；</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.本例中的交易（tx）使用墨客主网格式（chainId=99；shardingFlag=0；systemContract=0；via=""）。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/82107371,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/82107371,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/82107371,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/82107371,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
