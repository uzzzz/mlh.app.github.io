<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Money—-思维+模拟 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Money—-思维+模拟" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：原创文章如需转载请注明出处 https://blog.csdn.net/holly_Z_P_F/article/details/84670836 &nbsp; 链接：https://ac.nowcoder.com/acm/contest/295/B 题目描述 White Cloud has built n stores numbered from 1 to n. White Rabbit wants to visit these stores in the order from 1 to n. The store numbered i has a price a[i] representing that White Rabbit can spend a[i] dollars to buy a product or sell a product to get a[i] dollars when it is in the i-th store. The product is too heavy so that White Rabbit can only take one product at the same time. White Rabbit wants to know the maximum profit after visiting all stores. Also, White Rabbit wants to know the minimum number of transactions while geting the maximum profit. Notice that White Rabbit has infinite money initially. 输入描述: The first line contains an integer T(0&lt;T&lt;=5), denoting the number of test cases. In each test case, there is one integer n(0&lt;n&lt;=100000) in the first line,denoting the number of stores. For the next line, There are n integers in range [0,2147483648), denoting a[1..n]. 输出描述: For each test case, print a single line containing 2 integers, denoting the maximum profit and the minimum number of transactions. 输入 1 5 9 10 7 6 8 输出 3 4 题目大意： 有n个商店，编号从1到n。编号为 i 的商店有一个价格 a[ i ]。 小白兔想按从1到n的顺序参观这些商店。 每到一个商店，小白兔可以在这里花费a[ i ]美元购买一种产品，或者出售一种产品以获得a[i]美元。 白兔身上只能携带一种产品。 要求的是白兔参观完所有商店后的最大利润是多少。并且希望在获取最大利润的同时，交易的数量是最少的。 ps：白兔一开始有无限的钱。 解题思路： 我们的思路 就是 当我们手里没商品的时候&nbsp; 我们需要选择一个买入商品的地方 如何选呢？ 先买下第一个商品 花费记为o&nbsp; 紧接着的第二个商品 如果说价格低于o&nbsp; 那么其实我们不应该买第一个的&nbsp; 应该从第二个开始买 所以这个时候我们做更新操作&nbsp; o的值更新为第二个 以此类推 如果接下来的还比o小 我们继续更新（此操作是在纠正买东西的位置） 当我们手里有商品的时候&nbsp; 我们需要选择一个卖出商品的地方 如何选呢？ 当我们第一次遇到大于o的值的时候&nbsp; 我们就卖掉商品 那么获利就是a[ i ] - o&nbsp;&nbsp; 交易次数累加2&nbsp; 然后我们把o更新为a[ i ] 接着走如果遇到的还大于o&nbsp; 那么说明我们刚才卖的早了&nbsp; 应该在这里卖&nbsp; 所以我们将获利 再累加上a[ i ] - o 但是不改变交易次数（这个操作是在纠正卖商品的地点&nbsp;&nbsp;&nbsp; 如何控制什么时候改变交易次数呢&nbsp;&nbsp; 就是看手中有商品没&nbsp; 手中有的时候&nbsp; 卖掉时 交易次数+2&nbsp; 然后就把flag置为0 代表手中没商品&nbsp; 接下来遇到a[ i ]再比o大 就只更新o 不改变次数 ） 以上两种情况交替使用 遍历一遍就得到了最大利润 和 最小交易次数（什么叫交替使用？&nbsp; 身上没商品的时候&nbsp; 选择买商品的位置&nbsp; 选好了&nbsp; 就要选择卖商品的位置&nbsp; 卖完了 就要选择买商品的位置） &nbsp; 最后再注意一点&nbsp; 当a[ i ]==o的时候 我们不进行任何操作 跳过即可 因为不会获利（注意&nbsp; 也不要改变flag的状态） &nbsp; 代码 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;stdio.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+7; ll a[maxn]; int T,n; int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); //o代表当前手里买的商品的价格 //cnt代表交易次数 //flag为1代表当前手里买了商品 为0代表手里没商品 ll o,cnt=0,sum=0,flag=1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); if(i==1){ o=a[1];flag=1; } else{ if(a[i]&lt;o){ o=a[i];flag=1; } else if(a[i]&gt;o){ if(flag==1){ sum+=a[i]-o;o=a[i]; cnt+=2;flag=0; } else{ sum+=a[i]-o;o=a[i]; } } } } printf(&quot;%lld %lld\n&quot;,sum,cnt); } return 0; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" />
<meta property="og:description" content="版权声明：原创文章如需转载请注明出处 https://blog.csdn.net/holly_Z_P_F/article/details/84670836 &nbsp; 链接：https://ac.nowcoder.com/acm/contest/295/B 题目描述 White Cloud has built n stores numbered from 1 to n. White Rabbit wants to visit these stores in the order from 1 to n. The store numbered i has a price a[i] representing that White Rabbit can spend a[i] dollars to buy a product or sell a product to get a[i] dollars when it is in the i-th store. The product is too heavy so that White Rabbit can only take one product at the same time. White Rabbit wants to know the maximum profit after visiting all stores. Also, White Rabbit wants to know the minimum number of transactions while geting the maximum profit. Notice that White Rabbit has infinite money initially. 输入描述: The first line contains an integer T(0&lt;T&lt;=5), denoting the number of test cases. In each test case, there is one integer n(0&lt;n&lt;=100000) in the first line,denoting the number of stores. For the next line, There are n integers in range [0,2147483648), denoting a[1..n]. 输出描述: For each test case, print a single line containing 2 integers, denoting the maximum profit and the minimum number of transactions. 输入 1 5 9 10 7 6 8 输出 3 4 题目大意： 有n个商店，编号从1到n。编号为 i 的商店有一个价格 a[ i ]。 小白兔想按从1到n的顺序参观这些商店。 每到一个商店，小白兔可以在这里花费a[ i ]美元购买一种产品，或者出售一种产品以获得a[i]美元。 白兔身上只能携带一种产品。 要求的是白兔参观完所有商店后的最大利润是多少。并且希望在获取最大利润的同时，交易的数量是最少的。 ps：白兔一开始有无限的钱。 解题思路： 我们的思路 就是 当我们手里没商品的时候&nbsp; 我们需要选择一个买入商品的地方 如何选呢？ 先买下第一个商品 花费记为o&nbsp; 紧接着的第二个商品 如果说价格低于o&nbsp; 那么其实我们不应该买第一个的&nbsp; 应该从第二个开始买 所以这个时候我们做更新操作&nbsp; o的值更新为第二个 以此类推 如果接下来的还比o小 我们继续更新（此操作是在纠正买东西的位置） 当我们手里有商品的时候&nbsp; 我们需要选择一个卖出商品的地方 如何选呢？ 当我们第一次遇到大于o的值的时候&nbsp; 我们就卖掉商品 那么获利就是a[ i ] - o&nbsp;&nbsp; 交易次数累加2&nbsp; 然后我们把o更新为a[ i ] 接着走如果遇到的还大于o&nbsp; 那么说明我们刚才卖的早了&nbsp; 应该在这里卖&nbsp; 所以我们将获利 再累加上a[ i ] - o 但是不改变交易次数（这个操作是在纠正卖商品的地点&nbsp;&nbsp;&nbsp; 如何控制什么时候改变交易次数呢&nbsp;&nbsp; 就是看手中有商品没&nbsp; 手中有的时候&nbsp; 卖掉时 交易次数+2&nbsp; 然后就把flag置为0 代表手中没商品&nbsp; 接下来遇到a[ i ]再比o大 就只更新o 不改变次数 ） 以上两种情况交替使用 遍历一遍就得到了最大利润 和 最小交易次数（什么叫交替使用？&nbsp; 身上没商品的时候&nbsp; 选择买商品的位置&nbsp; 选好了&nbsp; 就要选择卖商品的位置&nbsp; 卖完了 就要选择买商品的位置） &nbsp; 最后再注意一点&nbsp; 当a[ i ]==o的时候 我们不进行任何操作 跳过即可 因为不会获利（注意&nbsp; 也不要改变flag的状态） &nbsp; 代码 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;stdio.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+7; ll a[maxn]; int T,n; int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); //o代表当前手里买的商品的价格 //cnt代表交易次数 //flag为1代表当前手里买了商品 为0代表手里没商品 ll o,cnt=0,sum=0,flag=1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); if(i==1){ o=a[1];flag=1; } else{ if(a[i]&lt;o){ o=a[i];flag=1; } else if(a[i]&gt;o){ if(flag==1){ sum+=a[i]-o;o=a[i]; cnt+=2;flag=0; } else{ sum+=a[i]-o;o=a[i]; } } } } printf(&quot;%lld %lld\n&quot;,sum,cnt); } return 0; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" />
<link rel="canonical" href="https://mlh.app/2018/12/01/4439a02af2feff06830cc9c745533645.html" />
<meta property="og:url" content="https://mlh.app/2018/12/01/4439a02af2feff06830cc9c745533645.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：原创文章如需转载请注明出处 https://blog.csdn.net/holly_Z_P_F/article/details/84670836 &nbsp; 链接：https://ac.nowcoder.com/acm/contest/295/B 题目描述 White Cloud has built n stores numbered from 1 to n. White Rabbit wants to visit these stores in the order from 1 to n. The store numbered i has a price a[i] representing that White Rabbit can spend a[i] dollars to buy a product or sell a product to get a[i] dollars when it is in the i-th store. The product is too heavy so that White Rabbit can only take one product at the same time. White Rabbit wants to know the maximum profit after visiting all stores. Also, White Rabbit wants to know the minimum number of transactions while geting the maximum profit. Notice that White Rabbit has infinite money initially. 输入描述: The first line contains an integer T(0&lt;T&lt;=5), denoting the number of test cases. In each test case, there is one integer n(0&lt;n&lt;=100000) in the first line,denoting the number of stores. For the next line, There are n integers in range [0,2147483648), denoting a[1..n]. 输出描述: For each test case, print a single line containing 2 integers, denoting the maximum profit and the minimum number of transactions. 输入 1 5 9 10 7 6 8 输出 3 4 题目大意： 有n个商店，编号从1到n。编号为 i 的商店有一个价格 a[ i ]。 小白兔想按从1到n的顺序参观这些商店。 每到一个商店，小白兔可以在这里花费a[ i ]美元购买一种产品，或者出售一种产品以获得a[i]美元。 白兔身上只能携带一种产品。 要求的是白兔参观完所有商店后的最大利润是多少。并且希望在获取最大利润的同时，交易的数量是最少的。 ps：白兔一开始有无限的钱。 解题思路： 我们的思路 就是 当我们手里没商品的时候&nbsp; 我们需要选择一个买入商品的地方 如何选呢？ 先买下第一个商品 花费记为o&nbsp; 紧接着的第二个商品 如果说价格低于o&nbsp; 那么其实我们不应该买第一个的&nbsp; 应该从第二个开始买 所以这个时候我们做更新操作&nbsp; o的值更新为第二个 以此类推 如果接下来的还比o小 我们继续更新（此操作是在纠正买东西的位置） 当我们手里有商品的时候&nbsp; 我们需要选择一个卖出商品的地方 如何选呢？ 当我们第一次遇到大于o的值的时候&nbsp; 我们就卖掉商品 那么获利就是a[ i ] - o&nbsp;&nbsp; 交易次数累加2&nbsp; 然后我们把o更新为a[ i ] 接着走如果遇到的还大于o&nbsp; 那么说明我们刚才卖的早了&nbsp; 应该在这里卖&nbsp; 所以我们将获利 再累加上a[ i ] - o 但是不改变交易次数（这个操作是在纠正卖商品的地点&nbsp;&nbsp;&nbsp; 如何控制什么时候改变交易次数呢&nbsp;&nbsp; 就是看手中有商品没&nbsp; 手中有的时候&nbsp; 卖掉时 交易次数+2&nbsp; 然后就把flag置为0 代表手中没商品&nbsp; 接下来遇到a[ i ]再比o大 就只更新o 不改变次数 ） 以上两种情况交替使用 遍历一遍就得到了最大利润 和 最小交易次数（什么叫交替使用？&nbsp; 身上没商品的时候&nbsp; 选择买商品的位置&nbsp; 选好了&nbsp; 就要选择卖商品的位置&nbsp; 卖完了 就要选择买商品的位置） &nbsp; 最后再注意一点&nbsp; 当a[ i ]==o的时候 我们不进行任何操作 跳过即可 因为不会获利（注意&nbsp; 也不要改变flag的状态） &nbsp; 代码 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;stdio.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+7; ll a[maxn]; int T,n; int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); //o代表当前手里买的商品的价格 //cnt代表交易次数 //flag为1代表当前手里买了商品 为0代表手里没商品 ll o,cnt=0,sum=0,flag=1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); if(i==1){ o=a[1];flag=1; } else{ if(a[i]&lt;o){ o=a[i];flag=1; } else if(a[i]&gt;o){ if(flag==1){ sum+=a[i]-o;o=a[i]; cnt+=2;flag=0; } else{ sum+=a[i]-o;o=a[i]; } } } } printf(&quot;%lld %lld\\n&quot;,sum,cnt); } return 0; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2018/12/01/4439a02af2feff06830cc9c745533645.html","headline":"Money—-思维+模拟","dateModified":"2018-12-01T00:00:00+08:00","datePublished":"2018-12-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/12/01/4439a02af2feff06830cc9c745533645.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Money----思维+模拟</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：原创文章如需转载请注明出处 https://blog.csdn.net/holly_Z_P_F/article/details/84670836 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-5edb848729.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p>链接：<a href="https://ac.nowcoder.com/acm/contest/295/B" rel="nofollow">https://ac.nowcoder.com/acm/contest/295/B</a></p> 
   <h2>题目描述</h2> 
   <p>White Cloud has built n stores numbered from 1 to n.<br> White Rabbit wants to visit these stores in the order from 1 to n.<br> The store numbered i has a price a[i] representing that White Rabbit can spend a[i] dollars to buy a product or sell a product to get a[i] dollars when it is in the i-th store.<br> The product is too heavy so that White Rabbit can only take one product at the same time.<br> White Rabbit wants to know the maximum profit after visiting all stores.<br> Also, White Rabbit wants to know the minimum number of transactions while geting the maximum profit.<br> Notice that White Rabbit has infinite money initially.</p> 
   <h2>输入描述:</h2> 
   <pre>
The first line contains an integer T(0&lt;T&lt;=5), denoting the number of test cases.
In each test case, there is one integer n(0&lt;n&lt;=100000) in the first line,denoting the number of stores.
For the next line, There are n integers in range [0,2147483648), denoting a[1..n].</pre> 
   <h2>输出描述:</h2> 
   <pre>
For each test case, print a single line containing 2 integers, denoting the maximum profit and the minimum number of transactions.</pre> 
   <p>输入</p> 
   <pre>
1
5
9 10 7 6 8</pre> 
   <p>输出</p> 
   <pre>
3 4</pre> 
  </blockquote> 
  <h3>题目大意：</h3> 
  <p>有n个商店，编号从1到n。编号为 i 的商店有一个价格 a[ i ]。</p> 
  <p>小白兔想按从1到n的顺序参观这些商店。</p> 
  <p>每到一个商店，小白兔可以在这里花费a[ i ]美元购买一种产品，或者出售一种产品以获得a[i]美元。</p> 
  <p>白兔身上只能携带一种产品。</p> 
  <p>要求的是白兔参观完所有商店后的最大利润是多少。并且希望在获取最大利润的同时，交易的数量是最少的。</p> 
  <p>ps：白兔一开始有无限的钱。</p> 
  <h3>解题思路：</h3> 
  <p>我们的思路 就是</p> 
  <p><strong>当我们手里没商品的时候&nbsp; 我们需要选择一个买入商品的地方 如何选呢？</strong></p> 
  <p>先买下第一个商品 花费记为o&nbsp; 紧接着的第二个商品 如果说价格低于o&nbsp; 那么其实我们不应该买第一个的&nbsp; 应该从第二个开始买</p> 
  <p>所以这个时候我们做更新操作&nbsp; o的值更新为第二个 以此类推 如果接下来的还比o小 我们继续更新（此操作是在纠正买东西的位置）</p> 
  <p><strong>当我们手里有商品的时候&nbsp; 我们需要选择一个卖出商品的地方 如何选呢？</strong></p> 
  <p>当我们第一次遇到大于o的值的时候&nbsp; 我们就卖掉商品 那么获利就是a[ i ] - o&nbsp;&nbsp; 交易次数累加2&nbsp; 然后我们把<strong>o更新为a[ i ]</strong></p> 
  <p>接着走如果遇到的还大于o&nbsp; 那么说明我们刚才卖的早了&nbsp; 应该在这里卖&nbsp; 所以我们将获利 再累加上a[ i ] - o 但是不改变交易次数（这个操作是在纠正卖商品的地点&nbsp;&nbsp;&nbsp; 如何控制什么时候改变交易次数呢&nbsp;&nbsp; 就是看手中有商品没&nbsp; 手中有的时候&nbsp; 卖掉时 交易次数+2&nbsp; 然后就把flag置为0 代表手中没商品&nbsp; 接下来遇到a[ i ]再比o大 就只更新o 不改变次数 ）</p> 
  <p><strong>以上两种情况交替使用 遍历一遍就得到了最大利润 和 最小交易次数</strong>（什么叫交替使用？&nbsp; 身上没商品的时候&nbsp; 选择买商品的位置&nbsp; 选好了&nbsp; 就要选择卖商品的位置&nbsp; 卖完了 就要选择买商品的位置）</p> 
  <p>&nbsp;</p> 
  <p>最后再注意一点&nbsp; 当a[ i ]==o的时候 我们不进行任何操作 跳过即可 因为不会获利（注意&nbsp; 也不要改变flag的状态）</p> 
  <p>&nbsp;</p> 
  <p>代码</p> 
  <pre class="has">
<code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;
const int maxn=1e5+7;
ll a[maxn];
int T,n;
int main(){
    scanf("%d",&amp;T);
    while(T--){
        scanf("%d",&amp;n);
        //o代表当前手里买的商品的价格
        //cnt代表交易次数
        //flag为1代表当前手里买了商品 为0代表手里没商品
        ll o,cnt=0,sum=0,flag=1;
        for(int i=1;i&lt;=n;i++){
            scanf("%lld",&amp;a[i]);
            if(i==1){
                o=a[1];flag=1;
            }
            else{
                if(a[i]&lt;o){
                    o=a[i];flag=1;
                }
                else if(a[i]&gt;o){
                    if(flag==1){
                        sum+=a[i]-o;o=a[i];
                        cnt+=2;flag=0;
                    }
                    else{
                        sum+=a[i]-o;o=a[i];
                    }
                }
            }
        }
        printf("%lld %lld\n",sum,cnt);
    }
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
