<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Fabric chaincode测试 —— 开发者模式和单元测试 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Fabric chaincode测试 —— 开发者模式和单元测试" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zhayujie5200/article/details/84561825 前言 在fabric开发中，chaincode的测试是一个令人比较头疼的问题，一是由于实际情况中chaincode中的存储和查询是依赖于peer节点上的状态数据库的，所以无法在本地直接测试；二是由于chaincode是运行于容器中的，这导致我们很难获取在代码中打印的日志。 如果直接在实际开发环境中测试chaincode就很麻烦了，每一次调试都需要重启整个网络（有可能还是多机部署的），并且要创建和加入通道，安装以及实例化链码，这严重影响了测试的效率。下面介绍两种测试链码的手段，一种是开发者 (dev) 模式，在本地单机搭建一个简单的网络来进行测试；另一种是单元测试 (UT)，可以无需启动节点环境，自动化测试所有接口。 开发者模式 环境分析 使用开发者调试环境，需要先下载fabric-samples，置于$GOPATH/src下。开发者调试目录位于： fabric-samples/chaincode-docker-devmode 首先分析一下目录中的docker-compose-simple.yaml文件： 该网络中包含1个orderer节点，1个peer节点，1个chaincode容器（负责运行我们要测试的链码），1个cli容器（负责发送请求来测试链码）。 有两点需要注意的： 在cli容器的command项中可以看见，启动后会自动执行当前目录下的script.sh脚本，该脚本会自动创建名为myc的通道，并且将节点加入。所以我们只需要安装和实例化链码即可。 在chaincode容器的volumes中可以看见这样一条映射：- ./../chaincode:/opt/gopath/src/chaincode 说明fabric-samples/chaincode目录会映射到容器内部，这也是我们待测试链码需要放置的地方。为了方便管理，我们可以在该目录下为每个链码再分配一个目录，然后把要测试的链码放在其中。（当然也可以直接修改映射指向自己chaincode的实际路径）。 测试过程 这里在以最简单的sacc.go为例，该链码只涉及到简单的存储（set）和查询（get）功能。整个过程需要启动三个终端： 终端一：启动网络 首先进入开发者模式目录： cd fabric-samples/chaincode-docker-devmode 启动网络： docker-compose -f docker-compose-simple.yaml up 当看到Going to wait for newer blocks时表示启动成功，此时网络中存在四个容器（1 orderer，1 peer， 1 chaincode， 1 cli），创建了通道myc并将peer成功加入。 终端二：编译链码 进入chaincode容器 docker exec -it chaincode bash 编译想要测试的chaincode： cd sacc go build 成功执行后单当前目录下会出现生成的可执行文件。此时需要启动这个可执行文件： CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc 注：这里有个不解的小问题，官网教程中的端口是peer:7051，并且当前peer确实也在监听7051，但是写成7051就会报错：Error starting SimpleAsset chaincode: error sending chaincode REGISTER。 当出现starting up ...的提示就说明链码启动成功了，在这个终端二里可以输出chaincode中的日志（比如通过fmt.Print()打印的内容）。 终端三：在cli中测试链码 进入cli容器： docker exec -it cli bash 安装和实例化链码（实例化设置了a的初始值10）： peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 进行测试： 调用set()接口将a的值设置为20: peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 调用get()接口查询a的值，发现a的值已经更新为20，测试完毕。 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39; -C myc 在开发者环境中加入couchdb 如果实际开发的链码中使用了couchdb提供的富查询，则需要在测试环境中加入couchdb容器。 只需要对docker-compose-simple.yaml文件进行修改即可: 首先在文件中添加couchdb段的配置： couchdb: container_name: couchdb image: hyperledger/fabric-couchdb environment: - COUCHDB_USER= - COUCHDB_PASSWORD= ports: - 5984:5984 networks: - default 在peer的environment部分添加： environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME= - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD= 在peer的depends_on部分添加： depends_on: - couchdb 执行docker-compose命令后就可以启动couchdb容器，同时在浏览器中输入地址http://localhost:5984/_utils还可以进入couchdb的web端管理界面，更清晰的看到存入的数据，从而方便配合我们进行测试。 单元测试 单元测试 (UT) 可以提高调试的效率和我们代码的质量。fabric中提供了一个MockStub类用于单元测试。 单元测试 单元测试不需要启动任何网络节点，通过我们的测试文件就可以在本地对链码中的接口进行调用测试。 其原理就是在MockStub类中维护一个map[string][]byte来模拟key-val的状态数据库，链码调用的PutStat() 和 GetStat() 其实是作用于内存中的map。 MockStub主要提供两个函数来模拟背书节点对链码的调用：MockInit()和MockInvoke()，分别调用Init和Invoke接口。接收的参数均为类型为string的uuid（随便设置即可），以及一个二维byte数组（用于测试的提供参数）。 单元测试的要求： 1.需要导入testing包 2.单元测试文件以_test.go结尾 3.测试用例的函数必须以Test开头 单元测试的例子 下面是对sacc.go的单元测试例子，由于该代码较简单，这里就将几个接口的测试写在一个case里。创建sacc_test.go文件，测试用例如下： func TestFunc(t *testing.T) { cc := new(SimpleAsset) // 创建Chaincode对象 stub := shim.NewMockStub(&quot;sacc&quot;, cc) // 创建MockStub对象 // 调用Init接口，将a的值设为90 stub.MockInit(&quot;1&quot;, [][]byte{[]byte(&quot;a&quot;), []byte(&quot;90&quot;)}) // 调用get接口查询a的值 res := stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The value of a is&quot;, string(res.Payload)) // 调用set接口设置a为100 stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) // 再次查询a的值 res = stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The new value of a is&quot;, string(res.Payload)) } 在当前目录执行go test，输出结果如下 还可以查看更详细的测试结果，如覆盖率： go test -cover -covermode count -coverprofile ./cover.out 输出结果，可以看见覆盖率为68.8%，覆盖率越高说明测试用例写的越完整。 进一步执行以下命令可以将刚刚生成的cover.out文件转化为html页面在浏览器中更具体的看见测试的覆盖程度。 go tool cover -html=./cover.out 实际测试的时候对每个接口都应该有不止一个case，需要考虑到反例或其他边界条件，还可以在测试时将预期得到的结果与实际得到的结果进行比较，如果不一致就报错使用例不显示PASS。 性能测试 性能测试的函数必须以Benchmark开头，接收的参数类型为*testing.B。这里我将一次存储和查询合并为一次操作(operation)来进行测试，代码如下： func BenchmarkFunc(b *testing.B) { cc := new(SimpleAsset) stub := shim.NewMockStub(&quot;sacc&quot;, cc) for i :=0 ; i&lt; b.N; i++ { stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) } } 循环的次数为 b.N，并且每次测试时整个函数会被执行三次，N的数量会不断增加，如100, 10k, 300k。 执行测试： go test --benchmem -bench=. 测试结果如图，ns/op 指的是平均每次操作花费的纳秒数，B/op指平均每次操作占用的内存大小。 由于实际情况下chaincode的接口是面向状态数据库的，而这里是用内存的读写来模拟的，所以这里的性能测试显得意义不是很大，但是如果链码中存在一些比较耗时的计算等操作，还是可以性能测试一下的。 小结 使用开发者 (dev) 模式进行测试： 好处是网络规模简单，可以在终端中直接看到链码打印的日志，使用cli命令行容器测试也比较方便（可以写成测试脚本映射到cli容器中自动执行）。 不足之处为每次修改链码后还是需要重新启动整个网络，再次编译、安装和实例化链码，不过这些操作都可以写成一个脚本一键完成。 使用单元测试： 好处是不需要启动网络环境，一条简单的命令就可以在本地自动化执行，且可以帮助我们很规范地对接口进行完整的测试。 不足之处是目前还无法测试基于couchDB的富查询操作。" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zhayujie5200/article/details/84561825 前言 在fabric开发中，chaincode的测试是一个令人比较头疼的问题，一是由于实际情况中chaincode中的存储和查询是依赖于peer节点上的状态数据库的，所以无法在本地直接测试；二是由于chaincode是运行于容器中的，这导致我们很难获取在代码中打印的日志。 如果直接在实际开发环境中测试chaincode就很麻烦了，每一次调试都需要重启整个网络（有可能还是多机部署的），并且要创建和加入通道，安装以及实例化链码，这严重影响了测试的效率。下面介绍两种测试链码的手段，一种是开发者 (dev) 模式，在本地单机搭建一个简单的网络来进行测试；另一种是单元测试 (UT)，可以无需启动节点环境，自动化测试所有接口。 开发者模式 环境分析 使用开发者调试环境，需要先下载fabric-samples，置于$GOPATH/src下。开发者调试目录位于： fabric-samples/chaincode-docker-devmode 首先分析一下目录中的docker-compose-simple.yaml文件： 该网络中包含1个orderer节点，1个peer节点，1个chaincode容器（负责运行我们要测试的链码），1个cli容器（负责发送请求来测试链码）。 有两点需要注意的： 在cli容器的command项中可以看见，启动后会自动执行当前目录下的script.sh脚本，该脚本会自动创建名为myc的通道，并且将节点加入。所以我们只需要安装和实例化链码即可。 在chaincode容器的volumes中可以看见这样一条映射：- ./../chaincode:/opt/gopath/src/chaincode 说明fabric-samples/chaincode目录会映射到容器内部，这也是我们待测试链码需要放置的地方。为了方便管理，我们可以在该目录下为每个链码再分配一个目录，然后把要测试的链码放在其中。（当然也可以直接修改映射指向自己chaincode的实际路径）。 测试过程 这里在以最简单的sacc.go为例，该链码只涉及到简单的存储（set）和查询（get）功能。整个过程需要启动三个终端： 终端一：启动网络 首先进入开发者模式目录： cd fabric-samples/chaincode-docker-devmode 启动网络： docker-compose -f docker-compose-simple.yaml up 当看到Going to wait for newer blocks时表示启动成功，此时网络中存在四个容器（1 orderer，1 peer， 1 chaincode， 1 cli），创建了通道myc并将peer成功加入。 终端二：编译链码 进入chaincode容器 docker exec -it chaincode bash 编译想要测试的chaincode： cd sacc go build 成功执行后单当前目录下会出现生成的可执行文件。此时需要启动这个可执行文件： CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc 注：这里有个不解的小问题，官网教程中的端口是peer:7051，并且当前peer确实也在监听7051，但是写成7051就会报错：Error starting SimpleAsset chaincode: error sending chaincode REGISTER。 当出现starting up ...的提示就说明链码启动成功了，在这个终端二里可以输出chaincode中的日志（比如通过fmt.Print()打印的内容）。 终端三：在cli中测试链码 进入cli容器： docker exec -it cli bash 安装和实例化链码（实例化设置了a的初始值10）： peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 进行测试： 调用set()接口将a的值设置为20: peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 调用get()接口查询a的值，发现a的值已经更新为20，测试完毕。 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39; -C myc 在开发者环境中加入couchdb 如果实际开发的链码中使用了couchdb提供的富查询，则需要在测试环境中加入couchdb容器。 只需要对docker-compose-simple.yaml文件进行修改即可: 首先在文件中添加couchdb段的配置： couchdb: container_name: couchdb image: hyperledger/fabric-couchdb environment: - COUCHDB_USER= - COUCHDB_PASSWORD= ports: - 5984:5984 networks: - default 在peer的environment部分添加： environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME= - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD= 在peer的depends_on部分添加： depends_on: - couchdb 执行docker-compose命令后就可以启动couchdb容器，同时在浏览器中输入地址http://localhost:5984/_utils还可以进入couchdb的web端管理界面，更清晰的看到存入的数据，从而方便配合我们进行测试。 单元测试 单元测试 (UT) 可以提高调试的效率和我们代码的质量。fabric中提供了一个MockStub类用于单元测试。 单元测试 单元测试不需要启动任何网络节点，通过我们的测试文件就可以在本地对链码中的接口进行调用测试。 其原理就是在MockStub类中维护一个map[string][]byte来模拟key-val的状态数据库，链码调用的PutStat() 和 GetStat() 其实是作用于内存中的map。 MockStub主要提供两个函数来模拟背书节点对链码的调用：MockInit()和MockInvoke()，分别调用Init和Invoke接口。接收的参数均为类型为string的uuid（随便设置即可），以及一个二维byte数组（用于测试的提供参数）。 单元测试的要求： 1.需要导入testing包 2.单元测试文件以_test.go结尾 3.测试用例的函数必须以Test开头 单元测试的例子 下面是对sacc.go的单元测试例子，由于该代码较简单，这里就将几个接口的测试写在一个case里。创建sacc_test.go文件，测试用例如下： func TestFunc(t *testing.T) { cc := new(SimpleAsset) // 创建Chaincode对象 stub := shim.NewMockStub(&quot;sacc&quot;, cc) // 创建MockStub对象 // 调用Init接口，将a的值设为90 stub.MockInit(&quot;1&quot;, [][]byte{[]byte(&quot;a&quot;), []byte(&quot;90&quot;)}) // 调用get接口查询a的值 res := stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The value of a is&quot;, string(res.Payload)) // 调用set接口设置a为100 stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) // 再次查询a的值 res = stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The new value of a is&quot;, string(res.Payload)) } 在当前目录执行go test，输出结果如下 还可以查看更详细的测试结果，如覆盖率： go test -cover -covermode count -coverprofile ./cover.out 输出结果，可以看见覆盖率为68.8%，覆盖率越高说明测试用例写的越完整。 进一步执行以下命令可以将刚刚生成的cover.out文件转化为html页面在浏览器中更具体的看见测试的覆盖程度。 go tool cover -html=./cover.out 实际测试的时候对每个接口都应该有不止一个case，需要考虑到反例或其他边界条件，还可以在测试时将预期得到的结果与实际得到的结果进行比较，如果不一致就报错使用例不显示PASS。 性能测试 性能测试的函数必须以Benchmark开头，接收的参数类型为*testing.B。这里我将一次存储和查询合并为一次操作(operation)来进行测试，代码如下： func BenchmarkFunc(b *testing.B) { cc := new(SimpleAsset) stub := shim.NewMockStub(&quot;sacc&quot;, cc) for i :=0 ; i&lt; b.N; i++ { stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) } } 循环的次数为 b.N，并且每次测试时整个函数会被执行三次，N的数量会不断增加，如100, 10k, 300k。 执行测试： go test --benchmem -bench=. 测试结果如图，ns/op 指的是平均每次操作花费的纳秒数，B/op指平均每次操作占用的内存大小。 由于实际情况下chaincode的接口是面向状态数据库的，而这里是用内存的读写来模拟的，所以这里的性能测试显得意义不是很大，但是如果链码中存在一些比较耗时的计算等操作，还是可以性能测试一下的。 小结 使用开发者 (dev) 模式进行测试： 好处是网络规模简单，可以在终端中直接看到链码打印的日志，使用cli命令行容器测试也比较方便（可以写成测试脚本映射到cli容器中自动执行）。 不足之处为每次修改链码后还是需要重新启动整个网络，再次编译、安装和实例化链码，不过这些操作都可以写成一个脚本一键完成。 使用单元测试： 好处是不需要启动网络环境，一条简单的命令就可以在本地自动化执行，且可以帮助我们很规范地对接口进行完整的测试。 不足之处是目前还无法测试基于couchDB的富查询操作。" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zhayujie5200/article/details/84561825 前言 在fabric开发中，chaincode的测试是一个令人比较头疼的问题，一是由于实际情况中chaincode中的存储和查询是依赖于peer节点上的状态数据库的，所以无法在本地直接测试；二是由于chaincode是运行于容器中的，这导致我们很难获取在代码中打印的日志。 如果直接在实际开发环境中测试chaincode就很麻烦了，每一次调试都需要重启整个网络（有可能还是多机部署的），并且要创建和加入通道，安装以及实例化链码，这严重影响了测试的效率。下面介绍两种测试链码的手段，一种是开发者 (dev) 模式，在本地单机搭建一个简单的网络来进行测试；另一种是单元测试 (UT)，可以无需启动节点环境，自动化测试所有接口。 开发者模式 环境分析 使用开发者调试环境，需要先下载fabric-samples，置于$GOPATH/src下。开发者调试目录位于： fabric-samples/chaincode-docker-devmode 首先分析一下目录中的docker-compose-simple.yaml文件： 该网络中包含1个orderer节点，1个peer节点，1个chaincode容器（负责运行我们要测试的链码），1个cli容器（负责发送请求来测试链码）。 有两点需要注意的： 在cli容器的command项中可以看见，启动后会自动执行当前目录下的script.sh脚本，该脚本会自动创建名为myc的通道，并且将节点加入。所以我们只需要安装和实例化链码即可。 在chaincode容器的volumes中可以看见这样一条映射：- ./../chaincode:/opt/gopath/src/chaincode 说明fabric-samples/chaincode目录会映射到容器内部，这也是我们待测试链码需要放置的地方。为了方便管理，我们可以在该目录下为每个链码再分配一个目录，然后把要测试的链码放在其中。（当然也可以直接修改映射指向自己chaincode的实际路径）。 测试过程 这里在以最简单的sacc.go为例，该链码只涉及到简单的存储（set）和查询（get）功能。整个过程需要启动三个终端： 终端一：启动网络 首先进入开发者模式目录： cd fabric-samples/chaincode-docker-devmode 启动网络： docker-compose -f docker-compose-simple.yaml up 当看到Going to wait for newer blocks时表示启动成功，此时网络中存在四个容器（1 orderer，1 peer， 1 chaincode， 1 cli），创建了通道myc并将peer成功加入。 终端二：编译链码 进入chaincode容器 docker exec -it chaincode bash 编译想要测试的chaincode： cd sacc go build 成功执行后单当前目录下会出现生成的可执行文件。此时需要启动这个可执行文件： CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc 注：这里有个不解的小问题，官网教程中的端口是peer:7051，并且当前peer确实也在监听7051，但是写成7051就会报错：Error starting SimpleAsset chaincode: error sending chaincode REGISTER。 当出现starting up ...的提示就说明链码启动成功了，在这个终端二里可以输出chaincode中的日志（比如通过fmt.Print()打印的内容）。 终端三：在cli中测试链码 进入cli容器： docker exec -it cli bash 安装和实例化链码（实例化设置了a的初始值10）： peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0 peer chaincode instantiate -n mycc -v 0 -c &#39;{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}&#39; -C myc 进行测试： 调用set()接口将a的值设置为20: peer chaincode invoke -n mycc -c &#39;{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}&#39; -C myc 调用get()接口查询a的值，发现a的值已经更新为20，测试完毕。 peer chaincode query -n mycc -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39; -C myc 在开发者环境中加入couchdb 如果实际开发的链码中使用了couchdb提供的富查询，则需要在测试环境中加入couchdb容器。 只需要对docker-compose-simple.yaml文件进行修改即可: 首先在文件中添加couchdb段的配置： couchdb: container_name: couchdb image: hyperledger/fabric-couchdb environment: - COUCHDB_USER= - COUCHDB_PASSWORD= ports: - 5984:5984 networks: - default 在peer的environment部分添加： environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME= - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD= 在peer的depends_on部分添加： depends_on: - couchdb 执行docker-compose命令后就可以启动couchdb容器，同时在浏览器中输入地址http://localhost:5984/_utils还可以进入couchdb的web端管理界面，更清晰的看到存入的数据，从而方便配合我们进行测试。 单元测试 单元测试 (UT) 可以提高调试的效率和我们代码的质量。fabric中提供了一个MockStub类用于单元测试。 单元测试 单元测试不需要启动任何网络节点，通过我们的测试文件就可以在本地对链码中的接口进行调用测试。 其原理就是在MockStub类中维护一个map[string][]byte来模拟key-val的状态数据库，链码调用的PutStat() 和 GetStat() 其实是作用于内存中的map。 MockStub主要提供两个函数来模拟背书节点对链码的调用：MockInit()和MockInvoke()，分别调用Init和Invoke接口。接收的参数均为类型为string的uuid（随便设置即可），以及一个二维byte数组（用于测试的提供参数）。 单元测试的要求： 1.需要导入testing包 2.单元测试文件以_test.go结尾 3.测试用例的函数必须以Test开头 单元测试的例子 下面是对sacc.go的单元测试例子，由于该代码较简单，这里就将几个接口的测试写在一个case里。创建sacc_test.go文件，测试用例如下： func TestFunc(t *testing.T) { cc := new(SimpleAsset) // 创建Chaincode对象 stub := shim.NewMockStub(&quot;sacc&quot;, cc) // 创建MockStub对象 // 调用Init接口，将a的值设为90 stub.MockInit(&quot;1&quot;, [][]byte{[]byte(&quot;a&quot;), []byte(&quot;90&quot;)}) // 调用get接口查询a的值 res := stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The value of a is&quot;, string(res.Payload)) // 调用set接口设置a为100 stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) // 再次查询a的值 res = stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) fmt.Println(&quot;The new value of a is&quot;, string(res.Payload)) } 在当前目录执行go test，输出结果如下 还可以查看更详细的测试结果，如覆盖率： go test -cover -covermode count -coverprofile ./cover.out 输出结果，可以看见覆盖率为68.8%，覆盖率越高说明测试用例写的越完整。 进一步执行以下命令可以将刚刚生成的cover.out文件转化为html页面在浏览器中更具体的看见测试的覆盖程度。 go tool cover -html=./cover.out 实际测试的时候对每个接口都应该有不止一个case，需要考虑到反例或其他边界条件，还可以在测试时将预期得到的结果与实际得到的结果进行比较，如果不一致就报错使用例不显示PASS。 性能测试 性能测试的函数必须以Benchmark开头，接收的参数类型为*testing.B。这里我将一次存储和查询合并为一次操作(operation)来进行测试，代码如下： func BenchmarkFunc(b *testing.B) { cc := new(SimpleAsset) stub := shim.NewMockStub(&quot;sacc&quot;, cc) for i :=0 ; i&lt; b.N; i++ { stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;set&quot;), []byte(&quot;a&quot;), []byte(&quot;100&quot;)}) stub.MockInvoke(&quot;1&quot;, [][]byte{[]byte(&quot;get&quot;), []byte(&quot;a&quot;)}) } } 循环的次数为 b.N，并且每次测试时整个函数会被执行三次，N的数量会不断增加，如100, 10k, 300k。 执行测试： go test --benchmem -bench=. 测试结果如图，ns/op 指的是平均每次操作花费的纳秒数，B/op指平均每次操作占用的内存大小。 由于实际情况下chaincode的接口是面向状态数据库的，而这里是用内存的读写来模拟的，所以这里的性能测试显得意义不是很大，但是如果链码中存在一些比较耗时的计算等操作，还是可以性能测试一下的。 小结 使用开发者 (dev) 模式进行测试： 好处是网络规模简单，可以在终端中直接看到链码打印的日志，使用cli命令行容器测试也比较方便（可以写成测试脚本映射到cli容器中自动执行）。 不足之处为每次修改链码后还是需要重新启动整个网络，再次编译、安装和实例化链码，不过这些操作都可以写成一个脚本一键完成。 使用单元测试： 好处是不需要启动网络环境，一条简单的命令就可以在本地自动化执行，且可以帮助我们很规范地对接口进行完整的测试。 不足之处是目前还无法测试基于couchDB的富查询操作。","@type":"BlogPosting","url":"/2018/12/01/07537eb9ab3caf12bb484707e6c95d67.html","headline":"Fabric chaincode测试 —— 开发者模式和单元测试","dateModified":"2018-12-01T00:00:00+08:00","datePublished":"2018-12-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/12/01/07537eb9ab3caf12bb484707e6c95d67.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Fabric chaincode测试 —— 开发者模式和单元测试</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zhayujie5200/article/details/84561825 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="_0"></a>前言</h1> 
  <p>在fabric开发中，chaincode的测试是一个令人比较头疼的问题，一是由于实际情况中chaincode中的存储和查询是依赖于peer节点上的状态数据库的，所以无法在本地直接测试；二是由于chaincode是运行于容器中的，这导致我们很难获取在代码中打印的日志。</p> 
  <p>如果直接在实际开发环境中测试chaincode就很麻烦了，每一次调试都需要重启整个网络（有可能还是多机部署的），并且要创建和加入通道，安装以及实例化链码，这严重影响了测试的效率。下面介绍两种测试链码的手段，一种是开发者 (dev) 模式，在本地单机搭建一个简单的网络来进行测试；另一种是单元测试 (UT)，可以无需启动节点环境，自动化测试所有接口。</p> 
  <h1><a id="_5"></a>开发者模式</h1> 
  <h4><a id="_7"></a>环境分析</h4> 
  <p>使用开发者调试环境，需要先下载<code>fabric-samples</code>，置于<code>$GOPATH/src</code>下。开发者调试目录位于：</p> 
  <pre><code class="prism language-shell">fabric-samples/chaincode-docker-devmode
</code></pre> 
  <p><strong>首先分析一下目录中的<code>docker-compose-simple.yaml</code>文件：</strong><br> 该网络中包含1个orderer节点，1个peer节点，1个chaincode容器（负责运行我们要测试的链码），1个cli容器（负责发送请求来测试链码）。</p> 
  <p><strong>有两点需要注意的：</strong></p> 
  <ul> 
   <li>在cli容器的<code>command</code>项中可以看见，启动后会自动执行当前目录下的<code>script.sh</code>脚本，该脚本会自动创建名为<code>myc</code>的通道，并且将节点加入。所以我们只需要安装和实例化链码即可。</li> 
   <li>在chaincode容器的<code>volumes</code>中可以看见这样一条映射：<pre><code class="prism language-yaml"><span class="token punctuation">-</span> ./../chaincode<span class="token punctuation">:</span>/opt/gopath/src/chaincode
</code></pre> 说明<code>fabric-samples/chaincode</code>目录会映射到容器内部，这也是我们待测试链码需要放置的地方。为了方便管理，我们可以在该目录下为每个链码再分配一个目录，然后把要测试的链码放在其中。（当然也可以直接修改映射指向自己chaincode的实际路径）。</li> 
  </ul> 
  <h4><a id="_23"></a>测试过程</h4> 
  <p>这里在以最简单的<code>sacc.go</code>为例，该链码只涉及到简单的存储（set）和查询（get）功能。整个过程需要启动三个终端：</p> 
  <p><strong>终端一：启动网络</strong><br> 首先进入开发者模式目录：</p> 
  <pre><code class="prism language-shell"><span class="token function">cd</span> fabric-samples/chaincode-docker-devmode
</code></pre> 
  <p>启动网络：</p> 
  <pre><code class="prism language-shell">docker-compose -f docker-compose-simple.yaml up
</code></pre> 
  <p>当看到<code>Going to wait for newer blocks</code>时表示启动成功，此时网络中存在四个容器（1 orderer，1 peer， 1 chaincode， 1 cli），创建了通道myc并将peer成功加入。</p> 
  <p><strong>终端二：编译链码</strong><br> 进入chaincode容器</p> 
  <pre><code class="prism language-shell">docker <span class="token function">exec</span> -it chaincode <span class="token function">bash</span>
</code></pre> 
  <p>编译想要测试的chaincode：</p> 
  <pre><code class="prism language-shell"><span class="token function">cd</span> sacc
go build
</code></pre> 
  <p>成功执行后单当前目录下会出现生成的可执行文件。此时需要启动这个可执行文件：</p> 
  <pre><code class="prism language-shell">CORE_PEER_ADDRESS<span class="token operator">=</span>peer:7052 CORE_CHAINCODE_ID_NAME<span class="token operator">=</span>mycc:0 ./sacc
</code></pre> 
  <p>注：这里有个不解的小问题，官网教程中的端口是peer:7051，并且当前peer确实也在监听7051，但是写成7051就会报错：<code>Error starting SimpleAsset chaincode: error sending chaincode REGISTER</code>。</p> 
  <p>当出现<code>starting up ...</code>的提示就说明链码启动成功了，在这个终端二里可以输出chaincode中的日志（比如通过<code>fmt.Print()</code>打印的内容）。</p> 
  <p><strong>终端三：在cli中测试链码</strong><br> 进入cli容器：</p> 
  <pre><code class="prism language-shell">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>
</code></pre> 
  <p>安装和实例化链码（实例化设置了a的初始值10）：</p> 
  <pre><code class="prism language-shell">peer chaincode <span class="token function">install</span> -p chaincodedev/chaincode/sacc -n mycc -v 0
peer chaincode instantiate -n mycc -v 0 -c <span class="token string">'{"Args":["a","10"]}'</span> -C myc
</code></pre> 
  <p><strong>进行测试：</strong><br> 调用set()接口将a的值设置为20:</p> 
  <pre><code class="prism language-shell">peer chaincode invoke -n mycc -c <span class="token string">'{"Args":["set", "a", "20"]}'</span> -C myc
</code></pre> 
  <p>调用get()接口查询a的值，发现a的值已经更新为20，测试完毕。</p> 
  <pre><code class="prism language-shell">peer chaincode query -n mycc -c <span class="token string">'{"Args":["get","a"]}'</span> -C myc
</code></pre> 
  <p><strong>在开发者环境中加入couchdb</strong><br> 如果实际开发的链码中使用了couchdb提供的富查询，则需要在测试环境中加入couchdb容器。</p> 
  <p>只需要对<code>docker-compose-simple.yaml</code>文件进行修改即可:<br> 首先在文件中添加couchdb段的配置：</p> 
  <pre><code class="prism language-yaml"><span class="token key atrule">couchdb</span><span class="token punctuation">:</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> couchdb
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hyperledger/fabric<span class="token punctuation">-</span>couchdb
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> COUCHDB_USER=
      <span class="token punctuation">-</span> COUCHDB_PASSWORD=
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 5984<span class="token punctuation">:</span><span class="token number">5984</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> default
</code></pre> 
  <p>在peer的environment部分添加：</p> 
  <pre><code class="prism language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> CORE_LEDGER_STATE_STATEDATABASE=CouchDB
	<span class="token punctuation">-</span> CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb<span class="token punctuation">:</span><span class="token number">5984</span>
	<span class="token punctuation">-</span> CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=
	<span class="token punctuation">-</span> CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=
</code></pre> 
  <p>在peer的depends_on部分添加：</p> 
  <pre><code class="prism language-yaml"><span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> couchdb
</code></pre> 
  <p>执行docker-compose命令后就可以启动couchdb容器，同时在浏览器中输入地址<a href="http://localhost:5984/_utils" rel="nofollow">http://localhost:5984/_utils</a>还可以进入couchdb的web端管理界面，更清晰的看到存入的数据，从而方便配合我们进行测试。</p> 
  <h1><a id="_111"></a>单元测试</h1> 
  <p>单元测试 (UT) 可以提高调试的效率和我们代码的质量。fabric中提供了一个<code>MockStub</code>类用于单元测试。</p> 
  <h4><a id="_114"></a>单元测试</h4> 
  <p>单元测试不需要启动任何网络节点，通过我们的测试文件就可以在本地对链码中的接口进行调用测试。</p> 
  <p>其原理就是在<code>MockStub</code>类中维护一个<code>map[string][]byte</code>来模拟key-val的状态数据库，链码调用的<code>PutStat()</code> 和 <code>GetStat()</code> 其实是作用于内存中的map。</p> 
  <p><code>MockStub</code>主要提供两个函数来模拟背书节点对链码的调用：<code>MockInit()</code>和<code>MockInvoke()</code>，分别调用<code>Init</code>和<code>Invoke</code>接口。接收的参数均为类型为string的uuid（随便设置即可），以及一个二维byte数组（用于测试的提供参数）。</p> 
  <p><strong>单元测试的要求：</strong><br> 1.需要导入<code>testing</code>包<br> 2.单元测试文件以<code>_test.go</code>结尾<br> 3.测试用例的函数必须以<code>Test</code>开头</p> 
  <p><strong>单元测试的例子</strong><br> 下面是对sacc.go的单元测试例子，由于该代码较简单，这里就将几个接口的测试写在一个case里。创建<code>sacc_test.go</code>文件，测试用例如下：</p> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cc <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>SimpleAsset<span class="token punctuation">)</span>          				<span class="token comment">// 创建Chaincode对象</span>
    stub <span class="token operator">:=</span> shim<span class="token punctuation">.</span><span class="token function">NewMockStub</span><span class="token punctuation">(</span><span class="token string">"sacc"</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span>			<span class="token comment">// 创建MockStub对象</span>
    <span class="token comment">// 调用Init接口，将a的值设为90</span>
    stub<span class="token punctuation">.</span><span class="token function">MockInit</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"90"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用get接口查询a的值</span>
    res <span class="token operator">:=</span> stub<span class="token punctuation">.</span><span class="token function">MockInvoke</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"The value of a is"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Payload<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用set接口设置a为100</span>
    stub<span class="token punctuation">.</span><span class="token function">MockInvoke</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"set"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"100"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 再次查询a的值</span>
    res <span class="token operator">=</span> stub<span class="token punctuation">.</span><span class="token function">MockInvoke</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"The new value of a is"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Payload<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>在当前目录执行<code>go test</code>，输出结果如下<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20181201152729558.png" alt="在这里插入图片描述"></p> 
  <p>还可以查看更详细的测试结果，如覆盖率：</p> 
  <pre><code class="prism language-shell">go <span class="token function">test</span> -cover -covermode count -coverprofile ./cover.out
</code></pre> 
  <p>输出结果，可以看见覆盖率为68.8%，覆盖率越高说明测试用例写的越完整。<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20181201193547460.png" alt="在这里插入图片描述"></p> 
  <p>进一步执行以下命令可以将刚刚生成的cover.out文件转化为html页面在浏览器中更具体的看见测试的覆盖程度。</p> 
  <pre><code class="prism language-shell">go tool cover -html<span class="token operator">=</span>./cover.out
</code></pre> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20181201150338163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYXl1amllNTIwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p>实际测试的时候对每个接口都应该有不止一个case，需要考虑到反例或其他边界条件，还可以在测试时将预期得到的结果与实际得到的结果进行比较，如果不一致就报错使用例不显示PASS。</p> 
  <h4><a id="_163"></a>性能测试</h4> 
  <p>性能测试的函数必须以Benchmark开头，接收的参数类型为<code>*testing.B</code>。这里我将一次存储和查询合并为一次操作(operation)来进行测试，代码如下：</p> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkFunc</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cc <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>SimpleAsset<span class="token punctuation">)</span>
    stub <span class="token operator">:=</span> shim<span class="token punctuation">.</span><span class="token function">NewMockStub</span><span class="token punctuation">(</span><span class="token string">"sacc"</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        stub<span class="token punctuation">.</span><span class="token function">MockInvoke</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"set"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"100"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        stub<span class="token punctuation">.</span><span class="token function">MockInvoke</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>循环的次数为 b.N，并且每次测试时整个函数会被执行三次，N的数量会不断增加，如100, 10k, 300k。</p> 
  <p>执行测试：</p> 
  <pre><code class="prism language-shell">go <span class="token function">test</span> --benchmem -bench<span class="token operator">=</span>.
</code></pre> 
  <p>测试结果如图，ns/op 指的是平均每次操作花费的纳秒数，B/op指平均每次操作占用的内存大小。<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20181201200359216.png" alt="在这里插入图片描述"><br> 由于实际情况下chaincode的接口是面向状态数据库的，而这里是用内存的读写来模拟的，所以这里的性能测试显得意义不是很大，但是如果链码中存在一些比较耗时的计算等操作，还是可以性能测试一下的。</p> 
  <h2><a id="_185"></a>小结</h2> 
  <p><strong>使用开发者 (dev) 模式进行测试：</strong></p> 
  <ul> 
   <li>好处是网络规模简单，可以在终端中直接看到链码打印的日志，使用cli命令行容器测试也比较方便（可以写成测试脚本映射到cli容器中自动执行）。</li> 
   <li>不足之处为每次修改链码后还是需要重新启动整个网络，再次编译、安装和实例化链码，不过这些操作都可以写成一个脚本一键完成。</li> 
  </ul> 
  <p><strong>使用单元测试：</strong></p> 
  <ul> 
   <li>好处是不需要启动网络环境，一条简单的命令就可以在本地自动化执行，且可以帮助我们很规范地对接口进行完整的测试。</li> 
   <li>不足之处是目前还无法测试基于couchDB的富查询操作。</li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
